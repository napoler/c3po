using system _ i _ compression ; using system _ text ; namespace shadowsocks _ controller { public class file _ manager { public static bool byte _ array _ to _ file ( string file _ name , byte [ ] content ) { try {
connection . begin _ receive ( connetion _ recv _ buffer , 2 , recv _ size - 2 , socket _ flags . none , on _ address _ fully _ read , new object [ ] { bytes _ remain , on _ success } ) ; } private void on _ address _ fully _ read ( i _ async _ result ar ) { if ( closed ) return ; try { int bytes _ read = connection . end _ receive ( ar ) ;
} private void on _ address _ fully _ read ( i _ async _ result ar ) { if ( closed ) return ; try { int bytes _ read = connection . end _ receive ( ar ) ; var states = ( object [ ] ) ar . async _ state ; int bytes _ remain = ( int ) states [ 0 ] ;
break ; default : throw new not _ supported _ exception ( STR ) ; } proxy _ ep = socket _ util . get _ end _ point ( config . proxy . proxy _ server , config . proxy . proxy _ port ) ; } else { remote = new direct _ connect ( ) ; }
remote . begin _ connect _ proxy ( proxy _ ep , proxy _ connect _ callback , new async _ session < proxy _ timer > ( remote , proxy _ timer ) ) ; } catch ( exception e ) { logger . log _ useful _ exception ( e ) ; close ( ) ; } } private void proxy _ connect _ timer _ elapsed ( object sender , elapsed _ event _ args e ) {
close ( ) ; } private void proxy _ connect _ callback ( i _ async _ result ar ) { if ( closed ) { return ; } try {
catch ( argument _ exception ) { } catch ( exception e ) { logger . log _ useful _ exception ( e ) ; close ( ) ; } } private void dest _ connect _ timer _ elapsed ( object sender , elapsed _ event _ args e ) {
} var session = timer . session ; server server = timer . server ; i _ strategy strategy = controller . get _ current _ strategy ( ) ; strategy ? . set _ failure ( server ) ; logger . info ( $ STR ) ; session . remote . close ( ) ; close ( ) ; } private void connect _ callback ( i _ async _ result ar ) {
logger . trace ( $ STR ) ; send _ to _ server ( first _ packet _ length , session ) ; } catch ( exception e ) { logger . log _ useful _ exception ( e ) ; close ( ) ; } } private void pipe _ remote _ receive _ callback ( i _ async _ result ar ) {
} private void retry _ connect ( ) { if ( retry _ count < max _ retry ) { logging . debug ( $ STR ) ; start _ connect ( ) ; retry _ count + + ; } else
public void start ( configuration configuration ) { if ( process = = null ) { process [ ] existing _ privoxy = process . get _ processes _ by _ name ( STR ) ; foreach ( process p in existing _ privoxy . where ( is _ child _ process ) ) { kill _ process ( p ) ; } string privoxy _ config = resources . privoxy _ conf ;
throw new argument _ exception ( n . get _ string ( STR ) ) ; } public static void check _ local _ port ( int port ) { check _ port ( port ) ; if ( port = = NUM ) throw new argument _ exception ( n . get _ string ( STR ) ) ; } private static void check _ password ( string password ) {
if ( port = = NUM ) throw new argument _ exception ( n . get _ string ( STR ) ) ; } private static void check _ password ( string password ) { if ( string . is _ null _ or _ empty ( password ) ) throw new argument _ exception ( n . get _ string ( STR ) ) ; } private static void check _ server ( string server ) {
{ return server . get _ hash _ code ( ) ^ server _ port ; } public override bool equals ( object obj ) { server = ( server ) obj ; return server = = . server & & server _ port = = . server _ port ; } public string friendly _ name ( ) {
{ server = ( server ) obj ; return server = = . server & & server _ port = = . server _ port ; } public string friendly _ name ( ) { if ( string . is _ null _ or _ empty ( server ) ) { return n . get _ string ( STR ) ; }

if ( string . is _ null _ or _ empty ( controller . get _ configuration _ copy ( ) . pac _ url ) ) { update _ online _ pacurl _ item _ click ( sender , e ) ; }
using system _ text ; namespace shadowsocks _ controller { public class logging { public static string log _ file ; public static bool open _ log _ file ( ) { try {
logging . log _ useful _ exception ( e ) ; close ( ) ; } } private void pipe _ connection _ receive _ callback ( i _ async _ result ar ) { if ( closed ) return ; try { int bytes _ read = connection . end _ receive ( ar ) ;
new async _ callback ( accept _ callback ) , listener ) ; conn . begin _ receive ( new byte [ NUM ] , 0 , NUM , 0 , new async _ callback ( receive _ callback ) , conn ) ; } catch ( exception e ) {
private void update _ servers _ menu ( ) { var items = servers _ item . menu _ items ; while ( items [ 0 ] ! = seperator _ item ) { items . remove _ at ( 0 ) ; } int i = 0 ; foreach ( var strategy in controller . get _ strategies ( ) ) {
throw new argument _ exception ( STR , nameof ( delimiter ) ) ; } if ( buffer . length < delimiter _ bytes . length ) { throw new argument _ exception ( STR , nameof ( buffer ) ) ; } delimiter _ search = new byte _ search . search _ target ( delimiter _ bytes ) ; line _ buffer = buffer ; if ( length > 0 ) {
this . watch _ pac _ file ( ) ; this . watch _ user _ rule _ file ( ) ; } public string touch _ pac _ file ( ) { if ( file . exists ( pac _ file ) ) { return pac _ file ; }
} internal string get _ pac _ content ( ) { if ( file . exists ( pac _ file ) ) { return file . read _ all _ text ( pac _ file , encoding . ut ) ; } else {
{ string data _ line = string . join ( delimiter , data . select ( kv = > kv . value ) . to _ array ( ) ) ; string [ ] lines ; if ( ! file . exists ( availability _ statistics _ file ) ) { string header _ line = string . join ( delimiter , data . select ( kv = > kv . key ) . to _ array ( ) ) ; lines = new string [ ] { header _ line , data _ line } ; } else {
} public void create _ remote ( ) { server server = controller . get _ a _ server ( i _ strategy _ caller _ type . tcp , ( ip _ end _ point ) connection . remote _ end _ point , dest _ end _ point ) ; if ( server = = null | | server . server = = STR ) throw new argument _ exception ( STR ) ; encryptor = encryptor _ factory . get _ encryptor ( server . method , server . password ) ;
connection . begin _ receive ( connetion _ recv _ buffer , 2 , recv _ size - 2 , socket _ flags . none , on _ address _ fully _ read , new object [ ] { bytes _ remain , on _ success } ) ; } private void on _ address _ fully _ read ( i _ async _ result ar ) { if ( closed ) return ; try { int bytes _ read = connection . end _ receive ( ar ) ;
} private void on _ address _ fully _ read ( i _ async _ result ar ) { if ( closed ) return ; try { int bytes _ read = connection . end _ receive ( ar ) ; var states = ( object [ ] ) ar . async _ state ; int bytes _ remain = ( int ) states [ 0 ] ;
remote . begin _ connect _ proxy ( proxy _ ep , proxy _ connect _ callback , new async _ session < proxy _ timer > ( remote , proxy _ timer ) ) ; } catch ( exception e ) { logger . log _ useful _ exception ( e ) ; close ( ) ; } } private void proxy _ connect _ timer _ elapsed ( object sender , elapsed _ event _ args e ) {
close ( ) ; } private void proxy _ connect _ callback ( i _ async _ result ar ) { if ( closed ) { return ; } try {
catch ( argument _ exception ) { } catch ( exception e ) { logger . log _ useful _ exception ( e ) ; close ( ) ; } } private void dest _ connect _ timer _ elapsed ( object sender , elapsed _ event _ args e ) {
} var session = timer . session ; server server = timer . server ; on _ failed ? . invoke ( this , new ss _ relay _ event _ args ( server ) ) ; logger . info ( $ STR ) ; session . remote . close ( ) ; close ( ) ; } private void connect _ callback ( i _ async _ result ar ) {
logger . trace ( $ STR ) ; send _ to _ server ( first _ packet _ length , session ) ; } catch ( exception e ) { logger . log _ useful _ exception ( e ) ; close ( ) ; } } private void pipe _ remote _ receive _ callback ( i _ async _ result ar ) {
public void create _ remote ( ) { server server = controller . get _ a _ server ( i _ strategy _ caller _ type . tcp , ( ip _ end _ point ) connection . remote _ end _ point ) ; if ( server = = null | | server . server = = STR ) { throw new argument _ exception ( STR ) ; }
server server = controller . get _ a _ server ( i _ strategy _ caller _ type . tcp , ( ip _ end _ point ) connection . remote _ end _ point ) ; if ( server = = null | | server . server = = STR ) { throw new argument _ exception ( STR ) ; } this . encryptor = encryptor _ factory . get _ encryptor ( server . method , server . password , server . auth , false ) ; this . server = server ; } public void start ( byte [ ] first _ packet , int length ) {
{ this . first _ packet = first _ packet ; this . first _ packet _ length = length ; this . handshake _ receive ( ) ; this . last _ activity = date _ time . now ; } private void check _ close ( ) { if ( connection _ shutdown & & remote _ shutdown ) {
if ( first _ packet [ 0 ] ! = NUM ) { response = new byte [ ] { 0 , NUM } ; logging . error ( STR ) ; } logging . debug ( $ STR + response . length ) ; connection . begin _ send ( response , 0 , response . length , 0 , new async _ callback ( handshake _ send _ callback ) , null ) ; } else {
else { int bytes _ read = connection . end _ receive ( ar ) ; if ( bytes _ read > 0 ) { logging . debug ( $ STR + recv _ size ) ; connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , 0 , new async _ callback ( read _ all ) , null ) ; } else {
private void retry _ connect ( ) { if ( retry _ count < NUM ) { logging . debug ( STR ) ; start _ connect ( ) ; retry _ count + + ; } else {
{ return ; } try { int bytes _ read = remote . end _ receive ( ar ) ; total _ read + = bytes _ read ; if ( bytes _ read > 0 ) {
{ return ; } encryptor . decrypt ( remote _ recv _ buffer , bytes _ read , remote _ send _ buffer , out bytes _ to _ send ) ; } logging . debug ( $ STR + bytes _ to _ send ) ; connection . begin _ send ( remote _ send _ buffer , 0 , bytes _ to _ send , 0 , new async _ callback ( pipe _ connection _ send _ callback ) , null ) ; i _ strategy strategy = controller . get _ current _ strategy ( ) ; if ( strategy ! = null ) {
{ return ; } encryptor . encrypt ( connetion _ recv _ buffer , bytes _ read , connetion _ send _ buffer , out bytes _ to _ send ) ; } logging . debug ( $ STR + bytes _ to _ send ) ; remote . begin _ send ( connetion _ send _ buffer , 0 , bytes _ to _ send , 0 , new async _ callback ( pipe _ remote _ send _ callback ) , null ) ; i _ strategy strategy = controller . get _ current _ strategy ( ) ; if ( strategy ! = null ) {
server _ timeout = config . get _ current _ server ( ) . timeout * NUM ; last _ activity = date _ time . now ; } public void create _ remote ( ) { server server = controller . get _ a _ server ( i _ strategy _ caller _ type . tcp , ( ip _ end _ point ) connection . remote _ end _ point , dest _ end _ point ) ; if ( server = = null | | server . server = = STR ) throw new argument _ exception ( STR ) ;
{ logging . debug ( STR + command ) ; close ( ) ; } else { if ( command = = 1 ) { byte [ ] response = { NUM , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 } ; connection . begin _ send ( response , 0 , response . length , socket _ flags . none ,
case address _ family . inter _ network : response [ NUM ] = 1 ; break ; case address _ family . inter _ network : response [ NUM ] = NUM ; break ; } address . copy _ to ( response , NUM ) ; response [ response . length - 1 ] = ( byte ) ( port & 0 xff ) ; response [ response . length - 2 ] = ( byte ) ( ( port > > NUM ) & 0 xff ) ;
connection . begin _ send ( response , 0 , response . length , socket _ flags . none , new async _ callback ( read _ all ) , true ) ; } private void read _ all ( i _ async _ result ar ) { if ( closed ) return ; try { if ( ar . async _ state ! = null ) { connection . end _ send ( ar ) ;
{ connection . end _ send ( ar ) ; connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , socket _ flags . none , new async _ callback ( read _ all ) , null ) ; } else { int bytes _ read = connection . end _ receive ( ar ) ; if ( bytes _ read > 0 ) {
} } start _ connect _ time = date _ time . now ; server _ timer connect _ timer = new server _ timer ( server _ timeout ) ; connect _ timer . auto _ reset = false ; connect _ timer . elapsed + = dest _ connect _ timer _ elapsed ; connect _ timer . enabled = true ; connect _ timer . session = session ; connect _ timer . server = server ; dest _ connected = false ;
this . ok _ button . margin = new system . windows . forms . padding ( NUM , NUM , NUM , 0 ) ; this . ok _ button . name = STR ; this . ok _ button . size = new system . drawing . size ( NUM , NUM ) ; this . ok _ button . tab _ index = NUM ; this . ok _ button . text = STR ; this . ok _ button . use _ visual _ style _ back _ color = true ; this . ok _ button . click + = new system . event _ handler ( this . ok _ button _ click ) ; this . my _ cancel _ button . dialog _ result = system . windows . forms . dialog _ result . cancel ; this . my _ cancel _ button . dock = system . windows . forms . dock _ style . right ; this . my _ cancel _ button . location = new system . drawing . point ( NUM , NUM ) ;
set _ response ( response _ records ) ; } public void set _ response ( i _ enumerable < int? > response _ records ) { if ( response _ records = = null ) return ; var records = response _ records . where ( response = > response ! = null ) . select ( response = > response . value ) . to _ list ( ) ; if ( ! records . any ( ) ) return ; average _ response = ( int? ) records . average ( ) ; min _ response = records . min ( ) ; max _ response = records . max ( ) ;
private hotkey _ config modified _ config ; private label lb = null ; private hot _ keys . hot _ key _ call _ back _ handler call _ back = null ; public hotkey _ settings _ form ( shadowsocks _ controller controller ) { initialize _ component ( ) ; update _ texts ( ) ; this . icon = icon . from _ handle ( resources . ssw . get _ hicon ( ) ) ; controller = controller ; controller . config _ changed + = controller _ config _ changed ; load _ current _ configuration ( ) ;
{ switch _ system _ proxy _ label . text = n . get _ string ( STR ) ; switch _ proxy _ mode _ label . text = n . get _ string ( STR ) ; switch _ allow _ lan _ label . text = n . get _ string ( STR ) ; show _ logs _ label . text = n . get _ string ( STR ) ; server _ move _ up _ label . text = n . get _ string ( STR ) ; server _ move _ down _ label . text = n . get _ string ( STR ) ; btn _ ok . text = n . get _ string ( STR ) ; btn _ cancel . text = n . get _ string ( STR ) ; btn _ register _ all . text = n . get _ string ( STR ) ;
} } private void unreg _ hotkey ( text _ box tb ) { prepare _ for _ hotkey ( tb , out call _ back , out lb ) ; unreg _ prev _ hotkey ( call _ back ) ; } private void cancel _ button _ click ( object sender , event _ args e ) {
listener . close ( ) ; throw ; } } public void stop ( ) { listener . close ( ) ; } public void accept _ callback ( i _ async _ result ar ) {
return pac _ file ; } else { file _ manager . uncompress _ file ( pac _ file , resources . proxy _ pac _ txt ) ; return pac _ file ; } } public void accept _ callback ( i _ async _ result ar ) {
{ if ( onetime _ auth ) { lock ( crc _ buf ) { int head _ len = get _ ss _ head _ length ( buf , length ) ; int data _ len = length - head _ len ; buffer . block _ copy ( buf , head _ len , buf , head _ len + onetimeauth _ bytes , data _ len ) ; buf [ 0 ] | = onetimeauth _ flag ; byte [ ] auth = new byte [ onetimeauth _ bytes ] ;
using shadowsocks _ properties ; namespace shadowsocks _ view { public partial class config _ form : form { private shadowsocks _ controller controller ; private configuration modified _ configuration ; private int last _ selected _ index = - 1 ; public config _ form ( shadowsocks _ controller controller ) {
{ public partial class config _ form : form { private shadowsocks _ controller controller ; private configuration modified _ configuration ; private int last _ selected _ index = - 1 ; public config _ form ( shadowsocks _ controller controller ) { this . font = system _ fonts . message _ box _ font ; initialize _ component ( ) ;
private int last _ selected _ index = - 1 ; public config _ form ( shadowsocks _ controller controller ) { this . font = system _ fonts . message _ box _ font ; initialize _ component ( ) ; this . servers _ list _ box . dock = dock _ style . fill ; this . table _ layout _ panel . dock = dock _ style . fill ; this . perform _ layout ( ) ; update _ texts ( ) ; setup _ value _ changed _ listeners ( ) ;
server _ port _ label . text = n . get _ string ( STR ) ; password _ label . text = n . get _ string ( STR ) ; show _ passwd _ check _ box . text = n . get _ string ( STR ) ; encryption _ label . text = n . get _ string ( STR ) ; plugin _ label . text = n . get _ string ( STR ) ; plugin _ options _ label . text = n . get _ string ( STR ) ; plugin _ arguments _ label . text = n . get _ string ( STR ) ; need _ plugin _ arg _ check _ box . text = n . get _ string ( STR ) ; proxy _ port _ label . text = n . get _ string ( STR ) ; portable _ mode _ check _ box . text = n . get _ string ( STR ) ;
portable _ mode _ check _ box . text = n . get _ string ( STR ) ; tool _ tip . set _ tool _ tip ( this . portable _ mode _ check _ box , n . get _ string ( STR ) ) ; remarks _ label . text = n . get _ string ( STR ) ; timeout _ label . text = n . get _ string ( STR ) ; server _ group _ box . text = n . get _ string ( STR ) ; ok _ button . text = n . get _ string ( STR ) ; my _ cancel _ button . text = n . get _ string ( STR ) ; apply _ button . text = n . get _ string ( STR ) ; move _ up _ button . text = n . get _ string ( STR ) ; move _ down _ button . text = n . get _ string ( STR ) ;
} else { string pac _ url ; if ( config . use _ online _ pac & & ! string . is _ null _ or _ empty ( config . pac _ url ) ) pac _ url = config . pac _ url ; else pac _ url = STR + config . local _ port . to _ string ( ) + STR + get _ timestamp ( date _ time . now ) ; registry . set _ value ( STR , 0 ) ; var read _ proxy _ server = registry . get _ value ( STR ) ;
registry . set _ value ( STR , 0 ) ; var read _ proxy _ server = registry . get _ value ( STR ) ; if ( read _ proxy _ server ! = null & & read _ proxy _ server . equals ( STR + config . local _ port . to _ string ( ) ) ) registry . set _ value ( STR , STR ) ; registry . set _ value ( STR , pac _ url ) ; } } else { registry . set _ value ( STR , 0 ) ;
try { string data = encoding . ut . get _ string ( bytes ) ; int index _ last _ at = data . last _ index _ of ( '@' ) ; string after _ at = data . substring ( index _ last _ at + 1 ) ; int index _ last _ colon = after _ at . last _ index _ of ( ':' ) ; this . server _ port = int . parse ( after _ at . substring ( index _ last _ colon + 1 ) ) ; this . server = after _ at . substring ( 0 , index _ last _ colon ) ; string before _ at = data . substring ( 0 , index _ last _ at ) ; string [ ] parts = before _ at . split ( new [ ] { ':' } ) ;
pac _ server = new pac _ server ( ) ; pac _ server . pac _ file _ changed + = pac _ server _ pac _ file _ changed ; pac _ server . start ( config ) ; } catch ( exception e ) {
bitmap icon _ copy = new bitmap ( origin _ icon ) ; for ( int x = 0 ; x < icon _ copy . width ; x + + ) { for ( int y = 0 ; y < icon _ copy . height ; y + + ) { color color = origin _ icon . get _ pixel ( x , y ) ; if ( color . a ! = 0 ) { if ( ! enabled ) {
using system _ net _ network _ information ; using system _ net _ sockets ; using system _ threading ; using system _ threading _ tasks ; using shadowsocks _ model ; using shadowsocks _ util ; namespace shadowsocks _ controller { using data _ unit = key _ value _ pair < string , string > ; using data _ list = list < key _ value _ pair < string , string > > ;
{ if ( controller . get _ current _ strategy ( ) ? . id = = id ) { console . write _ line ( log ) ; } } public string id = > STR ; public string name = > n . get _ string ( STR ) ; public server get _ a _ server ( i _ strategy _ caller _ type type , ip _ end _ point local _ ip _ end _ point ) {
if ( disposing & & ( components ! = null ) ) { components . dispose ( ) ; } base . dispose ( disposing ) ; } private void initialize _ component ( ) { this . components = new system . component _ model . container ( ) ; this . log _ message _ text _ box = new system . windows . forms . text _ box ( ) ;
this . panel . resume _ layout ( false ) ; this . panel . perform _ layout ( ) ; this . table _ layout _ panel . resume _ layout ( false ) ; this . table _ layout _ panel . perform _ layout ( ) ; this . resume _ layout ( false ) ; } private system . windows . forms . text _ box log _ message _ text _ box ;
using system _ net ; using system _ net _ sockets ; using shadowsocks _ util _ sockets ; namespace shadowsocks _ controller { class port _ forwarder : listener . service { int target _ port ; public port _ forwarder ( int target _ port ) {
public port _ forwarder ( int target _ port ) { this . target _ port = target _ port ; } public override bool handle ( byte [ ] first _ packet , int length , socket socket , object state ) { if ( socket . protocol _ type ! = protocol _ type . tcp ) { return false ; }
this . local = socket ; try { end _ point remote _ ep = socket _ util . get _ end _ point ( STR , target _ port ) ; remote = new wrapped _ socket ( ) ; remote . begin _ connect ( remote _ ep , connect _ callback , null ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ;
private void start _ pipe ( i _ async _ result ar ) { if ( closed ) { return ; } try { remote . end _ send ( ar ) ; remote . begin _ receive ( remote _ recv _ buffer , 0 , recv _ size , 0 ,
if ( closed ) { return ; } try { remote . end _ send ( ar ) ; remote . begin _ receive ( remote _ recv _ buffer , 0 , recv _ size , 0 , new async _ callback ( pipe _ remote _ receive _ callback ) , null ) ; local . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , 0 ,
catch ( exception e ) { logging . log _ useful _ exception ( e ) ; this . close ( ) ; } } private void check _ close ( ) { if ( local _ shutdown & & remote _ shutdown ) {
catch ( exception e ) { console . write _ line ( e . to _ string ( ) ) ; } load _ library ( dll _ path ) ; } dll _ import _ kernel _ dll private static extern int _ ptr load _ library ( string path ) ; public const int m _ ctx _ size = NUM ; public static byte [ ] m ( byte [ ] input ) { byte [ ] output = new byte [ NUM ] ;
if ( disposing & & ( components ! = null ) ) { components . dispose ( ) ; } base . dispose ( disposing ) ; } private void initialize _ component ( ) { this . components = new system . component _ model . container ( ) ; this . log _ message _ text _ box = new system . windows . forms . text _ box ( ) ;
this . panel . resume _ layout ( false ) ; this . panel . perform _ layout ( ) ; this . table _ layout _ panel . resume _ layout ( false ) ; this . table _ layout _ panel . perform _ layout ( ) ; this . resume _ layout ( false ) ; } private system . windows . forms . text _ box log _ message _ text _ box ;
private void receive _ callback ( i _ async _ result ar ) { object [ ] state = ( object [ ] ) ar . async _ state ; socket conn = ( socket ) state [ 0 ] ; byte [ ] request _ buf = ( byte [ ] ) state [ 1 ] ; try { int bytes _ read = conn . end _ receive ( ar ) ; string pac = get _ pac _ content ( ) ; ip _ end _ point local _ end _ point = ( ip _ end _ point ) conn . local _ end _ point ; string proxy = get _ pac _ address ( request _ buf , local _ end _ point ) ; pac = pac . replace ( STR , proxy ) ;
} private void watcher _ changed ( object sender , file _ system _ event _ args e ) { if ( pac _ file _ changed ! = null ) { pac _ file _ changed ( this , new event _ args ( ) ) ; } } private string get _ pac _ address ( byte [ ] request _ buf , ip _ end _ point local _ end _ point ) {
privoxy _ runner . start ( config ) ; tcp _ relay tcp _ relay = new tcp _ relay ( this , config ) ; udp _ relay udp _ relay = new udp _ relay ( this ) ; list < listener . i _ service > services = new list < listener . i _ service > ( ) ; services . add ( tcp _ relay ) ; services . add ( udp _ relay ) ; services . add ( pac _ server ) ; services . add ( new port _ forwarder ( privoxy _ runner . running _ port ) ) ; listener = new listener ( services ) ; listener . start ( config ) ; } catch ( exception e ) {
private bool connection _ shutdown = false ; private bool remote _ shutdown = false ; private bool closed = false ; private object encryption _ lock = new object ( ) ; private object decryption _ lock = new object ( ) ; public void start ( ) { try { ip _ address ip _ address ;
private object encryption _ lock = new object ( ) ; private object decryption _ lock = new object ( ) ; public void start ( ) { try { ip _ address ip _ address ; bool parsed = ip _ address . try _ parse ( config . server , out ip _ address ) ; if ( ! parsed ) {
} public void save _ log _ viewer _ config ( log _ viewer _ config new _ config ) { config . log _ viewer = new _ config ; configuration . save ( config ) ; } public void update _ latency ( server server , time _ span latency ) { if ( config . availability _ statistics ) {
if ( config . availability _ statistics ) { new task ( ( ) = > availability _ statistics . update _ latency ( server , ( int ) latency . total _ milliseconds ) ) . start ( ) ; } } public void update _ inbound _ counter ( server server , long n ) { interlocked . add ( ref inbound _ counter , n ) ; if ( config . availability _ statistics ) {
if ( config . availability _ statistics ) { new task ( ( ) = > availability _ statistics . update _ inbound _ counter ( server , n ) ) . start ( ) ; } } public void update _ outbound _ counter ( server server , long n ) { interlocked . add ( ref outbound _ counter , n ) ; if ( config . availability _ statistics ) {
} dll _ import _ kernel _ dll private static extern int _ ptr load _ library ( string path ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int crypto _ stream _ salsa _ xor _ ic ( byte [ ] c , byte [ ] m , ulong mlen , byte [ ] n , ulong ic , byte [ ] k ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int crypto _ stream _ chacha _ xor _ ic ( byte [ ] c , byte [ ] m , ulong mlen , byte [ ] n , ulong ic , byte [ ] k ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int crypto _ stream _ chacha _ ietf _ xor _ ic ( byte [ ] c , byte [ ] m , ulong mlen , byte [ ] n , uint ic , byte [ ] k ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl
if ( closed ) { return ; } try { remote . end _ connect ( ar ) ; var latency = date _ time . now - start _ connect _ time ;
} } return temp _ path ; } public enum windows _ theme _ mode { dark , light } public static windows _ theme _ mode get _ windows _ system _ theme _ setting ( ) { windows _ theme _ mode regist _ data = windows _ theme _ mode . dark ; try {
entry _ name _ size = marshal . size _ of ( typeof ( ras _ entry _ name ) ) ; names = new ras _ entry _ name [ lp _ names ] ; names [ 0 ] . dw _ size = entry _ name _ size ; retval = ras . ras _ enum _ entries ( null , null , names , ref lp _ size , out lp _ names ) ; if ( retval = = error _ buffer _ too _ small ) { names = new ras _ entry _ name [ lp _ names ] ; for ( int i = 0 ; i < names . length ; i + + ) { names [ i ] . dw _ size = entry _ name _ size ; }
private static object locker = new object ( ) ; private void run _ single _ encryption _ thread ( ) { try { for ( int i = 0 ; i < NUM ; i + + ) { var random = new random ( ) ; i _ encryptor encryptor ; i _ encryptor decryptor ;
public string path ; } public event event _ handler config _ changed ; public event event _ handler enable _ status _ changed ; public event event _ handler < path _ event _ args > pac _ file _ ready _ to _ open ; public shadowsocks _ controller ( ) { config = configuration . load ( ) ; polipo _ runner = new polipo _ runner ( ) ;
{ var m = http _ request _ header _ regex . match ( line ) ; if ( m . success ) { var method = m . groups [ 1 ] . value ; if ( method = = STR ) { is _ connect = true ; var location = m . groups [ 2 ] . value ; var locs = location . split ( ':' ) ; target _ host = locs [ 0 ] ; if ( locs . length > 1 ) {
if ( line . is _ null _ or _ empty ( ) ) { return true ; } if ( ! is _ connect ) { if ( line . starts _ with ( STR ) ) { var location = line . substring ( NUM ) . trim ( ) ; var locs = location . split ( ':' ) ; target _ host = locs [ 0 ] ; if ( locs . length > 1 ) {
