                RegistryKey runKey = Microsoft.Win32.Registry.CurrentUser.OpenSubKey(@"Software\Microsoft\Windows\CurrentVersion\Run", true);
                    runKey.SetValue("Shadowsocks", path);
                    runKey.DeleteValue("Shadowsocks");
                runKey.Close();
                RegistryKey runKey = Microsoft.Win32.Registry.CurrentUser.OpenSubKey(@"Software\Microsoft\Windows\CurrentVersion\Run");
                runKey.Close();
                    if (item.Equals("Shadowsocks"))
                if (!File.Exists(_pluginProcess.StartInfo.FileName))\n                {\n                    throw new FileNotFoundException(I18N.GetString("Cannot find the plugin program file"), _pluginProcess.StartInfo.FileName);\n                }
                _pluginProcess.Start();
﻿using System;
using Shadowsocks.Controller;\nusing Shadowsocks.Properties;\nusing Shadowsocks.Model;\nusing Newtonsoft.Json;
                    process.Start();\n                    process.BeginErrorReadLine();\n                    process.BeginOutputReadLine();\n                    process.WaitForExit();
                        throw new ProxyException(stderr);
                            throw new ProxyException("failed to query wininet settings");
                            Color flyBlue = Color.FromArgb(192, 192, 192, 192);
            this.tableLayoutPanel1.Controls.Add(this.PluginArgumentsTextBox, 1, 7);\n            this.tableLayoutPanel1.Controls.Add(this.PluginArgumentsLabel, 0, 7);\n            this.tableLayoutPanel1.Controls.Add(this.RemarksLabel, 0, 9);
            this.tableLayoutPanel1.RowCount = 11;\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.Size = new System.Drawing.Size(279, 270);
            this.groupBox1 = new System.Windows.Forms.GroupBox();
                config.isDefault = false;
        public void Start()
            HotkeyReg.RegAllHotkeys();
            IntPtr ctx = Marshal.AllocHGlobal(MD5_CTX_SIZE);
            MbedTLS.md5_init(ctx);\n            MbedTLS.md5_starts(ctx);\n            MbedTLS.md5_update(ctx, input, (uint)input.Length);\n            MbedTLS.md5_finish(ctx, output);\n            MbedTLS.md5_free(ctx);\n            Marshal.FreeHGlobal(ctx);
        public extern static void md5_init(IntPtr ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void md5_free(IntPtr ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void md5_starts(IntPtr ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void md5_update(IntPtr ctx, byte[] input, uint ilen);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void md5_finish(IntPtr ctx, byte[] output);
﻿using System;\nusing System.Collections;\nusing System.Globalization;\nusing System.IO;
using Shadowsocks.Encryption;\nusing Shadowsocks.Model;\nusing Shadowsocks.Properties;\nusing Shadowsocks.Util;\nusing System.Threading.Tasks;
﻿using Shadowsocks.Controller;\nusing Shadowsocks.Properties;\nusing System;
        Model.Configuration config;\n        public LogForm(string filename)\n        {
            config = Model.Configuration.Load();\n            if (config.logViewer == null)\n            {\n                config.logViewer = new Model.LogViewerConfig();\n            }\n            else\n            {\n                topMostTrigger = config.logViewer.topMost;\n                wrapTextTrigger = config.logViewer.wrapText;\n                toolbarTrigger = config.logViewer.toolbarShown;\n                LogMessageTextBox.Font = new Font(config.logViewer.fontName, config.logViewer.fontSize);\n                LogMessageTextBox.BackColor = config.logViewer.GetBackgroundColor();\n                LogMessageTextBox.ForeColor = config.logViewer.GetTextColor();\n            }
                    connection.BeginReceive(_connetionRecvBuffer, 0, RecvSize, 0, new AsyncCallback(ReadAll), null);
                        connection.BeginReceive(_connetionRecvBuffer, 0, RecvSize, 0, new AsyncCallback(ReadAll), null);
            // \n            // AutoStartupItem\n            // \n            this.AutoStartupItem.Index = 3;\n            this.AutoStartupItem.Text = "Start on Boot";\n            this.AutoStartupItem.Click += new System.EventHandler(this.AutoStartupItem_Click);\n            // \n            // ShareOverLANItem\n            // \n            this.ShareOverLANItem.Index = 4;\n            this.ShareOverLANItem.Text = "Share over LAN";\n            this.ShareOverLANItem.Click += new System.EventHandler(this.ShareOverLANItem_Click);
            // menuItem4\n            // \n            this.menuItem4.Index = 6;\n            this.menuItem4.Text = "-";
        public static void Enable()
                registry.SetValue("ProxyEnable", 0);\n                registry.SetValue("ProxyServer", "");\n                registry.SetValue("AutoConfigURL", "http://127.0.0.1:8093/pac?t=" + GetTimestamp(DateTime.Now));
        public static void UpdateIE()
            registry.SetValue("ProxyEnable", 1);\n            registry.SetValue("ProxyServer", "127.0.0.1:8123");\n            SystemProxy.UpdateIE();
            SystemProxy.UpdateIE();
using System.Text.RegularExpressions;
        public static readonly Regex\n            UrlFinder = new Regex(@"ss://(?<base64>[A-Za-z0-9+-/=_]+)(?:#(?<tag>\S+))?", RegexOptions.IgnoreCase),\n            DetailsParser = new Regex(@"^((?<method>.+?):(?<password>.*)@(?<hostname>.+?):(?<port>\d+?))$", RegexOptions.IgnoreCase);
            var matches = UrlFinder.Matches(ssURL);\n            if (matches.Count <= 0) return null;
            foreach (Match match in matches)
                Server tmp = new Server();\n                var base64 = match.Groups["base64"].Value;\n                var tag = match.Groups["tag"].Value;\n                if (!tag.IsNullOrEmpty())
                    tmp.remarks = HttpUtility.UrlDecode(tag, Encoding.UTF8);
                Match details = DetailsParser.Match(Encoding.UTF8.GetString(Convert.FromBase64String(\n                    base64.PadRight(base64.Length + (4 - base64.Length % 4) % 4, '='))));\n                if (!details.Success)
                tmp.method = details.Groups["method"].Value;\n                tmp.password = details.Groups["password"].Value;\n                tmp.server = details.Groups["hostname"].Value;\n                tmp.server_port = int.Parse(details.Groups["port"].Value);
            this.tableLayoutPanel1.Controls.Add(this.RemarksTextBox, 1, 5);\n            this.tableLayoutPanel1.Controls.Add(this.RemarksLabel, 0, 5);
            this.tableLayoutPanel1.Controls.Add(this.TimeoutLabel, 0, 6);\n            this.tableLayoutPanel1.Controls.Add(this.TimeoutTextBox, 1, 6);
            this.tableLayoutPanel1.RowCount = 7;\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.Size = new System.Drawing.Size(255, 167);
            if (!File.Exists(DATABASE_PATH))\n            {
        static void LoadGeositeList(byte[] data = null)\n        {\n            data = data ?? File.ReadAllBytes(DATABASE_PATH);\n            var list = GeositeList.Parser.ParseFrom(data);
        public static void UpdatePACFromGeosite(Configuration config)
            WebClient http = new WebClient();
                http.Proxy = new WebProxy(
            http.DownloadDataCompleted += (o, e) =>\n            {\n                try\n                {\n                    File.WriteAllBytes(DATABASE_PATH, e.Result);\n                    LoadGeositeList();\n                    bool pacFileChanged = MergeAndWritePACFile(group, blacklist);\n                    UpdateCompleted?.Invoke(null, new GeositeResultEventArgs(pacFileChanged));\n                }\n                catch (Exception ex)\n                {\n                    Error?.Invoke(null, new ErrorEventArgs(ex));\n                }\n            };\n            http.DownloadDataAsync(new Uri(geositeUrl));
        ShadowsocksController controller;
            updateUI();
            updateUI();
            updateUI();
        private void updateUI()
            Server server = controller.GetCurrentServer();
            enableItem.Checked = controller.GetConfiguration().enabled;
        private void CinfigForm_Load(object sender, EventArgs e)
            try\n            {\n                Server server = new Server\n                {\n                    server = IPTextBox.Text,\n                    server_port = int.Parse(ServerPortTextBox.Text),\n                    password = PasswordTextBox.Text,\n                    local_port = int.Parse(ProxyPortTextBox.Text),\n                    method = EncryptionSelect.Text\n                };\n                Configuration config = controller.GetConfiguration();\n                config.configs.Clear();\n                config.configs.Add(server);\n                config.index = 0;\n                controller.SaveConfig(config);\n                this.Hide();\n            }\n            catch (FormatException)\n            {\n                MessageBox.Show("illegal port number format");\n            }\n            catch (Exception ex)\n            {\n                MessageBox.Show(ex.Message);\n            }
            updateUI();
            this.label5 = new System.Windows.Forms.Label();
            this.EncryptionSelect = new System.Windows.Forms.ComboBox();
            this.label4 = new System.Windows.Forms.Label();
            this.ProxyPortTextBox = new System.Windows.Forms.TextBox();
            this.DeleteButton = new System.Windows.Forms.Button();
            // \n            // label1\n            // \n            this.label1.Anchor = System.Windows.Forms.AnchorStyles.Right;\n            this.label1.AutoSize = true;\n            this.label1.Location = new System.Drawing.Point(17, 11);\n            this.label1.Name = "label1";\n            this.label1.Size = new System.Drawing.Size(51, 13);\n            this.label1.TabIndex = 0;\n            this.label1.Text = "Server IP";\n            // \n            // label2\n            // \n            this.label2.Anchor = System.Windows.Forms.AnchorStyles.Right;\n            this.label2.AutoSize = true;\n            this.label2.Location = new System.Drawing.Point(8, 37);\n            this.label2.Name = "label2";\n            this.label2.Size = new System.Drawing.Size(60, 13);\n            this.label2.TabIndex = 1;\n            this.label2.Text = "Server Port";
            // \n            // DeleteButton\n            // \n            this.DeleteButton.Location = new System.Drawing.Point(86, 4);\n            this.DeleteButton.Name = "DeleteButton";\n            this.DeleteButton.Size = new System.Drawing.Size(75, 23);\n            this.DeleteButton.TabIndex = 4;\n            this.DeleteButton.Text = "&Delete";\n            this.DeleteButton.UseVisualStyleBackColor = true;
                    try
                        using (File.Create(path))\n                        {\n                            //do nothing\n                        }
                    catch (Exception e)\n                    {\n                        Logging.LogUsefulException(e);\n                    }\n                    if (!File.Exists(path))\n                    {\n                        Console.WriteLine(\n                            $"statistics file does not exist, try to reload {_retryInterval.TotalMinutes} minutes later");\n                        _recorder.Change(_retryInterval, RecordingInterval);\n                        return;\n                    }
        public LineReader(WrappedSocket socket, byte[] firstPackge, int index, int length,
            Encoding encoding, string delimiter, int maxLineBytes,
            if (maxLineBytes < length)
                throw new ArgumentException("Line buffer length can't less than first package length!", nameof(maxLineBytes));
            if (maxLineBytes < _delimiterBytes.Length)
                throw new ArgumentException("Too small!", nameof(maxLineBytes));
            _lineBuffer = new byte[maxLineBytes];
                Array.Copy(firstPackge, index, _lineBuffer, 0, length);
                socket.BeginReceive(_lineBuffer, 0, maxLineBytes, 0, ReceiveCallback, 0);
        public LineReader(WrappedSocket socket, Func<string, object, bool> onLineRead,\n            Action<Exception, object> onException,\n            Action<byte[], int, int, object> onFinish, Encoding encoding, string delimiter, int maxLineBytes,\n            object state)\n            : this(socket, null, 0, 0, onLineRead, onException, onFinish, encoding, delimiter, maxLineBytes, state)
            int len = Socks5Util.HeaderAddrLength(destEndPoint);\n            byte[] request = new byte[len + 3];\n            Socks5Util.FillHeaderAddr(request, 3, destEndPoint);
namespace Shadowsocks.Controller.Service
        private readonly List<ITCPHandlerFactory> _factories = new List<ITCPHandlerFactory>();\n        public ISet<TCPHandler> Handlers { get; } = new HashSet<TCPHandler>();
            _factories.Add(new Socks5HandlerFactory());\n            _factories.Add(new HttpHandlerHandlerFactory());
            TCPHandler handler = null;\n            foreach (var factory in _factories)\n            {\n                if (factory.CanHandle(firstPacket, length))\n                {\n                    handler = factory.NewHandler(_controller, _config, this, socket);\n                    break;\n                }\n            }\n            if (handler == null)\n            {
            }
    interface ITCPHandlerFactory
        bool CanHandle(byte[] firstPacket, int length);\n        TCPHandler NewHandler(ShadowsocksController controller, Configuration config, TCPRelay tcprelay, Socket socket);\n    }\n    abstract class TCPHandler\n    {\n        public abstract void StartHandshake(byte[] firstPacket, int length);\n        protected abstract void OnServerConnected(AsyncSession session);\n        protected class AsyncSession
        protected class AsyncSession<T> : AsyncSession
        private ShadowsocksController _controller;\n        protected Configuration Config { get; }\n        private TCPRelay _tcprelay;\n        protected Socket Connection { get; }\n        private Server _server;
        private bool _proxyConnected;\n        private bool _destConnected;\n        private int _totalRead = 0;\n        private int _totalWrite = 0;\n        protected byte[] RemoteRecvBuffer { get; } = new byte[BufferSize];\n        private readonly byte[] _remoteSendBuffer = new byte[BufferSize];\n        protected byte[] ConnetionRecvBuffer { get; } = new byte[BufferSize];\n        private readonly byte[] _connetionSendBuffer = new byte[BufferSize];\n        private IEncryptor _encryptor;\n        private readonly object _encryptionLock = new object();\n        private readonly object _decryptionLock = new object();\n        private bool _connectionShutdown = false;\n        private bool _remoteShutdown = false;\n        protected bool Closed { get; private set; }= false;\n        private readonly object _closeConnLock = new object();
        public TCPHandler(ShadowsocksController controller, Configuration config, TCPRelay tcprelay, Socket socket, bool autoAppendHeader = true)
            _serverHeaderSent = !autoAppendHeader;\n        }\n        private void CreateRemote()\n        {\n            Server server = _controller.GetAServer(IStrategyCallerType.TCP, (IPEndPoint)Connection.RemoteEndPoint, _destEndPoint);
        protected void StartPipe(AsyncSession session)\n        {\n            if (Closed) return;
                session.Remote.BeginReceive(RemoteRecvBuffer, 0, RecvSize, SocketFlags.None, PipeRemoteReceiveCallback, session);\n                Connection.BeginReceive(ConnetionRecvBuffer, 0, RecvSize, SocketFlags.None, PipeConnectionReceiveCallback, session);
            BeginSendToServer(length, session, PipeRemoteSendCallback);\n        }\n        private bool _serverHeaderSent;\n        protected void BeginSendToServer(int length, AsyncSession session, AsyncCallback callback)\n        {\n            if (!_serverHeaderSent)\n            {\n                _serverHeaderSent = true;\n                // Append socks5 header\n                int len = Socks5Util.HeaderAddrLength(_destEndPoint);\n                Array.Copy(ConnetionRecvBuffer, 0, ConnetionRecvBuffer, len, length);\n                Socks5Util.FillHeaderAddr(ConnetionRecvBuffer, 0, _destEndPoint);\n                length += len;\n            }
            session.Remote.BeginSend(_connetionSendBuffer, 0, bytesToSend, SocketFlags.None, callback, session);
        protected AsyncSession EndSendToServer(IAsyncResult ar)\n        {\n            var session = (AsyncSession)ar.AsyncState;\n            session.Remote.EndSend(ar);\n            return session;\n        }
            if (Closed) return;\n            try\n            {\n                var session = EndSendToServer(ar);\n                Connection.BeginReceive(ConnetionRecvBuffer, 0, RecvSize, SocketFlags.None, PipeConnectionReceiveCallback, session);
                services.Add(_pacServer);
                    // PolarSSL takes key length by bit\n                    PolarSSL.aes_setkey_enc(ctx, realkey, keyLen * 8);
                    // PolarSSL takes key length by bit\n                    // since we'll use CFB mode, here we also do enc, not dec\n                    PolarSSL.aes_setkey_enc(ctx, realkey, keyLen * 8);
        GfwListUpdater gfwlistUpdater;
                StartGfwListUpdater();
            if (gfwlistUpdater != null)\n            {\n                gfwlistUpdater.Stop();\n                gfwlistUpdater = null;\n            }
        private const int EXPIRE_HOURS = 6;
        public bool useSystemProxy = true;\n        public class GfwListChangedArgs : EventArgs\n        {\n            public string[] GfwList { get; set; }\n        }\n        public event EventHandler<GfwListChangedArgs> GfwListChanged; \n        private bool running = false;\n        private bool closed = false;\n        private int jobId = 0;\n        DateTime lastUpdateTimeUtc;\n        string lastUpdateMd5;\n        private object locker = new object();\n        public GfwListUpdater()\n        {\n        }\n        ~GfwListUpdater()\n        {\n            Stop();\n        }\n        public void Start()\n        {\n            lock (locker)\n            {\n                if (running)\n                    return;\n                running = true;\n                closed = false;\n                jobId++;\n                new Thread(new ParameterizedThreadStart(UpdateJob)).Start(jobId);\n            }\n        }\n        public void Stop()\n        {\n            lock(locker)\n            {\n                closed = true;\n                running = false;\n                jobId++;\n            }\n        }\n        public void ScheduleUpdateTime(int delaySeconds)\n        {\n            lock(locker)\n            {\n                lastUpdateTimeUtc = DateTime.UtcNow.AddHours(-1 * EXPIRE_HOURS).AddSeconds(delaySeconds);\n            }\n        }\n        private string DownloadGfwListFile()
                WebClient http = new WebClient();\n                http.Proxy = useSystemProxy ? WebRequest.GetSystemWebProxy() : proxy;\n                return http.DownloadString(new Uri(GFWLIST_URL));
                Console.WriteLine(ex.ToString());\n            }\n            return null;\n        }\n        private bool IsExpire()\n        {\n            lock (locker)\n            {\n                TimeSpan ts = DateTime.UtcNow - lastUpdateTimeUtc;\n                bool expire = ((int)ts.TotalHours) >= EXPIRE_HOURS;\n                if (expire)\n                    lastUpdateTimeUtc = DateTime.UtcNow;\n                return expire;\n            }\n        }\n        private bool IsJobStop(int currentJobId)\n        {\n            lock (locker)\n            {\n                if (!running || closed || currentJobId != this.jobId)\n                    return true;\n            }\n            return false;\n        }\n        private bool IsGfwListChanged(string content)\n        {\n            byte[] inputBytes = Encoding.UTF8.GetBytes(content);\n            byte[] md5Bytes = MD5.Create().ComputeHash(inputBytes);\n            string md5 = "";\n            for (int i = 0; i < md5Bytes.Length; i++)\n                md5 += md5Bytes[i].ToString("x").PadLeft(2, '0');\n            if (md5 == lastUpdateMd5)\n                return false;\n            lastUpdateMd5 = md5;\n            return true;\n        }\n        private void ParseGfwList(string response)\n        {\n            if (!IsGfwListChanged(response))\n                return;\n            if (GfwListChanged != null)\n            {\n                try\n                {\n                    Parser parser = new Parser(response);\n                    GfwListChangedArgs args = new GfwListChangedArgs\n                    {\n                        GfwList = parser.GetReducedDomains()\n                    };\n                    GfwListChanged(this, args);\n                }\n                catch(Exception ex)\n                {\n                    Console.WriteLine(ex.ToString());\n                }\n            }\n        }\n        private void UpdateJob(object state)\n        {\n            int currentJobId = (int)state;\n            int retryTimes = 3;\n            while (!IsJobStop(currentJobId))\n            {\n                if (IsExpire())\n                {\n                    string response = DownloadGfwListFile();\n                    if (response != null)\n                    {\n                        ParseGfwList(response);\n                    }\n                    else if (retryTimes > 0)\n                    {\n                        ScheduleUpdateTime(30); /*Delay 30 seconds to retry*/\n                        retryTimes--;\n                    }\n                    else\n                    {\n                        retryTimes = 3; /* reset retry times, and wait next update time. */\n                    }\n                }\n                Thread.Sleep(1000);\n            }\n        }\n        class Parser\n        {\n            public string Content { get; private set; }
                this.Content = Encoding.ASCII.GetString(bytes);\n            }\n            public string[] GetLines()\n            {\n                return Content.Split(new char[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries); 
                List<string> lines = new List<string>(GetLines());
                    this.secureLocalPacUrlToggleItem = CreateMenuItem("Secure Local PAC", new EventHandler(this.SecureLocalPacUrlToggleItem_Click)),
            this.QRCodeItem = new System.Windows.Forms.MenuItem();
            if (!controller.GetConfiguration().isDefault)
                BeginInvoke(new MethodInvoker(delegate\n                {\n                    this.Hide();\n                }));\n            }\n            else\n            {\n                isFirstRun = true;
            if (PACFileChanged != null)\n            {\n                Console.WriteLine("Detected: PAC file '{0}' was {1}.", e.Name, e.ChangeType.ToString().ToLower());\n                PACFileChanged(this, new EventArgs());
            if (UserRuleFileChanged != null)\n            {\n                Console.WriteLine("Detected: User Rule file '{0}' was {1}.", e.Name, e.ChangeType.ToString().ToLower());\n                UserRuleFileChanged(this, new EventArgs());\n            }\n        }
                _process.StartInfo.UseShellExecute = false;
                _process.StartInfo.RedirectStandardOutput = true;\n                _process.StartInfo.RedirectStandardError = true;
            onlinePACItem.Enabled = !string.IsNullOrEmpty(config.pacUrl);
                localPACItem.Checked = false;\n                onlinePACItem.Checked = true;\n                controller.UseOnlinePAC(true);
using System.Collections.Generic;
using System.Text;
                System.IO.FileStream _FileStream =\n                   new System.IO.FileStream(fileName, System.IO.FileMode.Create,\n                                            System.IO.FileAccess.Write);
                while (true)
                    n = input.Read(buffer, 0, buffer.Length);\n                    if (n == 0)\n                    {\n                        break;\n                    }
                FileStream fs = new FileStream(LogFilePath, FileMode.Append);\n                StreamWriterWithTimestamp sw = new StreamWriterWithTimestamp(fs);\n                sw.AutoFlush = true;\n                Console.SetOut(sw);\n                Console.SetError(sw);
            Console.WriteLine("[E] " + o);
            Console.WriteLine(o);
            Console.WriteLine("[D] " + o);
        public void UpdatePACFromGFWList()
            http.Proxy = new WebProxy(IPAddress.Loopback.ToString(), 8123);
            CleanLogsButton.Text = I18N.GetString("&Clean Logs");
            CleanLogsMenuItem.Text = I18N.GetString("&Clean Logs");
        private void DoCleanLogs()
        private void CleanLogsMenuItem_Click(object sender, EventArgs e)\n        {\n            DoCleanLogs();\n        }\n        private void CleanLogsButton_Click(object sender, EventArgs e)\n        {\n            DoCleanLogs();
            this.CleanLogsMenuItem = new System.Windows.Forms.MenuItem();
            this.CleanLogsButton = new System.Windows.Forms.Button();
            // CleanLogsMenuItem\n            // \n            this.CleanLogsMenuItem.Index = 0;\n            this.CleanLogsMenuItem.Text = "&Clean Logs";\n            this.CleanLogsMenuItem.Click += new System.EventHandler(this.CleanLogsMenuItem_Click);
        private System.Windows.Forms.Button CleanLogsButton;
        private System.Windows.Forms.MenuItem CleanLogsMenuItem;
                        {
                        }
                if (targetIndex == -1)
                    Logging.Debug(remote.LocalEndPoint, remote.DestEndPoint, RecvSize, "TCP Relay");
                        Logging.Debug(remote.LocalEndPoint, remote.DestEndPoint, RecvSize, "TCP Relay");
                // TODO async resolving\n                IPAddress ipAddress;\n                bool parsed = IPAddress.TryParse(server.server, out ipAddress);\n                if (!parsed)\n                {\n                    IPHostEntry ipHostInfo = Dns.GetHostEntry(server.server);\n                    ipAddress = ipHostInfo.AddressList[0];\n                }\n                IPEndPoint destEP = new IPEndPoint(ipAddress, server.server_port);
                    parsed = IPAddress.TryParse(_config.proxyServer, out ipAddress);
                    proxyEP = destEP;
                proxyTimer.DestEndPoint = destEP;
        public EndPoint ProxyEndPoint { get; private set; }\n        public EndPoint DestEndPoint { get; private set; }
            ProxyEndPoint = remoteEP;
        public void BeginConnectDest(EndPoint remoteEP, AsyncCallback callback, object state)
            DestEndPoint = remoteEP;
        EndPoint DestEndPoint { get; }
        void BeginConnectDest(EndPoint remoteEP, AsyncCallback callback, object state);
            QRCode4CS.QRCode qrCoded = new QRCode4CS.QRCode(6, QRErrorCorrectLevel.H);\n            qrCoded.AddData(qrText);\n            qrCoded.Make();\n            int blockSize = 5;
            for (int row = 0; row < qrCoded.GetModuleCount(); row++)
                for (int col = 0; col < qrCoded.GetModuleCount(); col++)
                    bool isDark = qrCoded.IsDark(row, col);\n                    if (isDark)
                        for (int y = 0; y < blockSize; y++)
                            int myCol = (blockSize * (col - 1)) + (y + blockSize);\n                            for (int x = 0; x < blockSize; x++)
                                drawArea.SetPixel((blockSize * (row - 1)) + (x + blockSize), myCol, Color.Black);\n                            }\n                        }\n                    }\n                    else\n                    {\n                        for (int y = 0; y < blockSize; y++)\n                        {\n                            int myCol = (blockSize * (col - 1)) + (y + blockSize);\n                            for (int x = 0; x < blockSize; x++)\n                            {\n                                drawArea.SetPixel((blockSize * (row - 1)) + (x + blockSize), myCol, Color.White);
                Configuration config = JsonConvert.DeserializeObject<Configuration>(configContent);
                try\n                {\n                    config.nLogConfig = NLogConfig.LoadXML();\n                    switch (config.nLogConfig.GetLogLevel())\n                    {\n                        case NLogConfig.LogLevel.Fatal:\n                        case NLogConfig.LogLevel.Error:\n                        case NLogConfig.LogLevel.Warn:\n                        case NLogConfig.LogLevel.Info:\n                            config.isVerboseLogging = false;\n                            break;\n                        case NLogConfig.LogLevel.Debug:\n                        case NLogConfig.LogLevel.Trace:\n                            config.isVerboseLogging = true;\n                            break;\n                    }\n                }\n                catch (Exception e)\n                {\n                    // todo: route the error to UI since there is no log file in this scenario\n                    logger.Error(e, "Cannot get the log level from NLog config file. Please check if the nlog config file exists with corresponding XML nodes.");\n                }\n                return config;
                return new Configuration
            FontDialog fd = new FontDialog();\n            fd.Font = LogMessageTextBox.Font;\n            if (fd.ShowDialog() == DialogResult.OK)
                LogMessageTextBox.Font = fd.Font;
        ///   Looks up a localized resource of type System.Byte[].\n        /// </summary>\n        internal static byte[] polipo {\n            get {\n                object obj = ResourceManager.GetObject("polipo", resourceCulture);\n                return ((byte[])(obj));\n            }\n        }\n        /// <summary>
                if (string.IsNullOrWhiteSpace(serverUrl))
                    parsedUrl = new Uri(serverUrl);
                string possiblyUnpaddedBase64 = parsedUrl.GetComponents(UriComponents.UserInfo, UriFormat.Unescaped);\n                bool isOldFormatUrl = possiblyUnpaddedBase64.Length == 0;\n                if (isOldFormatUrl)\n                {\n                    int prefixLength = "ss://".Length;\n                    int indexOfHashOrSlash = serverUrl.LastIndexOfAny(\n                        new[] { '/', '#' },\n                        serverUrl.Length - 1,\n                        serverUrl.Length - prefixLength);\n                    int substringLength = serverUrl.Length - prefixLength;\n                    if (indexOfHashOrSlash >= 0)\n                    {\n                        substringLength = indexOfHashOrSlash - prefixLength;\n                    }\n                    possiblyUnpaddedBase64 = serverUrl.Substring(prefixLength, substringLength).TrimEnd('/');\n                }\n                else\n                {\n                    // Web-safe base64 to normal base64\n                    possiblyUnpaddedBase64 = possiblyUnpaddedBase64.Replace('-', '+').Replace('_', '/');\n                }\n                string base64 = possiblyUnpaddedBase64.PadRight(\n                    possiblyUnpaddedBase64.Length + (4 - possiblyUnpaddedBase64.Length % 4) % 4,\n                    '=');\n                string innerUserInfoOrUrl = Encoding.UTF8.GetString(Convert.FromBase64String(base64));\n                string userInfo;\n                if (isOldFormatUrl)\n                {\n                    Uri innerUrl = new Uri("inner://" + innerUserInfoOrUrl);\n                    userInfo = innerUrl.GetComponents(UriComponents.UserInfo, UriFormat.Unescaped);\n                    tmp.server = innerUrl.GetComponents(UriComponents.Host, UriFormat.Unescaped);\n                    tmp.server_port = innerUrl.Port;\n                }\n                else\n                {\n                    userInfo = innerUserInfoOrUrl;\n                    tmp.server = parsedUrl.GetComponents(UriComponents.Host, UriFormat.Unescaped);\n                    tmp.server_port = parsedUrl.Port;\n                }
            this.tableLayoutPanel1.Controls.Add(this.OneTimeAuth, 1, 6);
            this.tableLayoutPanel1.RowCount = 7;\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.Size = new System.Drawing.Size(249, 162);
            this.ProxyPortLable = new System.Windows.Forms.Label();
            this.ProxyAddrLabel.Anchor = System.Windows.Forms.AnchorStyles.Left;
            // ProxyPortLable\n            // \n            this.ProxyPortLable.Anchor = System.Windows.Forms.AnchorStyles.Left;\n            this.ProxyPortLable.AutoSize = true;\n            this.ProxyPortLable.Location = new System.Drawing.Point(215, 7);\n            this.ProxyPortLable.Name = "ProxyPortLable";\n            this.ProxyPortLable.Size = new System.Drawing.Size(65, 12);\n            this.ProxyPortLable.TabIndex = 2;\n            this.ProxyPortLable.Text = "Proxy Port";
            this.tableLayoutPanel4.ColumnCount = 2;
            this.ProxyTypeLabel.Anchor = System.Windows.Forms.AnchorStyles.Left;
            this.ProxyTypeComboBox.Dock = System.Windows.Forms.DockStyle.Fill;
        private System.Windows.Forms.Label ProxyPortLable;
        public void UpdateLatency(Server server, TimeSpan latency)\n        {
                availabilityStatistics.UpdateLatency(server, (int)latency.TotalMilliseconds);\n            }\n        }\n        public void UpdateInboundCounter(Server server, long n)\n        {\n            Interlocked.Add(ref _inboundCounter, n);
                availabilityStatistics.UpdateInboundCounter(server, n);\n            }\n        }\n        public void UpdateOutboundCounter(Server server, long n)\n        {\n            Interlocked.Add(ref _outboundCounter, n);
                availabilityStatistics.UpdateOutboundCounter(server, n);
﻿using NLog;\nusing System;
    class TCPRelay : Listener.Service
        private static Logger logger = LogManager.GetCurrentClassLogger();\n        private ShadowsocksController _controller;
        private Configuration _config;
            TCPHandler handler = new TCPHandler(_controller, _config, this, socket);
        public void UpdateInboundCounter(Server server, long n)\n        {\n            _controller.UpdateInboundCounter(server, n);\n        }\n        public void UpdateOutboundCounter(Server server, long n)\n        {\n            _controller.UpdateOutboundCounter(server, n);\n        }\n        public void UpdateLatency(Server server, TimeSpan latency)\n        {\n            _controller.UpdateLatency(server, latency);
        class AsyncSession
        class AsyncSession<T> : AsyncSession
        private static Logger Logger = LogManager.GetCurrentClassLogger();
        private ShadowsocksController _controller;\n        private Configuration _config;\n        private TCPRelay _tcprelay;\n        private Socket _connection;
        private byte[] _remoteRecvBuffer = new byte[BufferSize];
        private byte[] _connetionRecvBuffer = new byte[BufferSize];
        private byte[] _remoteSendBuffer = new byte[BufferSize];
        private byte[] _connetionSendBuffer = new byte[BufferSize];
        public TCPHandler(ShadowsocksController controller, Configuration config, TCPRelay tcprelay, Socket socket)
            _config = config;\n            _tcprelay = tcprelay;
            this._server = server;
                if (_closed) return;
            lock (_tcprelay.Handlers)\n            {\n                _tcprelay.Handlers.Remove(this);\n            }
            }\n            catch (Exception e)\n            {\n                Logger.LogUsefulException(e);\n                Close();
            if (_closed) return;
                    HandshakeReceive2Callback, null);\n            }\n            catch (Exception e)\n            {\n                Logger.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void HandshakeReceive2Callback(IAsyncResult ar)\n        {\n            if (_closed) return;
                Logger.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void ResponseCallback(IAsyncResult ar)
                Logger.LogUsefulException(e);\n                Close();
            if (_closed) return;
                var states = (object[])ar.AsyncState;
                var onSuccess = (Action)states[1];
                }\n            }\n            catch (Exception e)\n            {\n                Logger.LogUsefulException(e);\n                Close();
                    proxyEP = SocketUtil.GetEndPoint(_config.proxy.proxyServer, _config.proxy.proxyPort);
                var session = new AsyncSession(remote);
                Logger.LogUsefulException(e);\n                Close();
            var timer = (ProxyTimer)sender;
            var proxy = timer.Session.Remote;
                var session = (AsyncSession<ProxyTimer>)ar.AsyncState;
                var destEndPoint = timer.DestEndPoint;\n                var server = timer.Server;
                var remote = session.Remote;
                if (_config.proxy.useAuth)\n                {\n                    auth = new NetworkCredential(_config.proxy.authUser, _config.proxy.authPwd);
                Logger.LogUsefulException(e);\n                Close();
            var timer = (ServerTimer)sender;
            var session = timer.Session;
            IStrategy strategy = _controller.GetCurrentStrategy();\n            strategy?.SetFailure(server);
            if (_closed) return;\n            try\n            {\n                var session = (AsyncSession<ServerTimer>)ar.AsyncState;
                var remote = session.Remote;
                var latency = DateTime.Now - _startConnectTime;\n                IStrategy strategy = _controller.GetCurrentStrategy();\n                strategy?.UpdateLatency(_server, latency);\n                _tcprelay.UpdateLatency(_server, latency);
                    IStrategy strategy = _controller.GetCurrentStrategy();\n                    strategy?.SetFailure(_server);\n                }\n                Logger.LogUsefulException(e);\n                Close();
                var size = _connection.Receive(_connetionRecvBuffer, _firstPacketLength, available,
            if (_closed) return;
                Logger.LogUsefulException(e);\n                Close();
            if (_closed) return;\n            try\n            {\n                var session = (AsyncSession)ar.AsyncState;
                _tcprelay.UpdateInboundCounter(_server, bytesRead);
                Logger.LogUsefulException(e);\n                Close();
            if (_closed) return;
                var session = (AsyncSession)ar.AsyncState;\n                var remote = session.Remote;
            _tcprelay.UpdateOutboundCounter(_server, bytesToSend);
            IStrategy strategy = _controller.GetCurrentStrategy();\n            strategy?.UpdateLastWrite(_server);
            if (_closed) return;\n            try\n            {\n                var container = (object[])ar.AsyncState;\n                var session = (AsyncSession)container[0];\n                var bytesShouldSend = (int)container[1];
                Logger.LogUsefulException(e);\n                Close();
                var container = (object[])ar.AsyncState;\n                var session = (AsyncSession)container[0];\n                var bytesShouldSend = (int)container[1];\n                var bytesSent = _connection.EndSend(ar);\n                var bytesRemaining = bytesShouldSend - bytesSent;
            "table",
            "aes-128-cfb",\n            "rc4"});
        private static bool encryptionFailed = false;\n        private static object locker = new object();
                    for (int i = 0; i < 100; i++)\n                    {\n                        var random = new Random();\n                        IEncryptor encryptor;\n                        IEncryptor decryptor;\n                        encryptor = new PolarSSLEncryptor("aes-256-cfb", "barfoo!");\n                        decryptor = new PolarSSLEncryptor("aes-256-cfb", "barfoo!");\n                        byte[] plain = new byte[16384];\n                        byte[] cipher = new byte[plain.Length + 16];\n                        byte[] plain2 = new byte[plain.Length + 16];\n                        int outLen = 0;\n                        int outLen2 = 0;\n                        random.NextBytes(plain);\n                        //lock (locker)\n                        //{\n                            encryptor.Encrypt(plain, plain.Length, cipher, out outLen);\n                            decryptor.Decrypt(cipher, outLen, plain2, out outLen2);\n                            Assert.AreEqual(plain.Length, outLen2);\n                            for (int j = 0; j < plain.Length; j++)\n                            {\n                                Assert.AreEqual(plain[j], plain2[j]);\n                            }\n                            encryptor.Encrypt(plain, 1000, cipher, out outLen);\n                            decryptor.Decrypt(cipher, outLen, plain2, out outLen2);\n                            Assert.AreEqual(1000, outLen2);\n                            for (int j = 0; j < outLen2; j++)\n                            {\n                                Assert.AreEqual(plain[j], plain2[j]);\n                            }\n                            encryptor.Encrypt(plain, 12333, cipher, out outLen);\n                            decryptor.Decrypt(cipher, outLen, plain2, out outLen2);\n                            Assert.AreEqual(12333, outLen2);\n                            for (int j = 0; j < outLen2; j++)\n                            {\n                                Assert.AreEqual(plain[j], plain2[j]);\n                            }\n                        //}\n                    }
            this.tableLayoutPanel1 = new System.Windows.Forms.TableLayoutPanel();\n            this.tableLayoutPanel3 = new System.Windows.Forms.TableLayoutPanel();
            this.tableLayoutPanel2 = new System.Windows.Forms.TableLayoutPanel();
            this.tableLayoutPanel4 = new System.Windows.Forms.TableLayoutPanel();
            this.tableLayoutPanel3.SuspendLayout();\n            this.tableLayoutPanel2.SuspendLayout();\n            this.tableLayoutPanel4.SuspendLayout();
            this.MyCancelButton.Dock = System.Windows.Forms.DockStyle.Right;
            this.OKButton.Dock = System.Windows.Forms.DockStyle.Right;
            this.tableLayoutPanel3.ResumeLayout(false);\n            this.tableLayoutPanel2.ResumeLayout(false);\n            this.tableLayoutPanel2.PerformLayout();\n            this.tableLayoutPanel4.ResumeLayout(false);\n            this.tableLayoutPanel4.PerformLayout();
            this.PerformLayout();
        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel1;
        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel2;
        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel3;
        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel4;
            this.QRCodeItem = new System.Windows.Forms.MenuItem();
            this.LockButton = new System.Windows.Forms.Button();\n            this.panel4 = new System.Windows.Forms.Panel();
            this.panel4.SuspendLayout();
            this.CancelButton = this.MyCancelButton;
            this.Controls.Add(this.panel4);
            this.TopMost = true;
            this.panel4.ResumeLayout(false);
            if (controller == null || controller.GetConfiguration().isDefault)\n            {\n                _isFirstRun = true;
                this.Opacity = 0;\n                BeginInvoke(new MethodInvoker(delegate { this.Hide(); }));
            IPAddress addr;\n            if ( !IPAddress.TryParse( server, out addr ) ) {\n                Logging.Error( "Invalid server IP Address" );
            if ( remarks.IsNullOrEmpty() ) {\n                switch ( addr.AddressFamily ) {\n                    case AddressFamily.InterNetwork:\n                        return $"{server}:{server_port}";\n                    case AddressFamily.InterNetworkV6:\n                        return $"[{server}]:{server_port}";\n                }\n            } else {\n                switch ( addr.AddressFamily ) {\n                    case AddressFamily.InterNetwork:\n                        return $"{remarks} ({server}:{server_port})";\n                    case AddressFamily.InterNetworkV6:\n                        return $"{remarks} ([{server}]:{server_port})";\n                }
            // If reached here, boom.\n            return null;
            this.ClientSize = new System.Drawing.Size(204, 202);
        private void controller_TrafficChanged(object sender, EventArgs e)\n        {
            inboundPoints.Clear();\n            outboundPoints.Clear();\n            foreach (var trafficPerSecond in controller.traffic)\n            {\n                inboundPoints.Add(trafficPerSecond.inboundIncreasement);\n                outboundPoints.Add(trafficPerSecond.outboundIncreasement);\n                maxSpeed = Math.Max(maxSpeed, Math.Max(trafficPerSecond.inboundIncreasement, trafficPerSecond.outboundIncreasement));
            try\n            {\n                if (trafficChart.InvokeRequired && trafficChart.IsHandleCreated)\n                {\n                    trafficChart.Invoke(new Action(() =>\n                    {\n                        trafficChart.Series["Inbound"].Points.DataBindY(inboundPoints);\n                        trafficChart.Series["Outbound"].Points.DataBindY(outboundPoints);\n                        trafficChart.ChartAreas[0].AxisY.LabelStyle.Format = "{0:0.##} " + bandwidthScale.Item2;\n                        inboundAnnotation.AnchorDataPoint = trafficChart.Series["Inbound"].Points.Last();\n                        inboundAnnotation.Text = Utils.FormatBandwidth(controller.traffic.Last.inboundIncreasement);\n                        outboundAnnotation.AnchorDataPoint = trafficChart.Series["Outbound"].Points.Last();\n                        outboundAnnotation.Text = Utils.FormatBandwidth(controller.traffic.Last.outboundIncreasement);\n                        trafficChart.Annotations.Clear();\n                        trafficChart.Annotations.Add(inboundAnnotation);\n                        trafficChart.Annotations.Add(outboundAnnotation);\n                    }));\n                }\n            }\n            catch (ObjectDisposedException)\n            {\n                // suppress the thread race error:\n                // when closing the form but the Invoked Action is still working and cause 'Chart is Disposed' exception
            this.PluginTextBox.Margin = new System.Windows.Forms.Padding(4, 4, 4, 4);
            this.RemarksTextBox.Margin = new System.Windows.Forms.Padding(4, 4, 4, 4);
            this.IPTextBox.Margin = new System.Windows.Forms.Padding(4, 4, 4, 4);
            this.ServerPortTextBox.Margin = new System.Windows.Forms.Padding(4, 4, 4, 4);
            this.PasswordTextBox.Margin = new System.Windows.Forms.Padding(4, 4, 4, 4);
            this.PluginOptionsTextBox.Margin = new System.Windows.Forms.Padding(4, 4, 4, 4);
            this.ShowPasswdCheckBox.Margin = new System.Windows.Forms.Padding(4, 4, 4, 4);
            this.PluginArgumentsTextBox.Margin = new System.Windows.Forms.Padding(4, 4, 4, 4);
            this.tableLayoutPanel5.Padding = new System.Windows.Forms.Padding(4, 4, 4, 4);
            this.ProxyPortTextBox.Margin = new System.Windows.Forms.Padding(4, 4, 4, 4);
        public static readonly DateTime UnknownDateTime;
            UnknownDateTime = new DateTime(1970, 1, 1);
            this.allMode.Checked = true;
            this.allMode.TabStop = true;
            this.splitContainer3.Size = new System.Drawing.Size(700, 252);\n            this.splitContainer3.SplitterDistance = 46;\n            this.splitContainer3.SplitterWidth = 10;
            this.label1.Text = "Design evaluation method";
        public TCPRelay(ShadowsocksController controller)
            TCPHandler handler = new TCPHandler(this);
        public TCPHandler(TCPRelay tcprelay)
                            if ( controller.GetCurrentConfiguration().isVerboseLogging ) {
                            if ( controller.GetCurrentConfiguration().isVerboseLogging ) {
                            if ( controller.GetCurrentConfiguration().isVerboseLogging ) {
        void controller_UpdatePACFromGFWListError(object sender, System.IO.ErrorEventArgs e)\n        {\n            isUpdatePACFromGFWListRunning = false;\n            _notifyIcon.BalloonTipTitle = I18N.GetString("Update PAC File via gfwlist...");\n            _notifyIcon.BalloonTipText = I18N.GetString("Update PAC file failed");\n            _notifyIcon.BalloonTipIcon = ToolTipIcon.Info;\n            _notifyIcon.ShowBalloonTip(5000);
            isUpdatePACFromGFWListRunning = false;\n            _notifyIcon.BalloonTipTitle = I18N.GetString("Update PAC File via gfwlist...");\n            _notifyIcon.BalloonTipText = I18N.GetString("Update PAC file succeed");\n            _notifyIcon.BalloonTipIcon = ToolTipIcon.Info;\n            _notifyIcon.ShowBalloonTip(5000);
            _notifyIcon.BalloonTipTitle = String.Format(I18N.GetString("Shadowsocks {0} Update Found"), updateChecker.LatestVersionNumber);\n            _notifyIcon.BalloonTipText = I18N.GetString("Click here to download");\n            _notifyIcon.BalloonTipIcon = ToolTipIcon.Info;
            _notifyIcon.ShowBalloonTip(5000);
                if (_config.useProxy)
                    proxyEP = SocketUtil.GetEndPoint(_config.proxyServer, _config.proxyPort);
            _config.useProxy = false;
            _config.useProxy = true;\n            _config.proxyServer = proxy;\n            _config.proxyPort = port;
            UrlFinder = new Regex("^(?i)ss://([A-Za-z0-9+-/=_]+)(#(.+))?$",\n                                  RegexOptions.IgnoreCase | RegexOptions.Compiled),
                                      ":(?<port>\\d+?))$", RegexOptions.Compiled | RegexOptions.IgnoreCase);
                    var type = ProxyTypeComboBox.SelectedIndex;\n                    var proxy = ProxyServerTextBox.Text;\n                    var port = int.Parse(ProxyPortTextBox.Text);\n                    var timeout = int.Parse(ProxyTimeoutTextBox.Text);\n                    Configuration.CheckServer(proxy);\n                    Configuration.CheckPort(port);\n                    Configuration.CheckTimeout(timeout, ProxyConfig.MaxProxyTimeoutSec);\n                    controller.EnableProxy(type, proxy, port);
            _modifiedConfiguration.proxyType = ProxyTypeComboBox.SelectedIndex;\n            _modifiedConfiguration.proxyServer = ProxyServerTextBox.Text;\n            var tmpProxyPort = 0;\n            int.TryParse(ProxyPortTextBox.Text, out tmpProxyPort);\n            _modifiedConfiguration.proxyPort = tmpProxyPort;\n            var tmpProxyTimeout = 0;\n            int.TryParse(ProxyTimeoutTextBox.Text, out tmpProxyTimeout);\n            _modifiedConfiguration.proxyTimeout = tmpProxyTimeout;
                Server server = new Server\n                {\n                    server = IPTextBox.Text.Trim(),\n                    server_port = int.Parse(ServerPortTextBox.Text),\n                    password = PasswordTextBox.Text,\n                    method = EncryptionSelect.Text,\n                    remarks = RemarksTextBox.Text,\n                    timeout = int.Parse(TimeoutTextBox.Text),\n                    auth = OneTimeAuth.Checked\n                };
            }\n            catch (FormatException)\n            {\n                MessageBox.Show(I18N.GetString("Illegal port number format"));
            this.QRCodeWebBrowser = new System.Windows.Forms.WebBrowser();
            // \n            // QRCodeWebBrowser\n            // \n            this.QRCodeWebBrowser.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) \n            | System.Windows.Forms.AnchorStyles.Left) \n            | System.Windows.Forms.AnchorStyles.Right)));\n            this.QRCodeWebBrowser.Location = new System.Drawing.Point(0, 0);\n            this.QRCodeWebBrowser.Margin = new System.Windows.Forms.Padding(0);\n            this.QRCodeWebBrowser.MinimumSize = new System.Drawing.Size(20, 20);\n            this.QRCodeWebBrowser.Name = "QRCodeWebBrowser";\n            this.QRCodeWebBrowser.ScriptErrorsSuppressed = true;\n            this.QRCodeWebBrowser.ScrollBarsEnabled = false;\n            this.QRCodeWebBrowser.Size = new System.Drawing.Size(201, 203);\n            this.QRCodeWebBrowser.TabIndex = 0;
            this.pictureBox1.Location = new System.Drawing.Point(0, 0);
            this.pictureBox1.Size = new System.Drawing.Size(205, 205);
            this.AutoSize = true;\n            this.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;\n            this.ClientSize = new System.Drawing.Size(205, 205);\n            this.Controls.Add(this.pictureBox1);\n            this.Controls.Add(this.QRCodeWebBrowser);
        private System.Windows.Forms.WebBrowser QRCodeWebBrowser;
        public TCPHandler(ShadowsocksController controller, Configuration config, TCPRelay tcprelay, Socket socket)
            _tcprelay = tcprelay;
        public void AskAddServerBySSURL(string ssURL)
                AddServerBySSURL(ssURL);\n            }
                return;\n            }\n            List<string> lines = new List<string>();\n            if (File.Exists(PACServer.USER_RULE_FILE))\n            {\n                string local = FileManager.NonExclusiveReadAllText(PACServer.USER_RULE_FILE, Encoding.UTF8);\n                using (var sr = new StringReader(local))\n                {\n                    foreach (var rule in sr.NonWhiteSpaceLines())\n                    {\n                        if (rule.BeginWithAny(IgnoredLineBegins))\n                            continue;\n                        lines.Add(rule);\n                    }\n                }\n            }\n            lines.AddRange(GFWListUpdater.ParseResult(FileManager.NonExclusiveReadAllText(Utils.GetTempPath("gfwlist.txt"))));\n            string abpContent;\n            if (File.Exists(PACServer.USER_ABP_FILE))\n            {\n                abpContent = FileManager.NonExclusiveReadAllText(PACServer.USER_ABP_FILE, Encoding.UTF8);
                abpContent = Utils.UnGzip(Resources.abp_js);\n            }\n            abpContent = abpContent.Replace("__RULES__", JsonConvert.SerializeObject(lines, Formatting.Indented));\n            if (File.Exists(PACServer.PAC_FILE))\n            {\n                string original = FileManager.NonExclusiveReadAllText(PACServer.PAC_FILE, Encoding.UTF8);\n                if (original == abpContent)\n                {\n                    return;\n                }\n            }\n            File.WriteAllText(PACServer.PAC_FILE, abpContent, Encoding.UTF8);
                List<string> lines = new List<string>();\n                if (File.Exists(PACServer.USER_RULE_FILE))\n                {\n                    string local = FileManager.NonExclusiveReadAllText(PACServer.USER_RULE_FILE, Encoding.UTF8);\n                    using (var sr = new StringReader(local))\n                    {\n                        foreach (var rule in sr.NonWhiteSpaceLines())\n                        {\n                            if (rule.BeginWithAny(IgnoredLineBegins))\n                                continue;\n                            lines.Add(rule);\n                        }\n                    }\n                }\n                lines.AddRange(ParseResult(e.Result));\n                string abpContent;\n                if (File.Exists(PACServer.USER_ABP_FILE))\n                {\n                    abpContent = FileManager.NonExclusiveReadAllText(PACServer.USER_ABP_FILE, Encoding.UTF8);\n                }\n                else\n                {\n                    abpContent = Utils.UnGzip(Resources.abp_js);\n                }\n                abpContent = abpContent.Replace("__RULES__", JsonConvert.SerializeObject(lines, Formatting.Indented));\n                if (File.Exists(PACServer.PAC_FILE))\n                {\n                    string original = FileManager.NonExclusiveReadAllText(PACServer.PAC_FILE, Encoding.UTF8);\n                    if (original == abpContent)\n                    {\n                        UpdateCompleted(this, new ResultEventArgs(false));\n                        return;\n                    }\n                }\n                File.WriteAllText(PACServer.PAC_FILE, abpContent, Encoding.UTF8);\n                UpdateCompleted?.Invoke(this, new ResultEventArgs(true));
        public const int BufferSize = RecvSize + (RecvSize / IVEncryptor.CRC_BUF_LEN + 1) * IVEncryptor.CRC_BYTES + 48;
        private byte[] remoteRecvBuffer = new byte[RecvSize];
        private byte[] connetionRecvBuffer = new byte[RecvSize];
                server.server = IPTextBox.Text.Trim();\n                try\n                {\n                    server.server_port = int.Parse(ServerPortTextBox.Text);\n                }\n                catch (FormatException)
                    ServerPortTextBox.Clear();
                try\n                {\n                    server.timeout = int.Parse(TimeoutTextBox.Text);\n                }\n                catch (FormatException)
                    TimeoutTextBox.Clear();
            if (socket.ProtocolType != ProtocolType.Tcp)\n            {
            }\n            if (length < 2 || firstPacket[0] != 5)\n            {\n                return false;\n            }\n            socket.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n            TCPHandler handler = new TCPHandler(this);\n            handler.connection = socket;\n            handler.controller = _controller;\n            handler.tcprelay = this;\n            handler.Start(firstPacket, length);\n            IList<TCPHandler> handlersToClose = new List<TCPHandler>();\n            lock (Handlers)\n            {\n                Handlers.Add(handler);\n                DateTime now = DateTime.Now;\n                if (now - _lastSweepTime > TimeSpan.FromSeconds(1))\n                {\n                    _lastSweepTime = now;\n                    foreach (TCPHandler handler1 in Handlers)\n                    {\n                        if (now - handler1.lastActivity > TimeSpan.FromSeconds(900))\n                        {\n                            handlersToClose.Add(handler1);\n                        }\n                    }\n                }\n            }\n            foreach (TCPHandler handler1 in handlersToClose)\n            {\n                Logging.Debug("Closing timed out TCP connection.");\n                handler1.Close();\n            }\n            return true;
            this._tcprelay = tcprelay;
            {
            }
                {
                }\n                _closed = true;\n            }\n            if (connection != null)\n            {\n                try\n                {\n                    connection.Shutdown(SocketShutdown.Both);\n                    connection.Close();\n                }\n                catch (Exception e)\n                {\n                    Logging.LogUsefulException(e);\n                }\n            }\n            if (remote != null)\n            {\n                try\n                {\n                    remote.Shutdown(SocketShutdown.Both);\n                    remote.Close();\n                }\n                catch (Exception e)\n                {\n                    Logging.LogUsefulException(e);\n                }
                    if (encryptor != null)\n                    {\n                        ((IDisposable)encryptor).Dispose();\n                    }
            if (_closed)\n            {\n                return;\n            }
                {
                }
            if (_closed)\n            {\n                return;\n            }
                    {
                    }
            if (endPoint.AddressFamily == AddressFamily.InterNetwork)\n            {\n                response[3] = 1;\n            }\n            else if (endPoint.AddressFamily == AddressFamily.InterNetworkV6)\n            {\n                response[3] = 4;
            if (_closed)\n            {\n                return;\n            }
                    {
                    }
            if (_connected)\n            {\n                return;\n            }
            if (strategy != null)\n            {\n                strategy.SetFailure(server);\n            }
            {\n                Close();\n            }
            Server server = null;\n            if (_closed)\n            {\n                return;\n            }
                server = timer.Server;
                    if (strategy != null)\n                    {\n                        strategy.SetFailure(server);\n                    }
            if (_closed)\n            {\n                return;\n            }
                        if (_closed)\n                        {\n                            return;\n                        }
                    if (strategy != null)\n                    {\n                        strategy.UpdateLastRead(server);\n                    }
                    -2 * 5 * (Math.Min(2000, status.latency.TotalMilliseconds) / (1 + (now - status.lastTimeDetectLatency).TotalSeconds / 30 / 2) +
            var serverUrls = ssURL.Split('\r', '\n', ' ');\n            List<Server> servers = new List<Server>();\n            foreach (string serverUrl in serverUrls)\n            {\n                string _serverUrl = serverUrl.Trim();\n                if (!_serverUrl.BeginWith("ss://", StringComparison.InvariantCultureIgnoreCase))\n                {\n                    continue;\n                }\n                Server legacyServer = ParseLegacyURL(serverUrl);\n                if (legacyServer != null)   //legacy\n                {\n                    servers.Add(legacyServer);\n                }\n                else   //SIP002\n                {\n                    Uri parsedUrl;\n                    try\n                    {\n                        parsedUrl = new Uri(serverUrl);\n                    }\n                    catch (UriFormatException)\n                    {\n                        continue;\n                    }\n                    Server server = new Server\n                    {\n                        remarks = parsedUrl.GetComponents(UriComponents.Fragment, UriFormat.Unescaped),\n                        server = parsedUrl.IdnHost,\n                        server_port = parsedUrl.Port,\n                    };\n                    // parse base64 UserInfo\n                    string rawUserInfo = parsedUrl.GetComponents(UriComponents.UserInfo, UriFormat.Unescaped);\n                    string base64 = rawUserInfo.Replace('-', '+').Replace('_', '/');    // Web-safe base64 to normal base64\n                    string userInfo = "";\n                    try\n                    {\n                        userInfo = Encoding.UTF8.GetString(Convert.FromBase64String(\n                        base64.PadRight(base64.Length + (4 - base64.Length % 4) % 4, '=')));\n                    }\n                    catch (FormatException)\n                    {\n                        continue;\n                    }\n                    string[] userInfoParts = userInfo.Split(new char[] { ':' }, 2);\n                    if (userInfoParts.Length != 2)\n                    {\n                        continue;\n                    }\n                    server.method = userInfoParts[0];\n                    server.password = userInfoParts[1];\n                    NameValueCollection queryParameters = HttpUtility.ParseQueryString(parsedUrl.Query);\n                    string[] pluginParts = (queryParameters["plugin"] ?? "").Split(new[] { ';' }, 2);\n                    if (pluginParts.Length > 0)\n                    {\n                        server.plugin = pluginParts[0] ?? "";\n                    }\n                    if (pluginParts.Length > 1)\n                    {\n                        server.plugin_opts = pluginParts[1] ?? "";\n                    }\n                    servers.Add(server);\n                }\n            }\n            return servers;
            using (StreamReader reader = new StreamReader(new FileStream(filename,\n                     FileMode.Open, FileAccess.Read, FileShare.ReadWrite)))\n            {\n                reader.BaseStream.Seek(lastOffset, SeekOrigin.Begin);\n                string line = "";\n                bool changed = false;\n                while ((line = reader.ReadLine()) != null)\n                {\n                    changed = true;\n                    LogMessageTextBox.AppendText(line + Environment.NewLine);
                if (changed)\n                {\n                    LogMessageTextBox.ScrollToCaret();\n                }\n                lastOffset = reader.BaseStream.Position;
                FileStream fs = new FileStream(LogFilePath, FileMode.Append);\n                StreamWriterWithTimestamp sw = new StreamWriterWithTimestamp(fs);
            Console.WriteLine(o);
            UpdateSystemProxy();
            UpdateSystemProxy();
            UpdateSystemProxy();
            UpdateSystemProxy();
using System.Collections.Generic;\nusing System.ComponentModel;
using System.Net.NetworkInformation;
using System.Runtime.InteropServices;
                _runningPort = this.GetFreePort();
                FileManager.ByteArrayToFile(Utils.GetTempPath(UniqueConfigFile), Encoding.UTF8.GetBytes(privoxyConfig));\n                _process = new Process();\n                // Configure the process using the StartInfo properties.\n                _process.StartInfo.FileName = "ss_privoxy.exe";\n                _process.StartInfo.Arguments = UniqueConfigFile;\n                _process.StartInfo.WorkingDirectory = Utils.GetTempPath();\n                _process.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;\n                _process.StartInfo.UseShellExecute = true;\n                _process.StartInfo.CreateNoWindow = true;
            RefreshTrayArea();
            RefreshTrayArea();
            this.panel1 = new System.Windows.Forms.Panel();
            this.panel1.SuspendLayout();
            this.pictureBox1.Dock = System.Windows.Forms.DockStyle.Fill;\n            this.pictureBox1.Location = new System.Drawing.Point(10, 10);
            this.pictureBox1.Size = new System.Drawing.Size(204, 202);\n            this.pictureBox1.SizeMode = System.Windows.Forms.PictureBoxSizeMode.StretchImage;
            // panel1\n            // \n            this.panel1.Controls.Add(this.pictureBox1);\n            this.panel1.Dock = System.Windows.Forms.DockStyle.Fill;\n            this.panel1.Location = new System.Drawing.Point(0, 0);\n            this.panel1.Margin = new System.Windows.Forms.Padding(0);\n            this.panel1.Name = "panel1";\n            this.panel1.Padding = new System.Windows.Forms.Padding(10);\n            this.panel1.Size = new System.Drawing.Size(224, 222);\n            this.panel1.TabIndex = 2;\n            // 
            this.ClientSize = new System.Drawing.Size(224, 222);\n            this.Controls.Add(this.panel1);
            this.panel1.ResumeLayout(false);
        private System.Windows.Forms.Panel panel1;
        private readonly ConcurrentDictionary<string, long> _inboundCounter = new ConcurrentDictionary<string, long>();\n        private readonly ConcurrentDictionary<string, long> _lastInboundCounter = new ConcurrentDictionary<string, long>();
        private readonly ConcurrentDictionary<string, long> _outboundCounter = new ConcurrentDictionary<string, long>();\n        private readonly ConcurrentDictionary<string, long> _lastOutboundCounter = new ConcurrentDictionary<string, long>();
            foreach (var kv in _lastInboundCounter)
                var lastInbound = kv.Value;\n                var inbound = _inboundCounter[id];\n                var bytes = inbound - lastInbound;\n                _lastInboundCounter[id] = inbound;\n                var inboundSpeed = GetSpeedInKiBPerSecond(bytes, _monitorInterval.TotalSeconds);\n                _inboundSpeedRecords.GetOrAdd(id, (k) =>\n                {\n                    List<int> records = new List<int>();\n                    records.Add(inboundSpeed);\n                    return records;\n                });\n                var lastOutbound = _lastOutboundCounter[id];\n                var outbound = _outboundCounter[id];\n                bytes = outbound - lastOutbound;\n                _lastOutboundCounter[id] = outbound;\n                var outboundSpeed = GetSpeedInKiBPerSecond(bytes, _monitorInterval.TotalSeconds);\n                _outboundSpeedRecords.GetOrAdd(id, (k) =>\n                {\n                    List<int> records = new List<int>();\n                    records.Add(outboundSpeed);\n                    return records;\n                });
            _inboundCounter.AddOrUpdate(server.Identifier(), (k) =>\n            {\n                _lastInboundCounter.GetOrAdd(server.Identifier(), 0);\n                return n;\n            }, (k, v) => (v + n));
            _outboundCounter.AddOrUpdate(server.Identifier(), (k) =>\n            {\n                _lastOutboundCounter.GetOrAdd(server.Identifier(), 0);\n                return n;\n            }, (k, v) => (v + n));
            if (string.IsNullOrEmpty(password))
            if (string.IsNullOrEmpty(server))
            if (string.IsNullOrEmpty(server))
            if (string.IsNullOrEmpty(remarks))
                if (String.IsNullOrEmpty(controller.GetConfigurationCopy().pacUrl))
                if (!String.IsNullOrEmpty(controller.GetConfigurationCopy().pacUrl))
                MD5 md5 = MD5.Create();
                    md5sum = md5.ComputeHash(password);
                    md5sum = md5.ComputeHash(result);
            this.ShareOverLANItem.Index = 1;
            this.ServersItem.Index = 2;
                            float minX = Int32.MaxValue, minY = Int32.MaxValue, maxX = 0, maxY = 0;
        FileSystemWatcher watcher;
            if (watcher != null)\n            {\n                watcher.Dispose();\n            }\n            watcher = new FileSystemWatcher(Directory.GetCurrentDirectory());\n            watcher.NotifyFilter = NotifyFilters.LastWrite | NotifyFilters.FileName | NotifyFilters.DirectoryName;\n            watcher.Filter = PAC_FILE;\n            watcher.Changed += Watcher_Changed;\n            watcher.Created += Watcher_Changed;\n            watcher.Deleted += Watcher_Changed;\n            watcher.Renamed += Watcher_Changed;\n            watcher.EnableRaisingEvents = true;\n        }\n        private void Watcher_Changed(object sender, FileSystemEventArgs e)
                int targetIndex = 0;\n                for (int i = 1; i < localeNames.Length; i++)
                    }\n                    if (localeNames[i] == locale)\n                    {\n                        targetIndex = i;
                    if (string.IsNullOrWhiteSpace(translations[0])) continue;
                    _strings[translations[enIndex]] = translations[targetIndex];
            Init(Resources.i18n_csv, CultureInfo.CurrentCulture.IetfLanguageTag);
            ((System.ComponentModel.ISupportInitialize)(this.bindingConfiguration)).BeginInit();
            public string Timestamp;
            int prefixLength = "ss://".Length;
                // Decode the Base64 part of Uri\n                int indexOfHashOrSlash = _serverUrl.IndexOfAny(new[] { '@', '/', '#' }, \n                                                               prefixLength, _serverUrl.Length - prefixLength);\n                string webSafeBase64Str = indexOfHashOrSlash == -1 ?\n                    _serverUrl.Substring(prefixLength) :\n                    _serverUrl.Substring(prefixLength, indexOfHashOrSlash - prefixLength);\n                string base64Str = webSafeBase64Str.Replace('-', '+').Replace('_', '/');\n                string base64 = base64Str.PadRight(base64Str.Length + (4 - base64Str.Length % 4) % 4, '=');\n                string decodedBase64 = Encoding.UTF8.GetString(Convert.FromBase64String(base64));\n                string decodedServerUrl = serverUrl.Replace(webSafeBase64Str, decodedBase64);\n                Uri parsedUrl;\n                try
                    parsedUrl = new Uri(decodedServerUrl);
                catch (UriFormatException)
                    continue;
                Server tmp = new Server\n                {\n                    remarks = parsedUrl.GetComponents(UriComponents.Fragment, UriFormat.Unescaped)\n                };\n                string userInfo = parsedUrl.GetComponents(UriComponents.UserInfo, UriFormat.Unescaped);\n                tmp.server = parsedUrl.GetComponents(UriComponents.Host, UriFormat.Unescaped);\n                tmp.server_port = parsedUrl.Port;\n                string[] userInfoParts = userInfo.Split(new[] { ':' }, 2);\n                if (userInfoParts.Length != 2)\n                {\n                    continue;\n                }\n                tmp.method = userInfoParts[0];\n                tmp.password = userInfoParts[1];\n                NameValueCollection queryParameters = HttpUtility.ParseQueryString(parsedUrl.Query);\n                string[] pluginParts = HttpUtility.UrlDecode(queryParameters["plugin"] ?? "").Split(new[] { ';' }, 2);\n                if (pluginParts.Length > 0)\n                {\n                    tmp.plugin = pluginParts[0] ?? "";\n                }\n                if (pluginParts.Length > 1)\n                {\n                    tmp.plugin_opts = pluginParts[1] ?? "";\n                }\n                servers.Add(tmp);
        protected byte[] _encryptBuf;\n        protected byte[] _decryptBuf;
            _encryptBuf = new byte[MAX_INPUT_SIZE + SODIUM_BLOCK_SIZE];\n            _decryptBuf = new byte[MAX_INPUT_SIZE + SODIUM_BLOCK_SIZE];
            byte[] sodiumBuf;
            if (isCipher)
                bytesRemaining = _encryptBytesRemaining;\n                ic = _encryptIC;\n                sodiumBuf = _encryptBuf;\n                iv = _encryptIV;\n            }\n            else\n            {\n                bytesRemaining = _decryptBytesRemaining;\n                ic = _decryptIC;\n                sodiumBuf = _decryptBuf;\n                iv = _decryptIV;\n            }\n            int padding = bytesRemaining;\n            Buffer.BlockCopy(buf, 0, sodiumBuf, padding, length);\n            switch (_cipher)\n            {\n                case CIPHER_SALSA20:\n                    Sodium.crypto_stream_salsa20_xor_ic(sodiumBuf, sodiumBuf, (ulong)(padding + length), iv, ic, _key);\n                    break;\n                case CIPHER_CHACHA20:\n                    Sodium.crypto_stream_chacha20_xor_ic(sodiumBuf, sodiumBuf, (ulong)(padding + length), iv, ic, _key);\n                    break;\n            }\n            Buffer.BlockCopy(sodiumBuf, padding, outbuf, 0, length);\n            padding += length;\n            ic += (ulong)padding / SODIUM_BLOCK_SIZE;\n            bytesRemaining = padding % SODIUM_BLOCK_SIZE;\n            if (isCipher)\n            {\n                _encryptBytesRemaining = bytesRemaining;\n                _encryptIC = ic;\n            }\n            else\n            {\n                _decryptBytesRemaining = bytesRemaining;\n                _decryptIC = ic;
                    int strlen = IPAddress.NetworkToHostOrder(BitConverter.ToInt32(buf, 0));\n                    await stream.ReadAsync(buf, 0, strlen);\n                    string url = Encoding.UTF8.GetString(buf, 0, strlen);\n                    Console.WriteLine(url);
            polipoRunner = new PolipoRunner();\n            polipoRunner.Start(_config);\n            local = new Local(_config);\n            try\n            {\n                local.Start();\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine(e);\n            }\n            try\n            {\n                pacServer = new PACServer();\n                pacServer.PACFileChanged += pacServer_PACFileChanged;\n                pacServer.Start(_config);\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine(e);\n            }\n            UpdateSystemProxy();\n            StartReleasingMemory();
        protected void SaveConfig(Configuration newConfig)\n        {\n            Configuration.Save(newConfig);
            local.Stop();
            polipoRunner.Start(_config);\n            local = new Local(_config);\n            local.Start();\n            pacServer.Start(_config);
                controller.GetCurrentStrategy().UpdateLatency(server, latency);
                    controller.GetCurrentStrategy().SetFailure(server);
        private MenuItem SeperatorItem3;\n        private MenuItem editPACFileItem;\n        private MenuItem QRCodeItem;\n        private MenuItem ShowLogItem;\n        private MenuItem aboutItem;
        private MenuItem SeperatorItem4;\n        private MenuItem quitItem;\n        private MenuItem SeperatorItem2;\n        private MenuItem modeItem;
            this.modeItem = CreateMenuGroup(1, "Mode", new System.Windows.Forms.MenuItem[] {\n            this.PACModeItem,\n            this.globalModeItem});
            this.SeperatorItem,\n            this.ConfigItem});\n            this.SeperatorItem2 = CreateSeperatorItem(3);
            this.editPACFileItem = CreateMenuItem(6, "Edit PAC File...", new System.EventHandler(this.EditPACFileItem_Click));\n            this.SeperatorItem3 = CreateSeperatorItem(7);\n            this.QRCodeItem = CreateMenuItem(8, "Show QRCode...", new System.EventHandler(this.QRCodeItem_Click));\n            this.ShowLogItem = CreateMenuItem(9, "Show Logs...", new System.EventHandler(this.ShowLogItem_Click));\n            this.aboutItem = CreateMenuItem(10, "About...", new System.EventHandler(this.Config_Click));\n            this.SeperatorItem4 = CreateSeperatorItem(11);\n            this.quitItem = CreateMenuItem(12, "Quit", new System.EventHandler(this.Quit_Click));\n            // \n            // contextMenu1\n            // 
            this.modeItem,
            this.SeperatorItem2,
            this.editPACFileItem,\n            this.SeperatorItem3,\n            this.QRCodeItem,\n            this.ShowLogItem,\n            this.aboutItem,\n            this.SeperatorItem4,\n            this.quitItem});
                XmlDocument xmlDoc = new XmlDocument();\n                xmlDoc.LoadXml(response);\n                XmlNodeList elements = xmlDoc.GetElementsByTagName("media:content");
                foreach (XmlNode el in elements)
                    foreach (XmlAttribute attr in el.Attributes)
                        if (attr.Name == "url")
                            if (IsNewVersion(attr.Value))\n                            {\n                                versions.Add(attr.Value);\n                            }
using System.Text;
        private static bool _userSettingsRecorded = false;
        private static string[] _userSettings = new string[4];
            string str;\n            if (_userSettingsRecorded == false)
                ExecSysproxy("query", out str);\n                ParseQueryStr(str);\n                _userSettingsRecorded = true;
                var flags = _userSettings[0];\n                var proxy_server = _userSettings[1] ?? "-";\n                var bypass_list = _userSettings[2] ?? "-";\n                var pac_url = _userSettings[3] ?? "-";
                _userSettingsRecorded = false;
            ExecSysproxy(arguments, out str);
        private static void ExecSysproxy(string arguments, out string queryStr)
                if (arguments == "query" && stdout.IsNullOrWhiteSpace())\n                {\n                    // we cannot get user settings\n                    throw new ProxyException("failed to query wininet settings");
                queryStr = stdout;
            _userSettings = str.Split(new string[] { "\r\n" }, StringSplitOptions.RemoveEmptyEntries);\n            for (var i = 0; i < 4; i++)\n            {\n                // handle output from WinINET\n                if (_userSettings[i] == "(null)")\n                    _userSettings[i] = null;\n            }
﻿using System;
using System.IO;\nusing System.Reflection;\nusing System.Runtime.InteropServices;
        [DllImport("Kernel32.dll")]\n        private static extern IntPtr LoadLibrary(string path);
        protected void updateKeyBuffer()\n        {\n            if (_keyBuffer == null)\n            {\n                _keyBuffer = new byte[MAX_IV_LENGTH + 4];\n                Buffer.BlockCopy(_encryptIV, 0, _keyBuffer, 0, ivLen);\n            }\n            byte[] counter_bytes = BitConverter.GetBytes((uint)IPAddress.HostToNetworkOrder((int)counter));\n            Buffer.BlockCopy(counter_bytes, 0, _keyBuffer, ivLen, 4);\n            counter++;\n        }\n        protected byte[] genHash(byte[] buf, int offset, int len)
            updateKeyBuffer();\n            Sodium.ss_sha1_hmac_ex(_keyBuffer, (uint)_keyBuffer.Length,
                int headLen = getHeadLen(buf, length);
                byte[] hash = genOnetimeAuthHash(buf, headLen);
            byte[] hash = genOnetimeAuthHash(buf, length);
                    reactBuffer4TCP(buf, ref length);
                    reactBuffer4UDP(buf, ref length);\n                }\n            }
                reactBuffer(buf, ref length);
namespace shadowsocks_csharp.Properties\n{
        internal static global::System.Resources.ResourceManager ResourceManager\n        {\n            get\n            {\n                if ((resourceMan == null))\n                {
        private void ConfigForm_KeyDown(object sender, KeyEventArgs e)\n        {\n            // Sometimes the users may hit enter key by mistake, and the form will close without saving entries.\n            if (e.KeyCode == Keys.Enter)\n            {\n                Server server = controller.GetCurrentServer();\n                if (!ValidateAndSaveSelectedServerDetails())\n                {\n                    return;\n                }\n                if (_modifiedConfiguration.configs.Count == 0)\n                {\n                    MessageBox.Show(I18N.GetString("Please add at least one server"));\n                    return;\n                }\n                int localPort = int.Parse(ProxyPortTextBox.Text);\n                Configuration.CheckLocalPort(localPort);\n                _modifiedConfiguration.localPort = localPort;\n                _modifiedConfiguration.portableMode = PortableModeCheckBox.Checked;\n                controller.SaveServers(_modifiedConfiguration.configs, _modifiedConfiguration.localPort, _modifiedConfiguration.portableMode);\n                controller.SelectServerIndex(_modifiedConfiguration.configs.IndexOf(server));\n            }\n        }\n        private void ServersListBox_SelectedIndexChanged(object sender, EventArgs e)\n        {\n            if (!ServersListBox.CanSelect)\n            {\n                return;\n            }\n            if (_lastSelectedIndex == ServersListBox.SelectedIndex)\n            {\n                // we are moving back to oldSelectedIndex or doing a force move\n                return;\n            }\n            if (!ValidateAndSaveSelectedServerDetails())\n            {\n                // why this won't cause stack overflow?\n                ServersListBox.SelectedIndex = _lastSelectedIndex;\n                return;\n            }\n            if (_lastSelectedIndex >= 0)\n            {\n                ServersListBox.Items[_lastSelectedIndex] = _modifiedConfiguration.configs[_lastSelectedIndex].FriendlyName();\n            }\n            UpdateButtons();\n            LoadSelectedServerDetails();\n            _lastSelectedIndex = ServersListBox.SelectedIndex;\n        }\n        private void AddButton_Click(object sender, EventArgs e)\n        {\n            if (!ValidateAndSaveSelectedServerDetails())\n            {\n                return;\n            }\n            Server server = Configuration.GetDefaultServer();\n            _modifiedConfiguration.configs.Add(server);\n            LoadServerNameListToUI(_modifiedConfiguration);\n            ServersListBox.SelectedIndex = _modifiedConfiguration.configs.Count - 1;\n            _lastSelectedIndex = ServersListBox.SelectedIndex;\n        }\n        private void DuplicateButton_Click(object sender, EventArgs e)\n        {\n            if (!ValidateAndSaveSelectedServerDetails())\n            {\n                return;\n            }\n            Server currServer = _modifiedConfiguration.configs[_lastSelectedIndex];\n            var currIndex = _modifiedConfiguration.configs.IndexOf(currServer);\n            _modifiedConfiguration.configs.Insert(currIndex + 1, currServer);\n            LoadServerNameListToUI(_modifiedConfiguration);\n            ServersListBox.SelectedIndex = currIndex + 1;\n            _lastSelectedIndex = ServersListBox.SelectedIndex;\n        }\n        private void DeleteButton_Click(object sender, EventArgs e)\n        {\n            _lastSelectedIndex = ServersListBox.SelectedIndex;\n            if (_lastSelectedIndex >= 0 && _lastSelectedIndex < _modifiedConfiguration.configs.Count)\n            {\n                _modifiedConfiguration.configs.RemoveAt(_lastSelectedIndex);\n            }\n            if (_lastSelectedIndex >= _modifiedConfiguration.configs.Count)\n            {\n                // can be -1\n                _lastSelectedIndex = _modifiedConfiguration.configs.Count - 1;\n            }\n            ServersListBox.SelectedIndex = _lastSelectedIndex;\n            LoadServerNameListToUI(_modifiedConfiguration);\n            ServersListBox.SelectedIndex = _lastSelectedIndex;\n            LoadSelectedServerDetails();\n        }\n        private void OKButton_Click(object sender, EventArgs e)\n        {\n            if (!ValidateAndSaveSelectedServerDetails())\n            {\n                return;
                return;
            this.Close();
            this.ApplyButton.Dock = System.Windows.Forms.DockStyle.Right;
            _config.bandwidthIn = inboundCounter;
            _config.bandwidthOut = outboundCounter;
            inboundCounter = _config.bandwidthIn;\n            outboundCounter = _config.bandwidthOut;
            this.CancelButton = new System.Windows.Forms.Button();
            ((System.ComponentModel.ISupportInitialize)(this.bindingConfiguration)).BeginInit();
            // CancelButton\n            // \n            this.CancelButton.Location = new System.Drawing.Point(844, 166);\n            this.CancelButton.Name = "CancelButton";\n            this.CancelButton.Size = new System.Drawing.Size(93, 43);\n            this.CancelButton.TabIndex = 5;\n            this.CancelButton.Text = "Cancel";\n            this.CancelButton.UseVisualStyleBackColor = true;\n            this.CancelButton.Click += new System.EventHandler(this.CancelButton_Click);
            _configuration = _controller.GetConfigurationCopy()?.statisticsStrategyConfiguration
using System.Text.RegularExpressions;
        private static string PAC_FILE = "pac.txt";
        public event EventHandler UpdatePACFromGFWListCompleted;\n        public event ErrorEventHandler UpdatePACFromGFWListError;
        public IWebProxy proxy = null;\n        public class GfwListDownloadCompletedArgs : EventArgs\n        {\n            public string Content;\n        }\n        public event EventHandler<GfwListDownloadCompletedArgs> DownloadCompleted;
        public void Download()\n        {\n            WebClient http = new WebClient();\n            http.Proxy = proxy;\n            http.DownloadStringCompleted += http_DownloadStringCompleted;\n            http.DownloadStringAsync(new Uri(GFWLIST_URL));\n        }\n        protected void ReportError(Exception e)\n        {\n            if (Error != null)\n            {\n                Error(this, new ErrorEventArgs(e));\n            }\n        }
                string response = e.Result;\n                if (DownloadCompleted != null)
                    DownloadCompleted(this, new GfwListDownloadCompletedArgs\n                    {\n                        Content = response\n                    });
                ReportError(ex);
        public class Parser
            private string _Content;\n            public string Content
                get { return _Content; }
            public Parser(string response)\n            {\n                byte[] bytes = Convert.FromBase64String(response);\n                this._Content = Encoding.ASCII.GetString(bytes);\n            }\n            public string[] GetValidLines()\n            {\n                string[] lines = Content.Split(new char[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);\n                List<string> valid_lines = new List<string>(lines.Length);\n                foreach (string line in lines)\n                {\n                    if (line.StartsWith("!") || line.StartsWith("["))\n                        continue;\n                    valid_lines.Add(line);\n                }\n                return valid_lines.ToArray();\n            }
        private void pacServer_UpdatePACFromGFWListError(object sender, ErrorEventArgs e)
    public class Util
            temppath = Path.GetTempPath();
            }\n            return true;
         if ("Shift_JIS".Equals(encoding))\n         {\n            // Choose Kanji mode if all input are double-byte characters\n            return isOnlyDoubleByteKanji(content) ? Mode.KANJI : Mode.BYTE;\n         }\n         bool hasNumeric = false;\n         bool hasAlphanumeric = false;\n         for (int i = 0; i < content.Length; ++i)\n         {\n            char c = content[i];\n            if (c >= '0' && c <= '9')\n            {\n               hasNumeric = true;\n            }\n            else if (getAlphanumericCode(c) != -1)\n            {\n               hasAlphanumeric = true;\n            }\n            else\n            {\n               return Mode.BYTE;\n            }\n         }\n         if (hasAlphanumeric)\n         {\n            return Mode.ALPHANUMERIC;\n         }\n         if (hasNumeric)\n         {\n            return Mode.NUMERIC;\n         }
      }\n      private static bool isOnlyDoubleByteKanji(String content)\n      {\n         byte[] bytes;\n         try\n         {\n            bytes = Encoding.GetEncoding("Shift_JIS").GetBytes(content);\n         }\n         catch (Exception )\n         {\n            return false;\n         }\n         int length = bytes.Length;\n         if (length % 2 != 0)\n         {\n            return false;\n         }\n         for (int i = 0; i < length; i += 2)\n         {\n            int byte1 = bytes[i] & 0xFF;\n            if ((byte1 < 0x81 || byte1 > 0x9F) && (byte1 < 0xE0 || byte1 > 0xEB))\n            {\n               return false;\n            }\n         }\n         return true;
         if (mode.Equals(Mode.NUMERIC))\n            appendNumericBytes(content, bits);\n         else\n            if (mode.Equals(Mode.ALPHANUMERIC))\n               appendAlphanumericBytes(content, bits);
               if (mode.Equals(Mode.BYTE))\n                  append8BitBytes(content, bits, encoding);\n               else\n                  if (mode.Equals(Mode.KANJI))\n                     appendKanjiBytes(content, bits);\n                  else\n                     throw new WriterException("Invalid mode: " + mode);
      /// <summary>\n      /// Gets the next set.\n      /// </summary>\n      /// <param name="from">first bit to check</param>\n      /// <returns>index of first bit that is set, starting from the given index, or size if none are set\n      /// at or beyond this given index</returns>\n      public int getNextSet(int from)\n      {\n         if (from >= size)\n         {\n            return size;\n         }\n         int bitsOffset = from >> 5;\n         int currentBits = bits[bitsOffset];\n         // mask off lesser bits first\n         currentBits &= ~((1 << (from & 0x1F)) - 1);\n         while (currentBits == 0)\n         {\n            if (++bitsOffset == bits.Length)\n            {\n               return size;\n            }\n            currentBits = bits[bitsOffset];\n         }\n         int result = (bitsOffset << 5) + numberOfTrailingZeros(currentBits);\n         return result > size ? size : result;\n      }\n      /// <summary>\n      /// see getNextSet(int)\n      /// </summary>\n      /// <param name="from"></param>\n      /// <returns></returns>\n      public int getNextUnset(int from)\n      {\n         if (from >= size)\n         {\n            return size;\n         }\n         int bitsOffset = from >> 5;\n         int currentBits = ~bits[bitsOffset];\n         // mask off lesser bits first\n         currentBits &= ~((1 << (from & 0x1F)) - 1);\n         while (currentBits == 0)\n         {\n            if (++bitsOffset == bits.Length)\n            {\n               return size;\n            }\n            currentBits = ~bits[bitsOffset];\n         }\n         int result = (bitsOffset << 5) + numberOfTrailingZeros(currentBits);\n         return result > size ? size : result;\n      }
      /// <summary>\n      /// Sets a range of bits.\n      /// </summary>\n      /// <param name="start">start of range, inclusive.</param>\n      /// <param name="end">end of range, exclusive</param>\n      public void setRange(int start, int end)\n      {\n         if (end < start)\n         {\n            throw new ArgumentException();\n         }\n         if (end == start)\n         {\n            return;\n         }\n         end--; // will be easier to treat this as the last actually set bit -- inclusive\n         int firstInt = start >> 5;\n         int lastInt = end >> 5;\n         for (int i = firstInt; i <= lastInt; i++)\n         {\n            int firstBit = i > firstInt ? 0 : start & 0x1F;\n            int lastBit = i < lastInt ? 31 : end & 0x1F;\n            int mask;\n            if (firstBit == 0 && lastBit == 31)\n            {\n               mask = -1;\n            }\n            else\n            {\n               mask = 0;\n               for (int j = firstBit; j <= lastBit; j++)\n               {\n                  mask |= 1 << j;\n               }\n            }\n            bits[i] |= mask;\n         }\n      }
      }\n      /// <summary> Efficient method to check if a range of bits is set, or not set.\n      /// \n      /// </summary>\n      /// <param name="start">start of range, inclusive.\n      /// </param>\n      /// <param name="end">end of range, exclusive\n      /// </param>\n      /// <param name="value">if true, checks that bits in range are set, otherwise checks that they are not set\n      /// </param>\n      /// <returns> true iff all bits are set or not set in range, according to value argument\n      /// </returns>\n      /// <throws>  IllegalArgumentException if end is less than or equal to start </throws>\n      public bool isRange(int start, int end, bool value)\n      {\n         if (end < start)\n         {\n            throw new System.ArgumentException();\n         }\n         if (end == start)\n         {\n            return true; // empty range matches\n         }\n         end--; // will be easier to treat this as the last actually set bit -- inclusive    \n         int firstInt = start >> 5;\n         int lastInt = end >> 5;\n         for (int i = firstInt; i <= lastInt; i++)\n         {\n            int firstBit = i > firstInt ? 0 : start & 0x1F;\n            int lastBit = i < lastInt ? 31 : end & 0x1F;\n            int mask;\n            if (firstBit == 0 && lastBit == 31)\n            {\n               mask = -1;\n            }\n            else\n            {\n               mask = 0;\n               for (int j = firstBit; j <= lastBit; j++)\n               {\n                  mask |= 1 << j;\n               }\n            }\n            // Return false if we're looking for 1s and the masked bits[i] isn't all 1s (that is,\n            // equals the mask, or we're looking for 0s and the masked portion is not all 0s\n            if ((bits[i] & mask) != (value ? mask : 0))\n            {\n               return false;\n            }\n         }\n         return true;
using System.Threading;
        private void Evaluate(object obj)
            var state = (State) obj;\n            foreach (var server in _servers)
                Logging.Debug("eveluating " + server.FriendlyName());\n                foreach (var _ in Enumerable.Range(0, Repeat))
                    //TODO: do simple analyze of data to provide friendly message, like package loss.\n                    var timestamp = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss");\n                    //ICMP echo. we can also set options and special bytes\n                    //seems no need to use SendPingAsync：\n                    var reply = ping.Send(server.server, Timeout);\n                    state.Data = new List<KeyValuePair<string, string>>\n                    {\n                        new KeyValuePair<string, string>("Timestamp", timestamp),\n                        new KeyValuePair<string, string>("Server", server.FriendlyName()),\n                        new KeyValuePair<string, string>("Status", reply?.Status.ToString()),\n                        new KeyValuePair<string, string>("RoundtripTime", reply?.RoundtripTime.ToString())\n                    };\n                    //state.data.Add(new KeyValuePair<string, string>("data", reply.Buffer.ToString())); // The data of reply\n                    Append(state.Data);
        private static void Append(List<KeyValuePair<string, string>> data)
            public static Asset ParseAsset(JObject aJObject)\n            {\n                var name = (string) aJObject["name"];
                        browser_download_url = (string) aJObject["browser_download_url"],
    struct TrafficInfo\n    {\n        public long inbound;\n        public long outbound;\n        public TrafficInfo(long inbound, long outbound)\n        {\n            this.inbound = inbound;\n            this.outbound = outbound;\n        }\n    }
        #region chart\n        long lastMaxSpeed;\n        ShadowsocksController.QueueLast<TrafficInfo> traffic = new ShadowsocksController.QueueLast<TrafficInfo>();
        private void update_TrafficChart()\n        {\n            List<float> inboundPoints = new List<float>();\n            List<float> outboundPoints = new List<float>();\n            TextAnnotation inboundAnnotation = new TextAnnotation();\n            TextAnnotation outboundAnnotation = new TextAnnotation();\n            BandwidthScaleInfo bandwidthScale;\n            const long minScale = 50;\n            long maxSpeed = 0;\n            long lastInbound, lastOutbound;
                if (traffic.Count == 0)
                foreach (var trafficPerSecond in traffic)\n                {\n                    inboundPoints.Add(trafficPerSecond.inbound);\n                    outboundPoints.Add(trafficPerSecond.outbound);\n                    maxSpeed = Math.Max(maxSpeed, Math.Max(trafficPerSecond.inbound, trafficPerSecond.outbound));\n                }\n                lastInbound = traffic.Last().inbound;\n                lastOutbound = traffic.Last().outbound;
        public QueueLast<TrafficPerSecond> traffic;
        }\n        public class QueueLast<T> : Queue<T>\n        {\n            public T Last { get; private set; }\n            public new void Enqueue(T item)\n            {\n                Last = item;\n                base.Enqueue(item);\n            }
            traffic = new QueueLast<TrafficPerSecond>();
                traffic.Enqueue(new TrafficPerSecond());
                TrafficPerSecond previous = traffic.Last;\n                TrafficPerSecond current = new TrafficPerSecond();\n                var inbound = current.inboundCounter = InboundCounter;\n                var outbound = current.outboundCounter = OutboundCounter;\n                current.inboundIncreasement = inbound - previous.inboundCounter;\n                current.outboundIncreasement = outbound - previous.outboundCounter;\n                traffic.Enqueue(current);\n                if (traffic.Count > queueMaxSize)\n                    traffic.Dequeue();
        public TCPRelay relay;
        // Size of receive buffer.\n        public const int RecvSize = 8192;\n        public const int RecvReserveSize = IVEncryptor.ONETIMEAUTH_BYTES + IVEncryptor.AUTH_BYTES; // reserve for one-time auth\n        public const int BufferSize = RecvSize + RecvReserveSize + 32;\n        private int totalRead = 0;\n        private int totalWrite = 0;\n        // remote receive buffer\n        private byte[] remoteRecvBuffer = new byte[BufferSize];\n        // remote send buffer\n        private byte[] remoteSendBuffer = new byte[BufferSize];\n        // connection receive buffer\n        private byte[] connetionRecvBuffer = new byte[BufferSize];\n        // connection send buffer\n        private byte[] connetionSendBuffer = new byte[BufferSize];\n        // Received data string.\n        private bool connectionShutdown = false;\n        private bool remoteShutdown = false;\n        private bool closed = false;\n        private object encryptionLock = new object();\n        private object decryptionLock = new object();
            ShowToolbarTrigger = !ShowToolbarTrigger;\n            ToolbarFlowLayoutPanel.Visible = ShowToolbarTrigger;\n            ShowToolbarMenuItem.Checked = ShowToolbarTrigger;
        public const int BufferSize = 1500;
        public byte[] remoteBuffer = new byte[BufferSize];
        public byte[] connetionBuffer = new byte[BufferSize];
                remote.BeginReceive(remoteBuffer, 0, BufferSize, 0,
                connection.BeginReceive(connetionBuffer, 0, BufferSize, 0,
        public override byte[] Encrypt(byte[] buf, int length)
                byte[] iv = new byte[ivLen];\n                OpenSSL.RAND_bytes(iv, iv.Length);\n                InitCipher(ref _encryptCtx, iv, true);\n                int outLen = length + ivLen;\n                byte[] cipherText = new byte[outLen];\n                OpenSSL.EVP_CipherUpdate(_encryptCtx, cipherText, out outLen, buf, length);\n                byte[] result = new byte[outLen + ivLen];\n                Buffer.BlockCopy(iv, 0, result, 0, ivLen);\n                Buffer.BlockCopy(cipherText, 0, result, ivLen, outLen);\n                return result;
                int outLen = length + ivLen;\n                byte[] cipherText = new byte[outLen];\n                OpenSSL.EVP_CipherUpdate(_encryptCtx, cipherText, out outLen, buf, length);\n                byte[] result = new byte[outLen];\n                Buffer.BlockCopy(cipherText, 0, result, 0, outLen);\n                return result;
        public override byte[] Decrypt(byte[] buf, int length)
                byte[] iv = new byte[ivLen];\n                Buffer.BlockCopy(buf, 0, iv, 0, ivLen);\n                InitCipher(ref _decryptCtx, iv, false);\n                int outLen = length + ivLen;\n                outLen -= ivLen;\n                byte[] cipherText = new byte[outLen];\n                byte[] subset = new byte[length - ivLen];\n                Buffer.BlockCopy(buf, ivLen, subset, 0, length - ivLen);\n                OpenSSL.EVP_CipherUpdate(_decryptCtx, cipherText, out outLen, subset, length - ivLen);\n                byte[] result = new byte[outLen];\n                Buffer.BlockCopy(cipherText, 0, result, 0, outLen);\n                return result;
                int outLen = length + ivLen;\n                byte[] cipherText = new byte[outLen];\n                OpenSSL.EVP_CipherUpdate(_decryptCtx, cipherText, out outLen, buf, length);\n                byte[] result = new byte[outLen];\n                Buffer.BlockCopy(cipherText, 0, result, 0, outLen);\n                return result;
    public interface IEncryptor
        byte[] Encrypt(byte[] buf, int length);\n        byte[] Decrypt(byte[] buf, int length);
        public override byte[] Encrypt(byte[] buf, int length)
                result[i] = _encryptTable[buf[i]];
            return result;
        public override byte[] Decrypt(byte[] buf, int length)
                result[i] = _decryptTable[buf[i]];
            return result;
    class AutoStartup
        static string Key = "Shadowsocks_" + Application.StartupPath.GetHashCode();
                string path = Application.ExecutablePath;
                    runKey.SetValue(Key, path);
                            runKey.SetValue(Key, path);
        // public Encryptor encryptor;\n        public IEncryptor encryptor;\n        public Server server;\n        // Client  socket.
        public Socket connection;\n        public ShadowsocksController controller;\n        public TCPRelay tcprelay;\n        public DateTime lastActivity;\n        private const int MaxRetry = 4;\n        private int _retryCount = 0;\n        private bool _proxyConnected;\n        private bool _destConnected;\n        private byte _command;\n        private byte[] _firstPacket;\n        private int _firstPacketLength;\n        private int _totalRead = 0;\n        private int _totalWrite = 0;\n        private byte[] _remoteRecvBuffer = new byte[BufferSize];\n        private byte[] _remoteSendBuffer = new byte[BufferSize];\n        private byte[] _connetionRecvBuffer = new byte[BufferSize];\n        private byte[] _connetionSendBuffer = new byte[BufferSize];\n        private bool _connectionShutdown = false;\n        private bool _remoteShutdown = false;\n        private bool _closed = false;\n        private object _encryptionLock = new object();\n        private object _decryptionLock = new object();
        private int _bytesToSend;\n        private TCPRelay _tcprelay;  // TODO: is _tcprelay equals tcprelay declared above?\n        private Configuration _config;\n        public TCPHandler(TCPRelay tcprelay, Configuration config)\n        {
            this._config = config;
            lock (tcprelay.Handlers)\n            {\n                tcprelay.Handlers.Remove(this);\n            }\n            lock (this) {
            try\n            {\n                connection?.Shutdown(SocketShutdown.Both);\n                connection?.Close();
                throw new Exception();
                throw new Exception();
                throw new Exception();
                    ? Resources.zh_tw\n                    : Resources.cn);
                Init(Resources.jp);
        private Configuration _config;
        public UDPRelay(Configuration config)
            this._config = config;
                + "\n" + config.GetCurrentServer().FriendlyName();
            enableItem.Checked = controller.GetConfiguration().enabled;
            ShareOverLANItem.Checked = controller.GetConfiguration().shareOverLan;
            globalModeItem.Checked = controller.GetConfiguration().global;
            Configuration configuration = controller.GetConfiguration();\n            for (int i = 0; i < configuration.configs.Count; i++)\n            {\n                Server server = configuration.configs[i];
            }\n            if (configuration.index >= 0 && configuration.index < configuration.configs.Count)\n            {\n                items[configuration.index].Checked = true;
        private Configuration _config;\n        public TCPRelay(Configuration config)\n        {\n            this._config = config;
        public Configuration GetConfiguration()
            if (config.index < 0)
                config.index = 0;
        private void StartConnect(IAsyncResult ar)
                    _controller?.Stop();
                _controller?.Start();
            string parts = server.method;\n            if (server.auth) parts += "-auth";\n            parts += ":" + server.password + "@" + server.server + ":" + server.server_port;
            return "ss://" + base64;
            var tag = match.Groups[2].Value;
                remarks = tag.Substring(1).Trim();
                    Logging.Debug(remote.LocalEndPoint, remote.DestEndPoint, RecvSize, "TCP Relay");
                        Logging.Debug(remote.LocalEndPoint, remote.DestEndPoint, RecvSize, "TCP Relay");
                if (bytesRead > 0)
                if (_encryptCtx != IntPtr.Zero)
                if (_decryptCtx != IntPtr.Zero)
                defConnection[8] = (byte)(defConnection[8] | 8);\n                savedLegacySetting[8] = (byte)(savedLegacySetting[8] | 8);
                defConnection[8] = (byte)(defConnection[8] & ~8);\n                savedLegacySetting[8] = (byte)(savedLegacySetting[8] & ~8);
            BitConverter.GetBytes(unchecked(BitConverter.ToUInt32(defConnection, 4) + 1)).CopyTo(defConnection, 4);\n            BitConverter.GetBytes(unchecked(BitConverter.ToUInt32(savedLegacySetting, 4) + 1)).CopyTo(savedLegacySetting, 4);
    using DataUnit = KeyValuePair<string, string>;\n    using DataList = List<KeyValuePair<string, string>>;\n    using Statistics = Dictionary<string, List<AvailabilityStatistics.RawStatisticsData>>;
        private AvailabilityStatistics() { }\n        public const string DateTimePattern = "yyyy-MM-dd HH:mm:ss";\n        private const string StatisticsFilesName = "shadowsocks.availability.csv";\n        private const string Delimiter = ",";\n        private const int TimeoutMilliseconds = 500;\n        private readonly TimeSpan _delayBeforeStart = TimeSpan.FromSeconds(1);
        public static readonly DateTime UnknownDateTime = new DateTime(1970, 1, 1);
        private readonly TimeSpan _retryInterval = TimeSpan.FromMinutes(2); //retry 2 minutes after failed\n        private TimeSpan Interval => TimeSpan.FromMinutes(_config.DataCollectionMinutes);\n        private Timer _timer;\n        private Timer _speedMonior;\n        private State _state;\n        private List<Server> _servers;\n        private StatisticsStrategyConfiguration _config;\n        private const string Empty = "";\n        public static string AvailabilityStatisticsFile;\n        //speed in KiB/s\n        private int _inboundSpeed = 0;\n        private int _outboundSpeed = 0;\n        private int? _latency = 0;\n        private Server _currentServer;\n        private Configuration _globalConfig;\n        private ShadowsocksController _controller;\n        private long _lastInboundCounter = 0;\n        private long _lastOutboundCounter = 0;\n        private readonly TimeSpan _monitorInterval = TimeSpan.FromSeconds(1);\n        //static constructor to initialize every public static fields before refereced\n        static AvailabilityStatistics()\n        {\n            AvailabilityStatisticsFile = Utils.GetTempPath(StatisticsFilesName);\n        }
                    if (_timer?.Change(_delayBeforeStart, Interval) == null)\n                    {\n                        _state = new State();\n                        _timer = new Timer(Run, _state, _delayBeforeStart, Interval);
                    _timer?.Dispose();
            var inboundSpeed = GetSpeedInKiBPerSecond(bytes ,_monitorInterval.TotalSeconds);
            if (inboundSpeed > _inboundSpeed)\n            {\n                _inboundSpeed = inboundSpeed;\n            }\n            if (outboundSpeed > _outboundSpeed)\n            {\n                _outboundSpeed = outboundSpeed;\n            }\n            Logging.Debug($"{_currentServer.FriendlyName()}: current/max inbound {inboundSpeed}/{_inboundSpeed} KiB/s, current/max outbound {outboundSpeed}/{_outboundSpeed} KiB/s");\n        }\n        private async Task<List<DataList>> ICMPTest(Server server)
            var ret = new List<DataList>();\n            try {\n                var IP = Dns.GetHostAddresses(server.server).First(ip => (ip.AddressFamily == AddressFamily.InterNetwork || ip.AddressFamily == AddressFamily.InterNetworkV6));
                foreach (var timestamp in Enumerable.Range(0, Repeat).Select(_ => DateTime.Now.ToString(DateTimePattern)))\n                {\n                    //ICMP echo. we can also set options and special bytes
                        ret.Add(new List<KeyValuePair<string, string>>\n                    {\n                        new KeyValuePair<string, string>("Timestamp", timestamp),\n                        new KeyValuePair<string, string>("Server", server.FriendlyName()),\n                        new KeyValuePair<string, string>("Status", reply?.Status.ToString()),\n                        new KeyValuePair<string, string>("RoundtripTime", reply?.RoundtripTime.ToString()),\n                        new KeyValuePair<string, string>("Latency", GetRecentLatency(server)),\n                        new KeyValuePair<string, string>("InboundSpeed", GetRecentInboundSpeed(server)),\n                        new KeyValuePair<string, string>("OutboundSpeed", GetRecentOutboundSpeed(server))\n                        //new KeyValuePair<string, string>("data", reply.Buffer.ToString()); // The data of reply\n                    });\n                        Thread.Sleep(TimeoutMilliseconds + new Random().Next() % TimeoutMilliseconds);
            return ret;\n        }\n        private string GetRecentOutboundSpeed(Server server)\n        {\n            return server != _currentServer ? Empty : _outboundSpeed.ToString();\n        }\n        private string GetRecentInboundSpeed(Server server)\n        {\n            return server != _currentServer ? Empty : _inboundSpeed.ToString();\n        }\n        private string GetRecentLatency(Server server)\n        {\n            if (server != _currentServer) return Empty;\n            return _latency == null ? Empty : _latency.ToString();\n        }\n        private void ResetSpeed()\n        {\n            _currentServer = _controller.GetCurrentServer();\n            _latency = null;\n            _inboundSpeed = 0;\n            _outboundSpeed = 0;\n        }\n        private void Run(object obj)\n        {\n            if (_speedMonior?.Change(_delayBeforeStart, _monitorInterval) == null)\n            {\n                _speedMonior = new Timer(UpdateSpeed, null, _delayBeforeStart, _monitorInterval);\n            }\n            LoadRawStatistics();
            Evaluate();\n            ResetSpeed();\n        }\n        private async void Evaluate()\n        {\n            foreach (var dataLists in await TaskEx.WhenAll(_servers.Select(ICMPTest)))\n            {\n                if (dataLists == null) continue;\n                foreach (var dataList in dataLists.Where(dataList => dataList != null))\n                {\n                    Append(dataList, Enumerable.Empty<DataUnit>());\n                }\n            }\n        }
            ResetSpeed();
            foreach (IEnumerable<RawStatisticsData> rawData in RawStatistics.Values)\n            {\n                var filteredData = rawData;\n                if (_config.ByHourOfDay)\n                {\n                    var currentHour = DateTime.Now.Hour;\n                    filteredData = filteredData.Where(data =>\n                        data.Timestamp != UnknownDateTime && data.Timestamp.Hour.Equals(currentHour)\n                    );\n                    if (filteredData.LongCount() == 0) return;\n                }\n                var dataList = filteredData as List<RawStatisticsData> ?? filteredData.ToList();\n                var serverName = dataList[0].ServerName;\n                FilteredStatistics[serverName] = dataList;
                    if (!File.Exists(path)) {\n                        Console.WriteLine($"statistics file does not exist, try to reload {_retryInterval.TotalMinutes} minutes later");\n                        _timer.Change(_retryInterval, Interval);
                RawStatistics = (from l in File.ReadAllLines(path).Skip(1)\n                                 let strings = l.Split(new[] { "," }, StringSplitOptions.RemoveEmptyEntries)\n                                 let rawData = new RawStatisticsData\n                                 {\n                                     Timestamp = ParseExactOrUnknown(strings[0]),\n                                     ServerName = strings[1],\n                                     ICMPStatus = strings[2],\n                                     RoundtripTime = int.Parse(strings[3])\n                                 }\n                                 group rawData by rawData.ServerName into server\n                                 select new\n                                 {\n                                     ServerName = server.Key,\n                                     data = server.ToList()\n                                 }).ToDictionary(server => server.ServerName, server => server.data);
            return !DateTime.TryParseExact(str, DateTimePattern, null, DateTimeStyles.None, out dateTime) ? UnknownDateTime : dateTime;\n        }\n        public class State\n        {\n            public DataList dataList = new DataList();\n            public const string Unknown = "Unknown";\n        }\n        //TODO: redesign model\n        public class RawStatisticsData\n        {\n            public DateTime Timestamp;\n            public string ServerName;\n            public string ICMPStatus;\n            public int RoundtripTime;\n        }\n        public class StatisticsData\n        {\n            public float PackageLoss;\n            public int AverageResponse;\n            public int MinResponse;\n            public int MaxResponse;
            _latency = latency;
            List<AvailabilityStatistics.RawStatisticsData> statistics;
            IEnumerable<IGrouping<int, AvailabilityStatistics.RawStatisticsData>> dataGroups;
        private Dictionary<string, List<AvailabilityStatistics.RawStatisticsData>> _filteredStatistics;
            _filteredStatistics = _controller.availabilityStatistics.RawStatistics ?? _filteredStatistics ?? new Dictionary<string, List<AvailabilityStatistics.RawStatisticsData>>();
            List<AvailabilityStatistics.RawStatisticsData> dataList;\n            if (_filteredStatistics == null || !_filteredStatistics.TryGetValue(serverName, out dataList)) return 0;\n            var successTimes = (float) dataList.Count(data => data.ICMPStatus.Equals(IPStatus.Success.ToString()));\n            var timedOutTimes = (float) dataList.Count(data => data.ICMPStatus.Equals(IPStatus.TimedOut.ToString()));\n            var statisticsData = new AvailabilityStatistics.StatisticsData\n            {\n                PackageLoss = timedOutTimes/(successTimes + timedOutTimes)*100,\n                AverageResponse = Convert.ToInt32(dataList.Average(data => data.RoundtripTime)),\n                MinResponse = dataList.Min(data => data.RoundtripTime),\n                MaxResponse = dataList.Max(data => data.RoundtripTime)\n            };
            score += statisticsData.PackageLoss*factor;
            score += statisticsData.AverageResponse*factor;
            score += statisticsData.MinResponse*factor;
            score += statisticsData.MaxResponse*factor;\n            Logging.Debug($"{serverName}  {JsonConvert.SerializeObject(statisticsData)}");
            this.QRCodeItem = new System.Windows.Forms.MenuItem();
            this.tableLayoutPanel1.Location = new System.Drawing.Point(8, 21);\n            this.tableLayoutPanel1.Margin = new System.Windows.Forms.Padding(5);
            this.tableLayoutPanel1.Padding = new System.Windows.Forms.Padding(5);
            this.RemarksTextBox.Location = new System.Drawing.Point(74, 139);
            this.label6.Location = new System.Drawing.Point(19, 142);
            this.label1.Location = new System.Drawing.Point(17, 11);
            this.label2.Location = new System.Drawing.Point(8, 37);
            this.ProxyPortTextBox.Location = new System.Drawing.Point(74, 113);
            this.label4.Location = new System.Drawing.Point(13, 116);
            this.label3.Location = new System.Drawing.Point(15, 63);
            this.IPTextBox.Location = new System.Drawing.Point(74, 8);
            this.ServerPortTextBox.Location = new System.Drawing.Point(74, 34);
            this.PasswordTextBox.Location = new System.Drawing.Point(74, 60);
            this.label5.Location = new System.Drawing.Point(11, 90);
            this.EncryptionSelect.Location = new System.Drawing.Point(74, 86);
            this.notifyIcon1.Icon = ((System.Drawing.Icon)(resources.GetObject("notifyIcon1.Icon")));
            this.notifyIcon1.Visible = true;
            this.panel2.Location = new System.Drawing.Point(164, 175);
            this.OKButton.Location = new System.Drawing.Point(4, 4);
            this.MyCancelButton.Location = new System.Drawing.Point(86, 4);
            this.DeleteButton.Location = new System.Drawing.Point(100, 4);
            this.AddButton.Location = new System.Drawing.Point(4, 4);
            this.ServerGroupBox.Location = new System.Drawing.Point(222, 12);
            this.ServerGroupBox.Size = new System.Drawing.Size(255, 205);
            this.ServersListBox.Location = new System.Drawing.Point(12, 12);
            if (File.Exists(PAC_FILE))
                return File.ReadAllText(PAC_FILE, Encoding.UTF8);
            else\n            {\n                return Resources.default_abp_rule + Resources.abp_js;\n            }
            handler.Receive();
                UpdateIndexToEnd();
                UpdateIndexToEnd();
                Configuration.AddDefaultServerOrServer(_modifiedConfiguration, currServer);
                UpdateIndexToEnd();
            int index = ServersListBox.SelectedIndex;\n            Server server = _modifiedConfiguration.configs[index];\n            object item = ServersListBox.Items[index];\n            _modifiedConfiguration.configs.Remove(server);\n            _modifiedConfiguration.configs.Insert(index + step, server);\n            _modifiedConfiguration.index += step;
            ServersListBox.Enabled = false;\n            _lastSelectedIndex = index + step;\n            ServersListBox.Items.Remove(item);\n            ServersListBox.Items.Insert(index + step, item);\n            ServersListBox.Enabled = true;\n            ServersListBox.SelectedIndex = index + step;
            byte[] realkey;\n            if (_method == "rc4-md5")\n            {\n                byte[] temp = new byte[keyLen + ivLen];\n                realkey = new byte[keyLen];\n                Array.Copy(_key, 0, temp, 0, keyLen);\n                Array.Copy(iv, 0, temp, keyLen, ivLen);\n                realkey = MD5.Create().ComputeHash(temp);\n            }\n            else\n            {\n                realkey = _key;\n            }\n            if (_cipher == CIPHER_AES)\n            {\n                PolarSSL.aes_init(ctx);\n                // PolarSSL takes key length by bit\n                // since we'll use CFB mode, here we both do enc, not dec\n                PolarSSL.aes_setkey_enc(ctx, realkey, keyLen * 8);\n                if (isCipher)\n                {\n                    _encryptIV = new byte[ivLen];\n                    Array.Copy(iv, _encryptIV, ivLen);
                    _decryptIV = new byte[ivLen];\n                    Array.Copy(iv, _decryptIV, ivLen);\n                }\n            }\n            else if (_cipher == CIPHER_BF)\n            {\n                PolarSSL.blowfish_init(ctx);\n                // PolarSSL takes key length by bit\n                PolarSSL.blowfish_setkey(ctx, realkey, keyLen * 8);\n                if (isCipher)\n                {\n                    _encryptIV = new byte[ivLen];\n                    Array.Copy(iv, _encryptIV, ivLen);\n                }\n                else\n                {\n                    _decryptIV = new byte[ivLen];\n                    Array.Copy(iv, _decryptIV, ivLen);\n                }\n            }\n            else if (_cipher == CIPHER_RC4)\n            {\n                PolarSSL.arc4_init(ctx);\n                PolarSSL.arc4_setup(ctx, realkey, keyLen);
                            PolarSSL.aes_crypt_cfb128(_encryptCtx, PolarSSL.AES_ENCRYPT, length, ref _encryptIVOffset, _encryptIV, buf, tempbuf);
                            PolarSSL.blowfish_crypt_cfb64(_encryptCtx, PolarSSL.BLOWFISH_ENCRYPT, length, ref _encryptIVOffset, _encryptIV, buf, tempbuf);
                            PolarSSL.arc4_crypt(_encryptCtx, length, buf, tempbuf);\n                            break;\n                    }\n                    outlength = length + ivLen;\n                    Buffer.BlockCopy(tempbuf, 0, outbuf, ivLen, outlength);\n                }\n            }\n            else\n            {\n                outlength = length;\n                switch (_cipher)\n                {\n                    case CIPHER_AES:\n                        PolarSSL.aes_crypt_cfb128(_encryptCtx, PolarSSL.AES_ENCRYPT, length, ref _encryptIVOffset, _encryptIV, buf, outbuf);\n                        break;\n                    case CIPHER_BF:\n                        PolarSSL.blowfish_crypt_cfb64(_encryptCtx, PolarSSL.BLOWFISH_ENCRYPT, length, ref _encryptIVOffset, _encryptIV, buf, outbuf);\n                        break;\n                    case CIPHER_RC4:\n                        PolarSSL.arc4_crypt(_encryptCtx, length, buf, outbuf);\n                        break;
                            PolarSSL.aes_crypt_cfb128(_decryptCtx, PolarSSL.AES_DECRYPT, length - ivLen, ref _decryptIVOffset, _decryptIV, tempbuf, outbuf);
                            PolarSSL.blowfish_crypt_cfb64(_decryptCtx, PolarSSL.BLOWFISH_DECRYPT, length - ivLen, ref _decryptIVOffset, _decryptIV, tempbuf, outbuf);
                            PolarSSL.arc4_crypt(_decryptCtx, length - ivLen, tempbuf, outbuf);\n                            break;\n                    }\n                }\n            }\n            else\n            {\n                outlength = length;\n                switch (_cipher)\n                {\n                    case CIPHER_AES:\n                        PolarSSL.aes_crypt_cfb128(_decryptCtx, PolarSSL.AES_DECRYPT, length, ref _decryptIVOffset, _decryptIV, buf, outbuf);\n                        break;\n                    case CIPHER_BF:\n                        PolarSSL.blowfish_crypt_cfb64(_decryptCtx, PolarSSL.BLOWFISH_DECRYPT, length, ref _decryptIVOffset, _decryptIV, buf, outbuf);\n                        break;\n                    case CIPHER_RC4:\n                        PolarSSL.arc4_crypt(_decryptCtx, length, buf, outbuf);\n                        break;
            if (!_disposed)\n            {\n                if (disposing)\n                {\n                }
                    switch (_cipher)\n                    {\n                        case CIPHER_AES:\n                            PolarSSL.aes_free(_encryptCtx);\n                            break;\n                        case CIPHER_BF:\n                            PolarSSL.blowfish_free(_encryptCtx);\n                            break;\n                        case CIPHER_RC4:\n                            PolarSSL.arc4_free(_encryptCtx);\n                            break;
                    switch (_cipher)\n                    {\n                        case CIPHER_AES:\n                            PolarSSL.aes_free(_decryptCtx);\n                            break;\n                        case CIPHER_BF:\n                            PolarSSL.blowfish_free(_decryptCtx);\n                            break;\n                        case CIPHER_RC4:\n                            PolarSSL.arc4_free(_decryptCtx);\n                            break;\n                    }\n                }\n                _encryptCtx = null;\n                _decryptCtx = null;\n                _disposed = true;
                string pacContent = $"var __PROXY__ = \"{proxy}\";\n" + _pacDaemon.GetPACContent();\n                //string pacContent = _pacDaemon.GetPACContent().Replace("__PROXY__", proxy);\n                string responseHead = String.Format(@"HTTP/1.1 200 OK\nServer: Shadowsocks
Content-Length: {0}
            using (var fs = new FileStream(path, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))\n            using (var sr = new StreamReader(fs, encoding))
                return sr.ReadToEnd();
        protected uint _encryptBytesRemaining;\n        protected uint _decryptBytesRemaining;
            uint bytesRemaining;
[assembly: AssemblyTitle("shadowsocks-csharp")]
[assembly: AssemblyProduct("shadowsocks-csharp")]
﻿using System;
            {                
                IDictionary<string, string> tld_dic = GetTldDictionary();
                    if (!tld_dic.ContainsKey(last_root_domain))
            private IDictionary<string, string> GetTldDictionary()
                IDictionary<string, string> dic = new Dictionary<string, string>(tlds.Length);
                    if (!dic.ContainsKey(tld))
                }\n                return dic;
                    Console.WriteLine("HA switching to server: {0}", _currentServer.server.FriendlyName());
            Logging.Debug(String.Format("latency: {0} {1}", server.FriendlyName(), latency));
            Logging.Debug(String.Format("last read: {0}", server.FriendlyName()));
            Logging.Debug(String.Format("last write: {0}", server.FriendlyName()));
            Logging.Debug(String.Format("failure: {0}", server.FriendlyName()));
            catch (Exception _Exception)
                Console.WriteLine("Exception caught in process: {0}",\n                                  _Exception.ToString());
            Console.WriteLine(o);
        public ShadowsocksController.QueueLast<Tuple<long, long>> traffic = new ShadowsocksController.QueueLast<Tuple<long, long>>();
            Tuple<float, string, long> bandwidthScale;
                    inboundPoints.Add(trafficPerSecond.Item1);\n                    outboundPoints.Add(trafficPerSecond.Item2);\n                    maxSpeed = Math.Max(maxSpeed, Math.Max(trafficPerSecond.Item1, trafficPerSecond.Item2));\n                }\n                lastInbound = traffic.Last().Item1;\n                lastOutbound = traffic.Last().Item2;
            inboundPoints = inboundPoints.Select(p => p / bandwidthScale.Item3).ToList();\n            outboundPoints = outboundPoints.Select(p => p / bandwidthScale.Item3).ToList();
                trafficChart.ChartAreas[0].AxisY.LabelStyle.Format = "{0:0.##} " + bandwidthScale.Item2;\n                trafficChart.ChartAreas[0].AxisY.Maximum = bandwidthScale.Item1;
                traffic = new ShadowsocksController.QueueLast<Tuple<long, long>>();
                    traffic.Enqueue(new Tuple<long, long>(trafficPerSecond.inboundIncreasement, trafficPerSecond.outboundIncreasement));
                return (bytes / (double)K).ToString("F1") + "KB";\n            }\n            return bytes.ToString();
        public static Tuple<float, string, long> GetBandwidthScale(long n)
using Shadowsocks.ForwardProxy;
namespace Shadowsocks.ForwardProxy
    public class Socks5Proxy : IForwardProxy
namespace Shadowsocks.ForwardProxy
    public class HttpProxy : IForwardProxy
namespace Shadowsocks.ForwardProxy
    public interface IForwardProxy
namespace Shadowsocks.ForwardProxy
    public class DirectConnect : IForwardProxy
        public event EventHandler NewVersionFound;
                if (versions.Count == 0)
                    return;
                // sort versions\n                SortVersions(versions);\n                LatestVersionURL = versions[versions.Count - 1];\n                LatestVersionNumber = ParseVersionFromURL(LatestVersionURL);\n                if (NewVersionFound != null)
                    NewVersionFound(this, new EventArgs());
            updateChecker.NewVersionFound += updateChecker_NewVersionFound;
            updateChecker.CheckUpdate(controller.GetConfigurationCopy());\n            if (controller.GetConfigurationCopy().isDefault)
using Cyotek.Collections.Generic;
        private CircularBuffer<byte> _encCircularBuffer = new CircularBuffer<byte>(TCPHandler.BufferSize * 2, false);\n        private CircularBuffer<byte> _decCircularBuffer = new CircularBuffer<byte>(TCPHandler.BufferSize * 2, false);
            Close();
            foreach (var tb in _allTextBoxes)\n            {\n                if (tb.Text.IsNullOrEmpty())\n                {\n                    continue;\n                }\n                if (!TryRegHotkey(tb))\n                {\n                    MessageBox.Show(I18N.GetString("Register hotkey failed"));\n                    return;\n                }
            Close();
                TryRegHotkey(tb);\n            }
            bool regResult = HotKeys.Regist(hotkey, callBack);
                HotKeys.UnRegist(prevHotKey);
            _modifiedConfig.SwitchSystemProxy = SwitchSystemProxyTextBox.Text;\n            _modifiedConfig.SwitchSystemProxyMode = SwitchProxyModeTextBox.Text;\n            _modifiedConfig.SwitchAllowLan = SwitchAllowLanTextBox.Text;\n            _modifiedConfig.ShowLogs = ShowLogsTextBox.Text;\n            _modifiedConfig.ServerMoveUp = ServerMoveUpTextBox.Text;\n            _modifiedConfig.ServerMoveDown = ServerMoveDownTextBox.Text;\n            _controller.SaveHotkeyConfig(_modifiedConfig);
            ShowToolbarTrigger = !ShowToolbarTrigger;\n            ToolbarFlowLayoutPanel.Visible = ShowToolbarTrigger;\n            ShowToolbarMenuItem.Checked = ShowToolbarTrigger;
        /**\n         * if last failure is > 10 min\n         * and (last write > last read) and (now - last read <  5s)  // means not stuck\n         * choose the lowest latency\n         */
            // just leave removed servers there\n            // TODO\n            _currentServer = _controller.GetCurrentConfiguration().configs[0];
using Shadowsocks.Controller.Strategy;\nusing SimpleJson;\nusing Newtonsoft.Json;
        public Server(string ssURL) : this()
            var match = UrlFinder.Match(ssURL);\n            if (!match.Success) throw new FormatException();\n            var base64 = match.Groups[1].Value;\n            var tag = match.Groups[3].Value;\n            if (!tag.IsNullOrEmpty())\n                remarks = HttpUtility.UrlDecode(tag, Encoding.UTF8);\n            match = DetailsParser.Match(Encoding.UTF8.GetString(Convert.FromBase64String(\n                base64.PadRight(base64.Length + (4 - base64.Length % 4) % 4, '='))));\n            method = match.Groups["method"].Value;\n            password = match.Groups["password"].Value;\n            server = match.Groups["hostname"].Value;\n            server_port = int.Parse(match.Groups["port"].Value);
        public void Encrypt(byte[] buf)
            for (int i = 0; i < buf.Length; i++)
        public void Decrypt(byte[] buf)
            for (int i = 0; i < buf.Length; i++)
using System.Text;\nusing Shadowsocks.Model;\nusing System.IO;
        private ShadowsocksController _controller;
        private Timer timer;\n        private Dictionary<string, StatisticsData> statistics;\n        private static readonly int CachedInterval = 30 * 60 * 1000; //choose a new server every 30 minutes
            int randomIndex = new Random().Next() % servers.Count();
            List<Server> servers = _controller.GetCurrentConfiguration().configs;
                if (_controller.GetCurrentStrategy().ID == ID && _currentServer != bestResult.server) //output when enabled
                    Console.WriteLine("Switch to server: {0} by package loss:{1}", bestResult.server.FriendlyName(), 1 - bestResult.score);
        public string ID
            get { return "com.shadowsocks.strategy.scbs"; }
        public string Name\n        {\n            get { return I18N.GetString("Choose By Total Package Loss"); }\n        }
            if (oldServer != _currentServer)\n            {\n            }
            Logging.Debug(String.Format("failure: {0}", server.FriendlyName()));
                ShowFirstTimeBalloon();
                Logging.Error(e.ExceptionObject?.ToString());
            string errorMsg = $"Exception Type: {e.Exception.GetType().Name}{Environment.NewLine}Stack Trace:{Environment.NewLine}{e.Exception.StackTrace}";\n            Logging.Error(errorMsg);\n            MessageBox.Show(\n                $"{I18N.GetString("Unexpected error, shadowsocks will exit. Please report to")} https://github.com/shadowsocks/shadowsocks-windows/issues {Environment.NewLine}{errorMsg}",\n                "Shadowsocks UI Error", MessageBoxButtons.OK, MessageBoxIcon.Error);\n            Application.Exit();
            RegistryKey userKey = RegistryKey.OpenRemoteBaseKey( RegistryHive.CurrentUser, "",\n                Environment.Is64BitOperatingSystem ? RegistryView.Registry64 : RegistryView.Registry32 )\n                .OpenSubKey( name, writable );\n            return userKey;
﻿using System.Windows.Forms;\nusing Microsoft.Win32;\nusing System;\nusing System.Runtime.InteropServices;\nusing System.IO;
using Shadowsocks.Util;
        [DllImport("wininet.dll")]\n        public static extern bool InternetSetOption(IntPtr hInternet, int dwOption, IntPtr lpBuffer, int dwBufferLength);\n        public const int INTERNET_OPTION_SETTINGS_CHANGED = 39;\n        public const int INTERNET_OPTION_REFRESH = 37;\n        static bool _settingsReturn, _refreshReturn;\n        public static void NotifyIE()\n        {\n            // These lines implement the Interface in the beginning of program \n            // They cause the OS to refresh the settings, causing IP to realy update\n            _settingsReturn = InternetSetOption(IntPtr.Zero, INTERNET_OPTION_SETTINGS_CHANGED, IntPtr.Zero, 0);\n            _refreshReturn = InternetSetOption(IntPtr.Zero, INTERNET_OPTION_REFRESH, IntPtr.Zero, 0);\n        }\n        private static readonly DateTime UnixEpoch\n            = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc);\n        public static long ToUnixEpochMilliseconds(this DateTime dt)\n            => (long)(dt - UnixEpoch).TotalMilliseconds;
            RegistryKey registry = null;\n            try {\n                registry = Utils.OpenUserRegKey( @"Software\Microsoft\Windows\CurrentVersion\Internet Settings", true );\n                if ( registry == null ) {\n                    Logging.Error( @"Cannot find HKCU\Software\Microsoft\Windows\CurrentVersion\Internet Settings" );\n                    return;
                if ( enabled ) {\n                    if ( global ) {\n                        registry.SetValue( "ProxyEnable", 1 );\n                        registry.SetValue( "ProxyServer", "127.0.0.1:" + config.localPort.ToString() );\n                        registry.SetValue( "AutoConfigURL", "" );\n                    } else {\n                        string pacUrl;\n                        if ( config.useOnlinePac && ! config.pacUrl.IsNullOrEmpty() )\n                            pacUrl = config.pacUrl;\n                        else\n                            pacUrl = $"http://127.0.0.1:{config.localPort}/pac?t={GetTimestamp( DateTime.Now )}";\n                        registry.SetValue( "ProxyEnable", 0 );\n                        var readProxyServer = registry.GetValue( "ProxyServer" );\n                        registry.SetValue( "ProxyServer", "" );\n                        registry.SetValue( "AutoConfigURL", pacUrl );\n                    }\n                } else {\n                    registry.SetValue( "ProxyEnable", 0 );\n                    registry.SetValue( "ProxyServer", "" );\n                    registry.SetValue( "AutoConfigURL", "" );\n                }\n                //Set AutoDetectProxy\n                IEAutoDetectProxy( ! enabled );\n                NotifyIE();\n                //Must Notify IE first, or the connections do not chanage\n                CopyProxySettingFromLan();\n            } catch ( Exception e ) {\n                Logging.LogUsefulException( e );\n                // TODO this should be moved into views\n                MessageBox.Show( I18N.GetString( "Failed to update registry" ) );\n            } finally {\n                if ( registry != null ) {\n                    try {\n                        registry.Close();\n                        registry.Dispose();\n                    } catch (Exception e)\n                    { Logging.LogUsefulException(e); }
        }\n        private static void CopyProxySettingFromLan()\n        {\n            RegistryKey registry = null;\n            try {\n                registry = Utils.OpenUserRegKey( @"Software\Microsoft\Windows\CurrentVersion\Internet Settings\Connections", true );\n                if ( registry == null ) {\n                    Logging.Error( @"Cannot find HKCU\Software\Microsoft\Windows\CurrentVersion\Internet Settings\Connections" );\n                    return;\n                }\n                var defaultValue = registry.GetValue( "DefaultConnectionSettings" );\n                var connections = registry.GetValueNames();\n                foreach ( var each in connections ) {\n                    switch ( each.ToUpperInvariant() ) {\n                        case "DEFAULTCONNECTIONSETTINGS":\n                        case "LAN CONNECTION":\n                        case "SAVEDLEGACYSETTINGS":\n                            continue;\n                        default:\n                            //set all the connections's proxy as the lan\n                            registry.SetValue( each, defaultValue );\n                            continue;\n                    }\n                }\n                NotifyIE();\n            } catch ( IOException e ) {\n                Logging.LogUsefulException( e );\n            } finally {\n                if ( registry != null ) {\n                    try {\n                        registry.Close();\n                        registry.Dispose();\n                    } catch (Exception e)\n                    { Logging.LogUsefulException(e); }\n                }\n            }\n        }\n        /// <summary>\n        /// Checks or unchecks the IE Options Connection setting of "Automatically detect Proxy"\n        /// </summary>\n        /// <param name="set">Provide 'true' if you want to check the 'Automatically detect Proxy' check box. To uncheck, pass 'false'</param>\n        private static void IEAutoDetectProxy(bool set)\n        {\n            RegistryKey registry = null;\n            try {\n                registry = Utils.OpenUserRegKey( @"Software\Microsoft\Windows\CurrentVersion\Internet Settings\Connections", true );\n                if ( registry == null ) {\n                    Logging.Error( @"Cannot find HKCU\Software\Microsoft\Windows\CurrentVersion\Internet Settings\Connections" );\n                    return;\n                }\n                var defConnection = ( byte[] ) registry.GetValue( "DefaultConnectionSettings" );\n                var savedLegacySetting = ( byte[] ) registry.GetValue( "SavedLegacySettings" );\n                const int versionOffset = 4;\n                const int optionsOffset = 8;\n                if ( set ) {\n                    defConnection[ optionsOffset ] = ( byte ) ( defConnection[ optionsOffset ] | 8 );\n                    savedLegacySetting[ optionsOffset ] = ( byte ) ( savedLegacySetting[ optionsOffset ] | 8 );\n                } else {\n                    defConnection[ optionsOffset ] = ( byte ) ( defConnection[ optionsOffset ] & ~8 );\n                    savedLegacySetting[ optionsOffset ] = ( byte ) ( savedLegacySetting[ optionsOffset ] & ~8 );\n                }\n                BitConverter.GetBytes(unchecked( BitConverter.ToUInt32( defConnection, versionOffset ) + 1 ) )\n                            .CopyTo( defConnection, versionOffset );\n                BitConverter.GetBytes(unchecked( BitConverter.ToUInt32( savedLegacySetting, versionOffset ) + 1 ) )\n                            .CopyTo( savedLegacySetting, versionOffset );\n                registry.SetValue( "DefaultConnectionSettings", defConnection );\n                registry.SetValue( "SavedLegacySettings", savedLegacySetting );\n            } catch ( Exception e ) {\n                Logging.LogUsefulException( e );\n            } finally {\n                if (registry != null)\n                {\n                    try {\n                        registry.Close();\n                        registry.Dispose();\n                    } catch (Exception e)\n                    { Logging.LogUsefulException(e); }\n                }
            RegistryKey registry =\n                Registry.CurrentUser.OpenSubKey("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Connections",\n                    true);
                foreach (String each in connections)
                SystemProxy.NotifyIE();\n            } catch (IOException e) {
        }\n        private static String GetTimestamp(DateTime value)\n        {\n            return value.ToString("yyyyMMddHHmmssffff");
            RegistryKey registry =\n                Registry.CurrentUser.OpenSubKey("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Connections",\n                    true);\n            byte[] defConnection = (byte[])registry.GetValue("DefaultConnectionSettings");\n            byte[] savedLegacySetting = (byte[])registry.GetValue("SavedLegacySettings");
                defConnection[8] = Convert.ToByte(defConnection[8] & 8);\n                savedLegacySetting[8] = Convert.ToByte(savedLegacySetting[8] & 8);
                defConnection[8] = Convert.ToByte(defConnection[8] & ~8);\n                savedLegacySetting[8] = Convert.ToByte(savedLegacySetting[8] & ~8);
                FileStream _FileStream = new FileStream(fileName, FileMode.Create, FileAccess.Write);\n                _FileStream.Write(content, 0, content.Length);\n                _FileStream.Close();
            catch (Exception _Exception)
                                  _Exception.ToString());
            FileStream destinationFile = File.Create(fileName);
            using (GZipStream input = new GZipStream(new MemoryStream(content),
                    destinationFile.Write(buffer, 0, n);
            destinationFile.Close();
            this.tableLayoutPanel2 = new System.Windows.Forms.TableLayoutPanel();\n            this.listView1 = new System.Windows.Forms.ListView();\n            this.tableLayoutPanel3 = new System.Windows.Forms.TableLayoutPanel();
            this.tableLayoutPanel2.SuspendLayout();\n            this.tableLayoutPanel3.SuspendLayout();
            this.tableLayoutPanel1.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) \n            | System.Windows.Forms.AnchorStyles.Right)));
            this.tableLayoutPanel1.Controls.Add(this.label5, 0, 4);
            this.tableLayoutPanel1.Controls.Add(this.EncryptionSelect, 1, 4);
            this.tableLayoutPanel1.Controls.Add(this.label4, 0, 3);
            this.tableLayoutPanel1.Controls.Add(this.ProxyPortTextBox, 1, 3);\n            this.tableLayoutPanel1.Location = new System.Drawing.Point(246, 10);\n            this.tableLayoutPanel1.Margin = new System.Windows.Forms.Padding(10);
            this.panel1.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) \n            | System.Windows.Forms.AnchorStyles.Right)));
            this.panel1.Location = new System.Drawing.Point(311, 205);
            ((System.ComponentModel.ISupportInitialize)(this.numericUpDown2)).BeginInit();
            this.splitContainer2.Size = new System.Drawing.Size(1216, 459);\n            this.splitContainer2.SplitterDistance = 297;
            this.numericUpDown1.Location = new System.Drawing.Point(62, 142);
﻿using Shadowsocks.Model;\nusing Shadowsocks.Properties;\nusing System;
using System.IO.Compression;
using System.Net.NetworkInformation;\nusing System.Net;\nusing System.Runtime.InteropServices;
        private static string temppath;
            temppath = Utils.GetTempPath();
                FileManager.UncompressFile(temppath + "/ss_privoxy.exe", Resources.privoxy_exe);\n                FileManager.UncompressFile(temppath + "/mgwz.dll", Resources.mgwz_dll);
                FileManager.ByteArrayToFile(temppath + "/privoxy.conf", System.Text.Encoding.UTF8.GetBytes(polipoConfig));\n                if (!(temppath.EndsWith("\\") || temppath.EndsWith("/"))) {\n                    temppath = temppath + "\\";\n                }
                _process.StartInfo.FileName = temppath + "ss_privoxy.exe";\n                _process.StartInfo.Arguments = " \"" + temppath + "privoxy.conf\"";
﻿using Shadowsocks.Controller;
using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Runtime.InteropServices;\nusing System.Text;
﻿using Shadowsocks.Controller;\nusing Shadowsocks.Properties;\nusing Shadowsocks.View;\nusing System;\nusing System.Collections.Generic;
            Util.Utils.ReleaseMemory(true);
﻿using Shadowsocks.Controller;
using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Runtime.InteropServices;\nusing System.Text;
            string tempPath = Utils.GetTempPath();\n            string dllPath = tempPath + "/libsscrypto.dll";
﻿using Shadowsocks.Controller;
using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Runtime.InteropServices;\nusing System.Text;
            string tempPath = Utils.GetTempPath();\n            string dllPath = tempPath + "/libsscrypto.dll";
﻿using Shadowsocks.Util;\nusing System;\nusing System.Collections.Generic;
using System.Text;
                string temppath = Utils.GetTempPath();\n                LogFile = Path.Combine(temppath, "shadowsocks.log");
            if (!File.Exists(Utils.GetTempPath() + "\\gfwlist.txt"))
            List<string> lines = GFWListUpdater.ParseResult(File.ReadAllText(Utils.GetTempPath() + "\\gfwlist.txt"));
using System.Net;\nusing System.IO;
using SimpleJson;
using Shadowsocks.Model;
using System.Collections;
using System.Reflection;\nusing System.Text;
using System.IO;
            if (File.Exists(Application.StartupPath + "\\shadowsocks_portable_mode.txt"))
                try\n                {\n                    Directory.CreateDirectory(Application.StartupPath + "\\temp");\n                }\n                catch (Exception e)\n                {\n                    Logging.LogUsefulException(e);\n                }\n                // don't use "/", it will fail when we call explorer /select xxx/temp\xxx.log\n                return Application.StartupPath + "\\temp";
            return Path.GetTempPath();
                current.inboundCounter = inboundCounter;\n                current.outboundCounter = outboundCounter;\n                current.inboundIncreasement = inboundCounter - previous.inboundCounter;\n                current.outboundIncreasement = outboundCounter - previous.outboundCounter;
                if (TrafficChanged != null)\n                {\n                    TrafficChanged(this, new EventArgs());\n                }
                _totalWrite += bytesRead;\n                var session = (AsyncSession<bool>) ar.AsyncState;
                    /*\n                     * Only the first packet contains the socks5 header, it doesn't make sense to parse every packets. \n                     * Also it's unnecessary to parse these data if we turn off the VerboseLogging.\n                     */\n                    if (session.State && _config.isVerboseLogging)\n                    {\n                        int atyp = _connetionRecvBuffer[0];\n                        string dst_addr;\n                        int dst_port;\n                        switch (atyp)\n                        {\n                            case 1: // IPv4 address, 4 bytes\n                                dst_addr = new IPAddress(_connetionRecvBuffer.Skip(1).Take(4).ToArray()).ToString();\n                                dst_port = (_connetionRecvBuffer[5] << 8) + _connetionRecvBuffer[6];\n                                Logging.Info($"connect to {dst_addr}:{dst_port}");\n                                session.State = false;\n                                break;\n                            case 3: // domain name, length + str\n                                int len = _connetionRecvBuffer[1];\n                                dst_addr = System.Text.Encoding.UTF8.GetString(_connetionRecvBuffer, 2, len);\n                                dst_port = (_connetionRecvBuffer[len + 2] << 8) + _connetionRecvBuffer[len + 3];\n                                Logging.Info($"connect to {dst_addr}:{dst_port}");\n                                session.State = false;\n                                break;\n                            case 4: // IPv6 address, 16 bytes\n                                dst_addr = new IPAddress(_connetionRecvBuffer.Skip(1).Take(16).ToArray()).ToString();\n                                dst_port = (_connetionRecvBuffer[17] << 8) + _connetionRecvBuffer[18];\n                                Logging.Info($"connect to [{dst_addr}]:{dst_port}");\n                                session.State = false;\n                                break;\n                        }\n                    }\n                    int bytesToSend;\n                    lock (_encryptionLock)\n                    {\n                        _encryptor.Encrypt(_connetionRecvBuffer, bytesRead, _connetionSendBuffer, out bytesToSend);\n                    }\n                    _tcprelay.UpdateOutboundCounter(_server, bytesToSend);\n                    _startSendingTime = DateTime.Now;\n                    remote.BeginSend(_connetionSendBuffer, 0, bytesToSend, SocketFlags.None, new AsyncCallback(PipeRemoteSendCallback), session);\n                    IStrategy strategy = _controller.GetCurrentStrategy();\n                    strategy?.UpdateLastWrite(_server);
        public Server GetAServer(IStrategyCallerType type, IPEndPoint localIPEndPoint)
                return strategy.GetAServer(type, localIPEndPoint);
            if (Utils.IsPortableMode())\n            {\n                /*\n                 * Under PortableMode, we could identify it by the path of ss_privoxy.exe.\n                 */\n                try
                     * Sometimes Process.GetProcessesByName will return some processes that\n                     * are already dead, and that will cause exceptions here.\n                     * We could simply ignore those exceptions.
                    string path = process.MainModule.FileName;
                catch (Exception ex)\n                {\n                    Logging.LogUsefulException(ex);\n                    return false;\n                }\n            }\n            else\n            {\n                try
                catch (Win32Exception ex)\n                {\n                    if ((uint) ex.ErrorCode != 0x80004005)\n                    {\n                        throw;\n                    }\n                }
                    PolarSSL.aes_crypt_cfb128(_encryptCtx, isCipher ? PolarSSL.AES_ENCRYPT : PolarSSL.AES_DECRYPT, length, ref ivOffset, iv, buf, outbuf);
        public void TestEncryption()
                Thread t = new Thread(new ThreadStart(RunSingleEncryptionThread));
        private void ShowWindow()\n        {\n            this.Opacity = 1;\n            this.Show();\n            IPTextBox.Focus();\n        }\n        private bool SaveOldSelectedServer()
                Server server = new Server();\n                if (Uri.CheckHostName(server.server = IPTextBox.Text.Trim()) == UriHostNameType.Unknown)\n                {\n                    MessageBox.Show(I18N.GetString("Invalid server address"));\n                    IPTextBox.Focus();\n                    return false;\n                }\n                if (!int.TryParse(ServerPortTextBox.Text, out server.server_port))\n                {\n                    MessageBox.Show(I18N.GetString("Illegal port number format"));\n                    ServerPortTextBox.Focus();\n                    return false;\n                }\n                server.password = PasswordTextBox.Text;\n                server.method = EncryptionSelect.Text;\n                server.plugin = PluginTextBox.Text;\n                server.plugin_opts = PluginOptionsTextBox.Text;\n                server.plugin_args = PluginArgumentsTextBox.Text;\n                server.remarks = RemarksTextBox.Text;\n                if (!int.TryParse(TimeoutTextBox.Text, out server.timeout))\n                {\n                    MessageBox.Show(I18N.GetString("Illegal timeout format"));\n                    TimeoutTextBox.Focus();\n                    return false;\n                }\n                int localPort = int.Parse(ProxyPortTextBox.Text);
                Configuration.CheckLocalPort(localPort);
                _modifiedConfiguration.localPort = localPort;\n                _modifiedConfiguration.portableMode = PortableModeCheckBox.Checked;
        private void LoadSelectedServer()
                IPTextBox.Text = server.server;\n                ServerPortTextBox.Text = server.server_port.ToString();\n                PasswordTextBox.Text = server.password;\n                ProxyPortTextBox.Text = _modifiedConfiguration.localPort.ToString();\n                EncryptionSelect.Text = server.method ?? "aes-256-cfb";\n                PluginTextBox.Text = server.plugin;\n                PluginOptionsTextBox.Text = server.plugin_opts;\n                PluginArgumentsTextBox.Text = server.plugin_args;\n                RemarksTextBox.Text = server.remarks;\n                TimeoutTextBox.Text = server.timeout.ToString();\n            }\n        }\n        private void LoadConfiguration(Configuration configuration)
            foreach (Server server in _modifiedConfiguration.configs)
            LoadConfiguration(_modifiedConfiguration);
            UpdateMoveUpAndDownButton();\n            LoadSelectedServer();
        }\n        private void ConfigForm_Load(object sender, EventArgs e)\n        {
                if (!SaveOldSelectedServer())
            if (!SaveOldSelectedServer())
            UpdateMoveUpAndDownButton();\n            LoadSelectedServer();
            if (!SaveOldSelectedServer())
            LoadConfiguration(_modifiedConfiguration);
            if (!SaveOldSelectedServer())
            LoadConfiguration(_modifiedConfiguration);
            LoadConfiguration(_modifiedConfiguration);
            LoadSelectedServer();
            if (!SaveOldSelectedServer())
            UpdateMoveUpAndDownButton();\n        }\n        private void UpdateMoveUpAndDownButton()\n        {\n            if (ServersListBox.SelectedIndex == 0)\n            {\n                MoveUpButton.Enabled = false;\n            }\n            else\n            {\n                MoveUpButton.Enabled = true;\n            }\n            if (ServersListBox.SelectedIndex == ServersListBox.Items.Count - 1)\n            {\n                MoveDownButton.Enabled = false;\n            }\n            else\n            {\n                MoveDownButton.Enabled = true;\n            }
            if (!SaveOldSelectedServer())
        : EncryptorBase, IDisposable
        static Dictionary<string, int[]> ciphers = new Dictionary<string, int[]> {\n            {"aes-128-cfb", new int[]{16, 16, CIPHER_AES, PolarSSL.AES_CTX_SIZE}},\n            {"aes-192-cfb", new int[]{24, 16, CIPHER_AES, PolarSSL.AES_CTX_SIZE}},\n            {"aes-256-cfb", new int[]{32, 16, CIPHER_AES, PolarSSL.AES_CTX_SIZE}},\n            {"rc4", new int[]{16, 0, CIPHER_RC4, PolarSSL.ARC4_CTX_SIZE}},\n            {"rc4-md5", new int[]{16, 16, CIPHER_RC4, PolarSSL.ARC4_CTX_SIZE}},\n        };\n        private static readonly Dictionary<string, byte[]> CachedKeys = new Dictionary<string, byte[]>();\n        private int _cipher;\n        private int[] _cipherInfo;\n        private byte[] _key;
        private byte[] _encryptIV;\n        private byte[] _decryptIV;\n        private int _encryptIVOffset = 0;\n        private int _decryptIVOffset = 0;\n        private string _method;\n        private int keyLen;\n        private int ivLen;
        private static void randBytes(byte[] buf, int length)
            byte[] temp = new byte[length];\n            new Random().NextBytes(temp);\n            temp.CopyTo(buf, 0);
        private void bytesToKey(byte[] password, byte[] key)
            byte[] result = new byte[password.Length + 16];\n            int i = 0;\n            byte[] md5sum = null;\n            while (i < key.Length)
                MD5 md5 = MD5.Create();\n                if (i == 0)\n                {\n                    md5sum = md5.ComputeHash(password);\n                }\n                else\n                {\n                    md5sum.CopyTo(result, 0);\n                    password.CopyTo(result, md5sum.Length);\n                    md5sum = md5.ComputeHash(result);\n                }\n                md5sum.CopyTo(key, i);\n                i += md5sum.Length;\n            }\n        }\n        private void InitKey(string method, string password)\n        {\n            method = method.ToLower();\n            _method = method;\n            string k = method + ":" + password;\n            _cipherInfo = ciphers[_method];\n            _cipher = _cipherInfo[2];\n            if (_cipher == 0)\n            {\n                throw new Exception("method not found");\n            }\n            keyLen = ciphers[_method][0];\n            ivLen = ciphers[_method][1];\n            if (CachedKeys.ContainsKey(k))\n            {\n                _key = CachedKeys[k];
                byte[] passbuf = Encoding.UTF8.GetBytes(password);\n                _key = new byte[32];\n                byte[] iv = new byte[16];\n                bytesToKey(passbuf, _key);\n                CachedKeys[k] = _key;
        }\n        private void InitCipher(ref IntPtr ctx, byte[] iv, bool isCipher)\n        {\n            ctx = Marshal.AllocHGlobal(_cipherInfo[3]);
                if (isCipher)\n                {\n                    _encryptIV = new byte[ivLen];\n                    Array.Copy(iv, _encryptIV, ivLen);\n                }\n                else\n                {\n                    _decryptIV = new byte[ivLen];\n                    Array.Copy(iv, _decryptIV, ivLen);\n                }
        static byte[] tempbuf = new byte[32768];\n        public override void Encrypt(byte[] buf, int length, byte[] outbuf, out int outlength)
            if (_encryptCtx == IntPtr.Zero)
                randBytes(outbuf, ivLen);\n                InitCipher(ref _encryptCtx, outbuf, true);\n                outlength = length + ivLen;\n                lock (tempbuf)\n                {\n                    // C# could be multi-threaded\n                    if (_disposed)\n                    {\n                        throw new ObjectDisposedException(this.ToString());\n                    }\n                    switch (_cipher)\n                    {\n                        case CIPHER_AES:\n                            PolarSSL.aes_crypt_cfb128(_encryptCtx, PolarSSL.AES_ENCRYPT, length, ref _encryptIVOffset, _encryptIV, buf, tempbuf);\n                            break;\n                        case CIPHER_RC4:\n                            PolarSSL.arc4_crypt(_encryptCtx, length, buf, tempbuf);\n                            break;\n                    }\n                    outlength = length + ivLen;\n                    Buffer.BlockCopy(tempbuf, 0, outbuf, ivLen, length);\n                }
                outlength = length;\n                if (_disposed)\n                {\n                    throw new ObjectDisposedException(this.ToString());\n                }\n                switch (_cipher)\n                {\n                    case CIPHER_AES:\n                        PolarSSL.aes_crypt_cfb128(_encryptCtx, PolarSSL.AES_ENCRYPT, length, ref _encryptIVOffset, _encryptIV, buf, outbuf);\n                        break;\n                    case CIPHER_RC4:\n                        PolarSSL.arc4_crypt(_encryptCtx, length, buf, outbuf);\n                        break;\n                }
        }\n        public override void Decrypt(byte[] buf, int length, byte[] outbuf, out int outlength)\n        {\n            if (_decryptCtx == IntPtr.Zero)
                InitCipher(ref _decryptCtx, buf, false);\n                outlength = length - ivLen;\n                lock (tempbuf)\n                {\n                    // C# could be multi-threaded\n                    Buffer.BlockCopy(buf, ivLen, tempbuf, 0, length - ivLen);\n                    if (_disposed)
                        throw new ObjectDisposedException(this.ToString());
                    switch (_cipher)
                        case CIPHER_AES:\n                            PolarSSL.aes_crypt_cfb128(_decryptCtx, PolarSSL.AES_DECRYPT, length - ivLen, ref _decryptIVOffset, _decryptIV, tempbuf, outbuf);\n                            break;\n                        case CIPHER_RC4:\n                            PolarSSL.arc4_crypt(_decryptCtx, length - ivLen, tempbuf, outbuf);\n                            break;
                }\n            }\n            else\n            {\n                outlength = length;\n                if (_disposed)\n                {\n                    throw new ObjectDisposedException(this.ToString());\n                }\n                switch (_cipher)\n                {\n                    case CIPHER_AES:\n                        PolarSSL.aes_crypt_cfb128(_decryptCtx, PolarSSL.AES_DECRYPT, length, ref _decryptIVOffset, _decryptIV, buf, outbuf);\n                        break;\n                    case CIPHER_RC4:\n                        PolarSSL.arc4_crypt(_decryptCtx, length, buf, outbuf);\n                        break;\n                }
                string tempPath = Path.GetTempPath();\n                string dllPath = tempPath + "/polarssl.dll";
                LoadLibrary(dllPath);
            byte[] pacGZ = Resources.proxy_pac_txt;\n            byte[] buffer = new byte[1024 * 1024];  // builtin pac gzip size: maximum 1M\n            int n;\n            using (GZipStream input = new GZipStream(new MemoryStream(pacGZ),\n                CompressionMode.Decompress, false))
                n = input.Read(buffer, 0, buffer.Length);\n                if (n == 0)
                    throw new IOException("can not decompress pac");
                return System.Text.Encoding.UTF8.GetString(buffer, 0, n);
            local.Start();\n            pacServer = new PACServer();\n            pacServer.Start();
            this.aboutItem.Index = 2;
        protected override Dictionary<string, int[]> getCiphers()\n        {\n            return new Dictionary<string, int[]> {
            };
            return new Dictionary<string, int[]> {\n                {"salsa20", new int[]{32, 8, CIPHER_SALSA20, PolarSSL.AES_CTX_SIZE}},\n                {"chacha20", new int[]{32, 8, CIPHER_CHACHA20, PolarSSL.AES_CTX_SIZE}},\n            }; ;
            if (string.IsNullOrEmpty(method) || method.ToLowerInvariant() == "table")
                return new TableEncryptor(method, password);
            return new SodiumEncryptor(method, password);
            this.btnOK.Location = new System.Drawing.Point(333, 9);
            this.btnCancel.Location = new System.Drawing.Point(204, 9);
            this.btnRegisterAll.Location = new System.Drawing.Point(75, 9);
﻿using System;\nusing System.Collections.Generic;
using System.Linq;
using Shadowsocks.Controller;\nusing Shadowsocks.Model;\nusing Shadowsocks.Properties;
﻿using System;\nusing System.Collections.Generic;
    using Shadowsocks.Properties;
        private static void Init(string res)
            using (var sr = new StringReader(res))
                foreach (var line in sr.NonWhiteSpaceLines())
                    if (line[0] == '#')\n                        continue;\n                    var pos = line.IndexOf('=');\n                    if (pos < 1)\n                        continue;\n                    _strings[line.Substring(0, pos)] = line.Substring(pos + 1);
            string name = CultureInfo.CurrentCulture.EnglishName;\n            if (name.StartsWith("Chinese", StringComparison.OrdinalIgnoreCase))\n            {\n                // choose Traditional Chinese only if we get explicit indication\n                Init(name.Contains("Traditional")\n                    ? Resources.zh_TW\n                    : Resources.zh_CN);\n            }\n            else if (name.StartsWith("Japan", StringComparison.OrdinalIgnoreCase))\n            {\n                Init(Resources.ja);\n            }
using Shadowsocks.Controller;\nusing Shadowsocks.Model;\nusing Shadowsocks.Properties;
            AddButton.Text = I18N.GetString("&Add");\n            DeleteButton.Text = I18N.GetString("&Delete");\n            DuplicateButton.Text = I18N.GetString("Dupli&cate");\n            IPLabel.Text = I18N.GetString("Server Addr");\n            ServerPortLabel.Text = I18N.GetString("Server Port");\n            PasswordLabel.Text = I18N.GetString("Password");\n            ShowPasswdCheckBox.Text = I18N.GetString("Show Password");\n            EncryptionLabel.Text = I18N.GetString("Encryption");\n            PluginLabel.Text = I18N.GetString("Plugin Program");\n            PluginOptionsLabel.Text = I18N.GetString("Plugin Options");\n            PluginArgumentsLabel.Text = I18N.GetString("Plugin Arguments");\n            NeedPluginArgCheckBox.Text = I18N.GetString("Need Plugin Argument");\n            ProxyPortLabel.Text = I18N.GetString("Proxy Port");\n            PortableModeCheckBox.Text = I18N.GetString("Portable Mode");
            RemarksLabel.Text = I18N.GetString("Remarks");\n            TimeoutLabel.Text = I18N.GetString("Timeout(Sec)");\n            ServerGroupBox.Text = I18N.GetString("Server");\n            OKButton.Text = I18N.GetString("OK");\n            MyCancelButton.Text = I18N.GetString("Cancel");\n            ApplyButton.Text = I18N.GetString("Apply");\n            MoveUpButton.Text = I18N.GetString("Move &Up");\n            MoveDownButton.Text = I18N.GetString("Move D&own");\n            Text = I18N.GetString("Edit Servers");
﻿using System.Reflection;
        public static HotkeyCallbacks Instance { get; private set; }
using System.Threading;
        private Dictionary<string, StatisticsData> _statistics;\n        private const int CachedInterval = 30*60*1000; //choose a new server every 30 minutes\n        private const int RetryInterval = 2*60*1000; //choose a new server every 30 minutes
        /*\n        return a dict:\n        {\n            'ServerFriendlyName1':StatisticsData,\n            'ServerFriendlyName2':...\n        }\n        */
                    LogWhenEnabled($"statistics file does not exist, try to reload {RetryInterval} minutes later");\n                    _timer.Change(RetryInterval, CachedInterval);
                _statistics = (from l in File.ReadAllLines(path)\n                                  .Skip(1)\n                                  let strings = l.Split(new[] { "," }, StringSplitOptions.RemoveEmptyEntries)\n                                  let rawData = new\n                                  {\n                                      ServerName = strings[1],\n                                      IPStatus = strings[2],\n                                      RoundtripTime = int.Parse(strings[3])\n                                  }\n                                  group rawData by rawData.ServerName into server\n                                  select new\n                                  {\n                                      ServerName = server.Key,\n                                      data = new StatisticsData\n                                      {\n                                          SuccessTimes = server.Count(data => IPStatus.Success.ToString().Equals(data.IPStatus)),\n                                          TimedOutTimes = server.Count(data => IPStatus.TimedOut.ToString().Equals(data.IPStatus)),\n                                          AverageResponse = Convert.ToInt32(server.Average(data => data.RoundtripTime)),\n                                          MinResponse = server.Min(data => data.RoundtripTime),\n                                          MaxResponse = server.Max(data => data.RoundtripTime)\n                                      }\n                                  }).ToDictionary(server => server.ServerName, server => server.data);
        private static double GetScore(StatisticsData data)\n        {\n            return (double)data.SuccessTimes / (data.SuccessTimes + data.TimedOutTimes); //simply choose min package loss
            public int SuccessTimes;\n            public int TimedOutTimes;
            if (_statistics == null || servers.Count == 0)
                                  where _statistics.ContainsKey(name)
                                      score = GetScore(_statistics[name])
        public CalculationControl(string value)
            valueLabel.Text = value;
        public float Factor => float.Parse(factorNum.Text);
            System.Windows.Forms.DataVisualization.Charting.Series series3 = new System.Windows.Forms.DataVisualization.Charting.Series();
            this.bindingConfiguration = new System.Windows.Forms.BindingSource(this.components);
            series1.ChartType = System.Windows.Forms.DataVisualization.Charting.SeriesChartType.Area;\n            series1.Color = System.Drawing.Color.FromArgb(((int)(((byte)(204)))), ((int)(((byte)(204)))), ((int)(((byte)(204)))));
            series1.Name = "Data Transferred";
            series2.ChartType = System.Windows.Forms.DataVisualization.Charting.SeriesChartType.Bubble;\n            series2.Color = System.Drawing.Color.FromArgb(((int)(((byte)(221)))), ((int)(((byte)(88)))), ((int)(((byte)(0)))));
            series2.Name = "Package Loss";\n            series2.YValuesPerPoint = 4;\n            series3.BorderWidth = 4;\n            series3.ChartArea = "ChartArea";\n            series3.ChartType = System.Windows.Forms.DataVisualization.Charting.SeriesChartType.Line;\n            series3.Color = System.Drawing.Color.FromArgb(((int)(((byte)(155)))), ((int)(((byte)(77)))), ((int)(((byte)(150)))));\n            series3.Legend = "ChartLegend";\n            series3.Name = "Ping";
            this.StatisticsChart.Series.Add(series3);\n            this.StatisticsChart.Size = new System.Drawing.Size(951, 222);
using SimpleJson = SimpleJson.SimpleJson;
        private const int Repeat = 4; //repeat times every evaluation\n        private const int Interval = 10*60*1000; //evaluate proxies every 15 minutes\n        private const int delayBeforeStart = 1*1000; //delay 1 second before start
            string temppath = Utils.GetTempPath();
        public bool Set(bool enabled)
                if (enabled)
                    if (_timer?.Change(0, Interval) == null)
                        _timer = new Timer(Evaluate, _state, 0, Interval);
        private static async Task<List<DataList>> ICMPTest(Server server)
                var timestamp in Enumerable.Range(0, Repeat).Select(_ => DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss")))
                    var reply = await ping.SendTaskAsync(server.server, Timeout);
            File.AppendAllLines(AvailabilityStatisticsFile, lines);
        internal void UpdateConfiguration(Configuration config)
            Set(config.availabilityStatistics);
        private class State
            RegistryKey runKey = null;
                RegistryKey hkcr = RegistryKey.OpenBaseKey(RegistryHive.ClassesRoot,\n                        Environment.Is64BitOperatingSystem ? RegistryView.Registry64 : RegistryView.Registry32);\n                runKey = hkcr.CreateSubKey("ss",RegistryKeyPermissionCheck.ReadWriteSubTree);\n                if (runKey == null)
                    runKey.SetValue("", "URL:Shadowsocks");\n                    runKey.SetValue("URL Protocol", "");\n                    var shellOpen = runKey.CreateSubKey("shell").CreateSubKey("open").CreateSubKey("command");
                    hkcr.DeleteSubKeyTree("ss");
                        runKey.Close();\n                        runKey.Dispose();
            RegistryKey runKey = null;
                runKey = Utils.OpenRegKey(@"ss", true, RegistryHive.ClassesRoot);\n                if (runKey == null)
                    logger.Error(@"Cannot find HKCR\ss");
                var shellOpen = runKey.OpenSubKey("shell").OpenSubKey("open").OpenSubKey("command");
                        runKey.Close();\n                        runKey.Dispose();
[assembly: AssemblyCompany("")]
[assembly: AssemblyCopyright("Copyright ©  2014")]
        public static void ReleaseMemory()
            SetProcessWorkingSetSize(Process.GetCurrentProcess().Handle,\n                (UIntPtr)0xFFFFFFFF, (UIntPtr)0xFFFFFFFF);
            ((IDisposable)encryptor).Dispose();
                    encryptor.Decrypt(remoteRecvBuffer, bytesRead, remoteSendBuffer, out bytesToSend);
                    encryptor.Encrypt(connetionRecvBuffer, bytesRead, connetionSendBuffer, out bytesToSend);
                Console.WriteLine(e.Message);
            using (Mutex mutex = new Mutex(false, "Global\\Shadowsocks_" + Application.StartupPath.GetHashCode()))
                MessageBox.Show(I18N.GetString("Unexpected error, shadowsocks will exit. Please report to") +\n                    " https://github.com/shadowsocks/shadowsocks-windows/issues " +\n                    Environment.NewLine + (e.ExceptionObject?.ToString()),
                        Logging.Error("socks 5 protocol error");
                Logging.LogUsefulException(e);
                            Logging.Debug("Unsupported CMD=" + _command);
                Logging.LogUsefulException(e);
                        Logging.Info($"connect to {dstAddr}:{dstPort}");
                    Logging.Debug("failed to recv data in Shadowsocks.Controller.TCPHandler.OnAddressFullyRead()");
                Logging.LogUsefulException(e);
                Logging.Debug($"_firstPacketLength = {_firstPacketLength}");
                Logging.LogUsefulException(e);
                            Logging.Error("decryption error");
                    Logging.Info(
                Logging.Error("Failed to start SIP003 plugin: " + ex.Message);
                Logging.LogUsefulException(e);
            Logging.Debug($"save statistics to {AvailabilityStatisticsFile}");
                Logging.LogUsefulException(e);
                Logging.Debug($"loading statistics from {path}");
                    Logging.Error($"An exception occured while eveluating {server.FriendlyName()}");\n                    Logging.LogUsefulException(e);
                    Logging.Error($"An exception occured while eveluating {server.FriendlyName()}");\n                    Logging.LogUsefulException(ex);
            Logging.Dump("Salt", salt, saltLen);
                    Logging.Error($"Invalid chunk length: {chunkLen}");
﻿using System;
﻿using Shadowsocks.Model;
                    Logging.Info($"HA switching to server: {_currentServer.server.FriendlyName()}");
                    Logging.Info(Encryption.EncryptorFactory.DumpRegisteredEncryptor());
                Logging.Debug("Checking updates...");
                Logging.LogUsefulException(ex);
                    Logging.Debug("No update is available");
                Logging.LogUsefulException(ex);
                Logging.Debug($"New version {LatestVersionNumber}{LatestVersionSuffix} found: {LatestVersionLocalName}");
                Logging.LogUsefulException(ex);
            Logging.Dump("_decNonce before dec", _decNonce, nonceLen);\n            Logging.Dump("_sodiumDecSubkey", _sodiumDecSubkey, keyLen);\n            Logging.Dump("before cipherDecrypt: cipher", ciphertext, (int) clen);
                Logging.Debug(_localEndPoint, _remoteEndPoint, outlen, "UDP Relay");
                Logging.OpenLogFile();
#else\n                Logging.OpenLogFile();
                Logging.Error(errMsg);
                                Logging.LogUsefulException(ex);
                Socket conn = listener.EndAccept(ar);
            catch (Exception e)
        public static string GetString(string key)
                ? _strings[key]\n                : key;
            IPEndPoint[] ipEndPoints = ipProperties.GetActiveTcpListeners();\n            foreach (IPEndPoint endPoint in ipEndPoints)\n            {\n                if (endPoint.Port == port)\n                {\n                    return true;\n                }\n            }\n            return false;
                throw new Exception(I18N.GetString("Port already in use"));
            // TODO resolving by proxy\n            IPAddress ipAddress;\n            bool parsed = IPAddress.TryParse(host, out ipAddress);\n            if (!parsed)\n            {\n                IPHostEntry ipHostInfo = Dns.GetHostEntry(host);\n                ipAddress = ipHostInfo.AddressList[0];\n            }\n            IPEndPoint ep = new IPEndPoint(ipAddress, port);
            switch (ep.AddressFamily)\n            {\n                case AddressFamily.InterNetwork:\n                    request = new byte[4 + 4 + 2];\n                    atyp = 1;\n                    break;\n                case AddressFamily.InterNetworkV6:\n                    request = new byte[4 + 16 + 2];\n                    atyp = 4;\n                    break;\n            }\n            if (request == null)\n            {\n                throw new Exception(I18N.GetString("Proxy request faild"));\n            }\n            // 构造request包\n            var addr = ep.Address.GetAddressBytes();
            Array.Copy(addr, 0, request, 4, request.Length - 4 - 2);\n            request[request.Length - 2] = (byte) ((ep.Port >> 8) & 0xff);\n            request[request.Length - 1] = (byte) (ep.Port & 0xff);
                            // Note by wongsyrone: this will be stripped out in Release version\n                            Logging.Debug($"connect to {dst_addr}:{dst_port}");
                            Logging.Debug($"connect to {dst_addr}:{dst_port}");
                            Logging.Debug($"connect to [{dst_addr}]:{dst_port}");
            if (CultureInfo.CurrentCulture.IetfLanguageTag.StartsWith("zh", StringComparison.OrdinalIgnoreCase))
                using (var sr = new StringReader(Resources.cn))
                    foreach (var line in sr.NonWhiteSpaceLines())\n                    {\n                        if (line[0] == '#')\n                            continue;\n                        var pos = line.IndexOf('=');\n                        if (pos < 1)\n                            continue;\n                        Strings[line.Substring(0, pos)] = line.Substring(pos + 1);\n                    }
            if (userSettingsArr.Length == 1)
            var sb = new StringBuilder($"{Environment.NewLine}{tag}: ");\n            for (int i = 0; i < length - 1; i++)
                sb.Append($"0x{arr[i]:X2}, ");
            sb.Append($"0x{arr[length - 1]:X2}");\n            sb.Append(Environment.NewLine);\n            logger.Debug(sb.ToString());
            if (header == null && tailer == null)\n                logger.Debug($"{local} => {remote} (size={len})");\n            else if (header == null && tailer != null)\n                logger.Debug($"{local} => {remote} (size={len}), {tailer}");\n            else if (header != null && tailer == null)\n                logger.Debug($"{header}: {local} => {remote} (size={len})");\n            else\n                logger.Debug($"{header}: {local} => {remote} (size={len}), {tailer}");
            logger.Debug(sock.LocalEndPoint, sock.RemoteEndPoint, len, header, tailer);
                var configuration = JsonConvert.DeserializeObject<StatisticsStrategyConfiguration>(content);
            catch (FileNotFoundException e)
        protected static bool SerializeValue(IJsonSerializerStrategy jsonSerializerStrategy, object value, StringBuilder builder)
                success = SerializeObject(jsonSerializerStrategy, dict.Keys, dict.Values, builder);
                success = SerializeObject(jsonSerializerStrategy, dict.Keys, dict.Values, builder);
                success = SerializeArray(jsonSerializerStrategy, (IEnumerable)value, builder);
                    SerializeValue(jsonSerializerStrategy, serializedObject, builder);
        protected static bool SerializeObject(IJsonSerializerStrategy jsonSerializerStrategy, IEnumerable keys, IEnumerable values, StringBuilder builder)
                    if (!SerializeValue(jsonSerializerStrategy, value, builder)) return false;
                if (!SerializeValue(jsonSerializerStrategy, value, builder))
            builder.Append("}\r\n");
        protected static bool SerializeArray(IJsonSerializerStrategy jsonSerializerStrategy, IEnumerable anArray, StringBuilder builder)\n        {\n            builder.Append("[\r\n  ");
                    builder.Append(",\r\n  ");\n                if (!SerializeValue(jsonSerializerStrategy, value, builder))
            builder.Append("\r\n]");
            if (_rng == null)\n                _rng = new RNGCryptoServiceProvider();
            if (_rng == null) return;\n            _rng.Dispose();
            if (_rng == null) Reload();
            catch (System.Exception)
                string[] lines = ParseResult(e.Result);\n                JsonArray rules = new JsonArray();\n                rules.AddRange(lines);
                abpContent = abpContent.Replace("__RULES__", rules.ToString());
        public string[] ParseResult(string response)
            catch (Exception)
                MessageBox.Show("can not change registry!");\n                throw;
            catch (Exception)
                MessageBox.Show("can not change registry!");\n                throw;
        private Encryptor encryptor;
            this.encryptor = new Encryptor(config.method, config.password);
            if (enabled)
                if (global)
                    WinINet.SetIEProxy(true, true, "127.0.0.1:" + config.localPort.ToString(), "");
                    string pacUrl;\n                    if (config.useOnlinePac && !config.pacUrl.IsNullOrEmpty())\n                        pacUrl = config.pacUrl;\n                    else\n                        pacUrl = $"http://127.0.0.1:{config.localPort}/pac?t={GetTimestamp(DateTime.Now)}";\n                    WinINet.SetIEProxy(true, false, "", pacUrl);
            else
                WinINet.SetIEProxy(false, false, "", "");
            LogMessageTextBox.WordWrap = WrapTextCheckBox.Checked = WrapTextMenuItem.Checked = wrapTextTrigger;\n            ToolbarFlowLayoutPanel.Visible = toolbarTrigger;
            if (_key.Length < keyLen) Array.Resize(ref _key, keyLen);\n            LegacyDeriveKey(passbuf, _key);
        public static void LegacyDeriveKey(byte[] password, byte[] key)
            byte[] result = new byte[password.Length + 16];
            while (i < key.Length) {
                    md5sum.CopyTo(result, 0);\n                    password.CopyTo(result, md5sum.Length);
                md5sum.CopyTo(key, i);\n                i += md5sum.Length;
            if (_Masterkey.Length < keyLen) Array.Resize(ref _Masterkey, keyLen);\n            DeriveKey(passbuf, _Masterkey);
        public void DeriveKey(byte[] password, byte[] key)\n        {\n            StreamEncryptor.LegacyDeriveKey(password, key);
        public string FriendlyName
            get
                if (string.IsNullOrEmpty(server))\n                {\n                    return I18N.GetString("New server");\n                }\n                return string.IsNullOrEmpty(remarks) ? server + ":" + server_port : server + ":" + server_port + " (" + remarks + ")";
                string temppath = Path.GetTempPath();
                FileManager.UncompressFile(temppath + "/ss_polipo.exe", Resources.polipo_exe);
        public IProxy remote;
            public IProxy Proxy;
                proxyTimer.Proxy = remote;
                remote.BeginConnectProxy(proxyEP, new AsyncCallback(ProxyConnectCallback), proxyTimer);
            var proxy = ((ProxyTimer)sender).Proxy;
            remote?.Close();
                ProxyTimer timer = (ProxyTimer)ar.AsyncState;
                remote.BeginConnectDest(destEndPoint, new AsyncCallback(ConnectCallback), connectTimer);
            remote?.Close();
                ServerTimer timer = (ServerTimer)ar.AsyncState;
        private void StartPipe()
                remote?.BeginReceive(_remoteRecvBuffer, 0, RecvSize, SocketFlags.None, new AsyncCallback(PipeRemoteReceiveCallback), null);
                    true /* to tell the callback this is the first time reading packet, and we haven't found the header yet. */);
                    object needToFindHeader = null;\n                    if (ar.AsyncState != null && _config.isVerboseLogging)
                                break;\n                            default:\n                                needToFindHeader = true; // Still not found, try next packet.
                remote?.BeginReceive(_remoteRecvBuffer, 0, RecvSize, SocketFlags.None, new AsyncCallback(PipeRemoteReceiveCallback), null);
        const int CIPHER_BF = 3;
            {"bf-cfb", new int[]{16, 8, CIPHER_BF, PolarSSL.BLOWFISH_CTX_SIZE}},
                    _remote = SocketUtil.CreateSocket(remoteEP);\n                    _remote.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);
                    _remote.BeginConnect(remoteEP,\n                        new AsyncCallback(ConnectCallback), null);
            if (_remote == null)\n            {\n                _remote = SocketUtil.CreateSocket(destEndPoint);\n                _remote.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n            }\n            _remote.BeginConnect(destEndPoint, callback, state);
            _remote?.EndConnect(asyncResult);
            _remote = SocketUtil.CreateSocket(remoteEP);\n            _remote.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);
            _remote.BeginConnect(remoteEP, ConnectCallback, st);
        public static Socket CreateSocket(EndPoint endPoint, ProtocolType protocolType = ProtocolType.Tcp)
            SocketType socketType;\n            switch (protocolType)
                case ProtocolType.Tcp:\n                    socketType = SocketType.Stream;\n                    break;\n                case ProtocolType.Udp:\n                    socketType = SocketType.Dgram;\n                    break;\n                default:\n                    throw new NotSupportedException("Protocol " + protocolType + " doesn't supported!");
            if (endPoint is DnsEndPoint)
                // use dual-mode socket\n                var socket = new Socket(AddressFamily.InterNetworkV6, socketType, protocolType);\n                socket.SetSocketOption(SocketOptionLevel.IPv6, (SocketOptionName)27, false);\n                return socket;
            else
                return new Socket(endPoint.AddressFamily, socketType, protocolType);
                        if ((bool)release["prerelease"])
                            Asset ass = new Asset();\n                            ass.Parse(asset);\n                            if (ass.IsNewVersion(Version))
                                asserts.Add(ass);
            public bool IsNewVersion(string currentVersion)\n            {\n                if (prerelease)
                return CompareVersion(version, currentVersion) > 0;\n            }\n            public void Parse(JObject asset)\n            {\n                name = (string)asset["name"];\n                browser_download_url = (string)asset["browser_download_url"];\n                version = ParseVersionFromURL(browser_download_url);\n                prerelease = browser_download_url.IndexOf("prerelease", StringComparison.Ordinal) >= 0;\n            }\n            private static string ParseVersionFromURL(string url)\n            {\n                Match match = Regex.Match(url, @".*Shadowsocks-win.*?-([\d\.]+)\.\w+", RegexOptions.IgnoreCase);\n                if (match.Success)\n                {\n                    if (match.Groups.Count == 2)\n                    {\n                        return match.Groups[1].Value;\n                    }\n                }\n                return null;
                SystemProxy.Disable();
                    _controller?.Start();
            if (!_established)
                st.innerState.ex = new Exception(I18N.GetString("Proxy request failed"));
            st.innerState.Callback?.Invoke(st);
                    SendResponse(firstPacket, length, socket, useSocks);
            byte[] cipher = new byte[plain.Length + 16];
            encryptor.Encrypt(plain, plain.Length, cipher, out outLen);
            encryptor.Encrypt(plain, 1000, cipher, out outLen);
            encryptor.Encrypt(plain, 12333, cipher, out outLen);
        public const int ONETIMEAUTH_BYTES = 16;\n        public const int ONETIMEAUTH_KEYBYTES = 32;\n        public const int HASH_BYTES = 4;
        public const int AUTH_BYTES = HASH_BYTES + CLEN_BYTES;
        protected int ss_onetimeauth(byte[] auth, byte[] msg, int msg_len)\n        {\n            byte[] auth_key = new byte[ONETIMEAUTH_KEYBYTES];\n            byte[] auth_bytes = new byte[MAX_IV_LENGTH + MAX_KEY_LENGTH];\n            Buffer.BlockCopy(_encryptIV, 0, auth_bytes, 0, ivLen);\n            Buffer.BlockCopy(_key, 0, auth_bytes, ivLen, keyLen);\n            Sodium.crypto_generichash(auth_key, ONETIMEAUTH_KEYBYTES, auth_bytes, (ulong)(ivLen + keyLen), null, 0);\n            return Sodium.crypto_onetimeauth(auth, msg, (ulong)msg_len, auth_key);\n        }\n        protected void ss_gen_hash(byte[] buf, ref int offset, ref int len, int buf_size)\n        {\n            int size = len + AUTH_BYTES;\n            if (buf_size < (size + offset))\n                throw new Exception("failed to generate hash:  buffer size insufficient");
            byte[] hash = new byte[HASH_BYTES];\n            byte[] tmp = new byte[len];\n            Buffer.BlockCopy(buf, offset, tmp, 0, len);\n            Sodium.crypto_generichash(hash, HASH_BYTES, tmp, (ulong)len, _keyBuffer, (uint)_keyBuffer.Length);\n            Buffer.BlockCopy(buf, offset, buf, offset + AUTH_BYTES, len);\n            Buffer.BlockCopy(hash, 0, buf, offset + CLEN_BYTES, HASH_BYTES);\n            byte[] clen = BitConverter.GetBytes((ushort)IPAddress.HostToNetworkOrder((short)len));\n            Buffer.BlockCopy(clen, 0, buf, offset, CLEN_BYTES);
            len += AUTH_BYTES;\n            offset += len;\n        }\n        public override void Encrypt(byte[] buf, int length, byte[] outbuf, out int outlength)
                    if (OnetimeAuth)\n                    {\n                        int headLen = ss_headlen(buf, length);\n                        int len = length - headLen;\n                        Buffer.BlockCopy(buf, headLen, buf, headLen + ONETIMEAUTH_BYTES, len);\n                        buf[0] |= ONETIMEAUTH_FLAG;\n                        byte[] auth = new byte[ONETIMEAUTH_BYTES];\n                        ss_onetimeauth(auth, buf, headLen);\n                        Buffer.BlockCopy(auth, 0, buf, headLen, ONETIMEAUTH_BYTES);\n                        int offset = headLen + ONETIMEAUTH_BYTES;\n                        ss_gen_hash(buf, ref offset, ref len, buf.Length);\n                        length = headLen + ONETIMEAUTH_BYTES + len;\n                    }
                if (OnetimeAuth)\n                {\n                    int offset = 0;\n                    ss_gen_hash(buf, ref offset, ref length, buf.Length);
                IEncryptor encryptor = EncryptorFactory.GetEncryptor(_server.method, _server.password);\n                byte[] dataIn = new byte[length - 3];
                byte[] dataOut = new byte[length - 3 + 16];
                encryptor.Encrypt(dataIn, dataIn.Length, dataOut, out outlen);\n                _remote.SendTo(dataOut, _remoteEndPoint);
            this.tableLayoutPanel2 = new System.Windows.Forms.TableLayoutPanel();
            this.tableLayoutPanel2.SuspendLayout();
            this.ClientSize = new System.Drawing.Size(291, 206);\n            this.Controls.Add(this.tableLayoutPanel2);
            this.tableLayoutPanel2.ResumeLayout(false);\n            this.tableLayoutPanel2.PerformLayout();
            LoadConfiguration(_modifiedHotkeyConfig);\n        }\n        private void LoadConfiguration(HotkeyConfig config)
            if (!RegisterAllHotkeys(out _)) // declare out as an inline discard variable
            RegisterAllHotkeys(out _);  // declare out as an inline discard variable\n        }\n        private bool RegisterAllHotkeys(out string failureInfoStr)
            StringBuilder failureInfo = new StringBuilder();
                    failureInfo.AppendLine(tb.Text);\n                }\n            }\n            failureInfoStr = failureInfo.ToString();
                _runningPort = GetFreePort();
                privoxyConfig = privoxyConfig.Replace("__PRIVOXY_BIND_IP__", configuration.shareOverLan ? "0.0.0.0" : "127.0.0.1");
        private int GetFreePort()
                TcpListener l = new TcpListener(IPAddress.Loopback, 0);
            public EndPoint remoteEndPoint = new IPEndPoint(IPAddress.Any, 0);
                _tcpSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);\n                _udpSocket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
                    ? new IPEndPoint(IPAddress.Any, _config.localPort)\n                    : new IPEndPoint(IPAddress.Loopback, _config.localPort);
                UDPState udpState = new UDPState();\n                udpState.socket = _udpSocket;
                EndPoint remoteEndPoint = new IPEndPoint(IPAddress.Any, 0);
                    EndPoint remoteEndPoint = new IPEndPoint(IPAddress.Any, 0);
            try\n            {\n                int bytesRead = _udpSocket.EndReceiveFrom(ar, ref state.remoteEndPoint);
                    if (service.Handle(state.buffer, bytesRead, _udpSocket, state))
        public void SaveConfig(Configuration newConfig)\n        {\n            Configuration.Save(newConfig);\n            // some logic in configuration updated the config when saving, we need to read it again\n            _config = Configuration.Load();\n            pacServer.Stop();\n            local.Stop();\n            // don't put polipoRunner.Start() before pacServer.Stop()\n            // or bind will fail when switching bind address from 0.0.0.0 to 127.0.0.1\n            // though UseShellExecute is set to true now\n            // http://stackoverflow.com/questions/10235093/socket-doesnt-close-after-application-exits-if-a-launched-process-is-open\n            polipoRunner.Stop();\n            polipoRunner.Start(_config);\n            local = new Local(_config);\n            local.Start();\n            pacServer.Start(_config);\n            if (ConfigChanged != null)\n            {\n                ConfigChanged(this, new EventArgs());\n            }\n        }
        public string GetQRCodeForCurrentServer()
            _remote.EndConnect(asyncResult);
            _remote.BeginSend(buffer, offset, size, socketFlags, callback, state);
            _remote.BeginReceive(buffer, offset, size, socketFlags, callback, state);
            _remote.BeginSend(buffer, offset, size, socketFlags, callback, state);
            _remote.BeginReceive(buffer, offset, size, socketFlags, callback, state);
                _remote.SendTo(dataOut, outlen, SocketFlags.None, _remoteEndPoint);
                _remote.BeginReceiveFrom(_buffer, 0, _buffer.Length, 0, ref remoteEndPoint, new AsyncCallback(RecvFromCallback), null);
                    _local.SendTo(sendBuf, outlen + 3, 0, _localEndPoint);
using System.Text;
            using (var process = new Process())
                // Configure the process using the StartInfo properties.\n                process.StartInfo.FileName = Utils.GetTempPath("sysproxy.exe");\n                process.StartInfo.Arguments = arguments;\n                process.StartInfo.WorkingDirectory = Utils.GetTempPath();\n                process.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;\n                process.StartInfo.UseShellExecute = false;\n                process.StartInfo.RedirectStandardError = true;\n                process.StartInfo.RedirectStandardOutput = true;\n                // Need to provide encoding info, or output/error strings we got will be wrong.\n                process.StartInfo.StandardOutputEncoding = Encoding.Unicode;\n                process.StartInfo.StandardErrorEncoding = Encoding.Unicode;\n                process.StartInfo.CreateNoWindow = true;\n                process.Start();\n                var stderr = process.StandardError.ReadToEnd();\n                var stdout = process.StandardOutput.ReadToEnd();\n                process.WaitForExit();\n                var exitCode = process.ExitCode;\n                if (exitCode != (int)RET_ERRORS.RET_NO_ERROR)
                    throw new ProxyException(stderr);\n                }\n                if (arguments == "query")\n                {\n                    if (stdout.IsNullOrWhiteSpace() || stdout.IsNullOrEmpty())
                        // we cannot get user settings\n                        throw new ProxyException("failed to query wininet settings");
                    _queryStr = stdout;
                MenuItem item = new MenuItem(I18N.GetString(strategy.Name));
                item.Tag = i;
            get\n            {\n                return "Load Balance";\n            }
            get\n            {\n                return "com.shadowsocks.strategy.balancing";\n            }
        void UpdateLatency(Server server);
            this.RemarksTextBox.Location = new System.Drawing.Point(110, 194);\n            this.RemarksTextBox.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);
            this.label6.Location = new System.Drawing.Point(27, 197);\n            this.label6.Margin = new System.Windows.Forms.Padding(5, 0, 5, 0);
            this.label1.Location = new System.Drawing.Point(26, 15);\n            this.label1.Margin = new System.Windows.Forms.Padding(5, 0, 5, 0);
            this.label2.Location = new System.Drawing.Point(12, 51);\n            this.label2.Margin = new System.Windows.Forms.Padding(5, 0, 5, 0);
            this.ProxyPortTextBox.Location = new System.Drawing.Point(110, 158);\n            this.ProxyPortTextBox.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);
            this.label4.Location = new System.Drawing.Point(20, 161);\n            this.label4.Margin = new System.Windows.Forms.Padding(5, 0, 5, 0);
            this.label3.Location = new System.Drawing.Point(22, 87);\n            this.label3.Margin = new System.Windows.Forms.Padding(5, 0, 5, 0);
            this.IPTextBox.Location = new System.Drawing.Point(110, 12);\n            this.IPTextBox.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);
            this.ServerPortTextBox.Location = new System.Drawing.Point(110, 48);\n            this.ServerPortTextBox.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);
            this.PasswordTextBox.Location = new System.Drawing.Point(110, 84);\n            this.PasswordTextBox.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);
            this.label5.Location = new System.Drawing.Point(16, 124);\n            this.label5.Margin = new System.Windows.Forms.Padding(5, 0, 5, 0);
            this.EncryptionSelect.Location = new System.Drawing.Point(110, 120);\n            this.EncryptionSelect.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);
            this.panel2.Location = new System.Drawing.Point(246, 263);\n            this.panel2.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);
            this.OKButton.Location = new System.Drawing.Point(6, 6);\n            this.OKButton.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);
            this.MyCancelButton.Location = new System.Drawing.Point(130, 6);\n            this.MyCancelButton.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);
            this.autoStartup,
            this.ServersItem,
            this.editPACFileItem,
this.contextMenu1.Popup += new System.EventHandler(this.contextMenu1_Popup);
this.ShareOverLANItem.Index = 2;
this.ServersItem.Index = 3;
            this.DeleteButton.Location = new System.Drawing.Point(150, 6);\n            this.DeleteButton.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);
            this.AddButton.Location = new System.Drawing.Point(6, 6);\n            this.AddButton.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);
            this.ServerGroupBox.Location = new System.Drawing.Point(334, 18);\n            this.ServerGroupBox.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);
            this.ServerGroupBox.Padding = new System.Windows.Forms.Padding(5, 5, 5, 5);\n            this.ServerGroupBox.Size = new System.Drawing.Size(383, 307);
            this.ServersListBox.ItemHeight = 20;\n            this.ServersListBox.Location = new System.Drawing.Point(18, 18);\n            this.ServersListBox.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);
// \n// autoStartup\n// \nthis.autoStartup.Index = 1;\nthis.autoStartup.Text = "Start on boot";\nthis.autoStartup.Click += new System.EventHandler(this.autoStartup_Click);\n// 
private void autoStartup_Click(object sender, EventArgs e) {\nautoStartup.Checked = !autoStartup.Checked;\nif (!AutoStartup.Set(autoStartup.Checked)) {
private void contextMenu1_Popup(object sender, EventArgs e) {\nautoStartup.Checked = AutoStartup.Check();\n}
            System.Diagnostics.Process.Start(updateChecker.LatestVersionURL);
﻿using Shadowsocks.Model;\nusing System;
            // TODO test failures\n            WebClient http = new WebClient();\n            http.Headers.Add("User-Agent", "Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.3319.102 Safari/537.36");\n            http.Proxy = new WebProxy(IPAddress.Loopback.ToString(), config.localPort);\n            http.DownloadStringCompleted += http_DownloadStringCompleted;\n            http.DownloadStringAsync(new Uri(UpdateURL));\n        }\n        public static int CompareVersion(string l, string r)\n        {\n            var ls = l.Split('.');\n            var rs = r.Split('.');\n            for (int i = 0; i < Math.Max(ls.Length, rs.Length); i++)
                int lp = (i < ls.Length) ? int.Parse(ls[i]) : 0;\n                int rp = (i < rs.Length) ? int.Parse(rs[i]) : 0;\n                if (lp != rp)\n                {\n                    return lp - rp;\n                }
            return 0;\n        }\n        public class VersionComparer : IComparer<string>\n        {\n            // Calls CaseInsensitiveComparer.Compare with the parameters reversed. \n            public int Compare(string x, string y)
                return CompareVersion(ParseVersionFromURL(x), ParseVersionFromURL(y));
        }\n        private static string ParseVersionFromURL(string url)\n        {\n            Match match = Regex.Match(url, @".*Shadowsocks-win.*?-([\d\.]+)\.\w+", RegexOptions.IgnoreCase);\n            if (match.Success)\n            {\n                if (match.Groups.Count == 2)\n                {\n                    return match.Groups[1].Value;\n                }\n            }\n            return null;\n        }\n        private void SortVersions(List<string> versions)\n        {\n            versions.Sort(new VersionComparer());\n        }\n        private bool IsNewVersion(string url)\n        {\n            if (url.IndexOf("prerelease") >= 0)\n            {\n                return false;\n            }\n            string version = ParseVersionFromURL(url);\n            if (version == null)\n            {\n                return false;\n            }\n            string currentVersion = Version;\n            return CompareVersion(version, currentVersion) > 0;
                List<string> versions = new List<string>();
                        string url = (string)asset["browser_download_url"];\n                        if (IsNewVersion(url))
                            versions.Add(url);
                if (versions.Count != 0)
                    // sort versions\n                    SortVersions(versions);
                    LatestVersionURL = versions[versions.Count - 1];\n                    LatestVersionNumber = ParseVersionFromURL(LatestVersionURL);
                Logging.Debug(ex.ToString());\n                return;
        public void SendResponse(byte[] firstPacket, int length, Socket socket)
                string proxy = GetPACAddress(firstPacket, length, localEndPoint);
        private string GetPACAddress(byte[] requestBuf, int length, IPEndPoint localEndPoint)
            return "PROXY " + localEndPoint.Address + ":" + this._config.localPort + ";";
                polipoConfig = polipoConfig.Replace("__POLIPO_BIND_PORT__", this.GetFreePort().ToString());
                            pacUrl = $"http://127.0.0.1:{config.localPort}/pac?t={GetTimestamp(DateTime.Now)}{pacSrv.PacSecret}";
            var servers = Configuration.Load();\n            var serverDatas = servers.configs.Select(
                    new KeyValuePair<string, string>(server.URL, server.ToString())
            var selectIndex = serverDatas.FindIndex(serverData => serverData.Key.StartsWith(code));
        public string URL\n        {\n            get\n            {\n                string tag = string.Empty;\n                string url = string.Empty;\n                if (string.IsNullOrWhiteSpace(plugin))\n                {\n                    // For backwards compatiblity, if no plugin, use old url format\n                    string parts = $"{method}:{password}@{server}:{server_port}";\n                    string base64 = Convert.ToBase64String(Encoding.UTF8.GetBytes(parts));\n                    url = base64;\n                }\n                else\n                {\n                    // SIP002\n                    string parts = $"{method}:{password}";\n                    string base64 = Convert.ToBase64String(Encoding.UTF8.GetBytes(parts));\n                    string websafeBase64 = base64.Replace('+', '-').Replace('/', '_').TrimEnd('=');
                    url = string.Format(\n                        "{0}@{1}:{2}/?plugin={3}",\n                        websafeBase64,\n                        FormalHostName,\n                        server_port,\n                        HttpUtility.UrlEncode(pluginPart, Encoding.UTF8));\n                }\n                if (!remarks.IsNullOrEmpty())\n                {\n                    tag = $"#{HttpUtility.UrlEncode(remarks, Encoding.UTF8)}";\n                }\n                return $"ss://{url}{tag}";\n            }
        public LineReader(byte[] buffer, WrappedSocket socket, byte[] firstPackge, int index, int length,
            Encoding encoding, string delimiter,
            if (buffer == null)\n            {\n                throw new ArgumentNullException(nameof(buffer));\n            }
            if (buffer.Length < length)
                throw new ArgumentException("Line buffer length can't less than first package length!", nameof(buffer));
            if (buffer.Length < _delimiterBytes.Length)
                throw new ArgumentException("Too small!", nameof(buffer));
            _lineBuffer = buffer;
                if (buffer == firstPackge)\n                {\n                    _bufferDataIndex = index;\n                }\n                else\n                {\n                    Array.Copy(firstPackge, index, _lineBuffer, 0, length);\n                }
                socket.BeginReceive(_lineBuffer, 0, _lineBuffer.Length, 0, ReceiveCallback, 0);
        public LineReader(int maxLineBytes, WrappedSocket socket, Func<string, object, bool> onLineRead,\n            Action<Exception, object> onException, Action<byte[], int, int, object> onFinish, Encoding encoding,\n            string delimiter, object state)\n            : this(\n                new byte[maxLineBytes], socket, null, 0, 0, onLineRead, onException, onFinish, encoding, delimiter,\n                state)
                        WinINet.SetIEProxy(true, true, "127.0.0.1:" + config.localPort.ToString(), "");
                ssURLAssociation = Registry.CurrentUser.CreateSubKey(@"SOFTWARE\Classes\ss", RegistryKeyPermissionCheck.ReadWriteSubTree);
                var json = "[0,1,2]";\n                var result = SimpleJson.SimpleJson.DeserializeObject<List<int>>(json);
                Configuration config = SimpleJson.SimpleJson.DeserializeObject<Configuration>(configContent);
            QRCode4CS.Options options = new QRCode4CS.Options();\n            options.Text = qrText;\n            QRCode4CS.QRCode qrCoded = null;\n            bool success = false;\n            foreach (var level in new QRErrorCorrectLevel[]{QRErrorCorrectLevel.H, QRErrorCorrectLevel.Q, QRErrorCorrectLevel.M, QRErrorCorrectLevel.L})\n            {\n                for (int i = 3; i < 10; i++)\n                {\n                    try\n                    {\n                        options.TypeNumber = i;\n                        options.CorrectLevel = level;\n                        qrCoded = new QRCode4CS.QRCode(options);\n                        qrCoded.Make();\n                        success = true;\n                        break;\n                    }\n                    catch\n                    {\n                        qrCoded = null;\n                        continue;\n                    }\n                }\n                if (success)\n                    break;\n            }\n            if (qrCoded == null)\n            {\n                return;\n            }\n            int blockSize = Math.Max(200 / qrCoded.GetModuleCount(), 1);\n            Bitmap drawArea = new Bitmap((qrCoded.GetModuleCount() * blockSize), (qrCoded.GetModuleCount() * blockSize));
                    for (int row = 0; row < qrCoded.GetModuleCount(); row++)
                        for (int col = 0; col < qrCoded.GetModuleCount(); col++)
                            if (qrCoded.IsDark(row, col))
            MenuItem result = new MenuItem(I18N.GetString(text), click);\n            return result;\n        }\n        private MenuItem CreateSeperatorItem()\n        {\n            MenuItem result = new MenuItem("-");\n            return result;
            for (int i = 0; i < items.Length; i++)\n            {\n                items[i].Index = i;\n            }\n            MenuItem result = new MenuItem(I18N.GetString(text), items);\n            return result;
                    this.SeperatorItem = CreateSeperatorItem(),
                CreateSeperatorItem(),
                CreateSeperatorItem(),
                CreateSeperatorItem(),
        public static List<string> ParseResult(string response)
                    arguments = "global " + proxyServer;
                    arguments = "pac " + pacURL;
            LoadTrayIcon();\n            this.controller = controller;
            this.enableItem.Text = "&Enable";
            this.modeItem.Text = "Mode";
            this.PACModeItem.Text = "PAC";
            this.globalModeItem.Text = "Global";
            this.ServersItem.Text = "&Servers";
            this.ConfigItem.Text = "Edit Servers...";
            this.AutoStartupItem.Text = "Start on Boot";
            this.ShareOverLANItem.Text = "Share over LAN";
            this.editPACFileItem.Text = "Edit &PAC File...";
            this.QRCodeItem.Text = "Show &QRCode...";
            this.ShowLogItem.Text = "Show Logs...";
            this.aboutItem.Text = "About...";
            this.quitItem.Text = "&Quit";
            this.label6 = new System.Windows.Forms.Label();\n            this.label1 = new System.Windows.Forms.Label();\n            this.label2 = new System.Windows.Forms.Label();
            this.label4 = new System.Windows.Forms.Label();\n            this.label3 = new System.Windows.Forms.Label();
            this.label5 = new System.Windows.Forms.Label();
            this.tableLayoutPanel1.Controls.Add(this.label6, 0, 5);\n            this.tableLayoutPanel1.Controls.Add(this.label1, 0, 0);\n            this.tableLayoutPanel1.Controls.Add(this.label2, 0, 1);
            this.tableLayoutPanel1.Controls.Add(this.label4, 0, 4);\n            this.tableLayoutPanel1.Controls.Add(this.label3, 0, 2);
            this.tableLayoutPanel1.Controls.Add(this.label5, 0, 3);
            // label6\n            // \n            this.label6.Anchor = System.Windows.Forms.AnchorStyles.Right;\n            this.label6.AutoSize = true;\n            this.label6.Location = new System.Drawing.Point(19, 142);\n            this.label6.Name = "label6";\n            this.label6.Size = new System.Drawing.Size(49, 13);\n            this.label6.TabIndex = 9;\n            this.label6.Text = "Remarks";\n            // \n            // label1\n            // \n            this.label1.Anchor = System.Windows.Forms.AnchorStyles.Right;\n            this.label1.AutoSize = true;\n            this.label1.Location = new System.Drawing.Point(17, 11);\n            this.label1.Name = "label1";\n            this.label1.Size = new System.Drawing.Size(51, 13);\n            this.label1.TabIndex = 0;\n            this.label1.Text = "Server IP";\n            // \n            // label2\n            // \n            this.label2.Anchor = System.Windows.Forms.AnchorStyles.Right;\n            this.label2.AutoSize = true;\n            this.label2.Location = new System.Drawing.Point(8, 37);\n            this.label2.Name = "label2";\n            this.label2.Size = new System.Drawing.Size(60, 13);\n            this.label2.TabIndex = 1;\n            this.label2.Text = "Server Port";
            // label4\n            // \n            this.label4.Anchor = System.Windows.Forms.AnchorStyles.Right;\n            this.label4.AutoSize = true;\n            this.label4.Location = new System.Drawing.Point(13, 116);\n            this.label4.Name = "label4";\n            this.label4.Size = new System.Drawing.Size(55, 13);\n            this.label4.TabIndex = 3;\n            this.label4.Text = "Proxy Port";\n            // \n            // label3\n            // \n            this.label3.Anchor = System.Windows.Forms.AnchorStyles.Right;\n            this.label3.AutoSize = true;\n            this.label3.Location = new System.Drawing.Point(15, 63);\n            this.label3.Name = "label3";\n            this.label3.Size = new System.Drawing.Size(53, 13);\n            this.label3.TabIndex = 2;\n            this.label3.Text = "Password";
        private System.Windows.Forms.Label label1;\n        private System.Windows.Forms.Label label2;\n        private System.Windows.Forms.Label label3;\n        private System.Windows.Forms.Label label4;
        private System.Windows.Forms.Label label5;
            _modifiedConfiguration.configs.Add(currServer);
            ServersListBox.SelectedIndex = _modifiedConfiguration.configs.Count - 1;
                FileManager.UncompressFile(dllPath, Resources.polarssl_dll);
            catch (IOException e)
            LoadLibrary(dllPath);
        internal static byte[] libsodium_dll {
                object obj = ResourceManager.GetObject("libsodium_dll", resourceCulture);\n                return ((byte[])(obj));\n            }\n        }\n        /// <summary>\n        ///   Looks up a localized resource of type System.Byte[].\n        /// </summary>\n        internal static byte[] polarssl_dll {\n            get {\n                object obj = ResourceManager.GetObject("polarssl_dll", resourceCulture);
                FileManager.UncompressFile(dllPath, Resources.libsodium_dll);
            catch (IOException e)
            LoadLibrary(dllPath);
            LogMessageTextBox.WordWrap = WrapTextCheckBox.Checked = WrapTextMenuItem.Checked = wrapTextTrigger;\n            ToolbarFlowLayoutPanel.Visible = toolbarTrigger;
                        _headers.Enqueue(line);
                        _headers.Enqueue("");
                    }\n                    if (!line.StartsWith("Proxy-"))\n                    {\n                        _headers.Enqueue(line);
            try
                var key = _keymap.First(x => x.Value == cb).Key;\n                hotkey = key;
            catch (InvalidOperationException)
        private void TextBox_TextChanged(object sender, EventArgs e)\n        {\n            var tb = (TextBox) sender;\n            if (tb.Text == "")\n            {\n                // unreg\n                UnregHotkey(tb);\n            }\n        }\n        private void UnregHotkey(TextBox tb)\n        {\n            HotKeys.HotKeyCallBackHandler callBack;\n            Label lb;\n            PrepareForHotkey(tb, out callBack, out lb);\n            UnregPrevHotkey(callBack);\n        }
            if (!RegisterAllHotkeys())
            RegisterAllHotkeys();\n        }\n        private bool RegisterAllHotkeys()\n        {\n            bool isSuccess = true;\n            foreach (var tb in _allTextBoxes)\n            {\n                if (tb.Text.IsNullOrEmpty())\n                {\n                    continue;\n                }\n                if (!TryRegHotkey(tb))\n                {\n                    isSuccess = false;\n                }\n            }\n            return isSuccess;\n        }\n        private bool TryRegHotkey(TextBox tb)\n        {\n            var hotkey = HotKeys.Str2HotKey(tb.Text);\n            if (hotkey == null)\n            {\n                MessageBox.Show(string.Format(I18N.GetString("Cannot parse hotkey: {0}"), tb.Text));\n                tb.Clear();\n                return false;\n            }\n            HotKeys.HotKeyCallBackHandler callBack;\n            Label lb;\n            PrepareForHotkey(tb, out callBack, out lb);\n            UnregPrevHotkey(callBack);\n            // try to register keys\n            // if already registered by other progs\n            // notify to change\n            // use the corresponding label color to indicate\n            // reg result.\n            // Green: not occupied by others and operation succeed\n            // Yellow: already registered by other program and need action: disable by clear the content\n            //         or change to another one\n            // Transparent without color: first run or empty config\n            bool regResult = HotKeys.Register(hotkey, callBack);\n            lb.BackColor = regResult ? Color.Green : Color.Yellow;\n            return regResult;
        #region Prepare hotkey\n        /// <summary>\n        /// Find correct callback and corresponding label by textBox\n        /// </summary>\n        /// <param name="tb"></param>\n        /// <param name="cb"></param>\n        /// <param name="lb"></param>\n        private void PrepareForHotkey(TextBox tb, out HotKeys.HotKeyCallBackHandler cb, out Label lb)\n        {\n            /*\n             * XXX: The labelName, TextBoxName and callbackName\n             *      must follow this rule to make use of reflection\n             *\n             *      <BaseName><Control-Type-Name>\n             */\n            if (tb == null)\n                throw new ArgumentNullException(nameof(tb));\n            var pos = tb.Name.LastIndexOf("TextBox", StringComparison.OrdinalIgnoreCase);\n            var rawName = tb.Name.Substring(0, pos);\n            var labelName = rawName + "Label";\n            var callbackName = rawName + "Callback";\n            var callback = HotkeyCallbacks.GetCallback(callbackName);\n            if (callback == null)\n            {\n                throw new Exception($"{callbackName} not found");\n            }\n            cb = callback as HotKeys.HotKeyCallBackHandler;\n            var label = GetFieldViaName(GetType(), labelName, this);\n            if (label == null)\n            {\n                throw new Exception($"{labelName} not found");\n            }\n            lb = label as Label;\n        }\n        /// <summary>\n        ///\n        /// </summary>\n        /// <param name="type">from which type</param>\n        /// <param name="name">field name</param>\n        /// <param name="obj">pass null if static field</param>\n        /// <returns></returns>\n        private static object GetFieldViaName(Type type, string name, object obj)\n        {\n            if (type == null) throw new ArgumentNullException(nameof(type));\n            if (name.IsNullOrEmpty()) throw new ArgumentException(nameof(name));\n            // In general, TextBoxes and Labels are private\n            FieldInfo fi = type.GetField(name,\n                BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.IgnoreCase | BindingFlags.Static);\n            return fi == null ? null : fi.GetValue(obj);\n        }\n        #endregion
            this.SwitchSystemProxyTextBox.TextChanged += new System.EventHandler(this.TextBox_TextChanged);
            this.SwitchProxyModeTextBox.TextChanged += new System.EventHandler(this.TextBox_TextChanged);
            this.SwitchAllowLanTextBox.TextChanged += new System.EventHandler(this.TextBox_TextChanged);
            this.ShowLogsTextBox.TextChanged += new System.EventHandler(this.TextBox_TextChanged);
            this.ServerMoveUpTextBox.TextChanged += new System.EventHandler(this.TextBox_TextChanged);
            this.ServerMoveDownTextBox.TextChanged += new System.EventHandler(this.TextBox_TextChanged);
        public TCPRelay(ShadowsocksController controller)
        public Socket remote;
        private bool connected;
                    Logging.Debug(remote, RecvSize, "TCP Relay");
                        Logging.Debug(remote, RecvSize, "TCP Relay");
                remote = new Socket(ipAddress.AddressFamily,\n                    SocketType.Stream, ProtocolType.Tcp);\n                remote.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);
                connectTimer.Elapsed += connectTimer_Elapsed;
                connected = false;
                remote.BeginConnect(remoteEP, new AsyncCallback(ConnectCallback), connectTimer);\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void connectTimer_Elapsed(object sender, ElapsedEventArgs e)\n        {\n            if (connected)
                timer.Elapsed -= connectTimer_Elapsed;
                remote.EndConnect(ar);\n                connected = true;\n                Logging.Debug($"Socket connected to {remote.RemoteEndPoint}");
        public string name;\n        public int key_size;\n        public int iv_size;\n        public int type;\n        public EncryptorInfo(string name, int key_size, int iv_size, int type)
            this.name = name;\n            this.key_size = key_size;\n            this.iv_size = iv_size;\n            this.type = type;
            string tempPath = Path.GetTempPath();\n            string dllPath = tempPath + "/polarssl.dll";\n            try
                FileManager.UncompressFile(dllPath, Resources.polarssl_dll);
            catch (IOException e)\n            {\n                Console.WriteLine(e.ToString());\n            }\n            LoadLibrary(dllPath);\n            try\n            {\n                FileStream fs = new FileStream("shadowsocks.log", FileMode.Append);\n                TextWriter tmp = Console.Out;\n                StreamWriter sw = new StreamWriter(fs);\n                sw.AutoFlush = true;\n                Console.SetOut(sw);\n                Console.SetError(sw);\n            }\n            catch (IOException e)\n            {\n                Console.WriteLine(e.ToString());\n            }\n            Application.EnableVisualStyles();\n            Application.SetCompatibleTextRenderingDefault(false);\n            ShadowsocksController controller = new ShadowsocksController();\n            // TODO run without a main form to save RAM\n            Application.Run(new ConfigForm(controller));
            series1.Color = System.Drawing.Color.FromArgb(((int)(((byte)(255)))), ((int)(((byte)(128)))), ((int)(((byte)(0)))));
            series2.Color = System.Drawing.Color.FromArgb(((int)(((byte)(128)))), ((int)(((byte)(128)))), ((int)(((byte)(255)))));
        public const int HASH_BUF_LEN = 128;
        protected byte[] hash_buf;\n        protected int hash_idx = 0;
            if (OnetimeAuth)\n            {\n                hash_buf = new byte[HASH_BUF_LEN];\n            }
        protected int ss_onetimeauth(byte[] auth,\n            byte[] msg, int msg_len,\n            byte[] iv, int iv_len,\n            byte[] key, int key_len)
            Buffer.BlockCopy(iv, 0, auth_bytes, 0, ivLen);\n            Buffer.BlockCopy(key, 0, auth_bytes, ivLen, key_len);\n            Sodium.crypto_generichash(auth_key, ONETIMEAUTH_KEYBYTES, auth_bytes, (ulong)(iv_len + key_len), null, 0);
        protected void ss_gen_hash(byte[] in_buf, ref int in_offset, ref int in_len,\n            byte[] hash_buf, ref int hash_idx, int buf_size)\n        {\n            int i, j;\n            int offset = in_offset;\n            int blen = in_len;\n            int cidx = hash_idx;\n            int size = (blen / HASH_BUF_LEN + 1) * HASH_BYTES + blen;
            for (i = 0, j = offset; i < blen; i++, j++)\n            {\n                if (cidx == HASH_BUF_LEN)\n                {\n                    Sodium.crypto_generichash(hash, HASH_BYTES, hash_buf, HASH_BUF_LEN, null, 0);\n                    Buffer.BlockCopy(in_buf, j, in_buf, j + HASH_BYTES, blen - i);\n                    Buffer.BlockCopy(hash, 0, in_buf, j, HASH_BYTES);\n                    j += HASH_BYTES; cidx = 0;\n                }\n                hash_buf[cidx] = in_buf[j];\n                cidx++;\n            }\n            in_offset = j;\n            in_len = j - offset;\n            hash_idx = cidx;
                        splash.Location = new Point((int)minX, (int)minY);
                        splash.Panel.Size = new Size((int)maxX - (int)minX, (int)maxY - (int)minY);\n                        splash.Size = splash.Panel.Size;
    public partial class QRCodeSplashForm : Form
            InitializeComponent();
            step = 0;
            timer.Interval = 300;
            if (File.Exists(PAC_FILE))
                return PAC_FILE;
            else\n            {\n                FileManager.UncompressFile(PAC_FILE, Resources.proxy_pac_txt);\n                return PAC_FILE;\n            }
            if (File.Exists(USER_RULE_FILE))\n            {\n                return USER_RULE_FILE;\n            }\n            else
                return USER_RULE_FILE;
                return Utils.UnGzip(Resources.proxy_pac_txt);
            string gfwListUrl = GEOSITE_URL;\n            if (!string.IsNullOrWhiteSpace(config.gfwListUrl))
                logger.Info("Found custom GFWListURL in config file");\n                gfwListUrl = config.gfwListUrl;
            logger.Info($"Checking GFWList from {gfwListUrl}");
                    bool pacFileChanged = MergeAndWritePACFile();
            http.DownloadDataAsync(new Uri(gfwListUrl));
        public static bool MergeAndWritePACFile()
            return MergeAndWritePACFile(Geosites["cn"]);\n        }\n        private static bool MergeAndWritePACFile(IList<DomainObject> domains)\n        {\n            string abpContent = MergePACFile(domains);
                userruleLines = ParseToValidList(userrulesString);
            List<string> gfwLines = ParseToValidList(domains);
        private static List<string> ParseToValidList(string content)
        private static List<string> ParseToValidList(IList<DomainObject> domains)
            List<string> ret = new List<string>(domains.Count + 100)// 100 overhead\n            {\n                "/.*/" // match any domain, so all non-cn domain go through proxy\n            }; 
                        ret.Add($"@@{domain}");
        public PACDaemon()
                GeositeUpdater.MergeAndWritePACFile();
        public static RegistryKey OpenUserRegKey( string name, bool writable )
                RegistryKey userKey = RegistryKey.OpenBaseKey(RegistryHive.CurrentUser,
            inboundCounter += n;
            outboundCounter += n;
            config = Config.Load();
            polipoRunner.Start(config);\n            local = new Local(config);
        public void SaveConfig(Config newConfig)
            Config.Save(newConfig);
            polipoRunner.Start(config);\n            local = new Local(config);
        public Config GetConfig()
            Config config = controller.GetConfig();\n            textBox1.Text = config.server;\n            textBox2.Text = config.server_port.ToString();\n            textBox3.Text = config.password;\n            textBox4.Text = config.local_port.ToString();\n            comboBox1.Text = config.method == null ? "aes-256-cfb" : config.method;\n            enableItem.Checked = config.enabled;
            if (!controller.GetConfig().isDefault)
                Config config = new Config
                    method = comboBox1.Text,\n                    isDefault = false
                            if (!ParseHost(m.Groups[2].Value))
                                throw new Exception("Bad http header: " + line);
                            if (!ParseHost(line.Substring(6).Trim()))
                                throw new Exception("Bad http header: " + line);
                    if (_command != CMD_CONNECT && _command != CMD_UDP_ASSOC)\n                    {\n                        Logging.Debug("Unsupported CMD=" + _command);\n                        Close();\n                    }\n                    else\n                    {\n                        if (_command == CMD_CONNECT)\n                        {
                        }\n                        else if (_command == CMD_UDP_ASSOC)\n                        {
                        }
using System.Collections.Generic;
using System.Linq;
using System.Security;
            catch (UnauthorizedAccessException uae)\n            {\n                Logging.LogUsefulException(uae);
            catch (SecurityException se)\n            {\n                Logging.LogUsefulException(se);\n                return null;\n            }\n            catch (ArgumentException ae)\n            {\n                MessageBox.Show("OpenRegKey: " + ae.ToString());
﻿using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Runtime.InteropServices;\nusing System.Text;\nusing System.Threading.Tasks;
    public static class RAS
﻿using Shadowsocks.Model;\nusing Shadowsocks.Properties;\nusing Shadowsocks.Util;\nusing System;
using System.Collections.Generic;\nusing System.Diagnostics;
using System.IO.Compression;
        public static string PAC_FILE = "pac.txt";\n        public static string USER_RULE_FILE = "user-rule.txt";\n        public static string USER_ABP_FILE = "abp.txt";
                if (File.Exists(USER_RULE_FILE))
                    string local = File.ReadAllText(USER_RULE_FILE, Encoding.UTF8);
                if (File.Exists(USER_ABP_FILE))
                    abpContent = File.ReadAllText(USER_ABP_FILE, Encoding.UTF8);
                    string original = File.ReadAllText(PAC_FILE, Encoding.UTF8);
                File.WriteAllText(PAC_FILE, abpContent, Encoding.UTF8);
                var reply = await ping.SendTaskAsync(server.server, Timeout);\n                ret.Add(new List<KeyValuePair<string, string>>
                    new KeyValuePair<string, string>("Timestamp", timestamp),\n                    new KeyValuePair<string, string>("Server", server.FriendlyName()),\n                    new KeyValuePair<string, string>("Status", reply?.Status.ToString()),\n                    new KeyValuePair<string, string>("RoundtripTime", reply?.RoundtripTime.ToString())\n                    //new KeyValuePair<string, string>("data", reply.Buffer.ToString()); // The data of reply\n                });
            md5(input, (uint) input.Length, output);
        public static extern void md5(byte[] input, uint ilen, byte[] output);
    class Local
        private bool _shareOverLAN;\n        //private Encryptor encryptor;\n        Socket _listener;
            _shareOverLAN = config.shareOverLan;\n            //this.encryptor = new Encryptor(config.method, config.password);\n        }\n        public void Start()\n        {\n            try\n            {\n                // Create a TCP/IP socket.\n                _listener = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);\n                _listener.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, true);\n                IPEndPoint localEndPoint = null;\n                if (_shareOverLAN)\n                {\n                    localEndPoint = new IPEndPoint(IPAddress.Any, _config.localPort);\n                }\n                else\n                {\n                    localEndPoint = new IPEndPoint(IPAddress.Loopback, _config.localPort);\n                }\n                // Bind the socket to the local endpoint and listen for incoming connections.\n                _listener.Bind(localEndPoint);\n                _listener.Listen(100);\n                // Start an asynchronous socket to listen for connections.\n                Console.WriteLine("Shadowsocks started");\n                _listener.BeginAccept(\n                    new AsyncCallback(AcceptCallback),\n                    _listener);\n            }\n            catch(SocketException)\n            {\n                _listener.Close();\n                throw;\n            }\n        }\n        public void Stop()\n        {\n            _listener.Close();\n        }\n        public void AcceptCallback(IAsyncResult ar)\n        {\n            Socket listener = (Socket)ar.AsyncState;\n            try\n            {\n                Socket conn = listener.EndAccept(ar);\n                conn.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n                Handler handler = new Handler();\n                handler.connection = conn;\n                Server server = _config.GetCurrentServer();\n                handler.encryptor = EncryptorFactory.GetEncryptor(server.method, server.password);\n                handler.server = server;\n                handler.Start();\n            }\n            catch\n            {\n                //Console.WriteLine(e.Message);\n            }\n            finally\n            {\n                try\n                {\n                    listener.BeginAccept(\n                        new AsyncCallback(AcceptCallback),\n                        listener);\n                }\n                catch\n                {\n                    //Console.WriteLine(e.Message);\n                }\n            }
                connection.BeginReceive(connetionRecvBuffer, 0, 256, 0,\n                    new AsyncCallback(HandshakeReceiveCallback), null);\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                this.Close();\n            }\n        }\n        private void HandshakeReceiveCallback(IAsyncResult ar)\n        {\n            if (closed)\n            {\n                return;\n            }\n            try\n            {\n                int bytesRead = connection.EndReceive(ar);
                    if (connetionRecvBuffer[0] != 5)
            if (local != null)\n            {\n                local.Stop();
                local = new Local(_config);\n                local.Start();
            this.valueLabel.Size = new System.Drawing.Size(0, 18);
            const string api = "http://ip-api.com/json";\n            var ret = new DataList
                return ret;
            if (!SimpleJson.SimpleJson.TryDeserializeObject(jsonString, out obj)) return ret;
            string regionName = obj["regionName"];\n            if (country == null || city == null || isp == null || regionName == null) return ret;\n            ret[0] = new DataUnit(State.Geolocation, $"{country} | {regionName} | {city}");\n            ret[1] = new DataUnit(State.ISP, isp);\n            return ret;
        private void loadChartData(string serverName)
            foreach (var data in statistics)
                _dataTable.Rows.Add(data.Timestamp, (float) new Random().Next() % 50, new Random().Next() % 200);
            loadChartData(_servers[serverSelector.SelectedIndex]);
            this.serverSelector = new System.Windows.Forms.ComboBox();
            this.groupBox1.SuspendLayout();
            // serverSelector\n            // \n            this.serverSelector.FormattingEnabled = true;\n            this.serverSelector.Location = new System.Drawing.Point(808, 75);\n            this.serverSelector.Name = "serverSelector";\n            this.serverSelector.Size = new System.Drawing.Size(239, 36);\n            this.serverSelector.TabIndex = 6;\n            this.serverSelector.SelectedIndexChanged += new System.EventHandler(this.serverSelector_SelectedIndexChanged);\n            // 
            this.groupBox1.ResumeLayout(false);\n            this.groupBox1.PerformLayout();
                    CreateMenuItem("Scan QRCode from Screen...", new EventHandler(this.ScanQRCodeItem_Click))
                        registry.SetValue("AutoConfigURL", "http://127.0.0.1:" + config.localPort.ToString() + "/pac?t=" + GetTimestamp(DateTime.Now));
                if (System.IO.File.Exists(updateChecker.LatestVersionLocalName))
                    System.Diagnostics.Process.Start("explorer.exe", argument);
using System.Reflection;
        private static readonly string StatisticsFilesName = "shadowsocks.availability.csv";\n        private static readonly string Delimiter = ",";\n        private static readonly int Timeout = 500;\n        private static readonly int Repeat = 4; //repeat times every evaluation\n        private static readonly int Interval = 10 * 60 * 1000;  //evaluate proxies every 15 minutes\n        private Timer timer = null;\n        private State state = null;\n        private List<Server> servers;
            string temppath = Path.GetTempPath();
                    if (timer?.Change(0, Interval) == null)\n                    {\n                        state = new State();\n                        timer = new Timer(Evaluate, state, 0, Interval);\n                    }
            Ping ping = new Ping();\n            State state = (State) obj;\n            foreach (var server in servers)
                    string timestamp = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss");
                    //seems no need to use SendPingAsync\n                    PingReply reply = ping.Send(server.server, Timeout);\n                    state.data = new List<KeyValuePair<string, string>>();\n                    state.data.Add(new KeyValuePair<string, string>("Timestamp", timestamp));\n                    state.data.Add(new KeyValuePair<string, string>("Server", server.FriendlyName()));\n                    state.data.Add(new KeyValuePair<string, string>("Status", reply.Status.ToString()));\n                    state.data.Add(new KeyValuePair<string, string>("RoundtripTime", reply.RoundtripTime.ToString()));
            string dataLine = string.Join(Delimiter, data.Select(kv => kv.Value).ToArray());
                string headerLine = string.Join(Delimiter, data.Select(kv => kv.Key).ToArray());\n                lines = new string[] { headerLine, dataLine };
                lines = new string[] { dataLine };
﻿using NLog;\nusing System;
    class TCPRelay : Listener.Service
        private static Logger logger = LogManager.GetCurrentClassLogger();\n        private ShadowsocksController _controller;
        private Configuration _config;
        class AsyncSession
        class AsyncSession<T> : AsyncSession
        private static Logger Logger = LogManager.GetCurrentClassLogger();
        private ShadowsocksController _controller;\n        private ProxyConfig _config;\n        private Socket _connection;
        private byte[] _remoteRecvBuffer = new byte[BufferSize];
        private byte[] _connetionRecvBuffer = new byte[BufferSize];
        private byte[] _remoteSendBuffer = new byte[BufferSize];
        private byte[] _connetionSendBuffer = new byte[BufferSize];
            this._server = server;
                if (_closed) return;
            }\n            catch (Exception e)\n            {\n                Logger.LogUsefulException(e);\n                Close();
            if (_closed) return;
                    HandshakeReceive2Callback, null);\n            }\n            catch (Exception e)\n            {\n                Logger.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void HandshakeReceive2Callback(IAsyncResult ar)\n        {\n            if (_closed) return;
                Logger.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void ResponseCallback(IAsyncResult ar)
                Logger.LogUsefulException(e);\n                Close();
            if (_closed) return;
                var states = (object[])ar.AsyncState;
                var onSuccess = (Action)states[1];
                }\n            }\n            catch (Exception e)\n            {\n                Logger.LogUsefulException(e);\n                Close();
                Logger.LogUsefulException(e);\n                Close();
            var timer = (ProxyTimer)sender;
            var proxy = timer.Session.Remote;
                var session = (AsyncSession<ProxyTimer>)ar.AsyncState;
                var destEndPoint = timer.DestEndPoint;\n                var server = timer.Server;
                var remote = session.Remote;
                Logger.LogUsefulException(e);\n                Close();
            var timer = (ServerTimer)sender;
            var session = timer.Session;
            if (_closed) return;\n            try\n            {\n                var session = (AsyncSession<ServerTimer>)ar.AsyncState;
                var remote = session.Remote;
                var latency = DateTime.Now - _startConnectTime;
                Logger.LogUsefulException(e);\n                Close();
                var size = _connection.Receive(_connetionRecvBuffer, _firstPacketLength, available,
            if (_closed) return;
                Logger.LogUsefulException(e);\n                Close();
            if (_closed) return;\n            try\n            {\n                var session = (AsyncSession)ar.AsyncState;
                Logger.LogUsefulException(e);\n                Close();
            if (_closed) return;
                var session = (AsyncSession)ar.AsyncState;\n                var remote = session.Remote;
                Logger.LogUsefulException(e);\n                Close();
                var container = (object[])ar.AsyncState;\n                var session = (AsyncSession)container[0];\n                var bytesShouldSend = (int)container[1];\n                var bytesSent = _connection.EndSend(ar);\n                var bytesRemaining = bytesShouldSend - bytesSent;
        private MenuItem menuItem4;
        private MenuItem menuItem3;
        private MenuItem menuItem1;
            this.enableItem = new System.Windows.Forms.MenuItem();\n            this.modeItem = new System.Windows.Forms.MenuItem();\n            this.PACModeItem = new System.Windows.Forms.MenuItem();\n            this.globalModeItem = new System.Windows.Forms.MenuItem();\n            this.AutoStartupItem = new System.Windows.Forms.MenuItem();\n            this.ShareOverLANItem = new System.Windows.Forms.MenuItem();\n            this.ServersItem = new System.Windows.Forms.MenuItem();\n            this.SeperatorItem = new System.Windows.Forms.MenuItem();\n            this.ConfigItem = new System.Windows.Forms.MenuItem();\n            this.menuItem4 = new System.Windows.Forms.MenuItem();\n            this.editPACFileItem = new System.Windows.Forms.MenuItem();\n            this.QRCodeItem = new System.Windows.Forms.MenuItem();\n            this.ShowLogItem = new System.Windows.Forms.MenuItem();\n            this.aboutItem = new System.Windows.Forms.MenuItem();\n            this.menuItem3 = new System.Windows.Forms.MenuItem();\n            this.quitItem = new System.Windows.Forms.MenuItem();\n            this.menuItem1 = new System.Windows.Forms.MenuItem();
            this.menuItem1,
            this.menuItem4,
            this.menuItem3,
            // \n            // enableItem\n            // \n            this.enableItem.Index = 0;\n            this.enableItem.Text = I18N.GetString("Enable");\n            this.enableItem.Click += new System.EventHandler(this.EnableItem_Click);\n            //\n            // modeMenu\n            //\n            this.modeItem.Index = 1;\n            this.modeItem.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {\n            this.PACModeItem,\n            this.globalModeItem});\n            this.modeItem.Text = I18N.GetString("Mode");\n            //\n            // PACModeItem\n            //\n            this.PACModeItem.Index = 0;\n            this.PACModeItem.Text = I18N.GetString("PAC");\n            this.PACModeItem.Click += new System.EventHandler(this.PACModeItem_Click);\n            //\n            // globalModeItem\n            //\n            this.globalModeItem.Index = 1;\n            this.globalModeItem.Text = I18N.GetString("Global");\n            this.globalModeItem.Click += new System.EventHandler(this.GlobalModeItem_Click);\n            // \n            // ServersItem\n            // \n            this.ServersItem.Index = 2;\n            this.ServersItem.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {\n            this.SeperatorItem,\n            this.ConfigItem});\n            this.ServersItem.Text = I18N.GetString("Servers");\n            // \n            // SeperatorItem\n            // \n            this.SeperatorItem.Index = 0;\n            this.SeperatorItem.Text = "-";\n            // \n            // ConfigItem\n            // \n            this.ConfigItem.Index = 1;\n            this.ConfigItem.Text = I18N.GetString("Edit Servers...");\n            this.ConfigItem.Click += new System.EventHandler(this.Config_Click);\n            // \n            // menuItem1\n            // \n            this.menuItem1.Index = 3;\n            this.menuItem1.Text = "-";\n            // \n            // AutoStartupItem\n            // \n            this.AutoStartupItem.Index = 4;\n            this.AutoStartupItem.Text = I18N.GetString("Start on Boot");\n            this.AutoStartupItem.Click += new System.EventHandler(this.AutoStartupItem_Click);\n            // \n            // ShareOverLANItem\n            // \n            this.ShareOverLANItem.Index = 5;\n            this.ShareOverLANItem.Text = I18N.GetString("Share over LAN");\n            this.ShareOverLANItem.Click += new System.EventHandler(this.ShareOverLANItem_Click);\n            // \n            // editPACFileItem\n            // \n            this.editPACFileItem.Index = 6;\n            this.editPACFileItem.Text = I18N.GetString("Edit PAC File...");\n            this.editPACFileItem.Click += new System.EventHandler(this.EditPACFileItem_Click);\n            // \n            // menuItem4\n            // \n            this.menuItem4.Index = 7;\n            this.menuItem4.Text = "-";\n            // \n            // QRCodeItem\n            // \n            this.QRCodeItem.Index = 8;\n            this.QRCodeItem.Text = I18N.GetString("Show QRCode...");\n            this.QRCodeItem.Click += new System.EventHandler(this.QRCodeItem_Click);\n            // \n            // ShowLogItem\n            // \n            this.ShowLogItem.Index = 9;\n            this.ShowLogItem.Text = I18N.GetString("Show Logs...");\n            this.ShowLogItem.Click += new System.EventHandler(this.ShowLogItem_Click);\n            // \n            // aboutItem\n            // \n            this.aboutItem.Index = 10;\n            this.aboutItem.Text = I18N.GetString("About...");\n            this.aboutItem.Click += new System.EventHandler(this.AboutItem_Click);\n            // \n            // menuItem3\n            // \n            this.menuItem3.Index = 11;\n            this.menuItem3.Text = "-";\n            // \n            // quitItem\n            // \n            this.quitItem.Index = 12;\n            this.quitItem.Text = I18N.GetString("Quit");\n            this.quitItem.Click += new System.EventHandler(this.Quit_Click);
            // TODO add cache\n            UDPHandler handler = new UDPHandler(socket, _config.GetCurrentServer(), (IPEndPoint)udpState.remoteEndPoint);
        class UDPHandler
            _modifiedConfiguration = controller.GetConfigurationCopy().proxy;\n            UseProxyCheckBox.Checked = _modifiedConfiguration.useProxy;\n            ProxyServerTextBox.Text = _modifiedConfiguration.proxyServer;\n            ProxyPortTextBox.Text = _modifiedConfiguration.proxyPort.ToString();\n            ProxyTimeoutTextBox.Text = _modifiedConfiguration.proxyTimeout.ToString();\n            ProxyTypeComboBox.SelectedIndex = _modifiedConfiguration.proxyType;
            if (UseProxyCheckBox.Checked)
                int port;\n                int timeout;\n                if (!int.TryParse(ProxyPortTextBox.Text, out port))
                if (!int.TryParse(ProxyTimeoutTextBox.Text, out timeout))
                var type = ProxyTypeComboBox.SelectedIndex;\n                var proxy = ProxyServerTextBox.Text;
                    Configuration.CheckServer(proxy);\n                    Configuration.CheckPort(port);\n                    Configuration.CheckTimeout(timeout, ProxyConfig.MaxProxyTimeoutSec);
                controller.EnableProxy(type, proxy, port, timeout);
            else\n            {\n                controller.DisableProxy();\n            }
                ProxyServerTextBox.Enabled = true;\n                ProxyPortTextBox.Enabled = true;\n                ProxyTimeoutTextBox.Enabled = true;
                ProxyServerTextBox.Enabled = false;\n                ProxyPortTextBox.Enabled = false;\n                ProxyTimeoutTextBox.Enabled = false;\n                ProxyTypeComboBox.Enabled = false;
        public int RunningPort\n        {\n            get\n            {\n                return _runningPort;\n            }\n        }
            Server server = configuration.GetCurrentServer();
                IPGlobalProperties properties = IPGlobalProperties.GetIPGlobalProperties();\n                IPEndPoint[] tcpEndPoints = properties.GetActiveTcpListeners();\n                List<int> usedPorts = new List<int>();\n                foreach (IPEndPoint endPoint in IPGlobalProperties.GetIPGlobalProperties().GetActiveTcpListeners())\n                {\n                    usedPorts.Add(endPoint.Port);\n                }\n                for (int port = defaultPort; port <= 65535; port++)\n                {\n                    if (!usedPorts.Contains(port))\n                    {\n                        return port;\n                    }\n                }
            throw new Exception("No free port found.");
                    string[] rules = local.Split(new char[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);\n                    foreach (string rule in rules)
                        if (rule[0] == '!' || rule[0] == '[')\n                            continue;\n                        lines.Add(rule);
            string[] lines = content.Split(new char[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);\n            List<string> valid_lines = new List<string>(lines.Length);\n            foreach (string line in lines)
                if (line[0] == '!' || line[0] == '[')\n                    continue;\n                valid_lines.Add(line);
﻿using Shadowsocks.View;\nusing System;
        public string fontName;\n        public float fontSize;\n        public string bgColor;\n        public string textColor;
            fontName = "Consolas";\n            fontSize = 8;\n            bgColor = "black";\n            textColor = "white";
            width = 600;\n            height = 400;\n            left = GetBestLeft();\n            top = GetBestTop();\n            maximized = true;
        public int GetBestLeft()
            width = (width >= 400) ? width : 400;  // set up the minimum size\n            return Screen.PrimaryScreen.WorkingArea.Width - width;\n        }\n        public int GetBestTop()\n        {\n            height = (height >= 200) ? height : 200;  // set up the minimum size\n            return Screen.PrimaryScreen.WorkingArea.Height - height;\n        }\n        public Font GetFont()\n        {\n            try
        public void SetFont(Font font)
            fontName = font.Name;\n            fontSize = font.Size;\n        }\n        public Color GetBackgroundColor()\n        {\n            try
                return ColorTranslator.FromHtml(bgColor);\n            }\n            catch (Exception)\n            {\n                return ColorTranslator.FromHtml("black");
        public void SetBackgroundColor(Color color)\n        {\n            bgColor = ColorTranslator.ToHtml(color);\n        }\n        public Color GetTextColor()\n        {\n            try\n            {\n                return ColorTranslator.FromHtml(textColor);\n            }\n            catch (Exception)\n            {\n                return ColorTranslator.FromHtml("white");\n            }\n        }\n        public void SetTextColor(Color color)\n        {\n            textColor = ColorTranslator.ToHtml(color);\n        }
                    controller.EnableProxy(proxy, port);
﻿using Shadowsocks.View;\nusing System;\nusing System.Drawing;\nusing System.Windows.Forms;
            this.tableLayoutPanel1.Controls.Add(this.tableLayoutPanel3, 0, 2);
            this.tableLayoutPanel1.Controls.Add(this.tableLayoutPanel2, 0, 1);
            this.tableLayoutPanel1.RowCount = 3;\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.Size = new System.Drawing.Size(395, 87);
            _remote?.BeginSend(buffer, offset, size, socketFlags, callback, state);
            _remote?.BeginReceive(buffer, offset, size, socketFlags, callback, state);
            _remote?.Shutdown(how);
            _remote?.Dispose();
        public void EnableProxy(string proxy, int port)
        const string MIN_LEVEL_ATTRIBUTE = "minlevel";\n        const string FILE_NAME_ATTRIBUTE = "fileName";
        XmlElement logFileNameElement;
            logLevelElement.SetAttribute(MIN_LEVEL_ATTRIBUTE, logLevel.ToString("G"));
﻿using Shadowsocks.Controller;\nusing Shadowsocks.Model;\nusing Shadowsocks.Properties;\nusing System;
using System.Text;
            this.panel1 = new System.Windows.Forms.Panel();\n            this.button2 = new System.Windows.Forms.Button();\n            this.button1 = new System.Windows.Forms.Button();
            this.contextMenuStrip1.SuspendLayout();
            this.contextMenuStrip1.ResumeLayout(false);
        private System.Windows.Forms.Panel panel1;\n        private System.Windows.Forms.Button button2;\n        private System.Windows.Forms.Button button1;
        public Encryptor(string password)
            // TODO endian\n            var a = BitConverter.ToUInt64(hash, 0);\n            for (int i = 0; i < 256; i++)\n            {\n                encryptTable[i] = (byte)i;\n            }\n            for (int i = 1; i < 1024; i++)\n            {\n                encryptTable = mergeSort(encryptTable, a, i);\n            }\n            for (int i = 0; i < 256; i++)\n            {\n                decryptTable[encryptTable[i]] = (byte)i;
            for (int i = 0; i < length; i++)
                buf[i] = encryptTable[buf[i]];
            for (int i = 0; i < length; i++)
                buf[i] = decryptTable[buf[i]];
using System.Text;
using System.Net;
using Shadowsocks.Controller.Strategy;\nusing System.Timers;
        public ISet<Handler> Handlers
            this._controller = controller;\n            this.Handlers = new HashSet<Handler>();\n            this._lastSweepTime = DateTime.Now;
            Handler handler = new Handler();
            IList<Handler> handlersToClose = new List<Handler>();\n            lock (this.Handlers)\n            {\n                this.Handlers.Add(handler);\n                Logging.Debug($"TCP connections: {Handlers.Count}");
                    foreach (Handler handler1 in this.Handlers)
            foreach (Handler handler1 in handlersToClose)
    class Handler
            this.encryptor = EncryptorFactory.GetEncryptor(server.method, server.password, server.auth, false);
            this._firstPacket = firstPacket;\n            this._firstPacketLength = length;\n            this.HandshakeReceive();\n            this.lastActivity = DateTime.Now;
                this.Close();
                Logging.Debug($"TCP connections: {relay.Handlers.Count}");
                    Logging.Debug($"======Send Local Port, size:" + response.Length);
                    this.Close();\n                }\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                this.Close();
                        Logging.Debug($"======Send Local Port, size:" + response.Length);
                    Logging.Error("failed to recv data in handshakeReceive2Callback");\n                    this.Close();\n                }\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                this.Close();
                    Logging.Debug($"======Receive Local Port, size:" + RecvSize);\n                    connection.BeginReceive(connetionRecvBuffer, 0, RecvSize, 0,\n                        new AsyncCallback(ReadAll), null);
                        Logging.Debug($"======Receive Local Port, size:" + RecvSize);\n                        connection.BeginReceive(connetionRecvBuffer, 0, RecvSize, 0,\n                            new AsyncCallback(ReadAll), null);
                        this.Close();\n                    }\n                }\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                this.Close();
            if (retryCount < 4)\n            {\n                Logging.Debug("Connection failed, retrying");
                this.Close();
                    this.lastActivity = DateTime.Now;
                    Logging.Debug($"======Send Local Port, size:" + bytesToSend);
                        strategy.UpdateLastRead(this.server);
                    if (totalRead == 0)\n                    {\n                        // closed before anything received, reports as failure\n                        // disable this feature\n                        // controller.GetCurrentStrategy().SetFailure(this.server);\n                    }\n                }\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                this.Close();
                    Logging.Debug($"++++++Send Server Port, size:" + bytesToSend);
                        strategy.UpdateLastWrite(this.server);
﻿using Shadowsocks.Model;\nusing System;
using System.Text;
﻿using System.IO;\nusing Shadowsocks.Model;\nusing System;
using System.Net.Sockets;
using System.Net;
using Shadowsocks.Properties;
using System.Text;
using System.Net.Sockets;\nusing System.Net;\nusing System.Runtime.CompilerServices;\nusing Shadowsocks.Controller.Strategy;
using System.Collections.Generic;
using System.Text;
using System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Data;
using System.Linq;\nusing System.Text;
using System.Collections.Generic;
using System.Text;
            private SpinLock _lock = new SpinLock();
                bool lockTaken = false;\n                try\n                {\n                    _lock.Enter(ref lockTaken);\n                    Interlocked.Add(ref _inbound, delta);\n                }\n                finally\n                {\n                    if (lockTaken)\n                    {\n                        _lock.Exit(false);\n                    }\n                }
                bool lockTaken = false;\n                try\n                {\n                    _lock.Enter(ref lockTaken);\n                    Interlocked.Add(ref _outbound, delta);\n                }\n                finally\n                {\n                    if (lockTaken)\n                    {\n                        _lock.Exit(false);\n                    }\n                }
                bool lockTaken = false;\n                try\n                {\n                    _lock.Enter(ref lockTaken);\n                    var i = Interlocked.Read(ref _inbound);\n                    var il = Interlocked.Exchange(ref _lastInbound, i);\n                    inboundDelta = i - il;\n                    var o = Interlocked.Read(ref _outbound);\n                    var ol = Interlocked.Exchange(ref _lastOutbound, o);\n                    outboundDelta = o - ol;\n                }\n                finally\n                {\n                    if (lockTaken)\n                    {\n                        _lock.Exit(false);\n                    }\n                }
        string DestHost { get; }\n        int DestPort { get; }
        void BeginConnectDest(string host, int port, AsyncCallback callback, object state);
        public void BeginConnectDest(string host, int port, AsyncCallback callback, object state)\n        {\n            DestHost = host;\n            DestPort = port;
            IPAddress ipAddress;\n            bool parsed = IPAddress.TryParse(host, out ipAddress);\n            if (parsed)\n            {\n                IPEndPoint ep = new IPEndPoint(ipAddress, port);\n                switch (ep.AddressFamily)
                var addr = ep.Address.GetAddressBytes();
            }\n            else\n            {\n                // maybe is a domain name, we will leave it to server\n                // need ValidateTcpPort? porttest > 1 && porttest < 65535?\n                atyp = 3; // DOMAINNAME\n                var enc = Encoding.UTF8;\n                var hostByteCount = enc.GetByteCount(host);\n                request = new byte[4 + 1/*length byte*/ + hostByteCount + 2];\n                request[4] = (byte)hostByteCount;\n                enc.GetBytes(host, 0, host.Length, request, 5);
        public string DestHost { get; private set; }\n        public int DestPort { get; private set; }
        public void BeginConnectDest(string host, int port, AsyncCallback callback, object state)
            // TODO async resolving\n            IPAddress ipAddress;\n            bool parsed = IPAddress.TryParse(host, out ipAddress);\n            if (!parsed)
                IPHostEntry ipHostInfo = Dns.GetHostEntry(host);\n                ipAddress = ipHostInfo.AddressList[0];
            IPEndPoint remoteEP = new IPEndPoint(ipAddress, port);\n            DestHost = host;\n            DestPort = port;
                _remote = new Socket(remoteEP.AddressFamily, SocketType.Stream, ProtocolType.Tcp);
            _remote.BeginConnect(remoteEP, callback, state);
        public LogForm(ShadowsocksController controller, string filename=null)
            this.filename = filename;
namespace Shadowsocks.Encryption
    public class SodiumEncryptor\n        : IVEncryptor, IDisposable
        protected override void cipherUpdate(bool isCipher, int length, byte[] buf, byte[] outbuf)
            if (isCipher)
                    Sodium.crypto_stream_salsa20_xor_ic(sodiumBuf, sodiumBuf, (ulong)(padding + length), iv, ic, _key);
                    Sodium.crypto_stream_chacha20_xor_ic(sodiumBuf, sodiumBuf, (ulong)(padding + length), iv, ic, _key);
                    Sodium.crypto_stream_chacha20_ietf_xor_ic(sodiumBuf, sodiumBuf, (ulong)(padding + length), iv, (uint)ic, _key);
            if (isCipher)
﻿using System.Text;\nnamespace Shadowsocks.Encryption
    public struct EncryptorInfo
        protected EncryptorBase(string method, string password, bool onetimeauth, bool isudp)
            OnetimeAuth = onetimeauth;\n            IsUDP = isudp;
        protected bool OnetimeAuth;\n        protected bool IsUDP;\n        protected byte[] GetPasswordHash()\n        {\n            byte[] inputBytes = Encoding.UTF8.GetBytes(Password);\n            byte[] hash = MbedTLS.MD5(inputBytes);\n            return hash;\n        }
    public class Sodium
        const string DLLNAME = "libsscrypto";
            string dllPath = Utils.GetTempPath("libsscrypto.dll");
            catch (Exception e)
        public static extern int crypto_stream_salsa20_xor_ic(byte[] c, byte[] m, ulong mlen, byte[] n, ulong ic, byte[] k);
        public static extern int crypto_stream_chacha20_xor_ic(byte[] c, byte[] m, ulong mlen, byte[] n, ulong ic, byte[] k);
        public static extern int crypto_stream_chacha20_ietf_xor_ic(byte[] c, byte[] m, ulong mlen, byte[] n, uint ic, byte[] k);
        public static extern void ss_sha1_hmac_ex(byte[] key, uint keylen,\n            byte[] input, int ioff, uint ilen,\n            byte[] output);
            _rng.GetBytes(buf);
            catch (Exception)
        private LRUCache<IPEndPoint, UDPHandler> _cache;
            this._cache = new LRUCache<IPEndPoint, UDPHandler>(512);  // todo: choose a smart number
                IEncryptor encryptor = EncryptorFactory.GetEncryptor(_server.method, _server.password, _server.auth, true);\n                byte[] dataIn = new byte[length - 3 + IVEncryptor.ONETIMEAUTH_BYTES];
                byte[] dataOut = new byte[length - 3 + 16 + IVEncryptor.ONETIMEAUTH_BYTES];
                encryptor.Encrypt(dataIn, length - 3, dataOut, out outlen);
        // Size of receive buffer.\n        public static readonly int RecvSize = 8192;\n        public static readonly int RecvReserveSize = IVEncryptor.ONETIMEAUTH_BYTES + IVEncryptor.AUTH_BYTES; // reserve for one-time auth\n        public static readonly int BufferSize = RecvSize + RecvReserveSize + 32;
        private bool        _proxyConnected;\n        private bool        _destConnected;\n        private byte    _command;\n        private byte[]  _firstPacket;\n        private int     _firstPacketLength;\n        private int     _totalRead = 0;\n        private int     _totalWrite = 0;\n        private byte[]  _remoteRecvBuffer = new byte[BufferSize];\n        private byte[]  _remoteSendBuffer = new byte[BufferSize];\n        private byte[]  _connetionRecvBuffer = new byte[BufferSize];\n        private byte[]  _connetionSendBuffer = new byte[BufferSize];\n        private bool    _connectionShutdown = false;\n        private bool    _remoteShutdown = false;\n        private bool    _closed = false;
            lock (_encryptionLock)\n            {\n                lock (_decryptionLock)\n                {\n                    _encryptor = EncryptorFactory.GetEncryptor(server.method, server.password, server.auth, false);\n                }\n            }
                _connection.BeginReceive(_connetionRecvBuffer, 0, 3 + 2, SocketFlags.None,\n                    new AsyncCallback(handshakeReceive2Callback), null);\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void handshakeReceive2Callback(IAsyncResult ar)
                    if (_command != 1 && _command != 3)
                        if (_command == 1)
                                new AsyncCallback(ResponseCallback), null);
                        else if (_command == 3)
                case 1: // IPv4 address, 4 bytes\n                    ReadAddress(4 + 2 - 1, onSuccess);
                case 3: // domain name, length + str
                    ReadAddress(len + 2, onSuccess);
                case 4: // IPv6 address, 16 bytes\n                    ReadAddress(16 + 2 - 1, onSuccess);
            Array.Copy(_connetionRecvBuffer, 3, _connetionRecvBuffer, 0, 2);
                        case 1: // IPv4 address, 4 bytes\n                            dst_addr = new IPAddress(_connetionRecvBuffer.Skip(1).Take(4).ToArray()).ToString();\n                            dst_port = (_connetionRecvBuffer[5] << 8) + _connetionRecvBuffer[6];
                        case 3: // domain name, length + str
                            dst_addr = System.Text.Encoding.UTF8.GetString(_connetionRecvBuffer, 2, len);\n                            dst_port = (_connetionRecvBuffer[len + 2] << 8) + _connetionRecvBuffer[len + 3];
                        case 4: // IPv6 address, 16 bytes\n                            dst_addr = $"[{new IPAddress(_connetionRecvBuffer.Skip(1).Take(16).ToArray())}]";\n                            dst_port = (_connetionRecvBuffer[17] << 8) + _connetionRecvBuffer[18];
            byte[] response = new byte[4 + address.Length + 2];
                    response[3] = 1;
                    response[3] = 4;
            _connection.BeginSend(response, 0, response.Length, SocketFlags.None, new AsyncCallback(ReadAll), true);
                    _connection.BeginReceive(_connetionRecvBuffer, 0, RecvSize, SocketFlags.None, new AsyncCallback(ReadAll), null);
                        _connection.BeginReceive(_connetionRecvBuffer, 0, RecvSize, SocketFlags.None, new AsyncCallback(ReadAll), null);
                EndPoint proxyEP;
                ProxyTimer proxyTimer = new ProxyTimer(_proxyTimeout);\n                proxyTimer.AutoReset = false;\n                proxyTimer.Elapsed += proxyConnectTimer_Elapsed;
                remote.BeginConnectProxy(proxyEP, new AsyncCallback(ProxyConnectCallback), new AsyncSession<ProxyTimer>(remote, proxyTimer));\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void proxyConnectTimer_Elapsed(object sender, ElapsedEventArgs e)\n        {\n            var timer = (ProxyTimer) sender;\n            timer.Elapsed -= proxyConnectTimer_Elapsed;
            Server server = null;
                server = timer.Server;\n                timer.Elapsed -= proxyConnectTimer_Elapsed;
                ServerTimer connectTimer = new ServerTimer(_serverTimeout);\n                connectTimer.AutoReset = false;\n                connectTimer.Elapsed += destConnectTimer_Elapsed;
                remote.BeginConnectDest(destEndPoint, new AsyncCallback(ConnectCallback), new AsyncSession<ServerTimer>(session, connectTimer));
                    int bytesToSend;
                        _encryptor.Decrypt(_remoteRecvBuffer, bytesRead, _remoteSendBuffer, out bytesToSend);\n                    }\n                    _connection.BeginSend(_remoteSendBuffer, 0, bytesToSend, SocketFlags.None, new AsyncCallback(PipeConnectionSendCallback), session);
                _encryptor.Encrypt(_connetionRecvBuffer, length, _connetionSendBuffer, out bytesToSend);
            session.Remote.BeginSend(_connetionSendBuffer, 0, bytesToSend, SocketFlags.None, new AsyncCallback(PipeRemoteSendCallback), session);
                var session = (AsyncSession)ar.AsyncState;\n                session.Remote.EndSend(ar);\n                _connection.BeginReceive(_connetionRecvBuffer, 0, RecvSize, SocketFlags.None, new AsyncCallback(PipeConnectionReceiveCallback), session);\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }
                var session = (AsyncSession)ar.AsyncState;\n                _connection.EndSend(ar);\n                session.Remote.BeginReceive(_remoteRecvBuffer, 0, RecvSize, SocketFlags.None, new AsyncCallback(PipeRemoteReceiveCallback), session);
namespace Shadowsocks.Encryption
    public class MbedTLSEncryptor\n        : IVEncryptor, IDisposable
        public MbedTLSEncryptor(string method, string password, bool onetimeauth, bool isudp)\n            : base(method, password, onetimeauth, isudp)
            base.initCipher(iv, isCipher);
                isCipher ? MbedTLS.MBEDTLS_ENCRYPT : MbedTLS.MBEDTLS_DECRYPT) != 0 )\n                throw new Exception("Cannot set mbed TLS cipher key");
                throw new Exception("Cannot set mbed TLS cipher IV");
                throw new Exception("Cannot finalize mbed TLS cipher context");
        protected override void cipherUpdate(bool isCipher, int length, byte[] buf, byte[] outbuf)
            if (MbedTLS.cipher_update(isCipher ? _encryptCtx : _decryptCtx,
                throw new Exception("Cannot update mbed TLS cipher context");
        ~MbedTLSEncryptor()
        private static Dictionary<string, Type> _registeredEncryptors;\n        private static Type[] _constructorTypes = new Type[] { typeof(string), typeof(string), typeof(bool), typeof(bool) };
            _registeredEncryptors = new Dictionary<string, Type>();\n            foreach (string method in MbedTLSEncryptor.SupportedCiphers())
                _registeredEncryptors.Add(method, typeof(MbedTLSEncryptor));
            foreach (string method in SodiumEncryptor.SupportedCiphers())
                _registeredEncryptors.Add(method, typeof(SodiumEncryptor));
        public static IEncryptor GetEncryptor(string method, string password, bool onetimeauth, bool isudp)
            ConstructorInfo c = t.GetConstructor(_constructorTypes);\n            IEncryptor result = (IEncryptor)c.Invoke(new object[] { method, password, onetimeauth, isudp });
    public class MbedTLS
        const string DLLNAME = "libsscrypto";
            string dllPath = Utils.GetTempPath("libsscrypto.dll");
            catch (Exception e)
        public static extern void md5(byte[] input, uint ilen, byte[] output);
        public static extern int cipher_get_size_ex();
            return _currentServer;
            Server oldServer = _currentServer;
                _currentServer = max.server;\n                if (_currentServer != oldServer)
                    Console.WriteLine("HA switching to server: {0}", _currentServer.FriendlyName());
                Logging.Debug(String.Format("choosing server: {0}", _currentServer.FriendlyName()));
            this.PasswordTextBox.PasswordChar = '*';
                        new KeyValuePair<string, string>("OutboundSpeed", GetRecentOutboundSpeed(server)),\n                        new KeyValuePair<string, string>("Status", reply?.Status.ToString()),\n                        new KeyValuePair<string, string>("RoundtripTime", reply?.RoundtripTime.ToString())
            var geolocationAndIsp = GetGeolocationAndIsp();
                    Append(dataList, geolocationAndIsp.Result);
            public const string Geolocation = "Geolocation";\n            public const string ISP = "ISP";
            public string Geolocation;\n            public string ISP;
                    _encryptIVOffset = new byte[8];
                    _decryptIVOffset = new byte[8];
                    _encryptIVOffset = new byte[8];
                    _decryptIVOffset = new byte[8];
                            PolarSSL.aes_crypt_cfb128(_encryptCtx, PolarSSL.AES_ENCRYPT, length, _encryptIVOffset, _encryptIV, buf, tempbuf);
                            PolarSSL.blowfish_crypt_cfb64(_encryptCtx, PolarSSL.BLOWFISH_ENCRYPT, length, _encryptIVOffset, _encryptIV, buf, tempbuf);
                        PolarSSL.aes_crypt_cfb128(_encryptCtx, PolarSSL.AES_ENCRYPT, length, _encryptIVOffset, _encryptIV, buf, outbuf);
                        PolarSSL.blowfish_crypt_cfb64(_encryptCtx, PolarSSL.BLOWFISH_ENCRYPT, length, _encryptIVOffset, _encryptIV, buf, outbuf);
                            PolarSSL.aes_crypt_cfb128(_decryptCtx, PolarSSL.AES_DECRYPT, length - ivLen, _decryptIVOffset, _decryptIV, tempbuf, outbuf);
                            PolarSSL.blowfish_crypt_cfb64(_decryptCtx, PolarSSL.BLOWFISH_DECRYPT, length - ivLen, _decryptIVOffset, _decryptIV, tempbuf, outbuf);
                        PolarSSL.aes_crypt_cfb128(_decryptCtx, PolarSSL.AES_DECRYPT, length, _decryptIVOffset, _decryptIV, buf, outbuf);
                        PolarSSL.blowfish_crypt_cfb64(_decryptCtx, PolarSSL.BLOWFISH_DECRYPT, length, _decryptIVOffset, _decryptIV, buf, outbuf);
            this.MyCancelButton.Margin = new System.Windows.Forms.Padding(3, 3, 0, 0);
using System.Collections.Generic;\nusing System.ComponentModel;
using System.Text;
using System.Diagnostics;\nusing Microsoft.Win32;
using System.Threading.Tasks;
                IEncryptor encryptor = EncryptorFactory.GetEncryptor(_server.method, _server.password, _server.one_time_auth);
                encryptor.Encrypt(dataIn, length - 3, dataOut, out outlen, true);
        public override void Encrypt(byte[] buf, int length, byte[] outbuf, out int outlength, bool udp)
                _encryptIVSent = true;
                if (OnetimeAuth && ivLen > 0)\n                {\n                    if(!udp)\n                    {\n                        int headLen = getHeadLen(buf, length);\n                        int dataLen = length - headLen;\n                        buf[0] |= ONETIMEAUTH_FLAG;\n                        byte[] hash = genOnetimeAuthHash(buf, headLen);\n                        Buffer.BlockCopy(buf, headLen, buf, headLen + ONETIMEAUTH_BYTES + AUTH_BYTES, dataLen);\n                        Buffer.BlockCopy(hash, 0, buf, headLen, ONETIMEAUTH_BYTES);\n                        hash = genHash(buf, headLen + ONETIMEAUTH_BYTES + AUTH_BYTES, dataLen);\n                        Buffer.BlockCopy(hash, 0, buf, headLen + ONETIMEAUTH_BYTES + CLEN_BYTES, ONETIMEAUTH_BYTES);\n                        byte[] lenBytes = BitConverter.GetBytes((ushort)IPAddress.HostToNetworkOrder((short)dataLen));\n                        Buffer.BlockCopy(lenBytes, 0, buf, headLen + ONETIMEAUTH_BYTES, CLEN_BYTES);\n                        length = headLen + ONETIMEAUTH_BYTES + AUTH_BYTES + dataLen;\n                    }\n                    else\n                    {\n                        buf[0] |= ONETIMEAUTH_FLAG;\n                        byte[] hash = genOnetimeAuthHash(buf, length);\n                        Buffer.BlockCopy(hash, 0, buf, length, ONETIMEAUTH_BYTES);\n                        length += ONETIMEAUTH_BYTES;\n                    }\n                }
                if (OnetimeAuth && ivLen > 0)\n                {\n                    byte[] hash = genHash(buf, 0, length);\n                    Buffer.BlockCopy(buf, 0, buf, AUTH_BYTES, length);\n                    byte[] lenBytes = BitConverter.GetBytes((ushort)IPAddress.HostToNetworkOrder((short)length));\n                    Buffer.BlockCopy(lenBytes, 0, buf, 0, CLEN_BYTES);\n                    Buffer.BlockCopy(hash, 0, buf, CLEN_BYTES, ONETIMEAUTH_BYTES);\n                    length += AUTH_BYTES;\n                }
        protected EncryptorBase(string method, string password, bool onetimeauth)
        public abstract void Encrypt(byte[] buf, int length, byte[] outbuf, out int outlength, bool udp);
        public static IEncryptor GetEncryptor(string method, string password, bool onetimeauth)
            IEncryptor result = (IEncryptor)c.Invoke(new object[] { method, password, onetimeauth });
            encryptor.Encrypt(plain, plain.Length, cipher, out outLen, false);
            encryptor.Encrypt(plain, 1000, cipher, out outLen, false);
            encryptor.Encrypt(plain, 12333, cipher, out outLen, false);
            this.button2 = new System.Windows.Forms.Button();
            // \n            // button2\n            // \n            this.button2.DialogResult = System.Windows.Forms.DialogResult.Cancel;\n            this.button2.Location = new System.Drawing.Point(86, 3);\n            this.button2.Name = "button2";\n            this.button2.Size = new System.Drawing.Size(75, 23);\n            this.button2.TabIndex = 1;\n            this.button2.Text = "Cancel";\n            this.button2.UseVisualStyleBackColor = true;
        private List<int> _latencyRecords;
        private long _lastInboundCounter;\n        private List<int> _inboundSpeedRecords;\n        private long _lastOutboundCounter;\n        private List<int> _outboundSpeedRecords;
        private Timer _writer; //write RawStatistics to file\n        private readonly TimeSpan _writingInterval = TimeSpan.FromMinutes(1);
        private Server CurrentServer => _controller.GetCurrentServer();
                    StartTimerWithoutState(ref _writer, Save, _writingInterval);
                    _writer?.Dispose();
            _inboundSpeedRecords = new List<int>();\n            _outboundSpeedRecords = new List<int>();\n            _latencyRecords = new List<int>();
            var currentServerRecord = new StatisticsRecord(CurrentServer.Identifier(), _inboundSpeedRecords, _outboundSpeedRecords, _latencyRecords);\n            if (!Config.Ping)\n            {\n                AppendRecord(CurrentServer, currentServerRecord);
            var icmpResults = TaskEx.WhenAll(_controller.GetCurrentConfiguration().configs.Select(ICMPTest));\n            foreach (var result in (await icmpResults).Where(result => result != null))\n            {\n                if (result.Server.Equals(CurrentServer))\n                {\n                    currentServerRecord.setResponse(result.RoundtripTime);\n                    AppendRecord(CurrentServer, currentServerRecord);\n                }\n                else\n                {\n                    AppendRecord(result.Server, new StatisticsRecord(result.Server.Identifier(), result.RoundtripTime));\n                }\n            }\n        }\n        private void AppendRecord(Server server, StatisticsRecord record)\n        {\n            List<StatisticsRecord> records;\n            if (!RawStatistics.TryGetValue(server.Identifier(), out records))\n            {\n                records = new List<StatisticsRecord>();\n            }\n            records.Add(record);\n            RawStatistics[server.Identifier()] = records;\n        }\n        private void Save(object _)\n        {
                File.WriteAllText(AvailabilityStatisticsFile,\n                    JsonConvert.SerializeObject(RawStatistics, Formatting.None));
                _writer.Change(_retryInterval, _writingInterval);
            _writer.Dispose();
        public void UpdateInboundCounter(long n)
        }\n        public void UpdateOutboundCounter(long n)
        public string ServerName { get; set; }
        public StatisticsRecord(string identifier, IEnumerable<int> inboundSpeedRecords, IEnumerable<int> outboundSpeedRecords, IEnumerable<int> latencyRecords)
            ServerName = identifier;
            ServerName = identifier;\n            setResponse(responseRecords);
        public void setResponse(IEnumerable<int?> responseRecords)
            PackageLoss = responseRecords.Count(response => response != null)/(float) responseRecords.Count();
        private float GetScore(string serverName)
            List<StatisticsRecord> records;\n            if (_filteredStatistics == null || !_filteredStatistics.TryGetValue(serverName, out records)) return 0;\n            float factor;\n            float score = 0;\n            var averageRecord = new StatisticsRecord(serverName,\n                records.FindAll(record => record.MaxInboundSpeed != null).Select(record => record.MaxInboundSpeed.Value),\n                records.FindAll(record => record.MaxOutboundSpeed != null).Select(record => record.MaxOutboundSpeed.Value),\n                records.FindAll(record => record.AverageLatency != null).Select(record => record.AverageLatency.Value));\n            averageRecord.setResponse(records.Select(record => record.AverageResponse));\n            if (!config.Calculations.TryGetValue("PackageLoss", out factor)) factor = 0;\n            score += averageRecord.PackageLoss * factor ?? 0;\n            if (!config.Calculations.TryGetValue("AverageResponse", out factor)) factor = 0;\n            score += averageRecord.AverageResponse * factor ?? 0;\n            if (!config.Calculations.TryGetValue("MinResponse", out factor)) factor = 0;\n            score += averageRecord.MinResponse * factor ?? 0;\n            if (!config.Calculations.TryGetValue("MaxResponse", out factor)) factor = 0;\n            score += averageRecord.MaxResponse * factor ?? 0;\n            Logging.Debug($"Highest score: {score} {JsonConvert.SerializeObject(averageRecord, Formatting.Indented)}");
            this.bindingConfiguration = new System.Windows.Forms.BindingSource(this.components);
            this.ServersListBox.ItemHeight = 12;
            // \n            // label6\n            // \n            this.label6.Anchor = System.Windows.Forms.AnchorStyles.Right;\n            this.label6.AutoSize = true;\n            this.label6.Location = new System.Drawing.Point(38, 146);\n            this.label6.Name = "label6";\n            this.label6.Size = new System.Drawing.Size(41, 12);\n            this.label6.TabIndex = 9;\n            this.label6.Text = "Remark";\n            // \n            // RemarkTextBox\n            // \n            this.RemarkTextBox.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));\n            this.RemarkTextBox.Location = new System.Drawing.Point(85, 142);\n            this.RemarkTextBox.Name = "RemarkTextBox";\n            this.RemarkTextBox.Size = new System.Drawing.Size(160, 21);\n            this.RemarkTextBox.TabIndex = 10;\n            this.RemarkTextBox.WordWrap = false;
                    string line;\n                    while ((line = sr.ReadLine()) != null)
                        if (line.BeginWith('#'))
        private int port;
        public Local(int port)\n        {\n            this.port = port;\n            this.encryptor = new Encryptor("barfoo!");
            IPEndPoint localEndPoint = new IPEndPoint(0, port);
            IPHostEntry ipHostInfo = Dns.GetHostEntry("127.0.0.1");
            IPEndPoint remoteEP = new IPEndPoint(ipAddress, 8388);
        void controller_UpdatePACFromGFWListError(object sender, System.IO.ErrorEventArgs e)
        void controller_UpdatePACFromGFWListCompleted(object sender, GeositeResultEventArgs e)
            UpdatePACFromGFWListCompleted?.Invoke(this, e);
            UpdatePACFromGFWListError?.Invoke(this, e);
            RegistryKey registry = Registry.CurrentUser.OpenSubKey("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings", true);\n            registry.SetValue("ProxyEnable", 0);\n            registry.SetValue("ProxyServer", "");\n            registry.SetValue("AutoConfigURL", "http://127.0.0.1:8090/pac?t=" + GetTimestamp(DateTime.Now));\n            SystemProxy.NotifyIE();
            RegistryKey registry = Registry.CurrentUser.OpenSubKey("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings", true);\n            registry.SetValue("ProxyEnable", 0);\n            registry.SetValue("ProxyServer", "");\n            registry.SetValue("AutoConfigURL", "");\n            SystemProxy.NotifyIE();
            if (File.Exists(PACServer.PAC_FILE))
                string original = FileManager.NonExclusiveReadAllText(PACServer.PAC_FILE, Encoding.UTF8);
            File.WriteAllText(PACServer.PAC_FILE, abpContent, Encoding.UTF8);
            string pacFilename = _pacServer.TouchPACFile();
            string userRuleFilename = _pacServer.TouchUserRuleFile();
                _pacServer = new PACServer();\n                _pacServer.PACFileChanged += PacServer_PACFileChanged;\n                _pacServer.UserRuleFileChanged += PacServer_UserRuleFileChanged;\n            }\n            _pacServer.UpdateConfiguration(_config);
        public const string PAC_FILE = "pac.txt";\n        public const string USER_RULE_FILE = "user-rule.txt";\n        public const string USER_ABP_FILE = "abp.txt";
        FileSystemWatcher PACFileWatcher;\n        FileSystemWatcher UserRuleFileWatcher;
        public event EventHandler PACFileChanged;\n        public event EventHandler UserRuleFileChanged;\n        public PACServer()
            this.WatchPacFile();\n            this.WatchUserRuleFile();
        public void UpdateConfiguration(Configuration config)
                foreach (string line in lines)
                    string[] kv = line.Split(new char[] { ':' }, 2);
                    }\n                    else if (kv.Length == 1)\n                    {\n                        if (line.IndexOf("pac", StringComparison.Ordinal) >= 0)\n                        {\n                            pathMatch = true;\n                        }\n                        if (!secretMatch)\n                        {\n                            if (line.IndexOf(PacSecret, StringComparison.Ordinal) >= 0)\n                            {\n                                secretMatch = true;\n                            }\n                        }
        public string TouchPACFile()\n        {\n            if (File.Exists(PAC_FILE))\n            {\n                return PAC_FILE;\n            }\n            else\n            {\n                FileManager.UncompressFile(PAC_FILE, Resources.proxy_pac_txt);\n                return PAC_FILE;\n            }\n        }\n        internal string TouchUserRuleFile()\n        {\n            if (File.Exists(USER_RULE_FILE))\n            {\n                return USER_RULE_FILE;\n            }\n            else\n            {\n                File.WriteAllText(USER_RULE_FILE, Resources.user_rule);\n                return USER_RULE_FILE;\n            }\n        }\n        private string GetPACContent()\n        {\n            if (File.Exists(PAC_FILE))\n            {\n                return File.ReadAllText(PAC_FILE, Encoding.UTF8);\n            }\n            else\n            {\n                return Utils.UnGzip(Resources.proxy_pac_txt);\n            }\n        }
                string pacContent = GetPACContent().Replace("__PROXY__", proxy);
        private Timer _recorder; //analyze and save cached records to RawStatistics and filter records
        private Timer _speedMonior;
                    StartTimerWithoutState(ref _recorder, Run, RecordingInterval);
                    StartTimerWithoutState(ref _speedMonior, UpdateSpeed, _monitorInterval);
                    _recorder?.Dispose();\n                    _speedMonior?.Dispose();
        private void StartTimerWithoutState(ref Timer timer, TimerCallback callback, TimeSpan interval)\n        {\n            if (timer?.Change(_delayBeforeStart, interval) == null)\n            {\n                timer = new Timer(callback, null, _delayBeforeStart, interval);\n            }\n        }\n        private void UpdateSpeed(object _)
        private void Run(object _)
            state.counter = _controller.GetCurrentConfiguration().configs.Count;\n            foreach (var server in _controller.GetCurrentConfiguration().configs)\n            {\n                var id = server.Identifier();\n                List<int> inboundSpeedRecords = null;\n                List<int> outboundSpeedRecords = null;\n                List<int> latencyRecords = null;\n                _inboundSpeedRecords.TryGetValue(id, out inboundSpeedRecords);\n                _outboundSpeedRecords.TryGetValue(id, out outboundSpeedRecords);\n                _latencyRecords.TryGetValue(id, out latencyRecords);\n                StatisticsRecord record = new StatisticsRecord(id, inboundSpeedRecords, outboundSpeedRecords, latencyRecords);\n                /* duplicate server identifier */\n                if (records.ContainsKey(id))\n                    records[id] = record;\n                else\n                    records.Add(id, record);\n                if (Config.Ping)\n                {\n                    MyPing ping = new MyPing(server, Repeat);\n                    ping.Completed += ping_Completed;\n                    ping.Start(new PingState { state = state, record = record });\n                }\n                else if (!record.IsEmptyData())\n                {\n                    AppendRecord(id, record);\n                }\n            }\n            if (!Config.Ping)
                if (FilteredStatistics == null)\n                {\n                    FilteredStatistics = new Statistics();\n                }
                    FilteredStatistics[server] = filteredRecords;\n                }
                Console.WriteLine($"failed to load statistics; try to reload {_retryInterval.TotalMinutes} minutes later");\n                _recorder.Change(_retryInterval, RecordingInterval);
            _recorder.Dispose();\n            _speedMonior.Dispose();
        private string PacSecret { get; set; } = "";
            this._config = config;\n            if (config.secureLocalPac)\n            {\n                var rd = new byte[32];\n                RNG.GetBytes(rd);\n                PacSecret = $"&secret={Convert.ToBase64String(rd)}";\n            }\n            else\n            {\n                PacSecret = "";\n            }\n            PacUrl = $"http://{config.localHost}:{config.localPort}/{RESOURCE_NAME}?hash={GetHash(_pacDaemon.GetPACContent())}{PacSecret}";
                return BitConverter.ToString(md5Bytes).Replace("-", "");
    public class I18N
        protected static Dictionary<string, string> Strings;\n        static void Init(string res)
            Strings = new Dictionary<string, string>();\n            string name = CultureInfo.CurrentCulture.Name;\n            if (name.StartsWith("zh"))
                if (name == "zh" || name == "zh-CN")\n                {\n                    Init(Resources.cn);\n                }\n                else\n                {\n                    Init(Resources.zh_tw);\n                }
            if (Strings.ContainsKey(key))\n            {\n                return Strings[key];\n            }\n            else\n            {\n                return key;\n            }
                File.WriteAllText(I18N_FILE, i18n, Encoding.UTF8);
﻿using System;
using System.Drawing.Imaging;
using Shadowsocks.Controller;\nusing Shadowsocks.Model;\nusing Shadowsocks.Properties;\nusing Shadowsocks.Util;\nusing System.Linq;\nusing Microsoft.Win32;\nusing System.Windows.Interop;
                Local local = new Local(_config);
                services.Add(local);
            bool Handle(byte[] firstPacket, int length, Socket socket);
        Socket _socket;
                _socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);\n                _socket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, true);
                _socket.Bind(localEndPoint);\n                _socket.Listen(1024);
                _socket.BeginAccept(
                    _socket);
                _socket.Close();
            if (_socket != null)
                _socket.Close();\n                _socket = null;
                    if (service.Handle(buf, bytesRead, conn))
                // shouldn't happen\n                conn.Close();
    class Local : Listener.Service
        public Local(Configuration config)
        public bool Handle(byte[] firstPacket, int length, Socket socket)\n        {
        public bool Handle(byte[] firstPacket, int length, Socket socket)
        public bool Handle(byte[] firstPacket, int length, Socket socket)
        IAsyncResult BeginConnectProxy(EndPoint remoteEP, AsyncCallback callback, object state);
        IAsyncResult BeginConnectDest(EndPoint remoteEP, AsyncCallback callback, object state);
        IAsyncResult BeginSend(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,
        IAsyncResult BeginReceive(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,
        public IAsyncResult BeginConnectProxy(EndPoint remoteEP, AsyncCallback callback, object state)
            return r;
        public IAsyncResult BeginConnectDest(EndPoint remoteEP, AsyncCallback callback, object state)
            return _remote.BeginConnect(remoteEP, callback, state);
        public IAsyncResult BeginSend(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,
            return _remote.BeginSend(buffer, offset, size, socketFlags, callback, state);
        public IAsyncResult BeginReceive(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,
            return _remote.BeginReceive(buffer, offset, size, socketFlags, callback, state);
                foreach (Process p in existingPolipo)
                FileManager.ByteArrayToFile(Utils.GetTempPath("privoxy.conf"), Encoding.UTF8.GetBytes(polipoConfig));
                _process.StartInfo.Arguments = "privoxy.conf";
                if (File.Exists(Path.Combine(Application.StartupPath, "shadowsocks_portable_mode.txt")))
                    LogMessageTextBox.AppendText(line + Environment.NewLine);
                        LogMessageTextBox.AppendText(line + Environment.NewLine);
        private const string TEMP_LOG = "temp.log";\n        private static readonly string[] COMMON_ENV =\n        {\n             "%Tmp%",\n             "%Temp%",\n             "%AppData%",\n             "%LocalAppData%",\n             "%Home%",\n             "%UserProfile%",\n             "%Public%",\n             "%CommonProgramFiles%",\n             "%CommonProgramFiles(x86)%",\n             "%CommonProgramW6432%",\n             "%ProgramFiles%",\n             "%ProgramFiles(x86)%",\n             "%ProgramW6432%",\n             "%ProgramData%",\n        };
                    var tempFolder = Configuration.Load().tempFolder;\n                    if (string.IsNullOrWhiteSpace(tempFolder))
                        tempFolder = "ss_win_temp";\n                    else if (COMMON_ENV.Contains(tempFolder, StringComparer.OrdinalIgnoreCase))\n                        // add subfolder for these common folders\n                        tempFolder += (@"\Shadowsocks\ss_win_temp_" + Application.ExecutablePath.GetHashCode());\n                    tempFolder = Environment.ExpandEnvironmentVariables(tempFolder);\n                    // If `tempFolder` is an absolute path, `Application.StartupPath` will be ignored.\n                    var tempDirectory = Directory.CreateDirectory(Path.Combine(Application.StartupPath, tempFolder));\n                    _tempPath = tempDirectory.FullName;\n                    File.AppendAllText(Path.Combine(_tempPath, TEMP_LOG), $"[{DateTimeOffset.Now.ToString("u")}] Temp folder used by \"{Application.ExecutablePath}\"{Environment.NewLine}");
                Configuration.CheckTempFolder(TempFolderTextBox.Text);
        public void SaveServers(List<Server> servers, int localPort)
            Configuration.Save(_config);\n        }\n        public void SaveTempFolder(string tempFolder)\n        {\n            _config.tempFolder = tempFolder;
        private System.Windows.Forms.Label TempFolderLabel;
        private System.Windows.Forms.TextBox TempFolderTextBox;
                _connection?.BeginReceive(_connetionRecvBuffer, 0, RecvSize, SocketFlags.None, new AsyncCallback(PipeConnectionReceiveCallback), session);
            if (_closed) return;
                _connection?.EndSend(ar);
            this.BackColor = System.Drawing.Color.Crimson;
            using (Bitmap image = new Bitmap(Screen.PrimaryScreen.Bounds.Width,
                using (Graphics g = Graphics.FromImage(image))
                                     image.Size,
                var reader = new BarcodeReader
                    TryHarder = true,\n                    PossibleFormats = new List<BarcodeFormat>
                        BarcodeFormat.QR_CODE
                };\n                var result = reader.Decode(image);\n                if (result != null)\n                {\n                    var success = controller.AddServerBySSURL(result.Text);\n                    if (success)
                        minX -= margin;\n                        maxX += margin;\n                        minY -= margin;\n                        maxY += margin;\n                        QRCodeSplashForm splash = new QRCodeSplashForm();\n                        splash.FormClosed += splash_FormClosed;
                        splash.Size = new Size((int)maxX - (int)minX, (int)maxY - (int)minY);
                MessageBox.Show(I18N.GetString("Failed to scan QRCode"));\n            }
        private ShadowsocksController _controller;
        private StringBuilder _sb = new StringBuilder();\n        private IEnumerable<TextBox> _allTextBoxes;\n        private Label _lb = null;\n        private HotKeys.HotKeyCallBackHandler _callBack = null;
            this.Icon = Icon.FromHandle(Resources.ssw128.GetHicon());
            _allTextBoxes = HotKeys.GetChildControls<TextBox>(this.tableLayoutPanel1);
            this.Text = I18N.GetString("Edit Hotkeys...");
            _sb.Length = 0;
            TextBox tb = sender as TextBox;\n            string content = tb.Text.TrimEnd();
            TextBox tb = sender as TextBox;
            PrepareForHotkey(tb, out _callBack, out _lb);\n            UnregPrevHotkey(_callBack);
            this.Close();
                        _controller.Stop();
                    _controller.Start();
                _controller.Stop();\n                _controller = null;
                LoadLibrary(dllPath);
            var proxy = ((ProxyTimer)sender).Session.Remote;
            var session = ((ServerTimer) sender).Session;\n            Server server = ((ServerTimer)sender).Server;
        private class TcpUserToken : IAsyncResult
            public AsyncCallback Callback { get; }\n            public SocketAsyncEventArgs Args { get; }
            public bool IsCompleted { get; } = true;\n            public WaitHandle AsyncWaitHandle { get; } = null;\n            public object AsyncState { get; }\n            public bool CompletedSynchronously { get; } = true;
            token.Callback(token);
            var tut = asyncResult as TcpUserToken;\n            if (tut == null)
            this.notifyIcon1 = new System.Windows.Forms.NotifyIcon(this.components);
            this.contextMenu1 = new System.Windows.Forms.ContextMenu();\n            this.enableItem = new System.Windows.Forms.MenuItem();\n            this.AutoStartupItem = new System.Windows.Forms.MenuItem();\n            this.ShareOverLANItem = new System.Windows.Forms.MenuItem();\n            this.ServersItem = new System.Windows.Forms.MenuItem();\n            this.SeperatorItem = new System.Windows.Forms.MenuItem();\n            this.ConfigItem = new System.Windows.Forms.MenuItem();\n            this.menuItem4 = new System.Windows.Forms.MenuItem();\n            this.editPACFileItem = new System.Windows.Forms.MenuItem();\n            this.QRCodeItem = new System.Windows.Forms.MenuItem();\n            this.ShowLogItem = new System.Windows.Forms.MenuItem();\n            this.aboutItem = new System.Windows.Forms.MenuItem();\n            this.menuItem3 = new System.Windows.Forms.MenuItem();\n            this.quitItem = new System.Windows.Forms.MenuItem();
            this.menuItem1 = new System.Windows.Forms.MenuItem();
            this.tableLayoutPanel1.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);
            this.tableLayoutPanel1.Padding = new System.Windows.Forms.Padding(5, 5, 5, 5);
        private System.Windows.Forms.NotifyIcon notifyIcon1;
        private System.Windows.Forms.ContextMenu contextMenu1;\n        private System.Windows.Forms.MenuItem enableItem;\n        private System.Windows.Forms.MenuItem aboutItem;\n        private System.Windows.Forms.MenuItem menuItem3;\n        private System.Windows.Forms.MenuItem quitItem;\n        private System.Windows.Forms.MenuItem ConfigItem;\n        private System.Windows.Forms.MenuItem editPACFileItem;
        private System.Windows.Forms.MenuItem ServersItem;\n        private System.Windows.Forms.MenuItem SeperatorItem;\n        private System.Windows.Forms.MenuItem menuItem4;
        private System.Windows.Forms.MenuItem QRCodeItem;\n        private System.Windows.Forms.MenuItem ShowLogItem;\n        private System.Windows.Forms.MenuItem ShareOverLANItem;\nprivate System.Windows.Forms.MenuItem AutoStartupItem;\n        private System.Windows.Forms.MenuItem menuItem1;
            LoadTrayIcon();\n            notifyIcon1.ContextMenu = contextMenu1;
            controller.EnableStatusChanged += controller_EnableStatusChanged;
            controller.PACFileReadyToOpen += controller_PACFileReadyToOpen;\n            controller.ShareOverLANStatusChanged += controller_ShareOverLANStatusChanged;\n            this.updateChecker = new UpdateChecker();\n            updateChecker.NewVersionFound += updateChecker_NewVersionFound;
        }\n        private void LoadTrayIcon()\n        {\n            int dpi;\n            Graphics graphics = this.CreateGraphics();\n            dpi = (int)graphics.DpiX;\n            graphics.Dispose();\n            Bitmap icon = null;\n            if (dpi < 97)\n            {\n                // dpi = 96;\n                icon = Resources.ss16;\n            }\n            else if (dpi < 121)\n            {\n                // dpi = 120;\n                icon = Resources.ss20;\n            }\n            else\n            {\n                icon = Resources.ss24;\n            }\n            notifyIcon1.Icon = Icon.FromHandle(icon.GetHicon());\n            notifyIcon1.Visible = true;\n            this.Icon = Icon.FromHandle(Resources.ssw128.GetHicon());
        }\n        private void controller_EnableStatusChanged(object sender, EventArgs e)\n        {\n            enableItem.Checked = controller.GetConfiguration().enabled;\n        }\n        void controller_ShareOverLANStatusChanged(object sender, EventArgs e)\n        {\n            ShareOverLANItem.Checked = controller.GetConfiguration().shareOverLan;\n        }\n        void controller_PACFileReadyToOpen(object sender, ShadowsocksController.PathEventArgs e)\n        {\n            string argument = @"/select, " + e.Path;\n            System.Diagnostics.Process.Start("explorer.exe", argument);\n        }\n        void updateChecker_NewVersionFound(object sender, EventArgs e)\n        {\n            notifyIcon1.BalloonTipTitle = "Shadowsocks " + updateChecker.LatestVersionNumber + " Update Found";\n            notifyIcon1.BalloonTipText = "Click here to download";\n            notifyIcon1.BalloonTipIcon = ToolTipIcon.Info;\n            notifyIcon1.BalloonTipClicked += notifyIcon1_BalloonTipClicked;\n            notifyIcon1.ShowBalloonTip(5000);\n            _isFirstRun = false;
            UpdateServersMenu();\n            enableItem.Checked = _modifiedConfiguration.enabled;\n            ShareOverLANItem.Checked = _modifiedConfiguration.shareOverLan;\n            AutoStartupItem.Checked = AutoStartup.Check();\n        }\n        private void UpdateServersMenu()\n        {\n            var items = ServersItem.MenuItems;\n            items.Clear();\n            Configuration configuration = controller.GetConfiguration();\n            for (int i = 0; i < configuration.configs.Count; i++)\n            {\n                Server server = configuration.configs[i];\n                MenuItem item = new MenuItem(string.IsNullOrEmpty(server.remarks) ? server.server + ":" + server.server_port : server.server + ":" + server.server_port + " (" + server.remarks + ")");\n                item.Tag = i;\n                item.Click += AServerItem_Click;\n                items.Add(item);\n            }\n            items.Add(SeperatorItem);\n            items.Add(ConfigItem);\n            if (configuration.index >= 0 && configuration.index < configuration.configs.Count)\n            {\n                items[configuration.index].Checked = true;\n            }
            if (!controller.GetConfiguration().isDefault)\n            {\n                this.Opacity = 0;\n                BeginInvoke(new MethodInvoker(delegate\n                {\n                    this.Hide();\n                }));\n            }\n            else\n            {\n                _isFirstRun = true;\n            }\n            updateChecker.CheckUpdate();
            ShowFirstTimeBalloon();
            this.Hide();\n            LoadCurrentConfiguration();\n            ShowFirstTimeBalloon();\n        }\n        private void ConfigForm_FormClosed(object sender, FormClosedEventArgs e)\n        {\n            controller.Stop();\n        }\n        private void AboutItem_Click(object sender, EventArgs e)\n        {\n            Process.Start("https://github.com/clowwindy/shadowsocks-csharp");\n        }\n        private void notifyIcon1_DoubleClick(object sender, EventArgs e)\n        {\n            ShowWindow();\n        }\n        private void EnableItem_Click(object sender, EventArgs e)\n        {\n            enableItem.Checked = !enableItem.Checked;\n            controller.ToggleEnable(enableItem.Checked);\n        }\n        private void ShareOverLANItem_Click(object sender, EventArgs e)\n        {\n            ShareOverLANItem.Checked = !ShareOverLANItem.Checked;\n            controller.ToggleShareOverLAN(ShareOverLANItem.Checked);\n        }\n        private void EditPACFileItem_Click(object sender, EventArgs e)\n        {\n            controller.TouchPACFile();\n        }\n        private void AServerItem_Click(object sender, EventArgs e)\n        {\n            MenuItem item = (MenuItem)sender;\n            controller.SelectServerIndex((int)item.Tag);\n        }\n        private void ShowLogItem_Click(object sender, EventArgs e)\n        {\n            string argument = Logging.LogFile;\n            System.Diagnostics.Process.Start("notepad.exe", argument);
        private void QRCodeItem_Click(object sender, EventArgs e)
            QRCodeForm qrCodeForm = new QRCodeForm(controller.GetQRCodeForCurrentServer());\n            qrCodeForm.Icon = this.Icon;\n            qrCodeForm.Show();
private void AutoStartupItem_Click(object sender, EventArgs e) {\nAutoStartupItem.Checked = !AutoStartupItem.Checked;\nif (!AutoStartup.Set(AutoStartupItem.Checked)) {\nMessageBox.Show("Failed to edit registry");\n}\n}
            try\n            {\n                Socket listener = (Socket)ar.AsyncState;
                listener.BeginAccept(\n                    new AsyncCallback(AcceptCallback),\n                    listener);
            try\n            {\n                Socket listener = (Socket)ar.AsyncState;
                listener.BeginAccept(\n                    new AsyncCallback(AcceptCallback),\n                    listener);
            this.panel1 = new System.Windows.Forms.Panel();\n            this.panel3 = new System.Windows.Forms.Panel();
            this.panel1.SuspendLayout();\n            this.panel3.SuspendLayout();
            this.OKButton.Location = new System.Drawing.Point(4, 4);
            this.MyCancelButton.Location = new System.Drawing.Point(87, 4);
            // panel1\n            // \n            this.panel1.AutoSize = true;\n            this.panel1.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;\n            this.panel1.Controls.Add(this.MyCancelButton);\n            this.panel1.Controls.Add(this.OKButton);\n            this.panel1.Location = new System.Drawing.Point(313, 247);\n            this.panel1.Margin = new System.Windows.Forms.Padding(0);\n            this.panel1.Name = "panel1";\n            this.panel1.Size = new System.Drawing.Size(165, 30);\n            this.panel1.TabIndex = 1;\n            // \n            // panel3\n            // \n            this.panel3.AutoSize = true;\n            this.panel3.Controls.Add(this.DeleteButton);\n            this.panel3.Controls.Add(this.AddButton);\n            this.panel3.Location = new System.Drawing.Point(12, 220);\n            this.panel3.Margin = new System.Windows.Forms.Padding(0);\n            this.panel3.Name = "panel3";\n            this.panel3.Size = new System.Drawing.Size(192, 31);\n            this.panel3.TabIndex = 5;\n            // 
            this.DeleteButton.Location = new System.Drawing.Point(100, 4);
            this.AddButton.Location = new System.Drawing.Point(4, 4);
            this.ServerGroupBox.Location = new System.Drawing.Point(220, 12);
            this.ServersListBox.Location = new System.Drawing.Point(12, 12);
            this.ClientSize = new System.Drawing.Size(489, 287);\n            this.Controls.Add(this.ServersListBox);\n            this.Controls.Add(this.ServerGroupBox);\n            this.Controls.Add(this.panel1);\n            this.Controls.Add(this.panel3);
            this.panel1.ResumeLayout(false);\n            this.panel3.ResumeLayout(false);
        private System.Windows.Forms.Panel panel1;\n        private System.Windows.Forms.Panel panel3;
using System.Linq;
using System.Threading.Tasks;
                        registry.SetValue("ProxyServer", "");
                    registry.SetValue("ProxyServer", "");
﻿using System;
namespace shadowsocks_csharp
﻿using shadowsocks_csharp.Properties;
namespace shadowsocks_csharp
        private bool ByteArrayToFile(string fileName, byte[] content)\n        {\n            try\n            {\n                System.IO.FileStream _FileStream =\n                   new System.IO.FileStream(fileName, System.IO.FileMode.Create,\n                                            System.IO.FileAccess.Write);\n                _FileStream.Write(content, 0, content.Length);\n                _FileStream.Close();\n                return true;\n            }\n            catch (Exception _Exception)\n            {\n                Console.WriteLine("Exception caught in process: {0}",\n                                  _Exception.ToString());\n            }\n            return false;\n        }\n        public static void UncompressFile(string fileName, byte[] content)\n        {\n            FileStream destinationFile = File.Create(fileName);\n            // Because the uncompressed size of the file is unknown, \n            // we are using an arbitrary buffer size.\n            byte[] buffer = new byte[4096];\n            int n;\n            using (GZipStream input = new GZipStream(new MemoryStream(content),\n                CompressionMode.Decompress, false))\n            {\n                while (true)\n                {\n                    n = input.Read(buffer, 0, buffer.Length);\n                    if (n == 0)\n                    {\n                        break;\n                    }\n                    destinationFile.Write(buffer, 0, n);\n                }\n            }\n            destinationFile.Close();\n        }
namespace shadowsocks_csharp
    class SystemProxy
                    Console.WriteLine(e);
                Console.WriteLine(e);
        public interface Service
                foreach (Service service in _services)
            // requested regist and not autostart\n            if (regist && !Check())
        public void CheckUpdate()
            http.Proxy = new WebProxy(IPAddress.Loopback.ToString(), 8123);
            this.tableLayoutPanel1.Controls.Add(this.LogMessageTextBox, 0, 1);
            return $"{f:0.##}{unit}";
            Bitmap icon = null;
                icon = Resources.ss16;
                icon = Resources.ss20;
                icon = Resources.ss24;
            icon = getTrayIconByState(icon, enabled, global);\n            _notifyIcon.Icon = Icon.FromHandle(icon.GetHicon());
            using (Bitmap fullImage = new Bitmap(Screen.PrimaryScreen.Bounds.Width,\n                                            Screen.PrimaryScreen.Bounds.Height))\n            {\n                using (Graphics g = Graphics.FromImage(fullImage))
                    g.CopyFromScreen(Screen.PrimaryScreen.Bounds.X,\n                                     Screen.PrimaryScreen.Bounds.Y,\n                                     0, 0,\n                                     fullImage.Size,\n                                     CopyPixelOperation.SourceCopy);\n                }\n                for (int i = 0; i < 5; i++)\n                {\n                    int marginLeft = fullImage.Width * i / 3 / 5;\n                    int marginTop = fullImage.Height * i / 3 / 5;\n                    Rectangle cropRect = new Rectangle(marginLeft, marginTop, fullImage.Width - marginLeft * 2, fullImage.Height - marginTop * 2);\n                    Bitmap target = new Bitmap(cropRect.Width, cropRect.Height);\n                    using (Graphics g = Graphics.FromImage(target))
                        g.DrawImage(fullImage, new Rectangle(0, 0, target.Width, target.Height),\n                                        cropRect,\n                                        GraphicsUnit.Pixel);
                    var source = new BitmapLuminanceSource(target);\n                    var bitmap = new BinaryBitmap(new HybridBinarizer(source));\n                    QRCodeReader reader = new QRCodeReader();\n                    var result = reader.decode(bitmap);\n                    if (result != null)
                        var success = controller.AddServerBySSURL(result.Text);\n                        QRCodeSplashForm splash = new QRCodeSplashForm();\n                        if (success)
                            splash.FormClosed += splash_FormClosed;
                        else if (result.Text.StartsWith("http://") || result.Text.StartsWith("https://"))
                    return buf;
                    return buf;
                    return buf;
                    return buf;
        Local local;\n        PACServer pacServer;\n        Config config;\n        PolipoRunner polipoRunner;\n        public ConfigForm()
            config = Config.Load();
            enableItem.Checked = config.enabled;\n            configToTextBox();
        private void configToTextBox()
            comboBox1.Text = config.method == null ? "table" : config.method;
            if (!config.isDefault)
                reload(config); BeginInvoke(new MethodInvoker(delegate
            pacServer = new PACServer();\n            pacServer.Start();\n            updateSystemProxy();\n        }\n        private void reload(Config config)\n        {\n            if (local != null)\n            {\n                local.Stop();\n                if (polipoRunner != null)\n                {\n                    polipoRunner.Stop();\n                }\n            }\n            if (polipoRunner == null)\n            {\n                polipoRunner = new PolipoRunner();\n            }\n            polipoRunner.Start(config);\n            local = new Local(config);\n            local.Start();
            configToTextBox();
            if (local != null) local.Stop();\n            if (polipoRunner != null) polipoRunner.Stop();\n            if (config.enabled)\n            {\n                SystemProxy.Disable();\n            }
        private void updateSystemProxy()\n        {\n            if (config.enabled)\n            {\n                SystemProxy.Enable();\n            }\n            else\n            {\n                SystemProxy.Disable();\n            }\n        }
            config.enabled = enableItem.Checked;\n            Config.Save(config);\n            updateSystemProxy();
        public void EnableProxy(int type, string proxy, int port)
            var type = ProxyTypeComboBox.SelectedIndex;\n            var proxy = ProxyServerTextBox.Text;\n            var port = 0;\n            var timeout = 3;
                try\n                {\n                    port = int.Parse(ProxyPortTextBox.Text);\n                }\n                catch (FormatException)
                    ProxyPortTextBox.Clear();
                try\n                {\n                    timeout = int.Parse(ProxyTimeoutTextBox.Text);\n                }\n                catch (FormatException)
                    ProxyTimeoutTextBox.Clear();
                controller.EnableProxy(type, proxy, port);
            _modifiedConfiguration.useProxy = UseProxyCheckBox.Checked;\n            _modifiedConfiguration.proxyType = type;\n            _modifiedConfiguration.proxyServer = proxy;\n            _modifiedConfiguration.proxyPort = port;\n            _modifiedConfiguration.proxyTimeout = timeout;\n            controller.SaveProxyConfig(_modifiedConfiguration);
                    var method = m.Groups["method"].Value;\n                    var path = m.Groups["path"].Value;
                        if (!ParseHost(path))
                    else\n                    {\n                        var targetUrl = new Uri(path);\n                        if (!ParseHost(targetUrl.Authority))\n                        {\n                            throw new Exception("Bad http header: " + line);\n                        }\n                        var newRequestLine = $"{method} {targetUrl.PathAndQuery} {m.Groups["tail"].Value}";\n                        _headers.Enqueue(newRequestLine);\n                    }\n                }\n                else\n                {\n                    throw new FormatException("Not a vaild request line");\n                }\n            }\n            else\n            {\n                // Handle Proxy-x Headers\n                if (!line.StartsWith("Proxy-"))\n                {\n                    _headers.Enqueue(line);\n                }\n                else\n                {\n                    if (line.StartsWith("Proxy-Connection: "))\n                    {\n                        _headers.Enqueue(line.Substring(6));\n                    }\n                }
        public void UpdateLatency(Server server, TimeSpan latency)\n        {
                availabilityStatistics.UpdateLatency(server, (int)latency.TotalMilliseconds);\n            }\n        }\n        public void UpdateInboundCounter(Server server, long n)\n        {\n            Interlocked.Add(ref _inboundCounter, n);
                availabilityStatistics.UpdateInboundCounter(server, n);\n            }\n        }\n        public void UpdateOutboundCounter(Server server, long n)\n        {\n            Interlocked.Add(ref _outboundCounter, n);
                availabilityStatistics.UpdateOutboundCounter(server, n);
        public void UpdateInboundCounter(Server server, long n)\n        {\n            _controller.UpdateInboundCounter(server, n);\n        }\n        public void UpdateOutboundCounter(Server server, long n)\n        {\n            _controller.UpdateOutboundCounter(server, n);\n        }\n        public void UpdateLatency(Server server, TimeSpan latency)\n        {\n            IStrategy strategy = _controller.GetCurrentStrategy();\n            strategy?.UpdateLatency(server, latency);\n            _controller.UpdateLatency(server, latency);\n        }
    class SSRelayEventArgs : EventArgs
    class SSInboundEventArgs : SSRelayEventArgs
        public SSInboundEventArgs(Server server, long length) : base(server)
    class SSOutboundEventArgs : SSRelayEventArgs\n    {\n        public readonly long length;\n        public SSOutboundEventArgs(Server server, long length) : base(server)\n        {\n            this.length = length;\n        }\n    }\n    class SSTCPConnectedEventArgs : SSRelayEventArgs
        }\n    }\n    class SSTCPClosedEventArgs : SSRelayEventArgs\n    {\n        public readonly TCPHandler handler;\n        public SSTCPClosedEventArgs(Server server, TCPHandler handler) : base(server)\n        {\n            this.handler = handler;
        public event EventHandler<SSInboundEventArgs> OnInbound;\n        public event EventHandler<SSOutboundEventArgs> OnOutbound;\n        public event EventHandler<SSTCPClosedEventArgs> OnClosed;
            OnOutbound?.Invoke(this, new SSOutboundEventArgs(_server, bytesToSend));
            IStrategy strategy = _controller.GetCurrentStrategy();\n            strategy?.UpdateLastWrite(_server);
        public IVEncryptor(string method, string password)\n            : base(method, password)
            LoadLibrary(dllPath);
        protected EncryptorBase(string method, string password)
            this.tableLayoutPanel1.RowCount = 6;\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.Size = new System.Drawing.Size(238, 137);
            this.ServerGroupBox.Size = new System.Drawing.Size(249, 174);\n            this.ServerGroupBox.TabIndex = 6;
            this.ServersListBox.ItemHeight = 12;
        public static IEncryptor GetEncryptor(string method, string password)
            IEncryptor result = (IEncryptor)c.Invoke(new object[] { method, password });
            this.PluginOptionsLabel.Location = new System.Drawing.Point(18, 166);
            this.PluginTextBox.Location = new System.Drawing.Point(113, 135);
            this.RemarksTextBox.Location = new System.Drawing.Point(113, 238);
            this.IPLabel.Location = new System.Drawing.Point(48, 10);
            this.ServerPortLabel.Location = new System.Drawing.Point(36, 37);
            this.PasswordLabel.Location = new System.Drawing.Point(54, 64);
            this.IPTextBox.Location = new System.Drawing.Point(113, 6);
            this.ServerPortTextBox.Location = new System.Drawing.Point(113, 33);
            this.PasswordTextBox.Location = new System.Drawing.Point(113, 60);
            this.EncryptionLabel.Location = new System.Drawing.Point(42, 113);
            this.EncryptionSelect.ItemHeight = 12;\n            this.EncryptionSelect.Items.AddRange(new object[] {\n            "rc4-md5",\n            "salsa20",\n            "chacha20",\n            "chacha20-ietf",\n            "aes-256-cfb",\n            "aes-192-cfb",\n            "aes-128-cfb",\n            "aes-256-ctr",\n            "aes-192-ctr",\n            "aes-128-ctr",\n            "bf-cfb",\n            "camellia-128-cfb",\n            "camellia-192-cfb",\n            "camellia-256-cfb",\n            "aes-128-gcm",\n            "aes-192-gcm",\n            "aes-256-gcm",\n            "chacha20-ietf-poly1305",\n            "xchacha20-ietf-poly1305"});\n            this.EncryptionSelect.Location = new System.Drawing.Point(113, 109);
            this.TimeoutLabel.Location = new System.Drawing.Point(30, 269);
            this.TimeoutTextBox.Location = new System.Drawing.Point(113, 265);
            this.PluginLabel.Location = new System.Drawing.Point(18, 139);
            this.PluginOptionsTextBox.Location = new System.Drawing.Point(113, 162);
            this.ShowPasswdCheckBox.Location = new System.Drawing.Point(113, 87);
            this.PluginArgumentsTextBox.Location = new System.Drawing.Point(113, 211);
            this.PluginArgumentsLabel.Location = new System.Drawing.Point(6, 215);
            this.RemarksLabel.Location = new System.Drawing.Point(60, 242);
            this.NeedPluginArgCheckBox.Location = new System.Drawing.Point(113, 189);
            this.panel2.Location = new System.Drawing.Point(165, 187);
            this.tableLayoutPanel5.Padding = new System.Windows.Forms.Padding(3);
            this.ProxyPortTextBox.Location = new System.Drawing.Point(77, 6);
            this.ProxyPortLabel.Location = new System.Drawing.Point(6, 10);
            this.PortableModeCheckBox.Location = new System.Drawing.Point(6, 37);
using Shadowsocks.Encryption;
using Shadowsocks.Encryption.Stream;\nusing Shadowsocks.Model;\nusing Shadowsocks.Controller.Service;
using System.Net;\nnamespace test
        public void SendResponse(byte[] firstPacket, int length, Socket socket, bool useSocks)
                string pac = GetPACContent();
                string proxy = GetPACAddress(firstPacket, length, localEndPoint, useSocks);\n                pac = pac.Replace("__PROXY__", proxy);\n                string text = String.Format(@"HTTP/1.1 200 OK
", Encoding.UTF8.GetBytes(pac).Length) + pac;\n                byte[] response = Encoding.UTF8.GetBytes(text);
                    FileManager.UncompressFile(dllPath, Resources.libeay32_dll);
    public struct INTERNET_PER_CONN_OPTION_OptionUnion
    public struct INTERNET_PER_CONN_OPTION_LIST
                if (!File.Exists(LogFilePath))\n                    using (File.Create(LogFilePath)) { }\n                LogFileCreationTime = File.GetCreationTime(LogFilePath);\n                if ((DateTime.Now - LogFileCreationTime).Days >= 1)\n                    RollLogFile();\n                else\n                {\n                    FileStream fs = new FileStream(LogFilePath, FileMode.Append);\n                    StreamWriterWithTimestamp sw = new StreamWriterWithTimestamp(fs);\n                    sw.AutoFlush = true;\n                    Console.SetOut(sw);\n                    Console.SetError(sw);\n                }
        private static void RollLogFile()\n        {\n            Console.Out.Close();\n            Console.Error.Close();\n            MemoryStream ms = new MemoryStream();\n            StreamWriterWithTimestamp sw = new StreamWriterWithTimestamp(ms);\n            sw.AutoFlush = true;\n            Console.SetOut(sw);\n            Console.SetError(sw);\n            byte[] logContents = File.ReadAllBytes(LogFilePath);\n            string datestr = DateTime.Now.AddDays(-1).ToString("yyyyMMdd");\n            string filepath = Utils.GetTempPath($"shadowsocks.{datestr}.log.zip");\n            FileManager.CompressFile(filepath, logContents);\n            File.Delete(LogFilePath);\n            FileStream fs = new FileStream(LogFilePath, FileMode.CreateNew);\n            LogFileCreationTime = DateTime.Now;\n            ms.CopyTo(fs);\n            StreamWriterWithTimestamp sw2 = new StreamWriterWithTimestamp(fs);\n            sw2.AutoFlush = true;\n            Console.SetOut(sw2);\n            Console.SetError(sw2);\n        }
            if ((DateTime.Now - LogFileCreationTime).Days >= 1)\n                RollLogFile();
        private UpdateChecker updateChecker;
        private bool _isFirstRun;
        protected Dictionary<string, Dictionary<string, int[]>> ciphers;\n        protected Dictionary<string, int[]> ciphersDetail;
        protected int[] _cipherInfo;
        protected abstract Dictionary<string, Dictionary<string, int[]>> getCiphers();
            ciphersDetail = ciphers[_method];\n            _cipherMbedName = ciphersDetail.Keys.FirstOrDefault();\n            _cipherInfo = ciphers[_method][_cipherMbedName];\n            _cipher = _cipherInfo[2];
            keyLen = _cipherInfo[0];\n            ivLen = _cipherInfo[1];
        private static Dictionary<string, Dictionary<string, int[]>> _ciphers = new Dictionary<string, Dictionary<string, int[]>> {\n            { "aes-128-cfb", new Dictionary<string, int[]> { { "AES-128-CFB128", new int[] { 16, 16, CIPHER_AES } } } },\n            { "aes-192-cfb", new Dictionary<string, int[]> { { "AES-192-CFB128", new int[] { 24, 16, CIPHER_AES } } } },\n            { "aes-256-cfb", new Dictionary<string, int[]> { { "AES-256-CFB128", new int[] { 32, 16, CIPHER_AES } } } },\n            { "aes-128-ctr", new Dictionary<string, int[]> { { "AES-128-CTR", new int[] { 16, 16, CIPHER_AES } } } },\n            { "aes-192-ctr", new Dictionary<string, int[]> { { "AES-192-CTR", new int[] { 24, 16, CIPHER_AES } } } },\n            { "aes-256-ctr", new Dictionary<string, int[]> { { "AES-256-CTR", new int[] { 32, 16, CIPHER_AES } } } },\n            { "bf-cfb", new Dictionary<string, int[]> { { "BLOWFISH-CFB64", new int[] { 16, 8, CIPHER_BLOWFISH } } } },\n            { "camellia-128-cfb", new Dictionary<string, int[]> { { "CAMELLIA-128-CFB128", new int[] { 16, 16, CIPHER_CAMELLIA } } } },\n            { "camellia-192-cfb", new Dictionary<string, int[]> { { "CAMELLIA-192-CFB128", new int[] { 24, 16, CIPHER_CAMELLIA } } } },\n            { "camellia-256-cfb", new Dictionary<string, int[]> { { "CAMELLIA-256-CFB128", new int[] { 32, 16, CIPHER_CAMELLIA } } } },\n            { "rc4-md5", new Dictionary<string, int[]> { { "ARC4-128", new int[] { 16, 16, CIPHER_RC4 } } } }
        protected override Dictionary<string, Dictionary<string, int[]>> getCiphers()
        private static Dictionary<string, Dictionary<string, int[]>> _ciphers = new Dictionary<string, Dictionary<string, int[]>> {\n            { "salsa20", new Dictionary<string, int[]> { { "salsa20", new int[] { 32, 8, CIPHER_SALSA20 } } } },\n            { "chacha20", new Dictionary<string, int[]> { { "chacha20", new int[] { 32, 8, CIPHER_CHACHA20 } } } },\n            { "chacha20-ietf", new Dictionary<string, int[]> { { "chacha20-ietf", new int[] { 32, 12, CIPHER_CHACHA20_IETF } } } }
        protected override Dictionary<string, Dictionary<string, int[]>> getCiphers()
            this.Text = "Form1";
        public const int CRC_BUF_LEN = 128;\n        public const int CRC_BYTES = 2;
        protected byte[] crc_buf;\n        protected int crc_idx = 0;
                crc_buf = new byte[CRC_BUF_LEN];
                        lock(crc_buf)
                            int headLen = GetSSHeadLength(buf, length);
                            Sodium.ss_onetimeauth(auth, buf, headLen, _encryptIV, ivLen, _key, keyLen);
                            int rc = Sodium.ss_gen_crc(buf, ref buf_offset, ref data_len, crc_buf, ref crc_idx, buf.Length);\n                            if (rc != 0)\n                                throw new Exception("failed to generate crc");
                    lock(crc_buf)
                        int rc = Sodium.ss_gen_crc(buf, ref buf_offset, ref length, crc_buf, ref crc_idx, buf.Length);\n                        if (rc != 0)\n                            throw new Exception("failed to generate crc");
        public extern static int ss_gen_crc(byte[] buf, ref int buf_offset, ref int data_len,\n            byte[] crc_buf, ref int crc_idx, int buf_size);
        public extern static int ss_onetimeauth(byte[] auth, \n            byte[] msg, int msg_len, \n            byte[] iv, int iv_len,\n            byte[] key, int key_len);
private bool setAutoStartup(bool enabled) {\ntry {\nstring path = Application.ExecutablePath;\nRegistryKey runKey = Registry.CurrentUser.OpenSubKey(@"Software\Microsoft\Windows\CurrentVersion\Run", true);\nif (enabled) {\nrunKey.SetValue("Shadowsocks-CSharp", path);\n} else {\nrunKey.DeleteValue("Shadowsocks-CSharp");\n}\nrunKey.Close();\nreturn true;\n} catch (Exception e) {\nreturn false;\n}\n}\nprivate bool checkAutoStartup() {\ntry {\nstring path = Application.ExecutablePath;\nRegistryKey runKey = Registry.CurrentUser.OpenSubKey(@"Software\Microsoft\Windows\CurrentVersion\Run");\nstring[] runList = runKey.GetValueNames();\nrunKey.Close();\nforeach(string item in runList){\nif (item.Equals("Shadowsocks-CSharp"))\nreturn true;\n}\nreturn false;\n} catch (Exception e) {\nreturn false;\n}\n}
if (!setAutoStartup(autoStartup.Checked)) {\n//MessageBox.Show("Failed to edit registry");
autoStartup.Checked = checkAutoStartup();
            Bitmap drawArea = new Bitmap((m.Height * blockSize), (m.Height * blockSize));
         return encode(content, ecLevel, null);\n      }\n      /// <summary>\n      /// Encodes the specified content.\n      /// </summary>\n      /// <param name="content">The content.</param>\n      /// <param name="ecLevel">The ec level.</param>\n      /// <param name="hints">The hints.</param>\n      /// <returns></returns>\n      public static QRCode encode(String content,\n                                ErrorCorrectionLevel ecLevel,\n                                IDictionary<EncodeHintType, object> hints)\n      {
         String encoding = hints == null || !hints.ContainsKey(EncodeHintType.CHARACTER_SET) ? null : (String)hints[EncodeHintType.CHARACTER_SET];\n         if (encoding == null)\n         {\n            encoding = DEFAULT_BYTE_MODE_ENCODING;\n         }\n         bool generateECI = !DEFAULT_BYTE_MODE_ENCODING.Equals(encoding);
         Mode mode = chooseMode(content, encoding);
         if (mode.Equals(Mode.NUMERIC))\n            appendNumericBytes(content, bits);\n         else\n            if (mode.Equals(Mode.ALPHANUMERIC))\n               appendAlphanumericBytes(content, bits);\n            else
               else\n                  if (mode.Equals(Mode.KANJI))\n                     appendKanjiBytes(content, bits);
      }\n      internal static void appendNumericBytes(String content, BitArray bits)\n      {\n         int length = content.Length;\n         int i = 0;\n         while (i < length)\n         {\n            int num1 = content[i] - '0';\n            if (i + 2 < length)\n            {\n               // Encode three numeric letters in ten bits.\n               int num2 = content[i + 1] - '0';\n               int num3 = content[i + 2] - '0';\n               bits.appendBits(num1 * 100 + num2 * 10 + num3, 10);\n               i += 3;\n            }\n            else if (i + 1 < length)\n            {\n               // Encode two numeric letters in seven bits.\n               int num2 = content[i + 1] - '0';\n               bits.appendBits(num1 * 10 + num2, 7);\n               i += 2;\n            }\n            else\n            {\n               // Encode one numeric letter in four bits.\n               bits.appendBits(num1, 4);\n               i++;\n            }\n         }\n      }\n      internal static void appendAlphanumericBytes(String content, BitArray bits)\n      {\n         int length = content.Length;\n         int i = 0;\n         while (i < length)\n         {\n            int code1 = getAlphanumericCode(content[i]);\n            if (code1 == -1)\n            {\n                throw new Exception();\n            }\n            if (i + 1 < length)\n            {\n               int code2 = getAlphanumericCode(content[i + 1]);\n               if (code2 == -1)\n               {\n                   throw new Exception();\n               }\n               // Encode two alphanumeric letters in 11 bits.\n               bits.appendBits(code1 * 45 + code2, 11);\n               i += 2;\n            }\n            else\n            {\n               // Encode one alphanumeric letter in six bits.\n               bits.appendBits(code1, 6);\n               i++;\n            }\n         }
      /// <summary> <p>Deduces version information purely from QR Code dimensions.</p>\n      /// \n      /// </summary>\n      /// <param name="dimension">dimension in modules\n      /// </param>\n      /// <returns><see cref="Version" /> for a QR Code of that dimension or null</returns>\n      public static Version getProvisionalVersionForDimension(int dimension)\n      {\n         if (dimension % 4 != 1)\n         {\n            return null;\n         }\n         try\n         {\n            return getVersionForNumber((dimension - 17) >> 2);\n         }\n         catch (ArgumentException)\n         {\n            return null;\n         }\n      }
      }\n      internal static Version decodeVersionInformation(int versionBits)\n      {\n         int bestDifference = Int32.MaxValue;\n         int bestVersion = 0;\n         for (int i = 0; i < VERSION_DECODE_INFO.Length; i++)\n         {\n            int targetVersion = VERSION_DECODE_INFO[i];\n            // Do the version info bits match exactly? done.\n            if (targetVersion == versionBits)\n            {\n               return getVersionForNumber(i + 7);\n            }\n            // Otherwise see if this is the closest to a real version info bit string\n            // we have seen so far\n            int bitsDifference = FormatInformation.numBitsDiffering(versionBits, targetVersion);\n            if (bitsDifference < bestDifference)\n            {\n               bestVersion = i + 7;\n               bestDifference = bitsDifference;\n            }\n         }\n         // We can tolerate up to 3 bits of error since no two version info codewords will\n         // differ in less than 8 bits.\n         if (bestDifference <= 3)\n         {\n            return getVersionForNumber(bestVersion);\n         }\n         // If we didn't find a close enough match, fail\n         return null;\n      }\n      /// <summary> See ISO 18004:2006 Annex E</summary>\n      internal BitMatrix buildFunctionPattern()\n      {\n         int dimension = DimensionForVersion;\n         BitMatrix bitMatrix = new BitMatrix(dimension);\n         // Top left finder pattern + separator + format\n         bitMatrix.setRegion(0, 0, 9, 9);\n         // Top right finder pattern + separator + format\n         bitMatrix.setRegion(dimension - 8, 0, 8, 9);\n         // Bottom left finder pattern + separator + format\n         bitMatrix.setRegion(0, dimension - 8, 9, 8);\n         // Alignment patterns\n         int max = alignmentPatternCenters.Length;\n         for (int x = 0; x < max; x++)\n         {\n            int i = alignmentPatternCenters[x] - 2;\n            for (int y = 0; y < max; y++)\n            {\n               if ((x == 0 && (y == 0 || y == max - 1)) || (x == max - 1 && y == 0))\n               {\n                  // No alignment patterns near the three finder paterns\n                  continue;\n               }\n               bitMatrix.setRegion(alignmentPatternCenters[y] - 2, i, 5, 5);\n            }\n         }\n         // Vertical timing pattern\n         bitMatrix.setRegion(6, 9, 1, dimension - 17);\n         // Horizontal timing pattern\n         bitMatrix.setRegion(9, 6, dimension - 17, 1);\n         if (versionNumber > 6)\n         {\n            // Version info, top right\n            bitMatrix.setRegion(dimension - 11, 0, 3, 6);\n            // Version info, bottom left\n            bitMatrix.setRegion(0, dimension - 11, 6, 3);\n         }\n         return bitMatrix;
      /// Gets the size.\n      /// </summary>\n      public int Size\n      {\n         get { return size; }\n      }\n      /// <summary>
      /// <summary>\n      /// Returns a <see cref="System.String"/> that represents this instance.\n      /// </summary>\n      /// <returns>\n      /// A <see cref="System.String"/> that represents this instance.\n      /// </returns>\n      override public String ToString()\n      {\n         return "GF(0x" + primitive.ToString("X") + ',' + size + ')';\n      }
         set\n         {\n            if (value)\n               bits[i >> 5] |= 1 << (i & 0x1F);\n         }
      }\n      public BitArray(int size)\n      {\n         if (size < 1)\n         {\n            throw new ArgumentException("size must be at least 1");\n         }\n         this.size = size;\n         this.bits = makeArray(size);\n      }\n      // For testing only\n      private BitArray(int[] bits, int size)\n      {\n         this.bits = bits;\n         this.size = size;
      /// <summary> Reverses all bits in the array.</summary>\n      public void reverse()\n      {\n         var newBits = new int[bits.Length];\n         // reverse all int's first\n         var len = ((size - 1) >> 5);\n         var oldBitsLen = len + 1;\n         for (var i = 0; i < oldBitsLen; i++)\n         {\n            var x = (long)bits[i];\n            x = ((x >>  1) & 0x55555555u) | ((x & 0x55555555u) <<  1);\n            x = ((x >>  2) & 0x33333333u) | ((x & 0x33333333u) <<  2);\n            x = ((x >>  4) & 0x0f0f0f0fu) | ((x & 0x0f0f0f0fu) <<  4);\n            x = ((x >>  8) & 0x00ff00ffu) | ((x & 0x00ff00ffu) <<  8);\n            x = ((x >> 16) & 0x0000ffffu) | ((x & 0x0000ffffu) << 16);\n            newBits[len - i] = (int)x;\n         }\n         // now correct the int's if the bit size isn't a multiple of 32\n         if (size != oldBitsLen * 32)\n         {\n            var leftOffset = oldBitsLen * 32 - size;\n            var mask = 1;\n            for (var i = 0; i < 31 - leftOffset; i++)\n               mask = (mask << 1) | 1;\n            var currentInt = (newBits[0] >> leftOffset) & mask;\n            for (var i = 1; i < oldBitsLen; i++)\n            {\n               var nextInt = newBits[i];\n               currentInt |= nextInt << (32 - leftOffset);\n               newBits[i - 1] = currentInt;\n               currentInt = (nextInt >> leftOffset) & mask;\n            }\n            newBits[oldBitsLen - 1] = currentInt;\n         }\n         bits = newBits;\n      }
      /// <summary>\n      /// Determines whether the specified <see cref="System.Object"/> is equal to this instance.\n      /// </summary>\n      /// <param name="o">The <see cref="System.Object"/> to compare with this instance.</param>\n      /// <returns>\n      ///   <c>true</c> if the specified <see cref="System.Object"/> is equal to this instance; otherwise, <c>false</c>.\n      /// </returns>\n      public override bool Equals(Object o)\n      {\n         var other = o as BitArray;\n         if (other == null)\n            return false;\n         if (size != other.size)\n            return false;\n         for (var index = 0; index < size; index++)\n         {\n            if (bits[index] != other.bits[index])\n               return false;\n         }\n         return true;\n      }\n      /// <summary>\n      /// Returns a hash code for this instance.\n      /// </summary>\n      /// <returns>\n      /// A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. \n      /// </returns>\n      public override int GetHashCode()\n      {\n         var hash = size;\n         foreach (var bit in bits)\n         {\n            hash = 31 * hash + bit.GetHashCode();\n         }\n         return hash;\n      }\n      /// <summary>\n      /// Returns a <see cref="System.String"/> that represents this instance.\n      /// </summary>\n      /// <returns>\n      /// A <see cref="System.String"/> that represents this instance.\n      /// </returns>\n      public override String ToString()\n      {\n         var result = new System.Text.StringBuilder(size);\n         for (int i = 0; i < size; i++)\n         {\n            if ((i & 0x07) == 0)\n            {\n               result.Append(' ');\n            }\n            result.Append(this[i] ? 'X' : '.');\n         }\n         return result.ToString();\n      }\n      /// <summary>\n      /// Erstellt ein neues Objekt, das eine Kopie der aktuellen Instanz darstellt.\n      /// </summary>\n      /// <returns>\n      /// Ein neues Objekt, das eine Kopie dieser Instanz darstellt.\n      /// </returns>\n      public object Clone()\n      {\n         return new BitArray((int[])bits.Clone(), size);\n      }
        private void ShowLogForms()\n        {\n            if (logForms.Count == 0)\n            {\n                LogForm f = new LogForm(controller, Logging.LogFilePath);\n                f.Show();\n                f.Activate();\n                f.FormClosed += logForm_FormClosed;\n                logForms.Add(f);\n                logFormsVisible = true;
                logFormsVisible = !logFormsVisible;\n                foreach (LogForm f in logForms)\n                {\n                    f.Visible = logFormsVisible;\n                }
            logForms.Remove((LogForm)sender);
                byte[] iv = new byte[16];
        protected void bytesToKey(byte[] password, byte[] key)
            if (!File.Exists(NLOG_CONFIG_FILE_NAME))
                LogManager.LoadConfiguration(NLOG_CONFIG_FILE_NAME);
            return new Sip003Plugin(server.plugin, server.plugin_opts, server.server, server.server_port);
        private Sip003Plugin(string plugin, string pluginOpts, string serverAddress, int serverPort)
            this.tableLayoutPanel1.RowCount = 10;\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.Size = new System.Drawing.Size(267, 243);
        private System.Windows.Forms.Label ProxyPortLabel;
        private System.Windows.Forms.TextBox ProxyPortTextBox;
            this.ServersListView = new System.Windows.Forms.ListView();
            this.Controls.Add(this.ServersListView);
        private System.Windows.Forms.ListView ServersListView;
[assembly: AssemblyCompany("clowwindy")]
[assembly: AssemblyFileVersion("2.0.0")]
    countryCode_ = other.countryCode_;\n    domain_ = other.domain_.Clone();
  /// <summary>Field number for the "country_code" field.</summary>\n  public const int CountryCodeFieldNumber = 1;\n  private string countryCode_ = "";\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n  public string CountryCode {\n    get { return countryCode_; }
      countryCode_ = pb::ProtoPreconditions.CheckNotNull(value, "value");\n    }\n  }\n  /// <summary>Field number for the "domain" field.</summary>\n  public const int DomainFieldNumber = 2;\n  private static readonly pb::FieldCodec<global::DomainObject> _repeated_domain_codec
  private readonly pbc::RepeatedField<global::DomainObject> domain_ = new pbc::RepeatedField<global::DomainObject>();\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n  public pbc::RepeatedField<global::DomainObject> Domain {\n    get { return domain_; }
    if (CountryCode != other.CountryCode) return false;\n    if(!domain_.Equals(other.domain_)) return false;
    if (CountryCode.Length != 0) hash ^= CountryCode.GetHashCode();\n    hash ^= domain_.GetHashCode();
    if (CountryCode.Length != 0) {
      output.WriteString(CountryCode);\n    }\n    domain_.WriteTo(output, _repeated_domain_codec);
    if (CountryCode.Length != 0) {\n      size += 1 + pb::CodedOutputStream.ComputeStringSize(CountryCode);\n    }\n    size += domain_.CalculateSize(_repeated_domain_codec);
          CountryCode = input.ReadString();
          domain_.AddEntriesFrom(input, _repeated_domain_codec);
  /// <summary>Field number for the "entry" field.</summary>\n  public const int EntryFieldNumber = 1;\n  private static readonly pb::FieldCodec<global::Geosite> _repeated_entry_codec
  private readonly pbc::RepeatedField<global::Geosite> entry_ = new pbc::RepeatedField<global::Geosite>();\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n  public pbc::RepeatedField<global::Geosite> Entry {\n    get { return entry_; }
    if(!entry_.Equals(other.entry_)) return false;
        private static readonly string DatabasePath = Utils.GetTempPath("dlc.dat");\n        public static readonly GeositeList List;\n        public static readonly Dictionary<string, List<DomainObject>> Geosites = new Dictionary<string, List<DomainObject>>();
            List = GeositeList.Parser.ParseFrom(File.ReadAllBytes(DatabasePath));\n            foreach (var item in List.Entry)
                Geosites[item.CountryCode] = item.Domain.ToList();
                    else if (line.IndexOf("*") >= 0)
                        line = line.Substring(2);
                        line = line.Substring(1);
                        line = line.Substring(1);
                    domains.Add(line);\n                }\n                return domains.ToArray();
                    if (se.SocketErrorCode == SocketError.AccessDenied)
        }
            this.Font = SystemFonts.MessageBoxFont;
            this.ServersListBox.Dock = DockStyle.Fill;\n            this.tableLayoutPanel5.Dock = DockStyle.Fill;\n            this.PerformLayout();
            this.Icon = Icon.FromHandle(Resources.ssw128.GetHicon());
            toolTip1.SetToolTip(this.PortableModeCheckBox, I18N.GetString("Restart required"));
            this.Text = I18N.GetString("Edit Servers");
        private bool ValidateAndSaveSelectedServerDetails()
                Server server = GetServerDetailsFromUI();\n                if (server == null)\n                {\n                    return false;\n                }\n                Configuration.CheckServer(server);\n                _modifiedConfiguration.configs[_lastSelectedIndex] = server;
            if (!ValidateAndSaveSelectedServerDetails())\n            {\n                return;\n            }\n            Configuration.AddDefaultServerOrServer(_modifiedConfiguration);
            ServersListBox.SelectedIndex = _modifiedConfiguration.configs.Count - 1;\n            _lastSelectedIndex = ServersListBox.SelectedIndex;\n        }\n        private void DuplicateButton_Click(object sender, EventArgs e)\n        {\n            if (_lastSelectedIndex == -1 || _lastSelectedIndex > _modifiedConfiguration.configs.Count\n                || !ValidateAndSaveSelectedServerDetails())\n            {\n                return;\n            }\n            Server currServer = _modifiedConfiguration.configs[_lastSelectedIndex];\n            var currIndex = _modifiedConfiguration.configs.IndexOf(currServer);\n            _modifiedConfiguration.configs.Insert(currIndex + 1, currServer);\n            LoadServerNameListToUI(_modifiedConfiguration);\n            ServersListBox.SelectedIndex = currIndex + 1;\n            _lastSelectedIndex = ServersListBox.SelectedIndex;\n        }\n        private void DeleteButton_Click(object sender, EventArgs e)\n        {\n            _lastSelectedIndex = ServersListBox.SelectedIndex;\n            if (_lastSelectedIndex >= 0 && _lastSelectedIndex < _modifiedConfiguration.configs.Count)\n            {\n                _modifiedConfiguration.configs.RemoveAt(_lastSelectedIndex);\n            }\n            if (_modifiedConfiguration.configs.Count == 0)\n            {\n                Configuration.AddDefaultServerOrServer(_modifiedConfiguration);\n            }\n            if (_lastSelectedIndex >= _modifiedConfiguration.configs.Count)\n            {\n                // can be -1\n                _lastSelectedIndex = _modifiedConfiguration.configs.Count - 1;\n            }\n            ServersListBox.SelectedIndex = _lastSelectedIndex;\n            LoadServerNameListToUI(_modifiedConfiguration);\n            ServersListBox.SelectedIndex = _lastSelectedIndex;
        private void OKButton_Click(object sender, EventArgs e)\n        {\n            if (SaveValidConfiguration())\n            {\n                this.Close();\n            }\n        }\n        private void CancelButton_Click(object sender, EventArgs e)\n        {\n            this.Close();\n        }\n        private void ApplyButton_Click(object sender, EventArgs e)\n        {\n            SaveValidConfiguration();\n        }\n        private void ConfigForm_Shown(object sender, EventArgs e)\n        {\n            IPTextBox.Focus();\n        }\n        private void ConfigForm_FormClosed(object sender, FormClosedEventArgs e)\n        {\n            controller.ConfigChanged -= controller_ConfigChanged;
        private void UpdateButtons()\n        {\n            DeleteButton.Enabled = (ServersListBox.Items.Count > 0);\n            MoveUpButton.Enabled = (ServersListBox.SelectedIndex > 0);\n            MoveDownButton.Enabled = (ServersListBox.SelectedIndex < ServersListBox.Items.Count - 1);\n        }\n        private void MoveUpButton_Click(object sender, EventArgs e)\n        {\n            if (!ValidateAndSaveSelectedServerDetails())\n            {\n                return;\n            }\n            if (ServersListBox.SelectedIndex > 0)\n            {\n                MoveConfigItem(-1);  // -1 means move backward\n            }\n        }\n        private void MoveDownButton_Click(object sender, EventArgs e)\n        {\n            if (!ValidateAndSaveSelectedServerDetails())\n            {\n                return;\n            }\n            if (ServersListBox.SelectedIndex < ServersListBox.Items.Count - 1)\n            {\n                MoveConfigItem(+1);  // +1 means move forward\n            }
            this.PasswordTextBox.UseSystemPasswordChar = !this.ShowPasswdCheckBox.Checked;
            ShowHidePluginArgInput(this.NeedPluginArgCheckBox.Checked);
using Newtonsoft.Json;
        private static string CONFIG_FILE = "gui-config.json";
            CheckServer(server.server);
        public static Server AddDefaultServerOrServer(Configuration config, Server server = null)
                config.configs.Add(server);
        private static Hashtable fileChangedTime = new Hashtable();
            string path = e.FullPath.ToString();\n            string currentLastWriteTime = File.GetLastWriteTime(e.FullPath).ToString(CultureInfo.InvariantCulture);\n            // if there is no path info stored yet or stored path has different time of write then the one now is inspected\n            if (!fileChangedTime.ContainsKey(path) || fileChangedTime[path].ToString() != currentLastWriteTime)\n            {\n                if (PACFileChanged != null)\n                {\n                    Logging.Info($"Detected: PAC file '{e.Name}' was {e.ChangeType.ToString().ToLower()}.");
                }\n                // lastly we update the last write time in the hashtable\n                fileChangedTime[path] = currentLastWriteTime;
            string path = e.FullPath.ToString();\n            string currentLastWriteTime = File.GetLastWriteTime(e.FullPath).ToString(CultureInfo.InvariantCulture);\n            // if there is no path info stored yet or stored path has different time of write then the one now is inspected\n            if (!fileChangedTime.ContainsKey(path) || fileChangedTime[path].ToString() != currentLastWriteTime)\n            {\n                if (UserRuleFileChanged != null)\n                {\n                    Logging.Info($"Detected: User Rule file '{e.Name}' was {e.ChangeType.ToString().ToLower()}.");
                }\n                // lastly we update the last write time in the hashtable\n                fileChangedTime[path] = currentLastWriteTime;
﻿using System;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Threading;\nusing System.Windows.Forms;
using Microsoft.Win32;
using System.IO.Pipes;
using System.Net;
using System.Collections.Generic;
    static class Program
        private static Logger logger = LogManager.GetCurrentClassLogger();
        static void Main(string[] args)
            System.Net.ServicePointManager.SecurityProtocol |=\n                System.Net.SecurityProtocolType.Tls | System.Net.SecurityProtocolType.Tls11 | System.Net.SecurityProtocolType.Tls12;
                var alist = Args.ToList();
                    if (Args.Length <= urlidx) return;\n                    if (!pipeExist) return;\n                    byte[] b = Encoding.UTF8.GetBytes(Args[urlidx]);\n                    byte[] opAddUrl = BitConverter.GetBytes(IPAddress.HostToNetworkOrder(1));\n                    byte[] blen = BitConverter.GetBytes(IPAddress.HostToNetworkOrder(b.Length));\n                    pipe.Write(opAddUrl, 0, 4); // opcode addurl\n                    pipe.Write(blen, 0, 4);\n                    pipe.Write(b, 0, b.Length);\n                    pipe.Close();\n                    return;\n                }
    public class QRCodeSplashForm : PerPixelAlphaForm
        public class ErrorEventArgs : EventArgs\n        {\n            public string Error;\n        }
        public event EventHandler<ErrorEventArgs> LocalFailToStart;
            textBox1.Text = server.server;\n            textBox2.Text = server.server_port.ToString();\n            textBox3.Text = server.password;\n            textBox4.Text = server.local_port.ToString();\n            comboBox1.Text = server.method == null ? "aes-256-cfb" : server.method;
        private void Form1_Load(object sender, EventArgs e)
        private void Form1_FormClosed(object sender, FormClosedEventArgs e)
            this.comboBox1 = new System.Windows.Forms.ComboBox();
            this.textBox1 = new System.Windows.Forms.TextBox();\n            this.textBox2 = new System.Windows.Forms.TextBox();\n            this.textBox3 = new System.Windows.Forms.TextBox();\n            this.textBox4 = new System.Windows.Forms.TextBox();
            this.button1 = new System.Windows.Forms.Button();\n            this.button2 = new System.Windows.Forms.Button();
            this.editPACFileItem = new System.Windows.Forms.MenuItem();
            this.tableLayoutPanel1.Controls.Add(this.comboBox1, 1, 4);
            this.tableLayoutPanel1.Controls.Add(this.textBox1, 1, 0);\n            this.tableLayoutPanel1.Controls.Add(this.textBox2, 1, 1);\n            this.tableLayoutPanel1.Controls.Add(this.textBox3, 1, 2);\n            this.tableLayoutPanel1.Controls.Add(this.textBox4, 1, 3);\n            this.tableLayoutPanel1.Location = new System.Drawing.Point(19, 19);
            // comboBox1\n            // \n            this.comboBox1.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;\n            this.comboBox1.FormattingEnabled = true;\n            this.comboBox1.ImeMode = System.Windows.Forms.ImeMode.NoControl;\n            this.comboBox1.ItemHeight = 13;\n            this.comboBox1.Items.AddRange(new object[] {
            // button1\n            // \n            this.button1.DialogResult = System.Windows.Forms.DialogResult.OK;\n            this.button1.Location = new System.Drawing.Point(4, 4);\n            this.button1.Name = "button1";\n            this.button1.Size = new System.Drawing.Size(75, 23);\n            this.button1.TabIndex = 0;\n            this.button1.Text = "OK";\n            this.button1.UseVisualStyleBackColor = true;\n            this.button1.Click += new System.EventHandler(this.OKButton_Click);\n            // \n            // button2\n            // \n            this.button2.DialogResult = System.Windows.Forms.DialogResult.Cancel;\n            this.button2.Location = new System.Drawing.Point(86, 4);\n            this.button2.Name = "button2";\n            this.button2.Size = new System.Drawing.Size(75, 23);\n            this.button2.TabIndex = 1;\n            this.button2.Text = "Cancel";\n            this.button2.UseVisualStyleBackColor = true;\n            this.button2.Click += new System.EventHandler(this.cancelButton_Click);
            this.panel1.Anchor = System.Windows.Forms.AnchorStyles.Top;
            this.panel1.Controls.Add(this.button2);\n            this.panel1.Controls.Add(this.button1);\n            this.panel1.Location = new System.Drawing.Point(61, 173);
            this.aboutItem.Click += new System.EventHandler(this.aboutToolStripMenuItem_Click);
            this.CancelButton = this.button2;\n            this.ClientSize = new System.Drawing.Size(250, 221);
            this.Controls.Add(this.tableLayoutPanel1);\n            this.Controls.Add(this.panel1);
            this.FormClosed += new System.Windows.Forms.FormClosedEventHandler(this.Form1_FormClosed);\n            this.Load += new System.EventHandler(this.Form1_Load);
        private System.Windows.Forms.TextBox textBox1;\n        private System.Windows.Forms.TextBox textBox2;\n        private System.Windows.Forms.TextBox textBox3;\n        private System.Windows.Forms.TextBox textBox4;
        private System.Windows.Forms.ComboBox comboBox1;
        private System.Windows.Forms.Button button1;\n        private System.Windows.Forms.Button button2;
using System.Threading;
using System.IO.Compression;\nusing System.Security.Cryptography;\nusing System.Text.RegularExpressions;\nusing Shadowsocks.Model;\nusing Shadowsocks.Properties;
using System.Collections;
using System.Text.RegularExpressions;
            animationStep = 0;
                timer.Interval = 50;
                        if (readProxyServer != null && readProxyServer.Equals("127.0.0.1:" + config.localPort.ToString()))\n                            registry.SetValue("ProxyServer", "");
                    if (global)\n                    {\n                        registry.SetValue("ProxyServer", "");\n                    }
                this.server_port = int.Parse(afterAt.Substring(indexLastColon + 1));\n                this.server = afterAt.Substring(0, indexLastColon);
                this.method = parts[0];\n                this.password = parts[1];
            {
            }
            {
            }
                {
                }\n                if (config.index == -1)\n                {\n                    if (config.strategy == null)\n                    {\n                        config.index = 0;\n                    }\n                }
                {
                }
            {
            }
            {
            }\n            if (config.index == -1)\n            {\n                if (config.strategy == null)\n                {\n                    config.index = 0;\n                }\n            }
            {
            }
            {
            }
            {
            }
            {
            }
            {
            }
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
                if (global)\n                {\n                    arguments = $"global {proxyServer} <local>;localhost;127.*;10.*;172.16.*;172.17.*;172.18.*;172.19.*;172.20.*;172.21.*;172.22.*;172.23.*;172.24.*;172.25.*;172.26.*;172.27.*;172.28.*;172.29.*;172.30.*;172.31.*;172.32.*;192.168.*";\n                }\n                else\n                {\n                    arguments = $"pac {pacURL}";\n                }
                arguments = "off";
                var error = process.StandardError.ReadToEnd();
                    throw new ProxyException(error);
                        Sysproxy.SetIEProxy(true, false, "", pacUrl);
                    Sysproxy.SetIEProxy(false, false, "", "");
                            if (kv[1].IndexOf("Chrome") >= 0)
                            }
                SystemProxy.Enable(_config.global);
                    SystemProxy.Disable();
        public static void Enable(bool global)
                if (global)
                    registry.SetValue("ProxyEnable", 1);\n                    registry.SetValue("ProxyServer", "127.0.0.1:8123");\n                    registry.SetValue("AutoConfigURL", "");
                    registry.SetValue("AutoConfigURL", "http://127.0.0.1:8093/pac?t=" + GetTimestamp(DateTime.Now));
                CopyProxySettingFromLan();\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                // TODO this should be moved into views\n                MessageBox.Show(I18N.GetString("Failed to update registry"));\n            }\n        }\n        public static void Disable()\n        {\n            try\n            {\n                RegistryKey registry =\n                    Registry.CurrentUser.OpenSubKey("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings",\n                        true);\n                registry.SetValue("ProxyEnable", 0);\n                registry.SetValue("ProxyServer", "");\n                registry.SetValue("AutoConfigURL", "");\n                SystemProxy.NotifyIE();
                    textBox1.AppendText(line + "\r\n");
                    textBox1.ScrollToCaret();
        private void menuItem2_Click(object sender, EventArgs e)
        private void menuItem3_Click(object sender, EventArgs e)\n        {\n        }\n        private void menuItem4_Click(object sender, EventArgs e)
            textBox1.ScrollToCaret();
            this.textBox1 = new System.Windows.Forms.TextBox();
            this.menuItem1 = new System.Windows.Forms.MenuItem();\n            this.menuItem2 = new System.Windows.Forms.MenuItem();\n            this.menuItem4 = new System.Windows.Forms.MenuItem();
            this.menuItem1});
            this.menuItem1.Index = 0;\n            this.menuItem1.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {\n            this.menuItem2,\n            this.menuItem4});\n            this.menuItem1.Text = "&File";
            this.menuItem2.Index = 0;\n            this.menuItem2.Text = "&Open Location";\n            this.menuItem2.Click += new System.EventHandler(this.menuItem2_Click);
            this.ClientSize = new System.Drawing.Size(547, 382);\n            this.Controls.Add(this.textBox1);
            this.PerformLayout();
        private System.Windows.Forms.TextBox textBox1;
        private System.Windows.Forms.MenuItem menuItem1;\n        private System.Windows.Forms.MenuItem menuItem2;\n        private System.Windows.Forms.MenuItem menuItem4;
                throw new Exception("assertion failure");
                throw new ArgumentException("port out of range");
                throw new ArgumentException("password can not be blank");
                throw new ArgumentException("server IP can not be blank");
        public event EventHandler UpdateCompleted;
                    UpdateCompleted(this, new EventArgs());
                LogFile = Utils.GetTempPath("shadowsocks.log");\n                FileStream fs = new FileStream(LogFile, FileMode.Append);
            // start reading\n            socket.BeginReceive(_lineBuffer, 0, maxLineBytes, 0, ReceiveCallback, 0);
            int length = (int)ar.AsyncState;
                    OnFinish(length);
                length += bytesRead;\n                int i;\n                while ((i = IndexOf(_lineBuffer, _bufferIndex, length, _delimiterBytes, _delimiterSearchOffsetTable,\n                           _delimiterSearchCharTable)) != -1)\n                {\n                    var decodeLen = i - _bufferIndex;\n                    string line = _encoding.GetString(_lineBuffer, _bufferIndex, decodeLen);\n                    _bufferIndex = i + _delimiterBytes.Length;\n                    length -= decodeLen;\n                    length -= _delimiterBytes.Length;\n                    var stop = _onLineRead(line, _state);\n                    if (stop)\n                    {\n                        OnFinish(length);\n                        return;\n                    }\n                }\n                if (length == _lineBuffer.Length)\n                {\n                    OnException(new IndexOutOfRangeException("LineBuffer full! Try increace maxLineBytes!"));\n                    OnFinish(length);
                if (_bufferIndex > 0)\n                {\n                    Buffer.BlockCopy(_lineBuffer, _bufferIndex, _lineBuffer, 0, length);\n                    _bufferIndex = 0;\n                }\n                _socket.BeginReceive(_lineBuffer, length, _lineBuffer.Length - length, 0, ReceiveCallback, length);\n            }\n            catch (Exception ex)\n            {\n                OnException(ex);\n                OnFinish(length);\n            }
        private void OnFinish(int length)\n        {\n            _onFinish?.Invoke(_lineBuffer, _bufferIndex, length, _state);
        public static int IndexOf(byte[] haystack, int index, int length, byte[] needle, int[] offsetTable, int[] charTable)
using System.Collections.Generic;
using System.Text;
                MessageBox.Show(I18N.GetString("Failed to update registry"));
            var registry = Registry.CurrentUser\n                .OpenSubKey(@"Software\Microsoft\Windows\CurrentVersion\Internet Settings\Connections", true);\n            var defaultValue = registry.GetValue("DefaultConnectionSettings");\n            try\n            {
            }\n            catch (IOException e)\n            {\n                Logging.LogUsefulException(e);
            var registry = Registry.CurrentUser\n                .OpenSubKey(@"Software\Microsoft\Windows\CurrentVersion\Internet Settings\Connections", true);\n            var defConnection = (byte[])registry.GetValue("DefaultConnectionSettings");\n            var savedLegacySetting = (byte[])registry.GetValue("SavedLegacySettings");\n            const int versionOffset = 4;\n            const int optionsOffset = 8;\n            if (set)\n            {\n                defConnection[optionsOffset] = (byte)(defConnection[optionsOffset] | 8);\n                savedLegacySetting[optionsOffset] = (byte)(savedLegacySetting[optionsOffset] | 8);
            else\n            {\n                defConnection[optionsOffset] = (byte)(defConnection[optionsOffset] & ~8);\n                savedLegacySetting[optionsOffset] = (byte)(savedLegacySetting[optionsOffset] & ~8);\n            }\n            BitConverter.GetBytes(\n                unchecked(BitConverter.ToUInt32(defConnection, versionOffset) + 1))\n                .CopyTo(defConnection, versionOffset);\n            BitConverter.GetBytes(\n                unchecked(BitConverter.ToUInt32(savedLegacySetting, versionOffset) + 1))\n                .CopyTo(savedLegacySetting, versionOffset);\n            registry.SetValue("DefaultConnectionSettings", defConnection);\n            registry.SetValue("SavedLegacySettings", savedLegacySetting);
            Utils.ReleaseMemory(true);\n            using (Mutex mutex = new Mutex(false, $"Global\\Shadowsocks_{Application.StartupPath.GetHashCode()}"))
                Application.SetUnhandledExceptionMode(UnhandledExceptionMode.CatchException);\n                // handle UI exceptions\n                Application.ThreadException += Application_ThreadException;\n                // handle non-UI exceptions\n                AppDomain.CurrentDomain.UnhandledException += CurrentDomain_UnhandledException;\n                Application.ApplicationExit += Application_ApplicationExit;\n                SystemEvents.PowerModeChanged += SystemEvents_PowerModeChanged;\n                Application.EnableVisualStyles();\n                Application.SetCompatibleTextRenderingDefault(false);\n                AutoStartup.RegisterForRestart(true);\n                if (!mutex.WaitOne(0, false))
                Directory.SetCurrentDirectory(Application.StartupPath);
                MainController = new ShadowsocksController();\n                MenuController = new MenuViewController(MainController);\n                HotKeys.Init(MainController);\n                MainController.Start();\n                Application.Run();\n            }
            StatisticsChart.Series["Speed"].XValueMember = "Timestamp";\n            StatisticsChart.Series["Speed"].YValueMembers = "Speed";\n            if (_configuration.Ping)\n            {\n                _dataTable.Columns.Add("Package Loss", typeof (int));\n                _dataTable.Columns.Add("Ping", typeof (int));\n                StatisticsChart.Series["Package Loss"].XValueMember = "Timestamp";\n                StatisticsChart.Series["Package Loss"].YValueMembers = "Package Loss";\n                StatisticsChart.Series["Ping"].XValueMember = "Timestamp";\n                StatisticsChart.Series["Ping"].YValueMembers = "Ping";\n            }
                                Ping = (int)dataGroup.Average(data => data.AverageResponse),\n                                PackageLoss = dataGroup.Average(data => data.PackageLoss)};
                _dataTable.Rows.Add(data.Timestamp, data.PackageLoss, data.Ping);
        private void serverSelector_SelectedIndexChanged(object sender, EventArgs e)
        }\n        private void chartModeSelector_Enter(object sender, EventArgs e)\n        {
            ((System.ComponentModel.ISupportInitialize)(this.bindingConfiguration)).BeginInit();
            series1.ChartType = System.Windows.Forms.DataVisualization.Charting.SeriesChartType.Bubble;\n            series1.Color = System.Drawing.Color.FromArgb(((int)(((byte)(221)))), ((int)(((byte)(88)))), ((int)(((byte)(0)))));
            series1.Name = "Package Loss";\n            series1.XValueType = System.Windows.Forms.DataVisualization.Charting.ChartValueType.DateTime;\n            series1.YValuesPerPoint = 2;\n            series2.BorderWidth = 4;
            series2.ChartType = System.Windows.Forms.DataVisualization.Charting.SeriesChartType.Line;\n            series2.Color = System.Drawing.Color.FromArgb(((int)(((byte)(155)))), ((int)(((byte)(77)))), ((int)(((byte)(150)))));
            series2.Name = "Ping";\n            series2.XValueType = System.Windows.Forms.DataVisualization.Charting.ChartValueType.DateTime;
            series3.ChartType = System.Windows.Forms.DataVisualization.Charting.SeriesChartType.Area;
            series3.Name = "Speed";
            this.StatisticsChart.Click += new System.EventHandler(this.StatisticsChart_Click);
            ((System.ComponentModel.ISupportInitialize)(this.bindingConfiguration)).EndInit();
      public static readonly Mode TERMINATOR = new Mode(new int[] { 0, 0, 0 }, 0x00, "TERMINATOR"); // Not really a mode...\n      /// <summary>\n      /// \n      /// </summary>\n      public static readonly Mode NUMERIC = new Mode(new int[] { 10, 12, 14 }, 0x01, "NUMERIC");\n      /// <summary>\n      /// \n      /// </summary>\n      public static readonly Mode ALPHANUMERIC = new Mode(new int[] { 9, 11, 13 }, 0x02, "ALPHANUMERIC");\n      /// <summary>\n      /// \n      /// </summary>\n      public static readonly Mode STRUCTURED_APPEND = new Mode(new int[] { 0, 0, 0 }, 0x03, "STRUCTURED_APPEND"); // Not supported\n      /// <summary>\n      /// \n      /// </summary>
      /// <summary>\n      /// \n      /// </summary>\n      public static readonly Mode ECI = new Mode(null, 0x07, "ECI"); // character counts don't apply\n      /// <summary>\n      /// \n      /// </summary>\n      public static readonly Mode KANJI = new Mode(new int[] { 8, 10, 12 }, 0x08, "KANJI");\n      /// <summary>\n      /// \n      /// </summary>\n      public static readonly Mode FNC1_FIRST_POSITION = new Mode(null, 0x05, "FNC1_FIRST_POSITION");\n      /// <summary>\n      /// \n      /// </summary>\n      public static readonly Mode FNC1_SECOND_POSITION = new Mode(null, 0x09, "FNC1_SECOND_POSITION");\n      /// <summary>See GBT 18284-2000; "Hanzi" is a transliteration of this mode name.</summary>\n      public static readonly Mode HANZI = new Mode(new int[] { 8, 10, 12 }, 0x0D, "HANZI");
            case 0x0:\n               return TERMINATOR;\n            case 0x1:\n               return NUMERIC;\n            case 0x2:\n               return ALPHANUMERIC;\n            case 0x3:\n               return STRUCTURED_APPEND;
            case 0x5:\n               return FNC1_FIRST_POSITION;\n            case 0x7:\n               return ECI;\n            case 0x8:\n               return KANJI;\n            case 0x9:\n               return FNC1_SECOND_POSITION;\n            case 0xD:\n               // 0xD is defined in GBT 18284-2000, may not be supported in foreign country\n               return HANZI;
      public static GenericGF AZTEC_DATA_12 = new GenericGF(0x1069, 4096, 1); // x^12 + x^6 + x^5 + x^3 + 1\n      public static GenericGF AZTEC_DATA_10 = new GenericGF(0x409, 1024, 1); // x^10 + x^3 + 1\n      public static GenericGF AZTEC_DATA_6 = new GenericGF(0x43, 64, 1); // x^6 + x + 1\n      public static GenericGF AZTEC_PARAM = new GenericGF(0x13, 16, 1); // x^4 + x + 1
      public static GenericGF DATA_MATRIX_FIELD_256 = new GenericGF(0x012D, 256, 1); // x^8 + x^5 + x^3 + x^2 + 1\n      public static GenericGF AZTEC_DATA_8 = DATA_MATRIX_FIELD_256;\n      public static GenericGF MAXICODE_FIELD_64 = AZTEC_DATA_6;
    static class GeositeUpdater
        public static event EventHandler<ResultEventArgs> UpdateCompleted;\n        public class ResultEventArgs : EventArgs\n        {\n            public bool Success;\n            public ResultEventArgs(bool success)\n            {\n                this.Success = success;\n            }\n        }
                Console.WriteLine(e.Message);
        private Delegate GetDelegateViaMethodName(Type type, string methodname)\n        {\n            if (type == null) throw new ArgumentNullException(nameof(type));
            //HotkeySettingsForm form = new HotkeySettingsForm(_controller);\n            Type delegateType = Type.GetType("Shadowsocks.Util.HotKeys").GetNestedType("HotKeyCallBackHandler");\n            MethodInfo dynMethod = type.GetMethod(methodname,
            return dynMethod == null ? null : Delegate.CreateDelegate(delegateType, this, dynMethod);
using Shadowsocks.Util;
namespace Shadowsocks.Util
        public static void Init()
                            Color flyBlue = Color.FromArgb(192, 192, 192);
                            iconCopy.SetPixel(x, y, Color.FromArgb(color.A, red, green, blue));
            // don't put PrivoxyRunner.Start() before pacServer.Stop()\n            // or bind will fail when switching bind address from 0.0.0.0 to 127.0.0.1\n            // though UseShellExecute is set to true now\n            // http://stackoverflow.com/questions/10235093/socket-doesnt-close-after-application-exits-if-a-launched-process-is-open\n            privoxyRunner.Stop();
                privoxyRunner.Start(_config);
                services.Add(new PortForwarder(privoxyRunner.RunningPort));
        static extern IntPtr CreateJobObject(IntPtr a, string lpName);
        static extern bool SetInformationJobObject(IntPtr hJob, JobObjectInfoType infoType, IntPtr lpJobObjectInfo, UInt32 cbJobObjectInfoLength);
        static extern bool AssignProcessToJobObject(IntPtr job, IntPtr process);
        static extern bool CloseHandle(IntPtr hObject);
            int length = Marshal.SizeOf(typeof(JOBOBJECT_EXTENDED_LIMIT_INFORMATION));\n            IntPtr extendedInfoPtr = Marshal.AllocHGlobal(length);\n            Marshal.StructureToPtr(extendedInfo, extendedInfoPtr, false);\n            if (!SetInformationJobObject(handle, JobObjectInfoType.ExtendedLimitInformation, extendedInfoPtr, (uint)length))\n                throw new Exception(string.Format("Unable to set information.  Error: {0}", Marshal.GetLastWin32Error()));
            ServersListBox.Items.Clear();\n            foreach (Server server in modifiedConfiguration.configs)\n            {\n                ServersListBox.Items.Add(server.server);\n            }
            oldSelectedIndex = ServersListBox.SelectedIndex;
            "cast5-cfb",\n            "des-cfb",
﻿using OpenSSL.Core;\nusing OpenSSL.Crypto;\nusing System;
                int ivLen = _cipher.IVLength;
                Native.RAND_bytes(iv, iv.Length);
                int outLen = length + _cipher.BlockSize;
                Native.EVP_CipherUpdate(_encryptCtx, cipherText, out outLen, buf, length);
                int outLen = length + _cipher.BlockSize;
                Native.EVP_CipherUpdate(_encryptCtx, cipherText, out outLen, buf, length);
                int ivLen = _cipher.IVLength;
                int outLen = length + _cipher.BlockSize;
                Native.EVP_CipherUpdate(_decryptCtx, cipherText, out outLen, subset, length - ivLen);
                int outLen = length + _cipher.BlockSize;
                Native.EVP_CipherUpdate(_decryptCtx, cipherText, out outLen, buf, length);
        private static readonly Dictionary<string, Cipher> CachedCiphers = new Dictionary<string, Cipher>();
        private Cipher _cipher;
                _cipher = CachedCiphers[k];\n                return;
            _cipher = Cipher.CreateByName(method);\n            if (_cipher == null)
                throw new NullReferenceException();
            byte[] passbuf = Encoding.UTF8.GetBytes(password);\n            _key = new byte[_cipher.KeyLength];\n            byte[] iv = new byte[_cipher.IVLength];\n            Native.EVP_BytesToKey(_cipher.Handle, MessageDigest.MD5.Handle, null, passbuf, passbuf.Length, 1, _key, iv);\n            CachedKeys[k] = _key;\n            CachedCiphers[k] = _cipher;
            ctx = Native.OPENSSL_malloc(Marshal.SizeOf(typeof(CipherContext.EVP_CIPHER_CTX)));
            Native.EVP_CIPHER_CTX_init(ctx);\n            Native.ExpectSuccess(Native.EVP_CipherInit_ex(ctx, _cipher.Handle, IntPtr.Zero, null, null, enc));\n            Native.ExpectSuccess(Native.EVP_CIPHER_CTX_set_key_length(ctx, _key.Length));\n            Native.ExpectSuccess(Native.EVP_CIPHER_CTX_set_padding(ctx, 1));\n            Native.ExpectSuccess(Native.EVP_CipherInit_ex(ctx, _cipher.Handle, IntPtr.Zero, _key, iv, enc));
            if (privoxyRunner == null)\n            {\n                privoxyRunner = new PrivoxyRunner();\n            }\n            if (_pacDaemon == null)\n            {\n                _pacDaemon = new PACDaemon();\n                _pacDaemon.PACFileChanged += PacDaemon_PACFileChanged;\n                _pacDaemon.UserRuleFileChanged += PacDaemon_UserRuleFileChanged;\n            }\n            if (_pacServer == null)\n            {\n                _pacServer = new PACServer(_pacDaemon);\n            }\n            if (gfwListUpdater == null)\n            {\n                gfwListUpdater = new GFWListUpdater();\n                gfwListUpdater.UpdateCompleted += PacServer_PACUpdateCompleted;\n                gfwListUpdater.Error += PacServer_PACUpdateError;\n            }
            if (_listener != null)\n            {\n                _listener.Stop();\n            }
                if (strategy != null)\n                {\n                    strategy.ReloadServers();\n                }
namespace Shadowsocks.Controller {\nclass AutoStartup {\npublic static bool Set(bool enabled) {\ntry {\nstring path = Application.ExecutablePath;\nRegistryKey runKey = Microsoft.Win32.Registry.CurrentUser.OpenSubKey(@"Software\Microsoft\Windows\CurrentVersion\Run", true);\nif (enabled) {\nrunKey.SetValue("Shadowsocks", path);\n} else {\nrunKey.DeleteValue("Shadowsocks");\n}\nrunKey.Close();\nreturn true;\n} catch (Exception e) {\n                Logging.LogUsefulException(e);\nreturn false;\n}\n}\npublic static bool Check() {\ntry {\nstring path = Application.ExecutablePath;\nRegistryKey runKey = Microsoft.Win32.Registry.CurrentUser.OpenSubKey(@"Software\Microsoft\Windows\CurrentVersion\Run");\nstring[] runList = runKey.GetValueNames();\nrunKey.Close();\nforeach (string item in runList) {\nif (item.Equals("Shadowsocks"))\nreturn true;\n}\nreturn false;
return false;
}\n}\n}
                CreateMenuItem("Edit PAC File...", new EventHandler(this.EditPACFileItem_Click)),\n                CreateMenuItem("Update PAC from GFWList", new EventHandler(this.UpdatePACFromGFWListItem_Click)),
                catch (InvalidOperationException)
            string serverStr;\n            // CheckHostName() won't do a real DNS lookup\n            var hostType = Uri.CheckHostName(server);\n            switch (hostType)\n            {\n                case UriHostNameType.IPv6:\n                    serverStr = $"[{server}]:{server_port}";\n                    break;\n                default:\n                    // IPv4 and domain name\n                    serverStr = $"{server}:{server_port}";\n                    break;\n            }
        private static bool failed = false;
        public static void Update(Configuration config, bool forceDisable, PACServer pacSrv)
            if (failed) return;
                switch (ex.Type)
                    case ProxyExceptionType.FailToRun:\n                        MessageBox.Show(I18N.GetString("Error when running sysproxy, check your proxy config"), I18N.GetString("Shadowsocks"));\n                        break;\n                    case ProxyExceptionType.QueryReturnMalformed:\n                    case ProxyExceptionType.QueryReturnEmpty:\n                        MessageBox.Show(I18N.GetString("Can't query proxy config, check your proxy config"), I18N.GetString("Shadowsocks"));\n                        break;\n                    case ProxyExceptionType.SysproxyExitError:\n                        MessageBox.Show(I18N.GetString("Sysproxy return a error:") + ex.Message, I18N.GetString("Shadowsocks"));\n                        break;
        public void Enable()
            RegistryKey registry = Registry.CurrentUser.OpenSubKey("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings", true);\n            registry.SetValue("ProxyEnable", 1);\n            registry.SetValue("ProxyServer", "127.0.0.1:8123");
        public void Disable()
            // These lines implement the Interface in the beginning of program \n            // They cause the OS to refresh the settings, causing IP to realy update\n            settingsReturn = InternetSetOption(IntPtr.Zero, INTERNET_OPTION_SETTINGS_CHANGED, IntPtr.Zero, 0);\n            refreshReturn = InternetSetOption(IntPtr.Zero, INTERNET_OPTION_REFRESH, IntPtr.Zero, 0);
    using RawStatistics = Dictionary<string, List<AvailabilityStatistics.RawStatisticsData>>;\n    using Statistics = Dictionary<string, List<AvailabilityStatistics.StatisticsData>>;
        public RawStatistics rawStatistics { get; private set; }\n        public RawStatistics filteredStatistics { get; private set; }\n        private int _repeat => _config.RepeatTimesNum;
                    var reply = ping.Send(IP, Timeout);
                    Thread.Sleep(new Random().Next() % Timeout);
                    Logging.Debug(remote, bytesToSend, "TCP Relay", "@PipeConnectionReceiveCallback() (upload)");
            this.byISPCheckBox = new System.Windows.Forms.CheckBox();
            this.label4 = new System.Windows.Forms.Label();
        private System.Windows.Forms.CheckBox byISPCheckBox;
        private System.Windows.Forms.Label label4;
        private const int TimeoutMilliseconds = 500;\n        public static readonly DateTime UnknownDateTime = new DateTime(1970, 1, 1);
        private readonly TimeSpan _delayBeforeStart = TimeSpan.FromSeconds(1);\n        private readonly TimeSpan _monitorInterval = TimeSpan.FromSeconds(1);\n        private readonly TimeSpan _retryInterval = TimeSpan.FromMinutes(2); //retry 2 minutes after failed\n        private readonly TimeSpan _writingInterval = TimeSpan.FromMinutes(1);\n        private StatisticsStrategyConfiguration _config;\n        private ShadowsocksController _controller;\n        private Server _currentServer;\n        //speed in KiB/s\n        private List<int> _inboundSpeedRecords;\n        private long _lastInboundCounter;\n        private long _lastOutboundCounter;\n        private List<int> _latencyRecords;\n        private List<int> _outboundSpeedRecords;\n        private Timer _recorder;\n        private List<Server> _servers;\n        private Timer _speedMonior;\n        private Timer _writer;
        }\n        private AvailabilityStatistics()\n        {\n            RawStatistics = new Statistics();\n        }
        private int Repeat => _config.RepeatTimesNum;\n        private TimeSpan RecordingInterval => TimeSpan.FromMinutes(_config.DataCollectionMinutes);\n        public bool Set(StatisticsStrategyConfiguration config)\n        {\n            _config = config;\n            try\n            {\n                if (config.StatisticsEnabled)\n                {\n                    if (_recorder?.Change(_delayBeforeStart, RecordingInterval) == null)\n                    {\n                        _recorder = new Timer(Run, null, _delayBeforeStart, RecordingInterval);\n                    }
                    if (_speedMonior?.Change(_delayBeforeStart, _monitorInterval) == null)\n                    {\n                        _speedMonior = new Timer(UpdateSpeed, null, _delayBeforeStart, _monitorInterval);\n                    }\n                    if (_writer?.Change(_delayBeforeStart, RecordingInterval) == null)\n                    {\n                        _writer = new Timer(Save, null, _delayBeforeStart, RecordingInterval);\n                    }
                }\n                return true;
                return false;\n            }\n        }\n        private void UpdateSpeed(object state)
            AppendRecord();
        private async void AppendRecord()\n        {\n            //todo: option for icmp test\n            var icmpResults = TaskEx.WhenAll(_servers.Select(ICMPTest));\n            var currentServerRecord = new StatisticsRecord(_currentServer.Identifier(),\n                _inboundSpeedRecords, _outboundSpeedRecords, _latencyRecords);
                List<StatisticsRecord> records;\n                if (!RawStatistics.TryGetValue(result.Server.Identifier(), out records))\n                {\n                    records = new List<StatisticsRecord>();\n                }\n                if (result.Server.Equals(_currentServer))
                    records.Add(currentServerRecord);
                    records.Add(new StatisticsRecord(result.Server.Identifier(), result.RoundtripTime));\n                }\n                RawStatistics[result.Server.Identifier()] = records;\n            }
        /*\n        private static void Append(DataList dataList, IEnumerable<DataUnit> extra)\n        {\n            var data = dataList.Concat(extra);\n            var dataLine = string.Join(Delimiter, data.Select(kv => kv.Value).ToArray());\n            string[] lines;\n            if (!File.Exists(AvailabilityStatisticsFile))\n            {\n                var headerLine = string.Join(Delimiter, data.Select(kv => kv.Key).ToArray());\n                lines = new[] { headerLine, dataLine };\n            }\n            else\n            {\n                lines = new[] { dataLine };\n            }\n            try\n            {\n                File.AppendAllLines(AvailabilityStatisticsFile, lines);\n            }\n            catch (IOException e)\n            {\n                Logging.LogUsefulException(e);\n            }\n        }\n        */\n        internal void UpdateConfiguration(ShadowsocksController controller)\n        {\n            _controller = controller;\n            _currentServer = _controller.GetCurrentServer();\n            Reset();\n            Set(controller.StatisticsConfiguration);\n            _servers = _controller.GetCurrentConfiguration().configs;\n        }
            if (_config.ByHourOfDay)\n            {\n                var currentHour = DateTime.Now.Hour;
            var oldServer = _currentServer;\n            if (oldServer == null)
            }\n            if (oldServer != _currentServer)\n            {
        private void WrapTextCheckBox_CheckedChanged(object sender, EventArgs e)\n        {\n            LogMessageTextBox.WordWrap = WrapTextCheckBox.Checked;\n            LogMessageTextBox.ScrollToCaret();
            LogMessageTextBox.Clear();\n        }\n        private void ChangeFontButton_Click(object sender, EventArgs e)
            this.TopMost = TopMostCheckBox.Checked;
            this.contextMenuStrip1 = new System.Windows.Forms.ContextMenuStrip(this.components);\n            this.mainMenu1 = new System.Windows.Forms.MainMenu(this.components);
            this.panel1 = new System.Windows.Forms.Panel();
            this.TopMostCheckBox = new System.Windows.Forms.CheckBox();\n            this.panel1.SuspendLayout();
            // panel1\n            // \n            this.panel1.Controls.Add(this.TopMostCheckBox);\n            this.panel1.Controls.Add(this.ChangeFontButton);\n            this.panel1.Controls.Add(this.CleanLogsButton);\n            this.panel1.Controls.Add(this.WrapTextCheckBox);\n            this.panel1.Dock = System.Windows.Forms.DockStyle.Fill;\n            this.panel1.Location = new System.Drawing.Point(3, 3);\n            this.panel1.Name = "panel1";\n            this.panel1.Size = new System.Drawing.Size(541, 34);\n            this.panel1.TabIndex = 1;
            this.ChangeFontButton.Location = new System.Drawing.Point(107, 4);
            this.CleanLogsButton.Location = new System.Drawing.Point(9, 4);
            this.tableLayoutPanel1.Controls.Add(this.panel1, 0, 0);
            this.tableLayoutPanel1.Size = new System.Drawing.Size(547, 353);
            // TopMostCheckBox\n            // \n            this.TopMostCheckBox.AutoSize = true;\n            this.TopMostCheckBox.Location = new System.Drawing.Point(311, 9);\n            this.TopMostCheckBox.Name = "TopMostCheckBox";\n            this.TopMostCheckBox.Size = new System.Drawing.Size(72, 16);\n            this.TopMostCheckBox.TabIndex = 3;\n            this.TopMostCheckBox.Text = "&Top most";\n            this.TopMostCheckBox.UseVisualStyleBackColor = true;\n            this.TopMostCheckBox.CheckedChanged += new System.EventHandler(this.TopMostCheckBox_CheckedChanged);
            this.panel1.ResumeLayout(false);\n            this.panel1.PerformLayout();
        private System.Windows.Forms.ContextMenuStrip contextMenuStrip1;\n        private System.Windows.Forms.MainMenu mainMenu1;
        private System.Windows.Forms.Panel panel1;
        int _targetPort;
            this._targetPort = targetPort;
            new Handler().Start(firstPacket, length, socket, this._targetPort);
        class Handler
            public const int RecvSize = 16384;
                this._firstPacket = firstPacket;\n                this._firstPacketLength = length;\n                this._local = socket;
                    this.Close();
                        new AsyncCallback(PipeRemoteReceiveCallback), null);
                        new AsyncCallback(PipeConnectionReceiveCallback), null);\n                }\n                catch (Exception e)\n                {\n                    Logging.LogUsefulException(e);\n                    this.Close();
                    _remote.BeginReceive(this.remoteRecvBuffer, 0, RecvSize, 0,\n                        new AsyncCallback(PipeRemoteReceiveCallback), null);\n                }\n                catch (Exception e)\n                {\n                    Logging.LogUsefulException(e);\n                    this.Close();
                    this.Close();
            if (CachedKeys.ContainsKey(k))\n            {
            }\n            else\n            {\n                byte[] passbuf = Encoding.UTF8.GetBytes(password);\n                _key = new byte[32];\n                byte[] iv = new byte[16];\n                bytesToKey(passbuf, _key);\n                CachedKeys[k] = _key;\n            }
namespace Shadowsocks.Proxy
    public class DirectConnect : IProxy
namespace Shadowsocks.Proxy
    public class HttpProxy : IProxy
using Shadowsocks.Proxy;
namespace Shadowsocks.Proxy
    public interface IProxy
namespace Shadowsocks.Proxy
    public class Socks5Proxy : IProxy
            System.Windows.Forms.DataVisualization.Charting.ChartArea chartArea1 = new System.Windows.Forms.DataVisualization.Charting.ChartArea();\n            System.Windows.Forms.DataVisualization.Charting.Legend legend1 = new System.Windows.Forms.DataVisualization.Charting.Legend();\n            System.Windows.Forms.DataVisualization.Charting.Series series1 = new System.Windows.Forms.DataVisualization.Charting.Series();\n            System.Windows.Forms.DataVisualization.Charting.Series series2 = new System.Windows.Forms.DataVisualization.Charting.Series();\n            System.Windows.Forms.DataVisualization.Charting.Series series3 = new System.Windows.Forms.DataVisualization.Charting.Series();
            this.checkBox1 = new System.Windows.Forms.CheckBox();
            this.numericUpDown2 = new System.Windows.Forms.NumericUpDown();\n            this.checkBox2 = new System.Windows.Forms.CheckBox();\n            this.numericUpDown1 = new System.Windows.Forms.NumericUpDown();
            this.flowLayoutPanel1 = new System.Windows.Forms.FlowLayoutPanel();\n            this.panel3 = new System.Windows.Forms.Panel();\n            this.label5 = new System.Windows.Forms.Label();\n            this.label7 = new System.Windows.Forms.Label();\n            this.textBox5 = new System.Windows.Forms.TextBox();\n            this.comboBox3 = new System.Windows.Forms.ComboBox();
            ((System.ComponentModel.ISupportInitialize)(this.numericUpDown2)).BeginInit();\n            ((System.ComponentModel.ISupportInitialize)(this.numericUpDown1)).BeginInit();
            this.flowLayoutPanel1.SuspendLayout();\n            this.panel3.SuspendLayout();
            this.splitContainer1.Panel1.Paint += new System.Windows.Forms.PaintEventHandler(this.splitContainer1_Panel1_Paint);
            this.splitContainer2.Panel1.Controls.Add(this.numericUpDown2);\n            this.splitContainer2.Panel1.Controls.Add(this.checkBox2);\n            this.splitContainer2.Panel1.Controls.Add(this.numericUpDown1);
            this.splitContainer2.Panel1.Controls.Add(this.checkBox1);
            // numericUpDown2\n            // \n            this.numericUpDown2.Location = new System.Drawing.Point(16, 145);\n            this.numericUpDown2.Margin = new System.Windows.Forms.Padding(3, 4, 3, 4);\n            this.numericUpDown2.Maximum = new decimal(new int[] {\n            60,\n            0,\n            0,\n            0});\n            this.numericUpDown2.Name = "numericUpDown2";\n            this.numericUpDown2.Size = new System.Drawing.Size(146, 34);\n            this.numericUpDown2.TabIndex = 16;\n            // \n            // checkBox2\n            // \n            this.checkBox2.AutoSize = true;\n            this.checkBox2.Location = new System.Drawing.Point(16, 64);\n            this.checkBox2.Margin = new System.Windows.Forms.Padding(5, 10, 5, 10);\n            this.checkBox2.Name = "checkBox2";\n            this.checkBox2.Size = new System.Drawing.Size(165, 32);\n            this.checkBox2.TabIndex = 15;\n            this.checkBox2.Text = "By hour of day";\n            this.checkBox2.UseVisualStyleBackColor = true;\n            // \n            // numericUpDown1\n            // \n            this.numericUpDown1.Location = new System.Drawing.Point(76, 189);\n            this.numericUpDown1.Margin = new System.Windows.Forms.Padding(3, 4, 3, 4);\n            this.numericUpDown1.Maximum = new decimal(new int[] {
            this.numericUpDown1.Name = "numericUpDown1";\n            this.numericUpDown1.Size = new System.Drawing.Size(91, 34);\n            this.numericUpDown1.TabIndex = 14;\n            this.numericUpDown1.Value = new decimal(new int[] {
            this.Load += new System.EventHandler(this.StatisticsStrategyOptionsForm_Load);
            ((System.ComponentModel.ISupportInitialize)(this.numericUpDown2)).EndInit();\n            ((System.ComponentModel.ISupportInitialize)(this.numericUpDown1)).EndInit();
            this.flowLayoutPanel1.ResumeLayout(false);\n            this.flowLayoutPanel1.PerformLayout();\n            this.panel3.ResumeLayout(false);\n            this.panel3.PerformLayout();
        private System.Windows.Forms.CheckBox checkBox1;
        private System.Windows.Forms.FlowLayoutPanel flowLayoutPanel1;
        private System.Windows.Forms.Panel panel3;\n        private System.Windows.Forms.Label label5;\n        private System.Windows.Forms.Label label7;\n        private System.Windows.Forms.TextBox textBox5;\n        private System.Windows.Forms.ComboBox comboBox3;\n        private System.Windows.Forms.NumericUpDown numericUpDown1;
        private System.Windows.Forms.CheckBox checkBox2;\n        private System.Windows.Forms.NumericUpDown numericUpDown2;
    class SimplyChooseByStatisticsStrategy : IStrategy
        public SimplyChooseByStatisticsStrategy(ShadowsocksController controller)
        private static void StatisticsStrategyOptionsItem_Click(object sender, EventArgs e)
            var statisticsStrategyOptionsForm = new StatisticsStrategyOptionsForm();
                Logging.Debug(string.Format("best server {0}: {1}", bestResult.server.FriendlyName(), bestResult.score));
        string IStrategy.ID
        string IStrategy.Name
        Server IStrategy.GetAServer(IStrategyCallerType type, IPEndPoint localIPEndPoint)
            Console.WriteLine("Switch to server by statistics: {0}", _currentServer.FriendlyName());
        void IStrategy.ReloadServers()
        void IStrategy.SetFailure(Server server)
        void IStrategy.UpdateLastRead(Server server)
        void IStrategy.UpdateLastWrite(Server server)
        void IStrategy.UpdateLatency(Server server, TimeSpan latency)
            Server server = Configuration.GetDefaultServer();\n            _modifiedConfiguration.configs.Add(server);
            if (!ValidateAndSaveSelectedServerDetails())
                RegisterApplicationRestart(null, (int)ApplicationRestartFlags.RESTART_NO_CRASH | (int)ApplicationRestartFlags.RESTART_NO_HANG);\n                Logging.Debug("Register restart after system reboot");
        static void Main()
        private Int64 compare(byte x, byte y, UInt64 a, int i) {\n            return (Int64)(a % (UInt64)(x + i)) - (Int64)(a % (UInt64)(y + i));
        private byte[] mergeSort(byte[] array, UInt64 a, int j)
            Socket listener = new Socket(AddressFamily.InterNetwork,
            new Local(1081).Start();
                    if (strategy != null)\n                    {\n                        strategy.UpdateLastWrite(server);\n                    }
        public static readonly string DateTimePattern = "yyyy-MM-dd HH:mm:ss";
        private const int DelayBeforeStart = 1000;
        private const int RetryInterval = 2 * 60 * 1000; //retry 2 minutes after failed\n        private int Interval => (int)TimeSpan.FromMinutes(_config.DataCollectionMinutes).TotalMilliseconds;
        public AvailabilityStatistics(Configuration config, StatisticsStrategyConfiguration statisticsConfig)\n        {\n            UpdateConfiguration(config, statisticsConfig);
                    await geolocationAndIsp;
                process.Kill();
            IPGlobalProperties properties = IPGlobalProperties.GetIPGlobalProperties();\n            IPEndPoint[] tcpEndPoints = properties.GetActiveTcpListeners();\n            List<int> usedPorts = new List<int>();\n            foreach (IPEndPoint endPoint in IPGlobalProperties.GetIPGlobalProperties().GetActiveTcpListeners())
                usedPorts.Add(endPoint.Port);
            for (int port = 8123; port < 65535; port++)
                if (!usedPorts.Contains(port))\n                {\n                    return port;\n                }
            ChangeToPacTextBox.Text = config.ChangeToPac;\n            ChangeToGlobalTextBox.Text = config.ChangeToGlobal;
            ChangeToPacLabel.Text = I18N.GetString("Switch to PAC mode");\n            ChangeToGlobalLabel.Text = I18N.GetString("Switch to Global mode");
        public string ChangeToPac;\n        public string ChangeToGlobal;
            ChangeToPac = "";\n            ChangeToGlobal = "";
            this.ChangeToPacLabel = new System.Windows.Forms.Label();\n            this.ChangeToGlobalLabel = new System.Windows.Forms.Label();
            this.ChangeToPacTextBox = new System.Windows.Forms.TextBox();\n            this.ChangeToGlobalTextBox = new System.Windows.Forms.TextBox();
            this.tableLayoutPanel1.Controls.Add(this.ChangeToPacLabel, 0, 1);\n            this.tableLayoutPanel1.Controls.Add(this.ChangeToGlobalLabel, 0, 2);\n            this.tableLayoutPanel1.Controls.Add(this.SwitchAllowLanLabel, 0, 3);\n            this.tableLayoutPanel1.Controls.Add(this.ShowLogsLabel, 0, 4);\n            this.tableLayoutPanel1.Controls.Add(this.ServerMoveUpLabel, 0, 5);\n            this.tableLayoutPanel1.Controls.Add(this.ServerMoveDownLabel, 0, 6);\n            this.tableLayoutPanel1.Controls.Add(flowLayoutPanel1, 0, 7);
            this.tableLayoutPanel1.Controls.Add(this.ChangeToPacTextBox, 1, 1);\n            this.tableLayoutPanel1.Controls.Add(this.ChangeToGlobalTextBox, 1, 2);\n            this.tableLayoutPanel1.Controls.Add(this.SwitchAllowLanTextBox, 1, 3);\n            this.tableLayoutPanel1.Controls.Add(this.ShowLogsTextBox, 1, 4);\n            this.tableLayoutPanel1.Controls.Add(this.ServerMoveUpTextBox, 1, 5);\n            this.tableLayoutPanel1.Controls.Add(this.ServerMoveDownTextBox, 1, 6);
        private System.Windows.Forms.Label ChangeToPacLabel;\n        private System.Windows.Forms.Label ChangeToGlobalLabel;
        private System.Windows.Forms.TextBox ChangeToGlobalTextBox;\n        private System.Windows.Forms.TextBox ChangeToPacTextBox;
                runKey = Microsoft.Win32.Registry.CurrentUser.OpenSubKey(@"Software\Microsoft\Windows\CurrentVersion\Run", true);
                    if (item.Equals(Key))
                    else if (item.Equals("Shadowsocks")) // Compatibility with older versions
        [DllImport("kernel32.dll", CharSet = CharSet.Unicode)]\n        private static extern IntPtr CreateJobObject(IntPtr a, string lpName);\n        [DllImport("kernel32.dll", SetLastError = true)]\n        private static extern bool SetInformationJobObject(IntPtr hJob, JobObjectInfoType infoType, IntPtr lpJobObjectInfo, UInt32 cbJobObjectInfoLength);\n        [DllImport("kernel32.dll", SetLastError = true)]\n        private static extern bool AssignProcessToJobObject(IntPtr job, IntPtr process);\n        [DllImport("kernel32.dll", SetLastError = true)]\n        [return: MarshalAs(UnmanagedType.Bool)]\n        private static extern bool CloseHandle(IntPtr hObject);
        private bool disposed;
            this.toolStripSeparator2 = new System.Windows.Forms.ToolStripSeparator();
            // \n            // toolStripSeparator2\n            // \n            this.toolStripSeparator2.Name = "toolStripSeparator2";\n            this.toolStripSeparator2.Size = new System.Drawing.Size(107, 6);
            this.FormClosed += new System.Windows.Forms.FormClosedEventHandler(this.Form1_FormClosed);
            // TODO async resolving\n            IPHostEntry ipHostInfo = Dns.GetHostEntry(config.server);\n            IPAddress ipAddress = ipHostInfo.AddressList[0];\n            IPEndPoint remoteEP = new IPEndPoint(ipAddress, config.server_port);\n            remote = new Socket(ipAddress.AddressFamily,\n                SocketType.Stream, ProtocolType.Tcp);\n            // Connect to the remote endpoint.\n            remote.BeginConnect(remoteEP,\n                new AsyncCallback(connectCallback), null);
            remote.Close();
using System.Runtime.Serialization.Json;
        [NonSerialized]
            DataContractJsonSerializer ser = new DataContractJsonSerializer(typeof(Config));
                using (FileStream fs = File.OpenRead(@"config.json"))
                    Config config = ser.ReadObject(fs) as Config;
            DataContractJsonSerializer ser = new DataContractJsonSerializer(typeof(Config));
                using (FileStream fs = File.Open(@"config.json", FileMode.Create))
                    ser.WriteObject(fs, config);
            this.contextMenu1 = new System.Windows.Forms.ContextMenu(new System.Windows.Forms.MenuItem[] {\n                this.enableItem = CreateMenuItem("Enable", new System.EventHandler(this.EnableItem_Click)),\n                CreateMenuGroup("Mode", new System.Windows.Forms.MenuItem[] {\n                    this.PACModeItem = CreateMenuItem("PAC", new System.EventHandler(this.PACModeItem_Click)),\n                    this.globalModeItem = CreateMenuItem("Global", new System.EventHandler(this.GlobalModeItem_Click))
                this.ServersItem = CreateMenuGroup("Servers", new System.Windows.Forms.MenuItem[] {
                    this.ConfigItem = CreateMenuItem("Edit Servers...", new System.EventHandler(this.Config_Click))
                this.AutoStartupItem = CreateMenuItem("Start on Boot", new System.EventHandler(this.AutoStartupItem_Click)),\n                this.ShareOverLANItem = CreateMenuItem("Share over LAN", new System.EventHandler(this.ShareOverLANItem_Click)),\n                CreateMenuItem("Edit PAC File...", new System.EventHandler(this.EditPACFileItem_Click)),
                CreateMenuItem("Show QRCode...", new System.EventHandler(this.QRCodeItem_Click)),\n                CreateMenuItem("Show Logs...", new System.EventHandler(this.ShowLogItem_Click)),\n                CreateMenuItem("About...", new System.EventHandler(this.Config_Click)),
                CreateMenuItem("Quit", new System.EventHandler(this.Quit_Click))
                Console.WriteLine(e.ToString());
        [DllImport("Kernel32.dll")]\n        private static extern IntPtr LoadLibrary(string path);\n        public const int MD5_CTX_SIZE = 88;
            MbedTLS.md5(input, (uint)input.Length, output);
        public extern static void md5(byte[] input, uint ilen, byte[] output);
        protected Dictionary<string, int[]> ciphers;
        protected int _encryptIVOffset = 0;\n        protected int _decryptIVOffset = 0;
        protected abstract Dictionary<string, int[]> getCiphers();
            _cipherInfo = ciphers[_method];
            keyLen = ciphers[_method][0];\n            ivLen = ciphers[_method][1];
        private static Dictionary<string, int[]> _ciphers = new Dictionary<string, int[]> {\n                {"salsa20", new int[]{32, 8, CIPHER_SALSA20, PolarSSL.AES_CTX_SIZE}},\n                {"chacha20", new int[]{32, 8, CIPHER_CHACHA20, PolarSSL.AES_CTX_SIZE}},\n                {"chacha20-ietf", new int[]{32, 12, CIPHER_CHACHA20_IETF, PolarSSL.AES_CTX_SIZE}},
        protected override Dictionary<string, int[]> getCiphers()
        public void TestPolarSSLEncryption()
                Thread t = new Thread(new ThreadStart(RunSinglePolarSSLEncryptionThread));
        private void RunSinglePolarSSLEncryptionThread()
                    encryptor = new PolarSSLEncryptor("aes-256-cfb", "barfoo!", false, false);\n                    decryptor = new PolarSSLEncryptor("aes-256-cfb", "barfoo!", false, false);
            if (ret != 0) throw new CryptoErrorException();
            return ret;
        public override int cipherDecrypt(byte[] ciphertext, uint clen, byte[] plaintext, ref uint plen)
            if (ret != 0) throw new CryptoErrorException();
            return ret;
            foreach (string method in StreamMbedTLSEncryptor.SupportedCiphers())
                _registeredEncryptors.Add(method, typeof(StreamMbedTLSEncryptor));
                _registeredEncryptors.Add(method, typeof(StreamSodiumEncryptor));
                _registeredEncryptors.Add(method, typeof(AEADMbedTLSEncryptor));\n            }\n            foreach (string method in AEADSodiumEncryptorSupportedCiphers)\n            {\n                _registeredEncryptors.Add(method, typeof(AEADSodiumEncryptor));
                    if (ret != 0) throw new CryptoErrorException();
                    return ret;
        public override int cipherDecrypt(byte[] ciphertext, uint clen, byte[] plaintext, ref uint plen)
                    if (ret != 0) throw new CryptoErrorException();
                    return ret;
            this.contextMenuStrip1 = new System.Windows.Forms.ContextMenuStrip(this.components);\n            this.mainMenu1 = new System.Windows.Forms.MainMenu(this.components);
            this.panel1 = new System.Windows.Forms.Panel();
            this.TopMostCheckBox = new System.Windows.Forms.CheckBox();\n            this.panel1.SuspendLayout();
            // panel1\n            // \n            this.panel1.Controls.Add(this.TopMostCheckBox);\n            this.panel1.Controls.Add(this.ChangeFontButton);\n            this.panel1.Controls.Add(this.CleanLogsButton);\n            this.panel1.Controls.Add(this.WrapTextCheckBox);\n            this.panel1.Dock = System.Windows.Forms.DockStyle.Fill;\n            this.panel1.Location = new System.Drawing.Point(3, 3);\n            this.panel1.Name = "panel1";\n            this.panel1.Size = new System.Drawing.Size(541, 34);\n            this.panel1.TabIndex = 1;
            this.ChangeFontButton.Location = new System.Drawing.Point(107, 4);
            this.CleanLogsButton.Location = new System.Drawing.Point(9, 4);
            this.tableLayoutPanel1.Controls.Add(this.panel1, 0, 0);
            this.tableLayoutPanel1.Size = new System.Drawing.Size(547, 353);
            // TopMostCheckBox\n            // \n            this.TopMostCheckBox.AutoSize = true;\n            this.TopMostCheckBox.Location = new System.Drawing.Point(311, 9);\n            this.TopMostCheckBox.Name = "TopMostCheckBox";\n            this.TopMostCheckBox.Size = new System.Drawing.Size(72, 16);\n            this.TopMostCheckBox.TabIndex = 3;\n            this.TopMostCheckBox.Text = "&Top most";\n            this.TopMostCheckBox.UseVisualStyleBackColor = true;\n            this.TopMostCheckBox.CheckedChanged += new System.EventHandler(this.TopMostCheckBox_CheckedChanged);
            this.panel1.ResumeLayout(false);\n            this.panel1.PerformLayout();
        private System.Windows.Forms.ContextMenuStrip contextMenuStrip1;\n        private System.Windows.Forms.MainMenu mainMenu1;
        private System.Windows.Forms.Panel panel1;
        private void WrapTextCheckBox_CheckedChanged(object sender, EventArgs e)\n        {\n            LogMessageTextBox.WordWrap = WrapTextCheckBox.Checked;\n            LogMessageTextBox.ScrollToCaret();
            LogMessageTextBox.Clear();\n        }\n        private void ChangeFontButton_Click(object sender, EventArgs e)
            this.TopMost = TopMostCheckBox.Checked;
                        int atyp = _connetionRecvBuffer[3];\n                        switch (atyp)
                            case 1: // IPv4 address, 4 bytes\n                                ReadAddress(4 + 2 - 1);\n                                break;\n                            case 3: // domain name, length + str\n                                int len = _connetionRecvBuffer[4];\n                                ReadAddress(len + 2);\n                                break;\n                            case 4: // IPv6 address, 16 bytes\n                                ReadAddress(16 + 2 - 1);\n                                break;\n                            default:\n                                Logging.Debug("Unsupported ATYP=" + atyp);\n                                Close();\n                                break;
        private void ReadAddress(int bytesRemain)
            _connection.BeginReceive(_connetionRecvBuffer, 2, RecvSize - 2, SocketFlags.None, OnAddressFullyRead, bytesRemain);
                int bytesRemain = (int) ar.AsyncState;
            if (remarks.IsNullOrEmpty())\n            {\n                return server + ":" + server_port;
            else\n            {\n                return remarks + " (" + server + ":" + server_port + ")";\n            }
            if (!line.StartsWith("Proxy-"))\n            {\n                _headers.Enqueue(line);\n            }
                    var method = m.Groups[1].Value;
                        if (!ParseHost(m.Groups[2].Value))
                }\n            }\n            else\n            {
                if (bytesRead > 0)\n                {
                    connection.BeginSend(response, 0, response.Length, 0, new AsyncCallback(StartPipe), null);
            this.PACUrlTextBox.Location = new System.Drawing.Point(61, 12);
            this.PACUrlLabel.Location = new System.Drawing.Point(6, 15);
            this.ClientSize = new System.Drawing.Size(327, 88);\n            this.Controls.Add(this.CancelButton);\n            this.Controls.Add(this.OkButton);\n            this.Controls.Add(this.PACUrlTextBox);\n            this.Controls.Add(this.PACUrlLabel);
         String encoding = DEFAULT_BYTE_MODE_ENCODING;\n         //bool generateECI = !DEFAULT_BYTE_MODE_ENCODING.Equals(encoding);
         Mode mode = Mode.BYTE;
         /*\n          // Append ECI segment if applicable\n         if (mode == Mode.BYTE && generateECI)\n         {\n            CharacterSetECI eci = CharacterSetECI.getCharacterSetECIByName(encoding);\n            if (eci != null)\n            {\n               var eciIsExplicitDisabled = (hints != null && hints.ContainsKey(EncodeHintType.DISABLE_ECI) ? (bool)hints[EncodeHintType.DISABLE_ECI] : false);\n               if (!eciIsExplicitDisabled)\n               {\n                  appendECI(eci, headerBits);\n               }\n            }\n         }\n          * */
         throw new Exception("Data too big");
             throw new Exception("EC bytes mismatch");
             throw new Exception("RS blocks mismatch");
             throw new Exception("Total bytes mismatch");
             throw new Exception(numLetters + " is bigger than " + ((1 << numBits) - 1));
                      throw new Exception("Invalid mode: " + mode);
             throw new Exception(uee.Message, uee);
             throw new Exception();
                throw new Exception();
                pacServer.Start(_config);
    class PACServer
        private static Configuration config;\n        Socket _listener;
        public void Start(Configuration configuration)
                config = configuration;\n                // Create a TCP/IP socket.\n                _listener = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);\n                _listener.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, true);\n                IPEndPoint localEndPoint = null;\n                if (configuration.shareOverLan)
                    localEndPoint = new IPEndPoint(IPAddress.Any, PORT);
                else
                    localEndPoint = new IPEndPoint(IPAddress.Loopback, PORT);
                // Bind the socket to the local endpoint and listen for incoming connections.\n                _listener.Bind(localEndPoint);\n                _listener.Listen(100);\n                _listener.BeginAccept(\n                    new AsyncCallback(AcceptCallback),\n                    _listener);\n                WatchPacFile();
            catch (SocketException)
                _listener.Close();\n                throw;\n            }\n        }\n        public void Stop()\n        {\n            if (_listener != null)\n            {\n                _listener.Close();\n                _listener = null;
        private void ReceiveCallback(IAsyncResult ar)
            object[] state = (object[])ar.AsyncState;\n            Socket conn = (Socket)state[0];\n            byte[] requestBuf = (byte[])state[1];
                int bytesRead = conn.EndReceive(ar);
                IPEndPoint localEndPoint = (IPEndPoint)conn.LocalEndPoint;\n                string proxy = GetPACAddress(requestBuf, localEndPoint);
                if (bytesRead > 0)\n                {\n                    string text = String.Format(@"HTTP/1.1 200 OK
                    byte[] response = System.Text.Encoding.UTF8.GetBytes(text);\n                    conn.BeginSend(response, 0, response.Length, 0, new AsyncCallback(SendCallback), conn);\n                    Util.Utils.ReleaseMemory();\n                }\n                else\n                {\n                    conn.Close();\n                }
                conn.Close();
        private string GetPACAddress(byte[] requestBuf, IPEndPoint localEndPoint)
            string proxy = "PROXY " + localEndPoint.Address + ":8123;";\n            //try\n            //{\n            //    string requestString = Encoding.UTF8.GetString(requestBuf);\n            //    if (requestString.IndexOf("AppleWebKit") >= 0)\n            //    {\n            //        string address = "" + localEndPoint.Address + ":" + config.GetCurrentServer().local_port;\n            //        proxy = "SOCKS5 " + address + "; SOCKS " + address + ";";\n            //    }\n            //}\n            //catch (Exception e)\n            //{\n            //    Console.WriteLine(e);\n            //}\n            return proxy;
        public bool GoodForMe(byte[] firstPacket, int length)\n        {\n            return true;\n        }\n        public void Handle(byte[] firstPacket, int length, Socket socket)\n        {
        [TestMethod]\n        public void ParseAndGenerateShadowsocksUrl()\n        {\n            var server = new Server
            var serverCanonUrl = "ss://YmYtY2ZiOnRlc3RAMTkyLjE2OC4xMDAuMTo4ODg4";\n            var server2 = new Server
            var server2CanonUrl = "ss://YmYtY2ZiOnRlc3RAMTkyLjE2OC4xLjE6ODM4OA==";\n            var serverWithRemark = new Server\n            {\n                server = server.server,\n                server_port = server.server_port,\n                password = server.password,\n                method = server.method,
            var serverWithRemarkCanonUrl = "ss://YmYtY2ZiOnRlc3RAMTkyLjE2OC4xMDAuMTo4ODg4#example-server";\n            var server2WithRemark = new Server
            var server2WithRemarkCanonUrl = "ss://YmYtY2ZiOnRlc3RAMTkyLjE2OC4xLjE6ODM4OA==#example-server";\n            var serverWithPlugin = new Server\n            {\n                server = server.server,\n                server_port = server.server_port,\n                password = server.password,\n                method = server.method,
            var serverWithPluginCanonUrl =
            var server2WithPlugin = new Server
            var server2WithPluginCanonUrl =
            var serverWithPluginAndRemark = new Server\n            {\n                server = server.server,\n                server_port = server.server_port,\n                password = server.password,\n                method = server.method,\n                plugin = serverWithPlugin.plugin,\n                plugin_opts = serverWithPlugin.plugin_opts,\n                remarks = serverWithRemark.remarks\n            };\n            var serverWithPluginAndRemarkCanonUrl =
            var server2WithPluginAndRemark = new Server
            var server2WithPluginAndRemarkCanonUrl =
            RunParseShadowsocksUrlTest(\n                string.Join(\n                    "\r\n",\n                    serverCanonUrl,
                    server,\n                    server,\n                    serverWithRemark,\n                    serverWithRemark\n                });
        public void Sip003PluginSupport()
            string fake_plugin = "ftp";
        private readonly IEnumerable<TextBox> _allTextBoxes;
            // get all textboxes belong to this form\n            _allTextBoxes = tableLayoutPanel1.GetChildControls<TextBox>();\n            if (!_allTextBoxes.Any()) throw new Exception("Cannot get all textboxes");
                TryRegHotkeyFromString(hotkeyConfig.SwitchSystemProxy, "SwitchSystemProxyCallback", SwitchSystemProxyLabel)\n                && TryRegHotkeyFromString(hotkeyConfig.SwitchSystemProxyMode, "SwitchProxyModeCallback", SwitchProxyModeLabel)\n                && TryRegHotkeyFromString(hotkeyConfig.SwitchAllowLan, "SwitchAllowLanCallback", SwitchAllowLanLabel)\n                && TryRegHotkeyFromString(hotkeyConfig.ShowLogs, "ShowLogsCallback", ShowLogsLabel)\n                && TryRegHotkeyFromString(hotkeyConfig.ServerMoveUp, "ServerMoveUpCallback", ServerMoveUpLabel)\n                && TryRegHotkeyFromString(hotkeyConfig.ServerMoveDown, "ServerMoveDownCallback", ServerMoveDownLabel);
        private bool TryRegHotkeyFromString(string hotkeyStr, string callbackName, Label indicator = null)
                UnregPrevHotkey(callback);
                    bool regResult = (TryRegHotkey(hotkey, callback));
        private bool TryRegHotkey(GlobalHotKey.HotKey hotkey, HotKeys.HotKeyCallBackHandler callback)\n        {\n            UnregPrevHotkey(callback);\n            return HotKeys.Register(hotkey, callback);\n        }\n        private static void UnregPrevHotkey(HotKeys.HotKeyCallBackHandler cb)\n        {\n            GlobalHotKey.HotKey prevHotKey;\n            if (HotKeys.IsCallbackExists(cb, out prevHotKey))\n            {\n                // unregister previous one\n                HotKeys.Unregister(prevHotKey);\n            }\n        }
            List<string> ret = new List<string>(domains.Count + 100); // 100 overhead
                        ret.Add(domain);
                updateChecker.CheckUpdate(config);
            this.tableLayoutPanel1.Controls.Add(this.EncryptionLabel, 0, 3);\n            this.tableLayoutPanel1.Controls.Add(this.EncryptionSelect, 1, 3);\n            this.tableLayoutPanel1.Controls.Add(this.TimeoutLabel, 0, 8);\n            this.tableLayoutPanel1.Controls.Add(this.TimeoutTextBox, 1, 8);\n            this.tableLayoutPanel1.Controls.Add(this.PluginLabel, 0, 4);\n            this.tableLayoutPanel1.Controls.Add(this.PluginOptionsTextBox, 1, 5);
            this.tableLayoutPanel1.RowCount = 9;\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.Size = new System.Drawing.Size(253, 215);
                var configuration = SimpleJson.SimpleJson.DeserializeObject<StatisticsStrategyConfiguration>(content);
            catch (FileNotFoundException)
            this.bindingConfiguration = new System.Windows.Forms.BindingSource(this.components);\n            this.label2 = new System.Windows.Forms.Label();\n            this.label3 = new System.Windows.Forms.Label();
            this.label9 = new System.Windows.Forms.Label();\n            this.label8 = new System.Windows.Forms.Label();
            this.label6 = new System.Windows.Forms.Label();
            this.label1 = new System.Windows.Forms.Label();
            ((System.ComponentModel.ISupportInitialize)(this.bindingConfiguration)).BeginInit();
            this.splitContainer2.Panel1.Controls.Add(this.label9);\n            this.splitContainer2.Panel1.Controls.Add(this.label8);
            this.splitContainer2.Panel1.Controls.Add(this.label6);\n            this.splitContainer2.Panel1.Controls.Add(this.label2);
            this.splitContainer2.Panel1.Controls.Add(this.label3);
            this.splitContainer3.Panel1.Controls.Add(this.label1);
            // label1\n            // \n            this.label1.AutoSize = true;\n            this.label1.Location = new System.Drawing.Point(5, 9);\n            this.label1.Margin = new System.Windows.Forms.Padding(5, 0, 5, 0);\n            this.label1.Name = "label1";\n            this.label1.Size = new System.Drawing.Size(137, 27);\n            this.label1.TabIndex = 0;\n            this.label1.Text = "Final Score =";\n            this.CalculatinTip.SetToolTip(this.label1, "(The server with the highest score would be choosen)");
            ((System.ComponentModel.ISupportInitialize)(this.bindingConfiguration)).EndInit();
        private System.Windows.Forms.Label label2;\n        private System.Windows.Forms.Label label3;
        private System.Windows.Forms.Label label1;
        private System.Windows.Forms.Label label6;
        private System.Windows.Forms.Label label9;\n        private System.Windows.Forms.Label label8;
                CreateMenuItem("Show Logs...", new EventHandler(this.ShowLogItem_Click)),\n                this.VerboseLoggingToggleItem = CreateMenuItem( "Verbose Logging", new EventHandler(this.VerboseLoggingToggleItem_Click) ),
                CreateMenuGroup("Updates...", new MenuItem[] {\n                    CreateMenuItem("Check for Updates...", new EventHandler(this.checkUpdatesItem_Click)),\n                    new MenuItem("-"),\n                    this.autoCheckUpdatesToggleItem = CreateMenuItem("Check for Updates at Startup", new EventHandler(this.autoCheckUpdatesToggleItem_Click)),\n                    this.checkPreReleaseToggleItem = CreateMenuItem("Check Pre-release Version", new EventHandler(this.checkPreReleaseToggleItem_Click)),
                CreateMenuItem("About...", new EventHandler(this.AboutItem_Click)),
using Newtonsoft.Json;
using Shadowsocks.Properties;
using System.Linq;\nusing Shadowsocks.Controller.Service;\nusing Shadowsocks.Proxy;
            if (EnableStatusChanged != null)\n            {\n                EnableStatusChanged(this, new EventArgs());\n            }
            if (EnableGlobalChanged != null)\n            {\n                EnableGlobalChanged(this, new EventArgs());\n            }
            if (ShareOverLANStatusChanged != null)\n            {\n                ShareOverLANStatusChanged(this, new EventArgs());\n            }
            if (PACFileReadyToOpen != null)\n            {\n                PACFileReadyToOpen(this, new PathEventArgs() { Path = pacFilename });\n            }
            if (UserRuleFileReadyToOpen != null)\n            {\n                UserRuleFileReadyToOpen(this, new PathEventArgs() { Path = userRuleFilename });\n            }
            if (availabilityStatistics == null) return;\n            availabilityStatistics.UpdateConfiguration(this);\n            _config.availabilityStatistics = enabled;\n            SaveConfig(_config);
            if (ConfigChanged != null)\n            {\n                ConfigChanged(this, new EventArgs());\n            }
            if (ConfigChanged != null)\n            {\n                ConfigChanged(this, new EventArgs());\n            }
            if (ConfigChanged != null)\n            {\n                ConfigChanged(this, new EventArgs());\n            }
            if (ConfigChanged != null)\n            {\n                ConfigChanged(this, new EventArgs());\n            }
            if (ConfigChanged != null)\n            {\n                ConfigChanged(this, new EventArgs());\n            }
            if (ConfigChanged != null)\n            {\n                ConfigChanged(this, new EventArgs());\n            }
            if (ConfigChanged != null)\n            {\n                ConfigChanged(this, new EventArgs());\n            }
                List<Listener.IService> services = new List<Listener.IService>();\n                services.Add(tcpRelay);\n                services.Add(udpRelay);\n                services.Add(_pacServer);\n                services.Add(new PortForwarder(privoxyRunner.RunningPort));
                if (e is SocketException)\n                {\n                    SocketException se = (SocketException)e;
            _trafficThread = new Thread(new ThreadStart(() => TrafficStatistics(queueMaxSize)));\n            _trafficThread.IsBackground = true;
                current = new TrafficPerSecond();\n                current.inboundCounter = InboundCounter;\n                current.outboundCounter = OutboundCounter;
            if (length > 0)\n            {\n                // process first package\n                Array.Copy(firstPackge, index, _lineBuffer, 0, length);\n                _bufferDataLength = length;\n                try\n                {\n                    NewPackageRecv();\n                }\n                catch (Exception ex)\n                {\n                    OnException(ex);\n                    OnFinish();\n                }\n            }\n            else\n            {\n                // start reading\n                socket.BeginReceive(_lineBuffer, 0, maxLineBytes, 0, ReceiveCallback, 0);\n            }\n        }\n        public LineReader(WrappedSocket socket, Func<string, object, bool> onLineRead,\n            Action<Exception, object> onException,\n            Action<byte[], int, int, object> onFinish, Encoding encoding, string delimiter, int maxLineBytes,\n            object state)\n            : this(socket, null, 0, 0, onLineRead, onException, onFinish, encoding, delimiter, maxLineBytes, state)\n        {
                    OnFinish();
                _bufferDataLength += bytesRead;\n                NewPackageRecv();
                OnFinish();\n            }\n        }\n        private void NewPackageRecv()\n        {\n            int i;\n            while ((i = IndexOf(_lineBuffer, _bufferDataIndex, _bufferDataLength, _delimiterBytes, _delimiterSearchOffsetTable,\n                       _delimiterSearchCharTable)) != -1)\n            {\n                var decodeLen = i - _bufferDataIndex;\n                string line = _encoding.GetString(_lineBuffer, _bufferDataIndex, decodeLen);\n                _bufferDataIndex = i + _delimiterBytes.Length;\n                _bufferDataLength -= decodeLen;\n                _bufferDataLength -= _delimiterBytes.Length;\n                var stop = _onLineRead(line, _state);\n                if (stop)\n                {\n                    OnFinish();\n                    return;\n                }\n            }\n            if (_bufferDataLength == _lineBuffer.Length)\n            {\n                OnException(new IndexOutOfRangeException("LineBuffer full! Try increace maxLineBytes!"));\n                OnFinish();\n                return;\n            }\n            if (_bufferDataIndex > 0)\n            {\n                Buffer.BlockCopy(_lineBuffer, _bufferDataIndex, _lineBuffer, 0, _bufferDataLength);\n                _bufferDataIndex = 0;\n            }\n            _socket.BeginReceive(_lineBuffer, _bufferDataLength, _lineBuffer.Length - _bufferDataLength, 0, ReceiveCallback, _bufferDataLength);
        private void OnFinish()\n        {\n            _onFinish?.Invoke(_lineBuffer, _bufferDataIndex, _bufferDataLength, _state);
        private static int IndexOf(byte[] haystack, int index, int length, byte[] needle, int[] offsetTable, int[] charTable)
            catch (Exception)
            private EndPoint _remoteEndPoint;
                _remoteEndPoint = SocketUtil.GetEndPoint(server.server, server.server_port);\n                _remote = SocketUtil.CreateSocket(_remoteEndPoint, ProtocolType.Udp);
                            iconCopy.SetPixel(x, y, Color.FromArgb(color.A, 234, 67, 53));
                            iconCopy.SetPixel(x, y, Color.FromArgb(color.A, 52, 168, 83));
                            iconCopy.SetPixel(x, y, Color.FromArgb(color.A, 251, 188, 5));
            var IP = Dns.GetHostAddresses(server.server).First(ip => (ip.AddressFamily == AddressFamily.InterNetwork || ip.AddressFamily == AddressFamily.InterNetworkV6));\n            var ping = new Ping();
            foreach (var timestamp in Enumerable.Range(0, Repeat).Select(_ => DateTime.Now.ToString(DateTimePattern)))\n            {\n                //ICMP echo. we can also set options and special bytes\n                try\n                {\n                    var reply = await ping.SendTaskAsync(IP, Timeout);\n                    ret.Add(new List<KeyValuePair<string, string>>
                    Thread.Sleep(Timeout + new Random().Next() % Timeout);\n                    //Do ICMPTest in a random frequency\n                }\n                catch (Exception e)\n                {\n                    Logging.Error($"An exception occured while eveluating {server.FriendlyName()}");\n                    Logging.LogUsefulException(e);\n                }
            SocketUtil.BeginConnectTcp(destEndPoint, callback, state);
            _remote = SocketUtil.EndConnectTcp(asyncResult);
using System.Collections.Generic;\nusing System.Linq;
using Shadowsocks.Util;
            _remote?.Close();
                _remote = SocketUtil.EndConnectTcp(ar);
        private void EnableItem_Click(object sender, EventArgs e)
            EnableItem.Checked = !EnableItem.Checked;\n            if (EnableItem.Checked)
        internal static string proxy_pac {
                return ResourceManager.GetString("proxy_pac", resourceCulture);
                string pac = Resources.proxy_pac;
            this.contextMenuStrip1 = new System.Windows.Forms.ContextMenuStrip(this.components);\n            this.ConfigItem = new System.Windows.Forms.ToolStripMenuItem();\n            this.aboutToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();\n            this.toolStripSeparator2 = new System.Windows.Forms.ToolStripSeparator();\n            this.QuitItem = new System.Windows.Forms.ToolStripMenuItem();
            this.EnableItem = new System.Windows.Forms.ToolStripMenuItem();
            this.contextMenuStrip1.SuspendLayout();
            this.notifyIcon1.ContextMenuStrip = this.contextMenuStrip1;
            // \n            // contextMenuStrip1\n            // \n            this.contextMenuStrip1.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {\n            this.EnableItem,\n            this.ConfigItem,\n            this.aboutToolStripMenuItem,\n            this.toolStripSeparator2,\n            this.QuitItem});\n            this.contextMenuStrip1.Name = "contextMenuStrip1";\n            this.contextMenuStrip1.RenderMode = System.Windows.Forms.ToolStripRenderMode.System;\n            this.contextMenuStrip1.Size = new System.Drawing.Size(153, 120);\n            // \n            // ConfigItem\n            // \n            this.ConfigItem.Name = "ConfigItem";\n            this.ConfigItem.Size = new System.Drawing.Size(152, 22);\n            this.ConfigItem.Text = "Config";\n            this.ConfigItem.Click += new System.EventHandler(this.Config_Click);\n            // \n            // aboutToolStripMenuItem\n            // \n            this.aboutToolStripMenuItem.Name = "aboutToolStripMenuItem";\n            this.aboutToolStripMenuItem.Size = new System.Drawing.Size(152, 22);\n            this.aboutToolStripMenuItem.Text = "About";\n            this.aboutToolStripMenuItem.Click += new System.EventHandler(this.aboutToolStripMenuItem_Click);\n            // \n            // toolStripSeparator2\n            // \n            this.toolStripSeparator2.Name = "toolStripSeparator2";\n            this.toolStripSeparator2.Size = new System.Drawing.Size(149, 6);\n            // \n            // QuitItem\n            // \n            this.QuitItem.Name = "QuitItem";\n            this.QuitItem.Size = new System.Drawing.Size(152, 22);\n            this.QuitItem.Text = "Quit";\n            this.QuitItem.Click += new System.EventHandler(this.Quit_Click);
        private System.Windows.Forms.ContextMenuStrip contextMenuStrip1;\n        private System.Windows.Forms.ToolStripMenuItem ConfigItem;\n        private System.Windows.Forms.ToolStripMenuItem QuitItem;\n        private System.Windows.Forms.ToolStripMenuItem aboutToolStripMenuItem;\n        private System.Windows.Forms.ToolStripSeparator toolStripSeparator2;
        private System.Windows.Forms.ToolStripMenuItem EnableItem;
            this.configItem = new System.Windows.Forms.MenuItem();
            this.tableLayoutPanel1.Location = new System.Drawing.Point(22, 12);
            // configItem\n            // \n            this.configItem.Index = 1;\n            this.configItem.Text = "Options...";\n            this.configItem.Click += new System.EventHandler(this.Config_Click);\n            // \n            // Form1
        private void showPACUrlForm()\n        {\n            if (pacUrlForm != null)\n            {\n                pacUrlForm.Activate();\n            }\n            else\n            {\n                pacUrlForm = new PACUrlForm(controller);\n                pacUrlForm.Show();\n                pacUrlForm.FormClosed += pacUrlForm_FormClosed;\n            }\n        }\n        private void pacUrlForm_FormClosed(object sender, FormClosedEventArgs e)\n        {\n            pacUrlForm = null;\n            Util.Utils.ReleaseMemory();\n            ShowFirstTimeBalloon();\n        }
            showPACUrlForm();
                if (UpdateCompleted != null)\n                {\n                    UpdateCompleted(this, new ResultEventArgs(true));\n                }
                if (Error != null)\n                {\n                    Error(this, new ErrorEventArgs(ex));\n                }
﻿using Shadowsocks.Properties;\nusing System;
using System.Text;\nusing System.Text.RegularExpressions;
            if (System.Globalization.CultureInfo.CurrentCulture.IetfLanguageTag.ToLowerInvariant().StartsWith("zh"))
                string[] lines = Regex.Split(Resources.cn, "\r\n|\r|\n");\n                foreach (string line in lines)
                    if (line.StartsWith("#"))
                        continue;\n                    }\n                    string[] kv = Regex.Split(line, "=");\n                    if (kv.Length == 2)\n                    {\n                        Strings[kv[0]] = kv[1];
                    if (item == Key)
                    else if (item == "Shadowsocks") // Compatibility with older versions
                        if (path.Equals(value, StringComparison.InvariantCultureIgnoreCase))
            Socket conn = (Socket)ar.AsyncState;
                string proxy = "PROXY " + localEndPoint.Address + ":8123;";
                    local_port = int.Parse(ProxyPortTextBox.Text),
        private Server _server;
            this._server = config.GetCurrentServer();
                    localEndPoint = new IPEndPoint(IPAddress.Any, _server.local_port);
                    localEndPoint = new IPEndPoint(IPAddress.Loopback, _server.local_port);
                bool parsed = IPAddress.TryParse(config.server, out ipAddress);
                    IPHostEntry ipHostInfo = Dns.GetHostEntry(config.server);
                IPEndPoint remoteEP = new IPEndPoint(ipAddress, config.server_port);
using System.Collections;
using System.Net.Http;
using Newtonsoft.Json;\nusing Newtonsoft.Json.Linq;
    //TODO: change to singleton\n    public class AvailabilityStatistics
        private const int Timeout = 500;\n        private readonly TimeSpan DelayBeforeStart = TimeSpan.FromSeconds(1);
        private readonly ShadowsocksController _controller;
        public AvailabilityStatistics(ShadowsocksController controller)\n        {\n            _controller = controller;\n            _globalConfig = controller.GetCurrentConfiguration();\n            UpdateConfiguration(_globalConfig, controller.StatisticsConfiguration);\n        }
            if (server != _currentServer) return Empty;\n            return _outboundSpeed.ToString();
            if (server != _currentServer) return Empty;\n            return _inboundSpeed.ToString();
            _currentServer = _globalConfig.GetCurrentServer();
        internal void UpdateConfiguration(Configuration config, StatisticsStrategyConfiguration statisticsConfig)\n        {\n            Set(statisticsConfig);\n            _servers = config.configs;
        }\n        private async void FilterRawStatistics()
                new Task(() => availabilityStatistics.UpdateLatency(server, (int)latency.TotalMilliseconds)).Start();
                new Task(() => availabilityStatistics.UpdateInboundCounter(server, n)).Start();
                new Task(() => availabilityStatistics.UpdateOutboundCounter(server, n)).Start();
                try\n                {\n                    _process.Kill();\n                    _process.WaitForExit();\n                }\n                catch (Exception e)\n                {\n                    Logging.LogUsefulException(e);\n                }
                _inboundSpeedRecords.GetOrAdd(id, new List<int> {inboundSpeed}).Add(inboundSpeed);
                _outboundSpeedRecords.GetOrAdd(id, new List<int> {outboundSpeed}).Add(outboundSpeed);
        }\n        private async Task<ICMPResult> ICMPTest(Server server)\n        {\n            Logging.Debug("Ping " + server.FriendlyName());\n            if (server.server == "") return null;\n            var result = new ICMPResult(server);\n            try\n            {\n                var IP =\n                    Dns.GetHostAddresses(server.server)\n                        .First(\n                            ip =>\n                                ip.AddressFamily == AddressFamily.InterNetwork ||\n                                ip.AddressFamily == AddressFamily.InterNetworkV6);\n                var ping = new Ping();\n                foreach (var _ in Enumerable.Range(0, Repeat))\n                {\n                    try\n                    {\n                        var reply = await ping.SendTaskAsync(IP, TimeoutMilliseconds);\n                        if (reply.Status.Equals(IPStatus.Success))\n                        {\n                            result.RoundtripTime.Add((int?) reply.RoundtripTime);\n                        }\n                        else\n                        {\n                            result.RoundtripTime.Add(null);\n                        }\n                        //Do ICMPTest in a random frequency\n                        Thread.Sleep(TimeoutMilliseconds + new Random().Next()%TimeoutMilliseconds);\n                    }\n                    catch (Exception e)\n                    {\n                        Logging.Error($"An exception occured while eveluating {server.FriendlyName()}");\n                        Logging.LogUsefulException(e);\n                    }\n                }\n            }\n            catch (Exception e)\n            {\n                Logging.Error($"An exception occured while eveluating {server.FriendlyName()}");\n                Logging.LogUsefulException(e);\n            }\n            return result;
            Save();
            FilterRawStatistics();\n        }\n        private async void UpdateRecords()
            }\n            if (Config.Ping)\n            {\n                var icmpResults = await TaskEx.WhenAll(_controller.GetCurrentConfiguration().configs.Select(ICMPTest));\n                foreach (var result in icmpResults.Where(result => result != null))\n                {\n                    records[result.Server.Identifier()].SetResponse(result.RoundtripTime);\n                }\n            }\n            foreach (var kv in records.Where(kv => !kv.Value.IsEmptyData()))\n            {\n                AppendRecord(kv.Key, kv.Value);
            List<StatisticsRecord> records;\n            if (!RawStatistics.TryGetValue(serverIdentifier, out records))\n            {\n                records = new List<StatisticsRecord>();\n            }\n            records.Add(record);\n            RawStatistics[serverIdentifier] = records;
                var content = JsonConvert.SerializeObject(RawStatistics, Formatting.None);
        }\n        private class ICMPResult\n        {\n            internal readonly List<int?> RoundtripTime = new List<int?>();\n            internal readonly Server Server;\n            internal ICMPResult(Server server)\n            {\n                Server = server;\n            }
            List<int> records;\n            _latencyRecords.TryGetValue(server.Identifier(), out records);\n            if (records == null)\n            {\n                records = new List<int>();\n            }\n            records.Add(latency);\n            _latencyRecords[server.Identifier()] = records;
            long count;\n            if (_inboundCounter.TryGetValue(server.Identifier(), out count))\n            {\n                count += n;\n            }\n            else\n            {\n                count = n;\n                _lastInboundCounter[server.Identifier()] = 0;\n            }\n            _inboundCounter[server.Identifier()] = count;
            long count;\n            if (_outboundCounter.TryGetValue(server.Identifier(), out count))\n            {\n                count += n;\n            }\n            else\n            {\n                count = n;\n                _lastOutboundCounter[server.Identifier()] = 0;\n            }\n            _outboundCounter[server.Identifier()] = count;
                Logging.OpenLogFile();
#else\n                Logging.OpenLogFile();
                SystemProxy.Update(_config, false);
                    SystemProxy.Update(_config, false);
    class PACServer : Listener.Service
                byte[] buf = new byte[2048];
                    buf
                conn.BeginReceive(buf, 0, 1024, 0,
                byte[] buffer = new byte[1024 * 1024];  // builtin pac gzip size: maximum 1M
                    n = input.Read(buffer, 0, buffer.Length);\n                    if (n == 0)
                        throw new IOException("can not decompress pac");
                    return System.Text.Encoding.UTF8.GetString(buffer, 0, n);
        public void BeginConnectDest(EndPoint destEndPoint, AsyncCallback callback, object state)
            string request = string.Format(HTTP_CONNECT_TEMPLATE, destEndPoint);
                    new AsyncSession<ServerTimer>(session, connectTimer));
                ProxyTypeComboBox.Enabled = false; 
            if(_modifiedConfiguration == null)
            var conf = controller.GetConfigurationCopy().proxy;\n            if (conf == null)\n                conf = new ProxyConfig();\n            conf.useProxy = UseProxyCheckBox.Checked;\n            conf.proxyServer = ProxyServerTextBox.Text;\n            int tmpProxyPort;\n            int.TryParse(ProxyPortTextBox.Text, out tmpProxyPort);\n            conf.proxyPort = tmpProxyPort;\n            controller.SaveProxyConfig(conf);
        public extern static void ss_sha1_hmac_ex(byte[] key, uint keylen,
                if (_disposed)\n                {\n                    return;\n                }
                if (_encryptCtx != IntPtr.Zero)\n                {\n                    MbedTLS.cipher_free(_encryptCtx);\n                    Marshal.FreeHGlobal(_encryptCtx);\n                    _encryptCtx = IntPtr.Zero;\n                }\n                if (_decryptCtx != IntPtr.Zero)\n                {\n                    MbedTLS.cipher_free(_decryptCtx);\n                    Marshal.FreeHGlobal(_decryptCtx);\n                    _decryptCtx = IntPtr.Zero;\n                }
            if (disposed)\n                return;
            disposed = true;
        public void Close()
            CloseHandle(handle);\n            handle = IntPtr.Zero;
            if (inboundSpeedRecords != null && inboundSpeedRecords.Any())
                AverageInboundSpeed = (int) inboundSpeedRecords.Average();\n                MinInboundSpeed = inboundSpeedRecords.Min();\n                MaxInboundSpeed = inboundSpeedRecords.Max();
            if (outboundSpeedRecords != null && outboundSpeedRecords.Any())
                AverageOutboundSpeed = (int) outboundSpeedRecords.Average();\n                MinOutboundSpeed = outboundSpeedRecords.Min();\n                MaxOutboundSpeed = outboundSpeedRecords.Max();
            if (latencyRecords != null && latencyRecords.Any())
                AverageLatency = (int) latencyRecords.Average();\n                MinLatency = latencyRecords.Min();\n                MaxLatency = latencyRecords.Max();
                                PackageLossPercentage = (dataGroup.Average(data => data.PackageLoss) ?? 0) * 100
            foreach (var data in finalData)
using System.Text;\nusing Shadowsocks.Model;\nusing System.IO;
using System.Windows.Forms;
using Timer = System.Threading.Timer;
    using DataUnit = KeyValuePair<string, string>;\n    using DataList = List<KeyValuePair<string, string>>;
        private Dictionary<string, List<StatisticsRawData>> _rawStatistics;
        private const int RetryInterval = 2*60*1000; //retry 2 minutes after failed
            try\n            {\n                var path = AvailabilityStatistics.AvailabilityStatisticsFile;\n                Logging.Debug($"loading statistics from {path}");\n                if (!File.Exists(path))\n                {\n                    LogWhenEnabled($"statistics file does not exist, try to reload {RetryInterval/60/1000} minutes later");\n                    _timer.Change(RetryInterval, ChoiceKeptMilliseconds);\n                    return;\n                }\n                _rawStatistics = (from l in File.ReadAllLines(path)\n                    .Skip(1)\n                    let strings = l.Split(new[] {","}, StringSplitOptions.RemoveEmptyEntries)\n                    let rawData = new StatisticsRawData\n                    {\n                        Timestamp = strings[0],\n                        ServerName = strings[1],\n                        ICMPStatus = strings[2],\n                        RoundtripTime = int.Parse(strings[3]),\n                        Geolocation = 5 > strings.Length ?\n                        null \n                        : strings[4],\n                        ISP = 6 > strings.Length ? null : strings[5]\n                    }\n                    group rawData by rawData.ServerName into server\n                    select new\n                    {\n                        ServerName = server.Key,\n                        data = server.ToList()\n                    }).ToDictionary(server => server.ServerName, server=> server.data);\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n            }
        private float GetScore(IEnumerable<StatisticsRawData> rawDataList)
            if (config.ByIsp)\n            {\n                var current = AvailabilityStatistics.GetGeolocationAndIsp().Result;\n                rawDataList = rawDataList.Where(data => data.Geolocation == current[0].Value || data.Geolocation == AvailabilityStatistics.State.Unknown);\n                rawDataList = rawDataList.Where(data => data.ISP == current[1].Value || data.ISP == AvailabilityStatistics.State.Unknown);\n                if (rawDataList.LongCount() == 0) return 0; \n            }\n            if (config.ByHourOfDay)\n            {\n                var currentHour = DateTime.Now.Hour;\n                rawDataList = rawDataList.Where(data =>\n                {\n                    DateTime dateTime;\n                    DateTime.TryParseExact(data.Timestamp, AvailabilityStatistics.DateTimePattern, null,\n                        DateTimeStyles.None, out dateTime);\n                    var result = dateTime.Hour.Equals(currentHour);\n                    return result;\n                });\n                if (rawDataList.LongCount() == 0) return 0; \n            }\n            var dataList = rawDataList as IList<StatisticsRawData> ?? rawDataList.ToList();\n            var serverName = dataList[0]?.ServerName;
            var statisticsData = new StatisticsData()
        class StatisticsRawData\n        {\n            public string Timestamp;\n            public string ServerName;\n            public string ICMPStatus;\n            public int RoundtripTime;\n            public string Geolocation;\n            public string ISP ;\n        }\n        public class StatisticsData\n        {\n            public float PackageLoss;\n            public int AverageResponse;\n            public int MinResponse;\n            public int MaxResponse;\n        }
            if (_rawStatistics == null || servers.Count == 0)
                                  where _rawStatistics.ContainsKey(name)
                                      score = GetScore(_rawStatistics[name])
using SimpleJson;
using System.Windows.Forms;
using Timer = System.Threading.Timer;
    internal class AvailabilityStatistics
            this.bindingConfiguration = new System.Windows.Forms.BindingSource(this.components);
            foreach (string method in AEADMbedTLSEncryptor.SupportedCiphers())
            foreach (string method in AEADSodiumEncryptor.SupportedCiphers())
                    new AsyncCallback(ConnectCallback), null);\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);
            if (closed)\n            {\n                return;\n            }\n            try\n            {
                controller.GetCurrentStrategy().UpdateLatency(this.server, latency);
            catch (Exception e)\n            {\n                controller.GetCurrentStrategy().SetFailure(this.server);\n                Logging.LogUsefulException(e);\n                if (retryCount < 3)\n                {\n                    Console.WriteLine("Connection failed, retrying");\n                    StartConnect();\n                    retryCount++;\n                }\n                else\n                {\n                    this.Close();\n                }
            var defulatValue = registry.GetValue("DefaultConnectionSettings");\n            var connections = registry.GetValueNames();\n            foreach (String each in connections){\n                if (!(each.Equals("DefaultConnectionSettings")\n                    || each.Equals("LAN Connection")\n                    || each.Equals("SavedLegacySettings")))
                    //set all the connections's proxy as the lan\n                    registry.SetValue(each, defulatValue);
            NotifyIE();
                using (Graphics g = Graphics.FromImage(bmpScreenCapture))
                                     bmpScreenCapture.Size,
                resultPoints.Clear();\n             /*   var reader = new BarcodeReader
                var result = barcodeReader.Decode(image);\n                var timerStart = DateTime.Now.Ticks;\n                var timerStop = DateTime.Now.Ticks;\n                if (result == null)
                    txtDecoderContent.Text = "No barcode recognized";
                labDuration.Text = new TimeSpan(timerStop - timerStart).Milliseconds.ToString("0 ms");\n            }\n         }\n             * */
            catch (IOException)
                    password = "barfoo!"
            reload(config);
        private void button1_Click(object sender, EventArgs e)
            reload(Config.Load());
        private void button2_Click(object sender, EventArgs e)
            this.button2.Click += new System.EventHandler(this.button2_Click);
            this.button1.Click += new System.EventHandler(this.button1_Click);
            this.contextMenuStrip1.ShowImageMargin = false;\n            this.contextMenuStrip1.Size = new System.Drawing.Size(86, 48);
            Logging.Info("Current language is: " + CultureInfo.CurrentCulture.Name);\n            Init(i18n, CultureInfo.CurrentCulture.Name);
        public byte[] remoteRecvBuffer = new byte[RecvSize];
        public byte[] remoteSendBuffer = new byte[BufferSize];
        public byte[] connetionRecvBuffer = new byte[RecvSize];
        public byte[] connetionSendBuffer = new byte[BufferSize];
        public StringBuilder sb = new StringBuilder();
            this.tableLayoutPanel4.RowCount = 1;
            this.tableLayoutPanel4.Size = new System.Drawing.Size(166, 32);
            _config.GetCurrentServer().bandwidthIn = inboundCounter;
            _config.GetCurrentServer().bandwidthOut = outboundCounter;
            inboundCounter = _config.GetCurrentServer().bandwidthIn;\n            outboundCounter = _config.GetCurrentServer().bandwidthOut;
            private IPEndPoint _remoteEndPoint;
                // TODO async resolving\n                IPAddress ipAddress;\n                bool parsed = IPAddress.TryParse(server.server, out ipAddress);\n                if (!parsed)\n                {\n                    IPHostEntry ipHostInfo = Dns.GetHostEntry(server.server);\n                    ipAddress = ipHostInfo.AddressList[0];\n                }\n                _remoteEndPoint = new IPEndPoint(ipAddress, server.server_port);\n                _remote = new Socket(_remoteEndPoint.AddressFamily, SocketType.Dgram, ProtocolType.Udp);
            EndPoint realEndPoint = DestEndPoint = destEndPoint;\n            /*\n             * On windows vista or later, dual-mode socket is supported, so that\n             * we don't need to resolve a DnsEndPoint manually.\n             * We could just create a dual-mode socket and pass the DnsEndPoint\n             * directly to it's BeginConnect and the system will handle it correctlly\n             * so that we won't worry about async resolving any more.\n             * \n             * see: https://blogs.msdn.microsoft.com/webdev/2013/01/08/dual-mode-sockets-never-create-an-ipv4-socket-again/\n             * \n             * But it seems that we can't use this feature because DnsEndPoint\n             * doesn't have a specific AddressFamily before it has been\n             * resolved (we don't know whether it's ipv4 or ipv6) and we don't have\n             * a dual-mode socket to use on windows xp :(\n             */\n            var dep = realEndPoint as DnsEndPoint;\n            if (dep != null)\n            {\n                // need to resolve manually\n                // TODO async resolving\n                IPHostEntry ipHostInfo = Dns.GetHostEntry(dep.Host);\n                IPAddress ipAddress = ipHostInfo.AddressList[0];\n                realEndPoint = new IPEndPoint(ipAddress, dep.Port);\n            }
                _remote = new Socket(realEndPoint.AddressFamily, SocketType.Stream, ProtocolType.Tcp);
            _remote.BeginConnect(realEndPoint, callback, state);
                IPEndPoint proxyEP;
                    IPAddress ipAddress;\n                    bool parsed = IPAddress.TryParse(_config.proxyServer, out ipAddress);\n                    if (!parsed)\n                    {\n                        /*\n                         * TODO really necessary to resolve a proxy's address? Maybe from local hosts?\n                         * also we may simplify it by using dual-mode socket with \n                         * the approach described in DirectConnect.BeginConnectDest\n                         */\n                        IPHostEntry ipHostInfo = Dns.GetHostEntry(_config.proxyServer);\n                        ipAddress = ipHostInfo.AddressList[0];\n                    }
                    proxyEP = new IPEndPoint(ipAddress, _config.proxyPort);
            LoadTrayIcon();
            _notifyIcon.Text = I18N.GetString("Shadowsocks");
            LoadTrayIcon();
            this.PasswordTextBox.UseSystemPasswordChar = true;
        private Bitmap icon_baseBitmap;\n        private Icon icon_base, icon_in, icon_out, icon_both, targetIcon;\n        private ContextMenu contextMenu1;
                newIcon = icon_base;\n            if (newIcon != this.targetIcon)\n            {\n                this.targetIcon = newIcon;
        private void UpdateTrayIcon()\n        {\n            int dpi;\n            Graphics graphics = Graphics.FromHwnd(IntPtr.Zero);\n            dpi = (int)graphics.DpiX;\n            graphics.Dispose();\n            icon_baseBitmap = null;\n            if (dpi < 97)\n            {\n                // dpi = 96;\n                icon_baseBitmap = Resources.ss16;\n            }\n            else if (dpi < 121)\n            {\n                // dpi = 120;\n                icon_baseBitmap = Resources.ss20;\n            }\n            else\n            {\n                icon_baseBitmap = Resources.ss24;\n            }
            // set Windows 10 Theme color (1903+)\n            currentWindowsThemeMode = Utils.GetWindows10SystemThemeSetting();\n            if (currentWindowsThemeMode == Utils.WindowsThemeMode.Light)\n                if (!global || !enabled)\n                    icon_baseBitmap = getDarkTrayIcon(icon_baseBitmap);\n            icon_baseBitmap = getTrayIconByState(icon_baseBitmap, enabled, global);\n            icon_base = Icon.FromHandle(icon_baseBitmap.GetHicon());\n            targetIcon = icon_base;\n            icon_in = Icon.FromHandle(AddBitmapOverlay(icon_baseBitmap, Resources.ssIn24).GetHicon());\n            icon_out = Icon.FromHandle(AddBitmapOverlay(icon_baseBitmap, Resources.ssOut24).GetHicon());\n            icon_both = Icon.FromHandle(AddBitmapOverlay(icon_baseBitmap, Resources.ssIn24, Resources.ssOut24).GetHicon());\n            _notifyIcon.Icon = targetIcon;
        private Bitmap getDarkTrayIcon(Bitmap originIcon)\n        {\n            Bitmap iconCopy = new Bitmap(originIcon);\n            for (int x = 0; x < iconCopy.Width; x++)\n            {\n                for (int y = 0; y < iconCopy.Height; y++)\n                {\n                    Color color = originIcon.GetPixel(x, y);\n                    if (color.A != 0)
                        Color flyBlue = Color.FromArgb(192, 0, 0, 0);\n                        // Multiply with flyBlue\n                        int red = color.R * flyBlue.R / 255;\n                        int green = color.G * flyBlue.G / 255;\n                        int blue = color.B * flyBlue.B / 255;\n                        int alpha = color.A;\n                        iconCopy.SetPixel(x, y, Color.FromArgb(alpha, red, green, blue));
                    else\n                    {\n                        iconCopy.SetPixel(x, y, Color.FromArgb(color.A, color.R, color.G, color.B));\n                    }\n                }\n            }\n            return iconCopy;\n        }\n        private Bitmap getTrayIconByState(Bitmap originIcon, bool enabled, bool global)\n        {\n            Bitmap iconCopy = new Bitmap(originIcon);\n            for (int x = 0; x < iconCopy.Width; x++)\n            {\n                for (int y = 0; y < iconCopy.Height; y++)\n                {\n                    Color color = originIcon.GetPixel(x, y);\n                    if (color.A != 0)\n                    {\n                        if (!enabled)\n                        {\n                            // Multiply with flyBlue\n                            Color flyBlue;\n                            if (currentWindowsThemeMode == Utils.WindowsThemeMode.Light)\n                                flyBlue = Color.FromArgb(128, 192, 192, 192); // Dark icon more transparent\n                            else\n                                flyBlue = Color.FromArgb(192, 192, 192, 192); // Light icon less transparent\n                            int red = color.R * flyBlue.R / 255;\n                            int green = color.G * flyBlue.G / 255;\n                            int blue = color.B * flyBlue.B / 255;\n                            int alpha = color.A * flyBlue.A / 255;\n                            iconCopy.SetPixel(x, y, Color.FromArgb(alpha, red, green, blue));\n                        }\n                        else if (global)\n                        {\n                            Color flyBlue = Color.FromArgb(25, 125, 191);\n                            // Multiply with flyBlue\n                            int red = color.R * flyBlue.R / 255;\n                            int green = color.G * flyBlue.G / 255;\n                            int blue = color.B * flyBlue.B / 255;\n                            iconCopy.SetPixel(x, y, Color.FromArgb(color.A, red, green, blue));\n                        }\n                    }\n                    else\n                    {\n                        iconCopy.SetPixel(x, y, Color.FromArgb(color.A, color.R, color.G, color.B));\n                    }\n                }\n            }\n            return iconCopy;\n        }\n        private Bitmap AddBitmapOverlay(Bitmap original, params Bitmap[] overlays)\n        {\n            Bitmap bitmap = new Bitmap(original.Width, original.Height, PixelFormat.Format64bppArgb);\n            Graphics canvas = Graphics.FromImage(bitmap);\n            canvas.DrawImage(original, new Point(0, 0));\n            foreach (Bitmap overlay in overlays)\n            {\n                canvas.DrawImage(new Bitmap(overlay, original.Size), new Point(0, 0));\n            }\n            canvas.Save();\n            return bitmap;
            WindowsThemeMode registData = WindowsThemeMode.Dark;
                RegistryKey reg_HKCU = Registry.CurrentUser;\n                RegistryKey reg_ThemesPersonalize = reg_HKCU.OpenSubKey(@"Software\Microsoft\Windows\CurrentVersion\Themes\Personalize", false);
                    if (Convert.ToInt32(reg_ThemesPersonalize.GetValue("SystemUsesLightTheme").ToString()) == 0) // 0:dark mode, 1:light mode\n                        registData = WindowsThemeMode.Dark;
                        registData = WindowsThemeMode.Light;\n                    //Console.WriteLine(registData);
                    Directory.CreateDirectory(Path.Combine(Application.StartupPath, "ss_win_temp"));\n                    // don't use "/", it will fail when we call explorer /select xxx/ss_win_temp\xxx.log\n                    _tempPath = Path.Combine(Application.StartupPath, "ss_win_temp");
            this.Font = System.Drawing.SystemFonts.MessageBoxFont;
            this.ServersListBox.Dock = System.Windows.Forms.DockStyle.Fill;
            this.RemarksLabel = new System.Windows.Forms.Label();
            | System.Windows.Forms.AnchorStyles.Right)));
            this.tableLayoutPanel5.Location = new System.Drawing.Point(272, 308);
            this.tableLayoutPanel5.RowCount = 1;
            try {\n                using (StreamWriter sw = new StreamWriter(File.Open(_userWininetConfigFile, FileMode.Create))) {
            try {\n                string configContent = File.ReadAllText(_userWininetConfigFile);
using System.Linq;
namespace Shadowsocks.Controller
        public ISet<TCPHandler> Handlers { get; set; }
            Handlers = new HashSet<TCPHandler>();
            if (socket.ProtocolType != ProtocolType.Tcp\n                || (length < 2 || firstPacket[0] != 5))
            TCPHandler handler = new TCPHandler(_controller, _config, this, socket);
    class TCPHandler
        class AsyncSession
        class AsyncSession<T> : AsyncSession
        private ShadowsocksController   _controller;\n        private Configuration           _config;\n        private TCPRelay                _tcprelay;\n        private Socket                  _connection;\n        private IEncryptor  _encryptor;\n        private Server      _server;
        private bool        _proxyConnected;\n        private bool        _destConnected;\n        private byte    _command;\n        private byte[]  _firstPacket;\n        private int     _firstPacketLength;\n        private int     _totalRead = 0;\n        private int     _totalWrite = 0;\n        private byte[]  _remoteRecvBuffer = new byte[BufferSize];\n        private byte[]  _remoteSendBuffer = new byte[BufferSize];\n        private byte[]  _connetionRecvBuffer = new byte[BufferSize];\n        private byte[]  _connetionSendBuffer = new byte[BufferSize];\n        private bool    _connectionShutdown = false;\n        private bool    _remoteShutdown = false;\n        private bool    _closed = false;\n        // instance-based lock without static\n        private readonly object  _encryptionLock = new object();\n        private readonly object  _decryptionLock = new object();\n        private readonly object  _closeConnLock = new object();
        public TCPHandler(ShadowsocksController controller, Configuration config, TCPRelay tcprelay, Socket socket)
        }\n        public void CreateRemote()\n        {\n            Server server = _controller.GetAServer(IStrategyCallerType.TCP, (IPEndPoint)_connection.RemoteEndPoint, _destEndPoint);
        private void StartPipe(AsyncSession session)\n        {\n            if (_closed) return;
                session.Remote.BeginReceive(_remoteRecvBuffer, 0, RecvSize, SocketFlags.None, new AsyncCallback(PipeRemoteReceiveCallback), session);\n                SendToServer(_firstPacketLength, session);
            session.Remote.BeginSend(_connetionSendBuffer, 0, bytesToSend, SocketFlags.None, new AsyncCallback(PipeRemoteSendCallback), session);
            if (_closed) return;
                session.Remote.EndSend(ar);\n                _connection.BeginReceive(_connetionRecvBuffer, 0, RecvSize, SocketFlags.None, new AsyncCallback(PipeConnectionReceiveCallback), session);\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void PipeConnectionSendCallback(IAsyncResult ar)\n        {\n            try\n            {\n                var session = (AsyncSession)ar.AsyncState;\n                _connection.EndSend(ar);\n                session.Remote.BeginReceive(_remoteRecvBuffer, 0, RecvSize, SocketFlags.None, new AsyncCallback(PipeRemoteReceiveCallback), session);
                services.Add(_pacServer);\n                services.Add(new Http2Socks5(_config.localPort));
            byte[] request = null;\n            byte atyp = 0;\n            int port;\n            var dep = destEndPoint as DnsEndPoint;\n            if (dep != null)\n            {\n                // is a domain name, we will leave it to server\n                atyp = 3; // DOMAINNAME\n                var enc = Encoding.UTF8;\n                var hostByteCount = enc.GetByteCount(dep.Host);\n                request = new byte[4 + 1/*length byte*/ + hostByteCount + 2];\n                request[4] = (byte)hostByteCount;\n                enc.GetBytes(dep.Host, 0, dep.Host.Length, request, 5);\n                port = dep.Port;\n            }\n            else\n            {\n                switch (DestEndPoint.AddressFamily)\n                {\n                    case AddressFamily.InterNetwork:\n                        request = new byte[4 + 4 + 2];\n                        atyp = 1; // IP V4 address\n                        break;\n                    case AddressFamily.InterNetworkV6:\n                        request = new byte[4 + 16 + 2];\n                        atyp = 4; // IP V6 address\n                        break;\n                    default:\n                        throw new Exception(I18N.GetString("Proxy request failed"));\n                }\n                port = ((IPEndPoint) DestEndPoint).Port;\n                var addr = ((IPEndPoint)DestEndPoint).Address.GetAddressBytes();\n                Array.Copy(addr, 0, request, 4, request.Length - 4 - 2);\n            }
            request[3] = atyp;\n            request[request.Length - 2] = (byte) ((port >> 8) & 0xff);\n            request[request.Length - 1] = (byte) (port & 0xff);
            int lpNames = 1;
            lpSize = lpNames * entryNameSize;\n            names = new RasEntryName[lpNames];\n            names[0].dwSize = entryNameSize;\n            retval = RAS.RasEnumEntries(null, null, names, ref lpSize, out lpNames);\n            //if we have more than one connection, we need to resize
                retval = RAS.RasEnumEntries(null, null, names, ref lpSize, out lpNames);
            int i = 0;
                items.Add(i, item);\n                i++;
            items.Add(i++, new MenuItem("-"));\n            int strategyCount = i;
                    item.Tag = i - strategyCount;
                    items.Add(i, item);\n                    i++;
                    this.ConfigItem = CreateMenuItem("Edit Servers...", new EventHandler(this.Config_Click))
                CreateMenuItem("Show QRCode...", new EventHandler(this.QRCodeItem_Click)),\n                CreateMenuItem("Scan QRCode...", new EventHandler(this.ScanQRCodeItem_Click)),
            items.Clear();
                items.Add(item);\n            }\n            items.Add(SeperatorItem);\n            items.Add(ConfigItem);
                    Console.WriteLine(result.Text);
            List<string> lines = GFWListUpdater.ParseResult(File.ReadAllText(Utils.GetTempPath("gfwlist.txt")));
                string local = File.ReadAllText(PACServer.USER_RULE_FILE, Encoding.UTF8);
            enableItem.Checked = controller.GetConfigurationCopy().enabled;\n            modeItem.Enabled = enableItem.Checked;
            controller.ToggleEnable(!enableItem.Checked);
                LogFile = Path.Combine(temppath, "shadowsocks.log");\n                FileStream fs = new FileStream(LogFile, FileMode.Append);
            local = new Local(config);\n            local.Start();
        private MenuItem CreateMenuItem(int index, string text, EventHandler click)
            result.Index = index;
        private MenuItem CreateSeperatorItem(int index)
            result.Index = index;
        private MenuItem CreateMenuGroup(int index, string text, MenuItem[] items)\n        {
            result.Index = index;
            this.PACModeItem = CreateMenuItem(0, "PAC", new System.EventHandler(this.PACModeItem_Click));\n            this.globalModeItem = CreateMenuItem(1, "Global", new System.EventHandler(this.GlobalModeItem_Click));\n            this.SeperatorItem = CreateSeperatorItem(0);\n            this.ConfigItem = CreateMenuItem(1, "Edit Servers...", new System.EventHandler(this.Config_Click));\n            this.enableItem = CreateMenuItem(0, "Enable", new System.EventHandler(this.EnableItem_Click));\n            this.ServersItem = CreateMenuGroup(2, "Servers", new System.Windows.Forms.MenuItem[] {\n                this.SeperatorItem,\n                this.ConfigItem
            this.AutoStartupItem = CreateMenuItem(4, "Start on Boot", new System.EventHandler(this.AutoStartupItem_Click));\n            this.ShareOverLANItem = CreateMenuItem(5, "Share over LAN", new System.EventHandler(this.ShareOverLANItem_Click));\n            this.contextMenu1.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {\n            this.enableItem,\n            CreateMenuGroup(1, "Mode", new System.Windows.Forms.MenuItem[] {\n                this.PACModeItem,\n                this.globalModeItem\n            }),\n            this.ServersItem,\n            CreateSeperatorItem(3),\n            this.AutoStartupItem,\n            this.ShareOverLANItem,\n            CreateMenuItem(6, "Edit PAC File...", new System.EventHandler(this.EditPACFileItem_Click)),\n            CreateSeperatorItem(7),\n            CreateMenuItem(8, "Show QRCode...", new System.EventHandler(this.QRCodeItem_Click)),\n            CreateMenuItem(9, "Show Logs...", new System.EventHandler(this.ShowLogItem_Click)),\n            CreateMenuItem(10, "About...", new System.EventHandler(this.Config_Click)),\n            CreateSeperatorItem(11),\n            CreateMenuItem(12, "Quit", new System.EventHandler(this.Quit_Click))});
                    int atyp = _connetionRecvBuffer[0];\n                    string dst_addr;\n                    int dst_port;\n                    switch (atyp)
                        case 1:  // IPv4 address, 4 bytes\n                            dst_addr = new IPAddress(_connetionRecvBuffer.Skip(1).Take(4).ToArray()).ToString();\n                            dst_port = (_connetionRecvBuffer[5] << 8) + _connetionRecvBuffer[6];\n                            if ( _config.isVerboseLogging ) {\n                                Logging.Info( $"connect to {dst_addr}:{dst_port}" );\n                            }\n                            break;\n                        case 3:  // domain name, length + str\n                            int len = _connetionRecvBuffer[1];\n                            dst_addr = System.Text.Encoding.UTF8.GetString(_connetionRecvBuffer, 2, len);\n                            dst_port = (_connetionRecvBuffer[len + 2] << 8) + _connetionRecvBuffer[len + 3];\n                            if ( _config.isVerboseLogging ) {\n                                Logging.Info( $"connect to {dst_addr}:{dst_port}" );\n                            }\n                            break;\n                        case 4:  // IPv6 address, 16 bytes\n                            dst_addr = new IPAddress(_connetionRecvBuffer.Skip(1).Take(16).ToArray()).ToString();\n                            dst_port = (_connetionRecvBuffer[17] << 8) + _connetionRecvBuffer[18];\n                            if ( _config.isVerboseLogging ) {\n                                Logging.Info( $"connect to [{dst_addr}]:{dst_port}" );\n                            }\n                            break;
        private static Logger logger = LogManager.GetCurrentClassLogger();
        // hidden\n        public bool isIPv6Enabled = false;
        // geosite config is hidden\n        public string geositeUrl;\n        public string geositeGroup = "geolocation-!cn";\n        public bool geositeBlacklistMode = true;
        // hidden config\n        public bool generateLegacyUrl = false;
        private static readonly NLogConfig.LogLevel verboseLogLevel =
        NLogConfig.LogLevel.Trace;
        NLogConfig.LogLevel.Debug;
using System.Reflection;
using Shadowsocks.Controller.Hotkeys;
using Shadowsocks.Util;
                RegHotkeyFromString(hotkeyConfig.SwitchSystemProxy, "SwitchSystemProxyCallback", SwitchSystemProxyLabel)\n                && RegHotkeyFromString(hotkeyConfig.SwitchSystemProxyMode, "SwitchSystemProxyModeCallback", SwitchProxyModeLabel)\n                && RegHotkeyFromString(hotkeyConfig.SwitchAllowLan, "SwitchAllowLanCallback", SwitchAllowLanLabel)\n                && RegHotkeyFromString(hotkeyConfig.ShowLogs, "ShowLogsCallback", ShowLogsLabel)\n                && RegHotkeyFromString(hotkeyConfig.ServerMoveUp, "ServerMoveUpCallback", ServerMoveUpLabel)\n                && RegHotkeyFromString(hotkeyConfig.ServerMoveDown, "ServerMoveDownCallback", ServerMoveDownLabel);
        private bool RegHotkeyFromString(string hotkeyStr, string callbackName, Label indicator = null)
            var _callback = HotkeyCallbacks.GetCallback(callbackName);\n            if (_callback == null)
                throw new Exception($"{callbackName} not found");\n            }\n            var callback = _callback as HotKeys.HotKeyCallBackHandler;\n            if (hotkeyStr.IsNullOrEmpty())\n            {\n                HotKeys.UnregExistingHotkey(callback);\n                if (indicator != null)\n                {\n                    indicator.ResetBackColor();\n                }\n                return true;\n            }\n            else\n            {\n                var hotkey = HotKeys.Str2HotKey(hotkeyStr);\n                if (hotkey == null)\n                {
                    return false;\n                }\n                else\n                {\n                    bool regResult = (HotKeys.RegHotkey(hotkey, callback));\n                    if (indicator != null)\n                    {\n                        indicator.BackColor = regResult ? Color.Green : Color.Yellow;\n                    }\n                    return regResult;\n                }
            if (config.autoCheckUpdate)
            }\n            if (config.isDefault)\n            {\n                _isFirstRun = true;\n                ShowConfigForm();
                _isFirstRun = false;
                _isFirstRun = false;
            if (_isFirstRun)\n            {\n                _notifyIcon.BalloonTipTitle = I18N.GetString("Shadowsocks is here");\n                _notifyIcon.BalloonTipText = I18N.GetString("You can turn on/off Shadowsocks in the context menu");\n                _notifyIcon.BalloonTipIcon = ToolTipIcon.Info;\n                _notifyIcon.ShowBalloonTip(0);\n                _isFirstRun = false;\n            }
            _oldSelectedIndex = _modifiedConfiguration.index;\n            if (_oldSelectedIndex < 0)\n            {\n                _oldSelectedIndex = 0;\n            }\n            ServersListBox.SelectedIndex = _oldSelectedIndex;
            _oldSelectedIndex = ServersListBox.SelectedIndex;\n            if (_oldSelectedIndex >= 0 && _oldSelectedIndex < _modifiedConfiguration.configs.Count)\n            {\n                _modifiedConfiguration.configs.RemoveAt(_oldSelectedIndex);\n            }\n            if (_oldSelectedIndex >= _modifiedConfiguration.configs.Count)
            int index = _modifiedConfiguration.index;
            controller.SelectServerIndex(index);
        static byte[] sodiumBuf = new byte[MAX_INPUT_SIZE + SODIUM_BLOCK_SIZE];
            // I'm tired. just add a big lock\n            // let's optimize for RAM instead of CPU\n            lock(sodiumBuf)
                if (isCipher)\n                {\n                    bytesRemaining = _encryptBytesRemaining;\n                    ic = _encryptIC;\n                    iv = _encryptIV;\n                }\n                else\n                {\n                    bytesRemaining = _decryptBytesRemaining;\n                    ic = _decryptIC;\n                    iv = _decryptIV;\n                }\n                int padding = bytesRemaining;\n                Buffer.BlockCopy(buf, 0, sodiumBuf, padding, length);\n                switch (_cipher)\n                {\n                    case CIPHER_SALSA20:\n                        Sodium.crypto_stream_salsa20_xor_ic(sodiumBuf, sodiumBuf, (ulong)(padding + length), iv, ic, _key);\n                        break;\n                    case CIPHER_CHACHA20:\n                        Sodium.crypto_stream_chacha20_xor_ic(sodiumBuf, sodiumBuf, (ulong)(padding + length), iv, ic, _key);\n                        break;\n                    case CIPHER_CHACHA20_IETF:\n                        Sodium.crypto_stream_chacha20_ietf_xor_ic(sodiumBuf, sodiumBuf, (ulong)(padding + length), iv, (uint)ic, _key);\n                        break;\n                }\n                Buffer.BlockCopy(sodiumBuf, padding, outbuf, 0, length);\n                padding += length;\n                ic += (ulong)padding / SODIUM_BLOCK_SIZE;\n                bytesRemaining = padding % SODIUM_BLOCK_SIZE;\n                if (isCipher)\n                {\n                    _encryptBytesRemaining = bytesRemaining;\n                    _encryptIC = ic;\n                }\n                else\n                {\n                    _decryptBytesRemaining = bytesRemaining;\n                    _decryptIC = ic;\n                }
﻿using shadowsocks_csharp.Model;\nusing shadowsocks_csharp.Properties;
namespace shadowsocks_csharp.Controller
﻿using shadowsocks_csharp.Properties;
namespace shadowsocks_csharp.Controller
﻿using shadowsocks_csharp.Model;
namespace shadowsocks_csharp.Controller
﻿using shadowsocks_csharp.Controller;\nusing shadowsocks_csharp.Properties;\nusing shadowsocks_csharp.View;
namespace shadowsocks_csharp
                ServersListBox.Items.Add(string.IsNullOrEmpty(server.server) ? "New server" : server.server);
            this.configItem,
            // configItem\n            // \n            this.configItem.Index = 1;\n            this.configItem.Text = "Options...";\n            this.configItem.Click += new System.EventHandler(this.Config_Click);
            this.editPACFileItem.Index = 2;\n            this.editPACFileItem.Text = "Edit PAC File...";
                services.Add(new PortForwarder(polipoRunner.RunningPort));
    class PolipoRunner
        static PolipoRunner()
                Process[] existingPolipo = Process.GetProcessesByName("ss_privoxy");\n                foreach (Process p in existingPolipo.Where(IsChildProcess))
                string polipoConfig = Resources.privoxy_conf;
                polipoConfig = polipoConfig.Replace("__SOCKS_PORT__", configuration.localPort.ToString());\n                polipoConfig = polipoConfig.Replace("__POLIPO_BIND_PORT__", _runningPort.ToString());\n                polipoConfig = polipoConfig.Replace("__POLIPO_BIND_IP__", configuration.shareOverLan ? "0.0.0.0" : "127.0.0.1");\n                FileManager.ByteArrayToFile(Utils.GetTempPath(UniqueConfigFile), Encoding.UTF8.GetBytes(polipoConfig));
                    if ((uint)ex.ErrorCode == 0x80004005)   // file not found
using System.Windows.Forms.DataVisualization.Charting;
using SimpleJson;\nusing System.Net.NetworkInformation;
                JsonArray result = (JsonArray)SimpleJson.SimpleJson.DeserializeObject(e.Result);
                foreach (JsonObject release in result)\n                {\n                    if ((bool)release["prerelease"])\n                    {\n                        continue;\n                    }\n                    foreach (JsonObject asset in (JsonArray)release["assets"])\n                    {\n                        Asset ass = new Asset();\n                        ass.Parse(asset);\n                        if (ass.IsNewVersion(Version))
                            asserts.Add(ass);
using System.Collections.Generic;
using System.IO;\nusing System.Diagnostics;\nusing SimpleJson;
using System.Text.RegularExpressions;
﻿using Shadowsocks.Controller;\nusing System;
using System.Text;\nusing System.Windows.Forms;\nusing SimpleJson;
    class Encryptor
        public const int TYPE_TABLE = 1;\n        public const int TYPE_RC4 = 2;
        public int method = TYPE_TABLE;\n        public RC4 rc4 = null;
                this.method = TYPE_RC4;
            } else {
                this.method = TYPE_TABLE;
        }\n        public void Encrypt(byte[] buf, int length)
                case TYPE_TABLE:
                    break;\n                case TYPE_RC4:
                    break;\n            }\n        }\n        public void Decrypt(byte[] buf, int length)
                case TYPE_TABLE:
                    break;\n                case TYPE_RC4:
                    break;
            catch (Exception)
                MessageBox.Show("there is some problem with parameters");
            connection.Close();
                remote.Close();\n            }
        public static Sip003Plugin CreateIfConfigured(Server server)
            return new Sip003Plugin(server.plugin, server.plugin_opts, server.plugin_args, server.server, server.server_port);
        private Sip003Plugin(string plugin, string pluginOpts, string pluginArgs, string serverAddress, int serverPort)
            Local local = new Local(1081);\n            local.Start();
            local.Stop();
            this.Config,\n            this.Quit});
            // Config\n            // \n            this.Config.Name = "Config";\n            this.Config.Size = new System.Drawing.Size(127, 22);\n            this.Config.Text = "Config";\n            this.Config.Click += new System.EventHandler(this.Config_Click);\n            // \n            // Quit\n            // \n            this.Quit.Name = "Quit";\n            this.Quit.Size = new System.Drawing.Size(127, 22);\n            this.Quit.Text = "Quit";\n            this.Quit.Click += new System.EventHandler(this.Quit_Click);
            var jsonString = await new HttpClient().GetStringAsync(api);
                await geolocationAndIsp;\n                foreach (var dataList in dataLists)
            }\n            if (_availabilityStatics == null)\n            {\n                _availabilityStatics = new AvailabilityStatistics();\n                _availabilityStatics.UpdateConfiguration(_config);
    public partial class Form1 : Form
        public Form1()
                    byte[] response = { 5, 0, 0, 1, 0, 0, 0, 0, 0, 0 };\n                    connection.BeginSend(response, 0, response.Length, 0, new AsyncCallback(StartConnect), null);
        public static void SetIEProxy(bool enable, bool global, string proxyServer, string pacURL)
                        Value = { dwValue = (int)INTERNET_OPTION_PER_CONN_FLAGS_UI.PROXY_TYPE_PROXY }
                        Value = { pszValue = Marshal.StringToHGlobalAnsi(proxyServer) }
                        Value = { pszValue = Marshal.StringToHGlobalAnsi("<local>") }
            NativeMethods.InternetSetOption(
                INTERNET_OPTION.INTERNET_OPTION_SETTINGS_CHANGED,
            NativeMethods.InternetSetOption(
﻿using System.Collections.Generic;
using Shadowsocks.Properties;\nusing Shadowsocks.Util;
using Microsoft.VisualBasic.FileIO;\nusing System.Text;
        const string DLLNAME2 = "libsscrypto2";
        {\n            LoadSSCryptoLibrary();\n            LoadSSCrypto2Library();\n        }\n        static void LoadSSCryptoLibrary()
                LoadLibrary(dllPath);
        }\n        static void LoadSSCrypto2Library()\n        {\n            string tempPath = Utils.GetTempPath();\n            string dllPath = tempPath + "/libsscrypto2.dll";\n            try\n            {\n                FileManager.UncompressFile(dllPath, Resources.libsscrypto2_dll);\n                LoadLibrary(dllPath);\n            }\n            catch (IOException)\n            {\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine(e.ToString());\n            }
        public extern static void crypto_stream_salsa20_xor_ic(byte[] c, byte[] m, ulong mlen, byte[] n, ulong ic, byte[] k);
        public extern static void crypto_stream_chacha20_xor_ic(byte[] c, byte[] m, ulong mlen, byte[] n, ulong ic, byte[] k);\n        [DllImport(DLLNAME2, CallingConvention = CallingConvention.Cdecl)]
            _remote?.BeginSend(buffer, offset, size, socketFlags, callback, state);
            _remote?.BeginReceive(buffer, offset, size, socketFlags, callback, state);
            _remote?.Shutdown(how);
            _remote?.Dispose();
            this.QRCodeWebBrowser.Dock = System.Windows.Forms.DockStyle.Fill;
            this.ClientSize = new System.Drawing.Size(184, 182);
        private byte[] _encryptCtx;\n        private byte[] _decryptCtx;
        private int _encryptIVOffset;\n        private int _decryptIVOffset;
        private void InitCipher(ref byte[] ctx, byte[] iv, bool isCipher)\n        {\n            ctx = new byte[_cipherInfo[3]];\n            lock (ctx)\n            {\n                byte[] realkey;\n                if (_method == "rc4-md5")\n                {\n                    byte[] temp = new byte[keyLen + ivLen];\n                    realkey = new byte[keyLen];\n                    Array.Copy(_key, 0, temp, 0, keyLen);\n                    Array.Copy(iv, 0, temp, keyLen, ivLen);\n                    realkey = MD5.Create().ComputeHash(temp);
                    realkey = _key;\n                }\n                if (_cipher == CIPHER_AES)\n                {\n                    PolarSSL.aes_init(ctx);\n                    // PolarSSL takes key length by bit\n                    // since we'll use CFB mode, here we both do enc, not dec\n                    PolarSSL.aes_setkey_enc(ctx, realkey, keyLen * 8);\n                    if (isCipher)\n                    {\n                        _encryptIV = new byte[ivLen];\n                        Array.Copy(iv, _encryptIV, ivLen);\n                    }\n                    else\n                    {\n                        _decryptIV = new byte[ivLen];\n                        Array.Copy(iv, _decryptIV, ivLen);\n                    }\n                }\n                else if (_cipher == CIPHER_BF)\n                {\n                    PolarSSL.blowfish_init(ctx);\n                    // PolarSSL takes key length by bit\n                    PolarSSL.blowfish_setkey(ctx, realkey, keyLen * 8);\n                    if (isCipher)\n                    {\n                        _encryptIV = new byte[ivLen];\n                        Array.Copy(iv, _encryptIV, ivLen);\n                    }\n                    else\n                    {\n                        _decryptIV = new byte[ivLen];\n                        Array.Copy(iv, _decryptIV, ivLen);\n                    }\n                }\n                else if (_cipher == CIPHER_RC4)\n                {\n                    PolarSSL.arc4_init(ctx);\n                    PolarSSL.arc4_setup(ctx, realkey, keyLen);\n                }
            if (_encryptCtx == null)
                    lock (_encryptCtx)\n                    {\n                        if (_disposed)\n                        {\n                            throw new ObjectDisposedException(this.ToString());\n                        }\n                        switch (_cipher)\n                        {\n                            case CIPHER_AES:\n                                PolarSSL.aes_crypt_cfb128(_encryptCtx, PolarSSL.AES_ENCRYPT, length, ref _encryptIVOffset, _encryptIV, buf, tempbuf);\n                                break;\n                            case CIPHER_BF:\n                                PolarSSL.blowfish_crypt_cfb64(_encryptCtx, PolarSSL.BLOWFISH_ENCRYPT, length, ref _encryptIVOffset, _encryptIV, buf, tempbuf);\n                                break;\n                            case CIPHER_RC4:\n                                PolarSSL.arc4_crypt(_encryptCtx, length, buf, tempbuf);\n                                break;\n                        }\n                        outlength = length + ivLen;\n                        Buffer.BlockCopy(tempbuf, 0, outbuf, ivLen, length);\n                    }
                lock (_encryptCtx)\n                {\n                    if (_disposed)\n                    {\n                        throw new ObjectDisposedException(this.ToString());\n                    }\n                    switch (_cipher)\n                    {\n                        case CIPHER_AES:\n                            PolarSSL.aes_crypt_cfb128(_encryptCtx, PolarSSL.AES_ENCRYPT, length, ref _encryptIVOffset, _encryptIV, buf, outbuf);\n                            break;\n                        case CIPHER_BF:\n                            PolarSSL.blowfish_crypt_cfb64(_encryptCtx, PolarSSL.BLOWFISH_ENCRYPT, length, ref _encryptIVOffset, _encryptIV, buf, outbuf);\n                            break;\n                        case CIPHER_RC4:\n                            PolarSSL.arc4_crypt(_encryptCtx, length, buf, outbuf);\n                            break;\n                    }
            if (_decryptCtx == null)
                    lock (_decryptCtx)\n                    {\n                        if (_disposed)\n                        {\n                            throw new ObjectDisposedException(this.ToString());\n                        }\n                        switch (_cipher)\n                        {\n                            case CIPHER_AES:\n                                PolarSSL.aes_crypt_cfb128(_decryptCtx, PolarSSL.AES_DECRYPT, length - ivLen, ref _decryptIVOffset, _decryptIV, tempbuf, outbuf);\n                                break;\n                            case CIPHER_BF:\n                                PolarSSL.blowfish_crypt_cfb64(_decryptCtx, PolarSSL.BLOWFISH_DECRYPT, length - ivLen, ref _decryptIVOffset, _decryptIV, tempbuf, outbuf);\n                                break;\n                            case CIPHER_RC4:\n                                PolarSSL.arc4_crypt(_decryptCtx, length - ivLen, tempbuf, outbuf);\n                                break;\n                        }
                lock (_decryptCtx)\n                {\n                    if (_disposed)\n                    {\n                        throw new ObjectDisposedException(this.ToString());\n                    }\n                    switch (_cipher)\n                    {\n                        case CIPHER_AES:\n                            PolarSSL.aes_crypt_cfb128(_decryptCtx, PolarSSL.AES_DECRYPT, length, ref _decryptIVOffset, _decryptIV, buf, outbuf);\n                            break;\n                        case CIPHER_BF:\n                            PolarSSL.blowfish_crypt_cfb64(_decryptCtx, PolarSSL.BLOWFISH_DECRYPT, length, ref _decryptIVOffset, _decryptIV, buf, outbuf);\n                            break;\n                        case CIPHER_RC4:\n                            PolarSSL.arc4_crypt(_decryptCtx, length, buf, outbuf);\n                            break;\n                    }
        public extern static void aes_init(byte[] ctx);
        public extern static void aes_free(byte[] ctx);
        public extern static int aes_setkey_enc(byte[] ctx, byte[] key, int keysize);
        public extern static int aes_crypt_cfb128(byte[] ctx, int mode, int length, ref int iv_off, byte[] iv, byte[] input, byte[] output);
        public extern static void arc4_init(byte[] ctx);
        public extern static void arc4_free(byte[] ctx);
        public extern static void arc4_setup(byte[] ctx, byte[] key, int keysize);
        public extern static int arc4_crypt(byte[] ctx, int length, byte[] input, byte[] output);
        public extern static void blowfish_init(byte[] ctx);
        public extern static void blowfish_free(byte[] ctx);
        public extern static int blowfish_setkey(byte[] ctx, byte[] key, int keysize);
        public extern static int blowfish_crypt_cfb64(byte[] ctx, int mode, int length, ref int iv_off, byte[] iv, byte[] input, byte[] output);
                        lock (locker)\n                        {\n                            encryptor = new PolarSSLEncryptor("aes-256-cfb", "barfoo!");\n                            decryptor = new PolarSSLEncryptor("aes-256-cfb", "barfoo!");\n                        }
                        Assert.AreEqual(12333, outLen2);\n                        for (int j = 0; j < plain.Length; j++)\n                        {\n                            Assert.AreEqual(plain[j], plain2[j]);\n                        }
using System.Text.RegularExpressions;\nusing Shadowsocks.ForwardProxy;
        private readonly ByteSearch.SearchTarget _connectSearch =\n            new ByteSearch.SearchTarget(Encoding.UTF8.GetBytes("HTTP"));\n        private readonly int _socks5Port;\n        public Http2Socks5(int socks5Port)\n        {\n            _socks5Port = socks5Port;\n        }
        private static string GetTimestamp(DateTime value)
            return value.ToString("yyyyMMddHHmmssfff");
                    if (!(each.Equals("DefaultConnectionSettings")\n                        || each.Equals("LAN Connection")\n                        || each.Equals("SavedLegacySettings")))
                        //set all the connections's proxy as the lan\n                        registry.SetValue(each, defaultValue);
        public bool StatisticsEnabled { get; } = true;\n        public bool ByHourOfDay { get; } = true;
        public int ChoiceKeptMinutes { get; } = 10;\n        public int DataCollectionMinutes { get; } = 10;\n        public int RepeatTimesNum { get; } = 4;
using System.Drawing;
using System.Windows.Forms.DataVisualization.Charting;
    using Statistics = Dictionary<string, List<StatisticsRecord>>;
            this.tableLayoutPanel1.Controls.Add(this.OneTimeAuth, 1, 7);
            this.tableLayoutPanel1.RowCount = 8;\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.Size = new System.Drawing.Size(255, 189);
            "camellia-256-cfb"});
            // OneTimeAuth\n            // \n            this.OneTimeAuth.AutoSize = true;\n            this.OneTimeAuth.Location = new System.Drawing.Point(89, 167);\n            this.OneTimeAuth.Name = "OneTimeAuth";\n            this.OneTimeAuth.Size = new System.Drawing.Size(156, 16);\n            this.OneTimeAuth.TabIndex = 5;\n            this.OneTimeAuth.Text = "Onetime Authentication";\n            this.OneTimeAuth.UseVisualStyleBackColor = true;
            polipoRunner.Start(_config.GetCurrentServer());\n            local = new Local(_config.GetCurrentServer());
                pacServer.Start();
        private Server config;
        public Local(Server config)\n        {\n            this.config = config;
                _listener = new Socket(AddressFamily.InterNetwork,\n                    SocketType.Stream, ProtocolType.Tcp);\n                IPEndPoint localEndPoint = new IPEndPoint(0, config.local_port);
        public void Start()
            // Create a TCP/IP socket.\n            listener = new Socket(AddressFamily.InterNetwork,\n                SocketType.Stream, ProtocolType.Tcp);\n            IPEndPoint localEndPoint = new IPEndPoint(0, 8090);\n            // Bind the socket to the local endpoint and listen for incoming connections.\n            listener.Bind(localEndPoint);\n            listener.Listen(100);\n            listener.BeginAccept(\n                new AsyncCallback(AcceptCallback),\n                listener);\n            WatchPacFile();
                Socket conn = listener.EndAccept(ar);
            WatchPacFile();
                string proxy = "PROXY 127.0.0.1:8123;";
            this.ShowLogItem = new System.Windows.Forms.MenuItem();
            this.ServersItem.Index = 1;
            this.menuItem4.Index = 2;
        public void Start(Server config)
        public TCPHandler(TCPRelay tcprelay)
                IPEndPoint remoteEP = new IPEndPoint(ipAddress, server.server_port);\n                remote = new DirectConnect();
                proxyTimer.DestEndPoint = remoteEP;
                remote.BeginConnectProxy(remoteEP, new AsyncCallback(ProxyConnectCallback), proxyTimer);
                            var location = m.Groups[2].Value;\n                            var locs = location.Split(':');\n                            _targetHost = locs[0];\n                            if (locs.Length > 1)
                                if (!int.TryParse(locs[1], out _targetPort))\n                                {\n                                    throw new Exception("Bad http header: " + line);\n                                }\n                            }\n                            else\n                            {\n                                _targetPort = 80;
                            var location = line.Substring(6).Trim();\n                            var locs = location.Split(':');\n                            _targetHost = locs[0];\n                            if (locs.Length > 1)
                                if (!int.TryParse(locs[1], out _targetPort))\n                                {\n                                    throw new Exception("Bad http header: " + line);\n                                }\n                            }\n                            else\n                            {\n                                _targetPort = 80;
        int enc_index1 = 0;\n        int enc_index2 = 0;\n        int dec_index1 = 0;\n        int dec_index2 = 0;
            EncryptOutput(enc_index1, enc_index2, table, data, length);
            EncryptOutput(dec_index1, dec_index2, table, data, length);
        private void EncryptOutput(int index1, int index2, byte[] s, byte[] data, int length)
                index1 = (index1 + 1) & 255;\n                index2 = (index2 + s[index1]) & 255;\n                Swap(s, index1, index2);\n                data[n] = (byte)(b ^ s[(s[index1] + s[index2]) & 255]);
        private static bool? _portableMode;\n        private static string TempPath = null;\n        public static bool IsPortableMode()\n        {\n            if (!_portableMode.HasValue)\n            {\n                _portableMode = File.Exists(Path.Combine(Application.StartupPath, "shadowsocks_portable_mode.txt"));\n            }\n            return _portableMode.Value;\n        }
            if (TempPath == null)\n            {\n                if (IsPortableMode())\n                    try\n                    {\n                        Directory.CreateDirectory(Path.Combine(Application.StartupPath, "temp"));\n                    }\n                    catch (Exception e)\n                    {\n                        TempPath = Path.GetTempPath();\n                        Logging.LogUsefulException(e);\n                    }\n                    finally\n                    {\n                        // don't use "/", it will fail when we call explorer /select xxx/temp\xxx.log\n                        TempPath = Path.Combine(Application.StartupPath, "temp");\n                    }\n                else\n                    TempPath = Path.GetTempPath();\n            }\n            return TempPath;