{\n    class AutoStartup\n    {\n        public static bool Set(bool enabled)\n        {\n            try\n            {\n                string path = Application.ExecutablePath;
        public static bool Set(bool enabled)\n        {\n            try\n            {\n                string path = Application.ExecutablePath;\n                RegistryKey runKey = Microsoft.Win32.Registry.CurrentUser.OpenSubKey(@"Software\Microsoft\Windows\CurrentVersion\Run", true);\n                if (enabled)\n                {
            try\n            {\n                string path = Application.ExecutablePath;\n                RegistryKey runKey = Microsoft.Win32.Registry.CurrentUser.OpenSubKey(@"Software\Microsoft\Windows\CurrentVersion\Run", true);\n                if (enabled)\n                {\n                    runKey.SetValue("Shadowsocks", path);\n                }\n                else\n                {
                string path = Application.ExecutablePath;\n                RegistryKey runKey = Microsoft.Win32.Registry.CurrentUser.OpenSubKey(@"Software\Microsoft\Windows\CurrentVersion\Run", true);\n                if (enabled)\n                {\n                    runKey.SetValue("Shadowsocks", path);\n                }\n                else\n                {\n                    runKey.DeleteValue("Shadowsocks");\n                }
        }\n        public static bool Check()\n        {\n            try\n            {\n                string path = Application.ExecutablePath;
        }\n        public static bool Check()\n        {\n            try\n            {\n                string path = Application.ExecutablePath;\n                RegistryKey runKey = Microsoft.Win32.Registry.CurrentUser.OpenSubKey(@"Software\Microsoft\Windows\CurrentVersion\Run");\n                string[] runList = runKey.GetValueNames();
        {\n            try\n            {\n                string path = Application.ExecutablePath;\n                RegistryKey runKey = Microsoft.Win32.Registry.CurrentUser.OpenSubKey(@"Software\Microsoft\Windows\CurrentVersion\Run");\n                string[] runList = runKey.GetValueNames();\n                runKey.Close();\n                foreach (string item in runList)\n                {
            if (_disposed)\n            {\n                throw new ObjectDisposedException(GetType().FullName);\n            }\n            lock (_startProcessLock)\n            {\n                if (_started && !_pluginProcess.HasExited)\n                {\n                    return false;\n                }
                if (_started && !_pluginProcess.HasExited)\n                {\n                    return false;\n                }\n                if (!File.Exists(_pluginProcess.StartInfo.FileName))\n                {\n                    throw new FileNotFoundException(I18N.GetString("Cannot find the plugin program file"), _pluginProcess.StartInfo.FileName);\n                }\n                var localPort = GetNextFreeTcpPort();\n                LocalEndPoint = new IPEndPoint(IPAddress.Loopback, localPort);\n                _pluginProcess.StartInfo.Environment["SS_LOCAL_HOST"] = LocalEndPoint.Address.ToString();\n                _pluginProcess.StartInfo.Environment["SS_LOCAL_PORT"] = LocalEndPoint.Port.ToString();\n                _pluginProcess.StartInfo.Arguments = ExpandEnvironmentVariables(_pluginProcess.StartInfo.Arguments, _pluginProcess.StartInfo.EnvironmentVariables);

﻿using System;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Text;\nusing System.Threading;
                    {\n                        if (e.Data == null)\n                        {\n                            errorWaitHandle.Set();\n                        }\n                        else\n                        {\n                            error.AppendLine(e.Data);\n                        }\n                    };
                    process.Start();\n                    process.BeginErrorReadLine();\n                    process.BeginOutputReadLine();\n                    process.WaitForExit();\n                    var stderr = error.ToString();\n                    var stdout = output.ToString();\n                    var exitCode = process.ExitCode;\n                    if (exitCode != (int)RET_ERRORS.RET_NO_ERROR)\n                    {
                    var stdout = output.ToString();\n                    var exitCode = process.ExitCode;\n                    if (exitCode != (int)RET_ERRORS.RET_NO_ERROR)\n                    {\n                        throw new ProxyException(stderr);\n                    }\n                    if (arguments == "query")\n                    {\n                        if (stdout.IsNullOrWhiteSpace() || stdout.IsNullOrEmpty())\n                        {\n                            // we cannot get user settings
            Bitmap iconCopy = new Bitmap(originIcon);\n            for (int x = 0; x < iconCopy.Width; x++)\n            {\n                for (int y = 0; y < iconCopy.Height; y++)\n                {\n                    Color color = originIcon.GetPixel(x, y);\n                    if (color.A != 0)\n                    {\n                        if (!enabled)\n                        {
            // \n            // tableLayoutPanel1\n            // \n            this.tableLayoutPanel1.AutoSize = true;\n            this.tableLayoutPanel1.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;\n            this.tableLayoutPanel1.ColumnCount = 2;\n            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());\n            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());\n            this.tableLayoutPanel1.Controls.Add(this.PluginOptionsLabel, 0, 6);\n            this.tableLayoutPanel1.Controls.Add(this.PluginTextBox, 1, 5);
            this.tableLayoutPanel1.Controls.Add(this.PluginOptionsLabel, 0, 6);\n            this.tableLayoutPanel1.Controls.Add(this.PluginTextBox, 1, 5);\n            this.tableLayoutPanel1.Controls.Add(this.PluginArgumentsTextBox, 1, 7);\n            this.tableLayoutPanel1.Controls.Add(this.PluginArgumentsLabel, 0, 7);\n            this.tableLayoutPanel1.Controls.Add(this.RemarksLabel, 0, 9);\n            this.tableLayoutPanel1.Location = new System.Drawing.Point(8, 21);\n            this.tableLayoutPanel1.Margin = new System.Windows.Forms.Padding(0);\n            this.tableLayoutPanel1.Name = "tableLayoutPanel1";\n            this.tableLayoutPanel1.Padding = new System.Windows.Forms.Padding(3);
            this.contextMenu1 = new System.Windows.Forms.ContextMenu();\n            this.enableItem = new System.Windows.Forms.MenuItem();\n            this.configItem = new System.Windows.Forms.MenuItem();\n            this.editPACFileItem = new System.Windows.Forms.MenuItem();\n            this.aboutItem = new System.Windows.Forms.MenuItem();\n            this.menuItem3 = new System.Windows.Forms.MenuItem();\n            this.quitItem = new System.Windows.Forms.MenuItem();\n            this.panel3 = new System.Windows.Forms.Panel();\n            this.DeleteButton = new System.Windows.Forms.Button();\n            this.AddButton = new System.Windows.Forms.Button();
            try\n            {
        public event ErrorEventHandler Errored;\n        public ShadowsocksController()\n        {\n            _config = Configuration.Load();\n            StatisticsConfiguration = StatisticsStrategyConfiguration.Load();\n            _strategyManager = new StrategyManager(this);\n            _pluginsByServer = new ConcurrentDictionary<Server, Sip003Plugin>();\n            StartReleasingMemory();\n            StartTrafficStatistics(61);\n        }
            _config = Configuration.Load();\n            StatisticsConfiguration = StatisticsStrategyConfiguration.Load();\n            _strategyManager = new StrategyManager(this);\n            _pluginsByServer = new ConcurrentDictionary<Server, Sip003Plugin>();\n            StartReleasingMemory();\n            StartTrafficStatistics(61);\n        }\n        public void Start()\n        {\n            Reload();
            {\n                Console.WriteLine(e.ToString());\n            }\n            LoadLibrary(dllPath);\n        }\n        [DllImport("Kernel32.dll")]\n        private static extern IntPtr LoadLibrary(string path);\n        public const int MD5_CTX_SIZE = 88;\n        public static byte[] MD5(byte[] input)\n        {
            }\n            LoadLibrary(dllPath);\n        }\n        [DllImport("Kernel32.dll")]\n        private static extern IntPtr LoadLibrary(string path);\n        public const int MD5_CTX_SIZE = 88;\n        public static byte[] MD5(byte[] input)\n        {\n            IntPtr ctx = Marshal.AllocHGlobal(MD5_CTX_SIZE);\n            byte[] output = new byte[16];
        private static extern IntPtr LoadLibrary(string path);\n        public const int MD5_CTX_SIZE = 88;\n        public static byte[] MD5(byte[] input)\n        {\n            IntPtr ctx = Marshal.AllocHGlobal(MD5_CTX_SIZE);\n            byte[] output = new byte[16];\n            MbedTLS.md5_init(ctx);\n            MbedTLS.md5_starts(ctx);\n            MbedTLS.md5_update(ctx, input, (uint)input.Length);\n            MbedTLS.md5_finish(ctx, output);\n            MbedTLS.md5_free(ctx);\n            Marshal.FreeHGlobal(ctx);\n            return output;\n        }\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]

﻿using System;\nusing System.Collections;\nusing System.Globalization;\nusing System.IO;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Text;

namespace Shadowsocks.View\n{\n    public partial class LogForm : Form\n    {\n        long lastOffset;\n        string filename;\n        Timer timer;\n        const int BACK_OFFSET = 65536;
        string filename;\n        Timer timer;\n        const int BACK_OFFSET = 65536;\n        Model.Configuration config;\n        public LogForm(string filename)\n        {\n            this.filename = filename;\n            InitializeComponent();\n            this.Icon = Icon.FromHandle(Resources.ssw128.GetHicon());
        }\n        private void ReadAll(IAsyncResult ar)\n        {\n            if (_closed) return;\n            try\n            {\n                if (ar.AsyncState != null)\n                {\n                    connection.EndSend(ar);\n                    Logging.Debug(remote, RecvSize, "TCP Relay");
                    connection.EndSend(ar);\n                    Logging.Debug(remote, RecvSize, "TCP Relay");\n                    connection.BeginReceive(_connetionRecvBuffer, 0, RecvSize, 0, new AsyncCallback(ReadAll), null);\n                }\n                else\n                {\n                    int bytesRead = connection.EndReceive(ar);\n                    if (bytesRead > 0)\n                    {\n                        Logging.Debug(remote, RecvSize, "TCP Relay");
            this.ShowLogItem,\n            this.aboutItem,\n            this.menuItem3,\n            this.quitItem});\n            // \n            // enableItem\n            // \n            this.enableItem.Index = 0;\n            this.enableItem.Text = "&Enable";\n            this.enableItem.Click += new System.EventHandler(this.EnableItem_Click);
            this.ServersItem.Index = 1;\n            // \n            this.SeperatorItem.Index = 0;\n            this.SeperatorItem.Text = "-";\n            // \n            // ConfigItem\n            // \n            this.ConfigItem.Index = 1;\n            this.ConfigItem.Text = "Edit Servers...";\n            this.ConfigItem.Click += new System.EventHandler(this.Config_Click);\n            // 
        public const int INTERNET_OPTION_SETTINGS_CHANGED = 39;\n        public const int INTERNET_OPTION_REFRESH = 37;\n        static bool _settingsReturn, _refreshReturn;\n        public static void NotifyIE()\n        {\n            // These lines implement the Interface in the beginning of program \n            // They cause the OS to refresh the settings, causing IP to realy update\n            _settingsReturn = InternetSetOption(IntPtr.Zero, INTERNET_OPTION_SETTINGS_CHANGED, IntPtr.Zero, 0);\n            _refreshReturn = InternetSetOption(IntPtr.Zero, INTERNET_OPTION_REFRESH, IntPtr.Zero, 0);\n        }
            _settingsReturn = InternetSetOption(IntPtr.Zero, INTERNET_OPTION_SETTINGS_CHANGED, IntPtr.Zero, 0);\n            _refreshReturn = InternetSetOption(IntPtr.Zero, INTERNET_OPTION_REFRESH, IntPtr.Zero, 0);\n        }\n        public static void Enable()\n        {\n            try\n            {\n                RegistryKey registry =\n                    Registry.CurrentUser.OpenSubKey("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings",\n                        true);
using System.Text;\nnamespace shadowsocks_csharp\n{\n    class SystemProxy\n    {\n        [DllImport("wininet.dll")]\n        public static extern bool InternetSetOption(IntPtr hInternet, int dwOption, IntPtr lpBuffer, int dwBufferLength);\n        public const int INTERNET_OPTION_SETTINGS_CHANGED = 39;\n        public const int INTERNET_OPTION_REFRESH = 37;\n        static bool settingsReturn, refreshReturn;
        public const int INTERNET_OPTION_REFRESH = 37;\n        static bool settingsReturn, refreshReturn;\n        public static void UpdateIE()\n        {\n            // These lines implement the Interface in the beginning of program \n            // They cause the OS to refresh the settings, causing IP to realy update\n            settingsReturn = InternetSetOption(IntPtr.Zero, INTERNET_OPTION_SETTINGS_CHANGED, IntPtr.Zero, 0);\n            refreshReturn = InternetSetOption(IntPtr.Zero, INTERNET_OPTION_REFRESH, IntPtr.Zero, 0);\n        }\n        public static void Enable()\n        {\n            RegistryKey registry = Registry.CurrentUser.OpenSubKey("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings", true);
            registry.SetValue("ProxyEnable", 1);\n            registry.SetValue("ProxyServer", "127.0.0.1:8123");\n            SystemProxy.UpdateIE();\n        }\n        public static void Disable()\n        {\n            RegistryKey registry = Registry.CurrentUser.OpenSubKey("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings", true);\n            registry.SetValue("ProxyEnable", 0);\n            registry.SetValue("ProxyServer", "");
using System;\nusing System.Collections.Generic;\nusing System.Text;
using System.Text;\nusing System.Text.RegularExpressions;\nusing System.Web;\nusing Shadowsocks.Controller;\nnamespace Shadowsocks.Model\n{\n    [Serializable]\n    public class Server\n    {
            server_port = 8388;\n            method = "aes-256-cfb";\n            password = "";\n            remarks = "";\n            timeout = DefaultServerTimeoutSec;\n        }\n        public static List<Server> GetServers(string ssURL)\n        {
            password = "";\n            remarks = "";\n            timeout = DefaultServerTimeoutSec;\n        }\n        public static List<Server> GetServers(string ssURL)\n        {\n            var matches = UrlFinder.Matches(ssURL);\n            if (matches.Count <= 0) return null;\n            List<Server> servers = new List<Server>();
            password = "";\n            remarks = "";\n            timeout = DefaultServerTimeoutSec;\n        }\n        public static List<Server> GetServers(string ssURL)\n        {\n            var matches = UrlFinder.Matches(ssURL);\n            if (matches.Count <= 0) return null;\n            List<Server> servers = new List<Server>();\n            foreach (Match match in matches)\n            {
            timeout = DefaultServerTimeoutSec;\n        }\n        public static List<Server> GetServers(string ssURL)\n        {\n            var matches = UrlFinder.Matches(ssURL);\n            if (matches.Count <= 0) return null;\n            List<Server> servers = new List<Server>();\n            foreach (Match match in matches)\n            {\n                Server tmp = new Server();\n                var base64 = match.Groups["base64"].Value;\n                var tag = match.Groups["tag"].Value;\n                if (!tag.IsNullOrEmpty())\n                {
        public static List<Server> GetServers(string ssURL)\n        {\n            var matches = UrlFinder.Matches(ssURL);\n            if (matches.Count <= 0) return null;\n            List<Server> servers = new List<Server>();\n            foreach (Match match in matches)\n            {\n                Server tmp = new Server();\n                var base64 = match.Groups["base64"].Value;\n                var tag = match.Groups["tag"].Value;\n                if (!tag.IsNullOrEmpty())\n                {\n                    tmp.remarks = HttpUtility.UrlDecode(tag, Encoding.UTF8);\n                }
            List<Server> servers = new List<Server>();\n            foreach (Match match in matches)\n            {\n                Server tmp = new Server();\n                var base64 = match.Groups["base64"].Value;\n                var tag = match.Groups["tag"].Value;\n                if (!tag.IsNullOrEmpty())\n                {\n                    tmp.remarks = HttpUtility.UrlDecode(tag, Encoding.UTF8);\n                }\n                Match details = DetailsParser.Match(Encoding.UTF8.GetString(Convert.FromBase64String(\n                    base64.PadRight(base64.Length + (4 - base64.Length % 4) % 4, '='))));\n                if (!details.Success)\n                    continue;
            this.tableLayoutPanel4.SuspendLayout();\n            this.SuspendLayout();\n            // \n            // tableLayoutPanel1\n            // \n            this.tableLayoutPanel1.AutoSize = true;\n            this.tableLayoutPanel1.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;\n            this.tableLayoutPanel1.ColumnCount = 2;\n            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());\n            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());
            this.tableLayoutPanel1.Controls.Add(this.RemarksTextBox, 1, 5);\n            this.tableLayoutPanel1.Controls.Add(this.RemarksLabel, 0, 5);\n            this.tableLayoutPanel1.Controls.Add(this.IPLabel, 0, 0);\n            this.tableLayoutPanel1.Controls.Add(this.ServerPortLabel, 0, 1);\n            this.tableLayoutPanel1.Controls.Add(this.PasswordLabel, 0, 2);\n            this.tableLayoutPanel1.Controls.Add(this.IPTextBox, 1, 0);\n            this.tableLayoutPanel1.Controls.Add(this.ServerPortTextBox, 1, 1);\n            this.tableLayoutPanel1.Controls.Add(this.PasswordTextBox, 1, 2);\n            this.tableLayoutPanel1.Controls.Add(this.EncryptionLabel, 0, 3);\n            this.tableLayoutPanel1.Controls.Add(this.EncryptionSelect, 1, 3);
            this.tableLayoutPanel1.Controls.Add(this.PasswordTextBox, 1, 2);\n            this.tableLayoutPanel1.Controls.Add(this.EncryptionLabel, 0, 3);\n            this.tableLayoutPanel1.Controls.Add(this.EncryptionSelect, 1, 3);\n            this.tableLayoutPanel1.Controls.Add(this.TimeoutLabel, 0, 6);\n            this.tableLayoutPanel1.Controls.Add(this.TimeoutTextBox, 1, 6);\n            this.tableLayoutPanel1.Location = new System.Drawing.Point(8, 21);\n            this.tableLayoutPanel1.Margin = new System.Windows.Forms.Padding(0);\n            this.tableLayoutPanel1.Name = "tableLayoutPanel1";\n            this.tableLayoutPanel1.Padding = new System.Windows.Forms.Padding(3);
        public static event ErrorEventHandler Error;\n        private static readonly string DATABASE_PATH = Utils.GetTempPath("dlc.dat");\n        private static readonly string GEOSITE_URL = "https://github.com/v2ray/domain-list-community/raw/release/dlc.dat";\n        public static readonly Dictionary<string, IList<DomainObject>> Geosites = new Dictionary<string, IList<DomainObject>>();\n        static GeositeUpdater()\n        {
        public static readonly Dictionary<string, IList<DomainObject>> Geosites = new Dictionary<string, IList<DomainObject>>();\n        static GeositeUpdater()\n        {\n            if (!File.Exists(DATABASE_PATH))\n            {\n                File.WriteAllBytes(DATABASE_PATH, Resources.dlc_dat);\n            }\n            LoadGeositeList();\n        }
            foreach (var item in list.Entries)\n            {\n                Geosites[item.GroupName.ToLower()] = item.Domains;\n            }\n        }\n        public static void ResetEvent()\n        {\n            UpdateCompleted = null;\n            Error = null;\n        }
            string group = config.geositeGroup;\n            bool blacklist = config.geositeBlacklistMode;\n            if (!string.IsNullOrWhiteSpace(config.geositeUrl))\n            {\n                logger.Info("Found custom Geosite URL in config file");\n                geositeUrl = config.geositeUrl;\n            }\n            logger.Info($"Checking Geosite from {geositeUrl}");
            if (!string.IsNullOrWhiteSpace(config.geositeUrl))\n            {\n                logger.Info("Found custom Geosite URL in config file");\n                geositeUrl = config.geositeUrl;\n            }\n            logger.Info($"Checking Geosite from {geositeUrl}");\n            WebClient http = new WebClient();\n            if (config.enabled)\n            {
            WebClient http = new WebClient();\n            if (config.enabled)\n            {\n                http.Proxy = new WebProxy(\n                    config.isIPv6Enabled\n                    ? $"[{IPAddress.IPv6Loopback}]"\n                    : IPAddress.Loopback.ToString(),\n                    config.localPort);\n            }
using System.Drawing;\nusing System.Text;\nusing System.Windows.Forms;\nusing System.Diagnostics;\nusing Shadowsocks.Controller;\nusing Shadowsocks.Model;\nnamespace Shadowsocks.View\n{\n    public partial class ConfigForm : Form\n    {
        ShadowsocksController controller;\n        public ConfigForm(ShadowsocksController controller)\n        {\n            InitializeComponent();\n            notifyIcon1.ContextMenu = contextMenu1;\n            this.controller = controller;\n            controller.EnableStatusChanged += controller_EnableStatusChanged;\n            controller.ConfigChanged += controller_ConfigChanged;\n            controller.PACFileReadyToOpen += controller_PACFileReadyToOpen;
            InitializeComponent();\n            notifyIcon1.ContextMenu = contextMenu1;\n            this.controller = controller;\n            controller.EnableStatusChanged += controller_EnableStatusChanged;\n            controller.ConfigChanged += controller_ConfigChanged;\n            controller.PACFileReadyToOpen += controller_PACFileReadyToOpen;\n            updateUI();\n        }\n        private void controller_ConfigChanged(object sender, EventArgs e)\n        {
            controller.ConfigChanged += controller_ConfigChanged;\n            controller.PACFileReadyToOpen += controller_PACFileReadyToOpen;\n            updateUI();\n        }\n        private void controller_ConfigChanged(object sender, EventArgs e)\n        {\n            updateUI();\n        }\n        private void controller_EnableStatusChanged(object sender, EventArgs e)\n        {
        void controller_PACFileReadyToOpen(object sender, ShadowsocksController.PathEventArgs e)\n        {\n            string argument = @"/select, " + e.Path;\n            System.Diagnostics.Process.Start("explorer.exe", argument);\n        }\n        private void showWindow()\n        {\n            this.Opacity = 1;\n            this.Show();\n        }
            string argument = @"/select, " + e.Path;\n            System.Diagnostics.Process.Start("explorer.exe", argument);\n        }\n        private void showWindow()\n        {\n            this.Opacity = 1;\n            this.Show();\n        }\n        private void updateUI()\n        {
        }\n        private void updateUI()\n        {\n            Server server = controller.GetCurrentServer();\n            IPTextBox.Text = server.server;\n            ServerPortTextBox.Text = server.server_port.ToString();\n            PasswordTextBox.Text = server.password;\n            ProxyPortTextBox.Text = server.local_port.ToString();\n            EncryptionSelect.Text = server.method == null ? "aes-256-cfb" : server.method;
        {\n            Server server = controller.GetCurrentServer();\n            IPTextBox.Text = server.server;\n            ServerPortTextBox.Text = server.server_port.ToString();\n            PasswordTextBox.Text = server.password;\n            ProxyPortTextBox.Text = server.local_port.ToString();\n            EncryptionSelect.Text = server.method == null ? "aes-256-cfb" : server.method;\n            enableItem.Checked = controller.GetConfiguration().enabled;\n        }
        private void Config_Click(object sender, EventArgs e)\n        {\n            showWindow();\n        }\n        private void Quit_Click(object sender, EventArgs e)\n        {\n            this.Close();\n        }\n        private void OKButton_Click(object sender, EventArgs e)\n        {
                MessageBox.Show("illegal port number format");\n            }\n            catch (Exception ex)\n            {\n                MessageBox.Show(ex.Message);\n            }\n        }\n        private void CancelButton_Click(object sender, EventArgs e)\n        {\n            this.Hide();
        #region Windows 窗体设计器生成的代码\n        /// <summary>\n        /// 设计器支持所需的方法 - 不要\n        /// 使用代码编辑器修改此方法的内容。\n        /// </summary>\n        private void InitializeComponent()\n        {\n            this.components = new System.ComponentModel.Container();\n            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(ConfigForm));\n            this.tableLayoutPanel1 = new System.Windows.Forms.TableLayoutPanel();
        /// 使用代码编辑器修改此方法的内容。\n        /// </summary>\n        private void InitializeComponent()\n        {\n            this.components = new System.ComponentModel.Container();\n            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(ConfigForm));\n            this.tableLayoutPanel1 = new System.Windows.Forms.TableLayoutPanel();\n            this.label5 = new System.Windows.Forms.Label();\n            this.label1 = new System.Windows.Forms.Label();\n            this.label2 = new System.Windows.Forms.Label();
        {\n            this.components = new System.ComponentModel.Container();\n            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(ConfigForm));\n            this.tableLayoutPanel1 = new System.Windows.Forms.TableLayoutPanel();\n            this.label5 = new System.Windows.Forms.Label();\n            this.label1 = new System.Windows.Forms.Label();\n            this.label2 = new System.Windows.Forms.Label();\n            this.EncryptionSelect = new System.Windows.Forms.ComboBox();\n            this.label3 = new System.Windows.Forms.Label();
            this.label5 = new System.Windows.Forms.Label();\n            this.label1 = new System.Windows.Forms.Label();\n            this.label2 = new System.Windows.Forms.Label();\n            this.EncryptionSelect = new System.Windows.Forms.ComboBox();\n            this.label3 = new System.Windows.Forms.Label();\n            this.label4 = new System.Windows.Forms.Label();\n            this.IPTextBox = new System.Windows.Forms.TextBox();\n            this.ServerPortTextBox = new System.Windows.Forms.TextBox();\n            this.PasswordTextBox = new System.Windows.Forms.TextBox();
            this.contextMenu1 = new System.Windows.Forms.ContextMenu();\n            this.enableItem = new System.Windows.Forms.MenuItem();\n            this.configItem = new System.Windows.Forms.MenuItem();\n            this.editPACFileItem = new System.Windows.Forms.MenuItem();\n            this.aboutItem = new System.Windows.Forms.MenuItem();\n            this.menuItem3 = new System.Windows.Forms.MenuItem();\n            this.quitItem = new System.Windows.Forms.MenuItem();\n            this.panel3 = new System.Windows.Forms.Panel();\n            this.AddButton = new System.Windows.Forms.Button();
            // label5\n            // \n            this.label5.Anchor = System.Windows.Forms.AnchorStyles.Right;\n            this.label5.AutoSize = true;\n            this.label5.Location = new System.Drawing.Point(11, 90);\n            this.label5.Name = "label5";\n            this.label5.Size = new System.Drawing.Size(57, 13);\n            this.label5.TabIndex = 8;\n            this.label5.Text = "Encryption";
            // AddButton\n            // \n            this.AddButton.Location = new System.Drawing.Point(4, 4);\n            this.AddButton.Name = "AddButton";\n            this.AddButton.Size = new System.Drawing.Size(75, 23);\n            this.AddButton.TabIndex = 3;\n            this.AddButton.Text = "&Add";\n            this.AddButton.UseVisualStyleBackColor = true;
            }\n        }\n        private void LoadRawStatistics()\n        {\n            try\n            {\n                var path = AvailabilityStatisticsFile;\n                Logging.Debug($"loading statistics from {path}");\n                if (!File.Exists(path))\n                {
        private void LoadRawStatistics()\n        {\n            try\n            {\n                var path = AvailabilityStatisticsFile;\n                Logging.Debug($"loading statistics from {path}");\n                if (!File.Exists(path))\n                {\n                    try\n                    {
            {\n                var path = AvailabilityStatisticsFile;\n                Logging.Debug($"loading statistics from {path}");\n                if (!File.Exists(path))\n                {\n                    try\n                    {\n                        using (File.Create(path))\n                        {\n                            //do nothing\n                        }\n                    }
        private readonly Action<Exception, object> _onException;\n        private readonly Action<byte[], int, int, object> _onFinish;\n        private readonly Encoding _encoding;\n        // private readonly string _delimiter;\n        private readonly byte[] _delimiterBytes;\n        private readonly ByteSearch.SearchTarget _delimiterSearch;\n        private readonly object _state;\n        private readonly byte[] _lineBuffer;\n        private int _bufferDataIndex;\n        private int _bufferDataLength;
        // private readonly string _delimiter;\n        private readonly byte[] _delimiterBytes;\n        private readonly ByteSearch.SearchTarget _delimiterSearch;\n        private readonly object _state;\n        private readonly byte[] _lineBuffer;\n        private int _bufferDataIndex;\n        private int _bufferDataLength;\n        public LineReader(WrappedSocket socket, byte[] firstPackge, int index, int length,\n            Func<string, object, bool> onLineRead, Action<Exception, object> onException,\n            Action<byte[], int, int, object> onFinish,
                throw new ArgumentNullException(nameof(onLineRead));\n            }\n            if (encoding == null)\n            {\n                throw new ArgumentNullException(nameof(encoding));\n            }\n            if (delimiter == null)\n            {\n                throw new ArgumentNullException(nameof(delimiter));\n            }
            if (encoding == null)\n            {\n                throw new ArgumentNullException(nameof(encoding));\n            }\n            if (delimiter == null)\n            {\n                throw new ArgumentNullException(nameof(delimiter));\n            }\n            if (maxLineBytes < length)\n            {
            _onFinish = onFinish;\n            _encoding = encoding;\n            // _delimiter = delimiter;\n            _state = state;\n            // decode delimiter\n            _delimiterBytes = encoding.GetBytes(delimiter);\n            if (_delimiterBytes.Length == 0)\n            {\n                throw new ArgumentException("Too short!", nameof(delimiter));\n            }
            // _delimiter = delimiter;\n            _state = state;\n            // decode delimiter\n            _delimiterBytes = encoding.GetBytes(delimiter);\n            if (_delimiterBytes.Length == 0)\n            {\n                throw new ArgumentException("Too short!", nameof(delimiter));\n            }\n            if (maxLineBytes < _delimiterBytes.Length)\n            {
            _delimiterBytes = encoding.GetBytes(delimiter);\n            if (_delimiterBytes.Length == 0)\n            {\n                throw new ArgumentException("Too short!", nameof(delimiter));\n            }\n            if (maxLineBytes < _delimiterBytes.Length)\n            {\n                throw new ArgumentException("Too small!", nameof(maxLineBytes));\n            }\n            _delimiterSearch = new ByteSearch.SearchTarget(_delimiterBytes);
                throw new ArgumentException("Too short!", nameof(delimiter));\n            }\n            if (maxLineBytes < _delimiterBytes.Length)\n            {\n                throw new ArgumentException("Too small!", nameof(maxLineBytes));\n            }\n            _delimiterSearch = new ByteSearch.SearchTarget(_delimiterBytes);\n            _lineBuffer = new byte[maxLineBytes];\n            if (length > 0)\n            {\n                // process first package
                }\n                catch (Exception ex)\n                {\n                    OnException(ex);\n                    OnFinish();\n                }\n            }\n            else\n            {\n                // start reading
                    OnException(ex);\n                    OnFinish();\n                }\n            }\n            else\n            {\n                // start reading\n                socket.BeginReceive(_lineBuffer, 0, maxLineBytes, 0, ReceiveCallback, 0);\n            }\n        }
        {\n            var state = ((FakeAsyncResult)asyncResult).innerState;\n            if (state.ex != null)\n            {\n                throw state.ex;\n            }\n        }\n        public void BeginConnectDest(EndPoint destEndPoint, AsyncCallback callback, object state)\n        {\n            DestEndPoint = destEndPoint;
using System.Collections.Generic;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Timers;\nusing Shadowsocks.Controller.Strategy;\nusing Shadowsocks.Encryption;\nusing Shadowsocks.ForwardProxy;\nusing Shadowsocks.Model;\nusing Shadowsocks.Util.Sockets;
using Shadowsocks.ForwardProxy;\nusing Shadowsocks.Model;\nusing Shadowsocks.Util.Sockets;\nnamespace Shadowsocks.Controller.Service\n{\n    class TCPRelay : Listener.Service\n    {\n        private ShadowsocksController _controller;\n        private DateTime _lastSweepTime;\n        private Configuration _config;
        private ShadowsocksController _controller;\n        private DateTime _lastSweepTime;\n        private Configuration _config;\n        private readonly List<ITCPHandlerFactory> _factories = new List<ITCPHandlerFactory>();\n        public ISet<TCPHandler> Handlers { get; } = new HashSet<TCPHandler>();\n        public TCPRelay(ShadowsocksController controller, Configuration conf)\n        {\n            _controller = controller;\n            _config = conf;\n            _lastSweepTime = DateTime.Now;
        public TCPRelay(ShadowsocksController controller, Configuration conf)\n        {\n            _controller = controller;\n            _config = conf;\n            _lastSweepTime = DateTime.Now;\n            _factories.Add(new Socks5HandlerFactory());\n            _factories.Add(new HttpHandlerHandlerFactory());\n        }\n        public override bool Handle(byte[] firstPacket, int length, Socket socket, object state)\n        {
            _config = conf;\n            _lastSweepTime = DateTime.Now;\n            _factories.Add(new Socks5HandlerFactory());\n            _factories.Add(new HttpHandlerHandlerFactory());\n        }\n        public override bool Handle(byte[] firstPacket, int length, Socket socket, object state)\n        {\n            {\n                if (factory.CanHandle(firstPacket, length))\n                {\n                    handler = factory.NewHandler(_controller, _config, this, socket);\n                    break;\n                }\n            }\n            if (handler == null)\n            {\n                return false;
            return true;\n        }\n        public override void Stop()\n        {\n            List<TCPHandler> handlersToClose = new List<TCPHandler>();\n            lock (Handlers)\n            {\n                handlersToClose.AddRange(Handlers);\n            }
        }\n        public override void Stop()\n        {\n            List<TCPHandler> handlersToClose = new List<TCPHandler>();\n            lock (Handlers)\n            {\n                handlersToClose.AddRange(Handlers);\n            }\n    interface ITCPHandlerFactory\n    {
    interface ITCPHandlerFactory\n    {\n        public abstract void StartHandshake(byte[] firstPacket, int length);\n        protected abstract void OnServerConnected(AsyncSession session);\n        protected class AsyncSession\n        {\n            public IForwardProxy Remote { get; }\n            public AsyncSession(IForwardProxy remote)\n            {\n                Remote = remote;\n            }\n        }
        {\n            public T State { get; set; }\n            public AsyncSession(IForwardProxy remote, T state) : base(remote)\n            {\n                State = state;\n            }
            public AsyncSession(IForwardProxy remote, T state) : base(remote)\n            {\n                State = state;\n            }\n        private ShadowsocksController _controller;\n        protected Configuration Config { get; }\n        private TCPRelay _tcprelay;\n        protected Socket Connection { get; }\n        private Server _server;\n        private AsyncSession _currentRemoteSession;
        private readonly object _encryptionLock = new object();\n        private readonly object _decryptionLock = new object();\n        private bool _connectionShutdown = false;\n        private bool _remoteShutdown = false;\n        protected bool Closed { get; private set; }= false;\n        private readonly object _closeConnLock = new object();\n        private DateTime _startConnectTime;\n        private DateTime _startReceivingTime;\n        private DateTime _startSendingTime;\n        private EndPoint _destEndPoint = null;
        private EndPoint _destEndPoint = null;\n        public TCPHandler(ShadowsocksController controller, Configuration config, TCPRelay tcprelay, Socket socket, bool autoAppendHeader = true)\n        {\n            _controller = controller;
            {\n                if (_server != null)\n                {\n                    IStrategy strategy = _controller.GetCurrentStrategy();\n                    strategy?.SetFailure(_server);\n                }\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }
                Logging.LogUsefulException(e);\n                Close();\n            }\n        }\n        protected void StartPipe(AsyncSession session)\n        {\n            if (Closed) return;\n            try\n            {\n                _startReceivingTime = DateTime.Now;
                    IStrategy strategy = _controller.GetCurrentStrategy();\n                    strategy?.UpdateLastRead(_server);\n                }\n                else\n                {
                length += len;\n            }\n            _totalWrite += length;\n            int bytesToSend;\n            lock (_encryptionLock)\n            {
            _totalWrite += length;\n            int bytesToSend;\n            lock (_encryptionLock)\n            {\n            session.Remote.BeginSend(_connetionSendBuffer, 0, bytesToSend, SocketFlags.None, callback, session);\n            IStrategy strategy = _controller.GetCurrentStrategy();\n            strategy?.UpdateLastWrite(_server);\n        }
            int bytesToSend;\n            lock (_encryptionLock)\n            {\n            session.Remote.BeginSend(_connetionSendBuffer, 0, bytesToSend, SocketFlags.None, callback, session);\n            IStrategy strategy = _controller.GetCurrentStrategy();\n            strategy?.UpdateLastWrite(_server);\n        }\n        protected AsyncSession EndSendToServer(IAsyncResult ar)\n        {\n            var session = (AsyncSession)ar.AsyncState;\n            session.Remote.EndSend(ar);\n            return session;\n        }\n        private void PipeRemoteSendCallback(IAsyncResult ar)\n        {
            try\n            {\n                var strategy = GetCurrentStrategy();\n                if (strategy != null)\n                {\n                    strategy.ReloadServers();\n                }\n                TCPRelay tcpRelay = new TCPRelay(this, _config);\n                UDPRelay udpRelay = new UDPRelay(this);\n                List<Listener.IService> services = new List<Listener.IService>();
            else\n            {\n                realkey = _key;\n            }\n            if (_cipher == CIPHER_AES)\n            {\n                PolarSSL.aes_init(ctx);\n                if (isCipher)\n                {
                PolarSSL.aes_init(ctx);\n                if (isCipher)\n                {\n                    // PolarSSL takes key length by bit\n                    PolarSSL.aes_setkey_enc(ctx, realkey, keyLen * 8);\n                    _encryptIV = new byte[ivLen];\n                    Array.Copy(iv, _encryptIV, ivLen);\n                }\n                else\n                {
using System.Text.RegularExpressions;\nnamespace Shadowsocks.Controller\n{\n    class PACServer\n    {\n        private static int PORT = 8093;\n        private static string PAC_FILE = "pac.txt";\n        private static Configuration config;\n        Socket _listener;\n        FileSystemWatcher watcher;
                {\n                    localEndPoint = new IPEndPoint(IPAddress.Loopback, PORT);\n                }\n                // Bind the socket to the local endpoint and listen for incoming connections.\n                _listener.Bind(localEndPoint);\n                _listener.Listen(100);\n                _listener.BeginAccept(\n                    new AsyncCallback(AcceptCallback),\n                    _listener);\n                WatchPacFile();
                StartGfwListUpdater();\n            }\n            catch (SocketException)\n            {\n                _listener.Close();\n                throw;\n            }\n        }\n        public void Stop()\n        {
using System.IO.Compression;\nusing System.Security.Cryptography;\nusing System.Text.RegularExpressions;\nusing Shadowsocks.Model;\nusing Shadowsocks.Properties;\nnamespace Shadowsocks.Controller\n{\n    public class GfwListUpdater\n    {\n        private const string GFWLIST_URL = "https://autoproxy-gfwlist.googlecode.com/svn/trunk/gfwlist.txt";
using System.Text.RegularExpressions;\nusing Shadowsocks.Model;\nusing Shadowsocks.Properties;\nnamespace Shadowsocks.Controller\n{\n    public class GfwListUpdater\n    {\n        private const string GFWLIST_URL = "https://autoproxy-gfwlist.googlecode.com/svn/trunk/gfwlist.txt";\n        private const int EXPIRE_HOURS = 6;\n        public IWebProxy proxy = null;
        {\n            lock(locker)\n            {\n                lastUpdateTimeUtc = DateTime.UtcNow.AddHours(-1 * EXPIRE_HOURS).AddSeconds(delaySeconds);\n            }\n        }\n        private string DownloadGfwListFile()\n        {\n            try\n            {
        }\n        private string DownloadGfwListFile()\n        {\n            try\n            {\n                WebClient http = new WebClient();\n                http.Proxy = useSystemProxy ? WebRequest.GetSystemWebProxy() : proxy;\n                return http.DownloadString(new Uri(GFWLIST_URL));\n            }\n            catch (Exception ex)\n            {
                }\n                Thread.Sleep(1000);\n            }\n        }\n        class Parser\n        {\n            public string Content { get; private set; }\n            public Parser(string response)\n            {\n                byte[] bytes = Convert.FromBase64String(response);
                byte[] bytes = Convert.FromBase64String(response);\n                this.Content = Encoding.ASCII.GetString(bytes);\n            }\n            public string[] GetLines()\n            {\n                return Content.Split(new char[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries); \n            }\n            /* refer https://github.com/clowwindy/gfwlist2pac/blob/master/gfwlist2pac/main.py */\n            public string[] GetDomains()\n            {
                    this.editOnlinePACItem = CreateMenuItem("Edit Online PAC URL...", new EventHandler(this.UpdateOnlinePACURLItem_Click)),
            this.editPACFileItem = new System.Windows.Forms.MenuItem();\n            this.aboutItem = new System.Windows.Forms.MenuItem();\n            this.menuItem3 = new System.Windows.Forms.MenuItem();\n            this.quitItem = new System.Windows.Forms.MenuItem();\n            this.panel3 = new System.Windows.Forms.Panel();\n            this.DeleteButton = new System.Windows.Forms.Button();\n            this.AddButton = new System.Windows.Forms.Button();\n            this.ServerGroupBox = new System.Windows.Forms.GroupBox();\n            this.ServersListBox = new System.Windows.Forms.ListBox();
            }\n            items.Add(SeperatorItem);\n            items.Add(ConfigItem);\n            if (configuration.index >= 0 && configuration.index < configuration.configs.Count)\n            {\n                items[configuration.index].Checked = true;\n            }\n        }\n        private void ConfigForm_Load(object sender, EventArgs e)\n        {
            {\n                items[configuration.index].Checked = true;\n            }\n        }\n        private void ConfigForm_Load(object sender, EventArgs e)\n        {\n            if (!controller.GetConfiguration().isDefault)\n            {\n                this.Opacity = 0;
            UserRuleFileWatcher.Filter = USER_RULE_FILE;\n            UserRuleFileWatcher.Changed += UserRuleFileWatcher_Changed;\n            UserRuleFileWatcher.Created += UserRuleFileWatcher_Changed;\n            UserRuleFileWatcher.Deleted += UserRuleFileWatcher_Changed;\n            UserRuleFileWatcher.Renamed += UserRuleFileWatcher_Changed;\n            UserRuleFileWatcher.EnableRaisingEvents = true;\n        }\n        private void PACFileWatcher_Changed(object sender, FileSystemEventArgs e)\n        {
            if (PACFileChanged != null)\n            {\n                Console.WriteLine("Detected: PAC file '{0}' was {1}.", e.Name, e.ChangeType.ToString().ToLower());\n                PACFileChanged(this, new EventArgs());\n            }\n        }\n        private void UserRuleFileWatcher_Changed(object sender, FileSystemEventArgs e)\n        {
                string polipoConfig = Resources.polipo_config; \n                polipoConfig = polipoConfig.Replace("__SOCKS_PORT__", server.local_port.ToString());\n                polipoConfig = polipoConfig.Replace("__POLIPO_BIND_IP__", configuration.shareOverLan ? "0.0.0.0" : "127.0.0.1");\n                FileManager.ByteArrayToFile(temppath + "/polipo.conf", System.Text.Encoding.UTF8.GetBytes(polipoConfig));\n                FileManager.UncompressFile(temppath + "/ss_polipo.exe", Resources.polipo_exe);\n                _process = new Process();\n                // Configure the process using the StartInfo properties.\n                _process.StartInfo.FileName = temppath + "/ss_polipo.exe";\n                _process.StartInfo.Arguments = "-c \"" + temppath + "/polipo.conf\"";\n                _process.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;
                polipoConfig = polipoConfig.Replace("__POLIPO_BIND_IP__", configuration.shareOverLan ? "0.0.0.0" : "127.0.0.1");\n                FileManager.ByteArrayToFile(temppath + "/polipo.conf", System.Text.Encoding.UTF8.GetBytes(polipoConfig));\n                FileManager.UncompressFile(temppath + "/ss_polipo.exe", Resources.polipo_exe);\n                _process = new Process();\n                // Configure the process using the StartInfo properties.\n                _process.StartInfo.FileName = temppath + "/ss_polipo.exe";\n                _process.StartInfo.Arguments = "-c \"" + temppath + "/polipo.conf\"";\n                _process.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;\n                _process.StartInfo.UseShellExecute = false;\n                _process.StartInfo.CreateNoWindow = true;
        private void LoadCurrentConfiguration()\n        {\n            Configuration config = controller.GetConfiguration();\n            UpdateServersMenu();\n            enableItem.Checked = config.enabled;\n            modeItem.Enabled = config.enabled;\n            globalModeItem.Checked = config.global;\n            PACModeItem.Checked = !config.global;\n            ShareOverLANItem.Checked = config.shareOverLan;\n            AutoStartupItem.Checked = AutoStartup.Check();
            }\n        }\n        private void OnlinePACItem_Click(object sender, EventArgs e)\n        {\n            if (!onlinePACItem.Checked)\n            {
﻿using System;
﻿using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.IO.Compression;
using System.IO.Compression;\nusing System.Text;\nnamespace Shadowsocks.Controller\n{\n    public class FileManager\n    {\n        public static bool ByteArrayToFile(string fileName, byte[] content)\n        {\n            try\n            {
            catch (Exception _Exception)\n            {\n                Console.WriteLine("Exception caught in process: {0}",\n                                  _Exception.ToString());\n            }\n            return false;\n        }\n        public static void UncompressFile(string fileName, byte[] content)\n        {\n            FileStream destinationFile = File.Create(fileName);
                Console.WriteLine("Exception caught in process: {0}",\n                                  _Exception.ToString());\n            }\n            return false;\n        }\n        public static void UncompressFile(string fileName, byte[] content)\n        {\n            FileStream destinationFile = File.Create(fileName);\n                while (true)\n                {
{\n    public class Logging\n    {\n        public static string LogFilePath;\n        public static bool OpenLogFile()\n        {\n            try\n            {\n                LogFilePath = Utils.GetTempPath("shadowsocks.log");
        public static void Error(object o)\n        {
        public static void Error(object o)\n        {\n            Console.WriteLine("[E] " + o);\n        }\n        public static void Info(object o)\n        {
        public static void Error(object o)\n        {\n            Console.WriteLine("[E] " + o);\n        }\n        public static void Info(object o)\n        {\n            Console.WriteLine(o);\n        }\n        public static void Debug(object o)\n        {\n#if DEBUG
                }\n            }\n            catch (Exception ex)\n            {\n                if (Error != null)\n                {\n                    Error(this, new ErrorEventArgs(ex));\n                }\n            }\n        }
            {\n                if (Error != null)\n                {\n                    Error(this, new ErrorEventArgs(ex));\n                }\n            }\n        }\n        public void UpdatePACFromGFWList()\n        {\n            WebClient http = new WebClient();
                    if (trafficInfoQueue.Count > queueMaxLength)\n                        trafficInfoQueue.Dequeue();\n                }\n            }\n        }\n        private void UpdateTexts()\n        {\n            FileMenuItem.Text = I18N.GetString("&File");\n            OpenLocationMenuItem.Text = I18N.GetString("&Open Location");\n            ExitMenuItem.Text = I18N.GetString("E&xit");
        private void UpdateTexts()\n        {\n            FileMenuItem.Text = I18N.GetString("&File");\n            OpenLocationMenuItem.Text = I18N.GetString("&Open Location");\n            ExitMenuItem.Text = I18N.GetString("E&xit");\n            CleanLogsButton.Text = I18N.GetString("&Clean Logs");\n            ChangeFontButton.Text = I18N.GetString("Change &Font");\n            WrapTextCheckBox.Text = I18N.GetString("&Wrap Text");\n            TopMostCheckBox.Text = I18N.GetString("&Top Most");\n            ViewMenuItem.Text = I18N.GetString("&View");
        }\n        private void ExitMenuItem_Click(object sender, EventArgs e)\n        {\n            Close();\n        }\n        private void LogForm_Shown(object sender, EventArgs e)\n        {\n            LogMessageTextBox.ScrollToCaret();\n        }\n        #region Clean up the content in LogMessageTextBox.
        {\n            LogMessageTextBox.ScrollToCaret();\n        }\n        #region Clean up the content in LogMessageTextBox.\n        private void DoCleanLogs()\n        {\n            Logging.Clear();\n            lastOffset = 0;\n            LogMessageTextBox.Clear();\n        }
            System.Windows.Forms.DataVisualization.Charting.ChartArea chartArea1 = new System.Windows.Forms.DataVisualization.Charting.ChartArea();\n            System.Windows.Forms.DataVisualization.Charting.Legend legend1 = new System.Windows.Forms.DataVisualization.Charting.Legend();\n            System.Windows.Forms.DataVisualization.Charting.Series series1 = new System.Windows.Forms.DataVisualization.Charting.Series();\n            System.Windows.Forms.DataVisualization.Charting.Series series2 = new System.Windows.Forms.DataVisualization.Charting.Series();\n            this.LogMessageTextBox = new System.Windows.Forms.TextBox();\n            this.MainMenu = new System.Windows.Forms.MainMenu(this.components);\n            this.FileMenuItem = new System.Windows.Forms.MenuItem();\n            this.OpenLocationMenuItem = new System.Windows.Forms.MenuItem();\n            this.ExitMenuItem = new System.Windows.Forms.MenuItem();\n            this.ViewMenuItem = new System.Windows.Forms.MenuItem();
            this.ExitMenuItem = new System.Windows.Forms.MenuItem();\n            this.ViewMenuItem = new System.Windows.Forms.MenuItem();\n            this.CleanLogsMenuItem = new System.Windows.Forms.MenuItem();\n            this.ChangeFontMenuItem = new System.Windows.Forms.MenuItem();\n            this.WrapTextMenuItem = new System.Windows.Forms.MenuItem();\n            this.TopMostMenuItem = new System.Windows.Forms.MenuItem();\n            this.MenuItemSeparater = new System.Windows.Forms.MenuItem();\n            this.ShowToolbarMenuItem = new System.Windows.Forms.MenuItem();\n            this.TopMostCheckBox = new System.Windows.Forms.CheckBox();\n            this.ChangeFontButton = new System.Windows.Forms.Button();
            this.CleanLogsMenuItem,\n            this.ChangeFontMenuItem,\n            this.WrapTextMenuItem,\n            this.TopMostMenuItem,\n            this.MenuItemSeparater,\n            this.ShowToolbarMenuItem});\n            this.ViewMenuItem.Text = "&View";\n            // 

        private System.Windows.Forms.Button CleanLogsButton;\n        private System.Windows.Forms.Button ChangeFontButton;\n        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel1;\n        private System.Windows.Forms.CheckBox TopMostCheckBox;\n        private System.Windows.Forms.MenuItem ViewMenuItem;
                    if (localeNames[i] == locale)\n                        targetIndex = i;\n                }\n                // Fallback to same language with different region\n                if (targetIndex == -1)\n                {\n                    string localeNoRegion = locale.Split('-')[0];\n                    for (int i = 0; i < localeNames.Length; i++)\n                    {\n                        if (localeNames[i].Split('-')[0] == localeNoRegion)
                }\n                // Fallback to same language with different region\n                if (targetIndex == -1)\n                {\n                    string localeNoRegion = locale.Split('-')[0];\n                    for (int i = 0; i < localeNames.Length; i++)\n                    {\n                        if (localeNames[i].Split('-')[0] == localeNoRegion)\n                        {\n                            targetIndex = i;
                    string localeNoRegion = locale.Split('-')[0];\n                    for (int i = 0; i < localeNames.Length; i++)\n                    {\n                        if (localeNames[i].Split('-')[0] == localeNoRegion)\n                        {\n                            targetIndex = i;\n                        }\n                    }\n                }\n                // Still not found, exit
            connection.BeginSend(response, 0, response.Length, SocketFlags.None, new AsyncCallback(ReadAll), true);\n        }\n        private void ReadAll(IAsyncResult ar)\n        {\n            if (_closed) return;\n            try\n            {\n                if (ar.AsyncState != null)\n                {\n                    connection.EndSend(ar);
                {\n                    connection.EndSend(ar);\n                    Logging.Debug(remote.LocalEndPoint, remote.DestEndPoint, RecvSize, "TCP Relay");\n                    connection.BeginReceive(_connetionRecvBuffer, 0, RecvSize, SocketFlags.None, new AsyncCallback(ReadAll), null);\n                }\n                else\n                {\n                    int bytesRead = connection.EndReceive(ar);\n                    if (bytesRead > 0)\n                    {
        private class ServerTimer : Timer\n        {\n            public Server Server;\n            public ServerTimer(int p) : base(p) { }\n        }\n        private void StartConnect()\n        {\n            try\n            {\n                CreateRemote();
        }\n        private void StartConnect()\n        {\n            try\n            {\n                CreateRemote();\n                bool parsed = IPAddress.TryParse(server.server, out ipAddress);\n                if (!parsed)\n                {\n                    IPHostEntry ipHostInfo = Dns.GetHostEntry(server.server);\n                    ipAddress = ipHostInfo.AddressList[0];\n                }\n                IPEndPoint destEP = new IPEndPoint(ipAddress, server.server_port);\n                // Setting up proxy\n                IPEndPoint proxyEP;\n                if (_config.useProxy)\n                {
                    if (!parsed)\n                    {
                    if (!parsed)\n                    {\n                    proxyEP = destEP;\n                }\n                ProxyTimer proxyTimer = new ProxyTimer(3000);\n                proxyTimer.AutoReset = false;\n                proxyTimer.Elapsed += proxyConnectTimer_Elapsed;\n                proxyTimer.Enabled = true;
        private Socket _remote;\n        public EndPoint LocalEndPoint => _remote.LocalEndPoint;
        private Socket _remote;\n        public EndPoint LocalEndPoint => _remote.LocalEndPoint;\n        public EndPoint ProxyEndPoint { get; private set; }\n        public EndPoint DestEndPoint { get; private set; }\n        public void BeginConnectProxy(EndPoint remoteEP, AsyncCallback callback, object state)\n        {\n            // do nothing
        public EndPoint DestEndPoint { get; private set; }\n        public void BeginConnectProxy(EndPoint remoteEP, AsyncCallback callback, object state)\n        {\n            // do nothing\n            ProxyEndPoint = remoteEP;\n            var r = new FakeAsyncResult(state);\n            callback?.Invoke(r);\n        }\n        public void EndConnectProxy(IAsyncResult asyncResult)\n        {\n            // do nothing\n        }
            if (_remote == null)\n            {\n                _remote = new Socket(remoteEP.AddressFamily, SocketType.Stream, ProtocolType.Tcp);\n                _remote.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n            }
﻿using System;\nusing System.Net;\nusing System.Net.Sockets;\nnamespace Shadowsocks.Proxy\n{\n    public interface IProxy\n    {\n        EndPoint LocalEndPoint { get; }\n        EndPoint ProxyEndPoint { get; }
namespace Shadowsocks.Proxy\n{\n    public interface IProxy\n    {\n        EndPoint LocalEndPoint { get; }\n        EndPoint ProxyEndPoint { get; }\n        EndPoint DestEndPoint { get; }\n        void BeginConnectProxy(EndPoint remoteEP, AsyncCallback callback, object state);\n        void EndConnectProxy(IAsyncResult asyncResult);
    {\n        private string code;\n        public QRCodeForm(string code)\n        {\n            this.code = code;\n            InitializeComponent();\n        }\n        private void GenQR(string ssconfig)\n        {\n            string qrText = ssconfig;
        private void GenQR(string ssconfig)\n        {\n            string qrText = ssconfig;\n            QRCode4CS.QRCode qrCoded = new QRCode4CS.QRCode(6, QRErrorCorrectLevel.H);\n            qrCoded.AddData(qrText);\n            qrCoded.Make();\n            int blockSize = 5;\n            Bitmap drawArea = new Bitmap((qrCoded.GetModuleCount() * blockSize), (qrCoded.GetModuleCount() * blockSize));
            string qrText = ssconfig;\n            QRCode4CS.QRCode qrCoded = new QRCode4CS.QRCode(6, QRErrorCorrectLevel.H);\n            qrCoded.AddData(qrText);\n            qrCoded.Make();\n            int blockSize = 5;\n            Bitmap drawArea = new Bitmap((qrCoded.GetModuleCount() * blockSize), (qrCoded.GetModuleCount() * blockSize));\n            for (int row = 0; row < qrCoded.GetModuleCount(); row++)\n            {
            QRCode4CS.QRCode qrCoded = new QRCode4CS.QRCode(6, QRErrorCorrectLevel.H);\n            qrCoded.AddData(qrText);\n            qrCoded.Make();\n            int blockSize = 5;\n            Bitmap drawArea = new Bitmap((qrCoded.GetModuleCount() * blockSize), (qrCoded.GetModuleCount() * blockSize));\n            for (int row = 0; row < qrCoded.GetModuleCount(); row++)\n            {\n                for (int col = 0; col < qrCoded.GetModuleCount(); col++)\n                {
            qrCoded.Make();\n            int blockSize = 5;\n            Bitmap drawArea = new Bitmap((qrCoded.GetModuleCount() * blockSize), (qrCoded.GetModuleCount() * blockSize));\n            for (int row = 0; row < qrCoded.GetModuleCount(); row++)\n            {\n                for (int col = 0; col < qrCoded.GetModuleCount(); col++)\n                {\n                    bool isDark = qrCoded.IsDark(row, col);\n                    if (isDark)\n                    {
            Bitmap drawArea = new Bitmap((qrCoded.GetModuleCount() * blockSize), (qrCoded.GetModuleCount() * blockSize));\n            for (int row = 0; row < qrCoded.GetModuleCount(); row++)\n            {\n                for (int col = 0; col < qrCoded.GetModuleCount(); col++)\n                {\n                    bool isDark = qrCoded.IsDark(row, col);\n                    if (isDark)\n                    {\n                        for (int y = 0; y < blockSize; y++)\n                        {
                for (int col = 0; col < qrCoded.GetModuleCount(); col++)\n                {\n                    bool isDark = qrCoded.IsDark(row, col);\n                    if (isDark)\n                    {\n                        for (int y = 0; y < blockSize; y++)\n                        {\n                            int myCol = (blockSize * (col - 1)) + (y + blockSize);\n                            for (int x = 0; x < blockSize; x++)\n                            {
            {\n                return false;\n            }\n        }\n        public static Configuration Load()\n        {\n            try\n            {\n                string configContent = File.ReadAllText(CONFIG_FILE);
                if (config.proxy == null)\n                    config.proxy = new ProxyConfig();\n                if (config.hotkey == null)\n                    config.hotkey = new HotkeyConfig();\n                if (!System.Net.Sockets.Socket.OSSupportsIPv6)\n                {\n                    config.isIPv6Enabled = false; // disable IPv6 if os not support\n                }\n                //TODO if remote host(server) do not support IPv6 (or DNS resolve AAAA TYPE record) disable IPv6?\n                config.proxy.CheckConfig();
                }\n                //TODO if remote host(server) do not support IPv6 (or DNS resolve AAAA TYPE record) disable IPv6?\n                config.proxy.CheckConfig();\n                {\n                    // todo: route the error to UI since there is no log file in this scenario\n                    logger.Error(e, "Cannot get the log level from NLog config file. Please check if the nlog config file exists with corresponding XML nodes.");\n                }\n                return config;\n            }\n            catch (Exception e)\n            {\n                if (!(e is FileNotFoundException))\n                    logger.LogUsefulException(e);
        {\n            LogMessageTextBox.WordWrap = WrapTextCheckBox.Checked;\n            LogMessageTextBox.ScrollToCaret();\n        }\n        private void CleanLogsButton_Click(object sender, EventArgs e)\n        {\n            LogMessageTextBox.Clear();\n        }\n        private void ChangeFontButton_Click(object sender, EventArgs e)\n        {
            LogMessageTextBox.ScrollToCaret();\n        }\n        private void CleanLogsButton_Click(object sender, EventArgs e)\n        {\n            LogMessageTextBox.Clear();\n        }\n        private void ChangeFontButton_Click(object sender, EventArgs e)\n        {\n            FontDialog fd = new FontDialog();\n            fd.Font = LogMessageTextBox.Font;\n            if (fd.ShowDialog() == DialogResult.OK)\n            {
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]\n        internal static global::System.Globalization.CultureInfo Culture {\n            get {\n                return resourceCulture;\n            }\n            set {\n                resourceCulture = value;\n            }\n        }\n        /// <summary>
            remarks = "";\n            timeout = DefaultServerTimeoutSec;\n        }\n        public static List<Server> GetServers(string ssURL)\n        {\n            var serverUrls = ssURL.Split('\r', '\n');\n            List<Server> servers = new List<Server>();\n            foreach (string serverUrl in serverUrls)\n            {
                Uri parsedUrl;\n                try\n                {
                    parsedUrl = new Uri(serverUrl);\n                }\n                catch (UriFormatException)\n                {\n                    continue;\n                }\n                Server tmp = new Server\n                {\n                    remarks = parsedUrl.GetComponents(UriComponents.Fragment, UriFormat.Unescaped)\n                };
            this.tableLayoutPanel1.Controls.Add(this.RemarksTextBox, 1, 5);\n            this.tableLayoutPanel1.Controls.Add(this.RemarksLabel, 0, 5);\n            this.tableLayoutPanel1.Controls.Add(this.IPLabel, 0, 0);\n            this.tableLayoutPanel1.Controls.Add(this.ServerPortLabel, 0, 1);\n            this.tableLayoutPanel1.Controls.Add(this.PasswordLabel, 0, 2);\n            this.tableLayoutPanel1.Controls.Add(this.IPTextBox, 1, 0);\n            this.tableLayoutPanel1.Controls.Add(this.ServerPortTextBox, 1, 1);\n            this.tableLayoutPanel1.Controls.Add(this.PasswordTextBox, 1, 2);\n            this.tableLayoutPanel1.Controls.Add(this.EncryptionLabel, 0, 3);\n            this.tableLayoutPanel1.Controls.Add(this.EncryptionSelect, 1, 3);
            this.tableLayoutPanel1.Controls.Add(this.ServerPortTextBox, 1, 1);\n            this.tableLayoutPanel1.Controls.Add(this.PasswordTextBox, 1, 2);\n            this.tableLayoutPanel1.Controls.Add(this.EncryptionLabel, 0, 3);\n            this.tableLayoutPanel1.Controls.Add(this.EncryptionSelect, 1, 3);\n            this.tableLayoutPanel1.Controls.Add(this.OneTimeAuth, 1, 6);\n            this.tableLayoutPanel1.Location = new System.Drawing.Point(8, 21);\n            this.tableLayoutPanel1.Margin = new System.Windows.Forms.Padding(0);\n            this.tableLayoutPanel1.Name = "tableLayoutPanel1";\n            this.tableLayoutPanel1.Padding = new System.Windows.Forms.Padding(3);
        private void InitializeComponent()\n        {\n            this.tableLayoutPanel1 = new System.Windows.Forms.TableLayoutPanel();\n            this.tableLayoutPanel3 = new System.Windows.Forms.TableLayoutPanel();\n            this.MyCancelButton = new System.Windows.Forms.Button();\n            this.OKButton = new System.Windows.Forms.Button();\n            this.UseProxyCheckBox = new System.Windows.Forms.CheckBox();\n            this.tableLayoutPanel2 = new System.Windows.Forms.TableLayoutPanel();\n            this.ProxyAddrLabel = new System.Windows.Forms.Label();\n            this.ProxyServerTextBox = new System.Windows.Forms.TextBox();

            // \n            // ProxyServerTextBox\n            // \n            this.ProxyServerTextBox.Location = new System.Drawing.Point(74, 3);\n            this.ProxyServerTextBox.MaxLength = 512;\n            this.ProxyServerTextBox.Name = "ProxyServerTextBox";\n            this.ProxyServerTextBox.Size = new System.Drawing.Size(135, 21);\n            this.ProxyServerTextBox.TabIndex = 1;\n            this.ProxyServerTextBox.WordWrap = false;\n            // 
            this.ProxyPortLable.TabIndex = 2;\n            this.ProxyPortLable.Text = "Proxy Port";\n            // ProxyPortTextBox\n            // \n            this.ProxyPortTextBox.Location = new System.Drawing.Point(286, 3);\n            this.ProxyPortTextBox.MaxLength = 10;\n            this.ProxyPortTextBox.Name = "ProxyPortTextBox";\n            this.ProxyPortTextBox.Size = new System.Drawing.Size(100, 21);\n            this.ProxyPortTextBox.TabIndex = 3;\n            this.ProxyPortTextBox.WordWrap = false;\n            // \n            // tableLayoutPanel4\n            // \n            this.tableLayoutPanel4.AutoSize = true;
            this.tableLayoutPanel4.Controls.Add(this.ProxyTypeLabel, 0, 0);\n            this.tableLayoutPanel4.Controls.Add(this.ProxyTypeComboBox, 1, 0);\n            this.tableLayoutPanel4.Location = new System.Drawing.Point(3, 25);\n            this.tableLayoutPanel4.Name = "tableLayoutPanel4";\n            this.tableLayoutPanel4.RowCount = 1;\n            this.tableLayoutPanel4.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel4.Name = "tableLayoutPanel4";\n            this.tableLayoutPanel4.RowCount = 1;\n            this.tableLayoutPanel4.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.ProxyTypeLabel.Anchor = System.Windows.Forms.AnchorStyles.Left;\n            this.ProxyTypeLabel.AutoSize = true;\n            this.ProxyTypeLabel.Location = new System.Drawing.Point(3, 9);\n            this.ProxyTypeLabel.Name = "ProxyTypeLabel";\n            this.ProxyTypeLabel.Size = new System.Drawing.Size(65, 12);\n            this.ProxyTypeLabel.TabIndex = 1;\n            this.ProxyTypeLabel.Text = "Proxy Type";\n            // \n            // ProxyTypeComboBox\n            // 

            newConfig.SaveSize();\n            Configuration.Save(_config);\n            ConfigChanged?.Invoke(this, new EventArgs());\n        }\n        public void SaveHotkeyConfig(HotkeyConfig newConfig)\n        {\n            _config.hotkey = newConfig;\n            SaveConfig(_config);\n            ConfigChanged?.Invoke(this, new EventArgs());\n        }
        {\n            _config.hotkey = newConfig;\n            SaveConfig(_config);\n            ConfigChanged?.Invoke(this, new EventArgs());\n        }\n        public void UpdateLatency(Server server, TimeSpan latency)\n        {\n            if (_config.availabilityStatistics)\n            {
            {\n                availabilityStatistics.UpdateLatency(server, (int)latency.TotalMilliseconds);\n            }\n        }\n        public void UpdateInboundCounter(Server server, long n)\n        {\n            Interlocked.Add(ref _inboundCounter, n);\n            if (_config.availabilityStatistics)\n            {
            {\n                availabilityStatistics.UpdateInboundCounter(server, n);\n            }\n        }\n        public void UpdateOutboundCounter(Server server, long n)\n        {\n            Interlocked.Add(ref _outboundCounter, n);\n            if (_config.availabilityStatistics)\n            {

using Shadowsocks.Controller.Strategy;\nusing Shadowsocks.Encryption;\nusing Shadowsocks.Encryption.AEAD;\nusing Shadowsocks.Encryption.Exception;\nusing Shadowsocks.Model;\nusing Shadowsocks.Proxy;\nusing Shadowsocks.Util.Sockets;\nusing static Shadowsocks.Encryption.EncryptorBase;\nnamespace Shadowsocks.Controller\n{
using Shadowsocks.Encryption.AEAD;\nusing Shadowsocks.Encryption.Exception;\nusing Shadowsocks.Model;\nusing Shadowsocks.Proxy;\nusing Shadowsocks.Util.Sockets;\nusing static Shadowsocks.Encryption.EncryptorBase;\nnamespace Shadowsocks.Controller\n{\n    class TCPRelay : Listener.Service\n    {
using Shadowsocks.Proxy;\nusing Shadowsocks.Util.Sockets;\nusing static Shadowsocks.Encryption.EncryptorBase;\nnamespace Shadowsocks.Controller\n{\n    class TCPRelay : Listener.Service\n    {\n        private static Logger logger = LogManager.GetCurrentClassLogger();\n        private ShadowsocksController _controller;\n        private DateTime _lastSweepTime;
            _lastSweepTime = DateTime.Now;\n        }\n        public override bool Handle(byte[] firstPacket, int length, Socket socket, object state)\n        {\n            if (socket.ProtocolType != ProtocolType.Tcp\n                || (length < 2 || firstPacket[0] != 5))\n                return false;\n            socket.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);
        }\n        public override void Stop()\n        {\n            List<TCPHandler> handlersToClose = new List<TCPHandler>();\n            lock (Handlers)\n            {\n                handlersToClose.AddRange(Handlers);\n            }\n            handlersToClose.ForEach(h => h.Close());\n        }
        {\n            _controller.UpdateOutboundCounter(server, n);\n        }\n        public void UpdateLatency(Server server, TimeSpan latency)\n        {\n            _controller.UpdateLatency(server, latency);\n        }\n    }\n    internal class TCPHandler\n    {
    {\n        class AsyncSession\n        {\n            public IProxy Remote { get; }\n            public AsyncSession(IProxy remote)\n            {\n                Remote = remote;\n            }\n        }
            public T State { get; set; }\n            public AsyncSession(IProxy remote, T state) : base(remote)\n            {\n                State = state;\n            }\n            public AsyncSession(AsyncSession session, T state) : base(session.Remote)\n            {\n                State = state;\n            }\n        }
            }\n        }\n        private static Logger Logger = LogManager.GetCurrentClassLogger();\n        private readonly int _proxyTimeout;\n        // each recv size.\n        public const int RecvSize = 2048;\n        // overhead of one chunk, reserved for AEAD ciphers\n        public const int ChunkOverheadSize = 16 * 2 /* two tags */ + AEADEncryptor.CHUNK_LEN_BYTES;\n        // max chunk size\n        public const uint MaxChunkSize = AEADEncryptor.CHUNK_LEN_MASK + AEADEncryptor.CHUNK_LEN_BYTES + 16 * 2;\n        // In general, the ciphertext length, we should take overhead into account\n        public const int BufferSize = RecvSize + (int)MaxChunkSize + 32 /* max salt len */;\n        public DateTime lastActivity;
        private byte _command;\n        private byte[] _firstPacket;\n        private int _firstPacketLength;\n        private const int CMD_CONNECT = 0x01;\n        private const int CMD_BIND = 0x02;\n        private const int CMD_UDP_ASSOC = 0x03;\n        private int _addrBufLength = -1;\n        private int _totalRead = 0;\n        private int _totalWrite = 0;\n        // remote -> local proxy (ciphertext, before decrypt)
        private byte[] _firstPacket;\n        private int _firstPacketLength;\n        private const int CMD_CONNECT = 0x01;\n        private const int CMD_BIND = 0x02;\n        private const int CMD_UDP_ASSOC = 0x03;\n        private int _addrBufLength = -1;\n        private int _totalRead = 0;\n        private int _totalWrite = 0;\n        // remote -> local proxy (ciphertext, before decrypt)\n        private byte[] _remoteRecvBuffer = new byte[BufferSize];\n        // client -> local proxy (plaintext, before encrypt)
        private int _firstPacketLength;\n        private const int CMD_CONNECT = 0x01;\n        private const int CMD_BIND = 0x02;\n        private const int CMD_UDP_ASSOC = 0x03;\n        private int _addrBufLength = -1;\n        private int _totalRead = 0;\n        private int _totalWrite = 0;\n        // remote -> local proxy (ciphertext, before decrypt)\n        private byte[] _remoteRecvBuffer = new byte[BufferSize];\n        // client -> local proxy (plaintext, before encrypt)\n        private byte[] _connetionRecvBuffer = new byte[BufferSize];\n        // local proxy -> remote (plaintext, after decrypt)
        private const int CMD_CONNECT = 0x01;\n        private const int CMD_BIND = 0x02;\n        private const int CMD_UDP_ASSOC = 0x03;\n        private int _addrBufLength = -1;\n        private int _totalRead = 0;\n        private int _totalWrite = 0;\n        // remote -> local proxy (ciphertext, before decrypt)\n        private byte[] _remoteRecvBuffer = new byte[BufferSize];\n        // client -> local proxy (plaintext, before encrypt)\n        private byte[] _connetionRecvBuffer = new byte[BufferSize];\n        // local proxy -> remote (plaintext, after decrypt)\n        private byte[] _remoteSendBuffer = new byte[BufferSize];\n        // local proxy -> client (ciphertext, before decrypt)
        private bool _remoteShutdown = false;\n        private bool _closed = false;\n        // instance-based lock without static\n        private readonly object _encryptionLock = new object();\n        private readonly object _decryptionLock = new object();\n        private readonly object _closeConnLock = new object();\n        private DateTime _startConnectTime;\n        private DateTime _startReceivingTime;\n        private DateTime _startSendingTime;\n        private EndPoint _destEndPoint = null;
        private readonly object _decryptionLock = new object();\n        private readonly object _closeConnLock = new object();\n        private DateTime _startConnectTime;\n        private DateTime _startReceivingTime;\n        private DateTime _startSendingTime;\n        private EndPoint _destEndPoint = null;\n        public TCPHandler(ShadowsocksController controller, Configuration config, TCPRelay tcprelay, Socket socket)\n        {\n            _controller = controller;
        }\n        public void CreateRemote()\n        {\n            Server server = _controller.GetAServer(IStrategyCallerType.TCP, (IPEndPoint)_connection.RemoteEndPoint,\n                _destEndPoint);\n            if (server == null || server.server == "")\n                throw new ArgumentException("No server configured");\n            _encryptor = EncryptorFactory.GetEncryptor(server.method, server.password);
        }\n        public void Close()\n        {\n            lock (_closeConnLock)\n            {
        }\n        public void Close()\n        {\n            lock (_closeConnLock)\n            {\n                if (_closed) return;\n                _closed = true;\n            }
                        // reject socks 4\n                        response = new byte[] { 0, 91 };\n                        Logger.Error("socks 5 protocol error");\n                    }\n                    _connection.BeginSend(response, 0, response.Length, SocketFlags.None,\n                        HandshakeSendCallback, null);\n                }\n                else\n                    Close();
                    Close();\n            }\n            catch (Exception e)\n            {\n                Logger.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void HandshakeSendCallback(IAsyncResult ar)\n        {
            }\n        }\n        private void HandshakeSendCallback(IAsyncResult ar)\n        {\n            if (_closed) return;\n            try\n            {\n                _connection.EndSend(ar);\n                // +-----+-----+-------+------+----------+----------+\n                // | VER | CMD |  RSV  | ATYP | DST.ADDR | DST.PORT |\n                // +-----+-----+-------+------+----------+----------+\n                // |  1  |  1  | X'00' |  1   | Variable |    2     |\n                // +-----+-----+-------+------+----------+----------+\n                // Skip first 3 bytes, and read 2 more bytes to analysis the address.\n                // 2 more bytes is designed if address is domain then we don't need to read once more to get the addr length.
                }\n                else\n                {\n                    Logger.Debug(\n                        "failed to recv data in Shadowsocks.Controller.TCPHandler.handshakeReceive2Callback()");\n                    Close();\n                }\n            }\n            catch (Exception e)\n            {
        }\n        private void ResponseCallback(IAsyncResult ar)\n        {\n            try\n            {\n                _connection.EndSend(ar);\n                ReadAddress(StartConnect);\n            }\n            catch (Exception e)\n            {
        private void ReadAddress(int bytesRemain, Action onSuccess)\n        {\n            // drop [ VER | CMD |  RSV  ]\n            Array.Copy(_connetionRecvBuffer, 3, _connetionRecvBuffer, 0, ADDR_ATYP_LEN + 1);\n            // Read the remain address bytes\n            _connection.BeginReceive(_connetionRecvBuffer, 2, RecvSize - 2, SocketFlags.None, OnAddressFullyRead,\n                new object[] { bytesRemain, onSuccess });\n        }\n        private void OnAddressFullyRead(IAsyncResult ar)\n        {
            _connection.BeginReceive(_connetionRecvBuffer, 2, RecvSize - 2, SocketFlags.None, OnAddressFullyRead,\n                new object[] { bytesRemain, onSuccess });\n        }\n        private void OnAddressFullyRead(IAsyncResult ar)\n        {\n            if (_closed) return;\n            try\n            {\n                int bytesRead = _connection.EndReceive(ar);
        }\n        private void OnAddressFullyRead(IAsyncResult ar)\n        {\n            if (_closed) return;\n            try\n            {\n                int bytesRead = _connection.EndReceive(ar);\n                var states = (object[])ar.AsyncState;\n                int bytesRemain = (int)states[0];
                {\n                    int bytesRead = _connection.EndReceive(ar);\n                    if (bytesRead > 0)\n                    {\n                        _connection.BeginReceive(_connetionRecvBuffer, 0, RecvSize, SocketFlags.None,\n                            ReadAll, null);\n                    }\n                    else\n                        Close();
                    {\n                        case ProxyConfig.PROXY_SOCKS5:\n                            remote = new Socks5Proxy();\n                            break;\n                        case ProxyConfig.PROXY_HTTP:\n                            remote = new HttpProxy();\n                            break;\n                        default:\n                            throw new NotSupportedException("Unknown forward proxy.");\n                    }
                            break;\n                        default:\n                            throw new NotSupportedException("Unknown forward proxy.");\n                    }\n                    proxyEP = SocketUtil.GetEndPoint(_config.proxy.proxyServer, _config.proxy.proxyPort);\n                }\n                else\n                {\n                    remote = new DirectConnect();\n                }
                proxyTimer.Session = session;\n                proxyTimer.DestEndPoint = serverEP;\n                proxyTimer.Server = _server;\n                _proxyConnected = false;\n                // Connect to the proxy server.\n                remote.BeginConnectProxy(proxyEP, ProxyConnectCallback,\n                    new AsyncSession<ProxyTimer>(remote, proxyTimer));\n            }\n            catch (Exception e)\n            {
                remote.BeginConnectProxy(proxyEP, ProxyConnectCallback,\n                    new AsyncSession<ProxyTimer>(remote, proxyTimer));\n            }\n            catch (Exception e)\n            {\n                Logger.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void ProxyConnectTimer_Elapsed(object sender, ElapsedEventArgs e)\n        {
        private void ProxyConnectTimer_Elapsed(object sender, ElapsedEventArgs e)\n        {\n            var timer = (ProxyTimer)sender;\n            timer.Elapsed -= ProxyConnectTimer_Elapsed;\n            timer.Enabled = false;\n            timer.Dispose();\n            if (_proxyConnected || _destConnected || _closed)\n            {\n                return;\n            }
            Close();\n        }\n        private void ProxyConnectCallback(IAsyncResult ar)\n        {\n            if (_closed)\n            {\n                return;\n            }\n            try\n            {
        private void ProxyConnectCallback(IAsyncResult ar)\n        {\n            if (_closed)\n            {\n                return;\n            }\n            try\n            {\n                var session = (AsyncSession<ProxyTimer>)ar.AsyncState;\n                ProxyTimer timer = session.State;
            }\n            try\n            {\n                var session = (AsyncSession<ProxyTimer>)ar.AsyncState;\n                ProxyTimer timer = session.State;\n                var destEndPoint = timer.DestEndPoint;\n                var server = timer.Server;\n                timer.Elapsed -= ProxyConnectTimer_Elapsed;\n                timer.Enabled = false;\n                timer.Dispose();
                    Logger.Debug($"Socket connected to proxy {remote.ProxyEndPoint}");\n                }\n                _startConnectTime = DateTime.Now;\n                ServerTimer connectTimer = new ServerTimer(_serverTimeout) { AutoReset = false };\n                connectTimer.Elapsed += DestConnectTimer_Elapsed;\n                connectTimer.Enabled = true;\n                connectTimer.Session = session;\n                connectTimer.Server = server;\n                _destConnected = false;\n                NetworkCredential auth = null;
                    auth = new NetworkCredential(_config.proxy.authUser, _config.proxy.authPwd);\n                }\n                // Connect to the remote endpoint.\n                remote.BeginConnectDest(destEndPoint, ConnectCallback,\n                    new AsyncSession<ServerTimer>(session, connectTimer), auth);\n            }\n            catch (ArgumentException)\n            {\n            }\n            catch (Exception e)\n            {
            catch (ArgumentException)\n            {\n            }\n            catch (Exception e)\n            {\n                Logger.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void DestConnectTimer_Elapsed(object sender, ElapsedEventArgs e)\n        {
        private void DestConnectTimer_Elapsed(object sender, ElapsedEventArgs e)\n        {\n            var timer = (ServerTimer)sender;\n            timer.Elapsed -= DestConnectTimer_Elapsed;\n            timer.Enabled = false;\n            timer.Dispose();\n            if (_destConnected || _closed)\n            {\n                return;\n            }
            var timer = (ServerTimer)sender;\n            timer.Elapsed -= DestConnectTimer_Elapsed;\n            timer.Enabled = false;\n            timer.Dispose();\n            if (_destConnected || _closed)\n            {\n                return;\n            }\n            var session = timer.Session;\n            Server server = timer.Server;
            }\n            var session = timer.Session;\n            Server server = timer.Server;\n            IStrategy strategy = _controller.GetCurrentStrategy();\n            strategy?.SetFailure(server);\n            Logger.Info($"{server.FriendlyName()} timed out");\n            session.Remote.Close();\n            Close();\n        }\n        private void ConnectCallback(IAsyncResult ar)\n        {
            if (_closed) return;\n            try\n            {\n                var session = (AsyncSession<ServerTimer>)ar.AsyncState;\n                ServerTimer timer = session.State;\n                _server = timer.Server;\n                timer.Elapsed -= DestConnectTimer_Elapsed;\n                timer.Enabled = false;\n                timer.Dispose();
                var session = (AsyncSession<ServerTimer>)ar.AsyncState;\n                ServerTimer timer = session.State;\n                _server = timer.Server;\n                timer.Elapsed -= DestConnectTimer_Elapsed;\n                timer.Enabled = false;\n                timer.Dispose();\n                var remote = session.Remote;\n                // Complete the connection.\n                remote.EndConnectDest(ar);\n                _destConnected = true;\n                Logger.Debug($"Socket connected to ss server: {_server.FriendlyName()}");
                _tcprelay.UpdateLatency(_server, latency);\n                StartPipe(session);\n            }\n            catch (ArgumentException)\n            {\n            }\n            catch (Exception e)\n            {\n                if (_server != null)\n                {
                }\n                Logger.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void TryReadAvailableData()\n        {\n            int available = Math.Min(_connection.Available, RecvSize - _firstPacketLength);\n            if (available > 0)\n            {
            int available = Math.Min(_connection.Available, RecvSize - _firstPacketLength);\n            if (available > 0)\n            {\n                var size = _connection.Receive(_connetionRecvBuffer, _firstPacketLength, available,\n                    SocketFlags.None);\n                _firstPacketLength += size;\n            }\n        }\n        private void StartPipe(AsyncSession session)\n        {
            {\n                _startReceivingTime = DateTime.Now;\n                session.Remote.BeginReceive(_remoteRecvBuffer, 0, RecvSize, SocketFlags.None,\n                    PipeRemoteReceiveCallback, session);\n                TryReadAvailableData();\n                Logger.Trace($"_firstPacketLength = {_firstPacketLength}");\n                SendToServer(_firstPacketLength, session);\n            }\n            catch (Exception e)\n            {
                Logger.Trace($"_firstPacketLength = {_firstPacketLength}");\n                SendToServer(_firstPacketLength, session);\n            }\n            catch (Exception e)\n            {\n                Logger.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void PipeRemoteReceiveCallback(IAsyncResult ar)\n        {
        }\n        private void PipeRemoteReceiveCallback(IAsyncResult ar)\n        {\n            if (_closed) return;\n            try\n            {\n                var session = (AsyncSession)ar.AsyncState;\n                int bytesRead = session.Remote.EndReceive(ar);\n                _totalRead += bytesRead;
                }\n                else\n                {\n                    _connection.Shutdown(SocketShutdown.Send);\n                    _connectionShutdown = true;\n                    CheckClose();\n                }\n            }\n            catch (Exception e)\n            {
                    CheckClose();\n                }\n            }\n            catch (Exception e)\n            {\n                Logger.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void PipeConnectionReceiveCallback(IAsyncResult ar)\n        {
                Close();\n            }\n        }\n        private void PipeConnectionReceiveCallback(IAsyncResult ar)\n        {\n            if (_closed) return;\n            try\n            {\n                int bytesRead = _connection.EndReceive(ar);
                {\n                    _encryptor.Encrypt(_connetionRecvBuffer, length, _connetionSendBuffer, out bytesToSend);\n                }\n                catch (CryptoErrorException)\n                {\n                    Logger.Debug("encryption error");\n                    Close();\n                    return;\n                }\n            }
                {\n                    Logger.Debug("encryption error");\n                    Close();\n                    return;\n                }\n            }\n            _tcprelay.UpdateOutboundCounter(_server, bytesToSend);\n            _startSendingTime = DateTime.Now;\n            session.Remote.BeginSend(_connetionSendBuffer, 0, bytesToSend, SocketFlags.None,\n                PipeRemoteSendCallback, new object[] { session, bytesToSend });
                }\n            }\n            _tcprelay.UpdateOutboundCounter(_server, bytesToSend);\n            _startSendingTime = DateTime.Now;\n            session.Remote.BeginSend(_connetionSendBuffer, 0, bytesToSend, SocketFlags.None,\n                PipeRemoteSendCallback, new object[] { session, bytesToSend });\n            IStrategy strategy = _controller.GetCurrentStrategy();\n            strategy?.UpdateLastWrite(_server);\n        }\n        private void PipeRemoteSendCallback(IAsyncResult ar)\n        {
                    Buffer.BlockCopy(_connetionSendBuffer, bytesSent, _connetionSendBuffer, 0, bytesRemaining);\n                    session.Remote.BeginSend(_connetionSendBuffer, 0, bytesRemaining, SocketFlags.None,\n                        PipeRemoteSendCallback, new object[] { session, bytesRemaining });\n                    return;\n                }\n                _connection.BeginReceive(_connetionRecvBuffer, 0, RecvSize, SocketFlags.None,\n                    PipeConnectionReceiveCallback, session);\n            }\n            catch (Exception e)\n            {
            }\n            catch (Exception e)\n            {\n                Logger.LogUsefulException(e);\n                Close();\n            }\n        }\n        // In general, we assume there is no delay between local proxy and client, add this for sanity\n        private void PipeConnectionSendCallback(IAsyncResult ar)\n        {\n            try\n            {
            // \n            // EncryptionSelect\n            // \n            this.EncryptionSelect.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) \n            | System.Windows.Forms.AnchorStyles.Right)));\n            this.EncryptionSelect.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;\n            this.EncryptionSelect.FormattingEnabled = true;\n            this.EncryptionSelect.ImeMode = System.Windows.Forms.ImeMode.NoControl;\n            this.EncryptionSelect.ItemHeight = 12;\n            this.EncryptionSelect.Items.AddRange(new object[] {
            this.EncryptionSelect.FormattingEnabled = true;\n            this.EncryptionSelect.ImeMode = System.Windows.Forms.ImeMode.NoControl;\n            this.EncryptionSelect.ItemHeight = 12;\n            this.EncryptionSelect.Items.AddRange(new object[] {\n            "table",\n            "rc4-md5",\n            "salsa20",\n            "chacha20",\n            "aes-256-cfb",\n            "aes-192-cfb",
                Thread t = new Thread(new ThreadStart(RunSinglePolarSSLEncryptionThread));\n                threads.Add(t);\n                t.Start();\n            }\n            foreach (Thread t in threads)\n            {\n                t.Join();\n            }\n            Assert.IsFalse(encryptionFailed);\n        }
            {\n                t.Join();\n            }\n            Assert.IsFalse(encryptionFailed);\n        }\n        private static bool encryptionFailed = false;\n        private static object locker = new object();\n        private void RunSinglePolarSSLEncryptionThread()\n        {\n            try\n            {
            }\n            base.Dispose(disposing);\n        }\n        #region Windows Form Designer generated code\n        /// <summary>\n        /// Required method for Designer support - do not modify\n        /// the contents of this method with the code editor.\n        /// </summary>\n        private void InitializeComponent()\n        {
        /// <summary>\n        /// Required method for Designer support - do not modify\n        /// the contents of this method with the code editor.\n        /// </summary>\n        private void InitializeComponent()\n        {\n            this.tableLayoutPanel1 = new System.Windows.Forms.TableLayoutPanel();\n            this.tableLayoutPanel3 = new System.Windows.Forms.TableLayoutPanel();\n            this.MyCancelButton = new System.Windows.Forms.Button();\n            this.OKButton = new System.Windows.Forms.Button();\n            this.UseProxyCheckBox = new System.Windows.Forms.CheckBox();
        {\n            this.tableLayoutPanel1 = new System.Windows.Forms.TableLayoutPanel();\n            this.tableLayoutPanel3 = new System.Windows.Forms.TableLayoutPanel();\n            this.MyCancelButton = new System.Windows.Forms.Button();\n            this.OKButton = new System.Windows.Forms.Button();\n            this.UseProxyCheckBox = new System.Windows.Forms.CheckBox();\n            this.tableLayoutPanel2 = new System.Windows.Forms.TableLayoutPanel();\n            this.ProxyAddrLabel = new System.Windows.Forms.Label();\n            this.ProxyServerTextBox = new System.Windows.Forms.TextBox();\n            this.ProxyPortLabel = new System.Windows.Forms.Label();\n            this.ProxyPortTextBox = new System.Windows.Forms.TextBox();
            this.ProxyPortTextBox = new System.Windows.Forms.TextBox();\n            this.tableLayoutPanel4 = new System.Windows.Forms.TableLayoutPanel();\n            this.ProxyTypeLabel = new System.Windows.Forms.Label();\n            this.ProxyTypeComboBox = new System.Windows.Forms.ComboBox();\n            this.ProxyTimeoutTextBox = new System.Windows.Forms.TextBox();\n            this.ProxyTimeoutLabel = new System.Windows.Forms.Label();\n            this.tableLayoutPanel1.SuspendLayout();
            this.SuspendLayout();\n            // 
            this.MyCancelButton.Dock = System.Windows.Forms.DockStyle.Right;\n            this.MyCancelButton.Name = "MyCancelButton";\n            this.MyCancelButton.Size = new System.Drawing.Size(75, 23);\n            this.MyCancelButton.TabIndex = 13;\n            this.MyCancelButton.Text = "Cancel";\n            this.MyCancelButton.UseVisualStyleBackColor = true;\n            this.MyCancelButton.Click += new System.EventHandler(this.CancelButton_Click);\n            // \n            // OKButton\n            // \n            this.OKButton.DialogResult = System.Windows.Forms.DialogResult.OK;
            // ProxyTypeLabel\n            // \n            this.ProxyTypeLabel.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));\n            this.ProxyTypeLabel.AutoSize = true;
            // ProxyTypeLabel\n            // \n            this.ProxyTypeLabel.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));\n            this.ProxyTypeLabel.AutoSize = true;\n            this.tableLayoutPanel3.ResumeLayout(false);\n            this.tableLayoutPanel2.ResumeLayout(false);\n            this.tableLayoutPanel2.PerformLayout();\n            this.tableLayoutPanel4.ResumeLayout(false);\n            this.tableLayoutPanel4.PerformLayout();\n            this.ResumeLayout(false);
            // ProxyTypeLabel\n            // \n            this.ProxyTypeLabel.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));\n            this.ProxyTypeLabel.AutoSize = true;\n            this.tableLayoutPanel3.ResumeLayout(false);\n            this.tableLayoutPanel2.ResumeLayout(false);\n            this.tableLayoutPanel2.PerformLayout();\n            this.tableLayoutPanel4.ResumeLayout(false);\n            this.tableLayoutPanel4.PerformLayout();\n            this.ResumeLayout(false);\n            this.PerformLayout();\n        }\n        #endregion
            // ProxyTypeLabel\n            // \n            this.ProxyTypeLabel.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));\n            this.ProxyTypeLabel.AutoSize = true;\n            this.tableLayoutPanel3.ResumeLayout(false);\n            this.tableLayoutPanel2.ResumeLayout(false);\n            this.tableLayoutPanel2.PerformLayout();\n            this.tableLayoutPanel4.ResumeLayout(false);\n            this.tableLayoutPanel4.PerformLayout();\n            this.ResumeLayout(false);\n            this.PerformLayout();\n        }\n        #endregion\n        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel1;\n        private System.Windows.Forms.CheckBox UseProxyCheckBox;
            this.ResumeLayout(false);\n            this.PerformLayout();\n        }\n        #endregion\n        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel1;\n        private System.Windows.Forms.CheckBox UseProxyCheckBox;\n        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel2;\n        private System.Windows.Forms.Label ProxyAddrLabel;\n        private System.Windows.Forms.TextBox ProxyServerTextBox;\n        private System.Windows.Forms.Label ProxyPortLabel;\n        private System.Windows.Forms.TextBox ProxyPortTextBox;
        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel1;\n        private System.Windows.Forms.CheckBox UseProxyCheckBox;\n        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel2;\n        private System.Windows.Forms.Label ProxyAddrLabel;\n        private System.Windows.Forms.TextBox ProxyServerTextBox;\n        private System.Windows.Forms.Label ProxyPortLabel;\n        private System.Windows.Forms.TextBox ProxyPortTextBox;\n        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel3;\n        private System.Windows.Forms.Button MyCancelButton;\n        private System.Windows.Forms.Button OKButton;
            this.OKButton = new System.Windows.Forms.Button();\n            this.MyCancelButton = new System.Windows.Forms.Button();\n            this.panel1 = new System.Windows.Forms.Panel();\n            this.contextMenu1 = new System.Windows.Forms.ContextMenu();\n            this.enableItem = new System.Windows.Forms.MenuItem();\n            this.ServersItem = new System.Windows.Forms.MenuItem();\n            this.SeperatorItem = new System.Windows.Forms.MenuItem();\n            this.ConfigItem = new System.Windows.Forms.MenuItem();\n            this.menuItem4 = new System.Windows.Forms.MenuItem();\n            this.editPACFileItem = new System.Windows.Forms.MenuItem();
            this.editPACFileItem = new System.Windows.Forms.MenuItem();\n            this.QRCodeItem = new System.Windows.Forms.MenuItem();\n            this.aboutItem = new System.Windows.Forms.MenuItem();\n            this.menuItem3 = new System.Windows.Forms.MenuItem();\n            this.quitItem = new System.Windows.Forms.MenuItem();\n            this.panel3 = new System.Windows.Forms.Panel();\n            this.DeleteButton = new System.Windows.Forms.Button();\n            this.AddButton = new System.Windows.Forms.Button();\n            this.ServerGroupBox = new System.Windows.Forms.GroupBox();\n            this.ServersListBox = new System.Windows.Forms.ListBox();
            this.panel3 = new System.Windows.Forms.Panel();\n            this.DeleteButton = new System.Windows.Forms.Button();\n            this.AddButton = new System.Windows.Forms.Button();\n            this.ServerGroupBox = new System.Windows.Forms.GroupBox();\n            this.ServersListBox = new System.Windows.Forms.ListBox();\n            this.LockButton = new System.Windows.Forms.Button();\n            this.panel4 = new System.Windows.Forms.Panel();\n            this.tableLayoutPanel1.SuspendLayout();\n            this.panel1.SuspendLayout();\n            this.panel3.SuspendLayout();\n            this.ServerGroupBox.SuspendLayout();

            this.CancelButton = this.MyCancelButton;\n            this.ClientSize = new System.Drawing.Size(489, 286);
            this.Controls.Add(this.ServerGroupBox);\n            this.Controls.Add(this.panel1);\n            this.Controls.Add(this.panel3);\n            this.Controls.Add(this.panel2);\n            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedSingle;\n            this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));\n            this.MaximizeBox = false;\n            this.Name = "ConfigForm";\n            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;\n            this.Text = "Shadowsocks";
            this.TopMost = true;\n            this.FormClosed += new System.Windows.Forms.FormClosedEventHandler(this.ConfigForm_FormClosed);\n            this.Load += new System.EventHandler(this.ConfigForm_Load);\n            this.Shown += new System.EventHandler(this.ConfigForm_Shown);\n            this.tableLayoutPanel1.ResumeLayout(false);\n            this.tableLayoutPanel1.PerformLayout();\n            this.panel1.ResumeLayout(false);\n            this.panel3.ResumeLayout(false);\n            this.ServerGroupBox.ResumeLayout(false);\n            this.ServerGroupBox.PerformLayout();
            }\n            items.Add(SeperatorItem);\n            items.Add(ConfigItem);\n            if (configuration.index >= 0 && configuration.index < configuration.configs.Count)\n            {\n                items[configuration.index].Checked = true;\n            }\n        }\n        private void ConfigForm_Load(object sender, EventArgs e)\n        {
        }\n        private void ConfigForm_Load(object sender, EventArgs e)\n        {\n            if (controller == null || controller.GetConfiguration().isDefault)\n            {\n                _isFirstRun = true;\n            }\n            else\n            {
        {\n            Server o2 = (Server)obj;\n            return server == o2.server && server_port == o2.server_port;\n        }\n        public string FriendlyName()\n        {\n            if (server.IsNullOrEmpty())\n            {\n                return I18N.GetString("New server");\n            }
        }\n        public string FriendlyName()\n        {\n            if (server.IsNullOrEmpty())\n            {\n                return I18N.GetString("New server");\n            }\n            IPAddress addr;\n            if ( !IPAddress.TryParse( server, out addr ) ) {\n                Logging.Error( "Invalid server IP Address" );\n            }
            {\n                return I18N.GetString("New server");\n            }\n            IPAddress addr;\n            if ( !IPAddress.TryParse( server, out addr ) ) {\n                Logging.Error( "Invalid server IP Address" );\n            }\n                        return $"[{server}]:{server_port}";\n                }\n            } else {\n                switch ( addr.AddressFamily ) {\n                    case AddressFamily.InterNetwork:\n                        return $"{remarks} ({server}:{server_port})";\n                    case AddressFamily.InterNetworkV6:\n                        return $"{remarks} ([{server}]:{server_port})";\n                }\n            }

                topMostTrigger = config.topMost;\n                wrapTextTrigger = config.wrapText;\n                toolbarTrigger = config.toolbarShown;\n                LogMessageTextBox.BackColor = config.GetBackgroundColor();\n                LogMessageTextBox.ForeColor = config.GetTextColor();\n                LogMessageTextBox.Font = config.GetFont();\n            }\n            controller.TrafficChanged += controller_TrafficChanged;\n            UpdateTexts();\n        }
                LogMessageTextBox.ForeColor = config.GetTextColor();\n                LogMessageTextBox.Font = config.GetFont();\n            }\n            controller.TrafficChanged += controller_TrafficChanged;\n            UpdateTexts();\n        }\n        private void controller_TrafficChanged(object sender, EventArgs e)\n        {\n            long maxSpeed = 0;
            outboundPoints.Clear();\n            foreach (var trafficPerSecond in controller.traffic)\n            {\n                inboundPoints.Add(trafficPerSecond.inboundIncreasement);\n                outboundPoints.Add(trafficPerSecond.outboundIncreasement);\n                maxSpeed = Math.Max(maxSpeed, Math.Max(trafficPerSecond.inboundIncreasement, trafficPerSecond.outboundIncreasement));\n            }\n            bandwidthScale = Utils.GetBandwidthScale(maxSpeed);\n            //rescale the original data points, since it is List<float>, .ForEach does not work\n            inboundPoints = inboundPoints.Select(p => p / bandwidthScale.Item3).ToList();\n            outboundPoints = outboundPoints.Select(p => p / bandwidthScale.Item3).ToList();
            this.PluginOptionsLabel.Name = "PluginOptionsLabel";\n            this.PluginOptionsLabel.Size = new System.Drawing.Size(119, 15);\n            this.PluginOptionsLabel.TabIndex = 6;\n            this.PluginOptionsLabel.Text = "Plugin Options";\n            this.toolTip1.SetToolTip(this.PluginOptionsLabel, "Environment variables for plugin program");\n            // \n            // PluginTextBox\n            // \n            this.PluginTextBox.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));\n            this.PluginTextBox.Location = new System.Drawing.Point(151, 165);
            this.PluginTextBox.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));\n            this.PluginTextBox.Location = new System.Drawing.Point(151, 165);\n            this.PluginTextBox.Margin = new System.Windows.Forms.Padding(4, 4, 4, 4);\n            this.PluginTextBox.MaxLength = 256;\n            this.PluginTextBox.Name = "PluginTextBox";\n            this.PluginTextBox.Size = new System.Drawing.Size(235, 25);\n            this.PluginTextBox.TabIndex = 5;\n            this.PluginTextBox.WordWrap = false;\n            // \n            // RemarksTextBox\n            // \n            this.RemarksTextBox.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));\n            this.RemarksTextBox.Location = new System.Drawing.Point(151, 291);
            this.PasswordLabel.Name = "PasswordLabel";\n            this.PasswordLabel.Size = new System.Drawing.Size(71, 15);\n            this.PasswordLabel.TabIndex = 2;\n            this.PasswordLabel.Text = "Password";\n            this.PasswordLabel.TextAlign = System.Drawing.ContentAlignment.MiddleCenter;\n            // \n            // IPTextBox\n            // \n            this.IPTextBox.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));\n            this.IPTextBox.Location = new System.Drawing.Point(151, 8);
            this.IPTextBox.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));\n            this.IPTextBox.Location = new System.Drawing.Point(151, 8);\n            this.IPTextBox.Margin = new System.Windows.Forms.Padding(4, 4, 4, 4);\n            this.IPTextBox.MaxLength = 512;\n            this.IPTextBox.Name = "IPTextBox";\n            this.IPTextBox.Size = new System.Drawing.Size(235, 25);\n            this.IPTextBox.TabIndex = 0;\n            this.IPTextBox.WordWrap = false;\n            // \n            // ServerPortTextBox\n            // \n            this.ServerPortTextBox.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));\n            this.ServerPortTextBox.Location = new System.Drawing.Point(151, 41);
            this.ServerPortTextBox.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));\n            this.ServerPortTextBox.Location = new System.Drawing.Point(151, 41);\n            this.ServerPortTextBox.Margin = new System.Windows.Forms.Padding(4, 4, 4, 4);\n            this.ServerPortTextBox.MaxLength = 10;\n            this.ServerPortTextBox.Name = "ServerPortTextBox";\n            this.ServerPortTextBox.Size = new System.Drawing.Size(235, 25);\n            this.ServerPortTextBox.TabIndex = 1;\n            this.ServerPortTextBox.WordWrap = false;\n            // \n            // PasswordTextBox\n            // \n            this.PasswordTextBox.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));
            this.PluginLabel.Margin = new System.Windows.Forms.Padding(4, 0, 4, 0);\n            this.PluginLabel.Name = "PluginLabel";\n            this.PluginLabel.Size = new System.Drawing.Size(119, 15);\n            this.PluginLabel.TabIndex = 5;\n            this.PluginLabel.Text = "Plugin Program";\n            // \n            // PluginOptionsTextBox\n            // \n            this.PluginOptionsTextBox.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));\n            this.PluginOptionsTextBox.Location = new System.Drawing.Point(151, 198);
            this.PluginOptionsTextBox.Margin = new System.Windows.Forms.Padding(4, 4, 4, 4);\n            this.PluginOptionsTextBox.Size = new System.Drawing.Size(235, 25);\n            this.PluginOptionsTextBox.TabIndex = 6;\n            this.PluginOptionsTextBox.WordWrap = false;\n            // \n            // ShowPasswdCheckBox\n            // \n            this.ShowPasswdCheckBox.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) \n            | System.Windows.Forms.AnchorStyles.Left)));\n            this.ShowPasswdCheckBox.AutoSize = true;\n            this.ShowPasswdCheckBox.Location = new System.Drawing.Point(151, 107);
            this.ShowPasswdCheckBox.Margin = new System.Windows.Forms.Padding(4, 4, 4, 4);\n            this.ShowPasswdCheckBox.TabIndex = 3;\n            this.ShowPasswdCheckBox.Text = "Show Password";\n            this.ShowPasswdCheckBox.TextAlign = System.Drawing.ContentAlignment.MiddleCenter;\n            this.ShowPasswdCheckBox.UseVisualStyleBackColor = true;\n            this.ShowPasswdCheckBox.CheckedChanged += new System.EventHandler(this.ShowPasswdCheckBox_CheckedChanged);\n            // \n            // PluginArgumentsTextBox\n            // \n            this.PluginArgumentsTextBox.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));\n            this.PluginArgumentsTextBox.Location = new System.Drawing.Point(151, 258);
            this.tableLayoutPanel5.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;\n            this.tableLayoutPanel5.ColumnCount = 2;\n            this.tableLayoutPanel5.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());\n            this.tableLayoutPanel5.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());\n            this.tableLayoutPanel5.Controls.Add(this.ProxyPortTextBox, 1, 0);\n            this.tableLayoutPanel5.Controls.Add(this.ProxyPortLabel, 0, 0);\n            this.tableLayoutPanel5.Controls.Add(this.PortableModeCheckBox, 0, 1);\n            this.tableLayoutPanel5.Location = new System.Drawing.Point(208, 405);\n            this.tableLayoutPanel5.Margin = new System.Windows.Forms.Padding(0);\n            this.tableLayoutPanel5.Name = "tableLayoutPanel5";
            this.tableLayoutPanel5.Margin = new System.Windows.Forms.Padding(0);\n            this.tableLayoutPanel5.Name = "tableLayoutPanel5";\n            this.tableLayoutPanel5.Padding = new System.Windows.Forms.Padding(4, 4, 4, 4);\n            this.tableLayoutPanel5.RowCount = 2;\n            this.tableLayoutPanel5.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel5.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel5.Size = new System.Drawing.Size(251, 82);\n            this.tableLayoutPanel5.TabIndex = 9;\n            // \n            // ProxyPortTextBox\n            // \n            this.ProxyPortTextBox.Anchor = System.Windows.Forms.AnchorStyles.Left;\n            this.ProxyPortTextBox.Location = new System.Drawing.Point(103, 8);
using System.Threading.Tasks;\nusing Newtonsoft.Json;\nusing Shadowsocks.Model;\nusing Shadowsocks.Util;\nnamespace Shadowsocks.Controller\n{\n    using Statistics = Dictionary<string, List<StatisticsRecord>>;\n    public sealed class AvailabilityStatistics : IDisposable\n    {\n        public const string DateTimePattern = "yyyy-MM-dd HH:mm:ss";
    using Statistics = Dictionary<string, List<StatisticsRecord>>;\n    public sealed class AvailabilityStatistics : IDisposable\n    {\n        public const string DateTimePattern = "yyyy-MM-dd HH:mm:ss";\n        public static readonly DateTime UnknownDateTime;\n        private const string StatisticsFilesName = "shadowsocks.availability.json";\n        public static string AvailabilityStatisticsFile;\n        //static constructor to initialize every public static fields before refereced\n        static AvailabilityStatistics()\n        {\n            AvailabilityStatisticsFile = Utils.GetTempPath(StatisticsFilesName);
            this.label3.Name = "label3";\n            this.label3.Size = new System.Drawing.Size(87, 27);\n            this.label3.TabIndex = 9;\n            this.label3.Text = "minutes";\n            // \n            // chartModeSelector\n            // \n            this.chartModeSelector.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));\n            this.chartModeSelector.Controls.Add(this.allMode);\n            this.chartModeSelector.Controls.Add(this.dayMode);
            // \n            this.chartModeSelector.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));\n            this.chartModeSelector.Controls.Add(this.allMode);\n            this.chartModeSelector.Controls.Add(this.dayMode);\n            this.allMode.Checked = true;\n            this.allMode.Location = new System.Drawing.Point(11, 61);\n            this.allMode.Margin = new System.Windows.Forms.Padding(5, 10, 5, 10);\n            this.allMode.Name = "allMode";\n            this.allMode.Size = new System.Drawing.Size(58, 31);\n            this.allMode.TabIndex = 1;
            // \n            this.splitContainer1.Panel1.Controls.Add(this.splitContainer2);\n            // \n            // splitContainer1.Panel2\n            // \n            this.splitContainer1.Panel2.Controls.Add(this.serverSelector);\n            this.splitContainer1.Panel2.Controls.Add(this.CancelButton);\n            this.splitContainer1.Panel2.Controls.Add(this.OKButton);\n            this.splitContainer1.Panel2.Controls.Add(this.chartModeSelector);\n            this.splitContainer1.Panel2.Controls.Add(this.StatisticsChart);
            this.splitContainer3.Size = new System.Drawing.Size(700, 252);\n            this.splitContainer3.SplitterDistance = 46;\n            this.splitContainer3.SplitterWidth = 10;\n            this.splitContainer3.TabIndex = 6;\n            // \n            // label1\n            // \n            this.label1.AutoSize = true;
using Shadowsocks.Encryption;\nusing Shadowsocks.Model;\nnamespace Shadowsocks.Controller\n{\n    class TCPRelay : Listener.Service\n    {\n        private ShadowsocksController _controller;\n        private DateTime _lastSweepTime;\n        public ISet<TCPHandler> Handlers { get; set; }
            Handlers = new HashSet<TCPHandler>();\n            _lastSweepTime = DateTime.Now;\n        }\n        public bool Handle(byte[] firstPacket, int length, Socket socket, object state)\n        {\n            if (socket.ProtocolType != ProtocolType.Tcp\n                || (length < 2 || firstPacket[0] != 5))\n                return false;\n            socket.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);
        private bool _connectionShutdown = false;\n        private bool _remoteShutdown = false;\n        private bool _closed = false;\n        private object _encryptionLock = new object();\n        private object _decryptionLock = new object();\n        private DateTime _startConnectTime;\n        private DateTime _startReceivingTime;\n        private DateTime _startSendingTime;\n        private int _bytesToSend;\n        private TCPRelay _tcprelay;  // TODO: is _tcprelay equals tcprelay declared above?
                if (bytesRead > 0)\n                {\n                    int atyp = _connetionRecvBuffer[0];\n                    string dst_addr;\n                    int dst_port;\n                    switch (atyp)\n                    {\n                        case 1:  // IPv4 address, 4 bytes\n                            dst_addr = new IPAddress(_connetionRecvBuffer.Skip(1).Take(4).ToArray()).ToString();\n                            dst_port = (_connetionRecvBuffer[5] << 8) + _connetionRecvBuffer[6];
                            dst_addr = new IPAddress(_connetionRecvBuffer.Skip(1).Take(4).ToArray()).ToString();\n                            dst_port = (_connetionRecvBuffer[5] << 8) + _connetionRecvBuffer[6];\n                            if ( controller.GetCurrentConfiguration().isVerboseLogging ) {\n                                Logging.Info( $"connect to {dst_addr}:{dst_port}" );\n                            }\n                            break;\n                        case 3:  // domain name, length + str\n                            int len = _connetionRecvBuffer[1];\n                            dst_addr = System.Text.Encoding.UTF8.GetString(_connetionRecvBuffer, 2, len);\n                            dst_port = (_connetionRecvBuffer[len + 2] << 8) + _connetionRecvBuffer[len + 3];
                            int len = _connetionRecvBuffer[1];\n                            dst_addr = System.Text.Encoding.UTF8.GetString(_connetionRecvBuffer, 2, len);\n                            dst_port = (_connetionRecvBuffer[len + 2] << 8) + _connetionRecvBuffer[len + 3];\n                            if ( controller.GetCurrentConfiguration().isVerboseLogging ) {\n                                Logging.Info( $"connect to {dst_addr}:{dst_port}" );\n                            }\n                            break;\n                        case 4:  // IPv6 address, 16 bytes\n                            dst_addr = new IPAddress(_connetionRecvBuffer.Skip(1).Take(16).ToArray()).ToString();\n                            dst_port = (_connetionRecvBuffer[17] << 8) + _connetionRecvBuffer[18];

        {\n            isUpdatePACFromGFWListRunning = false;\n            _notifyIcon.BalloonTipTitle = I18N.GetString("Update PAC File via gfwlist...");\n            _notifyIcon.BalloonTipText = I18N.GetString("Update PAC file failed");\n            _notifyIcon.BalloonTipIcon = ToolTipIcon.Info;\n            _notifyIcon.ShowBalloonTip(5000);\n            Logging.LogUsefulException(e.GetException());\n        }\n        void controller_UpdatePACFromGFWListCompleted(object sender, EventArgs e)\n        {
            _notifyIcon.BalloonTipIcon = ToolTipIcon.Info;\n            _notifyIcon.ShowBalloonTip(5000);\n            Logging.LogUsefulException(e.GetException());\n        }\n        void controller_UpdatePACFromGFWListCompleted(object sender, EventArgs e)\n        {\n            isUpdatePACFromGFWListRunning = false;\n            _notifyIcon.BalloonTipTitle = I18N.GetString("Update PAC File via gfwlist...");\n            _notifyIcon.BalloonTipText = I18N.GetString("Update PAC file succeed");\n            _notifyIcon.BalloonTipIcon = ToolTipIcon.Info;\n            _notifyIcon.ShowBalloonTip(5000);\n        }\n        void updateChecker_NewVersionFound(object sender, EventArgs e)\n        {
            Logging.LogUsefulException(e.GetException());\n        }\n        void controller_UpdatePACFromGFWListCompleted(object sender, EventArgs e)\n        {\n            isUpdatePACFromGFWListRunning = false;\n            _notifyIcon.BalloonTipTitle = I18N.GetString("Update PAC File via gfwlist...");\n            _notifyIcon.BalloonTipText = I18N.GetString("Update PAC file succeed");\n            _notifyIcon.BalloonTipIcon = ToolTipIcon.Info;\n            _notifyIcon.ShowBalloonTip(5000);\n        }\n        void updateChecker_NewVersionFound(object sender, EventArgs e)\n        {\n            _notifyIcon.BalloonTipTitle = String.Format(I18N.GetString("Shadowsocks {0} Update Found"), updateChecker.LatestVersionNumber);\n            _notifyIcon.BalloonTipText = I18N.GetString("Click here to download");\n            _notifyIcon.BalloonTipIcon = ToolTipIcon.Info;\n            _notifyIcon.BalloonTipClicked += notifyIcon1_BalloonTipClicked;
            public ServerTimer(int p) : base(p) { }\n        }\n        private void StartConnect()\n        {\n            try\n            {\n                CreateRemote();\n                // Setting up proxy\n                IProxy remote;\n                EndPoint proxyEP;
        {\n            try\n            {\n                CreateRemote();\n                // Setting up proxy\n                IProxy remote;\n                EndPoint proxyEP;\n                if (_config.useProxy)\n                {\n                    remote = new Socks5Proxy();
        {\n            _config.shareOverLan = enabled;\n            SaveConfig(_config);\n            if (ShareOverLANStatusChanged != null)\n            {\n                ShareOverLANStatusChanged(this, new EventArgs());\n            }\n        }\n        public void DisableProxy()\n        {
                ShareOverLANStatusChanged(this, new EventArgs());\n            }\n        }\n        public void DisableProxy()\n        {\n            _config.useProxy = false;\n            SaveConfig(_config);\n        }\n        public void EnableProxy(string proxy, int port)\n        {
using System.Text;\nusing System.Text.RegularExpressions;\nusing System.Web;\nusing Shadowsocks.Controller;\nnamespace Shadowsocks.Model\n{\n    [Serializable]\n    public class Server\n    {\n        public static readonly Regex
using System.Web;\nusing Shadowsocks.Controller;\nnamespace Shadowsocks.Model\n{\n    [Serializable]\n    public class Server\n    {\n        public static readonly Regex\n            UrlFinder = new Regex("^(?i)ss://([A-Za-z0-9+-/=_]+)(#(.+))?$",\n                                  RegexOptions.IgnoreCase | RegexOptions.Compiled),\n            DetailsParser = new Regex("^((?<method>.+?)(?<auth>-auth)??:(?<password>.*)@(?<hostname>.+?)" +
        private void OKButton_Click(object sender, EventArgs e)\n        {\n            if (UseProxyCheckBox.Checked)\n            {\n                try\n                {
                    MessageBox.Show(ex.Message);\n                    return;\n                }\n            }\n            else\n            {\n                controller.DisableProxy();\n            }\n            _modifiedConfiguration.useProxy = UseProxyCheckBox.Checked;
            IPTextBox.Focus();\n        }\n        private bool SaveOldSelectedServer()\n        {\n            try\n            {\n                if (_lastSelectedIndex == -1 || _lastSelectedIndex >= _modifiedConfiguration.configs.Count)\n                {\n                    return true;\n                }
                    remarks = RemarksTextBox.Text,\n                    timeout = int.Parse(TimeoutTextBox.Text),\n                    auth = OneTimeAuth.Checked\n                };\n                int localPort = int.Parse(ProxyPortTextBox.Text);\n                Configuration.CheckServer(server);\n                Configuration.CheckLocalPort(localPort);\n                _modifiedConfiguration.configs[_lastSelectedIndex] = server;\n                _modifiedConfiguration.localPort = localPort;\n                return true;
            }\n            base.Dispose(disposing);\n        }\n        #region Windows Form Designer generated code\n        /// <summary>\n        /// Required method for Designer support - do not modify\n        /// the contents of this method with the code editor.\n        /// </summary>\n        private void InitializeComponent()\n        {
        /// the contents of this method with the code editor.\n        /// </summary>\n        private void InitializeComponent()\n        {\n            this.QRCodeWebBrowser = new System.Windows.Forms.WebBrowser();\n            this.pictureBox1 = new System.Windows.Forms.PictureBox();\n            ((System.ComponentModel.ISupportInitialize)(this.pictureBox1)).BeginInit();\n            this.SuspendLayout();
        /// </summary>\n        private void InitializeComponent()\n        {\n            this.QRCodeWebBrowser = new System.Windows.Forms.WebBrowser();\n            this.pictureBox1 = new System.Windows.Forms.PictureBox();\n            ((System.ComponentModel.ISupportInitialize)(this.pictureBox1)).BeginInit();\n            this.SuspendLayout();\n            | System.Windows.Forms.AnchorStyles.Left) \n            | System.Windows.Forms.AnchorStyles.Right)));\n            this.QRCodeWebBrowser.Location = new System.Drawing.Point(0, 0);\n            this.QRCodeWebBrowser.Margin = new System.Windows.Forms.Padding(0);\n            this.QRCodeWebBrowser.MinimumSize = new System.Drawing.Size(20, 20);\n            this.QRCodeWebBrowser.Name = "QRCodeWebBrowser";\n            this.QRCodeWebBrowser.ScriptErrorsSuppressed = true;\n            this.QRCodeWebBrowser.ScrollBarsEnabled = false;\n            this.QRCodeWebBrowser.Size = new System.Drawing.Size(201, 203);\n            this.QRCodeWebBrowser.TabIndex = 0;\n            // \n            // pictureBox1\n            // 
            this.QRCodeWebBrowser = new System.Windows.Forms.WebBrowser();\n            this.pictureBox1 = new System.Windows.Forms.PictureBox();\n            ((System.ComponentModel.ISupportInitialize)(this.pictureBox1)).BeginInit();\n            this.SuspendLayout();\n            this.QRCodeWebBrowser.Margin = new System.Windows.Forms.Padding(0);\n            this.QRCodeWebBrowser.MinimumSize = new System.Drawing.Size(20, 20);\n            this.QRCodeWebBrowser.Name = "QRCodeWebBrowser";\n            this.QRCodeWebBrowser.ScriptErrorsSuppressed = true;\n            this.QRCodeWebBrowser.ScrollBarsEnabled = false;\n            this.QRCodeWebBrowser.Size = new System.Drawing.Size(201, 203);\n            this.QRCodeWebBrowser.TabIndex = 0;\n            // \n            // pictureBox1\n            // \n            this.pictureBox1.Location = new System.Drawing.Point(0, 0);\n            this.pictureBox1.Name = "pictureBox1";

            this.MaximizeBox = false;\n            this.MinimizeBox = false;\n            this.Name = "QRCodeForm";\n            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;\n            this.Text = "QRCode";\n            this.Load += new System.EventHandler(this.QRCodeForm_Load);\n            ((System.ComponentModel.ISupportInitialize)(this.pictureBox1)).EndInit();\n            this.ResumeLayout(false);\n        }\n        #endregion
        private bool _remoteShutdown = false;\n        private bool _closed = false;\n        // instance-based lock without static\n        private readonly object _encryptionLock = new object();\n        private readonly object _decryptionLock = new object();\n        private readonly object _closeConnLock = new object();\n        private DateTime _startConnectTime;\n        private DateTime _startReceivingTime;\n        private DateTime _startSendingTime;\n        private EndPoint _destEndPoint = null;
        private readonly object _decryptionLock = new object();\n        private readonly object _closeConnLock = new object();\n        private DateTime _startConnectTime;\n        private DateTime _startReceivingTime;\n        private DateTime _startSendingTime;\n        private EndPoint _destEndPoint = null;\n        public TCPHandler(ShadowsocksController controller, Configuration config, TCPRelay tcprelay, Socket socket)\n        {\n            _controller = controller;\n            _config = config;
            _config.configs = servers;\n            _config.localPort = localPort;\n            _config.portableMode = portableMode;\n            Configuration.Save(_config);\n        }\n        public void SaveStrategyConfigurations(StatisticsStrategyConfiguration configuration)\n        {\n            StatisticsConfiguration = configuration;\n            StatisticsStrategyConfiguration.Save(configuration);\n        }
        public void SaveStrategyConfigurations(StatisticsStrategyConfiguration configuration)\n        {\n            StatisticsConfiguration = configuration;\n            StatisticsStrategyConfiguration.Save(configuration);\n        }\n        public void AskAddServerBySSURL(string ssURL)\n        {\n            var dr = MessageBox.Show(I18N.GetString("Import from URL: {0} ?", ssURL), I18N.GetString("Shadowsocks"), MessageBoxButtons.YesNo);\n            if (dr == DialogResult.Yes)\n            {
                UpdatePACFromGFWListCompleted(this, e);\n        }\n        private void pacServer_PACUpdateError(object sender, ErrorEventArgs e)\n        {\n            if (UpdatePACFromGFWListError != null)\n                UpdatePACFromGFWListError(this, e);\n        }\n        private static readonly IEnumerable<char> IgnoredLineBegins = new[] { '!', '[' };\n        private void pacServer_UserRuleFileChanged(object sender, EventArgs e)\n        {
            if (UpdatePACFromGFWListError != null)\n                UpdatePACFromGFWListError(this, e);\n        }\n        private static readonly IEnumerable<char> IgnoredLineBegins = new[] { '!', '[' };\n        private void pacServer_UserRuleFileChanged(object sender, EventArgs e)\n        {\n                }\n            }\n            lines.AddRange(GFWListUpdater.ParseResult(FileManager.NonExclusiveReadAllText(Utils.GetTempPath("gfwlist.txt"))));\n            string abpContent;\n            if (File.Exists(PACServer.USER_ABP_FILE))\n            {\n                abpContent = FileManager.NonExclusiveReadAllText(PACServer.USER_ABP_FILE, Encoding.UTF8);\n            }\n            else\n            {
            {\n                this.Success = success;\n            }\n        }\n        private static readonly IEnumerable<char> IgnoredLineBegins = new[] { '!', '[' };\n        private void http_DownloadStringCompleted(object sender, DownloadStringCompletedEventArgs e)\n        {\n            try\n            {\n                File.WriteAllText(Utils.GetTempPath("gfwlist.txt"), e.Result, Encoding.UTF8);
        public ShadowsocksController controller;\n        public TCPRelay relay;\n        public DateTime lastActivity;\n        private int retryCount = 0;\n        private bool connected;\n        private byte command;\n        private byte[] _firstPacket;\n        private int _firstPacketLength;\n        // Size of receive buffer.\n        public const int RecvSize = 8192;
        private bool connected;\n        private byte command;\n        private byte[] _firstPacket;\n        private int _firstPacketLength;\n        // Size of receive buffer.\n        public const int RecvSize = 8192;\n        public const int BufferSize = RecvSize + (RecvSize / IVEncryptor.CRC_BUF_LEN + 1) * IVEncryptor.CRC_BYTES + 48;\n        private int totalRead = 0;\n        private int totalWrite = 0;\n        // remote receive buffer
        private byte[] _firstPacket;\n        private int _firstPacketLength;\n        // Size of receive buffer.\n        public const int RecvSize = 8192;\n        public const int BufferSize = RecvSize + (RecvSize / IVEncryptor.CRC_BUF_LEN + 1) * IVEncryptor.CRC_BYTES + 48;\n        private int totalRead = 0;\n        private int totalWrite = 0;\n        // remote receive buffer\n        private byte[] remoteRecvBuffer = new byte[RecvSize];\n        // remote send buffer\n        private byte[] remoteSendBuffer = new byte[BufferSize];\n        // connection receive buffer
        }\n        private bool SaveOldSelectedServer()\n        {\n            try\n            {\n                if (_lastSelectedIndex == -1 || _lastSelectedIndex >= _modifiedConfiguration.configs.Count)\n                {\n                    return true;\n                }\n                Server server = new Server();
                }\n                Server server = new Server();\n                server.server = IPTextBox.Text.Trim();\n                try\n                {\n                    server.server_port = int.Parse(ServerPortTextBox.Text);\n                }\n                catch (FormatException)\n                {\n                    MessageBox.Show(I18N.GetString("Illegal port number format"));
                }\n                catch (FormatException)\n                {\n                    MessageBox.Show(I18N.GetString("Illegal port number format"));\n                    ServerPortTextBox.Clear();\n                    return false;\n                }\n                server.password = PasswordTextBox.Text;\n                server.method = EncryptionSelect.Text;\n                server.remarks = RemarksTextBox.Text;
                    MessageBox.Show(I18N.GetString("Illegal port number format"));\n                    ServerPortTextBox.Clear();\n                    return false;\n                }\n                server.password = PasswordTextBox.Text;\n                server.method = EncryptionSelect.Text;\n                server.remarks = RemarksTextBox.Text;\n                try\n                {\n                    server.timeout = int.Parse(TimeoutTextBox.Text);\n                }\n                catch (FormatException)\n                {\n                    MessageBox.Show(I18N.GetString("Illegal timeout format"));
        private DateTime _lastSweepTime;\n        public ISet<TCPHandler> Handlers { get; set; }\n        public TCPRelay(ShadowsocksController controller)\n        {\n            _controller = controller;\n            Handlers = new HashSet<TCPHandler>();\n            _lastSweepTime = DateTime.Now;\n        }\n        public bool Handle(byte[] firstPacket, int length, Socket socket, object state)\n        {
        public TCPRelay(ShadowsocksController controller)\n        {\n            _controller = controller;\n            Handlers = new HashSet<TCPHandler>();\n            _lastSweepTime = DateTime.Now;\n        }\n        public bool Handle(byte[] firstPacket, int length, Socket socket, object state)\n        {\n            if (socket.ProtocolType != ProtocolType.Tcp)\n            {\n                return false;
        private bool _closed = false;\n        private object _encryptionLock = new object();\n        private object _decryptionLock = new object();\n        private DateTime _startConnectTime;\n        private DateTime _startReceivingTime;\n        private DateTime _startSendingTime;\n        private int _bytesToSend;\n        private TCPRelay _tcprelay;  // TODO: is _tcprelay equals tcprelay declared above?\n        public TCPHandler(TCPRelay tcprelay)\n        {
        private int _bytesToSend;\n        private TCPRelay _tcprelay;  // TODO: is _tcprelay equals tcprelay declared above?\n        public TCPHandler(TCPRelay tcprelay)\n        {\n            this._tcprelay = tcprelay;\n        }\n        public void CreateRemote()\n        {\n            Server server = controller.GetAServer(IStrategyCallerType.TCP, (IPEndPoint)connection.RemoteEndPoint);\n            if (server == null || server.server == "")
        public TCPHandler(TCPRelay tcprelay)\n        {\n            this._tcprelay = tcprelay;\n        }\n        public void CreateRemote()\n        {\n            Server server = controller.GetAServer(IStrategyCallerType.TCP, (IPEndPoint)connection.RemoteEndPoint);\n            if (server == null || server.server == "")\n            {\n                throw new ArgumentException("No server configured");
        }\n        public void Close()\n        {\n            lock (tcprelay.Handlers)\n            {\n                tcprelay.Handlers.Remove(this);\n            }\n            lock (this)\n            {\n                if (_closed)
        {\n            lock (tcprelay.Handlers)\n            {\n                tcprelay.Handlers.Remove(this);\n            }\n            lock (this)\n            {\n                if (_closed)\n                {\n                    return;
                }\n                catch (Exception e)\n                {\n                    Logging.LogUsefulException(e);\n                }\n            }\n            lock (_encryptionLock)\n            {\n                lock (_decryptionLock)\n                {
            lock (_encryptionLock)\n            {\n                lock (_decryptionLock)\n                {\n                    if (encryptor != null)\n                    {\n                        ((IDisposable)encryptor).Dispose();\n                    }\n                }\n            }\n        }\n        private void HandshakeReceive()\n        {
                    byte[] response = { 5, 0 };\n                    if (_firstPacket[0] != 5)\n                    {\n                        // reject socks 4\n                        response = new byte[] { 0, 91 };\n                        Logging.Error("socks 5 protocol error");\n                    }\n                    connection.BeginSend(response, 0, response.Length, 0, new AsyncCallback(HandshakeSendCallback), null);\n                }\n                else
                    {\n                        // reject socks 4\n                        response = new byte[] { 0, 91 };\n                        Logging.Error("socks 5 protocol error");\n                    }\n                    connection.BeginSend(response, 0, response.Length, 0, new AsyncCallback(HandshakeSendCallback), null);\n                }\n                else\n                {\n                    Close();
                }\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void HandshakeSendCallback(IAsyncResult ar)\n        {
                int bytesRead = connection.EndReceive(ar);\n                if (bytesRead >= 3)\n                {\n                    _command = _connetionRecvBuffer[1];\n                    if (_command == 1)\n                    {\n                        byte[] response = { 5, 0, 0, 1, 0, 0, 0, 0, 0, 0 };\n                        connection.BeginSend(response, 0, response.Length, 0, new AsyncCallback(ResponseCallback), null);\n                    }\n                    else if (_command == 3)
                {\n                    _command = _connetionRecvBuffer[1];\n                    if (_command == 1)\n                    {\n                        byte[] response = { 5, 0, 0, 1, 0, 0, 0, 0, 0, 0 };\n                        connection.BeginSend(response, 0, response.Length, 0, new AsyncCallback(ResponseCallback), null);\n                    }\n                    else if (_command == 3)\n                    {\n                        HandleUDPAssociate();
                Close();\n            }\n        }\n        private void HandleUDPAssociate()\n        {\n            IPEndPoint endPoint = (IPEndPoint)connection.LocalEndPoint;\n            byte[] address = endPoint.Address.GetAddressBytes();\n            int port = endPoint.Port;\n            byte[] response = new byte[4 + address.Length + 2];\n            response[0] = 5;
            {\n                response[3] = 4;\n            }\n            address.CopyTo(response, 4);\n            response[response.Length - 1] = (byte)(port & 0xFF);\n            response[response.Length - 2] = (byte)((port >> 8) & 0xFF);\n            connection.BeginSend(response, 0, response.Length, 0, new AsyncCallback(ReadAll), true);\n        }\n        private void ReadAll(IAsyncResult ar)\n        {
                }\n                else\n                {\n                    int bytesRead = connection.EndReceive(ar);\n                    if (bytesRead > 0)\n                    {\n                        Logging.Debug(remote, RecvSize, "TCP Relay");\n                        connection.BeginReceive(_connetionRecvBuffer, 0, RecvSize, 0, new AsyncCallback(ReadAll), null);\n                    }\n                    else
                {\n                    int bytesRead = connection.EndReceive(ar);\n                    if (bytesRead > 0)\n                    {\n                        Logging.Debug(remote, RecvSize, "TCP Relay");\n                        connection.BeginReceive(_connetionRecvBuffer, 0, RecvSize, 0, new AsyncCallback(ReadAll), null);\n                    }\n                    else\n                    {\n                        Close();
                remote.BeginConnect(remoteEP, new AsyncCallback(ConnectCallback), connectTimer);\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void connectTimer_Elapsed(object sender, ElapsedEventArgs e)\n        {
            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void connectTimer_Elapsed(object sender, ElapsedEventArgs e)\n        {\n            if (_connected)\n            {\n                return;\n            }\n            Server server = ((ServerTimer)sender).Server;\n            IStrategy strategy = controller.GetCurrentStrategy();
        }\n        private void RetryConnect()\n        {\n            if (_retryCount < _maxRetry)\n            {\n                Logging.Debug($"Connection failed, retry ({_retryCount})");\n                StartConnect();\n                _retryCount++;\n            }\n            else
                StartConnect();\n                _retryCount++;\n            }\n            else\n            {\n                Close();\n            }\n        }\n        private void ConnectCallback(IAsyncResult ar)\n        {
            {\n                Close();\n            }\n        }\n        private void ConnectCallback(IAsyncResult ar)\n        {\n            Server server = null;\n            if (_closed)\n            {\n                return;\n            }\n            try\n            {\n                ServerTimer timer = (ServerTimer)ar.AsyncState;
                StartPipe();\n            }\n            catch (ArgumentException)\n            {\n            }\n            catch (Exception e)\n            {\n                if (server != null)\n                {\n                    IStrategy strategy = controller.GetCurrentStrategy();
                {\n                    IStrategy strategy = controller.GetCurrentStrategy();\n                    {\n                        strategy.SetFailure(server);\n                    }\n                }\n                Logging.LogUsefulException(e);\n                RetryConnect();\n            }\n        }\n        private void StartPipe()\n        {
            {\n                int bytesRead = remote.EndReceive(ar);\n                _totalRead += bytesRead;\n                _tcprelay.UpdateInboundCounter(server, bytesRead);\n                if (bytesRead > 0)\n                {\n                    lastActivity = DateTime.Now;\n                    int bytesToSend;\n                    lock (_decryptionLock)\n                    {
                {\n                    lastActivity = DateTime.Now;\n                    int bytesToSend;\n                    lock (_decryptionLock)\n                    {\n                        if (_closed)\n                        {\n                            return;\n                        }\n                        encryptor.Decrypt(_remoteRecvBuffer, bytesRead, _remoteSendBuffer, out bytesToSend);\n                    }\n                    connection.BeginSend(_remoteSendBuffer, 0, bytesToSend, 0, new AsyncCallback(PipeConnectionSendCallback), null);\n                    IStrategy strategy = controller.GetCurrentStrategy();
         */\n        public void ChooseNewServer()\n        {\n            List<ServerStatus> servers = new List<ServerStatus>(_serverStatus.Values);\n            DateTime now = DateTime.Now;\n            foreach (var status in servers)\n            {\n                // all of failure, latency, (lastread - lastwrite) normalized to 1000, then\n                // 100 * failure - 2 * latency - 0.5 * (lastread - lastwrite)\n                status.score =\n                    100 * 1000 * Math.Min(5 * 60, (now - status.lastFailure).TotalSeconds)
        public static List<Server> GetServers(string ssURL)\n        {
                }\n                string line = "";\n                while ((line = reader.ReadLine()) != null)\n                    LogMessageTextBox.AppendText(line + Environment.NewLine);\n                LogMessageTextBox.ScrollToCaret();\n                lastOffset = reader.BaseStream.Position;\n            }\n        }\n        private void UpdateContent()\n        {
                     FileMode.Open, FileAccess.Read, FileShare.ReadWrite)))\n            {\n                reader.BaseStream.Seek(lastOffset, SeekOrigin.Begin);\n                string line = "";\n                bool changed = false;\n                while ((line = reader.ReadLine()) != null)\n                {\n                    changed = true;\n                    LogMessageTextBox.AppendText(line + Environment.NewLine);\n                }
    public class Logging\n    {\n        public static string LogFilePath;\n        public static bool OpenLogFile()\n        {\n            try\n            {\n                LogFilePath = Utils.GetTempPath("shadowsocks.log");
                return true;\n            }\n            catch (IOException e)\n            {\n                Console.WriteLine(e.ToString());\n                return false;\n            }\n        }\n        private static void WriteToLogFile(object o)\n        {
            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                return false;\n            }\n        }\n        public void ToggleEnable(bool enabled)\n        {\n            _config.enabled = enabled;
            UpdateSystemProxy();\n            SaveConfig(_config);\n            if (EnableStatusChanged != null)\n            {\n                EnableStatusChanged(this, new EventArgs());\n            }\n        }\n        public void ToggleGlobal(bool global)\n        {\n            _config.global = global;
        public void UpdateStatisticsConfiguration(bool enabled)\n        {\n            if (availabilityStatistics == null) return;\n            availabilityStatistics.UpdateConfiguration(this);\n            _config.availabilityStatistics = enabled;\n            SaveConfig(_config);\n        }\n        public void SavePACUrl(string pacUrl)\n        {\n            _config.pacUrl = pacUrl;
            UpdateSystemProxy();\n            SaveConfig(_config);\n            if (ConfigChanged != null)\n            {\n                ConfigChanged(this, new EventArgs());\n            }\n        }\n        public void UseOnlinePAC(bool useOnlinePac)\n        {\n            _config.useOnlinePac = useOnlinePac;
﻿using System;
﻿using System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Net;
﻿using System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Net;\nusing System.Net.NetworkInformation;\nusing System.Net.Sockets;
using System.Text;\nusing System.Windows.Forms;\nusing Shadowsocks.Model;\nusing Shadowsocks.Properties;\nusing Shadowsocks.Util;\nusing Shadowsocks.Util.ProcessManagement;\nnamespace Shadowsocks.Controller\n{\n    class PrivoxyRunner\n    {
using Shadowsocks.Util;\nusing Shadowsocks.Util.ProcessManagement;\nnamespace Shadowsocks.Controller\n{\n    class PrivoxyRunner\n    {\n                _runningPort = this.GetFreePort();\n                privoxyConfig = privoxyConfig.Replace("__SOCKS_PORT__", configuration.localPort.ToString());\n                privoxyConfig = privoxyConfig.Replace("__PRIVOXY_BIND_PORT__", _runningPort.ToString());\n                privoxyConfig = privoxyConfig.Replace("__PRIVOXY_BIND_IP__", configuration.shareOverLan ? "0.0.0.0" : "127.0.0.1");
                _process.StartInfo.WorkingDirectory = Utils.GetTempPath();\n                _process.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;\n                _process.StartInfo.UseShellExecute = true;\n                _process.StartInfo.CreateNoWindow = true;\n                _process.Start();\n                /*\n                 * Add this process to job obj associated with this ss process, so that\n                 * when ss exit unexpectedly, this process will be forced killed by system.\n                 */
            RefreshTrayArea();\n        }\n        public void Stop()\n        {\n            if (_process != null)\n            {\n                KillProcess(_process);\n                _process.Dispose();\n                _process = null;\n            }
            base.Dispose(disposing);\n        }\n        #region Windows Form Designer generated code\n        /// <summary>\n        /// Required method for Designer support - do not modify\n        /// the contents of this method with the code editor.\n        /// </summary>\n        private void InitializeComponent()\n        {\n            this.pictureBox1 = new System.Windows.Forms.PictureBox();
        #region Windows Form Designer generated code\n        /// <summary>\n        /// Required method for Designer support - do not modify\n        /// the contents of this method with the code editor.\n        /// </summary>\n        private void InitializeComponent()\n        {\n            this.pictureBox1 = new System.Windows.Forms.PictureBox();\n            this.panel1 = new System.Windows.Forms.Panel();\n            ((System.ComponentModel.ISupportInitialize)(this.pictureBox1)).BeginInit();
        /// Required method for Designer support - do not modify\n        /// the contents of this method with the code editor.\n        /// </summary>\n        private void InitializeComponent()\n        {\n            this.pictureBox1 = new System.Windows.Forms.PictureBox();\n            this.panel1 = new System.Windows.Forms.Panel();\n            ((System.ComponentModel.ISupportInitialize)(this.pictureBox1)).BeginInit();\n            this.panel1.SuspendLayout();\n            this.SuspendLayout();\n            // \n            // pictureBox1\n            // 
        {\n            this.pictureBox1 = new System.Windows.Forms.PictureBox();\n            this.panel1 = new System.Windows.Forms.Panel();\n            ((System.ComponentModel.ISupportInitialize)(this.pictureBox1)).BeginInit();\n            this.panel1.SuspendLayout();\n            this.SuspendLayout();\n            // \n            // pictureBox1\n            // \n            this.pictureBox1.Dock = System.Windows.Forms.DockStyle.Fill;\n            this.pictureBox1.Location = new System.Drawing.Point(10, 10);\n            this.pictureBox1.Margin = new System.Windows.Forms.Padding(0);\n            this.pictureBox1.Name = "pictureBox1";
            this.panel1.SuspendLayout();\n            // pictureBox1\n            // \n            this.pictureBox1.Dock = System.Windows.Forms.DockStyle.Fill;\n            this.pictureBox1.Location = new System.Drawing.Point(10, 10);\n            this.pictureBox1.Margin = new System.Windows.Forms.Padding(0);\n            this.pictureBox1.Name = "pictureBox1";\n            this.pictureBox1.Size = new System.Drawing.Size(204, 202);\n            this.pictureBox1.SizeMode = System.Windows.Forms.PictureBoxSizeMode.StretchImage;\n            this.pictureBox1.TabIndex = 1;\n            this.pictureBox1.TabStop = false;\n            // 
            this.pictureBox1.Dock = System.Windows.Forms.DockStyle.Fill;\n            this.pictureBox1.Location = new System.Drawing.Point(10, 10);\n            this.pictureBox1.Margin = new System.Windows.Forms.Padding(0);\n            this.pictureBox1.Name = "pictureBox1";\n            this.pictureBox1.Size = new System.Drawing.Size(204, 202);\n            this.pictureBox1.SizeMode = System.Windows.Forms.PictureBoxSizeMode.StretchImage;\n            this.pictureBox1.TabIndex = 1;\n            this.pictureBox1.TabStop = false;\n            // \n            this.panel1.Controls.Add(this.pictureBox1);\n            this.panel1.Dock = System.Windows.Forms.DockStyle.Fill;\n            this.panel1.Location = new System.Drawing.Point(0, 0);\n            this.panel1.Margin = new System.Windows.Forms.Padding(0);\n            this.panel1.Name = "panel1";\n            this.panel1.Padding = new System.Windows.Forms.Padding(10);\n            this.panel1.Size = new System.Drawing.Size(224, 222);\n            this.panel1.TabIndex = 2;\n            // \n            // QRCodeForm\n            // 
            this.Controls.Add(this.panel1);\n            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedSingle;\n            this.MaximizeBox = false;\n            this.MinimizeBox = false;\n            this.Name = "QRCodeForm";\n            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;\n            this.Text = "QRCode";\n            this.Load += new System.EventHandler(this.QRCodeForm_Load);\n            ((System.ComponentModel.ISupportInitialize)(this.pictureBox1)).EndInit();
            this.Name = "QRCodeForm";\n            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;\n            this.Text = "QRCode";\n            this.Load += new System.EventHandler(this.QRCodeForm_Load);\n            ((System.ComponentModel.ISupportInitialize)(this.pictureBox1)).EndInit();\n            this.panel1.ResumeLayout(false);\n            this.ResumeLayout(false);\n        }\n        #endregion\n        private System.Windows.Forms.PictureBox pictureBox1;
        static AvailabilityStatistics()\n        {\n            AvailabilityStatisticsFile = Utils.GetTempPath(StatisticsFilesName);\n        }\n        //arguments for ICMP tests\n        private int Repeat => Config.RepeatTimesNum;\n        public const int TimeoutMilliseconds = 500;\n        //records cache for current server in {_monitorInterval} minutes\n        private readonly ConcurrentDictionary<string, List<int>> _latencyRecords = new ConcurrentDictionary<string, List<int>>();\n        //speed in KiB/s
            AvailabilityStatisticsFile = Utils.GetTempPath(StatisticsFilesName);\n        }\n        //arguments for ICMP tests\n        private int Repeat => Config.RepeatTimesNum;\n        public const int TimeoutMilliseconds = 500;\n        //records cache for current server in {_monitorInterval} minutes\n        private readonly ConcurrentDictionary<string, List<int>> _latencyRecords = new ConcurrentDictionary<string, List<int>>();\n        //speed in KiB/s\n        private readonly ConcurrentDictionary<string, long> _inboundCounter = new ConcurrentDictionary<string, long>();\n        private readonly ConcurrentDictionary<string, long> _lastInboundCounter = new ConcurrentDictionary<string, long>();\n        private readonly ConcurrentDictionary<string, List<int>> _inboundSpeedRecords = new ConcurrentDictionary<string, List<int>>();
        }\n        private void StartTimerWithoutState(ref Timer timer, TimerCallback callback, TimeSpan interval)\n        {\n            if (timer?.Change(_delayBeforeStart, interval) == null)\n            {\n                timer = new Timer(callback, null, _delayBeforeStart, interval);\n            }\n        }\n        private void UpdateSpeed(object _)\n        {
            if (timer?.Change(_delayBeforeStart, interval) == null)\n            {\n                timer = new Timer(callback, null, _delayBeforeStart, interval);\n            }\n        }\n        private void UpdateSpeed(object _)\n        {\n            foreach (var kv in _lastInboundCounter)\n            {\n                var id = kv.Key;
                Logging.Debug(
                Logging.Debug(\n            _inboundCounter.AddOrUpdate(server.Identifier(), (k) =>\n            {\n                _lastInboundCounter.GetOrAdd(server.Identifier(), 0);\n                return n;\n            }, (k, v) => (v + n));\n        }\n        public void UpdateOutboundCounter(Server server, long n)\n        {
                throw new ArgumentException(I18N.GetString("Port out of range"));\n        }\n        public static void CheckLocalPort(int port)\n        {\n            CheckPort(port);\n            if (port == 8123)\n                throw new ArgumentException(I18N.GetString("Port can't be 8123"));\n        }\n        private static void CheckPassword(string password)\n        {
            if (port == 8123)\n                throw new ArgumentException(I18N.GetString("Port can't be 8123"));\n        }\n        private static void CheckPassword(string password)\n        {\n            if (string.IsNullOrEmpty(password))\n                throw new ArgumentException(I18N.GetString("Password can not be blank"));\n        }\n        private static void CheckServer(string server)\n        {
        {\n            return server.GetHashCode() ^ server_port;\n        }\n        public override bool Equals(object obj)\n        {\n            Server o2 = (Server)obj;\n            return server == o2.server && server_port == o2.server_port;\n        }\n        public string FriendlyName()\n        {
        {\n            Server o2 = (Server)obj;\n            return server == o2.server && server_port == o2.server_port;\n        }\n        public string FriendlyName()\n        {\n            if (string.IsNullOrEmpty(server))\n            {\n                return I18N.GetString("New server");\n            }

                if (String.IsNullOrEmpty(controller.GetConfigurationCopy().pacUrl))\n                {\n                    UpdateOnlinePACURLItem_Click(sender, e);\n                }
                CachedKeys[k] = _key;\n            }\n        }\n        protected void bytesToKey(byte[] password, byte[] key)\n        {\n            byte[] result = new byte[password.Length + 16];\n            int i = 0;\n            byte[] md5sum = null;\n            while (i < key.Length)\n            {
        protected void bytesToKey(byte[] password, byte[] key)\n        {\n            byte[] result = new byte[password.Length + 16];\n            int i = 0;\n            byte[] md5sum = null;\n            while (i < key.Length)\n            {\n                MD5 md5 = MD5.Create();\n                if (i == 0)\n                {
            {\n                MD5 md5 = MD5.Create();\n                if (i == 0)\n                {\n                    md5sum = md5.ComputeHash(password);\n                }\n                else\n                {\n                    md5sum.CopyTo(result, 0);\n                    password.CopyTo(result, md5sum.Length);
            this.editPACFileItem,\n            this.QRCodeItem,\n            this.ShowLogItem,\n            this.aboutItem,\n            this.menuItem3,\n            this.quitItem});\n            // \n            // enableItem\n            // \n            this.enableItem.Index = 0;\n            this.enableItem.Text = "&Enable";\n            this.enableItem.Click += new System.EventHandler(this.EnableItem_Click);\n            // \n            // ShareOverLANItem\n            // 
            this.aboutItem,\n            this.menuItem3,\n            this.quitItem});\n            // \n            this.enableItem.Index = 0;\n            this.enableItem.Text = "&Enable";\n            this.enableItem.Click += new System.EventHandler(this.EnableItem_Click);\n            // \n            // ShareOverLANItem\n            // \n            this.ShareOverLANItem.Index = 1;\n            this.ShareOverLANItem.Text = "Share over LAN";\n            this.ShareOverLANItem.Click += new System.EventHandler(this.ShareOverLANItem_Click);\n            // \n            // ServersItem\n            // 
                            else if (result.Text.StartsWith("http://") || result.Text.StartsWith("https://"))\n                            {\n                                _urlToOpen = result.Text;\n                                splash.FormClosed += openURLFromQRCode;\n                            }\n                            else\n                            {\n                                MessageBox.Show(I18N.GetString("Failed to decode QRCode"));\n                                return;\n                            }
using System.IO.Compression;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Text;\nnamespace Shadowsocks.Controller\n{\n    class PACServer : Listener.Service\n    {\n        public static string PAC_FILE = "pac.txt";\n        public static string USER_RULE_FILE = "user-rule.txt";
            Socket conn = (Socket)ar.AsyncState;\n            try\n            {\n                conn.Shutdown(SocketShutdown.Send);\n            }\n            catch\n            { }\n        }\n        private void WatchPacFile()\n        {
    {\n        private static Dictionary<string, string> _strings = new Dictionary<string, string>();\n        private static void Init(string res, string locale)\n        {\n            using (TextFieldParser csvParser = new TextFieldParser(new StringReader(res)))\n            {\n                csvParser.SetDelimiters(",");
                    if (localeNames[i] == "en")\n                    {
                    }\n                }\n                while (!csvParser.EndOfData)\n                {\n                    string[] translations = csvParser.ReadFields();
                while (!csvParser.EndOfData)\n                {\n                    string[] translations = csvParser.ReadFields();\n                    if (string.IsNullOrWhiteSpace(translations[0])) continue;\n                    if (translations[0].TrimStart(' ')[0] == '#') continue;
                    if (string.IsNullOrWhiteSpace(translations[0])) continue;\n                    if (translations[0].TrimStart(' ')[0] == '#') continue;\n                    _strings[translations[enIndex]] = translations[targetIndex];\n                }\n            }\n        }\n        static I18N()\n        {
            this.repeatTimesNum = new System.Windows.Forms.NumericUpDown();\n            this.label6 = new System.Windows.Forms.Label();\n            this.splitContainer3 = new System.Windows.Forms.SplitContainer();\n            this.label1 = new System.Windows.Forms.Label();\n            this.calculationContainer = new System.Windows.Forms.FlowLayoutPanel();\n            this.CancelButton = new System.Windows.Forms.Button();\n            this.OKButton = new System.Windows.Forms.Button();\n            ((System.ComponentModel.ISupportInitialize)(this.StatisticsChart)).BeginInit();
        public class State\n        {\n            public DataList dataList = new DataList();\n            public const string Geolocation = "Geolocation";\n            public const string ISP = "ISP";\n            public const string Unknown = "Unknown";\n        }\n        public class RawStatisticsData\n        {
        public static List<Server> GetServers(string ssURL)\n        {
            int prefixLength = "ss://".Length;\n            var serverUrls = ssURL.Split('\r', '\n');\n            List<Server> servers = new List<Server>();\n            foreach (string serverUrl in serverUrls)\n            {\n                string _serverUrl = serverUrl.Trim();\n                if (!_serverUrl.BeginWith("ss://", StringComparison.InvariantCultureIgnoreCase))\n                {\n                    continue;\n                }
            foreach (string serverUrl in serverUrls)\n            {\n                string _serverUrl = serverUrl.Trim();\n                if (!_serverUrl.BeginWith("ss://", StringComparison.InvariantCultureIgnoreCase))\n                {\n                    continue;\n                }\n                string webSafeBase64Str = indexOfHashOrSlash == -1 ?\n                    _serverUrl.Substring(prefixLength) :\n                    _serverUrl.Substring(prefixLength, indexOfHashOrSlash - prefixLength);\n                string base64Str = webSafeBase64Str.Replace('-', '+').Replace('_', '/');\n                string base64 = base64Str.PadRight(base64Str.Length + (4 - base64Str.Length % 4) % 4, '=');\n                string decodedBase64 = Encoding.UTF8.GetString(Convert.FromBase64String(base64));\n                string decodedServerUrl = serverUrl.Replace(webSafeBase64Str, decodedBase64);\n                Uri parsedUrl;\n                try\n                {
                string _serverUrl = serverUrl.Trim();\n                if (!_serverUrl.BeginWith("ss://", StringComparison.InvariantCultureIgnoreCase))\n                {\n                    continue;\n                }\n                    _serverUrl.Substring(prefixLength, indexOfHashOrSlash - prefixLength);\n                string base64Str = webSafeBase64Str.Replace('-', '+').Replace('_', '/');\n                string base64 = base64Str.PadRight(base64Str.Length + (4 - base64Str.Length % 4) % 4, '=');\n                string decodedBase64 = Encoding.UTF8.GetString(Convert.FromBase64String(base64));\n                string decodedServerUrl = serverUrl.Replace(webSafeBase64Str, decodedBase64);\n                Uri parsedUrl;\n                try\n                {\n                    parsedUrl = new Uri(decodedServerUrl);\n                }
                {\n                    continue;\n                }\n                string base64 = base64Str.PadRight(base64Str.Length + (4 - base64Str.Length % 4) % 4, '=');\n                string decodedBase64 = Encoding.UTF8.GetString(Convert.FromBase64String(base64));\n                string decodedServerUrl = serverUrl.Replace(webSafeBase64Str, decodedBase64);\n                Uri parsedUrl;\n                try\n                {\n                    parsedUrl = new Uri(decodedServerUrl);\n                }\n                catch (UriFormatException)\n                {
                {\n                    parsedUrl = new Uri(decodedServerUrl);\n                }\n                catch (UriFormatException)\n                {\n                    continue;\n                }
        : IVEncryptor, IDisposable\n    {\n        const int CIPHER_SALSA20 = 1;\n        const int CIPHER_CHACHA20 = 2;\n        const int SODIUM_BLOCK_SIZE = 64;\n        protected int _encryptBytesRemaining;\n        protected int _decryptBytesRemaining;\n        protected ulong _encryptIC;\n        protected ulong _decryptIC;
        protected int _encryptBytesRemaining;\n        protected int _decryptBytesRemaining;\n        protected ulong _encryptIC;\n        protected ulong _decryptIC;\n        protected byte[] _encryptBuf;\n        protected byte[] _decryptBuf;\n        public SodiumEncryptor(string method, string password)\n            : base(method, password)\n        {\n            InitKey(method, password);
        }\n        public static List<string> SupportedCiphers()\n        {\n            return new List<string>(_ciphers.Keys);\n        }\n        protected override void cipherUpdate(bool isCipher, int length, byte[] buf, byte[] outbuf)\n        {\n            // TODO write a unidirection cipher so we don't have to if if if\n            int bytesRemaining;\n            ulong ic;
        {\n            return new List<string>(_ciphers.Keys);\n        }\n        protected override void cipherUpdate(bool isCipher, int length, byte[] buf, byte[] outbuf)\n        {\n            // TODO write a unidirection cipher so we don't have to if if if\n            int bytesRemaining;\n            ulong ic;\n            byte[] sodiumBuf;\n            byte[] iv;
        protected override void cipherUpdate(bool isCipher, int length, byte[] buf, byte[] outbuf)\n        {\n            // TODO write a unidirection cipher so we don't have to if if if\n            int bytesRemaining;\n            ulong ic;\n            byte[] sodiumBuf;\n            byte[] iv;\n            if (isCipher)\n            {
        public async void Run(string path)\n        {\n            byte[] buf = new byte[4096];\n            while (true)\n            {\n                using (NamedPipeServerStream stream = new NamedPipeServerStream(path))\n                {\n                    stream.WaitForConnection();\n                    await stream.ReadAsync(buf, 0, 4);
        public event EventHandler ConfigChanged;\n        public event EventHandler EnableStatusChanged;\n        public event EventHandler EnableGlobalChanged;\n        public event EventHandler ShareOverLANStatusChanged;\n        // when user clicked Edit PAC, and PAC file has already created\n        public event EventHandler<PathEventArgs> PACFileReadyToOpen;\n        public ShadowsocksController()\n        {\n            _config = Configuration.Load();
                PACFileReadyToOpen(this, new PathEventArgs() { Path = pacFilename });\n            }\n        }\n        public string GetQRCodeForCurrentServer()\n        {\n            Server server = GetCurrentServer();\n            string parts = server.method + ":" + server.password + "@" + server.server + ":" + server.server_port;\n            string base64 = System.Convert.ToBase64String(Encoding.UTF8.GetBytes(parts));\n            return "ss://" + base64;\n        }
            pacServer.Stop();
            pacServer.Stop();\n            local.Stop();\n            // don't put polipoRunner.Start() before pacServer.Stop()\n            // or bind will fail when switching bind address from 0.0.0.0 to 127.0.0.1\n            // though UseShellExecute is set to true now\n            // http://stackoverflow.com/questions/10235093/socket-doesnt-close-after-application-exits-if-a-launched-process-is-open\n            polipoRunner.Stop();
                server = timer.Server;\n                timer.Elapsed -= connectTimer_Elapsed;\n                timer.Enabled = false;\n                timer.Dispose();\n                // Complete the connection.\n                remote.EndConnect(ar);\n                connected = true;\n                //Console.WriteLine("Socket connected to {0}",\n                //    remote.RemoteEndPoint.ToString());\n                var latency = DateTime.Now - _startConnectTime;
                controller.GetCurrentStrategy().UpdateLatency(server, latency);\n                StartPipe();\n            }\n            catch (ArgumentException e)\n            {\n            }\n            catch (Exception e)\n            {\n                if (server != null)\n                {
        private ShadowsocksController controller;\n        private UpdateChecker updateChecker;\n        private NotifyIcon _notifyIcon;\n        private ContextMenu contextMenu1;\n        private bool _isFirstRun;\n        private MenuItem enableItem;\n        private MenuItem AutoStartupItem;\n        private MenuItem ShareOverLANItem;\n        private MenuItem SeperatorItem;\n        private MenuItem ConfigItem;
        private NotifyIcon _notifyIcon;\n        private ContextMenu contextMenu1;\n        private bool _isFirstRun;\n        private MenuItem enableItem;\n        private MenuItem AutoStartupItem;\n        private MenuItem ShareOverLANItem;\n        private MenuItem SeperatorItem;\n        private MenuItem ConfigItem;\n        private MenuItem SeperatorItem3;\n        private MenuItem editPACFileItem;\n        private MenuItem QRCodeItem;\n        private MenuItem ShowLogItem;\n        private MenuItem aboutItem;\n        private MenuItem ServersItem;

            this.modeItem = CreateMenuGroup(1, "Mode", new System.Windows.Forms.MenuItem[] {\n            this.PACModeItem,\n            this.globalModeItem});\n            this.ServersItem = CreateMenuGroup(2, "Servers", new System.Windows.Forms.MenuItem[] {
            this.modeItem = CreateMenuGroup(1, "Mode", new System.Windows.Forms.MenuItem[] {\n            this.PACModeItem,\n            this.globalModeItem});\n            this.ServersItem = CreateMenuGroup(2, "Servers", new System.Windows.Forms.MenuItem[] {\n            this.SeperatorItem,\n            this.ConfigItem});\n            this.SeperatorItem2 = CreateSeperatorItem(3);\n            this.AutoStartupItem = CreateMenuItem(4, "Start on Boot", new System.EventHandler(this.AutoStartupItem_Click));\n            this.ShareOverLANItem = CreateMenuItem(5, "Share over LAN", new System.EventHandler(this.ShareOverLANItem_Click));
            this.globalModeItem});\n            this.ServersItem = CreateMenuGroup(2, "Servers", new System.Windows.Forms.MenuItem[] {\n            this.SeperatorItem,\n            this.ConfigItem});\n            this.SeperatorItem2 = CreateSeperatorItem(3);\n            this.AutoStartupItem = CreateMenuItem(4, "Start on Boot", new System.EventHandler(this.AutoStartupItem_Click));\n            this.ShareOverLANItem = CreateMenuItem(5, "Share over LAN", new System.EventHandler(this.ShareOverLANItem_Click));\n            this.QRCodeItem = CreateMenuItem(8, "Show QRCode...", new System.EventHandler(this.QRCodeItem_Click));\n            this.ShowLogItem = CreateMenuItem(9, "Show Logs...", new System.EventHandler(this.ShowLogItem_Click));\n            this.aboutItem = CreateMenuItem(10, "About...", new System.EventHandler(this.Config_Click));\n            this.SeperatorItem4 = CreateSeperatorItem(11);\n            this.quitItem = CreateMenuItem(12, "Quit", new System.EventHandler(this.Quit_Click));\n            // \n            // contextMenu1\n            // \n            this.contextMenu1.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {\n            this.enableItem,
            this.ConfigItem});\n            this.SeperatorItem2 = CreateSeperatorItem(3);\n            this.AutoStartupItem = CreateMenuItem(4, "Start on Boot", new System.EventHandler(this.AutoStartupItem_Click));\n            this.ShareOverLANItem = CreateMenuItem(5, "Share over LAN", new System.EventHandler(this.ShareOverLANItem_Click));\n            this.SeperatorItem4 = CreateSeperatorItem(11);\n            this.quitItem = CreateMenuItem(12, "Quit", new System.EventHandler(this.Quit_Click));\n            // \n            // contextMenu1\n            // \n            this.contextMenu1.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {\n            this.enableItem,\n            this.modeItem,\n            this.ServersItem,
            this.ShareOverLANItem = CreateMenuItem(5, "Share over LAN", new System.EventHandler(this.ShareOverLANItem_Click));\n            // contextMenu1\n            // \n            this.contextMenu1.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {\n            this.enableItem,\n            this.modeItem,\n            this.ServersItem,\n            this.SeperatorItem2,\n            this.AutoStartupItem,\n            this.ShareOverLANItem,
                return false;\n            }\n            string currentVersion = Version;\n            return CompareVersion(version, currentVersion) > 0;\n        }\n        private void http_DownloadStringCompleted(object sender, DownloadStringCompletedEventArgs e)\n        {\n            try\n            {\n                string response = e.Result;
            string currentVersion = Version;\n            return CompareVersion(version, currentVersion) > 0;\n        }\n        private void http_DownloadStringCompleted(object sender, DownloadStringCompletedEventArgs e)\n        {\n            try\n            {\n                string response = e.Result;\n                XmlDocument xmlDoc = new XmlDocument();\n                xmlDoc.LoadXml(response);\n                XmlNodeList elements = xmlDoc.GetElementsByTagName("media:content");\n                List<string> versions = new List<string>();
        }\n        private void http_DownloadStringCompleted(object sender, DownloadStringCompletedEventArgs e)\n        {\n            try\n            {\n                string response = e.Result;\n                XmlDocument xmlDoc = new XmlDocument();\n                xmlDoc.LoadXml(response);\n                XmlNodeList elements = xmlDoc.GetElementsByTagName("media:content");\n                List<string> versions = new List<string>();\n                foreach (XmlNode el in elements)\n                {
        {\n            try\n            {\n                string response = e.Result;\n                XmlDocument xmlDoc = new XmlDocument();\n                xmlDoc.LoadXml(response);\n                XmlNodeList elements = xmlDoc.GetElementsByTagName("media:content");\n                List<string> versions = new List<string>();\n                foreach (XmlNode el in elements)\n                {\n                    foreach (XmlAttribute attr in el.Attributes)\n                    {
                string response = e.Result;\n                xmlDoc.LoadXml(response);\n                XmlNodeList elements = xmlDoc.GetElementsByTagName("media:content");\n                List<string> versions = new List<string>();\n                foreach (XmlNode el in elements)\n                {\n                    foreach (XmlAttribute attr in el.Attributes)\n                    {\n                        if (attr.Name == "url")\n                        {
﻿using System;\nusing System.Diagnostics;\nusing System.IO;
using System.Text;\nusing Shadowsocks.Controller;\nusing Shadowsocks.Properties;\nnamespace Shadowsocks.Util.SystemProxy\n{\n    public static class Sysproxy\n    {
using Shadowsocks.Properties;\nnamespace Shadowsocks.Util.SystemProxy\n{\n    public static class Sysproxy\n    {\n        private static bool _userSettingsRecorded = false;\n        // In general, this won't change\n        // format:\n        //  <flags><CR-LF>\n        //  <proxy-server><CR-LF>\n        //  <bypass-list><CR-LF>\n        //  <pac-url>
                FileManager.UncompressFile(Utils.GetTempPath("sysproxy.exe"),\n                    Environment.Is64BitOperatingSystem ? Resources.sysproxy64_exe : Resources.sysproxy_exe);\n            }\n            catch (IOException e)\n            {\n                Logging.LogUsefulException(e);\n            }\n        }\n        public static void SetIEProxy(bool enable, bool global, string proxyServer, string pacURL)\n        {
            catch (IOException e)\n            {\n                Logging.LogUsefulException(e);\n            }\n        }\n        public static void SetIEProxy(bool enable, bool global, string proxyServer, string pacURL)\n        {\n            string str;\n            if (_userSettingsRecorded == false)\n            {\n                // record user settings
            string arguments;\n            if (enable)\n            {\n                arguments = global\n                    ? $"global {proxyServer} <local>;localhost;127.*;10.*;172.16.*;172.17.*;172.18.*;172.19.*;172.20.*;172.21.*;172.22.*;172.23.*;172.24.*;172.25.*;172.26.*;172.27.*;172.28.*;172.29.*;172.30.*;172.31.*;172.32.*;192.168.*"\n                    : $"pac {pacURL}";\n            }\n            else\n            {\n                // restore user settings
                    : $"pac {pacURL}";\n            }\n            else\n            {\n                // restore user settings\n                var flags = _userSettings[0];\n                var proxy_server = _userSettings[1] ?? "-";\n                var bypass_list = _userSettings[2] ?? "-";\n                var pac_url = _userSettings[3] ?? "-";\n                arguments = $"set {flags} {proxy_server} {bypass_list} {pac_url}";\n                // have to get new settings
            else\n            {\n                // restore user settings\n                var flags = _userSettings[0];\n                var proxy_server = _userSettings[1] ?? "-";\n                var bypass_list = _userSettings[2] ?? "-";\n                var pac_url = _userSettings[3] ?? "-";\n                arguments = $"set {flags} {proxy_server} {bypass_list} {pac_url}";\n                // have to get new settings\n                _userSettingsRecorded = false;\n            }
                var flags = _userSettings[0];\n                var proxy_server = _userSettings[1] ?? "-";\n                var bypass_list = _userSettings[2] ?? "-";\n                var pac_url = _userSettings[3] ?? "-";\n                arguments = $"set {flags} {proxy_server} {bypass_list} {pac_url}";\n                // have to get new settings\n                _userSettingsRecorded = false;\n            }\n            ExecSysproxy(arguments, out str);\n        }
                process.StartInfo.CreateNoWindow = true;\n                process.Start();\n                var stderr = process.StandardError.ReadToEnd();\n                var stdout = process.StandardOutput.ReadToEnd();\n                process.WaitForExit();\n                var exitCode = process.ExitCode;\n                if (exitCode != (int)RET_ERRORS.RET_NO_ERROR)\n                {\n                    throw new ProxyException(stderr);\n                }
                var exitCode = process.ExitCode;\n                if (exitCode != (int)RET_ERRORS.RET_NO_ERROR)\n                {\n                    throw new ProxyException(stderr);\n                }\n                if (arguments == "query" && stdout.IsNullOrWhiteSpace())\n                {\n                    // we cannot get user settings\n                    throw new ProxyException("failed to query wininet settings");\n                }
                {\n                    // we cannot get user settings\n                    throw new ProxyException("failed to query wininet settings");\n                }\n                queryStr = stdout;\n            }\n        }\n        private static void ParseQueryStr(string str)\n        {

﻿using Shadowsocks.Controller;\nusing Shadowsocks.Properties;\nusing Shadowsocks.View;\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;
using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Reflection;\nusing System.Runtime.InteropServices;\nusing System.Threading;\nusing System.Windows.Forms;\nnamespace Shadowsocks\n{\n    static class Program\n    {
            byte[] auth = new byte[ONETIMEAUTH_BYTES];\n            byte[] hash = new byte[20];\n            byte[] auth_key = new byte[MAX_IV_LENGTH + MAX_KEY_LENGTH];\n            Buffer.BlockCopy(_encryptIV, 0, auth_key, 0, ivLen);\n            Buffer.BlockCopy(_key, 0, auth_key, ivLen, keyLen);\n            Sodium.ss_sha1_hmac_ex(auth_key, (uint)(ivLen + keyLen),\n                msg, 0, (uint)msg_len, hash);\n            Buffer.BlockCopy(hash, 0, auth, 0, ONETIMEAUTH_BYTES);\n            return auth;\n        }
                _keyBuffer = new byte[MAX_IV_LENGTH + 4];\n                Buffer.BlockCopy(_encryptIV, 0, _keyBuffer, 0, ivLen);\n            }\n            byte[] counter_bytes = BitConverter.GetBytes((uint)IPAddress.HostToNetworkOrder((int)counter));\n            Buffer.BlockCopy(counter_bytes, 0, _keyBuffer, ivLen, 4);\n            counter++;\n        }\n        protected byte[] genHash(byte[] buf, int offset, int len)\n        {\n            byte[] hash = new byte[20];
            byte[] hash = new byte[20];\n            updateKeyBuffer();\n            Sodium.ss_sha1_hmac_ex(_keyBuffer, (uint)_keyBuffer.Length,\n                buf, offset, (uint)len, hash);\n            return hash;\n        }\n        protected void reactBuffer4TCP(byte[] buf, ref int length)\n        {\n            if (!_encryptIVSent)\n            {
                buf, offset, (uint)len, hash);\n            return hash;\n        }\n        protected void reactBuffer4TCP(byte[] buf, ref int length)\n        {\n            if (!_encryptIVSent)\n            {\n                int headLen = getHeadLen(buf, length);\n                int dataLen = length - headLen;\n                buf[0] |= ONETIMEAUTH_FLAG;
                Buffer.BlockCopy(buf, 0, buf, AUTH_BYTES, length);\n                byte[] lenBytes = BitConverter.GetBytes((ushort)IPAddress.HostToNetworkOrder((short)length));\n                Buffer.BlockCopy(lenBytes, 0, buf, 0, CLEN_BYTES);\n                Buffer.BlockCopy(hash, 0, buf, CLEN_BYTES, ONETIMEAUTH_BYTES);\n                length += AUTH_BYTES;\n            }\n        }\n        protected void reactBuffer4UDP(byte[] buf, ref int length)\n        {\n            buf[0] |= ONETIMEAUTH_FLAG;
            byte[] hash = genOnetimeAuthHash(buf, length);\n            Buffer.BlockCopy(hash, 0, buf, length, ONETIMEAUTH_BYTES);\n            length += ONETIMEAUTH_BYTES;\n        }\n        protected void reactBuffer(byte[] buf, ref int length)\n        {\n            if (OnetimeAuth && ivLen > 0)\n            {\n                if (!IsUDP)\n                {
        protected void reactBuffer(byte[] buf, ref int length)\n        {\n            if (OnetimeAuth && ivLen > 0)\n            {\n                if (!IsUDP)\n                {\n                    reactBuffer4TCP(buf, ref length);\n                }\n                else\n                {
                    reactBuffer4UDP(buf, ref length);\n                }\n            }\n        }\n        public override void Encrypt(byte[] buf, int length, byte[] outbuf, out int outlength)\n        {\n            if (!_encryptIVSent)\n            {
﻿//------------------------------------------------------------------------------\n// <auto-generated>
    internal class Resources\n    {\n        private static global::System.Resources.ResourceManager resourceMan;\n        private static global::System.Globalization.CultureInfo resourceCulture;\n        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]\n        internal Resources()\n        {\n        }\n        /// <summary>
            if (_lastSelectedIndex < 0 || _lastSelectedIndex >= ServersListBox.Items.Count)\n            {\n                _lastSelectedIndex = 0;\n            }\n            ServersListBox.SelectedIndex = _lastSelectedIndex;\n            UpdateButtons();\n            LoadSelectedServerDetails();\n            ProxyPortTextBox.Text = _modifiedConfiguration.localPort.ToString();\n            PortableModeCheckBox.Checked = _modifiedConfiguration.portableMode;\n        }
        }\n        private void OKButton_Click(object sender, EventArgs e)\n        {\n            if (!ValidateAndSaveSelectedServerDetails())\n            {\n                return;\n            }\n            if (_modifiedConfiguration.configs.Count == 0)\n            {\n                MessageBox.Show(I18N.GetString("Please add at least one server"));
            {\n                MessageBox.Show(I18N.GetString("Please add at least one server"));\n                return;\n            }\n            int localPort = int.Parse(ProxyPortTextBox.Text);\n            Configuration.CheckLocalPort(localPort);\n            _modifiedConfiguration.localPort = localPort;\n            _modifiedConfiguration.portableMode = PortableModeCheckBox.Checked;\n            controller.SaveServers(_modifiedConfiguration.configs, _modifiedConfiguration.localPort, _modifiedConfiguration.portableMode);\n            // SelectedIndex remains valid\n            // We handled this in event handlers, e.g. Add/DeleteButton, SelectedIndexChanged\n            // and move operations\n            controller.SelectServerIndex(ServersListBox.SelectedIndex);
            // \n            this.PluginOptionsLabel.Anchor = System.Windows.Forms.AnchorStyles.Right;\n            this.PluginOptionsLabel.AutoSize = true;\n            this.PluginOptionsLabel.Location = new System.Drawing.Point(18, 166);\n            this.PluginOptionsLabel.Name = "PluginOptionsLabel";\n            this.PluginOptionsLabel.Size = new System.Drawing.Size(89, 12);\n            this.PluginOptionsLabel.TabIndex = 6;\n            this.PluginOptionsLabel.Text = "Plugin Options";\n            this.ApplyButton.Enabled = false;
            Configuration.Save(_config);\n        }\n        public void SaveLogViewerConfig(LogViewerConfig newConfig)\n        {\n            _config.logViewer = newConfig;\n            Configuration.Save(_config);\n        }\n        public void UpdateInboundCounter(long n)\n        {\n            Interlocked.Add(ref inboundCounter, n);
            Configuration.Save(_config);\n        }\n        public void UpdateInboundCounter(long n)\n        {\n            Interlocked.Add(ref inboundCounter, n);\n            _config.bandwidthIn = inboundCounter;\n        }\n        public void UpdateOutboundCounter(long n)\n        {\n            Interlocked.Add(ref outboundCounter, n);
            _config.bandwidthIn = inboundCounter;\n        }\n        public void UpdateOutboundCounter(long n)\n        {\n            Interlocked.Add(ref outboundCounter, n);\n            _config.bandwidthOut = outboundCounter;\n        }\n        protected void Reload()\n        {\n            // some logic in configuration updated the config when saving, we need to read it again\n            _config = Configuration.Load();
            this.StatisticsEnabledCheckBox = new System.Windows.Forms.CheckBox();\n            this.choiceKeptMinutesNum = new System.Windows.Forms.NumericUpDown();\n            this.byHourOfDayCheckBox = new System.Windows.Forms.CheckBox();\n            this.repeatTimesNum = new System.Windows.Forms.NumericUpDown();\n            this.label6 = new System.Windows.Forms.Label();\n            this.splitContainer3 = new System.Windows.Forms.SplitContainer();\n            this.label1 = new System.Windows.Forms.Label();\n            this.calculationContainer = new System.Windows.Forms.FlowLayoutPanel();\n            this.OKButton = new System.Windows.Forms.Button();
            this.byHourOfDayCheckBox = new System.Windows.Forms.CheckBox();\n            this.repeatTimesNum = new System.Windows.Forms.NumericUpDown();\n            this.label6 = new System.Windows.Forms.Label();\n            this.splitContainer3 = new System.Windows.Forms.SplitContainer();\n            this.label1 = new System.Windows.Forms.Label();\n            this.calculationContainer = new System.Windows.Forms.FlowLayoutPanel();\n            this.OKButton = new System.Windows.Forms.Button();\n            this.CancelButton = new System.Windows.Forms.Button();\n            ((System.ComponentModel.ISupportInitialize)(this.StatisticsChart)).BeginInit();
            // OKButton\n            // \n            this.OKButton.Location = new System.Drawing.Point(745, 166);\n            this.OKButton.Name = "OKButton";\n            this.OKButton.Size = new System.Drawing.Size(93, 43);\n            this.OKButton.TabIndex = 4;\n            this.OKButton.Text = "OK";\n            this.OKButton.UseVisualStyleBackColor = true;\n            this.OKButton.Click += new System.EventHandler(this.OKButton_Click);\n            // 
        {\n            if (controller == null) return;\n            InitializeComponent();\n            _controller = controller;\n            _controller.ConfigChanged += (sender, args) => LoadConfiguration();\n            LoadConfiguration();\n            Load += (sender, args) => InitData();\n        }\n        private void LoadConfiguration()\n        {
using Shadowsocks.Properties;\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.IO.Compression;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Text;
using System.IO.Compression;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Text;\nusing System.Text.RegularExpressions;\nnamespace Shadowsocks.Controller\n{\n    class PACServer\n    {\n        private static int PORT = 8093;
namespace Shadowsocks.Controller\n{\n    class PACServer\n    {\n        private static int PORT = 8093;\n        private static string PAC_FILE = "pac.txt";\n        private static Configuration config;\n        Socket _listener;\n        FileSystemWatcher watcher;\n        public event EventHandler PACFileChanged;
namespace Shadowsocks.Controller\n{
namespace Shadowsocks.Controller\n{\n        public IWebProxy proxy = null;\n        public class GfwListDownloadCompletedArgs : EventArgs\n        {\n            public string Content;\n        }\n        public event EventHandler<GfwListDownloadCompletedArgs> DownloadCompleted;\n        public event ErrorEventHandler Error;
namespace Shadowsocks.Controller\n{\n        {\n            public string Content;\n        }\n        public event EventHandler<GfwListDownloadCompletedArgs> DownloadCompleted;\n        public event ErrorEventHandler Error;\n        {\n            if (Error != null)\n            {\n                Error(this, new ErrorEventArgs(e));\n            }\n        }\n        private void http_DownloadStringCompleted(object sender, DownloadStringCompletedEventArgs e)\n        {\n            try\n            {
        public event EventHandler<GfwListDownloadCompletedArgs> DownloadCompleted;\n        public event ErrorEventHandler Error;\n                Error(this, new ErrorEventArgs(e));\n            }\n        }\n        private void http_DownloadStringCompleted(object sender, DownloadStringCompletedEventArgs e)\n        {\n            try\n            {\n                string response = e.Result;\n                if (DownloadCompleted != null)\n                {
            try\n            {\n                string response = e.Result;\n                if (DownloadCompleted != null)\n                {\n                    DownloadCompleted(this, new GfwListDownloadCompletedArgs\n                    {\n                        Content = response\n                    });\n                }\n            }\n            catch (Exception ex)\n            {
                {\n                        Content = response\n                    });\n                }\n            }\n            catch (Exception ex)\n            {\n                ReportError(ex);\n            }\n        }
                }\n            }\n            catch (Exception ex)\n            {\n                ReportError(ex);\n            }\n        }\n        public class Parser\n        {
            {\n                ReportError(ex);\n            }\n        }\n        public class Parser\n        {\n            private string _Content;\n            public string Content\n            {
            }\n        }\n        public class Parser\n        {\n            private string _Content;\n            public string Content\n            {\n                get { return _Content; }\n            }
        }\n        private void pacServer_PACFileChanged(object sender, EventArgs e)\n        {\n            UpdateSystemProxy();\n        }\n        private void pacServer_UpdatePACFromGFWListCompleted(object sender, EventArgs e)\n        {\n            if (UpdatePACFromGFWListCompleted != null)\n                UpdatePACFromGFWListCompleted(this, e);\n        }
﻿using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Runtime.InteropServices;\nusing System.Text;\nnamespace Shadowsocks.Util\n{
namespace Shadowsocks.Controller\n{\n    class PolipoRunner\n    {\n        private Process _process;\n        private static string temppath;\n        private int _runningPort;\n        static PolipoRunner()\n        {
            Handler handler = new Handler();\n            handler.connection = socket;\n            handler.controller = _controller;\n            handler.relay = this;\n            handler.Start(firstPacket, length);\n            lock (this.Handlers)\n            {\n                this.Handlers.Add(handler);\n                Logging.Debug($"connections: {Handlers.Count}");

         }\n         if (hasAlphanumeric)\n         {\n            return Mode.ALPHANUMERIC;\n         }\n         if (hasNumeric)\n         {\n            return Mode.NUMERIC;\n         }\n         return Mode.BYTE;
      /// </summary>\n      /// <param name="content">The content.</param>\n      /// <param name="mode">The mode.</param>\n      /// <param name="bits">The bits.</param>\n      /// <param name="encoding">The encoding.</param>\n      internal static void appendBytes(String content,\n                              Mode mode,\n                              BitArray bits,\n                              String encoding)\n      {
      /// <param name="bits">The bits.</param>\n      /// <param name="encoding">The encoding.</param>\n      internal static void appendBytes(String content,\n                              Mode mode,\n                              BitArray bits,\n                              String encoding)\n      {\n         if (mode.Equals(Mode.NUMERIC))\n            appendNumericBytes(content, bits);\n         else\n            if (mode.Equals(Mode.ALPHANUMERIC))\n               appendAlphanumericBytes(content, bits);\n            else
         var index = (-num & num)%37;\n         if (index < 0)\n            index *= -1;\n         return _lookup[index];\n      }\n      private static readonly int[] _lookup =\n         {\n            32, 0, 1, 26, 2, 23, 27, 0, 3, 16, 24, 30, 28, 11, 0, 13, 4, 7, 17,\n            0, 25, 22, 31, 15, 29, 10, 12, 6, 0, 21, 14, 9, 5, 20, 8, 19, 18\n         };
            0, 25, 22, 31, 15, 29, 10, 12, 6, 0, 21, 14, 9, 5, 20, 8, 19, 18\n         };\n            }\n            currentBits = ~bits[bitsOffset];\n         }\n         int result = (bitsOffset << 5) + numberOfTrailingZeros(currentBits);\n         return result > size ? size : result;\n      }\n      /// </summary>\n      /// <param name="i">first bit to set\n      /// </param>\n      /// <param name="newBits">the new value of the next 32 bits. Note again that the least-significant bit\n      /// corresponds to bit i, the next-least-significant to i+1, and so on.\n      /// </param>\n      public void setBulk(int i, int newBits)\n      {\n         bits[i >> 5] = newBits;\n      }
         bits[i >> 5] = newBits;\n      }\n            bits[i] |= mask;\n         }\n      }\n      /// <summary> Clears all bits (sets to false).</summary>\n      public void clear()\n      {\n         int max = bits.Length;\n         for (int i = 0; i < max; i++)\n         {\n            bits[i] = 0;\n         }
﻿using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Net.NetworkInformation;
                    _timer?.Dispose();\n                }\n                return true;\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                return false;\n            }\n        }
            var ping = new Ping();
            var ping = new Ping();\n            var state = (State) obj;\n            foreach (var server in _servers)\n            {
            var ping = new Ping();\n            var state = (State) obj;\n            foreach (var server in _servers)\n            {\n                Logging.Debug("eveluating " + server.FriendlyName());\n                foreach (var _ in Enumerable.Range(0, Repeat))\n                {
                        new KeyValuePair<string, string>("Timestamp", timestamp),\n                        new KeyValuePair<string, string>("Server", server.FriendlyName()),\n                        new KeyValuePair<string, string>("Status", reply?.Status.ToString()),\n                        new KeyValuePair<string, string>("RoundtripTime", reply?.RoundtripTime.ToString())\n                    };\n                    //state.data.Add(new KeyValuePair<string, string>("data", reply.Buffer.ToString())); // The data of reply\n                    Append(state.Data);\n                }\n            }\n        }
        {\n            asserts.Sort(new VersionComparer());\n        }\n        public class Asset\n        {\n            public bool prerelease;\n            public string name;\n            public string version;\n            public string browser_download_url;\n            public string suffix;
            public static Asset ParseAsset(JObject aJObject)\n            {\n                var name = (string) aJObject["name"];\n                Match match = Regex.Match(name, @"^Shadowsocks-(?<version>\d+(?:\.\d+)*)(?:|-(?<suffix>.+))\.\w+$",\n                    RegexOptions.IgnoreCase);\n                if (match.Success)\n                {\n                    string version = match.Groups["version"].Value;\n                    var asset = new Asset\n                    {
using System.Windows.Forms.DataVisualization.Charting;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Shadowsocks.Controller;\nusing Shadowsocks.Properties;\nusing Shadowsocks.Model;\nusing Shadowsocks.Util;\nusing System.Text;\nnamespace Shadowsocks.View\n{
{\n        }\n    }\n    public partial class LogForm : Form\n    {\n        long lastOffset;\n        string filename;\n        Timer timer;\n        const int BACK_OFFSET = 65536;\n        ShadowsocksController controller;\n        // global traffic update lock, make it static\n        private static readonly object _lock = new object();
            LogViewerConfig config = controller.GetConfigurationCopy().logViewer;\n            topMostTrigger = config.topMost;\n            wrapTextTrigger = config.wrapText;\n            toolbarTrigger = config.toolbarShown;\n            LogMessageTextBox.BackColor = config.BackgroundColor;\n            LogMessageTextBox.ForeColor = config.TextColor;\n            LogMessageTextBox.Font = config.Font;\n            controller.TrafficChanged += controller_TrafficChanged;\n            UpdateTexts();\n        }
            LogMessageTextBox.ForeColor = config.TextColor;\n            LogMessageTextBox.Font = config.Font;\n            controller.TrafficChanged += controller_TrafficChanged;\n            UpdateTexts();\n        }\n            List<float> inboundPoints = new List<float>();\n            List<float> outboundPoints = new List<float>();\n            TextAnnotation inboundAnnotation = new TextAnnotation();\n            TextAnnotation outboundAnnotation = new TextAnnotation();\n            BandwidthScaleInfo bandwidthScale;\n            const long minScale = 50;\n            long maxSpeed = 0;\n            long lastInbound, lastOutbound;\n            lock (_lock)\n            {
            controller.TrafficChanged += controller_TrafficChanged;\n            UpdateTexts();\n        }\n            TextAnnotation inboundAnnotation = new TextAnnotation();\n            TextAnnotation outboundAnnotation = new TextAnnotation();\n            BandwidthScaleInfo bandwidthScale;\n            const long minScale = 50;\n            long maxSpeed = 0;\n            long lastInbound, lastOutbound;\n            lock (_lock)\n            {\n                if (traffic.Count == 0)\n                    return;
        private Configuration _config;\n        private StrategyManager _strategyManager;\n        private PrivoxyRunner privoxyRunner;\n        private GFWListUpdater gfwListUpdater;\n        public AvailabilityStatistics availabilityStatistics = AvailabilityStatistics.Instance;\n        public StatisticsStrategyConfiguration StatisticsConfiguration { get; private set; }\n        private long _inboundCounter = 0;\n        private long _outboundCounter = 0;\n        public long InboundCounter => Interlocked.Read(ref _inboundCounter);\n        public long OutboundCounter => Interlocked.Read(ref _outboundCounter);
        private long _inboundCounter = 0;\n        private long _outboundCounter = 0;\n        public long InboundCounter => Interlocked.Read(ref _inboundCounter);\n        public long OutboundCounter => Interlocked.Read(ref _outboundCounter);\n        public QueueLast<TrafficPerSecond> traffic;\n        private bool stopped = false;\n        private bool _systemProxyIsDirty = false;\n        public class PathEventArgs : EventArgs\n        {\n            public string Path;
            while (true)\n            {\n                Utils.ReleaseMemory(false);\n                Thread.Sleep(30 * 1000);\n            }\n        }\n        #endregion\n        #region Traffic Statistics\n        private void StartTrafficStatistics(int queueMaxSize)\n        {
                Thread.Sleep(30 * 1000);\n            }\n        }\n        #endregion\n        #region Traffic Statistics\n        private void StartTrafficStatistics(int queueMaxSize)\n        {\n            traffic = new QueueLast<TrafficPerSecond>();\n            for (int i = 0; i < queueMaxSize; i++)\n            {
            }\n            _trafficThread = new Thread(new ThreadStart(() => TrafficStatistics(queueMaxSize)));\n            _trafficThread.IsBackground = true;\n            _trafficThread.Start();\n        }\n        private void TrafficStatistics(int queueMaxSize)\n        {\n            while (true)\n            {
    class TCPHandler\n    {\n        // public Encryptor encryptor;\n        public IEncryptor encryptor;\n        public Server server;\n        // Client  socket.\n        public Socket remote;\n        public Socket connection;\n        public ShadowsocksController controller;
        public Socket connection;\n        public ShadowsocksController controller;\n        public TCPRelay relay;\n        public DateTime lastActivity;
        }\n        private void ChangeFontButton_Click(object sender, EventArgs e)\n        {\n            DoChangeFont();\n        }\n        #endregion\n        #region Trigger the log messages wrapable, or not.\n        private bool ShowToolbarTrigger = false;\n        private void ShowToolbarMenuItem_Click(object sender, EventArgs e)\n        {
    }\n    class Handler\n    {\n        //public Encryptor encryptor;\n        public IEncryptor encryptor;\n        public Config config;\n        // Client  socket.\n        public Socket remote;\n        public Socket connection;\n        // Size of receive buffer.
    {\n        //public Encryptor encryptor;\n        public IEncryptor encryptor;\n        public Config config;\n        // Client  socket.\n        public Socket remote;\n        public Socket connection;\n        // Size of receive buffer.\n        public const int BufferSize = 1500;\n        // remote receive buffer
        public IEncryptor encryptor;\n        public Config config;\n        // Client  socket.\n        public Socket remote;\n        public Socket connection;\n        // Size of receive buffer.\n        public const int BufferSize = 1500;\n        // remote receive buffer\n        public byte[] remoteBuffer = new byte[BufferSize];\n        // connection receive buffer
            {\n                Console.WriteLine(e.ToString());\n                this.Close();\n            }\n        }\n        private void startPipe(IAsyncResult ar)\n        {\n            try\n            {\n                connection.EndReceive(ar);
                this.Close();\n            }\n        }\n        private void startPipe(IAsyncResult ar)\n        {\n            try\n            {\n                connection.EndReceive(ar);\n                remote.BeginReceive(remoteBuffer, 0, BufferSize, 0,\n                    new AsyncCallback(pipeRemoteReceiveCallback), null);
        };\n        static OpensslEncryptor()\n        {\n            OpenSSL.OpenSSL_add_all_ciphers();\n        }\n        public OpensslEncryptor(string method, string password)\n            : base(method, password)\n        {\n            InitKey(method, password);\n        }
        public OpensslEncryptor(string method, string password)\n            : base(method, password)\n        {\n            InitKey(method, password);\n        }\n        public override byte[] Encrypt(byte[] buf, int length)\n        {\n            if (_encryptCtx == IntPtr.Zero)\n            {
        public override byte[] Encrypt(byte[] buf, int length)\n        {\n            if (_encryptCtx == IntPtr.Zero)\n            {\n                int outLen = length + ivLen;\n                byte[] cipherText = new byte[outLen];\n                OpenSSL.EVP_CipherUpdate(_encryptCtx, cipherText, out outLen, buf, length);\n                byte[] result = new byte[outLen + ivLen];\n                Buffer.BlockCopy(iv, 0, result, 0, ivLen);\n                Buffer.BlockCopy(cipherText, 0, result, ivLen, outLen);\n                return result;\n            }\n            else\n            {
            {\n                Buffer.BlockCopy(iv, 0, result, 0, ivLen);\n                Buffer.BlockCopy(cipherText, 0, result, ivLen, outLen);\n                return result;\n            }\n            else\n            {\n                int outLen = length + ivLen;\n                byte[] cipherText = new byte[outLen];\n                OpenSSL.EVP_CipherUpdate(_encryptCtx, cipherText, out outLen, buf, length);\n                byte[] result = new byte[outLen];\n                Buffer.BlockCopy(cipherText, 0, result, 0, outLen);\n                return result;\n            }\n        }
            else\n            {\n                OpenSSL.EVP_CipherUpdate(_encryptCtx, cipherText, out outLen, buf, length);\n                byte[] result = new byte[outLen];\n                Buffer.BlockCopy(cipherText, 0, result, 0, outLen);\n                return result;\n            }\n        }\n        public override byte[] Decrypt(byte[] buf, int length)\n        {\n            if (_decryptCtx == IntPtr.Zero)\n            {
        }\n        public override byte[] Decrypt(byte[] buf, int length)\n        {\n            if (_decryptCtx == IntPtr.Zero)\n            {\n                byte[] cipherText = new byte[outLen];\n                byte[] subset = new byte[length - ivLen];\n                Buffer.BlockCopy(buf, ivLen, subset, 0, length - ivLen);\n                OpenSSL.EVP_CipherUpdate(_decryptCtx, cipherText, out outLen, subset, length - ivLen);\n                byte[] result = new byte[outLen];\n                Buffer.BlockCopy(cipherText, 0, result, 0, outLen);\n                return result;\n            }\n            else\n            {
﻿using System;\nusing System.Collections.Generic;\nusing System.Text;\nnamespace shadowsocks_csharp.Encrypt\n{
﻿using System;\nusing System.Collections.Generic;\nusing System.Text;\nnamespace shadowsocks_csharp.Encrypt\n{\n    public interface IEncryptor\n    {
            }\n            for (int i = 1; i < 1024; i++)\n            {\n                _encryptTable = MergeSort(_encryptTable, a, i);\n            }\n            for (int i = 0; i < 256; i++)\n            {\n                _decryptTable[_encryptTable[i]] = (byte)i;\n            }\n        }
            for (int i = 0; i < 256; i++)\n            {\n                _decryptTable[_encryptTable[i]] = (byte)i;\n            }\n        }\n        public override byte[] Encrypt(byte[] buf, int length)\n        {\n            byte[] result = new byte[length];\n            for (int i = 0; i < length; i++)\n            {
                _decryptTable[_encryptTable[i]] = (byte)i;\n            }\n        }\n        public override byte[] Encrypt(byte[] buf, int length)\n        {\n            byte[] result = new byte[length];\n            for (int i = 0; i < length; i++)\n            {\n                result[i] = _encryptTable[buf[i]];\n            }
        }\n        public override byte[] Encrypt(byte[] buf, int length)\n        {\n            byte[] result = new byte[length];\n            for (int i = 0; i < length; i++)\n            {\n                result[i] = _encryptTable[buf[i]];\n            }\n            return result;\n        }
            {\n                result[i] = _encryptTable[buf[i]];\n            }\n            return result;\n        }\n        public override byte[] Decrypt(byte[] buf, int length)\n        {\n            byte[] result = new byte[length];\n            for (int i = 0; i < length; i++)\n            {
            }\n            return result;\n        }\n        public override byte[] Decrypt(byte[] buf, int length)\n        {\n            byte[] result = new byte[length];\n            for (int i = 0; i < length; i++)\n            {\n                result[i] = _decryptTable[buf[i]];\n            }
﻿using System;\nusing System.Windows.Forms;\nusing Microsoft.Win32;\nusing Shadowsocks.Util;\nnamespace Shadowsocks.Controller\n{
﻿using System;\nusing System.Windows.Forms;\nusing Microsoft.Win32;\nusing Shadowsocks.Util;\nnamespace Shadowsocks.Controller\n{\n    class AutoStartup\n    {
{\n    class AutoStartup\n    {\n        static string Key = "Shadowsocks_" + Application.StartupPath.GetHashCode();\n        public static bool Set(bool enabled)\n        {\n            RegistryKey runKey = null;\n            try\n            {
            try\n            {\n                string path = Application.ExecutablePath;\n                runKey = Utils.OpenRegKey(@"Software\Microsoft\Windows\CurrentVersion\Run", true);\n                if ( runKey == null ) {\n                    Logging.Error( @"Cannot find HKCU\Software\Microsoft\Windows\CurrentVersion\Run" );\n                    return false;\n                }\n                if (enabled)\n                {
                foreach (string item in runList)\n                {\n                    if (item.Equals(Key, StringComparison.OrdinalIgnoreCase))\n                        return true;\n                    else if (item.Equals("Shadowsocks", StringComparison.OrdinalIgnoreCase)) // Compatibility with older versions\n                    {\n                        string value = Convert.ToString(runKey.GetValue(item));\n                        if (path.Equals(value, StringComparison.OrdinalIgnoreCase))\n                        {\n                            runKey.DeleteValue(item);
            }\n            public AsyncSession(AsyncSession session, T state): base(session.Remote)\n            {\n                State = state;\n            }\n        }\n        // Size of receive buffer.\n        public static readonly int RecvSize = 8192;\n        public static readonly int RecvReserveSize = IVEncryptor.ONETIMEAUTH_BYTES + IVEncryptor.AUTH_BYTES; // reserve for one-time auth\n        public static readonly int BufferSize = RecvSize + RecvReserveSize + 32;
                State = state;\n            }\n        }\n        // Size of receive buffer.\n        public static readonly int RecvSize = 8192;\n        public static readonly int RecvReserveSize = IVEncryptor.ONETIMEAUTH_BYTES + IVEncryptor.AUTH_BYTES; // reserve for one-time auth\n        public static readonly int BufferSize = RecvSize + RecvReserveSize + 32;\n        // public Encryptor encryptor;\n        public IEncryptor encryptor;\n        public Server server;\n        // Client  socket.\n        private AsyncSession _currentRemoteSession;
        private byte[] _connetionRecvBuffer = new byte[BufferSize];\n        private byte[] _connetionSendBuffer = new byte[BufferSize];\n        private bool _connectionShutdown = false;\n        private bool _remoteShutdown = false;\n        private bool _closed = false;\n        private object _encryptionLock = new object();\n        private object _decryptionLock = new object();\n        private DateTime _startConnectTime;\n        private DateTime _startReceivingTime;\n        private DateTime _startSendingTime;
        private object _encryptionLock = new object();\n        private object _decryptionLock = new object();\n        private DateTime _startConnectTime;\n        private DateTime _startReceivingTime;\n        private DateTime _startSendingTime;\n        private int _bytesToSend;\n        private TCPRelay _tcprelay;  // TODO: is _tcprelay equals tcprelay declared above?\n        private Configuration _config;\n        public TCPHandler(TCPRelay tcprelay, Configuration config)\n        {\n            this._tcprelay = tcprelay;
        }\n        public void CreateRemote()\n        {
        }\n        public void CreateRemote()\n        {\n            lock (tcprelay.Handlers)\n            {\n                tcprelay.Handlers.Remove(this);\n            }\n            lock (this) {\n                if (_closed) return;\n                _closed = true;\n            }
             * cipher_setkey() will set the correct key schedule\n             * and operation\n             *\n             *  MBEDTLS_AES_{EN,DE}CRYPT\n             *  == MBEDTLS_BLOWFISH_{EN,DE}CRYPT\n             *  == MBEDTLS_CAMELLIA_{EN,DE}CRYPT\n             *  == MBEDTLS_{EN,DE}CRYPT\n             *  \n             */\n            if (MbedTLS.cipher_setkey(ctx, realkey, keyLen * 8, isCipher ? MbedTLS.MBEDTLS_ENCRYPT : MbedTLS.MBEDTLS_DECRYPT) != 0 )
             *\n             *  MBEDTLS_AES_{EN,DE}CRYPT\n             *  == MBEDTLS_BLOWFISH_{EN,DE}CRYPT\n             *  == MBEDTLS_CAMELLIA_{EN,DE}CRYPT\n             *  == MBEDTLS_{EN,DE}CRYPT\n             *  \n             */\n            if (MbedTLS.cipher_setkey(ctx, realkey, keyLen * 8, isCipher ? MbedTLS.MBEDTLS_ENCRYPT : MbedTLS.MBEDTLS_DECRYPT) != 0 )\n                throw new Exception();\n            if (MbedTLS.cipher_set_iv(ctx, iv, ivLen) != 0)
             *  == MBEDTLS_BLOWFISH_{EN,DE}CRYPT\n             *  == MBEDTLS_CAMELLIA_{EN,DE}CRYPT\n             *  == MBEDTLS_{EN,DE}CRYPT\n             *  \n             */\n            if (MbedTLS.cipher_setkey(ctx, realkey, keyLen * 8, isCipher ? MbedTLS.MBEDTLS_ENCRYPT : MbedTLS.MBEDTLS_DECRYPT) != 0 )\n                throw new Exception();\n            if (MbedTLS.cipher_set_iv(ctx, iv, ivLen) != 0)\n                throw new Exception();\n            if (MbedTLS.cipher_reset(ctx) != 0)
                }\n            }\n        }\n        static I18N()\n        {\n            string name = CultureInfo.CurrentCulture.EnglishName;\n            if (name.StartsWith("Chinese", StringComparison.OrdinalIgnoreCase))\n            {\n                // choose Traditional Chinese only if we get explicit indication\n                Init(name.Contains("Traditional")
            string name = CultureInfo.CurrentCulture.EnglishName;\n            if (name.StartsWith("Chinese", StringComparison.OrdinalIgnoreCase))\n            {\n                // choose Traditional Chinese only if we get explicit indication\n                Init(name.Contains("Traditional")\n                    ? Resources.zh_tw\n                    : Resources.cn);\n            }\n            else if (name.StartsWith("Japan", StringComparison.OrdinalIgnoreCase))\n            {
using Shadowsocks.Encryption;\nusing Shadowsocks.Model;\nusing System.Net.Sockets;\nusing System.Net;\nusing System.Runtime.CompilerServices;\nnamespace Shadowsocks.Controller\n{\n    class UDPRelay : Listener.Service\n    {
using System.Net.Sockets;\nusing System.Net;\nusing System.Runtime.CompilerServices;\nnamespace Shadowsocks.Controller\n{\n    class UDPRelay : Listener.Service\n    {\n        private Configuration _config;\n        private LRUCache<IPEndPoint, UDPHandler> _cache;
using System.Runtime.CompilerServices;\nnamespace Shadowsocks.Controller\n{\n    class UDPRelay : Listener.Service\n    {\n        private Configuration _config;\n        private LRUCache<IPEndPoint, UDPHandler> _cache;\n        public UDPRelay(Configuration config)\n        {
            // we want to show more details but notify icon title is limited to 63 characters\n            string text = I18N.GetString("Shadowsocks") + " " + UpdateChecker.Version + "\n" +\n                (enabled ?\n                    I18N.GetString("System Proxy On: ") + (global ? I18N.GetString("Global") : I18N.GetString("PAC")) :\n                    String.Format(I18N.GetString("Running: Port {0}"), config.localPort))  // this feedback is very important because they need to know Shadowsocks is running
                CreateMenuItem("Quit", new EventHandler(this.Quit_Click))\n            });\n        }\n        private void controller_ConfigChanged(object sender, EventArgs e)\n        {\n            LoadCurrentConfiguration();\n            UpdateTrayIcon();\n        }\n        private void controller_EnableStatusChanged(object sender, EventArgs e)\n        {
            LoadCurrentConfiguration();\n            UpdateTrayIcon();\n        }\n        private void controller_EnableStatusChanged(object sender, EventArgs e)\n        {\n            enableItem.Checked = controller.GetConfiguration().enabled;\n            modeItem.Enabled = enableItem.Checked;\n        }\n        void controller_ShareOverLANStatusChanged(object sender, EventArgs e)\n        {
        {\n            enableItem.Checked = controller.GetConfiguration().enabled;\n            modeItem.Enabled = enableItem.Checked;\n        }\n        void controller_ShareOverLANStatusChanged(object sender, EventArgs e)\n        {\n            ShareOverLANItem.Checked = controller.GetConfiguration().shareOverLan;\n        }\n        void controller_EnableGlobalChanged(object sender, EventArgs e)\n        {
            localPACItem.Checked = !onlinePACItem.Checked;\n            UpdatePACItemsEnabledStatus();\n        }\n        private void UpdateServersMenu()\n        {\n            var items = ServersItem.MenuItems;\n            while (items[0] != SeperatorItem)\n            {\n                items.RemoveAt(0);\n            }
            }\n            Configuration configuration = controller.GetConfiguration();\n            for (int i = 0; i < configuration.configs.Count; i++)\n            {\n                Server server = configuration.configs[i];\n                MenuItem item = new MenuItem(server.FriendlyName());\n                item.Tag = i;\n                item.Click += AServerItem_Click;\n                items.Add(i, item);
using System.Text;\nusing System.Net.Sockets;\nusing System.Net;\nusing Shadowsocks.Encryption;\nusing Shadowsocks.Model;\nnamespace Shadowsocks.Controller\n{\n    class TCPRelay : Listener.Service\n    {
            if (Errored != null)\n            {\n                Errored(this, new ErrorEventArgs(e));\n            }\n        }\n        public Server GetCurrentServer()\n        {\n            return _config.GetCurrentServer();\n        }\n        // always return copy
                    }\n                };\n            }\n        }\n        public static void Save(Configuration config)\n        {\n            if (config.index >= config.configs.Count)\n            {\n                config.index = config.configs.Count - 1;\n            }
            }\n        }\n        public static void Save(Configuration config)\n        {\n            if (config.index >= config.configs.Count)\n            {\n                config.index = config.configs.Count - 1;\n            }\n            if (config.index < 0)\n            {
                        this.Close();\n                    }\n                }\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                this.Close();\n            }\n        }
            Application.Exit();\n        }\n        private static void SystemEvents_PowerModeChanged(object sender, PowerModeChangedEventArgs e)\n        {\n            switch (e.Mode)\n            {\n                case PowerModes.Resume:\n                    Logging.Info("os wake up");\n                    if (_controller != null)\n                    {
                    _controller?.Stop();\n                    Logging.Info("os suspend");\n                    break;\n            }\n        }\n        private static void Timer_Elapsed(object sender, System.Timers.ElapsedEventArgs e)\n        {\n            try\n            {
                UserRuleFileReadyToOpen(this, new PathEventArgs() { Path = userRuleFilename });\n            }\n        }\n        public string GetQRCodeForCurrentServer()\n        {\n            Server server = GetCurrentServer();\n            return GetQRCode(server);\n        }\n        public static string GetQRCode(Server server)\n        {
        {\n            Server server = GetCurrentServer();\n            return GetQRCode(server);\n        }\n        public static string GetQRCode(Server server)\n        {\n            string parts = server.method;\n            if (server.auth) parts += "-auth";\n            parts += ":" + server.password + "@" + server.server + ":" + server.server_port;\n            string base64 = Convert.ToBase64String(Encoding.UTF8.GetBytes(parts));
using Shadowsocks.Controller;\nnamespace Shadowsocks.Model\n{\n    [Serializable]\n    public class Server\n    {\n        public static readonly Regex
using Shadowsocks.Controller;\nnamespace Shadowsocks.Model\n{\n    [Serializable]\n    public class Server\n    {\n        public static readonly Regex\n            var tag = match.Groups[2].Value;\n            if (!tag.IsNullOrEmpty())
            connection.BeginSend(response, 0, response.Length, SocketFlags.None, new AsyncCallback(ReadAll), true);\n        }\n        private void ReadAll(IAsyncResult ar)\n        {\n            if (_closed) return;\n            try\n            {\n                if (ar.AsyncState != null)\n                {\n                    connection.EndSend(ar);
                {\n                    connection.EndSend(ar);\n                    Logging.Debug(remote.LocalEndPoint, remote.DestEndPoint, RecvSize, "TCP Relay");\n                    connection.BeginReceive(_connetionRecvBuffer, 0, RecvSize, SocketFlags.None, new AsyncCallback(ReadAll), null);\n                }\n                else\n                {\n                    int bytesRead = connection.EndReceive(ar);\n                    if (bytesRead > 0)\n                    {
            {\n                Console.WriteLine(e.ToString());\n                this.Close();\n            }\n        }\n        private void handshakeReceiveCallback(IAsyncResult ar)\n        {\n            try\n            {\n                int bytesRead = connection.EndReceive(ar);
        {\n            Dispose(false);\n        }\n        protected virtual void Dispose(bool disposing)\n        {\n            if (!_disposed)\n            {\n                if (disposing)\n                {\n                }
            {\n                if (disposing)\n                {\n                }\n                if (_encryptCtx != IntPtr.Zero)\n                {\n                    OpenSSL.EVP_CIPHER_CTX_cleanup(_encryptCtx);\n                    OpenSSL.EVP_CIPHER_CTX_free(_encryptCtx);\n                    _encryptCtx = IntPtr.Zero;\n                }
        private static void IEAutoDetectProxy(bool set)\n        {\n            var registry = Registry.CurrentUser\n                .OpenSubKey(@"Software\Microsoft\Windows\CurrentVersion\Internet Settings\Connections", true);\n            var defConnection = (byte[])registry.GetValue("DefaultConnectionSettings");\n            var savedLegacySetting = (byte[])registry.GetValue("SavedLegacySettings");\n            if (set)\n            {
            var savedLegacySetting = (byte[])registry.GetValue("SavedLegacySettings");\n            if (set)\n            {\n                defConnection[8] = (byte)(defConnection[8] | 8);\n                savedLegacySetting[8] = (byte)(savedLegacySetting[8] | 8);\n            }\n            else\n            {
            if (set)\n            {\n                defConnection[8] = (byte)(defConnection[8] | 8);\n                savedLegacySetting[8] = (byte)(savedLegacySetting[8] | 8);\n            }\n            else\n            {\n                defConnection[8] = (byte)(defConnection[8] & ~8);\n                savedLegacySetting[8] = (byte)(savedLegacySetting[8] & ~8);\n            }
using System.Net;\nusing System.Net.NetworkInformation;\nusing System.Net.Sockets;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Shadowsocks.Model;\nusing Shadowsocks.Util;\nnamespace Shadowsocks.Controller\n{
        // Static Singleton Initialization\n        public static AvailabilityStatistics Instance { get; } = new AvailabilityStatistics();
        // Static Singleton Initialization\n        public static AvailabilityStatistics Instance { get; } = new AvailabilityStatistics();\n        private AvailabilityStatistics() { }\n        public const string DateTimePattern = "yyyy-MM-dd HH:mm:ss";\n        private const string StatisticsFilesName = "shadowsocks.availability.csv";\n        private const string Delimiter = ",";\n        private const int TimeoutMilliseconds = 500;\n        private readonly TimeSpan _delayBeforeStart = TimeSpan.FromSeconds(1);\n        public Statistics RawStatistics { get; private set; }\n        public Statistics FilteredStatistics { get; private set; }
        // Static Singleton Initialization\n        public static AvailabilityStatistics Instance { get; } = new AvailabilityStatistics();\n        private AvailabilityStatistics() { }\n        public const string DateTimePattern = "yyyy-MM-dd HH:mm:ss";\n        private const string StatisticsFilesName = "shadowsocks.availability.csv";\n        private const string Delimiter = ",";\n        private const int TimeoutMilliseconds = 500;\n        private readonly TimeSpan _delayBeforeStart = TimeSpan.FromSeconds(1);\n        public Statistics RawStatistics { get; private set; }\n        public Statistics FilteredStatistics { get; private set; }\n        public static readonly DateTime UnknownDateTime = new DateTime(1970, 1, 1);\n        private int Repeat => _config.RepeatTimesNum;
        {\n            AvailabilityStatisticsFile = Utils.GetTempPath(StatisticsFilesName);\n        }\n        public bool Set(StatisticsStrategyConfiguration config)\n        {\n            _config = config;\n            try\n            {\n                if (config.StatisticsEnabled)\n                {
                if (config.StatisticsEnabled)\n                {\n                    if (_timer?.Change(_delayBeforeStart, Interval) == null)\n                    {\n                        _state = new State();\n                        _timer = new Timer(Run, _state, _delayBeforeStart, Interval);\n                    }\n                }\n                else\n                {
            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                return false;\n            }\n        }\n        private void UpdateSpeed(object state)\n        {\n            var bytes = _controller.inboundCounter - _lastInboundCounter;\n            _lastInboundCounter = _controller.inboundCounter;
        }\n        private void UpdateSpeed(object state)\n        {\n            var bytes = _controller.inboundCounter - _lastInboundCounter;\n            _lastInboundCounter = _controller.inboundCounter;\n            var inboundSpeed = GetSpeedInKiBPerSecond(bytes ,_monitorInterval.TotalSeconds);\n            bytes = _controller.outboundCounter - _lastOutboundCounter;\n            _lastOutboundCounter = _controller.outboundCounter;\n            var outboundSpeed = GetSpeedInKiBPerSecond(bytes, _monitorInterval.TotalSeconds);
            var outboundSpeed = GetSpeedInKiBPerSecond(bytes, _monitorInterval.TotalSeconds);\n            if (outboundSpeed > _outboundSpeed)\n            {\n                _outboundSpeed = outboundSpeed;\n            }\n            Logging.Debug($"{_currentServer.FriendlyName()}: current/max inbound {inboundSpeed}/{_inboundSpeed} KiB/s, current/max outbound {outboundSpeed}/{_outboundSpeed} KiB/s");\n        }\n        private async Task<List<DataList>> ICMPTest(Server server)\n        {\n            Logging.Debug("Ping " + server.FriendlyName());\n            if (server.server == "") return null;
            }\n            Logging.Debug($"{_currentServer.FriendlyName()}: current/max inbound {inboundSpeed}/{_inboundSpeed} KiB/s, current/max outbound {outboundSpeed}/{_outboundSpeed} KiB/s");\n        }\n        private async Task<List<DataList>> ICMPTest(Server server)\n        {\n            Logging.Debug("Ping " + server.FriendlyName());\n            if (server.server == "") return null;\n            var ret = new List<DataList>();\n            try {\n                var IP = Dns.GetHostAddresses(server.server).First(ip => (ip.AddressFamily == AddressFamily.InterNetwork || ip.AddressFamily == AddressFamily.InterNetworkV6));\n                var ping = new Ping();
            Logging.Debug("Ping " + server.FriendlyName());\n            if (server.server == "") return null;\n            var ret = new List<DataList>();\n            try {\n                var IP = Dns.GetHostAddresses(server.server).First(ip => (ip.AddressFamily == AddressFamily.InterNetwork || ip.AddressFamily == AddressFamily.InterNetworkV6));\n                var ping = new Ping();\n                foreach (var timestamp in Enumerable.Range(0, Repeat).Select(_ => DateTime.Now.ToString(DateTimePattern)))\n                {\n                    //ICMP echo. we can also set options and special bytes\n                    try\n                    {\n                        var reply = await ping.SendTaskAsync(IP, TimeoutMilliseconds);
                        Logging.LogUsefulException(e);\n                    }\n                }\n            }catch(Exception e)\n            {\n                Logging.Error($"An exception occured while eveluating {server.FriendlyName()}");\n                Logging.LogUsefulException(e);\n            }
            _outboundSpeed = 0;\n        }\n        private void Run(object obj)\n        {\n            if (_speedMonior?.Change(_delayBeforeStart, _monitorInterval) == null)\n            {\n                _speedMonior = new Timer(UpdateSpeed, null, _delayBeforeStart, _monitorInterval);\n            }\n            LoadRawStatistics();\n            FilterRawStatistics();
            }\n            catch (IOException e)\n            {\n                Logging.LogUsefulException(e);\n            }\n        }\n        internal void UpdateConfiguration(ShadowsocksController controller)\n        {\n            _controller = controller;
        private void FilterRawStatistics()\n        {\n            if (RawStatistics == null) return;\n            if (FilteredStatistics == null)\n            {\n                FilteredStatistics = new Statistics();\n            }
                    try {\n                        using (var fs = File.Create(path))\n                        {\n                            //do nothing\n                        }\n                    }catch(Exception e)\n                    {\n                        Logging.LogUsefulException(e);\n                    }
                    }catch(Exception e)\n                    {\n                        Logging.LogUsefulException(e);\n                    }\n                    if (!File.Exists(path)) {\n                        Console.WriteLine($"statistics file does not exist, try to reload {_retryInterval.TotalMinutes} minutes later");\n                        _timer.Change(_retryInterval, Interval);\n                        return;\n                    }\n                }
                                 }).ToDictionary(server => server.ServerName, server => server.data);\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n            }\n        }\n        private DateTime ParseExactOrUnknown(string str)\n        {\n            DateTime dateTime;
        }\n        private DateTime ParseExactOrUnknown(string str)\n        {\n            DateTime dateTime;\n        }\n        public class StatisticsData\n        {\n            public float PackageLoss;\n            public int AverageResponse;\n            public int MinResponse;\n            public int MaxResponse;\n        }\n        public void UpdateLatency(int latency)\n        {
            _controller?.SaveStrategyConfigurations(_configuration);\n            _controller?.UpdateStatisticsConfiguration(StatisticsEnabledCheckBox.Checked);\n            Close();\n        }\n        private void loadChartData()\n        {\n            string serverName = _servers[serverSelector.SelectedIndex];\n            _dataTable.Rows.Clear();\n            //return directly when no data is usable\n            if (_controller.availabilityStatistics?.FilteredStatistics == null) return;
            Close();\n        }\n        private void loadChartData()\n        {\n            string serverName = _servers[serverSelector.SelectedIndex];\n            _dataTable.Rows.Clear();\n            //return directly when no data is usable\n            if (_controller.availabilityStatistics?.FilteredStatistics == null) return;\n            List<AvailabilityStatistics.RawStatisticsData> statistics;\n            if (!_controller.availabilityStatistics.FilteredStatistics.TryGetValue(serverName, out statistics)) return;
using Newtonsoft.Json;\nusing Shadowsocks.Model;\nnamespace Shadowsocks.Controller.Strategy\n{\n    class StatisticsStrategy : IStrategy\n    {\n        private readonly ShadowsocksController _controller;\n        private Server _currentServer;\n        private readonly Timer _timer;
        }\n        private void ReloadStatisticsAndChooseAServer(object obj)\n        {\n            Logging.Debug("Reloading statistics and choose a new server....");\n            var servers = _controller.GetCurrentConfiguration().configs;\n            LoadStatistics();\n            ChooseNewServer(servers);\n        }\n        private void LoadStatistics()\n        {
            ChooseNewServer(servers);\n        }\n        private void LoadStatistics()\n        {\n            _filteredStatistics = _controller.availabilityStatistics.RawStatistics ?? _filteredStatistics ?? new Dictionary<string, List<AvailabilityStatistics.RawStatisticsData>>();\n        }\n        //return the score by data\n        //server with highest score will be choosen\n        private float GetScore(string serverName)\n        {\n            var config = _controller.StatisticsConfiguration;
                MaxResponse = dataList.Max(data => data.RoundtripTime)\n            };\n            float factor;\n            float score = 0;\n            if (!config.Calculations.TryGetValue("PackageLoss", out factor)) factor = 0;
            float factor;\n            float score = 0;\n            if (!config.Calculations.TryGetValue("PackageLoss", out factor)) factor = 0;\n            score += statisticsData.PackageLoss*factor;\n            if (!config.Calculations.TryGetValue("AverageResponse", out factor)) factor = 0;
            if (!config.Calculations.TryGetValue("PackageLoss", out factor)) factor = 0;\n            score += statisticsData.PackageLoss*factor;\n            if (!config.Calculations.TryGetValue("AverageResponse", out factor)) factor = 0;\n            score += statisticsData.AverageResponse*factor;\n            if (!config.Calculations.TryGetValue("MinResponse", out factor)) factor = 0;
            if (!config.Calculations.TryGetValue("PackageLoss", out factor)) factor = 0;\n            score += statisticsData.PackageLoss*factor;\n            if (!config.Calculations.TryGetValue("AverageResponse", out factor)) factor = 0;\n            score += statisticsData.AverageResponse*factor;\n            if (!config.Calculations.TryGetValue("MinResponse", out factor)) factor = 0;\n            score += statisticsData.MinResponse*factor;\n            if (!config.Calculations.TryGetValue("MaxResponse", out factor)) factor = 0;
            this.editPACFileItem = new System.Windows.Forms.MenuItem();\n            this.aboutItem = new System.Windows.Forms.MenuItem();\n            this.menuItem3 = new System.Windows.Forms.MenuItem();\n            this.quitItem = new System.Windows.Forms.MenuItem();\n            this.panel3 = new System.Windows.Forms.Panel();\n            this.DeleteButton = new System.Windows.Forms.Button();\n            this.AddButton = new System.Windows.Forms.Button();\n            this.ServerGroupBox = new System.Windows.Forms.GroupBox();\n            this.ServersListBox = new System.Windows.Forms.ListBox();
            this.tableLayoutPanel1.Controls.Add(this.label1, 0, 0);\n            this.tableLayoutPanel1.Controls.Add(this.label2, 0, 1);\n            this.tableLayoutPanel1.Controls.Add(this.ProxyPortTextBox, 1, 4);\n            this.tableLayoutPanel1.Controls.Add(this.label4, 0, 4);\n            this.tableLayoutPanel1.Controls.Add(this.label3, 0, 2);\n            this.tableLayoutPanel1.Controls.Add(this.IPTextBox, 1, 0);\n            this.tableLayoutPanel1.Controls.Add(this.ServerPortTextBox, 1, 1);\n            this.tableLayoutPanel1.Controls.Add(this.PasswordTextBox, 1, 2);\n            this.tableLayoutPanel1.Controls.Add(this.label5, 0, 3);\n            this.tableLayoutPanel1.Controls.Add(this.EncryptionSelect, 1, 3);
            this.tableLayoutPanel1.Controls.Add(this.label4, 0, 4);\n            this.tableLayoutPanel1.Controls.Add(this.label3, 0, 2);\n            this.tableLayoutPanel1.Controls.Add(this.IPTextBox, 1, 0);\n            this.tableLayoutPanel1.Controls.Add(this.ServerPortTextBox, 1, 1);\n            this.tableLayoutPanel1.Controls.Add(this.PasswordTextBox, 1, 2);\n            this.tableLayoutPanel1.Controls.Add(this.label5, 0, 3);\n            this.tableLayoutPanel1.Controls.Add(this.EncryptionSelect, 1, 3);\n            this.tableLayoutPanel1.Location = new System.Drawing.Point(8, 21);\n            this.tableLayoutPanel1.Margin = new System.Windows.Forms.Padding(5);\n            this.tableLayoutPanel1.Name = "tableLayoutPanel1";
            this.tableLayoutPanel1.RowCount = 6;\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.RemarksTextBox.Location = new System.Drawing.Point(74, 139);\n            this.RemarksTextBox.Name = "RemarksTextBox";
            this.RemarksTextBox.Name = "RemarksTextBox";\n            this.label6.Location = new System.Drawing.Point(19, 142);\n            this.label6.Name = "label6";
            this.label6.Name = "label6";\n            this.label1.Location = new System.Drawing.Point(17, 11);\n            this.label1.Name = "label1";
            this.label1.Name = "label1";\n            this.label2.Location = new System.Drawing.Point(8, 37);\n            this.label2.Name = "label2";
            this.label2.Name = "label2";\n            this.ProxyPortTextBox.Location = new System.Drawing.Point(74, 113);\n            this.ProxyPortTextBox.Name = "ProxyPortTextBox";
            this.ProxyPortTextBox.Name = "ProxyPortTextBox";\n            this.label4.Location = new System.Drawing.Point(13, 116);\n            this.label4.Name = "label4";
            this.label4.Name = "label4";\n            this.label3.Location = new System.Drawing.Point(15, 63);\n            this.label3.Name = "label3";
            this.label3.Name = "label3";\n            this.IPTextBox.Location = new System.Drawing.Point(74, 8);\n            this.IPTextBox.Name = "IPTextBox";
            this.IPTextBox.Name = "IPTextBox";\n            this.ServerPortTextBox.Location = new System.Drawing.Point(74, 34);\n            this.ServerPortTextBox.Name = "ServerPortTextBox";
            this.ServerPortTextBox.Name = "ServerPortTextBox";\n            this.PasswordTextBox.Location = new System.Drawing.Point(74, 60);\n            this.PasswordTextBox.Name = "PasswordTextBox";\n            this.PasswordTextBox.PasswordChar = '*';
            this.label5.Name = "label5";
            this.label5.Name = "label5";\n            this.EncryptionSelect.Location = new System.Drawing.Point(74, 86);\n            this.EncryptionSelect.Name = "EncryptionSelect";
            this.label5.Name = "label5";\n            this.EncryptionSelect.Location = new System.Drawing.Point(74, 86);\n            this.EncryptionSelect.Name = "EncryptionSelect";\n            this.notifyIcon1.Icon = ((System.Drawing.Icon)(resources.GetObject("notifyIcon1.Icon")));\n            this.notifyIcon1.Text = "Shadowsocks";
            this.EncryptionSelect.Name = "EncryptionSelect";\n            this.notifyIcon1.Icon = ((System.Drawing.Icon)(resources.GetObject("notifyIcon1.Icon")));\n            this.notifyIcon1.Text = "Shadowsocks";\n            this.notifyIcon1.Visible = true;\n            this.notifyIcon1.DoubleClick += new System.EventHandler(this.notifyIcon1_DoubleClick);\n            // \n            // panel2\n            // \n            this.panel2.Anchor = System.Windows.Forms.AnchorStyles.Top;\n            this.panel2.AutoSize = true;\n            this.panel2.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;
            // \n            this.panel2.Anchor = System.Windows.Forms.AnchorStyles.Top;\n            this.panel2.AutoSize = true;\n            this.panel2.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;\n            this.panel2.Location = new System.Drawing.Point(164, 175);\n            this.panel2.Name = "panel2";\n            this.panel2.Size = new System.Drawing.Size(0, 0);\n            this.panel2.TabIndex = 1;\n            // \n            // OKButton\n            // \n            this.OKButton.DialogResult = System.Windows.Forms.DialogResult.OK;
            this.OKButton.DialogResult = System.Windows.Forms.DialogResult.OK;\n            this.OKButton.Location = new System.Drawing.Point(4, 4);\n            this.OKButton.Name = "OKButton";
            this.MyCancelButton.Name = "MyCancelButton";
            this.MyCancelButton.Name = "MyCancelButton";\n            this.DeleteButton.Location = new System.Drawing.Point(100, 4);\n            this.DeleteButton.Name = "DeleteButton";
            this.DeleteButton.Name = "DeleteButton";\n            this.AddButton.Location = new System.Drawing.Point(4, 4);\n            this.AddButton.Name = "AddButton";
            this.AddButton.Name = "AddButton";\n            this.ServerGroupBox.Location = new System.Drawing.Point(222, 12);\n            this.ServerGroupBox.Name = "ServerGroupBox";
            this.AddButton.Name = "AddButton";\n            this.ServerGroupBox.Location = new System.Drawing.Point(222, 12);\n            this.ServerGroupBox.Name = "ServerGroupBox";\n            this.ServerGroupBox.Size = new System.Drawing.Size(255, 205);\n            this.ServerGroupBox.TabIndex = 6;\n            this.ServerGroupBox.TabStop = false;\n            this.ServerGroupBox.Text = "Server";\n            // \n            // ServersListBox\n            // \n            this.ServersListBox.FormattingEnabled = true;
        internal string TouchUserRuleFile()\n        {\n            if (!File.Exists(USER_RULE_FILE))\n            {\n                File.WriteAllText(USER_RULE_FILE, Resources.user_rule);\n            }\n            return USER_RULE_FILE;\n        }\n        internal string GetPACContent()\n        {
            if (!File.Exists(USER_RULE_FILE))\n            {\n                File.WriteAllText(USER_RULE_FILE, Resources.user_rule);\n            }\n            return USER_RULE_FILE;\n        }\n        internal string GetPACContent()\n        {\n            if (File.Exists(PAC_FILE))\n            {
                File.WriteAllText(USER_RULE_FILE, Resources.user_rule);\n            }\n            return USER_RULE_FILE;\n        }\n        internal string GetPACContent()\n        {\n            if (File.Exists(PAC_FILE))\n            {\n                return File.ReadAllText(PAC_FILE, Encoding.UTF8);\n            }
            Listener.UDPState udpState = (Listener.UDPState)state;\n            IPEndPoint remoteEndPoint = (IPEndPoint)udpState.remoteEndPoint;\n            UDPHandler handler = _cache.get(remoteEndPoint);\n            if (handler == null)\n            {\n                handler = new UDPHandler(socket, _controller.GetAServer(IStrategyCallerType.UDP, remoteEndPoint, null/*TODO: fix this*/), remoteEndPoint);\n                _cache.add(remoteEndPoint, handler);\n            }\n            handler.Send(firstPacket, length);
                    timeout = timeout.Value,\n                };\n                return true;\n            }\n            if (checkIP == null || checkPort == null || checkTimeout == null)\n            {\n                _modifiedConfiguration.configs.RemoveAt(_lastSelectedIndex);\n                ServersListBox.SelectedIndexChanged -= ServersListBox_SelectedIndexChanged;\n                LoadServerNameListToUI(_modifiedConfiguration);
            UpdateButtons();\n            LoadSelectedServerDetails();\n            _lastSelectedIndex = ServersListBox.SelectedIndex;\n        }\n        private void AddButton_Click(object sender, EventArgs e)\n        {\n            if (ValidateAndSaveSelectedServerDetails(isSave: true))\n            {\n                Configuration.AddDefaultServerOrServer(_modifiedConfiguration);\n                LoadServerNameListToUI(_modifiedConfiguration);
                Configuration.AddDefaultServerOrServer(_modifiedConfiguration);\n                LoadServerNameListToUI(_modifiedConfiguration);\n                UpdateIndexToEnd();\n            }\n        }\n        private void DuplicateButton_Click(object sender, EventArgs e)\n        {\n            if (ValidateAndSaveSelectedServerDetails(isCopy: true))\n            {\n                Server currServer = _modifiedConfiguration.configs[_lastSelectedIndex];
                UpdateIndexToEnd();\n            }\n        }\n        private void DuplicateButton_Click(object sender, EventArgs e)\n        {\n            if (ValidateAndSaveSelectedServerDetails(isCopy: true))\n            {\n                Server currServer = _modifiedConfiguration.configs[_lastSelectedIndex];\n                Configuration.AddDefaultServerOrServer(_modifiedConfiguration, currServer);\n                LoadServerNameListToUI(_modifiedConfiguration);
        }\n        private void MoveDownButton_Click(object sender, EventArgs e)\n        {\n            if (ServersListBox.SelectedIndex < ServersListBox.Items.Count - 1)\n            {\n                MoveConfigItem(+1);  // +1 means move forward\n            }\n        }\n        private void MoveConfigItem(int step)\n        {
            if (ServersListBox.SelectedIndex < ServersListBox.Items.Count - 1)\n            {\n                MoveConfigItem(+1);  // +1 means move forward\n            }\n        }\n        private void MoveConfigItem(int step)\n        {\n            int index = ServersListBox.SelectedIndex;\n            Server server = _modifiedConfiguration.configs[index];\n            object item = ServersListBox.Items[index];\n            _modifiedConfiguration.configs.Remove(server);\n            _modifiedConfiguration.configs.Insert(index + step, server);\n            _modifiedConfiguration.index += step;\n            ServersListBox.BeginUpdate();
                byte[] passbuf = Encoding.UTF8.GetBytes(password);\n                _key = new byte[32];\n                byte[] iv = new byte[16];\n                bytesToKey(passbuf, _key);\n                CachedKeys[k] = _key;\n            }\n        }\n        private void InitCipher(ref byte[] ctx, byte[] iv, bool isCipher)\n        {\n            ctx = new byte[_cipherInfo[3]];
                // PolarSSL takes key length by bit\n                // since we'll use CFB mode, here we both do enc, not dec\n                PolarSSL.aes_setkey_enc(ctx, realkey, keyLen * 8);\n                if (isCipher)\n                {\n                    _encryptIV = new byte[ivLen];\n                    Array.Copy(iv, _encryptIV, ivLen);\n                }\n                else\n                {
                    switch (_cipher)\n                    {\n                        case CIPHER_AES:
                    switch (_cipher)\n                    {\n                        case CIPHER_AES:\n                            PolarSSL.aes_crypt_cfb128(_encryptCtx, PolarSSL.AES_ENCRYPT, length, ref _encryptIVOffset, _encryptIV, buf, tempbuf);\n                            break;\n                        case CIPHER_BF:
                    switch (_cipher)\n                    {\n                        case CIPHER_AES:\n                            PolarSSL.aes_crypt_cfb128(_encryptCtx, PolarSSL.AES_ENCRYPT, length, ref _encryptIVOffset, _encryptIV, buf, tempbuf);\n                            break;\n                        case CIPHER_BF:\n                            PolarSSL.blowfish_crypt_cfb64(_encryptCtx, PolarSSL.BLOWFISH_ENCRYPT, length, ref _encryptIVOffset, _encryptIV, buf, tempbuf);\n                            break;\n                        case CIPHER_RC4:
                    switch (_cipher)\n                    {\n                        case CIPHER_AES:
                    switch (_cipher)\n                    {\n                        case CIPHER_AES:\n                            PolarSSL.aes_crypt_cfb128(_decryptCtx, PolarSSL.AES_DECRYPT, length - ivLen, ref _decryptIVOffset, _decryptIV, tempbuf, outbuf);\n                            break;\n                        case CIPHER_BF:
                    switch (_cipher)\n                    {\n                        case CIPHER_AES:\n                            PolarSSL.aes_crypt_cfb128(_decryptCtx, PolarSSL.AES_DECRYPT, length - ivLen, ref _decryptIVOffset, _decryptIV, tempbuf, outbuf);\n                            break;\n                        case CIPHER_BF:\n                            PolarSSL.blowfish_crypt_cfb64(_decryptCtx, PolarSSL.BLOWFISH_DECRYPT, length - ivLen, ref _decryptIVOffset, _decryptIV, tempbuf, outbuf);\n                            break;\n                        case CIPHER_RC4:
        {\n            Dispose(true);\n            GC.SuppressFinalize(this);\n        }\n        ~PolarSSLEncryptor()\n        {\n            Dispose(false);\n        }\n        protected virtual void Dispose(bool disposing)\n        {
        {\n            if (!_disposed)\n            {\n                if (disposing)\n                {\n                }\n                if (_encryptCtx != null)\n                {
                        case CIPHER_BF:\n                            PolarSSL.blowfish_free(_encryptCtx);\n                            break;\n                        case CIPHER_RC4:\n                            PolarSSL.arc4_free(_encryptCtx);\n                            break;\n                    }\n                }\n                if (_decryptCtx != null)\n                {

                string pacContent = $"var __PROXY__ = \"{proxy}\";\n" + _pacDaemon.GetPACContent();\n                //string pacContent = _pacDaemon.GetPACContent().Replace("__PROXY__", proxy);\n                string responseHead = String.Format(@"HTTP/1.1 200 OK\nServer: Shadowsocks\nContent-Type: application/x-ns-proxy-autoconfig
                    fs.Write(buffer, 0, n);\n                }\n            }\n        }\n        public static string NonExclusiveReadAllText(string path)\n        {\n            return NonExclusiveReadAllText(path, Encoding.Default);\n        }\n        public static string NonExclusiveReadAllText(string path, Encoding encoding)\n        {
            }\n        }\n        public static string NonExclusiveReadAllText(string path)\n        {\n            return NonExclusiveReadAllText(path, Encoding.Default);\n        }\n        public static string NonExclusiveReadAllText(string path, Encoding encoding)\n        {\n            using (var fs = new FileStream(path, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))\n            using (var sr = new StreamReader(fs, encoding))\n            {
﻿using System;\nusing System.Collections.Generic;\nusing System.Text;\nnamespace Shadowsocks.Encrypt\n{\n    public class SodiumEncryptor\n        : IVEncryptor, IDisposable\n    {\n        const int CIPHER_SALSA20 = 1;\n        const int CIPHER_CHACHA20 = 2;
        }\n        protected override Dictionary<string, int[]> getCiphers()\n        {\n            return new Dictionary<string, int[]> {\n                {"salsa20", new int[]{32, 8, CIPHER_SALSA20, PolarSSL.AES_CTX_SIZE}},\n                {"chacha20", new int[]{32, 8, CIPHER_CHACHA20, PolarSSL.AES_CTX_SIZE}},\n            }; ;\n        }\n        protected override void cipherUpdate(bool isCipher, int length, byte[] buf, byte[] outbuf)\n        {
﻿using System.Reflection;\nusing System.Runtime.CompilerServices;\nusing System.Runtime.InteropServices;\n// 有关程序集的常规信息通过下列属性集\n// 控制。更改这些属性值可修改\n// 与程序集关联的信息。
﻿using System.Reflection;\nusing System.Runtime.CompilerServices;\nusing System.Runtime.InteropServices;\n// 有关程序集的常规信息通过下列属性集\n// 控制。更改这些属性值可修改\n// 与程序集关联的信息。\n[assembly: AssemblyTitle("shadowsocks-csharp")]\n[assembly: AssemblyDescription("")]\n[assembly: AssemblyConfiguration("")]\n[assembly: AssemblyCompany("clowwindy")]

namespace shadowsocks_csharp\n{\n    static class Program\n    {\n        /// <summary>\n        /// 应用程序的主入口点。\n        /// </summary>\n        [STAThread]\n        static void Main()\n        {\n            try
                        continue; /*ignore white list*/\n                    domains.Add(line);\n                }\n                return domains.ToArray();\n            }\n            /* refer https://github.com/clowwindy/gfwlist2pac/blob/master/gfwlist2pac/main.py */\n            public string[] GetReducedDomains()\n            {\n                string[] domains = GetDomains();\n                List<string> new_domains = new List<string>(domains.Length);
            {\n                string[] domains = GetDomains();\n                List<string> new_domains = new List<string>(domains.Length);\n                IDictionary<string, string> tld_dic = GetTldDictionary();\n                foreach(string domain in domains)\n                {\n                    string last_root_domain = null;\n                    int pos;\n                    pos = domain.LastIndexOf('.');\n                    last_root_domain = domain.Substring(pos + 1);
                        while ((n = input.Read(buffer, 0, buffer.Length)) > 0)\n                        {\n                            sb.Write(buffer, 0, n);\n                        }\n                    }\n                    tlds = System.Text.Encoding.UTF8.GetString(sb.ToArray())\n                        .Split(new char[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);\n                }\n                return tlds;\n            }
                        }\n                    }\n                    tlds = System.Text.Encoding.UTF8.GetString(sb.ToArray())\n                        .Split(new char[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);\n                }\n                return tlds;\n            }\n            private IDictionary<string, string> GetTldDictionary()\n            {\n                string[] tlds = GetTlds();
                        .Split(new char[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);\n                }\n                return tlds;\n            }\n            private IDictionary<string, string> GetTldDictionary()\n            {\n                string[] tlds = GetTlds();\n                IDictionary<string, string> dic = new Dictionary<string, string>(tlds.Length);\n                foreach (string tld in tlds)\n                {
            }\n            private IDictionary<string, string> GetTldDictionary()\n            {\n                string[] tlds = GetTlds();\n                IDictionary<string, string> dic = new Dictionary<string, string>(tlds.Length);\n                foreach (string tld in tlds)\n                {\n                    if (!dic.ContainsKey(tld))\n                        dic.Add(tld, tld);

                    Console.WriteLine("HA switching to server: {0}", _currentServer.server.FriendlyName());\n                }\n            }\n        }\n        public void UpdateLatency(Model.Server server, TimeSpan latency)\n        {
            Logging.Debug(String.Format("latency: {0} {1}", server.FriendlyName(), latency));\n            ServerStatus status;\n            if (_serverStatus.TryGetValue(server, out status))\n            {\n                status.latency = latency;\n                status.lastTimeDetectLatency = DateTime.Now;\n            }\n        }\n        public void UpdateLastRead(Model.Server server)\n        {
        {\n            Logging.Debug(String.Format("last read: {0}", server.FriendlyName()));\n            ServerStatus status;\n            if (_serverStatus.TryGetValue(server, out status))\n            {\n                status.lastRead = DateTime.Now;\n            }\n        }\n        public void UpdateLastWrite(Model.Server server)\n        {
        {\n            Logging.Debug(String.Format("last write: {0}", server.FriendlyName()));\n            ServerStatus status;\n            if (_serverStatus.TryGetValue(server, out status))\n            {\n                status.lastWrite = DateTime.Now;\n            }\n        }\n        public void SetFailure(Model.Server server)\n        {
        {\n            try\n            {\n                System.IO.FileStream _FileStream =\n                   new System.IO.FileStream(fileName, System.IO.FileMode.Create,\n                                            System.IO.FileAccess.Write);\n                _FileStream.Write(content, 0, content.Length);\n                _FileStream.Close();\n                return true;\n            }
            {\n                System.IO.FileStream _FileStream =\n                   new System.IO.FileStream(fileName, System.IO.FileMode.Create,\n                                            System.IO.FileAccess.Write);\n                _FileStream.Write(content, 0, content.Length);\n                _FileStream.Close();\n                return true;\n            }\n            catch (Exception _Exception)\n            {
                Console.WriteLine(e.ToString());\n                return false;\n            }\n        }\n        public static void Debug(object o)\n        {\n#if DEBUG
    public partial class LogForm : Form\n    {\n        long lastOffset;\n        string filename;\n        Timer timer;\n        const int BACK_OFFSET = 65536;\n        ShadowsocksController controller;\n        #region chart\n        long lastMaxSpeed;
            LogMessageTextBox.Font = config.GetFont();\n            controller.TrafficChanged += controller_TrafficChanged;\n            UpdateTexts();\n        }\n        private void update_TrafficChart()\n        {\n            List<float> inboundPoints = new List<float>();\n            List<float> outboundPoints = new List<float>();\n            TextAnnotation inboundAnnotation = new TextAnnotation();\n            TextAnnotation outboundAnnotation = new TextAnnotation();
            Tuple<float, string, long> bandwidthScale;\n            const long minScale = 50;\n            long maxSpeed = 0;\n            long lastInbound, lastOutbound;\n            lock (this)\n            {\n                if (traffic.Count == 0)\n                    return;\n                foreach (var trafficPerSecond in traffic)\n                {
                lastMaxSpeed -= lastMaxSpeed / 32;\n                maxSpeed = Math.Max(minScale, Math.Max(maxSpeed, lastMaxSpeed));\n                lastMaxSpeed = maxSpeed;\n            }\n            else\n            {\n                maxSpeed = lastMaxSpeed = minScale;\n            }\n            bandwidthScale = Utils.GetBandwidthScale(maxSpeed);\n            //rescale the original data points, since it is List<float>, .ForEach does not work
                maxSpeed = lastMaxSpeed = minScale;\n            }\n            bandwidthScale = Utils.GetBandwidthScale(maxSpeed);\n            //rescale the original data points, since it is List<float>, .ForEach does not work\n            inboundPoints = inboundPoints.Select(p => p / bandwidthScale.Item3).ToList();\n            outboundPoints = outboundPoints.Select(p => p / bandwidthScale.Item3).ToList();\n            if (trafficChart.IsHandleCreated)\n            {\n                trafficChart.Series["Inbound"].Points.DataBindY(inboundPoints);\n                trafficChart.Series["Outbound"].Points.DataBindY(outboundPoints);
                outboundAnnotation.Text = Utils.FormatBandwidth(lastOutbound);\n                trafficChart.Annotations.Clear();\n                trafficChart.Annotations.Add(inboundAnnotation);\n                trafficChart.Annotations.Add(outboundAnnotation);\n            }\n        }\n        private void controller_TrafficChanged(object sender, EventArgs e)\n        {\n            lock (this)\n            {
                trafficChart.Annotations.Add(outboundAnnotation);\n            }\n        }\n        private void controller_TrafficChanged(object sender, EventArgs e)\n        {\n            lock (this)\n            {\n                traffic = new ShadowsocksController.QueueLast<Tuple<long, long>>();\n                foreach (var trafficPerSecond in controller.traffic)\n                {
                    {\n                        sb.Write(buffer, 0, n);\n                    }\n                }\n                return System.Text.Encoding.UTF8.GetString(sb.ToArray());\n            }\n        }\n        public static string FormatBandwidth(long n)\n        {\n            var result = GetBandwidthScale(n);
                return System.Text.Encoding.UTF8.GetString(sb.ToArray());\n            }\n        }\n        public static string FormatBandwidth(long n)\n        {\n            var result = GetBandwidthScale(n);\n                return (bytes / (double)K).ToString("F1") + "KB";\n            }\n            return bytes.ToString();\n        }\n        /// <summary>\n        /// Return scaled bandwidth\n        /// </summary>\n        /// <param name="n">Raw bandwidth</param>\n        /// <returns>
﻿using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Timers;\nusing Shadowsocks.Controller.Strategy;\nusing Shadowsocks.Encryption;
﻿using System;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Text;\nusing System.Threading;\nusing Shadowsocks.Controller;\nusing Shadowsocks.Util.Sockets;
﻿using System;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Text;\nusing System.Threading;\nusing Shadowsocks.Controller;\nusing Shadowsocks.Util.Sockets;\nnamespace Shadowsocks.ForwardProxy\n{
﻿using System;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Threading;\nusing Shadowsocks.Controller;\nusing Shadowsocks.Util.Sockets;
﻿using System;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Threading;\nusing Shadowsocks.Controller;\nusing Shadowsocks.Util.Sockets;\nnamespace Shadowsocks.ForwardProxy\n{
﻿using System;\nusing System.Net;\nusing System.Net.Sockets;
﻿using System;\nusing System.Net;\nusing System.Net.Sockets;\nnamespace Shadowsocks.ForwardProxy\n{
﻿using System;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Threading;\nusing Shadowsocks.Util.Sockets;
﻿using System;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Threading;\nusing Shadowsocks.Util.Sockets;\nnamespace Shadowsocks.ForwardProxy\n{
using System.Text.RegularExpressions;\nusing SimpleJson;\nnamespace Shadowsocks.Controller\n{\n    public class UpdateChecker\n    {\n        private const string UpdateURL = "https://api.github.com/repos/shadowsocks/shadowsocks-windows/releases";\n        public string LatestVersionNumber;\n        public string LatestVersionURL;
                    }\n                    foreach (JsonObject asset in (JsonArray)release["assets"])\n                    {\n                        string url = (string)asset["browser_download_url"];\n                        if (IsNewVersion(url))\n                        {\n                            versions.Add(url);\n                        }\n                    }\n                }
                    {\n                        string url = (string)asset["browser_download_url"];\n                        if (IsNewVersion(url))\n                        {\n                            versions.Add(url);\n                        }\n                    }\n                }\n                if (versions.Count == 0)\n                {
                        {\n                            versions.Add(url);\n                        }\n                    }\n                }\n                if (versions.Count == 0)\n                {\n                    return;\n                }
                        }\n                    }\n                }\n                if (versions.Count == 0)\n                {\n                    return;\n                }\n                // sort versions\n                SortVersions(versions);\n                LatestVersionURL = versions[versions.Count - 1];\n                LatestVersionNumber = ParseVersionFromURL(LatestVersionURL);\n                if (NewVersionFound != null)\n                {
            controller.EnableGlobalChanged += controller_EnableGlobalChanged;\n            controller.Errored += controller_Errored;\n            controller.UpdatePACFromGFWListCompleted += controller_UpdatePACFromGFWListCompleted;\n            controller.UpdatePACFromGFWListError += controller_UpdatePACFromGFWListError;\n            _notifyIcon = new NotifyIcon();\n            UpdateTrayIcon();\n            _notifyIcon.Visible = true;\n            _notifyIcon.ContextMenu = contextMenu1;\n            _notifyIcon.MouseDoubleClick += notifyIcon1_DoubleClick;\n            this.updateChecker = new UpdateChecker();
            controller.UpdatePACFromGFWListCompleted += controller_UpdatePACFromGFWListCompleted;\n            controller.UpdatePACFromGFWListError += controller_UpdatePACFromGFWListError;\n            _notifyIcon = new NotifyIcon();\n            UpdateTrayIcon();\n            _notifyIcon.Visible = true;\n            _notifyIcon.ContextMenu = contextMenu1;\n            _notifyIcon.MouseDoubleClick += notifyIcon1_DoubleClick;\n            this.updateChecker = new UpdateChecker();\n            updateChecker.NewVersionFound += updateChecker_NewVersionFound;\n            LoadCurrentConfiguration();
﻿using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Text;
using System.Diagnostics;\nusing System.Text;\nusing Cyotek.Collections.Generic;\nusing Shadowsocks.Controller;\nnamespace Shadowsocks.Encryption.Stream\n{\n    public abstract class StreamEncryptor\n        : EncryptorBase\n    {\n        // for UDP only\n        protected static byte[] _udpTmpBuf = new byte[65536];\n        // every connection should create its own buffer
        }\n        private void UnregHotkey(TextBox tb)\n        {\n            HotKeys.HotKeyCallBackHandler callBack;\n            Label lb;\n            PrepareForHotkey(tb, out callBack, out lb);\n            UnregPrevHotkey(callBack);\n        }\n        private void CancelButton_Click(object sender, EventArgs e)\n        {
            Label lb;\n            PrepareForHotkey(tb, out callBack, out lb);\n            UnregPrevHotkey(callBack);\n        }\n        private void CancelButton_Click(object sender, EventArgs e)\n        {\n            Close();\n        }\n        private void OKButton_Click(object sender, EventArgs e)\n        {\n            // try to register, notify to change settings if failed
        private void OKButton_Click(object sender, EventArgs e)\n        {\n            // try to register, notify to change settings if failed\n                {\n                    continue;\n                }\n                if (!TryRegHotkey(tb))\n                {\n                    MessageBox.Show(I18N.GetString("Register hotkey failed"));\n                    return;\n                }\n            }\n            // All check passed, saving\n            SaveConfig();
            foreach (var tb in _allTextBoxes)\n            {\n                if (tb.Text.IsNullOrEmpty())\n                {\n                    continue;\n                }
            UnregPrevHotkey(callBack);\n            // try to register keys\n            // if already registered by other progs\n            // notify to change\n            // use the corresponding label color to indicate\n            // reg result.\n            // Green: not occupied by others and operation succeed\n            // Yellow: already registered by other program and need action: disable by clear the content\n            //         or change to another one\n            // Transparent without color: first run or empty config
            // Transparent without color: first run or empty config\n            bool regResult = HotKeys.Regist(hotkey, callBack);\n            lb.BackColor = regResult ? Color.Green : Color.Yellow;\n            return regResult;\n        }\n        private static void UnregPrevHotkey(HotKeys.HotKeyCallBackHandler cb)\n        {\n            GlobalHotKey.HotKey prevHotKey;\n            if (HotKeys.IsCallbackExists(cb, out prevHotKey))\n            {\n                // unregister previous one
        {\n            GlobalHotKey.HotKey prevHotKey;\n            if (HotKeys.IsCallbackExists(cb, out prevHotKey))\n            {\n                // unregister previous one\n                HotKeys.UnRegist(prevHotKey);\n            }\n        }\n        private void SaveConfig()\n        {
        }\n        private void ChangeFontButton_Click(object sender, EventArgs e)\n        {\n            DoChangeFont();\n        }\n        #endregion\n        #region Trigger the log messages wrapable, or not.\n        private bool ShowToolbarTrigger = false;\n        private void ShowToolbarMenuItem_Click(object sender, EventArgs e)\n        {
        {\n            // time interval between SYN and SYN+ACK\n            public TimeSpan latency;\n            // last time anything received\n            public DateTime lastRead;\n            // last time anything sent\n            public DateTime lastWrite;\n            // connection refused or closed before anything received\n            public DateTime lastFailure;\n            public Server server;\n        }
                    status.server = server;\n                    newServerStatus[server] = status;\n                }\n            }\n            _serverStatus = newServerStatus;
﻿using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Reflection;\nusing Shadowsocks.Controller;
        }\n        public Server()\n        {\n            server = "";\n            server_port = 8388;\n            method = "aes-256-cfb";\n            password = "";\n            remarks = "";\n            timeout = DefaultServerTimeoutSec;\n        }
        {\n            server = "";\n            server_port = 8388;\n            method = "aes-256-cfb";\n            password = "";\n            remarks = "";\n            timeout = DefaultServerTimeoutSec;\n        }\n        public Server(string ssURL) : this()\n        {
            }\n            for (int i = 1; i < 1024; i++)\n            {\n                encryptTable = mergeSort(encryptTable, a, i);\n            }\n            for (int i = 0; i < 256; i++)\n            {\n                decryptTable[encryptTable[i]] = (byte)i;\n            }\n        }
            {\n                encryptTable = mergeSort(encryptTable, a, i);\n            }\n            for (int i = 0; i < 256; i++)\n            {\n                decryptTable[encryptTable[i]] = (byte)i;\n            }\n        }\n        public void Encrypt(byte[] buf)\n        {
                decryptTable[encryptTable[i]] = (byte)i;\n            }\n        }\n        public void Encrypt(byte[] buf)\n        {\n            for (int i = 0; i < buf.Length; i++)\n            {\n                buf[i] = encryptTable[buf[i]];\n            }\n        }
        }\n        public void Encrypt(byte[] buf)\n        {\n            for (int i = 0; i < buf.Length; i++)\n            {\n                buf[i] = encryptTable[buf[i]];\n            }\n        }\n        public void Decrypt(byte[] buf)\n        {
﻿using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;
using System.Linq;\nusing System.Net;\nusing System.Text;\nusing Shadowsocks.Model;\nusing System.IO;\nusing System.Net.NetworkInformation;\nusing System.Threading;\nnamespace Shadowsocks.Controller.Strategy\n{\n    class SimplyChooseByStatisticsStrategy : IStrategy\n    {
using System.IO;\nusing System.Net.NetworkInformation;\nusing System.Threading;\nnamespace Shadowsocks.Controller.Strategy\n{\n    class SimplyChooseByStatisticsStrategy : IStrategy\n    {\n        private ShadowsocksController _controller;\n        private Server _currentServer;
        private ShadowsocksController _controller;\n        private Server _currentServer;\n        private Timer timer;\n        private Dictionary<string, StatisticsData> statistics;\n        private static readonly int CachedInterval = 30 * 60 * 1000; //choose a new server every 30 minutes\n        public SimplyChooseByStatisticsStrategy(ShadowsocksController controller)\n        {\n            _controller = controller;\n            var servers = controller.GetCurrentConfiguration().configs;
        {\n            _controller = controller;\n            var servers = controller.GetCurrentConfiguration().configs;\n            int randomIndex = new Random().Next() % servers.Count();\n            _currentServer = servers[randomIndex];  //choose a server randomly at first
        private class StatisticsData\n        {\n            public int SuccessTimes;\n            public int TimedOutTimes;\n            public int AverageResponse;\n            public int MinResponse;\n            public int MaxResponse;\n        }\n        private void ChooseNewServer(List<Server> servers)\n        {
            public int SuccessTimes;\n            public int TimedOutTimes;\n            public int AverageResponse;\n            public int MinResponse;\n            public int MaxResponse;\n        }\n        private void ChooseNewServer(List<Server> servers)\n        {\n                if (_controller.GetCurrentStrategy().ID == ID && _currentServer != bestResult.server) //output when enabled\n                {  
                {  \n                    Console.WriteLine("Switch to server: {0} by package loss:{1}", bestResult.server.FriendlyName(), 1 - bestResult.score);\n                }\n                _currentServer = bestResult.server;\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n            }\n        }
                }\n                _currentServer = bestResult.server;\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n            }\n        }\n        public string ID\n        {
            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n            }\n        }\n        public string ID\n        {\n            get { return "com.shadowsocks.strategy.scbs"; }\n        }
        }\n        {\n            get { return I18N.GetString("Choose By Total Package Loss"); }\n        }\n        public Server GetAServer(IStrategyCallerType type, IPEndPoint localIPEndPoint)\n        {\n            var oldServer = _currentServer;\n            if (oldServer == null)\n            {\n                ChooseNewServer(_controller.GetCurrentConfiguration().configs);\n            }
            }\n            return _currentServer;  //current server cached for CachedInterval\n        }\n        public void ReloadServers()\n        {\n            ChooseNewServer(_controller.GetCurrentConfiguration().configs);
            Utils.ReleaseMemory(true);\n        }\n        void configForm_FormClosed(object sender, FormClosedEventArgs e)\n        {\n            configForm.Dispose();\n            configForm = null;\n            Utils.ReleaseMemory(true);\n            if (_isFirstRun)\n            {\n                CheckUpdateForFirstRun();
                HotKeys.Init();\n                _controller.Start();\n                Application.Run();\n            }\n        }\n        private static int exited = 0;\n        private static void CurrentDomain_UnhandledException(object sender, UnhandledExceptionEventArgs e)\n        {\n            if (Interlocked.Increment(ref exited) == 1)\n            {
                Logging.Error(e.ExceptionObject?.ToString());\n                MessageBox.Show(
        public static RegistryKey OpenUserRegKey( string name, bool writable ) {\n            // we are building x86 binary for both x86 and x64, which will\n            // cause problem when opening registry key\n            // detect operating system instead of CPU

﻿using System.Windows.Forms;\nusing Microsoft.Win32;\nusing System;\nusing System.Runtime.InteropServices;\nusing System.IO;\nusing Shadowsocks.Model;
using Microsoft.Win32;\nusing System;\nusing System.Runtime.InteropServices;\nusing System.IO;\nusing Shadowsocks.Model;\nusing Shadowsocks.Util;\nnamespace Shadowsocks.Controller\n{\n    public static class SystemProxy\n    {
            return value.ToString("yyyyMMddHHmmssfff");\n        }\n        public static void Update(Configuration config, bool forceDisable)\n        {\n            bool global = config.global;\n            bool enabled = config.enabled;\n            if (forceDisable)\n            {\n                enabled = false;\n            }
        {\n            bool global = config.global;\n            bool enabled = config.enabled;\n            if (forceDisable)\n            {\n                enabled = false;\n            }\n            RegistryKey registry = null;\n            try {\n                registry = Utils.OpenUserRegKey( @"Software\Microsoft\Windows\CurrentVersion\Internet Settings", true );\n                if ( registry == null ) {\n                    Logging.Error( @"Cannot find HKCU\Software\Microsoft\Windows\CurrentVersion\Internet Settings" );\n                    return;\n                }
                MessageBox.Show( I18N.GetString( "Failed to update registry" ) );\n            } finally {\n                if ( registry != null ) {\n                    try {\n                        registry.Close();\n                        registry.Dispose();\n                    } catch (Exception e)\n                    { Logging.LogUsefulException(e); }\n                }\n            }
            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                // TODO this should be moved into views\n                MessageBox.Show(I18N.GetString("Failed to update registry"));\n            }\n        }\n        private static void CopyProxySettingFromLan()\n        {
            }\n        }\n        private static void CopyProxySettingFromLan()\n        {\n            RegistryKey registry =\n                Registry.CurrentUser.OpenSubKey("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Connections",\n                    true);\n            var defaultValue = registry.GetValue("DefaultConnectionSettings");\n            try\n            {\n                var connections = registry.GetValueNames();
                var connections = registry.GetValueNames();\n                foreach (String each in connections)\n                {\n                    if (!(each.Equals("DefaultConnectionSettings")\n                        || each.Equals("LAN Connection")\n                        || each.Equals("SavedLegacySettings")))\n                    {\n                        //set all the connections's proxy as the lan\n                        registry.SetValue(each, defaultValue);\n                    }\n                }
                        || each.Equals("SavedLegacySettings")))\n                    {\n                        //set all the connections's proxy as the lan\n                        registry.SetValue(each, defaultValue);\n                    }\n                }\n                SystemProxy.NotifyIE();\n            } catch (IOException e) {\n                Logging.LogUsefulException(e);\n            }
                    }\n                }\n                SystemProxy.NotifyIE();\n            } catch (IOException e) {\n                Logging.LogUsefulException(e);\n            }\n        }\n        private static String GetTimestamp(DateTime value)\n        {\n            return value.ToString("yyyyMMddHHmmssffff");\n        }\n        /// <summary>\n        /// Checks or unchecks the IE Options Connection setting of "Automatically detect Proxy"\n        /// </summary>\n        /// <param name="set">Provide 'true' if you want to check the 'Automatically detect Proxy' check box. To uncheck, pass 'false'</param>\n        private static void IEAutoDetectProxy(bool set)\n        {
                Logging.LogUsefulException(e);\n            }\n        private static String GetTimestamp(DateTime value)\n        {\n            return value.ToString("yyyyMMddHHmmssffff");\n        /// <summary>\n        /// Checks or unchecks the IE Options Connection setting of "Automatically detect Proxy"\n        /// </summary>\n        /// <param name="set">Provide 'true' if you want to check the 'Automatically detect Proxy' check box. To uncheck, pass 'false'</param>\n        private static void IEAutoDetectProxy(bool set)\n        {\n            RegistryKey registry =\n                Registry.CurrentUser.OpenSubKey("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Connections",\n                    true);\n            byte[] defConnection = (byte[])registry.GetValue("DefaultConnectionSettings");\n            byte[] savedLegacySetting = (byte[])registry.GetValue("SavedLegacySettings");\n            if (set)\n            {
        {\n                    true);\n            byte[] defConnection = (byte[])registry.GetValue("DefaultConnectionSettings");\n            byte[] savedLegacySetting = (byte[])registry.GetValue("SavedLegacySettings");\n            if (set)\n            {\n                defConnection[8] = Convert.ToByte(defConnection[8] & 8);\n                savedLegacySetting[8] = Convert.ToByte(savedLegacySetting[8] & 8);\n            }\n            else\n            {
using System.IO;\nusing System.IO.Compression;\nnamespace Shadowsocks.Controller\n{\n    public class FileManager\n    {\n        public static bool ByteArrayToFile(string fileName, byte[] content)\n        {\n            try\n            {
    public class FileManager\n    {\n        public static bool ByteArrayToFile(string fileName, byte[] content)\n        {\n            try\n            {\n                FileStream _FileStream = new FileStream(fileName, FileMode.Create, FileAccess.Write);\n                _FileStream.Write(content, 0, content.Length);\n                _FileStream.Close();\n                return true;\n            }
        {\n            try\n            {\n                FileStream _FileStream = new FileStream(fileName, FileMode.Create, FileAccess.Write);\n                _FileStream.Write(content, 0, content.Length);\n                _FileStream.Close();\n                return true;\n            }\n            catch (Exception _Exception)\n            {\n                Console.WriteLine("Exception caught in process: {0}",
            }\n            catch (Exception _Exception)\n            {\n                Console.WriteLine("Exception caught in process: {0}",\n                                  _Exception.ToString());\n            }\n            return false;\n        }\n        public static void UncompressFile(string fileName, byte[] content)\n        {
                Console.WriteLine("Exception caught in process: {0}",\n                                  _Exception.ToString());\n            }\n            return false;\n        }\n        public static void UncompressFile(string fileName, byte[] content)\n        {\n            FileStream destinationFile = File.Create(fileName);\n            // Because the uncompressed size of the file is unknown,\n            // we are using an arbitrary buffer size.\n            byte[] buffer = new byte[4096];\n            int n;
        {\n            FileStream destinationFile = File.Create(fileName);\n            // Because the uncompressed size of the file is unknown,\n            // we are using an arbitrary buffer size.\n            byte[] buffer = new byte[4096];\n            int n;\n            using (GZipStream input = new GZipStream(new MemoryStream(content),\n                CompressionMode.Decompress, false))\n            {\n                while ((n = input.Read(buffer, 0, buffer.Length)) > 0)\n                {
            int n;\n            using (GZipStream input = new GZipStream(new MemoryStream(content),\n                CompressionMode.Decompress, false))\n            {\n                while ((n = input.Read(buffer, 0, buffer.Length)) > 0)\n                {\n                    destinationFile.Write(buffer, 0, n);\n                }\n            }
            this.OKButton = new System.Windows.Forms.Button();\n            this.MyCancelButton = new System.Windows.Forms.Button();\n            this.panel1 = new System.Windows.Forms.Panel();\n            this.contextMenu1 = new System.Windows.Forms.ContextMenu();\n            this.enableItem = new System.Windows.Forms.MenuItem();\n            this.configItem = new System.Windows.Forms.MenuItem();\n            this.editPACFileItem = new System.Windows.Forms.MenuItem();\n            this.aboutItem = new System.Windows.Forms.MenuItem();\n            this.menuItem3 = new System.Windows.Forms.MenuItem();\n            this.quitItem = new System.Windows.Forms.MenuItem();
            this.enableItem = new System.Windows.Forms.MenuItem();\n            this.configItem = new System.Windows.Forms.MenuItem();\n            this.editPACFileItem = new System.Windows.Forms.MenuItem();\n            this.aboutItem = new System.Windows.Forms.MenuItem();\n            this.menuItem3 = new System.Windows.Forms.MenuItem();\n            this.quitItem = new System.Windows.Forms.MenuItem();\n            this.tableLayoutPanel2 = new System.Windows.Forms.TableLayoutPanel();\n            this.listView1 = new System.Windows.Forms.ListView();\n            this.tableLayoutPanel3 = new System.Windows.Forms.TableLayoutPanel();\n            this.tableLayoutPanel1.SuspendLayout();\n            this.panel1.SuspendLayout();
            this.aboutItem = new System.Windows.Forms.MenuItem();\n            this.menuItem3 = new System.Windows.Forms.MenuItem();\n            this.quitItem = new System.Windows.Forms.MenuItem();\n            this.tableLayoutPanel2 = new System.Windows.Forms.TableLayoutPanel();\n            this.listView1 = new System.Windows.Forms.ListView();\n            this.tableLayoutPanel3 = new System.Windows.Forms.TableLayoutPanel();\n            this.tableLayoutPanel1.SuspendLayout();\n            this.panel1.SuspendLayout();\n            this.tableLayoutPanel2.SuspendLayout();\n            this.tableLayoutPanel3.SuspendLayout();\n            this.SuspendLayout();\n            // \n            // tableLayoutPanel1\n            // 
            this.panel1.SuspendLayout();\n            this.tableLayoutPanel2.SuspendLayout();\n            this.tableLayoutPanel3.SuspendLayout();\n            this.SuspendLayout();\n            // \n            // tableLayoutPanel1\n            // \n            this.tableLayoutPanel1.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) \n            | System.Windows.Forms.AnchorStyles.Right)));\n            this.tableLayoutPanel1.AutoSize = true;\n            this.tableLayoutPanel1.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;\n            this.tableLayoutPanel1.ColumnCount = 2;\n            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());\n            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());
            // \n            this.tableLayoutPanel1.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) \n            | System.Windows.Forms.AnchorStyles.Right)));\n            this.tableLayoutPanel1.AutoSize = true;\n            this.tableLayoutPanel1.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;\n            this.tableLayoutPanel1.ColumnCount = 2;\n            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());\n            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());\n            this.tableLayoutPanel1.Controls.Add(this.label5, 0, 4);\n            this.tableLayoutPanel1.Controls.Add(this.label1, 0, 0);\n            this.tableLayoutPanel1.Controls.Add(this.label2, 0, 1);
            this.tableLayoutPanel1.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;\n            this.tableLayoutPanel1.ColumnCount = 2;\n            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());\n            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());\n            this.tableLayoutPanel1.Controls.Add(this.label5, 0, 4);\n            this.tableLayoutPanel1.Controls.Add(this.label1, 0, 0);\n            this.tableLayoutPanel1.Controls.Add(this.label2, 0, 1);\n            this.tableLayoutPanel1.Controls.Add(this.EncryptionSelect, 1, 4);\n            this.tableLayoutPanel1.Controls.Add(this.label3, 0, 2);
            this.tableLayoutPanel1.Controls.Add(this.label5, 0, 4);\n            this.tableLayoutPanel1.Controls.Add(this.label1, 0, 0);\n            this.tableLayoutPanel1.Controls.Add(this.label2, 0, 1);\n            this.tableLayoutPanel1.Controls.Add(this.EncryptionSelect, 1, 4);\n            this.tableLayoutPanel1.Controls.Add(this.label3, 0, 2);\n            this.tableLayoutPanel1.Controls.Add(this.label4, 0, 3);\n            this.tableLayoutPanel1.Controls.Add(this.IPTextBox, 1, 0);\n            this.tableLayoutPanel1.Controls.Add(this.ServerPortTextBox, 1, 1);\n            this.tableLayoutPanel1.Controls.Add(this.PasswordTextBox, 1, 2);
            this.tableLayoutPanel1.Name = "tableLayoutPanel1";\n            this.tableLayoutPanel1.Padding = new System.Windows.Forms.Padding(5);\n            this.tableLayoutPanel1.RowCount = 5;\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.panel1.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) \n            | System.Windows.Forms.AnchorStyles.Right)));\n            this.panel1.AutoSize = true;\n            this.panel1.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;\n            this.panel1.Controls.Add(this.MyCancelButton);\n            this.panel1.Controls.Add(this.OKButton);
            this.splitContainer2.Panel2.SuspendLayout();\n            this.splitContainer2.SuspendLayout();\n            ((System.ComponentModel.ISupportInitialize)(this.numericUpDown1)).BeginInit();\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer3)).BeginInit();\n            this.splitContainer3.Panel1.SuspendLayout();\n            this.splitContainer3.Panel2.SuspendLayout();\n            this.splitContainer3.SuspendLayout();\n            this.flowLayoutPanel1.SuspendLayout();\n            this.panel3.SuspendLayout();
            this.splitContainer2.Location = new System.Drawing.Point(0, 0);
            // checkBox2\n            // \n            this.checkBox2.AutoSize = true;

﻿using Shadowsocks.Model;\nusing Shadowsocks.Properties;\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;
﻿using Shadowsocks.Model;\nusing Shadowsocks.Properties;\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.IO.Compression;\nusing System.Text;
using System.IO.Compression;\nusing System.Text;\nusing System.Net.NetworkInformation;\nusing System.Net;\nusing System.Runtime.InteropServices;\nusing Shadowsocks.Util;\nnamespace Shadowsocks.Controller\n{\n    class PolipoRunner\n    {\n        private Process _process;
using Shadowsocks.Util;\nnamespace Shadowsocks.Controller\n{\n    class PolipoRunner\n    {\n        private Process _process;\n        private static string temppath;\n        private int _runningPort;\n        static PolipoRunner()\n        {
    class PolipoRunner\n    {\n        private Process _process;\n        private static string temppath;\n        private int _runningPort;\n        static PolipoRunner()\n        {\n            temppath = Utils.GetTempPath();\n            try\n            {
                    catch (Exception e)\n                    {\n                        Logging.LogUsefulException(e);\n                    }\n                }\n                string polipoConfig = Resources.privoxy_conf;\n                _runningPort = this.GetFreePort();\n                polipoConfig = polipoConfig.Replace("__SOCKS_PORT__", configuration.localPort.ToString());\n                polipoConfig = polipoConfig.Replace("__POLIPO_BIND_PORT__", _runningPort.ToString());\n                polipoConfig = polipoConfig.Replace("__POLIPO_BIND_IP__", configuration.shareOverLan ? "0.0.0.0" : "127.0.0.1");
                        Logging.LogUsefulException(e);\n                    }\n                }\n                string polipoConfig = Resources.privoxy_conf;\n                _runningPort = this.GetFreePort();\n                polipoConfig = polipoConfig.Replace("__SOCKS_PORT__", configuration.localPort.ToString());\n                polipoConfig = polipoConfig.Replace("__POLIPO_BIND_PORT__", _runningPort.ToString());\n                polipoConfig = polipoConfig.Replace("__POLIPO_BIND_IP__", configuration.shareOverLan ? "0.0.0.0" : "127.0.0.1");\n                FileManager.ByteArrayToFile(temppath + "/privoxy.conf", System.Text.Encoding.UTF8.GetBytes(polipoConfig));\n                if (!(temppath.EndsWith("\\") || temppath.EndsWith("/"))) {\n                    temppath = temppath + "\\";\n                }\n                _process = new Process();\n                // Configure the process using the StartInfo properties.

﻿using Shadowsocks.Controller;\nusing Shadowsocks.Properties;\nusing Shadowsocks.Util;

namespace Shadowsocks\n{\n    static class Program\n    {\n        /// <summary>\n        /// 应用程序的主入口点。\n        /// </summary>\n        [STAThread]\n        static void Main()\n        {

﻿using Shadowsocks.Controller;\nusing Shadowsocks.Properties;\nusing Shadowsocks.Util;
using Shadowsocks.Properties;\nusing Shadowsocks.Util;\nusing System.IO;\nusing System.Runtime.InteropServices;\nusing System.Text;\nnamespace Shadowsocks.Encryption\n{\n    public class Sodium\n    {\n        const string DLLNAME = "libsscrypto";\n        static Sodium()\n        {

﻿using Shadowsocks.Controller;\nusing Shadowsocks.Properties;\nusing Shadowsocks.Util;
using Shadowsocks.Properties;\nusing Shadowsocks.Util;\nusing System.IO;\nusing System.Runtime.InteropServices;\nusing System.Text;\nnamespace Shadowsocks.Encryption\n{\n    public class MbedTLS\n    {\n        const string DLLNAME = "libsscrypto";\n        static MbedTLS()\n        {

﻿using Shadowsocks.Util;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Net.Sockets;
using System.Text;\nnamespace Shadowsocks.Controller\n{\n    public class Logging\n    {\n        public static string LogFile;\n        public static bool OpenLogFile()\n        {\n            try\n            {
                UpdatePACFromGFWListCompleted(this, e);\n        }\n        private void pacServer_PACUpdateError(object sender, ErrorEventArgs e)\n        {\n            if (UpdatePACFromGFWListError != null)\n                UpdatePACFromGFWListError(this, e);\n        }\n        private void pacServer_UserRuleFileChanged(object sender, EventArgs e)\n        {\n            // TODO: this is a dirty hack. (from code GListUpdater.http_DownloadStringCompleted())
                UpdatePACFromGFWListError(this, e);\n        }\n        private void pacServer_UserRuleFileChanged(object sender, EventArgs e)\n        {\n            // TODO: this is a dirty hack. (from code GListUpdater.http_DownloadStringCompleted())\n            if (!File.Exists(Utils.GetTempPath() + "\\gfwlist.txt"))\n            {\n                UpdatePACFromGFWList();\n                return;\n            }
﻿using System;\nusing System.Collections.Generic;\nusing System.Text;
﻿using System;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.Net;\nusing System.IO;\nusing Shadowsocks.Properties;
﻿using System;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.Net;\nusing System.IO;\nusing Shadowsocks.Properties;\nusing SimpleJson;\nusing Shadowsocks.Util;
﻿using System;
﻿using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Net;
﻿using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Net;\nusing System.Reflection;\nusing System.Text;\nusing System.Text.RegularExpressions;
using System.Runtime.InteropServices;\nusing System.Windows.Forms;\nusing Shadowsocks.Controller;\nnamespace Shadowsocks.Util\n{\n    public class Utils\n    {\n        // return path to store temporary files\n        public static string GetTempPath()\n        {
using Shadowsocks.Controller;\nnamespace Shadowsocks.Util\n{\n    public class Utils\n    {\n        // return path to store temporary files\n        public static string GetTempPath()\n        {\n            if (File.Exists(Application.StartupPath + "\\shadowsocks_portable_mode.txt"))\n            {
                {\n                    Directory.CreateDirectory(Application.StartupPath + "\\temp");\n                }\n                catch (Exception e)\n                {\n                    Logging.LogUsefulException(e);\n                }\n                // don't use "/", it will fail when we call explorer /select xxx/temp\xxx.log\n                return Application.StartupPath + "\\temp";\n            }
        }\n        public void UpdateLatency(Server server, TimeSpan latency)\n        {\n            if (_config.availabilityStatistics)\n            {\n                availabilityStatistics.UpdateLatency(server, (int)latency.TotalMilliseconds);\n            }\n        }\n        public void UpdateInboundCounter(Server server, long n)\n        {
        }\n        public void UpdateInboundCounter(Server server, long n)\n        {\n                current.inboundCounter = inboundCounter;\n                current.outboundCounter = outboundCounter;\n                current.inboundIncreasement = inboundCounter - previous.inboundCounter;\n                current.outboundIncreasement = outboundCounter - previous.outboundCounter;\n                traffic.Enqueue(current);\n                if (traffic.Count > queueMaxSize)\n                    traffic.Dequeue();
                Logging.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void PipeConnectionReceiveCallback(IAsyncResult ar)\n        {\n            if (_closed) return;\n            try\n            {\n                int bytesRead = _connection.EndReceive(ar);
        private void PipeConnectionReceiveCallback(IAsyncResult ar)\n        {\n            if (_closed) return;\n            try\n            {\n                int bytesRead = _connection.EndReceive(ar);\n                _totalWrite += bytesRead;\n                var session = (AsyncSession<bool>) ar.AsyncState;\n                var remote = session.Remote;\n                if (bytesRead > 0)\n                {
        {\n            foreach (var strategy in _strategyManager.GetStrategies())\n            {\n                if (strategy.ID == this._config.strategy)\n                {\n                    return strategy;\n                }\n            }\n            return null;\n        }
                    return strategy;\n                }\n            }\n            return null;\n        }\n        public Server GetAServer(IStrategyCallerType type, IPEndPoint localIPEndPoint)\n        {\n            IStrategy strategy = GetCurrentStrategy();\n            if (strategy != null)\n            {
         * We won't like to kill other ss instances' ss_privoxy.exe.\n         * This function will check whether the given process is created\n         * by this process by checking the module path or command line.\n         * \n         * Since it's required to put ss in different dirs to run muti instances,\n         * different instance will create their unique "privoxy_UID.conf" where\n         * UID is hash of ss's location.\n         */\n        private static bool IsChildProcess(Process process)\n        {
         * different instance will create their unique "privoxy_UID.conf" where\n         * UID is hash of ss's location.\n         */\n        private static bool IsChildProcess(Process process)\n        {\n            if (Utils.IsPortableMode())\n            {\n                /*\n                 * Under PortableMode, we could identify it by the path of ss_privoxy.exe.\n                 */\n                try\n                {\n                    /*
         */\n        private static bool IsChildProcess(Process process)\n        {\n            if (Utils.IsPortableMode())\n            {\n                /*\n                 * Under PortableMode, we could identify it by the path of ss_privoxy.exe.\n                 */\n                try\n                {\n                    /*\n                     * Sometimes Process.GetProcessesByName will return some processes that\n                     * are already dead, and that will cause exceptions here.\n                     * We could simply ignore those exceptions.\n                     */
                /*\n                 * Under PortableMode, we could identify it by the path of ss_privoxy.exe.\n                 */\n                try\n                {\n                    /*\n                     * Sometimes Process.GetProcessesByName will return some processes that\n                     * are already dead, and that will cause exceptions here.\n                     * We could simply ignore those exceptions.\n                     */\n                    string path = process.MainModule.FileName;\n                    return Utils.GetTempPath("ss_privoxy.exe").Equals(path);\n                }
                    string path = process.MainModule.FileName;\n                    return Utils.GetTempPath("ss_privoxy.exe").Equals(path);\n                }\n                    return false;\n                }\n            }\n            else\n            {\n                try\n                {\n                    var cmd = process.GetCommandLine();\n                    return cmd.Contains(UniqueConfigFile);\n                }
            }\n            else\n            {\n                iv = _decryptIV;\n                ivOffset = _decryptIVOffset;\n            }\n            switch (_cipher)\n            {\n                case CIPHER_AES:
        {\n            Assert.IsTrue(UpdateChecker.CompareVersion("2.3.1.0", "2.3.1") == 0);\n            Assert.IsTrue(UpdateChecker.CompareVersion("1.2", "1.3") < 0);\n            Assert.IsTrue(UpdateChecker.CompareVersion("1.3", "1.2") > 0);\n            Assert.IsTrue(UpdateChecker.CompareVersion("1.3", "1.3") == 0);\n            Assert.IsTrue(UpdateChecker.CompareVersion("1.2.1", "1.2") > 0);\n            Assert.IsTrue(UpdateChecker.CompareVersion("2.3.1", "2.4") < 0);\n            Assert.IsTrue(UpdateChecker.CompareVersion("1.3.2", "1.3.1") > 0);\n        }\n        [TestMethod]
            Assert.IsTrue(UpdateChecker.CompareVersion("2.3.1", "2.4") < 0);\n            Assert.IsTrue(UpdateChecker.CompareVersion("1.3.2", "1.3.1") > 0);\n        }\n        [TestMethod]\n        public void TestEncryption()\n        {\n            // run it once before the multi-threading test to initialize global tables\n            RunSingleEncryptionThread();\n            List<Thread> threads = new List<Thread>();\n            for (int i = 0; i < 10; i++)\n            {
            OKButton.Text = I18N.GetString("OK");\n            MyCancelButton.Text = I18N.GetString("Cancel");\n            MoveUpButton.Text = I18N.GetString("Move &Up");\n            MoveDownButton.Text = I18N.GetString("Move D&own");\n            this.Text = I18N.GetString("Edit Servers");\n        }\n        private void controller_ConfigChanged(object sender, EventArgs e)\n        {\n            LoadCurrentConfiguration();\n        }
            LoadCurrentConfiguration();\n        }\n            IPTextBox.Focus();\n        }\n        private bool SaveOldSelectedServer()\n        {\n            try\n            {\n                if (_lastSelectedIndex == -1 || _lastSelectedIndex >= _modifiedConfiguration.configs.Count)\n                {\n                    return true;\n                }
        private bool SaveOldSelectedServer()\n        {\n            try\n            {\n                if (_lastSelectedIndex == -1 || _lastSelectedIndex >= _modifiedConfiguration.configs.Count)\n                {\n                    return true;\n                }\n                server.plugin_args = PluginArgumentsTextBox.Text;\n                server.remarks = RemarksTextBox.Text;\n                if (!int.TryParse(TimeoutTextBox.Text, out server.timeout))\n                {\n                    MessageBox.Show(I18N.GetString("Illegal timeout format"));\n                    TimeoutTextBox.Focus();\n                    return false;\n                }\n                int localPort = int.Parse(ProxyPortTextBox.Text);\n                Configuration.CheckServer(server);
            try\n            {\n                if (_lastSelectedIndex == -1 || _lastSelectedIndex >= _modifiedConfiguration.configs.Count)\n                {\n                    return true;\n                }\n                if (!int.TryParse(TimeoutTextBox.Text, out server.timeout))\n                {\n                    MessageBox.Show(I18N.GetString("Illegal timeout format"));\n                    TimeoutTextBox.Focus();\n                    return false;\n                }\n                int localPort = int.Parse(ProxyPortTextBox.Text);\n                Configuration.CheckServer(server);\n                Configuration.CheckLocalPort(localPort);\n                _modifiedConfiguration.configs[_lastSelectedIndex] = server;
                _modifiedConfiguration.configs[_lastSelectedIndex] = server;\n                _modifiedConfiguration.localPort = localPort;\n                _modifiedConfiguration.portableMode = PortableModeCheckBox.Checked;\n                return true;\n            }\n            catch (Exception ex)\n            {\n                MessageBox.Show(ex.Message);\n            }\n            return false;\n        }
                MessageBox.Show(ex.Message);\n            }\n            return false;\n        }\n        private void LoadSelectedServer()\n        {\n            if (ServersListBox.SelectedIndex >= 0 && ServersListBox.SelectedIndex < _modifiedConfiguration.configs.Count)\n            {\n                Server server = _modifiedConfiguration.configs[ServersListBox.SelectedIndex];
                PluginTextBox.Text = server.plugin;\n                PluginOptionsTextBox.Text = server.plugin_opts;\n                PluginArgumentsTextBox.Text = server.plugin_args;\n                RemarksTextBox.Text = server.remarks;\n                TimeoutTextBox.Text = server.timeout.ToString();\n            }\n        }\n        private void LoadConfiguration(Configuration configuration)\n        {\n            ServersListBox.Items.Clear();
        {\n            ServersListBox.Items.Clear();\n            foreach (Server server in _modifiedConfiguration.configs)\n            {\n                ServersListBox.Items.Add(server.FriendlyName());\n            }\n        }\n        private void LoadCurrentConfiguration()\n        {\n            _modifiedConfiguration = controller.GetConfigurationCopy();
        private void LoadCurrentConfiguration()\n        {\n            _modifiedConfiguration = controller.GetConfigurationCopy();\n            LoadConfiguration(_modifiedConfiguration);\n            _lastSelectedIndex = _modifiedConfiguration.index;\n            if (_lastSelectedIndex < 0 || _lastSelectedIndex >= ServersListBox.Items.Count)\n            {\n                _lastSelectedIndex = 0;\n            }\n            ServersListBox.SelectedIndex = _lastSelectedIndex;
            LoadConfiguration(_modifiedConfiguration);\n            _lastSelectedIndex = _modifiedConfiguration.index;\n            if (_lastSelectedIndex < 0 || _lastSelectedIndex >= ServersListBox.Items.Count)\n            {\n                _lastSelectedIndex = 0;\n            }\n            ServersListBox.SelectedIndex = _lastSelectedIndex;\n            UpdateMoveUpAndDownButton();\n            LoadSelectedServer();\n            PortableModeCheckBox.Checked = _modifiedConfiguration.portableMode;
            UpdateMoveUpAndDownButton();\n            LoadSelectedServer();\n            PortableModeCheckBox.Checked = _modifiedConfiguration.portableMode;\n        }\n        private void ConfigForm_Load(object sender, EventArgs e)\n        {\n        }\n        private void ConfigForm_KeyDown(object sender, KeyEventArgs e)\n        {\n            // Sometimes the users may hit enter key by mistake, and the form will close without saving entries.\n            if (e.KeyCode == Keys.Enter)\n            {\n                Server server = controller.GetCurrentServer();
        {\n            if (!ServersListBox.CanSelect)\n            {\n                return;\n            }\n            if (_lastSelectedIndex == ServersListBox.SelectedIndex)\n            {\n                // we are moving back to oldSelectedIndex or doing a force move\n                return;\n            }
            }\n            if (!SaveOldSelectedServer())\n            {\n                // why this won't cause stack overflow?\n                ServersListBox.SelectedIndex = _lastSelectedIndex;\n                return;\n            }\n            if (_lastSelectedIndex >= 0)\n            {\n                ServersListBox.Items[_lastSelectedIndex] = _modifiedConfiguration.configs[_lastSelectedIndex].FriendlyName();\n            }
            if (_lastSelectedIndex >= 0)\n            {\n                ServersListBox.Items[_lastSelectedIndex] = _modifiedConfiguration.configs[_lastSelectedIndex].FriendlyName();\n            }\n            UpdateMoveUpAndDownButton();\n            LoadSelectedServer();\n            _lastSelectedIndex = ServersListBox.SelectedIndex;\n        }\n        private void AddButton_Click(object sender, EventArgs e)\n        {
            _lastSelectedIndex = ServersListBox.SelectedIndex;\n        }\n        private void AddButton_Click(object sender, EventArgs e)\n        {\n            if (!SaveOldSelectedServer())\n            {\n                return;\n            }\n            Server server = Configuration.GetDefaultServer();\n            _modifiedConfiguration.configs.Add(server);
                return;\n            }\n            Server server = Configuration.GetDefaultServer();\n            _modifiedConfiguration.configs.Add(server);\n            LoadConfiguration(_modifiedConfiguration);\n            ServersListBox.SelectedIndex = _modifiedConfiguration.configs.Count - 1;\n            _lastSelectedIndex = ServersListBox.SelectedIndex;\n        }\n        private void DuplicateButton_Click(object sender, EventArgs e)\n        {
        }\n        private void DuplicateButton_Click(object sender, EventArgs e)\n        {\n            if (!SaveOldSelectedServer())\n            {\n                return;\n            }\n            Server currServer = _modifiedConfiguration.configs[_lastSelectedIndex];\n            var currIndex = _modifiedConfiguration.configs.IndexOf(currServer);\n            _modifiedConfiguration.configs.Insert(currIndex + 1, currServer);
            if (_lastSelectedIndex >= 0 && _lastSelectedIndex < _modifiedConfiguration.configs.Count)\n            {\n                _modifiedConfiguration.configs.RemoveAt(_lastSelectedIndex);\n            }\n            if (_lastSelectedIndex >= _modifiedConfiguration.configs.Count)\n            {\n                // can be -1\n                _lastSelectedIndex = _modifiedConfiguration.configs.Count - 1;\n            }\n            ServersListBox.SelectedIndex = _lastSelectedIndex;
                _modifiedConfiguration.configs.RemoveAt(_lastSelectedIndex);\n            }\n            if (_lastSelectedIndex >= _modifiedConfiguration.configs.Count)\n            {\n                // can be -1\n                _lastSelectedIndex = _modifiedConfiguration.configs.Count - 1;\n            }\n            ServersListBox.SelectedIndex = _lastSelectedIndex;\n            LoadConfiguration(_modifiedConfiguration);\n            ServersListBox.SelectedIndex = _lastSelectedIndex;
                // can be -1\n                _lastSelectedIndex = _modifiedConfiguration.configs.Count - 1;\n            }\n            ServersListBox.SelectedIndex = _lastSelectedIndex;\n            LoadConfiguration(_modifiedConfiguration);\n            ServersListBox.SelectedIndex = _lastSelectedIndex;\n            LoadSelectedServer();\n        }\n        private void OKButton_Click(object sender, EventArgs e)\n        {
            _modifiedConfiguration.configs.Insert(index + step, server);\n            _modifiedConfiguration.index += step;\n            ServersListBox.BeginUpdate();\n            ServersListBox.Enabled = false;\n            _lastSelectedIndex = index + step;\n            ServersListBox.Items.Remove(item);\n            ServersListBox.Items.Insert(index + step, item);\n            ServersListBox.Enabled = true;\n            ServersListBox.SelectedIndex = index + step;\n            ServersListBox.EndUpdate();
            {\n                MoveDownButton.Enabled = false;\n            }\n            else\n            {\n                MoveDownButton.Enabled = true;\n            }\n        }\n        private void MoveUpButton_Click(object sender, EventArgs e)\n        {
﻿using System;\nusing System.Collections.Generic;\nusing System.Runtime.InteropServices;\nusing System.Security.Cryptography;\nusing System.Text;\nusing System.Threading;\nnamespace Shadowsocks.Encrypt\n{\n    public class PolarSSLEncryptor
using System.Security.Cryptography;\nusing System.Text;\nusing System.Threading;\nnamespace Shadowsocks.Encrypt\n{\n    public class PolarSSLEncryptor\n        : EncryptorBase, IDisposable\n    {\n        const int CIPHER_AES = 1;\n        const int CIPHER_RC4 = 2;
namespace Shadowsocks.Encrypt\n{\n    public class PolarSSLEncryptor\n        : EncryptorBase, IDisposable\n    {\n        const int CIPHER_AES = 1;\n        const int CIPHER_RC4 = 2;\n            {"aes-256-cfb", new int[]{32, 16, CIPHER_AES, PolarSSL.AES_CTX_SIZE}},\n            {"rc4", new int[]{16, 0, CIPHER_RC4, PolarSSL.ARC4_CTX_SIZE}},\n            {"rc4-md5", new int[]{16, 16, CIPHER_RC4, PolarSSL.ARC4_CTX_SIZE}},\n        };\n        private static readonly Dictionary<string, byte[]> CachedKeys = new Dictionary<string, byte[]>();\n        private int _cipher;\n        private int[] _cipherInfo;\n        private byte[] _key;\n        private IntPtr _encryptCtx = IntPtr.Zero;\n        private IntPtr _decryptCtx = IntPtr.Zero;
        const int CIPHER_RC4 = 2;\n        private int[] _cipherInfo;\n        private byte[] _key;\n        private IntPtr _encryptCtx = IntPtr.Zero;\n        private IntPtr _decryptCtx = IntPtr.Zero;\n        private int _encryptIVOffset = 0;\n        private int _decryptIVOffset = 0;\n        private string _method;\n        private int keyLen;\n        private int ivLen;\n        public PolarSSLEncryptor(string method, string password)\n            : base(method, password)\n        {\n            InitKey(method, password);\n        }
        private IntPtr _encryptCtx = IntPtr.Zero;\n        private IntPtr _decryptCtx = IntPtr.Zero;\n        private string _method;\n        private int keyLen;\n        private int ivLen;\n        public PolarSSLEncryptor(string method, string password)\n            : base(method, password)\n        {\n            InitKey(method, password);\n        }\n        private static void randBytes(byte[] buf, int length)\n        {
        public PolarSSLEncryptor(string method, string password)\n            : base(method, password)\n        {\n            InitKey(method, password);\n        }\n        private static void randBytes(byte[] buf, int length)\n        {\n            byte[] temp = new byte[length];\n            new Random().NextBytes(temp);\n            temp.CopyTo(buf, 0);\n        }
        {\n            InitKey(method, password);\n        }\n        private static void randBytes(byte[] buf, int length)\n        {\n            byte[] temp = new byte[length];\n            new Random().NextBytes(temp);\n            temp.CopyTo(buf, 0);\n        }\n        private void bytesToKey(byte[] password, byte[] key)\n        {
            new Random().NextBytes(temp);\n            temp.CopyTo(buf, 0);\n        }\n        private void bytesToKey(byte[] password, byte[] key)\n        {\n            byte[] result = new byte[password.Length + 16];\n            int i = 0;\n            byte[] md5sum = null;\n            while (i < key.Length)\n            {
        {\n            byte[] result = new byte[password.Length + 16];\n            int i = 0;\n            byte[] md5sum = null;\n            while (i < key.Length)\n            {\n                throw new Exception("method not found");\n            }\n            keyLen = ciphers[_method][0];\n            ivLen = ciphers[_method][1];\n            if (CachedKeys.ContainsKey(k))\n            {\n                _key = CachedKeys[k];\n            }\n            else\n            {
            int i = 0;\n            byte[] md5sum = null;\n            while (i < key.Length)\n            {\n            keyLen = ciphers[_method][0];\n            ivLen = ciphers[_method][1];\n            if (CachedKeys.ContainsKey(k))\n            {\n                _key = CachedKeys[k];\n            }\n            else\n            {\n                byte[] passbuf = Encoding.UTF8.GetBytes(password);\n                _key = new byte[32];\n                byte[] iv = new byte[16];\n                bytesToKey(passbuf, _key);\n                CachedKeys[k] = _key;\n            }
            else\n            {\n                realkey = _key;\n            }\n            if (_cipher == CIPHER_AES)\n            {\n                PolarSSL.aes_init(ctx);\n                // PolarSSL takes key length by bit\n                // since we'll use CFB mode, here we both do enc, not dec\n                PolarSSL.aes_setkey_enc(ctx, realkey, keyLen * 8);
                // since we'll use CFB mode, here we both do enc, not dec\n                PolarSSL.aes_setkey_enc(ctx, realkey, keyLen * 8);\n                    _decryptIV = new byte[ivLen];\n                    Array.Copy(iv, _decryptIV, ivLen);\n                }\n            }\n            else if (_cipher == CIPHER_RC4)\n            {\n                PolarSSL.arc4_init(ctx);\n                // PolarSSL RC4 takes key length by byte\n                PolarSSL.arc4_setup(ctx, realkey, keyLen);\n            }\n        }
                }\n            }\n            else if (_cipher == CIPHER_RC4)\n            {\n                PolarSSL.arc4_init(ctx);\n                // PolarSSL RC4 takes key length by byte\n                PolarSSL.arc4_setup(ctx, realkey, keyLen);\n            }\n        }\n        static byte[] tempbuf = new byte[32768];\n        public override void Encrypt(byte[] buf, int length, byte[] outbuf, out int outlength)\n        {
                PolarSSL.arc4_init(ctx);\n                // PolarSSL RC4 takes key length by byte\n                PolarSSL.arc4_setup(ctx, realkey, keyLen);\n            }\n        }\n        static byte[] tempbuf = new byte[32768];\n        public override void Encrypt(byte[] buf, int length, byte[] outbuf, out int outlength)\n        {\n            if (_encryptCtx == IntPtr.Zero)\n            {
                        case CIPHER_RC4:\n                            PolarSSL.arc4_crypt(_encryptCtx, length, buf, tempbuf);\n                            break;\n                    }\n                    outlength = length + ivLen;\n                    Buffer.BlockCopy(tempbuf, 0, outbuf, ivLen, length);\n                }\n            }\n            else\n            {
                    }\n                    outlength = length + ivLen;\n                    Buffer.BlockCopy(tempbuf, 0, outbuf, ivLen, length);\n                }\n            }\n            else\n            {\n                switch (_cipher)\n                {\n                    case CIPHER_AES:\n                        PolarSSL.aes_crypt_cfb128(_encryptCtx, PolarSSL.AES_ENCRYPT, length, ref _encryptIVOffset, _encryptIV, buf, outbuf);\n                        break;\n                    case CIPHER_RC4:\n                        PolarSSL.arc4_crypt(_encryptCtx, length, buf, outbuf);\n                        break;\n                }\n            }
                    Buffer.BlockCopy(tempbuf, 0, outbuf, ivLen, length);\n                }\n            }\n            else\n            {\n                    case CIPHER_AES:\n                        PolarSSL.aes_crypt_cfb128(_encryptCtx, PolarSSL.AES_ENCRYPT, length, ref _encryptIVOffset, _encryptIV, buf, outbuf);\n                        break;\n                    case CIPHER_RC4:\n                        PolarSSL.arc4_crypt(_encryptCtx, length, buf, outbuf);\n                        break;\n                }\n            }\n        }\n        public override void Decrypt(byte[] buf, int length, byte[] outbuf, out int outlength)\n        {\n            if (_decryptCtx == IntPtr.Zero)\n            {
            {\n                        PolarSSL.arc4_crypt(_encryptCtx, length, buf, outbuf);\n                        break;\n                }\n            }\n        }\n        public override void Decrypt(byte[] buf, int length, byte[] outbuf, out int outlength)\n        {\n            if (_decryptCtx == IntPtr.Zero)\n            {\n                InitCipher(ref _decryptCtx, buf, false);\n                outlength = length - ivLen;\n                lock (tempbuf)\n                {\n                    // C# could be multi-threaded\n                    Buffer.BlockCopy(buf, ivLen, tempbuf, 0, length - ivLen);\n                    if (_disposed)\n                    {
                }\n            }\n        public override void Decrypt(byte[] buf, int length, byte[] outbuf, out int outlength)\n        {\n            if (_decryptCtx == IntPtr.Zero)\n            {\n                InitCipher(ref _decryptCtx, buf, false);\n                outlength = length - ivLen;\n                lock (tempbuf)\n                {\n                    // C# could be multi-threaded\n                    Buffer.BlockCopy(buf, ivLen, tempbuf, 0, length - ivLen);\n                    if (_disposed)\n                    {\n                        throw new ObjectDisposedException(this.ToString());\n                    }
            if (_decryptCtx == IntPtr.Zero)\n            {\n                lock (tempbuf)\n                {\n                    // C# could be multi-threaded\n                    Buffer.BlockCopy(buf, ivLen, tempbuf, 0, length - ivLen);\n                    if (_disposed)\n                    {\n                        throw new ObjectDisposedException(this.ToString());\n                    }\n                    switch (_cipher)\n                    {
                    // C# could be multi-threaded\n                    Buffer.BlockCopy(buf, ivLen, tempbuf, 0, length - ivLen);\n                    if (_disposed)\n                    {\n                        throw new ObjectDisposedException(this.ToString());\n                    }\n                    switch (_cipher)\n                    {\n                        case CIPHER_AES:\n                            PolarSSL.aes_crypt_cfb128(_decryptCtx, PolarSSL.AES_DECRYPT, length - ivLen, ref _decryptIVOffset, _decryptIV, tempbuf, outbuf);\n                            break;\n                        case CIPHER_RC4:\n                            PolarSSL.arc4_crypt(_decryptCtx, length - ivLen, tempbuf, outbuf);\n                            break;\n                    }
        /// <summary>\n        /// 应用程序的主入口点。\n        /// </summary>\n        [STAThread]\n        static void Main()\n        {\n            try\n            {
        /// </summary>\n        [STAThread]\n        static void Main()\n        {\n            try\n            {\n                string tempPath = Path.GetTempPath();\n                string dllPath = tempPath + "/polarssl.dll";\n                FileManager.UncompressFile(dllPath, Resources.polarssl_dll);
                    new AsyncCallback(receiveCallback), conn);\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine(e.ToString());\n            }\n        }\n        private string getPACContent()\n        {\n            // TODO try pac.txt in current directory
            catch (Exception e)\n            {\n                Console.WriteLine(e.ToString());\n            }\n        }\n        private string getPACContent()\n        {\n            // TODO try pac.txt in current directory\n            byte[] pacGZ = Resources.proxy_pac_txt;\n            byte[] buffer = new byte[1024 * 1024];  // builtin pac gzip size: maximum 1M\n            int n;\n            using (GZipStream input = new GZipStream(new MemoryStream(pacGZ),\n                CompressionMode.Decompress, false))\n            {
            }\n        }\n        private string getPACContent()\n        {\n            // TODO try pac.txt in current directory\n            byte[] pacGZ = Resources.proxy_pac_txt;\n            byte[] buffer = new byte[1024 * 1024];  // builtin pac gzip size: maximum 1M\n            int n;\n            using (GZipStream input = new GZipStream(new MemoryStream(pacGZ),\n                CompressionMode.Decompress, false))\n            {\n                n = input.Read(buffer, 0, buffer.Length);\n                if (n == 0)\n                {
            // TODO try pac.txt in current directory\n            using (GZipStream input = new GZipStream(new MemoryStream(pacGZ),\n                CompressionMode.Decompress, false))\n            {\n                n = input.Read(buffer, 0, buffer.Length);\n                if (n == 0)\n                {\n                    throw new IOException("can not decompress pac");\n                }
        public event EventHandler ConfigChanged;\n        public event EventHandler EnableStatusChanged;\n        // when user clicked Edit PAC, and PAC file has already created\n        public event EventHandler<PathEventArgs> PACFileReadyToOpen;\n        public ShadowsocksController()\n        {\n            config = Config.Load();\n            polipoRunner = new PolipoRunner();\n            polipoRunner.Start(config);\n            local = new Local(config);
            this.enableItem.Click += new System.EventHandler(this.EnableItem_Click);\n            // \n            // configItem\n            // \n            this.configItem.Index = 1;\n            this.configItem.Text = "Options...";\n            this.configItem.Click += new System.EventHandler(this.Config_Click);\n            // \n            // aboutItem\n            // 
    {\n        const int CIPHER_AES = 1;\n        const int CIPHER_RC4 = 2;\n        private IntPtr _encryptCtx = IntPtr.Zero;\n        private IntPtr _decryptCtx = IntPtr.Zero;\n        public PolarSSLEncryptor(string method, string password)\n            : base(method, password)\n        {\n            InitKey(method, password);\n        }
            : base(method, password)\n        {\n            InitKey(method, password);\n        }\n        protected override Dictionary<string, int[]> getCiphers()\n        {\n            return new Dictionary<string, int[]> {\n                {"aes-128-cfb", new int[]{16, 16, CIPHER_AES, PolarSSL.AES_CTX_SIZE}},\n                {"aes-192-cfb", new int[]{24, 16, CIPHER_AES, PolarSSL.AES_CTX_SIZE}},\n                {"aes-256-cfb", new int[]{32, 16, CIPHER_AES, PolarSSL.AES_CTX_SIZE}},\n                {"rc4", new int[]{16, 0, CIPHER_RC4, PolarSSL.ARC4_CTX_SIZE}},\n                {"rc4-md5", new int[]{16, 16, CIPHER_RC4, PolarSSL.ARC4_CTX_SIZE}},
            InitKey(method, password);\n            _encryptBuf = new byte[MAX_INPUT_SIZE + SODIUM_BLOCK_SIZE];\n            _decryptBuf = new byte[MAX_INPUT_SIZE + SODIUM_BLOCK_SIZE];\n        }\n        protected override Dictionary<string, int[]> getCiphers()\n        {
        public static IEncryptor GetEncryptor(string method, string password)\n        {
        public static IEncryptor GetEncryptor(string method, string password)\n        {\n            if (string.IsNullOrEmpty(method) || method.ToLowerInvariant() == "table")\n            {
        public static IEncryptor GetEncryptor(string method, string password)\n        {\n            if (string.IsNullOrEmpty(method) || method.ToLowerInvariant() == "table")\n            {\n                return new TableEncryptor(method, password);\n            }
            this.tableLayoutPanel1.SuspendLayout();\n            this.SuspendLayout();\n            // \n            // flowLayoutPanel1\n            // \n            this.tableLayoutPanel1.SetColumnSpan(flowLayoutPanel1, 2);\n            flowLayoutPanel1.Controls.Add(this.btnOK);\n            flowLayoutPanel1.Controls.Add(this.btnCancel);\n            flowLayoutPanel1.Controls.Add(this.btnRegisterAll);\n            flowLayoutPanel1.FlowDirection = System.Windows.Forms.FlowDirection.BottomUp;
            flowLayoutPanel1.FlowDirection = System.Windows.Forms.FlowDirection.BottomUp;\n            this.btnOK.Location = new System.Drawing.Point(333, 9);\n            this.btnOK.Name = "btnOK";
            this.btnOK.Name = "btnOK";\n            this.btnCancel.Location = new System.Drawing.Point(204, 9);\n            this.btnCancel.Name = "btnCancel";

﻿using System;\nusing System.Collections.Generic;\nusing System.Drawing;
﻿using System;\nusing System.Collections.Generic;\nusing System.Drawing;\nusing System.Linq;\nusing System.Text;\nusing System.Windows.Forms;

﻿using System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.IO;\nnamespace Shadowsocks.Controller\n{
namespace Shadowsocks.Controller\n{\n    using Shadowsocks.Properties;\n    public static class I18N\n    {\n        private static Dictionary<string, string> _strings = new Dictionary<string, string>();
namespace Shadowsocks.Controller\n{\n    using Shadowsocks.Properties;\n    public static class I18N\n    {\n        private static Dictionary<string, string> _strings = new Dictionary<string, string>();\n        private static void Init(string res)\n        {
namespace Shadowsocks.Controller\n{\n    using Shadowsocks.Properties;\n    public static class I18N\n    {\n        private static Dictionary<string, string> _strings = new Dictionary<string, string>();\n        private static void Init(string res)\n        {\n            using (var sr = new StringReader(res))\n            {
    public static class I18N\n    {\n        private static Dictionary<string, string> _strings = new Dictionary<string, string>();\n        private static void Init(string res)\n        {\n            using (var sr = new StringReader(res))\n            {\n                foreach (var line in sr.NonWhiteSpaceLines())\n                {
                foreach (var line in sr.NonWhiteSpaceLines())\n                {\n                        continue;\n                    var pos = line.IndexOf('=');\n                    if (pos < 1)\n                        continue;\n                    _strings[line.Substring(0, pos)] = line.Substring(pos + 1);\n                }\n            }\n        }\n        static I18N()\n        {
using System;\nusing System.Drawing;\nusing System.Windows.Forms;
            PerformLayout();\n            UpdateTexts();\n            SetupValueChangedListeners();\n            Icon = Icon.FromHandle(Resources.ssw128.GetHicon());\n            this.controller = controller;\n            controller.ConfigChanged += Controller_ConfigChanged;\n            LoadCurrentConfiguration();\n        }\n        private void UpdateTexts()\n        {
            SetupValueChangedListeners();\n            Icon = Icon.FromHandle(Resources.ssw128.GetHicon());\n            this.controller = controller;\n            controller.ConfigChanged += Controller_ConfigChanged;\n            LoadCurrentConfiguration();\n        }\n        private void UpdateTexts()\n        {\n            PasswordLabel.Text = I18N.GetString("Password");\n            ShowPasswdCheckBox.Text = I18N.GetString("Show Password");\n            EncryptionLabel.Text = I18N.GetString("Encryption");\n            PluginLabel.Text = I18N.GetString("Plugin Program");\n            PluginOptionsLabel.Text = I18N.GetString("Plugin Options");\n            PluginArgumentsLabel.Text = I18N.GetString("Plugin Arguments");\n            NeedPluginArgCheckBox.Text = I18N.GetString("Need Plugin Argument");\n            ProxyPortLabel.Text = I18N.GetString("Proxy Port");\n            PortableModeCheckBox.Text = I18N.GetString("Portable Mode");\n            toolTip1.SetToolTip(PortableModeCheckBox, I18N.GetString("Restart required"));

﻿using System.Reflection;\nusing Shadowsocks.View;\nnamespace Shadowsocks.Controller.Hotkeys\n{\n    public class HotkeyCallbacks\n    {
﻿using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Net;\nusing System.Text;\nusing Shadowsocks.Model;\nusing System.IO;\nusing System.Net.NetworkInformation;
namespace Shadowsocks.Controller.Strategy\n{\n    class StatisticsStrategy : IStrategy\n    {\n        private readonly ShadowsocksController _controller;\n        private Server _currentServer;\n        private readonly Timer _timer;
            _currentServer = servers[randomIndex];  //choose a server randomly at first\n            _timer = new Timer(ReloadStatisticsAndChooseAServer);\n        }\n        private void ReloadStatisticsAndChooseAServer(object obj)\n        {\n            Logging.Debug("Reloading statistics and choose a new server....");\n            var servers = _controller.GetCurrentConfiguration().configs;\n            LoadStatistics();\n            ChooseNewServer(servers);\n        }
        }\n        }\n        */\n        private void LoadStatistics()\n        {\n            try\n            {\n                var path = AvailabilityStatistics.AvailabilityStatisticsFile;\n                Logging.Debug($"loading statistics from {path}");\n                if (!File.Exists(path))\n                {
            try\n            {\n                var path = AvailabilityStatistics.AvailabilityStatisticsFile;\n                Logging.Debug($"loading statistics from {path}");\n                if (!File.Exists(path))\n                {\n                    LogWhenEnabled($"statistics file does not exist, try to reload {RetryInterval} minutes later");\n                    _timer.Change(RetryInterval, CachedInterval);\n                    return;\n                }
                                          MinResponse = server.Min(data => data.RoundtripTime),\n                                          MaxResponse = server.Max(data => data.RoundtripTime)\n                                      }\n                                  }).ToDictionary(server => server.ServerName, server => server.data);\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n            }\n        }\n        //return the score by data\n        //server with highest score will be choosen
        }\n        //return the score by data\n        //server with highest score will be choosen\n        private static double GetScore(StatisticsData data)\n        {\n            return (double)data.SuccessTimes / (data.SuccessTimes + data.TimedOutTimes); //simply choose min package loss\n        }\n        public class StatisticsData\n        {
        }\n        public class StatisticsData\n        {\n            public int SuccessTimes;\n            public int TimedOutTimes;\n            public int AverageResponse;\n            public int MinResponse;\n            public int MaxResponse;\n        }\n        private void ChooseNewServer(List<Server> servers)\n        {
        private void ChooseNewServer(List<Server> servers)\n        {\n            if (_statistics == null || servers.Count == 0)\n            {\n                return;\n            }\n            try\n            {\n                var bestResult = (from server in servers\n                                  let name = server.FriendlyName()
                return;\n            }\n            try\n            {\n                var bestResult = (from server in servers\n                                  let name = server.FriendlyName()\n                                  where _statistics.ContainsKey(name)\n                                  select new\n                                  {\n                                      server,
using System.Drawing;\nusing System.Data;\nusing System.Linq;\nusing System.Text;\nusing System.Windows.Forms;\nnamespace Shadowsocks.View\n{\n    public partial class CalculationControl : UserControl\n    {
using System.Linq;\nusing System.Text;\nusing System.Windows.Forms;\nnamespace Shadowsocks.View\n{\n    public partial class CalculationControl : UserControl\n    {\n        public CalculationControl(string value)\n        {\n            InitializeComponent();
{\n    public partial class CalculationControl : UserControl\n    {\n        public CalculationControl(string value)\n        {\n            InitializeComponent();\n            valueLabel.Text = value;\n        }\n        public string Value => valueLabel.Text;
        /// Required method for Designer support - do not modify\n        /// the contents of this method with the code editor.\n        /// </summary>\n        private void InitializeComponent()\n        {\n            this.components = new System.ComponentModel.Container();\n            System.Windows.Forms.DataVisualization.Charting.ChartArea chartArea1 = new System.Windows.Forms.DataVisualization.Charting.ChartArea();\n            System.Windows.Forms.DataVisualization.Charting.Legend legend1 = new System.Windows.Forms.DataVisualization.Charting.Legend();\n            System.Windows.Forms.DataVisualization.Charting.Series series1 = new System.Windows.Forms.DataVisualization.Charting.Series();\n            System.Windows.Forms.DataVisualization.Charting.Series series2 = new System.Windows.Forms.DataVisualization.Charting.Series();
            this.StatisticsEnabledCheckBox = new System.Windows.Forms.CheckBox();\n            this.choiceKeptMinutesNum = new System.Windows.Forms.NumericUpDown();\n            this.byHourOfDayCheckBox = new System.Windows.Forms.CheckBox();\n            this.repeatTimesNum = new System.Windows.Forms.NumericUpDown();\n            this.label6 = new System.Windows.Forms.Label();\n            this.splitContainer3 = new System.Windows.Forms.SplitContainer();\n            this.label1 = new System.Windows.Forms.Label();\n            this.calculationContainer = new System.Windows.Forms.FlowLayoutPanel();\n            this.CancelButton = new System.Windows.Forms.Button();\n            this.OKButton = new System.Windows.Forms.Button();
            this.StatisticsChart.ChartAreas.Add(chartArea1);\n            this.StatisticsChart.Dock = System.Windows.Forms.DockStyle.Fill;\n            legend1.BackColor = System.Drawing.Color.Transparent;\n            legend1.Name = "ChartLegend";\n            this.StatisticsChart.Legends.Add(legend1);\n            this.StatisticsChart.Location = new System.Drawing.Point(0, 0);\n            this.StatisticsChart.Margin = new System.Windows.Forms.Padding(5, 10, 5, 10);\n            this.StatisticsChart.Name = "StatisticsChart";\n            this.StatisticsChart.Palette = System.Windows.Forms.DataVisualization.Charting.ChartColorPalette.Pastel;\n            series1.ChartArea = "ChartArea";
            legend1.Name = "ChartLegend";\n            this.StatisticsChart.Legends.Add(legend1);\n            this.StatisticsChart.Location = new System.Drawing.Point(0, 0);\n            this.StatisticsChart.Margin = new System.Windows.Forms.Padding(5, 10, 5, 10);\n            this.StatisticsChart.Name = "StatisticsChart";\n            this.StatisticsChart.Palette = System.Windows.Forms.DataVisualization.Charting.ChartColorPalette.Pastel;\n            series1.ChartArea = "ChartArea";\n            series1.ChartType = System.Windows.Forms.DataVisualization.Charting.SeriesChartType.Area;\n            series1.Color = System.Drawing.Color.FromArgb(((int)(((byte)(204)))), ((int)(((byte)(204)))), ((int)(((byte)(204)))));\n            series1.Legend = "ChartLegend";
            this.StatisticsChart.Margin = new System.Windows.Forms.Padding(5, 10, 5, 10);\n            this.StatisticsChart.Name = "StatisticsChart";\n            this.StatisticsChart.Palette = System.Windows.Forms.DataVisualization.Charting.ChartColorPalette.Pastel;\n            series1.ChartArea = "ChartArea";\n            series1.ChartType = System.Windows.Forms.DataVisualization.Charting.SeriesChartType.Area;\n            series1.Color = System.Drawing.Color.FromArgb(((int)(((byte)(204)))), ((int)(((byte)(204)))), ((int)(((byte)(204)))));\n            series1.Legend = "ChartLegend";\n            series1.Name = "Data Transferred";\n            series2.ChartArea = "ChartArea";
            series1.ChartArea = "ChartArea";\n            series1.ChartType = System.Windows.Forms.DataVisualization.Charting.SeriesChartType.Area;\n            series1.Color = System.Drawing.Color.FromArgb(((int)(((byte)(204)))), ((int)(((byte)(204)))), ((int)(((byte)(204)))));\n            series1.Legend = "ChartLegend";\n            series1.Name = "Data Transferred";\n            series2.ChartArea = "ChartArea";\n            series2.ChartType = System.Windows.Forms.DataVisualization.Charting.SeriesChartType.Bubble;\n            series2.Color = System.Drawing.Color.FromArgb(((int)(((byte)(221)))), ((int)(((byte)(88)))), ((int)(((byte)(0)))));\n            series2.Legend = "ChartLegend";
            series1.Name = "Data Transferred";\n            series2.ChartArea = "ChartArea";\n            series2.ChartType = System.Windows.Forms.DataVisualization.Charting.SeriesChartType.Bubble;\n            series2.Color = System.Drawing.Color.FromArgb(((int)(((byte)(221)))), ((int)(((byte)(88)))), ((int)(((byte)(0)))));\n            series2.Legend = "ChartLegend";\n            series2.Name = "Package Loss";\n            series2.YValuesPerPoint = 4;\n            series3.BorderWidth = 4;\n            series3.ChartArea = "ChartArea";\n            series3.ChartType = System.Windows.Forms.DataVisualization.Charting.SeriesChartType.Line;\n            series3.Color = System.Drawing.Color.FromArgb(((int)(((byte)(155)))), ((int)(((byte)(77)))), ((int)(((byte)(150)))));\n            series3.Legend = "ChartLegend";\n            series3.Name = "Ping";\n            this.StatisticsChart.Series.Add(series1);\n            this.StatisticsChart.Series.Add(series2);
using System.Linq;\nusing System.Net;\nusing SimpleJson;\nusing System.Net.Http;\nusing System.Net.NetworkInformation;\nusing System.Threading.Tasks;\nusing System.Windows.Forms;\nusing Shadowsocks.Model;
namespace Shadowsocks.Controller\n{\n    using DataUnit = KeyValuePair<string, string>;\n    using DataList = List<KeyValuePair<string, string>>;\n    internal class AvailabilityStatistics\n    {\n        private const string StatisticsFilesName = "shadowsocks.availability.csv";\n        private const string Delimiter = ",";\n        private const int Timeout = 500;
        private const int Repeat = 4; //repeat times every evaluation\n        private const int Interval = 10*60*1000; //evaluate proxies every 15 minutes\n        private const int delayBeforeStart = 1*1000; //delay 1 second before start\n        private Timer _timer;\n        private State _state;\n        private List<Server> _servers;\n        public static string AvailabilityStatisticsFile;\n        //static constructor to initialize every public static fields before refereced\n        static AvailabilityStatistics()\n        {
        private Timer _timer;\n        private State _state;\n        private List<Server> _servers;\n        public static string AvailabilityStatisticsFile;\n        //static constructor to initialize every public static fields before refereced\n        static AvailabilityStatistics()\n        {\n            string temppath = Utils.GetTempPath();\n            AvailabilityStatisticsFile = Path.Combine(temppath, StatisticsFilesName);\n        }
        }\n        public bool Set(bool enabled)\n        {\n            try\n            {
        {\n            try\n            {\n                if (enabled)\n                {
            try\n            {\n                if (enabled)\n                {\n                    if (_timer?.Change(0, Interval) == null)\n                    {\n                        _state = new State();
                Logging.LogUsefulException(e);\n                return ret;\n            }\n            dynamic obj;\n            if (!global::SimpleJson.SimpleJson.TryDeserializeObject(jsonString, out obj)) return ret;\n            string country = obj["country"];\n            string city = obj["city"];\n            string isp = obj["isp"];\n            string regionName = obj["regionName"];\n            if (country == null || city == null || isp == null || regionName == null) return ret;
            string regionName = obj["regionName"];\n            if (country == null || city == null || isp == null || regionName == null) return ret;\n        private static async Task<List<DataList>> ICMPTest(Server server)\n        {\n            var ping = new Ping();\n            var ret = new List<DataList>();\n            foreach (
        {\n            var ping = new Ping();\n            var ret = new List<DataList>();\n            foreach (\n                var timestamp in Enumerable.Range(0, Repeat).Select(_ => DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss")))\n            {\n                //ICMP echo. we can also set options and special bytes\n                try\n                {
                catch (Exception e)\n                {\n                    Console.WriteLine($"An exception occured when eveluating {server.FriendlyName()}");\n                    Logging.LogUsefulException(e);\n                }\n            }\n            return ret;\n        }\n        private async void Evaluate(object obj)\n        {
                }\n            }\n            return ret;\n        }\n        private async void Evaluate(object obj)\n        {\n            File.AppendAllLines(AvailabilityStatisticsFile, lines);\n        }
            return ret;\n        }\n        private async void Evaluate(object obj)\n        {\n            File.AppendAllLines(AvailabilityStatisticsFile, lines);\n        }\n        internal void UpdateConfiguration(Configuration config)\n        {
        {\n            File.AppendAllLines(AvailabilityStatisticsFile, lines);\n        }\n        internal void UpdateConfiguration(Configuration config)\n        {\n            Set(config.availabilityStatistics);\n            _servers = config.configs;\n        }
{\n    static class ProtocolHandler\n    {\n        private static Logger logger = LogManager.GetCurrentClassLogger();\n        // Don't use Application.ExecutablePath\n        // see https://stackoverflow.com/questions/12945805/odd-c-sharp-path-issue\n        private static readonly string ExecutablePath = Assembly.GetEntryAssembly().Location;\n        // TODO: Elevate when necessary\n        public static bool Set(bool enabled)\n        {
        private static Logger logger = LogManager.GetCurrentClassLogger();\n        // Don't use Application.ExecutablePath\n        // see https://stackoverflow.com/questions/12945805/odd-c-sharp-path-issue\n        private static readonly string ExecutablePath = Assembly.GetEntryAssembly().Location;\n        // TODO: Elevate when necessary\n        public static bool Set(bool enabled)\n        {\n            RegistryKey runKey = null;\n            try\n            {
            try\n            {\n                RegistryKey hkcr = RegistryKey.OpenBaseKey(RegistryHive.ClassesRoot,\n                        Environment.Is64BitOperatingSystem ? RegistryView.Registry64 : RegistryView.Registry32);\n                runKey = hkcr.CreateSubKey("ss",RegistryKeyPermissionCheck.ReadWriteSubTree);\n                if (runKey == null)\n                {
                {\n                    runKey.SetValue("", "URL:Shadowsocks");\n                    runKey.SetValue("URL Protocol", "");\n                    var shellOpen = runKey.CreateSubKey("shell").CreateSubKey("open").CreateSubKey("command");\n                    shellOpen.SetValue("", $"{ExecutablePath} --open-url %1");\n                }\n                else\n                {
            {\n                logger.LogUsefulException(e);\n                return false;\n            }\n            finally\n            {\n                if (runKey != null)\n                {\n                    try\n                    {
                        runKey.Close();\n                        runKey.Dispose();\n                    }\n                    catch (Exception e)\n                    { logger.LogUsefulException(e); }\n                }\n            }\n        }\n        public static bool Check()\n        {
                    catch (Exception e)\n                    { logger.LogUsefulException(e); }\n                }\n            }\n        }\n        public static bool Check()\n        {\n            RegistryKey runKey = null;\n            try\n            {
            }\n        }\n        public static bool Check()\n        {\n            RegistryKey runKey = null;\n            try\n            {\n                runKey = Utils.OpenRegKey(@"ss", true, RegistryHive.ClassesRoot);\n                if (runKey == null)\n                {
        {\n            RegistryKey runKey = null;\n            try\n            {\n                runKey = Utils.OpenRegKey(@"ss", true, RegistryHive.ClassesRoot);\n                if (runKey == null)\n                {\n                    logger.Error(@"Cannot find HKCR\ss");\n                    return false;\n                }
            {\n                logger.LogUsefulException(e);\n                return false;\n            }\n            finally\n            {\n                if (runKey != null)\n                {\n                    try\n                    {
﻿using System.Reflection;\nusing System.Runtime.CompilerServices;\nusing System.Runtime.InteropServices;\n// 有关程序集的常规信息通过下列属性集\n// 控制。更改这些属性值可修改\n// 与程序集关联的信息。\n[assembly: AssemblyTitle("shadowsocks-csharp")]\n[assembly: AssemblyDescription("")]\n[assembly: AssemblyConfiguration("")]
using System.Runtime.CompilerServices;\nusing System.Runtime.InteropServices;\n// 有关程序集的常规信息通过下列属性集\n// 控制。更改这些属性值可修改\n// 与程序集关联的信息。\n[assembly: AssemblyTitle("shadowsocks-csharp")]\n[assembly: AssemblyDescription("")]\n[assembly: AssemblyConfiguration("")]\n[assembly: AssemblyCompany("")]\n[assembly: AssemblyProduct("shadowsocks-csharp")]
using System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.IO.Compression;\nusing System.Runtime.InteropServices;\nusing System.Text;\nnamespace Shadowsocks.Util\n{\n    public class Utils\n    {
using System.Runtime.InteropServices;\nusing System.Text;\nnamespace Shadowsocks.Util\n{\n    public class Utils\n    {\n        public static void ReleaseMemory()\n        {\n            // release any unused pages\n            // making the numbers look good in task manager\n            // this is totally nonsense in programming\n            // but good for those users who care\n            // making them happier with their everyday life\n            // which is part of user experience\n            GC.Collect(GC.MaxGeneration);\n            GC.WaitForPendingFinalizers();
                try\n                {\n                    remote.Shutdown(SocketShutdown.Both);\n                    remote.Close();\n                }\n                catch (SocketException e)\n                {\n                    Console.WriteLine(e);\n                }\n            }
            try\n            {\n                int bytesRead = remote.EndReceive(ar);\n                if (bytesRead > 0)\n                {\n                    int bytesToSend;
            try\n            {\n                int bytesRead = connection.EndReceive(ar);\n                if (bytesRead > 0)\n                {\n                    int bytesToSend;
                    new AsyncCallback(AcceptCallback),\n                    listener);\n                conn.BeginReceive(new byte[1024], 0, 1024, 0,\n                    new AsyncCallback(ReceiveCallback), conn);\n            }\n            catch (Exception e)\n            {
        static void Main()\n        {\n            // Check OS since we are using dual-mode socket\n            if (!Utils.IsWinVistaOrHigher())\n            {\n                MessageBox.Show(I18N.GetString("Unsupported operating system, use Windows Vista at least."),\n                "Shadowsocks Error", MessageBoxButtons.OK, MessageBoxIcon.Error);\n                return;\n            }\n            Utils.ReleaseMemory(true);
                _controller.Start();\n                Application.Run();\n            }\n        }\n        private static int exited = 0;\n        private static void CurrentDomain_UnhandledException(object sender, UnhandledExceptionEventArgs e)\n        {\n            if (Interlocked.Increment(ref exited) == 1)\n            {\n                Logging.Error(e.ExceptionObject?.ToString());
            try\n            {\n                int bytesRead = _firstPacketLength;\n                if (bytesRead > 1)\n                {\n                    byte[] response = { 5, 0 };\n                    if (_firstPacket[0] != 5)\n                    {\n                        // reject socks 4\n                        response = new byte[] { 0, 91 };
                        Logging.Error("socks 5 protocol error");\n                    }\n                    _connection.BeginSend(response, 0, response.Length, SocketFlags.None,\n                        HandshakeSendCallback, null);\n                }\n                else\n                    Close();\n            }\n            catch (Exception e)\n            {
                            // +----+-----+-------+------+----------+----------+\n                            byte[] response = { 5, 0, 0, 1, 0, 0, 0, 0, 0, 0 };\n                            _connection.BeginSend(response, 0, response.Length, SocketFlags.None,\n                                ResponseCallback, null);\n                            break;\n                        case CMD_UDP_ASSOC:\n                            ReadAddress(HandleUDPAssociate);\n                            break;\n                        case CMD_BIND:  // not implemented\n                        default:
                }\n                else\n                {\n                    Logging.Debug(\n                        "failed to recv data in Shadowsocks.Controller.TCPHandler.handshakeReceive2Callback()");\n                    Close();\n                }\n            }\n            catch (Exception e)\n            {
                            _addrBufLength = ADDR_ATYP_LEN + 1 + len + ADDR_PORT_LEN;\n                            break;\n                        case ATYP_IPv6: // IPv6 address, 16 bytes\n                            dstAddr = $"[{new IPAddress(_connetionRecvBuffer.Skip(1).Take(16).ToArray())}]";\n                            dstPort = (_connetionRecvBuffer[17] << 8) + _connetionRecvBuffer[18];\n                            _addrBufLength = ADDR_ATYP_LEN + 16 + ADDR_PORT_LEN;\n                            break;\n                    }\n                    if (_config.isVerboseLogging)\n                    {
                    }\n                    if (_config.isVerboseLogging)\n                    {\n                        Logging.Info($"connect to {dstAddr}:{dstPort}");\n                    }\n                    _destEndPoint = SocketUtil.GetEndPoint(dstAddr, dstPort);\n                    onSuccess.Invoke(); /* StartConnect() */\n                }\n                else\n                {
                    onSuccess.Invoke(); /* StartConnect() */\n                }\n                else\n                {\n                    Logging.Debug("failed to recv data in Shadowsocks.Controller.TCPHandler.OnAddressFullyRead()");\n                    Close();\n                }\n            }\n            catch (Exception e)\n            {
        }\n        private void StartPipe(AsyncSession session)\n        {\n            if (_closed) return;\n            try\n            {\n                _startReceivingTime = DateTime.Now;\n                session.Remote.BeginReceive(_remoteRecvBuffer, 0, RecvSize, SocketFlags.None,\n                    PipeRemoteReceiveCallback, session);\n                TryReadAvailableData();
            {\n                _startReceivingTime = DateTime.Now;\n                session.Remote.BeginReceive(_remoteRecvBuffer, 0, RecvSize, SocketFlags.None,\n                    PipeRemoteReceiveCallback, session);\n                TryReadAvailableData();\n                Logging.Debug($"_firstPacketLength = {_firstPacketLength}");\n                SendToServer(_firstPacketLength, session);\n            }\n            catch (Exception e)\n            {
                    lastActivity = DateTime.Now;\n                    int bytesToSend = -1;\n                    lock (_decryptionLock)\n                    {\n                        try\n                        {\n                            _encryptor.Decrypt(_remoteRecvBuffer, bytesRead, _remoteSendBuffer, out bytesToSend);\n                        }\n                        catch (CryptoErrorException)\n                        {
                server,\n                x => Sip003Plugin.CreateIfConfigured(x, _config.showPluginOutput));\n            if (plugin == null)\n            {\n                return null;\n            }\n            try\n            {\n                if (plugin.StartIfNeeded())\n                {
            try\n            {\n                if (plugin.StartIfNeeded())\n                {\n                    Logging.Info(\n                        $"Started SIP003 plugin for {server.Identifier()} on {plugin.LocalEndPoint} - PID: {plugin.ProcessId}");\n                }\n            }\n            catch (Exception ex)\n            {
                    if (!RawStatistics.TryGetValue(serverIdentifier, out records))\n                    {\n                        records = new List<StatisticsRecord>();\n                        RawStatistics[serverIdentifier] = records;\n                    }\n                }\n                records.Add(record);\n            }\n            catch (Exception e)\n            {
                }\n                records.Add(record);\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n            }\n        }\n        private void Save()\n        {
                foreach (var serverAndRecords in RawStatistics)\n                {\n                    var server = serverAndRecords.Key;\n                    var filteredRecords = serverAndRecords.Value.FindAll(IsValidRecord);\n                    filteredStatistics[server] = filteredRecords;\n                }\n                FilteredStatistics = filteredStatistics;\n            }\n            catch (Exception e)\n            {
            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n            }\n        }\n        private void LoadRawStatistics()\n        {\n            try\n            {\n                var path = AvailabilityStatisticsFile;
                                        ip.AddressFamily == AddressFamily.InterNetwork ||\n                                        ip.AddressFamily == AddressFamily.InterNetworkV6);\n                    }\n                    repeat--;\n                    if (delay > 0)\n                        Thread.Sleep(delay);\n                    ping.SendAsync(ip, TimeoutMilliseconds, userstate);\n                }\n                catch (Exception e)\n                {
                    }\n                    else\n                    {\n                        Logging.Debug($"Ping {server.FriendlyName()} timeout");\n                        RoundtripTime.Add(null);\n                    }\n                    TestNext(e.UserState);\n                }\n                catch (Exception ex)\n                {
        }\n        public virtual void InitCipher(byte[] salt, bool isEncrypt, bool isUdp)\n        {\n            if (isEncrypt) {\n                _encryptSalt = new byte[saltLen];\n                Array.Copy(salt, _encryptSalt, saltLen);\n            } else {\n                _decryptSalt = new byte[saltLen];\n                Array.Copy(salt, _decryptSalt, saltLen);\n            }
                uint decChunkLenLength = 0;\n                byte[] decChunkLenBytes = new byte[CHUNK_LEN_BYTES];\n                // try to dec chunk len\n                cipherDecrypt(encLenBytes, CHUNK_LEN_BYTES + (uint)tagLen, decChunkLenBytes, ref decChunkLenLength);\n                Debug.Assert(decChunkLenLength == CHUNK_LEN_BYTES);\n                // finally we get the real chunk len\n                ushort chunkLen = (ushort) IPAddress.NetworkToHostOrder((short)BitConverter.ToUInt16(decChunkLenBytes, 0));\n                if (chunkLen > CHUNK_LEN_MASK)\n                {\n                    // we get invalid chunk


                    {\n                        max = status;\n                    }\n                }\n            }\n            if (max != null)\n            {\n                if (_currentServer == null || max.score - _currentServer.score > 200)\n                {\n                    _currentServer = max;
                    ? new IPEndPoint(config.isIPv6Enabled ? IPAddress.IPv6Any : IPAddress.Any, _config.localPort)\n                    : new IPEndPoint(config.isIPv6Enabled ? IPAddress.IPv6Loopback : IPAddress.Loopback, _config.localPort);\n                // Bind the socket to the local endpoint and listen for incoming connections.\n                _tcpSocket.Bind(localEndPoint);\n                _udpSocket.Bind(localEndPoint);\n                _tcpSocket.Listen(1024);\n                // Start an asynchronous socket to listen for connections.\n                Logging.Info($"Shadowsocks started ({UpdateChecker.Version})");\n                if (_config.isVerboseLogging)\n                {
            timer.Elapsed -= Timer_Elapsed;\n            timer.Enabled = false;\n            timer.Dispose();\n            CheckUpdate(config);\n        }\n        public void CheckUpdate(Configuration config)\n        {\n            this.config = config;\n            try\n            {
            this.config = config;\n            try\n            {\n                Logging.Debug("Checking updates...");\n                WebClient http = CreateWebClient();\n                http.DownloadStringCompleted += http_DownloadStringCompleted;\n                http.DownloadStringAsync(new Uri(UpdateURL));\n            }\n            catch (Exception ex)\n            {
                    Asset asset = asserts[asserts.Count - 1];\n                    NewVersionFound = true;\n                    LatestVersionURL = asset.browser_download_url;\n                    LatestVersionNumber = asset.version;\n                    LatestVersionName = asset.name;\n                    LatestVersionSuffix = asset.suffix == null ? "" : $"-{asset.suffix}";\n                    startDownload();\n                }\n                else\n                {
                {\n                    Logging.Debug("No update is available");\n                    if (CheckUpdateCompleted != null)\n                    {\n                        CheckUpdateCompleted(this, new EventArgs());\n                    }\n                }\n            }\n            catch (Exception ex)\n            {
        }\n        private void Http_DownloadFileCompleted(object sender, System.ComponentModel.AsyncCompletedEventArgs e)\n        {\n            try\n            {\n                if (e.Error != null)\n                {\n                    Logging.LogUsefulException(e.Error);\n                    return;\n                }
                    return;\n                }\n                Logging.Debug($"New version {LatestVersionNumber}{LatestVersionSuffix} found: {LatestVersionLocalName}");\n                if (CheckUpdateCompleted != null)\n                {\n                    CheckUpdateCompleted(this, new EventArgs());\n                }\n            }\n            catch (Exception ex)\n            {
            }\n            if (ret != 0) throw new CryptoErrorException(String.Format("ret is {0}", ret));\n            Logging.Dump("after cipherEncrypt: cipher", ciphertext, (int) encClen);\n            clen = (uint) encClen;\n        }\n        public override void cipherDecrypt(byte[] ciphertext, uint clen, byte[] plaintext, ref uint plen)\n        {\n            Debug.Assert(_sodiumDecSubkey != null);\n            // buf: ciphertext + tag\n            // outbuf: plaintext\n            int ret;\n            ulong decPlen = 0;
                _remote.Bind(new IPEndPoint(GetIPAddress(), 0));\n            }\n            public void Send(byte[] data, int length)\n            {\n                IEncryptor encryptor = EncryptorFactory.GetEncryptor(_server.method, _server.password);\n                byte[] dataIn = new byte[length - 3];\n                Array.Copy(data, 3, dataIn, 0, length - 3);\n                byte[] dataOut = new byte[65536];  // enough space for AEAD ciphers\n                int outlen;\n                encryptor.EncryptUDP(dataIn, length - 3, dataOut, out outlen);
                        Process oldProcess = oldProcesses[0];\n                    }\n                    MessageBox.Show(I18N.GetString("Find Shadowsocks icon in your notify tray.")\n                        + Environment.NewLine\n                        + I18N.GetString("If you want to start multiple Shadowsocks, make a copy in another directory."),\n                        I18N.GetString("Shadowsocks is already running."));\n                    return;\n                }\n                Directory.SetCurrentDirectory(Application.StartupPath);\n#if DEBUG
                        + I18N.GetString("If you want to start multiple Shadowsocks, make a copy in another directory."),\n                        I18N.GetString("Shadowsocks is already running."));\n                    return;\n                }\n                Directory.SetCurrentDirectory(Application.StartupPath);\n#if DEBUG\n                Logging.OpenLogFile();\n                // truncate privoxy log file while debugging\n                string privoxyLogFilename = Utils.GetTempPath("privoxy.log");\n                if (File.Exists(privoxyLogFilename))\n                    using (new FileStream(privoxyLogFilename, FileMode.Truncate)) { }
        private static int exited = 0;\n        private static void CurrentDomain_UnhandledException(object sender, UnhandledExceptionEventArgs e)\n        {\n            if (Interlocked.Increment(ref exited) == 1)\n            {\n                string errMsg = e.ExceptionObject.ToString();
                        System.Threading.Tasks.Task.Factory.StartNew(() =>\n                        {\n                            Thread.Sleep(10 * 1000);\n                            try\n                            {\n                                MainController.Start(false);\n                                Logging.Info("controller started");\n                            }\n                            catch (Exception ex)\n                            {
                // Get the socket that handles the client request.\n                Socket listener = (Socket)ar.AsyncState;\n                //if (!listener.Connected)\n                //{\n                //    return;\n                //}\n                listener.BeginAccept(\n                    new AsyncCallback(AcceptCallback),\n                    listener);
                listener.BeginAccept(\n                    new AsyncCallback(AcceptCallback),\n                    listener);\n                Socket conn = listener.EndAccept(ar);\n                //else\n                //{\n                //    handler.encryptor = new Encryptor(config.method, config.password);\n                //}\n                handler.encryptor = EncryptorFactory.GetEncryptor(config.method, config.password);\n                handler.config = config;\n                handler.Start();\n                //handler.BeginReceive(state.buffer, 0, StateObject.BufferSize, 0,\n                //    new AsyncCallback(ReadCallback), state);\n            }
                // choose Traditional Chinese only if we get explicit indication\n                Init(name.Contains("Traditional")\n                    ? Resources.zh_TW\n                    : Resources.zh_CN);\n            }\n            else if (name.StartsWith("Japan", StringComparison.OrdinalIgnoreCase))\n            {\n                Init(Resources.ja);\n            }\n        }
                    : Resources.zh_CN);\n            }\n            else if (name.StartsWith("Japan", StringComparison.OrdinalIgnoreCase))\n            {\n                Init(Resources.ja);\n            }\n        }\n        public static string GetString(string key)\n        {\n            return _strings.ContainsKey(key)
        Socket _tcpSocket;\n        Socket _udpSocket;\n        List<IService> _services;\n        public Listener(List<IService> services)\n        {\n            this._services = services;\n        }\n        private bool CheckIfPortInUse(int port)\n        {\n            IPGlobalProperties ipProperties = IPGlobalProperties.GetIPGlobalProperties();
        private bool CheckIfPortInUse(int port)\n        {\n            IPGlobalProperties ipProperties = IPGlobalProperties.GetIPGlobalProperties();\n                    return true;\n                }\n            }\n            return false;\n        }\n        public void Start(Configuration config)\n        {\n            this._config = config;\n            this._shareOverLAN = config.shareOverLan;\n            if (CheckIfPortInUse(_config.localPort))
        public void EndConnectProxy(IAsyncResult asyncResult)\n        {\n            var state = ((FakeAsyncResult)asyncResult).innerState;\n            if (state.ex != null)\n            {\n                throw state.ex;\n            }\n        }\n        public void BeginConnectDest(string host, int port, AsyncCallback callback, object state)\n        {
                throw state.ex;\n            }\n        }\n        public void BeginConnectDest(string host, int port, AsyncCallback callback, object state)\n        {\n            if (!parsed)\n            {\n                IPHostEntry ipHostInfo = Dns.GetHostEntry(host);\n                ipAddress = ipHostInfo.AddressList[0];\n            }\n            IPEndPoint ep = new IPEndPoint(ipAddress, port);\n            DestHost = host;\n            DestPort = port;\n            byte[] request = null;\n            byte atyp = 0;
            if (request == null)\n            {\n                throw new Exception(I18N.GetString("Proxy request faild"));\n            }\n            // 构造request包\n            var addr = ep.Address.GetAddressBytes();\n            request[0] = 5;\n            request[1] = 1;\n            request[2] = 0;\n            request[3] = atyp;
                if (bytesRead > 0)\n                {\n                    int atyp = _connetionRecvBuffer[0];\n                    string dst_addr;\n                    int dst_port;\n                    switch (atyp)\n                    {\n                        case 1:  // IPv4 address, 4 bytes\n                            dst_addr = new IPAddress(_connetionRecvBuffer.Skip(1).Take(4).ToArray()).ToString();\n                            dst_port = (_connetionRecvBuffer[5] << 8) + _connetionRecvBuffer[6];
                        case 1:  // IPv4 address, 4 bytes\n                            dst_addr = new IPAddress(_connetionRecvBuffer.Skip(1).Take(4).ToArray()).ToString();\n                            dst_port = (_connetionRecvBuffer[5] << 8) + _connetionRecvBuffer[6];\n                            // Note by wongsyrone: this will be stripped out in Release version\n                            Logging.Debug($"connect to {dst_addr}:{dst_port}");\n                            break;\n                        case 3:  // domain name, length + str\n                            int len = _connetionRecvBuffer[1];\n                            dst_addr = System.Text.Encoding.UTF8.GetString(_connetionRecvBuffer, 2, len);\n                            dst_port = (_connetionRecvBuffer[len + 2] << 8) + _connetionRecvBuffer[len + 3];
                        case 3:  // domain name, length + str\n                            int len = _connetionRecvBuffer[1];\n                            dst_addr = System.Text.Encoding.UTF8.GetString(_connetionRecvBuffer, 2, len);\n                            dst_port = (_connetionRecvBuffer[len + 2] << 8) + _connetionRecvBuffer[len + 3];\n                            Logging.Debug($"connect to {dst_addr}:{dst_port}");\n                            break;\n                        case 4:  // IPv6 address, 16 bytes\n                            dst_addr = new IPAddress(_connetionRecvBuffer.Skip(1).Take(16).ToArray()).ToString();\n                            dst_port = (_connetionRecvBuffer[17] << 8) + _connetionRecvBuffer[18];
        static I18N()\n        {\n            Strings = new Dictionary<string, string>();
        static I18N()\n        {\n            Strings = new Dictionary<string, string>();\n            if (CultureInfo.CurrentCulture.IetfLanguageTag.StartsWith("zh", StringComparison.OrdinalIgnoreCase))\n            {
        static I18N()\n        {\n            Strings = new Dictionary<string, string>();\n            if (CultureInfo.CurrentCulture.IetfLanguageTag.StartsWith("zh", StringComparison.OrdinalIgnoreCase))\n            {\n                using (var sr = new StringReader(Resources.cn))\n                {
            } finally {\n                if (_userSettings == null) _userSettings = new SysproxyConfig();\n            }\n        }\n        private static void ParseQueryStr(string str)\n        {\n            string[] userSettingsArr = str.Split(new string[] { "\r\n" }, StringSplitOptions.RemoveEmptyEntries);\n            // sometimes sysproxy output in utf16le instead of ascii\n            // manually translate it
using System.Net;\nusing System.Diagnostics;\nusing System.Text;\nusing Shadowsocks.Util.SystemProxy;\nnamespace NLog\n{\n    public static class LoggerExtension\n    {\n        public static void Dump(this Logger logger, string tag, byte[] arr, int length)\n        {
using System.Text;\nusing Shadowsocks.Util.SystemProxy;\nnamespace NLog\n{\n    public static class LoggerExtension\n    {\n        public static void Dump(this Logger logger, string tag, byte[] arr, int length)\n        {\n            var sb = new StringBuilder($"{Environment.NewLine}{tag}: ");\n            for (int i = 0; i < length - 1; i++)\n            {
    public static class LoggerExtension\n    {\n        public static void Dump(this Logger logger, string tag, byte[] arr, int length)\n        {\n            var sb = new StringBuilder($"{Environment.NewLine}{tag}: ");\n            for (int i = 0; i < length - 1; i++)\n            {\n                sb.Append($"0x{arr[i]:X2}, ");\n            }
            for (int i = 0; i < length - 1; i++)\n            {\n                sb.Append($"0x{arr[i]:X2}, ");\n            }\n            sb.Append($"0x{arr[length - 1]:X2}");\n            sb.Append(Environment.NewLine);\n            logger.Debug(sb.ToString());\n        }\n        public static void Debug(this Logger logger, EndPoint local, EndPoint remote, int len, string header = null, string tailer = null)\n        {
                logger.Debug($"{local} => {remote} (size={len})");\n            else if (header == null && tailer != null)\n                logger.Debug($"{local} => {remote} (size={len}), {tailer}");\n            else if (header != null && tailer == null)\n                logger.Debug($"{header}: {local} => {remote} (size={len})");\n            else\n                logger.Debug($"{header}: {local} => {remote} (size={len}), {tailer}");\n        }\n        public static void Debug(this Logger logger, Socket sock, int len, string header = null, string tailer = null)\n        {
        private bool _byHourOfDay = false;\n        private int _choiceKeptMinutes = 10;\n        private int _dataCollectionMinutes = 10;\n        private int _repeatTimesNum = 4;\n        private const string ConfigFile = "statistics-config.json";\n        public static StatisticsStrategyConfiguration Load()\n        {\n            try\n            {\n                var content = File.ReadAllText(ConfigFile);
        private int _repeatTimesNum = 4;\n        private const string ConfigFile = "statistics-config.json";\n        public static StatisticsStrategyConfiguration Load()\n        {\n            try\n            {\n                var content = File.ReadAllText(ConfigFile);\n                var configuration = JsonConvert.DeserializeObject<StatisticsStrategyConfiguration>(content);\n                return configuration;\n            }
                    json[index + 1] == 'u' &&\n                    json[index + 2] == 'l' &&\n                    json[index + 3] == 'l')\n                {\n                    index += 4;\n                    return TOKEN_NULL;\n                }\n            }\n            return TOKEN_NONE;\n        }
            return TOKEN_NONE;\n        }\n        protected static bool SerializeValue(IJsonSerializerStrategy jsonSerializerStrategy, object value, StringBuilder builder)\n        {\n            bool success = true;\n            if (value is string)\n                success = SerializeString((string)value, builder);\n            else if (value is IDictionary<string, object>)\n            {\n                IDictionary<string, object> dict = (IDictionary<string, object>)value;
            if (value is string)\n                success = SerializeString((string)value, builder);\n            else if (value is IDictionary<string, object>)\n            {\n                IDictionary<string, object> dict = (IDictionary<string, object>)value;\n                success = SerializeObject(jsonSerializerStrategy, dict.Keys, dict.Values, builder);\n            }\n            else if (value is IDictionary<string, string>)\n            {\n                IDictionary<string, string> dict = (IDictionary<string, string>)value;
            {\n                IDictionary<string, object> dict = (IDictionary<string, object>)value;\n                success = SerializeObject(jsonSerializerStrategy, dict.Keys, dict.Values, builder);\n            }\n            else if (value is IDictionary<string, string>)\n            {\n                IDictionary<string, string> dict = (IDictionary<string, string>)value;\n                success = SerializeObject(jsonSerializerStrategy, dict.Keys, dict.Values, builder);\n            }\n            else if (value is IEnumerable)
                success = SerializeNumber(value, builder);\n            else if (value is Boolean)\n                builder.Append((bool)value ? "true" : "false");\n            else if (value == null)\n                builder.Append("null");\n            else\n            {\n                object serializedObject;\n                success = jsonSerializerStrategy.SerializeNonPrimitiveObject(value, out serializedObject);\n                if (success)
                builder.Append("null");\n            else\n            {\n                object serializedObject;\n                success = jsonSerializerStrategy.SerializeNonPrimitiveObject(value, out serializedObject);\n                if (success)\n                    SerializeValue(jsonSerializerStrategy, serializedObject, builder);\n            }\n            return success;\n        }
            while (ke.MoveNext() && ve.MoveNext())\n            {\n                object key = ke.Current;\n                object value = ve.Current;\n                if (!first)\n                    builder.Append(",\r\n");\n                if (key is string)\n                    SerializeString((string)key, builder);\n                else
                object key = ke.Current;\n                object value = ve.Current;\n                if (!first)\n                    builder.Append(",\r\n");\n                if (key is string)\n                    SerializeString((string)key, builder);\n                else\n                    if (!SerializeValue(jsonSerializerStrategy, value, builder)) return false;\n                builder.Append(" : ");
                if (key is string)\n                    SerializeString((string)key, builder);\n                else\n                    if (!SerializeValue(jsonSerializerStrategy, value, builder)) return false;\n                builder.Append(" : ");\n                if (!SerializeValue(jsonSerializerStrategy, value, builder))\n                    return false;\n                first = false;\n            }
                    if (!SerializeValue(jsonSerializerStrategy, value, builder)) return false;\n                builder.Append(" : ");\n                if (!SerializeValue(jsonSerializerStrategy, value, builder))\n                    return false;\n                first = false;\n            }\n            builder.Append("}\r\n");\n            return true;\n        }
            return true;\n        }\n        protected static bool SerializeArray(IJsonSerializerStrategy jsonSerializerStrategy, IEnumerable anArray, StringBuilder builder)\n        {\n            builder.Append("[\r\n  ");\n            bool first = true;\n            foreach (object value in anArray)\n            {\n                if (!first)
            bool first = true;\n            foreach (object value in anArray)\n            {\n                if (!first)\n                    builder.Append(",\r\n  ");\n                if (!SerializeValue(jsonSerializerStrategy, value, builder))\n                    return false;\n                first = false;\n            }
﻿using System;\nusing System.Security.Cryptography;\nnamespace Shadowsocks.Encryption\n{\n    public static class RNG\n    {\n        private static RNGCryptoServiceProvider _rng = null;\n        public static void Init()\n        {
{\n    public static class RNG\n    {\n        private static RNGCryptoServiceProvider _rng = null;\n        public static void Init()\n        {\n            if (_rng == null)\n                _rng = new RNGCryptoServiceProvider();\n        }\n        public static void Close()\n        {
        {\n            Close();\n            Init();\n        }\n        public static void GetBytes(byte[] buf)\n        {\n            GetBytes(buf, buf.Length);\n        }\n        public static void GetBytes(byte[] buf, int len)\n        {
        {\n            GetBytes(buf, buf.Length);\n        }\n        public static void GetBytes(byte[] buf, int len)\n        {\n            if (_rng == null) Reload();\n            try\n            {\n                _rng.GetBytes(buf, 0, len);\n            }
    public class GFWListUpdater\n    {\n        private const string GFWLIST_URL = "https://autoproxy-gfwlist.googlecode.com/svn/trunk/gfwlist.txt";\n        private static string PAC_FILE = PACServer.PAC_FILE;\n        public event EventHandler UpdateCompleted;\n        public event ErrorEventHandler Error;\n        private void http_DownloadStringCompleted(object sender, DownloadStringCompletedEventArgs e)\n        {\n            try\n            {
        private const string GFWLIST_URL = "https://autoproxy-gfwlist.googlecode.com/svn/trunk/gfwlist.txt";\n        private static string PAC_FILE = PACServer.PAC_FILE;\n        public event EventHandler UpdateCompleted;\n        public event ErrorEventHandler Error;\n        private void http_DownloadStringCompleted(object sender, DownloadStringCompletedEventArgs e)\n        {\n            try\n            {\n                string[] lines = ParseResult(e.Result);\n                JsonArray rules = new JsonArray();\n                rules.AddRange(lines);\n                string abpContent = Utils.UnGzip(Resources.abp_js);
                }\n            }\n        }\n        public void UpdatePACFromGFWList()\n        {\n            WebClient http = new WebClient();\n            http.DownloadStringCompleted += http_DownloadStringCompleted;\n            http.DownloadStringAsync(new Uri(GFWLIST_URL));\n        }
                else\n                {\n                    registry.SetValue("ProxyEnable", 0);\n                    registry.SetValue("ProxyServer", "");\n                    registry.SetValue("AutoConfigURL", "http://127.0.0.1:8093/pac?t=" + GetTimestamp(DateTime.Now));\n                }\n                SystemProxy.NotifyIE();\n                //Must Notify IE first, or the connections do not chanage\n                CopyProxySettingFromLan();\n            }
                    registry.SetValue("ProxyEnable", 0);\n                    registry.SetValue("ProxyServer", "");\n                    registry.SetValue("AutoConfigURL", "http://127.0.0.1:8093/pac?t=" + GetTimestamp(DateTime.Now));\n                }\n                SystemProxy.NotifyIE();\n                //Must Notify IE first, or the connections do not chanage\n                CopyProxySettingFromLan();\n            }\n            catch (Exception)\n            {
            {\n                RegistryKey registry =\n                    Registry.CurrentUser.OpenSubKey("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings",\n                        true);\n                registry.SetValue("ProxyEnable", 0);\n                registry.SetValue("ProxyServer", "");\n                registry.SetValue("AutoConfigURL", "");\n                SystemProxy.NotifyIE();\n                CopyProxySettingFromLan();\n            }
                    Registry.CurrentUser.OpenSubKey("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings",\n                        true);\n                registry.SetValue("ProxyEnable", 0);\n                registry.SetValue("ProxyServer", "");\n                registry.SetValue("AutoConfigURL", "");\n                SystemProxy.NotifyIE();\n                CopyProxySettingFromLan();\n            }\n            catch (Exception)\n            {
using System.Collections.Generic;\nusing System.Text;\nusing System.Net.Sockets;\nusing System.Net;\nnamespace shadowsocks_csharp\n{\n    class Local\n    {\n        private Config config;
namespace shadowsocks_csharp\n{\n    class Local\n    {\n        private Config config;\n        private Encryptor encryptor;\n        Socket listener;\n        public Local(Config config)\n        {\n            this.config = config;
            return value.ToString("yyyyMMddHHmmssfff");\n        }\n        public static void Update(Configuration config, bool forceDisable)\n        {\n            bool global = config.global;\n            bool enabled = config.enabled;\n            if (forceDisable)\n            {\n                enabled = false;\n            }
        public static void Update(Configuration config, bool forceDisable)\n        {\n            bool global = config.global;\n            bool enabled = config.enabled;\n            if (forceDisable)\n            {\n                enabled = false;\n            }\n            if (enabled)\n            {
            bool global = config.global;\n            bool enabled = config.enabled;\n            if (forceDisable)\n            {\n                enabled = false;\n            }\n            if (enabled)\n            {\n                if (global)\n                {
            if (enabled)\n            {\n                if (global)\n                {\n                    WinINet.SetIEProxy(true, true, "127.0.0.1:" + config.localPort.ToString(), "");\n                }\n                else\n                {
                {\n                    WinINet.SetIEProxy(true, true, "127.0.0.1:" + config.localPort.ToString(), "");\n                }\n                else\n                {\n                    string pacUrl;\n                    if (config.useOnlinePac && !config.pacUrl.IsNullOrEmpty())\n                        pacUrl = config.pacUrl;\n                    else\n                        pacUrl = $"http://127.0.0.1:{config.localPort}/pac?t={GetTimestamp(DateTime.Now)}";\n                    WinINet.SetIEProxy(true, false, "", pacUrl);\n                }\n            }
                    WinINet.SetIEProxy(true, true, "127.0.0.1:" + config.localPort.ToString(), "");\n                }\n                else\n                {\n                    string pacUrl;\n                    if (config.useOnlinePac && !config.pacUrl.IsNullOrEmpty())\n                        pacUrl = config.pacUrl;\n                    else\n                        pacUrl = $"http://127.0.0.1:{config.localPort}/pac?t={GetTimestamp(DateTime.Now)}";\n                    WinINet.SetIEProxy(true, false, "", pacUrl);\n                }\n            }\n            else\n            {
        }\n        private void LogForm_Load(object sender, EventArgs e)\n        {\n            InitContent();\n            timer = new Timer();\n            timer.Interval = 300;\n            timer.Tick += Timer_Tick;\n            timer.Start();\n            this.TopMost = TopMostMenuItem.Checked = TopMostCheckBox.Checked = topMostTrigger;
            if (_cipher == 0) {\n                throw new System.Exception("method not found");\n            }\n            keyLen = CipherInfo.KeySize;\n            ivLen = CipherInfo.IvSize;\n        }\n        private void InitKey(string password)\n        {\n            byte[] passbuf = Encoding.UTF8.GetBytes(password);\n            if (_key == null) _key = new byte[keyLen];
            keyLen = CipherInfo.KeySize;\n            ivLen = CipherInfo.IvSize;\n        }\n        private void InitKey(string password)\n        {\n            byte[] passbuf = Encoding.UTF8.GetBytes(password);\n            if (_key == null) _key = new byte[keyLen];\n            if (_key.Length < keyLen) Array.Resize(ref _key, keyLen);\n            LegacyDeriveKey(passbuf, _key);\n        }
        }\n        private void InitKey(string password)\n        {\n            byte[] passbuf = Encoding.UTF8.GetBytes(password);\n            if (_key == null) _key = new byte[keyLen];\n            if (_key.Length < keyLen) Array.Resize(ref _key, keyLen);\n            LegacyDeriveKey(passbuf, _key);\n        }\n        public static void LegacyDeriveKey(byte[] password, byte[] key)\n        {
            byte[] passbuf = Encoding.UTF8.GetBytes(password);\n            if (_key == null) _key = new byte[keyLen];\n            if (_key.Length < keyLen) Array.Resize(ref _key, keyLen);\n            LegacyDeriveKey(passbuf, _key);\n        }\n        public static void LegacyDeriveKey(byte[] password, byte[] key)\n        {\n            byte[] result = new byte[password.Length + 16];\n            int i = 0;\n            byte[] md5sum = null;
        }\n        public static void LegacyDeriveKey(byte[] password, byte[] key)\n        {\n            byte[] result = new byte[password.Length + 16];\n            int i = 0;\n            byte[] md5sum = null;\n            while (i < key.Length) {\n                if (i == 0) {\n                    md5sum = MbedTLS.MD5(password);\n                } else {
            int i = 0;\n            byte[] md5sum = null;\n            while (i < key.Length) {\n                if (i == 0) {\n                    md5sum = MbedTLS.MD5(password);\n                } else {\n                    md5sum.CopyTo(result, 0);\n                    password.CopyTo(result, md5sum.Length);\n                    md5sum = MbedTLS.MD5(result);\n                }
            keyLen = CipherInfo.KeySize;\n            saltLen = CipherInfo.SaltSize;\n            tagLen = CipherInfo.TagSize;\n            nonceLen = CipherInfo.NonceSize;\n        }\n        protected void InitKey(string password)\n        {\n            byte[] passbuf = Encoding.UTF8.GetBytes(password);\n            // init master key\n            if (_Masterkey == null) _Masterkey = new byte[keyLen];
        }\n        protected void InitKey(string password)\n        {\n            byte[] passbuf = Encoding.UTF8.GetBytes(password);\n            // init master key\n            if (_Masterkey == null) _Masterkey = new byte[keyLen];\n            if (_Masterkey.Length < keyLen) Array.Resize(ref _Masterkey, keyLen);\n            DeriveKey(passbuf, _Masterkey);\n            // init session key\n            if (_sessionKey == null) _sessionKey = new byte[keyLen];\n        }
{\n    [Serializable]\n    public class Server\n    {\n        public string server;\n        public int server_port;\n        public int local_port;\n        public string password;\n        public string method;\n        public string remarks;
    public class Server\n    {\n        public string server;\n        public int server_port;\n        public int local_port;\n        public string password;\n        public string method;\n        public string remarks;\n        public string FriendlyName\n        {
        public string server;\n        public int server_port;\n        public int local_port;\n        public string password;\n        public string method;\n        public string remarks;\n        public string FriendlyName\n        {\n            get\n            {
                    try\n                    {\n                        p.Kill();\n                        p.WaitForExit();\n                    }\n                    catch (Exception e)\n                    {\n                        Console.WriteLine(e.ToString());\n                    }\n                }
                    catch (Exception e)\n                    {\n                        Console.WriteLine(e.ToString());\n                    }\n                }\n                string temppath = Path.GetTempPath();\n                string polipoConfig = Resources.polipo_config; \n                polipoConfig = polipoConfig.Replace("__SOCKS_PORT__", server.local_port.ToString());\n                polipoConfig = polipoConfig.Replace("__POLIPO_BIND_IP__", configuration.shareOverLan ? "0.0.0.0" : "127.0.0.1");\n                FileManager.ByteArrayToFile(temppath + "/polipo.conf", System.Text.Encoding.UTF8.GetBytes(polipoConfig));
        // Size of receive buffer.\n        public static readonly int RecvSize = 8192;\n        public static readonly int RecvReserveSize = IVEncryptor.ONETIMEAUTH_BYTES + IVEncryptor.AUTH_BYTES; // reserve for one-time auth\n        public static readonly int BufferSize = RecvSize + RecvReserveSize + 32;\n        // public Encryptor encryptor;\n        public IEncryptor encryptor;\n        public Server server;\n        // Client  socket.
            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }\n        // inner class\n        private class ProxyTimer : Timer\n        {
                {\n                    remote = new DirectConnect();\n                    proxyEP = null;\n                }\n                ProxyTimer proxyTimer = new ProxyTimer(3000);\n                proxyTimer.AutoReset = false;\n                proxyTimer.Elapsed += proxyConnectTimer_Elapsed;\n                proxyTimer.Enabled = true;
                ProxyTimer proxyTimer = new ProxyTimer(3000);\n                proxyTimer.AutoReset = false;\n                proxyTimer.Elapsed += proxyConnectTimer_Elapsed;\n                proxyTimer.Enabled = true;\n                proxyTimer.Proxy = remote;\n                proxyTimer.DestEndPoint = SocketUtil.GetEndPoint(server.server, server.server_port);\n                proxyTimer.Server = server;\n                _proxyConnected = false;\n                // Connect to the proxy server.
                Logging.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void proxyConnectTimer_Elapsed(object sender, ElapsedEventArgs e)\n        {\n            if (_proxyConnected || _destConnected)\n            {\n                return;\n            }
            }\n        }\n        private void proxyConnectTimer_Elapsed(object sender, ElapsedEventArgs e)\n        {\n            if (_proxyConnected || _destConnected)\n            {\n                return;\n            }\n            var proxy = ((ProxyTimer)sender).Proxy;\n            Logging.Info($"Proxy {proxy.ProxyEndPoint} timed out");
        }\n        private void ProxyConnectCallback(IAsyncResult ar)\n        {\n            Server server = null;\n            if (_closed)\n            {\n                return;\n            }\n            try\n            {
                    }\n                }\n                _startConnectTime = DateTime.Now;\n                ServerTimer connectTimer = new ServerTimer(3000);\n                connectTimer.AutoReset = false;\n                connectTimer.Elapsed += destConnectTimer_Elapsed;\n                connectTimer.Enabled = true;\n                connectTimer.Server = server;\n                _destConnected = false;\n                // Connect to the remote endpoint.
        {\n            if (_destConnected)\n            {\n                return;\n            }\n            Server server = ((ServerTimer)sender).Server;\n            IStrategy strategy = controller.GetCurrentStrategy();\n            strategy?.SetFailure(server);\n            Logging.Info($"{server.FriendlyName()} timed out");
                _retryCount++;\n            }\n            else\n                Close();\n        }\n        private void ConnectCallback(IAsyncResult ar)\n        {\n            if (_closed) return;\n            try\n            {
            {\n                if (server != null)\n                {\n                    IStrategy strategy = controller.GetCurrentStrategy();\n                    strategy?.SetFailure(server);\n                }\n                Logging.LogUsefulException(e);\n                RetryConnect();\n            }\n        }
                Logging.LogUsefulException(e);\n                RetryConnect();\n            }\n        }\n        private void StartPipe()\n        {\n            if (_closed) return;\n            try\n            {\n                _startReceivingTime = DateTime.Now;
            }\n        }\n        private void StartPipe()\n        {\n            if (_closed) return;\n            try\n            {\n                _startReceivingTime = DateTime.Now;\n                remote?.BeginReceive(_remoteRecvBuffer, 0, RecvSize, SocketFlags.None, new AsyncCallback(PipeRemoteReceiveCallback), null);\n                connection?.BeginReceive(_connetionRecvBuffer, 0, RecvSize, SocketFlags.None, new AsyncCallback(PipeConnectionReceiveCallback), 
                if(connection == null) return;\n                int bytesRead = connection.EndReceive(ar);\n                _totalWrite += bytesRead;\n                if (bytesRead > 0)\n                {\n                    /*\n                     * Only the first packet contains the socks5 header, it doesn't make sense to parse every packets. \n                     * Also it's unnecessary to parse these data if we turn off the VerboseLogging.\n                     */
                                int len = _connetionRecvBuffer[1];\n                                dst_addr = System.Text.Encoding.UTF8.GetString(_connetionRecvBuffer, 2, len);\n                                dst_port = (_connetionRecvBuffer[len + 2] << 8) + _connetionRecvBuffer[len + 3];\n                                Logging.Info($"connect to {dst_addr}:{dst_port}");\n                                break;\n                            case 4: // IPv6 address, 16 bytes\n                                dst_addr = new IPAddress(_connetionRecvBuffer.Skip(1).Take(16).ToArray()).ToString();\n                                dst_port = (_connetionRecvBuffer[17] << 8) + _connetionRecvBuffer[18];\n                                Logging.Info($"connect to [{dst_addr}]:{dst_port}");
                Close();\n            }\n        }\n        private void PipeConnectionSendCallback(IAsyncResult ar)\n        {\n            if (_closed) return;\n            try\n            {\n                connection?.EndSend(ar);
using System.Security.Cryptography;\nusing System.Text;\nusing System.Threading;\nnamespace Shadowsocks.Encrypt\n{\n    public class PolarSSLEncryptor\n        : EncryptorBase, IDisposable\n    {\n        const int CIPHER_AES = 1;\n        const int CIPHER_RC4 = 2;
    public class PolarSSLEncryptor\n        : EncryptorBase, IDisposable\n    {\n        const int CIPHER_AES = 1;\n        const int CIPHER_RC4 = 2;\n        const int CIPHER_BF = 3;\n        static Dictionary<string, int[]> ciphers = new Dictionary<string, int[]> {\n            {"aes-128-cfb", new int[]{16, 16, CIPHER_AES, PolarSSL.AES_CTX_SIZE}},\n            {"aes-192-cfb", new int[]{24, 16, CIPHER_AES, PolarSSL.AES_CTX_SIZE}},\n            {"aes-256-cfb", new int[]{32, 16, CIPHER_AES, PolarSSL.AES_CTX_SIZE}},
            // connection receive buffer\n            private byte[] connetionRecvBuffer = new byte[RecvSize];\n            public void Start(byte[] firstPacket, int length, Socket socket, int targetPort)\n            {\n                this._firstPacket = firstPacket;\n                this._firstPacketLength = length;\n                this._local = socket;\n                try\n                {\n                    EndPoint remoteEP = SocketUtil.GetEndPoint("localhost", targetPort);
            private byte[] connetionRecvBuffer = new byte[RecvSize];\n            public void Start(byte[] firstPacket, int length, Socket socket, int targetPort)\n            {\n                this._firstPacket = firstPacket;\n                this._firstPacketLength = length;\n                this._local = socket;\n                try\n                {\n                    EndPoint remoteEP = SocketUtil.GetEndPoint("localhost", targetPort);\n                    _remote = SocketUtil.CreateSocket(remoteEP);\n                    _remote.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n                    // Connect to the remote endpoint.
            var r = new FakeAsyncResult(state);\n            callback?.Invoke(r);\n        }\n        public void EndConnectProxy(IAsyncResult asyncResult)\n        {\n            // do nothing\n        }\n        public void BeginConnectDest(EndPoint destEndPoint, AsyncCallback callback, object state)\n        {\n            DestEndPoint = destEndPoint;
        {\n            // do nothing\n        }\n        public void BeginConnectDest(EndPoint destEndPoint, AsyncCallback callback, object state)\n        {\n            DestEndPoint = destEndPoint;\n            if (_remote == null)\n            {\n                _remote = SocketUtil.CreateSocket(destEndPoint);\n                _remote.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n            }\n            _remote.BeginConnect(destEndPoint, callback, state);\n        }\n        public void EndConnectDest(IAsyncResult asyncResult)\n        {
            public Exception ex { get; set; }\n        }\n        private Socket _remote;\n        private const int Socks5PktMaxSize = 4 + 16 + 2;\n        private readonly byte[] _receiveBuffer = new byte[Socks5PktMaxSize];\n        public EndPoint LocalEndPoint => _remote.LocalEndPoint;\n        public EndPoint ProxyEndPoint { get; private set; }\n        public EndPoint DestEndPoint { get; private set; }\n        public void BeginConnectProxy(EndPoint remoteEP, AsyncCallback callback, object state)\n        {
        public EndPoint LocalEndPoint => _remote.LocalEndPoint;\n        public EndPoint ProxyEndPoint { get; private set; }\n        public EndPoint DestEndPoint { get; private set; }\n        public void BeginConnectProxy(EndPoint remoteEP, AsyncCallback callback, object state)\n        {\n            _remote = SocketUtil.CreateSocket(remoteEP);\n            _remote.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n            var st = new Socks5State();\n            st.Callback = callback;\n            st.AsyncState = state;\n            ProxyEndPoint = remoteEP;
        {\n            IPAddress ipAddress;\n            bool parsed = IPAddress.TryParse(host, out ipAddress);\n            if (parsed)\n            {\n                return new IPEndPoint(ipAddress, port);\n            }\n            // maybe is a domain name\n            return new DnsEndPoint2(host, port);\n        }
            bool parsed = IPAddress.TryParse(host, out ipAddress);\n            if (parsed)\n            {\n                return new IPEndPoint(ipAddress, port);\n            }\n            // maybe is a domain name\n            return new DnsEndPoint2(host, port);\n        }\n        public static Socket CreateSocket(EndPoint endPoint, ProtocolType protocolType = ProtocolType.Tcp)\n        {
                return new IPEndPoint(ipAddress, port);\n            }\n            // maybe is a domain name\n            return new DnsEndPoint2(host, port);\n        }\n        public static Socket CreateSocket(EndPoint endPoint, ProtocolType protocolType = ProtocolType.Tcp)\n        {\n            SocketType socketType;\n            switch (protocolType)\n            {
            return new DnsEndPoint2(host, port);\n        }\n        public static Socket CreateSocket(EndPoint endPoint, ProtocolType protocolType = ProtocolType.Tcp)\n        {\n            SocketType socketType;\n            switch (protocolType)\n            {\n                case ProtocolType.Tcp:\n                    socketType = SocketType.Stream;\n                    break;\n                case ProtocolType.Udp:\n                    socketType = SocketType.Dgram;\n                    break;\n                default:\n                    throw new NotSupportedException("Protocol " + protocolType + " doesn't supported!");\n            }
        {\n            SocketType socketType;\n            switch (protocolType)\n            {\n                    break;\n                case ProtocolType.Udp:\n                    socketType = SocketType.Dgram;\n                    break;\n                default:\n                    throw new NotSupportedException("Protocol " + protocolType + " doesn't supported!");\n            }\n            if (endPoint is DnsEndPoint)\n            {
            switch (protocolType)\n            {\n                    socketType = SocketType.Dgram;\n                    break;\n                default:\n                    throw new NotSupportedException("Protocol " + protocolType + " doesn't supported!");\n            }\n            if (endPoint is DnsEndPoint)\n            {\n                // use dual-mode socket\n                var socket = new Socket(AddressFamily.InterNetworkV6, socketType, protocolType);\n                socket.SetSocketOption(SocketOptionLevel.IPv6, (SocketOptionName)27, false);\n                return socket;\n            }
                    throw new NotSupportedException("Protocol " + protocolType + " doesn't supported!");\n            }\n            if (endPoint is DnsEndPoint)\n            {\n                // use dual-mode socket\n                var socket = new Socket(AddressFamily.InterNetworkV6, socketType, protocolType);\n                socket.SetSocketOption(SocketOptionLevel.IPv6, (SocketOptionName)27, false);\n                return socket;\n            }\n            else\n            {
        {\n            try\n            {\n                string response = e.Result;\n                JArray result = JArray.Parse(response);\n                List<Asset> asserts = new List<Asset>();\n                if (result != null)\n                {\n                    foreach (JObject release in result)\n                    {
                {\n                    foreach (JObject release in result)\n                    {\n                        if ((bool)release["prerelease"])\n                        {\n                            continue;\n                        }\n                        foreach (JObject asset in (JArray)release["assets"])\n                        {
                        if ((bool)release["prerelease"])\n                        {\n                            continue;\n                        }\n                        foreach (JObject asset in (JArray)release["assets"])\n                        {\n                            Asset ass = new Asset();\n                            ass.Parse(asset);\n                            if (ass.IsNewVersion(Version))\n                            {
        }\n        private void Http_DownloadFileCompleted(object sender, System.ComponentModel.AsyncCompletedEventArgs e)\n        {\n            try\n            {\n                if (e.Error != null)\n                {\n                    Logging.LogUsefulException(e.Error);\n                    return;\n                }
            public bool IsNewVersion(string currentVersion)\n            {\n                if (prerelease)\n                {\n                    return false;\n                }\n                if (version == null)\n                {\n                    return false;\n                }
        }\n        private void UpdateSystemProxy()\n        {\n            if (_config.enabled)\n            {\n                SystemProxy.Enable();\n            }\n            else\n            {
                    "Shadowsocks Error", MessageBoxButtons.OK, MessageBoxIcon.Error);\n                Application.Exit();\n            }\n        }\n        private static void SystemEvents_PowerModeChanged(object sender, PowerModeChangedEventArgs e)\n        {\n            switch (e.Mode)\n            {\n                case PowerModes.Resume:\n                    Logging.Info("os wake up");
                new LineReader(_remote, OnLineRead, OnException, OnFinish, Encoding.UTF8, HTTP_CRLF, 1024, new FakeAsyncResult(ar, state));\n            }\n            catch (Exception ex)\n            {\n                state.ex = ex;\n                state.Callback?.Invoke(new FakeAsyncResult(ar, state));\n            }\n        }\n        private void OnFinish(byte[] lastBytes, int index, int length, object state)\n        {
            catch (Exception ex)\n            {\n                state.ex = ex;\n                state.Callback?.Invoke(new FakeAsyncResult(ar, state));\n            }\n        }\n        private void OnFinish(byte[] lastBytes, int index, int length, object state)\n        {\n            if (!_established)\n            {
                st.innerState.ex = new Exception(I18N.GetString("Proxy request failed"));\n            }\n            st.innerState.Callback?.Invoke(st);\n        }\n        private void OnException(Exception ex, object state)\n        {\n            var st = (FakeAsyncResult) state;\n            st.innerState.ex = ex;
                    }\n                }\n                if (hostMatch && pathMatch)\n                {
            Assert.IsTrue(UpdateChecker.Asset.CompareVersion("1.2", "1.3") < 0);\n            Assert.IsTrue(UpdateChecker.Asset.CompareVersion("1.3", "1.2") > 0);\n            Assert.IsTrue(UpdateChecker.Asset.CompareVersion("1.3", "1.3") == 0);\n            Assert.IsTrue(UpdateChecker.Asset.CompareVersion("1.2.1", "1.2") > 0);\n            Assert.IsTrue(UpdateChecker.Asset.CompareVersion("2.3.1", "2.4") < 0);\n            Assert.IsTrue(UpdateChecker.Asset.CompareVersion("1.3.2", "1.3.1") > 0);\n        }\n        private void RunEncryptionRound(IEncryptor encryptor, IEncryptor decryptor)\n        {\n            byte[] plain = new byte[16384];
        }\n        private void RunEncryptionRound(IEncryptor encryptor, IEncryptor decryptor)\n        {\n            byte[] plain = new byte[16384];\n            byte[] cipher = new byte[plain.Length + 16];\n            byte[] plain2 = new byte[plain.Length + 16];\n            int outLen = 0;\n            int outLen2 = 0;\n            var random = new Random();\n            random.NextBytes(plain);
            int outLen2 = 0;\n            var random = new Random();\n            random.NextBytes(plain);\n            encryptor.Encrypt(plain, plain.Length, cipher, out outLen);\n            decryptor.Decrypt(cipher, outLen, plain2, out outLen2);\n            Assert.AreEqual(plain.Length, outLen2);\n            for (int j = 0; j < plain.Length; j++)\n            {\n                Assert.AreEqual(plain[j], plain2[j]);\n            }
            {\n                Assert.AreEqual(plain[j], plain2[j]);\n            }\n            encryptor.Encrypt(plain, 1000, cipher, out outLen);\n            decryptor.Decrypt(cipher, outLen, plain2, out outLen2);\n            Assert.AreEqual(1000, outLen2);\n            for (int j = 0; j < outLen2; j++)\n            {\n                Assert.AreEqual(plain[j], plain2[j]);\n            }
using System.Net;\nnamespace Shadowsocks.Encryption\n{\n    public abstract class IVEncryptor\n        : EncryptorBase\n    {\n        public const int MAX_KEY_LENGTH = 64;\n        public const int MAX_IV_LENGTH = 16;\n        public const int ONETIMEAUTH_FLAG = 0x10;\n        public const int ADDRTYPE_MASK = 0xF;
    public abstract class IVEncryptor\n        : EncryptorBase\n    {\n        public const int MAX_KEY_LENGTH = 64;\n        public const int MAX_IV_LENGTH = 16;\n        public const int ONETIMEAUTH_FLAG = 0x10;\n        public const int ADDRTYPE_MASK = 0xF;\n        public const int ONETIMEAUTH_BYTES = 16;\n        public const int ONETIMEAUTH_KEYBYTES = 32;\n        public const int HASH_BYTES = 4;\n        public const int CLEN_BYTES = 2;
                len = 4 + nameLen; // atyp (1 bytes) + name length (1 bytes) + name (n bytes) + port (2 bytes)\n            }\n            else if (atyp == 4)\n            {\n                len = 19; // atyp (1 bytes) + ipv6 (16 bytes) + port (2 bytes)\n            }\n            if (len == 0 || len > length)\n                throw new Exception($"invalid header with addr type {atyp}");\n            return len;\n        }
            int size = len + AUTH_BYTES;\n            if (buf_size < (size + offset))\n                throw new Exception("failed to generate hash:  buffer size insufficient");\n            if (_keyBuffer == null)\n            {\n                _keyBuffer = new byte[MAX_IV_LENGTH + 4];\n                Buffer.BlockCopy(_encryptIV, 0, _keyBuffer, 0, ivLen);\n            }\n            byte[] counter_bytes = BitConverter.GetBytes((uint)IPAddress.HostToNetworkOrder((int)counter));\n            Buffer.BlockCopy(counter_bytes, 0, _keyBuffer, ivLen, 4);
                throw new Exception("failed to generate hash:  buffer size insufficient");\n            if (_keyBuffer == null)\n            {\n                _keyBuffer = new byte[MAX_IV_LENGTH + 4];\n                Buffer.BlockCopy(_encryptIV, 0, _keyBuffer, 0, ivLen);\n            }\n            byte[] counter_bytes = BitConverter.GetBytes((uint)IPAddress.HostToNetworkOrder((int)counter));\n            Buffer.BlockCopy(counter_bytes, 0, _keyBuffer, ivLen, 4);\n            byte[] hash = new byte[HASH_BYTES];\n            byte[] tmp = new byte[len];\n            Buffer.BlockCopy(buf, offset, tmp, 0, len);\n            Sodium.crypto_generichash(hash, HASH_BYTES, tmp, (ulong)len, _keyBuffer, (uint)_keyBuffer.Length);\n            Buffer.BlockCopy(buf, offset, buf, offset + AUTH_BYTES, len);\n            Buffer.BlockCopy(hash, 0, buf, offset + CLEN_BYTES, HASH_BYTES);\n            byte[] clen = BitConverter.GetBytes((ushort)IPAddress.HostToNetworkOrder((short)len));\n            Buffer.BlockCopy(clen, 0, buf, offset, CLEN_BYTES);\n            counter++;
                lock (tempbuf)\n                {
                lock (tempbuf)\n                {\n                        ss_gen_hash(buf, ref offset, ref len, buf.Length);\n                        length = headLen + ONETIMEAUTH_BYTES + len;\n                    }\n                    cipherUpdate(true, length, buf, tempbuf);\n                    outlength = length + ivLen;\n                    Buffer.BlockCopy(tempbuf, 0, outbuf, ivLen, length);\n                }\n            }\n            else\n            {
                if (!parsed)\n                {\n                    IPHostEntry ipHostInfo = Dns.GetHostEntry(server.server);\n                    ipAddress = ipHostInfo.AddressList[0];\n                }\n                _remoteEndPoint = new IPEndPoint(ipAddress, server.server_port);\n                _remote = new Socket(_remoteEndPoint.AddressFamily, SocketType.Dgram, ProtocolType.Udp);\n            }\n            public void Send(byte[] data, int length)\n            {
                    ipAddress = ipHostInfo.AddressList[0];\n                }\n                _remoteEndPoint = new IPEndPoint(ipAddress, server.server_port);\n                _remote = new Socket(_remoteEndPoint.AddressFamily, SocketType.Dgram, ProtocolType.Udp);\n            }\n            public void Send(byte[] data, int length)\n            {\n                IEncryptor encryptor = EncryptorFactory.GetEncryptor(_server.method, _server.password);\n                byte[] dataIn = new byte[length - 3];\n                Array.Copy(data, 3, dataIn, 0, length - 3);
                _remoteEndPoint = new IPEndPoint(ipAddress, server.server_port);\n                _remote = new Socket(_remoteEndPoint.AddressFamily, SocketType.Dgram, ProtocolType.Udp);\n            }\n            public void Send(byte[] data, int length)\n            {\n                IEncryptor encryptor = EncryptorFactory.GetEncryptor(_server.method, _server.password);\n                byte[] dataIn = new byte[length - 3];\n                Array.Copy(data, 3, dataIn, 0, length - 3);\n                byte[] dataOut = new byte[length - 3 + 16];\n                int outlen;
            this.label2 = new System.Windows.Forms.Label();\n            this.label3 = new System.Windows.Forms.Label();\n            this.label4 = new System.Windows.Forms.Label();\n            this.textBox1 = new System.Windows.Forms.TextBox();\n            this.textBox2 = new System.Windows.Forms.TextBox();\n            this.textBox3 = new System.Windows.Forms.TextBox();\n            this.textBox4 = new System.Windows.Forms.TextBox();\n            this.panel1 = new System.Windows.Forms.Panel();\n            this.button2 = new System.Windows.Forms.Button();\n            this.button1 = new System.Windows.Forms.Button();
            this.panel1 = new System.Windows.Forms.Panel();\n            this.button2 = new System.Windows.Forms.Button();\n            this.button1 = new System.Windows.Forms.Button();\n            this.tableLayoutPanel2 = new System.Windows.Forms.TableLayoutPanel();\n            this.notifyIcon1 = new System.Windows.Forms.NotifyIcon(this.components);\n            this.contextMenuStrip1 = new System.Windows.Forms.ContextMenuStrip(this.components);\n            this.ConfigItem = new System.Windows.Forms.ToolStripMenuItem();\n            this.QuitItem = new System.Windows.Forms.ToolStripMenuItem();\n            this.tableLayoutPanel1.SuspendLayout();\n            this.panel1.SuspendLayout();
            this.panel1.AutoSize = true;\n            this.panel1.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;\n            this.panel1.Controls.Add(this.button2);\n            this.panel1.Controls.Add(this.button1);
            this.Controls.Add(this.tableLayoutPanel2);\n            this.Controls.Add(this.tableLayoutPanel1);\n            this.Name = "Form1";\n            this.Text = "Shadowsocks";\n            this.FormClosed += new System.Windows.Forms.FormClosedEventHandler(this.Form1_FormClosed);\n            this.tableLayoutPanel1.ResumeLayout(false);\n            this.tableLayoutPanel1.PerformLayout();\n            this.panel1.ResumeLayout(false);
            btnRegisterAll.Text = I18N.GetString("Reg All");\n            this.Text = I18N.GetString("Edit Hotkeys...");\n        }\n        private void controller_ConfigChanged(object sender, EventArgs e)\n        {\n            LoadCurrentConfiguration();\n        }\n        private void LoadCurrentConfiguration()\n        {\n            _modifiedHotkeyConfig = _controller.GetConfigurationCopy().hotkey;
            PrepareForHotkey(tb, out callBack, out lb);\n            UnregPrevHotkey(callBack);\n        }\n        private void CancelButton_Click(object sender, EventArgs e)\n        {\n            this.Close();\n        }\n        private void OKButton_Click(object sender, EventArgs e)\n        {\n            // try to register, notify to change settings if failed
            // try to register, notify to change settings if failed\n            if (!RegisterAllHotkeys(out _)) // declare out as an inline discard variable\n            {\n                MessageBox.Show(I18N.GetString("Register hotkey failed"));\n            }\n            // All check passed, saving\n            SaveConfig();\n            this.Close();\n        }\n        private void RegisterAllButton_Click(object sender, EventArgs e)\n        {
            SaveConfig();\n            this.Close();\n        }\n        private void RegisterAllButton_Click(object sender, EventArgs e)\n        {\n            RegisterAllHotkeys(out _);  // declare out as an inline discard variable\n        }\n        private bool RegisterAllHotkeys(out string failureInfoStr)\n        {\n            bool isSuccess = true;
            StringBuilder failureInfo = new StringBuilder();\n            foreach (var tb in _allTextBoxes)\n            {\n                if (tb.Text.IsNullOrEmpty())\n                {\n                    continue;\n                }\n                if (!TryRegHotkey(tb))\n                {\n                    isSuccess = false;
        public void Start(Configuration configuration)\n        {\n            if (_process == null)\n            {\n                Process[] existingPrivoxy = Process.GetProcessesByName("ss_privoxy");\n                foreach (Process p in existingPrivoxy.Where(IsChildProcess))\n                {\n                    KillProcess(p);\n                }\n                string privoxyConfig = Resources.privoxy_conf;
            {\n                Process[] existingPrivoxy = Process.GetProcessesByName("ss_privoxy");\n                foreach (Process p in existingPrivoxy.Where(IsChildProcess))\n                {\n                    KillProcess(p);\n                }\n                string privoxyConfig = Resources.privoxy_conf;\n                _runningPort = GetFreePort();\n                privoxyConfig = privoxyConfig.Replace("__SOCKS_PORT__", configuration.localPort.ToString());\n                privoxyConfig = privoxyConfig.Replace("__PRIVOXY_BIND_PORT__", _runningPort.ToString());
            {\n                /*\n                 * Sometimes Process.GetProcessesByName will return some processes that\n                 * are already dead, and that will cause exceptions here.\n                 * We could simply ignore those exceptions.\n                 */\n                Logging.LogUsefulException(ex);\n                return false;\n            }\n        }
                 */\n                Logging.LogUsefulException(ex);\n                return false;\n            }\n        }\n        private int GetFreePort()\n        {\n            int defaultPort = 8123;\n            try\n            {\n                // TCP stack please do me a favor
        }\n        public class UDPState\n        {\n            public Socket socket;\n            public byte[] buffer = new byte[4096];
        }\n        public void Start(Configuration config)\n        {\n            this._config = config;\n            this._shareOverLAN = config.shareOverLan;\n            if (CheckIfPortInUse(_config.localPort))\n                throw new Exception(I18N.GetString("Port {0} already in use", _config.localPort));\n            try\n            {\n                // Create a TCP/IP socket.
                throw new Exception(I18N.GetString("Port {0} already in use", _config.localPort));\n            try\n            {\n                // Create a TCP/IP socket.\n                _tcpSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);\n                _udpSocket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);\n                _tcpSocket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, true);\n                _udpSocket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, true);\n                IPEndPoint localEndPoint = null;\n                localEndPoint = _shareOverLAN
                    : new IPEndPoint(IPAddress.Loopback, _config.localPort);\n                _tcpSocket.Bind(localEndPoint);\n                _udpSocket.Bind(localEndPoint);\n                _tcpSocket.Listen(1024);\n                // Start an asynchronous socket to listen for connections.\n                Logging.Info($"Shadowsocks started ({UpdateChecker.Version})");\n                if (_config.isVerboseLogging)\n                {\n                    Logging.Info(Encryption.EncryptorFactory.DumpRegisteredEncryptor());\n                }\n                _tcpSocket.BeginAccept(new AsyncCallback(AcceptCallback), _tcpSocket);
                byte[] dataIn = new byte[length - 3];\n                Array.Copy(data, 3, dataIn, 0, length - 3);\n                byte[] dataOut = new byte[65536];  // enough space for AEAD ciphers\n                int outlen;\n                encryptor.EncryptUDP(dataIn, length - 3, dataOut, out outlen);\n                Logging.Debug(_localEndPoint, _remoteEndPoint, outlen, "UDP Relay");\n                _remote?.SendTo(dataOut, outlen, SocketFlags.None, _remoteEndPoint);\n            }\n            public void Receive()\n            {
            {\n                EndPoint remoteEndPoint = new IPEndPoint(IPAddress.Any, 0);\n                Logging.Debug($"++++++Receive Server Port, size:" + _buffer.Length);\n                _remote?.BeginReceiveFrom(_buffer, 0, _buffer.Length, 0, ref remoteEndPoint, new AsyncCallback(RecvFromCallback), null);\n            }\n            public void RecvFromCallback(IAsyncResult ar)\n            {\n                try\n                {\n                    if (_remote == null) return;
            if (_udpSocket != null)\n            {\n                _udpSocket.Close();\n                _udpSocket = null;\n            }\n            _services.ForEach(s=>s.Stop());\n        }\n        public void RecvFromCallback(IAsyncResult ar)\n        {\n            UDPState state = (UDPState)ar.AsyncState;
        }\n        public void RecvFromCallback(IAsyncResult ar)\n        {\n            UDPState state = (UDPState)ar.AsyncState;\n            try\n            {\n                int bytesRead = _udpSocket.EndReceiveFrom(ar, ref state.remoteEndPoint);\n                foreach (IService service in _services)\n                {
                pacServer = new PACServer();\n                pacServer.PACFileChanged += pacServer_PACFileChanged;\n                pacServer.Start(_config);\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine(e.Message);\n            }\n            UpdateSystemProxy();\n        }
            }\n        }\n        public void TouchUserRuleFile()\n        {\n            string userRuleFilename = _pacServer.TouchUserRuleFile();\n            if (UserRuleFileReadyToOpen != null)\n            {\n                UserRuleFileReadyToOpen(this, new PathEventArgs() { Path = userRuleFilename });\n            }\n        }
            if (_remote == null)\n            {\n                _remote = new Socket(remoteEP.AddressFamily, SocketType.Stream, ProtocolType.Tcp);\n                _remote.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n            }\n            DestEndPoint = remoteEP;\n            _remote.BeginConnect(remoteEP, callback, state);\n        }\n        public void EndConnectDest(IAsyncResult asyncResult)\n        {
            DestEndPoint = remoteEP;\n            _remote.BeginConnect(remoteEP, callback, state);\n        }\n        public void EndConnectDest(IAsyncResult asyncResult)\n        {\n            _remote.EndConnect(asyncResult);\n        }\n        public void BeginSend(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state)\n        {
        {\n            _remote.BeginSend(buffer, offset, size, socketFlags, callback, state);\n        }\n        public int EndSend(IAsyncResult asyncResult)\n        {\n            return _remote.EndSend(asyncResult);\n        }\n        public void BeginReceive(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state)\n        {
        {\n            var state = ((FakeAsyncResult)asyncResult).innerState;\n            if (state.ex != null)\n            {\n                throw state.ex;\n            }\n        }\n        public void BeginSend(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state)\n        {
        {\n            _remote.BeginSend(buffer, offset, size, socketFlags, callback, state);\n        }\n        public int EndSend(IAsyncResult asyncResult)\n        {\n            return _remote.EndSend(asyncResult);\n        }\n        public void BeginReceive(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state)\n        {
            }\n            public void Send(byte[] data, int length)\n            {\n                IEncryptor encryptor = EncryptorFactory.GetEncryptor(_server.method, _server.password, _server.auth, true);\n                byte[] dataIn = new byte[length - 3 + IVEncryptor.ONETIMEAUTH_BYTES];\n                Array.Copy(data, 3, dataIn, 0, length - 3);\n                byte[] dataOut = new byte[length - 3 + 16 + IVEncryptor.ONETIMEAUTH_BYTES];\n                int outlen;\n                encryptor.Encrypt(dataIn, length - 3, dataOut, out outlen);\n                Logging.Debug(_localEndPoint, _remoteEndPoint, outlen, "UDP Relay");
                byte[] dataOut = new byte[length - 3 + 16 + IVEncryptor.ONETIMEAUTH_BYTES];\n                int outlen;\n                encryptor.Encrypt(dataIn, length - 3, dataOut, out outlen);\n                Logging.Debug(_localEndPoint, _remoteEndPoint, outlen, "UDP Relay");\n                _remote.SendTo(dataOut, outlen, SocketFlags.None, _remoteEndPoint);\n            }\n            public void Receive()\n            {\n                EndPoint remoteEndPoint = new IPEndPoint(IPAddress.Any, 0);\n                Logging.Debug($"++++++Receive Server Port, size:" + _buffer.Length);
                    EndPoint remoteEndPoint = new IPEndPoint(IPAddress.Any, 0);\n                    int bytesRead = _remote.EndReceiveFrom(ar, ref remoteEndPoint);\n                    byte[] dataOut = new byte[bytesRead];\n                    int outlen;\n                    IEncryptor encryptor = EncryptorFactory.GetEncryptor(_server.method, _server.password, _server.auth, true);\n                    encryptor.Decrypt(_buffer, bytesRead, dataOut, out outlen);\n                    byte[] sendBuf = new byte[outlen + 3];\n                    Array.Copy(dataOut, 0, sendBuf, 3, outlen);\n                    Logging.Debug(_localEndPoint, _remoteEndPoint, outlen, "UDP Relay");
﻿using System;\nusing System.Diagnostics;\nusing System.IO;\nusing Shadowsocks.Controller;\nusing Shadowsocks.Properties;\nusing Shadowsocks.Model;
                var pac_url = _userSettings.PacUrl ?? "-";\n                arguments = $"set {flags} {proxy_server} {bypass_list} {pac_url}";\n                // have to get new settings\n                _userSettings.UserSettingsRecorded = false;\n            }\n            Save();\n            ExecSysproxy(arguments);\n        }\n        private static void ExecSysproxy(string arguments)\n        {
                _userSettings.UserSettingsRecorded = false;\n            }\n            Save();\n            ExecSysproxy(arguments);\n        }\n        private static void ExecSysproxy(string arguments)\n        {\n            using (var process = new Process())\n            {
            ExecSysproxy(arguments);\n        }\n        private static void ExecSysproxy(string arguments)\n        {\n            using (var process = new Process())\n            {\n                process.StartInfo.StandardOutputEncoding = Encoding.Unicode;\n                process.StartInfo.StandardErrorEncoding = Encoding.Unicode;\n                process.StartInfo.CreateNoWindow = true;\n                process.Start();\n                var stderr = process.StandardError.ReadToEnd();\n                var stdout = process.StandardOutput.ReadToEnd();\n                process.WaitForExit();\n                var exitCode = process.ExitCode;\n                if (exitCode != (int)RET_ERRORS.RET_NO_ERROR)\n                {
            using (var process = new Process())\n            {\n                var stderr = process.StandardError.ReadToEnd();\n                var stdout = process.StandardOutput.ReadToEnd();\n                process.WaitForExit();\n                var exitCode = process.ExitCode;\n                if (exitCode != (int)RET_ERRORS.RET_NO_ERROR)\n                {\n                    throw new ProxyException(stderr);\n                }\n                if (arguments == "query")\n                {\n                    if (stdout.IsNullOrWhiteSpace() || stdout.IsNullOrEmpty())\n                    {
                var exitCode = process.ExitCode;\n                if (exitCode != (int)RET_ERRORS.RET_NO_ERROR)\n                {\n                    throw new ProxyException(stderr);\n                }\n                if (arguments == "query")\n                {\n                    if (stdout.IsNullOrWhiteSpace() || stdout.IsNullOrEmpty())\n                    {\n                        // we cannot get user settings\n                        throw new ProxyException("failed to query wininet settings");\n                    }
        private void UpdateServersMenu()\n        {\n            var items = ServersItem.MenuItems;\n            while (items[0] != SeperatorItem)\n            {\n                items.RemoveAt(0);\n            }\n            int i = 0;\n            foreach (var strategy in controller.GetStrategies())\n            {
                item.Tag = strategy.ID;\n                item.Click += AStrategyItem_Click;\n                items.Add(i, item);\n                i++;\n            }\n            Configuration configuration = controller.GetConfigurationCopy();\n            foreach (var server in configuration.configs)\n            {\n                MenuItem item = new MenuItem(server.FriendlyName());
    {\n        ShadowsocksController _controller;\n        Random _random;\n        public BalancingStrategy(ShadowsocksController controller)\n        {\n            _controller = controller;\n            _random = new Random();\n        }\n        public string Name\n        {
        {\n            _controller = controller;\n            _random = new Random();\n        }\n        public string Name\n        {\n            get\n            {\n                return "Load Balance";\n            }\n        }\n        public string ID\n        {
    public interface IStrategy\n    {\n        string Name { get; }\n        string ID { get; }\n        Server GetAServer(IStrategyCallerType type, IPEndPoint localIPEndPoint);
            this.tableLayoutPanel1.Controls.Add(this.label1, 0, 0);\n            this.tableLayoutPanel1.Controls.Add(this.label2, 0, 1);\n            this.tableLayoutPanel1.Controls.Add(this.ProxyPortTextBox, 1, 4);\n            this.tableLayoutPanel1.Controls.Add(this.label4, 0, 4);\n            this.tableLayoutPanel1.Controls.Add(this.label3, 0, 2);\n            this.tableLayoutPanel1.Controls.Add(this.IPTextBox, 1, 0);\n            this.tableLayoutPanel1.Controls.Add(this.ServerPortTextBox, 1, 1);\n            this.tableLayoutPanel1.Controls.Add(this.PasswordTextBox, 1, 2);\n            this.tableLayoutPanel1.Controls.Add(this.label5, 0, 3);\n            this.tableLayoutPanel1.Controls.Add(this.EncryptionSelect, 1, 3);
            this.tableLayoutPanel1.Controls.Add(this.label5, 0, 3);\n            this.tableLayoutPanel1.Controls.Add(this.EncryptionSelect, 1, 3);\n            this.RemarksTextBox.Location = new System.Drawing.Point(110, 194);\n            this.RemarksTextBox.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);\n            this.RemarksTextBox.Name = "RemarksTextBox";
            this.RemarksTextBox.Name = "RemarksTextBox";\n            this.label6.Location = new System.Drawing.Point(27, 197);\n            this.label6.Margin = new System.Windows.Forms.Padding(5, 0, 5, 0);\n            this.label6.Name = "label6";
            this.label6.Name = "label6";\n            this.label1.Location = new System.Drawing.Point(26, 15);\n            this.label1.Margin = new System.Windows.Forms.Padding(5, 0, 5, 0);\n            this.label1.Name = "label1";
            this.label1.Name = "label1";\n            this.label2.Location = new System.Drawing.Point(12, 51);\n            this.label2.Margin = new System.Windows.Forms.Padding(5, 0, 5, 0);\n            this.label2.Name = "label2";
            this.label2.Name = "label2";\n            this.ProxyPortTextBox.Location = new System.Drawing.Point(110, 158);\n            this.ProxyPortTextBox.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);\n            this.ProxyPortTextBox.Name = "ProxyPortTextBox";
            this.ProxyPortTextBox.Name = "ProxyPortTextBox";\n            this.label4.Location = new System.Drawing.Point(20, 161);\n            this.label4.Margin = new System.Windows.Forms.Padding(5, 0, 5, 0);\n            this.label4.Name = "label4";
            this.label4.Name = "label4";\n            this.label3.Location = new System.Drawing.Point(22, 87);\n            this.label3.Margin = new System.Windows.Forms.Padding(5, 0, 5, 0);\n            this.label3.Name = "label3";
            this.label3.Name = "label3";\n            this.IPTextBox.Location = new System.Drawing.Point(110, 12);\n            this.IPTextBox.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);\n            this.IPTextBox.Name = "IPTextBox";
            this.IPTextBox.Name = "IPTextBox";\n            this.ServerPortTextBox.Location = new System.Drawing.Point(110, 48);\n            this.ServerPortTextBox.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);\n            this.ServerPortTextBox.Name = "ServerPortTextBox";
            this.ServerPortTextBox.Name = "ServerPortTextBox";\n            this.PasswordTextBox.Location = new System.Drawing.Point(110, 84);\n            this.PasswordTextBox.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);\n            this.PasswordTextBox.Name = "PasswordTextBox";\n            this.PasswordTextBox.PasswordChar = '*';
            this.label5.Name = "label5";
            this.EncryptionSelect.Location = new System.Drawing.Point(110, 120);\n            this.EncryptionSelect.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);\n            this.EncryptionSelect.Name = "EncryptionSelect";
            this.EncryptionSelect.Name = "EncryptionSelect";\n            this.panel2.Location = new System.Drawing.Point(246, 263);\n            this.panel2.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);\n            this.panel2.Name = "panel2";\n            this.panel2.Size = new System.Drawing.Size(0, 0);\n            this.panel2.TabIndex = 1;\n            // \n            // OKButton\n            // \n            this.OKButton.DialogResult = System.Windows.Forms.DialogResult.OK;
            this.OKButton.DialogResult = System.Windows.Forms.DialogResult.OK;\n            this.OKButton.Location = new System.Drawing.Point(6, 6);\n            this.OKButton.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);\n            this.OKButton.Name = "OKButton";
            this.MyCancelButton.Name = "MyCancelButton";
            this.MyCancelButton.Name = "MyCancelButton";\n            this.autoStartup,\n            this.ShareOverLANItem,
            this.MyCancelButton.Name = "MyCancelButton";\n            this.autoStartup,\n            this.ShareOverLANItem,\n            this.ServersItem,\n            this.menuItem4,
            this.autoStartup,\n            this.ShareOverLANItem,\n            this.ServersItem,\n            this.menuItem4,\n            this.editPACFileItem,\n            this.QRCodeItem,\n            this.ShowLogItem,\n            this.aboutItem,\n            this.menuItem3,\n            this.quitItem});
            this.aboutItem,\n            this.menuItem3,\n            this.quitItem});\nthis.contextMenu1.Popup += new System.EventHandler(this.contextMenu1_Popup);\n            // \n            // enableItem\n            // \n            this.enableItem.Index = 0;\n            this.enableItem.Text = "&Enable";\n            this.enableItem.Click += new System.EventHandler(this.EnableItem_Click);\n            // \n            // ShareOverLANItem\n            // 
this.contextMenu1.Popup += new System.EventHandler(this.contextMenu1_Popup);\n            this.enableItem.Index = 0;\n            this.enableItem.Text = "&Enable";\n            this.enableItem.Click += new System.EventHandler(this.EnableItem_Click);\n            // \n            // ShareOverLANItem\n            // \nthis.ShareOverLANItem.Index = 2;\n            this.ShareOverLANItem.Text = "Share over LAN";\n            this.ShareOverLANItem.Click += new System.EventHandler(this.ShareOverLANItem_Click);\n            // \n            // ServersItem\n            // 
            this.SeperatorItem.Text = "-";\n            // \n            // ConfigItem\n            // \n            this.ConfigItem.Index = 1;\n            this.ConfigItem.Text = "Edit Servers...";\n            this.ConfigItem.Click += new System.EventHandler(this.Config_Click);\n            // \n            // menuItem4\n            // 
            // menuItem4\n            // \n            this.DeleteButton.Location = new System.Drawing.Point(150, 6);\n            this.DeleteButton.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);\n            this.DeleteButton.Name = "DeleteButton";
            this.DeleteButton.Name = "DeleteButton";\n            this.AddButton.Location = new System.Drawing.Point(6, 6);\n            this.AddButton.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);\n            this.AddButton.Name = "AddButton";
            this.AddButton.Name = "AddButton";\n            this.ServerGroupBox.Location = new System.Drawing.Point(334, 18);\n            this.ServerGroupBox.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);\n            this.ServerGroupBox.Name = "ServerGroupBox";
            this.AddButton.Name = "AddButton";\n            this.ServerGroupBox.Location = new System.Drawing.Point(334, 18);\n            this.ServerGroupBox.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);\n            this.ServerGroupBox.Name = "ServerGroupBox";\n            this.ServerGroupBox.Padding = new System.Windows.Forms.Padding(5, 5, 5, 5);\n            this.ServerGroupBox.Size = new System.Drawing.Size(383, 307);\n            this.ServerGroupBox.TabIndex = 6;\n            this.ServerGroupBox.TabStop = false;\n            this.ServerGroupBox.Text = "Server";\n            // \n            // ServersListBox\n            // \n            this.ServersListBox.FormattingEnabled = true;
            // ServersListBox\n            // \n            this.ServersListBox.FormattingEnabled = true;\n            this.ServersListBox.ItemHeight = 20;\n            this.ServersListBox.Location = new System.Drawing.Point(18, 18);\n            this.ServersListBox.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);\n            this.ServersListBox.Name = "ServersListBox";
        private void ConfigForm_Shown(object sender, EventArgs e)\n        {\n            IPTextBox.Focus();\n        }\n        private void QRCodeItem_Click(object sender, EventArgs e)\n        {\n            QRCodeForm qrCodeForm = new QRCodeForm(controller.GetQRCodeForCurrentServer());\n            qrCodeForm.Icon = this.Icon;\n            qrCodeForm.Show();\n        }
            QRCodeForm qrCodeForm = new QRCodeForm(controller.GetQRCodeForCurrentServer());\n            qrCodeForm.Icon = this.Icon;\n            qrCodeForm.Show();\n        }\nprivate void autoStartup_Click(object sender, EventArgs e) {\nautoStartup.Checked = !autoStartup.Checked;\nif (!AutoStartup.Set(autoStartup.Checked)) {\nMessageBox.Show("Failed to edit registry");\n}\n}


        public bool NewVersionFound;\n        public string LatestVersionNumber;\n        public string LatestVersionURL;\n        public event EventHandler CheckUpdateCompleted;\n        public const string Version = "2.5.8";\n        public void CheckUpdate(Configuration config)\n        {
        public string LatestVersionURL;\n        public event EventHandler CheckUpdateCompleted;\n        public const string Version = "2.5.8";\n        public void CheckUpdate(Configuration config)\n        {\n            http.Proxy = new WebProxy(IPAddress.Loopback.ToString(), config.localPort);\n            http.DownloadStringCompleted += http_DownloadStringCompleted;\n            http.DownloadStringAsync(new Uri(UpdateURL));\n        }\n        public static int CompareVersion(string l, string r)\n        {\n            var ls = l.Split('.');\n            var rs = r.Split('.');\n            for (int i = 0; i < Math.Max(ls.Length, rs.Length); i++)\n            {
        public event EventHandler CheckUpdateCompleted;\n        public const string Version = "2.5.8";\n        public void CheckUpdate(Configuration config)\n        {\n        }\n        public static int CompareVersion(string l, string r)\n        {\n            var ls = l.Split('.');\n            var rs = r.Split('.');\n            for (int i = 0; i < Math.Max(ls.Length, rs.Length); i++)\n            {\n                int lp = (i < ls.Length) ? int.Parse(ls[i]) : 0;\n                int rp = (i < rs.Length) ? int.Parse(rs[i]) : 0;\n                if (lp != rp)\n                {\n                    return lp - rp;\n                }\n            }
        {\n            var ls = l.Split('.');\n            var rs = r.Split('.');\n            for (int i = 0; i < Math.Max(ls.Length, rs.Length); i++)\n            {\n                int lp = (i < ls.Length) ? int.Parse(ls[i]) : 0;\n                int rp = (i < rs.Length) ? int.Parse(rs[i]) : 0;\n                if (lp != rp)\n                {\n                    return lp - rp;\n                }\n            }\n            return 0;\n        }\n        public class VersionComparer : IComparer<string>\n        {\n            // Calls CaseInsensitiveComparer.Compare with the parameters reversed. \n            public int Compare(string x, string y)\n            {
            for (int i = 0; i < Math.Max(ls.Length, rs.Length); i++)\n            {\n                if (lp != rp)\n                {\n                    return lp - rp;\n                }\n            }\n            return 0;\n        }\n        public class VersionComparer : IComparer<string>\n        {\n            // Calls CaseInsensitiveComparer.Compare with the parameters reversed. \n            public int Compare(string x, string y)\n            {\n                return CompareVersion(ParseVersionFromURL(x), ParseVersionFromURL(y));\n            }
                return CompareVersion(ParseVersionFromURL(x), ParseVersionFromURL(y));\n            }\n            }\n            string currentVersion = Version;\n            return CompareVersion(version, currentVersion) > 0;\n        }\n        private void http_DownloadStringCompleted(object sender, DownloadStringCompletedEventArgs e)\n        {\n            try\n            {\n                string response = e.Result;\n                JsonArray result = (JsonArray)SimpleJson.SimpleJson.DeserializeObject(e.Result);
                JsonArray result = (JsonArray)SimpleJson.SimpleJson.DeserializeObject(e.Result);\n                List<string> versions = new List<string>();\n                foreach (JsonObject release in result)\n                {\n                    if ((bool)release["prerelease"])\n                    {\n                        continue;\n                    }\n                    foreach (JsonObject asset in (JsonArray)release["assets"])\n                    {
                {\n                    if ((bool)release["prerelease"])\n                    {\n                        continue;\n                    }\n                    foreach (JsonObject asset in (JsonArray)release["assets"])\n                    {\n                        string url = (string)asset["browser_download_url"];\n                        if (IsNewVersion(url))\n                        {
                    }\n                    foreach (JsonObject asset in (JsonArray)release["assets"])\n                    {\n                        string url = (string)asset["browser_download_url"];\n                        if (IsNewVersion(url))\n                        {\n                            versions.Add(url);\n                        }\n                    }\n                }
                    {\n                        string url = (string)asset["browser_download_url"];\n                        if (IsNewVersion(url))\n                        {\n                            versions.Add(url);\n                        }\n                    }\n                }\n                if (versions.Count != 0)\n                {
                        {\n                            versions.Add(url);\n                        }\n                    }\n                }\n                if (versions.Count != 0)\n                {\n                    // sort versions\n                    SortVersions(versions);\n                    NewVersionFound = true;
                    LatestVersionURL = versions[versions.Count - 1];\n                    LatestVersionNumber = ParseVersionFromURL(LatestVersionURL);\n                }\n                if (CheckUpdateCompleted != null)\n                {\n                    CheckUpdateCompleted(this, new EventArgs());\n                }\n            }\n            catch (Exception ex)\n            {
        {\n            if (File.Exists(PAC_FILE))\n            {\n                return File.ReadAllText(PAC_FILE, Encoding.UTF8);\n            }\n            else\n            {\n                return Utils.UnGzip(Resources.proxy_pac_txt);\n            }\n        }
            {\n                return Utils.UnGzip(Resources.proxy_pac_txt);\n            }\n        }\n        public void SendResponse(byte[] firstPacket, int length, Socket socket)\n        {\n            try\n            {\n                string pac = GetPACContent();\n                IPEndPoint localEndPoint = (IPEndPoint)socket.LocalEndPoint;
            watcher.Renamed += Watcher_Changed;\n            watcher.EnableRaisingEvents = true;\n        }\n        private void Watcher_Changed(object sender, FileSystemEventArgs e)\n        {\n            if (PACFileChanged != null)\n            {\n                PACFileChanged(this, new EventArgs());\n            }\n        }
        }\n        private void Watcher_Changed(object sender, FileSystemEventArgs e)\n        {\n            if (PACFileChanged != null)\n            {\n                PACFileChanged(this, new EventArgs());\n            }\n        }\n        private string GetPACAddress(byte[] requestBuf, int length, IPEndPoint localEndPoint)\n        {
                        p.WaitForExit();\n                    }\n                    catch (Exception e)\n                    {\n                        Console.WriteLine(e.ToString());\n                    }\n                }\n                string polipoConfig = Resources.polipo_config;\n                polipoConfig = polipoConfig.Replace("__SOCKS_PORT__", configuration.localPort.ToString());
                        Sysproxy.SetIEProxy(true, true, "127.0.0.1:" + config.localPort.ToString(), "");\n                    }\n                    else\n                    {\n                        string pacUrl;\n                        if (config.useOnlinePac && !config.pacUrl.IsNullOrEmpty())\n                            pacUrl = config.pacUrl;\n                        else
                                g.FillRectangle(b, blockSize*row, blockSize*col, blockSize, blockSize);\n                            }\n                        }\n                    }\n                }\n            }\n            pictureBox1.Image = drawArea;\n        }\n        private void QRCodeForm_Load(object sender, EventArgs e)\n        {
                    }\n                }\n            }\n            pictureBox1.Image = drawArea;\n        }\n        private void QRCodeForm_Load(object sender, EventArgs e)\n        {\n            var servers = Configuration.Load();\n            var serverDatas = servers.configs.Select(\n                server =>
            pictureBox1.Image = drawArea;\n        }\n        private void QRCodeForm_Load(object sender, EventArgs e)\n        {\n            var servers = Configuration.Load();\n            var serverDatas = servers.configs.Select(\n                server =>\n                    new KeyValuePair<string, string>(server.URL, server.ToString())\n                ).ToList();\n            listBox1.DataSource = serverDatas;
        {\n            if (server.IsNullOrEmpty())\n            {\n                return I18N.GetString("New server");\n            }\n            string serverStr = $"{FormalHostName}:{server_port}";\n            return remarks.IsNullOrEmpty()\n                ? serverStr\n                : $"{remarks} ({serverStr})";\n        }
                {\n                    // SIP002\n                    string parts = $"{method}:{password}";\n                    string base64 = Convert.ToBase64String(Encoding.UTF8.GetBytes(parts));\n                    string websafeBase64 = base64.Replace('+', '-').Replace('/', '_').TrimEnd('=');\n                    string pluginPart = plugin;\n                    if (!string.IsNullOrWhiteSpace(plugin_opts))\n                    {\n                        pluginPart += ";" + plugin_opts;\n                    }
        private readonly Action<Exception, object> _onException;\n        private readonly Action<byte[], int, int, object> _onFinish;\n        private readonly Encoding _encoding;\n        // private readonly string _delimiter;\n        private readonly byte[] _delimiterBytes;\n        private readonly ByteSearch.SearchTarget _delimiterSearch;\n        private readonly object _state;\n        private readonly byte[] _lineBuffer;\n        private int _bufferDataIndex;\n        private int _bufferDataLength;
        // private readonly string _delimiter;\n        private readonly byte[] _delimiterBytes;\n        private readonly ByteSearch.SearchTarget _delimiterSearch;\n        private readonly object _state;\n        private readonly byte[] _lineBuffer;\n        private int _bufferDataIndex;\n        private int _bufferDataLength;\n        public LineReader(byte[] buffer, WrappedSocket socket, byte[] firstPackge, int index, int length,\n            Func<string, object, bool> onLineRead, Action<Exception, object> onException,\n            Action<byte[], int, int, object> onFinish,
        private readonly object _state;\n        private readonly byte[] _lineBuffer;\n        private int _bufferDataIndex;\n        private int _bufferDataLength;\n        public LineReader(byte[] buffer, WrappedSocket socket, byte[] firstPackge, int index, int length,\n            Func<string, object, bool> onLineRead, Action<Exception, object> onException,\n            Action<byte[], int, int, object> onFinish,\n            Encoding encoding, string delimiter,\n            object state)\n        {
                throw new ArgumentNullException(nameof(onLineRead));\n            }\n            if (encoding == null)\n            {\n                throw new ArgumentNullException(nameof(encoding));\n            }\n            if (delimiter == null)\n            {\n                throw new ArgumentNullException(nameof(delimiter));\n            }
            if (encoding == null)\n            {\n                throw new ArgumentNullException(nameof(encoding));\n            }\n            if (delimiter == null)\n            {\n                throw new ArgumentNullException(nameof(delimiter));\n            }\n            if (buffer.Length < length)\n            {
            _onFinish = onFinish;\n            _encoding = encoding;\n            // _delimiter = delimiter;\n            _state = state;\n            // decode delimiter\n            _delimiterBytes = encoding.GetBytes(delimiter);\n            if (_delimiterBytes.Length == 0)\n            {\n                throw new ArgumentException("Too short!", nameof(delimiter));\n            }
            // _delimiter = delimiter;\n            _state = state;\n            // decode delimiter\n            _delimiterBytes = encoding.GetBytes(delimiter);\n            if (_delimiterBytes.Length == 0)\n            {\n                throw new ArgumentException("Too short!", nameof(delimiter));\n            }\n            if (buffer.Length < _delimiterBytes.Length)\n            {
            _delimiterBytes = encoding.GetBytes(delimiter);\n            if (_delimiterBytes.Length == 0)\n            {\n                throw new ArgumentException("Too short!", nameof(delimiter));\n            }\n            if (buffer.Length < _delimiterBytes.Length)\n            {\n                throw new ArgumentException("Too small!", nameof(buffer));\n            }\n            _delimiterSearch = new ByteSearch.SearchTarget(_delimiterBytes);
                throw new ArgumentException("Too short!", nameof(delimiter));\n            }\n            if (buffer.Length < _delimiterBytes.Length)\n            {\n                throw new ArgumentException("Too small!", nameof(buffer));\n            }\n            _delimiterSearch = new ByteSearch.SearchTarget(_delimiterBytes);\n            _lineBuffer = buffer;\n            if (length > 0)\n            {\n                // process first package
                }\n                catch (Exception ex)\n                {\n                    OnException(ex);\n                    OnFinish();\n                }\n            }\n            else\n            {\n                // start reading
                    OnException(ex);\n                    OnFinish();\n                }\n            }\n            else\n            {\n                // start reading\n                socket.BeginReceive(_lineBuffer, 0, _lineBuffer.Length, 0, ReceiveCallback, 0);\n            }\n        }
            if (forceDisable)\n            {\n                enabled = false;\n            }\n            try\n            {\n                if (enabled)\n                {\n                    if (global)\n                    {
    static class ProtocolHandler\n    {\n        private static Logger logger = LogManager.GetCurrentClassLogger();\n        // Don't use Application.ExecutablePath\n        // see https://stackoverflow.com/questions/12945805/odd-c-sharp-path-issue\n        private static readonly string ExecutablePath = Assembly.GetEntryAssembly().Location;\n        // TODO: Elevate when necessary\n        public static bool Set(bool enabled)\n        {\n            RegistryKey ssURLAssociation = null;\n            try\n            {
        {\n            checkPort(server.local_port);\n            checkPort(server.server_port);\n            checkPassword(server.password);\n            checkServer(server.server);\n        }\n        public static Configuration Load()\n        {\n            try\n            {
            checkPort(server.server_port);\n            checkPassword(server.password);\n            checkServer(server.server);\n        }\n        public static Configuration Load()\n        {\n            try\n            {\n                var json = "[0,1,2]";\n                var result = SimpleJson.SimpleJson.DeserializeObject<List<int>>(json);\n                string configContent = File.ReadAllText(CONFIG_FILE);
        public QRCodeForm(string code)\n        {\n            this.code = code;\n            InitializeComponent();\n            this.Icon = Icon.FromHandle(Resources.ssw128.GetHicon());\n            this.Text = I18N.GetString("QRCode");\n        }\n        private void GenQR(string ssconfig)\n        {\n            string qrText = ssconfig;
        private void GenQR(string ssconfig)\n        {\n            string qrText = ssconfig;\n            {\n                return;\n            }\n            int blockSize = Math.Max(200 / qrCoded.GetModuleCount(), 1);\n            Bitmap drawArea = new Bitmap((qrCoded.GetModuleCount() * blockSize), (qrCoded.GetModuleCount() * blockSize));\n            using (Graphics g = Graphics.FromImage(drawArea))\n            {\n                g.Clear(Color.White);\n                using (Brush b = new SolidBrush(Color.Black))\n                {
            string qrText = ssconfig;\n            }\n            int blockSize = Math.Max(200 / qrCoded.GetModuleCount(), 1);\n            Bitmap drawArea = new Bitmap((qrCoded.GetModuleCount() * blockSize), (qrCoded.GetModuleCount() * blockSize));\n            using (Graphics g = Graphics.FromImage(drawArea))\n            {\n                g.Clear(Color.White);\n                using (Brush b = new SolidBrush(Color.Black))\n                {\n                    for (int row = 0; row < qrCoded.GetModuleCount(); row++)\n                    {
            Bitmap drawArea = new Bitmap((qrCoded.GetModuleCount() * blockSize), (qrCoded.GetModuleCount() * blockSize));\n            using (Graphics g = Graphics.FromImage(drawArea))\n            {\n                g.Clear(Color.White);\n                using (Brush b = new SolidBrush(Color.Black))\n                {\n                    for (int row = 0; row < qrCoded.GetModuleCount(); row++)\n                    {\n                        for (int col = 0; col < qrCoded.GetModuleCount(); col++)\n                        {

            MenuItem result = new MenuItem(I18N.GetString(text), click);\n            return result;\n        }\n        private MenuItem CreateSeperatorItem()\n        {\n            MenuItem result = new MenuItem("-");\n            return result;\n        }\n        private MenuItem CreateMenuGroup(string text, MenuItem[] items)\n        {
        private void LoadMenu()\n        {\n            this.contextMenu1 = new System.Windows.Forms.ContextMenu();\n            this.contextMenu1.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {\n                this.enableItem = CreateMenuItem("Enable", new System.EventHandler(this.EnableItem_Click)),\n                CreateMenuGroup("Mode", new System.Windows.Forms.MenuItem[] {\n                    this.PACModeItem = CreateMenuItem("PAC", new System.EventHandler(this.PACModeItem_Click)),\n                    this.globalModeItem = CreateMenuItem("Global", new System.EventHandler(this.GlobalModeItem_Click))\n                }),\n                this.ServersItem = CreateMenuGroup("Servers", new System.Windows.Forms.MenuItem[] {
            this.contextMenu1.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {\n                this.enableItem = CreateMenuItem("Enable", new System.EventHandler(this.EnableItem_Click)),\n                CreateMenuGroup("Mode", new System.Windows.Forms.MenuItem[] {\n                    this.PACModeItem = CreateMenuItem("PAC", new System.EventHandler(this.PACModeItem_Click)),\n                    this.globalModeItem = CreateMenuItem("Global", new System.EventHandler(this.GlobalModeItem_Click))\n                }),\n                this.ServersItem = CreateMenuGroup("Servers", new System.Windows.Forms.MenuItem[] {\n                    this.SeperatorItem = CreateSeperatorItem(),\n                    this.ConfigItem = CreateMenuItem("Edit Servers...", new System.EventHandler(this.Config_Click))\n                }),
                    this.globalModeItem = CreateMenuItem("Global", new System.EventHandler(this.GlobalModeItem_Click))\n                }),\n                this.ServersItem = CreateMenuGroup("Servers", new System.Windows.Forms.MenuItem[] {\n                    this.SeperatorItem = CreateSeperatorItem(),\n                    this.ConfigItem = CreateMenuItem("Edit Servers...", new System.EventHandler(this.Config_Click))\n                }),\n                CreateSeperatorItem(),\n                this.AutoStartupItem = CreateMenuItem("Start on Boot", new System.EventHandler(this.AutoStartupItem_Click)),\n                this.ShareOverLANItem = CreateMenuItem("Share over LAN", new System.EventHandler(this.ShareOverLANItem_Click)),\n                CreateMenuItem("Edit PAC File...", new System.EventHandler(this.EditPACFileItem_Click)),
                    this.ConfigItem = CreateMenuItem("Edit Servers...", new System.EventHandler(this.Config_Click))\n                }),\n                CreateSeperatorItem(),\n                this.AutoStartupItem = CreateMenuItem("Start on Boot", new System.EventHandler(this.AutoStartupItem_Click)),\n                this.ShareOverLANItem = CreateMenuItem("Share over LAN", new System.EventHandler(this.ShareOverLANItem_Click)),\n                CreateMenuItem("Edit PAC File...", new System.EventHandler(this.EditPACFileItem_Click)),\n                CreateSeperatorItem(),\n                CreateMenuItem("Show QRCode...", new System.EventHandler(this.QRCodeItem_Click)),\n                CreateMenuItem("Show Logs...", new System.EventHandler(this.ShowLogItem_Click)),\n                CreateMenuItem("About...", new System.EventHandler(this.Config_Click)),
        public void UpdatePACFromGFWList(Configuration config)\n        {\n            WebClient http = new WebClient();\n            http.Proxy = new WebProxy(IPAddress.Loopback.ToString(), config.localPort);\n            http.DownloadStringCompleted += http_DownloadStringCompleted;\n            http.DownloadStringAsync(new Uri(GFWLIST_URL));\n        }
                Logging.LogUsefulException(e);\n            }\n        }\n        public static void SetIEProxy(bool enable, bool global, string proxyServer, string pacURL)\n        {\n            string arguments;\n            if (enable)\n            {\n                if (global)\n                {
        {\n            string arguments;\n            if (enable)\n            {\n                if (global)\n                {\n                    arguments = "global " + proxyServer;\n                }\n                else\n                {
{\n    public class MenuViewController\n    {\n        // yes this is just a menu view controller\n        // when config form is closed, it moves away from RAM\n        // and it should just do anything related to the config form\n        private ShadowsocksController controller;\n        private UpdateChecker updateChecker;\n            LoadMenu();
            }\n            else if (dpi < 121)\n            {\n                // dpi = 120;\n                icon = Resources.ss20;\n            }\n            else\n            {\n                icon = Resources.ss24;\n            }
            else\n            {\n                icon = Resources.ss24;\n            }\n            this.enableItem.Text = "&Enable";\n            this.enableItem.Click += new System.EventHandler(this.EnableItem_Click);\n            //\n            // modeMenu\n            //\n            this.modeItem.Index = 1;\n            this.modeItem.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {\n            this.PACModeItem,\n            this.globalModeItem});
                icon = Resources.ss24;\n            }\n            this.enableItem.Text = "&Enable";\n            this.enableItem.Click += new System.EventHandler(this.EnableItem_Click);\n            //\n            // modeMenu\n            //\n            this.modeItem.Index = 1;\n            this.modeItem.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {\n            this.PACModeItem,\n            this.globalModeItem});\n            this.modeItem.Text = "Mode";\n            //\n            // PACModeItem\n            //\n            this.PACModeItem.Index = 0;
            //\n            this.modeItem.Index = 1;\n            this.modeItem.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {\n            this.PACModeItem,\n            this.globalModeItem});\n            this.modeItem.Text = "Mode";\n            //\n            // PACModeItem\n            //\n            this.PACModeItem.Index = 0;\n            this.PACModeItem.Text = "PAC";\n            this.PACModeItem.Click += new System.EventHandler(this.PACModeItem_Click);\n            //\n            // globalModeItem\n            //\n            this.globalModeItem.Index = 1;
            this.PACModeItem.Index = 0;\n            this.PACModeItem.Text = "PAC";\n            //\n            // globalModeItem\n            //\n            this.globalModeItem.Index = 1;\n            this.globalModeItem.Text = "Global";\n            this.globalModeItem.Click += new System.EventHandler(this.GlobalModeItem_Click);\n            // \n            // ServersItem\n            // \n            this.ServersItem.Index = 2;\n            this.ServersItem.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {\n            this.SeperatorItem,\n            this.ConfigItem});
            this.globalModeItem.Text = "Global";\n            // ServersItem\n            // \n            this.ServersItem.Index = 2;\n            this.ServersItem.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {\n            this.SeperatorItem,\n            this.ConfigItem});\n            this.ServersItem.Text = "&Servers";\n            // \n            // SeperatorItem\n            // \n            this.SeperatorItem.Index = 0;\n            this.SeperatorItem.Text = "-";\n            // \n            // ConfigItem\n            // \n            this.ConfigItem.Index = 1;
            this.ConfigItem});\n            this.ServersItem.Text = "&Servers";\n            this.SeperatorItem.Text = "-";\n            // \n            // ConfigItem\n            // \n            this.ConfigItem.Index = 1;\n            this.ConfigItem.Text = "Edit Servers...";\n            this.ConfigItem.Click += new System.EventHandler(this.Config_Click);\n            // \n            // menuItem1\n            // \n            this.menuItem1.Index = 3;\n            this.menuItem1.Text = "-";\n            // \n            // AutoStartupItem\n            // \n            this.AutoStartupItem.Index = 4;
            // \n            this.ConfigItem.Index = 1;\n            this.ConfigItem.Text = "Edit Servers...";\n            // \n            this.menuItem1.Index = 3;\n            this.menuItem1.Text = "-";\n            // \n            // AutoStartupItem\n            // \n            this.AutoStartupItem.Index = 4;\n            this.AutoStartupItem.Text = "Start on Boot";\n            this.AutoStartupItem.Click += new System.EventHandler(this.AutoStartupItem_Click);\n            // \n            // ShareOverLANItem\n            // \n            this.ShareOverLANItem.Index = 5;
            // \n            // AutoStartupItem\n            // \n            this.AutoStartupItem.Index = 4;\n            this.AutoStartupItem.Text = "Start on Boot";\n            this.AutoStartupItem.Click += new System.EventHandler(this.AutoStartupItem_Click);\n            // \n            // ShareOverLANItem\n            // \n            this.ShareOverLANItem.Index = 5;\n            this.ShareOverLANItem.Text = "Share over LAN";\n            this.ShareOverLANItem.Click += new System.EventHandler(this.ShareOverLANItem_Click);\n            // \n            // editPACFileItem\n            // \n            this.editPACFileItem.Index = 6;
            // \n            this.ShareOverLANItem.Index = 5;\n            this.ShareOverLANItem.Text = "Share over LAN";\n            this.ShareOverLANItem.Click += new System.EventHandler(this.ShareOverLANItem_Click);\n            // \n            // editPACFileItem\n            // \n            this.editPACFileItem.Index = 6;\n            this.editPACFileItem.Text = "Edit &PAC File...";\n            this.editPACFileItem.Click += new System.EventHandler(this.EditPACFileItem_Click);\n            // \n            // menuItem4\n            // \n            this.menuItem4.Index = 7;\n            this.menuItem4.Text = "-";\n            // \n            // QRCodeItem\n            // \n            this.QRCodeItem.Index = 8;
            // \n            this.editPACFileItem.Index = 6;\n            this.editPACFileItem.Text = "Edit &PAC File...";\n            // \n            this.menuItem4.Index = 7;\n            this.menuItem4.Text = "-";\n            // \n            // QRCodeItem\n            // \n            this.QRCodeItem.Index = 8;\n            this.QRCodeItem.Text = "Show &QRCode...";\n            this.QRCodeItem.Click += new System.EventHandler(this.QRCodeItem_Click);\n            // \n            // ShowLogItem\n            // \n            this.ShowLogItem.Index = 9;
            // \n            // QRCodeItem\n            // \n            this.QRCodeItem.Index = 8;\n            this.QRCodeItem.Text = "Show &QRCode...";\n            this.QRCodeItem.Click += new System.EventHandler(this.QRCodeItem_Click);\n            // \n            // ShowLogItem\n            // \n            this.ShowLogItem.Index = 9;\n            this.ShowLogItem.Text = "Show Logs...";\n            this.ShowLogItem.Click += new System.EventHandler(this.ShowLogItem_Click);\n            // \n            // aboutItem\n            // \n            this.aboutItem.Index = 10;
            // \n            this.ShowLogItem.Index = 9;\n            this.ShowLogItem.Text = "Show Logs...";\n            this.ShowLogItem.Click += new System.EventHandler(this.ShowLogItem_Click);\n            // \n            // aboutItem\n            // \n            this.aboutItem.Index = 10;\n            this.aboutItem.Text = "About...";\n            this.aboutItem.Click += new System.EventHandler(this.AboutItem_Click);\n            // \n            // menuItem3\n            // \n            this.menuItem3.Index = 11;\n            this.menuItem3.Text = "-";\n            // \n            // quitItem\n            // \n            this.quitItem.Index = 12;
        }\n        #region Windows 窗体设计器生成的代码\n        /// <summary>\n        /// 设计器支持所需的方法 - 不要\n        /// 使用代码编辑器修改此方法的内容。\n        /// </summary>\n        private void InitializeComponent()\n        {\n            this.tableLayoutPanel1 = new System.Windows.Forms.TableLayoutPanel();\n            this.RemarksTextBox = new System.Windows.Forms.TextBox();
        /// 使用代码编辑器修改此方法的内容。\n        /// </summary>\n        private void InitializeComponent()\n        {\n            this.tableLayoutPanel1 = new System.Windows.Forms.TableLayoutPanel();\n            this.RemarksTextBox = new System.Windows.Forms.TextBox();\n            this.label6 = new System.Windows.Forms.Label();\n            this.label1 = new System.Windows.Forms.Label();\n            this.label2 = new System.Windows.Forms.Label();\n            this.ProxyPortTextBox = new System.Windows.Forms.TextBox();
            this.RemarksTextBox = new System.Windows.Forms.TextBox();\n            this.label6 = new System.Windows.Forms.Label();\n            this.label1 = new System.Windows.Forms.Label();\n            this.label2 = new System.Windows.Forms.Label();\n            this.ProxyPortTextBox = new System.Windows.Forms.TextBox();\n            this.label4 = new System.Windows.Forms.Label();\n            this.label3 = new System.Windows.Forms.Label();\n            this.IPTextBox = new System.Windows.Forms.TextBox();\n            this.ServerPortTextBox = new System.Windows.Forms.TextBox();\n            this.PasswordTextBox = new System.Windows.Forms.TextBox();
            this.SuspendLayout();\n            // \n            // tableLayoutPanel1\n            // \n            this.tableLayoutPanel1.AutoSize = true;\n            this.tableLayoutPanel1.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;\n            this.tableLayoutPanel1.ColumnCount = 2;\n            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());\n            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());\n            this.tableLayoutPanel1.Controls.Add(this.RemarksTextBox, 1, 5);
            this.tableLayoutPanel1.AutoSize = true;\n            this.tableLayoutPanel1.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;\n            this.tableLayoutPanel1.ColumnCount = 2;\n            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());\n            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());\n            this.tableLayoutPanel1.Controls.Add(this.RemarksTextBox, 1, 5);\n            this.tableLayoutPanel1.Controls.Add(this.label6, 0, 5);\n            this.tableLayoutPanel1.Controls.Add(this.label1, 0, 0);\n            this.tableLayoutPanel1.Controls.Add(this.label2, 0, 1);\n            this.tableLayoutPanel1.Controls.Add(this.ProxyPortTextBox, 1, 4);
            this.tableLayoutPanel1.Controls.Add(this.RemarksTextBox, 1, 5);\n            this.tableLayoutPanel1.Controls.Add(this.label6, 0, 5);\n            this.tableLayoutPanel1.Controls.Add(this.label1, 0, 0);\n            this.tableLayoutPanel1.Controls.Add(this.label2, 0, 1);\n            this.tableLayoutPanel1.Controls.Add(this.ProxyPortTextBox, 1, 4);\n            this.tableLayoutPanel1.Controls.Add(this.label4, 0, 4);\n            this.tableLayoutPanel1.Controls.Add(this.label3, 0, 2);\n            this.tableLayoutPanel1.Controls.Add(this.IPTextBox, 1, 0);\n            this.tableLayoutPanel1.Controls.Add(this.ServerPortTextBox, 1, 1);\n            this.tableLayoutPanel1.Controls.Add(this.PasswordTextBox, 1, 2);
            // \n            // RemarksTextBox\n            // \n            this.RemarksTextBox.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));\n            this.RemarksTextBox.Location = new System.Drawing.Point(74, 139);\n            this.RemarksTextBox.Name = "RemarksTextBox";\n            this.RemarksTextBox.Size = new System.Drawing.Size(160, 20);\n            this.RemarksTextBox.TabIndex = 10;\n            this.RemarksTextBox.WordWrap = false;\n            // 
            this.label2.Name = "label2";\n            this.label2.Size = new System.Drawing.Size(60, 13);\n            this.label2.TabIndex = 1;\n            this.label2.Text = "Server Port";\n            // \n            // ProxyPortTextBox\n            // \n            this.ProxyPortTextBox.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));\n            this.ProxyPortTextBox.Location = new System.Drawing.Point(74, 113);\n            this.ProxyPortTextBox.Name = "ProxyPortTextBox";\n            this.ProxyPortTextBox.Size = new System.Drawing.Size(160, 20);\n            this.ProxyPortTextBox.TabIndex = 4;\n            this.ProxyPortTextBox.WordWrap = false;\n            // 

        private System.Windows.Forms.Label label1;\n        private System.Windows.Forms.Label label2;\n        private System.Windows.Forms.Label label3;\n        private System.Windows.Forms.Label label4;\n        private System.Windows.Forms.TextBox IPTextBox;\n        private System.Windows.Forms.TextBox ServerPortTextBox;\n        private System.Windows.Forms.TextBox PasswordTextBox;\n        private System.Windows.Forms.TextBox ProxyPortTextBox;
            ServersListBox.SelectedIndex = _modifiedConfiguration.configs.Count - 1;\n            _lastSelectedIndex = ServersListBox.SelectedIndex;\n        }\n        private void DuplicateButton_Click( object sender, EventArgs e )\n        {\n            if (!SaveOldSelectedServer())\n            {\n                return;\n            }\n            Server currServer = _modifiedConfiguration.configs[_lastSelectedIndex];
        private void DuplicateButton_Click( object sender, EventArgs e )\n        {\n            if (!SaveOldSelectedServer())\n            {\n                return;\n            }\n            Server currServer = _modifiedConfiguration.configs[_lastSelectedIndex];\n            _modifiedConfiguration.configs.Add(currServer);\n            LoadConfiguration(_modifiedConfiguration);
using Shadowsocks.Properties;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Runtime.InteropServices;\nusing System.Text;\nnamespace Shadowsocks.Encrypt\n{\n    public class PolarSSL\n    {
using System.IO;\nusing System.Runtime.InteropServices;\nusing System.Text;\nnamespace Shadowsocks.Encrypt\n{\n    public class PolarSSL\n    {\n                FileManager.UncompressFile(dllPath, Resources.polarssl_dll);\n            }
    public class PolarSSL\n    {\n                FileManager.UncompressFile(dllPath, Resources.polarssl_dll);\n            }\n            catch (IOException e)\n            {\n                Console.WriteLine(e.ToString());\n            }
            get {\n                return resourceCulture;\n            }\n            set {\n                resourceCulture = value;\n            }\n        }\n        /// <summary>\n        ///   Looks up a localized resource of type System.Byte[].\n        /// </summary>
            }\n            set {\n                resourceCulture = value;\n            }\n        }\n        /// <summary>\n        ///   Looks up a localized resource of type System.Byte[].\n        /// </summary>\n        internal static byte[] libsodium_dll {\n            get {
using Shadowsocks.Properties;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Runtime.InteropServices;\nusing System.Text;\nnamespace Shadowsocks.Encrypt\n{\n    public class Sodium\n    {
using System.IO;\nusing System.Runtime.InteropServices;\nusing System.Text;\nnamespace Shadowsocks.Encrypt\n{\n    public class Sodium\n    {\n                FileManager.UncompressFile(dllPath, Resources.libsodium_dll);\n            }
    public class Sodium\n    {\n                FileManager.UncompressFile(dllPath, Resources.libsodium_dll);\n            }\n            catch (IOException e)\n            {\n                Console.WriteLine(e.ToString());\n            }
        }\n        private void LogForm_Load(object sender, EventArgs e)\n        {\n            InitContent();\n            timer = new Timer();\n            timer.Interval = 300;\n            timer.Tick += Timer_Tick;\n            timer.Start();\n            this.TopMost = TopMostMenuItem.Checked = TopMostCheckBox.Checked = topMostTrigger;
                                if (!int.TryParse(locs[1], out _targetPort))\n                                {\n                                    throw new Exception("Bad http header: " + line);\n                                }\n                            }\n                            else\n                            {\n                                _targetPort = 80;\n                            }\n                        }
                                _targetPort = 80;\n                            }\n                        }\n                        _headers.Enqueue(line);\n                    }\n                }\n                else\n                {\n                    if (line.IsNullOrEmpty())\n                    {
                        }\n                        _headers.Enqueue(line);\n                    }\n                }\n                else\n                {\n                    if (line.IsNullOrEmpty())\n                    {\n                        _headers.Enqueue("");\n                        return true;
                callback();\n        }\n        public static bool IsHotkeyExists( HotKey hotKey )\n        {\n            if (hotKey == null) throw new ArgumentNullException(nameof(hotKey));\n            return _keymap.Any( v => v.Key.Equals( hotKey ) );\n        }\n        public static bool IsCallbackExists( HotKeyCallBackHandler cb, out HotKey hotkey)\n        {\n            if (cb == null) throw new ArgumentNullException(nameof(cb));
        public static bool IsHotkeyExists( HotKey hotKey )\n        {\n            if (hotKey == null) throw new ArgumentNullException(nameof(hotKey));\n            return _keymap.Any( v => v.Key.Equals( hotKey ) );\n        }\n        public static bool IsCallbackExists( HotKeyCallBackHandler cb, out HotKey hotkey)\n        {\n            if (cb == null) throw new ArgumentNullException(nameof(cb));\n            try\n            {
            return _keymap.Any( v => v.Key.Equals( hotKey ) );\n        }\n        public static bool IsCallbackExists( HotKeyCallBackHandler cb, out HotKey hotkey)\n        {\n            if (cb == null) throw new ArgumentNullException(nameof(cb));\n            try\n            {\n                var key = _keymap.First(x => x.Value == cb).Key;\n                hotkey = key;\n                return true;\n            }
        /// </summary>\n        private void HotkeyUp(object sender, KeyEventArgs e)\n        {\n            var tb = (TextBox) sender;\n            var content = tb.Text.TrimEnd();\n            if (content.Length >= 1 && content[content.Length - 1] == '+')\n            {\n                tb.Text = "";\n            }\n        }
        }\n            PrepareForHotkey(tb, out callBack, out lb);\n            UnregPrevHotkey(callBack);\n        }\n        private void CancelButton_Click(object sender, EventArgs e)\n        {\n            this.Close();\n        }\n        private void OKButton_Click(object sender, EventArgs e)\n        {\n            // try to register, notify to change settings if failed
            // try to register, notify to change settings if failed\n            if (!RegisterAllHotkeys())\n            {\n                MessageBox.Show(I18N.GetString("Register hotkey failed"));\n            }\n            // All check passed, saving\n            SaveConfig();\n            this.Close();\n        }\n        private void RegisterAllButton_Click(object sender, EventArgs e)\n        {
            return regResult;\n        }\n        private static void UnregPrevHotkey(HotKeys.HotKeyCallBackHandler cb)\n        {\n            GlobalHotKey.HotKey prevHotKey;\n            if (HotKeys.IsCallbackExists(cb, out prevHotKey))\n            {\n                // unregister previous one\n                HotKeys.Unregister(prevHotKey);\n            }\n        }

            this.SwitchSystemProxyTextBox.TextChanged += new System.EventHandler(this.TextBox_TextChanged);\n            // \n            // SwitchProxyModeTextBox\n            // \n            this.SwitchProxyModeTextBox.Dock = System.Windows.Forms.DockStyle.Fill;\n            this.SwitchProxyModeTextBox.Location = new System.Drawing.Point(208, 37);\n            this.SwitchProxyModeTextBox.Margin = new System.Windows.Forms.Padding(3, 3, 16, 3);\n            this.SwitchProxyModeTextBox.Name = "SwitchProxyModeTextBox";\n            this.SwitchProxyModeTextBox.ReadOnly = true;\n            this.SwitchProxyModeTextBox.Size = new System.Drawing.Size(276, 25);\n            this.SwitchProxyModeTextBox.TabIndex = 8;
            this.SwitchProxyModeTextBox.TextChanged += new System.EventHandler(this.TextBox_TextChanged);\n            // \n            // SwitchAllowLanTextBox\n            // \n            this.SwitchAllowLanTextBox.Dock = System.Windows.Forms.DockStyle.Fill;\n            this.SwitchAllowLanTextBox.Location = new System.Drawing.Point(208, 71);\n            this.SwitchAllowLanTextBox.Margin = new System.Windows.Forms.Padding(3, 3, 16, 3);\n            this.SwitchAllowLanTextBox.Name = "SwitchAllowLanTextBox";\n            this.SwitchAllowLanTextBox.ReadOnly = true;\n            this.SwitchAllowLanTextBox.Size = new System.Drawing.Size(276, 25);\n            this.SwitchAllowLanTextBox.TabIndex = 10;
            this.SwitchAllowLanTextBox.TextChanged += new System.EventHandler(this.TextBox_TextChanged);\n            // \n            // ShowLogsTextBox\n            // \n            this.ShowLogsTextBox.Dock = System.Windows.Forms.DockStyle.Fill;\n            this.ShowLogsTextBox.Location = new System.Drawing.Point(208, 105);\n            this.ShowLogsTextBox.Margin = new System.Windows.Forms.Padding(3, 3, 16, 3);\n            this.ShowLogsTextBox.Name = "ShowLogsTextBox";\n            this.ShowLogsTextBox.ReadOnly = true;\n            this.ShowLogsTextBox.Size = new System.Drawing.Size(276, 25);\n            this.ShowLogsTextBox.TabIndex = 11;
            this.ShowLogsTextBox.TextChanged += new System.EventHandler(this.TextBox_TextChanged);\n            // \n            // ServerMoveUpTextBox\n            // \n            this.ServerMoveUpTextBox.Dock = System.Windows.Forms.DockStyle.Fill;\n            this.ServerMoveUpTextBox.Location = new System.Drawing.Point(208, 139);\n            this.ServerMoveUpTextBox.Margin = new System.Windows.Forms.Padding(3, 3, 16, 3);\n            this.ServerMoveUpTextBox.Name = "ServerMoveUpTextBox";\n            this.ServerMoveUpTextBox.ReadOnly = true;\n            this.ServerMoveUpTextBox.Size = new System.Drawing.Size(276, 25);\n            this.ServerMoveUpTextBox.TabIndex = 12;
            this.ServerMoveUpTextBox.TextChanged += new System.EventHandler(this.TextBox_TextChanged);\n            // \n            // ServerMoveDownTextBox\n            // \n            this.ServerMoveDownTextBox.Dock = System.Windows.Forms.DockStyle.Fill;\n            this.ServerMoveDownTextBox.Location = new System.Drawing.Point(208, 174);\n            this.ServerMoveDownTextBox.Margin = new System.Windows.Forms.Padding(3, 3, 16, 3);\n            this.ServerMoveDownTextBox.Name = "ServerMoveDownTextBox";\n            this.ServerMoveDownTextBox.ReadOnly = true;\n            this.ServerMoveDownTextBox.Size = new System.Drawing.Size(276, 25);\n            this.ServerMoveDownTextBox.TabIndex = 13;
{\n    class TCPRelay : Listener.Service\n    {\n        private ShadowsocksController _controller;\n        private DateTime _lastSweepTime;\n        public ISet<TCPHandler> Handlers\n        {\n            get; set;\n        }
        {\n            _controller.UpdateLatency(server, latency);\n        }\n    }\n    class TCPHandler\n    {\n        // public Encryptor encryptor;\n        public IEncryptor encryptor;\n        public Server server;\n        // Client  socket.
        public IEncryptor encryptor;\n        public Server server;\n        // Client  socket.\n        public Socket remote;\n        public Socket connection;\n        public ShadowsocksController controller;\n        public TCPRelay relay;\n        public DateTime lastActivity;\n        private const int maxRetry = 4;\n        private int retryCount = 0;
        {\n            if (closed)\n            {\n                return;\n            }\n            try\n            {\n                if (ar.AsyncState != null)\n                {\n                    connection.EndSend(ar);
                {\n                    connection.EndSend(ar);\n                    Logging.Debug(remote, RecvSize, "TCP Relay");\n                    connection.BeginReceive(connetionRecvBuffer, 0, RecvSize, 0, new AsyncCallback(ReadAll), null);\n                }\n                else\n                {\n                    int bytesRead = connection.EndReceive(ar);\n                    if (bytesRead > 0)\n                    {
                CreateRemote();\n                // TODO async resolving\n                IPAddress ipAddress;\n                bool parsed = IPAddress.TryParse(server.server, out ipAddress);\n                if (!parsed)\n                {\n                    IPHostEntry ipHostInfo = Dns.GetHostEntry(server.server);\n                    ipAddress = ipHostInfo.AddressList[0];\n                }\n                IPEndPoint remoteEP = new IPEndPoint(ipAddress, server.server_port);
                    ipAddress = ipHostInfo.AddressList[0];\n                }\n                IPEndPoint remoteEP = new IPEndPoint(ipAddress, server.server_port);\n                remote = new Socket(ipAddress.AddressFamily,\n                    SocketType.Stream, ProtocolType.Tcp);\n                remote.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n                _startConnectTime = DateTime.Now;\n                ServerTimer connectTimer = new ServerTimer(3000);\n                connectTimer.AutoReset = false;
                remote = new Socket(ipAddress.AddressFamily,\n                    SocketType.Stream, ProtocolType.Tcp);\n                remote.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n                _startConnectTime = DateTime.Now;\n                ServerTimer connectTimer = new ServerTimer(3000);\n                connectTimer.AutoReset = false;\n                connectTimer.Elapsed += connectTimer_Elapsed;\n                connectTimer.Enabled = true;\n                connectTimer.Server = server;
                remote = new Socket(ipAddress.AddressFamily,\n                    SocketType.Stream, ProtocolType.Tcp);\n                remote.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n                _startConnectTime = DateTime.Now;\n                ServerTimer connectTimer = new ServerTimer(3000);\n                connectTimer.AutoReset = false;\n                connectTimer.Elapsed += connectTimer_Elapsed;\n                connectTimer.Enabled = true;\n                connectTimer.Server = server;\n                connected = false;\n                // Connect to the remote endpoint.
        {\n            Server server = null;\n            if (closed)\n            {\n                return;\n            }\n            try\n            {\n                ServerTimer timer = (ServerTimer)ar.AsyncState;\n                server = timer.Server;
            {\n                return;\n            }\n            try\n            {\n                ServerTimer timer = (ServerTimer)ar.AsyncState;\n                server = timer.Server;\n                timer.Elapsed -= connectTimer_Elapsed;\n                timer.Enabled = false;\n                timer.Dispose();\n                // Complete the connection.
﻿using System.Text;\nnamespace Shadowsocks.Encryption\n{\n    public struct EncryptorInfo\n    {
{\n    public struct EncryptorInfo\n    {\n        public string name;\n        public int key_size;\n        public int iv_size;\n        public int type;\n        public EncryptorInfo(string name, int key_size, int iv_size, int type)\n        {
    static class Program\n    {\n        [DllImport("Kernel32.dll")]\n        private static extern IntPtr LoadLibrary(string path);\n        /// <summary>\n        /// 应用程序的主入口点。\n        /// </summary>\n        [STAThread]\n        static void Main()\n        {
        [DllImport("Kernel32.dll")]\n        private static extern IntPtr LoadLibrary(string path);\n        /// <summary>\n        /// 应用程序的主入口点。\n        /// </summary>\n        [STAThread]\n        static void Main()\n        {\n            string tempPath = Path.GetTempPath();\n            string dllPath = tempPath + "/polarssl.dll";\n            try\n            {
        [STAThread]\n        static void Main()\n        {\n            string tempPath = Path.GetTempPath();\n            string dllPath = tempPath + "/polarssl.dll";\n            try\n            {\n                FileManager.UncompressFile(dllPath, Resources.polarssl_dll);\n            }

            series1.Color = System.Drawing.Color.FromArgb(((int)(((byte)(255)))), ((int)(((byte)(128)))), ((int)(((byte)(0)))));\n            series1.IsXValueIndexed = true;\n            series1.Legend = "Legend1";\n            series1.Name = "Inbound";\n            series2.ChartArea = "ChartArea1";\n            series2.ChartType = System.Windows.Forms.DataVisualization.Charting.SeriesChartType.Line;
{\n    public abstract class IVEncryptor\n        : EncryptorBase\n    {\n        public const int MAX_KEY_LENGTH = 64;\n        public const int MAX_IV_LENGTH = 16;\n        public const int ONETIMEAUTH_FLAG = 0x10;\n        public const int ADDRTYPE_MASK = 0xF;\n        public const int ONETIMEAUTH_BYTES = 16;\n        public const int ONETIMEAUTH_KEYBYTES = 32;
        protected bool _decryptIVReceived;\n        protected bool _encryptIVSent;\n        protected int _encryptIVOffset = 0;\n        protected int _decryptIVOffset = 0;\n        protected string _method;\n        protected int _cipher;\n        protected int[] _cipherInfo;\n        protected byte[] _key;\n        protected int keyLen;\n        protected int ivLen;
        protected int[] _cipherInfo;\n        protected byte[] _key;\n        protected int keyLen;\n        protected int ivLen;\n        protected byte[] hash_buf;\n        protected int hash_idx = 0;\n        public IVEncryptor(string method, string password, bool onetimeauth)\n            : base(method, password, onetimeauth)\n        {\n            InitKey(method, password);
                len = 4 + nameLen; // atyp (1 bytes) + name length (1 bytes) + name (n bytes) + port (2 bytes)\n            }\n            else if (atyp == 4)\n            {\n                len = 19; // atyp (1 bytes) + ipv6 (16 bytes) + port (2 bytes)\n            }\n            if (len == 0 || len > length)\n                throw new Exception($"invalid header with addr type {atyp}");\n            return len;\n        }
                len = 19; // atyp (1 bytes) + ipv6 (16 bytes) + port (2 bytes)\n            }\n            if (len == 0 || len > length)\n                throw new Exception($"invalid header with addr type {atyp}");\n            return len;\n        }\n        protected int ss_onetimeauth(byte[] auth,\n            byte[] msg, int msg_len,\n            byte[] iv, int iv_len,\n            byte[] key, int key_len)\n        {\n            byte[] auth_key = new byte[ONETIMEAUTH_KEYBYTES];\n            byte[] auth_bytes = new byte[MAX_IV_LENGTH + MAX_KEY_LENGTH];
        }\n            byte[] iv, int iv_len,\n            byte[] key, int key_len)\n        {\n            byte[] auth_key = new byte[ONETIMEAUTH_KEYBYTES];\n            byte[] auth_bytes = new byte[MAX_IV_LENGTH + MAX_KEY_LENGTH];\n            Buffer.BlockCopy(iv, 0, auth_bytes, 0, ivLen);\n            Buffer.BlockCopy(key, 0, auth_bytes, ivLen, key_len);\n            Sodium.crypto_generichash(auth_key, ONETIMEAUTH_KEYBYTES, auth_bytes, (ulong)(iv_len + key_len), null, 0);\n            return Sodium.crypto_onetimeauth(auth, msg, (ulong)msg_len, auth_key);\n        }
            if (buf_size < (size + offset))\n                throw new Exception("failed to generate hash:  buffer size insufficient");\n            byte[] hash = new byte[HASH_BYTES];

                        splash.Location = new Point((int)minX, (int)minY);\n                        // we need a panel because a window has a minimal size
using System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Data;\nusing System.Drawing;\nusing System.Text;\nusing System.Windows.Forms;\nnamespace Shadowsocks.View\n{
        public QRCodeSplashForm()\n        {
        public QRCodeSplashForm()\n        {\n            InitializeComponent();\n        }\n        private Timer timer;
            InitializeComponent();\n        }\n        private Timer timer;\n            step = 0;\n            timer = new Timer();
        public event EventHandler UserRuleFileChanged;\n        public PACDaemon()\n        {\n            this.WatchPacFile();\n            this.WatchUserRuleFile();\n        }\n        public string TouchPACFile()\n        {
        {\n            this.WatchPacFile();\n            this.WatchUserRuleFile();\n        }\n        public string TouchPACFile()\n        {\n            if (File.Exists(PAC_FILE))\n            {
            this.WatchPacFile();\n            this.WatchUserRuleFile();\n        }\n        public string TouchPACFile()\n        {\n            if (File.Exists(PAC_FILE))\n            {\n                return PAC_FILE;\n            }
            if (File.Exists(PAC_FILE))\n            {\n                return PAC_FILE;\n            }\n            else\n            {\n                FileManager.UncompressFile(PAC_FILE, Resources.proxy_pac_txt);\n                return PAC_FILE;\n            }\n        }\n        internal string TouchUserRuleFile()\n        {
            }\n            {\n                FileManager.UncompressFile(PAC_FILE, Resources.proxy_pac_txt);\n                return PAC_FILE;\n            }\n        }\n        internal string TouchUserRuleFile()\n        {\n            if (File.Exists(USER_RULE_FILE))\n            {\n                return USER_RULE_FILE;\n            }\n            else\n            {\n                File.WriteAllText(USER_RULE_FILE, Resources.user_rule);
        }\n        internal string GetPACContent()\n        {\n            if (File.Exists(PAC_FILE))\n            {\n                return File.ReadAllText(PAC_FILE, Encoding.UTF8);\n            }\n            else\n            {
        {\n            this.Success = success;\n        }\n    }\n    public static class GeositeUpdater\n    {\n        private static Logger logger = LogManager.GetCurrentClassLogger();\n        public static event EventHandler<GeositeResultEventArgs> UpdateCompleted;\n        public static event ErrorEventHandler Error;\n        private static readonly string DATABASE_PATH = Utils.GetTempPath("dlc.dat");
    }\n    public static class GeositeUpdater\n    {\n        private static Logger logger = LogManager.GetCurrentClassLogger();\n        public static event EventHandler<GeositeResultEventArgs> UpdateCompleted;\n        public static event ErrorEventHandler Error;\n        private static readonly string DATABASE_PATH = Utils.GetTempPath("dlc.dat");\n            string gfwListUrl = GEOSITE_URL;\n            if (!string.IsNullOrWhiteSpace(config.gfwListUrl))\n            {
        private static Logger logger = LogManager.GetCurrentClassLogger();\n        public static event EventHandler<GeositeResultEventArgs> UpdateCompleted;\n        public static event ErrorEventHandler Error;\n        private static readonly string DATABASE_PATH = Utils.GetTempPath("dlc.dat");\n            string gfwListUrl = GEOSITE_URL;\n            if (!string.IsNullOrWhiteSpace(config.gfwListUrl))\n            {\n                logger.Info("Found custom GFWListURL in config file");\n                gfwListUrl = config.gfwListUrl;\n            }
                    ? $"[{IPAddress.IPv6Loopback}]"\n                    : IPAddress.Loopback.ToString(),\n                    config.localPort);\n            }\n            http.DownloadDataCompleted += (o, e) =>\n            {\n                try\n                {\n                    File.WriteAllBytes(DATABASE_PATH, e.Result);\n                    LoadGeositeList();
                    File.WriteAllBytes(DATABASE_PATH, e.Result);\n                    LoadGeositeList();\n                    bool pacFileChanged = MergeAndWritePACFile();\n                    UpdateCompleted?.Invoke(null, new GeositeResultEventArgs(pacFileChanged));\n                }\n                catch (Exception ex)\n                {\n                    Error?.Invoke(null, new ErrorEventArgs(ex));\n                }\n            };
                    bool pacFileChanged = MergeAndWritePACFile();\n                    UpdateCompleted?.Invoke(null, new GeositeResultEventArgs(pacFileChanged));\n                }\n                catch (Exception ex)\n                {\n                    Error?.Invoke(null, new ErrorEventArgs(ex));\n                }\n            };\n            http.DownloadDataAsync(new Uri(gfwListUrl));\n        }
                }\n                catch (Exception ex)\n                {\n                    Error?.Invoke(null, new ErrorEventArgs(ex));\n                }\n            };\n            http.DownloadDataAsync(new Uri(gfwListUrl));\n        }\n        public static bool MergeAndWritePACFile()\n        {
                abpContent = FileManager.NonExclusiveReadAllText(PACDaemon.USER_ABP_FILE, Encoding.UTF8);\n            }\n            else\n            {\n                abpContent = Resources.abp_js;\n            }\n            List<string> userruleLines = new List<string>();\n            if (File.Exists(PACDaemon.USER_RULE_FILE))\n            {\n                string userrulesString = FileManager.NonExclusiveReadAllText(PACDaemon.USER_RULE_FILE, Encoding.UTF8);
            else\n            {\n                abpContent = Resources.abp_js;\n            }\n            List<string> userruleLines = new List<string>();\n            if (File.Exists(PACDaemon.USER_RULE_FILE))\n            {\n                string userrulesString = FileManager.NonExclusiveReadAllText(PACDaemon.USER_RULE_FILE, Encoding.UTF8);\n                userruleLines = ParseToValidList(userrulesString);\n            }
                userruleLines = ParseToValidList(userrulesString);\n            }\n            List<string> gfwLines = ParseToValidList(domains);\n            abpContent =\n$@"var __USERRULES__ = {JsonConvert.SerializeObject(userruleLines, Formatting.Indented)};\nvar __RULES__ = {JsonConvert.SerializeObject(gfwLines, Formatting.Indented)};\n{abpContent}";\n            return abpContent;\n        }\n        private static readonly IEnumerable<char> IgnoredLineBegins = new[] { '!', '[' };
            {\n                foreach (var line in sr.NonWhiteSpaceLines())\n                {\n                    if (line.BeginWithAny(IgnoredLineBegins))\n                        continue;\n                    valid_lines.Add(line);\n                }\n            }\n            return valid_lines;\n        }
                {\n                    if (line.BeginWithAny(IgnoredLineBegins))\n                        continue;\n                    valid_lines.Add(line);\n                }\n            }\n            return valid_lines;\n        }\n        private static List<string> ParseToValidList(IList<DomainObject> domains)\n        {
            List<string> ret = new List<string>(domains.Count + 100)// 100 overhead\n            {\n                "/.*/" // match any domain, so all non-cn domain go through proxy\n            }; \n            foreach (var d in domains)\n            {\n                string domain = d.Value;\n                switch (d.Type)\n                {\n                    case DomainObject.Types.Type.Plain:
    {\n        private static Logger logger = LogManager.GetCurrentClassLogger();\n        public const string PAC_FILE = "pac.txt";\n        public const string USER_RULE_FILE = "user-rule.txt";\n        public const string USER_ABP_FILE = "abp.txt";\n        FileSystemWatcher PACFileWatcher;\n        FileSystemWatcher UserRuleFileWatcher;\n        public event EventHandler PACFileChanged;\n        public event EventHandler UserRuleFileChanged;
            TouchPACFile();\n            TouchUserRuleFile();\n            this.WatchPacFile();\n            this.WatchUserRuleFile();\n        }\n        public string TouchPACFile()\n        {\n            if (!File.Exists(PAC_FILE))\n            {

        public static RegistryKey OpenUserRegKey( string name, bool writable )\n        {\n            // we are building x86 binary for both x86 and x64, which will\n            // cause problem when opening registry key\n            // detect operating system instead of CPU\n            if (name.IsNullOrEmpty()) throw new ArgumentException(nameof(name));\n            try\n            {
            _config.autoCheckUpdate = enabled;\n            Configuration.Save(_config);\n        }\n        public void SaveLogViewerConfig(LogViewerConfig newConfig)\n        {\n            _config.logViewer = newConfig;\n            Configuration.Save(_config);\n        }\n        public void UpdateInboundCounter(long n)\n        {
        {\n            _config.logViewer = newConfig;\n            Configuration.Save(_config);\n        }\n        public void UpdateInboundCounter(long n)\n        {\n            inboundCounter += n;\n        }\n        public void UpdateOutboundCounter(long n)\n        {
        {\n            public string Error;\n        }\n        public event EventHandler ConfigChanged;\n        public event EventHandler EnableStatusChanged;\n        public event EventHandler<ErrorEventArgs> LocalFailToStart;\n        // when user clicked Edit PAC, and PAC file has already created\n        public event EventHandler<PathEventArgs> PACFileReadyToOpen;\n        public ShadowsocksController()\n        {
        }\n        public event EventHandler ConfigChanged;\n        public event EventHandler EnableStatusChanged;\n        public event EventHandler<ErrorEventArgs> LocalFailToStart;\n        // when user clicked Edit PAC, and PAC file has already created\n        public event EventHandler<PathEventArgs> PACFileReadyToOpen;\n        public ShadowsocksController()\n        {\n            config = Config.Load();\n            polipoRunner = new PolipoRunner();
                pacServer = new PACServer();\n                pacServer.PACFileChanged += pacServer_PACFileChanged;\n                pacServer.Start();\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine(e.Message);\n            }\n            updateSystemProxy();\n        }
                pacServer.Start();\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine(e.Message);\n            }\n            updateSystemProxy();\n        }\n        public void SaveConfig(Config newConfig)\n        {
                Console.WriteLine(e.Message);\n            }\n            updateSystemProxy();\n        }\n        public void SaveConfig(Config newConfig)\n        {\n            Config.Save(newConfig);\n            config = newConfig;\n            local.Stop();\n            polipoRunner.Stop();
            local.Stop();\n            polipoRunner.Stop();\n            polipoRunner.Start(config);\n            local = new Local(config);\n            local.Start();\n            if (ConfigChanged != null)\n            {\n                ConfigChanged(this, new EventArgs());\n            }\n        }
            string argument = @"/select, " + e.Path;\n            System.Diagnostics.Process.Start("explorer.exe", argument);\n        }\n        private void showWindow()\n        {\n            this.Opacity = 1;\n            this.Show();\n        }\n        private void updateUI()\n        {
            Config config = controller.GetConfig();\n            textBox1.Text = config.server;\n            textBox2.Text = config.server_port.ToString();\n            textBox3.Text = config.password;\n            textBox4.Text = config.local_port.ToString();\n            comboBox1.Text = config.method == null ? "aes-256-cfb" : config.method;\n            enableItem.Checked = config.enabled;\n        }\n        private void Form1_Load(object sender, EventArgs e)\n        {
            showWindow();\n        }\n        private void Quit_Click(object sender, EventArgs e)\n        {\n            this.Close();\n        }\n        private void OKButton_Click(object sender, EventArgs e)\n        {\n            try\n            {
        private void OKButton_Click(object sender, EventArgs e)\n        {\n            try\n            {\n                Config config = new Config\n                {\n                    server = textBox1.Text,\n                    server_port = int.Parse(textBox2.Text),\n                    password = textBox3.Text,\n                    local_port = int.Parse(textBox4.Text),
                }\n                if (_requestLineCount == 0)\n                {\n                    var m = HttpRequestHeaderRegex.Match(line);\n                    if (m.Success)\n                    {\n                        var method = m.Groups[1].Value;\n                        if (method == "CONNECT")\n                        {\n                            _isConnect = true;
                    var m = HttpRequestHeaderRegex.Match(line);\n                    if (m.Success)\n                    {\n                        var method = m.Groups[1].Value;\n                        if (method == "CONNECT")\n                        {\n                            _isConnect = true;\n                            if (!ParseHost(m.Groups[2].Value))\n                            {
                else\n                {\n                    if (line.IsNullOrEmpty())\n                    {\n                        return true;\n                    }\n                    if (!_isConnect)\n                    {\n                        if (line.StartsWith("Host: "))\n                        {
                    {\n                        return true;\n                    }\n                    if (!_isConnect)\n                    {\n                        if (line.StartsWith("Host: "))\n                        {\n                            if (!ParseHost(line.Substring(6).Trim()))\n                            {
        }\n        private void HandshakeReceive2Callback(IAsyncResult ar)\n        {\n            if (_closed) return;\n            try\n            {\n                int bytesRead = _connection.EndReceive(ar);\n                if (bytesRead >= 5)\n                {\n                    _command = _connetionRecvBuffer[1];
                if (bytesRead >= 5)\n                {\n                    _command = _connetionRecvBuffer[1];\n                        Logging.Debug("Unsupported CMD=" + _command);\n                        Close();\n                    }\n                    else\n                    {\n                        if (_command == CMD_CONNECT)\n                        {\n                            byte[] response = { 5, 0, 0, 1, 0, 0, 0, 0, 0, 0 };\n                            _connection.BeginSend(response, 0, response.Length, SocketFlags.None,\n                                ResponseCallback, null);
                    else\n                    {\n                        if (_command == CMD_CONNECT)\n                        {\n                            byte[] response = { 5, 0, 0, 1, 0, 0, 0, 0, 0, 0 };\n                            _connection.BeginSend(response, 0, response.Length, SocketFlags.None,\n                                ResponseCallback, null);\n                        }\n                        else if (_command == CMD_UDP_ASSOC)\n                        {\n                            ReadAddress(HandleUDPAssociate);
﻿using System;
﻿using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.IO.Compression;
﻿using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.IO.Compression;\nusing System.Linq;\nusing System.Runtime.InteropServices;

            catch (UnauthorizedAccessException uae)\n            {\n                Logging.LogUsefulException(uae);\n                return null;\n            }

﻿using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Runtime.InteropServices;\nusing System.Text;\nusing System.Threading.Tasks;\nnamespace Shadowsocks.Util.SystemProxy\n{

﻿using Shadowsocks.Model;\nusing Shadowsocks.Properties;\nusing Shadowsocks.Util;\nusing System;\nusing System.Collections;
﻿using Shadowsocks.Model;\nusing Shadowsocks.Properties;\nusing Shadowsocks.Util;\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;
using System.Net;\nusing System.Net.Sockets;\nusing System.Text;\nnamespace Shadowsocks.Controller\n{\n    class PACServer : Listener.Service\n    {
            {\n                this.Success = success;\n            }\n        }\n        private void http_DownloadStringCompleted(object sender, DownloadStringCompletedEventArgs e)\n        {\n            try\n            {\n                File.WriteAllText(Utils.GetTempPath("gfwlist.txt"), e.Result, Encoding.UTF8);\n                List<string> lines = ParseResult(e.Result);
            }\n        }\n        private void http_DownloadStringCompleted(object sender, DownloadStringCompletedEventArgs e)\n        {\n            try\n            {\n                File.WriteAllText(Utils.GetTempPath("gfwlist.txt"), e.Result, Encoding.UTF8);\n                List<string> lines = ParseResult(e.Result);\n                if (File.Exists(USER_RULE_FILE))\n                {
                    string local = File.ReadAllText(USER_RULE_FILE, Encoding.UTF8);\n                    string[] rules = local.Split(new char[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);\n                    foreach (string rule in rules)\n                    {\n                        if (rule.StartsWith("!") || rule.StartsWith("["))\n                            continue;\n                        lines.Add(rule);\n                    }\n                }\n                string abpContent;
                    foreach (string rule in rules)\n                    {\n                        if (rule.StartsWith("!") || rule.StartsWith("["))\n                            continue;\n                        lines.Add(rule);\n                    }\n                }\n                string abpContent;\n                if (File.Exists(USER_ABP_FILE))\n                {
                {\n                    abpContent = File.ReadAllText(USER_ABP_FILE, Encoding.UTF8);\n                }\n                else\n                {\n                    abpContent = Utils.UnGzip(Resources.abp_js);\n                }\n                abpContent = abpContent.Replace("__RULES__", JsonConvert.SerializeObject(lines, Formatting.Indented));\n                if (File.Exists(PACServer.PAC_FILE))\n                {
                abpContent = abpContent.Replace("__RULES__", JsonConvert.SerializeObject(lines, Formatting.Indented));\n                if (File.Exists(PACServer.PAC_FILE))\n                {\n                    string original = File.ReadAllText(PAC_FILE, Encoding.UTF8);\n                    if (original == abpContent)\n                    {\n                        UpdateCompleted(this, new ResultEventArgs(false));\n                        return;\n                    }\n                }
        }\n        private static async Task<List<DataList>> ICMPTest(Server server)\n        {\n            Logging.Debug("eveluating " + server.FriendlyName());\n            if (server.server == "") return null;\n            var ping = new Ping();\n            var ret = new List<DataList>();\n            foreach (var timestamp in Enumerable.Range(0, Repeat).Select(_ => DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss")))\n            {\n                //ICMP echo. we can also set options and special bytes
        {\n            Logging.Debug("eveluating " + server.FriendlyName());\n            if (server.server == "") return null;\n            var ping = new Ping();\n            var ret = new List<DataList>();\n            foreach (var timestamp in Enumerable.Range(0, Repeat).Select(_ => DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss")))\n            {\n                //ICMP echo. we can also set options and special bytes\n                var reply = await ping.SendTaskAsync(server.server, Timeout);\n                ret.Add(new List<KeyValuePair<string, string>>\n                {
            }\n            catch (System.Exception e)\n            {\n                Logging.LogUsefulException(e);\n            }\n            LoadLibrary(dllPath);\n        }\n        public static byte[] MD5(byte[] input)\n        {\n            byte[] output = new byte[16];
        public static byte[] MD5(byte[] input)\n        {\n            byte[] output = new byte[16];\n            md5(input, (uint) input.Length, output);\n            return output;\n        }\n        [DllImport("Kernel32.dll")]\n        private static extern IntPtr LoadLibrary(string path);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
﻿using System;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.Net.Sockets;\nusing System.Net;\nusing Shadowsocks.Encryption;\nusing Shadowsocks.Model;\nnamespace Shadowsocks.Controller\n{
using System.Text;\nusing System.Net.Sockets;\nusing System.Net;\nusing Shadowsocks.Encryption;\nusing Shadowsocks.Model;\nnamespace Shadowsocks.Controller\n{\n    class Local\n    {\n        private Configuration _config;
namespace Shadowsocks.Controller\n{\n    class Local\n    {\n        private Configuration _config;\n        private bool _shareOverLAN;\n        //private Encryptor encryptor;\n        Socket _listener;\n        public Local(Configuration config)\n        {\n            this._config = config;
            }\n        }\n        private void HandshakeReceive()\n        {\n            if (closed)\n            {\n                return;\n            }\n            try\n            {
            if (closed)\n            {\n                return;\n            }\n            try\n            {\n            if (closed)\n            {\n                return;\n            }\n            try\n            {\n                int bytesRead = connection.EndReceive(ar);\n                if (bytesRead > 1)\n                {\n                    byte[] response = { 5, 0 };
                pacServer = new PACServer();\n                pacServer.PACFileChanged += pacServer_PACFileChanged;\n            }\n            if (gfwListUpdater == null)\n            {\n                gfwListUpdater = new GFWListUpdater();\n                gfwListUpdater.UpdateCompleted += pacServer_PACUpdateCompleted;\n                gfwListUpdater.Error += pacServer_PACUpdateError;\n            }\n            pacServer.Stop();
            }\n            pacServer.Stop();\n            if (local != null)\n            {\n                local.Stop();\n            }\n            // don't put polipoRunner.Start() before pacServer.Stop()\n            // or bind will fail when switching bind address from 0.0.0.0 to 127.0.0.1\n            // though UseShellExecute is set to true now\n            // http://stackoverflow.com/questions/10235093/socket-doesnt-close-after-application-exits-if-a-launched-process-is-open\n            polipoRunner.Stop();\n            try\n            {\n                polipoRunner.Start(_config);

            {\n                Logging.LogUsefulException(e);\n                return false;\n            }\n        }\n        //hardcode\n        //TODO: backup reliable isp&geolocation provider or a local database is required\n        public static async Task<DataList> GetGeolocationAndIsp()\n        {\n            Logging.Debug("Retrive information of geolocation and isp");
            string jsonString;\n            try\n            {
            string jsonString;\n            try\n            {\n                return ret;\n            }\n            dynamic obj;
            string jsonString;\n            try\n            {\n                return ret;\n            }\n            dynamic obj;\n            if (!SimpleJson.SimpleJson.TryDeserializeObject(jsonString, out obj)) return ret;\n            string country = obj["country"];\n            string city = obj["city"];\n            string isp = obj["isp"];
        private void OKButton_Click(object sender, EventArgs e)\n        {\n            foreach (CalculationControl calculation in calculationContainer.Controls)\n            {\n                _configuration.Calculations[calculation.Value] = calculation.Factor;\n            }\n            _controller?.SaveStrategyConfigurations(_configuration);\n            _controller?.UpdateStatisticsConfiguration(StatisticsEnabledCheckBox.Checked);\n            Close();\n        }
            _controller?.SaveStrategyConfigurations(_configuration);\n            _controller?.UpdateStatisticsConfiguration(StatisticsEnabledCheckBox.Checked);\n            Close();\n        }\n        private void loadChartData(string serverName)\n        {\n            _dataTable.Rows.Clear();\n            List<AvailabilityStatistics.RawStatisticsData> statistics;\n            if (!_controller.availabilityStatistics.FilteredStatistics.TryGetValue(serverName, out statistics)) return;
        }\n        private void loadChartData(string serverName)\n        {\n            _dataTable.Rows.Clear();\n            List<AvailabilityStatistics.RawStatisticsData> statistics;\n            if (!_controller.availabilityStatistics.FilteredStatistics.TryGetValue(serverName, out statistics)) return;\n            foreach (var data in statistics)\n            {
        }\n        private void serverSelector_SelectedIndexChanged(object sender, EventArgs e)\n        {
            this.byHourOfDayCheckBox = new System.Windows.Forms.CheckBox();\n            this.repeatTimesNum = new System.Windows.Forms.NumericUpDown();\n            this.label6 = new System.Windows.Forms.Label();\n            this.splitContainer3 = new System.Windows.Forms.SplitContainer();\n            this.label1 = new System.Windows.Forms.Label();\n            this.calculationContainer = new System.Windows.Forms.FlowLayoutPanel();\n            this.CancelButton = new System.Windows.Forms.Button();\n            this.OKButton = new System.Windows.Forms.Button();\n            this.bindingConfiguration = new System.Windows.Forms.BindingSource(this.components);
            this.label6 = new System.Windows.Forms.Label();\n            this.splitContainer3 = new System.Windows.Forms.SplitContainer();\n            this.label1 = new System.Windows.Forms.Label();\n            this.calculationContainer = new System.Windows.Forms.FlowLayoutPanel();\n            this.CancelButton = new System.Windows.Forms.Button();\n            this.OKButton = new System.Windows.Forms.Button();\n            this.bindingConfiguration = new System.Windows.Forms.BindingSource(this.components);\n            this.serverSelector = new System.Windows.Forms.ComboBox();\n            ((System.ComponentModel.ISupportInitialize)(this.StatisticsChart)).BeginInit();
            // CancelButton\n            // \n            this.CancelButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
            // \n            // StatisticsStrategyConfigurationForm\n            // 
                    CreateMenuItem("Share Server Config...", new EventHandler(this.QRCodeItem_Click)),
                    }\n                    else\n                    {\n                        registry.SetValue("ProxyEnable", 0);\n                        registry.SetValue("ProxyServer", "");
            {\n                ShowBalloonTip(I18N.GetString("Shadowsocks"), I18N.GetString("No update is available"), ToolTipIcon.Info, 5000);\n            }\n            _isStartupChecking = false;\n        }\n        void notifyIcon1_BalloonTipClicked(object sender, EventArgs e)\n        {\n            if (updateChecker.NewVersionFound)\n            {\n                updateChecker.NewVersionFound = false; /* Reset the flag */
            _isStartupChecking = false;\n        }\n        void notifyIcon1_BalloonTipClicked(object sender, EventArgs e)\n        {\n            if (updateChecker.NewVersionFound)\n            {\n                updateChecker.NewVersionFound = false; /* Reset the flag */\n                if (System.IO.File.Exists(updateChecker.LatestVersionLocalName))\n                {\n                    string argument = "/select, \"" + updateChecker.LatestVersionLocalName + "\"";
﻿using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Net.NetworkInformation;\nusing System.Threading;\nusing Shadowsocks.Model;
using System.IO;\nusing System.Linq;\nusing System.Net.NetworkInformation;\nusing System.Threading;\nusing Shadowsocks.Model;\nusing System.Reflection;\nnamespace Shadowsocks.Controller\n{\n    class AvailabilityStatistics\n    {
        private static readonly string Delimiter = ",";\n        private static readonly int Timeout = 500;\n        private static readonly int Repeat = 4; //repeat times every evaluation\n        private static readonly int Interval = 10 * 60 * 1000;  //evaluate proxies every 15 minutes\n        private Timer timer = null;\n        private State state = null;\n        private List<Server> servers;\n        public static string AvailabilityStatisticsFile;\n        //static constructor to initialize every public static fields before refereced\n        static AvailabilityStatistics()\n        {
        {\n            string temppath = Path.GetTempPath();\n            AvailabilityStatisticsFile = Path.Combine(temppath, StatisticsFilesName);\n        }\n        public bool Set(bool enabled)\n        {\n            try\n            {\n                if (enabled)\n                {
                }\n                else\n                {
                }\n                else\n                {\n            Ping ping = new Ping();\n            State state = (State) obj;\n            foreach (var server in servers)\n            {\n                Logging.Debug("eveluating " + server.FriendlyName());\n                foreach (var _ in Enumerable.Range(0, Repeat))\n                {\n                    //TODO: do simple analyze of data to provide friendly message, like package loss.
                else\n                {\n            Ping ping = new Ping();\n            State state = (State) obj;\n            foreach (var server in servers)\n            {\n                Logging.Debug("eveluating " + server.FriendlyName());\n                foreach (var _ in Enumerable.Range(0, Repeat))\n                {\n                    //TODO: do simple analyze of data to provide friendly message, like package loss.\n                    string timestamp = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss");\n                    //ICMP echo. we can also set options and special bytes
                    state.data.Add(new KeyValuePair<string, string>("Timestamp", timestamp));\n                    state.data.Add(new KeyValuePair<string, string>("Server", server.FriendlyName()));\n                    state.data.Add(new KeyValuePair<string, string>("Status", reply.Status.ToString()));\n                    state.data.Add(new KeyValuePair<string, string>("RoundtripTime", reply.RoundtripTime.ToString()));\n                    //state.data.Add(new KeyValuePair<string, string>("data", reply.Buffer.ToString())); // The data of reply
                    //state.data.Add(new KeyValuePair<string, string>("data", reply.Buffer.ToString())); // The data of reply\n            string dataLine = string.Join(Delimiter, data.Select(kv => kv.Value).ToArray());\n            string[] lines;\n            if (!File.Exists(AvailabilityStatisticsFile))\n            {
                    //state.data.Add(new KeyValuePair<string, string>("data", reply.Buffer.ToString())); // The data of reply\n            string dataLine = string.Join(Delimiter, data.Select(kv => kv.Value).ToArray());\n            string[] lines;\n            if (!File.Exists(AvailabilityStatisticsFile))\n            {\n                string headerLine = string.Join(Delimiter, data.Select(kv => kv.Key).ToArray());\n                lines = new string[] { headerLine, dataLine };\n            }\n            else\n            {

using Shadowsocks.Controller.Strategy;\nusing Shadowsocks.Encryption;\nusing Shadowsocks.Encryption.AEAD;\nusing Shadowsocks.Encryption.Exception;\nusing Shadowsocks.Model;\nusing Shadowsocks.Proxy;\nusing Shadowsocks.Util.Sockets;\nusing static Shadowsocks.Encryption.EncryptorBase;\nnamespace Shadowsocks.Controller\n{
using Shadowsocks.Util.Sockets;\nusing static Shadowsocks.Encryption.EncryptorBase;\nnamespace Shadowsocks.Controller\n{\n    class TCPRelay : Listener.Service\n    {\n        public event EventHandler<SSTCPConnectedEventArgs> OnConnected;\n        public event EventHandler<SSTransmitEventArgs> OnInbound;\n        public event EventHandler<SSTransmitEventArgs> OnOutbound;\n        public event EventHandler<SSRelayEventArgs> OnFailed;
{\n    class TCPRelay : Listener.Service\n    {\n        public event EventHandler<SSTCPConnectedEventArgs> OnConnected;\n        public event EventHandler<SSTransmitEventArgs> OnInbound;\n        public event EventHandler<SSTransmitEventArgs> OnOutbound;\n        public event EventHandler<SSRelayEventArgs> OnFailed;\n        private static Logger logger = LogManager.GetCurrentClassLogger();\n        private ShadowsocksController _controller;\n        private DateTime _lastSweepTime;
            this.latency = latency;\n        }\n    }\n    internal class TCPHandler\n    {\n        public event EventHandler<SSTCPConnectedEventArgs> OnConnected;\n        public event EventHandler<SSTransmitEventArgs> OnInbound;\n        public event EventHandler<SSTransmitEventArgs> OnOutbound;\n        public event EventHandler<SSRelayEventArgs> OnClosed;\n        public event EventHandler<SSRelayEventArgs> OnFailed;
        public event EventHandler<SSRelayEventArgs> OnClosed;\n        public event EventHandler<SSRelayEventArgs> OnFailed;\n        class AsyncSession\n        {\n            public IProxy Remote { get; }\n            public AsyncSession(IProxy remote)\n            {\n                Remote = remote;\n            }\n        }
            public T State { get; set; }\n            public AsyncSession(IProxy remote, T state) : base(remote)\n            {\n                State = state;\n            }\n            public AsyncSession(AsyncSession session, T state) : base(session.Remote)\n            {\n                State = state;\n            }\n        }
            }\n        }\n        private static Logger Logger = LogManager.GetCurrentClassLogger();\n        private readonly int _proxyTimeout;\n        // each recv size.\n        public const int RecvSize = 2048;\n        // overhead of one chunk, reserved for AEAD ciphers\n        public const int ChunkOverheadSize = 16 * 2 /* two tags */ + AEADEncryptor.CHUNK_LEN_BYTES;\n        // max chunk size\n        public const uint MaxChunkSize = AEADEncryptor.CHUNK_LEN_MASK + AEADEncryptor.CHUNK_LEN_BYTES + 16 * 2;\n        // In general, the ciphertext length, we should take overhead into account\n        public const int BufferSize = RecvSize + (int)MaxChunkSize + 32 /* max salt len */;\n        public DateTime lastActivity;
        private byte _command;\n        private byte[] _firstPacket;\n        private int _firstPacketLength;\n        private const int CMD_CONNECT = 0x01;\n        private const int CMD_BIND = 0x02;\n        private const int CMD_UDP_ASSOC = 0x03;\n        private int _addrBufLength = -1;\n        private int _totalRead = 0;\n        private int _totalWrite = 0;\n        // remote -> local proxy (ciphertext, before decrypt)
        private byte[] _firstPacket;\n        private int _firstPacketLength;\n        private const int CMD_CONNECT = 0x01;\n        private const int CMD_BIND = 0x02;\n        private const int CMD_UDP_ASSOC = 0x03;\n        private int _addrBufLength = -1;\n        private int _totalRead = 0;\n        private int _totalWrite = 0;\n        // remote -> local proxy (ciphertext, before decrypt)\n        private byte[] _remoteRecvBuffer = new byte[BufferSize];\n        // client -> local proxy (plaintext, before encrypt)
        private int _firstPacketLength;\n        private const int CMD_CONNECT = 0x01;\n        private const int CMD_BIND = 0x02;\n        private const int CMD_UDP_ASSOC = 0x03;\n        private int _addrBufLength = -1;\n        private int _totalRead = 0;\n        private int _totalWrite = 0;\n        // remote -> local proxy (ciphertext, before decrypt)\n        private byte[] _remoteRecvBuffer = new byte[BufferSize];\n        // client -> local proxy (plaintext, before encrypt)\n        private byte[] _connetionRecvBuffer = new byte[BufferSize];\n        // local proxy -> remote (plaintext, after decrypt)
        private const int CMD_CONNECT = 0x01;\n        private const int CMD_BIND = 0x02;\n        private const int CMD_UDP_ASSOC = 0x03;\n        private int _addrBufLength = -1;\n        private int _totalRead = 0;\n        private int _totalWrite = 0;\n        // remote -> local proxy (ciphertext, before decrypt)\n        private byte[] _remoteRecvBuffer = new byte[BufferSize];\n        // client -> local proxy (plaintext, before encrypt)\n        private byte[] _connetionRecvBuffer = new byte[BufferSize];\n        // local proxy -> remote (plaintext, after decrypt)\n        private byte[] _remoteSendBuffer = new byte[BufferSize];\n        // local proxy -> client (ciphertext, before decrypt)
        private readonly object _decryptionLock = new object();\n        private readonly object _closeConnLock = new object();\n        private DateTime _startConnectTime;\n        private DateTime _startReceivingTime;\n        private DateTime _startSendingTime;\n        private EndPoint _destEndPoint = null;\n                throw new ArgumentException("No server configured");\n            _encryptor = EncryptorFactory.GetEncryptor(server.method, server.password);
        }\n        public void Close()\n        {\n            lock (_closeConnLock)\n            {
                        // reject socks 4\n                        response = new byte[] { 0, 91 };\n                        Logger.Error("socks 5 protocol error");\n                    }\n                    _connection.BeginSend(response, 0, response.Length, SocketFlags.None,\n                        HandshakeSendCallback, null);\n                }\n                else\n                    Close();
                    Close();\n            }\n            catch (Exception e)\n            {\n                Logger.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void HandshakeSendCallback(IAsyncResult ar)\n        {
            }\n        }\n        private void HandshakeSendCallback(IAsyncResult ar)\n        {\n            if (_closed) return;\n            try\n            {\n                _connection.EndSend(ar);\n                // +-----+-----+-------+------+----------+----------+\n                // | VER | CMD |  RSV  | ATYP | DST.ADDR | DST.PORT |\n                // +-----+-----+-------+------+----------+----------+\n                // |  1  |  1  | X'00' |  1   | Variable |    2     |\n                // +-----+-----+-------+------+----------+----------+\n                // Skip first 3 bytes, and read 2 more bytes to analysis the address.\n                // 2 more bytes is designed if address is domain then we don't need to read once more to get the addr length.
                }\n                else\n                {\n                    Logger.Debug(\n                        "failed to recv data in Shadowsocks.Controller.TCPHandler.handshakeReceive2Callback()");\n                    Close();\n                }\n            }\n            catch (Exception e)\n            {
        }\n        private void ResponseCallback(IAsyncResult ar)\n        {\n            try\n            {\n                _connection.EndSend(ar);\n                ReadAddress(StartConnect);\n            }\n            catch (Exception e)\n            {
        private void ReadAddress(int bytesRemain, Action onSuccess)\n        {\n            // drop [ VER | CMD |  RSV  ]\n            Array.Copy(_connetionRecvBuffer, 3, _connetionRecvBuffer, 0, ADDR_ATYP_LEN + 1);\n            // Read the remain address bytes\n            _connection.BeginReceive(_connetionRecvBuffer, 2, RecvSize - 2, SocketFlags.None, OnAddressFullyRead,\n                new object[] { bytesRemain, onSuccess });\n        }\n        private void OnAddressFullyRead(IAsyncResult ar)\n        {
            _connection.BeginReceive(_connetionRecvBuffer, 2, RecvSize - 2, SocketFlags.None, OnAddressFullyRead,\n                new object[] { bytesRemain, onSuccess });\n        }\n        private void OnAddressFullyRead(IAsyncResult ar)\n        {\n            if (_closed) return;\n            try\n            {\n                int bytesRead = _connection.EndReceive(ar);
        }\n        private void OnAddressFullyRead(IAsyncResult ar)\n        {\n            if (_closed) return;\n            try\n            {\n                int bytesRead = _connection.EndReceive(ar);\n                var states = (object[])ar.AsyncState;\n                int bytesRemain = (int)states[0];
                {\n                    int bytesRead = _connection.EndReceive(ar);\n                    if (bytesRead > 0)\n                    {\n                        _connection.BeginReceive(_connetionRecvBuffer, 0, RecvSize, SocketFlags.None,\n                            ReadAll, null);\n                    }\n                    else\n                        Close();
                proxyTimer.Session = session;\n                proxyTimer.DestEndPoint = serverEP;\n                proxyTimer.Server = _server;\n                _proxyConnected = false;\n                // Connect to the proxy server.\n                remote.BeginConnectProxy(proxyEP, ProxyConnectCallback,\n                    new AsyncSession<ProxyTimer>(remote, proxyTimer));\n            }\n            catch (Exception e)\n            {
                remote.BeginConnectProxy(proxyEP, ProxyConnectCallback,\n                    new AsyncSession<ProxyTimer>(remote, proxyTimer));\n            }\n            catch (Exception e)\n            {\n                Logger.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void ProxyConnectTimer_Elapsed(object sender, ElapsedEventArgs e)\n        {
        private void ProxyConnectTimer_Elapsed(object sender, ElapsedEventArgs e)\n        {\n            var timer = (ProxyTimer)sender;\n            timer.Elapsed -= ProxyConnectTimer_Elapsed;\n            timer.Enabled = false;\n            timer.Dispose();\n            if (_proxyConnected || _destConnected || _closed)\n            {\n                return;\n            }
            Close();\n        }\n        private void ProxyConnectCallback(IAsyncResult ar)\n        {\n            if (_closed)\n            {\n                return;\n            }\n            try\n            {
        private void ProxyConnectCallback(IAsyncResult ar)\n        {\n            if (_closed)\n            {\n                return;\n            }\n            try\n            {\n                var session = (AsyncSession<ProxyTimer>)ar.AsyncState;\n                ProxyTimer timer = session.State;
            }\n            try\n            {\n                var session = (AsyncSession<ProxyTimer>)ar.AsyncState;\n                ProxyTimer timer = session.State;\n                var destEndPoint = timer.DestEndPoint;\n                var server = timer.Server;\n                timer.Elapsed -= ProxyConnectTimer_Elapsed;\n                timer.Enabled = false;\n                timer.Dispose();
                }\n                // Connect to the remote endpoint.\n                remote.BeginConnectDest(destEndPoint, ConnectCallback,\n                    new AsyncSession<ServerTimer>(session, connectTimer), auth);\n            }\n            catch (ArgumentException)\n            {\n            }\n            catch (Exception e)\n            {
            catch (ArgumentException)\n            {\n            }\n            catch (Exception e)\n            {\n                Logger.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void DestConnectTimer_Elapsed(object sender, ElapsedEventArgs e)\n        {
        private void DestConnectTimer_Elapsed(object sender, ElapsedEventArgs e)\n        {\n            var timer = (ServerTimer)sender;\n            timer.Elapsed -= DestConnectTimer_Elapsed;\n            timer.Enabled = false;\n            timer.Dispose();\n            if (_destConnected || _closed)\n            {\n                return;\n            }
            }\n            var session = timer.Session;\n            Server server = timer.Server;\n            OnFailed?.Invoke(this, new SSRelayEventArgs(_server));\n            Logger.Info($"{server.FriendlyName()} timed out");\n            session.Remote.Close();\n            Close();\n        }\n        private void ConnectCallback(IAsyncResult ar)\n        {
            if (_closed) return;\n            try\n            {\n                var session = (AsyncSession<ServerTimer>)ar.AsyncState;\n                ServerTimer timer = session.State;\n                _server = timer.Server;\n                timer.Elapsed -= DestConnectTimer_Elapsed;\n                timer.Enabled = false;\n                timer.Dispose();
                var session = (AsyncSession<ServerTimer>)ar.AsyncState;\n                ServerTimer timer = session.State;\n                _server = timer.Server;\n                timer.Elapsed -= DestConnectTimer_Elapsed;\n                timer.Enabled = false;\n                timer.Dispose();\n                var remote = session.Remote;\n                // Complete the connection.\n                remote.EndConnectDest(ar);\n                _destConnected = true;\n                Logger.Debug($"Socket connected to ss server: {_server.FriendlyName()}");
            }\n            catch (ArgumentException)\n            {\n            }\n            catch (Exception e)\n            {\n                if (_server != null)\n                {\n                    OnFailed?.Invoke(this, new SSRelayEventArgs(_server));\n                }
                    OnFailed?.Invoke(this, new SSRelayEventArgs(_server));\n                }\n                Logger.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void TryReadAvailableData()\n        {\n            int available = Math.Min(_connection.Available, RecvSize - _firstPacketLength);\n            if (available > 0)\n            {
            int available = Math.Min(_connection.Available, RecvSize - _firstPacketLength);\n            if (available > 0)\n            {\n                var size = _connection.Receive(_connetionRecvBuffer, _firstPacketLength, available,\n                    SocketFlags.None);\n                _firstPacketLength += size;\n            }\n        }\n        private void StartPipe(AsyncSession session)\n        {
            {\n                _startReceivingTime = DateTime.Now;\n                session.Remote.BeginReceive(_remoteRecvBuffer, 0, RecvSize, SocketFlags.None,\n                    PipeRemoteReceiveCallback, session);\n                TryReadAvailableData();\n                Logger.Trace($"_firstPacketLength = {_firstPacketLength}");\n                SendToServer(_firstPacketLength, session);\n            }\n            catch (Exception e)\n            {
                Logger.Trace($"_firstPacketLength = {_firstPacketLength}");\n                SendToServer(_firstPacketLength, session);\n            }\n            catch (Exception e)\n            {\n                Logger.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void PipeRemoteReceiveCallback(IAsyncResult ar)\n        {
                }\n                else\n                {\n                    _connection.Shutdown(SocketShutdown.Send);\n                    _connectionShutdown = true;\n                    CheckClose();\n                }\n            }\n            catch (Exception e)\n            {
                    CheckClose();\n                }\n            }\n            catch (Exception e)\n            {\n                Logger.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void PipeConnectionReceiveCallback(IAsyncResult ar)\n        {
                Close();\n            }\n        }\n        private void PipeConnectionReceiveCallback(IAsyncResult ar)\n        {\n            if (_closed) return;\n            try\n            {\n                int bytesRead = _connection.EndReceive(ar);
                    Buffer.BlockCopy(_connetionSendBuffer, bytesSent, _connetionSendBuffer, 0, bytesRemaining);\n                    session.Remote.BeginSend(_connetionSendBuffer, 0, bytesRemaining, SocketFlags.None,\n                        PipeRemoteSendCallback, new object[] { session, bytesRemaining });\n                    return;\n                }\n                _connection.BeginReceive(_connetionRecvBuffer, 0, RecvSize, SocketFlags.None,\n                    PipeConnectionReceiveCallback, session);\n            }\n            catch (Exception e)\n            {
            }\n            catch (Exception e)\n            {\n                Logger.LogUsefulException(e);\n                Close();\n            }\n        }\n        // In general, we assume there is no delay between local proxy and client, add this for sanity\n        private void PipeConnectionSendCallback(IAsyncResult ar)\n        {\n            try\n            {
        private ShadowsocksController controller;\n        private UpdateChecker updateChecker;\n        private NotifyIcon _notifyIcon;\n        private ContextMenu contextMenu1;\n        private bool _isFirstRun;\n        private MenuItem enableItem;\n        private MenuItem AutoStartupItem;\n        private MenuItem ShareOverLANItem;\n        private MenuItem SeperatorItem;\n        private MenuItem ConfigItem;
        private MenuItem AutoStartupItem;\n        private MenuItem ShareOverLANItem;\n        private MenuItem SeperatorItem;\n        private MenuItem ConfigItem;\n        private MenuItem menuItem4;\n        private MenuItem editPACFileItem;\n        private MenuItem QRCodeItem;\n        private MenuItem ShowLogItem;\n        private MenuItem aboutItem;\n        private MenuItem ServersItem;
        private MenuItem SeperatorItem;\n        private MenuItem ConfigItem;\n        private MenuItem menuItem4;\n        private MenuItem editPACFileItem;\n        private MenuItem QRCodeItem;\n        private MenuItem ShowLogItem;\n        private MenuItem aboutItem;\n        private MenuItem ServersItem;\n        private MenuItem menuItem3;\n        private MenuItem quitItem;
        private void LoadMenu()\n        {\n            this.contextMenu1 = new System.Windows.Forms.ContextMenu();
        private void LoadMenu()\n        {\n            this.contextMenu1 = new System.Windows.Forms.ContextMenu();\n            this.QRCodeItem = new System.Windows.Forms.MenuItem();\n            this.ShowLogItem = new System.Windows.Forms.MenuItem();\n            this.aboutItem = new System.Windows.Forms.MenuItem();\n            this.menuItem3 = new System.Windows.Forms.MenuItem();\n            this.quitItem = new System.Windows.Forms.MenuItem();\n            this.menuItem1 = new System.Windows.Forms.MenuItem();\n            // \n            // contextMenu1\n            // \n            this.contextMenu1.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {\n            this.enableItem,\n            this.modeItem,\n            this.ServersItem,
            this.quitItem = new System.Windows.Forms.MenuItem();\n            this.menuItem1 = new System.Windows.Forms.MenuItem();\n            // contextMenu1\n            // \n            this.contextMenu1.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {\n            this.enableItem,\n            this.modeItem,\n            this.ServersItem,\n            this.menuItem1,\n            this.AutoStartupItem,\n            this.ShareOverLANItem,\n            this.editPACFileItem,
            this.modeItem,\n            this.ServersItem,\n            this.menuItem1,\n            this.AutoStartupItem,\n            this.ShareOverLANItem,\n            this.editPACFileItem,\n            this.menuItem4,\n            this.QRCodeItem,\n            this.ShowLogItem,\n            this.aboutItem,
            this.menuItem1,\n            this.AutoStartupItem,\n            this.ShareOverLANItem,\n            this.editPACFileItem,\n            this.menuItem4,\n            this.QRCodeItem,\n            this.ShowLogItem,\n            this.aboutItem,\n            this.menuItem3,\n            this.quitItem});
        {\n            if (socket.ProtocolType != ProtocolType.Udp)\n            {\n                return false;\n            }\n            if (length < 4)\n            {\n                return false;\n            }\n            Listener.UDPState udpState = (Listener.UDPState)state;
            {\n                return false;\n            }\n            Listener.UDPState udpState = (Listener.UDPState)state;\n            // TODO add cache\n            UDPHandler handler = new UDPHandler(socket, _config.GetCurrentServer(), (IPEndPoint)udpState.remoteEndPoint);\n            handler.Send(firstPacket, length);\n            handler.Receive();\n            return true;\n        }
            OKButton.Text = I18N.GetString("OK");\n            MyCancelButton.Text = I18N.GetString("Cancel");\n            this.Text = I18N.GetString("Edit Proxy");\n        }\n        private void controller_ConfigChanged(object sender, EventArgs e)\n        {\n            LoadCurrentConfiguration();\n        }\n        private void LoadCurrentConfiguration()\n        {
        {\n            _modifiedConfiguration = controller.GetConfigurationCopy().proxy;\n            UseProxyCheckBox.Checked = _modifiedConfiguration.useProxy;\n            ProxyServerTextBox.Text = _modifiedConfiguration.proxyServer;\n            ProxyPortTextBox.Text = _modifiedConfiguration.proxyPort.ToString();\n            ProxyTimeoutTextBox.Text = _modifiedConfiguration.proxyTimeout.ToString();\n            ProxyTypeComboBox.SelectedIndex = _modifiedConfiguration.proxyType;\n        }\n        private void OKButton_Click(object sender, EventArgs e)\n        {
            UseProxyCheckBox.Checked = _modifiedConfiguration.useProxy;\n            ProxyServerTextBox.Text = _modifiedConfiguration.proxyServer;\n            ProxyPortTextBox.Text = _modifiedConfiguration.proxyPort.ToString();\n            ProxyTimeoutTextBox.Text = _modifiedConfiguration.proxyTimeout.ToString();\n            ProxyTypeComboBox.SelectedIndex = _modifiedConfiguration.proxyType;\n        }\n        private void OKButton_Click(object sender, EventArgs e)\n        {\n            if (UseProxyCheckBox.Checked)\n            {
        }\n        private void OKButton_Click(object sender, EventArgs e)\n        {\n            if (UseProxyCheckBox.Checked)\n            {\n                int port;\n                int timeout;\n                if (!int.TryParse(ProxyPortTextBox.Text, out port))\n                {\n                    MessageBox.Show(I18N.GetString("Illegal port number format"));\n                    return;\n                }
                if (!int.TryParse(ProxyPortTextBox.Text, out port))\n                {\n                    MessageBox.Show(I18N.GetString("Illegal port number format"));\n                    return;\n                }\n                if (!int.TryParse(ProxyTimeoutTextBox.Text, out timeout))\n                {\n                    MessageBox.Show(I18N.GetString("Illegal timeout format"));\n                    return;\n                }
                    return;\n                }\n                if (!int.TryParse(ProxyTimeoutTextBox.Text, out timeout))\n                {\n                    MessageBox.Show(I18N.GetString("Illegal timeout format"));\n                    return;\n                }\n                var type = ProxyTypeComboBox.SelectedIndex;\n                var proxy = ProxyServerTextBox.Text;\n                try\n                {
                {\n                    Configuration.CheckServer(proxy);\n                    Configuration.CheckPort(port);\n                    Configuration.CheckTimeout(timeout, ProxyConfig.MaxProxyTimeoutSec);\n                }\n                catch (Exception ex)\n                {\n                    MessageBox.Show(ex.Message);\n                    return;\n                }
                    Configuration.CheckPort(port);\n                    Configuration.CheckTimeout(timeout, ProxyConfig.MaxProxyTimeoutSec);\n                }\n                catch (Exception ex)\n                {\n                    MessageBox.Show(ex.Message);\n                    return;\n                }\n                controller.EnableProxy(type, proxy, port, timeout);\n            }
            controller.ConfigChanged -= controller_ConfigChanged;\n        }\n        private void UseProxyCheckBox_CheckedChanged(object sender, EventArgs e)\n        {\n            UpdateEnabled();\n        }\n        private void UpdateEnabled()\n        {\n            if (UseProxyCheckBox.Checked)\n            {
        {\n            if (UseProxyCheckBox.Checked)\n            {\n                ProxyServerTextBox.Enabled = true;\n                ProxyPortTextBox.Enabled = true;\n                ProxyTimeoutTextBox.Enabled = true;\n                ProxyTypeComboBox.Enabled = true;\n            }\n            else\n            {
                UniqueConfigFile = $"privoxy_{Uid}.conf";\n                PrivoxyJob = new Job();\n                FileManager.UncompressFile(Utils.GetTempPath("ss_privoxy.exe"), Resources.privoxy_exe);\n                FileManager.UncompressFile(Utils.GetTempPath("mgwz.dll"), Resources.mgwz_dll);\n            }\n            catch (IOException e)\n            {\n                Logging.LogUsefulException(e);\n            }\n        }
                FileManager.UncompressFile(Utils.GetTempPath("mgwz.dll"), Resources.mgwz_dll);\n            }\n            catch (IOException e)\n            {\n                Logging.LogUsefulException(e);\n            }\n        }\n        public int RunningPort\n        {\n            get\n            {\n                return _runningPort;\n            }\n        }\n        public void Start(Configuration configuration)\n        {
                 */\n                Logging.LogUsefulException(ex);\n                return false;\n            }\n        }\n        private int GetFreePort()\n        {\n            int defaultPort = 8123;\n            try\n            {
                    {\n                        return port;\n                    }\n                }\n            }\n            catch (Exception e)\n            {\n                // in case access denied\n                Logging.LogUsefulException(e);\n                return defaultPort;\n            }
        }\n        private void http_DownloadStringCompleted(object sender, DownloadStringCompletedEventArgs e)\n        {\n            try\n            {\n                File.WriteAllText(Utils.GetTempPath("gfwlist.txt"), e.Result, Encoding.UTF8);\n                List<string> lines = ParseResult(e.Result);\n                if (File.Exists(PACServer.USER_RULE_FILE))\n                {\n                    string local = File.ReadAllText(PACServer.USER_RULE_FILE, Encoding.UTF8);
        {\n            try\n            {\n                File.WriteAllText(Utils.GetTempPath("gfwlist.txt"), e.Result, Encoding.UTF8);\n                List<string> lines = ParseResult(e.Result);\n                if (File.Exists(PACServer.USER_RULE_FILE))\n                {\n                    string local = File.ReadAllText(PACServer.USER_RULE_FILE, Encoding.UTF8);\n                    string[] rules = local.Split(new char[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);\n                    foreach (string rule in rules)\n                    {
        {\n            WebClient http = new WebClient();\n            http.Proxy = new WebProxy(IPAddress.Loopback.ToString(), config.localPort);\n            http.DownloadStringCompleted += http_DownloadStringCompleted;\n            http.DownloadStringAsync(new Uri(GFWLIST_URL));\n        }\n        public static List<string> ParseResult(string response)\n        {\n            byte[] bytes = Convert.FromBase64String(response);\n            string content = Encoding.ASCII.GetString(bytes);
            http.DownloadStringCompleted += http_DownloadStringCompleted;\n            http.DownloadStringAsync(new Uri(GFWLIST_URL));\n        }\n        public static List<string> ParseResult(string response)\n        {\n            byte[] bytes = Convert.FromBase64String(response);\n            string content = Encoding.ASCII.GetString(bytes);\n            string[] lines = content.Split(new char[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);\n            List<string> valid_lines = new List<string>(lines.Length);\n            foreach (string line in lines)\n            {

﻿using Shadowsocks.View;\nusing System;\nusing System.Drawing;\nusing System.Windows.Forms;\nnamespace Shadowsocks.Model\n{\n    [Serializable]\n    public class LogViewerConfig\n    {
        public bool topMost;\n        public bool wrapText;\n        public bool toolbarShown;
        public bool topMost;\n        public bool wrapText;\n        public bool toolbarShown;\n            fontName = "Consolas";\n            fontSize = 8;\n            bgColor = "black";\n            textColor = "white";\n            topMost = false;\n            wrapText = false;\n            toolbarShown = false;
        // Use GetBestTop() and GetBestLeft() to ensure the log viwer form can be always display IN screen. 
        // Use GetBestTop() and GetBestLeft() to ensure the log viwer form can be always display IN screen. \n        public int GetBestLeft()\n        {
        public int GetBestLeft()\n        {\n        public Font GetFont()\n        {\n            try\n            {
            {\n        public void SetFont(Font font)\n        {
            {\n        public void SetFont(Font font)\n        {\n            fontName = font.Name;\n            fontSize = font.Size;\n        }\n        public Color GetBackgroundColor()\n        {\n            try\n            {
            {\n        public void SetFont(Font font)\n        {\n            fontSize = font.Size;\n        }\n        public Color GetBackgroundColor()\n        {\n            try\n            {\n                return ColorTranslator.FromHtml(bgColor);\n            }\n            catch (Exception)\n            {\n                return ColorTranslator.FromHtml("black");\n            }\n        }
        {\n            if (UseProxyCheckBox.Checked)\n            {\n                try\n                {\n                    var proxy = ProxyServerTextBox.Text;\n                    var port = int.Parse(ProxyPortTextBox.Text);\n                    Configuration.CheckServer(proxy);\n                    Configuration.CheckPort(port);

            this.tableLayoutPanel1.SuspendLayout();\n            this.tableLayoutPanel3.SuspendLayout();\n            this.tableLayoutPanel2.SuspendLayout();\n            this.SuspendLayout();\n            // \n            // tableLayoutPanel1\n            // \n            this.tableLayoutPanel1.AutoSize = true;\n            this.tableLayoutPanel1.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;\n            this.tableLayoutPanel1.ColumnCount = 1;\n            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());
            this.tableLayoutPanel3.SuspendLayout();\n            this.tableLayoutPanel2.SuspendLayout();\n            this.SuspendLayout();\n            // \n            // tableLayoutPanel1\n            // \n            this.tableLayoutPanel1.AutoSize = true;\n            this.tableLayoutPanel1.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;\n            this.tableLayoutPanel1.ColumnCount = 1;\n            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());\n            this.tableLayoutPanel1.Controls.Add(this.tableLayoutPanel3, 0, 2);\n            this.tableLayoutPanel1.Controls.Add(this.UseProxyCheckBox, 0, 0);
            this.tableLayoutPanel1.AutoSize = true;\n            this.tableLayoutPanel1.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;\n            this.tableLayoutPanel1.ColumnCount = 1;\n            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());\n            this.tableLayoutPanel1.Controls.Add(this.tableLayoutPanel3, 0, 2);\n            this.tableLayoutPanel1.Controls.Add(this.UseProxyCheckBox, 0, 0);\n            this.tableLayoutPanel1.Controls.Add(this.tableLayoutPanel2, 0, 1);\n            this.tableLayoutPanel1.Location = new System.Drawing.Point(15, 15);\n            this.tableLayoutPanel1.Name = "tableLayoutPanel1";
        {\n            var state = ((FakeAsyncResult)asyncResult).innerState;\n            if (state.ex != null)\n            {\n                throw state.ex;\n            }\n        }\n        public void BeginSend(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state)\n        {
        {\n            _remote?.BeginSend(buffer, offset, size, socketFlags, callback, state);\n        }\n        public int EndSend(IAsyncResult asyncResult)\n        {\n            return _remote.EndSend(asyncResult);\n        }\n        public void BeginReceive(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state)\n        {
            object state)\n        {\n            _remote?.BeginReceive(buffer, offset, size, socketFlags, callback, state);\n        }\n        public int EndReceive(IAsyncResult asyncResult)\n        {\n            return _remote.EndReceive(asyncResult);\n        }\n        public void Shutdown(SocketShutdown how)\n        {
        public int EndReceive(IAsyncResult asyncResult)\n        {\n            return _remote.EndReceive(asyncResult);\n        }\n        public void Shutdown(SocketShutdown how)\n        {\n            _remote?.Shutdown(how);\n        }\n        public void Close()\n        {
            if (ShareOverLANStatusChanged != null)\n            {\n                ShareOverLANStatusChanged(this, new EventArgs());\n            }\n        }\n        public void DisableProxy()\n        {\n            _config.proxy.useProxy = false;\n            SaveConfig(_config);\n        }
        public enum LogLevel\n        {\n            Fatal,\n            Error,\n            Warn,\n            Info,\n            Debug,\n            Trace,\n        }\n        const string NLOG_CONFIG_FILE_NAME = "NLog.config";
            Info,\n            Debug,\n            Trace,\n        }\n        const string NLOG_CONFIG_FILE_NAME = "NLog.config";\n        const string MIN_LEVEL_ATTRIBUTE = "minlevel";\n        const string FILE_NAME_ATTRIBUTE = "fileName";\n        XmlDocument doc = new XmlDocument();\n        XmlElement logLevelElement;
            string levelStr = logLevelElement.GetAttribute(MIN_LEVEL_ATTRIBUTE);\n        /// <summary>\n        /// Get the target fileName from xml file\n        /// </summary>\n        /// <returns></returns>\n        public string GetLogFileName()\n        {\n            return logFileNameElement.GetAttribute(FILE_NAME_ATTRIBUTE);\n        }\n        /// <summary>\n        /// Set the minLogLevel to xml file\n        /// </summary>\n        /// <param name="logLevel"></param>\n        public void SetLogLevel(LogLevel logLevel)\n        {

﻿using Shadowsocks.Controller;\nusing Shadowsocks.Model;\nusing Shadowsocks.Properties;\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Drawing;
            this.label1 = new System.Windows.Forms.Label();\n            this.label2 = new System.Windows.Forms.Label();\n            this.label3 = new System.Windows.Forms.Label();\n            this.label4 = new System.Windows.Forms.Label();\n            this.textBox1 = new System.Windows.Forms.TextBox();\n            this.textBox2 = new System.Windows.Forms.TextBox();\n            this.textBox3 = new System.Windows.Forms.TextBox();\n            this.textBox4 = new System.Windows.Forms.TextBox();
            this.aboutToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();\n            this.toolStripSeparator2 = new System.Windows.Forms.ToolStripSeparator();\n            this.QuitItem = new System.Windows.Forms.ToolStripMenuItem();\n            this.tableLayoutPanel1.SuspendLayout();\n            this.panel1.SuspendLayout();
            this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));\n            this.Name = "Form1";\n            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;\n            this.Text = "Shadowsocks";\n            this.FormClosed += new System.Windows.Forms.FormClosedEventHandler(this.Form1_FormClosed);\n            this.Load += new System.EventHandler(this.Form1_Load);\n            this.tableLayoutPanel1.ResumeLayout(false);\n            this.tableLayoutPanel1.PerformLayout();\n            this.panel1.ResumeLayout(false);
        #endregion\n        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel1;\n        private System.Windows.Forms.Label label1;\n        private System.Windows.Forms.Label label2;\n        private System.Windows.Forms.Label label3;\n        private System.Windows.Forms.Label label4;\n        private System.Windows.Forms.TextBox textBox1;\n        private System.Windows.Forms.TextBox textBox2;\n        private System.Windows.Forms.TextBox textBox3;\n        private System.Windows.Forms.TextBox textBox4;
                    leftptr++;\n                }\n                else if (leftptr == left.Length || ((rightptr < right.Length) && (compare(right[rightptr], left[leftptr], a, j)) <= 0))\n                {\n                    sorted[k] = right[rightptr];\n                    rightptr++;\n                }\n            }\n            return sorted;\n        }
                    rightptr++;\n                }\n            }\n            return sorted;\n        }\n        public Encryptor(string password)\n        {\n            MD5 md5 = System.Security.Cryptography.MD5.Create();\n            byte[] inputBytes = System.Text.Encoding.UTF8.GetBytes(password);\n            byte[] hash = md5.ComputeHash(inputBytes);
            {\n                encryptTable = mergeSort(encryptTable, a, i);\n            }\n            for (int i = 0; i < 256; i++)\n            {\n                decryptTable[encryptTable[i]] = (byte)i;\n            }\n        }\n        public void Encrypt(byte[] buf, int length)\n        {
            }\n            for (int i = 0; i < 256; i++)\n            {\n                decryptTable[encryptTable[i]] = (byte)i;\n            }\n        }\n        public void Encrypt(byte[] buf, int length)\n        {\n            for (int i = 0; i < length; i++)\n            {
        {\n            for (int i = 0; i < length; i++)\n            {\n                buf[i] = encryptTable[buf[i]];\n            }\n        }\n        public void Decrypt(byte[] buf, int length)\n        {
            {\n                buf[i] = encryptTable[buf[i]];\n            }\n        }\n        public void Decrypt(byte[] buf, int length)\n        {\n            for (int i = 0; i < length; i++)\n            {
﻿using System;\nusing System.Collections.Generic;
﻿using System;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.Net.Sockets;
﻿using System;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.Net.Sockets;\nusing System.Net;\nusing Shadowsocks.Encryption;\nusing Shadowsocks.Model;
using System.Net;\nusing Shadowsocks.Encryption;\nusing Shadowsocks.Model;\nusing Shadowsocks.Controller.Strategy;\nusing System.Timers;\nnamespace Shadowsocks.Controller\n{\n    class TCPRelay : Listener.Service\n    {\n        private ShadowsocksController _controller;\n        private DateTime _lastSweepTime;
    class TCPRelay : Listener.Service\n    {\n        private ShadowsocksController _controller;\n        private DateTime _lastSweepTime;\n        public ISet<Handler> Handlers\n        {\n            get; set;\n        }\n        public TCPRelay(ShadowsocksController controller)\n        {
        {\n            if (socket.ProtocolType != ProtocolType.Tcp)\n            {\n                return false;\n            }\n            if (length < 2 || firstPacket[0] != 5)\n            {\n                return false;\n            }\n            socket.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);
            if (length < 2 || firstPacket[0] != 5)\n            {\n                return false;\n            }\n            socket.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n            Handler handler = new Handler();\n            handler.connection = socket;\n            handler.controller = _controller;\n            handler.relay = this;\n            handler.Start(firstPacket, length);
            handler.Start(firstPacket, length);\n            IList<Handler> handlersToClose = new List<Handler>();\n            lock (this.Handlers)\n            {\n                this.Handlers.Add(handler);\n                Logging.Debug($"TCP connections: {Handlers.Count}");\n                DateTime now = DateTime.Now;\n                if (now - _lastSweepTime > TimeSpan.FromSeconds(1))\n                {\n                    _lastSweepTime = now;
                    _lastSweepTime = now;\n                    foreach (Handler handler1 in this.Handlers)\n                    {\n                        if (now - handler1.lastActivity > TimeSpan.FromSeconds(900))\n                        {\n                            handlersToClose.Add(handler1);\n                        }\n                    }\n                }\n            }
        }\n    }
        public void CreateRemote()\n        {\n            Server server = controller.GetAServer(IStrategyCallerType.TCP, (IPEndPoint)connection.RemoteEndPoint);\n            if (server == null || server.server == "")\n            {\n                throw new ArgumentException("No server configured");\n            }
            Server server = controller.GetAServer(IStrategyCallerType.TCP, (IPEndPoint)connection.RemoteEndPoint);\n            if (server == null || server.server == "")\n            {\n                throw new ArgumentException("No server configured");\n            }\n            this.encryptor = EncryptorFactory.GetEncryptor(server.method, server.password, server.auth, false);\n            this.server = server;\n        }\n        public void Start(byte[] firstPacket, int length)\n        {
        {\n            this._firstPacket = firstPacket;\n            this._firstPacketLength = length;\n            this.HandshakeReceive();\n            this.lastActivity = DateTime.Now;\n        }\n        private void CheckClose()\n        {\n            if (connectionShutdown && remoteShutdown)\n            {
        {\n            if (connectionShutdown && remoteShutdown)\n            {\n                this.Close();\n            }\n        }\n        public void Close()\n        {\n            lock (relay.Handlers)\n            {
                int bytesRead = _firstPacketLength;\n                if (bytesRead > 1)\n                {\n                    byte[] response = { 5, 0 };\n                    if (_firstPacket[0] != 5)\n                    {\n                        // reject socks 4\n                        response = new byte[] { 0, 91 };\n                        Logging.Error("socks 5 protocol error");\n                    }
                    {\n                        // reject socks 4\n                        response = new byte[] { 0, 91 };\n                        Logging.Error("socks 5 protocol error");\n                    }\n                    Logging.Debug($"======Send Local Port, size:" + response.Length);\n                    connection.BeginSend(response, 0, response.Length, 0, new AsyncCallback(HandshakeSendCallback), null);\n                }\n                else\n                {
            }\n            try\n            {\n                int bytesRead = connection.EndReceive(ar);\n                if (bytesRead >= 3)\n                {\n                    command = connetionRecvBuffer[1];\n                    if (command == 1)\n                    {\n                        byte[] response = { 5, 0, 0, 1, 0, 0, 0, 0, 0, 0 };
                        Logging.Debug($"======Send Local Port, size:" + response.Length);\n                        connection.BeginSend(response, 0, response.Length, 0, new AsyncCallback(ResponseCallback), null);\n                    }\n                    else if (command == 3)\n                    {\n                        HandleUDPAssociate();\n                    }\n                }\n                else\n                {
        {\n            if (closed)\n            {\n                return;\n            }\n            try\n            {\n                if (ar.AsyncState != null)\n                {\n                    connection.EndSend(ar);
                {\n                    connection.EndSend(ar);\n                    Logging.Debug($"======Receive Local Port, size:" + RecvSize);\n                    connection.BeginReceive(connetionRecvBuffer, 0, RecvSize, 0,\n                        new AsyncCallback(ReadAll), null);\n                }\n                else\n                {\n                    int bytesRead = connection.EndReceive(ar);\n                    if (bytesRead > 0)\n                    {
                else\n                {\n                    int bytesRead = connection.EndReceive(ar);\n                    if (bytesRead > 0)\n                    {\n                        Logging.Debug($"======Receive Local Port, size:" + RecvSize);\n                        connection.BeginReceive(connetionRecvBuffer, 0, RecvSize, 0,\n                            new AsyncCallback(ReadAll), null);\n                    }\n                    else\n                    {
            if (strategy != null)\n            {\n                strategy.SetFailure(server);\n            }\n            Logging.Info($"{server.FriendlyName()} timed out");\n            remote.Close();\n            RetryConnect();\n        }\n        private void RetryConnect()\n        {
        private void RetryConnect()\n        {\n            if (retryCount < 4)\n            {\n                Logging.Debug("Connection failed, retrying");\n                StartConnect();\n                retryCount++;\n            }\n            else\n            {
            {\n                return;\n            }\n            try\n            {\n                int bytesRead = remote.EndReceive(ar);\n                totalRead += bytesRead;\n                if (bytesRead > 0)\n                {
                    this.lastActivity = DateTime.Now;\n                    int bytesToSend;\n                    lock (decryptionLock)\n                    {\n                        if (closed)\n                        {\n                            return;\n                        }\n                        encryptor.Decrypt(remoteRecvBuffer, bytesRead, remoteSendBuffer, out bytesToSend);\n                    }
                        {\n                            return;\n                        }\n                        encryptor.Decrypt(remoteRecvBuffer, bytesRead, remoteSendBuffer, out bytesToSend);\n                    }\n                    Logging.Debug($"======Send Local Port, size:" + bytesToSend);\n                    connection.BeginSend(remoteSendBuffer, 0, bytesToSend, 0, new AsyncCallback(PipeConnectionSendCallback), null);\n                    IStrategy strategy = controller.GetCurrentStrategy();\n                    if (strategy != null)\n                    {
                    if (strategy != null)\n                    {\n                        strategy.UpdateLastRead(this.server);\n                    }\n                }\n                else\n                {\n                    connection.Shutdown(SocketShutdown.Send);\n                    connectionShutdown = true;\n                    CheckClose();
                {\n                    int bytesToSend;\n                    lock (encryptionLock)\n                    {\n                        if (closed)\n                        {\n                            return;\n                        }\n                        encryptor.Encrypt(connetionRecvBuffer, bytesRead, connetionSendBuffer, out bytesToSend);\n                    }
                        {\n                            return;\n                        }\n                        encryptor.Encrypt(connetionRecvBuffer, bytesRead, connetionSendBuffer, out bytesToSend);\n                    }\n                    Logging.Debug($"++++++Send Server Port, size:" + bytesToSend);\n                    remote.BeginSend(connetionSendBuffer, 0, bytesToSend, 0, new AsyncCallback(PipeRemoteSendCallback), null);\n                    IStrategy strategy = controller.GetCurrentStrategy();\n                    if (strategy != null)\n                    {

﻿using Shadowsocks.Model;\nusing System;\nusing System.Collections.Generic;\nusing System.Net;\nusing System.Net.NetworkInformation;\nusing System.Net.Sockets;

﻿using System.IO;\nusing Shadowsocks.Model;\nusing System;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.Threading;
using Shadowsocks.Model;\nusing System;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.Threading;\nusing System.Net.Sockets;\nusing Shadowsocks.Controller.Strategy;
using System.Text;\nusing System.Threading;\nusing System.Net.Sockets;\nusing Shadowsocks.Controller.Strategy;\nusing System.Net;\nusing Shadowsocks.Util;
﻿using System;\nusing System.Collections.Generic;
﻿using System;\nusing System.Collections.Generic;\nusing System.Text;\nusing Shadowsocks.Encryption;\nusing Shadowsocks.Model;
﻿using System;
﻿using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.IO.Compression;\nusing System.Runtime.InteropServices;
﻿using System;
﻿using System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Data;\nusing System.Drawing;\nusing System.IO;
﻿using System;
﻿using System;\nusing System.Collections.Generic;\nusing System.Net;\nusing System.Net.Sockets;
        //speed in KiB/s\n        private readonly ConcurrentDictionary<string, List<int>> _inboundSpeedRecords = new ConcurrentDictionary<string, List<int>>();\n        private readonly ConcurrentDictionary<string, List<int>> _outboundSpeedRecords = new ConcurrentDictionary<string, List<int>>();\n        private readonly ConcurrentDictionary<string, InOutBoundRecord> _inOutBoundRecords = new ConcurrentDictionary<string, InOutBoundRecord>();\n        private class InOutBoundRecord\n        {\n            private long _inbound;\n            private long _lastInbound;\n            private long _outbound;\n            private long _lastOutbound;
        private readonly ConcurrentDictionary<string, InOutBoundRecord> _inOutBoundRecords = new ConcurrentDictionary<string, InOutBoundRecord>();\n        private class InOutBoundRecord\n        {\n            private long _inbound;\n            private long _lastInbound;\n            private long _outbound;\n            private long _lastOutbound;\n            private SpinLock _lock = new SpinLock();\n            public void UpdateInbound(long delta)\n            {
            private long _lastOutbound;\n            private SpinLock _lock = new SpinLock();\n            public void UpdateInbound(long delta)\n            {\n                finally\n                {\n                    if (lockTaken)\n                    {\n                        _lock.Exit(false);\n                    }\n                }\n            }\n            public void UpdateOutbound(long delta)\n            {
                }\n            }\n            public void UpdateOutbound(long delta)\n            {\n                finally\n                {\n                    if (lockTaken)\n                    {\n                        _lock.Exit(false);\n                    }\n                }\n            }\n            public void GetDelta(out long inboundDelta, out long outboundDelta)\n            {
﻿using System;\nusing System.Net;\nusing System.Net.Sockets;\nnamespace Shadowsocks.Proxy\n{\n    public interface IProxy\n    {\n        EndPoint LocalEndPoint { get; }\n        EndPoint ProxyEndPoint { get; }
using System.Net.Sockets;\nnamespace Shadowsocks.Proxy\n{\n    public interface IProxy\n    {\n        EndPoint LocalEndPoint { get; }\n        EndPoint ProxyEndPoint { get; }\n        string DestHost { get; }\n        int DestPort { get; }\n        void BeginConnectProxy(EndPoint remoteEP, AsyncCallback callback, object state);\n        void EndConnectProxy(IAsyncResult asyncResult);
            _remote.BeginConnect(remoteEP, ConnectCallback, st);\n        }\n        public void EndConnectProxy(IAsyncResult asyncResult)\n        {\n            var state = ((FakeAsyncResult)asyncResult).innerState;\n            if (state.ex != null)\n            {\n                throw state.ex;\n            }\n        }
            {\n                throw state.ex;\n            }\n        }\n        public void BeginConnectDest(string host, int port, AsyncCallback callback, object state)\n        {\n            DestHost = host;\n            DestPort = port;\n            byte[] request = null;\n            byte atyp = 0;
                        request = new byte[4 + 4 + 2];\n                        atyp = 1; // IP V4 address\n                        break;\n                    case AddressFamily.InterNetworkV6:\n                        request = new byte[4 + 16 + 2];\n                        atyp = 4; // IP V6 address\n                        break;\n                    default:\n                        throw new Exception(I18N.GetString("Proxy request failed"));\n                }
                    case AddressFamily.InterNetworkV6:\n                        request = new byte[4 + 16 + 2];\n                        atyp = 4; // IP V6 address\n                        break;\n                    default:\n                        throw new Exception(I18N.GetString("Proxy request failed"));\n                }\n                var addr = ep.Address.GetAddressBytes();\n                Array.Copy(addr, 0, request, 4, request.Length - 4 - 2);
        {\n            public override AddressFamily AddressFamily { get; } = AddressFamily.Unspecified;\n            public override string ToString()\n            {\n                return "null proxy";\n            }\n        }\n        private Socket _remote;\n        public EndPoint LocalEndPoint => _remote.LocalEndPoint;\n        public EndPoint ProxyEndPoint { get; } = new FakeEndPoint();
        public EndPoint ProxyEndPoint { get; } = new FakeEndPoint();\n        public string DestHost { get; private set; }\n        public int DestPort { get; private set; }\n        public void BeginConnectProxy(EndPoint remoteEP, AsyncCallback callback, object state)\n        {\n            // do nothing\n            var r = new FakeAsyncResult(state);\n            callback?.Invoke(r);\n        }\n        public void EndConnectProxy(IAsyncResult asyncResult)\n        {\n            // do nothing\n        }
            // do nothing\n            var r = new FakeAsyncResult(state);\n            callback?.Invoke(r);\n        }\n        public void EndConnectProxy(IAsyncResult asyncResult)\n        {\n            // do nothing\n        }\n        public void BeginConnectDest(string host, int port, AsyncCallback callback, object state)\n        {
        {\n            // do nothing\n        }\n        public void BeginConnectDest(string host, int port, AsyncCallback callback, object state)\n        {\n            // TODO async resolving\n            IPAddress ipAddress;\n            bool parsed = IPAddress.TryParse(host, out ipAddress);\n            if (!parsed)\n            {
        public void BeginConnectDest(string host, int port, AsyncCallback callback, object state)\n        {\n            // TODO async resolving\n            IPAddress ipAddress;\n            bool parsed = IPAddress.TryParse(host, out ipAddress);\n            if (!parsed)\n            {\n                IPHostEntry ipHostInfo = Dns.GetHostEntry(host);\n                ipAddress = ipHostInfo.AddressList[0];\n            }
            IPAddress ipAddress;\n            bool parsed = IPAddress.TryParse(host, out ipAddress);\n            if (!parsed)\n            {\n                IPHostEntry ipHostInfo = Dns.GetHostEntry(host);\n                ipAddress = ipHostInfo.AddressList[0];\n            }\n            IPEndPoint remoteEP = new IPEndPoint(ipAddress, port);\n            DestHost = host;\n            DestPort = port;\n            if (_remote == null)\n            {
            {\n                IPHostEntry ipHostInfo = Dns.GetHostEntry(host);\n                ipAddress = ipHostInfo.AddressList[0];\n            }\n            IPEndPoint remoteEP = new IPEndPoint(ipAddress, port);\n            DestHost = host;\n            DestPort = port;\n            if (_remote == null)\n            {\n                _remote = new Socket(remoteEP.AddressFamily, SocketType.Stream, ProtocolType.Tcp);\n                _remote.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n            }
        const int queueMaxLength = 60;\n        long lastInbound, lastOutbound;\n        long maxSpeed = 0, lastMaxSpeed = 0;\n        const long minScale = 50;\n        BandwidthScaleInfo bandwidthScale;\n        List<float> inboundPoints = new List<float>();\n        List<float> outboundPoints = new List<float>();\n        TextAnnotation inboundAnnotation = new TextAnnotation();\n        TextAnnotation outboundAnnotation = new TextAnnotation();\n        #endregion
        const long minScale = 50;\n        BandwidthScaleInfo bandwidthScale;\n        List<float> inboundPoints = new List<float>();\n        List<float> outboundPoints = new List<float>();\n        TextAnnotation inboundAnnotation = new TextAnnotation();\n        TextAnnotation outboundAnnotation = new TextAnnotation();\n        #endregion\n        public LogForm(ShadowsocksController controller, string filename=null)\n        {\n            this.controller = controller;
﻿using System;\nusing System.Collections.Generic;
﻿using System;\nusing System.Collections.Generic;\nnamespace Shadowsocks.Encryption\n{
            { "chacha20-ietf", new EncryptorInfo(32, 12, CIPHER_CHACHA20_IETF) }\n        };\n        protected override Dictionary<string, EncryptorInfo> getCiphers()\n        {\n            return _ciphers;\n        }\n        public static List<string> SupportedCiphers()\n        {\n            return new List<string>(_ciphers.Keys);\n        }
        public static List<string> SupportedCiphers()\n        {\n            return new List<string>(_ciphers.Keys);\n        }\n        protected override void cipherUpdate(bool isCipher, int length, byte[] buf, byte[] outbuf)\n        {\n            // TODO write a unidirection cipher so we don't have to if if if\n            int bytesRemaining;\n            ulong ic;\n            byte[] sodiumBuf;\n            byte[] iv;
                bytesRemaining = _decryptBytesRemaining;\n                ic = _decryptIC;\n                sodiumBuf = _decryptBuf;\n                iv = _decryptIV;\n            }\n            int padding = bytesRemaining;\n            Buffer.BlockCopy(buf, 0, sodiumBuf, padding, length);\n            switch (_cipher)\n            {\n                case CIPHER_SALSA20:
                iv = _decryptIV;\n            }\n            int padding = bytesRemaining;\n            Buffer.BlockCopy(buf, 0, sodiumBuf, padding, length);\n            switch (_cipher)\n            {\n                case CIPHER_SALSA20:\n                    Sodium.crypto_stream_salsa20_xor_ic(sodiumBuf, sodiumBuf, (ulong)(padding + length), iv, ic, _key);\n                    break;\n                case CIPHER_CHACHA20:
            Buffer.BlockCopy(buf, 0, sodiumBuf, padding, length);\n            switch (_cipher)\n            {\n                case CIPHER_SALSA20:\n                    Sodium.crypto_stream_salsa20_xor_ic(sodiumBuf, sodiumBuf, (ulong)(padding + length), iv, ic, _key);\n                    break;\n                case CIPHER_CHACHA20:\n                    Sodium.crypto_stream_chacha20_xor_ic(sodiumBuf, sodiumBuf, (ulong)(padding + length), iv, ic, _key);\n                    break;\n                case CIPHER_CHACHA20_IETF:
                    break;\n                case CIPHER_CHACHA20_IETF:\n                    Sodium.crypto_stream_chacha20_ietf_xor_ic(sodiumBuf, sodiumBuf, (ulong)(padding + length), iv, (uint)ic, _key);\n                    break;\n            }\n            Buffer.BlockCopy(sodiumBuf, padding, outbuf, 0, length);\n            padding += length;\n            ic += (ulong)padding / SODIUM_BLOCK_SIZE;\n            bytesRemaining = padding % SODIUM_BLOCK_SIZE;

﻿using System.Text;\nnamespace Shadowsocks.Encryption\n{
    }\n    public abstract class EncryptorBase\n        : IEncryptor\n    {\n        public const int MAX_INPUT_SIZE = 32768;
    }\n    public abstract class EncryptorBase\n        : IEncryptor\n    {\n        public const int MAX_INPUT_SIZE = 32768;\n        protected EncryptorBase(string method, string password, bool onetimeauth, bool isudp)\n        {\n            Method = method;\n            Password = password;
        public const int MAX_INPUT_SIZE = 32768;\n        protected EncryptorBase(string method, string password, bool onetimeauth, bool isudp)\n        {\n            Method = method;\n            Password = password;\n            OnetimeAuth = onetimeauth;\n            IsUDP = isudp;\n        }\n        protected string Method;\n        protected string Password;
﻿using System;\nusing System.IO;\nusing System.Runtime.InteropServices;\nusing Shadowsocks.Controller;\nusing Shadowsocks.Properties;\nusing Shadowsocks.Util;\nnamespace Shadowsocks.Encryption\n{
﻿using System;\nusing System.IO;\nusing System.Runtime.InteropServices;\nusing Shadowsocks.Controller;\nusing Shadowsocks.Properties;\nusing Shadowsocks.Util;\nnamespace Shadowsocks.Encryption\n{\n    public class Sodium\n    {
using Shadowsocks.Properties;\nusing Shadowsocks.Util;\nnamespace Shadowsocks.Encryption\n{\n    public class Sodium\n    {\n        const string DLLNAME = "libsscrypto";\n        static Sodium()\n        {
        static Sodium()\n        {\n            string dllPath = Utils.GetTempPath("libsscrypto.dll");\n            try\n            {\n                FileManager.UncompressFile(dllPath, Resources.libsscrypto_dll);\n            }\n            catch (IOException)\n            {\n            }
        }\n        [DllImport("Kernel32.dll")]\n        private static extern IntPtr LoadLibrary(string path);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
        }\n        [DllImport("Kernel32.dll")]\n        private static extern IntPtr LoadLibrary(string path);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public static extern int crypto_stream_salsa20_xor_ic(byte[] c, byte[] m, ulong mlen, byte[] n, ulong ic, byte[] k);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
        }\n        [DllImport("Kernel32.dll")]\n        private static extern IntPtr LoadLibrary(string path);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public static extern int crypto_stream_salsa20_xor_ic(byte[] c, byte[] m, ulong mlen, byte[] n, ulong ic, byte[] k);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public static extern int crypto_stream_chacha20_xor_ic(byte[] c, byte[] m, ulong mlen, byte[] n, ulong ic, byte[] k);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
        [DllImport("Kernel32.dll")]\n        private static extern IntPtr LoadLibrary(string path);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public static extern int crypto_stream_salsa20_xor_ic(byte[] c, byte[] m, ulong mlen, byte[] n, ulong ic, byte[] k);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public static extern int crypto_stream_chacha20_xor_ic(byte[] c, byte[] m, ulong mlen, byte[] n, ulong ic, byte[] k);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public static extern int crypto_stream_chacha20_ietf_xor_ic(byte[] c, byte[] m, ulong mlen, byte[] n, uint ic, byte[] k);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
            _rng.Dispose();\n            _rng = null;\n        }\n        public static void Reload()\n        {\n            Close();\n            Init();\n        }\n        public static void GetBytes(byte[] buf)\n        {
        {\n            _rng.GetBytes(buf);\n        }\n        public static void GetBytes(byte[] buf, int len)\n        {\n            try\n            {\n                _rng.GetBytes(buf, 0, len);\n            }
using System.Net.Sockets;\nusing System.Runtime.CompilerServices;\nusing Shadowsocks.Controller.Strategy;\nusing Shadowsocks.Encryption;\nusing Shadowsocks.Model;\nnamespace Shadowsocks.Controller\n{\n    class UDPRelay : Listener.Service\n    {\n        private ShadowsocksController _controller;
    class UDPRelay : Listener.Service\n    {\n        private ShadowsocksController _controller;\n        private LRUCache<IPEndPoint, UDPHandler> _cache;\n        public long outbound = 0;\n        public long inbound = 0;\n        public UDPRelay(ShadowsocksController controller)\n        {\n            this._controller = controller;
                if (!parsed)\n                {\n                    IPHostEntry ipHostInfo = Dns.GetHostEntry(server.server);\n                    ipAddress = ipHostInfo.AddressList[0];\n                }\n                _remoteEndPoint = new IPEndPoint(ipAddress, server.server_port);\n                _remote = new Socket(_remoteEndPoint.AddressFamily, SocketType.Dgram, ProtocolType.Udp);\n            }\n            public void Send(byte[] data, int length)\n            {
                    ipAddress = ipHostInfo.AddressList[0];\n                }\n                _remoteEndPoint = new IPEndPoint(ipAddress, server.server_port);\n                _remote = new Socket(_remoteEndPoint.AddressFamily, SocketType.Dgram, ProtocolType.Udp);\n            }\n            public void Send(byte[] data, int length)\n            {\n                IEncryptor encryptor = EncryptorFactory.GetEncryptor(_server.method, _server.password, _server.auth, true);\n                byte[] dataIn = new byte[length - 3 + IVEncryptor.ONETIMEAUTH_BYTES];\n                Array.Copy(data, 3, dataIn, 0, length - 3);
                _remoteEndPoint = new IPEndPoint(ipAddress, server.server_port);\n                _remote = new Socket(_remoteEndPoint.AddressFamily, SocketType.Dgram, ProtocolType.Udp);\n            }\n            public void Send(byte[] data, int length)\n            {\n                IEncryptor encryptor = EncryptorFactory.GetEncryptor(_server.method, _server.password, _server.auth, true);\n                byte[] dataIn = new byte[length - 3 + IVEncryptor.ONETIMEAUTH_BYTES];\n                Array.Copy(data, 3, dataIn, 0, length - 3);\n                byte[] dataOut = new byte[length - 3 + 16 + IVEncryptor.ONETIMEAUTH_BYTES];\n                int outlen;
                Remote = remote;\n            }\n        }\n        class AsyncSession<T> : AsyncSession\n        {\n            public T State { get; set; }\n            public AsyncSession(IProxy remote, T state) : base(remote)\n            {\n                State = state;\n            }
        public static readonly int RecvReserveSize = IVEncryptor.ONETIMEAUTH_BYTES + IVEncryptor.AUTH_BYTES; // reserve for one-time auth\n        public static readonly int BufferSize = RecvSize + RecvReserveSize + 32;\n        public DateTime lastActivity;
        // instance-based lock without static\n            Server server = _controller.GetAServer(IStrategyCallerType.TCP, (IPEndPoint)_connection.RemoteEndPoint, _destEndPoint);\n            if (server == null || server.server == "")\n                throw new ArgumentException("No server configured");
            {\n                _connection.EndSend(ar);\n                // +-----+-----+-------+------+----------+----------+\n                // | VER | CMD |  RSV  | ATYP | DST.ADDR | DST.PORT |\n                // +-----+-----+-------+------+----------+----------+\n                // |  1  |  1  | X'00' |  1   | Variable |    2     |\n                // +-----+-----+-------+------+----------+----------+\n                // Skip first 3 bytes, and read 2 more bytes to analysis the address.\n                // 2 more bytes is designed if address is domain then we don't need to read once more to get the addr length.\n                // TODO validate
        }\n        private void handshakeReceive2Callback(IAsyncResult ar)\n        {\n            if (_closed) return;\n            try\n            {\n                int bytesRead = _connection.EndReceive(ar);\n                if (bytesRead >= 5)\n                {\n                    _command = _connetionRecvBuffer[1];
                if (bytesRead >= 5)\n                {\n                    _command = _connetionRecvBuffer[1];\n                    if (_command != 1 && _command != 3)\n                    {\n                        Logging.Debug("Unsupported CMD=" + _command);\n                        Close();\n                    }\n                    else\n                    {
                    {\n                        Logging.Debug("Unsupported CMD=" + _command);\n                        Close();\n                    }\n                    else\n                    {\n                        if (_command == 1)\n                        {\n                            byte[] response = { 5, 0, 0, 1, 0, 0, 0, 0, 0, 0 };\n                            _connection.BeginSend(response, 0, response.Length, SocketFlags.None,
                        Close();\n                    }\n                    else\n                    {\n                        if (_command == 1)\n                        {\n                            byte[] response = { 5, 0, 0, 1, 0, 0, 0, 0, 0, 0 };\n                            _connection.BeginSend(response, 0, response.Length, SocketFlags.None,\n                                new AsyncCallback(ResponseCallback), null);\n                        }
            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void ReadAddress(Action onSuccess)\n        {\n            int atyp = _connetionRecvBuffer[3];\n            switch (atyp)\n            {
            }\n        }\n        private void ReadAddress(Action onSuccess)\n        {\n            int atyp = _connetionRecvBuffer[3];\n            switch (atyp)\n            {\n                case 1: // IPv4 address, 4 bytes\n                    ReadAddress(4 + 2 - 1, onSuccess);\n                    break;
        private void ReadAddress(Action onSuccess)\n        {\n            int atyp = _connetionRecvBuffer[3];\n            switch (atyp)\n            {\n                case 1: // IPv4 address, 4 bytes\n                    ReadAddress(4 + 2 - 1, onSuccess);\n                    break;\n                case 3: // domain name, length + str\n                    int len = _connetionRecvBuffer[4];
            int atyp = _connetionRecvBuffer[3];\n            switch (atyp)\n            {\n                case 1: // IPv4 address, 4 bytes\n                    ReadAddress(4 + 2 - 1, onSuccess);\n                    break;\n                case 3: // domain name, length + str\n                    int len = _connetionRecvBuffer[4];\n                    ReadAddress(len + 2, onSuccess);\n                    break;
                    ReadAddress(16 + 2 - 1, onSuccess);\n                    break;\n                default:\n                    Logging.Debug("Unsupported ATYP=" + atyp);\n                    Close();\n                    break;\n            }\n        }\n        private void ReadAddress(int bytesRemain, Action onSuccess)\n        {
        }\n        private void OnAddressFullyRead(IAsyncResult ar)\n        {\n            if (_closed) return;\n            try\n            {\n                int bytesRead = _connection.EndReceive(ar);
        {\n            if (_closed) return;\n            try\n            {\n                int bytesRead = _connection.EndReceive(ar);\n                        case 1: // IPv4 address, 4 bytes\n                            dst_addr = new IPAddress(_connetionRecvBuffer.Skip(1).Take(4).ToArray()).ToString();\n                            dst_port = (_connetionRecvBuffer[5] << 8) + _connetionRecvBuffer[6];\n                            break;
            try\n            {\n                int bytesRead = _connection.EndReceive(ar);\n                        case 1: // IPv4 address, 4 bytes\n                            dst_addr = new IPAddress(_connetionRecvBuffer.Skip(1).Take(4).ToArray()).ToString();\n                            dst_port = (_connetionRecvBuffer[5] << 8) + _connetionRecvBuffer[6];\n                            break;\n                        case 3: // domain name, length + str\n                            int len = _connetionRecvBuffer[1];
                        case 1: // IPv4 address, 4 bytes\n                            dst_addr = new IPAddress(_connetionRecvBuffer.Skip(1).Take(4).ToArray()).ToString();\n                            dst_port = (_connetionRecvBuffer[5] << 8) + _connetionRecvBuffer[6];\n                            break;\n                        case 3: // domain name, length + str\n                            int len = _connetionRecvBuffer[1];\n                            dst_addr = System.Text.Encoding.UTF8.GetString(_connetionRecvBuffer, 2, len);\n                            dst_port = (_connetionRecvBuffer[len + 2] << 8) + _connetionRecvBuffer[len + 3];\n                            break;
                            break;\n                    }\n                    if (_config.isVerboseLogging)\n                    {
                            break;\n                    }\n                    if (_config.isVerboseLogging)\n                    {\n            byte[] response = new byte[4 + address.Length + 2];\n            response[0] = 5;\n            switch (endPoint.AddressFamily)\n            {\n                case AddressFamily.InterNetwork:
                    if (_config.isVerboseLogging)\n                    {\n            byte[] response = new byte[4 + address.Length + 2];\n            response[0] = 5;\n            switch (endPoint.AddressFamily)\n            {\n                case AddressFamily.InterNetwork:\n                    response[3] = 1;\n                    break;\n                case AddressFamily.InterNetworkV6:
                case AddressFamily.InterNetwork:\n                    response[3] = 1;\n                    break;\n                case AddressFamily.InterNetworkV6:\n                    response[3] = 4;\n                    break;\n            }\n            address.CopyTo(response, 4);\n            response[response.Length - 1] = (byte)(port & 0xFF);\n            response[response.Length - 2] = (byte)((port >> 8) & 0xFF);
            _connection.BeginSend(response, 0, response.Length, SocketFlags.None, new AsyncCallback(ReadAll), true);\n        }\n        private void ReadAll(IAsyncResult ar)\n        {\n            if (_closed) return;\n            try\n            {\n                if (ar.AsyncState != null)\n                {\n                    _connection.EndSend(ar);
                {\n                    _connection.EndSend(ar);\n                    _connection.BeginReceive(_connetionRecvBuffer, 0, RecvSize, SocketFlags.None, new AsyncCallback(ReadAll), null);\n                }\n                else\n                {\n                    int bytesRead = _connection.EndReceive(ar);\n                    if (bytesRead > 0)\n                    {
            public ServerTimer(int p) : base(p) { }\n        }\n        private void StartConnect()\n        {\n            try\n            {\n                CreateRemote();\n                // Setting up proxy\n                IProxy remote;
                var session = new AsyncSession(remote);\n                lock (_closeConnLock)\n                {\n                    if (_closed)\n                    {\n                        remote.Close();\n                        return;\n                    }\n                    _currentRemoteSession = session;\n                }
                    _currentRemoteSession = session;\n                }\n                ProxyTimer proxyTimer = new ProxyTimer(_proxyTimeout);\n                proxyTimer.AutoReset = false;\n                proxyTimer.Elapsed += proxyConnectTimer_Elapsed;\n                proxyTimer.Enabled = true;\n                proxyTimer.Session = session;\n                proxyTimer.DestEndPoint = SocketUtil.GetEndPoint(_server.server, _server.server_port);\n                proxyTimer.Server = _server;\n                _proxyConnected = false;\n                // Connect to the proxy server.
            {\n                return;\n            }\n            var proxy = timer.Session.Remote;\n            Logging.Info($"Proxy {proxy.ProxyEndPoint} timed out");\n            proxy.Close();\n            Close();\n        }\n        private void ProxyConnectCallback(IAsyncResult ar)\n        {
            Server server = null;\n            if (_closed)\n            {\n                return;\n            }\n            try\n            {
                remote.EndConnectProxy(ar);\n                _proxyConnected = true;\n                if (_config.isVerboseLogging)\n                {\n                    if (!(remote is DirectConnect))\n                    {\n                        Logging.Info($"Socket connected to proxy {remote.ProxyEndPoint}");\n                    }\n                }\n                _startConnectTime = DateTime.Now;
                    }\n                }\n                _startConnectTime = DateTime.Now;\n                ServerTimer connectTimer = new ServerTimer(_serverTimeout);\n                connectTimer.AutoReset = false;\n                connectTimer.Elapsed += destConnectTimer_Elapsed;\n                connectTimer.Enabled = true;\n                connectTimer.Session = session;\n                connectTimer.Server = server;\n                _destConnected = false;\n                // Connect to the remote endpoint.
            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void PipeRemoteReceiveCallback(IAsyncResult ar)\n        {\n            if (_closed) return;\n            try\n            {
            }\n        }\n        private void PipeRemoteReceiveCallback(IAsyncResult ar)\n        {\n            if (_closed) return;\n            try\n            {\n                    int bytesToSend;\n                    lock (_decryptionLock)\n                    {
                Logging.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void PipeConnectionReceiveCallback(IAsyncResult ar)\n        {\n            if (_closed) return;\n            try\n            {\n                int bytesRead = _connection.EndReceive(ar);
            if (_closed) return;\n            try\n            {\n                int bytesRead = _connection.EndReceive(ar);\n                _encryptor.Encrypt(_connetionRecvBuffer, length, _connetionSendBuffer, out bytesToSend);\n            }\n            _tcprelay.UpdateOutboundCounter(_server, bytesToSend);\n            _startSendingTime = DateTime.Now;
            session.Remote.BeginSend(_connetionSendBuffer, 0, bytesToSend, SocketFlags.None, new AsyncCallback(PipeRemoteSendCallback), session);\n            IStrategy strategy = _controller.GetCurrentStrategy();\n            strategy?.UpdateLastWrite(_server);\n        }\n        private void PipeRemoteSendCallback(IAsyncResult ar)\n        {\n            if (_closed) return;\n            try\n            {
            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void PipeConnectionSendCallback(IAsyncResult ar)\n        {\n            try\n            {
﻿using System;\nusing System.Collections.Generic;\nusing System.Runtime.InteropServices;
﻿using System;\nusing System.Collections.Generic;\nusing System.Runtime.InteropServices;\nnamespace Shadowsocks.Encryption\n{
{\n    public class MbedTLSEncryptor\n        : IVEncryptor, IDisposable\n    {\n        const int CIPHER_RC4 = 1;\n        const int CIPHER_AES = 2;\n        const int CIPHER_BLOWFISH = 3;\n        const int CIPHER_CAMELLIA = 4;\n        private IntPtr _encryptCtx = IntPtr.Zero;\n        private IntPtr _decryptCtx = IntPtr.Zero;
        public static List<string> SupportedCiphers()\n        {\n            return new List<string>(_ciphers.Keys);\n        }\n        protected override Dictionary<string, EncryptorInfo> getCiphers()\n        {\n            return _ciphers;\n        }\n        protected override void initCipher(byte[] iv, bool isCipher)\n        {
             * cipher_setkey() will set the correct key schedule\n             * and operation\n             *\n             *  MBEDTLS_AES_{EN,DE}CRYPT\n             *  == MBEDTLS_BLOWFISH_{EN,DE}CRYPT\n             *  == MBEDTLS_CAMELLIA_{EN,DE}CRYPT\n             *  == MBEDTLS_{EN,DE}CRYPT\n             *  \n             */\n            if (MbedTLS.cipher_setkey(ctx, realkey, keyLen * 8,
             *  MBEDTLS_AES_{EN,DE}CRYPT\n             *  == MBEDTLS_BLOWFISH_{EN,DE}CRYPT\n             *  == MBEDTLS_CAMELLIA_{EN,DE}CRYPT\n             *  == MBEDTLS_{EN,DE}CRYPT\n             *  \n             */\n            if (MbedTLS.cipher_setkey(ctx, realkey, keyLen * 8,\n                isCipher ? MbedTLS.MBEDTLS_ENCRYPT : MbedTLS.MBEDTLS_DECRYPT) != 0 )\n                throw new Exception("Cannot set mbed TLS cipher key");\n            if (MbedTLS.cipher_set_iv(ctx, iv, ivLen) != 0)
             *  == MBEDTLS_CAMELLIA_{EN,DE}CRYPT\n             *  == MBEDTLS_{EN,DE}CRYPT\n             *  \n             */\n            if (MbedTLS.cipher_setkey(ctx, realkey, keyLen * 8,\n                isCipher ? MbedTLS.MBEDTLS_ENCRYPT : MbedTLS.MBEDTLS_DECRYPT) != 0 )\n                throw new Exception("Cannot set mbed TLS cipher key");\n            if (MbedTLS.cipher_set_iv(ctx, iv, ivLen) != 0)\n                throw new Exception("Cannot set mbed TLS cipher IV");\n            if (MbedTLS.cipher_reset(ctx) != 0)
             *  \n             */\n            if (MbedTLS.cipher_setkey(ctx, realkey, keyLen * 8,\n                isCipher ? MbedTLS.MBEDTLS_ENCRYPT : MbedTLS.MBEDTLS_DECRYPT) != 0 )\n                throw new Exception("Cannot set mbed TLS cipher key");\n            if (MbedTLS.cipher_set_iv(ctx, iv, ivLen) != 0)\n                throw new Exception("Cannot set mbed TLS cipher IV");\n            if (MbedTLS.cipher_reset(ctx) != 0)\n                throw new Exception("Cannot finalize mbed TLS cipher context");\n        }
                throw new Exception("Cannot set mbed TLS cipher IV");\n            if (MbedTLS.cipher_reset(ctx) != 0)\n                throw new Exception("Cannot finalize mbed TLS cipher context");\n        }\n        protected override void cipherUpdate(bool isCipher, int length, byte[] buf, byte[] outbuf)\n        {\n            // C# could be multi-threaded\n            if (_disposed)\n            {\n                throw new ObjectDisposedException(this.ToString());\n            }
                throw new Exception("Cannot finalize mbed TLS cipher context");\n        }\n        protected override void cipherUpdate(bool isCipher, int length, byte[] buf, byte[] outbuf)\n        {\n            // C# could be multi-threaded\n            if (_disposed)\n            {\n                throw new ObjectDisposedException(this.ToString());\n            }\n            if (MbedTLS.cipher_update(isCipher ? _encryptCtx : _decryptCtx,\n                buf, length, outbuf, ref length) != 0 )
                buf, length, outbuf, ref length) != 0 )\n                throw new Exception("Cannot update mbed TLS cipher context");\n        }\n        #region IDisposable\n        private bool _disposed;\n        // instance based lock\n        private readonly object _lock = new object();\n        public override void Dispose()\n        {\n            Dispose(true);\n            GC.SuppressFinalize(this);\n        }
﻿using System;\nusing System.Collections.Generic;\nusing System.Reflection;\nnamespace Shadowsocks.Encryption\n{\n    public static class EncryptorFactory\n    {
namespace Shadowsocks.Encryption\n{\n    public static class EncryptorFactory\n    {\n        private static Dictionary<string, Type> _registeredEncryptors;\n        private static Type[] _constructorTypes = new Type[] { typeof(string), typeof(string), typeof(bool), typeof(bool) };\n        static EncryptorFactory()\n        {
namespace Shadowsocks.Encryption\n{\n    public static class EncryptorFactory\n    {\n        private static Dictionary<string, Type> _registeredEncryptors;\n        private static Type[] _constructorTypes = new Type[] { typeof(string), typeof(string), typeof(bool), typeof(bool) };\n        static EncryptorFactory()\n        {\n            _registeredEncryptors = new Dictionary<string, Type>();\n            foreach (string method in MbedTLSEncryptor.SupportedCiphers())\n            {
    public static class EncryptorFactory\n    {\n        private static Dictionary<string, Type> _registeredEncryptors;\n        private static Type[] _constructorTypes = new Type[] { typeof(string), typeof(string), typeof(bool), typeof(bool) };\n        static EncryptorFactory()\n        {\n            _registeredEncryptors = new Dictionary<string, Type>();\n            foreach (string method in MbedTLSEncryptor.SupportedCiphers())\n            {\n                _registeredEncryptors.Add(method, typeof(MbedTLSEncryptor));\n            }
        private static Dictionary<string, Type> _registeredEncryptors;\n        private static Type[] _constructorTypes = new Type[] { typeof(string), typeof(string), typeof(bool), typeof(bool) };\n        static EncryptorFactory()\n        {\n            _registeredEncryptors = new Dictionary<string, Type>();\n            foreach (string method in MbedTLSEncryptor.SupportedCiphers())\n            {\n                _registeredEncryptors.Add(method, typeof(MbedTLSEncryptor));\n            }\n            foreach (string method in SodiumEncryptor.SupportedCiphers())\n            {
            foreach (string method in MbedTLSEncryptor.SupportedCiphers())\n            {\n                _registeredEncryptors.Add(method, typeof(MbedTLSEncryptor));\n            }\n            foreach (string method in SodiumEncryptor.SupportedCiphers())\n            {\n                _registeredEncryptors.Add(method, typeof(SodiumEncryptor));\n            }\n        }
            }\n        }\n        public static IEncryptor GetEncryptor(string method, string password, bool onetimeauth, bool isudp)\n        {\n            if (method.IsNullOrEmpty())\n            {\n                method = "aes-256-cfb";\n            }\n            method = method.ToLowerInvariant();\n            Type t = _registeredEncryptors[method];
﻿using System;\nusing System.IO;\nusing System.Runtime.InteropServices;\nusing Shadowsocks.Controller;\nusing Shadowsocks.Properties;\nusing Shadowsocks.Util;\nnamespace Shadowsocks.Encryption\n{
﻿using System;\nusing System.IO;\nusing System.Runtime.InteropServices;\nusing Shadowsocks.Controller;\nusing Shadowsocks.Properties;\nusing Shadowsocks.Util;\nnamespace Shadowsocks.Encryption\n{\n    public class MbedTLS\n    {
using Shadowsocks.Util;\nnamespace Shadowsocks.Encryption\n{\n    public class MbedTLS\n    {\n        const string DLLNAME = "libsscrypto";\n        public const int MBEDTLS_ENCRYPT = 1;\n        public const int MBEDTLS_DECRYPT = 0;\n        static MbedTLS()\n        {
        static MbedTLS()\n        {\n            string dllPath = Utils.GetTempPath("libsscrypto.dll");\n            try\n            {\n                FileManager.UncompressFile(dllPath, Resources.libsscrypto_dll);\n            }\n            catch (IOException)\n            {\n            }
        public static extern int cipher_setkey(IntPtr ctx, byte[] key, int key_bitlen, int operation);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public static extern int cipher_set_iv(IntPtr ctx, byte[] iv, int iv_len);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public static extern int cipher_reset(IntPtr ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public static extern int cipher_update(IntPtr ctx, byte[] input, int ilen, byte[] output, ref int olen);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public static extern void cipher_free(IntPtr ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public static extern int cipher_reset(IntPtr ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public static extern int cipher_update(IntPtr ctx, byte[] input, int ilen, byte[] output, ref int olen);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public static extern void cipher_free(IntPtr ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public static extern void md5(byte[] input, uint ilen, byte[] output);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
            }\n            _serverStatus = newServerStatus;\n            ChooseNewServer();\n        }\n        public Server GetAServer(IStrategyCallerType type, System.Net.IPEndPoint localIPEndPoint)\n        {\n            if (type == IStrategyCallerType.TCP)\n            {\n                ChooseNewServer();\n            }
            return _currentServer;\n        }\n        /**\n         * once failed, try after 5 min\n         * and (last write - last read) < 5s\n         * and (now - last read) <  5s  // means not stuck\n         * and latency < 200ms, try after 30s\n         */\n        public void ChooseNewServer()\n        {

                _currentServer = max.server;\n                if (_currentServer != oldServer)\n                {
                _currentServer = max.server;\n                if (_currentServer != oldServer)\n                {\n                    Console.WriteLine("HA switching to server: {0}", _currentServer.FriendlyName());\n                }
            this.ServerPortTextBox.Size = new System.Drawing.Size(160, 21);\n            this.ServerPortTextBox.TabIndex = 1;\n            this.ServerPortTextBox.WordWrap = false;\n            // \n            // PasswordTextBox\n            // \n            this.PasswordTextBox.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));\n            this.PasswordTextBox.Location = new System.Drawing.Point(83, 60);\n            this.PasswordTextBox.MaxLength = 256;\n            this.PasswordTextBox.Name = "PasswordTextBox";
                {\n                    var reply = await ping.SendTaskAsync(IP, Timeout);\n                    ret.Add(new List<KeyValuePair<string, string>>\n                    {\n                        new KeyValuePair<string, string>("Timestamp", timestamp),\n                        new KeyValuePair<string, string>("Server", server.FriendlyName()),\n                        new KeyValuePair<string, string>("Latency", GetRecentLatency(server)),\n                        new KeyValuePair<string, string>("InboundSpeed", GetRecentInboundSpeed(server)),
            {\n                _speedMonior = new Timer(UpdateSpeed, null, DelayBeforeStart, MonitorInterval);\n            }\n            LoadRawStatistics();\n            FilterRawStatistics();\n            evaluate();\n            ResetSpeed();\n        }\n        private async void evaluate()\n        {
            ResetSpeed();\n        }\n        private async void evaluate()\n        {\n            var geolocationAndIsp = GetGeolocationAndIsp();\n            foreach (var dataLists in await TaskEx.WhenAll(_servers.Select(ICMPTest)))\n            {\n                if (dataLists == null) continue;\n                foreach (var dataList in dataLists.Where(dataList => dataList != null))\n                {
            }\n        }\n        private DateTime ParseExactOrUnknown(string str)\n        {\n            DateTime dateTime;\n            return !DateTime.TryParseExact(str, DateTimePattern, null, DateTimeStyles.None, out dateTime) ? UnknownDateTime : dateTime;\n        }\n        public class State\n        {\n            public DataList dataList = new DataList();
            public DataList dataList = new DataList();\n            public const string Geolocation = "Geolocation";\n            public const string ISP = "ISP";\n            public const string Unknown = "Unknown";\n        }\n        //TODO: redesign model\n        public class RawStatisticsData\n        {\n            public DateTime Timestamp;\n            public string ServerName;\n            public string ICMPStatus;\n            public int RoundtripTime;
            }\n            if (_cipher == CIPHER_AES)\n            {\n                PolarSSL.aes_init(ctx);\n                // PolarSSL takes key length by bit\n                // since we'll use CFB mode, here we both do enc, not dec\n                PolarSSL.aes_setkey_enc(ctx, realkey, keyLen * 8);\n                if (isCipher)\n                {\n                    _encryptIV = new byte[ivLen];
                PolarSSL.aes_setkey_enc(ctx, realkey, keyLen * 8);\n                if (isCipher)\n                {\n                    _encryptIV = new byte[ivLen];\n                    _encryptIVOffset = new byte[8];\n                    Array.Copy(iv, _encryptIV, ivLen);\n                }\n                else\n                {\n                    _decryptIV = new byte[ivLen];
                }\n            }\n            else if (_cipher == CIPHER_BF)\n            {\n                PolarSSL.blowfish_init(ctx);\n                // PolarSSL takes key length by bit\n                PolarSSL.blowfish_setkey(ctx, realkey, keyLen * 8);\n                if (isCipher)\n                {\n                    _encryptIV = new byte[ivLen];
                PolarSSL.blowfish_setkey(ctx, realkey, keyLen * 8);\n                if (isCipher)\n                {\n                    _encryptIV = new byte[ivLen];\n                    _encryptIVOffset = new byte[8];\n                    Array.Copy(iv, _encryptIV, ivLen);\n                }\n                else\n                {\n                    _decryptIV = new byte[ivLen];
                lock (tempbuf)\n                {\n                    // C# could be multi-threaded\n                    if (_disposed)\n                    {\n                        throw new ObjectDisposedException(this.ToString());\n                    }\n                    switch (_cipher)\n                    {\n                        case CIPHER_AES:
                    if (_disposed)\n                    {\n                        throw new ObjectDisposedException(this.ToString());\n                    }\n                    switch (_cipher)\n                    {\n                        case CIPHER_AES:\n                            PolarSSL.aes_crypt_cfb128(_encryptCtx, PolarSSL.AES_ENCRYPT, length, _encryptIVOffset, _encryptIV, buf, tempbuf);\n                            break;\n                        case CIPHER_BF:
            else\n            {\n                outlength = length;\n                if (_disposed)\n                {\n                    throw new ObjectDisposedException(this.ToString());\n                }\n                switch (_cipher)\n                {\n                    case CIPHER_AES:
                if (_disposed)\n                {\n                    throw new ObjectDisposedException(this.ToString());\n                }\n                switch (_cipher)\n                {\n                    case CIPHER_AES:\n                        PolarSSL.aes_crypt_cfb128(_encryptCtx, PolarSSL.AES_ENCRYPT, length, _encryptIVOffset, _encryptIV, buf, outbuf);\n                        break;\n                    case CIPHER_BF:
                {\n                    // C# could be multi-threaded\n                    Buffer.BlockCopy(buf, ivLen, tempbuf, 0, length - ivLen);\n                    if (_disposed)\n                    {\n                        throw new ObjectDisposedException(this.ToString());\n                    }\n                    switch (_cipher)\n                    {\n                        case CIPHER_AES:
                    if (_disposed)\n                    {\n                        throw new ObjectDisposedException(this.ToString());\n                    }\n                    switch (_cipher)\n                    {\n                        case CIPHER_AES:\n                            PolarSSL.aes_crypt_cfb128(_decryptCtx, PolarSSL.AES_DECRYPT, length - ivLen, _decryptIVOffset, _decryptIV, tempbuf, outbuf);\n                            break;\n                        case CIPHER_BF:
            else\n            {\n                outlength = length;\n                if (_disposed)\n                {\n                    throw new ObjectDisposedException(this.ToString());\n                }\n                switch (_cipher)\n                {\n                    case CIPHER_AES:
                if (_disposed)\n                {\n                    throw new ObjectDisposedException(this.ToString());\n                }\n                switch (_cipher)\n                {\n                    case CIPHER_AES:\n                        PolarSSL.aes_crypt_cfb128(_decryptCtx, PolarSSL.AES_DECRYPT, length, _decryptIVOffset, _decryptIV, buf, outbuf);\n                        break;\n                    case CIPHER_BF:
            this.EncryptionLabel.Anchor = System.Windows.Forms.AnchorStyles.Right;\n            this.EncryptionLabel.AutoSize = true;\n            this.EncryptionLabel.Location = new System.Drawing.Point(42, 113);\n            this.EncryptionLabel.Name = "EncryptionLabel";\n            this.EncryptionLabel.Size = new System.Drawing.Size(65, 12);\n            this.EncryptionLabel.TabIndex = 4;\n            this.EncryptionLabel.Text = "Encryption";\n            // \n            // EncryptionSelect\n            // 
﻿using System;
﻿using System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Drawing;
﻿using System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Drawing;\nusing System.Text;\nusing System.Windows.Forms;
﻿using System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Drawing;\nusing System.Text;\nusing System.Windows.Forms;\nusing System.Diagnostics;\nusing Microsoft.Win32;\nusing Shadowsocks.Controller;\nusing Shadowsocks.Model;\nusing Shadowsocks.Properties;
                if (!parsed)\n                {\n                    IPHostEntry ipHostInfo = Dns.GetHostEntry(server.server);\n                    ipAddress = ipHostInfo.AddressList[0];\n                }\n                _remoteEndPoint = new IPEndPoint(ipAddress, server.server_port);\n                _remote = new Socket(_remoteEndPoint.AddressFamily, SocketType.Dgram, ProtocolType.Udp);\n            }\n            public void Send(byte[] data, int length)\n            {
                _remoteEndPoint = new IPEndPoint(ipAddress, server.server_port);\n                _remote = new Socket(_remoteEndPoint.AddressFamily, SocketType.Dgram, ProtocolType.Udp);\n            }\n            public void Send(byte[] data, int length)\n            {\n                IEncryptor encryptor = EncryptorFactory.GetEncryptor(_server.method, _server.password, _server.one_time_auth);\n                byte[] dataIn = new byte[length - 3 + IVEncryptor.ONETIMEAUTH_BYTES];\n                Array.Copy(data, 3, dataIn, 0, length - 3);\n                byte[] dataOut = new byte[length - 3 + 16 + IVEncryptor.ONETIMEAUTH_BYTES];\n                int outlen;
            counter++;\n        }\n        protected byte[] genHash(byte[] buf, int offset, int len)\n        {\n            byte[] hash = new byte[20];\n            updateKeyBuffer();\n            Sodium.ss_sha1_hmac_ex(_keyBuffer, (uint)_keyBuffer.Length,\n                buf, offset, (uint)len, hash);\n            return hash;\n        }
            byte[] hash = new byte[20];\n            updateKeyBuffer();\n            Sodium.ss_sha1_hmac_ex(_keyBuffer, (uint)_keyBuffer.Length,\n                buf, offset, (uint)len, hash);\n            return hash;\n        }\n        public override void Encrypt(byte[] buf, int length, byte[] outbuf, out int outlength, bool udp)\n        {\n            if (!_encryptIVSent)\n            {
        }\n        public override void Encrypt(byte[] buf, int length, byte[] outbuf, out int outlength, bool udp)\n        {\n            if (!_encryptIVSent)\n            {\n                _encryptIVSent = true;\n                randBytes(outbuf, ivLen);\n                initCipher(outbuf, true);\n                outlength = length + ivLen;
                }\n                lock (tempbuf)\n                {\n                    cipherUpdate(true, length, buf, tempbuf);\n                    outlength = length + ivLen;\n                    Buffer.BlockCopy(tempbuf, 0, outbuf, ivLen, length);\n                }\n            }\n            else\n            {
﻿using System.Security.Cryptography;\nusing System.Text;\nnamespace Shadowsocks.Encryption\n{\n    public abstract class EncryptorBase\n        : IEncryptor\n    {\n        public const int MAX_INPUT_SIZE = 32768;
        protected string Method;\n        protected string Password;\n        protected bool OnetimeAuth;\n        protected byte[] GetPasswordHash()\n        {\n            byte[] inputBytes = Encoding.UTF8.GetBytes(Password);\n            byte[] hash = MD5.Create().ComputeHash(inputBytes);\n            return hash;\n        }
            }\n            foreach (string method in PolarSSLEncryptor.SupportedCiphers())\n            {\n                _registeredEncryptors.Add(method, typeof(PolarSSLEncryptor));\n            }\n            foreach (string method in SodiumEncryptor.SupportedCiphers())\n            {\n                _registeredEncryptors.Add(method, typeof(SodiumEncryptor));\n            }\n        }
        }\n        public static IEncryptor GetEncryptor(string method, string password, bool onetimeauth)\n        {\n            if (string.IsNullOrEmpty(method))\n            {\n                method = "table";\n            }\n            method = method.ToLowerInvariant();\n            Type t = _registeredEncryptors[method];\n            ConstructorInfo c = t.GetConstructor(_constructorTypes);
        }\n        private void RunEncryptionRound(IEncryptor encryptor, IEncryptor decryptor)\n        {\n            byte[] plain = new byte[16384];\n            byte[] cipher = new byte[plain.Length + 16 + IVEncryptor.ONETIMEAUTH_BYTES + IVEncryptor.AUTH_BYTES];\n            byte[] plain2 = new byte[plain.Length + 16];\n            int outLen = 0;\n            int outLen2 = 0;\n            var random = new Random();\n            random.NextBytes(plain);
            int outLen2 = 0;\n            var random = new Random();\n            random.NextBytes(plain);\n            encryptor.Encrypt(plain, plain.Length, cipher, out outLen, false);\n            decryptor.Decrypt(cipher, outLen, plain2, out outLen2);\n            Assert.AreEqual(plain.Length, outLen2);\n            for (int j = 0; j < plain.Length; j++)\n            {\n                Assert.AreEqual(plain[j], plain2[j]);\n            }
            {\n                Assert.AreEqual(plain[j], plain2[j]);\n            }\n            encryptor.Encrypt(plain, 1000, cipher, out outLen, false);\n            decryptor.Decrypt(cipher, outLen, plain2, out outLen2);\n            Assert.AreEqual(1000, outLen2);\n            for (int j = 0; j < outLen2; j++)\n            {\n                Assert.AreEqual(plain[j], plain2[j]);\n            }
            this.label2 = new System.Windows.Forms.Label();\n            this.label3 = new System.Windows.Forms.Label();\n            this.label4 = new System.Windows.Forms.Label();\n            this.textBox1 = new System.Windows.Forms.TextBox();\n            this.textBox2 = new System.Windows.Forms.TextBox();\n            this.textBox3 = new System.Windows.Forms.TextBox();\n            this.textBox4 = new System.Windows.Forms.TextBox();\n            this.panel1 = new System.Windows.Forms.Panel();\n            this.button1 = new System.Windows.Forms.Button();
            // button1\n            // \n            this.button1.DialogResult = System.Windows.Forms.DialogResult.OK;\n            this.button1.Location = new System.Drawing.Point(4, 4);\n            this.button1.Name = "button1";\n            this.button1.Size = new System.Drawing.Size(75, 23);\n            this.button1.TabIndex = 0;\n            this.button1.Text = "OK";\n            this.button1.UseVisualStyleBackColor = true;
        public static string AvailabilityStatisticsFile;\n        //static constructor to initialize every public static fields before refereced\n        static AvailabilityStatistics()\n        {\n            AvailabilityStatisticsFile = Utils.GetTempPath(StatisticsFilesName);\n        }\n        //arguments for ICMP tests\n        private int Repeat => Config.RepeatTimesNum;\n        public const int TimeoutMilliseconds = 500;\n        //records cache for current server in {_monitorInterval} minutes
        //static constructor to initialize every public static fields before refereced\n        static AvailabilityStatistics()\n        {\n            AvailabilityStatisticsFile = Utils.GetTempPath(StatisticsFilesName);\n        }\n        //arguments for ICMP tests\n        private int Repeat => Config.RepeatTimesNum;\n        public const int TimeoutMilliseconds = 500;\n        //records cache for current server in {_monitorInterval} minutes\n        private List<int> _latencyRecords;\n        //speed in KiB/s
        //records cache for current server in {_monitorInterval} minutes\n        private List<int> _latencyRecords;\n        //speed in KiB/s\n        private long _lastInboundCounter;\n        private List<int> _inboundSpeedRecords;\n        private long _lastOutboundCounter;\n        private List<int> _outboundSpeedRecords;\n        //tasks\n        private readonly TimeSpan _delayBeforeStart = TimeSpan.FromSeconds(1);\n        private readonly TimeSpan _retryInterval = TimeSpan.FromMinutes(2);\n        private Timer _recorder; //analyze and save cached records to RawStatistics and filter records\n        private TimeSpan RecordingInterval => TimeSpan.FromMinutes(Config.DataCollectionMinutes);\n        private Timer _speedMonior;\n        private readonly TimeSpan _monitorInterval = TimeSpan.FromSeconds(1);
        private List<int> _outboundSpeedRecords;\n        //tasks\n        private readonly TimeSpan _delayBeforeStart = TimeSpan.FromSeconds(1);\n        private readonly TimeSpan _retryInterval = TimeSpan.FromMinutes(2);\n        private Timer _recorder; //analyze and save cached records to RawStatistics and filter records\n        private TimeSpan RecordingInterval => TimeSpan.FromMinutes(Config.DataCollectionMinutes);\n        private Timer _speedMonior;\n        private readonly TimeSpan _monitorInterval = TimeSpan.FromSeconds(1);\n        private Timer _writer; //write RawStatistics to file\n        private readonly TimeSpan _writingInterval = TimeSpan.FromMinutes(1);\n        private ShadowsocksController _controller;\n        private StatisticsStrategyConfiguration Config => _controller.StatisticsConfiguration;
        {\n            _controller = controller;\n            Reset();\n            try\n            {\n                if (Config.StatisticsEnabled)\n                {\n                    StartTimerWithoutState(ref _recorder, Run, RecordingInterval);\n                    LoadRawStatistics();\n                    StartTimerWithoutState(ref _speedMonior, UpdateSpeed, _monitorInterval);
                {\n                    StartTimerWithoutState(ref _recorder, Run, RecordingInterval);\n                    LoadRawStatistics();\n                    StartTimerWithoutState(ref _speedMonior, UpdateSpeed, _monitorInterval);\n                    StartTimerWithoutState(ref _writer, Save, _writingInterval);\n                }\n                else\n                {\n                    _recorder?.Dispose();\n                    _speedMonior?.Dispose();
            }\n            catch (Exception e)\n            {\n                Logging.Error($"An exception occured while eveluating {server.FriendlyName()}");\n                Logging.LogUsefulException(e);\n            }\n            return result;\n        }\n        private void Reset()\n        {
        }\n        private void Run(object _)\n        {\n            UpdateRecords();\n            Reset();\n            FilterRawStatistics();\n        }\n        private async void UpdateRecords()\n        {
        }\n        private async void UpdateRecords()\n        {\n            var currentServerRecord = new StatisticsRecord(CurrentServer.Identifier(), _inboundSpeedRecords, _outboundSpeedRecords, _latencyRecords);\n            if (!Config.Ping)\n            {\n                AppendRecord(CurrentServer, currentServerRecord);\n                return;\n            }
            var currentServerRecord = new StatisticsRecord(CurrentServer.Identifier(), _inboundSpeedRecords, _outboundSpeedRecords, _latencyRecords);\n            if (!Config.Ping)\n            {\n                AppendRecord(CurrentServer, currentServerRecord);\n                return;\n            }\n            {\n                records = new List<StatisticsRecord>();\n            }\n            records.Add(record);\n            RawStatistics[server.Identifier()] = records;\n        }\n        private void Save(object _)\n        {\n            try\n            {
            }\n        private void Save(object _)\n        {\n            try\n            {\n                File.WriteAllText(AvailabilityStatisticsFile,\n                    JsonConvert.SerializeObject(RawStatistics, Formatting.None));\n            }\n            catch (IOException e)\n            {\n                Logging.LogUsefulException(e);
            internal readonly List<int?> RoundtripTime = new List<int?>();\n            internal readonly Server Server;\n            internal ICMPResult(Server server)\n            {\n                Server = server;\n            }\n        }\n        public void Dispose()\n        {\n            _recorder.Dispose();
        public void ToggleCheckingUpdate(bool enabled)\n        {\n            _config.autoCheckUpdate = enabled;\n            Configuration.Save(_config);\n        }\n        public void SaveLogViewerConfig(LogViewerConfig newConfig)\n        {\n            _config.logViewer = newConfig;\n            Configuration.Save(_config);\n        }
        }\n        public void SaveLogViewerConfig(LogViewerConfig newConfig)\n        {\n            _config.logViewer = newConfig;\n            Configuration.Save(_config);\n        }\n        public void UpdateInboundCounter(long n)\n        {\n            Interlocked.Add(ref inboundCounter, n);
﻿using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nnamespace Shadowsocks.Model\n{\n    // Simple processed records for a short period of time\n    public class StatisticsRecord\n    {\n        public DateTime Timestamp { get; set; } = DateTime.Now;
        public int? MaxResponse;\n        public float? PackageLoss;\n        public StatisticsRecord()\n        {\n        }
        public StatisticsRecord()\n        {\n        }\n        public StatisticsRecord(string identifier, IEnumerable<int> inboundSpeedRecords, IEnumerable<int> outboundSpeedRecords, IEnumerable<int> latencyRecords)\n        {
            }\n            if (latencyRecords != null && latencyRecords.Any())\n            {\n                AverageLatency = (int) latencyRecords.Average();\n                MinLatency = latencyRecords.Min();\n                MaxLatency = latencyRecords.Max();\n            }\n        }\n        public StatisticsRecord(string identifier, IEnumerable<int?> responseRecords)\n        {
                AverageLatency = (int) latencyRecords.Average();\n                MinLatency = latencyRecords.Min();\n                MaxLatency = latencyRecords.Max();\n            }\n        }\n        public StatisticsRecord(string identifier, IEnumerable<int?> responseRecords)\n        {\n            ServerName = identifier;\n            setResponse(responseRecords);\n        }
            setResponse(responseRecords);\n        }\n        public void setResponse(IEnumerable<int?> responseRecords)\n        {\n            if (responseRecords == null) return;\n            var records = responseRecords.Where(response => response != null).Select(response => response.Value).ToList();\n            if (!records.Any()) return;\n            AverageResponse = (int?) records.Average();\n            MinResponse = records.Min();\n            MaxResponse = records.Max();
        }\n        private void LoadStatistics()\n        {\n            _filteredStatistics =\n                Service.FilteredStatistics ??\n                Service.RawStatistics ??\n                _filteredStatistics;\n        }\n        //return the score by data\n        //server with highest score will be choosen
            _filteredStatistics =\n                Service.FilteredStatistics ??\n                Service.RawStatistics ??\n                _filteredStatistics;\n        }\n        //return the score by data\n        //server with highest score will be choosen\n        private float GetScore(string serverName)\n        {\n            var config = _controller.StatisticsConfiguration;
            this.byHourOfDayCheckBox = new System.Windows.Forms.CheckBox();\n            this.repeatTimesNum = new System.Windows.Forms.NumericUpDown();\n            this.label6 = new System.Windows.Forms.Label();\n            this.splitContainer3 = new System.Windows.Forms.SplitContainer();\n            this.label1 = new System.Windows.Forms.Label();\n            this.calculationContainer = new System.Windows.Forms.FlowLayoutPanel();\n            this.serverSelector = new System.Windows.Forms.ComboBox();\n            this.CancelButton = new System.Windows.Forms.Button();\n            this.OKButton = new System.Windows.Forms.Button();\n            this.CalculatinTip = new System.Windows.Forms.ToolTip(this.components);
            // \n            // label1\n            // \n            this.label1.Anchor = System.Windows.Forms.AnchorStyles.Right;\n            this.label1.AutoSize = true;
            // label1\n            // \n            this.label1.Anchor = System.Windows.Forms.AnchorStyles.Right;\n            this.label1.AutoSize = true;\n            this.ServersListBox.ItemHeight = 12;\n            this.ServersListBox.Location = new System.Drawing.Point(12, 12);\n            this.ServersListBox.Name = "ServersListBox";
    public class I18N\n    {\n        protected static Dictionary<string, string> Strings;\n        static I18N()\n        {\n            Strings = new Dictionary<string, string>();\n            if (CultureInfo.CurrentCulture.IetfLanguageTag.StartsWith("zh", StringComparison.OrdinalIgnoreCase))\n            {\n                using (var sr = new StringReader(Resources.cn))\n                {
        protected static Dictionary<string, string> Strings;\n        static I18N()\n        {\n            Strings = new Dictionary<string, string>();\n            if (CultureInfo.CurrentCulture.IetfLanguageTag.StartsWith("zh", StringComparison.OrdinalIgnoreCase))\n            {\n                using (var sr = new StringReader(Resources.cn))\n                {\n                    string line;\n                    while ((line = sr.ReadLine()) != null)\n                    {
﻿using System;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.Net.Sockets;\nusing System.Net;\nnamespace shadowsocks_csharp\n{\n    class Local\n    {
using System.Text;\nusing System.Net.Sockets;\nusing System.Net;\nnamespace shadowsocks_csharp\n{\n    class Local\n    {\n        private int port;\n        private Encryptor encryptor;\n        Socket listener;
        Socket listener;\n        public Local(int port)\n        {\n            this.port = port;\n            this.encryptor = new Encryptor("barfoo!");\n        }\n        public void Start()\n        {\n            // Create a TCP/IP socket.\n            listener = new Socket(AddressFamily.InterNetwork,\n                SocketType.Stream, ProtocolType.Tcp);
        public Encryptor encryptor;\n        public const int BufferSize = 1500;\n        // remote receive buffer\n        public byte[] remoteBuffer = new byte[BufferSize];\n        // connection receive buffer\n        public byte[] connetionBuffer = new byte[BufferSize];\n        // Received data string.\n        public StringBuilder sb = new StringBuilder();\n        public void Start()\n        {\n            // TODO async resolving
        public byte[] remoteBuffer = new byte[BufferSize];\n        // connection receive buffer\n        public byte[] connetionBuffer = new byte[BufferSize];\n        // Received data string.\n        public StringBuilder sb = new StringBuilder();\n        public void Start()\n        {\n            // TODO async resolving\n            IPHostEntry ipHostInfo = Dns.GetHostEntry("127.0.0.1");\n            IPAddress ipAddress = ipHostInfo.AddressList[0];
            string argument = @"/select, " + e.Path;\n            Process.Start("explorer.exe", argument);\n        }\n        void ShowBalloonTip(string title, string content, ToolTipIcon icon, int timeout)\n        {\n            _notifyIcon.BalloonTipTitle = title;\n            _notifyIcon.BalloonTipText = content;\n            _notifyIcon.BalloonTipIcon = icon;\n            _notifyIcon.ShowBalloonTip(timeout);\n        }
            _notifyIcon.BalloonTipTitle = title;\n            _notifyIcon.BalloonTipText = content;\n            _notifyIcon.BalloonTipIcon = icon;\n            _notifyIcon.ShowBalloonTip(timeout);\n        }\n        void controller_UpdatePACFromGFWListError(object sender, System.IO.ErrorEventArgs e)\n        {\n            ShowBalloonTip(I18N.GetString("Failed to update PAC file"), e.GetException().Message, ToolTipIcon.Error, 5000);\n            logger.LogUsefulException(e.GetException());\n        }
        private void UpdateSystemProxy()\n        {\n            SystemProxy.Update(_config, false, _pacServer);\n        }\n        private void PacDaemon_PACFileChanged(object sender, EventArgs e)\n        {\n            UpdateSystemProxy();\n        }\n        private void PacServer_PACUpdateCompleted(object sender, GeositeResultEventArgs e)\n        {
        private void PacDaemon_PACFileChanged(object sender, EventArgs e)\n        {\n            UpdateSystemProxy();\n        }\n        private void PacServer_PACUpdateCompleted(object sender, GeositeResultEventArgs e)\n        {\n            UpdatePACFromGFWListCompleted?.Invoke(this, e);\n        }\n        private void PacServer_PACUpdateError(object sender, ErrorEventArgs e)\n        {
using System.Runtime.InteropServices;\nusing System.Text;\nnamespace Shadowsocks.Controller\n{\n    public class SystemProxy\n    {\n        [DllImport("wininet.dll")]\n        public static extern bool InternetSetOption(IntPtr hInternet, int dwOption, IntPtr lpBuffer, int dwBufferLength);\n        public const int INTERNET_OPTION_SETTINGS_CHANGED = 39;\n        public const int INTERNET_OPTION_REFRESH = 37;
            RegistryKey registry = Registry.CurrentUser.OpenSubKey("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings", true);\n            registry.SetValue("ProxyEnable", 0);\n            registry.SetValue("ProxyServer", "");\n            registry.SetValue("AutoConfigURL", "http://127.0.0.1:8090/pac?t=" + GetTimestamp(DateTime.Now));\n            SystemProxy.NotifyIE();\n        }\n        public static void Disable()\n        {
                UpdateCompleted?.Invoke(this, new ResultEventArgs(pacFileChanged));\n            }\n            catch (Exception ex)\n            {\n                Error?.Invoke(this, new ErrorEventArgs(ex));\n            }\n        }\n        public static bool MergeAndWritePACFile(string gfwListResult)\n        {\n            string abpContent = MergePACFile(gfwListResult);
            catch (Exception ex)\n            {\n                Error?.Invoke(this, new ErrorEventArgs(ex));\n            }\n        }\n        public static bool MergeAndWritePACFile(string gfwListResult)\n        {\n            string abpContent = MergePACFile(gfwListResult);\n            if (File.Exists(PACServer.PAC_FILE))\n            {
        {\n            string abpContent = MergePACFile(gfwListResult);\n            if (File.Exists(PACServer.PAC_FILE))\n            {\n                string original = FileManager.NonExclusiveReadAllText(PACServer.PAC_FILE, Encoding.UTF8);\n                if (original == abpContent)\n                {\n                    return false;\n                }\n            }
        private void StopPlugins()\n        {\n            foreach (var serverAndPlugin in _pluginsByServer)\n            {\n                serverAndPlugin.Value?.Dispose();\n            }\n            _pluginsByServer.Clear();\n        }\n        public void TouchPACFile()\n        {
            }\n            _pluginsByServer.Clear();\n        }\n        public void TouchPACFile()\n        {\n            string pacFilename = _pacServer.TouchPACFile();\n            PACFileReadyToOpen?.Invoke(this, new PathEventArgs() { Path = pacFilename });\n        }\n        public void TouchUserRuleFile()\n        {
                privoxyRunner = new PrivoxyRunner();\n            }\n            if (_pacServer == null)\n            {
using System.Text;\nusing Shadowsocks.Encryption;\nusing Shadowsocks.Model;\nusing Shadowsocks.Properties;\nusing Shadowsocks.Util;\nusing System.Threading.Tasks;\nnamespace Shadowsocks.Controller\n{\n    public class PACServer : Listener.Service\n    {
using Shadowsocks.Properties;\nusing Shadowsocks.Util;\nusing System.Threading.Tasks;\nnamespace Shadowsocks.Controller\n{\n    public class PACServer : Listener.Service\n    {\n        public const string PAC_FILE = "pac.txt";\n        public const string USER_RULE_FILE = "user-rule.txt";\n        public const string USER_ABP_FILE = "abp.txt";\n        private string PacSecret { get; set; } = "";\n        public string PacUrl { get; private set; } = "";
using System.Threading.Tasks;\nnamespace Shadowsocks.Controller\n{\n    public class PACServer : Listener.Service\n    {\n        public const string PAC_FILE = "pac.txt";\n        public const string USER_RULE_FILE = "user-rule.txt";\n        public const string USER_ABP_FILE = "abp.txt";\n        private string PacSecret { get; set; } = "";\n        public string PacUrl { get; private set; } = "";\n        FileSystemWatcher PACFileWatcher;\n        FileSystemWatcher UserRuleFileWatcher;\n        private Configuration _config;
    public class PACServer : Listener.Service\n    {\n        public const string PAC_FILE = "pac.txt";\n        public const string USER_RULE_FILE = "user-rule.txt";\n        public const string USER_ABP_FILE = "abp.txt";\n        private string PacSecret { get; set; } = "";\n        public string PacUrl { get; private set; } = "";\n        FileSystemWatcher PACFileWatcher;\n        FileSystemWatcher UserRuleFileWatcher;\n        private Configuration _config;\n        public event EventHandler PACFileChanged;\n        public event EventHandler UserRuleFileChanged;\n        public PACServer()\n        {
        public const string USER_ABP_FILE = "abp.txt";\n        private string PacSecret { get; set; } = "";\n        public string PacUrl { get; private set; } = "";\n        FileSystemWatcher PACFileWatcher;\n        FileSystemWatcher UserRuleFileWatcher;\n        private Configuration _config;\n        public event EventHandler PACFileChanged;\n        public event EventHandler UserRuleFileChanged;\n        public PACServer()\n        {\n            this.WatchPacFile();\n            this.WatchUserRuleFile();\n        }
            if (config.secureLocalPac)\n            {\n                var rd = new byte[32];\n                RNG.GetBytes(rd);\n                PacSecret = $"&secret={Convert.ToBase64String(rd)}";\n            }\n            else\n            {\n                PacSecret = "";\n            }
                var rd = new byte[32];\n                RNG.GetBytes(rd);\n                PacSecret = $"&secret={Convert.ToBase64String(rd)}";\n            }\n            else\n            {\n                PacSecret = "";\n            }\n                foreach (string line in lines)\n                {
                    string[] kv = line.Split(new char[] { ':' }, 2);\n                            }\n                        }\n                        //else if (kv[0] == "User-Agent")\n                        //{\n                        //    // we need to drop connections when changing servers\n                        //    if (kv[1].IndexOf("Chrome") >= 0)\n                        //    {\n                        //        useSocks = true;\n                        //    }\n                        //}
                    }\n                    return true;\n                }\n                return false;\n            }\n            catch (ArgumentException)\n            {\n                return false;\n            }\n        }
                return false;\n            }\n        }\n            {\n                return Utils.UnGzip(Resources.proxy_pac_txt);\n            }\n        }\n        public void SendResponse(Socket socket, bool useSocks)\n        {\n            try\n            {\n                IPEndPoint localEndPoint = (IPEndPoint)socket.LocalEndPoint;\n                string proxy = GetPACAddress(localEndPoint, useSocks);
                var il = Interlocked.Exchange(ref _lastInbound, i);\n                inboundDelta = i - il;\n                var o = Interlocked.Read(ref _outbound);\n                var ol = Interlocked.Exchange(ref _lastOutbound, o);\n                outboundDelta = o - ol;\n            }\n        }\n        //tasks\n        private readonly TimeSpan _delayBeforeStart = TimeSpan.FromSeconds(1);\n        private readonly TimeSpan _retryInterval = TimeSpan.FromMinutes(2);
                var o = Interlocked.Read(ref _outbound);\n                var ol = Interlocked.Exchange(ref _lastOutbound, o);\n                outboundDelta = o - ol;\n            }\n        }\n        //tasks\n        private readonly TimeSpan _delayBeforeStart = TimeSpan.FromSeconds(1);\n        private readonly TimeSpan _retryInterval = TimeSpan.FromMinutes(2);\n        private Timer _recorder; //analyze and save cached records to RawStatistics and filter records\n        private TimeSpan RecordingInterval => TimeSpan.FromMinutes(Config.DataCollectionMinutes);
            RawStatistics = new Statistics();\n        }\n        internal void UpdateConfiguration(ShadowsocksController controller)\n        {\n            _controller = controller;\n            Reset();\n            try\n            {\n                if (Config.StatisticsEnabled)\n                {
        internal void UpdateConfiguration(ShadowsocksController controller)\n        {\n            _controller = controller;\n            Reset();\n            try\n            {\n                if (Config.StatisticsEnabled)\n                {\n                    StartTimerWithoutState(ref _recorder, Run, RecordingInterval);\n                    LoadRawStatistics();
            {\n                if (Config.StatisticsEnabled)\n                {\n                    StartTimerWithoutState(ref _recorder, Run, RecordingInterval);\n                    LoadRawStatistics();\n                    StartTimerWithoutState(ref _speedMonior, UpdateSpeed, _monitorInterval);\n                }\n                else\n                {
                else\n                {\n                    _recorder?.Dispose();\n                    _speedMonior?.Dispose();\n                }\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n            }\n        }
        {\n            foreach (var kv in _inOutBoundRecords)\n            {\n                var id = kv.Key;\n                var record = kv.Value;\n                long inboundDelta, outboundDelta;\n                record.GetDelta(out inboundDelta, out outboundDelta);\n                var inboundSpeed = GetSpeedInKiBPerSecond(inboundDelta, _monitorInterval.TotalSeconds);\n                var outboundSpeed = GetSpeedInKiBPerSecond(outboundDelta, _monitorInterval.TotalSeconds);
                var outboundSpeed = GetSpeedInKiBPerSecond(outboundDelta, _monitorInterval.TotalSeconds);\n        private void Run(object _)\n        {\n            UpdateRecords();\n            Reset();\n        }\n        private void UpdateRecords()\n        {\n            var records = new Dictionary<string, StatisticsRecord>();\n            UpdateRecordsState state = new UpdateRecordsState();
                if (!record.Timestamp.Hour.Equals(DateTime.Now.Hour)) return false;\n            }\n            return true;\n        }\n        private void FilterRawStatistics()\n        {\n            try\n            {\n                Logging.Debug("filter raw statistics");\n                if (RawStatistics == null) return;
        {\n            try\n            {\n                Logging.Debug("filter raw statistics");\n                if (RawStatistics == null) return;\n                if (FilteredStatistics == null)\n                {\n                    FilteredStatistics = new Statistics();\n                }\n                foreach (var serverAndRecords in RawStatistics)\n                {\n                    var server = serverAndRecords.Key;\n                    var filteredRecords = serverAndRecords.Value.FindAll(IsValidRecord);
                    {\n                        //do nothing\n                    }\n                }\n                var content = File.ReadAllText(path);\n                RawStatistics = JsonConvert.DeserializeObject<Statistics>(content) ?? RawStatistics;\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);
                _recorder.Change(_retryInterval, RecordingInterval);\n            }\n        }\n        private static int GetSpeedInKiBPerSecond(long bytes, double seconds)\n        {\n            var result = (int)(bytes / seconds) / 1024;\n            return result;\n        }\n        public void Dispose()\n        {
using Shadowsocks.Model;\nusing Shadowsocks.Properties;\nusing Shadowsocks.Util;\nusing System.Threading.Tasks;\nnamespace Shadowsocks.Controller\n{\n    public class PACServer : Listener.Service\n    {\n        public const string RESOURCE_NAME = "pac";
        private string PacSecret { get; set; } = "";\n        public string PacUrl { get; private set; } = "";\n        private Configuration _config;\n        private PACDaemon _pacDaemon;\n        public PACServer(PACDaemon pacDaemon)\n        {\n            _pacDaemon = pacDaemon;\n        }\n        public void UpdatePACURL(Configuration config)\n        {
                PacSecret = "";\n            }\n            PacUrl = $"http://{config.localHost}:{config.localPort}/{RESOURCE_NAME}?hash={GetHash(_pacDaemon.GetPACContent())}{PacSecret}";\n        }\n        private static string GetHash(string content)\n        {\n            var contentBytes = Encoding.ASCII.GetBytes(content);\n            using (var md5 = System.Security.Cryptography.MD5.Create())\n            {\n                var md5Bytes = md5.ComputeHash(contentBytes);
﻿using System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.IO;\nnamespace Shadowsocks.Controller\n{\n    using Shadowsocks.Properties;
﻿using System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.IO;\nnamespace Shadowsocks.Controller\n{\n    using Shadowsocks.Properties;\n    public class I18N\n    {
        {\n            using (var sr = new StringReader(res))\n            {\n                foreach (var line in sr.NonWhiteSpaceLines())\n                {\n                    if (line[0] == '#')\n                        continue;\n                    var pos = line.IndexOf('=');\n                    if (pos < 1)\n                        continue;
                foreach (var line in sr.NonWhiteSpaceLines())\n                {\n                    if (line[0] == '#')\n                        continue;\n                    var pos = line.IndexOf('=');\n                    if (pos < 1)\n                        continue;\n            Strings = new Dictionary<string, string>();\n            string name = CultureInfo.CurrentCulture.Name;\n            if (name.StartsWith("zh"))\n            {
                        continue;\n            Strings = new Dictionary<string, string>();\n            string name = CultureInfo.CurrentCulture.Name;\n            if (name.StartsWith("zh"))\n            {\n                    Init(Resources.cn);\n                }\n                else\n                {\n                    Init(Resources.zh_tw);\n                }\n            }\n        }\n        public static string GetString(string key)\n        {
                }\n            }\n        }\n        static I18N()\n        {\n            string i18n;\n            string locale = CultureInfo.CurrentCulture.Name;\n            if (!File.Exists(I18N_FILE))\n            {\n                i18n = Resources.i18n_csv;

﻿using System;\nusing System.Diagnostics;\nusing System.Drawing;
﻿using System;\nusing System.Diagnostics;\nusing System.Drawing;\nusing System.Drawing.Imaging;\nusing System.Windows.Forms;\nusing ZXing;\nusing ZXing.Common;\nusing ZXing.QrCode;
                _listener.Stop();\n            }\n            // don't put polipoRunner.Start() before pacServer.Stop()\n            // or bind will fail when switching bind address from 0.0.0.0 to 127.0.0.1\n            // though UseShellExecute is set to true now\n            // http://stackoverflow.com/questions/10235093/socket-doesnt-close-after-application-exits-if-a-launched-process-is-open\n            polipoRunner.Stop();\n            try\n            {\n                polipoRunner.Start(_config);
            // or bind will fail when switching bind address from 0.0.0.0 to 127.0.0.1\n            // though UseShellExecute is set to true now\n            // http://stackoverflow.com/questions/10235093/socket-doesnt-close-after-application-exits-if-a-launched-process-is-open\n            polipoRunner.Stop();\n            try\n            {\n                polipoRunner.Start(_config);\n                Local local = new Local(_config);\n                List<Listener.Service> services = new List<Listener.Service>();
using System.Net;\nusing System.Net.NetworkInformation;\nusing System.Net.Sockets;\nusing System.Text;\nnamespace Shadowsocks.Controller\n{\n    public class Listener\n    {\n        public interface Service\n        {
{\n    public class Listener\n    {\n        public interface Service\n        {\n            bool Handle(byte[] firstPacket, int length, Socket socket);\n        }\n        Configuration _config;\n        bool _shareOverLAN;
        }\n        public void Start(Configuration config)\n        {\n            this._config = config;\n            this._shareOverLAN = config.shareOverLan;\n            if (CheckIfPortInUse(_config.localPort))\n                throw new Exception(I18N.GetString("Port already in use"));\n            try\n            {\n                // Create a TCP/IP socket.
                _socket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, true);\n                IPEndPoint localEndPoint = null;\n                if (_shareOverLAN)\n                {\n                    localEndPoint = new IPEndPoint(IPAddress.Any, _config.localPort);\n                }\n                else\n                {\n                    localEndPoint = new IPEndPoint(IPAddress.Loopback, _config.localPort);\n                }\n                // Bind the socket to the local endpoint and listen for incoming connections.
                    localEndPoint = new IPEndPoint(IPAddress.Any, _config.localPort);\n                }\n                else\n                {\n                    localEndPoint = new IPEndPoint(IPAddress.Loopback, _config.localPort);\n                }\n                // Bind the socket to the local endpoint and listen for incoming connections.\n                _socket.Bind(localEndPoint);\n                _socket.Listen(1024);\n                // Start an asynchronous socket to listen for connections.\n                Console.WriteLine("Shadowsocks started");
                else\n                {\n                    localEndPoint = new IPEndPoint(IPAddress.Loopback, _config.localPort);\n                }\n                // Bind the socket to the local endpoint and listen for incoming connections.\n                _socket.Bind(localEndPoint);\n                _socket.Listen(1024);\n                // Start an asynchronous socket to listen for connections.\n                Console.WriteLine("Shadowsocks started");\n                _socket.BeginAccept(\n                    new AsyncCallback(AcceptCallback),
                _socket.Bind(localEndPoint);\n                _socket.Listen(1024);\n                // Start an asynchronous socket to listen for connections.\n                Console.WriteLine("Shadowsocks started");\n                _socket.BeginAccept(\n                    new AsyncCallback(AcceptCallback),\n                    _socket);\n            }\n            catch (SocketException)\n            {
                    _socket);\n            }\n            catch (SocketException)\n            {\n                _socket.Close();\n                throw;\n            }\n        }\n        public void Stop()\n        {
            catch (SocketException)\n            {\n                _socket.Close();\n                throw;\n            }\n        }\n        public void Stop()\n        {\n            if (_socket != null)\n            {
        private void ReceiveCallback(IAsyncResult ar)\n        {\n            object[] state = (object[])ar.AsyncState;\n            Socket conn = (Socket)state[0];\n            byte[] buf = (byte[])state[1];\n            try\n            {\n                int bytesRead = conn.EndReceive(ar);\n                foreach (Service service in _services)\n                {
            try\n            {\n                int bytesRead = conn.EndReceive(ar);\n                foreach (Service service in _services)\n                {\n                    if (service.Handle(buf, bytesRead, conn))\n                    {\n                        return;\n                    }\n                }\n                // no service found for this
﻿using System;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.Net.Sockets;\nusing System.Net;\nusing Shadowsocks.Encryption;\nusing Shadowsocks.Model;\nnamespace Shadowsocks.Controller\n{
using System.Text;\nusing System.Net.Sockets;\nusing System.Net;\nusing Shadowsocks.Encryption;\nusing Shadowsocks.Model;\nnamespace Shadowsocks.Controller\n{\n    class Local : Listener.Service\n    {\n        private Configuration _config;
using Shadowsocks.Model;\nnamespace Shadowsocks.Controller\n{\n    class Local : Listener.Service\n    {\n        private Configuration _config;\n        public Local(Configuration config)\n        {\n            this._config = config;\n        }
        private Configuration _config;\n        public event EventHandler PACFileChanged;\n        public PACServer()\n        {\n            this.WatchPacFile();\n        }\n        public void UpdateConfiguration(Configuration config)\n        {\n            this._config = config;\n        }
using System.Text;\nnamespace Shadowsocks.Controller\n{\n    class PortForwarder : Listener.Service\n    {\n        int _targetPort;\n        public PortForwarder(int targetPort)\n        {\n            this._targetPort = targetPort;\n        }
﻿using System;\nusing System.Net;\nusing System.Net.Sockets;\nnamespace Shadowsocks.Proxy\n{\n    public interface IProxy\n    {\n        EndPoint LocalEndPoint { get; }\n        EndPoint ProxyEndPoint { get; }\n        EndPoint DestEndPoint { get; }
using System.Net.Sockets;\nnamespace Shadowsocks.Proxy\n{\n    public interface IProxy\n    {\n        EndPoint LocalEndPoint { get; }\n        EndPoint ProxyEndPoint { get; }\n        EndPoint DestEndPoint { get; }\n        IAsyncResult BeginConnectProxy(EndPoint remoteEP, AsyncCallback callback, object state);\n        void EndConnectProxy(IAsyncResult asyncResult);
{\n    public interface IProxy\n    {\n        EndPoint LocalEndPoint { get; }\n        EndPoint ProxyEndPoint { get; }\n        EndPoint DestEndPoint { get; }\n        IAsyncResult BeginConnectProxy(EndPoint remoteEP, AsyncCallback callback, object state);\n        void EndConnectProxy(IAsyncResult asyncResult);\n        IAsyncResult BeginConnectDest(EndPoint remoteEP, AsyncCallback callback, object state);\n        void EndConnectDest(IAsyncResult asyncResult);
        EndPoint LocalEndPoint { get; }\n        EndPoint ProxyEndPoint { get; }\n        EndPoint DestEndPoint { get; }\n        IAsyncResult BeginConnectProxy(EndPoint remoteEP, AsyncCallback callback, object state);\n        void EndConnectProxy(IAsyncResult asyncResult);\n        IAsyncResult BeginConnectDest(EndPoint remoteEP, AsyncCallback callback, object state);\n        void EndConnectDest(IAsyncResult asyncResult);\n        IAsyncResult BeginSend(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state);\n        int EndSend(IAsyncResult asyncResult);
            }\n            public bool IsCompleted { get; } = true;\n            public WaitHandle AsyncWaitHandle { get; } = null;\n            public object AsyncState { get; }\n            public bool CompletedSynchronously { get; } = true;\n        }\n        private Socket _remote;\n        public EndPoint LocalEndPoint => _remote.LocalEndPoint;\n        public EndPoint ProxyEndPoint { get; private set; }\n        public EndPoint DestEndPoint { get; private set; }
        }\n        private Socket _remote;\n        public EndPoint LocalEndPoint => _remote.LocalEndPoint;\n        public EndPoint ProxyEndPoint { get; private set; }\n        public EndPoint DestEndPoint { get; private set; }\n        public IAsyncResult BeginConnectProxy(EndPoint remoteEP, AsyncCallback callback, object state)\n        {\n            // do nothing\n            ProxyEndPoint = remoteEP;\n            var r = new FakeAsyncResult(state);\n            callback?.Invoke(r);
        public IAsyncResult BeginConnectProxy(EndPoint remoteEP, AsyncCallback callback, object state)\n        {\n            // do nothing\n            ProxyEndPoint = remoteEP;\n            var r = new FakeAsyncResult(state);\n            callback?.Invoke(r);\n            return r;\n        }\n        public void EndConnectProxy(IAsyncResult asyncResult)\n        {\n            // do nothing\n        }
            // do nothing\n        }\n        public IAsyncResult BeginConnectDest(EndPoint remoteEP, AsyncCallback callback, object state)\n        {\n            if (_remote == null)\n            {\n                _remote = new Socket(remoteEP.AddressFamily, SocketType.Stream, ProtocolType.Tcp);\n                _remote.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n            }\n            DestEndPoint = remoteEP;
                _remote = new Socket(remoteEP.AddressFamily, SocketType.Stream, ProtocolType.Tcp);\n                _remote.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n            }\n            DestEndPoint = remoteEP;\n            return _remote.BeginConnect(remoteEP, callback, state);\n        }\n        public void EndConnectDest(IAsyncResult asyncResult)\n        {\n            _remote.EndConnect(asyncResult);\n        }
            DestEndPoint = remoteEP;\n            return _remote.BeginConnect(remoteEP, callback, state);\n        }\n        public void EndConnectDest(IAsyncResult asyncResult)\n        {\n            _remote.EndConnect(asyncResult);\n        }\n        public IAsyncResult BeginSend(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state)\n        {
        }\n        public IAsyncResult BeginSend(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state)\n        {\n            return _remote.BeginSend(buffer, offset, size, socketFlags, callback, state);\n        }\n        public int EndSend(IAsyncResult asyncResult)\n        {\n            return _remote.EndSend(asyncResult);\n        }
        {\n            return _remote.BeginSend(buffer, offset, size, socketFlags, callback, state);\n        }\n        public int EndSend(IAsyncResult asyncResult)\n        {\n            return _remote.EndSend(asyncResult);\n        }\n        public IAsyncResult BeginReceive(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state)\n        {
            {\n                return _runningPort;\n            }\n        }\n        public void Start(Configuration configuration)\n        {\n            Server server = configuration.GetCurrentServer();\n            if (_process == null)\n            {\n                Process[] existingPolipo = Process.GetProcessesByName("ss_privoxy");
                Process[] existingPolipo = Process.GetProcessesByName("ss_privoxy");\n                foreach (Process p in existingPolipo)\n                {\n                    KillProcess(p);\n                }\n                string polipoConfig = Resources.privoxy_conf;\n                _runningPort = this.GetFreePort();\n                polipoConfig = polipoConfig.Replace("__SOCKS_PORT__", configuration.localPort.ToString());\n                polipoConfig = polipoConfig.Replace("__POLIPO_BIND_PORT__", _runningPort.ToString());\n                polipoConfig = polipoConfig.Replace("__POLIPO_BIND_IP__", configuration.shareOverLan ? "0.0.0.0" : "127.0.0.1");
                    KillProcess(p);\n                }\n                string polipoConfig = Resources.privoxy_conf;\n                _runningPort = this.GetFreePort();\n                polipoConfig = polipoConfig.Replace("__SOCKS_PORT__", configuration.localPort.ToString());\n                polipoConfig = polipoConfig.Replace("__POLIPO_BIND_PORT__", _runningPort.ToString());\n                polipoConfig = polipoConfig.Replace("__POLIPO_BIND_IP__", configuration.shareOverLan ? "0.0.0.0" : "127.0.0.1");\n                FileManager.ByteArrayToFile(Utils.GetTempPath("privoxy.conf"), Encoding.UTF8.GetBytes(polipoConfig));\n                _process = new Process();\n                // Configure the process using the StartInfo properties.\n                _process.StartInfo.FileName = "ss_privoxy.exe";
        // return path to store temporary files\n        public static string GetTempPath()\n        {\n            if (TempPath == null)\n            {
                     FileMode.Open, FileAccess.Read, FileShare.ReadWrite)))\n            {\n                if (reader.BaseStream.Length > BACK_OFFSET)\n                {\n                    reader.BaseStream.Seek(-BACK_OFFSET, SeekOrigin.End);\n                    reader.ReadLine();\n                }\n                string line = "";\n                while ((line = reader.ReadLine()) != null)
                using (StreamReader reader = new StreamReader(new FileStream(filename,\n                         FileMode.Open, FileAccess.Read, FileShare.ReadWrite)))\n                {\n                    reader.BaseStream.Seek(lastOffset, SeekOrigin.Begin);\n                    string line = "";\n                    bool changed = false;\n                    while ((line = reader.ReadLine()) != null)\n                    {\n                        changed = true;
        public BandwidthScaleInfo(float value, string unitName, long unit)\n        {\n            this.value = value;\n            this.unitName = unitName;\n            this.unit = unit;\n        }\n    }\n    public static class Utils\n    {\n        private static string _tempPath = null;
    {\n        private static string _tempPath = null;\n             "%ProgramW6432%",\n             "%ProgramData%",\n        };\n        // return path to store temporary files\n        public static string GetTempPath()\n        {\n            if (_tempPath == null)\n            {\n                try\n                {
        };\n        // return path to store temporary files\n        public static string GetTempPath()\n        {\n            if (_tempPath == null)\n            {\n                try\n                {\n                    var tempFolder = Configuration.Load().tempFolder;\n                    if (string.IsNullOrWhiteSpace(tempFolder))\n                        // don't use "/", it will fail when we call explorer /select xxx/ss_win_temp\xxx.log
                server.plugin_opts = PluginOptionsTextBox.Text;\n                server.plugin_args = PluginArgumentsTextBox.Text;\n                server.remarks = RemarksTextBox.Text;\n                if (!int.TryParse(TimeoutTextBox.Text, out server.timeout))\n                {\n                    MessageBox.Show(I18N.GetString("Illegal timeout format"));\n                    TimeoutTextBox.Focus();\n                    return false;\n                }\n                int localPort = int.Parse(ProxyPortTextBox.Text);
                        $"Started SIP003 plugin for {server.Identifier()} on {plugin.LocalEndPoint} - PID: {plugin.ProcessId}");\n                }\n            }\n            catch (Exception ex)\n            {\n                Logging.Error("Failed to start SIP003 plugin: " + ex.Message);\n                throw;\n            }\n            return plugin.LocalEndPoint;\n        }
            {\n                Logging.Error("Failed to start SIP003 plugin: " + ex.Message);\n                throw;\n            }\n            return plugin.LocalEndPoint;\n        }\n        public void SaveServers(List<Server> servers, int localPort)\n        {\n            _config.configs = servers;\n            _config.localPort = localPort;

        private System.Windows.Forms.Label TempFolderLabel;\n        private System.Windows.Forms.TextBox PluginArgumentsTextBox;\n        private System.Windows.Forms.Label PluginArgumentsLabel;\n        private System.Windows.Forms.ToolTip toolTip1;
                Close();\n            }\n        }\n        private void PipeRemoteSendCallback(IAsyncResult ar)\n        {\n            if (_closed) return;\n            try\n            {\n                var session = (AsyncSession)ar.AsyncState;\n                session.Remote.EndSend(ar);
                _connection?.BeginReceive(_connetionRecvBuffer, 0, RecvSize, SocketFlags.None, new AsyncCallback(PipeConnectionReceiveCallback), session);\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void PipeConnectionSendCallback(IAsyncResult ar)\n        {
                Logging.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void PipeConnectionSendCallback(IAsyncResult ar)\n        {\n            if (_closed) return;\n            try\n            {\n                var session = (AsyncSession)ar.AsyncState;
        {\n            this.SuspendLayout();\n            // \n            // QRCodeSplashForm\n            // \n            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.None;

            using (Bitmap image = new Bitmap(Screen.PrimaryScreen.Bounds.Width,\n                                            Screen.PrimaryScreen.Bounds.Height))\n            {
            using (Bitmap image = new Bitmap(Screen.PrimaryScreen.Bounds.Width,\n                                            Screen.PrimaryScreen.Bounds.Height))\n            {\n                using (Graphics g = Graphics.FromImage(image))\n                {\n                    g.CopyFromScreen(Screen.PrimaryScreen.Bounds.X,\n                                     Screen.PrimaryScreen.Bounds.Y,\n                                     0, 0,
                                            Screen.PrimaryScreen.Bounds.Height))\n            {\n                using (Graphics g = Graphics.FromImage(image))\n                {\n                    g.CopyFromScreen(Screen.PrimaryScreen.Bounds.X,\n                                     Screen.PrimaryScreen.Bounds.Y,\n                                     0, 0,\n                                     image.Size,\n                                     CopyPixelOperation.SourceCopy);\n                }
                using (Graphics g = Graphics.FromImage(image))\n                {\n                    g.CopyFromScreen(Screen.PrimaryScreen.Bounds.X,\n                                     Screen.PrimaryScreen.Bounds.Y,\n                                     0, 0,\n                                     image.Size,\n                                     CopyPixelOperation.SourceCopy);\n                }\n                var reader = new BarcodeReader\n                {
                                     Screen.PrimaryScreen.Bounds.Y,\n                                     0, 0,\n                                     image.Size,\n                                     CopyPixelOperation.SourceCopy);\n                }\n                var reader = new BarcodeReader\n                {\n                    TryHarder = true,\n                    PossibleFormats = new List<BarcodeFormat>\n                    {
                                     CopyPixelOperation.SourceCopy);\n                }\n                var reader = new BarcodeReader\n                {\n                    TryHarder = true,\n                    PossibleFormats = new List<BarcodeFormat>\n                    {\n                        BarcodeFormat.QR_CODE\n                    }

                        minX -= margin;\n                        maxX += margin;\n                        minY -= margin;\n                        maxY += margin;\n                        QRCodeSplashForm splash = new QRCodeSplashForm();\n                        splash.FormClosed += splash_FormClosed;\n                        splash.Location = new Point((int)minX, (int)minY);
                        maxY += margin;\n                        QRCodeSplashForm splash = new QRCodeSplashForm();\n                        splash.FormClosed += splash_FormClosed;\n                        splash.Location = new Point((int)minX, (int)minY);\n                        splash.Size = new Size((int)maxX - (int)minX, (int)maxY - (int)minY);\n                        splash.Show();\n                        return;\n                    }\n                }
using System.Windows.Forms;\nusing Shadowsocks.Controller;\nusing Shadowsocks.Controller.Hotkeys;\nusing Shadowsocks.Model;\nusing Shadowsocks.Properties;\nusing Shadowsocks.Util;\nnamespace Shadowsocks.View\n{\n    public partial class HotkeySettingsForm : Form\n    {
using Shadowsocks.Controller.Hotkeys;\nusing Shadowsocks.Model;\nusing Shadowsocks.Properties;\nusing Shadowsocks.Util;\nnamespace Shadowsocks.View\n{\n    public partial class HotkeySettingsForm : Form\n    {\n        private ShadowsocksController _controller;\n        // this is a copy of configuration that we are working on\n        private HotkeyConfig _modifiedConfig;
{\n    public partial class HotkeySettingsForm : Form\n    {\n        private ShadowsocksController _controller;\n        // this is a copy of configuration that we are working on\n        private HotkeyConfig _modifiedConfig;\n        private StringBuilder _sb = new StringBuilder();\n        private IEnumerable<TextBox> _allTextBoxes;\n        private Label _lb = null;\n        private HotKeys.HotKeyCallBackHandler _callBack = null;\n        public HotkeySettingsForm(ShadowsocksController controller)\n        {\n            InitializeComponent();\n            UpdateTexts();
        private HotkeyConfig _modifiedConfig;\n        private Label _lb = null;\n        private HotKeys.HotKeyCallBackHandler _callBack = null;\n        public HotkeySettingsForm(ShadowsocksController controller)\n        {\n            InitializeComponent();\n            UpdateTexts();\n            this.Icon = Icon.FromHandle(Resources.ssw128.GetHicon());\n            _controller = controller;\n            _controller.ConfigChanged += controller_ConfigChanged;\n            LoadCurrentConfiguration();\n            // get all textboxes belong to this form
            // I18N stuff\n            SwitchSystemProxyLabel.Text = I18N.GetString("Switch system proxy");\n            SwitchProxyModeLabel.Text = I18N.GetString("Switch system proxy mode");\n            SwitchAllowLanLabel.Text = I18N.GetString("Switch share over LAN");\n            ShowLogsLabel.Text = I18N.GetString("Show Logs");\n            ServerMoveUpLabel.Text = I18N.GetString("Switch to prev server");\n            ServerMoveDownLabel.Text = I18N.GetString("Switch to next server");\n            btnOK.Text = I18N.GetString("OK");\n            btnCancel.Text = I18N.GetString("Cancel");\n            btnRegisterAll.Text = I18N.GetString("Reg All");
            ShowLogsLabel.Text = I18N.GetString("Show Logs");\n            ServerMoveUpLabel.Text = I18N.GetString("Switch to prev server");\n            ServerMoveDownLabel.Text = I18N.GetString("Switch to next server");\n            btnOK.Text = I18N.GetString("OK");\n            btnCancel.Text = I18N.GetString("Cancel");\n            btnRegisterAll.Text = I18N.GetString("Reg All");\n            this.Text = I18N.GetString("Edit Hotkeys...");\n        }\n        /// <summary>\n        /// Capture hotkey - Press key\n        /// </summary>\n        private void HotkeyDown(object sender, KeyEventArgs e)\n        {
            //Combination key only\n            if (e.Modifiers != 0)\n            {\n                // XXX: Hotkey parsing depends on the sequence, more specifically, ModifierKeysConverter.\n                // Windows key is reserved by operating system, we deny this key.\n                if (e.Control)\n                {
                {\n            TextBox tb = sender as TextBox;\n            string content = tb.Text.TrimEnd();\n            if (content.Length >= 1 && content[content.Length - 1] == '+')\n            {\n                tb.Text = "";\n            }\n        }\n        private void TextBox_TextChanged(object sender, EventArgs e)\n        {
        private void TextBox_TextChanged(object sender, EventArgs e)\n        {\n            TextBox tb = sender as TextBox;\n            if (tb.Text == "")\n            {\n                // unreg\n                UnregHotkey(tb);\n            }\n        }\n        private void UnregHotkey(TextBox tb)\n        {
            }\n        }\n        private void UnregHotkey(TextBox tb)\n        {\n            PrepareForHotkey(tb, out _callBack, out _lb);\n            UnregPrevHotkey(_callBack);\n        }\n        private void CancelButton_Click(object sender, EventArgs e)\n        {
                        System.Timers.Timer timer = new System.Timers.Timer(10 * 1000);\n                        timer.Elapsed += Timer_Elapsed;\n                        timer.AutoReset = false;\n                        timer.Enabled = true;\n                        timer.Start();\n                    }\n                    break;\n                case PowerModes.Suspend:\n                    if (_controller != null)\n                    {
                    Logging.Info("os suspend");\n                    break;\n            }\n        }\n        private static void Timer_Elapsed(object sender, System.Timers.ElapsedEventArgs e)\n        {\n            try\n            {\n                if (_controller != null)\n                {
        }\n        private static void Application_ApplicationExit(object sender, EventArgs e)\n        {\n            // detach static event handlers\n            Application.ApplicationExit -= Application_ApplicationExit;\n            SystemEvents.PowerModeChanged -= SystemEvents_PowerModeChanged;\n            Application.ThreadException -= Application_ThreadException;\n            HotKeys.Destroy();\n            if (_controller != null)\n            {
        public const int AES_CTX_SIZE = 8 + 4 * 68;\n        public const int AES_ENCRYPT = 1;\n        public const int AES_DECRYPT = 0;\n        static PolarSSL()\n        {\n            string tempPath = Path.GetTempPath();\n            string dllPath = tempPath + "/libsscrypto.dll";\n            try\n            {\n                FileManager.UncompressFile(dllPath, Resources.libsscrypto_dll);
        private void proxyConnectTimer_Elapsed(object sender, ElapsedEventArgs e)\n        {\n            if (_proxyConnected || _destConnected)\n            {\n                return;\n            }
        private void destConnectTimer_Elapsed(object sender, ElapsedEventArgs e)\n        {\n            if (_destConnected)\n            {\n                return;\n            }
        {\n            IPAddress ipAddress;\n            bool parsed = IPAddress.TryParse(host, out ipAddress);\n            if (parsed)\n            {\n                return new IPEndPoint(ipAddress, port);\n            }\n            // maybe is a domain name\n            return new DnsEndPoint2(host, port);\n        }
            bool parsed = IPAddress.TryParse(host, out ipAddress);\n            if (parsed)\n            {\n                return new IPEndPoint(ipAddress, port);\n            }\n            // maybe is a domain name\n            return new DnsEndPoint2(host, port);\n        }\n        private class TcpUserToken : IAsyncResult\n        {
        private class TcpUserToken : IAsyncResult\n        {\n            public AsyncCallback Callback { get; }\n            public SocketAsyncEventArgs Args { get; }\n            public TcpUserToken(AsyncCallback callback, object state, SocketAsyncEventArgs args)\n            {\n                Callback = callback;\n                AsyncState = state;\n                Args = args;\n            }
                AsyncState = state;\n                Args = args;\n            }\n            public bool IsCompleted { get; } = true;\n            public WaitHandle AsyncWaitHandle { get; } = null;\n            public object AsyncState { get; }\n            public bool CompletedSynchronously { get; } = true;\n        }\n        private static void OnTcpConnectCompleted(object sender, SocketAsyncEventArgs args)\n        {\n            TcpUserToken token = (TcpUserToken) args.UserToken;
        public static void BeginConnectTcp(EndPoint endPoint, AsyncCallback callback, object state)\n        {\n            var arg = new SocketAsyncEventArgs();\n            arg.RemoteEndPoint = endPoint;\n            arg.Completed += OnTcpConnectCompleted;\n            arg.UserToken = new TcpUserToken(callback, state, arg);\n            Socket.ConnectAsync(SocketType.Stream, ProtocolType.Tcp, arg);\n        }\n        public static Socket EndConnectTcp(IAsyncResult asyncResult)\n        {
            this.label1 = new System.Windows.Forms.Label();\n            this.label2 = new System.Windows.Forms.Label();\n            this.ProxyPortTextBox = new System.Windows.Forms.TextBox();\n            this.label4 = new System.Windows.Forms.Label();\n            this.label3 = new System.Windows.Forms.Label();\n            this.IPTextBox = new System.Windows.Forms.TextBox();\n            this.ServerPortTextBox = new System.Windows.Forms.TextBox();\n            this.PasswordTextBox = new System.Windows.Forms.TextBox();\n            this.label5 = new System.Windows.Forms.Label();\n            this.EncryptionSelect = new System.Windows.Forms.ComboBox();
            this.IPTextBox = new System.Windows.Forms.TextBox();\n            this.ServerPortTextBox = new System.Windows.Forms.TextBox();\n            this.PasswordTextBox = new System.Windows.Forms.TextBox();\n            this.label5 = new System.Windows.Forms.Label();\n            this.EncryptionSelect = new System.Windows.Forms.ComboBox();\n            this.notifyIcon1 = new System.Windows.Forms.NotifyIcon(this.components);\n            this.panel2 = new System.Windows.Forms.Panel();\n            this.OKButton = new System.Windows.Forms.Button();\n            this.MyCancelButton = new System.Windows.Forms.Button();\n            this.panel1 = new System.Windows.Forms.Panel();
            this.panel2 = new System.Windows.Forms.Panel();\n            this.OKButton = new System.Windows.Forms.Button();\n            this.MyCancelButton = new System.Windows.Forms.Button();\n            this.panel1 = new System.Windows.Forms.Panel();\n            this.QRCodeItem = new System.Windows.Forms.MenuItem();\n            this.ShowLogItem = new System.Windows.Forms.MenuItem();\n            this.aboutItem = new System.Windows.Forms.MenuItem();\n            this.menuItem3 = new System.Windows.Forms.MenuItem();\n            this.quitItem = new System.Windows.Forms.MenuItem();\n            this.panel3 = new System.Windows.Forms.Panel();\n            this.DeleteButton = new System.Windows.Forms.Button();\n            this.AddButton = new System.Windows.Forms.Button();\n            this.ServerGroupBox = new System.Windows.Forms.GroupBox();\n            this.ServersListBox = new System.Windows.Forms.ListBox();
            this.tableLayoutPanel1.Controls.Add(this.label2, 0, 1);\n            this.tableLayoutPanel1.Controls.Add(this.ProxyPortTextBox, 1, 4);\n            this.tableLayoutPanel1.Controls.Add(this.label4, 0, 4);\n            this.tableLayoutPanel1.Controls.Add(this.label3, 0, 2);\n            this.tableLayoutPanel1.Controls.Add(this.IPTextBox, 1, 0);\n            this.tableLayoutPanel1.Controls.Add(this.ServerPortTextBox, 1, 1);\n            this.tableLayoutPanel1.Controls.Add(this.PasswordTextBox, 1, 2);\n            this.tableLayoutPanel1.Controls.Add(this.label5, 0, 3);\n            this.tableLayoutPanel1.Controls.Add(this.EncryptionSelect, 1, 3);\n            this.tableLayoutPanel1.Location = new System.Drawing.Point(8, 21);
            this.tableLayoutPanel1.Controls.Add(this.label4, 0, 4);\n            this.tableLayoutPanel1.Controls.Add(this.label3, 0, 2);\n            this.tableLayoutPanel1.Controls.Add(this.IPTextBox, 1, 0);\n            this.tableLayoutPanel1.Controls.Add(this.ServerPortTextBox, 1, 1);\n            this.tableLayoutPanel1.Controls.Add(this.PasswordTextBox, 1, 2);\n            this.tableLayoutPanel1.Controls.Add(this.label5, 0, 3);\n            this.tableLayoutPanel1.Controls.Add(this.EncryptionSelect, 1, 3);\n            this.tableLayoutPanel1.Location = new System.Drawing.Point(8, 21);\n            this.tableLayoutPanel1.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);\n            this.tableLayoutPanel1.Name = "tableLayoutPanel1";

        private System.Windows.Forms.NotifyIcon notifyIcon1;\n        private System.Windows.Forms.Label label5;\n        private System.Windows.Forms.ComboBox EncryptionSelect;\n        private System.Windows.Forms.Panel panel2;\n        private System.Windows.Forms.Button OKButton;\n        private System.Windows.Forms.Button MyCancelButton;\n        private System.Windows.Forms.Panel panel1;
        private System.Windows.Forms.Panel panel2;\n        private System.Windows.Forms.Button OKButton;\n        private System.Windows.Forms.Button MyCancelButton;\n        private System.Windows.Forms.Panel panel1;\n        private System.Windows.Forms.MenuItem aboutItem;\n        private System.Windows.Forms.MenuItem menuItem3;\n        private System.Windows.Forms.MenuItem quitItem;\n        private System.Windows.Forms.MenuItem ConfigItem;\n        private System.Windows.Forms.MenuItem editPACFileItem;\n        private System.Windows.Forms.Panel panel3;\n        private System.Windows.Forms.Button DeleteButton;\n        private System.Windows.Forms.Button AddButton;\n        private System.Windows.Forms.GroupBox ServerGroupBox;\n        private System.Windows.Forms.ListBox ServersListBox;
        private System.Windows.Forms.Panel panel1;\n        private System.Windows.Forms.MenuItem ConfigItem;\n        private System.Windows.Forms.MenuItem editPACFileItem;\n        private System.Windows.Forms.Panel panel3;\n        private System.Windows.Forms.Button DeleteButton;\n        private System.Windows.Forms.Button AddButton;\n        private System.Windows.Forms.GroupBox ServerGroupBox;\n        private System.Windows.Forms.ListBox ServersListBox;\n        private System.Windows.Forms.MenuItem ServersItem;\n        private System.Windows.Forms.MenuItem SeperatorItem;\n        private System.Windows.Forms.MenuItem menuItem4;\n        private System.Windows.Forms.TextBox RemarksTextBox;\n        private System.Windows.Forms.Label label6;
    {\n        private ShadowsocksController controller;\n        private UpdateChecker updateChecker;\n        // this is a copy of configuration that we are working on\n        private Configuration _modifiedConfiguration;\n        private int _oldSelectedIndex = -1;\n        private bool _isFirstRun;\n        public ConfigForm(ShadowsocksController controller)\n        {\n            InitializeComponent();
        private UpdateChecker updateChecker;\n        // this is a copy of configuration that we are working on\n        private Configuration _modifiedConfiguration;\n        private int _oldSelectedIndex = -1;\n        private bool _isFirstRun;\n        public ConfigForm(ShadowsocksController controller)\n        {\n            InitializeComponent();\n            LoadTrayIcon();\n            notifyIcon1.ContextMenu = contextMenu1;\n            this.controller = controller;
        private Configuration _modifiedConfiguration;\n        private int _oldSelectedIndex = -1;\n        private bool _isFirstRun;\n        public ConfigForm(ShadowsocksController controller)\n        {\n            InitializeComponent();\n            LoadTrayIcon();\n            notifyIcon1.ContextMenu = contextMenu1;\n            this.controller = controller;\n            controller.EnableStatusChanged += controller_EnableStatusChanged;\n            controller.ConfigChanged += controller_ConfigChanged;
        private bool _isFirstRun;\n        public ConfigForm(ShadowsocksController controller)\n        {\n            InitializeComponent();\n            LoadTrayIcon();\n            notifyIcon1.ContextMenu = contextMenu1;\n            this.controller = controller;\n            controller.EnableStatusChanged += controller_EnableStatusChanged;\n            controller.ConfigChanged += controller_ConfigChanged;\n            controller.PACFileReadyToOpen += controller_PACFileReadyToOpen;\n            controller.ShareOverLANStatusChanged += controller_ShareOverLANStatusChanged;\n            this.updateChecker = new UpdateChecker();\n            updateChecker.NewVersionFound += updateChecker_NewVersionFound;\n            LoadCurrentConfiguration();
            controller.ConfigChanged += controller_ConfigChanged;\n            this.updateChecker = new UpdateChecker();\n            updateChecker.NewVersionFound += updateChecker_NewVersionFound;\n            LoadCurrentConfiguration();\n            {\n                icon = Resources.ss24;\n            }\n            notifyIcon1.Icon = Icon.FromHandle(icon.GetHicon());\n            notifyIcon1.Visible = true;\n            this.Icon = Icon.FromHandle(Resources.ssw128.GetHicon());\n        }\n        private void controller_ConfigChanged(object sender, EventArgs e)\n        {\n            LoadCurrentConfiguration();
                ServersListBox.Items.Add(string.IsNullOrEmpty(server.server) ? "New server" : string.IsNullOrEmpty(server.remarks)? server.server + ":" + server.server_port : server.server + ":" + server.server_port + " (" + server.remarks + ")");\n            }\n        }\n        private void LoadCurrentConfiguration()\n        {\n            _modifiedConfiguration = controller.GetConfiguration();\n            LoadConfiguration(_modifiedConfiguration);\n            _oldSelectedIndex = _modifiedConfiguration.index;\n            ServersListBox.SelectedIndex = _modifiedConfiguration.index;\n            LoadSelectedServer();
        {\n            _modifiedConfiguration = controller.GetConfiguration();\n            LoadConfiguration(_modifiedConfiguration);\n            _oldSelectedIndex = _modifiedConfiguration.index;\n            ServersListBox.SelectedIndex = _modifiedConfiguration.index;\n            LoadSelectedServer();\n            }\n            items.Add(SeperatorItem);\n            items.Add(ConfigItem);\n            if (configuration.index >= 0 && configuration.index < configuration.configs.Count)\n            {\n                items[configuration.index].Checked = true;\n            }\n        }\n        private void ConfigForm_Load(object sender, EventArgs e)\n        {
            {\n                return;\n            }\n            if (_modifiedConfiguration.configs.Count == 0)\n            {\n                MessageBox.Show("Please add at least one server");\n                return;\n            }\n            controller.SaveServers(_modifiedConfiguration.configs);\n            this.Hide();
            {\n                MessageBox.Show("Please add at least one server");\n                return;\n            }\n            controller.SaveServers(_modifiedConfiguration.configs);\n            this.Hide();\n            ShowFirstTimeBalloon();\n        }\n        private void CancelButton_Click(object sender, EventArgs e)\n        {
            ShowFirstTimeBalloon();\n        }\n        private void CancelButton_Click(object sender, EventArgs e)\n        {\n        }\n        private void ShowLogItem_Click(object sender, EventArgs e)\n        {\n            string argument = Logging.LogFile;\n            System.Diagnostics.Process.Start("notepad.exe", argument);\n        }\n        private void ConfigForm_Shown(object sender, EventArgs e)\n        {\n            IPTextBox.Focus();\n        }
        private void CancelButton_Click(object sender, EventArgs e)\n        {\n        {\n            string argument = Logging.LogFile;\n            System.Diagnostics.Process.Start("notepad.exe", argument);\n        }\n        private void ConfigForm_Shown(object sender, EventArgs e)\n        {\n            IPTextBox.Focus();\n        }\n        private void QRCodeItem_Click(object sender, EventArgs e)\n        {
            System.Diagnostics.Process.Start("notepad.exe", argument);\n        }\n        private void ConfigForm_Shown(object sender, EventArgs e)\n        {\n            IPTextBox.Focus();\n        }\n        private void QRCodeItem_Click(object sender, EventArgs e)\n        {\n            QRCodeForm qrCodeForm = new QRCodeForm(controller.GetQRCodeForCurrentServer());\n            qrCodeForm.Icon = this.Icon;\n            qrCodeForm.Show();\n        }
                _listener.Close();\n                throw;\n            }\n        }\n        public void Stop()\n        {\n            _listener.Close();\n        }\n        public void AcceptCallback(IAsyncResult ar)\n        {
        {\n            _listener.Close();\n        }\n        public void AcceptCallback(IAsyncResult ar)\n        {\n            try\n            {\n                Socket listener = (Socket)ar.AsyncState;\n                Socket conn = listener.EndAccept(ar);\n                conn.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);
                return PAC_FILE;\n            }\n            else\n            {\n                FileManager.UncompressFile(PAC_FILE, Resources.proxy_pac_txt);\n                return PAC_FILE;\n            }\n        }\n        public void AcceptCallback(IAsyncResult ar)\n        {
                FileManager.UncompressFile(PAC_FILE, Resources.proxy_pac_txt);\n                return PAC_FILE;\n            }\n        }\n        public void AcceptCallback(IAsyncResult ar)\n        {\n            try\n            {\n                Socket listener = (Socket)ar.AsyncState;\n                Socket conn = listener.EndAccept(ar);
            this.ProxyPortLabel = new System.Windows.Forms.Label();\n            this.PasswordLabel = new System.Windows.Forms.Label();\n            this.IPTextBox = new System.Windows.Forms.TextBox();\n            this.ServerPortTextBox = new System.Windows.Forms.TextBox();\n            this.PasswordTextBox = new System.Windows.Forms.TextBox();\n            this.EncryptionLabel = new System.Windows.Forms.Label();\n            this.EncryptionSelect = new System.Windows.Forms.ComboBox();\n            this.panel2 = new System.Windows.Forms.Panel();\n            this.OKButton = new System.Windows.Forms.Button();\n            this.MyCancelButton = new System.Windows.Forms.Button();
            this.MyCancelButton = new System.Windows.Forms.Button();\n            this.panel1 = new System.Windows.Forms.Panel();\n            this.panel3 = new System.Windows.Forms.Panel();\n            this.DeleteButton = new System.Windows.Forms.Button();\n            this.AddButton = new System.Windows.Forms.Button();\n            this.ServerGroupBox = new System.Windows.Forms.GroupBox();\n            this.ServersListBox = new System.Windows.Forms.ListBox();\n            this.tableLayoutPanel1.SuspendLayout();
            this.tableLayoutPanel1.Name = "tableLayoutPanel1";
            this.OKButton.Location = new System.Drawing.Point(4, 4);\n            this.OKButton.Name = "OKButton";\n            this.OKButton.Size = new System.Drawing.Size(75, 23);\n            this.OKButton.TabIndex = 8;\n            this.OKButton.Text = "OK";\n            this.OKButton.UseVisualStyleBackColor = true;\n            this.OKButton.Click += new System.EventHandler(this.OKButton_Click);\n            // \n            // MyCancelButton\n            // \n            this.MyCancelButton.DialogResult = System.Windows.Forms.DialogResult.Cancel;
            this.MyCancelButton.DialogResult = System.Windows.Forms.DialogResult.Cancel;\n            this.MyCancelButton.Location = new System.Drawing.Point(87, 4);\n            this.MyCancelButton.Name = "MyCancelButton";\n            this.MyCancelButton.Size = new System.Drawing.Size(75, 23);\n            this.MyCancelButton.TabIndex = 9;\n            this.MyCancelButton.Text = "Cancel";\n            this.MyCancelButton.UseVisualStyleBackColor = true;\n            this.MyCancelButton.Click += new System.EventHandler(this.CancelButton_Click);\n            // 
            this.MyCancelButton.Location = new System.Drawing.Point(87, 4);\n            this.MyCancelButton.Name = "MyCancelButton";\n            this.MyCancelButton.Size = new System.Drawing.Size(75, 23);\n            this.MyCancelButton.TabIndex = 9;\n            this.MyCancelButton.Text = "Cancel";\n            this.MyCancelButton.UseVisualStyleBackColor = true;\n            this.MyCancelButton.Click += new System.EventHandler(this.CancelButton_Click);\n            // \n            // \n            this.panel3.AutoSize = true;\n            this.panel3.Controls.Add(this.DeleteButton);\n            this.panel3.Controls.Add(this.AddButton);\n            this.panel3.Location = new System.Drawing.Point(12, 220);\n            this.panel3.Margin = new System.Windows.Forms.Padding(0);\n            this.panel3.Name = "panel3";\n            this.panel3.Size = new System.Drawing.Size(192, 31);\n            this.panel3.TabIndex = 5;\n            // \n            // DeleteButton\n            // 
            // \n            // \n            this.DeleteButton.Location = new System.Drawing.Point(100, 4);\n            this.DeleteButton.Name = "DeleteButton";
            this.AddButton.Location = new System.Drawing.Point(4, 4);\n            this.AddButton.Name = "AddButton";\n            this.ServerGroupBox.Controls.Add(this.tableLayoutPanel1);
            this.ServerGroupBox.Controls.Add(this.tableLayoutPanel1);\n            this.ServerGroupBox.Location = new System.Drawing.Point(220, 12);\n            this.ServerGroupBox.Name = "ServerGroupBox";
            this.ServerGroupBox.Name = "ServerGroupBox";\n            this.ServersListBox.Location = new System.Drawing.Point(12, 12);\n            this.ServersListBox.Name = "ServersListBox";\n            this.CancelButton = this.MyCancelButton;
            this.MinimizeBox = false;\n            this.Name = "ConfigForm";\n            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;\n            this.Text = "Edit Servers";\n            this.FormClosed += new System.Windows.Forms.FormClosedEventHandler(this.ConfigForm_FormClosed);\n            this.Load += new System.EventHandler(this.ConfigForm_Load);\n            this.Shown += new System.EventHandler(this.ConfigForm_Shown);\n            this.tableLayoutPanel1.ResumeLayout(false);\n            this.tableLayoutPanel1.PerformLayout();
        private System.Windows.Forms.Label ProxyPortLabel;\n        private System.Windows.Forms.TextBox IPTextBox;\n        private System.Windows.Forms.TextBox ServerPortTextBox;\n        private System.Windows.Forms.TextBox PasswordTextBox;\n        private System.Windows.Forms.TextBox ProxyPortTextBox;\n        private System.Windows.Forms.Label EncryptionLabel;\n        private System.Windows.Forms.ComboBox EncryptionSelect;\n        private System.Windows.Forms.Panel panel2;\n        private System.Windows.Forms.Button OKButton;\n        private System.Windows.Forms.Button MyCancelButton;
﻿using System;\nusing System.Collections.Generic;
﻿using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net.Sockets;\nusing System.Text;
                        registry.SetValue("AutoConfigURL", "");\n                    }\n                    else\n                    {\n                        string pacUrl;\n                        if (config.useOnlinePac && !string.IsNullOrEmpty(config.pacUrl))\n                            pacUrl = config.pacUrl;\n                        else\n                            pacUrl = "http://127.0.0.1:" + config.localPort.ToString() + "/pac?t=" + GetTimestamp(DateTime.Now);\n                        registry.SetValue("ProxyEnable", 0);
                        else\n                            pacUrl = "http://127.0.0.1:" + config.localPort.ToString() + "/pac?t=" + GetTimestamp(DateTime.Now);\n                        registry.SetValue("ProxyEnable", 0);\n                        registry.SetValue("ProxyServer", "");\n                        registry.SetValue("AutoConfigURL", pacUrl);\n                    }\n                }\n                else\n                {\n                    registry.SetValue("ProxyEnable", 0);

﻿using System;\nusing System.Collections.Generic;\nusing System.Text;

﻿using shadowsocks_csharp.Properties;\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.IO.Compression;\nusing System.Text;
using System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.IO.Compression;\nusing System.Text;\nnamespace shadowsocks_csharp\n{\n    class PolipoRunner\n    {\n        private Process process;
﻿using Microsoft.Win32;\nusing System;\nusing System.Collections.Generic;\nusing System.Runtime.InteropServices;\nusing System.Text;
﻿using Microsoft.Win32;\nusing System;\nusing System.Collections.Generic;\nusing System.Runtime.InteropServices;\nusing System.Text;\nnamespace shadowsocks_csharp\n{
                {\n                    // close when not connected\n                }\n                else\n                {
                else\n                {\n                    Console.WriteLine(e);\n                }\n            }\n            else if (e is ObjectDisposedException)\n            {\n            }\n            else\n            {
using System.Collections.Generic;\nusing System.Net;\nusing System.Net.NetworkInformation;\nusing System.Net.Sockets;\nusing Shadowsocks.Model;\nnamespace Shadowsocks.Controller\n{\n    public class Listener\n    {
                _udpSocket = null;\n            }\n        }\n        public void RecvFromCallback(IAsyncResult ar)\n        {\n            UDPState state = (UDPState)ar.AsyncState;\n            try\n            {\n                int bytesRead = _udpSocket.EndReceiveFrom(ar, ref state.remoteEndPoint);
        static extern int UnregisterApplicationRestart();\n        enum ApplicationRestartFlags\n        {\n            RESTART_NO_CRASH = 1,\n            RESTART_NO_HANG = 2,\n            RESTART_NO_PATCH = 4,\n            RESTART_NO_REBOOT = 8,\n        }\n        // regist restart after system reboot/update\n        public static void RegisterForRestart(bool regist)\n        {
using System.Xml;\nnamespace Shadowsocks.Controller\n{\n    public class UpdateChecker\n    {\n        private const string UpdateURL = "https://sourceforge.net/api/file/index/project-id/1817190/path/dist/mtime/desc/limit/10/rss";\n        public string LatestVersionNumber;\n        public string LatestVersionURL;\n        public event EventHandler NewVersionFound;\n        public const string Version = "2.3";
    public class UpdateChecker\n    {\n        private const string UpdateURL = "https://sourceforge.net/api/file/index/project-id/1817190/path/dist/mtime/desc/limit/10/rss";\n        public string LatestVersionNumber;\n        public string LatestVersionURL;\n        public event EventHandler NewVersionFound;\n        public const string Version = "2.3";\n        public void CheckUpdate()\n        {\n            // TODO test failures\n            WebClient http = new WebClient();
            this.LogMessageTextBox.MaxLength = 2147483647;\n            this.LogMessageTextBox.Multiline = true;\n            this.LogMessageTextBox.Name = "LogMessageTextBox";\n            this.LogMessageTextBox.ReadOnly = true;\n            this.LogMessageTextBox.ScrollBars = System.Windows.Forms.ScrollBars.Both;
                f = f / 1024;\n                unit = "GiB";\n            }\n            if (f > 1024)\n            {\n                f = f / 1024;\n                unit = "TiB";\n            }
        void controller_Errored(object sender, System.IO.ErrorEventArgs e)\n        {\n            MessageBox.Show(e.GetException().ToString(), String.Format(I18N.GetString("Shadowsocks Error: {0}"), e.GetException().Message));\n        }\n        private void UpdateTrayIcon()\n        {\n            int dpi;\n            Graphics graphics = Graphics.FromHwnd(IntPtr.Zero);\n            dpi = (int)graphics.DpiX;\n            graphics.Dispose();
        }\n        private void UpdateTrayIcon()\n        {\n            int dpi;\n            Graphics graphics = Graphics.FromHwnd(IntPtr.Zero);\n            dpi = (int)graphics.DpiX;\n            graphics.Dispose();\n            Bitmap icon = null;\n            if (dpi < 97)\n            {\n                // dpi = 96;
            Graphics graphics = Graphics.FromHwnd(IntPtr.Zero);\n            dpi = (int)graphics.DpiX;\n            graphics.Dispose();\n            Bitmap icon = null;\n            if (dpi < 97)\n            {\n                // dpi = 96;\n                icon = Resources.ss16;\n            }\n            else if (dpi < 121)\n            {\n                // dpi = 120;
            {\n                // dpi = 96;\n                icon = Resources.ss16;\n            }\n            else if (dpi < 121)\n            {\n                // dpi = 120;\n                icon = Resources.ss20;\n            }\n            else\n            {
                // dpi = 120;\n                icon = Resources.ss20;\n            }\n            else\n            {\n                icon = Resources.ss24;\n            }\n            Configuration config = controller.GetConfigurationCopy();\n            bool enabled = config.enabled;\n            bool global = config.global;

            using (Bitmap fullImage = new Bitmap(Screen.PrimaryScreen.Bounds.Width,\n                                            Screen.PrimaryScreen.Bounds.Height))\n            {\n                using (Graphics g = Graphics.FromImage(fullImage))\n                {
            using (Bitmap fullImage = new Bitmap(Screen.PrimaryScreen.Bounds.Width,\n                                            Screen.PrimaryScreen.Bounds.Height))\n            {\n                using (Graphics g = Graphics.FromImage(fullImage))\n                {\n                                     CopyPixelOperation.SourceCopy);\n                }\n                for (int i = 0; i < 5; i++)\n                {\n                    int marginLeft = fullImage.Width * i / 3 / 5;\n                    int marginTop = fullImage.Height * i / 3 / 5;\n                    Rectangle cropRect = new Rectangle(marginLeft, marginTop, fullImage.Width - marginLeft * 2, fullImage.Height - marginTop * 2);\n                    Bitmap target = new Bitmap(cropRect.Width, cropRect.Height);\n                    using (Graphics g = Graphics.FromImage(target))\n                    {
            using (Bitmap fullImage = new Bitmap(Screen.PrimaryScreen.Bounds.Width,\n                                            Screen.PrimaryScreen.Bounds.Height))\n            {\n                using (Graphics g = Graphics.FromImage(fullImage))\n                {\n                {\n                    int marginLeft = fullImage.Width * i / 3 / 5;\n                    int marginTop = fullImage.Height * i / 3 / 5;\n                    Rectangle cropRect = new Rectangle(marginLeft, marginTop, fullImage.Width - marginLeft * 2, fullImage.Height - marginTop * 2);\n                    Bitmap target = new Bitmap(cropRect.Width, cropRect.Height);\n                    using (Graphics g = Graphics.FromImage(target))\n                    {\n                        g.DrawImage(fullImage, new Rectangle(0, 0, target.Width, target.Height),\n                                        cropRect,\n                                        GraphicsUnit.Pixel);\n                    }
                using (Graphics g = Graphics.FromImage(fullImage))\n                {\n                    Rectangle cropRect = new Rectangle(marginLeft, marginTop, fullImage.Width - marginLeft * 2, fullImage.Height - marginTop * 2);\n                    Bitmap target = new Bitmap(cropRect.Width, cropRect.Height);\n                    using (Graphics g = Graphics.FromImage(target))\n                    {\n                        g.DrawImage(fullImage, new Rectangle(0, 0, target.Width, target.Height),\n                                        cropRect,\n                                        GraphicsUnit.Pixel);\n                    }\n                    var source = new BitmapLuminanceSource(target);\n                    var bitmap = new BinaryBitmap(new HybridBinarizer(source));\n                    QRCodeReader reader = new QRCodeReader();\n                    var result = reader.decode(bitmap);\n                    if (result != null)\n                    {
                    {\n                        g.DrawImage(fullImage, new Rectangle(0, 0, target.Width, target.Height),\n                                        cropRect,\n                                        GraphicsUnit.Pixel);\n                    }\n                    var source = new BitmapLuminanceSource(target);\n                    var bitmap = new BinaryBitmap(new HybridBinarizer(source));\n                    QRCodeReader reader = new QRCodeReader();\n                    var result = reader.decode(bitmap);\n                    if (result != null)\n                    {\n                        var success = controller.AddServerBySSURL(result.Text);\n                        QRCodeSplashForm splash = new QRCodeSplashForm();\n                        if (success)\n                        {
                    }\n                    QRCodeReader reader = new QRCodeReader();\n                    var result = reader.decode(bitmap);\n                    if (result != null)\n                    {\n                        var success = controller.AddServerBySSURL(result.Text);\n                        QRCodeSplashForm splash = new QRCodeSplashForm();\n                        if (success)\n                        {\n                            splash.FormClosed += splash_FormClosed;\n                        }
        public byte[] Encrypt(byte[] buf, int length)\n        {\n            switch (method)\n            {\n                case "table":\n                    for (int i = 0; i < length; i++)\n                        buf[i] = encryptTable[buf[i]];
        {\n            switch (method)\n            {\n                case "table":\n                    for (int i = 0; i < length; i++)\n                        buf[i] = encryptTable[buf[i]];\n                    return buf;\n                    break;\n                case "rc4":\n                    rc4.Encrypt(encryptTable, buf, length);
                    return sslEncrypt(buf, length);\n            }\n        }\n        public byte[] Decrypt(byte[] buf, int length)\n        {\n            switch (method)\n            {\n                case "table":\n                    for (int i = 0; i < length; i++)\n                        buf[i] = decryptTable[buf[i]];
        {\n            switch (method)\n            {\n                case "table":\n                    for (int i = 0; i < length; i++)\n                        buf[i] = decryptTable[buf[i]];\n                    return buf;\n                    break;\n                case "rc4":\n                    rc4.Decrypt(decryptTable, buf, length);
using System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Drawing;\nusing System.Text;\nusing System.Windows.Forms;\nusing System.Diagnostics;\nnamespace shadowsocks_csharp\n{\n    public partial class ConfigForm : Form\n    {
using System.Text;\nusing System.Windows.Forms;\nusing System.Diagnostics;\nnamespace shadowsocks_csharp\n{\n    public partial class ConfigForm : Form\n    {\n        Local local;\n        PACServer pacServer;\n        Config config;\n        PolipoRunner polipoRunner;\n        public ConfigForm()\n        {
namespace shadowsocks_csharp\n{\n    public partial class ConfigForm : Form\n    {\n        Local local;\n        PACServer pacServer;\n        Config config;\n        PolipoRunner polipoRunner;\n        public ConfigForm()\n        {\n            config = Config.Load();\n            InitializeComponent();\n            notifyIcon1.ContextMenu = contextMenu1;
            InitializeComponent();\n            notifyIcon1.ContextMenu = contextMenu1;\n            enableItem.Checked = config.enabled;\n            configToTextBox();\n        }\n        private void showWindow()\n        {\n            this.Opacity = 1;\n            this.Show();\n        }
            this.Opacity = 1;\n            this.Show();\n        }\n        private void configToTextBox()\n        {\n            textBox1.Text = config.server;\n            textBox2.Text = config.server_port.ToString();\n            textBox3.Text = config.password;\n            textBox4.Text = config.local_port.ToString();
            textBox1.Text = config.server;\n            textBox2.Text = config.server_port.ToString();\n            textBox3.Text = config.password;\n            textBox4.Text = config.local_port.ToString();\n            comboBox1.Text = config.method == null ? "table" : config.method;\n        }\n        private void Form1_Load(object sender, EventArgs e)\n        {
            textBox3.Text = config.password;\n            textBox4.Text = config.local_port.ToString();\n            comboBox1.Text = config.method == null ? "table" : config.method;\n        }\n        private void Form1_Load(object sender, EventArgs e)\n        {\n            if (!config.isDefault)\n            {\n                this.Opacity = 0;
        private void Form1_Load(object sender, EventArgs e)\n        {\n            if (!config.isDefault)\n            {\n                this.Opacity = 0;\n                reload(config); BeginInvoke(new MethodInvoker(delegate\n                {\n                    this.Hide();\n                }));\n            }
                MessageBox.Show("there is format problem");\n            }\n            catch (Exception ex)\n            {\n                MessageBox.Show(ex.ToString());\n            }\n        }\n        private void cancelButton_Click(object sender, EventArgs e)\n        {\n            this.Hide();
                MessageBox.Show(ex.ToString());\n            }\n        }\n        private void cancelButton_Click(object sender, EventArgs e)\n        {\n            this.Hide();\n            configToTextBox();\n        }\n        private void Form1_FormClosed(object sender, FormClosedEventArgs e)\n        {
            }\n        }\n        private void aboutToolStripMenuItem_Click(object sender, EventArgs e)\n        {\n            Process.Start("https://github.com/clowwindy/shadowsocks-csharp");\n        }\n        private void notifyIcon1_DoubleClick(object sender, EventArgs e)\n        {\n            showWindow();\n        }
            Process.Start("https://github.com/clowwindy/shadowsocks-csharp");\n        }\n        private void notifyIcon1_DoubleClick(object sender, EventArgs e)\n        {\n            showWindow();\n        }\n                SystemProxy.Enable();\n            }\n            else\n            {\n                SystemProxy.Disable();\n            }\n        }\n        private void EnableItem_Click(object sender, EventArgs e)\n        {\n            enableItem.Checked = !enableItem.Checked;
            if (ShareOverLANStatusChanged != null)\n            {\n                ShareOverLANStatusChanged(this, new EventArgs());\n            }\n        }\n        public void DisableProxy()\n        {\n            _config.proxy.useProxy = false;\n            SaveConfig(_config);\n        }
        {\n            _modifiedConfiguration = controller.GetConfigurationCopy().proxy;\n            UseProxyCheckBox.Checked = _modifiedConfiguration.useProxy;\n            ProxyServerTextBox.Text = _modifiedConfiguration.proxyServer;\n            ProxyPortTextBox.Text = _modifiedConfiguration.proxyPort.ToString();\n            ProxyTimeoutTextBox.Text = _modifiedConfiguration.proxyTimeout.ToString();\n            ProxyTypeComboBox.SelectedIndex = _modifiedConfiguration.proxyType;\n        }\n        private void OKButton_Click(object sender, EventArgs e)\n        {
            ProxyServerTextBox.Text = _modifiedConfiguration.proxyServer;\n            ProxyPortTextBox.Text = _modifiedConfiguration.proxyPort.ToString();\n            ProxyTimeoutTextBox.Text = _modifiedConfiguration.proxyTimeout.ToString();\n            ProxyTypeComboBox.SelectedIndex = _modifiedConfiguration.proxyType;\n        }\n        private void OKButton_Click(object sender, EventArgs e)\n        {\n            var type = ProxyTypeComboBox.SelectedIndex;\n            var proxy = ProxyServerTextBox.Text;\n            var port = 0;\n            var timeout = 3;\n            if (UseProxyCheckBox.Checked)\n            {
        }\n        private void OKButton_Click(object sender, EventArgs e)\n        {\n            var type = ProxyTypeComboBox.SelectedIndex;\n            var proxy = ProxyServerTextBox.Text;\n            var port = 0;\n            var timeout = 3;\n            if (UseProxyCheckBox.Checked)\n            {\n                try\n                {\n                    port = int.Parse(ProxyPortTextBox.Text);\n                }\n                catch (FormatException)\n                {\n                    MessageBox.Show(I18N.GetString("Illegal port number format"));
            var timeout = 3;\n            if (UseProxyCheckBox.Checked)\n            {\n                try\n                {\n                    port = int.Parse(ProxyPortTextBox.Text);\n                }\n                catch (FormatException)\n                {\n                    MessageBox.Show(I18N.GetString("Illegal port number format"));\n                    ProxyPortTextBox.Clear();\n                    return;\n                }
                }\n                catch (FormatException)\n                {\n                    MessageBox.Show(I18N.GetString("Illegal port number format"));\n                    ProxyPortTextBox.Clear();\n                    return;\n                }\n                try\n                {\n                    timeout = int.Parse(ProxyTimeoutTextBox.Text);\n                }\n                catch (FormatException)\n                {\n                    MessageBox.Show(I18N.GetString("Illegal timeout format"));
                {\n                    Configuration.CheckServer(proxy);\n                    Configuration.CheckPort(port);\n                    Configuration.CheckTimeout(timeout, ProxyConfig.MaxProxyTimeoutSec);\n                }\n                catch (Exception ex)\n                {\n                    MessageBox.Show(ex.Message);\n                    return;\n                }
                {\n                    MessageBox.Show(ex.Message);\n                    return;\n                }\n                controller.EnableProxy(type, proxy, port);\n            }\n            else\n            {\n                controller.DisableProxy();\n            }
            Logging.Debug(line);\n            if (_requestLineCount == 0)\n            {\n                var m = HttpRequestHeaderRegex.Match(line);\n                if (m.Success)\n                {
            if (_requestLineCount == 0)\n            {\n                var m = HttpRequestHeaderRegex.Match(line);\n                if (m.Success)\n                {\n                    var method = m.Groups["method"].Value;\n                    var path = m.Groups["path"].Value;\n                    if (method == "CONNECT")\n                    {\n                        _isConnect = true;
                {\n                    var method = m.Groups["method"].Value;\n                    var path = m.Groups["path"].Value;\n                    if (method == "CONNECT")\n                    {\n                        _isConnect = true;\n                        if (!ParseHost(path))\n                        {\n                            throw new Exception("Bad http header: " + line);\n                        }\n                    }
            newConfig.SaveSize();\n            Configuration.Save(_config);\n            ConfigChanged?.Invoke(this, new EventArgs());\n        }\n        public void SaveHotkeyConfig(HotkeyConfig newConfig)\n        {\n            _config.hotkey = newConfig;\n            SaveConfig(_config);\n            ConfigChanged?.Invoke(this, new EventArgs());\n        }
        {\n            _config.hotkey = newConfig;\n            SaveConfig(_config);\n            ConfigChanged?.Invoke(this, new EventArgs());\n        }\n        public void UpdateLatency(Server server, TimeSpan latency)\n        {\n            if (_config.availabilityStatistics)\n            {
            {\n                availabilityStatistics.UpdateLatency(server, (int)latency.TotalMilliseconds);\n            }\n        }\n        public void UpdateInboundCounter(Server server, long n)\n        {\n            Interlocked.Add(ref _inboundCounter, n);\n            if (_config.availabilityStatistics)\n            {
            {\n                availabilityStatistics.UpdateInboundCounter(server, n);\n            }\n        }\n        public void UpdateOutboundCounter(Server server, long n)\n        {\n            Interlocked.Add(ref _outboundCounter, n);\n            if (_config.availabilityStatistics)\n            {
        }\n        public override void Stop()\n        {\n            List<TCPHandler> handlersToClose = new List<TCPHandler>();\n            lock (Handlers)\n            {\n                handlersToClose.AddRange(Handlers);\n            }\n            handlersToClose.ForEach(h => h.Close());\n        }
        {\n            List<TCPHandler> handlersToClose = new List<TCPHandler>();\n            lock (Handlers)\n            {\n                handlersToClose.AddRange(Handlers);\n            }\n            handlersToClose.ForEach(h => h.Close());\n        }\n        {\n            _controller.UpdateOutboundCounter(server, n);\n        }\n        public void UpdateLatency(Server server, TimeSpan latency)\n        {\n            IStrategy strategy = _controller.GetCurrentStrategy();\n            strategy?.UpdateLatency(server, latency);\n            _controller.UpdateLatency(server, latency);\n        }\n    }
        }\n    }\n    class SSRelayEventArgs : EventArgs\n    {\n        public readonly Server server;\n        public SSRelayEventArgs(Server server)\n        {\n            this.server = server;\n        }\n    }
    {\n        public readonly Server server;\n        public SSRelayEventArgs(Server server)\n        {\n            this.server = server;\n        }\n    }\n    class SSInboundEventArgs : SSRelayEventArgs\n    {\n        public readonly long length;
        }\n    }\n    class SSInboundEventArgs : SSRelayEventArgs\n    {\n        public readonly long length;\n        public SSInboundEventArgs(Server server, long length) : base(server)\n        {\n            this.length = length;\n        }\n    }
        {\n            this.length = length;\n        }\n    }\n        {\n            this.length = length;\n        }\n    }\n    class SSTCPConnectedEventArgs : SSRelayEventArgs\n    {\n        public readonly TimeSpan latency;\n        public SSTCPConnectedEventArgs(Server server, TimeSpan latency) : base(server)\n        {\n            this.latency = latency;
        public readonly TimeSpan latency;\n        public SSTCPConnectedEventArgs(Server server, TimeSpan latency) : base(server)\n        {\n            this.latency = latency;\n    {\n        public readonly TCPHandler handler;\n        public SSTCPClosedEventArgs(Server server, TCPHandler handler) : base(server)\n        {\n            this.handler = handler;\n        }\n    }\n    internal class TCPHandler\n    {\n        public event EventHandler<SSTCPConnectedEventArgs> OnConnected;
                {\n                    _encryptor.Encrypt(_connetionRecvBuffer, length, _connetionSendBuffer, out bytesToSend);\n                }\n                catch (CryptoErrorException)\n                {\n                    Logger.Debug("encryption error");\n                    Close();\n                    return;\n                }\n            }
                {\n                    Logger.Debug("encryption error");\n                    Close();\n                    return;\n                }\n            }\n            OnOutbound?.Invoke(this, new SSOutboundEventArgs(_server, bytesToSend));\n            _startSendingTime = DateTime.Now;\n            session.Remote.BeginSend(_connetionSendBuffer, 0, bytesToSend, SocketFlags.None,\n                PipeRemoteSendCallback, new object[] { session, bytesToSend });
        protected bool _decryptIVReceived;\n        protected bool _encryptIVSent;\n        protected int _encryptIVOffset = 0;\n        protected int _decryptIVOffset = 0;\n        protected string _method;\n        protected int _cipher;\n        protected int[] _cipherInfo;\n        protected byte[] _key;\n        protected int keyLen;\n        protected int ivLen;
                FileManager.UncompressFile(dllPath, Resources.libsscrypto_dll);\n                LoadLibrary(dllPath);\n            }\n            catch (IOException)\n            {\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine(e.ToString());\n            }
﻿using System.Security.Cryptography;\nusing System.Text;\nnamespace Shadowsocks.Encryption\n{\n    public abstract class EncryptorBase\n        : IEncryptor\n    {\n        public const int MAX_INPUT_SIZE = 32768;
            this.tableLayoutPanel1.Controls.Add(this.IPTextBox, 1, 0);\n            this.tableLayoutPanel1.Controls.Add(this.ServerPortTextBox, 1, 1);\n            this.tableLayoutPanel1.Controls.Add(this.PasswordTextBox, 1, 2);\n            this.tableLayoutPanel1.Controls.Add(this.EncryptionLabel, 0, 3);\n            this.tableLayoutPanel1.Controls.Add(this.EncryptionSelect, 1, 3);\n            this.tableLayoutPanel1.Location = new System.Drawing.Point(8, 21);\n            this.tableLayoutPanel1.Margin = new System.Windows.Forms.Padding(0);\n            this.tableLayoutPanel1.Name = "tableLayoutPanel1";\n            this.tableLayoutPanel1.Padding = new System.Windows.Forms.Padding(3);
            this.tableLayoutPanel1.TabIndex = 0;\n            // \n            // RemarksTextBox\n            // \n            this.RemarksTextBox.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));\n            this.RemarksTextBox.Location = new System.Drawing.Point(72, 111);\n            this.RemarksTextBox.MaxLength = 32;\n            this.RemarksTextBox.Name = "RemarksTextBox";\n            this.RemarksTextBox.Size = new System.Drawing.Size(160, 20);
            this.RemarksTextBox.Location = new System.Drawing.Point(72, 111);\n            this.RemarksTextBox.MaxLength = 32;\n            this.RemarksTextBox.Name = "RemarksTextBox";\n            this.RemarksTextBox.Size = new System.Drawing.Size(160, 20);\n            this.ServerGroupBox.Size = new System.Drawing.Size(249, 174);\n            this.ServerGroupBox.TabIndex = 6;\n            this.ServerGroupBox.TabStop = false;\n            this.ServerGroupBox.Text = "Server";\n            // \n            // ServersListBox\n            // \n            this.ServersListBox.FormattingEnabled = true;\n            this.ServersListBox.IntegralHeight = false;
            }\n            foreach (string method in PolarSSLEncryptor.SupportedCiphers())\n            {\n                _registeredEncryptors.Add(method, typeof(PolarSSLEncryptor));\n            }\n            foreach (string method in SodiumEncryptor.SupportedCiphers())\n            {\n                _registeredEncryptors.Add(method, typeof(SodiumEncryptor));\n            }\n        }
        }\n        public static IEncryptor GetEncryptor(string method, string password)\n        {\n            if (string.IsNullOrEmpty(method))\n            {\n                method = "table";\n            }\n            method = method.ToLowerInvariant();\n            Type t = _registeredEncryptors[method];\n            ConstructorInfo c = t.GetConstructor(_constructorTypes);
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.PluginOptionsLabel.Location = new System.Drawing.Point(18, 166);\n            this.PluginOptionsLabel.Name = "PluginOptionsLabel";
            this.PluginOptionsLabel.Name = "PluginOptionsLabel";\n            this.PluginTextBox.Location = new System.Drawing.Point(113, 135);\n            this.PluginTextBox.MaxLength = 256;\n            this.PluginTextBox.Name = "PluginTextBox";
            this.PluginTextBox.Name = "PluginTextBox";\n            this.RemarksTextBox.Location = new System.Drawing.Point(113, 238);\n            this.RemarksTextBox.MaxLength = 32;\n            this.RemarksTextBox.Name = "RemarksTextBox";
            this.RemarksTextBox.MaxLength = 32;\n            this.RemarksTextBox.Name = "RemarksTextBox";\n            this.IPLabel.Location = new System.Drawing.Point(48, 10);\n            this.IPLabel.Name = "IPLabel";
            this.IPLabel.Name = "IPLabel";\n            this.ServerPortLabel.Location = new System.Drawing.Point(36, 37);\n            this.ServerPortLabel.Name = "ServerPortLabel";
            this.ServerPortLabel.Name = "ServerPortLabel";\n            this.PasswordLabel.Location = new System.Drawing.Point(54, 64);\n            this.PasswordLabel.Name = "PasswordLabel";
            this.PasswordLabel.Name = "PasswordLabel";\n            this.IPTextBox.Location = new System.Drawing.Point(113, 6);\n            this.IPTextBox.MaxLength = 512;\n            this.IPTextBox.Name = "IPTextBox";
            this.IPTextBox.MaxLength = 512;\n            this.IPTextBox.Name = "IPTextBox";\n            this.ServerPortTextBox.Location = new System.Drawing.Point(113, 33);\n            this.ServerPortTextBox.MaxLength = 10;\n            this.ServerPortTextBox.Name = "ServerPortTextBox";
            this.PasswordTextBox.Location = new System.Drawing.Point(113, 60);\n            this.PasswordTextBox.MaxLength = 256;\n            this.PasswordTextBox.Name = "PasswordTextBox";
            this.EncryptionLabel.Location = new System.Drawing.Point(42, 113);\n            this.EncryptionLabel.Name = "EncryptionLabel";
            this.EncryptionLabel.Name = "EncryptionLabel";\n            "aes-192-gcm",\n            "aes-256-gcm",\n            "chacha20-ietf-poly1305",\n            "xchacha20-ietf-poly1305"});\n            this.EncryptionSelect.Location = new System.Drawing.Point(113, 109);\n            this.EncryptionSelect.Name = "EncryptionSelect";
            this.EncryptionSelect.Name = "EncryptionSelect";\n            this.TimeoutLabel.Location = new System.Drawing.Point(30, 269);\n            this.TimeoutLabel.Name = "TimeoutLabel";\n            this.TimeoutLabel.RightToLeft = System.Windows.Forms.RightToLeft.No;
            this.TimeoutLabel.Name = "TimeoutLabel";\n            this.TimeoutLabel.RightToLeft = System.Windows.Forms.RightToLeft.No;\n            this.TimeoutTextBox.Location = new System.Drawing.Point(113, 265);\n            this.TimeoutTextBox.MaxLength = 5;\n            this.TimeoutTextBox.Name = "TimeoutTextBox";
            this.TimeoutTextBox.MaxLength = 5;\n            this.TimeoutTextBox.Name = "TimeoutTextBox";\n            this.PluginLabel.Location = new System.Drawing.Point(18, 139);\n            this.PluginLabel.Name = "PluginLabel";
            this.PluginOptionsTextBox.Location = new System.Drawing.Point(113, 162);\n            this.PluginOptionsTextBox.MaxLength = 256;\n            this.PluginOptionsTextBox.Name = "PluginOptionsTextBox";
            this.ShowPasswdCheckBox.Location = new System.Drawing.Point(113, 87);\n            this.ShowPasswdCheckBox.Name = "ShowPasswdCheckBox";
            this.ShowPasswdCheckBox.Name = "ShowPasswdCheckBox";\n            this.PluginArgumentsTextBox.Location = new System.Drawing.Point(113, 211);\n            this.PluginArgumentsTextBox.MaxLength = 512;\n            this.PluginArgumentsTextBox.Name = "PluginArgumentsTextBox";
            this.PluginArgumentsLabel.Location = new System.Drawing.Point(6, 215);\n            this.PluginArgumentsLabel.Name = "PluginArgumentsLabel";
            this.PluginArgumentsLabel.Name = "PluginArgumentsLabel";\n            this.RemarksLabel.Location = new System.Drawing.Point(60, 242);\n            this.RemarksLabel.Name = "RemarksLabel";
            this.NeedPluginArgCheckBox.Location = new System.Drawing.Point(113, 189);\n            this.NeedPluginArgCheckBox.Name = "NeedPluginArgCheckBox";
            this.ServerGroupBox.TabIndex = 0;\n            this.ServerGroupBox.TabStop = false;\n            this.ServerGroupBox.Text = "Server";\n            // \n            // ServersListBox\n            // \n            this.ServersListBox.FormattingEnabled = true;\n            this.ServersListBox.IntegralHeight = false;
            // \n            this.ServersListBox.FormattingEnabled = true;\n            this.ServersListBox.IntegralHeight = false;\n            this.tableLayoutPanel5.Padding = new System.Windows.Forms.Padding(3);\n            this.tableLayoutPanel5.RowCount = 2;\n            this.tableLayoutPanel5.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel5.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel5.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.ProxyPortTextBox.Location = new System.Drawing.Point(77, 6);\n            this.ProxyPortTextBox.MaxLength = 10;\n            this.ProxyPortTextBox.Name = "ProxyPortTextBox";
            this.ProxyPortTextBox.Name = "ProxyPortTextBox";\n            this.ProxyPortLabel.Location = new System.Drawing.Point(6, 10);\n            this.ProxyPortLabel.Name = "ProxyPortLabel";
﻿using System;\nusing Microsoft.VisualStudio.TestTools.UnitTesting;\nusing Shadowsocks.Controller;
﻿using System;\nusing Microsoft.VisualStudio.TestTools.UnitTesting;\nusing Shadowsocks.Controller;\nusing Shadowsocks.Encryption;\nusing GlobalHotKey;\nusing System.Windows.Input;\nusing System.Threading;\nusing System.Collections.Generic;\nusing Shadowsocks.Controller.Hotkeys;
using Microsoft.VisualStudio.TestTools.UnitTesting;\nusing Shadowsocks.Controller;\nusing Shadowsocks.Encryption;\nusing GlobalHotKey;\nusing System.Windows.Input;\nusing System.Threading;\nusing System.Collections.Generic;\nusing Shadowsocks.Controller.Hotkeys;\nusing Shadowsocks.Encryption.Stream;\nusing Shadowsocks.Model;\nusing Shadowsocks.Controller.Service;\nusing System.Diagnostics;
        {\n            if (File.Exists(PAC_FILE))\n            {\n                return File.ReadAllText(PAC_FILE, Encoding.UTF8);\n            }\n            else\n            {\n                return Utils.UnGzip(Resources.proxy_pac_txt);\n            }\n        }
            }\n            else\n            {\n                return Utils.UnGzip(Resources.proxy_pac_txt);\n            }\n        }\n        public void SendResponse(byte[] firstPacket, int length, Socket socket, bool useSocks)\n        {\n            try\n            {
            {\n                return Utils.UnGzip(Resources.proxy_pac_txt);\n            }\n        }\n        public void SendResponse(byte[] firstPacket, int length, Socket socket, bool useSocks)\n        {\n            try\n            {\n                string pac = GetPACContent();\n                IPEndPoint localEndPoint = (IPEndPoint)socket.LocalEndPoint;
            {\n                string pac = GetPACContent();\n                IPEndPoint localEndPoint = (IPEndPoint)socket.LocalEndPoint;\n                string proxy = GetPACAddress(firstPacket, length, localEndPoint, useSocks);\n                pac = pac.Replace("__PROXY__", proxy);\n                string text = String.Format(@"HTTP/1.1 200 OK\nServer: Shadowsocks\nContent-Type: application/x-ns-proxy-autoconfig\nContent-Length: {0}\nConnection: Close
                {\n                    Process[] oldProcesses = Process.GetProcessesByName("Shadowsocks");\n                    if (oldProcesses.Length > 0)\n                    {\n                        Process oldProcess = oldProcesses[0];\n                    }\n                    MessageBox.Show("Shadowsocks is already running.\n\nFind Shadowsocks icon in your notify tray.");\n                    return;\n                }\n                string tempPath = Path.GetTempPath();
        PROXY_TYPE_PROXY = 0x00000002,   // via named proxy\n        PROXY_TYPE_AUTO_PROXY_URL = 0x00000004,   // autoproxy URL\n        PROXY_TYPE_AUTO_DETECT = 0x00000008   // use autoproxy detection\n    }\n    /// <summary>\n    /// Used in INTERNET_PER_CONN_OPTION.\n    /// When create a instance of OptionUnion, only one filed will be used.\n    /// The StructLayout and FieldOffset attributes could help to decrease the struct size.\n    /// </summary>\n    [StructLayout(LayoutKind.Explicit)]
 All other rights reserved.\n THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, \n EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED \n WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.\n\***************************************************************************/\nusing System.Runtime.InteropServices;\nnamespace Shadowsocks.Util.SystemProxy\n{\n    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
{\n    public class Logging\n    {\n        public static string LogFilePath;\n        private static DateTime LogFileCreationTime;\n        public static bool OpenLogFile()\n        {\n            try\n            {\n                LogFilePath = Utils.GetTempPath("shadowsocks.log");
                    Console.SetError(sw);\n                }\n                return true;\n            }\n            catch (IOException e)\n            {\n                Console.WriteLine(e.ToString());\n                return false;\n            }\n        }
            }\n            catch (IOException e)\n            {\n                Console.WriteLine(e.ToString());\n                return false;\n            }\n        }\n            FileStream fs = new FileStream(LogFilePath, FileMode.CreateNew);\n            LogFileCreationTime = DateTime.Now;\n            ms.CopyTo(fs);\n            StreamWriterWithTimestamp sw2 = new StreamWriterWithTimestamp(fs);\n            sw2.AutoFlush = true;\n            Console.SetOut(sw2);\n            Console.SetError(sw2);\n        }\n        private static void WriteToLogFile(object o)\n        {
using System.Diagnostics;\nusing Microsoft.Win32;\nusing Shadowsocks.Controller;\nusing Shadowsocks.Model;\nusing Shadowsocks.Properties;\nnamespace Shadowsocks.View\n{\n    public partial class ConfigForm : Form\n    {\n        private ShadowsocksController controller;
using Shadowsocks.Model;\nusing Shadowsocks.Properties;\nnamespace Shadowsocks.View\n{\n    public partial class ConfigForm : Form\n    {\n        private ShadowsocksController controller;\n        private UpdateChecker updateChecker;\n        // this is a copy of configuration that we are working on\n        private Configuration _modifiedConfiguration;\n        private int _oldSelectedIndex = -1;
using System.Text;\nusing System.Net;\nnamespace Shadowsocks.Encryption\n{\n    public abstract class IVEncryptor\n        : EncryptorBase\n    {\n        public const int MAX_KEY_LENGTH = 64;\n        public const int MAX_IV_LENGTH = 16;\n        protected static byte[] tempbuf = new byte[MAX_INPUT_SIZE];
        protected static byte[] tempbuf = new byte[MAX_INPUT_SIZE];\n        protected Dictionary<string, Dictionary<string, int[]>> ciphers;\n        protected Dictionary<string, int[]> ciphersDetail;\n        private static readonly ConcurrentDictionary<string, byte[]> CachedKeys = new ConcurrentDictionary<string, byte[]>();\n        protected byte[] _encryptIV;\n        protected byte[] _decryptIV;\n        protected bool _decryptIVReceived;\n        protected bool _encryptIVSent;\n        protected string _method;\n        protected int _cipher;\n        // cipher name in MbedTLS, useless when using LibSodium\n        protected string _cipherMbedName;
        protected string _cipherMbedName;\n        protected int[] _cipherInfo;\n        protected byte[] _key;\n        protected int keyLen;\n        protected int ivLen;\n        public IVEncryptor(string method, string password, bool onetimeauth, bool isudp)\n            : base(method, password, onetimeauth, isudp)\n        {\n            InitKey(method, password);\n        }
        {\n            InitKey(method, password);\n        }\n        protected abstract Dictionary<string, Dictionary<string, int[]>> getCiphers();\n        private void InitKey(string method, string password)\n        {\n            method = method.ToLower();\n            _method = method;\n            string k = method + ":" + password;\n            ciphers = getCiphers();
            method = method.ToLower();\n            _method = method;\n            string k = method + ":" + password;\n            ciphers = getCiphers();\n            ciphersDetail = ciphers[_method];\n            _cipherMbedName = ciphersDetail.Keys.FirstOrDefault();\n            _cipherInfo = ciphers[_method][_cipherMbedName];\n            _cipher = _cipherInfo[2];\n            if (_cipher == 0)\n            {\n                throw new Exception("method not found");\n            }
        const int CIPHER_RC4 = 1;\n        const int CIPHER_AES = 2;\n        const int CIPHER_BLOWFISH = 3;\n        const int CIPHER_CAMELLIA = 4;\n        private IntPtr _encryptCtx = IntPtr.Zero;\n        private IntPtr _decryptCtx = IntPtr.Zero;\n        public MbedTLSEncryptor(string method, string password, bool onetimeauth, bool isudp)\n            : base(method, password, onetimeauth, isudp)\n        {\n        }
            { "bf-cfb", new Dictionary<string, int[]> { { "BLOWFISH-CFB64", new int[] { 16, 8, CIPHER_BLOWFISH } } } },\n            { "camellia-128-cfb", new Dictionary<string, int[]> { { "CAMELLIA-128-CFB128", new int[] { 16, 16, CIPHER_CAMELLIA } } } },\n            { "camellia-192-cfb", new Dictionary<string, int[]> { { "CAMELLIA-192-CFB128", new int[] { 24, 16, CIPHER_CAMELLIA } } } },\n            { "camellia-256-cfb", new Dictionary<string, int[]> { { "CAMELLIA-256-CFB128", new int[] { 32, 16, CIPHER_CAMELLIA } } } },\n            { "rc4-md5", new Dictionary<string, int[]> { { "ARC4-128", new int[] { 16, 16, CIPHER_RC4 } } } }\n        };\n        public static List<string> SupportedCiphers()\n        {\n            return new List<string>(_ciphers.Keys);\n        }
        const int SODIUM_BLOCK_SIZE = 64;\n        static byte[] sodiumBuf = new byte[MAX_INPUT_SIZE + SODIUM_BLOCK_SIZE];\n        protected int _encryptBytesRemaining;\n        protected int _decryptBytesRemaining;\n        protected ulong _encryptIC;\n        protected ulong _decryptIC;\n        public SodiumEncryptor(string method, string password, bool onetimeauth, bool isudp)\n            : base(method, password, onetimeauth, isudp)\n        {\n        }
        protected ulong _decryptIC;\n        public SodiumEncryptor(string method, string password, bool onetimeauth, bool isudp)\n            : base(method, password, onetimeauth, isudp)\n        {\n        }\n        private static Dictionary<string, Dictionary<string, int[]>> _ciphers = new Dictionary<string, Dictionary<string, int[]>> {\n            { "salsa20", new Dictionary<string, int[]> { { "salsa20", new int[] { 32, 8, CIPHER_SALSA20 } } } },\n            { "chacha20", new Dictionary<string, int[]> { { "chacha20", new int[] { 32, 8, CIPHER_CHACHA20 } } } },\n            { "chacha20-ietf", new Dictionary<string, int[]> { { "chacha20-ietf", new int[] { 32, 12, CIPHER_CHACHA20_IETF } } } }\n        };
            }\n            base.Dispose(disposing);\n        }\n        #region Windows 窗体设计器生成的代码\n        /// <summary>\n        /// 设计器支持所需的方法 - 不要\n        /// 使用代码编辑器修改此方法的内容。\n        /// </summary>\n        private void InitializeComponent()\n        {
namespace Shadowsocks.Encryption\n{\n    public abstract class IVEncryptor\n        : EncryptorBase\n    {\n        public const int ONETIMEAUTH_FLAG = 0x10;\n        public const int ADDRTYPE_MASK = 0xF;\n        public const int ONETIMEAUTH_BYTES = 16;
        protected bool _decryptIVReceived;\n        protected bool _encryptIVSent;\n        protected int _encryptIVOffset = 0;\n        protected int _decryptIVOffset = 0;\n        protected string _method;\n        protected int _cipher;\n        protected int[] _cipherInfo;\n        protected byte[] _key;\n        protected int keyLen;\n        protected int ivLen;
        protected int keyLen;\n        protected int ivLen;\n        protected byte[] crc_buf;\n        protected int crc_idx = 0;\n        public IVEncryptor(string method, string password, bool onetimeauth)\n            : base(method, password, onetimeauth)\n        {\n            InitKey(method, password);\n            if (OnetimeAuth)\n            {
            if (!_encryptIVSent)\n            {\n                _encryptIVSent = true;\n                randBytes(outbuf, ivLen);\n                initCipher(outbuf, true);\n                outlength = length + ivLen;\n                lock (tempbuf)\n                {\n                    if (OnetimeAuth)\n                    {
                _encryptIVSent = true;\n                randBytes(outbuf, ivLen);\n                initCipher(outbuf, true);\n                outlength = length + ivLen;\n                lock (tempbuf)\n                {\n                    if (OnetimeAuth)\n                    {\n                        lock(crc_buf)\n                        {
                {\n                    if (OnetimeAuth)\n                    {\n                        lock(crc_buf)\n                        {\n                            int headLen = GetSSHeadLength(buf, length);\n                            int data_len = length - headLen;\n                            Buffer.BlockCopy(buf, headLen, buf, headLen + ONETIMEAUTH_BYTES, data_len);\n                            buf[0] |= ONETIMEAUTH_FLAG;\n                            byte[] auth = new byte[ONETIMEAUTH_BYTES];
                        lock(crc_buf)\n                        {\n                            int headLen = GetSSHeadLength(buf, length);\n                            int data_len = length - headLen;\n                            Buffer.BlockCopy(buf, headLen, buf, headLen + ONETIMEAUTH_BYTES, data_len);\n                            buf[0] |= ONETIMEAUTH_FLAG;\n                            byte[] auth = new byte[ONETIMEAUTH_BYTES];\n                            Sodium.ss_onetimeauth(auth, buf, headLen, _encryptIV, ivLen, _key, keyLen);\n                            Buffer.BlockCopy(auth, 0, buf, headLen, ONETIMEAUTH_BYTES);\n                            int buf_offset = headLen + ONETIMEAUTH_BYTES;
                    }\n                    cipherUpdate(true, length, buf, tempbuf);\n                    outlength = length + ivLen;\n                    Buffer.BlockCopy(tempbuf, 0, outbuf, ivLen, length);\n                }\n            }\n            else\n            {\n                if (OnetimeAuth)\n                {
                    Buffer.BlockCopy(tempbuf, 0, outbuf, ivLen, length);\n                }\n            }\n            else\n            {\n                if (OnetimeAuth)\n                {\n                    lock(crc_buf)\n                    {\n                        int buf_offset = 0;
            }\n            LoadLibrary(dllPath);\n        }\n        [DllImport("Kernel32.dll")]\n        private static extern IntPtr LoadLibrary(string path);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int crypto_stream_salsa20_xor_ic(byte[] c, byte[] m, ulong mlen, byte[] n, ulong ic, byte[] k);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int crypto_stream_chacha20_xor_ic(byte[] c, byte[] m, ulong mlen, byte[] n, ulong ic, byte[] k);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
        [DllImport("Kernel32.dll")]\n        private static extern IntPtr LoadLibrary(string path);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int crypto_stream_salsa20_xor_ic(byte[] c, byte[] m, ulong mlen, byte[] n, ulong ic, byte[] k);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int crypto_stream_chacha20_xor_ic(byte[] c, byte[] m, ulong mlen, byte[] n, ulong ic, byte[] k);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int ss_gen_crc(byte[] buf, ref int buf_offset, ref int data_len,\n            byte[] crc_buf, ref int crc_idx, int buf_size);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
        private void ConfigForm_Shown(object sender, EventArgs e)\n        {\n            IPTextBox.Focus();\n        }\n        private void QRCodeItem_Click(object sender, EventArgs e)\n        {\n            QRCodeForm qrCodeForm = new QRCodeForm(controller.GetQRCodeForCurrentServer());\n            qrCodeForm.Icon = this.Icon;\n            qrCodeForm.Show();\n        }
        }\n        private void QRCodeItem_Click(object sender, EventArgs e)\n        {\n            QRCodeForm qrCodeForm = new QRCodeForm(controller.GetQRCodeForCurrentServer());\n            qrCodeForm.Icon = this.Icon;\n            qrCodeForm.Show();\n        }\nif (item.Equals("Shadowsocks-CSharp"))\nreturn true;\n}\nreturn false;\n} catch (Exception e) {\nreturn false;\n}\n}\nprivate void autoStartup_Click(object sender, EventArgs e) {\nautoStartup.Checked = !autoStartup.Checked;
            qrCodeForm.Show();\n        }\nreturn false;\n}\n}\nprivate void autoStartup_Click(object sender, EventArgs e) {\nautoStartup.Checked = !autoStartup.Checked;\nif (!setAutoStartup(autoStartup.Checked)) {\n//MessageBox.Show("Failed to edit registry");\n}\n}\nprivate void contextMenu1_Popup(object sender, EventArgs e) {
            InitializeComponent();\n            this.Icon = Icon.FromHandle(Resources.ssw128.GetHicon());\n            this.Text = I18N.GetString("QRCode");\n        }\n        private void GenQR(string ssconfig)\n        {\n            string qrText = ssconfig;\n            QRCode code = ZXing.QrCode.Internal.Encoder.encode(qrText, ErrorCorrectionLevel.M);\n            ByteMatrix m = code.Matrix;\n            int blockSize = Math.Max(200 / m.Height, 1);
      /// "getECLevel" since our primary use is to show QR code on desktop screens. We don't need very\n      /// strong error correction for this purpose.\n      /// Note that there is no way to encode bytes in MODE_KANJI. We might want to add EncodeWithMode()\n      /// with which clients can specify the encoding mode. For now, we don't need the functionality.\n      /// </summary>\n      /// <param name="content">text to encode</param>\n      /// <param name="ecLevel">error correction level to use</param>\n      /// <returns><see cref="QRCode"/> representing the encoded QR code</returns>\n      public static QRCode encode(String content, ErrorCorrectionLevel ecLevel)\n      {
      /// Note that there is no way to encode bytes in MODE_KANJI. We might want to add EncodeWithMode()\n      /// with which clients can specify the encoding mode. For now, we don't need the functionality.\n      /// </summary>\n      /// <param name="content">text to encode</param>\n      /// <param name="ecLevel">error correction level to use</param>\n      /// <returns><see cref="QRCode"/> representing the encoded QR code</returns>\n      public static QRCode encode(String content, ErrorCorrectionLevel ecLevel)\n      {\n      /// Encodes the specified content.\n      /// </summary>\n      /// <param name="content">The content.</param>\n      /// <param name="ecLevel">The ec level.</param>\n      /// <param name="hints">The hints.</param>\n      /// <returns></returns>\n      public static QRCode encode(String content,\n                                ErrorCorrectionLevel ecLevel,\n                                IDictionary<EncodeHintType, object> hints)\n      {\n         // Determine what character encoding has been specified by the caller, if any\n#if !SILVERLIGHT || WINDOWS_PHONE
      /// <param name="content">text to encode</param>\n      /// <param name="ecLevel">error correction level to use</param>\n      /// <returns><see cref="QRCode"/> representing the encoded QR code</returns>\n      public static QRCode encode(String content, ErrorCorrectionLevel ecLevel)\n      {\n      /// <param name="ecLevel">The ec level.</param>\n      /// <param name="hints">The hints.</param>\n      /// <returns></returns>\n      public static QRCode encode(String content,\n                                ErrorCorrectionLevel ecLevel,\n                                IDictionary<EncodeHintType, object> hints)\n      {\n         // Determine what character encoding has been specified by the caller, if any\n#if !SILVERLIGHT || WINDOWS_PHONE\n         String encoding = hints == null || !hints.ContainsKey(EncodeHintType.CHARACTER_SET) ? null : (String)hints[EncodeHintType.CHARACTER_SET];\n         if (encoding == null)\n         {\n            encoding = DEFAULT_BYTE_MODE_ENCODING;\n         }\n         bool generateECI = !DEFAULT_BYTE_MODE_ENCODING.Equals(encoding);\n#else\n         // Silverlight supports only UTF-8 and UTF-16 out-of-the-box\n         const string encoding = "UTF-8";\n         // caller of the method can only control if the ECI segment should be written\n         // character set is fixed to UTF-8; but some scanners doesn't like the ECI segment\n         bool generateECI = (hints != null && hints.ContainsKey(EncodeHintType.CHARACTER_SET));\n#endif\n         // Pick an encoding mode appropriate for the content. Note that this will not attempt to use\n         // multiple modes / segments even if that were more efficient. Twould be nice.
      /// </summary>\n      /// <param name="content">The content.</param>\n      /// <param name="mode">The mode.</param>\n      /// <param name="bits">The bits.</param>\n      /// <param name="encoding">The encoding.</param>\n      internal static void appendBytes(String content,\n                              Mode mode,\n                              BitArray bits,\n                              String encoding)\n      {
      /// <param name="bits">The bits.</param>\n      /// <param name="encoding">The encoding.</param>\n      internal static void appendBytes(String content,\n                              Mode mode,\n                              BitArray bits,\n                              String encoding)\n      {\n         if (mode.Equals(Mode.NUMERIC))\n            appendNumericBytes(content, bits);\n         else\n            if (mode.Equals(Mode.ALPHANUMERIC))\n               appendAlphanumericBytes(content, bits);\n            else\n               if (mode.Equals(Mode.BYTE))\n                  append8BitBytes(content, bits, encoding);
                              Mode mode,\n                              BitArray bits,\n                              String encoding)\n      {\n            appendNumericBytes(content, bits);\n         else\n            if (mode.Equals(Mode.ALPHANUMERIC))\n               appendAlphanumericBytes(content, bits);\n            else\n               if (mode.Equals(Mode.BYTE))\n                  append8BitBytes(content, bits, encoding);\n               else\n                  if (mode.Equals(Mode.KANJI))\n                     appendKanjiBytes(content, bits);\n                  else\n                      throw new Exception("Invalid mode: " + mode);
      }\n      /// <summary>\n      /// Gets the EC blocks for level.\n      /// </summary>\n      /// <param name="ecLevel">The ec level.</param>\n      /// <returns></returns>\n      public ECBlocks getECBlocksForLevel(ErrorCorrectionLevel ecLevel)\n      {\n         return ecBlocks[ecLevel.ordinal()];\n      }
         return ecBlocks[ecLevel.ordinal()];\n      }\n            return null;\n         }\n      }\n      /// </summary>\n      /// <param name="versionNumber">The version number.</param>\n      /// <returns></returns>\n      public static Version getVersionForNumber(int versionNumber)\n      {\n         if (versionNumber < 1 || versionNumber > 40)\n         {\n            throw new ArgumentException();\n         }\n         return VERSIONS[versionNumber - 1];
      /// <returns>product of a and b in GF(size)</returns>\n      internal int multiply(int a, int b)\n      {\n         if (a == 0 || b == 0)\n         {\n            return 0;\n         }\n         return expTable[(logTable[a] + logTable[b]) % (size - 1)];\n      }\n      /// <summary>
            return 0;\n         }\n         return expTable[(logTable[a] + logTable[b]) % (size - 1)];\n      }\n      /// <summary>\n      /// </summary>\n      public int Size\n      {\n         get { return size; }\n      }\n      /// <summary>\n      /// Gets the generator base.\n      /// </summary>\n      public int GeneratorBase\n      {\n         get { return generatorBase; }\n      }

         set\n         {\n            if (value)\n               bits[i >> 5] |= 1 << (i & 0x1F);\n         }\n      }\n      public BitArray()\n      {\n         this.size = 0;\n         this.bits = new int[1];
            {\n               if (this[bitOffset])\n               {\n                  theByte |= 1 << (7 - j);\n               }\n               bitOffset++;\n            }\n            array[offset + i] = (byte)theByte;\n         }\n      }
            array[offset + i] = (byte)theByte;\n         }\n      }\n               currentInt = (nextInt >> leftOffset) & mask;\n            }\n            newBits[oldBitsLen - 1] = currentInt;\n         }\n         bits = newBits;\n      }\n      private static int[] makeArray(int size)\n      {\n         return new int[(size + 31) >> 5];\n      }
            if (newIcon != this.targetIcon)\n            {\n                this.targetIcon = newIcon;\n                _notifyIcon.Icon = newIcon;\n            }\n        }\n        void controller_Errored(object sender, System.IO.ErrorEventArgs e)\n        {\n            MessageBox.Show(e.GetException().ToString(), String.Format(I18N.GetString("Shadowsocks Error: {0}"), e.GetException().Message));\n        }
        }\n            {\n                LogForm f = new LogForm(controller, Logging.LogFilePath);\n                f.Show();\n                f.Activate();\n                f.FormClosed += logForm_FormClosed;\n                logForms.Add(f);\n                logFormsVisible = true;\n            }\n            else\n            {
                logFormsVisible = true;\n            }\n            else\n            {\n                logFormsVisible = !logFormsVisible;\n                foreach (LogForm f in logForms)\n                {\n                    f.Visible = logFormsVisible;\n                }\n            }\n        }\n        void logForm_FormClosed(object sender, FormClosedEventArgs e)\n        {
            if (_cipher == 0)\n            {\n                throw new Exception("method not found");\n            }\n            keyLen = _cipherInfo[0];\n            ivLen = _cipherInfo[1];\n            _key = CachedKeys.GetOrAdd(k, (nk) =>\n            {\n                byte[] passbuf = Encoding.UTF8.GetBytes(password);\n                byte[] key = new byte[32];
            ivLen = _cipherInfo[1];\n            _key = CachedKeys.GetOrAdd(k, (nk) =>\n            {\n                byte[] passbuf = Encoding.UTF8.GetBytes(password);\n                byte[] key = new byte[32];\n                byte[] iv = new byte[16];\n                bytesToKey(passbuf, key);\n                return key;\n            });\n        }
            XmlNamespaceManager manager = new XmlNamespaceManager(doc.NameTable);\n            manager.AddNamespace("nlog", "http://www.nlog-project.org/schemas/NLog.xsd");\n            //return doc.SelectSingleNode("//nlog:logger[(@shadowsocks='managed') and (@name='*')]", manager);\n            return doc.SelectSingleNode(xpath, manager);\n        }\n        /// <summary>\n        /// Extract the pre-defined NLog configuration file is does not exist. Then reload the Nlog configuration.\n        /// </summary>\n        public static void TouchAndApplyNLogConfig()\n        {
        /// <summary>\n        /// Extract the pre-defined NLog configuration file is does not exist. Then reload the Nlog configuration.\n        /// </summary>\n        public static void TouchAndApplyNLogConfig()\n        {\n            if (!File.Exists(NLOG_CONFIG_FILE_NAME))\n            {\n                File.WriteAllText(NLOG_CONFIG_FILE_NAME, Properties.Resources.NLog_config);
        public static Sip003Plugin CreateIfConfigured(Server server)\n        {\n            if (server == null)\n            {\n                throw new ArgumentNullException(nameof(server));\n            }\n            if (string.IsNullOrWhiteSpace(server.plugin))\n            {\n                return null;\n            }
            if (server == null)\n            {\n                throw new ArgumentNullException(nameof(server));\n            }\n            if (string.IsNullOrWhiteSpace(server.plugin))\n            {\n                return null;\n            }\n            return new Sip003Plugin(server.plugin, server.plugin_opts, server.server, server.server_port);\n        }
            this.tableLayoutPanel1.Controls.Add(this.PasswordTextBox, 1, 2);\n            this.tableLayoutPanel1.Controls.Add(this.EncryptionLabel, 0, 4);\n            this.tableLayoutPanel1.Controls.Add(this.EncryptionSelect, 1, 4);\n            this.tableLayoutPanel1.Location = new System.Drawing.Point(8, 21);\n            this.tableLayoutPanel1.Margin = new System.Windows.Forms.Padding(0);\n            this.tableLayoutPanel1.Name = "tableLayoutPanel1";\n            this.tableLayoutPanel1.Padding = new System.Windows.Forms.Padding(3);
            this.tableLayoutPanel3.ResumeLayout(false);\n            this.tableLayoutPanel4.ResumeLayout(false);\n            this.ResumeLayout(false);\n            this.PerformLayout();\n        }\n        #endregion\n        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel1;\n        private System.Windows.Forms.Label IPLabel;\n        private System.Windows.Forms.Label ServerPortLabel;\n        private System.Windows.Forms.Label PasswordLabel;
        }\n        #endregion\n        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel1;\n        private System.Windows.Forms.Label IPLabel;\n        private System.Windows.Forms.Label ServerPortLabel;\n        private System.Windows.Forms.Label PasswordLabel;\n        private System.Windows.Forms.Label ProxyPortLabel;\n        private System.Windows.Forms.TextBox IPTextBox;\n        private System.Windows.Forms.TextBox ServerPortTextBox;\n        private System.Windows.Forms.TextBox PasswordTextBox;
            this.OKButton = new System.Windows.Forms.Button();\n            this.MyCancelButton = new System.Windows.Forms.Button();\n            this.panel1 = new System.Windows.Forms.Panel();\n            this.contextMenu1 = new System.Windows.Forms.ContextMenu();\n            this.enableItem = new System.Windows.Forms.MenuItem();\n            this.configItem = new System.Windows.Forms.MenuItem();\n            this.editPACFileItem = new System.Windows.Forms.MenuItem();\n            this.aboutItem = new System.Windows.Forms.MenuItem();\n            this.menuItem3 = new System.Windows.Forms.MenuItem();\n            this.quitItem = new System.Windows.Forms.MenuItem();
            this.Controls.Add(this.groupBox1);
        private System.Windows.Forms.Button OKButton;\n        private System.Windows.Forms.Button MyCancelButton;\n        private System.Windows.Forms.Panel panel1;\n        private System.Windows.Forms.ContextMenu contextMenu1;\n        private System.Windows.Forms.MenuItem enableItem;\n        private System.Windows.Forms.MenuItem aboutItem;\n        private System.Windows.Forms.MenuItem menuItem3;\n        private System.Windows.Forms.MenuItem quitItem;\n        private System.Windows.Forms.MenuItem configItem;\n        private System.Windows.Forms.MenuItem editPACFileItem;
﻿using System.Reflection;\nusing System.Runtime.CompilerServices;\nusing System.Runtime.InteropServices;\n// 有关程序集的常规信息通过下列属性集\n// 控制。更改这些属性值可修改\n// 与程序集关联的信息。\n[assembly: AssemblyTitle("Shadowsocks")]\n[assembly: AssemblyDescription("")]\n[assembly: AssemblyConfiguration("")]
[assembly: AssemblyDescription("")]\n[assembly: AssemblyConfiguration("")]\n[assembly: AssemblyCompany("clowwindy")]\n//\n//      主版本\n//      次版本 \n//      内部版本号\n//      修订号\n//\n// 可以指定所有这些值，也可以使用“内部版本号”和“修订号”的默认值，\n// 方法是按如下所示使用“*”:\n// [assembly: AssemblyVersion("1.0.*")]\n[assembly: AssemblyVersion("2.0.0")]
  }\n  private static pbr::FileDescriptor descriptor;\n  static GeositeReflection() {\n    byte[] descriptorData = global::System.Convert.FromBase64String(\n        string.Concat(\n          "Cg1nZW9zaXRlLnByb3RvIvMBCgxEb21haW5PYmplY3QSIAoEdHlwZRgBIAEo",\n          "DjISLkRvbWFpbk9iamVjdC5UeXBlEg0KBXZhbHVlGAIgASgJEioKCWF0dHJp",\n          "YnV0ZRgDIAMoCzIXLkRvbWFpbk9iamVjdC5BdHRyaWJ1dGUaUgoJQXR0cmli",\n          "dXRlEgsKA2tleRgBIAEoCRIUCgpib29sX3ZhbHVlGAIgASgISAASEwoJaW50",\n          "X3ZhbHVlGAMgASgDSABCDQoLdHlwZWRfdmFsdWUiMgoEVHlwZRIJCgVQbGFp",
          "dXRlEgsKA2tleRgBIAEoCRIUCgpib29sX3ZhbHVlGAIgASgISAASEwoJaW50",\n          "X3ZhbHVlGAMgASgDSABCDQoLdHlwZWRfdmFsdWUiMgoEVHlwZRIJCgVQbGFp",\n    countryCode_ = other.countryCode_;\n    domain_ = other.domain_.Clone();\n    _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);\n  }\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n  public Geosite Clone() {\n    return new Geosite(this);\n  }
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n  public Geosite Clone() {\n    return new Geosite(this);\n  }\n  /// <summary>Field number for the "country_code" field.</summary>\n  public const int CountryCodeFieldNumber = 1;\n  private string countryCode_ = "";\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n  public string CountryCode {\n    get { return countryCode_; }\n    set {
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n  public string CountryCode {\n    get { return countryCode_; }\n    set {\n      countryCode_ = pb::ProtoPreconditions.CheckNotNull(value, "value");\n    }\n  }\n  /// <summary>Field number for the "domain" field.</summary>\n  public const int DomainFieldNumber = 2;\n  private static readonly pb::FieldCodec<global::DomainObject> _repeated_domain_codec\n      = pb::FieldCodec.ForMessage(18, global::DomainObject.Parser);
    return Equals(other as Geosite);\n  }\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n  public bool Equals(Geosite other) {\n    if (ReferenceEquals(other, null)) {\n      return false;\n    }\n    if (ReferenceEquals(other, this)) {\n      return true;\n    }
    if (ReferenceEquals(other, this)) {\n      return true;\n    }\n    if (CountryCode != other.CountryCode) return false;\n    if(!domain_.Equals(other.domain_)) return false;\n    return Equals(_unknownFields, other._unknownFields);\n  }\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n  public override int GetHashCode() {\n    int hash = 1;
      hash ^= _unknownFields.GetHashCode();\n    }\n    return hash;\n  }\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n  public override string ToString() {\n    return pb::JsonFormatter.ToDiagnosticString(this);\n  }\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n  public void WriteTo(pb::CodedOutputStream output) {
    return hash;\n  }\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n  public override string ToString() {\n    return pb::JsonFormatter.ToDiagnosticString(this);\n  }\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n  public void WriteTo(pb::CodedOutputStream output) {\n    if (CountryCode.Length != 0) {\n      output.WriteRawTag(10);
      output.WriteString(CountryCode);\n    }\n    domain_.WriteTo(output, _repeated_domain_codec);\n    if (_unknownFields != null) {\n      _unknownFields.WriteTo(output);\n    }\n  }\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n  public int CalculateSize() {\n    int size = 0;
  }\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n  public void MergeFrom(pb::CodedInputStream input) {\n    uint tag;\n    while ((tag = input.ReadTag()) != 0) {\n      switch(tag) {\n        default:\n          _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);\n          break;\n        case 10: {
    while ((tag = input.ReadTag()) != 0) {\n      switch(tag) {\n        default:\n          _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);\n          break;\n        case 10: {\n          CountryCode = input.ReadString();\n          break;\n        }\n        case 18: {
  partial void OnConstruction();\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n  public GeositeList(GeositeList other) : this() {\n    entry_ = other.entry_.Clone();\n    _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);\n  }\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n  public GeositeList Clone() {\n    return new GeositeList(this);\n  }
    entry_ = other.entry_.Clone();\n    _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);\n  }\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n  public GeositeList Clone() {\n    return new GeositeList(this);\n  }\n  /// <summary>Field number for the "entry" field.</summary>\n  public const int EntryFieldNumber = 1;\n  private static readonly pb::FieldCodec<global::Geosite> _repeated_entry_codec\n      = pb::FieldCodec.ForMessage(10, global::Geosite.Parser);
    return Equals(other as GeositeList);\n  }\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n  public bool Equals(GeositeList other) {\n    if (ReferenceEquals(other, null)) {\n      return false;\n    }\n    if (ReferenceEquals(other, this)) {\n      return true;\n    }
using System.Threading.Tasks;\nusing Google.Protobuf;\nnamespace Shadowsocks.Controller\n{\n    static class GeositeUpdater\n    {\n        private static Logger logger = LogManager.GetCurrentClassLogger();
        private static readonly string DatabasePath = Utils.GetTempPath("dlc.dat");\n        public static readonly GeositeList List;\n        public static readonly Dictionary<string, List<DomainObject>> Geosites = new Dictionary<string, List<DomainObject>>();\n        static GeositeUpdater()\n        {
        public static readonly Dictionary<string, List<DomainObject>> Geosites = new Dictionary<string, List<DomainObject>>();\n        static GeositeUpdater()\n        {\n            List = GeositeList.Parser.ParseFrom(File.ReadAllBytes(DatabasePath));\n            foreach (var item in List.Entry)\n            {
            public string[] GetDomains()\n            {\n                List<string> lines = new List<string>(GetLines());\n                lines.AddRange(GetBuildIn());\n                List<string> domains = new List<string>(lines.Count);\n                for (int i = 0; i < lines.Count; i++)\n                {\n                    string line = lines[i];\n                    if (line.IndexOf(".*") >= 0)\n                        continue;
                List<string> domains = new List<string>(lines.Count);\n                for (int i = 0; i < lines.Count; i++)\n                {\n                    string line = lines[i];\n                    if (line.IndexOf(".*") >= 0)\n                        continue;\n                    else if (line.IndexOf("*") >= 0)\n                        line = line.Replace("*", "/");\n                    if (line.StartsWith("||"))
                    string line = lines[i];\n                    if (line.IndexOf(".*") >= 0)\n                        continue;\n                    else if (line.IndexOf("*") >= 0)\n                        line = line.Replace("*", "/");\n                    if (line.StartsWith("||"))\n                        line = line.Substring(2);\n                    else if (line.StartsWith("|"))
                        continue;\n                    else if (line.IndexOf("*") >= 0)\n                        line = line.Replace("*", "/");\n                    if (line.StartsWith("||"))\n                        line = line.Substring(2);\n                    else if (line.StartsWith("|"))\n                        line = line.Substring(1);\n                    else if (line.StartsWith("."))
                    else if (line.StartsWith("|"))\n                        line = line.Substring(1);\n                    else if (line.StartsWith("."))\n                        line = line.Substring(1);\n                    if (line.StartsWith("!"))\n                        continue;\n                    else if (line.StartsWith("["))\n                        continue;\n                    else if (line.StartsWith("@"))\n                        continue; /*ignore white list*/
                _listener = new Listener(services);\n                _listener.Start(_config);\n            }\n            catch (Exception e)\n            {\n                // translate Microsoft language into human language\n                // i.e. An attempt was made to access a socket in a way forbidden by its access permissions => Port already in use\n                if (e is SocketException)\n                {\n                    SocketException se = (SocketException)e;
                        break;\n                    case CIPHER_RC4:\n                        PolarSSL.arc4_crypt(_decryptCtx, length, buf, outbuf);\n                        break;\n                }\n            }\n        }\n        public override void Dispose()\n        {
namespace Shadowsocks.View\n{\n    public partial class ConfigForm : Form\n    {\n        private ShadowsocksController controller;\n        // this is a copy of configuration that we are working on\n        private Configuration _modifiedConfiguration;\n        private int _lastSelectedIndex = -1;\n        public ConfigForm(ShadowsocksController controller)\n        {
    public partial class ConfigForm : Form\n    {\n        private ShadowsocksController controller;\n        // this is a copy of configuration that we are working on\n        private Configuration _modifiedConfiguration;\n        private int _lastSelectedIndex = -1;\n        public ConfigForm(ShadowsocksController controller)\n        {\n            this.Font = SystemFonts.MessageBoxFont;\n            InitializeComponent();\n            // a dirty hack
        private int _lastSelectedIndex = -1;\n        public ConfigForm(ShadowsocksController controller)\n        {\n            this.Font = SystemFonts.MessageBoxFont;\n            InitializeComponent();\n            // a dirty hack\n            this.ServersListBox.Dock = DockStyle.Fill;\n            this.tableLayoutPanel5.Dock = DockStyle.Fill;\n            this.PerformLayout();\n            UpdateTexts();\n            SetupValueChangedListeners();
            this.controller = controller;
            this.controller = controller;\n            toolTip1.SetToolTip(this.PortableModeCheckBox, I18N.GetString("Restart required"));\n            RemarksLabel.Text = I18N.GetString("Remarks");\n            TimeoutLabel.Text = I18N.GetString("Timeout(Sec)");\n            ServerGroupBox.Text = I18N.GetString("Server");\n            OKButton.Text = I18N.GetString("OK");\n            MyCancelButton.Text = I18N.GetString("Cancel");\n            ApplyButton.Text = I18N.GetString("Apply");\n            MoveUpButton.Text = I18N.GetString("Move &Up");\n            MoveDownButton.Text = I18N.GetString("Move D&own");
            PasswordTextBox.TextChanged += ConfigValueChanged;\n            EncryptionSelect.SelectedIndexChanged += ConfigValueChanged;\n            PluginTextBox.TextChanged += ConfigValueChanged;\n            PluginArgumentsTextBox.TextChanged += ConfigValueChanged;\n            PluginOptionsTextBox.TextChanged += ConfigValueChanged;\n            RemarksTextBox.TextChanged += ConfigValueChanged;\n            TimeoutTextBox.TextChanged += ConfigValueChanged;\n            PortableModeCheckBox.CheckedChanged += ConfigValueChanged;\n            ServerPortTextBox.TextChanged += ConfigValueChanged;\n        }
        }\n        private bool ValidateAndSaveSelectedServerDetails()\n        {\n            try\n            {\n                if (_lastSelectedIndex == -1 || _lastSelectedIndex >= _modifiedConfiguration.configs.Count)\n                {\n                    return true;\n                }
            if (_lastSelectedIndex >= 0 && _lastSelectedIndex < _modifiedConfiguration.configs.Count)\n            {\n                ServersListBox.Items[_lastSelectedIndex] = _modifiedConfiguration.configs[_lastSelectedIndex].FriendlyName();\n            }\n            UpdateButtons();\n            LoadSelectedServerDetails();\n            _lastSelectedIndex = ServersListBox.SelectedIndex;\n        }\n        private void AddButton_Click(object sender, EventArgs e)\n        {
        }\n        private void AddButton_Click(object sender, EventArgs e)\n        {\n            if (!ValidateAndSaveSelectedServerDetails())\n            {\n                return;\n            }\n            Configuration.AddDefaultServerOrServer(_modifiedConfiguration);\n            LoadServerNameListToUI(_modifiedConfiguration);
            {\n                return;\n            }\n            Configuration.AddDefaultServerOrServer(_modifiedConfiguration);\n            LoadServerNameListToUI(_modifiedConfiguration);\n            {\n                // can be -1\n                _lastSelectedIndex = _modifiedConfiguration.configs.Count - 1;\n            }\n            ServersListBox.SelectedIndex = _lastSelectedIndex;\n            LoadServerNameListToUI(_modifiedConfiguration);\n            ServersListBox.SelectedIndex = _lastSelectedIndex;\n            LoadSelectedServerDetails();\n            UpdateButtons();\n        }
            ServersListBox.BeginUpdate();\n            ServersListBox.Enabled = false;\n            _lastSelectedIndex = index + step;\n            ServersListBox.Items.Remove(item);\n            ServersListBox.Items.Insert(index + step, item);\n            ServersListBox.Enabled = true;\n            ServersListBox.SelectedIndex = index + step;\n            ServersListBox.EndUpdate();\n            UpdateButtons();\n        }
            {\n                return;\n            }\n            if (ServersListBox.SelectedIndex < ServersListBox.Items.Count - 1)\n            {\n                MoveConfigItem(+1);  // +1 means move forward\n            }\n        }\n        private void ShowPasswdCheckBox_CheckedChanged(object sender, EventArgs e)\n        {
            {\n                MoveConfigItem(+1);  // +1 means move forward\n            }\n        }\n        private void ShowPasswdCheckBox_CheckedChanged(object sender, EventArgs e)\n        {\n            this.PasswordTextBox.UseSystemPasswordChar = !this.ShowPasswdCheckBox.Checked;\n        }\n        private void UsePluginArgCheckBox_CheckedChanged(object sender, EventArgs e)\n        {
﻿using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing Shadowsocks.Controller;
        public string pacUrl;\n        public bool useOnlinePac;\n        public bool secureLocalPac = true;\n        public bool availabilityStatistics;\n        public bool autoCheckUpdate;\n        public bool checkPreRelease;\n        public bool isVerboseLogging;\n        public LogViewerConfig logViewer;\n        public ProxyConfig proxy;\n        public HotkeyConfig hotkey;
            if (index >= 0 && index < configs.Count)\n                return configs[index];\n            else\n                return GetDefaultServer();\n        }\n        public static void CheckServer(Server server)\n        {\n            CheckPort(server.server_port);\n            CheckPassword(server.password);
                    string jsonString = JsonConvert.SerializeObject(config, Formatting.Indented);\n                    sw.Write(jsonString);\n                    sw.Flush();\n                }\n            }\n            catch (IOException e)\n            {\n                Logging.LogUsefulException(e);\n            }\n        }
            catch (IOException e)\n            {\n                Logging.LogUsefulException(e);\n            }\n        }\n        public static Server AddDefaultServerOrServer(Configuration config, Server server = null)\n        {\n            if (config != null && config.configs != null)\n            {\n                server = (server ?? GetDefaultServer());
            UserRuleFileWatcher.Filter = USER_RULE_FILE;\n            UserRuleFileWatcher.Changed += UserRuleFileWatcher_Changed;\n            UserRuleFileWatcher.Created += UserRuleFileWatcher_Changed;\n            UserRuleFileWatcher.Deleted += UserRuleFileWatcher_Changed;\n            UserRuleFileWatcher.Renamed += UserRuleFileWatcher_Changed;\n            UserRuleFileWatcher.EnableRaisingEvents = true;\n        }\n        #region FileSystemWatcher.OnChanged()\n        // FileSystemWatcher Changed event is raised twice\n        // http://stackoverflow.com/questions/1764809/filesystemwatcher-changed-event-is-raised-twice
            UserRuleFileWatcher.Deleted += UserRuleFileWatcher_Changed;\n            UserRuleFileWatcher.Renamed += UserRuleFileWatcher_Changed;\n            UserRuleFileWatcher.EnableRaisingEvents = true;\n        }\n        #region FileSystemWatcher.OnChanged()\n        // FileSystemWatcher Changed event is raised twice\n        // http://stackoverflow.com/questions/1764809/filesystemwatcher-changed-event-is-raised-twice\n        private static Hashtable fileChangedTime = new Hashtable();\n        private void PACFileWatcher_Changed(object sender, FileSystemEventArgs e)\n        {
        private static Hashtable fileChangedTime = new Hashtable();\n        private void PACFileWatcher_Changed(object sender, FileSystemEventArgs e)\n        {\n            string path = e.FullPath.ToString();\n            string currentLastWriteTime = File.GetLastWriteTime(e.FullPath).ToString(CultureInfo.InvariantCulture);\n            // if there is no path info stored yet or stored path has different time of write then the one now is inspected\n            if (!fileChangedTime.ContainsKey(path) || fileChangedTime[path].ToString() != currentLastWriteTime)\n            {\n                if (PACFileChanged != null)\n                {\n                    Logging.Info($"Detected: PAC file '{e.Name}' was {e.ChangeType.ToString().ToLower()}.");\n                    PACFileChanged(this, new EventArgs());
                {\n                    Logging.Info($"Detected: PAC file '{e.Name}' was {e.ChangeType.ToString().ToLower()}.");\n                    PACFileChanged(this, new EventArgs());\n                }\n                // lastly we update the last write time in the hashtable\n                fileChangedTime[path] = currentLastWriteTime;\n            }\n        }\n        private void UserRuleFileWatcher_Changed(object sender, FileSystemEventArgs e)\n        {
        }\n        private void UserRuleFileWatcher_Changed(object sender, FileSystemEventArgs e)\n        {\n            string path = e.FullPath.ToString();\n            string currentLastWriteTime = File.GetLastWriteTime(e.FullPath).ToString(CultureInfo.InvariantCulture);\n            // if there is no path info stored yet or stored path has different time of write then the one now is inspected\n            if (!fileChangedTime.ContainsKey(path) || fileChangedTime[path].ToString() != currentLastWriteTime)\n            {\n                if (UserRuleFileChanged != null)\n                {\n                    Logging.Info($"Detected: User Rule file '{e.Name}' was {e.ChangeType.ToString().ToLower()}.");\n                    UserRuleFileChanged(this, new EventArgs());

﻿using System;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Threading;\nusing System.Windows.Forms;\nusing NLog;
using Shadowsocks.Controller;\nusing Shadowsocks.Controller.Hotkeys;\nusing Shadowsocks.Util;\nusing Shadowsocks.View;\nusing System.Linq;
using Shadowsocks.Util;\nusing Shadowsocks.View;\nusing System.Linq;\nusing System.IO.Pipes;\nusing System.Text;
using System.Linq;\nusing System.IO.Pipes;\nusing System.Text;\nusing System.Net;\nusing System.Threading.Tasks;
using System.Linq;\nusing System.IO.Pipes;\nusing System.Text;\nusing System.Net;\nusing System.Threading.Tasks;\nusing System.Collections.Generic;\nnamespace Shadowsocks\n{
using System.Linq;\nusing System.IO.Pipes;\nusing System.Text;\nusing System.Net;\nusing System.Threading.Tasks;\nusing System.Collections.Generic;\nnamespace Shadowsocks\n{\n    static class Program\n    {
using System.Collections.Generic;\nnamespace Shadowsocks\n{\n    static class Program\n    {\n        private static Logger logger = LogManager.GetCurrentClassLogger();\n        public static ShadowsocksController MainController { get; private set; }\n        public static MenuViewController MenuController { get; private set; }\n        public static string[] Args { get; private set; }\n        /// <summary>\n        /// 应用程序的主入口点。\n        /// </summary>\n        /// </summary>\n        [STAThread]
    {\n        private static Logger logger = LogManager.GetCurrentClassLogger();\n        public static string[] Args { get; private set; }\n        /// <summary>\n        /// 应用程序的主入口点。\n        /// </summary>\n        /// </summary>\n        [STAThread]\n        static void Main(string[] args)\n        {\n            Directory.SetCurrentDirectory(Application.StartupPath);\n            // todo: initialize the NLog configuartion\n            Model.NLogConfig.TouchAndApplyNLogConfig();\n            // .NET Framework 4.7.2 on Win7 compatibility
                bool pipeExist = false;\n                try\n                {\n                    pipe.Connect(10);\n                    pipeExist = true;\n                }\n                catch (TimeoutException)\n                {\n                    pipeExist = false;\n                }
                }\n                catch (TimeoutException)\n                {\n                    pipeExist = false;\n                }\n                var alist = Args.ToList();\n                int urlidx = alist.IndexOf("--open-url") + 1;\n                if (urlidx > 0)\n                {
using System.ComponentModel;\nusing System.Data;\nusing System.Drawing;\nusing System.Text;\nusing System.Windows.Forms;\nusing System.Drawing.Imaging;\nusing System.Runtime.InteropServices;\nusing System.Diagnostics;\nnamespace Shadowsocks.View\n{
        // interacts with low level logic\n        private Local local;\n        private PACServer pacServer;\n        private Configuration config;\n        private PolipoRunner polipoRunner;\n        private bool stopped = false;\n        public class PathEventArgs : EventArgs\n        {\n            public string Path;\n        }
        private Configuration config;\n        private PolipoRunner polipoRunner;\n        private bool stopped = false;\n        public class PathEventArgs : EventArgs\n        {\n            public string Path;\n        }\n        public class ErrorEventArgs : EventArgs\n        {\n            public string Error;\n        }\n        public event EventHandler ConfigChanged;\n        public event EventHandler EnableStatusChanged;
            System.Diagnostics.Process.Start("explorer.exe", argument);\n        }\n        private void showWindow()\n        {\n            this.Opacity = 1;\n            this.Show();\n        }\n        private void updateUI()\n        {\n            Server server = controller.GetCurrentServer();
        private void updateUI()\n        {\n            Server server = controller.GetCurrentServer();\n            textBox1.Text = server.server;\n            textBox2.Text = server.server_port.ToString();\n            textBox3.Text = server.password;\n            textBox4.Text = server.local_port.ToString();\n            comboBox1.Text = server.method == null ? "aes-256-cfb" : server.method;\n            enableItem.Checked = controller.GetConfiguration().enabled;\n        }
            }\n            catch (FormatException)\n            {\n                MessageBox.Show("illegal port number format");\n            }\n            catch (Exception ex)\n            {\n                MessageBox.Show(ex.Message);\n            }\n        }
        /// 使用代码编辑器修改此方法的内容。\n        /// </summary>\n        private void InitializeComponent()\n        {\n            this.components = new System.ComponentModel.Container();\n            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(ConfigForm));\n            this.tableLayoutPanel1 = new System.Windows.Forms.TableLayoutPanel();\n            this.label5 = new System.Windows.Forms.Label();\n            this.label1 = new System.Windows.Forms.Label();\n            this.label2 = new System.Windows.Forms.Label();
        {\n            this.components = new System.ComponentModel.Container();\n            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(ConfigForm));\n            this.tableLayoutPanel1 = new System.Windows.Forms.TableLayoutPanel();\n            this.label5 = new System.Windows.Forms.Label();\n            this.label1 = new System.Windows.Forms.Label();\n            this.label2 = new System.Windows.Forms.Label();\n            this.comboBox1 = new System.Windows.Forms.ComboBox();\n            this.label3 = new System.Windows.Forms.Label();\n            this.label4 = new System.Windows.Forms.Label();
            this.label2 = new System.Windows.Forms.Label();\n            this.comboBox1 = new System.Windows.Forms.ComboBox();\n            this.label3 = new System.Windows.Forms.Label();\n            this.label4 = new System.Windows.Forms.Label();\n            this.textBox1 = new System.Windows.Forms.TextBox();\n            this.textBox2 = new System.Windows.Forms.TextBox();\n            this.textBox3 = new System.Windows.Forms.TextBox();\n            this.textBox4 = new System.Windows.Forms.TextBox();\n            this.notifyIcon1 = new System.Windows.Forms.NotifyIcon(this.components);\n            this.panel2 = new System.Windows.Forms.Panel();
            this.button1 = new System.Windows.Forms.Button();\n            this.button2 = new System.Windows.Forms.Button();\n            this.panel1 = new System.Windows.Forms.Panel();\n            this.contextMenu1 = new System.Windows.Forms.ContextMenu();\n            this.enableItem = new System.Windows.Forms.MenuItem();\n            this.configItem = new System.Windows.Forms.MenuItem();\n            this.aboutItem = new System.Windows.Forms.MenuItem();\n            this.menuItem3 = new System.Windows.Forms.MenuItem();\n            this.quitItem = new System.Windows.Forms.MenuItem();
            this.tableLayoutPanel1.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) \n            | System.Windows.Forms.AnchorStyles.Right)));\n            this.tableLayoutPanel1.AutoSize = true;\n            this.tableLayoutPanel1.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;\n            this.tableLayoutPanel1.ColumnCount = 2;\n            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());\n            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());\n            this.tableLayoutPanel1.Controls.Add(this.label5, 0, 4);\n            this.tableLayoutPanel1.Controls.Add(this.label1, 0, 0);\n            this.tableLayoutPanel1.Controls.Add(this.label2, 0, 1);
            this.tableLayoutPanel1.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;\n            this.tableLayoutPanel1.ColumnCount = 2;\n            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());\n            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());\n            this.tableLayoutPanel1.Controls.Add(this.label5, 0, 4);\n            this.tableLayoutPanel1.Controls.Add(this.label1, 0, 0);\n            this.tableLayoutPanel1.Controls.Add(this.label2, 0, 1);\n            this.tableLayoutPanel1.Controls.Add(this.comboBox1, 1, 4);\n            this.tableLayoutPanel1.Controls.Add(this.label3, 0, 2);\n            this.tableLayoutPanel1.Controls.Add(this.label4, 0, 3);
            this.tableLayoutPanel1.Margin = new System.Windows.Forms.Padding(10);\n            this.tableLayoutPanel1.Name = "tableLayoutPanel1";\n            this.tableLayoutPanel1.Padding = new System.Windows.Forms.Padding(5);\n            this.tableLayoutPanel1.RowCount = 5;\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.notifyIcon1.Icon = ((System.Drawing.Icon)(resources.GetObject("notifyIcon1.Icon")));\n            this.notifyIcon1.Text = "shadowsocks";\n            this.notifyIcon1.Visible = true;\n            this.notifyIcon1.DoubleClick += new System.EventHandler(this.notifyIcon1_DoubleClick);\n            // \n            // panel2\n            // \n            this.panel2.Anchor = System.Windows.Forms.AnchorStyles.Top;\n            this.panel2.AutoSize = true;\n            this.panel2.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;
            // button2\n            // \n            this.button2.DialogResult = System.Windows.Forms.DialogResult.Cancel;\n            this.button2.Location = new System.Drawing.Point(86, 4);\n            this.button2.Name = "button2";\n            this.button2.Size = new System.Drawing.Size(75, 23);\n            this.button2.TabIndex = 1;\n            this.button2.Text = "Cancel";\n            this.button2.UseVisualStyleBackColor = true;\n            this.button2.Click += new System.EventHandler(this.cancelButton_Click);\n            // \n            // panel1\n            // 
            this.button2.Name = "button2";\n            this.button2.Size = new System.Drawing.Size(75, 23);\n            this.button2.TabIndex = 1;\n            this.button2.Text = "Cancel";\n            this.button2.UseVisualStyleBackColor = true;\n            this.button2.Click += new System.EventHandler(this.cancelButton_Click);\n            // \n            // panel1\n            // \n            this.panel1.Anchor = System.Windows.Forms.AnchorStyles.Top;\n            this.panel1.AutoSize = true;\n            this.panel1.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;
            this.panel1.Name = "panel1";\n            // aboutItem\n            // \n            this.aboutItem.Index = 3;\n            this.aboutItem.Text = "About";
            // \n            this.menuItem3.Index = 4;\n            this.menuItem3.Text = "-";\n            // \n            // quitItem\n            // \n            this.quitItem.Index = 5;\n            this.quitItem.Text = "Quit";\n            this.quitItem.Click += new System.EventHandler(this.Quit_Click);\n            // 
            // \n            // quitItem\n            // \n            this.quitItem.Index = 5;\n            this.quitItem.Text = "Quit";\n            this.quitItem.Click += new System.EventHandler(this.Quit_Click);\n            // \n            this.CancelButton = this.button2;\n            this.ClientSize = new System.Drawing.Size(250, 221);\n            this.Controls.Add(this.panel2);
            // \n            this.CancelButton = this.button2;\n            this.ClientSize = new System.Drawing.Size(250, 221);\n            this.Controls.Add(this.panel2);\n            this.Controls.Add(this.tableLayoutPanel1);\n            this.Controls.Add(this.panel1);\n            this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));\n            this.Name = "ConfigForm";\n            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;\n            this.Text = "Shadowsocks";
            this.ResumeLayout(false);\n            this.PerformLayout();\n        }\n        #endregion\n        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel1;\n        private System.Windows.Forms.Label label1;\n        private System.Windows.Forms.Label label2;\n        private System.Windows.Forms.Label label3;\n        private System.Windows.Forms.Label label4;
        private System.Windows.Forms.Label label1;\n        private System.Windows.Forms.Label label2;\n        private System.Windows.Forms.Label label3;\n        private System.Windows.Forms.Label label4;\n        private System.Windows.Forms.TextBox textBox1;\n        private System.Windows.Forms.TextBox textBox2;\n        private System.Windows.Forms.TextBox textBox3;\n        private System.Windows.Forms.TextBox textBox4;\n        private System.Windows.Forms.NotifyIcon notifyIcon1;\n        private System.Windows.Forms.Label label5;
        private System.Windows.Forms.Label label3;\n        private System.Windows.Forms.Label label4;\n        private System.Windows.Forms.TextBox textBox1;\n        private System.Windows.Forms.TextBox textBox2;\n        private System.Windows.Forms.TextBox textBox3;\n        private System.Windows.Forms.TextBox textBox4;\n        private System.Windows.Forms.NotifyIcon notifyIcon1;\n        private System.Windows.Forms.Label label5;\n        private System.Windows.Forms.ComboBox comboBox1;\n        private System.Windows.Forms.Panel panel2;
﻿using System;\nusing System.Collections.Generic;\nusing System.Text;
﻿using System;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.Threading;\nusing System.Net;\nusing System.IO;
﻿using Shadowsocks.Model;\nusing Shadowsocks.Properties;\nusing System;
using Shadowsocks.Properties;\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.IO.Compression;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Text;
        private int flashStep;
        {\n            get\n            {\n                CreateParams cp = base.CreateParams;\n                cp.ExStyle |= 0x00080000; // This form has to have the WS_EX_LAYERED extended style\n                return cp;\n            }\n        }\n        void timer_Tick(object sender, EventArgs e)\n        {
                    }\n                    else\n                    {\n                        string pacUrl;\n                        if (config.useOnlinePac && !string.IsNullOrEmpty(config.pacUrl))\n                            pacUrl = config.pacUrl;\n                        else\n                            pacUrl = "http://127.0.0.1:" + config.localPort.ToString() + "/pac?t=" + GetTimestamp(DateTime.Now);\n                        registry.SetValue("ProxyEnable", 0);\n                        var readProxyServer = registry.GetValue("ProxyServer");
                        registry.SetValue("ProxyEnable", 0);\n                        var readProxyServer = registry.GetValue("ProxyServer");\n                        if (readProxyServer != null && readProxyServer.Equals("127.0.0.1:" + config.localPort.ToString()))\n                            registry.SetValue("ProxyServer", "");\n                        registry.SetValue("AutoConfigURL", pacUrl);\n                    }\n                }\n                else\n                {\n                    registry.SetValue("ProxyEnable", 0);
            if (bytes == null)\n            {\n                throw new FormatException();\n            }\n            try\n            {\n                string data = Encoding.UTF8.GetString(bytes);\n                int indexLastAt = data.LastIndexOf('@');\n                string afterAt = data.Substring(indexLastAt + 1);\n                int indexLastColon = afterAt.LastIndexOf(':');
            try\n            {\n                string data = Encoding.UTF8.GetString(bytes);\n                int indexLastAt = data.LastIndexOf('@');\n                string afterAt = data.Substring(indexLastAt + 1);\n                int indexLastColon = afterAt.LastIndexOf(':');\n                this.server_port = int.Parse(afterAt.Substring(indexLastColon + 1));\n                this.server = afterAt.Substring(0, indexLastColon);\n                string beforeAt = data.Substring(0, indexLastAt);\n                string[] parts = beforeAt.Split(new[] { ':' });
        public bool useOnlinePac;\n        public bool availabilityStatistics;\n        public bool autoCheckUpdate;\n        public LogViewerConfig logViewer;\n        private static string CONFIG_FILE = "gui-config.json";\n        public Server GetCurrentServer()\n        {\n            if (index >= 0 && index < configs.Count)
        public bool autoCheckUpdate;\n        public LogViewerConfig logViewer;\n        private static string CONFIG_FILE = "gui-config.json";\n        public Server GetCurrentServer()\n        {\n            if (index >= 0 && index < configs.Count)\n            {\n                return configs[index];
        private static string CONFIG_FILE = "gui-config.json";\n        public Server GetCurrentServer()\n        {\n            if (index >= 0 && index < configs.Count)\n            {\n                return configs[index];\n            }\n            else
        private static string CONFIG_FILE = "gui-config.json";\n        public Server GetCurrentServer()\n        {\n            if (index >= 0 && index < configs.Count)\n            {\n                return configs[index];\n            }\n            else\n            {\n                return GetDefaultServer();
            CheckServer(server.server);\n        }\n        public static Configuration Load()\n        {\n            try\n            {\n                string configContent = File.ReadAllText(CONFIG_FILE);\n                Configuration config = JsonConvert.DeserializeObject<Configuration>(configContent);\n                config.isDefault = false;\n                if (config.localPort == 0)
        public static Configuration Load()\n        {\n            try\n            {\n                string configContent = File.ReadAllText(CONFIG_FILE);\n                Configuration config = JsonConvert.DeserializeObject<Configuration>(configContent);\n                config.isDefault = false;\n                if (config.localPort == 0)\n                {\n                    config.localPort = 1080;
                {\n                    config.localPort = 1080;\n                    if (config.strategy == null)\n                    {\n                        config.index = 0;\n                    }\n                }\n                return config;\n            }\n            catch (Exception e)\n            {\n                if (!(e is FileNotFoundException))
                        config.index = 0;\n                    }\n                }\n                return config;\n            }\n            catch (Exception e)\n            {\n                if (!(e is FileNotFoundException))\n                {\n                    Logging.LogUsefulException(e);
                    configs = new List<Server>()\n                    {\n                        GetDefaultServer()\n                    }\n                };\n            }\n        }\n        public static void Save(Configuration config)\n        {\n            if (config.index >= config.configs.Count)
                        GetDefaultServer()\n                    }\n                };\n            }\n        }\n        public static void Save(Configuration config)\n        {\n            if (config.index >= config.configs.Count)\n            {\n                config.index = config.configs.Count - 1;
                };\n            }\n        }\n        public static void Save(Configuration config)\n        {\n            if (config.index >= config.configs.Count)\n            {\n                config.index = config.configs.Count - 1;\n            }\n            if (config.index < -1)
        }\n        public static void Save(Configuration config)\n        {\n            if (config.index >= config.configs.Count)\n            {\n                config.index = config.configs.Count - 1;\n            }\n            if (config.index < -1)\n            {\n                config.index = -1;
                Console.Error.WriteLine(e);\n            }\n        }\n        public static Server GetDefaultServer()\n        {\n            return new Server();\n        }\n        private static void Assert(bool condition)\n        {\n            if (!condition)
        }\n        public static Server GetDefaultServer()\n        {\n            return new Server();\n        }\n        private static void Assert(bool condition)\n        {\n            if (!condition)\n            {\n                throw new Exception(I18N.GetString("assertion failure"));
        private static void Assert(bool condition)\n        {\n            if (!condition)\n            {\n                throw new Exception(I18N.GetString("assertion failure"));\n            }\n        }\n        public static void CheckPort(int port)\n        {\n            if (port <= 0 || port > 65535)
            if (!condition)\n            {\n                throw new Exception(I18N.GetString("assertion failure"));\n            }\n        }\n        public static void CheckPort(int port)\n        {\n            if (port <= 0 || port > 65535)\n            {\n                throw new ArgumentException(I18N.GetString("Port out of range"));
        {\n            if (port <= 0 || port > 65535)\n            {\n                throw new ArgumentException(I18N.GetString("Port out of range"));\n            }\n        }\n        public static void CheckLocalPort(int port)\n        {\n            CheckPort(port);\n            if (port == 8123)
            {\n                throw new ArgumentException(I18N.GetString("Port out of range"));\n            }\n        }\n        public static void CheckLocalPort(int port)\n        {\n            CheckPort(port);\n            if (port == 8123)\n            {\n                throw new ArgumentException(I18N.GetString("Port can't be 8123"));
        {\n            CheckPort(port);\n            if (port == 8123)\n            {\n                throw new ArgumentException(I18N.GetString("Port can't be 8123"));\n            }\n        }\n        private static void CheckPassword(string password)\n        {\n            if (string.IsNullOrEmpty(password))
            if (port == 8123)\n            {\n                throw new ArgumentException(I18N.GetString("Port can't be 8123"));\n            }\n        }\n        private static void CheckPassword(string password)\n        {\n            if (string.IsNullOrEmpty(password))\n            {\n                throw new ArgumentException(I18N.GetString("Password can not be blank"));
        private static void CheckPassword(string password)\n        {\n            if (string.IsNullOrEmpty(password))\n            {\n                throw new ArgumentException(I18N.GetString("Password can not be blank"));\n            }\n        }\n        private static void CheckServer(string server)\n        {\n            if (string.IsNullOrEmpty(server))
            if (string.IsNullOrEmpty(password))\n            {\n                throw new ArgumentException(I18N.GetString("Password can not be blank"));\n            }\n        }\n        private static void CheckServer(string server)\n        {\n            if (string.IsNullOrEmpty(server))\n            {\n                throw new ArgumentException(I18N.GetString("Server IP can not be blank"));
﻿using System;
﻿using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;
﻿using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Text;
            string arguments;\n            if (enable)\n            {
            string arguments;\n            if (enable)\n            {\n                {\n                    arguments = $"global {proxyServer} <local>;localhost;127.*;10.*;172.16.*;172.17.*;172.18.*;172.19.*;172.20.*;172.21.*;172.22.*;172.23.*;172.24.*;172.25.*;172.26.*;172.27.*;172.28.*;172.29.*;172.30.*;172.31.*;172.32.*;192.168.*";\n                }\n                else\n                {\n                    arguments = $"pac {pacURL}";\n                }\n            }\n            else\n            {
                process.StartInfo.Arguments = arguments;\n                process.StartInfo.WorkingDirectory = Utils.GetTempPath();\n                process.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;\n                process.StartInfo.UseShellExecute = false;\n                process.StartInfo.RedirectStandardError = true;\n                process.StartInfo.CreateNoWindow = true;\n                process.Start();
                process.StartInfo.CreateNoWindow = true;\n                process.Start();\n                var error = process.StandardError.ReadToEnd();\n                process.WaitForExit();\n                var exitCode = process.ExitCode;
                    {\n                        string pacUrl;\n                        if (config.useOnlinePac && !config.pacUrl.IsNullOrEmpty())\n                        {\n                            pacUrl = config.pacUrl;\n                        }\n                        else\n                        {\n                            pacUrl = pacSrv.PacUrl;\n                        }
                        }\n                        else\n                        {\n                            pacUrl = pacSrv.PacUrl;\n                        }\n                        Sysproxy.SetIEProxy(true, false, "", pacUrl);\n                    }\n                }\n                else\n                {
                    {\n                        if (kv[0] == "Host")\n                        {\n                            if (kv[1].Trim() == ((IPEndPoint)socket.LocalEndPoint).ToString())\n                            {\n                                hostMatch = true;\n                            }\n                        }\n                        else if (kv[0] == "User-Agent")\n                        {
                            if (kv[1].Trim() == ((IPEndPoint)socket.LocalEndPoint).ToString())\n                            {\n                                hostMatch = true;\n                            }\n                        }\n                        else if (kv[0] == "User-Agent")\n                        {\n                            if (kv[1].IndexOf("Chrome") >= 0)\n                            {\n                                useSocks = true;
        }\n        protected void SaveConfig(Configuration newConfig)\n        {\n            Configuration.Save(newConfig);\n            Reload();\n        }\n        private void UpdateSystemProxy()\n        {\n            if (_config.enabled)\n            {
        {\n            if (_config.enabled)\n            {\n                SystemProxy.Enable(_config.global);\n                _systemProxyIsDirty = true;\n            }\n            else\n            {\n                // only switch it off if we have switched it on\n                if (_systemProxyIsDirty)\n                {
        public const int INTERNET_OPTION_SETTINGS_CHANGED = 39;\n        public const int INTERNET_OPTION_REFRESH = 37;\n        static bool _settingsReturn, _refreshReturn;\n        public static void NotifyIE()\n        {\n            // These lines implement the Interface in the beginning of program \n            // They cause the OS to refresh the settings, causing IP to realy update\n            _settingsReturn = InternetSetOption(IntPtr.Zero, INTERNET_OPTION_SETTINGS_CHANGED, IntPtr.Zero, 0);\n            _refreshReturn = InternetSetOption(IntPtr.Zero, INTERNET_OPTION_REFRESH, IntPtr.Zero, 0);\n        }
            try\n            {\n                RegistryKey registry =\n                    Registry.CurrentUser.OpenSubKey("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings",\n                        true);
            try\n            {\n                RegistryKey registry =\n                    Registry.CurrentUser.OpenSubKey("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings",\n                        true);\n                if (global)\n                {
                    registry.SetValue("ProxyEnable", 1);\n                    registry.SetValue("ProxyServer", "127.0.0.1:8123");\n                    registry.SetValue("AutoConfigURL", "");\n                }\n                else\n                {\n                    registry.SetValue("ProxyEnable", 0);\n                    registry.SetValue("ProxyServer", "");
                    registry.SetValue("ProxyServer", "127.0.0.1:8123");\n                    registry.SetValue("AutoConfigURL", "");\n                }\n                else\n                {\n                    registry.SetValue("ProxyEnable", 0);\n                    registry.SetValue("ProxyServer", "");\n                    registry.SetValue("AutoConfigURL", "http://127.0.0.1:8093/pac?t=" + GetTimestamp(DateTime.Now));\n                }\n                SystemProxy.NotifyIE();\n                //Must Notify IE first, or the connections do not chanage
        {\n            using (StreamReader reader = new StreamReader(new FileStream(filename,\n                     FileMode.Open, FileAccess.Read, FileShare.ReadWrite)))\n            {\n                reader.BaseStream.Seek(lastOffset, SeekOrigin.Begin);\n                string line = "";\n                bool changed = false;\n                while ((line = reader.ReadLine()) != null)\n                {\n                    changed = true;
                reader.BaseStream.Seek(lastOffset, SeekOrigin.Begin);\n                string line = "";\n                bool changed = false;\n                while ((line = reader.ReadLine()) != null)\n                {\n                    changed = true;\n                    textBox1.AppendText(line + "\r\n");\n                }\n                if (changed)\n                {
            InitContent();\n            timer = new Timer();\n            timer.Interval = 300;\n            timer.Tick += Timer_Tick;\n            timer.Start();\n        }\n        private void LogForm_FormClosing(object sender, FormClosingEventArgs e)\n        {\n            timer.Stop();\n        }
        }\n        private void LogForm_FormClosing(object sender, FormClosingEventArgs e)\n        {\n            timer.Stop();\n        }\n        private void menuItem2_Click(object sender, EventArgs e)\n        {\n            string argument = @"/select, " + filename;\n            System.Diagnostics.Process.Start("explorer.exe", argument);\n        }
        {\n            string argument = @"/select, " + filename;\n            System.Diagnostics.Process.Start("explorer.exe", argument);\n        }\n        private void menuItem3_Click(object sender, EventArgs e)\n        {\n        }\n        private void menuItem4_Click(object sender, EventArgs e)\n        {\n            this.Close();\n        }\n        private void LogForm_Shown(object sender, EventArgs e)\n        {
            base.Dispose(disposing);\n        }\n        #region Windows Form Designer generated code\n        /// <summary>\n        /// Required method for Designer support - do not modify\n        /// the contents of this method with the code editor.\n        /// </summary>\n        private void InitializeComponent()\n        {\n            this.components = new System.ComponentModel.Container();
        /// <summary>\n        /// Required method for Designer support - do not modify\n        /// the contents of this method with the code editor.\n        /// </summary>\n        private void InitializeComponent()\n        {\n            this.components = new System.ComponentModel.Container();\n            this.textBox1 = new System.Windows.Forms.TextBox();\n            this.contextMenuStrip1 = new System.Windows.Forms.ContextMenuStrip(this.components);\n            this.mainMenu1 = new System.Windows.Forms.MainMenu(this.components);
            this.contextMenuStrip1 = new System.Windows.Forms.ContextMenuStrip(this.components);\n            this.mainMenu1 = new System.Windows.Forms.MainMenu(this.components);\n            this.menuItem1 = new System.Windows.Forms.MenuItem();\n            this.menuItem2 = new System.Windows.Forms.MenuItem();\n            this.menuItem4 = new System.Windows.Forms.MenuItem();\n            this.SuspendLayout();\n            // 
            this.mainMenu1 = new System.Windows.Forms.MainMenu(this.components);\n            this.menuItem1 = new System.Windows.Forms.MenuItem();\n            this.menuItem2 = new System.Windows.Forms.MenuItem();\n            this.menuItem4 = new System.Windows.Forms.MenuItem();\n            this.SuspendLayout();\n            // \n            this.menuItem1});\n            // 
            this.SuspendLayout();\n            // \n            this.menuItem1});\n            // \n            this.menuItem1.Index = 0;\n            this.menuItem1.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {\n            this.menuItem2,\n            this.menuItem4});\n            this.menuItem1.Text = "&File";\n            // 
            this.menuItem2,\n            this.menuItem4});\n            this.menuItem1.Text = "&File";\n            // \n            this.menuItem2.Index = 0;\n            this.menuItem2.Text = "&Open Location";\n            this.menuItem2.Click += new System.EventHandler(this.menuItem2_Click);\n            // 
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;\n            this.Text = "Log Viewer";\n            this.FormClosing += new System.Windows.Forms.FormClosingEventHandler(this.LogForm_FormClosing);\n            this.Load += new System.EventHandler(this.LogForm_Load);\n            this.Shown += new System.EventHandler(this.LogForm_Shown);\n            this.ResumeLayout(false);
            this.FormClosing += new System.Windows.Forms.FormClosingEventHandler(this.LogForm_FormClosing);\n            this.Load += new System.EventHandler(this.LogForm_Load);\n            this.Shown += new System.EventHandler(this.LogForm_Shown);\n            this.ResumeLayout(false);\n            this.PerformLayout();\n        }\n        #endregion
            this.ResumeLayout(false);\n            this.PerformLayout();\n        }\n        #endregion\n        private System.Windows.Forms.TextBox textBox1;\n        private System.Windows.Forms.ContextMenuStrip contextMenuStrip1;\n        private System.Windows.Forms.MainMenu mainMenu1;
                local_port = 1080,\n                method = "aes-256-cfb",\n                password = "",\n                remarks = ""\n            };\n        }\n        private static void Assert(bool condition)\n        {\n            if (!condition)\n            {
        {\n            if (!condition)\n            {\n                throw new Exception("assertion failure");\n            }\n        }\n        private static void CheckPort(int port)\n        {\n            if (port <= 0 || port > 65535)\n            {
        {\n            if (port <= 0 || port > 65535)\n            {\n                throw new ArgumentException("port out of range");\n            }\n        }\n        private static void CheckPassword(string password)\n        {\n            if (string.IsNullOrEmpty(password))\n            {
        {\n            if (string.IsNullOrEmpty(password))\n            {\n                throw new ArgumentException("password can not be blank");\n            }\n        }\n        private static void CheckServer(string server)\n        {\n            if (string.IsNullOrEmpty(server))\n            {
using Shadowsocks.Properties;\nusing SimpleJson;\nusing Shadowsocks.Util;\nusing Shadowsocks.Model;\nnamespace Shadowsocks.Controller\n{\n    public class GFWListUpdater\n    {\n        private const string GFWLIST_URL = "https://autoproxy-gfwlist.googlecode.com/svn/trunk/gfwlist.txt";\n        private static string PAC_FILE = PACServer.PAC_FILE;
                File.WriteAllText(PAC_FILE, abpContent, Encoding.UTF8);\n                if (UpdateCompleted != null)\n                {
using Shadowsocks.Util;\nnamespace Shadowsocks.Controller\n{\n    public class Logging\n    {\n        public static string LogFile;\n        public static bool OpenLogFile()\n        {\n            try\n            {
            {\n                throw new ArgumentException("Too short!", nameof(delimiter));\n            }\n            if (maxLineBytes < _delimiterBytes.Length)\n            {\n                throw new ArgumentException("Too small!", nameof(maxLineBytes));\n            }\n            _delimiterSearchCharTable = MakeCharTable(_delimiterBytes);\n            _delimiterSearchOffsetTable = MakeOffsetTable(_delimiterBytes);\n            _lineBuffer = new byte[maxLineBytes];
            _delimiterSearchCharTable = MakeCharTable(_delimiterBytes);\n            _delimiterSearchOffsetTable = MakeOffsetTable(_delimiterBytes);\n            _lineBuffer = new byte[maxLineBytes];\n            // start reading\n            socket.BeginReceive(_lineBuffer, 0, maxLineBytes, 0, ReceiveCallback, 0);\n        }\n        private void ReceiveCallback(IAsyncResult ar)\n        {
            socket.BeginReceive(_lineBuffer, 0, maxLineBytes, 0, ReceiveCallback, 0);\n        }\n        private void ReceiveCallback(IAsyncResult ar)\n        {\n            int length = (int)ar.AsyncState;\n            try\n            {\n                var bytesRead = _socket.EndReceive(ar);\n                if (bytesRead == 0)\n                {
        {\n            int length = (int)ar.AsyncState;\n            try\n            {\n                var bytesRead = _socket.EndReceive(ar);\n                if (bytesRead == 0)\n                {\n                    OnFinish(length);\n                    return;\n                }
                        OnFinish(length);\n                        return;\n                    }\n                }\n                if (length == _lineBuffer.Length)\n                {\n                    OnException(new IndexOutOfRangeException("LineBuffer full! Try increace maxLineBytes!"));\n                    OnFinish(length);\n                    return;\n                }
            catch (Exception ex)\n            {\n                OnException(ex);\n                OnFinish(length);\n            }\n        }\n        private void OnException(Exception ex)\n        {\n            _onException?.Invoke(ex, _state);\n        }
            }\n        }\n        private void OnException(Exception ex)\n        {\n            _onException?.Invoke(ex, _state);\n        }\n        private void OnFinish(int length)\n        {\n            _onFinish?.Invoke(_lineBuffer, _bufferIndex, length, _state);\n        }\n        #region Boyer-Moore string search
﻿using System.Windows.Forms;\nusing Microsoft.Win32;\nusing System;
﻿using System.Windows.Forms;\nusing Microsoft.Win32;\nusing System;\nusing System.Collections.Generic;\nusing System.Runtime.InteropServices;
                    registry.SetValue("ProxyServer", "");\n                    registry.SetValue("AutoConfigURL", "");\n                }\n                //Set AutoDetectProxy\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                // TODO this should be moved into views
            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                // TODO this should be moved into views\n                MessageBox.Show(I18N.GetString("Failed to update registry"));\n            }\n        }\n        private static void CopyProxySettingFromLan()\n        {
                        case "DEFAULTCONNECTIONSETTINGS":\n                        case "LAN CONNECTION":\n                        case "SAVEDLEGACYSETTINGS":\n                            continue;\n                        default:\n                            //set all the connections's proxy as the lan
                        default:\n                            //set all the connections's proxy as the lan\n            }\n            catch (IOException e)\n            {\n                Logging.LogUsefulException(e);\n            }\n        }\n        /// <summary>\n        /// Checks or unchecks the IE Options Connection setting of "Automatically detect Proxy"\n        /// </summary>\n        /// <param name="set">Provide 'true' if you want to check the 'Automatically detect Proxy' check box. To uncheck, pass 'false'</param>\n        private static void IEAutoDetectProxy(bool set)\n        {
                .OpenSubKey(@"Software\Microsoft\Windows\CurrentVersion\Internet Settings\Connections", true);\n            var defConnection = (byte[])registry.GetValue("DefaultConnectionSettings");\n            var savedLegacySetting = (byte[])registry.GetValue("SavedLegacySettings");\n            const int versionOffset = 4;\n            const int optionsOffset = 8;\n            if (set)\n            {\n                defConnection[optionsOffset] = (byte)(defConnection[optionsOffset] | 8);\n                savedLegacySetting[optionsOffset] = (byte)(savedLegacySetting[optionsOffset] | 8);\n            }
            if (!Utils.IsSupportedRuntimeVersion())\n            {\n                if (DialogResult.OK == MessageBox.Show(I18N.GetString("Unsupported .NET Framework, please update to {0} or later.", "4.7.2"),\n                "Shadowsocks Error", MessageBoxButtons.OKCancel, MessageBoxIcon.Error))\n                {\n                    //Process.Start("https://www.microsoft.com/download/details.aspx?id=53344");    // 4.6.2\n                    Process.Start("https://dotnet.microsoft.com/download/dotnet-framework/net472");\n                }\n                return;\n            }
                "Shadowsocks Error", MessageBoxButtons.OKCancel, MessageBoxIcon.Error))\n                {\n                    //Process.Start("https://www.microsoft.com/download/details.aspx?id=53344");    // 4.6.2\n                    Process.Start("https://dotnet.microsoft.com/download/dotnet-framework/net472");\n                }\n                return;\n            }\n            Utils.ReleaseMemory(true);\n            using (Mutex mutex = new Mutex(false, $"Global\\Shadowsocks_{Application.StartupPath.GetHashCode()}"))\n            {
                    if (oldProcesses.Length > 0)\n                    {\n                        Process oldProcess = oldProcesses[0];\n                    }\n                    MessageBox.Show(I18N.GetString("Find Shadowsocks icon in your notify tray.")\n                        + Environment.NewLine\n                        + I18N.GetString("If you want to start multiple Shadowsocks, make a copy in another directory."),\n                        I18N.GetString("Shadowsocks is already running."));\n                    return;\n                }
                        I18N.GetString("Shadowsocks is already running."));\n                    return;\n                }\n                Directory.SetCurrentDirectory(Application.StartupPath);\n#if DEBUG
            {\n                var calculation = new CalculationControl(kv.Key, kv.Value);\n                calculationContainer.Controls.Add(calculation);\n            }\n            serverSelector.DataSource = _servers;\n            _dataTable.Columns.Add("Timestamp", typeof(DateTime));\n            _dataTable.Columns.Add("Speed", typeof (int));
            var serverName = _servers[serverSelector.SelectedIndex];\n            _dataTable.Rows.Clear();\n            //return directly when no data is usable\n            if (_controller.availabilityStatistics?.FilteredStatistics == null) return;\n            List<StatisticsRecord> statistics;\n            if (!_controller.availabilityStatistics.FilteredStatistics.TryGetValue(serverName, out statistics)) return;\n            IEnumerable<IGrouping<int, StatisticsRecord>> dataGroups;\n            if (allMode.Checked)\n            {\n                dataGroups = statistics.GroupBy(data => data.Timestamp.DayOfYear);
            List<StatisticsRecord> statistics;\n            if (!_controller.availabilityStatistics.FilteredStatistics.TryGetValue(serverName, out statistics)) return;\n            IEnumerable<IGrouping<int, StatisticsRecord>> dataGroups;\n            if (allMode.Checked)\n            {\n                dataGroups = statistics.GroupBy(data => data.Timestamp.DayOfYear);\n                                Ping = (int)dataGroup.Average(data => data.AverageResponse),\n                                PackageLoss = dataGroup.Average(data => data.PackageLoss)};\n            foreach (var data in finalData)\n            {
            {\n                dataGroups = statistics.GroupBy(data => data.Timestamp.DayOfYear);\n                                Ping = (int)dataGroup.Average(data => data.AverageResponse),\n                                PackageLoss = dataGroup.Average(data => data.PackageLoss)};\n            foreach (var data in finalData)\n            {\n                _dataTable.Rows.Add(data.Timestamp, data.PackageLoss, data.Ping);\n            }\n            StatisticsChart.DataBind();\n        }
                                PackageLoss = dataGroup.Average(data => data.PackageLoss)};\n            foreach (var data in finalData)\n            {\n                _dataTable.Rows.Add(data.Timestamp, data.PackageLoss, data.Ping);\n            }\n            StatisticsChart.DataBind();\n        }\n        private void serverSelector_SelectedIndexChanged(object sender, EventArgs e)\n        {\n            LoadChartData();
            this.repeatTimesNum = new System.Windows.Forms.NumericUpDown();\n            this.label6 = new System.Windows.Forms.Label();\n            this.splitContainer3 = new System.Windows.Forms.SplitContainer();\n            this.label1 = new System.Windows.Forms.Label();\n            this.calculationContainer = new System.Windows.Forms.FlowLayoutPanel();\n            this.serverSelector = new System.Windows.Forms.ComboBox();\n            this.CancelButton = new System.Windows.Forms.Button();\n            this.OKButton = new System.Windows.Forms.Button();\n            ((System.ComponentModel.ISupportInitialize)(this.StatisticsChart)).BeginInit();
            this.StatisticsChart.ChartAreas.Add(chartArea1);\n            this.StatisticsChart.Dock = System.Windows.Forms.DockStyle.Fill;\n            legend1.BackColor = System.Drawing.Color.Transparent;\n            legend1.Name = "ChartLegend";\n            this.StatisticsChart.Legends.Add(legend1);\n            this.StatisticsChart.Location = new System.Drawing.Point(0, 0);\n            this.StatisticsChart.Margin = new System.Windows.Forms.Padding(5, 10, 5, 10);\n            this.StatisticsChart.Name = "StatisticsChart";\n            this.StatisticsChart.Palette = System.Windows.Forms.DataVisualization.Charting.ChartColorPalette.Pastel;\n            series1.ChartArea = "DataArea";
            legend1.BackColor = System.Drawing.Color.Transparent;\n            legend1.Name = "ChartLegend";\n            this.StatisticsChart.Legends.Add(legend1);\n            this.StatisticsChart.Location = new System.Drawing.Point(0, 0);\n            this.StatisticsChart.Margin = new System.Windows.Forms.Padding(5, 10, 5, 10);\n            this.StatisticsChart.Name = "StatisticsChart";\n            this.StatisticsChart.Palette = System.Windows.Forms.DataVisualization.Charting.ChartColorPalette.Pastel;\n            series1.ChartArea = "DataArea";\n            series1.ChartType = System.Windows.Forms.DataVisualization.Charting.SeriesChartType.Bubble;\n            series1.Color = System.Drawing.Color.FromArgb(((int)(((byte)(221)))), ((int)(((byte)(88)))), ((int)(((byte)(0)))));\n            series1.Legend = "ChartLegend";
            this.StatisticsChart.Margin = new System.Windows.Forms.Padding(5, 10, 5, 10);\n            this.StatisticsChart.Name = "StatisticsChart";\n            this.StatisticsChart.Palette = System.Windows.Forms.DataVisualization.Charting.ChartColorPalette.Pastel;\n            series1.ChartArea = "DataArea";\n            series1.ChartType = System.Windows.Forms.DataVisualization.Charting.SeriesChartType.Bubble;\n            series1.Color = System.Drawing.Color.FromArgb(((int)(((byte)(221)))), ((int)(((byte)(88)))), ((int)(((byte)(0)))));\n            series1.Legend = "ChartLegend";\n            series1.Name = "Package Loss";\n            series1.XValueType = System.Windows.Forms.DataVisualization.Charting.ChartValueType.DateTime;\n            series1.YValuesPerPoint = 2;\n            series2.BorderWidth = 4;\n            series2.ChartArea = "DataArea";
            series1.ChartArea = "DataArea";\n            series1.ChartType = System.Windows.Forms.DataVisualization.Charting.SeriesChartType.Bubble;\n            series1.Color = System.Drawing.Color.FromArgb(((int)(((byte)(221)))), ((int)(((byte)(88)))), ((int)(((byte)(0)))));\n            series1.Legend = "ChartLegend";\n            series1.Name = "Package Loss";\n            series1.XValueType = System.Windows.Forms.DataVisualization.Charting.ChartValueType.DateTime;\n            series1.YValuesPerPoint = 2;\n            series2.BorderWidth = 4;\n            series2.ChartArea = "DataArea";\n            series2.ChartType = System.Windows.Forms.DataVisualization.Charting.SeriesChartType.Line;\n            series2.Color = System.Drawing.Color.FromArgb(((int)(((byte)(155)))), ((int)(((byte)(77)))), ((int)(((byte)(150)))));\n            series2.Legend = "ChartLegend";
            series1.YValuesPerPoint = 2;\n            series2.BorderWidth = 4;\n            series2.ChartArea = "DataArea";\n            series2.ChartType = System.Windows.Forms.DataVisualization.Charting.SeriesChartType.Line;\n            series2.Color = System.Drawing.Color.FromArgb(((int)(((byte)(155)))), ((int)(((byte)(77)))), ((int)(((byte)(150)))));\n            series2.Legend = "ChartLegend";\n            series2.Name = "Ping";\n            series2.XValueType = System.Windows.Forms.DataVisualization.Charting.ChartValueType.DateTime;\n            series3.ChartArea = "DataArea";
            series2.ChartType = System.Windows.Forms.DataVisualization.Charting.SeriesChartType.Line;\n            series2.Color = System.Drawing.Color.FromArgb(((int)(((byte)(155)))), ((int)(((byte)(77)))), ((int)(((byte)(150)))));\n            series2.Legend = "ChartLegend";\n            series2.Name = "Ping";\n            series2.XValueType = System.Windows.Forms.DataVisualization.Charting.ChartValueType.DateTime;\n            series3.ChartArea = "DataArea";\n            series3.ChartType = System.Windows.Forms.DataVisualization.Charting.SeriesChartType.Area;\n            series3.Legend = "ChartLegend";
            series3.ChartType = System.Windows.Forms.DataVisualization.Charting.SeriesChartType.Area;\n            series3.Legend = "ChartLegend";\n            series3.Name = "Speed";\n            this.StatisticsChart.Series.Add(series1);\n            this.StatisticsChart.Series.Add(series2);\n            this.StatisticsChart.Series.Add(series3);
            // \n            // CancelButton\n            // \n            this.CancelButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));\n            // StatisticsStrategyConfigurationForm\n            // 

      /// </summary>\n      public static readonly Mode ALPHANUMERIC = new Mode(new int[] { 9, 11, 13 }, 0x02, "ALPHANUMERIC");\n      /// <summary>\n      /// \n      /// </summary>\n      public static readonly Mode STRUCTURED_APPEND = new Mode(new int[] { 0, 0, 0 }, 0x03, "STRUCTURED_APPEND"); // Not supported\n      /// <summary>\n      /// \n      /// </summary>\n      public static readonly Mode BYTE = new Mode(new int[] { 8, 16, 16 }, 0x04, "BYTE");
      /// </summary>\n      /// <param name="bits">four bits encoding a QR Code data mode</param>\n      /// <returns>\n      ///   <see cref="Mode"/> encoded by these bits\n      /// </returns>\n      /// <exception cref="ArgumentException">if bits do not correspond to a known mode</exception>\n      public static Mode forBits(int bits)\n      {\n         switch (bits)\n         {
      ///   <see cref="Mode"/> encoded by these bits\n      /// </returns>\n      /// <exception cref="ArgumentException">if bits do not correspond to a known mode</exception>\n      public static Mode forBits(int bits)\n      {\n         switch (bits)\n         {\n            case 0x0:\n               return TERMINATOR;\n            case 0x1:\n               return NUMERIC;\n            case 0x2:\n               return ALPHANUMERIC;\n            case 0x3:\n               return STRUCTURED_APPEND;\n            case 0x4:\n               return BYTE;

      public static GenericGF AZTEC_DATA_12 = new GenericGF(0x1069, 4096, 1); // x^12 + x^6 + x^5 + x^3 + 1\n      public static GenericGF AZTEC_DATA_10 = new GenericGF(0x409, 1024, 1); // x^10 + x^3 + 1\n      public static GenericGF AZTEC_DATA_6 = new GenericGF(0x43, 64, 1); // x^6 + x + 1\n      public static GenericGF AZTEC_PARAM = new GenericGF(0x13, 16, 1); // x^4 + x + 1\n      public static GenericGF QR_CODE_FIELD_256 = new GenericGF(0x011D, 256, 0); // x^8 + x^4 + x^3 + x^2 + 1
using System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing Google.Protobuf;\nusing Newtonsoft.Json;\nusing Shadowsocks.Model;\nusing System.Net;\nnamespace Shadowsocks.Controller\n{
using Google.Protobuf;\nusing Newtonsoft.Json;\nusing Shadowsocks.Model;\nusing System.Net;\nnamespace Shadowsocks.Controller\n{\n    static class GeositeUpdater\n    {\n        private static Logger logger = LogManager.GetCurrentClassLogger();
                pacServer = new PACServer();\n                pacServer.PACFileChanged += pacServer_PACFileChanged;\n                pacServer.Start(_config);\n            }\n            catch (Exception e)\n            {
            FieldInfo fi = type.GetField(name,\n                BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.IgnoreCase | BindingFlags.Static);\n            return fi == null ? null : fi.GetValue(obj);\n        }\n        /// <summary>\n        /// Create hotkey callback handler delegate based on callback name\n        /// </summary>\n        /// <param name="type"></param>\n        /// <param name="methodname"></param>\n        /// <returns></returns>
        /// <summary>\n        /// Create hotkey callback handler delegate based on callback name\n        /// </summary>\n        /// <param name="type"></param>\n        /// <param name="methodname"></param>\n        /// <returns></returns>\n        private Delegate GetDelegateViaMethodName(Type type, string methodname)\n        {\n            if (type == null) throw new ArgumentNullException(nameof(type));\n            if (methodname.IsNullOrEmpty()) throw new ArgumentException(nameof(methodname));
        /// </summary>\n        /// <param name="type"></param>\n        /// <param name="methodname"></param>\n        /// <returns></returns>\n        private Delegate GetDelegateViaMethodName(Type type, string methodname)\n        {\n            if (type == null) throw new ArgumentNullException(nameof(type));\n            if (methodname.IsNullOrEmpty()) throw new ArgumentException(nameof(methodname));\n            //HotkeySettingsForm form = new HotkeySettingsForm(_controller);\n            Type delegateType = Type.GetType("Shadowsocks.Util.HotKeys").GetNestedType("HotKeyCallBackHandler");\n            MethodInfo dynMethod = type.GetMethod(methodname,\n                BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.IgnoreCase);
﻿using System;\nusing Microsoft.VisualStudio.TestTools.UnitTesting;\nusing Shadowsocks.Controller;\nusing Shadowsocks.Encryption;
﻿using System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Linq;\nusing System.Windows.Forms;\nusing System.Windows.Input;\nusing GlobalHotKey;
using System.Windows.Forms;\nusing System.Windows.Input;\nusing GlobalHotKey;\nnamespace Shadowsocks.Util\n{\n    public static class HotKeys\n    {\n        private static HotKeyManager _hotKeyManager;\n        public delegate void HotKeyCallBackHandler();\n        // map key and corresponding handler function\n        private static Dictionary<HotKey, HotKeyCallBackHandler> _keymap = new Dictionary<HotKey, HotKeyCallBackHandler>();
            Bitmap iconCopy = new Bitmap(originIcon);\n            for (int x = 0; x < iconCopy.Width; x++)\n            {\n                for (int y = 0; y < iconCopy.Height; y++)\n                {\n                    Color color = originIcon.GetPixel(x, y);\n                    if (color.A != 0)\n                    {\n                        if (!enabled)\n                        {
                {\n                    Color color = originIcon.GetPixel(x, y);\n                    if (color.A != 0)\n                    {\n                        if (!enabled)\n                        {\n                            Color flyBlue = Color.FromArgb(192, 192, 192);\n                            // Multiply with flyBlue\n                            int red = color.R * flyBlue.R / 255;\n                            int green = color.G * flyBlue.G / 255;\n                            int blue = color.B * flyBlue.B / 255;
            {\n                gfwListUpdater = new GFWListUpdater();\n                gfwListUpdater.UpdateCompleted += pacServer_PACUpdateCompleted;\n                gfwListUpdater.Error += pacServer_PACUpdateError;\n            }\n            availabilityStatistics.UpdateConfiguration(this);\n            if (_listener != null)\n            {\n                _listener.Stop();\n            }
                _listener.Stop();\n            }\n            // though UseShellExecute is set to true now\n            // http://stackoverflow.com/questions/10235093/socket-doesnt-close-after-application-exits-if-a-launched-process-is-open\n            privoxyRunner.Stop();\n            try\n            {\n                var strategy = GetCurrentStrategy();\n                if (strategy != null)\n                {\n                    strategy.ReloadServers();\n                }
                {\n                    strategy.ReloadServers();\n                }\n                privoxyRunner.Start(_config);\n                TCPRelay tcpRelay = new TCPRelay(this, _config);\n                UDPRelay udpRelay = new UDPRelay(this);\n                List<Listener.IService> services = new List<Listener.IService>();\n                services.Add(tcpRelay);\n                services.Add(udpRelay);\n                services.Add(_pacServer);
using Shadowsocks.Controller;\nnamespace Shadowsocks.Util.ProcessManagement\n{\n    /*\n     * See:\n     * http://stackoverflow.com/questions/6266820/working-example-of-createjobobject-setinformationjobobject-pinvoke-in-net\n     */\n    public class Job : IDisposable\n    {\n        [DllImport("kernel32.dll", CharSet = CharSet.Unicode)]
{\n    /*\n     * See:\n     * http://stackoverflow.com/questions/6266820/working-example-of-createjobobject-setinformationjobobject-pinvoke-in-net\n     */\n    public class Job : IDisposable\n    {\n        [DllImport("kernel32.dll", CharSet = CharSet.Unicode)]\n        static extern IntPtr CreateJobObject(IntPtr a, string lpName);\n        [DllImport("kernel32.dll")]
     * See:\n     * http://stackoverflow.com/questions/6266820/working-example-of-createjobobject-setinformationjobobject-pinvoke-in-net\n     */\n    public class Job : IDisposable\n    {\n        [DllImport("kernel32.dll", CharSet = CharSet.Unicode)]\n        static extern IntPtr CreateJobObject(IntPtr a, string lpName);\n        [DllImport("kernel32.dll")]\n        static extern bool SetInformationJobObject(IntPtr hJob, JobObjectInfoType infoType, IntPtr lpJobObjectInfo, UInt32 cbJobObjectInfoLength);\n        [DllImport("kernel32.dll", SetLastError = true)]
    public class Job : IDisposable\n    {\n        [DllImport("kernel32.dll", CharSet = CharSet.Unicode)]\n        static extern IntPtr CreateJobObject(IntPtr a, string lpName);\n        [DllImport("kernel32.dll")]\n        static extern bool SetInformationJobObject(IntPtr hJob, JobObjectInfoType infoType, IntPtr lpJobObjectInfo, UInt32 cbJobObjectInfoLength);\n        [DllImport("kernel32.dll", SetLastError = true)]\n        static extern bool AssignProcessToJobObject(IntPtr job, IntPtr process);\n        [DllImport("kernel32.dll", SetLastError = true)]\n        [return: MarshalAs(UnmanagedType.Bool)]
            handle = CreateJobObject(IntPtr.Zero, null);\n            var info = new JOBOBJECT_BASIC_LIMIT_INFORMATION\n            {\n                LimitFlags = 0x2000\n            };\n            var extendedInfo = new JOBOBJECT_EXTENDED_LIMIT_INFORMATION\n            {\n                BasicLimitInformation = info\n            };
        private void loadCurrentConfiguration()\n        {\n            modifiedConfiguration = controller.GetConfiguration();
        private void loadCurrentConfiguration()\n        {\n            modifiedConfiguration = controller.GetConfiguration();\n            ServersListBox.Items.Clear();\n            foreach (Server server in modifiedConfiguration.configs)\n            {\n                ServersListBox.Items.Add(server.server);\n            }\n            ServersListBox.SelectedIndex = modifiedConfiguration.index;
            this.comboBox1.FormattingEnabled = true;\n            this.comboBox1.ImeMode = System.Windows.Forms.ImeMode.NoControl;\n            this.comboBox1.ItemHeight = 13;\n            this.comboBox1.Items.AddRange(new object[] {\n            "table",\n            "aes-256-cfb",\n            "aes-192-cfb",\n            "aes-128-cfb",\n            "bf-cfb",

        public OpensslEncryptor(string method, string password)\n            : base(method, password)\n        {\n            InitKey(method, password);\n        }\n        public override byte[] Encrypt(byte[] buf, int length)\n        {\n            if (_encryptCtx == IntPtr.Zero)\n            {
            : base(method, password)\n        {\n            InitKey(method, password);\n        }\n        public override byte[] Encrypt(byte[] buf, int length)\n        {\n            if (_encryptCtx == IntPtr.Zero)\n            {\n                int ivLen = _cipher.IVLength;\n                byte[] iv = new byte[ivLen];
            InitKey(method, password);\n        }\n        public override byte[] Encrypt(byte[] buf, int length)\n        {\n            if (_encryptCtx == IntPtr.Zero)\n            {\n                int ivLen = _cipher.IVLength;\n                byte[] iv = new byte[ivLen];\n                Native.RAND_bytes(iv, iv.Length);\n                InitCipher(ref _encryptCtx, iv, true);
        public override byte[] Encrypt(byte[] buf, int length)\n        {\n            if (_encryptCtx == IntPtr.Zero)\n            {\n                int ivLen = _cipher.IVLength;\n                byte[] iv = new byte[ivLen];\n                Native.RAND_bytes(iv, iv.Length);\n                InitCipher(ref _encryptCtx, iv, true);\n                int outLen = length + _cipher.BlockSize;\n                byte[] cipherText = new byte[outLen];
                int outLen = length + _cipher.BlockSize;\n                byte[] cipherText = new byte[outLen];\n                Native.EVP_CipherUpdate(_encryptCtx, cipherText, out outLen, buf, length);\n                byte[] result = new byte[outLen + ivLen];\n                Buffer.BlockCopy(iv, 0, result, 0, ivLen);\n                Buffer.BlockCopy(cipherText, 0, result, ivLen, outLen);\n                return result;\n            }\n            else\n            {
                Native.EVP_CipherUpdate(_encryptCtx, cipherText, out outLen, buf, length);\n                byte[] result = new byte[outLen + ivLen];\n                Buffer.BlockCopy(iv, 0, result, 0, ivLen);\n                Buffer.BlockCopy(cipherText, 0, result, ivLen, outLen);\n                return result;\n            }\n            else\n            {\n                int outLen = length + _cipher.BlockSize;\n                byte[] cipherText = new byte[outLen];
                Native.EVP_CipherUpdate(_encryptCtx, cipherText, out outLen, buf, length);\n                byte[] result = new byte[outLen];\n                Buffer.BlockCopy(cipherText, 0, result, 0, outLen);\n                return result;\n            }\n        }\n        public override byte[] Decrypt(byte[] buf, int length)\n        {\n            if (_decryptCtx == IntPtr.Zero)\n            {
            }\n        }\n        public override byte[] Decrypt(byte[] buf, int length)\n        {\n            if (_decryptCtx == IntPtr.Zero)\n            {\n                int ivLen = _cipher.IVLength;\n                byte[] iv = new byte[ivLen];\n                Buffer.BlockCopy(buf, 0, iv, 0, ivLen);\n                InitCipher(ref _decryptCtx, iv, false);
            {\n                int ivLen = _cipher.IVLength;\n                byte[] iv = new byte[ivLen];\n                Buffer.BlockCopy(buf, 0, iv, 0, ivLen);\n                InitCipher(ref _decryptCtx, iv, false);\n                int outLen = length + _cipher.BlockSize;\n                outLen -= ivLen;\n                byte[] cipherText = new byte[outLen];\n                byte[] subset = new byte[length - ivLen];\n                Buffer.BlockCopy(buf, ivLen, subset, 0, length - ivLen);
                byte[] cipherText = new byte[outLen];\n                byte[] subset = new byte[length - ivLen];\n                Buffer.BlockCopy(buf, ivLen, subset, 0, length - ivLen);\n                Native.EVP_CipherUpdate(_decryptCtx, cipherText, out outLen, subset, length - ivLen);\n                byte[] result = new byte[outLen];\n                Buffer.BlockCopy(cipherText, 0, result, 0, outLen);\n                return result;\n            }\n            else\n            {
                Buffer.BlockCopy(buf, ivLen, subset, 0, length - ivLen);\n                Native.EVP_CipherUpdate(_decryptCtx, cipherText, out outLen, subset, length - ivLen);\n                byte[] result = new byte[outLen];\n                Buffer.BlockCopy(cipherText, 0, result, 0, outLen);\n                return result;\n            }\n            else\n            {\n                int outLen = length + _cipher.BlockSize;\n                byte[] cipherText = new byte[outLen];
            {\n                int outLen = length + _cipher.BlockSize;\n                byte[] cipherText = new byte[outLen];\n                Native.EVP_CipherUpdate(_decryptCtx, cipherText, out outLen, buf, length);\n                byte[] result = new byte[outLen];\n                Buffer.BlockCopy(cipherText, 0, result, 0, outLen);\n                return result;\n            }\n        }\n        private static readonly Dictionary<string, byte[]> CachedKeys = new Dictionary<string, byte[]>();
                byte[] cipherText = new byte[outLen];\n                Native.EVP_CipherUpdate(_decryptCtx, cipherText, out outLen, buf, length);\n                byte[] result = new byte[outLen];\n                Buffer.BlockCopy(cipherText, 0, result, 0, outLen);\n                return result;\n            }\n        }\n        private static readonly Dictionary<string, byte[]> CachedKeys = new Dictionary<string, byte[]>();\n        private static readonly Dictionary<string, Cipher> CachedCiphers = new Dictionary<string, Cipher>();\n        private byte[] _key;
            if (CachedKeys.ContainsKey(k))\n            {\n                _key = CachedKeys[k];
            if (CachedKeys.ContainsKey(k))\n            {\n                _key = CachedKeys[k];\n                _cipher = CachedCiphers[k];\n                return;\n            }
            if (CachedKeys.ContainsKey(k))\n            {\n                _key = CachedKeys[k];\n                _cipher = CachedCiphers[k];\n                return;\n            }\n            _cipher = Cipher.CreateByName(method);\n            if (_cipher == null)\n            {
            if (CachedKeys.ContainsKey(k))\n            {\n                _key = CachedKeys[k];\n                _cipher = CachedCiphers[k];\n                return;\n            }\n            _cipher = Cipher.CreateByName(method);\n            if (_cipher == null)\n            {\n                throw new NullReferenceException();\n            }
            }\n            _cipher = Cipher.CreateByName(method);\n            if (_cipher == null)\n            {\n                throw new NullReferenceException();\n            }\n            byte[] passbuf = Encoding.UTF8.GetBytes(password);\n            _key = new byte[_cipher.KeyLength];\n            byte[] iv = new byte[_cipher.IVLength];\n            Native.EVP_BytesToKey(_cipher.Handle, MessageDigest.MD5.Handle, null, passbuf, passbuf.Length, 1, _key, iv);\n            CachedKeys[k] = _key;\n            CachedCiphers[k] = _cipher;\n        }\n        private void InitCipher(ref IntPtr ctx, byte[] iv, bool isCipher)\n        {
            {\n                throw new NullReferenceException();\n            }\n            _key = new byte[_cipher.KeyLength];\n            byte[] iv = new byte[_cipher.IVLength];\n            Native.EVP_BytesToKey(_cipher.Handle, MessageDigest.MD5.Handle, null, passbuf, passbuf.Length, 1, _key, iv);\n            CachedKeys[k] = _key;\n            CachedCiphers[k] = _cipher;\n        }\n        private void InitCipher(ref IntPtr ctx, byte[] iv, bool isCipher)\n        {\n            ctx = Native.OPENSSL_malloc(Marshal.SizeOf(typeof(CipherContext.EVP_CIPHER_CTX)));\n            int enc = isCipher ? 1 : 0;
            {\n                availabilityStatistics.UpdateOutboundCounter(server, n);\n            }\n        }\n        protected void Reload()\n        {\n            Encryption.RNG.Reload();\n            // some logic in configuration updated the config when saving, we need to read it again\n            _config = Configuration.Load();\n            StatisticsConfiguration = StatisticsStrategyConfiguration.Load();
            {\n                _pacServer = new PACServer(_pacDaemon);\n            }\n            if (gfwListUpdater == null)\n            {\n                gfwListUpdater = new GFWListUpdater();\n                gfwListUpdater.UpdateCompleted += PacServer_PACUpdateCompleted;\n                gfwListUpdater.Error += PacServer_PACUpdateError;\n            }\n            availabilityStatistics.UpdateConfiguration(this);
                gfwListUpdater.UpdateCompleted += PacServer_PACUpdateCompleted;\n                gfwListUpdater.Error += PacServer_PACUpdateError;\n            }\n            availabilityStatistics.UpdateConfiguration(this);\n            if (_listener != null)\n            {\n                _listener.Stop();\n            }\n            StopPlugins();\n            // don't put PrivoxyRunner.Start() before pacServer.Stop()\n            // or bind will fail when switching bind address from 0.0.0.0 to 127.0.0.1\n            // though UseShellExecute is set to true now\n            // http://stackoverflow.com/questions/10235093/socket-doesnt-close-after-application-exits-if-a-launched-process-is-open\n            privoxyRunner.Stop();\n            try\n            {\n                var strategy = GetCurrentStrategy();
﻿using System;\nusing System.Windows.Forms;\nusing Microsoft.Win32;
runKey.Close();\nforeach (string item in runList) {\nif (item.Equals("Shadowsocks"))\nreturn true;\n}\nreturn false;\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);
return true;\n}\nreturn false;\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\nreturn false;\n}
                this.AutoStartupItem = CreateMenuItem("Start on Boot", new EventHandler(this.AutoStartupItem_Click)),\n                this.ShareOverLANItem = CreateMenuItem("Allow Clients from LAN", new EventHandler(this.ShareOverLANItem_Click)),
        }\n        public void Stop()\n        {\n            if (_process != null)\n            {\n                try\n                {\n                    _process.Kill();\n                    _process.WaitForExit();\n                }
        {\n            Server o2 = (Server)obj;\n            return server == o2.server && server_port == o2.server_port;\n        }\n        public string FriendlyName()\n        {\n            if (server.IsNullOrEmpty())\n            {\n                return I18N.GetString("New server");\n            }
﻿using System;\nusing System.Windows.Forms;\nusing Shadowsocks.Model;\nusing Shadowsocks.Util.SystemProxy;\nnamespace Shadowsocks.Controller\n{\n    public static class SystemProxy\n    {
using Shadowsocks.Util.SystemProxy;\nnamespace Shadowsocks.Controller\n{\n    public static class SystemProxy\n    {\n        private static bool failed = false;\n        private static string GetTimestamp(DateTime value)\n        {\n            return value.ToString("yyyyMMddHHmmssfff");\n        }
{\n    public static class SystemProxy\n    {\n        private static bool failed = false;\n        private static string GetTimestamp(DateTime value)\n        {\n            return value.ToString("yyyyMMddHHmmssfff");\n        }\n        public static void Update(Configuration config, bool forceDisable, PACServer pacSrv)\n        {
                    }\n                }\n                else\n                {\n                    Sysproxy.SetIEProxy(false, false, null, null);\n                }\n            }\n            catch (ProxyException ex)\n            {\n                Logging.LogUsefulException(ex);
                else\n                {\n                    Sysproxy.SetIEProxy(false, false, null, null);\n                }\n            }\n            catch (ProxyException ex)\n            {\n                Logging.LogUsefulException(ex);\n                switch (ex.Type)\n                {
using System.Text;\nnamespace shadowsocks_csharp\n{\n    class SystemProxy\n    {\n        [DllImport("wininet.dll")]\n        public static extern bool InternetSetOption(IntPtr hInternet, int dwOption, IntPtr lpBuffer, int dwBufferLength);\n        public const int INTERNET_OPTION_SETTINGS_CHANGED = 39;\n        public const int INTERNET_OPTION_REFRESH = 37;\n        static bool settingsReturn, refreshReturn;
{\n    class SystemProxy\n    {\n        [DllImport("wininet.dll")]\n        public static extern bool InternetSetOption(IntPtr hInternet, int dwOption, IntPtr lpBuffer, int dwBufferLength);\n        public const int INTERNET_OPTION_SETTINGS_CHANGED = 39;\n        public const int INTERNET_OPTION_REFRESH = 37;\n        static bool settingsReturn, refreshReturn;\n        public void Enable()\n        {
        public static extern bool InternetSetOption(IntPtr hInternet, int dwOption, IntPtr lpBuffer, int dwBufferLength);\n        public const int INTERNET_OPTION_SETTINGS_CHANGED = 39;\n        public const int INTERNET_OPTION_REFRESH = 37;\n        static bool settingsReturn, refreshReturn;\n        public void Enable()\n        {\n            RegistryKey registry = Registry.CurrentUser.OpenSubKey("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings", true);\n            registry.SetValue("ProxyEnable", 1);\n            registry.SetValue("ProxyServer", "127.0.0.1:8123");\n            // These lines implement the Interface in the beginning of program \n            // They cause the OS to refresh the settings, causing IP to realy update\n            settingsReturn = InternetSetOption(IntPtr.Zero, INTERNET_OPTION_SETTINGS_CHANGED, IntPtr.Zero, 0);\n            refreshReturn = InternetSetOption(IntPtr.Zero, INTERNET_OPTION_REFRESH, IntPtr.Zero, 0);\n        }
            registry.SetValue("ProxyServer", "127.0.0.1:8123");\n            // They cause the OS to refresh the settings, causing IP to realy update\n            settingsReturn = InternetSetOption(IntPtr.Zero, INTERNET_OPTION_SETTINGS_CHANGED, IntPtr.Zero, 0);\n            refreshReturn = InternetSetOption(IntPtr.Zero, INTERNET_OPTION_REFRESH, IntPtr.Zero, 0);\n        }\n        public void Disable()\n        {\n            RegistryKey registry = Registry.CurrentUser.OpenSubKey("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings", true);\n            registry.SetValue("ProxyEnable", 0);\n            registry.SetValue("ProxyServer", "");
using System.Net.NetworkInformation;\nusing System.Net.Sockets;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Shadowsocks.Model;\nusing Shadowsocks.Util;\nnamespace Shadowsocks.Controller\n{\n    using DataUnit = KeyValuePair<string, string>;\n    using DataList = List<KeyValuePair<string, string>>;
    using DataUnit = KeyValuePair<string, string>;\n    using DataList = List<KeyValuePair<string, string>>;\n    using RawStatistics = Dictionary<string, List<AvailabilityStatistics.RawStatisticsData>>;\n    using Statistics = Dictionary<string, List<AvailabilityStatistics.StatisticsData>>;\n    public class AvailabilityStatistics\n    {\n        public static readonly string DateTimePattern = "yyyy-MM-dd HH:mm:ss";\n        private const string StatisticsFilesName = "shadowsocks.availability.csv";\n        private const string Delimiter = ",";\n        private const int Timeout = 500;\n        private const int DelayBeforeStart = 1000;
        private const int RetryInterval = 2*60*1000; //retry 2 minutes after failed
        private const int RetryInterval = 2*60*1000; //retry 2 minutes after failed\n                    var reply = ping.Send(IP, Timeout);\n                    ret.Add(new List<KeyValuePair<string, string>>\n                    {\n                        new KeyValuePair<string, string>("Timestamp", timestamp),\n                        new KeyValuePair<string, string>("Server", server.FriendlyName()),\n                        new KeyValuePair<string, string>("Status", reply?.Status.ToString()),\n                        new KeyValuePair<string, string>("RoundtripTime", reply?.RoundtripTime.ToString())\n                        //new KeyValuePair<string, string>("data", reply.Buffer.ToString()); // The data of reply\n                    });
                    int bytesToSend;\n                    lock (encryptionLock)\n                    {\n                        if (closed)\n                        {\n                            return;\n                        }\n                        encryptor.Encrypt(connetionRecvBuffer, bytesRead, connetionSendBuffer, out bytesToSend);\n                    }
        /// the contents of this method with the code editor.\n        /// </summary>\n        private void InitializeComponent()\n        {\n            this.components = new System.ComponentModel.Container();\n            System.Windows.Forms.DataVisualization.Charting.ChartArea chartArea1 = new System.Windows.Forms.DataVisualization.Charting.ChartArea();\n            System.Windows.Forms.DataVisualization.Charting.Legend legend1 = new System.Windows.Forms.DataVisualization.Charting.Legend();\n            System.Windows.Forms.DataVisualization.Charting.Series series1 = new System.Windows.Forms.DataVisualization.Charting.Series();\n            System.Windows.Forms.DataVisualization.Charting.Series series2 = new System.Windows.Forms.DataVisualization.Charting.Series();\n            this.StatisticsChart = new System.Windows.Forms.DataVisualization.Charting.Chart();
        {\n            this.components = new System.ComponentModel.Container();\n            System.Windows.Forms.DataVisualization.Charting.ChartArea chartArea1 = new System.Windows.Forms.DataVisualization.Charting.ChartArea();\n            System.Windows.Forms.DataVisualization.Charting.Legend legend1 = new System.Windows.Forms.DataVisualization.Charting.Legend();\n            System.Windows.Forms.DataVisualization.Charting.Series series1 = new System.Windows.Forms.DataVisualization.Charting.Series();\n            System.Windows.Forms.DataVisualization.Charting.Series series2 = new System.Windows.Forms.DataVisualization.Charting.Series();\n            this.StatisticsChart = new System.Windows.Forms.DataVisualization.Charting.Chart();\n            this.byISPCheckBox = new System.Windows.Forms.CheckBox();\n            this.label2 = new System.Windows.Forms.Label();\n            this.label3 = new System.Windows.Forms.Label();
            this.splitContainer2.Panel1.Controls.Add(this.label3);\n            // \n            // splitContainer2.Panel2\n            // \n            this.splitContainer2.Panel2.Controls.Add(this.splitContainer3);
            this.splitContainer2.Panel1.Controls.Add(this.label3);\n            // \n            // splitContainer2.Panel2\n            // \n            this.splitContainer2.Panel2.Controls.Add(this.splitContainer3);\n        private System.Windows.Forms.CheckBox byISPCheckBox;\n        private System.Windows.Forms.Label label2;\n        private System.Windows.Forms.Label label3;
using Shadowsocks.Model;\nusing Shadowsocks.Util;\nnamespace Shadowsocks.Controller\n{\n    using Statistics = Dictionary<string, List<StatisticsRecord>>;\n    public sealed class AvailabilityStatistics : IDisposable\n    {\n        public const string DateTimePattern = "yyyy-MM-dd HH:mm:ss";\n        private const string StatisticsFilesName = "shadowsocks.availability.json";
namespace Shadowsocks.Controller\n{\n    using Statistics = Dictionary<string, List<StatisticsRecord>>;\n    public sealed class AvailabilityStatistics : IDisposable\n    {\n        public const string DateTimePattern = "yyyy-MM-dd HH:mm:ss";\n        private const string StatisticsFilesName = "shadowsocks.availability.json";\n        private const int TimeoutMilliseconds = 500;\n        public static readonly DateTime UnknownDateTime = new DateTime(1970, 1, 1);\n        public static string AvailabilityStatisticsFile;
        public const string DateTimePattern = "yyyy-MM-dd HH:mm:ss";\n        private const string StatisticsFilesName = "shadowsocks.availability.json";\n        private const int TimeoutMilliseconds = 500;\n        public static readonly DateTime UnknownDateTime = new DateTime(1970, 1, 1);\n        public static string AvailabilityStatisticsFile;\n        private long _lastOutboundCounter;\n        private List<int> _latencyRecords;\n        private List<int> _outboundSpeedRecords;\n        private Timer _recorder;\n        private List<Server> _servers;\n        private Timer _speedMonior;\n        private Timer _writer;\n        //static constructor to initialize every public static fields before refereced\n        static AvailabilityStatistics()\n        {\n            AvailabilityStatisticsFile = Utils.GetTempPath(StatisticsFilesName);
        }\n        private AvailabilityStatistics()\n        {\n            RawStatistics = new Statistics();\n        }\n        // Static Singleton Initialization\n        public static AvailabilityStatistics Instance { get; } = new AvailabilityStatistics();\n        public Statistics RawStatistics { get; private set; }\n        public Statistics FilteredStatistics { get; private set; }
            _config = config;\n            try\n            {\n                if (config.StatisticsEnabled)\n                {\n                    if (_recorder?.Change(_delayBeforeStart, RecordingInterval) == null)\n                    {\n                        _recorder = new Timer(Run, null, _delayBeforeStart, RecordingInterval);\n                    }\n                    LoadRawStatistics();
                        _recorder = new Timer(Run, null, _delayBeforeStart, RecordingInterval);\n                    }\n                    LoadRawStatistics();\n                    }\n                    if (_writer?.Change(_delayBeforeStart, RecordingInterval) == null)\n                    {\n                        _writer = new Timer(Save, null, _delayBeforeStart, RecordingInterval);\n                    }\n                }\n                else\n                {\n                    _recorder?.Dispose();\n                    _speedMonior?.Dispose();
                else\n                {\n                    _recorder?.Dispose();\n                    _speedMonior?.Dispose();\n                }\n                return true;\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);
        {\n            var bytes = _controller.inboundCounter - _lastInboundCounter;\n            _lastInboundCounter = _controller.inboundCounter;\n            var inboundSpeed = GetSpeedInKiBPerSecond(bytes, _monitorInterval.TotalSeconds);\n            _inboundSpeedRecords.Add(inboundSpeed);\n            bytes = _controller.outboundCounter - _lastOutboundCounter;\n            _lastOutboundCounter = _controller.outboundCounter;\n            var outboundSpeed = GetSpeedInKiBPerSecond(bytes, _monitorInterval.TotalSeconds);\n            _outboundSpeedRecords.Add(outboundSpeed);\n            Logging.Debug(
            _inboundSpeedRecords.Add(inboundSpeed);\n            bytes = _controller.outboundCounter - _lastOutboundCounter;\n            _lastOutboundCounter = _controller.outboundCounter;\n            var outboundSpeed = GetSpeedInKiBPerSecond(bytes, _monitorInterval.TotalSeconds);\n            _outboundSpeedRecords.Add(outboundSpeed);\n            Logging.Debug(\n            AppendRecord();\n            Reset();\n            FilterRawStatistics();\n        }
            FilterRawStatistics();\n        }\n        private async void AppendRecord()\n        {\n            //todo: option for icmp test\n            var icmpResults = TaskEx.WhenAll(_servers.Select(ICMPTest));\n            var currentServerRecord = new StatisticsRecord(_currentServer.Identifier(),\n                _inboundSpeedRecords, _outboundSpeedRecords, _latencyRecords);\n            foreach (var result in (await icmpResults).Where(result => result != null))\n            {
            //todo: option for icmp test\n            var icmpResults = TaskEx.WhenAll(_servers.Select(ICMPTest));\n            var currentServerRecord = new StatisticsRecord(_currentServer.Identifier(),\n                _inboundSpeedRecords, _outboundSpeedRecords, _latencyRecords);\n            foreach (var result in (await icmpResults).Where(result => result != null))\n            {\n                List<StatisticsRecord> records;\n                if (!RawStatistics.TryGetValue(result.Server.Identifier(), out records))\n                {\n                    records = new List<StatisticsRecord>();\n                }\n                if (result.Server.Equals(_currentServer))\n                {\n                    currentServerRecord.setResponse(result.RoundtripTime);
            foreach (var result in (await icmpResults).Where(result => result != null))\n            {\n                {\n                    records = new List<StatisticsRecord>();\n                }\n                if (result.Server.Equals(_currentServer))\n                {\n                    currentServerRecord.setResponse(result.RoundtripTime);\n                    records.Add(currentServerRecord);\n                }\n                else\n                {
            {\n                File.WriteAllText(AvailabilityStatisticsFile,\n                    JsonConvert.SerializeObject(RawStatistics, Formatting.None));\n            }\n            catch (IOException e)\n            {\n                Logging.LogUsefulException(e);\n                _writer.Change(_retryInterval, _writingInterval);\n            }\n        }
            }\n            catch (IOException e)\n            {\n                Logging.LogUsefulException(e);\n                _writer.Change(_retryInterval, _writingInterval);\n            }\n        }\n        internal void UpdateConfiguration(ShadowsocksController controller)\n        {\n            _controller = controller;\n            _currentServer = _controller.GetCurrentServer();\n            Reset();\n            Set(controller.StatisticsConfiguration);\n            _servers = _controller.GetCurrentConfiguration().configs;\n        }\n        private bool IsValidRecord(StatisticsRecord record)\n        {
        {\n            if (_controller.GetCurrentStrategy()?.ID == ID) //output when enabled\n            {\n                Console.WriteLine(log);\n            }\n        }\n        public string ID => "com.shadowsocks.strategy.scbs";\n        public string Name => I18N.GetString("Choose By Total Package Loss");\n        public Server GetAServer(IStrategyCallerType type, IPEndPoint localIPEndPoint)\n        {
                Console.WriteLine(log);\n            }\n        }\n        public string ID => "com.shadowsocks.strategy.scbs";\n        public string Name => I18N.GetString("Choose By Total Package Loss");\n        public Server GetAServer(IStrategyCallerType type, IPEndPoint localIPEndPoint)\n        {\n            var oldServer = _currentServer;\n            if (oldServer == null)\n            {\n                ChooseNewServer(_controller.GetCurrentConfiguration().configs);
            System.Diagnostics.Process.Start("explorer.exe", argument);\n        }\n        private void ExitMenuItem_Click(object sender, EventArgs e)\n        {\n            this.Close();\n        }\n        private void LogForm_Shown(object sender, EventArgs e)\n        {\n            LogMessageTextBox.ScrollToCaret();\n        }
        {\n            LogMessageTextBox.ScrollToCaret();\n        }\n        private void WrapTextCheckBox_CheckedChanged(object sender, EventArgs e)\n        {\n            LogMessageTextBox.WordWrap = WrapTextCheckBox.Checked;\n            LogMessageTextBox.ScrollToCaret();\n        }\n        private void CleanLogsButton_Click(object sender, EventArgs e)\n        {
        private void TopMostCheckBox_CheckedChanged(object sender, EventArgs e)\n        {
        }\n        #region Windows Form Designer generated code\n        /// <summary>\n        /// Required method for Designer support - do not modify\n        /// the contents of this method with the code editor.\n        /// </summary>\n        private void InitializeComponent()\n        {\n            this.components = new System.ComponentModel.Container();\n            this.LogMessageTextBox = new System.Windows.Forms.TextBox();
        /// </summary>\n        private void InitializeComponent()\n        {\n            this.components = new System.ComponentModel.Container();\n            this.LogMessageTextBox = new System.Windows.Forms.TextBox();\n            this.contextMenuStrip1 = new System.Windows.Forms.ContextMenuStrip(this.components);\n            this.mainMenu1 = new System.Windows.Forms.MainMenu(this.components);\n            this.FileMenuItem = new System.Windows.Forms.MenuItem();\n            this.OpenLocationMenuItem = new System.Windows.Forms.MenuItem();\n            this.ExitMenuItem = new System.Windows.Forms.MenuItem();
            this.mainMenu1 = new System.Windows.Forms.MainMenu(this.components);\n            this.FileMenuItem = new System.Windows.Forms.MenuItem();\n            this.OpenLocationMenuItem = new System.Windows.Forms.MenuItem();\n            this.ExitMenuItem = new System.Windows.Forms.MenuItem();\n            this.panel1 = new System.Windows.Forms.Panel();\n            this.ChangeFontButton = new System.Windows.Forms.Button();\n            this.CleanLogsButton = new System.Windows.Forms.Button();\n            this.WrapTextCheckBox = new System.Windows.Forms.CheckBox();\n            this.tableLayoutPanel1 = new System.Windows.Forms.TableLayoutPanel();
            this.OpenLocationMenuItem.Index = 0;\n            this.OpenLocationMenuItem.Text = "&Open Location";\n            this.OpenLocationMenuItem.Click += new System.EventHandler(this.OpenLocationMenuItem_Click);\n            // \n            // ExitMenuItem\n            // \n            this.ExitMenuItem.Index = 1;\n            this.ExitMenuItem.Text = "E&xit";\n            this.ExitMenuItem.Click += new System.EventHandler(this.ExitMenuItem_Click);\n            // 
            // \n            this.panel1.Controls.Add(this.TopMostCheckBox);\n            this.panel1.Controls.Add(this.ChangeFontButton);\n            this.panel1.Controls.Add(this.CleanLogsButton);\n            this.panel1.Controls.Add(this.WrapTextCheckBox);\n            this.panel1.Dock = System.Windows.Forms.DockStyle.Fill;\n            this.panel1.Location = new System.Drawing.Point(3, 3);\n            this.panel1.Name = "panel1";\n            this.panel1.Size = new System.Drawing.Size(541, 34);\n            this.panel1.TabIndex = 1;\n            // \n            // ChangeFontButton\n            // 
            this.panel1.Size = new System.Drawing.Size(541, 34);\n            this.panel1.TabIndex = 1;\n            // ChangeFontButton\n            // \n            this.ChangeFontButton.Location = new System.Drawing.Point(107, 4);\n            this.ChangeFontButton.Name = "ChangeFontButton";\n            this.ChangeFontButton.Size = new System.Drawing.Size(75, 23);\n            this.ChangeFontButton.TabIndex = 2;\n            this.ChangeFontButton.Text = "&Font";\n            this.ChangeFontButton.UseVisualStyleBackColor = true;\n            this.ChangeFontButton.Click += new System.EventHandler(this.ChangeFontButton_Click);\n            // \n            // CleanLogsButton\n            // 
            this.WrapTextCheckBox.AutoSize = true;
            this.WrapTextCheckBox.AutoSize = true;\n            this.tableLayoutPanel1.Controls.Add(this.panel1, 0, 0);\n            this.tableLayoutPanel1.Controls.Add(this.LogMessageTextBox, 0, 1);\n            this.tableLayoutPanel1.Dock = System.Windows.Forms.DockStyle.Fill;\n            this.tableLayoutPanel1.Location = new System.Drawing.Point(0, 0);\n            this.tableLayoutPanel1.Name = "tableLayoutPanel1";\n            this.tableLayoutPanel1.RowCount = 2;
            this.tableLayoutPanel1.Controls.Add(this.LogMessageTextBox, 0, 1);\n            this.tableLayoutPanel1.Dock = System.Windows.Forms.DockStyle.Fill;\n            this.tableLayoutPanel1.Location = new System.Drawing.Point(0, 0);\n            this.tableLayoutPanel1.Name = "tableLayoutPanel1";\n            this.tableLayoutPanel1.RowCount = 2;\n            this.tableLayoutPanel1.Size = new System.Drawing.Size(547, 353);\n            this.tableLayoutPanel1.TabIndex = 2;\n            // 

            this.panel1.ResumeLayout(false);\n            this.panel1.PerformLayout();\n            this.tableLayoutPanel1.ResumeLayout(false);\n            this.tableLayoutPanel1.PerformLayout();\n            this.ResumeLayout(false);\n        }\n        #endregion\n        private System.Windows.Forms.TextBox LogMessageTextBox;
            this.ResumeLayout(false);\n        }\n        #endregion\n        private System.Windows.Forms.TextBox LogMessageTextBox;\n        private System.Windows.Forms.ContextMenuStrip contextMenuStrip1;\n        private System.Windows.Forms.MainMenu mainMenu1;\n        private System.Windows.Forms.MenuItem FileMenuItem;\n        private System.Windows.Forms.MenuItem OpenLocationMenuItem;\n        private System.Windows.Forms.MenuItem ExitMenuItem;
﻿using System;\nusing System.Net;\nusing System.Net.Sockets;\nusing Shadowsocks.Util.Sockets;\nnamespace Shadowsocks.Controller\n{\n    class PortForwarder : Listener.Service\n    {
using System.Net;\nusing System.Net.Sockets;\nusing Shadowsocks.Util.Sockets;\nnamespace Shadowsocks.Controller\n{\n    class PortForwarder : Listener.Service\n    {\n        int _targetPort;\n        public PortForwarder(int targetPort)\n        {
        public PortForwarder(int targetPort)\n        {\n            this._targetPort = targetPort;\n        }\n        public override bool Handle(byte[] firstPacket, int length, Socket socket, object state)\n        {\n            if (socket.ProtocolType != ProtocolType.Tcp)\n            {\n                return false;\n            }
        }\n        public override bool Handle(byte[] firstPacket, int length, Socket socket, object state)\n        {\n            if (socket.ProtocolType != ProtocolType.Tcp)\n            {\n                return false;\n            }\n            new Handler().Start(firstPacket, length, socket, this._targetPort);\n            return true;\n        }
        }\n        class Handler\n        {\n            private byte[] _firstPacket;\n            private int _firstPacketLength;\n            private Socket _local;\n            private WrappedSocket _remote;\n            private bool _closed = false;\n            private bool _localShutdown = false;\n            private bool _remoteShutdown = false;
            private WrappedSocket _remote;\n            private bool _closed = false;\n            private bool _localShutdown = false;\n            private bool _remoteShutdown = false;\n            public const int RecvSize = 16384;\n            // remote receive buffer\n            private byte[] remoteRecvBuffer = new byte[RecvSize];\n            // connection receive buffer\n            private byte[] connetionRecvBuffer = new byte[RecvSize];\n            // instance-based lock\n            private readonly object _Lock = new object();\n            public void Start(byte[] firstPacket, int length, Socket socket, int targetPort)\n            {
                this._local = socket;\n                try\n                {\n                    EndPoint remoteEP = SocketUtil.GetEndPoint("127.0.0.1", targetPort);\n                    // Connect to the remote endpoint.\n                    _remote = new WrappedSocket();\n                    _remote.BeginConnect(remoteEP, ConnectCallback, null);\n                }\n                catch (Exception e)\n                {\n                    Logging.LogUsefulException(e);
            private void StartPipe(IAsyncResult ar)\n            {\n                if (_closed)\n                {\n                    return;\n                }\n                try\n                {\n                    _remote.EndSend(ar);\n                    _remote.BeginReceive(remoteRecvBuffer, 0, RecvSize, 0,
                if (_closed)\n                {\n                    return;\n                }\n                try\n                {\n                    _remote.EndSend(ar);\n                    _remote.BeginReceive(remoteRecvBuffer, 0, RecvSize, 0,\n                        new AsyncCallback(PipeRemoteReceiveCallback), null);\n                    _local.BeginReceive(connetionRecvBuffer, 0, RecvSize, 0,
            }\n            private void PipeConnectionSendCallback(IAsyncResult ar)\n            {\n                if (_closed)\n                {\n                    return;\n                }\n                try\n                {\n                    _local.EndSend(ar);
                catch (Exception e)\n                {\n                    Logging.LogUsefulException(e);\n                    this.Close();\n                }\n            }\n            private void CheckClose()\n            {\n                if (_localShutdown && _remoteShutdown)\n                {
            string k = method + ":" + password;\n            ciphers = getCiphers();\n            _cipherInfo = ciphers[_method];\n            _cipher = _cipherInfo[2];\n            if (_cipher == 0)\n            {\n                throw new Exception("method not found");\n            }\n            keyLen = ciphers[_method][0];\n            ivLen = ciphers[_method][1];
            if (_cipher == 0)\n            {\n                throw new Exception("method not found");\n            }\n            keyLen = ciphers[_method][0];\n            ivLen = ciphers[_method][1];\n            if (CachedKeys.ContainsKey(k))\n            {\n                _key = CachedKeys[k];
﻿using System;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Threading;\nusing Shadowsocks.Util.Sockets;
﻿using System;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Threading;\nusing Shadowsocks.Util.Sockets;\nnamespace Shadowsocks.Proxy\n{
﻿using System;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Threading;\nusing Shadowsocks.Controller;\nusing Shadowsocks.Util.Sockets;
﻿using System;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Threading;\nusing Shadowsocks.Controller;\nusing Shadowsocks.Util.Sockets;\nnamespace Shadowsocks.Proxy\n{
﻿using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Timers;\nusing Shadowsocks.Controller.Strategy;\nusing Shadowsocks.Encryption;\nusing Shadowsocks.Model;
﻿using System;\nusing System.Net;\nusing System.Net.Sockets;
﻿using System;\nusing System.Net;\nusing System.Net.Sockets;\nnamespace Shadowsocks.Proxy\n{
﻿using System;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Text;\nusing System.Threading;\nusing Shadowsocks.Controller;\nusing Shadowsocks.Util.Sockets;
﻿using System;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Text;\nusing System.Threading;\nusing Shadowsocks.Controller;\nusing Shadowsocks.Util.Sockets;\nnamespace Shadowsocks.Proxy\n{
            }\n            base.Dispose(disposing);\n        }\n        #region Windows Form Designer generated code\n        /// <summary>\n        /// Required method for Designer support - do not modify\n        /// the contents of this method with the code editor.\n        /// </summary>\n        private void InitializeComponent()\n        {
        /// </summary>\n        private void InitializeComponent()\n        {\n            System.Windows.Forms.DataVisualization.Charting.ChartArea chartArea1 = new System.Windows.Forms.DataVisualization.Charting.ChartArea();\n            System.Windows.Forms.DataVisualization.Charting.Legend legend1 = new System.Windows.Forms.DataVisualization.Charting.Legend();\n            System.Windows.Forms.DataVisualization.Charting.Series series1 = new System.Windows.Forms.DataVisualization.Charting.Series();\n            System.Windows.Forms.DataVisualization.Charting.Series series2 = new System.Windows.Forms.DataVisualization.Charting.Series();\n            System.Windows.Forms.DataVisualization.Charting.Series series3 = new System.Windows.Forms.DataVisualization.Charting.Series();\n            this.StatisticsChart = new System.Windows.Forms.DataVisualization.Charting.Chart();
            this.checkBox1 = new System.Windows.Forms.CheckBox();\n            this.label2 = new System.Windows.Forms.Label();\n            this.label3 = new System.Windows.Forms.Label();\n            this.label4 = new System.Windows.Forms.Label();\n            this.groupBox1 = new System.Windows.Forms.GroupBox();\n            this.radioButton2 = new System.Windows.Forms.RadioButton();\n            this.radioButton1 = new System.Windows.Forms.RadioButton();\n            this.splitContainer1 = new System.Windows.Forms.SplitContainer();\n            this.splitContainer2 = new System.Windows.Forms.SplitContainer();
            this.groupBox1 = new System.Windows.Forms.GroupBox();\n            this.radioButton2 = new System.Windows.Forms.RadioButton();\n            this.radioButton1 = new System.Windows.Forms.RadioButton();\n            this.splitContainer1 = new System.Windows.Forms.SplitContainer();\n            this.splitContainer2 = new System.Windows.Forms.SplitContainer();\n            this.numericUpDown2 = new System.Windows.Forms.NumericUpDown();\n            this.checkBox2 = new System.Windows.Forms.CheckBox();\n            this.numericUpDown1 = new System.Windows.Forms.NumericUpDown();\n            this.label6 = new System.Windows.Forms.Label();\n            this.splitContainer3 = new System.Windows.Forms.SplitContainer();\n            this.label1 = new System.Windows.Forms.Label();
            this.groupBox1.SuspendLayout();\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer1)).BeginInit();\n            this.splitContainer1.Panel1.SuspendLayout();\n            this.splitContainer1.Panel2.SuspendLayout();\n            this.splitContainer1.SuspendLayout();\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer2)).BeginInit();\n            this.splitContainer2.Panel1.SuspendLayout();\n            this.splitContainer2.Panel2.SuspendLayout();\n            this.splitContainer2.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.splitContainer2)).BeginInit();\n            this.splitContainer2.Panel1.SuspendLayout();\n            this.splitContainer2.Panel2.SuspendLayout();\n            this.splitContainer2.SuspendLayout();\n            ((System.ComponentModel.ISupportInitialize)(this.numericUpDown2)).BeginInit();\n            ((System.ComponentModel.ISupportInitialize)(this.numericUpDown1)).BeginInit();\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer3)).BeginInit();\n            this.splitContainer3.Panel1.SuspendLayout();\n            this.splitContainer3.Panel2.SuspendLayout();\n            this.splitContainer3.SuspendLayout();
            // \n            // label4\n            // \n            this.label4.AutoSize = true;
            this.splitContainer1.Panel2.Controls.Add(this.groupBox1);\n            this.splitContainer1.Panel2.Controls.Add(this.StatisticsChart);
            this.splitContainer1.Panel2.Controls.Add(this.groupBox1);\n            this.splitContainer1.Panel2.Controls.Add(this.StatisticsChart);\n            this.splitContainer2.Panel1.Controls.Add(this.numericUpDown2);\n            this.splitContainer2.Panel1.Controls.Add(this.checkBox2);\n            this.splitContainer2.Panel1.Controls.Add(this.numericUpDown1);\n            this.splitContainer2.Panel1.Controls.Add(this.label6);\n            this.splitContainer2.Panel1.Controls.Add(this.label2);\n            this.splitContainer2.Panel1.Controls.Add(this.label4);
            this.splitContainer2.Panel1.Controls.Add(this.label6);\n            this.splitContainer2.Panel1.Controls.Add(this.label2);\n            this.splitContainer2.Panel1.Controls.Add(this.label4);\n            this.splitContainer2.Panel1.Controls.Add(this.checkBox1);\n            this.splitContainer2.Panel1.Controls.Add(this.label3);\n            // \n            // splitContainer2.Panel2\n            // \n            this.splitContainer2.Panel2.Controls.Add(this.splitContainer3);
            // \n            // numericUpDown1\n            // \n            this.numericUpDown1.Location = new System.Drawing.Point(76, 189);\n            this.numericUpDown1.Margin = new System.Windows.Forms.Padding(3, 4, 3, 4);\n            this.numericUpDown1.Maximum = new decimal(new int[] {\n            10,\n            0,\n            0,\n            0});

            this.groupBox1.PerformLayout();\n            this.splitContainer1.Panel1.ResumeLayout(false);\n            this.splitContainer1.Panel2.ResumeLayout(false);\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer1)).EndInit();\n            this.splitContainer1.ResumeLayout(false);\n            this.splitContainer2.Panel1.ResumeLayout(false);\n            this.splitContainer2.Panel1.PerformLayout();\n            this.splitContainer2.Panel2.ResumeLayout(false);\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer2)).EndInit();\n            this.splitContainer2.ResumeLayout(false);
            this.splitContainer2.Panel2.ResumeLayout(false);\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer2)).EndInit();\n            this.splitContainer2.ResumeLayout(false);\n            ((System.ComponentModel.ISupportInitialize)(this.numericUpDown2)).EndInit();\n            ((System.ComponentModel.ISupportInitialize)(this.numericUpDown1)).EndInit();\n            this.splitContainer3.Panel1.ResumeLayout(false);\n            this.splitContainer3.Panel1.PerformLayout();\n            this.splitContainer3.Panel2.ResumeLayout(false);\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer3)).EndInit();\n            this.splitContainer3.ResumeLayout(false);
            ((System.ComponentModel.ISupportInitialize)(this.numericUpDown1)).EndInit();\n            this.splitContainer3.Panel1.ResumeLayout(false);\n            this.splitContainer3.Panel1.PerformLayout();\n            this.splitContainer3.Panel2.ResumeLayout(false);\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer3)).EndInit();\n            this.splitContainer3.ResumeLayout(false);\n            this.flowLayoutPanel1.ResumeLayout(false);\n            this.flowLayoutPanel1.PerformLayout();\n            this.panel3.ResumeLayout(false);\n            this.panel3.PerformLayout();\n            this.ResumeLayout(false);\n        }\n        #endregion\n        private System.Windows.Forms.DataVisualization.Charting.Chart StatisticsChart;
        private System.Windows.Forms.CheckBox checkBox1;\n        private System.Windows.Forms.Label label2;\n        private System.Windows.Forms.Label label3;\n        private System.Windows.Forms.Label label4;\n        private System.Windows.Forms.GroupBox groupBox1;\n        private System.Windows.Forms.RadioButton radioButton2;\n        private System.Windows.Forms.RadioButton radioButton1;\n        private System.Windows.Forms.SplitContainer splitContainer1;\n        private System.Windows.Forms.Label label1;\n        private System.Windows.Forms.SplitContainer splitContainer2;
        private System.Windows.Forms.Label label3;\n        private System.Windows.Forms.Label label4;\n        private System.Windows.Forms.GroupBox groupBox1;\n        private System.Windows.Forms.RadioButton radioButton2;\n        private System.Windows.Forms.RadioButton radioButton1;\n        private System.Windows.Forms.SplitContainer splitContainer1;\n        private System.Windows.Forms.Label label1;\n        private System.Windows.Forms.SplitContainer splitContainer2;\n        private System.Windows.Forms.FlowLayoutPanel flowLayoutPanel1;\n        private System.Windows.Forms.SplitContainer splitContainer3;
        private System.Windows.Forms.GroupBox groupBox1;\n        private System.Windows.Forms.RadioButton radioButton2;\n        private System.Windows.Forms.RadioButton radioButton1;\n        private System.Windows.Forms.SplitContainer splitContainer1;\n        private System.Windows.Forms.Label label1;\n        private System.Windows.Forms.SplitContainer splitContainer2;\n        private System.Windows.Forms.FlowLayoutPanel flowLayoutPanel1;\n        private System.Windows.Forms.SplitContainer splitContainer3;\n        private System.Windows.Forms.Panel panel3;\n        private System.Windows.Forms.Label label5;\n        private System.Windows.Forms.Label label7;\n        private System.Windows.Forms.TextBox textBox5;\n        private System.Windows.Forms.ComboBox comboBox3;\n        private System.Windows.Forms.NumericUpDown numericUpDown1;\n        private System.Windows.Forms.Label label6;
﻿using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Net;\nusing System.Net.NetworkInformation;\nusing System.Threading;\nusing Shadowsocks.Model;\nnamespace Shadowsocks.Controller.Strategy\n{
namespace Shadowsocks.Controller.Strategy\n{\n    class SimplyChooseByStatisticsStrategy : IStrategy\n    {\n        private readonly ShadowsocksController _controller;\n        private Server _currentServer;\n        private readonly Timer _timer;\n        private Dictionary<string, StatisticsData> _statistics;\n        private const int CachedInterval = 30*60*1000; //choose a new server every 30 minutes\n        private const int RetryInterval = 2*60*1000; //choose a new server every 30 minutes
            string argument = Logging.LogFile;\n            new LogForm(argument).Show();\n        }\n        private void QRCodeItem_Click(object sender, EventArgs e)\n        {\n            QRCodeForm qrCodeForm = new QRCodeForm(controller.GetQRCodeForCurrentServer());\n            //qrCodeForm.Icon = this.Icon;\n            // TODO\n            qrCodeForm.Show();\n        }
        }\n        private void QRCodeItem_Click(object sender, EventArgs e)\n        {\n            QRCodeForm qrCodeForm = new QRCodeForm(controller.GetQRCodeForCurrentServer());\n            //qrCodeForm.Icon = this.Icon;\n            // TODO\n            qrCodeForm.Show();\n        }\n        private static void StatisticsStrategyOptionsItem_Click(object sender, EventArgs e)\n        {\n            //TODO: Load options
            {\n                var bestResult = (from server in servers\n                                  let name = server.FriendlyName()\n                                  where statistics.ContainsKey(name)\n                                  select new\n                                  {\n                                      server,\n                                      score = GetScore(statistics[name])\n                                  }\n                                  ).Aggregate((result1, result2) => result1.score > result2.score ? result1 : result2);
                                  ).Aggregate((result1, result2) => result1.score > result2.score ? result1 : result2);\n                Logging.Debug(string.Format("best server {0}: {1}", bestResult.server.FriendlyName(), bestResult.score));\n                _currentServer = bestResult.server;\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n            }\n        }
            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n            }\n        }\n        string IStrategy.ID\n        {\n            get { return "com.shadowsocks.strategy.scbs"; }\n        }
            }\n        }\n        string IStrategy.ID\n        {\n            get { return "com.shadowsocks.strategy.scbs"; }\n        }\n        string IStrategy.Name\n        {\n            get { return I18N.GetString("Choose By Total Package Loss"); }\n        }
        string IStrategy.ID\n        {\n            get { return "com.shadowsocks.strategy.scbs"; }\n        }\n        string IStrategy.Name\n        {\n            get { return I18N.GetString("Choose By Total Package Loss"); }\n        }\n        Server IStrategy.GetAServer(IStrategyCallerType type, IPEndPoint localIPEndPoint)\n        {
        string IStrategy.Name\n        {\n            get { return I18N.GetString("Choose By Total Package Loss"); }\n        }\n        Server IStrategy.GetAServer(IStrategyCallerType type, IPEndPoint localIPEndPoint)\n        {\n            Console.WriteLine("Switch to server by statistics: {0}", _currentServer.FriendlyName());\n            return _currentServer;  //current server cached for CachedInterval\n        }
        {\n            Console.WriteLine("Switch to server by statistics: {0}", _currentServer.FriendlyName());\n            return _currentServer;  //current server cached for CachedInterval\n        }\n        void IStrategy.ReloadServers()\n        {\n            ChooseNewServer(_controller.GetCurrentConfiguration().configs);\n            timer?.Change(0, CachedInterval);\n        }
        }\n        void IStrategy.ReloadServers()\n        {\n            ChooseNewServer(_controller.GetCurrentConfiguration().configs);\n            timer?.Change(0, CachedInterval);\n        }\n        void IStrategy.SetFailure(Server server)\n        {\n            Logging.Debug(String.Format("failure: {0}", server.FriendlyName()));\n        }
            ChooseNewServer(_controller.GetCurrentConfiguration().configs);\n            timer?.Change(0, CachedInterval);\n        }\n        void IStrategy.SetFailure(Server server)\n        {\n            Logging.Debug(String.Format("failure: {0}", server.FriendlyName()));\n        }\n        void IStrategy.UpdateLastRead(Server server)\n        {\n            //TODO: combine this part of data with ICMP statics\n        }
        void IStrategy.SetFailure(Server server)\n        {\n            Logging.Debug(String.Format("failure: {0}", server.FriendlyName()));\n        }\n        void IStrategy.UpdateLastRead(Server server)\n        {\n            //TODO: combine this part of data with ICMP statics\n        }\n        void IStrategy.UpdateLastWrite(Server server)\n        {\n            //TODO: combine this part of data with ICMP statics\n        }
            UpdateButtons();\n            LoadSelectedServerDetails();\n            _lastSelectedIndex = ServersListBox.SelectedIndex;\n        }\n        private void AddButton_Click(object sender, EventArgs e)\n        {\n            if (!ValidateAndSaveSelectedServerDetails())\n            {\n                return;\n            }
            {\n                return;\n            }\n            Server server = Configuration.GetDefaultServer();\n            _modifiedConfiguration.configs.Add(server);\n            LoadServerNameListToUI(_modifiedConfiguration);\n            ServersListBox.SelectedIndex = _modifiedConfiguration.configs.Count - 1;\n            _lastSelectedIndex = ServersListBox.SelectedIndex;\n        }\n        private void DuplicateButton_Click(object sender, EventArgs e)\n        {
        public static void RegisterForRestart(bool register)\n        {\n            // requested register and not autostartup\n            if (register && !Check())\n            {\n                // first parameter is process command line parameter
using Shadowsocks.Util;\nusing Shadowsocks.View;\nnamespace Shadowsocks\n{\n    static class Program\n    {\n        public static ShadowsocksController MainController { get; private set; }\n        public static MenuViewController MenuController { get; private set; }\n        /// <summary>\n        /// 应用程序的主入口点。\n        /// </summary>
﻿using System;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.Security.Cryptography;\nnamespace shadowsocks_csharp\n{\n    class Encryptor\n    {\n        public byte[] encryptTable = new byte[256];\n        public byte[] decryptTable = new byte[256];
using System.Security.Cryptography;\nnamespace shadowsocks_csharp\n{\n    class Encryptor\n    {\n        public byte[] encryptTable = new byte[256];\n        public byte[] decryptTable = new byte[256];\n        private Int64 compare(byte x, byte y, UInt64 a, int i) {\n            return (Int64)(a % (UInt64)(x + i)) - (Int64)(a % (UInt64)(y + i));\n        }
        private int port;\n        private Encryptor encryptor;\n        public Local(int port)\n        {\n            this.port = port;\n            this.encryptor = new Encryptor("barfoo!");\n        }\n        public void Start()\n        {\n            // Create a TCP/IP socket.
namespace shadowsocks_csharp\n{\n    static class Program\n    {\n        /// <summary>\n        /// 应用程序的主入口点。\n        /// </summary>\n        [STAThread]\n        static void Main()\n        {
                            return;\n                        }\n                        encryptor.Encrypt(connetionRecvBuffer, bytesRead, connetionSendBuffer, out bytesToSend);\n                    }\n                    Logging.Debug(remote, bytesToSend, "TCP Relay", "@PipeConnectionReceiveCallback() (upload)");\n                    tcprelay.UpdateOutboundCounter(bytesToSend);\n                    remote.BeginSend(connetionSendBuffer, 0, bytesToSend, 0, new AsyncCallback(PipeRemoteSendCallback), null);\n                    IStrategy strategy = controller.GetCurrentStrategy();
using System.Threading.Tasks;\nusing Newtonsoft.Json;\nusing Newtonsoft.Json.Linq;\nusing Shadowsocks.Model;\nusing Shadowsocks.Util;\nnamespace Shadowsocks.Controller\n{\n    using DataUnit = KeyValuePair<string, string>;\n    using DataList = List<KeyValuePair<string, string>>;\n    using Statistics = Dictionary<string, List<AvailabilityStatistics.RawStatisticsData>>;
using Shadowsocks.Util;\nnamespace Shadowsocks.Controller\n{\n    using DataUnit = KeyValuePair<string, string>;\n    using DataList = List<KeyValuePair<string, string>>;\n    using Statistics = Dictionary<string, List<AvailabilityStatistics.RawStatisticsData>>;\n        public static readonly string DateTimePattern = "yyyy-MM-dd HH:mm:ss";\n        private const string StatisticsFilesName = "shadowsocks.availability.csv";\n        private const string Delimiter = ",";\n        private const int Timeout = 500;
    using Statistics = Dictionary<string, List<AvailabilityStatistics.RawStatisticsData>>;\n        public static readonly string DateTimePattern = "yyyy-MM-dd HH:mm:ss";\n        private const string StatisticsFilesName = "shadowsocks.availability.csv";\n        private const string Delimiter = ",";\n        private const int Timeout = 500;\n        private const int DelayBeforeStart = 1000;\n        public Statistics RawStatistics { get; private set; }\n        public Statistics FilteredStatistics { get; private set; }\n        public static readonly DateTime UnknownDateTime = new DateTime(1970, 1, 1);\n        private int Repeat => _config.RepeatTimesNum;
        //static constructor to initialize every public static fields before refereced\n        static AvailabilityStatistics()\n        {\n            AvailabilityStatisticsFile = Utils.GetTempPath(StatisticsFilesName);\n        }
        }\n        private async void evaluate()\n        {\n            var geolocationAndIsp = GetGeolocationAndIsp();\n            foreach (var dataLists in await TaskEx.WhenAll(_servers.Select(ICMPTest)))\n            {\n                if (dataLists == null) continue;\n                foreach (var dataList in dataLists.Where(dataList => dataList != null))\n                {
                process.StartInfo.RedirectStandardOutput = true;\n                process.StartInfo.RedirectStandardError = true;\n                //process.StandardOutput\n                process.Start();\n            }\n        }\n        public void Stop()\n        {\n            if (process != null)\n            {
                }\n                catch (Exception e)\n                {\n                    Console.WriteLine(e.ToString());\n                }\n                _process = null;\n            }\n        }\n        private int GetFreePort()\n        {
                    Console.WriteLine(e.ToString());\n                }\n                _process = null;\n            }\n        }\n        private int GetFreePort()\n        {\n            IPGlobalProperties properties = IPGlobalProperties.GetIPGlobalProperties();\n            IPEndPoint[] tcpEndPoints = properties.GetActiveTcpListeners();\n            List<int> usedPorts = new List<int>();\n            foreach (IPEndPoint endPoint in IPGlobalProperties.GetIPGlobalProperties().GetActiveTcpListeners())\n            {
        }\n        private int GetFreePort()\n        {\n            IPGlobalProperties properties = IPGlobalProperties.GetIPGlobalProperties();\n            IPEndPoint[] tcpEndPoints = properties.GetActiveTcpListeners();\n            List<int> usedPorts = new List<int>();\n            foreach (IPEndPoint endPoint in IPGlobalProperties.GetIPGlobalProperties().GetActiveTcpListeners())\n            {\n                usedPorts.Add(endPoint.Port);\n            }
        {\n            IPEndPoint[] tcpEndPoints = properties.GetActiveTcpListeners();\n            List<int> usedPorts = new List<int>();\n            foreach (IPEndPoint endPoint in IPGlobalProperties.GetIPGlobalProperties().GetActiveTcpListeners())\n            {\n                usedPorts.Add(endPoint.Port);\n            }\n            for (int port = 8123; port < 65535; port++)\n            {
            LoadCurrentConfiguration();\n        }\n        private void LoadCurrentConfiguration()\n        {\n            _modifiedConfig = _controller.GetConfigurationCopy().hotkey;\n            LoadConfiguration(_modifiedConfig);\n        }\n        private void LoadConfiguration(HotkeyConfig config)\n        {\n            SwitchSystemProxyTextBox.Text = config.SwitchSystemProxy;
            SwitchSystemProxyTextBox.Text = config.SwitchSystemProxy;\n            ChangeToPacTextBox.Text = config.ChangeToPac;\n            ChangeToGlobalTextBox.Text = config.ChangeToGlobal;\n            SwitchAllowLanTextBox.Text = config.SwitchAllowLan;\n            ShowLogsTextBox.Text = config.ShowLogs;\n            ServerMoveUpTextBox.Text = config.ServerMoveUp;\n            ServerMoveDownTextBox.Text = config.ServerMoveDown;\n        }\n        private void UpdateTexts()\n        {\n            // I18N stuff\n            SwitchSystemProxyLabel.Text = I18N.GetString("Switch system proxy");
{\n    /*\n     * Format:\n     *  <modifiers-combination>+<key>\n     *\n     */\n    [Serializable]\n    public class HotkeyConfig\n    {\n        public string SwitchSystemProxy;
    {\n        public string SwitchSystemProxy;\n        public string ChangeToPac;\n        public string ChangeToGlobal;\n        public string SwitchAllowLan;\n        public string ShowLogs;\n        public string ServerMoveUp;\n        public string ServerMoveDown;\n        public HotkeyConfig()\n        {\n            SwitchSystemProxy = "";
        /// the contents of this method with the code editor.\n        /// </summary>\n        private void InitializeComponent()\n        {\n            System.Windows.Forms.FlowLayoutPanel flowLayoutPanel1;\n            this.btnOK = new System.Windows.Forms.Button();\n            this.btnCancel = new System.Windows.Forms.Button();\n            this.btnRegisterAll = new System.Windows.Forms.Button();\n            this.tableLayoutPanel1 = new System.Windows.Forms.TableLayoutPanel();\n            this.SwitchSystemProxyLabel = new System.Windows.Forms.Label();
            this.btnCancel = new System.Windows.Forms.Button();\n            this.btnRegisterAll = new System.Windows.Forms.Button();\n            this.tableLayoutPanel1 = new System.Windows.Forms.TableLayoutPanel();\n            this.SwitchSystemProxyLabel = new System.Windows.Forms.Label();\n            this.ChangeToPacLabel = new System.Windows.Forms.Label();\n            this.ChangeToGlobalLabel = new System.Windows.Forms.Label();\n            this.SwitchAllowLanLabel = new System.Windows.Forms.Label();\n            this.ShowLogsLabel = new System.Windows.Forms.Label();\n            this.ServerMoveUpLabel = new System.Windows.Forms.Label();\n            this.ServerMoveDownLabel = new System.Windows.Forms.Label();\n            this.SwitchSystemProxyTextBox = new System.Windows.Forms.TextBox();
            this.tableLayoutPanel1.SuspendLayout();\n            this.SuspendLayout();\n            // \n            // flowLayoutPanel1\n            // \n            this.tableLayoutPanel1.SetColumnSpan(flowLayoutPanel1, 2);\n            flowLayoutPanel1.Controls.Add(this.btnOK);\n            flowLayoutPanel1.Controls.Add(this.btnCancel);\n            flowLayoutPanel1.Controls.Add(this.btnRegisterAll);\n            flowLayoutPanel1.FlowDirection = System.Windows.Forms.FlowDirection.BottomUp;
            flowLayoutPanel1.Controls.Add(this.btnRegisterAll);\n            flowLayoutPanel1.FlowDirection = System.Windows.Forms.FlowDirection.BottomUp;\n            this.tableLayoutPanel1.Controls.Add(this.ChangeToPacLabel, 0, 1);\n            this.tableLayoutPanel1.Controls.Add(this.ChangeToGlobalLabel, 0, 2);\n            this.tableLayoutPanel1.Controls.Add(this.SwitchAllowLanLabel, 0, 3);\n            this.tableLayoutPanel1.Controls.Add(this.ShowLogsLabel, 0, 4);\n            this.tableLayoutPanel1.Controls.Add(this.ServerMoveUpLabel, 0, 5);\n            this.tableLayoutPanel1.Controls.Add(this.ServerMoveDownLabel, 0, 6);\n            this.tableLayoutPanel1.Controls.Add(flowLayoutPanel1, 0, 7);\n            this.tableLayoutPanel1.Controls.Add(this.SwitchSystemProxyTextBox, 1, 0);
            // \n            // SwitchAllowLanTextBox\n            // \n            this.SwitchAllowLanTextBox.Dock = System.Windows.Forms.DockStyle.Fill;
            this.SwitchAllowLanTextBox.Dock = System.Windows.Forms.DockStyle.Fill;\n        private System.Windows.Forms.Label ChangeToPacLabel;\n        private System.Windows.Forms.Label ChangeToGlobalLabel;\n        private System.Windows.Forms.Label SwitchAllowLanLabel;\n        private System.Windows.Forms.Label ShowLogsLabel;\n        private System.Windows.Forms.Label ServerMoveUpLabel;\n        private System.Windows.Forms.Label ServerMoveDownLabel;\n        private System.Windows.Forms.Button btnOK;\n        private System.Windows.Forms.Button btnCancel;\n        private System.Windows.Forms.TextBox ShowLogsTextBox;\n        private System.Windows.Forms.TextBox SwitchAllowLanTextBox;
                    { Logging.LogUsefulException(e); }\n                }\n            }\n        }\n        public static bool Check()\n        {\n            RegistryKey runKey = null;\n            try\n            {\n                string path = Application.ExecutablePath;
        public static bool Check()\n        {\n            RegistryKey runKey = null;\n            try\n            {\n                string path = Application.ExecutablePath;\n                runKey = Microsoft.Win32.Registry.CurrentUser.OpenSubKey(@"Software\Microsoft\Windows\CurrentVersion\Run", true);\n                string[] runList = runKey.GetValueNames();\n                foreach (string item in runList)\n                {
            RegistryKey runKey = null;\n            try\n            {\n                string path = Application.ExecutablePath;\n                runKey = Microsoft.Win32.Registry.CurrentUser.OpenSubKey(@"Software\Microsoft\Windows\CurrentVersion\Run", true);\n                string[] runList = runKey.GetValueNames();\n                foreach (string item in runList)\n                {\n                    if (item.Equals(Key))\n                        return true;
using System.Runtime.InteropServices;\nusing Shadowsocks.Controller;\nnamespace Shadowsocks.Util.ProcessManagement\n{\n    /*\n     * See:\n     * http://stackoverflow.com/questions/6266820/working-example-of-createjobobject-setinformationjobobject-pinvoke-in-net\n     */\n    public class Job : IDisposable\n    {
namespace Shadowsocks.Util.ProcessManagement\n{\n    /*\n     * See:\n     * http://stackoverflow.com/questions/6266820/working-example-of-createjobobject-setinformationjobobject-pinvoke-in-net\n     */\n    public class Job : IDisposable\n    {\n        [DllImport("kernel32.dll", CharSet = CharSet.Unicode)]\n        private static extern IntPtr CreateJobObject(IntPtr a, string lpName);\n        [DllImport("kernel32.dll", SetLastError = true)]\n        private static extern bool SetInformationJobObject(IntPtr hJob, JobObjectInfoType infoType, IntPtr lpJobObjectInfo, UInt32 cbJobObjectInfoLength);\n        [DllImport("kernel32.dll", SetLastError = true)]\n        private static extern bool AssignProcessToJobObject(IntPtr job, IntPtr process);\n        [DllImport("kernel32.dll", SetLastError = true)]\n        [return: MarshalAs(UnmanagedType.Bool)]\n        private static extern bool CloseHandle(IntPtr hObject);\n        private IntPtr handle = IntPtr.Zero;
            this.textBox4 = new System.Windows.Forms.TextBox();\n            this.panel1 = new System.Windows.Forms.Panel();\n            this.button2 = new System.Windows.Forms.Button();\n            this.button1 = new System.Windows.Forms.Button();\n            this.notifyIcon1 = new System.Windows.Forms.NotifyIcon(this.components);\n            this.contextMenuStrip1 = new System.Windows.Forms.ContextMenuStrip(this.components);\n            this.ConfigItem = new System.Windows.Forms.ToolStripMenuItem();\n            this.aboutToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();\n            this.QuitItem = new System.Windows.Forms.ToolStripMenuItem();
            // QuitItem\n            // \n            this.QuitItem.Name = "QuitItem";\n            this.QuitItem.Size = new System.Drawing.Size(110, 22);\n            this.QuitItem.Text = "Quit";\n            this.QuitItem.Click += new System.EventHandler(this.Quit_Click);
            this.Name = "Form1";\n            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;\n            this.Text = "Shadowsocks";\n            this.Load += new System.EventHandler(this.Form1_Load);
            this.config = config;\n            this.encryptor = new Encryptor(config.password);\n        }\n        public void Start()\n        {\n            // Create a TCP/IP socket.\n            listener = new Socket(AddressFamily.InterNetwork,\n                SocketType.Stream, ProtocolType.Tcp);\n            IPEndPoint localEndPoint = new IPEndPoint(0, config.local_port);\n            // Bind the socket to the local endpoint and listen for incoming connections.
            IPEndPoint remoteEP = new IPEndPoint(ipAddress, config.server_port);\n            remote = new Socket(ipAddress.AddressFamily,\n                SocketType.Stream, ProtocolType.Tcp);\n            // Connect to the remote endpoint.\n            remote.BeginConnect(remoteEP,\n                new AsyncCallback(connectCallback), null);\n        }\n        public void Close()\n        {\n            connection.Close();
﻿using System;\nusing System.Collections.Generic;
namespace shadowsocks_csharp\n{\n    [Serializable]\n    public class Config\n    {\n        public string server;\n        public int server_port;\n        public int local_port;\n        public string password;
        public bool isDefault;\n        private static void assert(bool condition)\n        {\n            if(!condition) \n            {\n                throw new Exception("assertion failure");\n            }\n        }\n        public static Config Load()\n        {
            if(!condition) \n            {\n                throw new Exception("assertion failure");\n            }\n        }\n        public static Config Load()\n        {\n            DataContractJsonSerializer ser = new DataContractJsonSerializer(typeof(Config));\n            try\n            {
                throw new Exception("assertion failure");\n            }\n        }\n        public static Config Load()\n        {\n            DataContractJsonSerializer ser = new DataContractJsonSerializer(typeof(Config));\n            try\n            {\n                using (FileStream fs = File.OpenRead(@"config.json"))\n                {
                    server = "127.0.0.1",\n                    server_port = 8388,\n                    local_port = 1081,\n                    password = "barfoo!",\n                    isDefault = true\n                };\n            }\n        }\n        public static void Save(Config config)\n        {
                    password = "barfoo!",\n                    isDefault = true\n                };\n            }\n        }\n        public static void Save(Config config)\n        {\n            DataContractJsonSerializer ser = new DataContractJsonSerializer(typeof(Config));\n            try\n            {
                };\n            }\n        }\n        public static void Save(Config config)\n        {\n            DataContractJsonSerializer ser = new DataContractJsonSerializer(typeof(Config));\n            try\n            {\n                using (FileStream fs = File.Open(@"config.json", FileMode.Create))\n                {

            this.contextMenu1 = new System.Windows.Forms.ContextMenu(new System.Windows.Forms.MenuItem[] {\n                this.enableItem = CreateMenuItem("Enable", new System.EventHandler(this.EnableItem_Click)),\n                CreateMenuGroup("Mode", new System.Windows.Forms.MenuItem[] {\n                    this.PACModeItem = CreateMenuItem("PAC", new System.EventHandler(this.PACModeItem_Click)),\n                    this.globalModeItem = CreateMenuItem("Global", new System.EventHandler(this.GlobalModeItem_Click))\n                }),
            this.contextMenu1 = new System.Windows.Forms.ContextMenu(new System.Windows.Forms.MenuItem[] {\n                this.enableItem = CreateMenuItem("Enable", new System.EventHandler(this.EnableItem_Click)),\n                CreateMenuGroup("Mode", new System.Windows.Forms.MenuItem[] {\n                    this.PACModeItem = CreateMenuItem("PAC", new System.EventHandler(this.PACModeItem_Click)),\n                    this.globalModeItem = CreateMenuItem("Global", new System.EventHandler(this.GlobalModeItem_Click))\n                }),\n                this.ServersItem = CreateMenuGroup("Servers", new System.Windows.Forms.MenuItem[] {\n                    this.SeperatorItem = new MenuItem("-"),
                this.enableItem = CreateMenuItem("Enable", new System.EventHandler(this.EnableItem_Click)),\n                CreateMenuGroup("Mode", new System.Windows.Forms.MenuItem[] {\n                    this.PACModeItem = CreateMenuItem("PAC", new System.EventHandler(this.PACModeItem_Click)),\n                    this.globalModeItem = CreateMenuItem("Global", new System.EventHandler(this.GlobalModeItem_Click))\n                }),\n                this.ServersItem = CreateMenuGroup("Servers", new System.Windows.Forms.MenuItem[] {\n                    this.SeperatorItem = new MenuItem("-"),\n                    this.ConfigItem = CreateMenuItem("Edit Servers...", new System.EventHandler(this.Config_Click))\n                }),\n                new MenuItem("-"),
                }),\n                this.ServersItem = CreateMenuGroup("Servers", new System.Windows.Forms.MenuItem[] {\n                    this.SeperatorItem = new MenuItem("-"),\n                    this.ConfigItem = CreateMenuItem("Edit Servers...", new System.EventHandler(this.Config_Click))\n                }),\n                new MenuItem("-"),\n                this.AutoStartupItem = CreateMenuItem("Start on Boot", new System.EventHandler(this.AutoStartupItem_Click)),\n                this.ShareOverLANItem = CreateMenuItem("Share over LAN", new System.EventHandler(this.ShareOverLANItem_Click)),\n                CreateMenuItem("Edit PAC File...", new System.EventHandler(this.EditPACFileItem_Click)),\n                new MenuItem("-"),
                }),\n                new MenuItem("-"),\n                this.AutoStartupItem = CreateMenuItem("Start on Boot", new System.EventHandler(this.AutoStartupItem_Click)),\n                this.ShareOverLANItem = CreateMenuItem("Share over LAN", new System.EventHandler(this.ShareOverLANItem_Click)),\n                CreateMenuItem("Edit PAC File...", new System.EventHandler(this.EditPACFileItem_Click)),\n                new MenuItem("-"),\n                CreateMenuItem("Show QRCode...", new System.EventHandler(this.QRCodeItem_Click)),\n                CreateMenuItem("Show Logs...", new System.EventHandler(this.ShowLogItem_Click)),\n                CreateMenuItem("About...", new System.EventHandler(this.Config_Click)),\n                new MenuItem("-"),
            string dllPath = Utils.GetTempPath("libsscrypto.dll");\n            try\n            {\n                FileManager.UncompressFile(dllPath, Resources.libsscrypto_dll);\n            }\n            catch (IOException)\n            {\n            }\n            catch (Exception e)\n            {
            }\n            catch (IOException)\n            {\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine(e.ToString());\n            }\n            LoadLibrary(dllPath);\n        }
            catch (Exception e)\n            {\n                Console.WriteLine(e.ToString());\n            }\n            LoadLibrary(dllPath);\n        }\n        [DllImport("Kernel32.dll")]\n        private static extern IntPtr LoadLibrary(string path);\n        public const int MD5_CTX_SIZE = 88;\n        public static byte[] MD5(byte[] input)\n        {\n            byte[] output = new byte[16];
        public const int MD5_CTX_SIZE = 88;\n        public static byte[] MD5(byte[] input)\n        {\n            byte[] output = new byte[16];\n            MbedTLS.md5(input, (uint)input.Length, output);\n            return output;\n        }\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
        : EncryptorBase\n    {\n        public const int MAX_KEY_LENGTH = 64;\n        public const int MAX_IV_LENGTH = 16;\n        public const int ONETIMEAUTH_FLAG = 0x10;\n        public const int ADDRTYPE_MASK = 0xF;\n        public const int ONETIMEAUTH_BYTES = 10;\n        public const int CLEN_BYTES = 2;\n        public const int AUTH_BYTES = ONETIMEAUTH_BYTES + CLEN_BYTES;\n        protected static byte[] tempbuf = new byte[MAX_INPUT_SIZE];
        public const int CLEN_BYTES = 2;\n        public const int AUTH_BYTES = ONETIMEAUTH_BYTES + CLEN_BYTES;\n        protected static byte[] tempbuf = new byte[MAX_INPUT_SIZE];\n        protected Dictionary<string, int[]> ciphers;\n        private static readonly ConcurrentDictionary<string, byte[]> CachedKeys = new ConcurrentDictionary<string, byte[]>();\n        protected byte[] _encryptIV;\n        protected byte[] _decryptIV;\n        protected bool _decryptIVReceived;\n        protected bool _encryptIVSent;
        protected byte[] _key;\n        protected int keyLen;\n        protected int ivLen;\n        protected uint counter = 0;\n        protected byte[] _keyBuffer = null;\n        public IVEncryptor(string method, string password, bool onetimeauth, bool isudp)\n            : base(method, password, onetimeauth, isudp)\n        {\n            InitKey(method, password);\n        }
        {\n            InitKey(method, password);\n        }\n        protected abstract Dictionary<string, int[]> getCiphers();\n        protected void InitKey(string method, string password)\n        {\n            method = method.ToLower();\n            _method = method;\n            string k = method + ":" + password;\n            ciphers = getCiphers();
            _method = method;\n            string k = method + ":" + password;\n            ciphers = getCiphers();\n            _cipherInfo = ciphers[_method];\n            _cipher = _cipherInfo[2];\n            if (_cipher == 0)\n            {\n                throw new Exception("method not found");\n            }
        static byte[] sodiumBuf = new byte[MAX_INPUT_SIZE + SODIUM_BLOCK_SIZE];\n        protected int _encryptBytesRemaining;\n        protected int _decryptBytesRemaining;\n        protected ulong _encryptIC;\n        protected ulong _decryptIC;\n        public SodiumEncryptor(string method, string password, bool onetimeauth, bool isudp)\n            : base(method, password, onetimeauth, isudp)\n        {\n            InitKey(method, password);\n        }
        public SodiumEncryptor(string method, string password, bool onetimeauth, bool isudp)\n            : base(method, password, onetimeauth, isudp)\n        {\n            InitKey(method, password);\n        }\n        private static Dictionary<string, int[]> _ciphers = new Dictionary<string, int[]> {\n                {"salsa20", new int[]{32, 8, CIPHER_SALSA20, PolarSSL.AES_CTX_SIZE}},\n                {"chacha20", new int[]{32, 8, CIPHER_CHACHA20, PolarSSL.AES_CTX_SIZE}},\n                {"chacha20-ietf", new int[]{32, 12, CIPHER_CHACHA20_IETF, PolarSSL.AES_CTX_SIZE}},\n        };
            decryptor.Decrypt(cipher, outLen, plain2, out outLen2);\n            Assert.AreEqual(12333, outLen2);\n            for (int j = 0; j < outLen2; j++)\n            {\n                Assert.AreEqual(plain[j], plain2[j]);\n            }\n        }\n        private static bool encryptionFailed = false;\n        private static object locker = new object();\n        [TestMethod]
        }\n        private static bool encryptionFailed = false;\n        private static object locker = new object();\n        [TestMethod]\n        public void TestPolarSSLEncryption()\n        {\n            // run it once before the multi-threading test to initialize global tables\n            RunSinglePolarSSLEncryptionThread();\n            List<Thread> threads = new List<Thread>();\n            for (int i = 0; i < 10; i++)\n            {
                Thread t = new Thread(new ThreadStart(RunSinglePolarSSLEncryptionThread));\n                threads.Add(t);\n                t.Start();\n            }\n            foreach (Thread t in threads)\n            {\n                t.Join();\n            }\n            Assert.IsFalse(encryptionFailed);\n        }
            Assert.IsFalse(encryptionFailed);\n        }\n        private void RunSinglePolarSSLEncryptionThread()\n        {\n            try\n            {\n                for (int i = 0; i < 100; i++)\n                {\n                    IEncryptor encryptor;\n                    IEncryptor decryptor;
                case CIPHER_AES256GCM:\n                    ret = Sodium.crypto_aead_aes256gcm_encrypt(ciphertext, ref encClen,\n                        plaintext, (ulong)plen,\n                        null, 0,\n                        null, _encNonce,\n                        _sodiumEncSubkey);\n                    break;\n                default:\n                    throw new System.Exception("not implemented");\n            }
                        null, 0,\n                        null, _encNonce,\n                        _sodiumEncSubkey);\n                    break;\n                default:\n                    throw new System.Exception("not implemented");\n            }\n            if (ret != 0) throw new CryptoErrorException();\n            Logging.Dump("after cipherEncrypt: cipher", ciphertext, (int) encClen);\n            clen = (uint) encClen;
                        _sodiumEncSubkey);\n                    break;\n                default:\n                    throw new System.Exception("not implemented");\n            }\n            if (ret != 0) throw new CryptoErrorException();\n            Logging.Dump("after cipherEncrypt: cipher", ciphertext, (int) encClen);\n            clen = (uint) encClen;\n            return ret;\n        }
                case CIPHER_AES256GCM:\n                    ret = Sodium.crypto_aead_aes256gcm_decrypt(plaintext, ref decPlen,\n                        null,\n                        ciphertext, (ulong)clen,\n                        null, 0,\n                        _decNonce, _sodiumDecSubkey);\n                    break;\n                default:\n                    throw new System.Exception("not implemented");\n            }
                        ciphertext, (ulong)clen,\n                        null, 0,\n                        _decNonce, _sodiumDecSubkey);\n                    break;\n                default:\n                    throw new System.Exception("not implemented");\n            }\n            if (ret != 0) throw new CryptoErrorException();\n            Logging.Dump("after cipherDecrypt: plain", plaintext, (int) decPlen);\n            plen = (uint) decPlen;
            var AEADSodiumEncryptorSupportedCiphers = AEADSodiumEncryptor.SupportedCiphers();\n            if (Sodium.AES256GCMAvailable)\n            {\n                // prefer to aes-256-gcm in libsodium\n                AEADMbedTLSEncryptorSupportedCiphers.Remove("aes-256-gcm");\n            }\n            else\n            {\n                AEADSodiumEncryptorSupportedCiphers.Remove("aes-256-gcm");\n            }
                // prefer to aes-256-gcm in libsodium\n                AEADMbedTLSEncryptorSupportedCiphers.Remove("aes-256-gcm");\n            }\n            else\n            {\n                AEADSodiumEncryptorSupportedCiphers.Remove("aes-256-gcm");\n            }\n            foreach (string method in StreamMbedTLSEncryptor.SupportedCiphers())\n            {
                AEADSodiumEncryptorSupportedCiphers.Remove("aes-256-gcm");\n            }\n            foreach (string method in StreamMbedTLSEncryptor.SupportedCiphers())\n            {\n                _registeredEncryptors.Add(method, typeof(StreamMbedTLSEncryptor));\n            }\n            foreach (string method in StreamSodiumEncryptor.SupportedCiphers())\n            {
                _registeredEncryptors.Add(method, typeof(StreamMbedTLSEncryptor));\n            }\n            foreach (string method in StreamSodiumEncryptor.SupportedCiphers())\n            {\n                _registeredEncryptors.Add(method, typeof(StreamSodiumEncryptor));\n            }\n            foreach (string method in AEADMbedTLSEncryptorSupportedCiphers)\n            {
                    ret = MbedTLS.cipher_auth_encrypt(_encryptCtx,\n                        /* nonce */\n                        _encNonce, (uint) nonceLen,\n                        /* AD */\n                        IntPtr.Zero, 0,\n                        /* plain */\n                        plaintext, plen,\n                        /* cipher */\n                        ciphertext, ref olen,\n                        tagbuf, (uint) tagLen);
                        IntPtr.Zero, 0,\n                        /* plain */\n                        plaintext, plen,\n                        /* cipher */\n                        ciphertext, ref olen,\n                        tagbuf, (uint) tagLen);\n                    if (ret != 0) throw new CryptoErrorException();\n                    Debug.Assert(olen == plen);\n                    // attach tag to ciphertext\n                    Array.Copy(tagbuf, 0, ciphertext, (int) plen, tagLen);\n                    clen = olen + (uint) tagLen;
                        tagbuf, (uint) tagLen);\n                    if (ret != 0) throw new CryptoErrorException();\n                    Debug.Assert(olen == plen);\n                    // attach tag to ciphertext\n                    Array.Copy(tagbuf, 0, ciphertext, (int) plen, tagLen);\n                    clen = olen + (uint) tagLen;\n                    return ret;\n                default:\n                    throw new System.Exception("not implemented");\n            }\n        }
            Array.Copy(ciphertext, (int) (clen - tagLen), tagbuf, 0, tagLen);\n            switch (_cipher)\n            {\n                case CIPHER_AES:\n                    ret = MbedTLS.cipher_auth_decrypt(_decryptCtx,\n                        _decNonce, (uint) nonceLen,\n                        IntPtr.Zero, 0,\n                        ciphertext, (uint) (clen - tagLen),\n                        plaintext, ref olen,\n                        tagbuf, (uint) tagLen);
                case CIPHER_AES:\n                    ret = MbedTLS.cipher_auth_decrypt(_decryptCtx,\n                        _decNonce, (uint) nonceLen,\n                        IntPtr.Zero, 0,\n                        ciphertext, (uint) (clen - tagLen),\n                        plaintext, ref olen,\n                        tagbuf, (uint) tagLen);\n                    if (ret != 0) throw new CryptoErrorException();\n                    Debug.Assert(olen == clen - tagLen);\n                    plen = olen;
        }\n        #region Windows Form Designer generated code\n        /// <summary>\n        /// Required method for Designer support - do not modify\n        /// the contents of this method with the code editor.\n        /// </summary>\n        private void InitializeComponent()\n        {\n            this.components = new System.ComponentModel.Container();\n            this.LogMessageTextBox = new System.Windows.Forms.TextBox();
        /// </summary>\n        private void InitializeComponent()\n        {\n            this.components = new System.ComponentModel.Container();\n            this.LogMessageTextBox = new System.Windows.Forms.TextBox();\n            this.contextMenuStrip1 = new System.Windows.Forms.ContextMenuStrip(this.components);\n            this.mainMenu1 = new System.Windows.Forms.MainMenu(this.components);\n            this.FileMenuItem = new System.Windows.Forms.MenuItem();\n            this.OpenLocationMenuItem = new System.Windows.Forms.MenuItem();\n            this.ExitMenuItem = new System.Windows.Forms.MenuItem();
            this.mainMenu1 = new System.Windows.Forms.MainMenu(this.components);\n            this.FileMenuItem = new System.Windows.Forms.MenuItem();\n            this.OpenLocationMenuItem = new System.Windows.Forms.MenuItem();\n            this.ExitMenuItem = new System.Windows.Forms.MenuItem();\n            this.panel1 = new System.Windows.Forms.Panel();\n            this.ChangeFontButton = new System.Windows.Forms.Button();\n            this.CleanLogsButton = new System.Windows.Forms.Button();\n            this.WrapTextCheckBox = new System.Windows.Forms.CheckBox();\n            this.tableLayoutPanel1 = new System.Windows.Forms.TableLayoutPanel();
            this.OpenLocationMenuItem.Index = 0;\n            this.OpenLocationMenuItem.Text = "&Open Location";\n            this.OpenLocationMenuItem.Click += new System.EventHandler(this.OpenLocationMenuItem_Click);\n            // \n            // ExitMenuItem\n            // \n            this.ExitMenuItem.Index = 1;\n            this.ExitMenuItem.Text = "E&xit";\n            this.ExitMenuItem.Click += new System.EventHandler(this.ExitMenuItem_Click);\n            // 
            // \n            this.panel1.Controls.Add(this.TopMostCheckBox);\n            this.panel1.Controls.Add(this.ChangeFontButton);\n            this.panel1.Controls.Add(this.CleanLogsButton);\n            this.panel1.Controls.Add(this.WrapTextCheckBox);\n            this.panel1.Dock = System.Windows.Forms.DockStyle.Fill;\n            this.panel1.Location = new System.Drawing.Point(3, 3);\n            this.panel1.Name = "panel1";\n            this.panel1.Size = new System.Drawing.Size(541, 34);\n            this.panel1.TabIndex = 1;\n            // \n            // ChangeFontButton\n            // 
            this.panel1.Size = new System.Drawing.Size(541, 34);\n            this.panel1.TabIndex = 1;\n            // ChangeFontButton\n            // \n            this.ChangeFontButton.Location = new System.Drawing.Point(107, 4);\n            this.ChangeFontButton.Name = "ChangeFontButton";\n            this.ChangeFontButton.Size = new System.Drawing.Size(75, 23);\n            this.ChangeFontButton.TabIndex = 2;\n            this.ChangeFontButton.Text = "&Font";\n            this.ChangeFontButton.UseVisualStyleBackColor = true;\n            this.ChangeFontButton.Click += new System.EventHandler(this.ChangeFontButton_Click);\n            // \n            // CleanLogsButton\n            // 
            this.WrapTextCheckBox.AutoSize = true;
            this.WrapTextCheckBox.AutoSize = true;\n            this.tableLayoutPanel1.Controls.Add(this.panel1, 0, 0);\n            this.tableLayoutPanel1.Controls.Add(this.LogMessageTextBox, 0, 1);\n            this.tableLayoutPanel1.Dock = System.Windows.Forms.DockStyle.Fill;\n            this.tableLayoutPanel1.Location = new System.Drawing.Point(0, 0);\n            this.tableLayoutPanel1.Name = "tableLayoutPanel1";\n            this.tableLayoutPanel1.RowCount = 2;
            this.tableLayoutPanel1.Controls.Add(this.LogMessageTextBox, 0, 1);\n            this.tableLayoutPanel1.Dock = System.Windows.Forms.DockStyle.Fill;\n            this.tableLayoutPanel1.Location = new System.Drawing.Point(0, 0);\n            this.tableLayoutPanel1.Name = "tableLayoutPanel1";\n            this.tableLayoutPanel1.RowCount = 2;\n            this.tableLayoutPanel1.Size = new System.Drawing.Size(547, 353);\n            this.tableLayoutPanel1.TabIndex = 2;\n            // 

            this.panel1.ResumeLayout(false);\n            this.panel1.PerformLayout();\n            this.tableLayoutPanel1.ResumeLayout(false);\n            this.tableLayoutPanel1.PerformLayout();\n            this.ResumeLayout(false);\n        }\n        #endregion\n        private System.Windows.Forms.TextBox LogMessageTextBox;
            this.ResumeLayout(false);\n        }\n        #endregion\n        private System.Windows.Forms.TextBox LogMessageTextBox;\n        private System.Windows.Forms.ContextMenuStrip contextMenuStrip1;\n        private System.Windows.Forms.MainMenu mainMenu1;\n        private System.Windows.Forms.MenuItem FileMenuItem;\n        private System.Windows.Forms.MenuItem OpenLocationMenuItem;\n        private System.Windows.Forms.MenuItem ExitMenuItem;
            System.Diagnostics.Process.Start("explorer.exe", argument);\n        }\n        private void ExitMenuItem_Click(object sender, EventArgs e)\n        {\n            this.Close();\n        }\n        private void LogForm_Shown(object sender, EventArgs e)\n        {\n            LogMessageTextBox.ScrollToCaret();\n        }
        {\n            LogMessageTextBox.ScrollToCaret();\n        }\n        private void WrapTextCheckBox_CheckedChanged(object sender, EventArgs e)\n        {\n            LogMessageTextBox.WordWrap = WrapTextCheckBox.Checked;\n            LogMessageTextBox.ScrollToCaret();\n        }\n        private void CleanLogsButton_Click(object sender, EventArgs e)\n        {
        private void TopMostCheckBox_CheckedChanged(object sender, EventArgs e)\n        {
                if (bytesRead >= 5)\n                {\n                    _command = _connetionRecvBuffer[1];\n                    if (_command != 1 && _command != 3)\n                    {\n                        Logging.Debug("Unsupported CMD=" + _command);\n                        Close();\n                    }\n                    else\n                    {
                    _command = _connetionRecvBuffer[1];\n                    if (_command != 1 && _command != 3)\n                    {\n                        Logging.Debug("Unsupported CMD=" + _command);\n                        Close();\n                    }\n                    else\n                    {\n                        int atyp = _connetionRecvBuffer[3];\n                        switch (atyp)\n                        {
                    Logging.Debug("failed to recv data in Shadowsocks.Controller.TCPHandler.handshakeReceive2Callback()");\n                    Close();\n                }\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }
            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void ReadAddress(int bytesRemain)\n        {\n            Array.Copy(_connetionRecvBuffer, 3, _connetionRecvBuffer, 0, 2);\n            // Read the remain address bytes
            Array.Copy(_connetionRecvBuffer, 3, _connetionRecvBuffer, 0, 2);\n            // Read the remain address bytes\n            _connection.BeginReceive(_connetionRecvBuffer, 2, RecvSize - 2, SocketFlags.None, OnAddressFullyRead, bytesRemain);\n        }\n        private void OnAddressFullyRead(IAsyncResult ar)\n        {\n            if (_closed) return;\n            try\n            {\n                int bytesRead = _connection.EndReceive(ar);
        {\n            Server o2 = (Server)obj;\n            return server == o2.server && server_port == o2.server_port;\n        }\n        public string FriendlyName()\n        {\n            if (server.IsNullOrEmpty())\n            {\n                return I18N.GetString("New server");\n            }
        }\n        public string FriendlyName()\n        {\n            if (server.IsNullOrEmpty())\n            {\n                return I18N.GetString("New server");\n            }\n            if (remarks.IsNullOrEmpty())\n            {\n                return server + ":" + server_port;\n            }
        {\n            new LineReader(firstPacket, _localSocket, firstPacket, 0, length, OnLineRead, OnException, OnFinish,\n                    Encoding.UTF8, HTTP_CRLF, null);\n        }\n        #region Header Parse\n        private void OnException(Exception ex, object state)\n        {\n            Logging.LogUsefulException(ex);\n            Close();\n        }
        {\n            Logging.LogUsefulException(ex);\n            Close();\n        }\n            if (!line.StartsWith("Proxy-"))\n            {\n                _headers.Enqueue(line);\n            }\n            if (_requestLineCount == 0)\n            {\n                var m = HttpRequestHeaderRegex.Match(line);\n                if (m.Success)\n                {
            if (_requestLineCount == 0)\n            {\n                var m = HttpRequestHeaderRegex.Match(line);\n                if (m.Success)\n                {\n                    var method = m.Groups[1].Value;\n                    if (method == "CONNECT")\n                    {\n                        _isConnect = true;
                    var method = m.Groups[1].Value;\n                    if (method == "CONNECT")\n                    {\n                        _isConnect = true;\n                        if (!ParseHost(m.Groups[2].Value))\n                        {\n                            throw new Exception("Bad http header: " + line);\n                        }\n                    }
        }\n        private void handshakeReceive2Callback(IAsyncResult ar)\n        {\n            if (closed)\n            {\n                return;\n            }\n            try\n            {\n                int bytesRead = connection.EndReceive(ar);
            {\n                return;\n            }\n            try\n            {\n                int bytesRead = connection.EndReceive(ar);\n                if (bytesRead > 0)\n                {\n                    byte[] response = { 5, 0, 0, 1, 0, 0, 0, 0, 0, 0 };
        {\n            this.PACUrlTextBox = new System.Windows.Forms.TextBox();\n            this.PACUrlLabel = new System.Windows.Forms.Label();\n            this.OkButton = new System.Windows.Forms.Button();\n            this.CancelButton = new System.Windows.Forms.Button();\n            this.SuspendLayout();\n            // \n            // PACUrlTextBox\n            // 
            // \n            this.PACUrlTextBox.Location = new System.Drawing.Point(61, 12);\n            this.PACUrlTextBox.MaxLength = 256;\n            this.PACUrlTextBox.Name = "PACUrlTextBox";\n            this.PACUrlTextBox.Size = new System.Drawing.Size(245, 20);\n            this.PACUrlTextBox.TabIndex = 4;\n            this.PACUrlTextBox.WordWrap = false;\n            // \n            // PACUrlLabel\n            // \n            this.PACUrlLabel.AutoSize = true;

      /// Note that there is no way to encode bytes in MODE_KANJI. We might want to add EncodeWithMode()\n      /// with which clients can specify the encoding mode. For now, we don't need the functionality.\n      /// </summary>\n      {\n         // Determine what character encoding has been specified by the caller, if any\n#if !SILVERLIGHT || WINDOWS_PHONE
      {\n         // Determine what character encoding has been specified by the caller, if any\n#if !SILVERLIGHT || WINDOWS_PHONE\n         String encoding = DEFAULT_BYTE_MODE_ENCODING;\n         //bool generateECI = !DEFAULT_BYTE_MODE_ENCODING.Equals(encoding);\n#else\n         // Silverlight supports only UTF-8 and UTF-16 out-of-the-box\n         const string encoding = "UTF-8";\n         // caller of the method can only control if the ECI segment should be written\n         // character set is fixed to UTF-8; but some scanners doesn't like the ECI segment\n         bool generateECI = (hints != null && hints.ContainsKey(EncodeHintType.CHARACTER_SET));\n#endif\n         // Pick an encoding mode appropriate for the content. Note that this will not attempt to use\n         // multiple modes / segments even if that were more efficient. Twould be nice.
      {\n         // Determine what character encoding has been specified by the caller, if any\n#if !SILVERLIGHT || WINDOWS_PHONE\n         String encoding = DEFAULT_BYTE_MODE_ENCODING;\n         //bool generateECI = !DEFAULT_BYTE_MODE_ENCODING.Equals(encoding);\n         // Silverlight supports only UTF-8 and UTF-16 out-of-the-box\n         const string encoding = "UTF-8";\n         // caller of the method can only control if the ECI segment should be written\n         // character set is fixed to UTF-8; but some scanners doesn't like the ECI segment\n         bool generateECI = (hints != null && hints.ContainsKey(EncodeHintType.CHARACTER_SET));\n#endif\n         // Pick an encoding mode appropriate for the content. Note that this will not attempt to use\n         // multiple modes / segments even if that were more efficient. Twould be nice.\n         Mode mode = Mode.BYTE;\n         // This will store the header information, like mode and\n         // length, as well as "header" segments like an ECI segment.\n         BitArray headerBits = new BitArray();
            Version.ECBlocks ecBlocks = version.getECBlocksForLevel(ecLevel);\n            int numEcBytes = ecBlocks.TotalECCodewords;\n            // getNumDataBytes = 196 - 130 = 66\n            int numDataBytes = numBytes - numEcBytes;\n            int totalInputBytes = (numInputBits + 7) / 8;\n            if (numDataBytes >= totalInputBytes)\n            {\n               return version;\n            }\n         }
         // numDataBytesInGroup2 = 13 + 1 = 14\n         int numDataBytesInGroup2 = numDataBytesInGroup1 + 1;\n         // numEcBytesInGroup1 = 39 - 13 = 26\n         int numEcBytesInGroup1 = numTotalBytesInGroup1 - numDataBytesInGroup1;\n         // numEcBytesInGroup2 = 40 - 14 = 26\n         int numEcBytesInGroup2 = numTotalBytesInGroup2 - numDataBytesInGroup2;\n         // Sanity checks.\n         // 26 = 26\n         if (numEcBytesInGroup1 != numEcBytesInGroup2)\n         {
         // numEcBytesInGroup2 = 40 - 14 = 26\n         int numEcBytesInGroup2 = numTotalBytesInGroup2 - numDataBytesInGroup2;\n         // Sanity checks.\n         // 26 = 26\n         if (numEcBytesInGroup1 != numEcBytesInGroup2)\n         {\n             throw new Exception("EC bytes mismatch");\n         }\n         // 5 = 4 + 1.\n         if (numRSBlocks != numRsBlocksInGroup1 + numRsBlocksInGroup2)\n         {
         if (numRSBlocks != numRsBlocksInGroup1 + numRsBlocksInGroup2)\n         {\n             throw new Exception("RS blocks mismatch");\n         }\n         // 196 = (13 + 26) * 4 + (14 + 26) * 1\n         if (numTotalBytes !=\n             ((numDataBytesInGroup1 + numEcBytesInGroup1) *\n                 numRsBlocksInGroup1) +\n                 ((numDataBytesInGroup2 + numEcBytesInGroup2) *\n                     numRsBlocksInGroup2))\n         {
      /// </summary>\n      /// <param name="numLetters">The num letters.</param>\n      /// <param name="version">The version.</param>\n      /// <param name="mode">The mode.</param>\n      /// <param name="bits">The bits.</param>\n      internal static void appendLengthInfo(int numLetters, Version version, Mode mode, BitArray bits)\n      {\n         int numBits = mode.getCharacterCountBits(version);\n         if (numLetters >= (1 << numBits))\n         {
               if (mode.Equals(Mode.BYTE))\n                  append8BitBytes(content, bits, encoding);\n                  else
               }\n            }\n            catch (Exception uee)\n            {\n               throw new WriterException(uee.Message, uee);\n            }\n         }\n#endif\n         catch (Exception uee)\n         {
         }\n      }\n      /// <summary>\n      /// Embed the lonely dark dot at left bottom corner. JISX0510:2004 (p.46)\n      /// </summary>\n      /// <param name="matrix">The matrix.</param>\n      private static void embedDarkDotAtLeftBottomCorner(ByteMatrix matrix)\n      {\n         if (matrix[8, matrix.Height - 8] == 0)\n         {
             throw new Exception();\n         }\n         matrix[8, matrix.Height - 8] = 1;\n      }\n      private static void embedHorizontalSeparationPattern(int xStart, int yStart, ByteMatrix matrix)\n      {\n         for (int x = 0; x < 8; ++x)\n         {\n            if (!isEmpty(matrix[xStart + x, yStart]))\n            {
            polipoRunner.Stop();\n            try\n            {\n                polipoRunner.Start(_config);\n                Local local = new Local(_config);\n                List<Listener.Service> services = new List<Listener.Service>();\n                services.Add(local);\n                _listener = new Listener(services);\n                _listener.Start(_config);
using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.IO.Compression;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Text;\nnamespace Shadowsocks.Controller\n{
using System.IO.Compression;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Text;\nnamespace Shadowsocks.Controller\n{\n    class PACServer\n    {\n        private static int PORT = 8093;\n        public static string PAC_FILE = "pac.txt";
using System.Text;\nnamespace Shadowsocks.Controller\n{\n    class PACServer\n    {\n        private static int PORT = 8093;\n        public static string PAC_FILE = "pac.txt";\n        private static Configuration config;\n        Socket _listener;\n        FileSystemWatcher watcher;\n        public event EventHandler PACFileChanged;
        private static int PORT = 8093;\n        public static string PAC_FILE = "pac.txt";\n        private static Configuration config;\n        Socket _listener;\n        FileSystemWatcher watcher;\n        public event EventHandler PACFileChanged;\n        public void Start(Configuration configuration)\n        {\n            try\n            {
        public event EventHandler PACFileChanged;\n        public void Start(Configuration configuration)\n        {\n            try\n            {\n                config = configuration;\n                // Create a TCP/IP socket.\n                _listener = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);\n                _listener.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, true);\n                IPEndPoint localEndPoint = null;\n                if (configuration.shareOverLan)\n                {
        {\n            try\n            {\n                config = configuration;\n                // Create a TCP/IP socket.\n                _listener = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);\n                _listener.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, true);\n                IPEndPoint localEndPoint = null;\n                if (configuration.shareOverLan)\n                {\n                    localEndPoint = new IPEndPoint(IPAddress.Any, PORT);\n                }
            {\n                _listener = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);\n                _listener.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, true);\n                IPEndPoint localEndPoint = null;\n                if (configuration.shareOverLan)\n                {\n                    localEndPoint = new IPEndPoint(IPAddress.Any, PORT);\n                }\n                else\n                {
                if (configuration.shareOverLan)\n                {\n                    localEndPoint = new IPEndPoint(IPAddress.Any, PORT);\n                }\n                else\n                {\n                    localEndPoint = new IPEndPoint(IPAddress.Loopback, PORT);\n                }
                    localEndPoint = new IPEndPoint(IPAddress.Any, PORT);\n                }\n                else\n                {\n                    localEndPoint = new IPEndPoint(IPAddress.Loopback, PORT);\n                }\n                // Bind the socket to the local endpoint and listen for incoming connections.\n                _listener.Bind(localEndPoint);\n                _listener.Listen(100);\n                _listener.BeginAccept(\n                    new AsyncCallback(AcceptCallback),\n                    _listener);\n                WatchPacFile();\n            }
                }\n                else\n                {\n                    localEndPoint = new IPEndPoint(IPAddress.Loopback, PORT);\n                }\n                // Bind the socket to the local endpoint and listen for incoming connections.\n                _listener.Bind(localEndPoint);\n                _listener.Listen(100);\n                _listener.BeginAccept(\n                    new AsyncCallback(AcceptCallback),\n                    _listener);\n                WatchPacFile();\n            }\n            catch (SocketException)\n            {
        {\n            if (File.Exists(PAC_FILE))\n            {\n                return File.ReadAllText(PAC_FILE, Encoding.UTF8);\n            }\n            else\n            {\n                return Utils.UnGzip(Resources.proxy_pac_txt);\n            }\n        }
            {\n                return File.ReadAllText(PAC_FILE, Encoding.UTF8);\n            }\n            else\n            {\n                return Utils.UnGzip(Resources.proxy_pac_txt);\n            }\n        }\n        private void ReceiveCallback(IAsyncResult ar)\n        {
            else\n            {\n                return Utils.UnGzip(Resources.proxy_pac_txt);\n            }\n        }\n        private void ReceiveCallback(IAsyncResult ar)\n        {\n            object[] state = (object[])ar.AsyncState;\n            Socket conn = (Socket)state[0];\n            byte[] requestBuf = (byte[])state[1];\n            try\n            {
                return Utils.UnGzip(Resources.proxy_pac_txt);\n            }\n        }\n        private void ReceiveCallback(IAsyncResult ar)\n        {\n            object[] state = (object[])ar.AsyncState;\n            Socket conn = (Socket)state[0];\n            byte[] requestBuf = (byte[])state[1];\n            try\n            {\n                int bytesRead = conn.EndReceive(ar);\n                string pac = GetPACContent();
        private void ReceiveCallback(IAsyncResult ar)\n        {\n            object[] state = (object[])ar.AsyncState;\n            Socket conn = (Socket)state[0];\n            byte[] requestBuf = (byte[])state[1];\n            try\n            {\n                int bytesRead = conn.EndReceive(ar);\n                string pac = GetPACContent();\n                IPEndPoint localEndPoint = (IPEndPoint)conn.LocalEndPoint;\n                string proxy = GetPACAddress(requestBuf, localEndPoint);\n                pac = pac.Replace("__PROXY__", proxy);
                IPEndPoint localEndPoint = (IPEndPoint)conn.LocalEndPoint;\n                string proxy = GetPACAddress(requestBuf, localEndPoint);\n                pac = pac.Replace("__PROXY__", proxy);\n                if (bytesRead > 0)\n                {\n                    string text = String.Format(@"HTTP/1.1 200 OK\nServer: Shadowsocks\nContent-Type: application/x-ns-proxy-autoconfig\nContent-Length: {0}\nConnection: Close\n", System.Text.Encoding.UTF8.GetBytes(pac).Length) + pac;
Connection: Close\n", System.Text.Encoding.UTF8.GetBytes(pac).Length) + pac;\n                    Util.Utils.ReleaseMemory();\n                }\n                else\n                {\n                    conn.Close();\n                }\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine(e);
            watcher.Renamed += Watcher_Changed;\n            watcher.EnableRaisingEvents = true;\n        }\n        private void Watcher_Changed(object sender, FileSystemEventArgs e)\n        {\n            if (PACFileChanged != null)\n            {\n                PACFileChanged(this, new EventArgs());\n            }\n        }
        }\n        private void Watcher_Changed(object sender, FileSystemEventArgs e)\n        {\n            if (PACFileChanged != null)\n            {\n                PACFileChanged(this, new EventArgs());\n            }\n        }\n        private string GetPACAddress(byte[] requestBuf, IPEndPoint localEndPoint)\n        {
using Shadowsocks.Model;\nnamespace Shadowsocks.Controller\n{\n    class Local : Listener.Service\n    {\n        private Configuration _config;\n        public Local(Configuration config)\n        {\n            this._config = config;\n        }
using Shadowsocks.Controller;\nusing System.Threading;\nusing System.Collections.Generic;\nusing Shadowsocks.Model;\nusing System.Diagnostics;\nnamespace Shadowsocks.Test\n{\n    [TestClass]\n    public class UrlTest\n    {
        [TestMethod]\n        public void ParseAndGenerateShadowsocksUrl()\n        {\n            var server = new Server\n            {\n                server = "192.168.100.1",\n                server_port = 8888,\n                password = "test",\n                method = "bf-cfb"\n            };
                method = "bf-cfb"\n            };\n            var serverCanonUrl = "ss://YmYtY2ZiOnRlc3RAMTkyLjE2OC4xMDAuMTo4ODg4";\n            var server2 = new Server\n            {\n                server = "192.168.1.1",\n                server_port = 8388,\n                password = "test",\n                method = "bf-cfb"\n            };
            };\n            var server2CanonUrl = "ss://YmYtY2ZiOnRlc3RAMTkyLjE2OC4xLjE6ODM4OA==";\n            var serverWithRemark = new Server\n            {\n                server = server.server,\n                server_port = server.server_port,\n                password = server.password,\n                method = server.method,\n                remarks = "example-server"\n            };
            };\n            var serverWithRemarkCanonUrl = "ss://YmYtY2ZiOnRlc3RAMTkyLjE2OC4xMDAuMTo4ODg4#example-server";\n            var server2WithRemark = new Server\n            {\n                server = server2.server,\n                server_port = server2.server_port,\n                password = server2.password,\n                method = server2.method,\n                remarks = "example-server"\n            };
            var server2WithRemarkCanonUrl = "ss://YmYtY2ZiOnRlc3RAMTkyLjE2OC4xLjE6ODM4OA==#example-server";\n            var serverWithPlugin = new Server\n            {\n                server = server.server,\n                server_port = server.server_port,\n                password = server.password,\n                method = server.method,\n                plugin = "obfs-local",\n                plugin_opts = "obfs=http;obfs-host=google.com"\n            };
            {\n                server = server.server,\n                server_port = server.server_port,\n                password = server.password,\n                method = server.method,\n                plugin = "obfs-local",\n                plugin_opts = "obfs=http;obfs-host=google.com"\n            };\n            var serverWithPluginCanonUrl =\n                "ss://YmYtY2ZiOnRlc3Q@192.168.100.1:8888/?plugin=obfs-local%3bobfs%3dhttp%3bobfs-host%3dgoogle.com";
                "ss://YmYtY2ZiOnRlc3Q@192.168.100.1:8888/?plugin=obfs-local%3bobfs%3dhttp%3bobfs-host%3dgoogle.com";\n            var server2WithPlugin = new Server\n            {\n                server = server2.server,\n                server_port = server2.server_port,\n                password = server2.password,\n                method = server2.method,\n                plugin = "obfs-local",\n                plugin_opts = "obfs=http;obfs-host=google.com"\n            };
            {\n                server = server2.server,\n                server_port = server2.server_port,\n                password = server2.password,\n                method = server2.method,\n                plugin = "obfs-local",\n                plugin_opts = "obfs=http;obfs-host=google.com"\n            };\n            var server2WithPluginCanonUrl =\n                "ss://YmYtY2ZiOnRlc3Q@192.168.1.1:8388/?plugin=obfs-local%3bobfs%3dhttp%3bobfs-host%3dgoogle.com";
                server = server.server,\n                server_port = server.server_port,\n                password = server.password,\n                method = server.method,\n                plugin = serverWithPlugin.plugin,\n                plugin_opts = serverWithPlugin.plugin_opts,\n                remarks = serverWithRemark.remarks\n            };\n            var serverWithPluginAndRemarkCanonUrl =\n                "ss://YmYtY2ZiOnRlc3Q@192.168.100.1:8888/?plugin=obfs-local%3bobfs%3dhttp%3bobfs-host%3dgoogle.com#example-server";
            var server2WithPluginAndRemark = new Server\n            {\n                server = server2.server,\n                server_port = server2.server_port,\n                password = server2.password,\n                method = server2.method,\n                plugin = server2WithPlugin.plugin,\n                plugin_opts = server2WithPlugin.plugin_opts,\n                remarks = server2WithRemark.remarks\n            };
                server = server2.server,\n                server_port = server2.server_port,\n                password = server2.password,\n                method = server2.method,\n                plugin = server2WithPlugin.plugin,\n                plugin_opts = server2WithPlugin.plugin_opts,\n                remarks = server2WithRemark.remarks\n            };\n            var server2WithPluginAndRemarkCanonUrl =\n                "ss://YmYtY2ZiOnRlc3Q@192.168.1.1:8388/?plugin=obfs-local%3bobfs%3dhttp%3bobfs-host%3dgoogle.com#example-server";
            RunParseShadowsocksUrlTest(\n                string.Join(\n                    "\r\n",\n                    serverCanonUrl,\n                    "\r\n",\n                    "ss://YmYtY2ZiOnRlc3RAMTkyLjE2OC4xMDAuMTo4ODg4/",
using Shadowsocks.Controller.Service;\nusing System.Diagnostics;\nusing System.Net;\nnamespace Shadowsocks.Test\n{\n    [TestClass]\n    public class Sip003PluginTest\n    {\n        [TestMethod]
using System.Net;\nnamespace Shadowsocks.Test\n{\n    [TestClass]\n    public class Sip003PluginTest\n    {\n        [TestMethod]\n        public void Sip003PluginSupport()\n        {
using Shadowsocks.Model;\nusing Shadowsocks.Properties;\nusing Shadowsocks.Util;\nnamespace Shadowsocks.View\n{\n    public partial class HotkeySettingsForm : Form\n    {\n        private readonly ShadowsocksController _controller;\n        // this is a copy of hotkey configuration that we are working on\n        private HotkeyConfig _modifiedHotkeyConfig;
        private HotkeyConfig _modifiedHotkeyConfig;\n        private readonly IEnumerable<TextBox> _allTextBoxes;\n        public HotkeySettingsForm(ShadowsocksController controller)\n        {\n            InitializeComponent();\n            UpdateTexts();\n            Icon = Icon.FromHandle(Resources.ssw128.GetHicon());\n            _controller = controller;\n            _controller.ConfigChanged += controller_ConfigChanged;\n            LoadCurrentConfiguration();
                    sb.Append("Ctrl+");\n                }\n                if (e.Alt)\n                {\n                    sb.Append("Alt+");\n                }\n                if (e.Shift)\n                {\n                    sb.Append("Shift+");\n                }
                {\n                    sb.Append("Shift+");\n                }\n                TryRegHotkeyFromString(hotkeyConfig.SwitchSystemProxy, "SwitchSystemProxyCallback", SwitchSystemProxyLabel)\n                && TryRegHotkeyFromString(hotkeyConfig.SwitchSystemProxyMode, "SwitchProxyModeCallback", SwitchProxyModeLabel)\n                && TryRegHotkeyFromString(hotkeyConfig.SwitchAllowLan, "SwitchAllowLanCallback", SwitchAllowLanLabel)\n                && TryRegHotkeyFromString(hotkeyConfig.ShowLogs, "ShowLogsCallback", ShowLogsLabel)\n                && TryRegHotkeyFromString(hotkeyConfig.ServerMoveUp, "ServerMoveUpCallback", ServerMoveUpLabel)\n                && TryRegHotkeyFromString(hotkeyConfig.ServerMoveDown, "ServerMoveDownCallback", ServerMoveDownLabel);\n        }
        private bool TryRegHotkeyFromString(string hotkeyStr, string callbackName, Label indicator = null)\n        {\n            var _callback = HotkeyCallbacks.GetCallback(callbackName);\n            if (_callback == null)\n            {\n                throw new Exception($"{callbackName} not found");\n            }\n            var callback = _callback as HotKeys.HotKeyCallBackHandler;\n            if (hotkeyStr.IsNullOrEmpty())\n            {
            else\n            {\n                var hotkey = HotKeys.Str2HotKey(hotkeyStr);\n                if (hotkey == null)\n                {\n                    MessageBox.Show(string.Format(I18N.GetString("Cannot parse hotkey: {0}"), hotkeyStr));\n                    return false;\n                }\n                else\n                {
                {\n                    bool regResult = (TryRegHotkey(hotkey, callback));\n                    if (indicator != null)\n                    {\n                        indicator.BackColor = regResult ? Color.Green : Color.Yellow;\n                    }\n                    return regResult;\n                }\n            }\n        }
                {\n                    if (line.BeginWithAny(IgnoredLineBegins))\n                        continue;\n                    valid_lines.Add(line);\n                }\n            }\n            return valid_lines;\n        }\n        private static List<string> ParseToValidList(IList<DomainObject> domains)\n        {
        private static List<string> ParseToValidList(IList<DomainObject> domains)\n        {\n            List<string> ret = new List<string>(domains.Count + 100); // 100 overhead\n            foreach (var d in domains)\n            {\n                string domain = d.Value;\n                switch (d.Type)\n                {\n                    case DomainObject.Types.Type.Plain:
            _notifyIcon.MouseDoubleClick += notifyIcon1_DoubleClick;\n            this.updateChecker = new UpdateChecker();\n            updateChecker.CheckUpdateCompleted += updateChecker_CheckUpdateCompleted;\n            LoadCurrentConfiguration();\n            Configuration config = controller.GetConfigurationCopy();\n            if (config.autoCheckUpdate)\n            {\n                _isStartupChecking = true;
            this.tableLayoutPanel4.SuspendLayout();\n            this.SuspendLayout();\n            // \n            // tableLayoutPanel1\n            // \n            this.tableLayoutPanel1.AutoSize = true;\n            this.tableLayoutPanel1.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;\n            this.tableLayoutPanel1.ColumnCount = 2;\n            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());\n            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());
            this.tableLayoutPanel1.Controls.Add(this.EncryptionLabel, 0, 3);\n            this.tableLayoutPanel1.Controls.Add(this.EncryptionSelect, 1, 3);\n            this.tableLayoutPanel1.Controls.Add(this.TimeoutLabel, 0, 8);\n            this.tableLayoutPanel1.Controls.Add(this.TimeoutTextBox, 1, 8);\n            this.tableLayoutPanel1.Controls.Add(this.PluginLabel, 0, 4);\n            this.tableLayoutPanel1.Controls.Add(this.PluginOptionsTextBox, 1, 5);\n            this.tableLayoutPanel1.Location = new System.Drawing.Point(8, 21);\n            this.tableLayoutPanel1.Margin = new System.Windows.Forms.Padding(0);\n            this.tableLayoutPanel1.Name = "tableLayoutPanel1";\n            this.tableLayoutPanel1.Padding = new System.Windows.Forms.Padding(3);
        private bool _byHourOfDay = false;\n        private int _choiceKeptMinutes = 10;\n        private int _dataCollectionMinutes = 10;\n        private int _repeatTimesNum = 4;\n        private const string ConfigFile = "statistics-config.json";\n        public static StatisticsStrategyConfiguration Load()\n        {\n            try\n            {\n                var content = File.ReadAllText(ConfigFile);
        private int _repeatTimesNum = 4;\n        private const string ConfigFile = "statistics-config.json";\n        public static StatisticsStrategyConfiguration Load()\n        {\n            try\n            {\n                var content = File.ReadAllText(ConfigFile);\n                var configuration = SimpleJson.SimpleJson.DeserializeObject<StatisticsStrategyConfiguration>(content);\n                return configuration;\n            }
        private void InitializeComponent()\n        {\n            this.components = new System.ComponentModel.Container();\n            System.Windows.Forms.DataVisualization.Charting.ChartArea chartArea1 = new System.Windows.Forms.DataVisualization.Charting.ChartArea();\n            System.Windows.Forms.DataVisualization.Charting.Legend legend1 = new System.Windows.Forms.DataVisualization.Charting.Legend();\n            System.Windows.Forms.DataVisualization.Charting.Series series1 = new System.Windows.Forms.DataVisualization.Charting.Series();\n            System.Windows.Forms.DataVisualization.Charting.Series series2 = new System.Windows.Forms.DataVisualization.Charting.Series();\n            System.Windows.Forms.DataVisualization.Charting.Series series3 = new System.Windows.Forms.DataVisualization.Charting.Series();\n            this.StatisticsChart = new System.Windows.Forms.DataVisualization.Charting.Chart();\n            this.PingCheckBox = new System.Windows.Forms.CheckBox();
            System.Windows.Forms.DataVisualization.Charting.Series series3 = new System.Windows.Forms.DataVisualization.Charting.Series();\n            this.StatisticsChart = new System.Windows.Forms.DataVisualization.Charting.Chart();\n            this.PingCheckBox = new System.Windows.Forms.CheckBox();\n            this.bindingConfiguration = new System.Windows.Forms.BindingSource(this.components);\n            this.label2 = new System.Windows.Forms.Label();\n            this.label3 = new System.Windows.Forms.Label();\n            this.chartModeSelector = new System.Windows.Forms.GroupBox();\n            this.allMode = new System.Windows.Forms.RadioButton();\n            this.dayMode = new System.Windows.Forms.RadioButton();\n            this.splitContainer1 = new System.Windows.Forms.SplitContainer();\n            this.splitContainer2 = new System.Windows.Forms.SplitContainer();
            this.dayMode = new System.Windows.Forms.RadioButton();\n            this.splitContainer1 = new System.Windows.Forms.SplitContainer();\n            this.splitContainer2 = new System.Windows.Forms.SplitContainer();\n            this.label9 = new System.Windows.Forms.Label();\n            this.label8 = new System.Windows.Forms.Label();\n            this.dataCollectionMinutesNum = new System.Windows.Forms.NumericUpDown();\n            this.StatisticsEnabledCheckBox = new System.Windows.Forms.CheckBox();\n            this.choiceKeptMinutesNum = new System.Windows.Forms.NumericUpDown();\n            this.byHourOfDayCheckBox = new System.Windows.Forms.CheckBox();\n            this.repeatTimesNum = new System.Windows.Forms.NumericUpDown();
            this.splitContainer2 = new System.Windows.Forms.SplitContainer();\n            this.label9 = new System.Windows.Forms.Label();\n            this.label8 = new System.Windows.Forms.Label();\n            this.dataCollectionMinutesNum = new System.Windows.Forms.NumericUpDown();\n            this.StatisticsEnabledCheckBox = new System.Windows.Forms.CheckBox();\n            this.choiceKeptMinutesNum = new System.Windows.Forms.NumericUpDown();\n            this.byHourOfDayCheckBox = new System.Windows.Forms.CheckBox();\n            this.repeatTimesNum = new System.Windows.Forms.NumericUpDown();\n            this.label6 = new System.Windows.Forms.Label();\n            this.splitContainer3 = new System.Windows.Forms.SplitContainer();
            this.label6 = new System.Windows.Forms.Label();\n            this.splitContainer3 = new System.Windows.Forms.SplitContainer();\n            this.label1 = new System.Windows.Forms.Label();\n            this.calculationContainer = new System.Windows.Forms.FlowLayoutPanel();\n            this.serverSelector = new System.Windows.Forms.ComboBox();\n            this.CancelButton = new System.Windows.Forms.Button();\n            this.OKButton = new System.Windows.Forms.Button();\n            this.CalculatinTip = new System.Windows.Forms.ToolTip(this.components);\n            ((System.ComponentModel.ISupportInitialize)(this.StatisticsChart)).BeginInit();
            // \n            // chartModeSelector\n            // \n            this.chartModeSelector.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));\n            this.chartModeSelector.Controls.Add(this.allMode);\n            this.chartModeSelector.Controls.Add(this.dayMode);
            this.chartModeSelector.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));\n            this.chartModeSelector.Controls.Add(this.allMode);\n            this.chartModeSelector.Controls.Add(this.dayMode);\n            this.splitContainer2.Panel1.Controls.Add(this.label9);\n            this.splitContainer2.Panel1.Controls.Add(this.label8);\n            this.splitContainer2.Panel1.Controls.Add(this.dataCollectionMinutesNum);\n            this.splitContainer2.Panel1.Controls.Add(this.StatisticsEnabledCheckBox);\n            this.splitContainer2.Panel1.Controls.Add(this.choiceKeptMinutesNum);\n            this.splitContainer2.Panel1.Controls.Add(this.byHourOfDayCheckBox);\n            this.splitContainer2.Panel1.Controls.Add(this.repeatTimesNum);
            this.splitContainer2.Panel1.Controls.Add(this.label9);\n            this.splitContainer2.Panel1.Controls.Add(this.label8);\n            this.splitContainer2.Panel1.Controls.Add(this.dataCollectionMinutesNum);\n            this.splitContainer2.Panel1.Controls.Add(this.StatisticsEnabledCheckBox);\n            this.splitContainer2.Panel1.Controls.Add(this.choiceKeptMinutesNum);\n            this.splitContainer2.Panel1.Controls.Add(this.byHourOfDayCheckBox);\n            this.splitContainer2.Panel1.Controls.Add(this.repeatTimesNum);\n            this.splitContainer2.Panel1.Controls.Add(this.label6);\n            this.splitContainer2.Panel1.Controls.Add(this.label2);\n            this.splitContainer2.Panel1.Controls.Add(this.PingCheckBox);
            // \n            // splitContainer2.Panel2\n            // \n            this.splitContainer2.Panel2.Controls.Add(this.splitContainer3);
            // \n            // splitContainer2.Panel2\n            // \n            this.splitContainer2.Panel2.Controls.Add(this.splitContainer3);\n            this.splitContainer3.Panel1.Controls.Add(this.label1);\n            // \n            // splitContainer3.Panel2\n            // \n            this.splitContainer3.Panel2.Controls.Add(this.calculationContainer);
            // StatisticsStrategyConfigurationForm\n            // 
            this.splitContainer3.Panel1.ResumeLayout(false);\n            this.splitContainer3.Panel1.PerformLayout();\n            this.splitContainer3.Panel2.ResumeLayout(false);\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer3)).EndInit();\n            this.splitContainer3.ResumeLayout(false);\n            this.ResumeLayout(false);\n        }\n        #endregion\n        private System.Windows.Forms.DataVisualization.Charting.Chart StatisticsChart;\n        private System.Windows.Forms.CheckBox PingCheckBox;
        }\n        #endregion\n        private System.Windows.Forms.DataVisualization.Charting.Chart StatisticsChart;\n        private System.Windows.Forms.CheckBox PingCheckBox;\n        private System.Windows.Forms.Label label2;\n        private System.Windows.Forms.Label label3;\n        private System.Windows.Forms.GroupBox chartModeSelector;\n        private System.Windows.Forms.RadioButton allMode;\n        private System.Windows.Forms.RadioButton dayMode;\n        private System.Windows.Forms.SplitContainer splitContainer1;
        private System.Windows.Forms.Label label3;\n        private System.Windows.Forms.GroupBox chartModeSelector;\n        private System.Windows.Forms.RadioButton allMode;\n        private System.Windows.Forms.RadioButton dayMode;\n        private System.Windows.Forms.SplitContainer splitContainer1;\n        private System.Windows.Forms.Label label1;\n        private System.Windows.Forms.SplitContainer splitContainer2;\n        private System.Windows.Forms.FlowLayoutPanel calculationContainer;\n        private System.Windows.Forms.SplitContainer splitContainer3;\n        private System.Windows.Forms.NumericUpDown repeatTimesNum;
        private System.Windows.Forms.SplitContainer splitContainer1;\n        private System.Windows.Forms.Label label1;\n        private System.Windows.Forms.SplitContainer splitContainer2;\n        private System.Windows.Forms.FlowLayoutPanel calculationContainer;\n        private System.Windows.Forms.SplitContainer splitContainer3;\n        private System.Windows.Forms.NumericUpDown repeatTimesNum;\n        private System.Windows.Forms.Label label6;\n        private System.Windows.Forms.CheckBox byHourOfDayCheckBox;\n        private System.Windows.Forms.NumericUpDown choiceKeptMinutesNum;\n        private System.Windows.Forms.CheckBox StatisticsEnabledCheckBox;
                    this.editGFWUserRuleItem = CreateMenuItem("Edit User Rule for GFWList...", new EventHandler(this.EditUserRuleFileForGFWListItem_Click)),\n                    this.secureLocalPacUrlToggleItem = CreateMenuItem("Secure Local PAC", new EventHandler(this.SecureLocalPacUrlToggleItem_Click)),\n                    CreateMenuItem("Copy Local PAC URL", new EventHandler(this.CopyLocalPacUrlItem_Click)),\n                    this.editOnlinePACItem = CreateMenuItem("Edit Online PAC URL...", new EventHandler(this.UpdateOnlinePACURLItem_Click)),\n                }),\n                this.proxyItem = CreateMenuItem("Forward Proxy...", new EventHandler(this.proxyItem_Click)),\n                new MenuItem("-"),\n                this.AutoStartupItem = CreateMenuItem("Start on Boot", new EventHandler(this.AutoStartupItem_Click)),\n                this.ShareOverLANItem = CreateMenuItem("Allow Clients from LAN", new EventHandler(this.ShareOverLANItem_Click)),\n                new MenuItem("-"),
                    CreateMenuItem("Copy Local PAC URL", new EventHandler(this.CopyLocalPacUrlItem_Click)),\n                    this.editOnlinePACItem = CreateMenuItem("Edit Online PAC URL...", new EventHandler(this.UpdateOnlinePACURLItem_Click)),\n                }),\n                this.proxyItem = CreateMenuItem("Forward Proxy...", new EventHandler(this.proxyItem_Click)),\n                new MenuItem("-"),\n                this.AutoStartupItem = CreateMenuItem("Start on Boot", new EventHandler(this.AutoStartupItem_Click)),\n                this.ShareOverLANItem = CreateMenuItem("Allow Clients from LAN", new EventHandler(this.ShareOverLANItem_Click)),\n                new MenuItem("-"),\n                CreateMenuItem("Show Logs...", new EventHandler(this.ShowLogItem_Click)),\n                this.VerboseLoggingToggleItem = CreateMenuItem( "Verbose Logging", new EventHandler(this.VerboseLoggingToggleItem_Click) ),\n                this.hotKeyItem = CreateMenuItem("Edit Hotkeys...", new EventHandler(this.hotKeyItem_Click)),
                this.VerboseLoggingToggleItem = CreateMenuItem( "Verbose Logging", new EventHandler(this.VerboseLoggingToggleItem_Click) ),\n                this.hotKeyItem = CreateMenuItem("Edit Hotkeys...", new EventHandler(this.hotKeyItem_Click)),\n                CreateMenuGroup("Updates...", new MenuItem[] {\n                    CreateMenuItem("Check for Updates...", new EventHandler(this.checkUpdatesItem_Click)),\n                    new MenuItem("-"),\n                    this.autoCheckUpdatesToggleItem = CreateMenuItem("Check for Updates at Startup", new EventHandler(this.autoCheckUpdatesToggleItem_Click)),\n                    this.checkPreReleaseToggleItem = CreateMenuItem("Check Pre-release Version", new EventHandler(this.checkPreReleaseToggleItem_Click)),\n                }),
using System.Collections.Concurrent;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Text;\nusing System.Threading;\nusing System.Web;\nusing System.Windows.Forms;
using System.Net;\nusing System.Net.Sockets;\nusing System.Text;\nusing System.Threading;\nusing System.Web;\nusing System.Windows.Forms;\nusing Newtonsoft.Json;\nusing Shadowsocks.Controller.Strategy;\nusing Shadowsocks.Model;
using System.Net.Sockets;\nusing System.Text;\nusing System.Threading;\nusing System.Web;\nusing System.Windows.Forms;\nusing Newtonsoft.Json;\nusing Shadowsocks.Controller.Strategy;\nusing Shadowsocks.Model;\nusing Shadowsocks.Properties;\nusing Shadowsocks.Util;
            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                return false;\n            }\n        }\n        public void ToggleEnable(bool enabled)\n        {\n            _config.enabled = enabled;\n            SaveConfig(_config);
        public void ToggleEnable(bool enabled)\n        {\n            _config.enabled = enabled;\n            SaveConfig(_config);\n            if (EnableStatusChanged != null)\n            {\n                EnableStatusChanged(this, new EventArgs());\n            }\n        }\n        public void ToggleGlobal(bool global)\n        {\n            _config.global = global;\n            SaveConfig(_config);
        public void ToggleGlobal(bool global)\n        {\n            _config.global = global;\n            SaveConfig(_config);\n            if (EnableGlobalChanged != null)\n            {\n                EnableGlobalChanged(this, new EventArgs());\n            }\n        }\n        public void ToggleShareOverLAN(bool enabled)\n        {\n            _config.shareOverLan = enabled;\n            SaveConfig(_config);
        {\n            foreach (var serverAndPlugin in _pluginsByServer)\n            {\n                serverAndPlugin.Value?.Dispose();\n            }\n            _pluginsByServer.Clear();\n        }\n        public void TouchPACFile()\n        {\n            string pacFilename = _pacServer.TouchPACFile();
            _pluginsByServer.Clear();\n        }\n        public void TouchPACFile()\n        {\n            string pacFilename = _pacServer.TouchPACFile();\n            if (PACFileReadyToOpen != null)\n            {\n                PACFileReadyToOpen(this, new PathEventArgs() { Path = pacFilename });\n            }\n        }\n        public void TouchUserRuleFile()\n        {\n            string userRuleFilename = _pacServer.TouchUserRuleFile();
        }\n        public void UpdatePACFromGFWList()\n        {\n            if (gfwListUpdater != null)\n            {\n                gfwListUpdater.UpdatePACFromGFWList(_config);\n            }\n        }\n        public void UpdateStatisticsConfiguration(bool enabled)\n        {
            if (availabilityStatistics == null) return;\n            availabilityStatistics.UpdateConfiguration(this);\n            _config.availabilityStatistics = enabled;\n            SaveConfig(_config);\n        }\n        public void SavePACUrl(string pacUrl)\n        {\n            _config.pacUrl = pacUrl;\n            SaveConfig(_config);
        public void SavePACUrl(string pacUrl)\n        {\n            _config.pacUrl = pacUrl;\n            SaveConfig(_config);\n            if (ConfigChanged != null)\n            {\n                ConfigChanged(this, new EventArgs());\n            }\n        }\n        public void UseOnlinePAC(bool useOnlinePac)\n        {\n            _config.useOnlinePac = useOnlinePac;\n            SaveConfig(_config);
        public void UseOnlinePAC(bool useOnlinePac)\n        {\n            _config.useOnlinePac = useOnlinePac;\n            SaveConfig(_config);\n            if (ConfigChanged != null)\n            {\n                ConfigChanged(this, new EventArgs());\n            }\n        }\n        public void ToggleSecureLocalPac(bool enabled)\n        {\n            _config.secureLocalPac = enabled;\n            SaveConfig(_config);
        public void ToggleSecureLocalPac(bool enabled)\n        {\n            _config.secureLocalPac = enabled;\n            SaveConfig(_config);\n            if (ConfigChanged != null)\n            {\n                ConfigChanged(this, new EventArgs());\n            }\n        }\n        public void ToggleCheckingUpdate(bool enabled)\n        {\n            _config.autoCheckUpdate = enabled;\n            Configuration.Save(_config);
        public void ToggleCheckingUpdate(bool enabled)\n        {\n            _config.autoCheckUpdate = enabled;\n            Configuration.Save(_config);\n            if (ConfigChanged != null)\n            {\n                ConfigChanged(this, new EventArgs());\n            }\n        }\n        public void ToggleCheckingPreRelease(bool enabled)\n        {\n            _config.checkPreRelease = enabled;\n            Configuration.Save(_config);
        {\n            _config.checkPreRelease = enabled;\n            Configuration.Save(_config);\n            if (ConfigChanged != null)\n            {\n                ConfigChanged(this, new EventArgs());\n            }\n        }\n        public void SaveLogViewerConfig(LogViewerConfig newConfig)\n        {\n            _config.logViewer = newConfig;\n            newConfig.SaveSize();\n            Configuration.Save(_config);
        {\n            _config.logViewer = newConfig;\n            newConfig.SaveSize();\n            Configuration.Save(_config);\n            if (ConfigChanged != null)\n            {\n                ConfigChanged(this, new EventArgs());\n            }\n        }\n        public void SaveHotkeyConfig(HotkeyConfig newConfig)\n        {\n            _config.hotkey = newConfig;\n            SaveConfig(_config);
            // some logic in configuration updated the config when saving, we need to read it again\n            _config = Configuration.Load();\n            StatisticsConfiguration = StatisticsStrategyConfiguration.Load();\n            if (privoxyRunner == null)\n            {\n                privoxyRunner = new PrivoxyRunner();\n            }\n            if (_pacServer == null)\n            {\n                _pacServer = new PACServer();
            if (_pacServer == null)\n            {\n                _pacServer = new PACServer();\n                List<Listener.IService> services = new List<Listener.IService>();\n                services.Add(tcpRelay);\n                services.Add(udpRelay);\n                services.Add(_pacServer);\n                services.Add(new PortForwarder(privoxyRunner.RunningPort));\n                _listener = new Listener(services);\n                _listener.Start(_config);\n            }\n            catch (Exception e)\n            {\n                // translate Microsoft language into human language\n                // i.e. An attempt was made to access a socket in a way forbidden by its access permissions => Port already in use
        }\n        #endregion\n        #region Traffic Statistics\n        private void StartTrafficStatistics(int queueMaxSize)\n        {\n            trafficPerSecondQueue = new Queue<TrafficPerSecond>();\n            for (int i = 0; i < queueMaxSize; i++)\n            {\n                trafficPerSecondQueue.Enqueue(new TrafficPerSecond());\n            }
            _trafficThread = new Thread(new ThreadStart(() => TrafficStatistics(queueMaxSize)));\n            _trafficThread.IsBackground = true;\n            _trafficThread.Start();\n        }\n        private void TrafficStatistics(int queueMaxSize)\n        {\n            TrafficPerSecond previous, current;\n            while (true)\n            {\n                previous = trafficPerSecondQueue.Last();
            {\n                throw new ArgumentException("Too short!", nameof(delimiter));\n            }\n            if (maxLineBytes < _delimiterBytes.Length)\n            {\n                throw new ArgumentException("Too small!", nameof(maxLineBytes));\n            }\n            _delimiterSearchCharTable = MakeCharTable(_delimiterBytes);\n            _delimiterSearchOffsetTable = MakeOffsetTable(_delimiterBytes);\n            _lineBuffer = new byte[maxLineBytes];
        {\n        }\n        private void ReceiveCallback(IAsyncResult ar)\n        {\n            try\n            {\n                var bytesRead = _socket.EndReceive(ar);\n                if (bytesRead == 0)\n                {
        {\n            try\n            {\n                var bytesRead = _socket.EndReceive(ar);\n                if (bytesRead == 0)\n                {\n                    OnFinish();\n                    return;\n                }
                {\n                    OnFinish();\n                    return;\n                }\n                _bufferDataLength += bytesRead;\n                NewPackageRecv();\n            }\n            catch (Exception ex)\n            {\n                OnException(ex);
                OnException(ex);\n            {\n                Buffer.BlockCopy(_lineBuffer, _bufferDataIndex, _lineBuffer, 0, _bufferDataLength);\n                _bufferDataIndex = 0;\n            }\n            _socket.BeginReceive(_lineBuffer, _bufferDataLength, _lineBuffer.Length - _bufferDataLength, 0, ReceiveCallback, _bufferDataLength);\n        }\n        private void OnException(Exception ex)\n        {\n            _onException?.Invoke(ex, _state);\n        }
            _socket.BeginReceive(_lineBuffer, _bufferDataLength, _lineBuffer.Length - _bufferDataLength, 0, ReceiveCallback, _bufferDataLength);\n        }\n        private void OnException(Exception ex)\n        {\n            _onException?.Invoke(ex, _state);\n        }\n        private void OnFinish()\n        {\n            _onFinish?.Invoke(_lineBuffer, _bufferDataIndex, _bufferDataLength, _state);\n        }\n        #region Boyer-Moore string search
                {\n                    if (service.Handle(state.buffer, bytesRead, _udpSocket, state))\n                    {\n                        break;\n                    }\n                }\n            }\n            catch (ObjectDisposedException)\n            {\n            }
            handler.Receive();\n            return true;\n        }\n        public class UDPHandler\n        {\n            private Socket _local;\n            private Socket _remote;\n            private Server _server;\n            private byte[] _buffer = new byte[1500];\n            private IPEndPoint _localEndPoint;
            private Socket _remote;\n            private Server _server;\n            private byte[] _buffer = new byte[1500];\n            private IPEndPoint _localEndPoint;\n            private EndPoint _remoteEndPoint;\n            public UDPHandler(Socket local, Server server, IPEndPoint localEndPoint)\n            {\n                _local = local;\n                _server = server;\n                _localEndPoint = localEndPoint;
            Bitmap iconCopy = new Bitmap(originIcon);\n            for (int x = 0; x < iconCopy.Width; x++)\n            {\n                for (int y = 0; y < iconCopy.Height; y++)\n                {\n                    Color color = originIcon.GetPixel(x, y);\n                    if (color.A != 0 && color.R > 30)\n                    {\n                        if (!enabled)\n                        {
                {\n                    Color color = originIcon.GetPixel(x, y);\n                    if (color.A != 0 && color.R > 30)\n                    {\n                        if (!enabled)\n                        {\n                            iconCopy.SetPixel(x, y, Color.FromArgb(color.A, 234, 67, 53));\n                        }\n                        else if (global)\n                        {
                        if (!enabled)\n                        {\n                            iconCopy.SetPixel(x, y, Color.FromArgb(color.A, 234, 67, 53));\n                        }\n                        else if (global)\n                        {\n                            iconCopy.SetPixel(x, y, Color.FromArgb(color.A, 52, 168, 83));\n                        }\n                        else\n                        {
            if (country == null || city == null || isp == null) return null;\n            return new DataList {\n                new DataUnit(State.Geolocation, $"\"{country} {city}\""),\n                new DataUnit(State.ISP, $"\"{isp}\"")\n            };\n        }\n        private async Task<List<DataList>> ICMPTest(Server server)\n        {\n            Logging.Debug("Ping " + server.FriendlyName());\n            if (server.server == "") return null;
                new DataUnit(State.Geolocation, $"\"{country} {city}\""),\n                new DataUnit(State.ISP, $"\"{isp}\"")\n            };\n        }\n        private async Task<List<DataList>> ICMPTest(Server server)\n        {\n            Logging.Debug("Ping " + server.FriendlyName());\n            if (server.server == "") return null;\n            var IP = Dns.GetHostAddresses(server.server).First(ip => (ip.AddressFamily == AddressFamily.InterNetwork || ip.AddressFamily == AddressFamily.InterNetworkV6));\n            var ping = new Ping();\n            var ret = new List<DataList>();
                try\n                {\n                    var reply = await ping.SendTaskAsync(IP, Timeout);\n                    ret.Add(new List<KeyValuePair<string, string>>\n                    {\n                        new KeyValuePair<string, string>("Timestamp", timestamp),\n                        new KeyValuePair<string, string>("Server", server.FriendlyName()),\n                        new KeyValuePair<string, string>("Status", reply?.Status.ToString()),\n                        new KeyValuePair<string, string>("RoundtripTime", reply?.RoundtripTime.ToString())\n                        //new KeyValuePair<string, string>("data", reply.Buffer.ToString()); // The data of reply\n                    });
            var r = new FakeAsyncResult(state);\n            callback?.Invoke(r);\n        }\n        public void EndConnectProxy(IAsyncResult asyncResult)\n        {\n            // do nothing\n        }\n        public void BeginConnectDest(EndPoint destEndPoint, AsyncCallback callback, object state)\n        {\n            DestEndPoint = destEndPoint;
        {\n            // do nothing\n        }\n        public void BeginConnectDest(EndPoint destEndPoint, AsyncCallback callback, object state)\n        {\n            DestEndPoint = destEndPoint;\n            SocketUtil.BeginConnectTcp(destEndPoint, callback, state);\n        }\n        public void EndConnectDest(IAsyncResult asyncResult)\n        {
﻿using System;
﻿using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Text;\nusing System.Threading;\nusing Shadowsocks.Controller;
        public int EndReceive(IAsyncResult asyncResult)\n        {\n            return _remote.EndReceive(asyncResult);\n        }\n        public void Shutdown(SocketShutdown how)\n        {\n            _remote?.Shutdown(how);\n        }\n        public void Close()\n        {
        }\n        public void Close()\n        {\n            _remote?.Close();\n        }\n        private void ConnectCallback(IAsyncResult ar)\n        {\n            var state = (Socks5State) ar.AsyncState;\n            try\n            {
        }\n        private void aboutToolStripMenuItem_Click(object sender, EventArgs e)\n        {\n            Process.Start("https://github.com/clowwindy/shadowsocks-csharp");\n        }\n        private void notifyIcon1_DoubleClick(object sender, EventArgs e)\n        {\n            showWindow();\n        }
        private void aboutToolStripMenuItem_Click(object sender, EventArgs e)\n        {\n            Process.Start("https://github.com/clowwindy/shadowsocks-csharp");\n        }\n        private void notifyIcon1_DoubleClick(object sender, EventArgs e)\n        {\n            showWindow();\n        }\n        private void EnableItem_Click(object sender, EventArgs e)\n        {
        /// <summary>\n        ///   Looks up a localized resource of type System.Byte[].\n        /// </summary>\n        internal static byte[] polipo_exe {\n            get {\n                object obj = ResourceManager.GetObject("polipo_exe", resourceCulture);\n                return ((byte[])(obj));\n            }\n        }\n        /// <summary>
        /// </summary>\n        internal static byte[] polipo_exe {\n            get {\n                object obj = ResourceManager.GetObject("polipo_exe", resourceCulture);\n                return ((byte[])(obj));\n            }\n        }\n        /// <summary>\n        internal static string proxy_pac {\n            get {
        private void receiveCallback(IAsyncResult ar)\n        {\n            Socket conn = (Socket)ar.AsyncState;\n            try\n            {\n                int bytesRead = conn.EndReceive(ar);
            this.label1 = new System.Windows.Forms.Label();\n            this.label2 = new System.Windows.Forms.Label();\n            this.comboBox1 = new System.Windows.Forms.ComboBox();\n            this.label3 = new System.Windows.Forms.Label();\n            this.label4 = new System.Windows.Forms.Label();\n            this.textBox1 = new System.Windows.Forms.TextBox();\n            this.textBox2 = new System.Windows.Forms.TextBox();\n            this.textBox3 = new System.Windows.Forms.TextBox();\n            this.textBox4 = new System.Windows.Forms.TextBox();\n            this.notifyIcon1 = new System.Windows.Forms.NotifyIcon(this.components);
            this.textBox1 = new System.Windows.Forms.TextBox();\n            this.textBox2 = new System.Windows.Forms.TextBox();\n            this.textBox3 = new System.Windows.Forms.TextBox();\n            this.textBox4 = new System.Windows.Forms.TextBox();\n            this.notifyIcon1 = new System.Windows.Forms.NotifyIcon(this.components);\n            this.contextMenuStrip1 = new System.Windows.Forms.ContextMenuStrip(this.components);\n            this.ConfigItem = new System.Windows.Forms.ToolStripMenuItem();\n            this.aboutToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();\n            this.toolStripSeparator2 = new System.Windows.Forms.ToolStripSeparator();\n            this.QuitItem = new System.Windows.Forms.ToolStripMenuItem();\n            this.panel2 = new System.Windows.Forms.Panel();\n            this.button1 = new System.Windows.Forms.Button();\n            this.button2 = new System.Windows.Forms.Button();\n            this.panel1 = new System.Windows.Forms.Panel();
            this.textBox4 = new System.Windows.Forms.TextBox();\n            this.notifyIcon1 = new System.Windows.Forms.NotifyIcon(this.components);\n            this.aboutToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();\n            this.toolStripSeparator2 = new System.Windows.Forms.ToolStripSeparator();\n            this.QuitItem = new System.Windows.Forms.ToolStripMenuItem();\n            this.panel2 = new System.Windows.Forms.Panel();\n            this.button1 = new System.Windows.Forms.Button();\n            this.button2 = new System.Windows.Forms.Button();\n            this.panel1 = new System.Windows.Forms.Panel();\n            this.EnableItem = new System.Windows.Forms.ToolStripMenuItem();\n            this.tableLayoutPanel1.SuspendLayout();
            // \n            this.textBox4.Anchor = System.Windows.Forms.AnchorStyles.Left;\n            this.textBox4.Location = new System.Drawing.Point(69, 81);\n            this.textBox4.Name = "textBox4";\n            this.textBox4.Size = new System.Drawing.Size(124, 20);\n            this.textBox4.TabIndex = 7;\n            this.textBox4.WordWrap = false;\n            // \n            // notifyIcon1\n            // 
            this.textBox4.TabIndex = 7;\n            this.textBox4.WordWrap = false;\n            // \n            // notifyIcon1\n            // \n            this.notifyIcon1.ContextMenuStrip = this.contextMenuStrip1;\n            this.notifyIcon1.Icon = ((System.Drawing.Icon)(resources.GetObject("notifyIcon1.Icon")));\n            this.notifyIcon1.Text = "shadowsocks";\n            this.notifyIcon1.Visible = true;\n            this.notifyIcon1.DoubleClick += new System.EventHandler(this.notifyIcon1_DoubleClick);
        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel1;\n        private System.Windows.Forms.Label label1;\n        private System.Windows.Forms.Label label2;\n        private System.Windows.Forms.Label label3;\n        private System.Windows.Forms.Label label4;\n        private System.Windows.Forms.TextBox textBox1;\n        private System.Windows.Forms.TextBox textBox2;\n        private System.Windows.Forms.TextBox textBox3;\n        private System.Windows.Forms.TextBox textBox4;\n        private System.Windows.Forms.NotifyIcon notifyIcon1;
        private System.Windows.Forms.TextBox textBox3;\n        private System.Windows.Forms.TextBox textBox4;\n        private System.Windows.Forms.NotifyIcon notifyIcon1;\n        private System.Windows.Forms.ToolStripMenuItem ConfigItem;\n        private System.Windows.Forms.ToolStripMenuItem QuitItem;\n        private System.Windows.Forms.ToolStripMenuItem aboutToolStripMenuItem;\n        private System.Windows.Forms.ToolStripSeparator toolStripSeparator2;\n        private System.Windows.Forms.Label label5;\n        private System.Windows.Forms.ComboBox comboBox1;\n        private System.Windows.Forms.Panel panel2;\n        private System.Windows.Forms.Button button1;\n        private System.Windows.Forms.Button button2;\n        private System.Windows.Forms.Panel panel1;
            this.panel2 = new System.Windows.Forms.Panel();\n            this.button1 = new System.Windows.Forms.Button();\n            this.button2 = new System.Windows.Forms.Button();\n            this.panel1 = new System.Windows.Forms.Panel();\n            this.contextMenu1 = new System.Windows.Forms.ContextMenu();\n            this.enableItem = new System.Windows.Forms.MenuItem();\n            this.aboutItem = new System.Windows.Forms.MenuItem();\n            this.menuItem3 = new System.Windows.Forms.MenuItem();\n            this.quitItem = new System.Windows.Forms.MenuItem();
            this.tableLayoutPanel1.Controls.Add(this.label5, 0, 4);\n            this.tableLayoutPanel1.Controls.Add(this.label1, 0, 0);\n            this.tableLayoutPanel1.Controls.Add(this.label2, 0, 1);\n            this.tableLayoutPanel1.Controls.Add(this.comboBox1, 1, 4);\n            this.tableLayoutPanel1.Controls.Add(this.label3, 0, 2);\n            this.tableLayoutPanel1.Controls.Add(this.label4, 0, 3);\n            this.tableLayoutPanel1.Controls.Add(this.textBox1, 1, 0);\n            this.tableLayoutPanel1.Controls.Add(this.textBox2, 1, 1);\n            this.tableLayoutPanel1.Controls.Add(this.textBox3, 1, 2);\n            this.tableLayoutPanel1.Controls.Add(this.textBox4, 1, 3);
            // \n            this.menuItem3.Index = 3;\n            this.menuItem3.Text = "-";\n            // \n            // quitItem\n            // \n            this.quitItem.Index = 4;\n            this.quitItem.Text = "Quit";\n            this.quitItem.Click += new System.EventHandler(this.Quit_Click);\n            // 

            }\n        }\n        private void pacUrlForm_FormClosed(object sender, FormClosedEventArgs e)\n        {\n            pacUrlForm = null;\n            Util.Utils.ReleaseMemory();\n            ShowFirstTimeBalloon();\n        }\n        private void UpdateOnlinePACURLItem_Click(object sender, EventArgs e)\n        {
                if (File.Exists(PACServer.PAC_FILE))\n                {\n                    string original = FileManager.NonExclusiveReadAllText(PACServer.PAC_FILE, Encoding.UTF8);\n                    if (original == abpContent)\n                    {\n                        UpdateCompleted(this, new ResultEventArgs(false));\n                        return;\n                    }\n                }\n                File.WriteAllText(PACServer.PAC_FILE, abpContent, Encoding.UTF8);
                    {\n                        UpdateCompleted(this, new ResultEventArgs(false));\n                        return;\n                    }\n                }\n                File.WriteAllText(PACServer.PAC_FILE, abpContent, Encoding.UTF8);\n                if (UpdateCompleted != null)\n                {\n                    UpdateCompleted(this, new ResultEventArgs(true));\n                }\n            }\n            catch (Exception ex)\n            {

﻿using Shadowsocks.Properties;\nusing System;\nusing System.Collections.Generic;
using System.Text.RegularExpressions;\nnamespace Shadowsocks.Controller\n{\n    public class I18N\n    {\n        protected static Dictionary<string, string> Strings;\n        static I18N()\n        {\n            Strings = new Dictionary<string, string>();
{\n    public class I18N\n    {\n        protected static Dictionary<string, string> Strings;\n        static I18N()\n        {\n            Strings = new Dictionary<string, string>();\n            if (System.Globalization.CultureInfo.CurrentCulture.IetfLanguageTag.ToLowerInvariant().StartsWith("zh"))\n            {
    public class I18N\n    {\n        protected static Dictionary<string, string> Strings;\n        static I18N()\n        {\n            Strings = new Dictionary<string, string>();\n            if (System.Globalization.CultureInfo.CurrentCulture.IetfLanguageTag.ToLowerInvariant().StartsWith("zh"))\n            {\n                string[] lines = Regex.Split(Resources.cn, "\r\n|\r|\n");\n                foreach (string line in lines)\n                {
        static I18N()\n        {\n            Strings = new Dictionary<string, string>();\n            if (System.Globalization.CultureInfo.CurrentCulture.IetfLanguageTag.ToLowerInvariant().StartsWith("zh"))\n            {\n                string[] lines = Regex.Split(Resources.cn, "\r\n|\r|\n");\n                foreach (string line in lines)\n                {\n                    if (line.StartsWith("#"))\n                    {
        public static bool Check()\n        {\n            RegistryKey runKey = null;\n            try\n            {\n                string path = Application.ExecutablePath;\n                runKey = Registry.CurrentUser.OpenSubKey(@"Software\Microsoft\Windows\CurrentVersion\Run", true);\n                string[] runList = runKey.GetValueNames();\n                foreach (string item in runList)\n                {
            RegistryKey runKey = null;\n            try\n            {\n                string path = Application.ExecutablePath;\n                runKey = Registry.CurrentUser.OpenSubKey(@"Software\Microsoft\Windows\CurrentVersion\Run", true);\n                string[] runList = runKey.GetValueNames();\n                foreach (string item in runList)\n                {\n                    if (item == Key)\n                        return true;
                string path = Application.ExecutablePath;\n                runKey = Registry.CurrentUser.OpenSubKey(@"Software\Microsoft\Windows\CurrentVersion\Run", true);\n                string[] runList = runKey.GetValueNames();\n                foreach (string item in runList)\n                {\n                    if (item == Key)\n                        return true;\n                    else if (item == "Shadowsocks") // Compatibility with older versions\n                    {\n                        string value = Convert.ToString(runKey.GetValue(item));
                    if (n == 0)\n                    {\n                        throw new IOException("can not decompress pac");\n                    }\n                    return System.Text.Encoding.UTF8.GetString(buffer, 0, n);\n                }\n            }\n        }\n        private void ReceiveCallback(IAsyncResult ar)\n        {
        }\n        private void ReceiveCallback(IAsyncResult ar)\n        {\n            Socket conn = (Socket)ar.AsyncState;\n            try\n            {\n                int bytesRead = conn.EndReceive(ar);\n                string pac = GetPACContent();\n                IPEndPoint localEndPoint = (IPEndPoint)conn.LocalEndPoint;
            {\n                if (_oldSelectedIndex == -1 || _oldSelectedIndex >= _modifiedConfiguration.configs.Count)\n                {\n                    return true;\n                }\n                Server server = new Server\n                {\n                    server = IPTextBox.Text,\n                    server_port = int.Parse(ServerPortTextBox.Text),\n                    password = PasswordTextBox.Text,
using System.Collections.Generic;\nusing System.Text;\nusing System.Net.Sockets;\nusing System.Net;\nusing Shadowsocks.Encryption;\nusing Shadowsocks.Model;\nnamespace Shadowsocks.Controller\n{\n    class Local\n    {
using Shadowsocks.Model;\nnamespace Shadowsocks.Controller\n{\n    class Local\n    {\n        private Server _server;\n        private bool _shareOverLAN;\n        //private Encryptor encryptor;\n        Socket _listener;\n        public Local(Configuration config)\n        {
        public void Start()\n        {\n            try\n            {\n                // Create a TCP/IP socket.\n                _listener = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);\n                _listener.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, true);\n                IPEndPoint localEndPoint = null;\n                if (_shareOverLAN)\n                {
                // Create a TCP/IP socket.\n                _listener = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);\n                _listener.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, true);\n                IPEndPoint localEndPoint = null;\n                if (_shareOverLAN)\n                {\n                    localEndPoint = new IPEndPoint(IPAddress.Any, _server.local_port);\n                }\n                else\n                {
        private bool remoteShutdown = false;\n        private bool closed = false;\n        private object encryptionLock = new object();\n        private object decryptionLock = new object();\n        public void Start()\n        {\n            try\n            {\n                // TODO async resolving\n                IPAddress ipAddress;
        private object decryptionLock = new object();\n        public void Start()\n        {\n            try\n            {\n                // TODO async resolving\n                IPAddress ipAddress;\n                bool parsed = IPAddress.TryParse(config.server, out ipAddress);\n                if (!parsed)\n                {
            try\n            {\n                // TODO async resolving\n                IPAddress ipAddress;\n                bool parsed = IPAddress.TryParse(config.server, out ipAddress);\n                if (!parsed)\n                {\n                    IPHostEntry ipHostInfo = Dns.GetHostEntry(config.server);\n                    ipAddress = ipHostInfo.AddressList[0];\n                }
﻿using System;
﻿using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.IO;\nusing System.Linq;\nusing System.Net;
using System.Collections.Generic;\nusing System.Globalization;\nusing System.IO;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.NetworkInformation;\nusing System.Net.Sockets;\nusing System.Threading;\nusing System.Threading.Tasks;
using System.Threading;\nusing System.Threading.Tasks;\nusing Newtonsoft.Json;\nusing Newtonsoft.Json.Linq;\nusing Shadowsocks.Model;\nusing Shadowsocks.Util;\nnamespace Shadowsocks.Controller\n{\n    using DataUnit = KeyValuePair<string, string>;\n    using DataList = List<KeyValuePair<string, string>>;\n    using Statistics = Dictionary<string, List<AvailabilityStatistics.RawStatisticsData>>;
    using DataUnit = KeyValuePair<string, string>;\n    using DataList = List<KeyValuePair<string, string>>;\n    using Statistics = Dictionary<string, List<AvailabilityStatistics.RawStatisticsData>>;\n    //TODO: change to singleton\n    public class AvailabilityStatistics\n    {\n        public const string DateTimePattern = "yyyy-MM-dd HH:mm:ss";\n        private const string StatisticsFilesName = "shadowsocks.availability.csv";\n        private const string Delimiter = ",";
        public Statistics RawStatistics { get; private set; }\n        public Statistics FilteredStatistics { get; private set; }\n        public static readonly DateTime UnknownDateTime = new DateTime(1970, 1, 1);\n        private int Repeat => _config.RepeatTimesNum;
        public static readonly DateTime UnknownDateTime = new DateTime(1970, 1, 1);\n        private int Repeat => _config.RepeatTimesNum;\n        private readonly ShadowsocksController _controller;\n        private long _lastInboundCounter = 0;\n        private long _lastOutboundCounter = 0;
                }\n            }catch(Exception e)\n            {\n                Logging.Error($"An exception occured while eveluating {server.FriendlyName()}");\n                Logging.LogUsefulException(e);\n            }\n            return ret;\n        }\n        private string GetRecentOutboundSpeed(Server server)\n        {
                Logging.LogUsefulException(e);\n            }\n            return ret;\n        }\n        private string GetRecentOutboundSpeed(Server server)\n        {\n            if (server != _currentServer) return Empty;\n            return _outboundSpeed.ToString();\n        }\n        private string GetRecentInboundSpeed(Server server)\n        {
        {\n            if (server != _currentServer) return Empty;\n            return _inboundSpeed.ToString();\n        }\n        private string GetRecentLatency(Server server)\n        {\n            if (server != _currentServer) return Empty;\n            return _latency == null ? Empty : _latency.ToString();\n        }\n        private void ResetSpeed()\n        {
            _latency = null;\n            _inboundSpeed = 0;\n            _outboundSpeed = 0;\n        }\n        private void Run(object obj)\n        {
            _inboundSpeed = 0;\n            _outboundSpeed = 0;\n        }\n        private void Run(object obj)\n        {\n        internal void UpdateConfiguration(Configuration config, StatisticsStrategyConfiguration statisticsConfig)\n        {\n            Set(statisticsConfig);\n            _servers = config.configs;\n            ResetSpeed();
        }\n        public void SaveLogViewerConfig(LogViewerConfig newConfig)\n        {\n            _config.logViewer = newConfig;\n            Configuration.Save(_config);\n        }\n        public void UpdateLatency(Server server, TimeSpan latency)\n        {\n            if (_config.availabilityStatistics)\n            {
            if (_config.availabilityStatistics)\n            {\n                new Task(() => availabilityStatistics.UpdateLatency(server, (int)latency.TotalMilliseconds)).Start();\n            }\n        }\n        public void UpdateInboundCounter(Server server, long n)\n        {\n            Interlocked.Add(ref inboundCounter, n);\n            if (_config.availabilityStatistics)\n            {
            if (_config.availabilityStatistics)\n            {\n                new Task(() => availabilityStatistics.UpdateInboundCounter(server, n)).Start();\n            }\n        }\n        public void UpdateOutboundCounter(Server server, long n)\n        {\n            Interlocked.Add(ref outboundCounter, n);\n            if (_config.availabilityStatistics)\n            {
                _process.StartInfo.UseShellExecute = true;\n                _process.StartInfo.CreateNoWindow = true;\n                _process.Start();\n            }\n            RefreshTrayArea();\n        }\n        public void Stop()\n        {\n            if (_process != null)\n            {
        private void UpdateSpeed(object _)\n        {\n            foreach (var kv in _lastInboundCounter)\n            {\n                var id = kv.Key;\n                var lastInbound = kv.Value;\n                var inbound = _inboundCounter[id];\n                var bytes = inbound - lastInbound;\n                _lastInboundCounter[id] = inbound;\n                var inboundSpeed = GetSpeedInKiBPerSecond(bytes, _monitorInterval.TotalSeconds);
                var bytes = inbound - lastInbound;\n                _lastInboundCounter[id] = inbound;\n                var inboundSpeed = GetSpeedInKiBPerSecond(bytes, _monitorInterval.TotalSeconds);\n                _inboundSpeedRecords.GetOrAdd(id, new List<int> {inboundSpeed}).Add(inboundSpeed);\n                var lastOutbound = _lastOutboundCounter[id];\n                var outbound = _outboundCounter[id];\n                bytes = outbound - lastOutbound;\n                _lastOutboundCounter[id] = outbound;\n                var outboundSpeed = GetSpeedInKiBPerSecond(bytes, _monitorInterval.TotalSeconds);
                var lastOutbound = _lastOutboundCounter[id];\n                var outbound = _outboundCounter[id];\n                bytes = outbound - lastOutbound;\n                _lastOutboundCounter[id] = outbound;\n                var outboundSpeed = GetSpeedInKiBPerSecond(bytes, _monitorInterval.TotalSeconds);\n                _outboundSpeedRecords.GetOrAdd(id, new List<int> {outboundSpeed}).Add(outboundSpeed);\n                Logging.Debug(\n                    $"{id}: current/max inbound {inboundSpeed}/{_inboundSpeedRecords[id].Max()} KiB/s, current/max outbound {outboundSpeed}/{_outboundSpeedRecords[id].Max()} KiB/s");\n            }
        }\n        private void Reset()\n        {\n            _inboundSpeedRecords.Clear();\n            _outboundSpeedRecords.Clear();\n            _latencyRecords.Clear();\n        }\n        private void Run(object _)\n        {\n            UpdateRecords();
        {\n            _inboundSpeedRecords.Clear();\n            _outboundSpeedRecords.Clear();\n            _latencyRecords.Clear();\n        }\n        private void Run(object _)\n        {\n            UpdateRecords();\n            Save();\n            Reset();
                List<int> latencyRecords = null;\n                _inboundSpeedRecords.TryGetValue(id, out inboundSpeedRecords);\n                _outboundSpeedRecords.TryGetValue(id, out outboundSpeedRecords);\n                _latencyRecords.TryGetValue(id, out latencyRecords);\n                StatisticsRecord record = new StatisticsRecord(id, inboundSpeedRecords, outboundSpeedRecords, latencyRecords);\n                /* duplicate server identifier */\n                if (records.ContainsKey(id))\n                    records[id] = record;\n                else\n                    records.Add(id, record);
                    records[result.Server.Identifier()].SetResponse(result.RoundtripTime);\n                }\n            }\n            foreach (var kv in records.Where(kv => !kv.Value.IsEmptyData()))\n            {\n                AppendRecord(kv.Key, kv.Value);\n            }\n        }\n        private void AppendRecord(string serverIdentifier, StatisticsRecord record)\n        {
        }\n        private void Save()\n        {\n            if (RawStatistics.Count == 0)\n            {\n                return;\n            }\n            try\n            {
            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Console.WriteLine($"failed to load statistics; try to reload {_retryInterval.TotalMinutes} minutes later");\n                _recorder.Change(_retryInterval, RecordingInterval);\n            }\n        }\n        private static int GetSpeedInKiBPerSecond(long bytes, double seconds)\n        {
        {\n                Server = server;\n            }\n        }\n        public void Dispose()\n        {\n            _recorder.Dispose();\n            _speedMonior.Dispose();\n        }\n        public void UpdateLatency(Server server, int latency)\n        {
            _latencyRecords.TryGetValue(server.Identifier(), out records);\n            if (records == null)\n            {\n                records = new List<int>();\n            }\n            records.Add(latency);\n            _latencyRecords[server.Identifier()] = records;\n        }\n        public void UpdateInboundCounter(Server server, long n)\n        {
        public void UpdateInboundCounter(Server server, long n)\n        {\n            }\n            else\n            {\n                count = n;\n                _lastInboundCounter[server.Identifier()] = 0;\n            }\n            _inboundCounter[server.Identifier()] = count;\n        }\n        public void UpdateOutboundCounter(Server server, long n)\n        {
        public static string[] Args { get; private set; }\n        /// <summary>\n        /// 应用程序的主入口点。\n        /// </summary>\n        /// </summary>\n        [STAThread]\n        static void Main(string[] args)\n        {\n            // .NET Framework 4.7.2 on Win7 compatibility\n#if DEBUG
        /// </summary>\n        [STAThread]\n        static void Main(string[] args)\n        {\n            // .NET Framework 4.7.2 on Win7 compatibility\n#if DEBUG\n                Logging.OpenLogFile();\n                // truncate privoxy log file while debugging\n                string privoxyLogFilename = Utils.GetTempPath("privoxy.log");\n                if (File.Exists(privoxyLogFilename))\n                    using (new FileStream(privoxyLogFilename, FileMode.Truncate)) { }
        }\n        protected void SaveConfig(Configuration newConfig)\n        {\n            Configuration.Save(newConfig);\n            Reload();\n        }\n        private void UpdateSystemProxy()\n        {\n            if (_config.enabled)\n            {
        {\n            if (_config.enabled)\n            {\n                SystemProxy.Update(_config, false);\n                _systemProxyIsDirty = true;\n            }\n            else\n            {\n                // only switch it off if we have switched it on\n                if (_systemProxyIsDirty)\n                {
using System.Globalization;\nusing System.IO;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Text;\nusing Shadowsocks.Model;\nusing Shadowsocks.Properties;\nusing Shadowsocks.Util;\nnamespace Shadowsocks.Controller\n{
                return PAC_FILE;\n            }\n        }\n        public void AcceptCallback(IAsyncResult ar)\n        {\n            Socket listener = (Socket)ar.AsyncState;\n            try\n            {\n                Socket conn = listener.EndAccept(ar);
        public void AcceptCallback(IAsyncResult ar)\n        {\n            Socket listener = (Socket)ar.AsyncState;\n            try\n            {\n                Socket conn = listener.EndAccept(ar);\n                byte[] buf = new byte[2048];\n                object[] state = new object[] {\n                    conn,
        {\n            Socket listener = (Socket)ar.AsyncState;\n            try\n            {\n                Socket conn = listener.EndAccept(ar);\n                byte[] buf = new byte[2048];\n                object[] state = new object[] {\n                    conn,\n                    buf\n                };
        }\n        private string GetPACContent()\n        {\n            if (File.Exists(PAC_FILE))\n            {\n                return File.ReadAllText(PAC_FILE, Encoding.UTF8);\n            }\n            else\n            {\n                byte[] pacGZ = Resources.proxy_pac_txt;
            }\n            else\n            {\n                byte[] pacGZ = Resources.proxy_pac_txt;\n                byte[] buffer = new byte[1024 * 1024];  // builtin pac gzip size: maximum 1M\n                int n;\n                using (GZipStream input = new GZipStream(new MemoryStream(pacGZ),\n                    CompressionMode.Decompress, false))\n                {
            {\n                byte[] pacGZ = Resources.proxy_pac_txt;\n                byte[] buffer = new byte[1024 * 1024];  // builtin pac gzip size: maximum 1M\n                int n;\n                using (GZipStream input = new GZipStream(new MemoryStream(pacGZ),\n                    CompressionMode.Decompress, false))\n                {\n                    n = input.Read(buffer, 0, buffer.Length);\n                    if (n == 0)\n                    {
                byte[] buffer = new byte[1024 * 1024];  // builtin pac gzip size: maximum 1M\n                int n;\n                using (GZipStream input = new GZipStream(new MemoryStream(pacGZ),\n                    CompressionMode.Decompress, false))\n                {\n                    n = input.Read(buffer, 0, buffer.Length);\n                    if (n == 0)\n                    {\n                        throw new IOException("can not decompress pac");\n                    }
            _remote.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n        }\n        private const string HTTP_CRLF = "\r\n";\n        private const string HTTP_CONNECT_TEMPLATE = \n            "CONNECT {0} HTTP/1.1" + HTTP_CRLF + \n            "Host: {0}" + HTTP_CRLF +\n            "Proxy-Connection: keep-alive" + HTTP_CRLF +\n            "User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.121 Safari/537.36" + HTTP_CRLF +\n            "" + HTTP_CRLF; // End with an empty line
            "CONNECT {0} HTTP/1.1" + HTTP_CRLF + \n            "Host: {0}" + HTTP_CRLF +\n            "Proxy-Connection: keep-alive" + HTTP_CRLF +\n            "User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.121 Safari/537.36" + HTTP_CRLF +\n            "" + HTTP_CRLF; // End with an empty line\n        public void BeginConnectDest(EndPoint destEndPoint, AsyncCallback callback, object state)\n        {\n            DestEndPoint = destEndPoint;
                connectTimer.Enabled = true;\n                connectTimer.Session = session;\n                connectTimer.Server = server;\n                _destConnected = false;\n                // Connect to the remote endpoint.\n                remote.BeginConnectDest(destEndPoint, ConnectCallback,
            }\n            else\n            {\n                ProxyServerTextBox.Enabled =\n                ProxyPortTextBox.Enabled =\n                ProxyTimeoutTextBox.Enabled =
            MyCancelButton.Text = I18N.GetString("Cancel");\n            this.Text = I18N.GetString("Edit Proxy");\n        }\n        private void controller_ConfigChanged(object sender, EventArgs e)\n        {\n            LoadCurrentConfiguration();\n        }\n        private void LoadCurrentConfiguration()\n        {\n            _modifiedConfiguration = controller.GetConfigurationCopy().proxy;
            this.Close();\n        }\n        private void CancelButton_Click(object sender, EventArgs e)\n        {\n            this.Close();\n        }\n        private void ProxyForm_FormClosed(object sender, FormClosedEventArgs e)\n        {\n            controller.ConfigChanged -= controller_ConfigChanged;
        }\n        [DllImport("Kernel32.dll")]\n        private static extern IntPtr LoadLibrary(string path);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int crypto_stream_salsa20_xor_ic(byte[] c, byte[] m, ulong mlen, byte[] n, ulong ic, byte[] k);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int crypto_stream_chacha20_xor_ic(byte[] c, byte[] m, ulong mlen, byte[] n, ulong ic, byte[] k);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int crypto_stream_chacha20_ietf_xor_ic(byte[] c, byte[] m, ulong mlen, byte[] n, uint ic, byte[] k);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
        {\n            Dispose(true);\n            GC.SuppressFinalize(this);\n        }\n        ~MbedTLSEncryptor()\n        {\n            Dispose(false);\n        }\n        protected virtual void Dispose(bool disposing)\n        {
        {\n            Dispose(false);\n        }\n        protected virtual void Dispose(bool disposing)\n        {\n                if (_disposed)\n                {\n                    return;\n                }\n                _disposed = true;\n            }\n            if (disposing)\n            {
                }\n            }\n        }\n        public void Dispose()\n        {\n            Dispose(true);\n            GC.SuppressFinalize(this);\n        }\n        private void Dispose(bool disposing)\n        {
        {\n            Dispose(true);\n            GC.SuppressFinalize(this);\n        }\n        private void Dispose(bool disposing)\n        {\n            if (disposed)\n                return;\n            if (disposing) { }\n            Close();
            GC.SuppressFinalize(this);\n        }\n        private void Dispose(bool disposing)\n        {\n            if (disposed)\n                return;\n            if (disposing) { }\n            Close();\n            disposed = true;\n        }
        private void Dispose(bool disposing)\n        {\n            if (disposed)\n                return;\n            if (disposing) { }\n            Close();\n            disposed = true;\n        }\n        public void Close()\n        {
            => (AverageResponse == null) && (MinResponse == null) && (MaxResponse == null) && (PackageLoss == null);\n        public bool IsEmptyData() {\n            return EmptyInboundSpeedData && EmptyOutboundSpeedData && EmptyResponseData && EmptyLatencyData;\n        }\n        public StatisticsRecord()\n        {\n        }\n        public StatisticsRecord(string identifier, ICollection<int> inboundSpeedRecords, ICollection<int> outboundSpeedRecords, ICollection<int> latencyRecords)\n        {\n            ServerIdentifier = identifier;
        }\n        public StatisticsRecord()\n        {\n        }\n        public StatisticsRecord(string identifier, ICollection<int> inboundSpeedRecords, ICollection<int> outboundSpeedRecords, ICollection<int> latencyRecords)\n        {\n            ServerIdentifier = identifier;\n            if (inboundSpeedRecords != null && inboundSpeedRecords.Any())\n            {
        public StatisticsRecord(string identifier, ICollection<int> inboundSpeedRecords, ICollection<int> outboundSpeedRecords, ICollection<int> latencyRecords)\n        {\n            ServerIdentifier = identifier;\n            if (inboundSpeedRecords != null && inboundSpeedRecords.Any())\n            {\n                AverageInboundSpeed = (int) inboundSpeedRecords.Average();\n                MinInboundSpeed = inboundSpeedRecords.Min();\n                MaxInboundSpeed = inboundSpeedRecords.Max();\n            }
            if (inboundSpeedRecords != null && inboundSpeedRecords.Any())\n            {\n                AverageInboundSpeed = (int) inboundSpeedRecords.Average();\n                MinInboundSpeed = inboundSpeedRecords.Min();\n                MaxInboundSpeed = inboundSpeedRecords.Max();\n            }\n            if (outboundSpeedRecords != null && outboundSpeedRecords.Any())\n            {
                MinInboundSpeed = inboundSpeedRecords.Min();\n                MaxInboundSpeed = inboundSpeedRecords.Max();\n            }\n            if (outboundSpeedRecords != null && outboundSpeedRecords.Any())\n            {\n                AverageOutboundSpeed = (int) outboundSpeedRecords.Average();\n                MinOutboundSpeed = outboundSpeedRecords.Min();\n                MaxOutboundSpeed = outboundSpeedRecords.Max();\n            }
            if (outboundSpeedRecords != null && outboundSpeedRecords.Any())\n            {\n                AverageOutboundSpeed = (int) outboundSpeedRecords.Average();\n                MinOutboundSpeed = outboundSpeedRecords.Min();\n                MaxOutboundSpeed = outboundSpeedRecords.Max();\n            }\n            if (latencyRecords != null && latencyRecords.Any())\n            {
                StatisticsChart.ChartAreas["DataArea"].AxisX.LabelStyle.Format = "HH:00";\n                StatisticsChart.ChartAreas["DataArea"].AxisX2.LabelStyle.Format = "HH:00";\n            }\n            var finalData = from dataGroup in dataGroups\n                            orderby dataGroup.Key\n                            select new\n                            {\n                                dataGroup.First().Timestamp,\n                                Speed = dataGroup.Max(data => data.MaxInboundSpeed) ?? 0,\n                                Ping = (int) (dataGroup.Average(data => data.AverageResponse) ?? 0),
            }\n            var finalData = from dataGroup in dataGroups\n                            orderby dataGroup.Key\n                            select new\n                            {\n                                dataGroup.First().Timestamp,\n                                Speed = dataGroup.Max(data => data.MaxInboundSpeed) ?? 0,\n                                Ping = (int) (dataGroup.Average(data => data.AverageResponse) ?? 0),\n                                PackageLossPercentage = (dataGroup.Average(data => data.PackageLoss) ?? 0) * 100\n                            };
﻿using System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.IO;\nusing System.Linq;\nusing System.Net;
﻿using System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.IO;\nusing System.Linq;\nusing System.Net;\nusing System.Text;\nusing Shadowsocks.Model;\nusing System.IO;\nusing System.Net.NetworkInformation;
using System.Collections.Generic;\nusing System.Globalization;\nusing System.IO;\nusing System.Linq;\nusing System.Net;\nusing System.Text;\nusing Shadowsocks.Model;\nusing System.IO;\nusing System.Net.NetworkInformation;\nusing System.Windows.Forms;\nusing Newtonsoft.Json;\nusing Shadowsocks.Model;
using System.Linq;\nusing System.Net;\nusing System.Text;\nusing Shadowsocks.Model;\nusing System.IO;\nusing System.Net.NetworkInformation;\nusing System.Windows.Forms;\nusing Newtonsoft.Json;\nusing Shadowsocks.Model;\nusing Timer = System.Threading.Timer;\nnamespace Shadowsocks.Controller.Strategy\n{
using Shadowsocks.Model;\nusing Timer = System.Threading.Timer;\nnamespace Shadowsocks.Controller.Strategy\n{\n    using DataUnit = KeyValuePair<string, string>;\n    using DataList = List<KeyValuePair<string, string>>;\n    class StatisticsStrategy : IStrategy\n    {\n        private readonly ShadowsocksController _controller;\n        private Server _currentServer;\n        private readonly Timer _timer;
{\n    using DataUnit = KeyValuePair<string, string>;\n    using DataList = List<KeyValuePair<string, string>>;\n    class StatisticsStrategy : IStrategy\n    {\n        private readonly ShadowsocksController _controller;\n        private Server _currentServer;\n        private readonly Timer _timer;\n        private Dictionary<string, List<StatisticsRawData>> _rawStatistics;\n        private int ChoiceKeptMilliseconds\n            => (int) TimeSpan.FromMinutes(_controller.StatisticsConfiguration.ChoiceKeptMinutes).TotalMilliseconds;
        }\n        private void ReloadStatisticsAndChooseAServer(object obj)\n        {\n            Logging.Debug("Reloading statistics and choose a new server....");\n            var servers = _controller.GetCurrentConfiguration().configs;\n            LoadStatistics();\n            ChooseNewServer(servers);\n        }\n        private void LoadStatistics()\n        {
        {\n            Logging.Debug("Reloading statistics and choose a new server....");\n            var servers = _controller.GetCurrentConfiguration().configs;\n            LoadStatistics();\n            ChooseNewServer(servers);\n        }\n        private void LoadStatistics()\n        {\n                    {\n                        ServerName = server.Key,\n                        data = server.ToList()\n                    }).ToDictionary(server => server.ServerName, server=> server.data);\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n            }\n        }\n        //return the score by data\n        //server with highest score will be choosen
            LoadStatistics();\n            ChooseNewServer(servers);\n        }\n        private void LoadStatistics()\n        {\n                    }).ToDictionary(server => server.ServerName, server=> server.data);\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n            }\n        }\n        //return the score by data\n        //server with highest score will be choosen\n        private float GetScore(IEnumerable<StatisticsRawData> rawDataList)\n        {\n            var config = _controller.StatisticsConfiguration;
        {\n                Logging.LogUsefulException(e);\n            }\n        }\n        //return the score by data\n        //server with highest score will be choosen\n        private float GetScore(IEnumerable<StatisticsRawData> rawDataList)\n        {\n            var config = _controller.StatisticsConfiguration;\n                        DateTimeStyles.None, out dateTime);\n                    var result = dateTime.Hour.Equals(currentHour);\n                    return result;\n                });\n                if (rawDataList.LongCount() == 0) return 0; \n            }\n            var dataList = rawDataList as IList<StatisticsRawData> ?? rawDataList.ToList();\n            var serverName = dataList[0]?.ServerName;\n            var SuccessTimes = (float) dataList.Count(data => data.ICMPStatus.Equals(IPStatus.Success.ToString()));\n            var TimedOutTimes = (float) dataList.Count(data => data.ICMPStatus.Equals(IPStatus.TimedOut.ToString()));
            {
            {\n        }\n        public class StatisticsData\n        {\n            public float PackageLoss;\n            public int AverageResponse;\n            public int MinResponse;\n            public int MaxResponse;\n        }\n        private void ChooseNewServer(List<Server> servers)\n        {
        private void ChooseNewServer(List<Server> servers)\n        {\n            if (_rawStatistics == null || servers.Count == 0)\n            {\n                return;\n            }\n            try\n            {\n                var bestResult = (from server in servers\n                                  let name = server.FriendlyName()
                return;\n            }\n            try\n            {\n                var bestResult = (from server in servers\n                                  let name = server.FriendlyName()\n                                  where _rawStatistics.ContainsKey(name)\n                                  select new\n                                  {\n                                      server,
﻿using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Net;
using System.IO;\nusing System.Linq;\nusing System.Net;\nusing SimpleJson;\nusing System.Net.Http;\nusing System.Net.NetworkInformation;\nusing System.Net.Sockets;\nusing System.Threading;\nusing System.Threading.Tasks;
using System.Net;\nusing SimpleJson;\nusing System.Net.Http;\nusing System.Net.NetworkInformation;\nusing System.Net.Sockets;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing System.Windows.Forms;\nusing Shadowsocks.Model;\nusing Shadowsocks.Util;
using System.Threading;\nusing System.Threading.Tasks;\nusing System.Windows.Forms;\nusing Shadowsocks.Model;\nusing Shadowsocks.Util;\nusing Timer = System.Threading.Timer;\nnamespace Shadowsocks.Controller\n{\n    using DataUnit = KeyValuePair<string, string>;\n    using DataList = List<KeyValuePair<string, string>>;
            this.choiceKeptMinutesNum = new System.Windows.Forms.NumericUpDown();\n            this.byHourOfDayCheckBox = new System.Windows.Forms.CheckBox();\n            this.repeatTimesNum = new System.Windows.Forms.NumericUpDown();\n            this.label6 = new System.Windows.Forms.Label();\n            this.splitContainer3 = new System.Windows.Forms.SplitContainer();\n            this.label1 = new System.Windows.Forms.Label();\n            this.calculationContainer = new System.Windows.Forms.FlowLayoutPanel();\n            this.serverSelector = new System.Windows.Forms.ComboBox();\n            this.CancelButton = new System.Windows.Forms.Button();\n            this.OKButton = new System.Windows.Forms.Button();
            foreach (string method in StreamMbedTLSEncryptor.SupportedCiphers())\n            {\n                _registeredEncryptors.Add(method, typeof(StreamMbedTLSEncryptor));\n            }\n            foreach (string method in StreamSodiumEncryptor.SupportedCiphers())\n            {\n                _registeredEncryptors.Add(method, typeof(StreamSodiumEncryptor));\n            }
                _registeredEncryptors.Add(method, typeof(StreamMbedTLSEncryptor));\n            }\n            foreach (string method in StreamSodiumEncryptor.SupportedCiphers())\n            {\n                _registeredEncryptors.Add(method, typeof(StreamSodiumEncryptor));\n            }\n            foreach (string method in AEADMbedTLSEncryptor.SupportedCiphers())\n            {\n                _registeredEncryptors.Add(method, typeof(AEADMbedTLSEncryptor));\n            }
                    SocketType.Stream, ProtocolType.Tcp);\n                remote.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n                _startConnectTime = DateTime.Now;\n                // Connect to the remote endpoint.\n                remote.BeginConnect(remoteEP,
                    new AsyncCallback(ConnectCallback), null);\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                this.Close();\n            }\n        }\n        private void ConnectCallback(IAsyncResult ar)\n        {
            if (closed)\n            {\n                return;\n            }\n            try\n            {\n                // Complete the connection.\n                remote.EndConnect(ar);\n                //Console.WriteLine("Socket connected to {0}",\n                //    remote.RemoteEndPoint.ToString());\n                var latency = DateTime.Now - _startConnectTime;
                return;\n            }\n            try\n            {\n                // Complete the connection.\n                remote.EndConnect(ar);\n                //Console.WriteLine("Socket connected to {0}",\n                //    remote.RemoteEndPoint.ToString());\n                var latency = DateTime.Now - _startConnectTime;\n                controller.GetCurrentStrategy().UpdateLatency(this.server, latency);\n                StartPipe();\n            }
            {\n                MessageBox.Show("can not change registry!");\n                throw;\n            }\n        }\n        private static void CopyProxySettingFromLan()\n        {\n            RegistryKey registry =\n                Registry.CurrentUser.OpenSubKey("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Connections",\n                    true);
        private static void CopyProxySettingFromLan()\n        {\n            RegistryKey registry =\n                Registry.CurrentUser.OpenSubKey("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Connections",\n                    true);\n            var defulatValue = registry.GetValue("DefaultConnectionSettings");\n            var connections = registry.GetValueNames();\n            foreach (String each in connections){\n                if (!(each.Equals("DefaultConnectionSettings")\n                    || each.Equals("LAN Connection")\n                    || each.Equals("SavedLegacySettings")))\n                {
                    || each.Equals("SavedLegacySettings")))\n                {\n                    //set all the connections's proxy as the lan\n                    registry.SetValue(each, defulatValue);\n                }\n            }
        }\n        private void QRCodeItem_Click(object sender, EventArgs e)\n        {\n            QRCodeForm qrCodeForm = new QRCodeForm(controller.GetQRCodeForCurrentServer());\n            //qrCodeForm.Icon = this.Icon;\n            // TODO\n            qrCodeForm.Show();\n        }\n        private void ScanQRCodeItem_Click(object sender, EventArgs e)\n        {
            // TODO\n            qrCodeForm.Show();\n        }\n        private void ScanQRCodeItem_Click(object sender, EventArgs e)\n        {\n                using (Graphics g = Graphics.FromImage(bmpScreenCapture))\n                {\n                    g.CopyFromScreen(Screen.PrimaryScreen.Bounds.X,\n                                     Screen.PrimaryScreen.Bounds.Y,\n                                     0, 0,
        private void ScanQRCodeItem_Click(object sender, EventArgs e)\n        {\n                using (Graphics g = Graphics.FromImage(bmpScreenCapture))\n                {\n                    g.CopyFromScreen(Screen.PrimaryScreen.Bounds.X,\n                                     Screen.PrimaryScreen.Bounds.Y,\n                                     0, 0,\n                                     bmpScreenCapture.Size,\n                                     CopyPixelOperation.SourceCopy);\n                }
                resultPoints.Clear();\n             /*   var reader = new BarcodeReader\n                {\n                    PossibleFormats = new List<BarcodeFormat>
                {\n                    PossibleFormats = new List<BarcodeFormat>\n                var result = barcodeReader.Decode(image);\n                var timerStart = DateTime.Now.Ticks;\n                var timerStop = DateTime.Now.Ticks;\n                if (result == null)\n                {
                    PossibleFormats = new List<BarcodeFormat>\n                var result = barcodeReader.Decode(image);\n                var timerStart = DateTime.Now.Ticks;\n                var timerStop = DateTime.Now.Ticks;\n                if (result == null)\n                {\n                    txtDecoderContent.Text = "No barcode recognized";\n                }
                {\n                    Config config = ser.ReadObject(fs) as Config;\n                    return config;\n                }\n            }
                }\n            }\n            catch (IOException)\n            {\n                return new Config\n                {\n                    server = "127.0.0.1",\n                    server_port = 8388,\n                    local_port = 1081,
namespace shadowsocks_csharp\n{\n    public partial class Form1 : Form\n    {\n        Local local;\n        Config config;\n        public Form1()\n        {\n            config = Config.Load();
            local.Start();\n        }\n        private void Config_Click(object sender, EventArgs e)\n        {\n        }\n        private void Quit_Click(object sender, EventArgs e)\n        {\n        }
        private void Config_Click(object sender, EventArgs e)\n        {\n        }\n        private void Quit_Click(object sender, EventArgs e)\n        {\n        }\n        private void button1_Click(object sender, EventArgs e)\n        {
        }\n        private void Quit_Click(object sender, EventArgs e)\n        {\n        }\n        private void button1_Click(object sender, EventArgs e)\n        {\n            reload(Config.Load());\n        }

            this.button2.Click += new System.EventHandler(this.button2_Click);\n            // \n            // button1\n            // \n            this.button1.DialogResult = System.Windows.Forms.DialogResult.OK;\n            this.button1.Location = new System.Drawing.Point(4, 4);\n            this.button1.Name = "button1";\n            this.button1.Size = new System.Drawing.Size(75, 23);\n            this.button1.TabIndex = 0;\n            this.button1.Text = "OK";\n            this.button1.UseVisualStyleBackColor = true;
            this.notifyIcon1.ContextMenuStrip = this.contextMenuStrip1;\n            this.notifyIcon1.Icon = ((System.Drawing.Icon)(resources.GetObject("notifyIcon1.Icon")));\n            // \n            // contextMenuStrip1\n            // \n            this.contextMenuStrip1.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {\n            this.ConfigItem,\n            this.QuitItem});\n            this.contextMenuStrip1.Name = "contextMenuStrip1";\n            this.contextMenuStrip1.RenderMode = System.Windows.Forms.ToolStripRenderMode.System;
            if (!File.Exists(I18N_FILE))\n            {\n                i18n = Resources.i18n_csv;\n                File.WriteAllText(I18N_FILE, i18n, Encoding.UTF8);\n            }\n            else\n            {\n                i18n = File.ReadAllText(I18N_FILE, Encoding.UTF8);\n            }
        //public Encryptor encryptor;\n        public IEncryptor encryptor;\n        public Server config;\n        // Client  socket.\n        public Socket remote;\n        public Socket connection;\n        // Size of receive buffer.\n        public const int RecvSize = 16384;\n        public const int BufferSize = RecvSize + 32;\n        // remote receive buffer
        public IEncryptor encryptor;\n        public Server config;\n        // Client  socket.\n        public Socket remote;\n        public Socket connection;\n        // Size of receive buffer.\n        public const int RecvSize = 16384;\n        public const int BufferSize = RecvSize + 32;\n        // remote receive buffer\n        public byte[] remoteRecvBuffer = new byte[RecvSize];\n        // remote send buffer
        public Server config;\n        // Client  socket.\n        public Socket remote;\n        public Socket connection;\n        // Size of receive buffer.\n        public const int RecvSize = 16384;\n        public const int BufferSize = RecvSize + 32;\n        // remote receive buffer\n        public byte[] remoteRecvBuffer = new byte[RecvSize];\n        // remote send buffer\n        public byte[] remoteSendBuffer = new byte[BufferSize];\n        // connection receive buffer
        // Client  socket.\n        public Socket remote;\n        public Socket connection;\n        // Size of receive buffer.\n        public const int RecvSize = 16384;\n        public const int BufferSize = RecvSize + 32;\n        // remote receive buffer\n        public byte[] remoteRecvBuffer = new byte[RecvSize];\n        // remote send buffer\n        public byte[] remoteSendBuffer = new byte[BufferSize];\n        // connection receive buffer\n        public byte[] connetionRecvBuffer = new byte[RecvSize];\n        // connection send buffer
        public Socket remote;\n        public Socket connection;\n        // Size of receive buffer.\n        public const int RecvSize = 16384;\n        public const int BufferSize = RecvSize + 32;\n        // remote receive buffer\n        public byte[] remoteRecvBuffer = new byte[RecvSize];\n        // remote send buffer\n        public byte[] remoteSendBuffer = new byte[BufferSize];\n        // connection receive buffer\n        public byte[] connetionRecvBuffer = new byte[RecvSize];\n        // connection send buffer\n        public byte[] connetionSendBuffer = new byte[BufferSize];\n        // Received data string.
            this.tableLayoutPanel2.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel2.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel2.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel4.Controls.Add(this.DeleteButton, 1, 0);\n            this.tableLayoutPanel4.Controls.Add(this.AddButton, 0, 0);\n            this.tableLayoutPanel4.Dock = System.Windows.Forms.DockStyle.Top;\n            this.tableLayoutPanel4.Location = new System.Drawing.Point(0, 200);\n            this.tableLayoutPanel4.Margin = new System.Windows.Forms.Padding(0);\n            this.tableLayoutPanel4.Name = "tableLayoutPanel4";
            this.tableLayoutPanel2.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel4.Controls.Add(this.DeleteButton, 1, 0);\n            this.tableLayoutPanel4.Controls.Add(this.AddButton, 0, 0);\n            this.tableLayoutPanel4.Dock = System.Windows.Forms.DockStyle.Top;\n            this.tableLayoutPanel4.Location = new System.Drawing.Point(0, 200);\n            this.tableLayoutPanel4.Margin = new System.Windows.Forms.Padding(0);\n            this.tableLayoutPanel4.Name = "tableLayoutPanel4";\n            this.tableLayoutPanel4.RowCount = 1;\n            this.tableLayoutPanel4.RowStyles.Add(new System.Windows.Forms.RowStyle());
            Configuration.Save(_config);\n        }\n        public void SaveLogViewerConfig(LogViewerConfig newConfig)\n        {\n            _config.logViewer = newConfig;\n            Configuration.Save(_config);\n        }\n        public void UpdateInboundCounter(long n)\n        {\n            Interlocked.Add(ref inboundCounter, n);
            Configuration.Save(_config);\n        }\n        public void UpdateInboundCounter(long n)\n        {\n            Interlocked.Add(ref inboundCounter, n);\n            _config.GetCurrentServer().bandwidthIn = inboundCounter;\n        }\n        public void UpdateOutboundCounter(long n)\n        {\n            Interlocked.Add(ref outboundCounter, n);
            _config.GetCurrentServer().bandwidthIn = inboundCounter;\n        }\n        public void UpdateOutboundCounter(long n)\n        {\n            Interlocked.Add(ref outboundCounter, n);\n            _config.GetCurrentServer().bandwidthOut = outboundCounter;\n        }\n        protected void Reload()\n        {\n            // some logic in configuration updated the config when saving, we need to read it again\n            _config = Configuration.Load();
            handler.Receive();\n            return true;\n        }\n        public class UDPHandler\n        {\n            private Socket _local;\n            private Socket _remote;\n            private Server _server;\n            private byte[] _buffer = new byte[1500];\n            private IPEndPoint _localEndPoint;
            private Socket _remote;\n            private Server _server;\n            private byte[] _buffer = new byte[1500];\n            private IPEndPoint _localEndPoint;\n            private IPEndPoint _remoteEndPoint;\n            public UDPHandler(Socket local, Server server, IPEndPoint localEndPoint)\n            {\n                _local = local;\n                _server = server;\n                _localEndPoint = localEndPoint;
            // do nothing\n            var r = new FakeAsyncResult(state);\n            callback?.Invoke(r);\n        }\n        public void EndConnectProxy(IAsyncResult asyncResult)\n        {\n            // do nothing\n        }\n        public void BeginConnectDest(EndPoint destEndPoint, AsyncCallback callback, object state)\n        {
        {\n            // do nothing\n        }\n        public void BeginConnectDest(EndPoint destEndPoint, AsyncCallback callback, object state)\n        {\n            if (dep != null)\n            {\n                // need to resolve manually\n                // TODO async resolving\n                IPHostEntry ipHostInfo = Dns.GetHostEntry(dep.Host);\n                IPAddress ipAddress = ipHostInfo.AddressList[0];\n                realEndPoint = new IPEndPoint(ipAddress, dep.Port);\n            }\n            if (_remote == null)\n            {
        public void BeginConnectDest(EndPoint destEndPoint, AsyncCallback callback, object state)\n        {\n                // TODO async resolving\n                IPHostEntry ipHostInfo = Dns.GetHostEntry(dep.Host);\n                IPAddress ipAddress = ipHostInfo.AddressList[0];\n                realEndPoint = new IPEndPoint(ipAddress, dep.Port);\n            }\n            if (_remote == null)\n            {\n                _remote = new Socket(realEndPoint.AddressFamily, SocketType.Stream, ProtocolType.Tcp);\n                _remote.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n            }
        {\n            public Server Server;\n            public ServerTimer(int p) : base(p) { }\n        }\n        private void StartConnect()\n        {\n            try\n            {\n                CreateRemote();\n                // Setting up proxy
        }\n        private void StartConnect()\n        {\n            try\n            {\n                CreateRemote();\n                // Setting up proxy\n                IPEndPoint proxyEP;\n                if (_config.useProxy)\n                {
            try\n            {\n                CreateRemote();\n                // Setting up proxy\n                IPEndPoint proxyEP;\n                if (_config.useProxy)\n                {\n                    {\n                        /*\n                         * TODO really necessary to resolve a proxy's address? Maybe from local hosts?\n                         * also we may simplify it by using dual-mode socket with \n                         * the approach described in DirectConnect.BeginConnectDest\n                         */\n                        IPHostEntry ipHostInfo = Dns.GetHostEntry(_config.proxyServer);\n                        ipAddress = ipHostInfo.AddressList[0];\n                    }\n                    remote = new Socks5Proxy();
        {\n            this.controller = controller;\n            LoadMenu();\n            controller.EnableStatusChanged += controller_EnableStatusChanged;\n            controller.ConfigChanged += controller_ConfigChanged;\n            controller.PACFileReadyToOpen += controller_PACFileReadyToOpen;\n            controller.ShareOverLANStatusChanged += controller_ShareOverLANStatusChanged;\n            controller.EnableGlobalChanged += controller_EnableGlobalChanged;\n            controller.Errored += controller_Errored;\n            _notifyIcon = new NotifyIcon();
            LoadMenu();\n            controller.EnableStatusChanged += controller_EnableStatusChanged;\n            controller.ConfigChanged += controller_ConfigChanged;\n            controller.PACFileReadyToOpen += controller_PACFileReadyToOpen;\n            controller.ShareOverLANStatusChanged += controller_ShareOverLANStatusChanged;\n            controller.EnableGlobalChanged += controller_EnableGlobalChanged;\n            controller.Errored += controller_Errored;\n            _notifyIcon = new NotifyIcon();\n            LoadTrayIcon();\n            _notifyIcon.Visible = true;
            this.quitItem.Click += new System.EventHandler(this.Quit_Click);\n        }\n        private void controller_ConfigChanged(object sender, EventArgs e)\n        {\n            LoadCurrentConfiguration();\n        }\n        private void controller_EnableStatusChanged(object sender, EventArgs e)\n        {\n            enableItem.Checked = controller.GetConfiguration().enabled;
            // PasswordTextBox\n            // \n            this.PasswordTextBox.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));\n            this.PasswordTextBox.Location = new System.Drawing.Point(83, 60);\n            this.PasswordTextBox.MaxLength = 256;\n            this.PasswordTextBox.Name = "PasswordTextBox";\n            this.PasswordTextBox.Size = new System.Drawing.Size(160, 21);\n            this.PasswordTextBox.TabIndex = 2;\n            this.PasswordTextBox.WordWrap = false;
namespace Shadowsocks.View\n{\n    public class MenuViewController\n    {\n        // yes this is just a menu view controller\n        // when config form is closed, it moves away from RAM\n        // and it should just do anything related to the config form\n        private ShadowsocksController controller;\n        private UpdateChecker updateChecker;\n        private NotifyIcon _notifyIcon;
            Icon newIcon;\n            bool hasInbound = controller.trafficPerSecondQueue.Last().inboundIncreasement > 0;\n            bool hasOutbound = controller.trafficPerSecondQueue.Last().outboundIncreasement > 0;\n            if (hasInbound && hasOutbound)\n                newIcon = icon_both;\n            else if (hasInbound)\n                newIcon = icon_in;\n            else if (hasOutbound)\n                newIcon = icon_out;\n            else
            if (newIcon != this.targetIcon)\n            {\n                this.targetIcon = newIcon;\n                _notifyIcon.Icon = newIcon;\n            }\n        }\n        void controller_Errored(object sender, System.IO.ErrorEventArgs e)\n        {\n            MessageBox.Show(e.GetException().ToString(), I18N.GetString("Shadowsocks Error: {0}", e.GetException().Message));\n        }\n        #region Tray Icon
        }\n        #region Tray Icon\n                // dpi = 120;\n                icon_baseBitmap = Resources.ss20;\n            }\n            else\n            {\n                icon_baseBitmap = Resources.ss24;\n            }\n            Configuration config = controller.GetConfigurationCopy();\n            bool enabled = config.enabled;\n            bool global = config.global;
                          (enabled ?\n                              I18N.GetString("System Proxy On: ") + (global ? I18N.GetString("Global") : I18N.GetString("PAC")) :\n                              I18N.GetString("Running: Port {0}", config.localPort))  // this feedback is very important because they need to know Shadowsocks is running\n                          + "\n" + serverInfo;\n            if (text.Length > 127)\n            {\n                text = text.Substring(0, 126 - 3) + "...";\n            }\n            ViewUtils.SetNotifyIconText(_notifyIcon, text);\n        }
        private Bitmap getDarkTrayIcon(Bitmap originIcon)\n        {\n            Bitmap iconCopy = new Bitmap(originIcon);\n            for (int x = 0; x < iconCopy.Width; x++)\n            {\n                for (int y = 0; y < iconCopy.Height; y++)\n                {\n                    Color color = originIcon.GetPixel(x, y);\n                    if (color.A != 0)\n                    {
            for (int x = 0; x < iconCopy.Width; x++)\n            {\n                for (int y = 0; y < iconCopy.Height; y++)\n                {\n                    Color color = originIcon.GetPixel(x, y);\n                    if (color.A != 0)\n                    {\n                        Color flyBlue = Color.FromArgb(192, 0, 0, 0);\n                        // Multiply with flyBlue\n                        int red = color.R * flyBlue.R / 255;\n                        int green = color.G * flyBlue.G / 255;\n                        int blue = color.B * flyBlue.B / 255;\n                        int alpha = color.A;\n                        iconCopy.SetPixel(x, y, Color.FromArgb(alpha, red, green, blue));\n                    }
                    Logging.Error(e);\n                    throw;\n                }\n            }\n            return _tempPath;\n        }\n        public enum WindowsThemeMode { Dark, Light }\n        // Support on Windows 10 1903+\n        public static WindowsThemeMode GetWindows10SystemThemeSetting()\n        {
            }\n            return _tempPath;\n        }\n        public enum WindowsThemeMode { Dark, Light }\n        // Support on Windows 10 1903+\n        public static WindowsThemeMode GetWindows10SystemThemeSetting()\n        {\n            WindowsThemeMode registData = WindowsThemeMode.Dark;\n            try\n            {
        public enum WindowsThemeMode { Dark, Light }\n        // Support on Windows 10 1903+\n        public static WindowsThemeMode GetWindows10SystemThemeSetting()\n        {\n            WindowsThemeMode registData = WindowsThemeMode.Dark;\n            try\n            {\n                RegistryKey reg_HKCU = Registry.CurrentUser;\n                RegistryKey reg_ThemesPersonalize = reg_HKCU.OpenSubKey(@"Software\Microsoft\Windows\CurrentVersion\Themes\Personalize", false);\n                if (reg_ThemesPersonalize.GetValue("SystemUsesLightTheme") != null)\n                {
        {\n            WindowsThemeMode registData = WindowsThemeMode.Dark;\n            try\n            {\n                RegistryKey reg_HKCU = Registry.CurrentUser;\n                RegistryKey reg_ThemesPersonalize = reg_HKCU.OpenSubKey(@"Software\Microsoft\Windows\CurrentVersion\Themes\Personalize", false);\n                if (reg_ThemesPersonalize.GetValue("SystemUsesLightTheme") != null)\n                {\n                    if (Convert.ToInt32(reg_ThemesPersonalize.GetValue("SystemUsesLightTheme").ToString()) == 0) // 0:dark mode, 1:light mode\n                        registData = WindowsThemeMode.Dark;\n                    else
        // return path to store temporary files\n        public static string GetTempPath()\n        {\n            if (_tempPath == null)\n            {\n                try\n                {
namespace Shadowsocks.View\n{\n    public partial class ConfigForm : Form\n    {\n        private ShadowsocksController controller;\n        // this is a copy of configuration that we are working on\n        private Configuration _modifiedConfiguration;\n        private int _lastSelectedIndex = -1;\n        public ConfigForm(ShadowsocksController controller)\n        {
    public partial class ConfigForm : Form\n    {\n        private ShadowsocksController controller;\n        // this is a copy of configuration that we are working on\n        private Configuration _modifiedConfiguration;\n        private int _lastSelectedIndex = -1;\n        public ConfigForm(ShadowsocksController controller)\n        {\n            this.Font = System.Drawing.SystemFonts.MessageBoxFont;\n            InitializeComponent();\n            // a dirty hack
            this.IPTextBox = new System.Windows.Forms.TextBox();\n            this.ServerPortTextBox = new System.Windows.Forms.TextBox();\n            this.PasswordTextBox = new System.Windows.Forms.TextBox();\n            this.EncryptionLabel = new System.Windows.Forms.Label();\n            this.EncryptionSelect = new System.Windows.Forms.ComboBox();\n            this.TimeoutLabel = new System.Windows.Forms.Label();\n            this.TimeoutTextBox = new System.Windows.Forms.TextBox();\n            this.PluginLabel = new System.Windows.Forms.Label();\n            this.PluginOptionsTextBox = new System.Windows.Forms.TextBox();\n            this.ShowPasswdCheckBox = new System.Windows.Forms.CheckBox();
            // panel2\n            // \n            this.panel2.Anchor = System.Windows.Forms.AnchorStyles.Top;\n            this.panel2.AutoSize = true;\n            this.panel2.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;
            this.panel2.AutoSize = true;\n            this.panel2.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;\n            | System.Windows.Forms.AnchorStyles.Right)));\n            this.tableLayoutPanel5.AutoSize = true;\n            this.tableLayoutPanel5.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;\n            this.tableLayoutPanel5.ColumnCount = 2;\n            this.tableLayoutPanel5.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());\n            this.tableLayoutPanel5.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());\n            this.tableLayoutPanel5.Controls.Add(this.ProxyPortTextBox, 1, 0);\n            this.tableLayoutPanel5.Controls.Add(this.ProxyPortLabel, 0, 0);
            this.tableLayoutPanel5.ColumnCount = 2;\n            this.tableLayoutPanel5.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());\n            this.tableLayoutPanel5.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());\n            this.tableLayoutPanel5.Controls.Add(this.ProxyPortTextBox, 1, 0);\n            this.tableLayoutPanel5.Controls.Add(this.ProxyPortLabel, 0, 0);\n            this.tableLayoutPanel5.Location = new System.Drawing.Point(272, 308);\n            this.tableLayoutPanel5.Margin = new System.Windows.Forms.Padding(0);\n            this.tableLayoutPanel5.Name = "tableLayoutPanel5";\n            this.tableLayoutPanel5.Padding = new System.Windows.Forms.Padding(3);
                if (arguments == "query") {\n                    if (stdout.IsNullOrWhiteSpace() || stdout.IsNullOrEmpty()) {\n                        // we cannot get user settings\n                        throw new ProxyException("failed to query wininet settings");\n                    }\n                    _queryStr = stdout;\n                }\n            }\n        }\n        private static void Save()\n        {
                }\n            } catch (IOException e) {\n                Logging.LogUsefulException(e);\n            }\n        }\n        private static void Read()\n        {
﻿using System;\nusing System.Collections.Generic;
using System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Timers;\nusing Shadowsocks.Controller.Strategy;\nusing Shadowsocks.Encryption;\nusing Shadowsocks.ForwardProxy;\nusing Shadowsocks.Model;\nusing Shadowsocks.Util.Sockets;
using Shadowsocks.ForwardProxy;\nusing Shadowsocks.Model;\nusing Shadowsocks.Util.Sockets;\nnamespace Shadowsocks.Controller\n{\n    class TCPRelay : Listener.Service\n    {\n        private ShadowsocksController _controller;\n        private DateTime _lastSweepTime;\n        private Configuration _config;
    {\n        private ShadowsocksController _controller;\n        private DateTime _lastSweepTime;\n        private Configuration _config;\n        public ISet<TCPHandler> Handlers { get; set; }\n        public TCPRelay(ShadowsocksController controller, Configuration conf)\n        {\n            _controller = controller;\n            _config = conf;
        {\n            _controller = controller;\n            _config = conf;\n            Handlers = new HashSet<TCPHandler>();\n            _lastSweepTime = DateTime.Now;\n        }\n        public override bool Handle(byte[] firstPacket, int length, Socket socket, object state)\n        {
        }\n        public override bool Handle(byte[] firstPacket, int length, Socket socket, object state)\n        {\n            if (socket.ProtocolType != ProtocolType.Tcp\n                || (length < 2 || firstPacket[0] != 5))\n                return false;\n            socket.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);
            return true;\n        }\n        public override void Stop()\n        {\n            List<TCPHandler> handlersToClose = new List<TCPHandler>();\n            lock (Handlers)\n            {\n                handlersToClose.AddRange(Handlers);\n            }
        }\n        public override void Stop()\n        {\n            List<TCPHandler> handlersToClose = new List<TCPHandler>();\n            lock (Handlers)\n            {\n                handlersToClose.AddRange(Handlers);\n            }\n    class TCPHandler\n    {
    {\n        class AsyncSession\n        {\n            public IForwardProxy Remote { get; }\n            public AsyncSession(IForwardProxy remote)\n            {\n                Remote = remote;\n            }\n        }
        {\n            public T State { get; set; }\n            public AsyncSession(IForwardProxy remote, T state) : base(remote)\n            {\n                State = state;\n            }
            {\n                State = state;\n            }\n        private ShadowsocksController   _controller;\n        private Configuration           _config;\n        private TCPRelay                _tcprelay;\n        private Socket                  _connection;\n        private IEncryptor  _encryptor;\n        private Server      _server;\n        private AsyncSession _currentRemoteSession;
        private bool    _remoteShutdown = false;\n        private bool    _closed = false;\n        // instance-based lock without static\n        private readonly object  _encryptionLock = new object();\n        private readonly object  _decryptionLock = new object();\n        private readonly object  _closeConnLock = new object();\n        private DateTime _startConnectTime;\n        private DateTime _startReceivingTime;\n        private DateTime _startSendingTime;\n        private EndPoint _destEndPoint = null;
        private EndPoint _destEndPoint = null;\n        public TCPHandler(ShadowsocksController controller, Configuration config, TCPRelay tcprelay, Socket socket)\n        {\n            _controller = controller;
            {\n                if (_server != null)\n                {\n                    IStrategy strategy = _controller.GetCurrentStrategy();\n                    strategy?.SetFailure(_server);\n                }\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }
                Logging.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void StartPipe(AsyncSession session)\n        {\n            if (_closed) return;\n            try\n            {\n                _startReceivingTime = DateTime.Now;
            _totalWrite += length;\n            int bytesToSend;\n            lock (_encryptionLock)\n            {
            strategy?.UpdateLastWrite(_server);\n        }\n        private void PipeRemoteSendCallback(IAsyncResult ar)\n        {
        private void PipeRemoteSendCallback(IAsyncResult ar)\n        {\n            if (_closed) return;\n            try\n            {\n                var session = (AsyncSession)ar.AsyncState;
                if (strategy != null)\n                {\n                    strategy.ReloadServers();\n                }\n                TCPRelay tcpRelay = new TCPRelay(this, _config);\n                UDPRelay udpRelay = new UDPRelay(this);\n                List<Listener.IService> services = new List<Listener.IService>();\n                services.Add(tcpRelay);\n                services.Add(udpRelay);
        {\n            var state = ((FakeAsyncResult)asyncResult).innerState;\n            if (state.ex != null)\n            {\n                throw state.ex;\n            }\n        }\n        public void BeginConnectDest(EndPoint destEndPoint, AsyncCallback callback, object state)\n        {\n            DestEndPoint = destEndPoint;
        }\n        public void BeginConnectDest(EndPoint destEndPoint, AsyncCallback callback, object state)\n        {\n            DestEndPoint = destEndPoint;\n                    default:\n                        throw new Exception(I18N.GetString("Proxy request failed"));\n                }\n                port = ((IPEndPoint) DestEndPoint).Port;\n                var addr = ((IPEndPoint)DestEndPoint).Address.GetAddressBytes();\n                Array.Copy(addr, 0, request, 4, request.Length - 4 - 2);\n            }\n            // 构造request包剩余部分\n            request[0] = 5;\n            request[1] = 1;\n            request[2] = 0;
        /// Get all entries from RAS\n        /// </summary>\n        /// <param name="allConns"></param>\n        /// <returns>\n        /// 0: success with entries\n        /// 1: success but no entries found\n        /// 2: failed\n        /// </returns>\n        public static uint GetAllConns(ref string[] allConns)\n        {
        /// 2: failed\n        /// </returns>\n        public static uint GetAllConns(ref string[] allConns)\n        {\n            int lpNames = 1;\n            int entryNameSize = 0;\n            int lpSize = 0;\n            uint retval = ERROR_SUCCESS;\n            RasEntryName[] names = null;\n            entryNameSize = Marshal.SizeOf(typeof(RasEntryName));
            entryNameSize = Marshal.SizeOf(typeof(RasEntryName));\n            names[0].dwSize = entryNameSize;\n            retval = RAS.RasEnumEntries(null, null, names, ref lpSize, out lpNames);\n            //if we have more than one connection, we need to resize\n            if (retval == ERROR_BUFFER_TOO_SMALL)\n            {\n                names = new RasEntryName[lpNames];\n                for (int i = 0; i < names.Length; i++)\n                {\n                    names[i].dwSize = entryNameSize;\n                }
            UpdatePACItemsEnabledStatus();\n            UpdateUpdateMenu();\n        }\n        private void UpdateServersMenu()\n        {\n            var items = ServersItem.MenuItems;\n            while (items[0] != SeperatorItem)\n            {\n                items.RemoveAt(0);\n            }
            while (items[0] != SeperatorItem)\n            {\n                items.RemoveAt(0);\n            }\n            int i = 0;\n            foreach (var strategy in controller.GetStrategies())\n            {\n                MenuItem item = new MenuItem(strategy.Name);\n                item.Tag = strategy.ID;\n                item.Click += AStrategyItem_Click;
            }\n            int i = 0;\n            foreach (var strategy in controller.GetStrategies())\n            {\n                MenuItem item = new MenuItem(strategy.Name);\n                item.Tag = strategy.ID;\n                item.Click += AStrategyItem_Click;\n                items.Add(i, item);\n                i++;\n            }\n            // user wants a seperator item between strategy and servers menugroup
                i++;\n            }\n            // user wants a seperator item between strategy and servers menugroup\n            items.Add(i++, new MenuItem("-"));\n            int strategyCount = i;\n            Configuration configuration = controller.GetConfigurationCopy();\n            foreach (var server in configuration.configs)\n            {\n                if (Configuration.ChecksServer(server))\n                {\n                    MenuItem item = new MenuItem(server.FriendlyName());
            items.Add(i++, new MenuItem("-"));\n            int strategyCount = i;\n            Configuration configuration = controller.GetConfigurationCopy();\n            foreach (var server in configuration.configs)\n            {\n                if (Configuration.ChecksServer(server))\n                {\n                    MenuItem item = new MenuItem(server.FriendlyName());\n                    item.Tag = i - strategyCount;\n                    item.Click += AServerItem_Click;

                    this.ConfigItem = CreateMenuItem("Edit Servers...", new EventHandler(this.Config_Click))\n                }),\n                new MenuItem("-"),\n                this.AutoStartupItem = CreateMenuItem("Start on Boot", new EventHandler(this.AutoStartupItem_Click)),\n                this.ShareOverLANItem = CreateMenuItem("Share over LAN", new EventHandler(this.ShareOverLANItem_Click)),\n                CreateMenuItem("Edit PAC File...", new EventHandler(this.EditPACFileItem_Click)),\n                CreateMenuItem("Update PAC from GFWList", new EventHandler(this.UpdatePACFromGFWListItem_Click)),\n                new MenuItem("-"),
            UpdateServersMenu();\n            enableItem.Checked = config.enabled;\n            globalModeItem.Checked = config.global;\n            PACModeItem.Checked = !config.global;\n            ShareOverLANItem.Checked = config.shareOverLan;\n            AutoStartupItem.Checked = AutoStartup.Check();\n        }\n        private void UpdateServersMenu()\n        {\n            var items = ServersItem.MenuItems;
            var items = ServersItem.MenuItems;\n            items.Clear();\n            Configuration configuration = controller.GetConfiguration();\n            for (int i = 0; i < configuration.configs.Count; i++)\n            {\n                Server server = configuration.configs[i];\n                MenuItem item = new MenuItem(server.FriendlyName());\n                item.Tag = i;\n                item.Click += AServerItem_Click;
                {\n                    TryHarder = true,\n                    PossibleFormats = new List<BarcodeFormat>\n                    {\n                        BarcodeFormat.QR_CODE\n                    }\n                };\n                var result = reader.Decode(image);\n                if (result != null)\n                {
        }\n        private static readonly IEnumerable<char> IgnoredLineBegins = new[] { '!', '[' };\n        private void pacServer_UserRuleFileChanged(object sender, EventArgs e)\n        {\n            // TODO: this is a dirty hack. (from code GListUpdater.http_DownloadStringCompleted())\n            if (!File.Exists(Utils.GetTempPath("gfwlist.txt")))\n            {\n                UpdatePACFromGFWList();\n                return;\n            }
        {\n            // TODO: this is a dirty hack. (from code GListUpdater.http_DownloadStringCompleted())\n            if (!File.Exists(Utils.GetTempPath("gfwlist.txt")))\n            {\n                UpdatePACFromGFWList();\n                return;\n            }\n            List<string> lines = GFWListUpdater.ParseResult(File.ReadAllText(Utils.GetTempPath("gfwlist.txt")));\n            if (File.Exists(PACServer.USER_RULE_FILE))\n            {
            });\n        }\n        #endregion\n        private void controller_ConfigChanged(object sender, EventArgs e)\n        {\n            LoadCurrentConfiguration();\n            UpdateTrayIcon();\n        }\n        private void controller_EnableStatusChanged(object sender, EventArgs e)\n        {
            int i = 0;\n            foreach (var strategy in controller.GetStrategies())\n            {\n                MenuItem item = new MenuItem(strategy.Name);\n                item.Tag = strategy.ID;\n                item.Click += AStrategyItem_Click;\n                items.Add(i, item);\n                i++;\n            }\n            // user wants a seperator item between strategy and servers menugroup
namespace Shadowsocks.Controller\n{\n    public class Logging\n    {\n        public static string LogFile;\n        public static bool OpenLogFile()\n        {\n            try\n            {\n                string temppath = Utils.GetTempPath();
        private void reload(Config config)\n        {\n            if (local != null)\n            {\n                local.Stop();\n                if (polipoRunner != null)\n                {\n                    polipoRunner.Stop();\n                }\n            }

        private MenuItem CreateMenuItem(int index, string text, EventHandler click)\n        {\n            MenuItem result = new MenuItem(I18N.GetString(text), click);
        private MenuItem CreateMenuItem(int index, string text, EventHandler click)\n        {\n            MenuItem result = new MenuItem(I18N.GetString(text), click);\n            result.Index = index;\n            return result;\n        }
        private MenuItem CreateMenuItem(int index, string text, EventHandler click)\n        {\n            MenuItem result = new MenuItem(I18N.GetString(text), click);\n            result.Index = index;\n            return result;\n        }\n        private MenuItem CreateSeperatorItem(int index)\n        {\n            MenuItem result = new MenuItem("-");
            MenuItem result = new MenuItem(I18N.GetString(text), click);\n            result.Index = index;\n            return result;\n        }\n        private MenuItem CreateSeperatorItem(int index)\n        {\n            MenuItem result = new MenuItem("-");\n            result.Index = index;\n            return result;\n        }
        private MenuItem CreateSeperatorItem(int index)\n        {\n            MenuItem result = new MenuItem("-");\n            result.Index = index;\n            return result;\n        }\n        private MenuItem CreateMenuGroup(int index, string text, MenuItem[] items)\n        {\n            MenuItem result = new MenuItem(I18N.GetString(text), items);
        private MenuItem CreateMenuGroup(int index, string text, MenuItem[] items)\n        {\n            MenuItem result = new MenuItem(I18N.GetString(text), items);\n            result.Index = index;\n            return result;\n        }\n        private void LoadMenu()\n        {\n            this.contextMenu1 = new System.Windows.Forms.ContextMenu();
            MenuItem result = new MenuItem(I18N.GetString(text), items);\n            result.Index = index;\n            return result;\n        }\n        private void LoadMenu()\n        {\n            this.contextMenu1 = new System.Windows.Forms.ContextMenu();\n            this.PACModeItem = CreateMenuItem(0, "PAC", new System.EventHandler(this.PACModeItem_Click));\n            this.globalModeItem = CreateMenuItem(1, "Global", new System.EventHandler(this.GlobalModeItem_Click));\n            this.SeperatorItem = CreateSeperatorItem(0);\n            this.ConfigItem = CreateMenuItem(1, "Edit Servers...", new System.EventHandler(this.Config_Click));\n            this.enableItem = CreateMenuItem(0, "Enable", new System.EventHandler(this.EnableItem_Click));\n            this.ServersItem = CreateMenuGroup(2, "Servers", new System.Windows.Forms.MenuItem[] {\n                this.SeperatorItem,\n                this.ConfigItem\n            });
        private void PipeConnectionReceiveCallback(IAsyncResult ar)\n        {\n            if (_closed) return;\n            try\n            {\n                if(connection == null) return;\n                int bytesRead = connection.EndReceive(ar);\n                _totalWrite += bytesRead;\n                if (bytesRead > 0)\n                {
            try\n            {\n                if(connection == null) return;\n                int bytesRead = connection.EndReceive(ar);\n                _totalWrite += bytesRead;\n                if (bytesRead > 0)\n                {\n                    int atyp = _connetionRecvBuffer[0];\n                    string dst_addr;\n                    int dst_port;\n                    switch (atyp)\n                    {
using System.IO;\nusing Newtonsoft.Json;\nusing NLog;\nusing Shadowsocks.Controller;\nnamespace Shadowsocks.Model\n{\n    [Serializable]\n    public class Configuration\n    {\n        [JsonIgnore]
        [JsonIgnore]\n        private static Logger logger = LogManager.GetCurrentClassLogger();\n        public string version;\n        public List<Server> configs;\n        // when strategy is set, index is ignored\n        public string strategy;\n        public int index;\n        public bool global;\n        public bool enabled;\n        public bool shareOverLan;\n        public bool isDefault;
        public int index;\n        public bool global;\n        public bool enabled;\n        public bool shareOverLan;\n        public bool isDefault;\n        // hidden\n        public bool isIPv6Enabled = false;\n        public int localPort;\n        public bool portableMode = true;\n        public bool showPluginOutput;\n        public string pacUrl;
        public bool portableMode = true;\n        public bool showPluginOutput;\n        public string pacUrl;\n        // geosite config is hidden\n        public string geositeUrl;\n        public string geositeGroup = "geolocation-!cn";\n        public bool geositeBlacklistMode = true;\n        public bool useOnlinePac;\n        public bool secureLocalPac = true;\n        public bool availabilityStatistics;\n        public bool autoCheckUpdate;\n        public bool checkPreRelease;\n        public bool isVerboseLogging;
        public bool isVerboseLogging;\n        // hidden config\n        public bool generateLegacyUrl = false;\n        //public NLogConfig.LogLevel logLevel;\n        public LogViewerConfig logViewer;\n        public ProxyConfig proxy;\n        public HotkeyConfig hotkey;\n        [JsonIgnore]\n        NLogConfig nLogConfig;\n        private static readonly string CONFIG_FILE = "gui-config.json";
        // hidden config\n        public bool generateLegacyUrl = false;\n        //public NLogConfig.LogLevel logLevel;\n        public LogViewerConfig logViewer;\n        public ProxyConfig proxy;\n        public HotkeyConfig hotkey;\n        [JsonIgnore]\n        NLogConfig nLogConfig;\n        private static readonly string CONFIG_FILE = "gui-config.json";\n        private static readonly NLogConfig.LogLevel verboseLogLevel =\n#if DEBUG
        // hidden config\n        public bool generateLegacyUrl = false;\n        //public NLogConfig.LogLevel logLevel;\n        public LogViewerConfig logViewer;\n        public ProxyConfig proxy;\n        public HotkeyConfig hotkey;\n        [JsonIgnore]\n        NLogConfig nLogConfig;\n        private static readonly string CONFIG_FILE = "gui-config.json";\n        private static readonly NLogConfig.LogLevel verboseLogLevel =\n#if DEBUG\n        NLogConfig.LogLevel.Trace;\n#else
﻿using System;\nusing System.Collections.Generic;\nusing System.Drawing;\nusing System.Linq;
﻿using System;\nusing System.Collections.Generic;\nusing System.Drawing;\nusing System.Linq;\nusing System.Reflection;\nusing System.Text;\nusing System.Windows.Forms;\nusing Shadowsocks.Controller;
using System.Collections.Generic;\nusing System.Drawing;\nusing System.Linq;\nusing System.Reflection;\nusing System.Text;\nusing System.Windows.Forms;\nusing Shadowsocks.Controller;\nusing Shadowsocks.Controller.Hotkeys;\nusing Shadowsocks.Model;\nusing Shadowsocks.Properties;
            this.Close();\n        }\n        private void RegisterAllButton_Click(object sender, EventArgs e)\n        {\n            _modifiedHotkeyConfig = GetConfigFromUI();\n            RegisterAllHotkeys(_modifiedHotkeyConfig);\n        }\n        private bool RegisterAllHotkeys(HotkeyConfig hotkeyConfig)\n        {\n            return
        private bool RegisterAllHotkeys(HotkeyConfig hotkeyConfig)\n        {\n            return\n                RegHotkeyFromString(hotkeyConfig.SwitchSystemProxy, "SwitchSystemProxyCallback", SwitchSystemProxyLabel)\n                && RegHotkeyFromString(hotkeyConfig.SwitchSystemProxyMode, "SwitchSystemProxyModeCallback", SwitchProxyModeLabel)\n                && RegHotkeyFromString(hotkeyConfig.SwitchAllowLan, "SwitchAllowLanCallback", SwitchAllowLanLabel)\n                && RegHotkeyFromString(hotkeyConfig.ShowLogs, "ShowLogsCallback", ShowLogsLabel)\n                && RegHotkeyFromString(hotkeyConfig.ServerMoveUp, "ServerMoveUpCallback", ServerMoveUpLabel)\n                && RegHotkeyFromString(hotkeyConfig.ServerMoveDown, "ServerMoveDownCallback", ServerMoveDownLabel);\n        }
            return\n                RegHotkeyFromString(hotkeyConfig.SwitchSystemProxy, "SwitchSystemProxyCallback", SwitchSystemProxyLabel)\n                && RegHotkeyFromString(hotkeyConfig.SwitchSystemProxyMode, "SwitchSystemProxyModeCallback", SwitchProxyModeLabel)\n                && RegHotkeyFromString(hotkeyConfig.SwitchAllowLan, "SwitchAllowLanCallback", SwitchAllowLanLabel)\n                && RegHotkeyFromString(hotkeyConfig.ShowLogs, "ShowLogsCallback", ShowLogsLabel)\n                && RegHotkeyFromString(hotkeyConfig.ServerMoveUp, "ServerMoveUpCallback", ServerMoveUpLabel)\n                && RegHotkeyFromString(hotkeyConfig.ServerMoveDown, "ServerMoveDownCallback", ServerMoveDownLabel);\n        }\n        private bool RegHotkeyFromString(string hotkeyStr, string callbackName, Label indicator = null)\n        {
                && RegHotkeyFromString(hotkeyConfig.SwitchSystemProxyMode, "SwitchSystemProxyModeCallback", SwitchProxyModeLabel)\n                && RegHotkeyFromString(hotkeyConfig.SwitchAllowLan, "SwitchAllowLanCallback", SwitchAllowLanLabel)\n                && RegHotkeyFromString(hotkeyConfig.ShowLogs, "ShowLogsCallback", ShowLogsLabel)\n                && RegHotkeyFromString(hotkeyConfig.ServerMoveUp, "ServerMoveUpCallback", ServerMoveUpLabel)\n                && RegHotkeyFromString(hotkeyConfig.ServerMoveDown, "ServerMoveDownCallback", ServerMoveDownLabel);\n        }\n        private bool RegHotkeyFromString(string hotkeyStr, string callbackName, Label indicator = null)\n        {\n            var _callback = HotkeyCallbacks.GetCallback(callbackName);\n            if (_callback == null)\n            {
                && RegHotkeyFromString(hotkeyConfig.ShowLogs, "ShowLogsCallback", ShowLogsLabel)\n                && RegHotkeyFromString(hotkeyConfig.ServerMoveUp, "ServerMoveUpCallback", ServerMoveUpLabel)\n                && RegHotkeyFromString(hotkeyConfig.ServerMoveDown, "ServerMoveDownCallback", ServerMoveDownLabel);\n        }\n        private bool RegHotkeyFromString(string hotkeyStr, string callbackName, Label indicator = null)\n        {\n            var _callback = HotkeyCallbacks.GetCallback(callbackName);\n            if (_callback == null)\n            {\n                    indicator.ResetBackColor();\n                }\n                return true;\n            }\n            else\n            {\n                var hotkey = HotKeys.Str2HotKey(hotkeyStr);\n                if (hotkey == null)\n                {\n                    MessageBox.Show(string.Format(I18N.GetString("Cannot parse hotkey: {0}"), hotkeyStr));
            _notifyIcon.Visible = true;\n            _notifyIcon.ContextMenu = contextMenu1;\n            _notifyIcon.BalloonTipClicked += notifyIcon1_BalloonTipClicked;\n            _notifyIcon.MouseClick += notifyIcon1_Click;\n            _notifyIcon.MouseDoubleClick += notifyIcon1_DoubleClick;\n            _notifyIcon.BalloonTipClosed += _notifyIcon_BalloonTipClosed;\n            this.updateChecker = new UpdateChecker();\n            updateChecker.CheckUpdateCompleted += updateChecker_CheckUpdateCompleted;\n            LoadCurrentConfiguration();\n            Configuration config = controller.GetConfigurationCopy();
            _notifyIcon.BalloonTipClosed += _notifyIcon_BalloonTipClosed;\n            this.updateChecker = new UpdateChecker();\n            updateChecker.CheckUpdateCompleted += updateChecker_CheckUpdateCompleted;\n            LoadCurrentConfiguration();\n            Configuration config = controller.GetConfigurationCopy();\n            if (config.autoCheckUpdate)\n            {\n                _isStartupChecking = true;\n                updateChecker.CheckUpdate(config, 3000);
                ShowBalloonTip(String.Format(I18N.GetString("Shadowsocks {0} Update Found"), updateChecker.LatestVersionNumber), I18N.GetString("Click here to update"), ToolTipIcon.Info, 5000);
                ShowBalloonTip(String.Format(I18N.GetString("Shadowsocks {0} Update Found"), updateChecker.LatestVersionNumber), I18N.GetString("Click here to update"), ToolTipIcon.Info, 5000);\n                _isFirstRun = false;\n            }\n            else if (!_isStartupChecking)\n            {\n                ShowBalloonTip(I18N.GetString("Shadowsocks"), I18N.GetString("No update is available"), ToolTipIcon.Info, 5000);
        private void ShowFirstTimeBalloon()\n        {
            ServersListBox.Items.Clear();\n            foreach (Server server in _modifiedConfiguration.configs)\n            {\n                ServersListBox.Items.Add(server.FriendlyName());\n            }\n        }\n        private void LoadCurrentConfiguration()\n        {\n            _modifiedConfiguration = controller.GetConfigurationCopy();\n            LoadConfiguration(_modifiedConfiguration);
                return;\n            }\n            Server server = Configuration.GetDefaultServer();\n            _modifiedConfiguration.configs.Add(server);\n            LoadConfiguration(_modifiedConfiguration);\n            ServersListBox.SelectedIndex = _modifiedConfiguration.configs.Count - 1;\n            _oldSelectedIndex = ServersListBox.SelectedIndex;\n        }\n        private void DeleteButton_Click(object sender, EventArgs e)\n        {
            if (!SaveOldSelectedServer())\n            {\n                return;\n            }\n            if (_modifiedConfiguration.configs.Count == 0)\n            {\n                MessageBox.Show(I18N.GetString("Please add at least one server"));\n                return;\n            }
            {\n                return;\n            }\n            if (_modifiedConfiguration.configs.Count == 0)\n            {\n                MessageBox.Show(I18N.GetString("Please add at least one server"));\n                return;\n            }\n            int index = _modifiedConfiguration.index;\n            controller.SaveServers(_modifiedConfiguration.configs, _modifiedConfiguration.localPort);
using System.Collections.Generic;\nnamespace Shadowsocks.Encryption\n{\n    public class SodiumEncryptor\n        : IVEncryptor, IDisposable\n    {\n        const int CIPHER_SALSA20 = 1;\n        const int CIPHER_CHACHA20 = 2;\n        const int CIPHER_CHACHA20_IETF = 3;\n        const int SODIUM_BLOCK_SIZE = 64;
        {\n            return new List<string>(_ciphers.Keys);\n        }\n        protected override void cipherUpdate(bool isCipher, int length, byte[] buf, byte[] outbuf)\n        {\n            // TODO write a unidirection cipher so we don't have to if if if\n            int bytesRemaining;\n            ulong ic;\n            byte[] iv;
        }\n        protected override void cipherUpdate(bool isCipher, int length, byte[] buf, byte[] outbuf)\n        {\n            // TODO write a unidirection cipher so we don't have to if if if\n            int bytesRemaining;\n            ulong ic;\n            byte[] iv;\n            // I'm tired. just add a big lock\n            // let's optimize for RAM instead of CPU\n            lock(sodiumBuf)\n            {

﻿using shadowsocks_csharp.Model;\nusing shadowsocks_csharp.Properties;\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.IO.Compression;\nusing System.Text;

﻿using shadowsocks_csharp.Properties;\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.IO.Compression;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Text;

﻿using shadowsocks_csharp.Model;\nusing System;\nusing System.Collections.Generic;\nusing System.Text;

﻿using shadowsocks_csharp.Controller;\nusing shadowsocks_csharp.Properties;\nusing shadowsocks_csharp.View;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Runtime.InteropServices;\nusing System.Windows.Forms;
            else\n            {\n                ServerGroupBox.Visible = false;\n            }\n        }\n        private void loadConfiguration(Configuration configuration)\n        {\n            ServersListBox.Items.Clear();\n            foreach (Server server in modifiedConfiguration.configs)\n            {
            this.panel1.Location = new System.Drawing.Point(275, 247);\n            this.panel1.Margin = new System.Windows.Forms.Padding(0);\n            this.panel1.Name = "panel1";\n            this.panel1.Size = new System.Drawing.Size(164, 30);\n            this.panel1.TabIndex = 1;\n            // \n            // contextMenu1\n            // \n            this.contextMenu1.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {\n            this.enableItem,
            this.enableItem,\n            this.configItem,\n            this.editPACFileItem,\n            this.aboutItem,\n            this.menuItem3,\n            this.quitItem});\n            // \n            // enableItem\n            // \n            this.enableItem.Index = 0;
            // \n            // enableItem\n            // \n            this.enableItem.Index = 0;\n            // configItem\n            // \n            this.configItem.Index = 1;\n            this.configItem.Text = "Options...";\n            this.configItem.Click += new System.EventHandler(this.Config_Click);\n            // \n            // editPACFileItem\n            // 
                {\n                    strategy.ReloadServers();\n                }\n                polipoRunner.Start(_config);\n                TCPRelay tcpRelay = new TCPRelay(this, _config);\n                UDPRelay udpRelay = new UDPRelay(this);\n                List<Listener.IService> services = new List<Listener.IService>();\n                services.Add(tcpRelay);\n                services.Add(udpRelay);\n                services.Add(_pacServer);
using System.Net.NetworkInformation;\nusing System.Runtime.InteropServices;\nusing System.Text;\nusing System.Windows.Forms;\nusing Shadowsocks.Model;\nusing Shadowsocks.Properties;\nusing Shadowsocks.Util;\nusing Shadowsocks.Util.ProcessManagement;\nnamespace Shadowsocks.Controller\n{
using Shadowsocks.Util.ProcessManagement;\nnamespace Shadowsocks.Controller\n{\n    class PolipoRunner\n    {\n        private static int Uid;\n        private static string UniqueConfigFile;\n        private static Job PolipoJob;\n        private Process _process;\n        private int _runningPort;
            get\n            {\n                return _runningPort;\n            }\n        }\n        public void Start(Configuration configuration)\n        {\n            Server server = configuration.GetCurrentServer();\n            if (_process == null)\n            {
        public void Start(Configuration configuration)\n        {\n            Server server = configuration.GetCurrentServer();\n            if (_process == null)\n            {\n                Process[] existingPolipo = Process.GetProcessesByName("ss_privoxy");\n                foreach (Process p in existingPolipo.Where(IsChildProcess))\n                {\n                    KillProcess(p);\n                }
            Server server = configuration.GetCurrentServer();\n            if (_process == null)\n            {\n                Process[] existingPolipo = Process.GetProcessesByName("ss_privoxy");\n                foreach (Process p in existingPolipo.Where(IsChildProcess))\n                {\n                    KillProcess(p);\n                }\n                string polipoConfig = Resources.privoxy_conf;\n                _runningPort = this.GetFreePort();
                _pluginProcess.StartInfo.Environment["SS_LOCAL_HOST"] = LocalEndPoint.Address.ToString();\n                _pluginProcess.StartInfo.Environment["SS_LOCAL_PORT"] = LocalEndPoint.Port.ToString();\n                _pluginProcess.StartInfo.Arguments = ExpandEnvironmentVariables(_pluginProcess.StartInfo.Arguments, _pluginProcess.StartInfo.EnvironmentVariables);\n                try\n                {\n                    _pluginProcess.Start();\n                }\n                catch (System.ComponentModel.Win32Exception ex)\n                {\n                    // do not use File.Exists(...), it can not handle the scenarios when the plugin file is in system environment path.
﻿using System;\nusing System.Collections.Generic;\nusing System.Data;\nusing System.Linq;\nusing System.Windows.Forms;
﻿using System;\nusing System.Collections.Generic;\nusing System.Data;\nusing System.Linq;\nusing System.Windows.Forms;\nusing System.Windows.Forms.DataVisualization.Charting;\nusing Shadowsocks.Controller;\nusing Shadowsocks.Model;
    {\n        private const string UpdateURL = "https://api.github.com/repos/shadowsocks/shadowsocks-windows/releases";\n        private const string UserAgent = "Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.3319.102 Safari/537.36";\n        private Configuration config;\n        public bool NewVersionFound;\n        public string LatestVersionNumber;\n        public string LatestVersionName;\n        public string LatestVersionURL;\n        public string LatestVersionLocalName;\n        public event EventHandler CheckUpdateCompleted;
        private const string UserAgent = "Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.3319.102 Safari/537.36";\n        private Configuration config;\n        public bool NewVersionFound;\n        public string LatestVersionNumber;\n        public string LatestVersionName;\n        public string LatestVersionURL;\n        public string LatestVersionLocalName;\n        public event EventHandler CheckUpdateCompleted;\n                JsonArray result = (JsonArray)SimpleJson.SimpleJson.DeserializeObject(e.Result);\n                List<Asset> asserts = new List<Asset>();
        public event EventHandler CheckUpdateCompleted;\n                JsonArray result = (JsonArray)SimpleJson.SimpleJson.DeserializeObject(e.Result);\n                List<Asset> asserts = new List<Asset>();\n                    if ((bool)release["prerelease"])\n                    {\n                        continue;\n                    }\n                    foreach (JsonObject asset in (JsonArray)release["assets"])\n                    {\n                        Asset ass = new Asset();\n                        ass.Parse(asset);\n                        if (ass.IsNewVersion(Version))\n                        {
using System;
using System;\nusing System.Collections.Generic;\nusing System.Text;
using System;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.IO;\nusing System.Diagnostics;\nusing SimpleJson;\nusing Shadowsocks.Controller;

﻿using Shadowsocks.Controller;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;
﻿using System;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.Security.Cryptography;\nnamespace shadowsocks_csharp\n{
using System.Collections.Generic;\nusing System.Text;\nusing System.Security.Cryptography;\nnamespace shadowsocks_csharp\n{\n    class Encryptor\n    {
namespace shadowsocks_csharp\n{\n    class Encryptor\n    {\n        public const int TYPE_TABLE = 1;\n        public const int TYPE_RC4 = 2;\n        public byte[] encryptTable = new byte[256];\n        public byte[] decryptTable = new byte[256];
        {\n            MD5 md5 = System.Security.Cryptography.MD5.Create();\n            byte[] inputBytes = System.Text.Encoding.UTF8.GetBytes(password);\n            byte[] hash = md5.ComputeHash(inputBytes);\n            if (method != null && method.ToLowerInvariant().Equals("rc4")) {\n                Console.WriteLine("init rc4");
            if (method != null && method.ToLowerInvariant().Equals("rc4")) {\n                Console.WriteLine("init rc4");\n                this.method = TYPE_RC4;\n                rc4 = new RC4();\n                encryptTable = rc4.EncryptInitalize(hash);\n                decryptTable = rc4.EncryptInitalize(hash);
            if (method != null && method.ToLowerInvariant().Equals("rc4")) {\n                Console.WriteLine("init rc4");\n                this.method = TYPE_RC4;\n                rc4 = new RC4();\n                encryptTable = rc4.EncryptInitalize(hash);\n                decryptTable = rc4.EncryptInitalize(hash);\n            } else {\n                Console.WriteLine("init table");
                }\n                for (int i = 1; i < 1024; i++)\n                {\n                    encryptTable = mergeSort(encryptTable, a, i);\n                }\n                for (int i = 0; i < 256; i++)\n                {\n                    decryptTable[encryptTable[i]] = (byte)i;\n                }\n            }
                {\n                    decryptTable[encryptTable[i]] = (byte)i;\n                }\n            }\n        }\n        public void Encrypt(byte[] buf, int length)\n        {\n            switch (method)\n            {
            }\n        }\n        public void Encrypt(byte[] buf, int length)\n        {\n            switch (method)\n            {\n                case TYPE_TABLE:\n                    for (int i = 0; i < length; i++)\n                        buf[i] = encryptTable[buf[i]];
        {\n            switch (method)\n            {\n                case TYPE_TABLE:\n                    for (int i = 0; i < length; i++)\n                        buf[i] = encryptTable[buf[i]];\n                    break;\n                case TYPE_RC4:\n                    rc4.Encrypt(encryptTable, buf, length);
                    rc4.Encrypt(encryptTable, buf, length);\n                    break;\n            }\n        }\n        public void Decrypt(byte[] buf, int length)\n        {\n            switch (method)\n            {
                    break;\n            }\n        }\n        public void Decrypt(byte[] buf, int length)\n        {\n            switch (method)\n            {\n                case TYPE_TABLE:\n                    for (int i = 0; i < length; i++)\n                        buf[i] = decryptTable[buf[i]];
        {\n            switch (method)\n            {\n                case TYPE_TABLE:\n                    for (int i = 0; i < length; i++)\n                        buf[i] = decryptTable[buf[i]];\n                    break;\n                case TYPE_RC4:\n                    rc4.Decrypt(decryptTable, buf, length);
                };\n                Config.Save(config);\n                this.config = config;\n                reload(config);\n                this.Hide();\n            }\n            catch (FormatException)\n            {\n                MessageBox.Show("there is format problem");\n            }
                this.config = config;\n                reload(config);\n                this.Hide();\n            }\n            catch (FormatException)\n            {\n                MessageBox.Show("there is format problem");\n            }\n            catch (Exception)\n            {
                    new AsyncCallback(connectCallback), null);\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine(e.ToString());\n                this.Close();\n            }\n        }\n        public void Close()\n        {
            {\n                Console.WriteLine(e.ToString());\n                this.Close();\n            }\n        }\n        public void Close()\n        {\n            connection.Close();\n            if (remote != null)\n            {
    // https://github.com/shadowsocks/shadowsocks-org/wiki/Plugin\n    public sealed class Sip003Plugin : IDisposable\n    {\n        public IPEndPoint LocalEndPoint { get; private set; }\n        public int ProcessId => _started ? _pluginProcess.Id : 0;\n        private readonly object _startProcessLock = new object();\n        private readonly Job _pluginJob;\n        private readonly Process _pluginProcess;\n        private bool _started;\n        private bool _disposed;
        public static Sip003Plugin CreateIfConfigured(Server server)\n        {\n            if (server == null)\n            {\n                throw new ArgumentNullException(nameof(server));\n            }\n            if (string.IsNullOrWhiteSpace(server.plugin))\n            {\n                return null;\n            }
            {\n                throw new ArgumentNullException(nameof(server));\n            }\n            if (string.IsNullOrWhiteSpace(server.plugin))\n            {\n                return null;\n            }\n            return new Sip003Plugin(server.plugin, server.plugin_opts, server.plugin_args, server.server, server.server_port);\n        }
namespace shadowsocks_csharp\n{\n    static class Program\n    {\n        /// <summary>\n        /// 应用程序的主入口点。\n        /// </summary>\n        [STAThread]\n        static void Main()\n        {
        /// <summary>\n        /// 应用程序的主入口点。\n        /// </summary>\n        [STAThread]\n        static void Main()\n        {\n            Local local = new Local(1081);\n            local.Start();\n            Application.EnableVisualStyles();\n            Application.SetCompatibleTextRenderingDefault(false);\n            Application.Run(new Form1());

            this.Config,\n            this.Quit});\n            this.contextMenuStrip1.Name = "contextMenuStrip1";\n            this.contextMenuStrip1.RenderMode = System.Windows.Forms.ToolStripRenderMode.System;\n            this.contextMenuStrip1.ShowImageMargin = false;\n            this.contextMenuStrip1.Size = new System.Drawing.Size(86, 48);\n            // 
                Logging.LogUsefulException(e);\n                return false;\n            }\n        }\n        //hardcode\n        //TODO: backup reliable isp&geolocation provider or a local database is required\n        private static async Task<DataList> getGeolocationAndISP()\n        {\n            Logging.Debug("Retrive information of geolocation and isp");\n            const string api = "http://ip-api.com/json";
                    //new KeyValuePair<string, string>("data", reply.Buffer.ToString()); // The data of reply\n                });\n            }\n            return ret;\n        }\n        private async void Evaluate(object obj)\n        {\n            var geolocationAndIsp = getGeolocationAndISP();\n            foreach (var dataLists in await TaskEx.WhenAll(_servers.Select(ICMPTest)))\n            {
                gfwListUpdater.Error += pacServer_PACUpdateError;\n            }\n            if (_listener != null)\n            {\n                _listener.Stop();
﻿using System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Drawing;\nusing System.Text;\nusing System.Windows.Forms;\nusing System.Diagnostics;\nnamespace shadowsocks_csharp\n{
using System.Windows.Forms;\nusing System.Diagnostics;\nnamespace shadowsocks_csharp\n{\n    public partial class Form1 : Form\n    {\n        Local local;\n        PACServer pacServer;\n        Config config;\n        PolipoRunner polipoRunner;
            if (closed)\n            {\n                return;\n            }\n            try\n            {\n                int bytesRead = connection.EndReceive(ar);\n                if (bytesRead >= 3)\n                {\n                    command = connetionRecvBuffer[1];
\***************************************************************************/\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Runtime.InteropServices;\nnamespace Shadowsocks.Util.SystemProxy\n{\n    public static class WinINet\n    {\n        /// <summary>
        public static void SetIEProxy(bool enable, bool global, string proxyServer, string pacURL)\n        {\n            List<INTERNET_PER_CONN_OPTION> _optionlist = new List<INTERNET_PER_CONN_OPTION>();\n            if (enable)\n            {\n                if (global)\n                {\n                    // global proxy\n                    _optionlist.Add(new INTERNET_PER_CONN_OPTION\n                    {\n                        dwOption = (int)INTERNET_PER_CONN_OptionEnum.INTERNET_PER_CONN_FLAGS_UI,
                    // global proxy\n                    _optionlist.Add(new INTERNET_PER_CONN_OPTION\n                    {\n                        dwOption = (int)INTERNET_PER_CONN_OptionEnum.INTERNET_PER_CONN_FLAGS_UI,\n                        Value = { dwValue = (int)INTERNET_OPTION_PER_CONN_FLAGS_UI.PROXY_TYPE_PROXY }\n                    });\n                    _optionlist.Add(new INTERNET_PER_CONN_OPTION\n                    {\n                        dwOption = (int)INTERNET_PER_CONN_OptionEnum.INTERNET_PER_CONN_PROXY_SERVER,
                        Value = { dwValue = (int)INTERNET_OPTION_PER_CONN_FLAGS_UI.PROXY_TYPE_PROXY }\n                    });\n                    _optionlist.Add(new INTERNET_PER_CONN_OPTION\n                    {\n                        dwOption = (int)INTERNET_PER_CONN_OptionEnum.INTERNET_PER_CONN_PROXY_SERVER,\n                        Value = { pszValue = Marshal.StringToHGlobalAnsi(proxyServer) }\n                    });\n                    _optionlist.Add(new INTERNET_PER_CONN_OPTION\n                    {\n                        dwOption = (int)INTERNET_PER_CONN_OptionEnum.INTERNET_PER_CONN_PROXY_BYPASS,
            // Free the allocated memory.\n            Marshal.FreeCoTaskMem(buffer);\n            Marshal.FreeCoTaskMem(intptrStruct);\n            // Throw an exception if this operation failed.\n            if (!bReturn)\n            {\n                throw new Exception("InternetSetOption: " + Marshal.GetLastWin32Error());\n            }\n            // Notify the system that the registry settings have been changed and cause\n            // the proxy data to be reread from the registry for a handle.
            // Throw an exception if this operation failed.\n            if (!bReturn)\n            {\n                throw new Exception("InternetSetOption: " + Marshal.GetLastWin32Error());\n            }\n            // Notify the system that the registry settings have been changed and cause\n            // the proxy data to be reread from the registry for a handle.\n            NativeMethods.InternetSetOption(\n                IntPtr.Zero,
            {\n                throw new Exception("InternetSetOption: " + Marshal.GetLastWin32Error());\n            }\n            // Notify the system that the registry settings have been changed and cause\n            // the proxy data to be reread from the registry for a handle.\n            NativeMethods.InternetSetOption(\n                IntPtr.Zero,\n                INTERNET_OPTION.INTERNET_OPTION_SETTINGS_CHANGED,\n                IntPtr.Zero, 0);

﻿using System.Collections.Generic;\nusing System.Globalization;\nusing System.IO;
﻿using System.Collections.Generic;\nusing System.Globalization;\nusing System.IO;\nusing Shadowsocks.Properties;\nusing Shadowsocks.Util;\nusing System.Windows.Forms;
using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Runtime.InteropServices;\nusing System.Text;\nnamespace Shadowsocks.Encryption\n{\n    public class Sodium\n    {\n        const string DLLNAME = "libsscrypto";
using System.IO;\nusing System.Runtime.InteropServices;\nusing System.Text;\nnamespace Shadowsocks.Encryption\n{\n    public class Sodium\n    {\n        const string DLLNAME = "libsscrypto";\n        const string DLLNAME2 = "libsscrypto2";\n        static Sodium()
        const string DLLNAME = "libsscrypto";\n        const string DLLNAME2 = "libsscrypto2";\n        static Sodium()\n            LoadSSCryptoLibrary();\n            LoadSSCrypto2Library();\n        }\n        static void LoadSSCryptoLibrary()\n        {\n            string tempPath = Utils.GetTempPath();\n            string dllPath = tempPath + "/libsscrypto.dll";\n            try\n            {\n                FileManager.UncompressFile(dllPath, Resources.libsscrypto_dll);
                FileManager.UncompressFile(dllPath, Resources.libsscrypto_dll);\n                LoadLibrary(dllPath);\n            }\n            catch (IOException)\n            {\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine(e.ToString());\n            }
            {\n                Console.WriteLine(e.ToString());\n            }\n            {\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine(e.ToString());\n            }\n        }\n        [DllImport("Kernel32.dll")]\n        private static extern IntPtr LoadLibrary(string path);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
            }\n            catch (Exception e)\n            {\n                Console.WriteLine(e.ToString());\n            }\n        }\n        [DllImport("Kernel32.dll")]\n        private static extern IntPtr LoadLibrary(string path);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void crypto_stream_salsa20_xor_ic(byte[] c, byte[] m, ulong mlen, byte[] n, ulong ic, byte[] k);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
            _remote.BeginConnect(destEndPoint, callback, state);\n        }\n        public void EndConnectDest(IAsyncResult asyncResult)\n        {\n            _remote.EndConnect(asyncResult);\n            _remote.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n        }\n        public void BeginSend(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state)\n        {
        {\n            _remote?.BeginSend(buffer, offset, size, socketFlags, callback, state);\n        }\n        public int EndSend(IAsyncResult asyncResult)\n        {\n            return _remote.EndSend(asyncResult);\n        }\n        public void BeginReceive(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state)\n        {
            object state)\n        {\n            _remote?.BeginReceive(buffer, offset, size, socketFlags, callback, state);\n        }\n        public int EndReceive(IAsyncResult asyncResult)\n        {\n            return _remote.EndReceive(asyncResult);\n        }\n        public void Shutdown(SocketShutdown how)\n        {
        public int EndReceive(IAsyncResult asyncResult)\n        {\n            return _remote.EndReceive(asyncResult);\n        }\n        public void Shutdown(SocketShutdown how)\n        {\n            _remote?.Shutdown(how);\n        }\n        public void Close()\n        {
        /// Required method for Designer support - do not modify\n        /// the contents of this method with the code editor.\n        /// </summary>\n        private void InitializeComponent()\n        {\n            this.QRCodeWebBrowser = new System.Windows.Forms.WebBrowser();\n            this.SuspendLayout();\n            // \n            // QRCodeWebBrowser\n            // 
            this.QRCodeWebBrowser.Dock = System.Windows.Forms.DockStyle.Fill;\n            this.QRCodeWebBrowser.Location = new System.Drawing.Point(0, 0);\n            this.QRCodeWebBrowser.MinimumSize = new System.Drawing.Size(20, 20);\n            this.QRCodeWebBrowser.Name = "QRCodeWebBrowser";\n            this.QRCodeWebBrowser.ScriptErrorsSuppressed = true;\n            this.QRCodeWebBrowser.ScrollBarsEnabled = false;
            {"aes-192-cfb", new int[]{24, 16, CIPHER_AES, PolarSSL.AES_CTX_SIZE}},\n            {"aes-256-cfb", new int[]{32, 16, CIPHER_AES, PolarSSL.AES_CTX_SIZE}},\n            {"bf-cfb", new int[]{16, 8, CIPHER_BF, PolarSSL.BLOWFISH_CTX_SIZE}},\n            {"rc4", new int[]{16, 0, CIPHER_RC4, PolarSSL.ARC4_CTX_SIZE}},\n            {"rc4-md5", new int[]{16, 16, CIPHER_RC4, PolarSSL.ARC4_CTX_SIZE}},\n        };\n        private static readonly Dictionary<string, byte[]> CachedKeys = new Dictionary<string, byte[]>();\n        private int _cipher;\n        private int[] _cipherInfo;\n        private byte[] _key;
            {"rc4-md5", new int[]{16, 16, CIPHER_RC4, PolarSSL.ARC4_CTX_SIZE}},\n        };\n        private static readonly Dictionary<string, byte[]> CachedKeys = new Dictionary<string, byte[]>();\n        private int _cipher;\n        private int[] _cipherInfo;\n        private byte[] _key;\n        private byte[] _encryptCtx;\n        private byte[] _decryptCtx;\n        private byte[] _encryptIV;\n        private byte[] _decryptIV;
            }\n            else\n            {\n                byte[] passbuf = Encoding.UTF8.GetBytes(password);\n                _key = new byte[32];\n                byte[] iv = new byte[16];\n                bytesToKey(passbuf, _key);\n                CachedKeys[k] = _key;\n            }\n        }
                if (_method == "rc4-md5")\n                {\n                    byte[] temp = new byte[keyLen + ivLen];\n                    realkey = new byte[keyLen];\n                    Array.Copy(_key, 0, temp, 0, keyLen);\n                    Array.Copy(iv, 0, temp, keyLen, ivLen);\n                    realkey = MD5.Create().ComputeHash(temp);\n                }\n                else\n                {
                else if (_cipher == CIPHER_RC4)\n                {\n                    PolarSSL.arc4_init(ctx);\n                    PolarSSL.arc4_setup(ctx, realkey, keyLen);\n                }\n            }\n        }\n        static byte[] tempbuf = new byte[32768];\n        public override void Encrypt(byte[] buf, int length, byte[] outbuf, out int outlength)\n        {
        static byte[] tempbuf = new byte[32768];\n        public override void Encrypt(byte[] buf, int length, byte[] outbuf, out int outlength)\n        {\n            if (_encryptCtx == null)\n            {\n                randBytes(outbuf, ivLen);\n                InitCipher(ref _encryptCtx, outbuf, true);\n                outlength = length + ivLen;\n                lock (tempbuf)\n                {\n                    // C# could be multi-threaded
                                break;\n                        }\n                        outlength = length + ivLen;\n                        Buffer.BlockCopy(tempbuf, 0, outbuf, ivLen, length);\n                    }\n                }\n            }\n            else\n            {\n                outlength = length;
                            break;\n                        case CIPHER_RC4:\n                            PolarSSL.arc4_crypt(_encryptCtx, length, buf, outbuf);\n                            break;\n                    }\n                }\n            }\n        }\n        public override void Decrypt(byte[] buf, int length, byte[] outbuf, out int outlength)\n        {
        }\n        public override void Decrypt(byte[] buf, int length, byte[] outbuf, out int outlength)\n        {\n            if (_decryptCtx == null)\n            {\n                InitCipher(ref _decryptCtx, buf, false);\n                outlength = length - ivLen;\n                lock (tempbuf)\n                {\n                    // C# could be multi-threaded\n                    Buffer.BlockCopy(buf, ivLen, tempbuf, 0, length - ivLen);
                            case CIPHER_RC4:\n                                PolarSSL.arc4_crypt(_decryptCtx, length - ivLen, tempbuf, outbuf);\n                                break;\n                        }\n                    }\n                }\n            }\n            else\n            {\n                outlength = length;
﻿using System;\nusing System.Collections.Generic;\nusing System.Runtime.InteropServices;\nusing System.Text;\nnamespace Shadowsocks.Encrypt\n{\n    public class PolarSSL\n    {
﻿using System;\nusing System.Collections.Generic;\nusing System.Runtime.InteropServices;\nusing System.Text;\nnamespace Shadowsocks.Encrypt\n{\n    public class PolarSSL\n    {\n        public extern static void aes_init(byte[] ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
using System.Runtime.InteropServices;\nusing System.Text;\nnamespace Shadowsocks.Encrypt\n{\n    public class PolarSSL\n    {\n        public extern static void aes_init(byte[] ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void aes_free(byte[] ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
namespace Shadowsocks.Encrypt\n{\n    public class PolarSSL\n    {\n        public extern static void aes_init(byte[] ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void aes_free(byte[] ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int aes_setkey_enc(byte[] ctx, byte[] key, int keysize);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
    {\n        public extern static void aes_init(byte[] ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void aes_free(byte[] ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int aes_setkey_enc(byte[] ctx, byte[] key, int keysize);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int aes_crypt_cfb128(byte[] ctx, int mode, int length, ref int iv_off, byte[] iv, byte[] input, byte[] output);\n        public const int ARC4_CTX_SIZE = 264;\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void aes_free(byte[] ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int aes_setkey_enc(byte[] ctx, byte[] key, int keysize);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int aes_crypt_cfb128(byte[] ctx, int mode, int length, ref int iv_off, byte[] iv, byte[] input, byte[] output);\n        public const int ARC4_CTX_SIZE = 264;\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void arc4_init(byte[] ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int aes_setkey_enc(byte[] ctx, byte[] key, int keysize);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int aes_crypt_cfb128(byte[] ctx, int mode, int length, ref int iv_off, byte[] iv, byte[] input, byte[] output);\n        public const int ARC4_CTX_SIZE = 264;\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void arc4_init(byte[] ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void arc4_free(byte[] ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int aes_crypt_cfb128(byte[] ctx, int mode, int length, ref int iv_off, byte[] iv, byte[] input, byte[] output);\n        public const int ARC4_CTX_SIZE = 264;\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void arc4_init(byte[] ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void arc4_free(byte[] ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void arc4_setup(byte[] ctx, byte[] key, int keysize);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void arc4_free(byte[] ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void arc4_setup(byte[] ctx, byte[] key, int keysize);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int arc4_crypt(byte[] ctx, int length, byte[] input, byte[] output);\n        public const int BLOWFISH_CTX_SIZE = 4168;\n        public const int BLOWFISH_ENCRYPT = 1;\n        public const int BLOWFISH_DECRYPT = 0;\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void arc4_setup(byte[] ctx, byte[] key, int keysize);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int arc4_crypt(byte[] ctx, int length, byte[] input, byte[] output);\n        public const int BLOWFISH_CTX_SIZE = 4168;\n        public const int BLOWFISH_ENCRYPT = 1;\n        public const int BLOWFISH_DECRYPT = 0;\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void blowfish_init(byte[] ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int arc4_crypt(byte[] ctx, int length, byte[] input, byte[] output);\n        public const int BLOWFISH_CTX_SIZE = 4168;\n        public const int BLOWFISH_ENCRYPT = 1;\n        public const int BLOWFISH_DECRYPT = 0;\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void blowfish_init(byte[] ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void blowfish_free(byte[] ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
        public const int BLOWFISH_CTX_SIZE = 4168;\n        public const int BLOWFISH_ENCRYPT = 1;\n        public const int BLOWFISH_DECRYPT = 0;\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void blowfish_init(byte[] ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void blowfish_free(byte[] ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int blowfish_setkey(byte[] ctx, byte[] key, int keysize);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
        private static object locker = new object();\n        private void RunSingleEncryptionThread()\n        {\n            try\n            {\n                    for (int i = 0; i < 1000; i++)\n                    {\n                        var random = new Random();\n                        IEncryptor encryptor;\n                        IEncryptor decryptor;
                            encryptor.Encrypt(plain, 12333, cipher, out outLen);\n                            decryptor.Decrypt(cipher, outLen, plain2, out outLen2);\n                        //}
﻿using System;\nusing System.Collections.Generic;\nusing System.Net.Sockets;\nusing System.Text;
using System.Collections.Generic;\nusing System.Net.Sockets;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing Shadowsocks.ForwardProxy;\nusing Shadowsocks.Util.Sockets;\nnamespace Shadowsocks.Controller.Service\n{\n    class Http2Socks5 : Listener.Service\n    {
            if (config.secureLocalPac)\n            {\n                var rd = new byte[32];\n                RNG.GetBytes(rd);\n                PacSecret = $"&secret={Convert.ToBase64String(rd)}";\n            }\n            else\n            {\n                PacSecret = "";\n            }
                var rd = new byte[32];\n                RNG.GetBytes(rd);\n                PacSecret = $"&secret={Convert.ToBase64String(rd)}";\n            }\n            else\n            {\n                PacSecret = "";\n            }\n        private static string GetTimestamp(DateTime value)\n        {
        private static void CopyProxySettingFromLan()\n        {\n            var registry = Registry.CurrentUser\n                .OpenSubKey(@"Software\Microsoft\Windows\CurrentVersion\Internet Settings\Connections", true);\n            var defaultValue = registry.GetValue("DefaultConnectionSettings");\n            try\n            {\n                var connections = registry.GetValueNames();\n                foreach (var each in connections)\n                {
            var registry = Registry.CurrentUser\n                .OpenSubKey(@"Software\Microsoft\Windows\CurrentVersion\Internet Settings\Connections", true);\n            var defaultValue = registry.GetValue("DefaultConnectionSettings");\n            try\n            {\n                var connections = registry.GetValueNames();\n                foreach (var each in connections)\n                {\n                    if (!(each.Equals("DefaultConnectionSettings")\n                        || each.Equals("LAN Connection")\n                        || each.Equals("SavedLegacySettings")))\n                    {
using System.Linq;\nusing System.Reflection;\nusing Newtonsoft.Json;\nusing Shadowsocks.Controller;\nnamespace Shadowsocks.Model\n{\n    [Serializable]\n    public class StatisticsStrategyConfiguration\n    {\n        public static readonly string ID = "com.shadowsocks.strategy.statistics";
using Shadowsocks.Controller;\nnamespace Shadowsocks.Model\n{\n    [Serializable]\n    public class StatisticsStrategyConfiguration\n    {\n        public static readonly string ID = "com.shadowsocks.strategy.statistics";\n        public bool StatisticsEnabled { get; } = true;\n        public bool ByHourOfDay { get; } = true;\n        public bool Ping { get; set; }
﻿using System;\nusing System.Collections.Generic;\nusing System.Data;
﻿using System;\nusing System.Collections.Generic;\nusing System.Data;\nusing System.Drawing;\nusing System.Linq;\nusing System.Windows.Forms;
using System.Collections.Generic;\nusing System.Data;\nusing System.Drawing;\nusing System.Linq;\nusing System.Windows.Forms;\nusing System.Windows.Forms.DataVisualization.Charting;\nusing Shadowsocks.Controller;\nusing Shadowsocks.Model;\nnamespace Shadowsocks.View\n{
            this.tableLayoutPanel1.Controls.Add(this.RemarksTextBox, 1, 5);\n            this.tableLayoutPanel1.Controls.Add(this.RemarksLabel, 0, 5);\n            this.tableLayoutPanel1.Controls.Add(this.IPLabel, 0, 0);\n            this.tableLayoutPanel1.Controls.Add(this.ServerPortLabel, 0, 1);\n            this.tableLayoutPanel1.Controls.Add(this.PasswordLabel, 0, 2);\n            this.tableLayoutPanel1.Controls.Add(this.IPTextBox, 1, 0);\n            this.tableLayoutPanel1.Controls.Add(this.ServerPortTextBox, 1, 1);\n            this.tableLayoutPanel1.Controls.Add(this.PasswordTextBox, 1, 2);\n            this.tableLayoutPanel1.Controls.Add(this.EncryptionLabel, 0, 3);\n            this.tableLayoutPanel1.Controls.Add(this.EncryptionSelect, 1, 3);
            this.tableLayoutPanel1.Controls.Add(this.PasswordTextBox, 1, 2);\n            this.tableLayoutPanel1.Controls.Add(this.EncryptionLabel, 0, 3);\n            this.tableLayoutPanel1.Controls.Add(this.EncryptionSelect, 1, 3);\n            this.tableLayoutPanel1.Controls.Add(this.OneTimeAuth, 1, 7);\n            this.tableLayoutPanel1.Controls.Add(this.TimeoutLabel, 0, 6);\n            this.tableLayoutPanel1.Controls.Add(this.TimeoutTextBox, 1, 6);\n            this.tableLayoutPanel1.Location = new System.Drawing.Point(8, 21);\n            this.tableLayoutPanel1.Margin = new System.Windows.Forms.Padding(0);\n            this.tableLayoutPanel1.Name = "tableLayoutPanel1";\n            this.tableLayoutPanel1.Padding = new System.Windows.Forms.Padding(3);
            "chacha20-ietf",\n            "aes-256-cfb",\n            "aes-192-cfb",\n            "aes-128-cfb",\n            "aes-256-ctr",\n            "aes-192-ctr",\n            "aes-128-ctr",\n            "bf-cfb",\n            "camellia-128-cfb",\n            "camellia-192-cfb",
            "aes-128-ctr",\n            "bf-cfb",\n            "camellia-128-cfb",\n            "camellia-192-cfb",\n            "camellia-256-cfb"});\n            this.EncryptionSelect.Location = new System.Drawing.Point(89, 87);\n            this.EncryptionSelect.Name = "EncryptionSelect";\n            this.EncryptionSelect.Size = new System.Drawing.Size(160, 20);\n            this.EncryptionSelect.TabIndex = 3;\n            // 
            public string Path;\n        }\n        public event EventHandler ConfigChanged;\n        public event EventHandler EnableStatusChanged;\n        // when user clicked Edit PAC, and PAC file has already created\n        public event EventHandler<PathEventArgs> PACFileReadyToOpen;\n        public ShadowsocksController()\n        {\n            _config = Configuration.Load();\n            polipoRunner = new PolipoRunner();
        {\n            _config = Configuration.Load();\n            polipoRunner = new PolipoRunner();\n            polipoRunner.Start(_config.GetCurrentServer());\n            local = new Local(_config.GetCurrentServer());\n            try\n            {\n                local.Start();\n                pacServer = new PACServer();\n                pacServer.PACFileChanged += pacServer_PACFileChanged;
using System.Collections.Generic;\nusing System.Text;\nusing System.Net.Sockets;\nusing System.Net;\nusing Shadowsocks.Encrypt;\nusing Shadowsocks.Model;\nnamespace Shadowsocks.Controller\n{\n    class Local\n    {
using System.Net;\nusing Shadowsocks.Encrypt;\nusing Shadowsocks.Model;\nnamespace Shadowsocks.Controller\n{\n    class Local\n    {\n        private Server config;\n        //private Encryptor encryptor;\n        Socket _listener;
        Socket _listener;\n        public Local(Server config)\n        {\n            this.config = config;\n            //this.encryptor = new Encryptor(config.method, config.password);\n        }\n        public void Start()\n        {\n            try\n            {\n                // Create a TCP/IP socket.
using System.Text;\nnamespace Shadowsocks.Controller\n{\n    class PACServer\n    {\n        private static string PAC_FILE = "pac.txt";
{\n    class PACServer\n    {\n        private static string PAC_FILE = "pac.txt";\n        public void Start()\n        {
        }\n        public void AcceptCallback(IAsyncResult ar)\n        {\n            try\n            {\n                Socket listener = (Socket)ar.AsyncState;\n                listener.BeginAccept(\n                    new AsyncCallback(AcceptCallback),\n                    listener);
                    CompressionMode.Decompress, false))\n                {\n                    n = input.Read(buffer, 0, buffer.Length);\n                    if (n == 0)\n                    {\n                        throw new IOException("can not decompress pac");\n                    }\n                    return System.Text.Encoding.UTF8.GetString(buffer, 0, n);\n                }\n            }
            }\n            WatchPacFile();\n        }\n        private void ReceiveCallback(IAsyncResult ar)\n        {\n            Socket conn = (Socket)ar.AsyncState;\n            try\n            {\n                int bytesRead = conn.EndReceive(ar);\n                string pac = GetPACContent();
            this.QRCodeItem = new System.Windows.Forms.MenuItem();\n            this.aboutItem = new System.Windows.Forms.MenuItem();\n            this.menuItem3 = new System.Windows.Forms.MenuItem();\n            this.quitItem = new System.Windows.Forms.MenuItem();\n            this.panel3 = new System.Windows.Forms.Panel();\n            this.DeleteButton = new System.Windows.Forms.Button();\n            this.AddButton = new System.Windows.Forms.Button();\n            this.ServerGroupBox = new System.Windows.Forms.GroupBox();\n            this.ServersListBox = new System.Windows.Forms.ListBox();
            // \n            // enableItem\n            // \n            this.enableItem.Index = 0;\n            this.enableItem.Text = "&Enable";\n            this.enableItem.Click += new System.EventHandler(this.EnableItem_Click);\n            // \n            // ServersItem\n            // 
            this.ServersItem.Index = 1;\n            this.SeperatorItem.Text = "-";\n            // \n            // ConfigItem\n            // \n            this.ConfigItem.Index = 1;\n            this.ConfigItem.Text = "Edit Servers...";\n            this.ConfigItem.Click += new System.EventHandler(this.Config_Click);\n            // \n            // menuItem4\n            // 
using System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.IO.Compression;\nusing System.Text;\nnamespace Shadowsocks.Controller\n{\n    class PolipoRunner\n    {\n        private Process _process;
        private bool connectionShutdown = false;\n        private bool remoteShutdown = false;\n        private bool closed = false;\n        private object encryptionLock = new object();\n        private object decryptionLock = new object();\n        private DateTime _startConnectTime;\n        private DateTime _startReceivingTime;\n        private DateTime _startSendingTime;\n        private int _bytesToSend;\n        private TCPRelay tcprelay;  // TODO: tcprelay ?= relay
            {\n                CreateRemote();\n                // TODO async resolving\n                IPAddress ipAddress;\n                bool parsed = IPAddress.TryParse(server.server, out ipAddress);\n                if (!parsed)\n                {\n                    IPHostEntry ipHostInfo = Dns.GetHostEntry(server.server);\n                    ipAddress = ipHostInfo.AddressList[0];\n                }
                }\n                IPEndPoint remoteEP = new IPEndPoint(ipAddress, server.server_port);\n                remote = new DirectConnect();\n                ProxyTimer proxyTimer = new ProxyTimer(3000);\n                proxyTimer.AutoReset = false;\n                proxyTimer.Elapsed += proxyConnectTimer_Elapsed;\n                proxyTimer.Enabled = true;
                IPEndPoint remoteEP = new IPEndPoint(ipAddress, server.server_port);\n                remote = new DirectConnect();\n                ProxyTimer proxyTimer = new ProxyTimer(3000);\n                proxyTimer.AutoReset = false;\n                proxyTimer.Elapsed += proxyConnectTimer_Elapsed;\n                proxyTimer.Enabled = true;\n                proxyTimer.DestEndPoint = remoteEP;\n                proxyTimer.Server = server;\n                proxyConnected = false;\n                // Connect to the proxy server.
                }\n                if (_requestLineCount == 0)\n                {\n                    var m = HttpRequestHeaderRegex.Match(line);\n                    if (m.Success)\n                    {\n                        var method = m.Groups[1].Value;\n                        if (method == "CONNECT")\n                        {\n                            _isConnect = true;
                {\n                    var m = HttpRequestHeaderRegex.Match(line);\n                    if (m.Success)\n                    {\n                        var method = m.Groups[1].Value;\n                        if (method == "CONNECT")\n                        {\n                            _isConnect = true;\n                            var location = m.Groups[2].Value;\n                            var locs = location.Split(':');\n                            _targetHost = locs[0];\n                            if (locs.Length > 1)\n                            {
                else\n                {\n                    if (line.IsNullOrEmpty())\n                    {\n                        return true;\n                    }\n                    if (!_isConnect)\n                    {\n                        if (line.StartsWith("Host: "))\n                        {
                    if (line.IsNullOrEmpty())\n                    {\n                        return true;\n                    }\n                    if (!_isConnect)\n                    {\n                        if (line.StartsWith("Host: "))\n                        {\n                            var location = line.Substring(6).Trim();\n                            var locs = location.Split(':');\n                            _targetHost = locs[0];\n                            if (locs.Length > 1)\n                            {
﻿using System;\nusing System.Collections.Generic;\nusing System.Text;\nnamespace shadowsocks_csharp\n{\n    public class RC4\n    {
using System.Collections.Generic;\nusing System.Text;\nnamespace shadowsocks_csharp\n{\n    public class RC4\n    {\n        int enc_index1 = 0;\n        int enc_index2 = 0;\n        int dec_index1 = 0;\n        int dec_index2 = 0;\n        public void Encrypt(byte[] table, byte[] data, int length)\n        {
    public class RC4\n    {\n        int enc_index1 = 0;\n        int enc_index2 = 0;\n        int dec_index1 = 0;\n        int dec_index2 = 0;\n        public void Encrypt(byte[] table, byte[] data, int length)\n        {\n            EncryptOutput(enc_index1, enc_index2, table, data, length);\n        }\n        public void Decrypt(byte[] table, byte[] data, int length)\n        {
            {\n                s[i] = (byte)i;\n            }\n            for (int i = 0, j = 0; i < 256; i++)\n            {\n                j = (j + key[i % key.Length] + s[i]) & 255;\n                Swap(s, i, j);\n            }\n            return s;\n        }
                j = (j + key[i % key.Length] + s[i]) & 255;\n                Swap(s, i, j);\n            }\n            return s;\n        }\n        private void EncryptOutput(int index1, int index2, byte[] s, byte[] data, int length)\n        {\n            for (int n = 0; n < length; n++)\n            {\n                byte b = data[n];
        public long unit;\n        public BandwidthScaleInfo(float value, string unit_name, long unit)\n        {\n            this.value = value;\n            this.unit_name = unit_name;\n            this.unit = unit;\n        }\n    }\n    public static class Utils\n    {
            this.unit = unit;\n        }\n    }\n    public static class Utils\n    {\n        public static bool IsPortableMode()\n        {\n            if (!_portableMode.HasValue)\n            {\n                _portableMode = File.Exists(Path.Combine(Application.StartupPath, "shadowsocks_portable_mode.txt"));\n            }\n            return _portableMode.Value;\n        }\n        // return path to store temporary files\n        public static string GetTempPath()\n        {