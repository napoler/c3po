                if (enabled)\n                {\n                    runKey.SetValue("Shadowsocks", path);\n                }\n                else\n                {\n                    runKey.DeleteValue("Shadowsocks");\n                }\n                runKey.Close();\n                return true;
                }\n                else\n                {\n                    runKey.DeleteValue("Shadowsocks");\n                }\n                runKey.Close();\n                return true;\n            }\n            catch (Exception e)\n            {
                }\n                runKey.Close();\n                return true;\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                return false;\n            }
                return true;\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                return false;\n            }
                string[] runList = runKey.GetValueNames();\n                runKey.Close();\n                foreach (string item in runList)\n                {\n                    if (item.Equals("Shadowsocks"))\n                        return true;
                foreach (string item in runList)\n                {\n                    if (item.Equals("Shadowsocks"))\n                        return true;
                        return true;
                var localPort = GetNextFreeTcpPort();\n                LocalEndPoint = new IPEndPoint(IPAddress.Loopback, localPort);\n                _pluginProcess.StartInfo.Environment["SS_LOCAL_HOST"] = LocalEndPoint.Address.ToString();\n                _pluginProcess.StartInfo.Environment["SS_LOCAL_PORT"] = LocalEndPoint.Port.ToString();\n                _pluginProcess.StartInfo.Arguments = ExpandEnvironmentVariables(_pluginProcess.StartInfo.Arguments, _pluginProcess.StartInfo.EnvironmentVariables);\n                _pluginProcess.Start();
                _pluginJob.AddProcess(_pluginProcess.Handle);\n                _started = true;\n            }\n            return true;\n        }\n        public string ExpandEnvironmentVariables(string name, StringDictionary environmentVariables = null)\n        {\n            // Expand the environment variables from the new process itself\n            if (environmentVariables != null)\n            {
using System.Diagnostics;\nusing System.IO;\nusing System.Text;\nusing System.Threading;\nusing Shadowsocks.Controller;\nusing Shadowsocks.Properties;\nusing Shadowsocks.Model;\nusing Newtonsoft.Json;\nnamespace Shadowsocks.Util.SystemProxy\n{
namespace Shadowsocks.Util.SystemProxy\n{\n    public static class Sysproxy\n    {\n        private const string _userWininetConfigFile = "user-wininet.json";\n        private static string _queryStr;\n        // In general, this won't change\n        // format:\n        //  <flags><CR-LF>\n        //  <proxy-server><CR-LF>
                    var stderr = error.ToString();\n                    var stdout = output.ToString();\n                    var exitCode = process.ExitCode;\n                    if (exitCode != (int)RET_ERRORS.RET_NO_ERROR)\n                    {\n                        throw new ProxyException(stderr);\n                    }\n                    if (arguments == "query")\n                    {\n                        if (stdout.IsNullOrWhiteSpace() || stdout.IsNullOrEmpty())
                    }\n                    if (arguments == "query")\n                    {\n                        if (stdout.IsNullOrWhiteSpace() || stdout.IsNullOrEmpty())\n                        {\n                            // we cannot get user settings\n                            throw new ProxyException("failed to query wininet settings");\n                        }\n                        _queryStr = stdout;\n                    }\n                }
                        }\n                        _queryStr = stdout;\n                    }\n                }\n            }\n        }\n        private static void Save()\n        {\n            try\n            {
                            // Multiply with flyBlue\n                            int red = color.R * flyBlue.R / 255;\n                            int green = color.G * flyBlue.G / 255;\n                            int blue = color.B * flyBlue.B / 255;\n                            int alpha = color.A * flyBlue.A / 255;\n                            iconCopy.SetPixel(x, y, Color.FromArgb(alpha, red, green, blue));
            this.tableLayoutPanel1.Location = new System.Drawing.Point(8, 21);\n            this.tableLayoutPanel1.Margin = new System.Windows.Forms.Padding(0);\n            this.tableLayoutPanel1.Name = "tableLayoutPanel1";\n            this.tableLayoutPanel1.Padding = new System.Windows.Forms.Padding(3);\n            this.tableLayoutPanel1.RowCount = 11;\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel1.TabIndex = 0;\n            // \n            // PluginOptionsLabel\n            // \n            this.PluginOptionsLabel.Anchor = System.Windows.Forms.AnchorStyles.Right;\n            this.PluginOptionsLabel.AutoSize = true;\n            this.PluginOptionsLabel.Location = new System.Drawing.Point(18, 166);\n            this.PluginOptionsLabel.Name = "PluginOptionsLabel";\n            this.PluginOptionsLabel.Size = new System.Drawing.Size(89, 12);\n            this.PluginOptionsLabel.TabIndex = 6;
            this.ServersListBox = new System.Windows.Forms.ListBox();\n            this.tableLayoutPanel1.SuspendLayout();\n            this.panel1.SuspendLayout();\n            this.panel3.SuspendLayout();\n            this.groupBox1.SuspendLayout();\n            this.SuspendLayout();\n            // \n            // tableLayoutPanel1\n            // \n            this.tableLayoutPanel1.AutoSize = true;
                using (StreamWriter sw = new StreamWriter(File.Open(CONFIG_FILE, FileMode.Create)))\n                {\n                    string jsonString = SimpleJson.SimpleJson.SerializeObject(config);\n                    sw.Write(jsonString);\n                    sw.Flush();\n                }\n            }\n            catch (IOException e)\n            {\n                Console.Error.WriteLine(e);
        {\n            Reload();\n            HotkeyReg.RegAllHotkeys();\n        }\n        protected void ReportError(Exception e)\n        {\n            if (Errored != null)
        }\n        protected void ReportError(Exception e)\n        {\n            if (Errored != null)\n            {\n                Errored(this, new ErrorEventArgs(e));\n            }\n        }\n        public Server GetCurrentServer()\n        {
            byte[] output = new byte[16];\n            MbedTLS.md5_init(ctx);\n            MbedTLS.md5_starts(ctx);\n            MbedTLS.md5_update(ctx, input, (uint)input.Length);\n            MbedTLS.md5_finish(ctx, output);\n            MbedTLS.md5_free(ctx);\n            Marshal.FreeHGlobal(ctx);\n            return output;\n        }
            return output;\n        }\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void md5_init(IntPtr ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void md5_free(IntPtr ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void md5_starts(IntPtr ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void md5_update(IntPtr ctx, byte[] input, uint ilen);
    }\n}
using System.Net;\nusing System.Net.Sockets;\nusing System.Text;\nusing Shadowsocks.Encryption;\nusing Shadowsocks.Model;\nusing Shadowsocks.Properties;\nusing Shadowsocks.Util;\nusing System.Threading.Tasks;\nusing System.Web;\nnamespace Shadowsocks.Controller
using System.Web;\nnamespace Shadowsocks.Controller\n{\n    public class PACServer : Listener.Service\n    {\n        public const string RESOURCE_NAME = "pac";\n        private string PacSecret\n        {\n            get\n            {
using System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Data;\nusing System.Drawing;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Windows.Forms;
            this.filename = filename;\n            InitializeComponent();\n            this.Icon = Icon.FromHandle(Resources.ssw128.GetHicon());\n            config = Model.Configuration.Load();\n            if (config.logViewer == null)\n            {\n                config.logViewer = new Model.LogViewerConfig();\n            }\n            else\n            {
            UpdateTexts();\n        }\n        private void UpdateTexts()\n        {\n            FileMenuItem.Text = I18N.GetString("&File");\n            OpenLocationMenuItem.Text = I18N.GetString("&Open Location");\n            ExitMenuItem.Text = I18N.GetString("E&xit");\n            CleanLogsButton.Text = I18N.GetString("&Clean logs");\n            ChangeFontButton.Text = I18N.GetString("Change &font");\n            WrapTextCheckBox.Text = I18N.GetString("&Wrap text");
                }\n                else\n                {\n                    int bytesRead = connection.EndReceive(ar);\n                    if (bytesRead > 0)\n                    {\n                        Logging.Debug(remote, RecvSize, "TCP Relay");\n                        connection.BeginReceive(_connetionRecvBuffer, 0, RecvSize, 0, new AsyncCallback(ReadAll), null);\n                    }\n                    else
                    }\n                    else\n                        Close();\n                }\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }
            // \n            // ServersItem\n            // \n            this.ServersItem.Index = 1;\n            this.ServersItem.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {\n            this.SeperatorItem,\n            this.ConfigItem});\n            this.ServersItem.Text = "&Servers";\n            // \n            // SeperatorItem\n            // \n            this.SeperatorItem.Index = 0;\n            this.SeperatorItem.Text = "-";
            // \n            // editPACFileItem\n            // \n            // QRCodeItem\n            // 
        {\n            try\n            {\n                RegistryKey registry =\n                    Registry.CurrentUser.OpenSubKey("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings",\n                        true);\n                registry.SetValue("ProxyEnable", 0);\n                registry.SetValue("ProxyServer", "");\n                registry.SetValue("AutoConfigURL", "http://127.0.0.1:8093/pac?t=" + GetTimestamp(DateTime.Now));
                SystemProxy.NotifyIE();\n                //Must Notify IE first, or the connections do not chanage\n                CopyProxySettingFromLan();\n            }\n            catch (Exception)\n            {\n                MessageBox.Show("can not change registry!");\n                throw;\n            }\n        }
        {\n            // These lines implement the Interface in the beginning of program \n            // They cause the OS to refresh the settings, causing IP to realy update\n            settingsReturn = InternetSetOption(IntPtr.Zero, INTERNET_OPTION_SETTINGS_CHANGED, IntPtr.Zero, 0);\n            refreshReturn = InternetSetOption(IntPtr.Zero, INTERNET_OPTION_REFRESH, IntPtr.Zero, 0);\n        }\n        public static void Enable()\n        {\n            RegistryKey registry = Registry.CurrentUser.OpenSubKey("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings", true);\n            registry.SetValue("ProxyEnable", 1);\n            registry.SetValue("ProxyServer", "127.0.0.1:8123");\n            SystemProxy.UpdateIE();
        }\n        public static void Disable()\n        {\n            RegistryKey registry = Registry.CurrentUser.OpenSubKey("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings", true);\n            registry.SetValue("ProxyEnable", 0);\n            registry.SetValue("ProxyServer", "");\n            SystemProxy.UpdateIE();\n        }
        }\n    }\n}
using System.Web;\nusing Shadowsocks.Controller;\nnamespace Shadowsocks.Model\n{\n    [Serializable]\n    public class Server\n    {\n        public static readonly Regex\n            UrlFinder = new Regex(@"ss://(?<base64>[A-Za-z0-9+-/=_]+)(?:#(?<tag>\S+))?", RegexOptions.IgnoreCase),\n            DetailsParser = new Regex(@"^((?<method>.+?):(?<password>.*)@(?<hostname>.+?):(?<port>\d+?))$", RegexOptions.IgnoreCase);
        private const int DefaultServerTimeoutSec = 5;\n        public const int MaxServerTimeoutSec = 20;\n        public string server;\n        public int server_port;\n        public string password;\n        public string method;\n        public string remarks;\n        public int timeout;
            List<Server> servers = new List<Server>();\n            foreach (Match match in matches)\n            {\n                Server tmp = new Server();\n                var base64 = match.Groups["base64"].Value;\n                var tag = match.Groups["tag"].Value;\n                if (!tag.IsNullOrEmpty())\n                {\n                    tmp.remarks = HttpUtility.UrlDecode(tag, Encoding.UTF8);
            {\n                Server tmp = new Server();\n                var base64 = match.Groups["base64"].Value;\n                var tag = match.Groups["tag"].Value;\n                if (!tag.IsNullOrEmpty())\n                {\n                    tmp.remarks = HttpUtility.UrlDecode(tag, Encoding.UTF8);\n                }\n                Match details = DetailsParser.Match(Encoding.UTF8.GetString(Convert.FromBase64String(
                {\n                    tmp.remarks = HttpUtility.UrlDecode(tag, Encoding.UTF8);\n                }\n                Match details = DetailsParser.Match(Encoding.UTF8.GetString(Convert.FromBase64String(\n                    base64.PadRight(base64.Length + (4 - base64.Length % 4) % 4, '='))));\n                if (!details.Success)
                }\n                Match details = DetailsParser.Match(Encoding.UTF8.GetString(Convert.FromBase64String(\n                    base64.PadRight(base64.Length + (4 - base64.Length % 4) % 4, '='))));\n                if (!details.Success)
                    continue;\n                tmp.method = details.Groups["method"].Value;\n                tmp.password = details.Groups["password"].Value;\n                tmp.server = details.Groups["hostname"].Value;\n                tmp.server_port = int.Parse(details.Groups["port"].Value);
                servers.Add(tmp);\n            }\n            return servers;\n        }\n        public string Identifier()\n        {\n            return server + ':' + server_port;\n        }\n    }\n}
            this.tableLayoutPanel1.Controls.Add(this.IPLabel, 0, 0);\n            this.tableLayoutPanel1.Controls.Add(this.ServerPortLabel, 0, 1);\n            this.tableLayoutPanel1.Controls.Add(this.PasswordLabel, 0, 2);\n            this.tableLayoutPanel1.Controls.Add(this.IPTextBox, 1, 0);\n            this.tableLayoutPanel1.Controls.Add(this.ServerPortTextBox, 1, 1);\n            this.tableLayoutPanel1.Controls.Add(this.PasswordTextBox, 1, 2);\n            this.tableLayoutPanel1.Controls.Add(this.EncryptionLabel, 0, 3);\n            this.tableLayoutPanel1.Controls.Add(this.EncryptionSelect, 1, 3);\n            this.tableLayoutPanel1.Controls.Add(this.TimeoutLabel, 0, 6);\n            this.tableLayoutPanel1.Controls.Add(this.TimeoutTextBox, 1, 6);
            this.tableLayoutPanel1.Location = new System.Drawing.Point(8, 21);\n            this.tableLayoutPanel1.Margin = new System.Windows.Forms.Padding(0);\n            this.tableLayoutPanel1.Name = "tableLayoutPanel1";\n            this.tableLayoutPanel1.Padding = new System.Windows.Forms.Padding(3);\n            this.tableLayoutPanel1.RowCount = 7;\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel1.TabIndex = 0;\n            // 
                File.WriteAllBytes(DATABASE_PATH, Resources.dlc_dat);\n            }\n            LoadGeositeList();\n        }\n        static void LoadGeositeList(byte[] data = null)\n        {\n            data = data ?? File.ReadAllBytes(DATABASE_PATH);\n            var list = GeositeList.Parser.ParseFrom(data);\n            foreach (var item in list.Entries)\n            {
            foreach (var item in list.Entries)\n            {\n                Geosites[item.GroupName.ToLower()] = item.Domains;\n            }\n        }\n        public static void ResetEvent()\n        {\n            UpdateCompleted = null;\n            Error = null;\n        }
        {\n            string geositeUrl = GEOSITE_URL;\n            string group = config.geositeGroup;\n            bool blacklist = config.geositeBlacklistMode;\n            if (!string.IsNullOrWhiteSpace(config.geositeUrl))\n            {\n                logger.Info("Found custom Geosite URL in config file");
            if (config.enabled)\n            {\n                http.Proxy = new WebProxy(\n                    config.isIPv6Enabled\n                    ? $"[{IPAddress.IPv6Loopback}]"\n                    : IPAddress.Loopback.ToString(),\n                    config.localPort);\n            }\n            http.DownloadDataCompleted += (o, e) =>\n            {
                    config.isIPv6Enabled\n                    ? $"[{IPAddress.IPv6Loopback}]"\n                    : IPAddress.Loopback.ToString(),\n                    config.localPort);\n            }\n            http.DownloadDataCompleted += (o, e) =>\n            {\n                try\n                {\n                    File.WriteAllBytes(DATABASE_PATH, e.Result);
        }\n        public static bool MergeAndWritePACFile(string group, bool blacklist)\n        {\n            IList<DomainObject> domains = Geosites[group];\n            string abpContent = MergePACFile(domains, blacklist);\n            if (File.Exists(PACDaemon.PAC_FILE))\n            {\n                string original = FileManager.NonExclusiveReadAllText(PACDaemon.PAC_FILE, Encoding.UTF8);\n                if (original == abpContent)\n                {
        public ConfigForm(ShadowsocksController controller)\n        {\n            InitializeComponent();\n            notifyIcon1.ContextMenu = contextMenu1;\n            this.controller = controller;\n            controller.EnableStatusChanged += controller_EnableStatusChanged;\n            controller.ConfigChanged += controller_ConfigChanged;\n            controller.PACFileReadyToOpen += controller_PACFileReadyToOpen;\n            updateUI();\n        }
        }\n        private void controller_ConfigChanged(object sender, EventArgs e)\n        {\n            updateUI();\n        }\n        private void controller_EnableStatusChanged(object sender, EventArgs e)\n        {\n            updateUI();\n        }\n        void controller_PACFileReadyToOpen(object sender, ShadowsocksController.PathEventArgs e)
        }\n        private void controller_EnableStatusChanged(object sender, EventArgs e)\n        {\n            updateUI();\n        }\n        void controller_PACFileReadyToOpen(object sender, ShadowsocksController.PathEventArgs e)\n        {\n            string argument = @"/select, " + e.Path;\n            System.Diagnostics.Process.Start("explorer.exe", argument);\n        }
        }\n        void controller_PACFileReadyToOpen(object sender, ShadowsocksController.PathEventArgs e)\n        {\n            string argument = @"/select, " + e.Path;\n            System.Diagnostics.Process.Start("explorer.exe", argument);\n        }\n        private void showWindow()\n        {\n            this.Opacity = 1;\n            this.Show();
        {\n            Server server = controller.GetCurrentServer();
            IPTextBox.Text = server.server;\n            ServerPortTextBox.Text = server.server_port.ToString();\n            PasswordTextBox.Text = server.password;\n            ProxyPortTextBox.Text = server.local_port.ToString();\n            EncryptionSelect.Text = server.method == null ? "aes-256-cfb" : server.method;\n            enableItem.Checked = controller.GetConfiguration().enabled;\n        }\n        private void CinfigForm_Load(object sender, EventArgs e)
        }\n        private void CinfigForm_Load(object sender, EventArgs e)
        {\n            if (!controller.GetConfiguration().isDefault)\n            {\n                this.Opacity = 0;\n                BeginInvoke(new MethodInvoker(delegate\n                {\n                    this.Hide();\n                }));\n            }
        }\n        private void CancelButton_Click(object sender, EventArgs e)\n        {\n            this.Hide();\n            updateUI();\n        }\n        private void ConfigForm_FormClosed(object sender, FormClosedEventArgs e)\n        {\n            controller.Stop();\n        }
        }\n        private void ConfigForm_FormClosed(object sender, FormClosedEventArgs e)\n        {\n            controller.Stop();\n        }\n        private void AboutItem_Click(object sender, EventArgs e)\n        {\n            Process.Start("https://github.com/clowwindy/shadowsocks-csharp");\n        }\n        private void notifyIcon1_DoubleClick(object sender, EventArgs e)
            this.label1 = new System.Windows.Forms.Label();\n            this.label2 = new System.Windows.Forms.Label();\n            this.EncryptionSelect = new System.Windows.Forms.ComboBox();\n            this.label3 = new System.Windows.Forms.Label();\n            this.label4 = new System.Windows.Forms.Label();\n            this.IPTextBox = new System.Windows.Forms.TextBox();\n            this.ServerPortTextBox = new System.Windows.Forms.TextBox();\n            this.PasswordTextBox = new System.Windows.Forms.TextBox();
            this.label3 = new System.Windows.Forms.Label();\n            this.label4 = new System.Windows.Forms.Label();\n            this.IPTextBox = new System.Windows.Forms.TextBox();\n            this.ServerPortTextBox = new System.Windows.Forms.TextBox();\n            this.PasswordTextBox = new System.Windows.Forms.TextBox();\n            this.ProxyPortTextBox = new System.Windows.Forms.TextBox();\n            this.notifyIcon1 = new System.Windows.Forms.NotifyIcon(this.components);\n            this.panel2 = new System.Windows.Forms.Panel();
            this.IPTextBox = new System.Windows.Forms.TextBox();\n            this.ServerPortTextBox = new System.Windows.Forms.TextBox();\n            this.PasswordTextBox = new System.Windows.Forms.TextBox();\n            this.ProxyPortTextBox = new System.Windows.Forms.TextBox();\n            this.notifyIcon1 = new System.Windows.Forms.NotifyIcon(this.components);\n            this.panel2 = new System.Windows.Forms.Panel();\n            this.OKButton = new System.Windows.Forms.Button();\n            this.MyCancelButton = new System.Windows.Forms.Button();
            this.notifyIcon1 = new System.Windows.Forms.NotifyIcon(this.components);\n            this.panel2 = new System.Windows.Forms.Panel();\n            this.OKButton = new System.Windows.Forms.Button();\n            this.MyCancelButton = new System.Windows.Forms.Button();\n            this.panel1 = new System.Windows.Forms.Panel();\n            this.contextMenu1 = new System.Windows.Forms.ContextMenu();\n            this.enableItem = new System.Windows.Forms.MenuItem();\n            this.configItem = new System.Windows.Forms.MenuItem();\n            this.editPACFileItem = new System.Windows.Forms.MenuItem();\n            this.aboutItem = new System.Windows.Forms.MenuItem();
            this.groupBox1 = new System.Windows.Forms.GroupBox();\n            this.ServersListBox = new System.Windows.Forms.ListBox();\n            this.tableLayoutPanel1.SuspendLayout();\n            this.panel1.SuspendLayout();\n            this.panel3.SuspendLayout();\n            this.groupBox1.SuspendLayout();\n            this.SuspendLayout();\n            // \n            // tableLayoutPanel1\n            // 
            // \n            // EncryptionSelect\n            // \n            this.EncryptionSelect.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) \n            | System.Windows.Forms.AnchorStyles.Right)));\n            this.EncryptionSelect.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;\n            this.EncryptionSelect.FormattingEnabled = true;\n            this.EncryptionSelect.ImeMode = System.Windows.Forms.ImeMode.NoControl;\n            this.EncryptionSelect.ItemHeight = 13;\n            this.EncryptionSelect.Items.AddRange(new object[] {
            // \n            // groupBox1\n            // \n            this.groupBox1.Controls.Add(this.tableLayoutPanel1);\n            this.groupBox1.Location = new System.Drawing.Point(182, 12);\n            this.groupBox1.Name = "groupBox1";\n            this.groupBox1.Size = new System.Drawing.Size(257, 186);\n            this.groupBox1.TabIndex = 6;\n            this.groupBox1.TabStop = false;\n            this.groupBox1.Text = "Server";
                    {\n                        using (File.Create(path))\n                        {\n                            //do nothing\n                        }\n                    }\n                    catch (Exception e)\n                    {\n                        Logging.LogUsefulException(e);\n                    }\n                    if (!File.Exists(path))
                    }\n                    catch (Exception e)\n                    {\n                        Logging.LogUsefulException(e);\n                    }\n                    if (!File.Exists(path))\n                    {\n                        Console.WriteLine(\n                            $"statistics file does not exist, try to reload {_retryInterval.TotalMinutes} minutes later");\n                        _recorder.Change(_retryInterval, RecordingInterval);
                }\n                RawStatistics = JsonConvert.DeserializeObject<Statistics>(File.ReadAllText(path)) ?? RawStatistics;\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n            }\n        }
            Func<string, object, bool> onLineRead, Action<Exception, object> onException,\n            Action<byte[], int, int, object> onFinish,\n            Encoding encoding, string delimiter, int maxLineBytes,\n            object state)\n        {\n            if (socket == null)
            object state)\n        {\n            if (socket == null)\n            {\n                throw new ArgumentNullException(nameof(socket));\n            }
            {\n                throw new ArgumentException("Line buffer length can't less than first package length!", nameof(maxLineBytes));\n            }\n            if (length > 0)\n            {\n                if (firstPackge == null)\n                {\n                    throw new ArgumentNullException(nameof(firstPackge));\n                }\n            }
            }\n            if (length > 0)\n            {\n                if (firstPackge == null)\n                {\n                    throw new ArgumentNullException(nameof(firstPackge));\n                }\n            }\n            _socket = socket;\n            _onLineRead = onLineRead;
            {\n                throw new ArgumentException("Too small!", nameof(maxLineBytes));\n            }\n            _delimiterSearch = new ByteSearch.SearchTarget(_delimiterBytes);\n            _lineBuffer = new byte[maxLineBytes];\n            if (length > 0)\n            {\n                // process first package\n                Array.Copy(firstPackge, index, _lineBuffer, 0, length);
            }\n            _delimiterSearch = new ByteSearch.SearchTarget(_delimiterBytes);\n            _lineBuffer = new byte[maxLineBytes];\n            if (length > 0)\n            {\n                // process first package\n                Array.Copy(firstPackge, index, _lineBuffer, 0, length);
            if (length > 0)\n            {\n                // process first package\n                Array.Copy(firstPackge, index, _lineBuffer, 0, length);
                _bufferDataLength = length;\n                try\n                {\n                    NewPackageRecv();\n                }\n                catch (Exception ex)\n                {\n                    OnException(ex);\n                    OnFinish();\n                }
            }\n        }\n        public LineReader(WrappedSocket socket, Func<string, object, bool> onLineRead,\n            Action<Exception, object> onException,\n            Action<byte[], int, int, object> onFinish, Encoding encoding, string delimiter, int maxLineBytes,\n            object state)\n            : this(socket, null, 0, 0, onLineRead, onException, onFinish, encoding, delimiter, maxLineBytes, state)
        {\n        }\n        private void ReceiveCallback(IAsyncResult ar)\n        {\n            try\n            {\n                var bytesRead = _socket.EndReceive(ar);\n                if (bytesRead == 0)\n                {\n                    OnFinish();
            // 构造request包剩余部分\n            request[0] = 5;\n            request[1] = 1;\n            request[2] = 0;\n            var st = new Socks5State();\n            st.Callback = callback;\n            st.AsyncState = state;\n            _remote.BeginSend(request, 0, request.Length, 0, Socks5RequestSendCallback, st);
{\n    class TCPRelay : Listener.Service\n    {\n        private ShadowsocksController _controller;\n        private DateTime _lastSweepTime;\n        private Configuration _config;\n        private readonly List<ITCPHandlerFactory> _factories = new List<ITCPHandlerFactory>();\n        public ISet<TCPHandler> Handlers { get; } = new HashSet<TCPHandler>();\n        public TCPRelay(ShadowsocksController controller, Configuration conf)
        public TCPRelay(ShadowsocksController controller, Configuration conf)\n        {\n            _controller = controller;\n            _config = conf;\n            _lastSweepTime = DateTime.Now;\n            _factories.Add(new Socks5HandlerFactory());\n            _factories.Add(new HttpHandlerHandlerFactory());\n        }\n        public override bool Handle(byte[] firstPacket, int length, Socket socket, object state)
        }\n        public override bool Handle(byte[] firstPacket, int length, Socket socket, object state)\n        {\n            TCPHandler handler = null;\n            foreach (var factory in _factories)\n            {\n                if (factory.CanHandle(firstPacket, length))\n                {\n                    handler = factory.NewHandler(_controller, _config, this, socket);\n                    break;
                return false;\n            }\n            socket.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n            IList<TCPHandler> handlersToClose = new List<TCPHandler>();\n            lock (Handlers)\n            {\n                Handlers.Add(handler);\n                DateTime now = DateTime.Now;\n                if (now - _lastSweepTime > TimeSpan.FromSeconds(1))
            socket.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n            IList<TCPHandler> handlersToClose = new List<TCPHandler>();\n            lock (Handlers)\n            {\n                Handlers.Add(handler);\n                DateTime now = DateTime.Now;\n                if (now - _lastSweepTime > TimeSpan.FromSeconds(1))\n                {\n                    _lastSweepTime = now;
    {\n        bool CanHandle(byte[] firstPacket, int length);\n        TCPHandler NewHandler(ShadowsocksController controller, Configuration config, TCPRelay tcprelay, Socket socket);\n    }\n    abstract class TCPHandler\n    {\n        public abstract void StartHandshake(byte[] firstPacket, int length);\n        protected abstract void OnServerConnected(AsyncSession session);\n        protected class AsyncSession
        {\n            public IForwardProxy Remote { get; }\n            public AsyncSession(IForwardProxy remote)\n            {\n                Remote = remote;\n            }\n        }\n        protected class AsyncSession<T> : AsyncSession\n        {\n            public T State { get; set; }
        {\n            public T State { get; set; }\n            public AsyncSession(IForwardProxy remote, T state) : base(remote)\n            {\n                State = state;\n            }
        private AsyncSession _currentRemoteSession;\n        private bool _proxyConnected;\n        private bool _destConnected;\n        private int _totalRead = 0;\n        private int _totalWrite = 0;\n        protected byte[] RemoteRecvBuffer { get; } = new byte[BufferSize];\n        private readonly byte[] _remoteSendBuffer = new byte[BufferSize];\n        protected byte[] ConnetionRecvBuffer { get; } = new byte[BufferSize];\n        private readonly byte[] _connetionSendBuffer = new byte[BufferSize];\n        private IEncryptor _encryptor;
        private DateTime _startConnectTime;\n        private DateTime _startReceivingTime;\n        private DateTime _startSendingTime;\n        private EndPoint _destEndPoint = null;\n        public TCPHandler(ShadowsocksController controller, Configuration config, TCPRelay tcprelay, Socket socket, bool autoAppendHeader = true)\n        {\n            _controller = controller;
        {\n            _controller = controller;\n            _serverHeaderSent = !autoAppendHeader;\n        }
            if (server == null || server.server == "")\n                throw new ArgumentException("No server configured");\n            lock (_encryptionLock)\n            {\n                lock (_decryptionLock)\n                {\n                    _encryptor = EncryptorFactory.GetEncryptor(server.method, server.password, server.auth, false);\n                }\n            }\n            this._server = server;
            try\n            {\n                _startReceivingTime = DateTime.Now;\n                session.Remote.BeginReceive(RemoteRecvBuffer, 0, RecvSize, SocketFlags.None, PipeRemoteReceiveCallback, session);\n                Connection.BeginReceive(ConnetionRecvBuffer, 0, RecvSize, SocketFlags.None, PipeConnectionReceiveCallback, session);\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();
            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void PipeRemoteReceiveCallback(IAsyncResult ar)\n        {
            _totalWrite += length;\n            int bytesToSend;\n            lock (_encryptionLock)\n            {\n            session.Remote.BeginSend(_connetionSendBuffer, 0, bytesToSend, SocketFlags.None, callback, session);\n            IStrategy strategy = _controller.GetCurrentStrategy();
            IStrategy strategy = _controller.GetCurrentStrategy();\n            strategy?.UpdateLastWrite(_server);\n        }\n        protected AsyncSession EndSendToServer(IAsyncResult ar)\n        {\n            var session = (AsyncSession)ar.AsyncState;\n            session.Remote.EndSend(ar);\n            return session;\n        }\n        private void PipeRemoteSendCallback(IAsyncResult ar)
        private void PipeRemoteSendCallback(IAsyncResult ar)\n        {\n            if (Closed) return;\n            try\n            {\n                var session = EndSendToServer(ar);\n                Connection.BeginReceive(ConnetionRecvBuffer, 0, RecvSize, SocketFlags.None, PipeConnectionReceiveCallback, session);\n            }\n            catch (Exception e)
            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void PipeConnectionSendCallback(IAsyncResult ar)\n        {\n            try
                services.Add(tcpRelay);\n                services.Add(udpRelay);\n                //services.Add(new Http2Socks5(_config.localPort));\n                _listener = new Listener(services);\n                _listener.Start(_config);\n            }\n            catch (Exception e)\n            {\n                // translate Microsoft language into human language
                    _encryptIV = new byte[ivLen];\n                    Array.Copy(iv, _encryptIV, ivLen);\n                }\n                else\n                {\n                    // PolarSSL takes key length by bit\n                    // since we'll use CFB mode, here we also do enc, not dec\n                    PolarSSL.aes_setkey_enc(ctx, realkey, keyLen * 8);
                    _decryptIV = new byte[ivLen];\n                    Array.Copy(iv, _decryptIV, ivLen);\n                }\n            }\n            else if (_cipher == CIPHER_RC4)\n            {\n                PolarSSL.arc4_init(ctx);\n                PolarSSL.arc4_setup(ctx, realkey, keyLen);\n            }\n        }
        public event EventHandler PACFileChanged;\n        public void Start(Configuration configuration)\n        {\n            try\n            {\n                config = configuration;\n                // Create a TCP/IP socket.\n                _listener = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
            }\n            catch (SocketException)\n            {\n                _listener.Close();\n                throw;\n            }\n        }\n        public void Stop()\n        {\n            if (gfwlistUpdater != null)
            if (_listener != null)\n            {\n                _listener.Close();\n                _listener = null;\n            }\n        }\n        public string TouchPACFile()\n        {\n            if (File.Exists(PAC_FILE))\n            {
        public IWebProxy proxy = null;\n        public bool useSystemProxy = true;\n        public class GfwListChangedArgs : EventArgs\n        {\n            public string[] GfwList { get; set; }\n        }\n        public event EventHandler<GfwListChangedArgs> GfwListChanged; \n        private bool running = false;\n        private bool closed = false;\n        private int jobId = 0;
        {\n            try\n            {\n                WebClient http = new WebClient();\n                http.Proxy = useSystemProxy ? WebRequest.GetSystemWebProxy() : proxy;\n                return http.DownloadString(new Uri(GFWLIST_URL));
            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(ex.ToString());\n            }\n            return null;\n        }\n        private bool IsExpire()\n        {\n            lock (locker)
            public Parser(string response)\n            {\n                byte[] bytes = Convert.FromBase64String(response);\n                this.Content = Encoding.ASCII.GetString(bytes);\n            }\n            public string[] GetLines()\n            {\n                return Content.Split(new char[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries); 
            }\n            /* refer https://github.com/clowwindy/gfwlist2pac/blob/master/gfwlist2pac/main.py */\n            public string[] GetDomains()\n            {\n                List<string> lines = new List<string>(GetLines());\n                lines.AddRange(GetBuildIn());\n                List<string> domains = new List<string>(lines.Count);\n                for (int i = 0; i < lines.Count; i++)\n                {\n                    string line = lines[i];\n                    if (line.IndexOf(".*") >= 0)
                lines.AddRange(GetBuildIn());\n                List<string> domains = new List<string>(lines.Count);\n                for (int i = 0; i < lines.Count; i++)\n                {\n                    string line = lines[i];\n                    if (line.IndexOf(".*") >= 0)\n                        continue;\n                    if (line.StartsWith("http://"))\n                        line = line.Substring(7);\n                    else if (line.StartsWith("https://"))

            this.tableLayoutPanel1.SuspendLayout();\n            this.panel1.SuspendLayout();\n            this.panel3.SuspendLayout();\n            this.ServerGroupBox.SuspendLayout();\n            this.SuspendLayout();\n            // \n            // tableLayoutPanel1\n            // \n            this.tableLayoutPanel1.AutoSize = true;
            {\n                this.Opacity = 0;\n                BeginInvoke(new MethodInvoker(delegate\n                {\n                    this.Hide();\n                }));\n            }\n            else\n            {\n                isFirstRun = true;
            }\n        }\n        private void ServersListBox_SelectedIndexChanged(object sender, EventArgs e)\n        {
            }\n        }\n        private void UserRuleFileWatcher_Changed(object sender, FileSystemEventArgs e)\n        {\n            if (UserRuleFileChanged != null)\n            {\n                Console.WriteLine("Detected: User Rule file '{0}' was {1}.", e.Name, e.ChangeType.ToString().ToLower());\n                UserRuleFileChanged(this, new EventArgs());\n            }\n        }
        private string GetPACAddress(byte[] requestBuf, int length, IPEndPoint localEndPoint, bool useSocks)\n        {\n            //try\n            //{\n            //    string requestString = Encoding.UTF8.GetString(requestBuf);\n            //    if (requestString.IndexOf("AppleWebKit") >= 0)\n            //    {\n            //        string address = "" + localEndPoint.Address + ":" + config.GetCurrentServer().local_port;\n            //        proxy = "SOCKS5 " + address + "; SOCKS " + address + ";";\n            //    }
                _process.StartInfo.CreateNoWindow = true;\n                _process.StartInfo.RedirectStandardOutput = true;\n                _process.StartInfo.RedirectStandardError = true;\n                _process.Start();\n            }\n        }\n        public void Stop()\n        {\n            if (_process != null)\n            {
                _process.Start();\n            }\n        }\n        public void Stop()\n        {\n            if (_process != null)\n            {\n                try\n                {\n                    _process.Kill();
            onlinePACItem.Checked = onlinePACItem.Enabled && config.useOnlinePac;\n            localPACItem.Checked = !onlinePACItem.Checked;
            }\n        }\n        private void UpdateOnlinePACURLItem_Click(object sender, EventArgs e)\n        {\n            string origPacUrl = controller.GetConfiguration().pacUrl;\n            string pacUrl = Microsoft.VisualBasic.Interaction.InputBox(\n                I18N.GetString("Please input PAC Url"),
using System.IO;\nusing System.IO.Compression;\nusing System.Text;\nnamespace Shadowsocks.Controller\n{\n    public class FileManager\n    {\n        public static bool ByteArrayToFile(string fileName, byte[] content)\n        {\n            try
namespace Shadowsocks.Controller\n{\n    public class FileManager\n    {\n        public static bool ByteArrayToFile(string fileName, byte[] content)\n        {\n            try\n            {\n                System.IO.FileStream _FileStream =\n                   new System.IO.FileStream(fileName, System.IO.FileMode.Create,
                _FileStream.Write(content, 0, content.Length);\n                _FileStream.Close();\n                return true;\n            }\n            catch (Exception _Exception)\n            {\n                Console.WriteLine("Exception caught in process: {0}",\n                                  _Exception.ToString());\n            }\n            return false;
                {\n                    n = input.Read(buffer, 0, buffer.Length);\n                    if (n == 0)\n                    {\n                        break;\n                    }\n                    destinationFile.Write(buffer, 0, n);
                    destinationFile.Write(buffer, 0, n);
                return true;\n            }\n            catch (IOException e)\n            {\n                Console.WriteLine(e.ToString());\n                return false;\n            }\n        }
        }\n        public static void Info(object o)\n        {\n            Console.WriteLine(o);\n        }\n        public static void Debug(object o)\n        {\n#if DEBUG\n            Console.WriteLine("[D] " + o);\n#endif\n        }
        }\n        public static void Debug(object o)\n        {\n#if DEBUG\n            Console.WriteLine("[D] " + o);\n#endif\n        }\n        public static void Debug(EndPoint local, EndPoint remote, int len, string header = null, string tailer = null)\n        {\n#if DEBUG\n            if (header == null && tailer == null)
#endif\n        }\n        public static void Debug(EndPoint local, EndPoint remote, int len, string header = null, string tailer = null)\n        {\n#if DEBUG\n            if (header == null && tailer == null)\n                Debug($"{local} => {remote} (size={len})");\n            else if (header == null && tailer != null)\n                Debug($"{local} => {remote} (size={len}), {tailer}");\n            else if (header != null && tailer == null)
        {\n            WebClient http = new WebClient();\n            http.Proxy = new WebProxy(IPAddress.Loopback.ToString(), 8123);\n            http.DownloadStringCompleted += http_DownloadStringCompleted;\n            http.DownloadStringAsync(new Uri(GFWLIST_URL));\n        }\n        public List<string> ParseResult(string response)\n        {\n            byte[] bytes = Convert.FromBase64String(response);\n            string content = Encoding.ASCII.GetString(bytes);
            http.DownloadStringCompleted += http_DownloadStringCompleted;\n            http.DownloadStringAsync(new Uri(GFWLIST_URL));\n        }\n        public List<string> ParseResult(string response)\n        {\n            byte[] bytes = Convert.FromBase64String(response);\n            string content = Encoding.ASCII.GetString(bytes);\n            string[] lines = content.Split(new char[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);\n            List<string> valid_lines = new List<string>(lines.Length);\n            foreach (string line in lines)
            ChangeFontButton.Text = I18N.GetString("Change &Font");\n            WrapTextCheckBox.Text = I18N.GetString("&Wrap Text");\n            TopMostCheckBox.Text = I18N.GetString("&Top Most");\n            ViewMenuItem.Text = I18N.GetString("&View");\n            CleanLogsMenuItem.Text = I18N.GetString("&Clean Logs");\n            ChangeFontMenuItem.Text = I18N.GetString("Change &Font");\n            WrapTextMenuItem.Text = I18N.GetString("&Wrap Text");\n            TopMostMenuItem.Text = I18N.GetString("&Top Most");\n            ShowToolbarMenuItem.Text = I18N.GetString("&Show Toolbar");\n            Text = I18N.GetString("Log Viewer");
            ChangeFontMenuItem.Text = I18N.GetString("Change &Font");\n            WrapTextMenuItem.Text = I18N.GetString("&Wrap Text");\n            TopMostMenuItem.Text = I18N.GetString("&Top Most");\n            ShowToolbarMenuItem.Text = I18N.GetString("&Show Toolbar");\n            Text = I18N.GetString("Log Viewer");\n            // traffic chart\n            trafficChart.Series["Inbound"].LegendText = I18N.GetString("Inbound");\n            trafficChart.Series["Outbound"].LegendText = I18N.GetString("Outbound");\n        }\n        private void Timer_Tick(object sender, EventArgs e)
        {\n            Logging.Clear();\n            lastOffset = 0;\n            LogMessageTextBox.Clear();\n        }\n        private void CleanLogsMenuItem_Click(object sender, EventArgs e)\n        {\n            DoCleanLogs();\n        }\n        private void CleanLogsButton_Click(object sender, EventArgs e)
        }\n        #endregion\n        #region Change the font settings applied in LogMessageTextBox.\n        private void DoChangeFont()\n        {\n            try\n            {\n                FontDialog fd = new FontDialog();\n                fd.Font = LogMessageTextBox.Font;\n                if (fd.ShowDialog() == DialogResult.OK)
            this.ChangeFontMenuItem = new System.Windows.Forms.MenuItem();\n            this.WrapTextMenuItem = new System.Windows.Forms.MenuItem();\n            this.TopMostMenuItem = new System.Windows.Forms.MenuItem();\n            this.MenuItemSeparater = new System.Windows.Forms.MenuItem();\n            this.ShowToolbarMenuItem = new System.Windows.Forms.MenuItem();\n            this.TopMostCheckBox = new System.Windows.Forms.CheckBox();\n            this.ChangeFontButton = new System.Windows.Forms.Button();\n            this.CleanLogsButton = new System.Windows.Forms.Button();

            // \n            // ChangeFontMenuItem\n            // \n            this.ChangeFontMenuItem.Index = 1;\n            this.ChangeFontMenuItem.Text = "Change &Font";\n            this.ChangeFontMenuItem.Click += new System.EventHandler(this.ChangeFontMenuItem_Click);\n            // \n            // WrapTextMenuItem\n            // \n            this.WrapTextMenuItem.Index = 2;
        private System.Windows.Forms.Button ChangeFontButton;\n        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel1;\n        private System.Windows.Forms.CheckBox TopMostCheckBox;\n        private System.Windows.Forms.MenuItem ViewMenuItem;\n        private System.Windows.Forms.MenuItem CleanLogsMenuItem;\n        private System.Windows.Forms.MenuItem ChangeFontMenuItem;\n        private System.Windows.Forms.MenuItem WrapTextMenuItem;\n        private System.Windows.Forms.MenuItem TopMostMenuItem;\n        private System.Windows.Forms.FlowLayoutPanel ToolbarFlowLayoutPanel;\n        private System.Windows.Forms.MenuItem MenuItemSeparater;
        private System.Windows.Forms.MenuItem ChangeFontMenuItem;\n        private System.Windows.Forms.MenuItem WrapTextMenuItem;\n        private System.Windows.Forms.MenuItem TopMostMenuItem;\n        private System.Windows.Forms.FlowLayoutPanel ToolbarFlowLayoutPanel;\n        private System.Windows.Forms.MenuItem MenuItemSeparater;\n        private System.Windows.Forms.MenuItem ShowToolbarMenuItem;\n        private System.Windows.Forms.SplitContainer splitContainer1;\n        private System.Windows.Forms.DataVisualization.Charting.Chart trafficChart;\n    }\n}
                            targetIndex = i;\n                        }\n                    }\n                }\n                // Still not found, exit\n                if (targetIndex == -1)\n                {\n                    Logging.Info($"Translation for {locale} not found");\n                    return;\n                }
                    }\n                }\n                // Still not found, exit\n                if (targetIndex == -1)\n                {\n                    Logging.Info($"Translation for {locale} not found");\n                    return;\n                }\n                // read translation lines\n                while (!csvParser.EndOfData)
                {\n                    Logging.Info($"Translation for {locale} not found");\n                    return;\n                }\n                // read translation lines\n                while (!csvParser.EndOfData)\n                {\n                    string[] translations = csvParser.ReadFields();\n                    string source = translations[enIndex];\n                    string translation = translations[targetIndex];
                    connection.BeginReceive(_connetionRecvBuffer, 0, RecvSize, SocketFlags.None, new AsyncCallback(ReadAll), null);\n                }\n                else\n                {\n                    int bytesRead = connection.EndReceive(ar);\n                    if (bytesRead > 0)\n                    {\n                        Logging.Debug(remote.LocalEndPoint, remote.DestEndPoint, RecvSize, "TCP Relay");\n                        connection.BeginReceive(_connetionRecvBuffer, 0, RecvSize, SocketFlags.None, new AsyncCallback(ReadAll), null);\n                    }
                        connection.BeginReceive(_connetionRecvBuffer, 0, RecvSize, SocketFlags.None, new AsyncCallback(ReadAll), null);\n                    }\n                    else\n                        Close();\n                }\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();
                // Setting up proxy\n                IPEndPoint proxyEP;\n                if (_config.useProxy)\n                {\n                    parsed = IPAddress.TryParse(_config.proxyServer, out ipAddress);\n                    if (!parsed)\n                    {
                    if (!parsed)\n                    {
                }\n                ProxyTimer proxyTimer = new ProxyTimer(3000);\n                proxyTimer.AutoReset = false;\n                proxyTimer.Elapsed += proxyConnectTimer_Elapsed;\n                proxyTimer.Enabled = true;\n                proxyTimer.DestEndPoint = destEP;\n                proxyTimer.Server = server;
                proxyTimer.Server = server;\n                _proxyConnected = false;\n                // Connect to the proxy server.\n                remote.BeginConnectProxy(proxyEP, new AsyncCallback(ProxyConnectCallback), proxyTimer);\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }
        public void BeginConnectProxy(EndPoint remoteEP, AsyncCallback callback, object state)\n        {\n            // do nothing\n            ProxyEndPoint = remoteEP;\n            var r = new FakeAsyncResult(state);\n            callback?.Invoke(r);\n        }\n        public void EndConnectProxy(IAsyncResult asyncResult)\n        {\n            // do nothing\n        }\n        public void BeginConnectDest(EndPoint remoteEP, AsyncCallback callback, object state)
            var r = new FakeAsyncResult(state);\n            callback?.Invoke(r);\n        }\n        public void EndConnectProxy(IAsyncResult asyncResult)\n        {\n            // do nothing\n        }\n        public void BeginConnectDest(EndPoint remoteEP, AsyncCallback callback, object state)\n        {
        {
            _remote.BeginConnect(remoteEP, callback, state);\n        }\n        public void EndConnectDest(IAsyncResult asyncResult)\n        {\n            _remote?.EndConnect(asyncResult);\n        }\n        public void BeginSend(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state)\n        {\n            _remote?.BeginSend(buffer, offset, size, socketFlags, callback, state);
        void BeginConnectProxy(EndPoint remoteEP, AsyncCallback callback, object state);\n        void EndConnectProxy(IAsyncResult asyncResult);\n        void BeginConnectDest(EndPoint remoteEP, AsyncCallback callback, object state);\n        void EndConnectDest(IAsyncResult asyncResult);\n        void BeginSend(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state);\n        int EndSend(IAsyncResult asyncResult);\n        void BeginReceive(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state);\n        int EndReceive(IAsyncResult asyncResult);
        void EndConnectDest(IAsyncResult asyncResult);\n        void BeginSend(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state);\n        int EndSend(IAsyncResult asyncResult);\n        void BeginReceive(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state);\n        int EndReceive(IAsyncResult asyncResult);\n        void Shutdown(SocketShutdown how);\n        void Close();\n    }
            Bitmap drawArea = new Bitmap((qrCoded.GetModuleCount() * blockSize), (qrCoded.GetModuleCount() * blockSize));\n            for (int row = 0; row < qrCoded.GetModuleCount(); row++)\n            {\n                for (int col = 0; col < qrCoded.GetModuleCount(); col++)\n                {\n                    bool isDark = qrCoded.IsDark(row, col);\n                    if (isDark)
            {\n                for (int col = 0; col < qrCoded.GetModuleCount(); col++)\n                {\n                    bool isDark = qrCoded.IsDark(row, col);\n                    if (isDark)\n                    {\n                        for (int y = 0; y < blockSize; y++)
                {\n                    bool isDark = qrCoded.IsDark(row, col);\n                    if (isDark)\n                    {\n                        for (int y = 0; y < blockSize; y++)\n                        {\n                            int myCol = (blockSize * (col - 1)) + (y + blockSize);\n                            for (int x = 0; x < blockSize; x++)\n                            {
                    {\n                        for (int y = 0; y < blockSize; y++)\n                        {\n                            int myCol = (blockSize * (col - 1)) + (y + blockSize);\n                            for (int x = 0; x < blockSize; x++)\n                            {\n                                drawArea.SetPixel((blockSize * (row - 1)) + (x + blockSize), myCol, Color.Black);\n                            }\n                        }\n                    }
                        {\n                            int myCol = (blockSize * (col - 1)) + (y + blockSize);\n                            for (int x = 0; x < blockSize; x++)\n                            {\n                                drawArea.SetPixel((blockSize * (row - 1)) + (x + blockSize), myCol, Color.Black);\n                            }\n                        }\n                    }\n                    else\n                    {
                            {\n                                drawArea.SetPixel((blockSize * (row - 1)) + (x + blockSize), myCol, Color.Black);\n                            }\n                        }\n                    }\n                    else\n                    {\n                        for (int y = 0; y < blockSize; y++)\n                        {\n                            int myCol = (blockSize * (col - 1)) + (y + blockSize);
                            }\n                        }\n                    }\n                }\n            }\n            pictureBox1.Image = drawArea;\n        }\n        private void QRCodeForm_Load(object sender, EventArgs e)\n        {\n            GenQR(code);
                config.isDefault = false;\n                if (UpdateChecker.Asset.CompareVersion(UpdateChecker.Version, config.version ?? "0") > 0)\n                {\n                    config.updated = true;\n                }\n                if (config.configs == null)\n                    config.configs = new List<Server>();\n                if (config.configs.Count == 0)\n                    config.configs.Add(GetDefaultServer());\n                if (config.localPort == 0)
            }\n            catch (Exception e)\n            {\n                if (!(e is FileNotFoundException))\n                    logger.LogUsefulException(e);\n                return new Configuration\n                {\n                    index = 0,\n                    isDefault = true,\n                    localPort = 1080,
                {\n                    index = 0,\n                    isDefault = true,\n                    localPort = 1080,\n                    autoCheckUpdate = true,\n                    configs = new List<Server>()\n                    {\n                        GetDefaultServer()\n                    },\n                    logViewer = new LogViewerConfig(),
            {\n                LogMessageTextBox.Font = fd.Font;
            }\n        }\n        private void TopMostCheckBox_CheckedChanged(object sender, EventArgs e)\n        {\n            this.TopMost = TopMostCheckBox.Checked;\n        }\n    }\n}
        ///   Looks up a localized string similar to # Sample configuration file for Polipo. -*-sh-*-\n        ///\n        ///# You should not need to use a configuration file; all configuration\n        ///# variables have reasonable defaults.  If you want to use one, you\n        ///# can copy this to /etc/polipo/config or to ~/.polipo and modify.\n        ///\n        ///# This file only contains some of the configuration variables; see the\n        ///# list given by ``polipo -v&apos;&apos; and the manual for more.\n        ///\n        ///\n            }
                {\n                    continue;\n                }
                }\n                catch (UriFormatException)\n                {\n                    continue;\n                }\n                Server tmp = new Server\n                {\n                    remarks = parsedUrl.GetComponents(UriComponents.Fragment, UriFormat.Unescaped)\n                };\n                string possiblyUnpaddedBase64 = parsedUrl.GetComponents(UriComponents.UserInfo, UriFormat.Unescaped);
                string[] userInfoParts = userInfo.Split(new[] { ':' }, 2);\n                if (userInfoParts.Length != 2)\n                {\n                    continue;\n                }\n                tmp.method = userInfoParts[0];\n                tmp.password = userInfoParts[1];\n                NameValueCollection queryParameters = HttpUtility.ParseQueryString(parsedUrl.Query);\n                string[] pluginParts = HttpUtility.UrlDecode(queryParameters["plugin"] ?? "").Split(new[] { ';' }, 2);\n                if (pluginParts.Length > 0)
            this.tableLayoutPanel1.Location = new System.Drawing.Point(8, 21);\n            this.tableLayoutPanel1.Margin = new System.Windows.Forms.Padding(0);\n            this.tableLayoutPanel1.Name = "tableLayoutPanel1";\n            this.tableLayoutPanel1.Padding = new System.Windows.Forms.Padding(3);\n            this.tableLayoutPanel1.RowCount = 7;\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel1.TabIndex = 0;\n            // \n            // RemarksTextBox\n            // \n            this.RemarksTextBox.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));
            this.ProxyPortTextBox = new System.Windows.Forms.TextBox();\n            this.tableLayoutPanel4 = new System.Windows.Forms.TableLayoutPanel();\n            this.ProxyTypeLabel = new System.Windows.Forms.Label();\n            this.ProxyTypeComboBox = new System.Windows.Forms.ComboBox();
            this.ProxyAddrLabel.AutoSize = true;\n            this.ProxyAddrLabel.Location = new System.Drawing.Point(3, 7);\n            this.ProxyAddrLabel.Name = "ProxyAddrLabel";\n            this.ProxyAddrLabel.Size = new System.Drawing.Size(65, 12);\n            this.ProxyAddrLabel.TabIndex = 0;\n            this.ProxyAddrLabel.Text = "Proxy Addr";\n            // \n            // ProxyServerTextBox\n            // \n            this.ProxyServerTextBox.Location = new System.Drawing.Point(74, 3);\n            this.ProxyServerTextBox.MaxLength = 512;\n            this.ProxyServerTextBox.Name = "ProxyServerTextBox";
            // \n            // ProxyPortTextBox\n            // \n            this.ProxyPortTextBox.Location = new System.Drawing.Point(286, 3);\n            this.ProxyPortTextBox.MaxLength = 10;\n            this.ProxyPortTextBox.Name = "ProxyPortTextBox";\n            this.ProxyPortTextBox.Size = new System.Drawing.Size(100, 21);\n            this.ProxyPortTextBox.TabIndex = 3;\n            this.ProxyPortTextBox.WordWrap = false;\n            // \n            // tableLayoutPanel4\n            // \n            this.tableLayoutPanel4.ColumnCount = 2;
            this.tableLayoutPanel4.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());\n            this.tableLayoutPanel4.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());\n            this.tableLayoutPanel4.Controls.Add(this.ProxyTypeLabel, 0, 0);\n            this.tableLayoutPanel4.Controls.Add(this.ProxyTypeComboBox, 1, 0);\n            this.tableLayoutPanel4.Location = new System.Drawing.Point(3, 25);\n            this.tableLayoutPanel4.Name = "tableLayoutPanel4";\n            this.tableLayoutPanel4.RowCount = 1;\n            this.tableLayoutPanel4.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.ProxyTypeLabel.AutoSize = true;\n            this.ProxyTypeLabel.Location = new System.Drawing.Point(3, 9);\n            this.ProxyTypeLabel.Name = "ProxyTypeLabel";\n            this.ProxyTypeLabel.Size = new System.Drawing.Size(65, 12);\n            this.ProxyTypeLabel.TabIndex = 1;\n            this.ProxyTypeLabel.Text = "Proxy Type";\n            // \n            // ProxyTypeComboBox\n            // \n            this.ProxyTypeComboBox.Dock = System.Windows.Forms.DockStyle.Fill;\n            this.ProxyTypeComboBox.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;\n            this.ProxyTypeComboBox.FormattingEnabled = true;\n            this.ProxyTypeComboBox.Items.AddRange(new object[] {
            this.ProxyTypeComboBox.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;\n            this.ProxyTypeComboBox.FormattingEnabled = true;\n            this.ProxyTypeComboBox.Items.AddRange(new object[] {\n            "SOCKS5",\n            "HTTP"});\n            this.ProxyTypeComboBox.Location = new System.Drawing.Point(74, 5);\n            this.ProxyTypeComboBox.Margin = new System.Windows.Forms.Padding(3, 5, 3, 5);\n            this.ProxyTypeComboBox.Name = "ProxyTypeComboBox";\n            this.ProxyTypeComboBox.Size = new System.Drawing.Size(121, 20);\n            this.ProxyTypeComboBox.TabIndex = 2;
        private System.Windows.Forms.TextBox ProxyPortTextBox;\n        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel3;\n        private System.Windows.Forms.Button MyCancelButton;\n        private System.Windows.Forms.Button OKButton;\n        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel4;\n        private System.Windows.Forms.Label ProxyTypeLabel;\n        private System.Windows.Forms.ComboBox ProxyTypeComboBox;\n    }
            if (_config.availabilityStatistics)\n            {\n                availabilityStatistics.UpdateLatency(server, (int)latency.TotalMilliseconds);\n            }\n        }\n        public void UpdateInboundCounter(Server server, long n)\n        {\n            Interlocked.Add(ref _inboundCounter, n);\n            if (_config.availabilityStatistics)
            if (_config.availabilityStatistics)\n            {\n                availabilityStatistics.UpdateInboundCounter(server, n);\n            }\n        }\n        public void UpdateOutboundCounter(Server server, long n)\n        {\n            Interlocked.Add(ref _outboundCounter, n);\n            if (_config.availabilityStatistics)
            if (_config.availabilityStatistics)\n            {\n                availabilityStatistics.UpdateOutboundCounter(server, n);\n            }\n        }\n        protected void Reload()\n        {\n            Encryption.RNG.Reload();\n            // some logic in configuration updated the config when saving, we need to read it again\n            _config = Configuration.Load();
            }\n        }\n        protected void Reload()\n        {\n            Encryption.RNG.Reload();\n            // some logic in configuration updated the config when saving, we need to read it again\n            _config = Configuration.Load();\n            NLogConfig.LoadConfiguration();\n            StatisticsConfiguration = StatisticsStrategyConfiguration.Load();\n            privoxyRunner = privoxyRunner ?? new PrivoxyRunner();
using System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Timers;\nusing Shadowsocks.Controller.Strategy;\nusing Shadowsocks.Encryption;\nusing Shadowsocks.Encryption.AEAD;\nusing Shadowsocks.Encryption.Exception;
    {\n        private static Logger logger = LogManager.GetCurrentClassLogger();\n        private ShadowsocksController _controller;\n        private DateTime _lastSweepTime;
        private DateTime _lastSweepTime;\n        private Configuration _config;\n        public ISet<TCPHandler> Handlers { get; set; }\n        public TCPRelay(ShadowsocksController controller, Configuration conf)\n        {\n            _controller = controller;\n            _config = conf;\n            Handlers = new HashSet<TCPHandler>();\n            _lastSweepTime = DateTime.Now;\n        }
        public ISet<TCPHandler> Handlers { get; set; }\n        public TCPRelay(ShadowsocksController controller, Configuration conf)\n        {\n            _controller = controller;\n            _config = conf;\n            Handlers = new HashSet<TCPHandler>();\n            _lastSweepTime = DateTime.Now;\n        }\n        public override bool Handle(byte[] firstPacket, int length, Socket socket, object state)\n        {
            IList<TCPHandler> handlersToClose = new List<TCPHandler>();\n            lock (Handlers)\n            {\n                Handlers.Add(handler);\n                DateTime now = DateTime.Now;\n                if (now - _lastSweepTime > TimeSpan.FromSeconds(1))\n                {\n                    _lastSweepTime = now;\n                    foreach (TCPHandler handler1 in Handlers)
        }\n    }\n    internal class TCPHandler\n    {\n        class AsyncSession
        {\n            public IProxy Remote { get; }\n            public AsyncSession(IProxy remote)\n            {\n                Remote = remote;\n            }\n        }\n        class AsyncSession<T> : AsyncSession\n        {\n            public T State { get; set; }
        {\n            public T State { get; set; }\n            public AsyncSession(IProxy remote, T state) : base(remote)\n            {\n                State = state;\n            }\n            public AsyncSession(AsyncSession session, T state) : base(session.Remote)\n            {\n                State = state;\n            }
        private readonly int _serverTimeout;\n        private readonly int _proxyTimeout;\n        // each recv size.\n        public const int RecvSize = 2048;\n        // overhead of one chunk, reserved for AEAD ciphers\n        public const int ChunkOverheadSize = 16 * 2 /* two tags */ + AEADEncryptor.CHUNK_LEN_BYTES;\n        // max chunk size\n        public const uint MaxChunkSize = AEADEncryptor.CHUNK_LEN_MASK + AEADEncryptor.CHUNK_LEN_BYTES + 16 * 2;\n        // In general, the ciphertext length, we should take overhead into account\n        public const int BufferSize = RecvSize + (int)MaxChunkSize + 32 /* max salt len */;\n        private ShadowsocksController _controller;\n        private Configuration _config;\n        private TCPRelay _tcprelay;
        private IEncryptor _encryptor;\n        private Server _server;\n        private AsyncSession _currentRemoteSession;\n        private bool _proxyConnected;\n        private bool _destConnected;\n        private byte _command;\n        private byte[] _firstPacket;\n        private int _firstPacketLength;\n        private const int CMD_CONNECT = 0x01;\n        private const int CMD_BIND = 0x02;
        // client -> local proxy (plaintext, before encrypt)\n        private byte[] _connetionRecvBuffer = new byte[BufferSize];\n        // local proxy -> remote (plaintext, after decrypt)\n        private byte[] _remoteSendBuffer = new byte[BufferSize];\n        // local proxy -> client (ciphertext, before decrypt)\n        private byte[] _connetionSendBuffer = new byte[BufferSize];\n        private bool _connectionShutdown = false;\n        private bool _remoteShutdown = false;\n        private bool _closed = false;\n        // instance-based lock without static\n        private readonly object _encryptionLock = new object();\n        private readonly object _decryptionLock = new object();\n        private readonly object _closeConnLock = new object();
        // local proxy -> remote (plaintext, after decrypt)\n        private byte[] _remoteSendBuffer = new byte[BufferSize];\n        // local proxy -> client (ciphertext, before decrypt)\n        private byte[] _connetionSendBuffer = new byte[BufferSize];\n        private bool _connectionShutdown = false;\n        private bool _remoteShutdown = false;\n        private bool _closed = false;\n        // instance-based lock without static\n        private readonly object _encryptionLock = new object();\n        private readonly object _decryptionLock = new object();\n        private readonly object _closeConnLock = new object();\n        private DateTime _startConnectTime;
        // local proxy -> client (ciphertext, before decrypt)\n        private byte[] _connetionSendBuffer = new byte[BufferSize];\n        private bool _connectionShutdown = false;\n        private bool _remoteShutdown = false;\n        private bool _closed = false;\n        // instance-based lock without static\n        private readonly object _encryptionLock = new object();\n        private readonly object _decryptionLock = new object();\n        private readonly object _closeConnLock = new object();\n        private DateTime _startConnectTime;\n        private DateTime _startReceivingTime;
        private bool _connectionShutdown = false;\n        private bool _remoteShutdown = false;\n        private bool _closed = false;\n        // instance-based lock without static\n        private readonly object _encryptionLock = new object();\n        private readonly object _decryptionLock = new object();\n        private readonly object _closeConnLock = new object();\n        private DateTime _startConnectTime;\n        private DateTime _startReceivingTime;\n        private DateTime _startSendingTime;
        {\n            _controller = controller;\n            _config = config;\n            _tcprelay = tcprelay;\n            _connection = socket;\n            _proxyTimeout = config.proxy.proxyTimeout * 1000;\n            _serverTimeout = config.GetCurrentServer().timeout * 1000;\n            lastActivity = DateTime.Now;\n        }
            _connection = socket;\n            _proxyTimeout = config.proxy.proxyTimeout * 1000;\n            _serverTimeout = config.GetCurrentServer().timeout * 1000;\n            lastActivity = DateTime.Now;\n        }\n        public void CreateRemote()\n        {\n            Server server = _controller.GetAServer(IStrategyCallerType.TCP, (IPEndPoint)_connection.RemoteEndPoint,\n                _destEndPoint);\n            if (server == null || server.server == "")
            /* prepare address buffer length for AEAD */\n            Logger.Trace($"_addrBufLength={_addrBufLength}");\n            _encryptor.AddrBufLength = _addrBufLength;\n        }\n        public void Start(byte[] firstPacket, int length)\n        {\n            _firstPacket = firstPacket;\n            _firstPacketLength = length;\n            HandshakeReceive();\n        }
                _closed = true;\n            }\n            lock (_tcprelay.Handlers)\n            {\n                _tcprelay.Handlers.Remove(this);\n            }\n            try\n            {\n                _connection.Shutdown(SocketShutdown.Both);
            try\n            {\n                _connection.Shutdown(SocketShutdown.Both);\n                _connection.Close();\n            }\n            catch (Exception e)\n            {\n                Logger.LogUsefulException(e);\n            }\n            if (_currentRemoteSession != null)
            }\n        }\n        private void HandshakeSendCallback(IAsyncResult ar)\n        {\n            if (_closed) return;\n            try
            try\n            {\n                _connection.EndSend(ar);\n                // +-----+-----+-------+------+----------+----------+\n                // | VER | CMD |  RSV  | ATYP | DST.ADDR | DST.PORT |\n                // +-----+-----+-------+------+----------+----------+\n                // |  1  |  1  | X'00' |  1   | Variable |    2     |\n                // +-----+-----+-------+------+----------+----------+\n                // Skip first 3 bytes, and read 2 more bytes to analysis the address.\n                // 2 more bytes is designed if address is domain then we don't need to read once more to get the addr length.\n                    HandshakeReceive2Callback, null);\n            }\n            catch (Exception e)\n            {\n                Logger.LogUsefulException(e);\n                Close();
            try\n            {\n                int bytesRead = _connection.EndReceive(ar);\n                if (bytesRead >= 5)\n                {\n                    _command = _connetionRecvBuffer[1];
        {\n            try\n            {\n                _connection.EndSend(ar);\n                ReadAddress(StartConnect);\n            }\n            catch (Exception e)\n            {\n                Logger.LogUsefulException(e);\n                Close();
            }\n        }\n        private void ReadAddress(Action onSuccess)\n        {\n            int atyp = _connetionRecvBuffer[3];\n            switch (atyp)\n            {\n                case ATYP_IPv4: // IPv4 address, 4 bytes\n                    ReadAddress(4 + ADDR_PORT_LEN - 1, onSuccess);\n                    break;
            try\n            {\n                int bytesRead = _connection.EndReceive(ar);\n                var states = (object[])ar.AsyncState;\n                int bytesRemain = (int)states[0];\n                var onSuccess = (Action)states[1];\n                if (bytesRead >= bytesRemain)\n                {\n                    _firstPacketLength = bytesRead + 2;\n                    int atyp = _connetionRecvBuffer[0];
                int bytesRemain = (int)states[0];\n                var onSuccess = (Action)states[1];\n                if (bytesRead >= bytesRemain)\n                {\n                    _firstPacketLength = bytesRead + 2;\n                    int atyp = _connetionRecvBuffer[0];\n                    string dstAddr = "Unknown";\n                    int dstPort = -1;\n                    switch (atyp)\n                    {
                if (bytesRead >= bytesRemain)\n                {\n                    _firstPacketLength = bytesRead + 2;\n                    int atyp = _connetionRecvBuffer[0];\n                    string dstAddr = "Unknown";\n                    int dstPort = -1;\n                    switch (atyp)\n                    {\n                        case ATYP_IPv4: // IPv4 address, 4 bytes\n                            dstAddr = new IPAddress(_connetionRecvBuffer.Skip(1).Take(4).ToArray()).ToString();
            }\n        }\n        // inner class\n        private class ProxyTimer : Timer\n        {\n            public AsyncSession Session;\n            public EndPoint DestEndPoint;\n            public Server Server;\n            public ProxyTimer(int p) : base(p)\n            {
                }\n                else\n                {\n                    remote = new DirectConnect();\n                }\n                var session = new AsyncSession(remote);\n                lock (_closeConnLock)\n                {\n                    if (_closed)\n                    {
                lock (_closeConnLock)\n                {\n                    if (_closed)\n                    {\n                        remote.Close();\n                        return;\n                    }\n                    _currentRemoteSession = session;\n                }\n                ProxyTimer proxyTimer = new ProxyTimer(_proxyTimeout) { AutoReset = false };
            }\n        }\n        private void ProxyConnectTimer_Elapsed(object sender, ElapsedEventArgs e)\n        {\n            var timer = (ProxyTimer)sender;\n            timer.Elapsed -= ProxyConnectTimer_Elapsed;\n            timer.Enabled = false;\n            timer.Dispose();\n            if (_proxyConnected || _destConnected || _closed)\n            {
            timer.Elapsed -= ProxyConnectTimer_Elapsed;\n            timer.Enabled = false;\n            timer.Dispose();\n            if (_proxyConnected || _destConnected || _closed)\n            {\n                return;\n            }\n            var proxy = timer.Session.Remote;\n            Logger.Info($"Proxy {proxy.ProxyEndPoint} timed out");\n            proxy.Close();
            Logger.Info($"Proxy {proxy.ProxyEndPoint} timed out");\n            proxy.Close();\n            Close();\n        }\n        private void ProxyConnectCallback(IAsyncResult ar)\n        {\n            if (_closed)\n            {\n                return;\n            }
                ProxyTimer timer = session.State;\n                var destEndPoint = timer.DestEndPoint;\n                var server = timer.Server;\n                timer.Elapsed -= ProxyConnectTimer_Elapsed;\n                timer.Enabled = false;\n                timer.Dispose();\n                var remote = session.Remote;\n                // Complete the connection.\n                remote.EndConnectProxy(ar);\n                _proxyConnected = true;
                timer.Elapsed -= ProxyConnectTimer_Elapsed;\n                timer.Enabled = false;\n                timer.Dispose();\n                var remote = session.Remote;\n                // Complete the connection.\n                remote.EndConnectProxy(ar);\n                _proxyConnected = true;\n                if (!(remote is DirectConnect))\n                {\n                    Logger.Debug($"Socket connected to proxy {remote.ProxyEndPoint}");
                // Complete the connection.\n                remote.EndConnectProxy(ar);\n                _proxyConnected = true;\n                if (!(remote is DirectConnect))\n                {\n                    Logger.Debug($"Socket connected to proxy {remote.ProxyEndPoint}");\n                }\n                _startConnectTime = DateTime.Now;\n                ServerTimer connectTimer = new ServerTimer(_serverTimeout) { AutoReset = false };\n                connectTimer.Elapsed += DestConnectTimer_Elapsed;
                }\n                // Connect to the remote endpoint.\n                remote.BeginConnectDest(destEndPoint, ConnectCallback,\n                    new AsyncSession<ServerTimer>(session, connectTimer), auth);\n            }\n            catch (ArgumentException)\n            {\n            }\n            catch (Exception e)\n            {\n                Logger.LogUsefulException(e);
            }\n        }\n        private void DestConnectTimer_Elapsed(object sender, ElapsedEventArgs e)\n        {\n            var timer = (ServerTimer)sender;\n            timer.Elapsed -= DestConnectTimer_Elapsed;\n            timer.Enabled = false;\n            timer.Dispose();\n            if (_destConnected || _closed)\n            {
            timer.Elapsed -= DestConnectTimer_Elapsed;\n            timer.Enabled = false;\n            timer.Dispose();\n            if (_destConnected || _closed)\n            {\n                return;\n            }\n            var session = timer.Session;\n            Server server = timer.Server;\n            IStrategy strategy = _controller.GetCurrentStrategy();
            Server server = timer.Server;\n            IStrategy strategy = _controller.GetCurrentStrategy();\n            strategy?.SetFailure(server);\n            Logger.Info($"{server.FriendlyName()} timed out");\n            session.Remote.Close();\n            Close();\n        }\n        private void ConnectCallback(IAsyncResult ar)\n        {
            Logger.Info($"{server.FriendlyName()} timed out");\n            session.Remote.Close();\n            Close();\n        }\n        private void ConnectCallback(IAsyncResult ar)\n        {\n            if (_closed) return;\n            try\n            {\n                var session = (AsyncSession<ServerTimer>)ar.AsyncState;
                ServerTimer timer = session.State;\n                _server = timer.Server;\n                timer.Elapsed -= DestConnectTimer_Elapsed;\n                timer.Enabled = false;\n                timer.Dispose();\n                var remote = session.Remote;\n                // Complete the connection.\n                remote.EndConnectDest(ar);\n                _destConnected = true;\n                Logger.Debug($"Socket connected to ss server: {_server.FriendlyName()}");\n                var latency = DateTime.Now - _startConnectTime;
                // Complete the connection.\n                remote.EndConnectDest(ar);\n                _destConnected = true;\n                Logger.Debug($"Socket connected to ss server: {_server.FriendlyName()}");\n                var latency = DateTime.Now - _startConnectTime;\n                IStrategy strategy = _controller.GetCurrentStrategy();\n                strategy?.UpdateLatency(_server, latency);\n                _tcprelay.UpdateLatency(_server, latency);\n                StartPipe(session);
                StartPipe(session);\n            }\n            catch (ArgumentException)\n            {\n            }\n            catch (Exception e)\n            {\n                if (_server != null)\n                {\n                    IStrategy strategy = _controller.GetCurrentStrategy();
            }\n        }\n        private void TryReadAvailableData()\n        {\n            int available = Math.Min(_connection.Available, RecvSize - _firstPacketLength);\n            if (available > 0)\n            {\n                var size = _connection.Receive(_connetionRecvBuffer, _firstPacketLength, available,\n                    SocketFlags.None);\n                _firstPacketLength += size;
                    SocketFlags.None);\n                _firstPacketLength += size;\n            }\n        }\n        private void StartPipe(AsyncSession session)\n        {\n            if (_closed) return;
            try\n            {\n                _startReceivingTime = DateTime.Now;\n                session.Remote.BeginReceive(_remoteRecvBuffer, 0, RecvSize, SocketFlags.None,\n                    PipeRemoteReceiveCallback, session);\n                TryReadAvailableData();\n                Logger.Trace($"_firstPacketLength = {_firstPacketLength}");\n                SendToServer(_firstPacketLength, session);\n            }\n            catch (Exception e)
            }\n        }\n        private void PipeRemoteReceiveCallback(IAsyncResult ar)\n        {\n            if (_closed) return;\n            try\n            {\n                var session = (AsyncSession)ar.AsyncState;
                int bytesRead = session.Remote.EndReceive(ar);\n                _totalRead += bytesRead;\n                _tcprelay.UpdateInboundCounter(_server, bytesRead);\n                if (bytesRead > 0)\n                {\n                    lastActivity = DateTime.Now;\n                    int bytesToSend = -1;\n                    lock (_decryptionLock)\n                    {\n                        try
                if (bytesRead > 0)\n                {\n                    lastActivity = DateTime.Now;\n                    int bytesToSend = -1;\n                    lock (_decryptionLock)\n                    {\n                        try\n                        {\n                            _encryptor.Decrypt(_remoteRecvBuffer, bytesRead, _remoteSendBuffer, out bytesToSend);\n                        }
            }\n        }\n        private void PipeConnectionReceiveCallback(IAsyncResult ar)\n        {\n            if (_closed) return;\n            try
            try\n            {\n                int bytesRead = _connection.EndReceive(ar);\n                var session = (AsyncSession)ar.AsyncState;\n                var remote = session.Remote;\n                if (bytesRead > 0)\n                {\n                    SendToServer(bytesRead, session);\n                }\n                else
                if (bytesRead > 0)\n                {\n                    SendToServer(bytesRead, session);\n                }\n                else\n                {\n                    remote.Shutdown(SocketShutdown.Send);\n                    _remoteShutdown = true;\n                    CheckClose();\n                }
            _startSendingTime = DateTime.Now;\n            session.Remote.BeginSend(_connetionSendBuffer, 0, bytesToSend, SocketFlags.None,\n                PipeRemoteSendCallback, new object[] { session, bytesToSend });\n            IStrategy strategy = _controller.GetCurrentStrategy();\n            strategy?.UpdateLastWrite(_server);\n        }\n        private void PipeRemoteSendCallback(IAsyncResult ar)\n        {\n            if (_closed) return;\n            try
        }\n        private void PipeRemoteSendCallback(IAsyncResult ar)\n        {\n            if (_closed) return;\n            try\n            {\n                var container = (object[])ar.AsyncState;\n                var session = (AsyncSession)container[0];\n                var bytesShouldSend = (int)container[1];
                int bytesSent = session.Remote.EndSend(ar);\n                if (bytesSent > 0)\n                {\n                    lastActivity = DateTime.Now;\n                }\n                int bytesRemaining = bytesShouldSend - bytesSent;\n                if (bytesRemaining > 0)\n                {\n                    Logger.Info("reconstruct _connetionSendBuffer to re-send");\n                    Buffer.BlockCopy(_connetionSendBuffer, bytesSent, _connetionSendBuffer, 0, bytesRemaining);
            }\n        }\n        // In general, we assume there is no delay between local proxy and client, add this for sanity\n        private void PipeConnectionSendCallback(IAsyncResult ar)\n        {\n            try\n            {\n                var container = (object[])ar.AsyncState;\n                var session = (AsyncSession)container[0];\n                var bytesShouldSend = (int)container[1];\n                var bytesSent = _connection.EndSend(ar);
                if (bytesRemaining > 0)\n                {\n                    Logger.Info("reconstruct _remoteSendBuffer to re-send");\n                    Buffer.BlockCopy(_remoteSendBuffer, bytesSent, _remoteSendBuffer, 0, bytesRemaining);\n                    _connection.BeginSend(_remoteSendBuffer, 0, bytesRemaining, SocketFlags.None,\n                        PipeConnectionSendCallback, new object[] { session, bytesRemaining });\n                    return;\n                }\n                session.Remote.BeginReceive(_remoteRecvBuffer, 0, RecvSize, SocketFlags.None,\n                    PipeRemoteReceiveCallback, session);
            "rc4-md5",\n            "salsa20",\n            "chacha20",\n            "aes-256-cfb",\n            "aes-192-cfb",\n            "aes-128-cfb",\n            "rc4"});

        private void RunSinglePolarSSLEncryptionThread()\n        {\n            try\n            {\n                    for (int i = 0; i < 100; i++)\n                    {\n                        var random = new Random();\n                        IEncryptor encryptor;\n                        IEncryptor decryptor;\n                        encryptor = new PolarSSLEncryptor("aes-256-cfb", "barfoo!");
            }\n            catch\n            {\n                encryptionFailed = true;\n                throw;\n            }\n        }\n        [TestMethod]\n        public void TestSodiumEncryption()\n        {
            this.MyCancelButton = new System.Windows.Forms.Button();\n            this.OKButton = new System.Windows.Forms.Button();\n            this.UseProxyCheckBox = new System.Windows.Forms.CheckBox();\n            this.tableLayoutPanel2 = new System.Windows.Forms.TableLayoutPanel();\n            this.ProxyAddrLabel = new System.Windows.Forms.Label();\n            this.ProxyServerTextBox = new System.Windows.Forms.TextBox();\n            this.ProxyPortLabel = new System.Windows.Forms.Label();\n            this.ProxyPortTextBox = new System.Windows.Forms.TextBox();\n            this.tableLayoutPanel4 = new System.Windows.Forms.TableLayoutPanel();\n            this.ProxyTypeLabel = new System.Windows.Forms.Label();
            this.ProxyAddrLabel = new System.Windows.Forms.Label();\n            this.ProxyServerTextBox = new System.Windows.Forms.TextBox();\n            this.ProxyPortLabel = new System.Windows.Forms.Label();\n            this.ProxyPortTextBox = new System.Windows.Forms.TextBox();\n            this.tableLayoutPanel4 = new System.Windows.Forms.TableLayoutPanel();\n            this.ProxyTypeLabel = new System.Windows.Forms.Label();\n            this.ProxyTypeComboBox = new System.Windows.Forms.ComboBox();\n            this.ProxyTimeoutTextBox = new System.Windows.Forms.TextBox();\n            this.ProxyTimeoutLabel = new System.Windows.Forms.Label();
            this.ProxyTypeLabel = new System.Windows.Forms.Label();\n            this.ProxyTypeComboBox = new System.Windows.Forms.ComboBox();\n            this.ProxyTimeoutTextBox = new System.Windows.Forms.TextBox();\n            this.ProxyTimeoutLabel = new System.Windows.Forms.Label();\n            this.tableLayoutPanel1.SuspendLayout();\n            this.tableLayoutPanel3.SuspendLayout();\n            this.tableLayoutPanel2.SuspendLayout();
            this.SuspendLayout();\n            // 
            this.MyCancelButton.Location = new System.Drawing.Point(84, 3);\n            this.MyCancelButton.Margin = new System.Windows.Forms.Padding(3, 3, 0, 0);\n            this.MyCancelButton.Name = "MyCancelButton";\n            this.MyCancelButton.Size = new System.Drawing.Size(75, 23);\n            this.MyCancelButton.TabIndex = 13;\n            this.MyCancelButton.Text = "Cancel";\n            this.MyCancelButton.UseVisualStyleBackColor = true;\n            this.MyCancelButton.Click += new System.EventHandler(this.CancelButton_Click);\n            // \n            // OKButton\n            this.OKButton.Dock = System.Windows.Forms.DockStyle.Right;
            this.OKButton.Location = new System.Drawing.Point(3, 3);\n            this.OKButton.Margin = new System.Windows.Forms.Padding(3, 3, 3, 0);\n            this.OKButton.Name = "OKButton";\n            this.OKButton.Size = new System.Drawing.Size(75, 23);\n            this.OKButton.TabIndex = 12;\n            this.OKButton.Text = "OK";\n            this.OKButton.UseVisualStyleBackColor = true;\n            this.OKButton.Click += new System.EventHandler(this.OKButton_Click);\n            // \n            // UseProxyCheckBox
            this.ResumeLayout(false);\n            this.PerformLayout();\n        }\n        #endregion\n        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel1;\n        private System.Windows.Forms.CheckBox UseProxyCheckBox;\n        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel2;\n        private System.Windows.Forms.Label ProxyAddrLabel;\n        private System.Windows.Forms.TextBox ProxyServerTextBox;\n        private System.Windows.Forms.Label ProxyPortLabel;\n        private System.Windows.Forms.TextBox ProxyPortTextBox;
        }\n        #endregion\n        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel1;\n        private System.Windows.Forms.CheckBox UseProxyCheckBox;\n        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel2;\n        private System.Windows.Forms.Label ProxyAddrLabel;\n        private System.Windows.Forms.TextBox ProxyServerTextBox;\n        private System.Windows.Forms.Label ProxyPortLabel;\n        private System.Windows.Forms.TextBox ProxyPortTextBox;\n        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel3;\n        private System.Windows.Forms.Button MyCancelButton;
        private System.Windows.Forms.CheckBox UseProxyCheckBox;\n        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel2;\n        private System.Windows.Forms.Label ProxyAddrLabel;\n        private System.Windows.Forms.TextBox ProxyServerTextBox;\n        private System.Windows.Forms.Label ProxyPortLabel;\n        private System.Windows.Forms.TextBox ProxyPortTextBox;\n        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel3;\n        private System.Windows.Forms.Button MyCancelButton;\n        private System.Windows.Forms.Button OKButton;\n        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel4;
        private System.Windows.Forms.Label ProxyAddrLabel;\n        private System.Windows.Forms.TextBox ProxyServerTextBox;\n        private System.Windows.Forms.Label ProxyPortLabel;\n        private System.Windows.Forms.TextBox ProxyPortTextBox;\n        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel3;\n        private System.Windows.Forms.Button MyCancelButton;\n        private System.Windows.Forms.Button OKButton;\n        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel4;\n        private System.Windows.Forms.Label ProxyTypeLabel;\n        private System.Windows.Forms.ComboBox ProxyTypeComboBox;
        private System.Windows.Forms.Button MyCancelButton;\n        private System.Windows.Forms.Button OKButton;\n        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel4;\n        private System.Windows.Forms.Label ProxyTypeLabel;\n        private System.Windows.Forms.ComboBox ProxyTypeComboBox;\n        private System.Windows.Forms.TextBox ProxyTimeoutTextBox;\n        private System.Windows.Forms.Label ProxyTimeoutLabel;
        private System.Windows.Forms.Label ProxyTypeLabel;\n        private System.Windows.Forms.ComboBox ProxyTypeComboBox;\n        private System.Windows.Forms.TextBox ProxyTimeoutTextBox;\n        private System.Windows.Forms.Label ProxyTimeoutLabel;\n    }\n}
            this.aboutItem = new System.Windows.Forms.MenuItem();\n            this.menuItem3 = new System.Windows.Forms.MenuItem();\n            this.quitItem = new System.Windows.Forms.MenuItem();\n            this.panel3 = new System.Windows.Forms.Panel();\n            this.DeleteButton = new System.Windows.Forms.Button();\n            this.AddButton = new System.Windows.Forms.Button();\n            this.ServerGroupBox = new System.Windows.Forms.GroupBox();\n            this.ServersListBox = new System.Windows.Forms.ListBox();\n            this.LockButton = new System.Windows.Forms.Button();\n            this.panel4 = new System.Windows.Forms.Panel();
            this.tableLayoutPanel1.SuspendLayout();\n            this.panel1.SuspendLayout();\n            this.panel3.SuspendLayout();\n            this.ServerGroupBox.SuspendLayout();\n            this.panel4.SuspendLayout();\n            this.SuspendLayout();\n            // \n            // tableLayoutPanel1\n            // \n            this.tableLayoutPanel1.AutoSize = true;
            this.SuspendLayout();\n            // \n            // tableLayoutPanel1\n            // \n            this.tableLayoutPanel1.AutoSize = true;\n            this.tableLayoutPanel1.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;\n            this.tableLayoutPanel1.ColumnCount = 2;\n            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());\n            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());\n            this.tableLayoutPanel1.Controls.Add(this.RemarksTextBox, 1, 5);
            this.ClientSize = new System.Drawing.Size(489, 286);\n            this.Controls.Add(this.panel4);\n            this.Controls.Add(this.ServersListBox);\n            this.Controls.Add(this.ServerGroupBox);\n            this.Controls.Add(this.panel1);\n            this.Controls.Add(this.panel3);\n            this.Controls.Add(this.panel2);\n            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedSingle;\n            this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));\n            this.MaximizeBox = false;
            this.Controls.Add(this.ServersListBox);\n            this.Controls.Add(this.ServerGroupBox);\n            this.Controls.Add(this.panel1);\n            this.Controls.Add(this.panel3);\n            this.Controls.Add(this.panel2);\n            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedSingle;\n            this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));\n            this.MaximizeBox = false;\n            this.Name = "ConfigForm";\n            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
            this.FormClosed += new System.Windows.Forms.FormClosedEventHandler(this.ConfigForm_FormClosed);\n            this.Load += new System.EventHandler(this.ConfigForm_Load);\n            this.Shown += new System.EventHandler(this.ConfigForm_Shown);\n            this.tableLayoutPanel1.ResumeLayout(false);\n            this.tableLayoutPanel1.PerformLayout();\n            this.panel1.ResumeLayout(false);\n            this.panel3.ResumeLayout(false);\n            this.ServerGroupBox.ResumeLayout(false);\n            this.ServerGroupBox.PerformLayout();\n            this.panel4.ResumeLayout(false);
            this.ResumeLayout(false);\n            this.PerformLayout();\n        }\n        #endregion\n        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel1;\n        private System.Windows.Forms.Label label1;\n        private System.Windows.Forms.Label label2;\n        private System.Windows.Forms.Label label3;\n        private System.Windows.Forms.Label label4;\n        private System.Windows.Forms.TextBox IPTextBox;
            }\n            else\n            {\n                this.Opacity = 0;\n                BeginInvoke(new MethodInvoker(delegate { this.Hide(); }));\n            }\n        }\n        private void ServersListBox_SelectedIndexChanged(object sender, EventArgs e)\n        {
            }\n        }\n        private void ServersListBox_SelectedIndexChanged(object sender, EventArgs e)\n        {
            }\n            if ( remarks.IsNullOrEmpty() ) {\n                switch ( addr.AddressFamily ) {\n                    case AddressFamily.InterNetwork:\n                        return $"{server}:{server_port}";\n                    case AddressFamily.InterNetworkV6:\n                        return $"[{server}]:{server_port}";\n                }\n            } else {\n                switch ( addr.AddressFamily ) {
            }\n            // If reached here, boom.\n            return null;\n        }\n        public Server()\n        {\n            server = "";\n            server_port = 8388;
        }\n        public Server()\n        {\n            server = "";\n            server_port = 8388;\n            method = "aes-256-cfb";\n            password = "";\n            remarks = "";\n            auth = false;\n        }
            this.Controls.Add(this.QRCodeWebBrowser);\n            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedSingle;\n            this.MaximizeBox = false;\n            this.Name = "QRCodeForm";\n            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;\n            this.Load += new System.EventHandler(this.QRCodeForm_Load);\n            this.ResumeLayout(false);
            long maxSpeed = 0;\n            inboundPoints.Clear();\n            outboundPoints.Clear();\n            foreach (var trafficPerSecond in controller.traffic)\n            {\n                inboundPoints.Add(trafficPerSecond.inboundIncreasement);\n                outboundPoints.Add(trafficPerSecond.outboundIncreasement);\n                maxSpeed = Math.Max(maxSpeed, Math.Max(trafficPerSecond.inboundIncreasement, trafficPerSecond.outboundIncreasement));
            }\n            bandwidthScale = Utils.GetBandwidthScale(maxSpeed);\n            //rescale the original data points, since it is List<float>, .ForEach does not work\n            inboundPoints = inboundPoints.Select(p => p / bandwidthScale.Item3).ToList();\n            outboundPoints = outboundPoints.Select(p => p / bandwidthScale.Item3).ToList();\n            try\n            {\n                if (trafficChart.InvokeRequired && trafficChart.IsHandleCreated)\n                {\n                    trafficChart.Invoke(new Action(() =>\n                    {
            }\n        }\n        private void UpdateTexts()\n        {\n            FileMenuItem.Text = I18N.GetString("&File");\n            OpenLocationMenuItem.Text = I18N.GetString("&Open Location");\n            ExitMenuItem.Text = I18N.GetString("E&xit");\n            CleanLogsButton.Text = I18N.GetString("&Clean Logs");\n            ChangeFontButton.Text = I18N.GetString("Change &Font");\n            WrapTextCheckBox.Text = I18N.GetString("&Wrap Text");
            this.PluginTextBox.MaxLength = 256;\n            this.PluginTextBox.Name = "PluginTextBox";\n            this.PluginTextBox.Size = new System.Drawing.Size(235, 25);\n            this.PluginTextBox.TabIndex = 5;\n            this.PluginTextBox.WordWrap = false;\n            // \n            // RemarksTextBox\n            // \n            this.RemarksTextBox.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));\n            this.RemarksTextBox.Location = new System.Drawing.Point(151, 291);\n            this.RemarksTextBox.Margin = new System.Windows.Forms.Padding(4, 4, 4, 4);\n            this.RemarksTextBox.MaxLength = 32;\n            this.RemarksTextBox.Name = "RemarksTextBox";
            this.RemarksTextBox.MaxLength = 32;\n            this.RemarksTextBox.Name = "RemarksTextBox";\n            this.RemarksTextBox.Size = new System.Drawing.Size(235, 25);\n            this.RemarksTextBox.TabIndex = 8;\n            this.RemarksTextBox.WordWrap = false;\n            // \n            // IPLabel\n            // \n            this.IPLabel.Anchor = System.Windows.Forms.AnchorStyles.Right;\n            this.IPLabel.AutoSize = true;
            this.IPTextBox.MaxLength = 512;\n            this.IPTextBox.Name = "IPTextBox";\n            this.IPTextBox.Size = new System.Drawing.Size(235, 25);\n            this.IPTextBox.TabIndex = 0;\n            this.IPTextBox.WordWrap = false;\n            // \n            // ServerPortTextBox\n            // \n            this.ServerPortTextBox.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));\n            this.ServerPortTextBox.Location = new System.Drawing.Point(151, 41);\n            this.ServerPortTextBox.Margin = new System.Windows.Forms.Padding(4, 4, 4, 4);\n            this.ServerPortTextBox.MaxLength = 10;\n            this.ServerPortTextBox.Name = "ServerPortTextBox";
            this.ServerPortTextBox.MaxLength = 10;\n            this.ServerPortTextBox.Name = "ServerPortTextBox";\n            this.ServerPortTextBox.Size = new System.Drawing.Size(235, 25);\n            this.ServerPortTextBox.TabIndex = 1;\n            this.ServerPortTextBox.WordWrap = false;\n            // \n            // PasswordTextBox\n            // \n            this.PasswordTextBox.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));\n            this.PasswordTextBox.Margin = new System.Windows.Forms.Padding(4, 4, 4, 4);\n            this.PasswordTextBox.MaxLength = 256;\n            this.PasswordTextBox.Name = "PasswordTextBox";
            this.PasswordTextBox.MaxLength = 256;\n            this.PasswordTextBox.Name = "PasswordTextBox";\n            this.PasswordTextBox.Size = new System.Drawing.Size(235, 25);\n            this.PasswordTextBox.TabIndex = 2;\n            this.PasswordTextBox.UseSystemPasswordChar = true;\n            this.PasswordTextBox.WordWrap = false;\n            // \n            // EncryptionLabel\n            // \n            this.EncryptionLabel.Anchor = System.Windows.Forms.AnchorStyles.Right;
            this.PluginOptionsTextBox.MaxLength = 256;\n            this.PluginOptionsTextBox.Name = "PluginOptionsTextBox";\n            this.PluginOptionsTextBox.Size = new System.Drawing.Size(235, 25);\n            this.PluginOptionsTextBox.TabIndex = 6;\n            this.PluginOptionsTextBox.WordWrap = false;\n            // \n            // ShowPasswdCheckBox\n            // \n            this.ShowPasswdCheckBox.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) \n            | System.Windows.Forms.AnchorStyles.Left)));\n            this.ShowPasswdCheckBox.Margin = new System.Windows.Forms.Padding(4, 4, 4, 4);
            this.ShowPasswdCheckBox.Name = "ShowPasswdCheckBox";\n            this.ShowPasswdCheckBox.Size = new System.Drawing.Size(133, 19);\n            this.ShowPasswdCheckBox.TabIndex = 3;\n            this.ShowPasswdCheckBox.Text = "Show Password";\n            this.ShowPasswdCheckBox.TextAlign = System.Drawing.ContentAlignment.MiddleCenter;\n            this.ShowPasswdCheckBox.UseVisualStyleBackColor = true;\n            this.ShowPasswdCheckBox.CheckedChanged += new System.EventHandler(this.ShowPasswdCheckBox_CheckedChanged);\n            // \n            // PluginArgumentsTextBox\n            // \n            this.PluginArgumentsTextBox.Margin = new System.Windows.Forms.Padding(4, 4, 4, 4);
            this.PluginArgumentsTextBox.MaxLength = 512;\n            this.PluginArgumentsTextBox.Name = "PluginArgumentsTextBox";\n            this.PluginArgumentsTextBox.Size = new System.Drawing.Size(235, 25);\n            this.PluginArgumentsTextBox.TabIndex = 7;\n            this.PluginArgumentsTextBox.WordWrap = false;\n            // \n            // PluginArgumentsLabel\n            // \n            this.PluginArgumentsLabel.Anchor = System.Windows.Forms.AnchorStyles.Right;\n            this.PluginArgumentsLabel.AutoSize = true;
            this.tableLayoutPanel5.RowCount = 2;\n            this.tableLayoutPanel5.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel5.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel5.Size = new System.Drawing.Size(251, 82);\n            this.tableLayoutPanel5.TabIndex = 9;\n            // \n            // ProxyPortTextBox\n            // \n            this.ProxyPortTextBox.Anchor = System.Windows.Forms.AnchorStyles.Left;\n            this.ProxyPortTextBox.Location = new System.Drawing.Point(103, 8);\n            this.ProxyPortTextBox.Margin = new System.Windows.Forms.Padding(4, 4, 4, 4);\n            this.ProxyPortTextBox.MaxLength = 10;\n            this.ProxyPortTextBox.Name = "ProxyPortTextBox";
            this.ProxyPortTextBox.MaxLength = 10;\n            this.ProxyPortTextBox.Name = "ProxyPortTextBox";\n            this.ProxyPortTextBox.Size = new System.Drawing.Size(140, 25);\n            this.ProxyPortTextBox.TabIndex = 10;\n            this.ProxyPortTextBox.WordWrap = false;\n            // \n            // ProxyPortLabel\n            // \n            this.ProxyPortLabel.Anchor = System.Windows.Forms.AnchorStyles.Right;\n            this.ProxyPortLabel.AutoSize = true;
        private const string StatisticsFilesName = "shadowsocks.availability.json";\n        public static string AvailabilityStatisticsFile;\n        //static constructor to initialize every public static fields before refereced\n        static AvailabilityStatistics()\n        {\n            AvailabilityStatisticsFile = Utils.GetTempPath(StatisticsFilesName);\n            UnknownDateTime = new DateTime(1970, 1, 1);\n        }\n        //arguments for ICMP tests\n        private int Repeat => Config.RepeatTimesNum;\n        public const int TimeoutMilliseconds = 500;
        }\n        //arguments for ICMP tests\n        private int Repeat => Config.RepeatTimesNum;\n        public const int TimeoutMilliseconds = 500;\n        //records cache for current server in {_monitorInterval} minutes\n        private List<int> _latencyRecords;\n        //speed in KiB/s\n        private long _lastInboundCounter;\n        private List<int> _inboundSpeedRecords;\n        private long _lastOutboundCounter;
            this.allMode.Location = new System.Drawing.Point(11, 61);\n            this.allMode.Margin = new System.Windows.Forms.Padding(5, 10, 5, 10);\n            this.allMode.Name = "allMode";\n            this.allMode.Size = new System.Drawing.Size(58, 31);\n            this.allMode.TabIndex = 1;\n            this.allMode.TabStop = true;\n            this.allMode.Text = "all";\n            this.allMode.UseVisualStyleBackColor = true;\n            this.allMode.CheckedChanged += new System.EventHandler(this.allMode_CheckedChanged);\n            // 
            this.allMode.Text = "all";\n            this.allMode.UseVisualStyleBackColor = true;\n            this.allMode.CheckedChanged += new System.EventHandler(this.allMode_CheckedChanged);\n            // \n            // dayMode\n            // \n            this.dayMode.AutoSize = true;\n            this.dayMode.Location = new System.Drawing.Point(11, 29);\n            this.dayMode.Margin = new System.Windows.Forms.Padding(5, 10, 5, 10);\n            this.dayMode.Name = "dayMode";\n            this.dayMode.Size = new System.Drawing.Size(73, 31);\n            this.dayMode.TabIndex = 0;
            this.splitContainer3.TabIndex = 6;\n            // \n            // label1\n            // \n            this.label1.AutoSize = true;\n            this.label1.Text = "Design evaluation method";\n            // 
            // \n            // calculationContainer\n            // \n            this.calculationContainer.AutoScroll = true;\n            this.calculationContainer.Dock = System.Windows.Forms.DockStyle.Fill;\n            this.calculationContainer.Location = new System.Drawing.Point(0, 0);\n            this.calculationContainer.Margin = new System.Windows.Forms.Padding(5, 10, 5, 10);\n            this.calculationContainer.Name = "calculationContainer";
        {\n            _controller = controller;\n            Handlers = new HashSet<TCPHandler>();\n            _lastSweepTime = DateTime.Now;\n        }\n        public bool Handle(byte[] firstPacket, int length, Socket socket, object state)\n        {\n            if (socket.ProtocolType != ProtocolType.Tcp\n                || (length < 2 || firstPacket[0] != 5))
            handler.connection = socket;\n            handler.controller = _controller;\n            handler.tcprelay = this;\n            handler.Start(firstPacket, length);\n            IList<TCPHandler> handlersToClose = new List<TCPHandler>();\n            lock (Handlers)\n            {\n                Handlers.Add(handler);\n                DateTime now = DateTime.Now;\n                if (now - _lastSweepTime > TimeSpan.FromSeconds(1))
        {\n            _tcprelay = tcprelay;\n        }\n        public void CreateRemote()\n        {\n            Server server = controller.GetAServer(IStrategyCallerType.TCP, (IPEndPoint)connection.RemoteEndPoint);\n            if (server == null || server.server == "")\n                throw new ArgumentException("No server configured");\n            encryptor = EncryptorFactory.GetEncryptor(server.method, server.password, server.auth, false);
                                Logging.Info( $"connect to {dst_addr}:{dst_port}" );\n                            }\n                            break;\n                        case 3:  // domain name, length + str\n                            int len = _connetionRecvBuffer[1];\n                            dst_addr = System.Text.Encoding.UTF8.GetString(_connetionRecvBuffer, 2, len);\n                            dst_port = (_connetionRecvBuffer[len + 2] << 8) + _connetionRecvBuffer[len + 3];\n                            if ( controller.GetCurrentConfiguration().isVerboseLogging ) {\n                                Logging.Info( $"connect to {dst_addr}:{dst_port}" );\n                            }
                                Logging.Info( $"connect to {dst_addr}:{dst_port}" );\n                            }\n                            break;\n                        case 4:  // IPv6 address, 16 bytes\n                            dst_addr = new IPAddress(_connetionRecvBuffer.Skip(1).Take(16).ToArray()).ToString();\n                            dst_port = (_connetionRecvBuffer[17] << 8) + _connetionRecvBuffer[18];\n                            if ( controller.GetCurrentConfiguration().isVerboseLogging ) {\n                                Logging.Info( $"connect to [{dst_addr}]:{dst_port}" );\n                            }\n                            break;
                                Logging.Info( $"connect to [{dst_addr}]:{dst_port}" );\n                            }\n                            break;\n                    }\n                    int bytesToSend;\n                    lock (_encryptionLock)\n                    {\n                        if (_closed) return;\n                        encryptor.Encrypt(_connetionRecvBuffer, bytesRead, _connetionSendBuffer, out bytesToSend);\n                    }
            Logging.LogUsefulException(e.GetException());\n        }\n        void controller_UpdatePACFromGFWListCompleted(object sender, EventArgs e)\n        {\n            isUpdatePACFromGFWListRunning = false;\n            _notifyIcon.BalloonTipTitle = I18N.GetString("Update PAC File via gfwlist...");\n            _notifyIcon.BalloonTipText = I18N.GetString("Update PAC file succeed");\n            _notifyIcon.BalloonTipIcon = ToolTipIcon.Info;\n            _notifyIcon.ShowBalloonTip(5000);
        }\n        void updateChecker_NewVersionFound(object sender, EventArgs e)\n        {\n            _notifyIcon.BalloonTipTitle = String.Format(I18N.GetString("Shadowsocks {0} Update Found"), updateChecker.LatestVersionNumber);\n            _notifyIcon.BalloonTipText = I18N.GetString("Click here to download");\n            _notifyIcon.BalloonTipIcon = ToolTipIcon.Info;\n            _notifyIcon.BalloonTipClicked += notifyIcon1_BalloonTipClicked;\n            _notifyIcon.ShowBalloonTip(5000);\n            _isFirstRun = false;
            _notifyIcon.BalloonTipClicked += notifyIcon1_BalloonTipClicked;\n            _notifyIcon.ShowBalloonTip(5000);\n            _isFirstRun = false;\n        }\n        void notifyIcon1_BalloonTipClicked(object sender, EventArgs e)\n        {\n            System.Diagnostics.Process.Start(updateChecker.LatestVersionURL);\n        }\n        private void LoadCurrentConfiguration()
            _isFirstRun = false;\n        }\n        void notifyIcon1_BalloonTipClicked(object sender, EventArgs e)\n        {\n            System.Diagnostics.Process.Start(updateChecker.LatestVersionURL);\n        }\n        private void LoadCurrentConfiguration()\n        {\n            Configuration config = controller.GetConfiguration();
                {\n                    remote = new Socks5Proxy();\n                    proxyEP = SocketUtil.GetEndPoint(_config.proxyServer, _config.proxyPort);\n                }\n                else\n                {\n                    remote = new DirectConnect();\n                    proxyEP = null;\n                }\n                var session = new AsyncSession(remote);
                }\n                else\n                {\n                    remote = new DirectConnect();\n                    proxyEP = null;\n                }\n                var session = new AsyncSession(remote);\n                _currentRemoteSession = session;\n                ProxyTimer proxyTimer = new ProxyTimer(3000);\n                proxyTimer.AutoReset = false;
            SaveConfig(_config);\n        }\n        public void EnableProxy(string proxy, int port)\n        {\n            _config.useProxy = true;\n            _config.proxyServer = proxy;\n            _config.proxyPort = port;\n            SaveConfig(_config);\n        }\n        public void ToggleVerboseLogging(bool enabled)
            SaveConfig(_config);\n        }\n        public void ToggleVerboseLogging(bool enabled)\n        {\n            _config.isVerboseLogging = enabled;\n            SaveConfig(_config);\n            if ( VerboseLoggingStatusChanged != null ) {\n                VerboseLoggingStatusChanged(this, new EventArgs());\n            }\n        }
            DetailsParser = new Regex("^((?<method>.+?)(?<auth>-auth)??:(?<password>.*)@(?<hostname>.+?)" +\n                                      ":(?<port>\\d+?))$", RegexOptions.Compiled | RegexOptions.IgnoreCase);\n        private const int DefaultServerTimeoutSec = 5;\n        public const int MaxServerTimeoutSec = 20;\n        public string server;\n        public int server_port;\n        public string password;\n        public string method;\n        public string remarks;\n        public bool auth;
        private const int DefaultServerTimeoutSec = 5;\n        public const int MaxServerTimeoutSec = 20;\n        public string server;\n        public int server_port;\n        public string password;\n        public string method;\n        public string remarks;\n        public bool auth;\n        public int timeout;\n        public override int GetHashCode()
                }\n                catch (FormatException)\n                {\n                    MessageBox.Show(I18N.GetString("Illegal port number format"));\n                    return;
            controller.SaveProxyConfig(_modifiedConfiguration);\n            this.Close();\n        }\n        private void CancelButton_Click(object sender, EventArgs e)\n        {\n            this.Close();\n        }\n        private void ProxyForm_FormClosed(object sender, FormClosedEventArgs e)\n        {\n            controller.ConfigChanged -= controller_ConfigChanged;
                int localPort = int.Parse(ProxyPortTextBox.Text);\n                Configuration.CheckServer(server);\n                Configuration.CheckLocalPort(localPort);\n                _modifiedConfiguration.configs[_lastSelectedIndex] = server;\n                _modifiedConfiguration.localPort = localPort;\n                return true;\n            }\n            catch (FormatException)\n            {\n                MessageBox.Show(I18N.GetString("Illegal port number format"));
            }\n            catch (Exception ex)\n            {\n                MessageBox.Show(ex.Message);\n            }\n            return false;\n        }\n        private void LoadSelectedServer()\n        {\n            if (ServersListBox.SelectedIndex >= 0 && ServersListBox.SelectedIndex < _modifiedConfiguration.configs.Count)
            this.pictureBox1 = new System.Windows.Forms.PictureBox();\n            ((System.ComponentModel.ISupportInitialize)(this.pictureBox1)).BeginInit();\n            this.SuspendLayout();\n            // \n            // QRCodeWebBrowser\n            // \n            this.QRCodeWebBrowser.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) \n            | System.Windows.Forms.AnchorStyles.Left) 
            // \n            // pictureBox1\n            // \n            this.pictureBox1.Location = new System.Drawing.Point(0, 0);\n            this.pictureBox1.Name = "pictureBox1";\n            this.pictureBox1.Size = new System.Drawing.Size(205, 205);\n            this.pictureBox1.TabIndex = 1;\n            this.pictureBox1.TabStop = false;
            this.pictureBox1.Name = "pictureBox1";\n            this.pictureBox1.Size = new System.Drawing.Size(205, 205);\n            this.pictureBox1.TabIndex = 1;\n            this.pictureBox1.TabStop = false;
            this.pictureBox1.TabIndex = 1;\n            this.pictureBox1.TabStop = false;
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedSingle;\n            this.MaximizeBox = false;\n            this.MinimizeBox = false;\n            this.Name = "QRCodeForm";\n            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;\n            this.Text = "QRCode";\n            this.Load += new System.EventHandler(this.QRCodeForm_Load);\n            ((System.ComponentModel.ISupportInitialize)(this.pictureBox1)).EndInit();\n            this.ResumeLayout(false);
        private System.Windows.Forms.PictureBox pictureBox1;\n    }\n}
        {\n            _controller = controller;\n            _config = config;\n            _tcprelay = tcprelay;\n            _connection = socket;\n            _proxyTimeout = config.proxy.proxyTimeout * 1000;\n            _serverTimeout = config.GetCurrentServer().timeout * 1000;\n            lastActivity = DateTime.Now;\n        }\n        public void CreateRemote()
            _connection = socket;\n            _proxyTimeout = config.proxy.proxyTimeout * 1000;\n            _serverTimeout = config.GetCurrentServer().timeout * 1000;\n            lastActivity = DateTime.Now;\n        }\n        public void CreateRemote()\n        {\n            Server server = _controller.GetAServer(IStrategyCallerType.TCP, (IPEndPoint)_connection.RemoteEndPoint,\n                _destEndPoint);\n            if (server == null || server.server == "")
        {\n            var dr = MessageBox.Show(I18N.GetString("Import from URL: {0} ?", ssURL), I18N.GetString("Shadowsocks"), MessageBoxButtons.YesNo);\n            if (dr == DialogResult.Yes)\n            {\n                AddServerBySSURL(ssURL);\n            }
        }\n        public bool AddServerBySSURL(string ssURL)\n        {\n            try\n            {\n                if (ssURL.IsNullOrEmpty() || ssURL.IsWhiteSpace())\n                    return false;\n                var servers = Server.GetServers(ssURL);\n                if (servers == null || servers.Count == 0)\n                    return false;
            }\n            else\n            {\n                abpContent = Utils.UnGzip(Resources.abp_js);\n            }\n            abpContent = abpContent.Replace("__RULES__", JsonConvert.SerializeObject(lines, Formatting.Indented));\n            if (File.Exists(PACServer.PAC_FILE))\n            {\n                string original = FileManager.NonExclusiveReadAllText(PACServer.PAC_FILE, Encoding.UTF8);\n                if (original == abpContent)
        }\n        public void CopyPacUrl()\n        {\n            Clipboard.SetDataObject(_pacServer.PacUrl);\n        }\n        #region Memory Management\n        private void StartReleasingMemory()\n        {\n            _ramThread = new Thread(new ThreadStart(ReleaseMemory));\n            _ramThread.IsBackground = true;
            }\n            catch (Exception ex)\n            {\n                Error?.Invoke(this, new ErrorEventArgs(ex));\n            }
        private int totalRead = 0;\n        private int totalWrite = 0;\n        // remote receive buffer\n        private byte[] remoteRecvBuffer = new byte[RecvSize];\n        // remote send buffer\n        private byte[] remoteSendBuffer = new byte[BufferSize];\n        // connection receive buffer\n        private byte[] connetionRecvBuffer = new byte[RecvSize];\n        // connection send buffer\n        private byte[] connetionSendBuffer = new byte[BufferSize];\n        // Received data string.\n        private bool connectionShutdown = false;\n        private bool remoteShutdown = false;
        // remote send buffer\n        private byte[] remoteSendBuffer = new byte[BufferSize];\n        // connection receive buffer\n        private byte[] connetionRecvBuffer = new byte[RecvSize];\n        // connection send buffer\n        private byte[] connetionSendBuffer = new byte[BufferSize];\n        // Received data string.\n        private bool connectionShutdown = false;\n        private bool remoteShutdown = false;\n        private bool closed = false;\n        private object encryptionLock = new object();\n        private object decryptionLock = new object();
        // connection send buffer\n        private byte[] connetionSendBuffer = new byte[BufferSize];\n        // Received data string.\n        private bool connectionShutdown = false;\n        private bool remoteShutdown = false;\n        private bool closed = false;\n        private object encryptionLock = new object();\n        private object decryptionLock = new object();\n        private DateTime _startConnectTime;\n        public void CreateRemote()
                {\n                    MessageBox.Show(I18N.GetString("Illegal port number format"));\n                    ServerPortTextBox.Clear();\n                    return false;\n                }\n                server.password = PasswordTextBox.Text;\n                server.method = EncryptionSelect.Text;\n                server.remarks = RemarksTextBox.Text;\n                try\n                {
                    return false;\n                }\n                server.password = PasswordTextBox.Text;\n                server.method = EncryptionSelect.Text;\n                server.remarks = RemarksTextBox.Text;\n                try\n                {\n                    server.timeout = int.Parse(TimeoutTextBox.Text);\n                }\n                catch (FormatException)
                {\n                    MessageBox.Show(I18N.GetString("Illegal timeout format"));\n                    TimeoutTextBox.Clear();\n                    return false;\n                }\n                server.auth = OneTimeAuth.Checked;\n                int localPort = int.Parse(ProxyPortTextBox.Text);\n                Configuration.CheckServer(server);\n                Configuration.CheckLocalPort(localPort);\n                _modifiedConfiguration.configs[_lastSelectedIndex] = server;
                    return false;\n                }\n                server.auth = OneTimeAuth.Checked;\n                int localPort = int.Parse(ProxyPortTextBox.Text);\n                Configuration.CheckServer(server);\n                Configuration.CheckLocalPort(localPort);\n                _modifiedConfiguration.configs[_lastSelectedIndex] = server;\n                _modifiedConfiguration.localPort = localPort;\n                return true;\n            }
                return false;\n            }\n            if (length < 2 || firstPacket[0] != 5)\n            {\n                return false;\n            }\n            socket.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n            TCPHandler handler = new TCPHandler(this);\n            handler.connection = socket;\n            handler.controller = _controller;
        }\n        public void UpdateInboundCounter(Server server, long n)\n        {\n            _controller.UpdateInboundCounter(server, n);\n        }\n        public void UpdateOutboundCounter(Server server, long n)\n        {\n            _controller.UpdateOutboundCounter(server, n);\n        }\n        public void UpdateLatency(Server server, TimeSpan latency)
        }\n        public void CreateRemote()\n        {\n            Server server = controller.GetAServer(IStrategyCallerType.TCP, (IPEndPoint)connection.RemoteEndPoint);\n            if (server == null || server.server == "")\n            {\n                throw new ArgumentException("No server configured");\n            }\n            encryptor = EncryptorFactory.GetEncryptor(server.method, server.password, server.auth, false);\n            this.server = server;
                throw new ArgumentException("No server configured");\n            }\n            encryptor = EncryptorFactory.GetEncryptor(server.method, server.password, server.auth, false);\n            this.server = server;\n        }\n        public void Start(byte[] firstPacket, int length)\n        {\n            _firstPacket = firstPacket;\n            _firstPacketLength = length;\n            HandshakeReceive();
            encryptor = EncryptorFactory.GetEncryptor(server.method, server.password, server.auth, false);\n            this.server = server;\n        }\n        public void Start(byte[] firstPacket, int length)\n        {\n            _firstPacket = firstPacket;\n            _firstPacketLength = length;\n            HandshakeReceive();\n            lastActivity = DateTime.Now;\n        }
                    return;\n                }\n                _closed = true;\n            }\n            if (connection != null)\n            {\n                try\n                {\n                    connection.Shutdown(SocketShutdown.Both);\n                    connection.Close();
            }\n            lock (_encryptionLock)\n            {\n                lock (_decryptionLock)\n                {\n                    if (encryptor != null)\n                    {\n                        ((IDisposable)encryptor).Dispose();\n                    }
                }\n            }\n        }\n        private void HandshakeReceive()\n        {\n            if (_closed)\n            {\n                return;\n            }
            try\n            {\n                int bytesRead = _firstPacketLength;\n                if (bytesRead > 1)\n                {\n                    byte[] response = { 5, 0 };\n                    if (_firstPacket[0] != 5)\n                    {\n                        // reject socks 4\n                        response = new byte[] { 0, 91 };
                    Close();\n                }\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void HandshakeSendCallback(IAsyncResult ar)
            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void HandshakeSendCallback(IAsyncResult ar)\n        {\n            if (_closed)
            try\n            {\n                connection.EndSend(ar);\n                // +-----+-----+-------+------+----------+----------+\n                // | VER | CMD |  RSV  | ATYP | DST.ADDR | DST.PORT |\n                // +-----+-----+-------+------+----------+----------+\n                // |  1  |  1  | X'00' |  1   | Variable |    2     |\n                // +-----+-----+-------+------+----------+----------+\n                // Skip first 3 bytes\n                // TODO validate
                        HandleUDPAssociate();\n                    }\n                }\n                else\n                {\n                    Logging.Debug("failed to recv data in Shadowsocks.Controller.TCPHandler.handshakeReceive2Callback()");\n                    Close();\n                }\n            }\n            catch (Exception e)
                }\n                else\n                {\n                    Logging.Debug("failed to recv data in Shadowsocks.Controller.TCPHandler.handshakeReceive2Callback()");\n                    Close();\n                }\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);
            }\n            address.CopyTo(response, 4);\n            response[response.Length - 1] = (byte)(port & 0xFF);\n            response[response.Length - 2] = (byte)((port >> 8) & 0xFF);\n            connection.BeginSend(response, 0, response.Length, 0, new AsyncCallback(ReadAll), true);\n        }\n        private void ReadAll(IAsyncResult ar)\n        {\n            if (_closed)\n            {
            try\n            {\n                if (ar.AsyncState != null)\n                {\n                    connection.EndSend(ar);\n                    Logging.Debug(remote, RecvSize, "TCP Relay");\n                    connection.BeginReceive(_connetionRecvBuffer, 0, RecvSize, 0, new AsyncCallback(ReadAll), null);\n                }\n                else\n                {
                        Close();\n                    }\n                }\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }
                }\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void ResponseCallback(IAsyncResult ar)\n        {
            Server server = ((ServerTimer)sender).Server;\n            IStrategy strategy = controller.GetCurrentStrategy();\n            if (strategy != null)\n            {\n                strategy.SetFailure(server);\n            }\n            Logging.Info($"{server.FriendlyName()} timed out");\n            remote.Close();\n            RetryConnect();
            Logging.Info($"{server.FriendlyName()} timed out");\n            remote.Close();\n            RetryConnect();\n        }\n        private void RetryConnect()\n        {\n            if (_retryCount < _maxRetry)\n            {\n                Logging.Debug($"Connection failed, retry ({_retryCount})");\n                StartConnect();
        }\n        private void ConnectCallback(IAsyncResult ar)\n        {\n            Server server = null;\n            if (_closed)\n            {\n                return;\n            }\n            try
            try\n            {\n                ServerTimer timer = (ServerTimer)ar.AsyncState;\n                server = timer.Server;\n                timer.Elapsed -= connectTimer_Elapsed;\n                timer.Enabled = false;\n                timer.Dispose();\n                // Complete the connection.\n                remote.EndConnect(ar);\n                _connected = true;
                timer.Elapsed -= connectTimer_Elapsed;\n                timer.Enabled = false;\n                timer.Dispose();\n                // Complete the connection.\n                remote.EndConnect(ar);\n                _connected = true;\n                var latency = DateTime.Now - _startConnectTime;\n                IStrategy strategy = controller.GetCurrentStrategy();\n                strategy?.UpdateLatency(server, latency);\n                _tcprelay.UpdateLatency(server, latency);
                }\n                Logging.LogUsefulException(e);\n                RetryConnect();\n            }\n        }\n        private void StartPipe()\n        {\n            if (_closed)\n            {\n                return;
            try\n            {\n                _startReceivingTime = DateTime.Now;\n                remote.BeginReceive(_remoteRecvBuffer, 0, RecvSize, 0, new AsyncCallback(PipeRemoteReceiveCallback), null);\n                connection.BeginReceive(_connetionRecvBuffer, 0, RecvSize, 0, new AsyncCallback(PipeConnectionReceiveCallback), null);\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();
                        encryptor.Decrypt(_remoteRecvBuffer, bytesRead, _remoteSendBuffer, out bytesToSend);\n                    }\n                    connection.BeginSend(_remoteSendBuffer, 0, bytesToSend, 0, new AsyncCallback(PipeConnectionSendCallback), null);\n                    IStrategy strategy = controller.GetCurrentStrategy();\n                    if (strategy != null)\n                    {\n                        strategy.UpdateLastRead(server);\n                    }\n                }
                }\n                else\n                {\n                    connection.Shutdown(SocketShutdown.Send);\n                    _connectionShutdown = true;\n                    CheckClose();

        }\n        public string Identifier()\n        {\n            return server + ':' + server_port;\n        }\n    }\n}
                }\n                if (changed)\n                {\n                    LogMessageTextBox.ScrollToCaret();\n                }\n                lastOffset = reader.BaseStream.Position;\n            }\n            this.Text = I18N.GetString("Log Viewer") +\n                $" [in: {Utils.FormatBandwidth(controller.inboundCounter)}, out: {Utils.FormatBandwidth(controller.outboundCounter)}]";
            }\n            this.Text = I18N.GetString("Log Viewer") +\n                $" [in: {Utils.FormatBandwidth(controller.inboundCounter)}, out: {Utils.FormatBandwidth(controller.outboundCounter)}]";\n        }\n        private void LogForm_Load(object sender, EventArgs e)\n        {\n            InitContent();\n            timer = new Timer();\n            timer.Interval = 300;\n            timer.Tick += Timer_Tick;
                sw.AutoFlush = true;\n                Console.SetOut(sw);\n                Console.SetError(sw);\n                return true;\n            }\n            catch (IOException e)\n            {\n                Console.WriteLine(e.ToString());\n                return false;\n            }
        }\n        public static void Error(object o)\n        {\n            WriteToLogFile("[E] " + o);\n        }\n        public static void Info(object o)\n        {\n            WriteToLogFile(o);
            SaveConfig(_config);\n            if (EnableStatusChanged != null)\n            {\n                EnableStatusChanged(this, new EventArgs());\n            }\n        }\n        public void ToggleGlobal(bool global)\n        {\n            _config.global = global;\n            UpdateSystemProxy();
            SaveConfig(_config);\n            if (EnableGlobalChanged != null)\n            {\n                EnableGlobalChanged(this, new EventArgs());\n            }\n        }\n        public void ToggleShareOverLAN(bool enabled)\n        {\n            _config.shareOverLan = enabled;\n            SaveConfig(_config);
            SaveConfig(_config);\n            if (ConfigChanged != null)\n            {\n                ConfigChanged(this, new EventArgs());\n            }\n        }\n        public void UseOnlinePAC(bool useOnlinePac)\n        {\n            _config.useOnlinePac = useOnlinePac;\n            UpdateSystemProxy();
            SaveConfig(_config);\n            if (ConfigChanged != null)\n            {\n                ConfigChanged(this, new EventArgs());\n            }\n        }\n        public void ToggleCheckingUpdate(bool enabled)\n        {\n            _config.autoCheckUpdate = enabled;\n            Configuration.Save(_config);
using System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Net;\nusing System.Net.NetworkInformation;\nusing System.Net.Sockets;\nusing System.Runtime.InteropServices;\nusing System.Text;\nusing System.Windows.Forms;\nusing Shadowsocks.Model;
using System.Net.Sockets;\nusing System.Runtime.InteropServices;\nusing System.Text;\nusing System.Windows.Forms;\nusing Shadowsocks.Model;\nusing Shadowsocks.Properties;\nusing Shadowsocks.Util;\nusing Shadowsocks.Util.ProcessManagement;\nnamespace Shadowsocks.Controller\n{
using System.Text;\nusing System.Windows.Forms;\nusing Shadowsocks.Model;\nusing Shadowsocks.Properties;\nusing Shadowsocks.Util;\nusing Shadowsocks.Util.ProcessManagement;\nnamespace Shadowsocks.Controller\n{\n    class PrivoxyRunner\n    {
                privoxyConfig = privoxyConfig.Replace("__SOCKS_PORT__", configuration.localPort.ToString());\n                privoxyConfig = privoxyConfig.Replace("__PRIVOXY_BIND_PORT__", _runningPort.ToString());\n                privoxyConfig = privoxyConfig.Replace("__PRIVOXY_BIND_IP__", configuration.shareOverLan ? "0.0.0.0" : "127.0.0.1");\n                FileManager.ByteArrayToFile(Utils.GetTempPath(UniqueConfigFile), Encoding.UTF8.GetBytes(privoxyConfig));\n                _process = new Process();\n                // Configure the process using the StartInfo properties.\n                _process.StartInfo.FileName = "ss_privoxy.exe";\n                _process.StartInfo.Arguments = UniqueConfigFile;\n                _process.StartInfo.WorkingDirectory = Utils.GetTempPath();\n                _process.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;
                _process.Start();\n                /*\n                 * Add this process to job obj associated with this ss process, so that\n                 * when ss exit unexpectedly, this process will be forced killed by system.\n                 */\n            RefreshTrayArea();\n        }\n        public void Stop()\n        {
        }\n        public void Stop()\n        {\n            if (_process != null)\n            {\n                KillProcess(_process);\n                _process.Dispose();\n                _process = null;\n            }\n            RefreshTrayArea();
        }\n        private static void KillProcess(Process p)\n        {\n            try\n            {\n                p.CloseMainWindow();\n                p.WaitForExit(100);\n                if (!p.HasExited)\n                {\n                    p.Kill();
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox1)).BeginInit();\n            this.panel1.SuspendLayout();\n            this.SuspendLayout();\n            // \n            // pictureBox1\n            // \n            this.pictureBox1.Dock = System.Windows.Forms.DockStyle.Fill;\n            this.pictureBox1.Location = new System.Drawing.Point(10, 10);\n            this.pictureBox1.Margin = new System.Windows.Forms.Padding(0);\n            this.pictureBox1.Name = "pictureBox1";\n            this.pictureBox1.Size = new System.Drawing.Size(204, 202);\n            this.pictureBox1.SizeMode = System.Windows.Forms.PictureBoxSizeMode.StretchImage;\n            this.pictureBox1.TabIndex = 1;
            this.SuspendLayout();\n            // \n            // pictureBox1\n            // \n            this.pictureBox1.Dock = System.Windows.Forms.DockStyle.Fill;\n            this.pictureBox1.Location = new System.Drawing.Point(10, 10);\n            this.pictureBox1.Margin = new System.Windows.Forms.Padding(0);\n            this.pictureBox1.Name = "pictureBox1";\n            this.pictureBox1.Size = new System.Drawing.Size(204, 202);\n            this.pictureBox1.SizeMode = System.Windows.Forms.PictureBoxSizeMode.StretchImage;\n            this.pictureBox1.TabIndex = 1;\n            this.pictureBox1.TabStop = false;\n            // \n            // panel1
            this.pictureBox1.Margin = new System.Windows.Forms.Padding(0);\n            this.pictureBox1.Name = "pictureBox1";\n            this.pictureBox1.Size = new System.Drawing.Size(204, 202);\n            this.pictureBox1.SizeMode = System.Windows.Forms.PictureBoxSizeMode.StretchImage;\n            this.pictureBox1.TabIndex = 1;\n            this.pictureBox1.TabStop = false;\n            // \n            // panel1\n            // \n            this.panel1.Controls.Add(this.pictureBox1);\n            this.panel1.Dock = System.Windows.Forms.DockStyle.Fill;
            this.pictureBox1.TabIndex = 1;\n            this.pictureBox1.TabStop = false;\n            // \n            // panel1\n            // \n            this.panel1.Controls.Add(this.pictureBox1);\n            this.panel1.Dock = System.Windows.Forms.DockStyle.Fill;\n            this.panel1.Location = new System.Drawing.Point(0, 0);\n            this.panel1.Margin = new System.Windows.Forms.Padding(0);\n            this.panel1.Name = "panel1";\n            this.panel1.Padding = new System.Windows.Forms.Padding(10);
            // QRCodeForm\n            // \n            this.ClientSize = new System.Drawing.Size(224, 222);\n            this.Controls.Add(this.panel1);\n            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedSingle;\n            this.MaximizeBox = false;\n            this.MinimizeBox = false;\n            this.Name = "QRCodeForm";\n            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;\n            this.Text = "QRCode";
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedSingle;\n            this.MaximizeBox = false;\n            this.MinimizeBox = false;\n            this.Name = "QRCodeForm";\n            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;\n            this.Text = "QRCode";\n            this.Load += new System.EventHandler(this.QRCodeForm_Load);\n            ((System.ComponentModel.ISupportInitialize)(this.pictureBox1)).EndInit();\n            this.panel1.ResumeLayout(false);
            this.ResumeLayout(false);\n        }\n        #endregion\n        private System.Windows.Forms.PictureBox pictureBox1;\n        private System.Windows.Forms.Panel panel1;\n    }\n}
    }\n}
        private readonly ConcurrentDictionary<string, List<int>> _inboundSpeedRecords = new ConcurrentDictionary<string, List<int>>();\n        private readonly ConcurrentDictionary<string, long> _outboundCounter = new ConcurrentDictionary<string, long>();\n        private readonly ConcurrentDictionary<string, long> _lastOutboundCounter = new ConcurrentDictionary<string, long>();\n        private readonly ConcurrentDictionary<string, List<int>> _outboundSpeedRecords = new ConcurrentDictionary<string, List<int>>();
        private readonly ConcurrentDictionary<string, List<int>> _outboundSpeedRecords = new ConcurrentDictionary<string, List<int>>();
            {\n                var id = kv.Key;\n                var lastInbound = kv.Value;\n                var inbound = _inboundCounter[id];\n                var bytes = inbound - lastInbound;\n                _lastInboundCounter[id] = inbound;\n                var inboundSpeed = GetSpeedInKiBPerSecond(bytes, _monitorInterval.TotalSeconds);\n                _inboundSpeedRecords.GetOrAdd(id, (k) =>\n                {\n                    List<int> records = new List<int>();
                Logging.Debug(
        }\n        public void UpdateOutboundCounter(Server server, long n)\n        {\n            _outboundCounter.AddOrUpdate(server.Identifier(), (k) =>\n            {\n                _lastOutboundCounter.GetOrAdd(server.Identifier(), 0);\n                return n;\n            }, (k, v) => (v + n));
        }\n        class UpdateRecordsState\n        {\n            public int counter;\n        }\n        class PingState\n        {\n            public UpdateRecordsState state;\n            public StatisticsRecord record;\n        }
                throw new ArgumentException(I18N.GetString("Password can not be blank"));\n        }\n        private static void CheckServer(string server)\n        {\n            if (string.IsNullOrEmpty(server))\n                throw new ArgumentException(I18N.GetString("Server IP can not be blank"));\n        }\n    }\n}
                throw new ArgumentException(I18N.GetString("Server IP can not be blank"));\n        }\n    }\n}
            {\n                return I18N.GetString("New server");\n            }\n            if (string.IsNullOrEmpty(remarks))\n            {\n                return server + ":" + server_port;\n            }\n            else\n            {\n                return remarks + " (" + server + ":" + server_port + ")";
            {\n                return server + ":" + server_port;\n            }\n            else\n            {\n                return remarks + " (" + server + ":" + server_port + ")";\n            }\n        }\n        public Server()\n        {
                {\n                    UpdateOnlinePACURLItem_Click(sender, e);\n                }\n                if (!String.IsNullOrEmpty(controller.GetConfigurationCopy().pacUrl))\n                {\n                    localPACItem.Checked = false;\n                    onlinePACItem.Checked = true;\n                    controller.UseOnlinePAC(true);\n                }\n                UpdatePACItemsEnabledStatus();
                {\n                    localPACItem.Checked = false;\n                    onlinePACItem.Checked = true;\n                    controller.UseOnlinePAC(true);\n                }\n                UpdatePACItemsEnabledStatus();\n            }\n        }\n        private void UpdateOnlinePACURLItem_Click(object sender, EventArgs e)\n        {
                if (i == 0)\n                {\n                    md5sum = md5.ComputeHash(password);\n                }\n                else\n                {\n                    md5sum.CopyTo(result, 0);\n                    password.CopyTo(result, md5sum.Length);\n                    md5sum = md5.ComputeHash(result);\n                }
                }\n                else\n                {\n                    md5sum.CopyTo(result, 0);\n                    password.CopyTo(result, md5sum.Length);\n                    md5sum = md5.ComputeHash(result);\n                }\n                md5sum.CopyTo(key, i);\n                i += md5sum.Length;\n            }
                }\n                md5sum.CopyTo(key, i);\n                i += md5sum.Length;\n            }\n        }\n        protected static void randBytes(byte[] buf, int length)\n        {\n            byte[] temp = new byte[length];\n            RNGCryptoServiceProvider rngServiceProvider = new RNGCryptoServiceProvider();\n            rngServiceProvider.GetBytes(temp);
            this.ShareOverLANItem.Text = "Share over LAN";\n            this.ShareOverLANItem.Click += new System.EventHandler(this.ShareOverLANItem_Click);\n            // \n            // ServersItem\n            // \n            this.ServersItem.Index = 2;\n            this.ServersItem.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {\n            this.SeperatorItem,\n            this.ConfigItem});\n            this.ServersItem.Text = "&Servers";\n            // \n            // SeperatorItem\n            // 
            this.ServersItem.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {\n            this.SeperatorItem,\n            this.ConfigItem});\n            this.ServersItem.Text = "&Servers";\n            // \n            // SeperatorItem\n            // \n            this.SeperatorItem.Index = 0;\n            this.SeperatorItem.Text = "-";\n            // 
                            foreach (ResultPoint point in result.ResultPoints)\n                            {\n                                minX = Math.Min(minX, point.X);\n                                minY = Math.Min(minY, point.Y);\n                                maxX = Math.Max(maxX, point.X);\n                                maxY = Math.Max(maxY, point.Y);\n                            }
        private Configuration _config;\n        public event EventHandler PACFileChanged;\n        public PACServer()\n        {\n            this.WatchPacFile();\n        }\n        public void UpdateConfiguration(Configuration config)\n        {
        {\n            if (PACFileChanged != null)\n            {\n                PACFileChanged(this, new EventArgs());
                {\n                    if (localeNames[i] == "en")
                    }\n                }\n                while (!csvParser.EndOfData)\n                {\n                    string[] translations = csvParser.ReadFields();
                    if (translations[0].TrimStart(' ')[0] == '#') continue;\n                    _strings[translations[enIndex]] = translations[targetIndex];\n                }\n            }\n        }\n        static I18N()\n        {\n            Init(Resources.i18n_csv, CultureInfo.CurrentCulture.IetfLanguageTag);
                }\n            }\n        }\n        static I18N()\n        {\n            Init(Resources.i18n_csv, CultureInfo.CurrentCulture.IetfLanguageTag);
        }\n        public static string GetString(string key, params object[] args)\n        {\n            return string.Format(_strings.TryGetValue(key, out var value) ? value : key, args);\n        }\n        public static void TranslateForm(Form c)\n        {\n            c.Text = GetString(c.Text);\n            foreach (var item in ViewUtils.GetChildControls<Control>(c))\n            {
            this.groupBox1.SuspendLayout();\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer1)).BeginInit();\n            this.splitContainer1.Panel1.SuspendLayout();\n            this.splitContainer1.Panel2.SuspendLayout();\n            this.splitContainer1.SuspendLayout();\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer2)).BeginInit();\n            this.splitContainer2.Panel1.SuspendLayout();\n            this.splitContainer2.Panel2.SuspendLayout();\n            this.splitContainer2.SuspendLayout();\n            ((System.ComponentModel.ISupportInitialize)(this.dataCollectionMinutesNum)).BeginInit();
            public string ServerName;\n            public string ICMPStatus;\n            public int RoundtripTime;\n            public string Geolocation;\n            public string ISP ;\n        }\n        public class StatisticsData\n        {\n            public float PackageLoss;\n            public int AverageResponse;
            var serverUrls = ssURL.Split('\r', '\n');\n            List<Server> servers = new List<Server>();\n            foreach (string serverUrl in serverUrls)\n            {\n                string _serverUrl = serverUrl.Trim();\n                if (!_serverUrl.BeginWith("ss://", StringComparison.InvariantCultureIgnoreCase))\n                {\n                    continue;\n                }\n                // Decode the Base64 part of Uri
                {\n                    parsedUrl = new Uri(decodedServerUrl);\n                }\n                catch (UriFormatException)\n                {\n                    continue;
                }\n                catch (UriFormatException)\n                {\n                    continue;
                {\n                    continue;
                }\n                Server tmp = new Server\n                {\n                    remarks = parsedUrl.GetComponents(UriComponents.Fragment, UriFormat.Unescaped)\n                };\n                string userInfo = parsedUrl.GetComponents(UriComponents.UserInfo, UriFormat.Unescaped);\n                tmp.server = parsedUrl.GetComponents(UriComponents.Host, UriFormat.Unescaped);\n                tmp.server_port = parsedUrl.Port;\n                string[] userInfoParts = userInfo.Split(new[] { ':' }, 2);\n                if (userInfoParts.Length != 2)
            }\n            return servers;\n        }\n        public string Identifier()\n        {\n            return server + ':' + server_port;\n        }\n    }\n}
        public SodiumEncryptor(string method, string password)\n            : base(method, password)\n        {\n            InitKey(method, password);\n            _encryptBuf = new byte[MAX_INPUT_SIZE + SODIUM_BLOCK_SIZE];\n            _decryptBuf = new byte[MAX_INPUT_SIZE + SODIUM_BLOCK_SIZE];\n        }\n        private static Dictionary<string, int[]> _ciphers = new Dictionary<string, int[]> {\n                {"salsa20", new int[]{32, 8, CIPHER_SALSA20, PolarSSL.AES_CTX_SIZE}},\n                {"chacha20", new int[]{32, 8, CIPHER_CHACHA20, PolarSSL.AES_CTX_SIZE}},
        }\n        private static Dictionary<string, int[]> _ciphers = new Dictionary<string, int[]> {\n                {"salsa20", new int[]{32, 8, CIPHER_SALSA20, PolarSSL.AES_CTX_SIZE}},\n                {"chacha20", new int[]{32, 8, CIPHER_CHACHA20, PolarSSL.AES_CTX_SIZE}},\n        };\n        protected override Dictionary<string, int[]> getCiphers()\n        {\n            return _ciphers;\n        }\n        public static List<string> SupportedCiphers()
            byte[] iv;\n            if (isCipher)\n            {\n                bytesRemaining = _encryptBytesRemaining;\n                ic = _encryptIC;\n                sodiumBuf = _encryptBuf;\n                iv = _encryptIV;\n            }\n            else
            {\n                bytesRemaining = _encryptBytesRemaining;\n                ic = _encryptIC;\n                sodiumBuf = _encryptBuf;\n                iv = _encryptIV;\n            }\n            else\n            {\n                bytesRemaining = _decryptBytesRemaining;\n                ic = _decryptIC;
            }\n        }\n        public override void Dispose()\n        {\n        }\n    }\n}
                    stream.Close();\n                }\n            }\n        }\n    }\n}
        }\n        public Server GetCurrentServer()\n        {\n            return _config.GetCurrentServer();\n        }\n        // always return copy\n        public Configuration GetConfiguration()\n        {\n            return Configuration.Load();\n        }
            // some logic in configuration updated the config when saving, we need to read it again\n            _config = Configuration.Load();
            // don't put polipoRunner.Start() before pacServer.Stop()\n            // or bind will fail when switching bind address from 0.0.0.0 to 127.0.0.1\n            // though UseShellExecute is set to true now\n            // http://stackoverflow.com/questions/10235093/socket-doesnt-close-after-application-exits-if-a-launched-process-is-open\n            polipoRunner.Stop();\n            polipoRunner.Start(_config);\n            local = new Local(_config);\n            local.Start();\n            pacServer.Start(_config);
            if (ConfigChanged != null)\n            {\n                ConfigChanged(this, new EventArgs());\n            }\n            Util.Util.ReleaseMemory();
                StartPipe();\n            }\n            catch (ArgumentException e)\n            {\n            }\n            catch (Exception e)\n            {\n                if (server != null)\n                {\n                    controller.GetCurrentStrategy().SetFailure(server);
                }\n                Logging.LogUsefulException(e);\n                RetryConnect();\n            }\n        }\n        private void StartPipe()\n        {\n            if (closed)\n            {\n                return;
        private MenuItem ServersItem;\n        private MenuItem SeperatorItem4;\n        private MenuItem quitItem;\n        private MenuItem SeperatorItem2;\n        private MenuItem modeItem;

            this.ServersItem = CreateMenuGroup(2, "Servers", new System.Windows.Forms.MenuItem[] {\n            this.SeperatorItem,\n            this.ConfigItem});\n            this.SeperatorItem2 = CreateSeperatorItem(3);\n            this.AutoStartupItem = CreateMenuItem(4, "Start on Boot", new System.EventHandler(this.AutoStartupItem_Click));\n            this.ShareOverLANItem = CreateMenuItem(5, "Share over LAN", new System.EventHandler(this.ShareOverLANItem_Click));\n            this.editPACFileItem = CreateMenuItem(6, "Edit PAC File...", new System.EventHandler(this.EditPACFileItem_Click));\n            this.SeperatorItem3 = CreateSeperatorItem(7);\n            this.QRCodeItem = CreateMenuItem(8, "Show QRCode...", new System.EventHandler(this.QRCodeItem_Click));\n            this.ShowLogItem = CreateMenuItem(9, "Show Logs...", new System.EventHandler(this.ShowLogItem_Click));
            this.AutoStartupItem = CreateMenuItem(4, "Start on Boot", new System.EventHandler(this.AutoStartupItem_Click));\n            this.ShareOverLANItem = CreateMenuItem(5, "Share over LAN", new System.EventHandler(this.ShareOverLANItem_Click));\n            this.editPACFileItem = CreateMenuItem(6, "Edit PAC File...", new System.EventHandler(this.EditPACFileItem_Click));\n            this.SeperatorItem3 = CreateSeperatorItem(7);\n            this.QRCodeItem = CreateMenuItem(8, "Show QRCode...", new System.EventHandler(this.QRCodeItem_Click));\n            this.ShowLogItem = CreateMenuItem(9, "Show Logs...", new System.EventHandler(this.ShowLogItem_Click));\n            this.aboutItem = CreateMenuItem(10, "About...", new System.EventHandler(this.Config_Click));\n            this.SeperatorItem4 = CreateSeperatorItem(11);\n            this.quitItem = CreateMenuItem(12, "Quit", new System.EventHandler(this.Quit_Click));\n            // \n            this.contextMenu1.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
            this.contextMenu1.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {\n            this.enableItem,\n            this.modeItem,\n            this.ServersItem,\n            this.SeperatorItem2,\n            this.AutoStartupItem,
            this.ServersItem,\n            this.SeperatorItem2,\n            this.AutoStartupItem,\n            this.ShareOverLANItem,\n            this.editPACFileItem,\n            this.SeperatorItem3,\n            this.QRCodeItem,\n            this.ShowLogItem,\n            this.aboutItem,\n            this.SeperatorItem4,
            this.AutoStartupItem,\n            this.ShareOverLANItem,\n            this.editPACFileItem,\n            this.SeperatorItem3,\n            this.QRCodeItem,\n            this.ShowLogItem,\n            this.aboutItem,\n            this.SeperatorItem4,\n            this.quitItem});\n        }
        }\n        private void controller_ConfigChanged(object sender, EventArgs e)\n        {\n            LoadCurrentConfiguration();\n            UpdateTrayIcon();\n        }\n        private void controller_EnableStatusChanged(object sender, EventArgs e)\n        {\n            enableItem.Checked = controller.GetConfiguration().enabled;\n        }
                List<string> versions = new List<string>();\n                foreach (XmlNode el in elements)\n                {\n                    foreach (XmlAttribute attr in el.Attributes)\n                    {\n                        if (attr.Name == "url")
                {\n                    foreach (XmlAttribute attr in el.Attributes)\n                    {\n                        if (attr.Name == "url")
                    {\n                        if (attr.Name == "url")\n                        {\n                            if (IsNewVersion(attr.Value))
                        {\n                            if (IsNewVersion(attr.Value))\n                            {\n                                versions.Add(attr.Value);\n                            }\n                        }\n                    }\n                }\n                if (versions.Count == 0)
                        }\n                    }\n                }\n                if (versions.Count == 0)\n                {\n                    return;\n                }\n                // sort versions\n                SortVersions(versions);\n                LatestVersionURL = versions[versions.Count - 1];
using Shadowsocks.Controller;\nusing Shadowsocks.Properties;\nnamespace Shadowsocks.Util.SystemProxy\n{\n    public static class Sysproxy\n    {\n        private static bool _userSettingsRecorded = false;
        // In general, this won't change\n        // format:\n        //  <flags><CR-LF>\n        //  <proxy-server><CR-LF>\n        //  <bypass-list><CR-LF>\n        //  <pac-url>\n        private static string[] _userSettings = new string[4];\n        enum RET_ERRORS : int\n        {\n            RET_NO_ERROR = 0,\n            INVALID_FORMAT = 1,\n            NO_PERMISSION = 2,\n            SYSCALL_FAILED = 3,\n            NO_MEMORY = 4,\n            INVAILD_OPTION_COUNT = 5,\n        };
        enum RET_ERRORS : int\n        {\n            RET_NO_ERROR = 0,\n            INVALID_FORMAT = 1,\n            NO_PERMISSION = 2,\n            SYSCALL_FAILED = 3,\n            NO_MEMORY = 4,\n            INVAILD_OPTION_COUNT = 5,\n        };\n        static Sysproxy()
            {\n                // record user settings\n                ExecSysproxy("query", out str);\n                ParseQueryStr(str);\n                _userSettingsRecorded = true;\n            }\n            string arguments;\n            if (enable)\n            {
            }\n            string arguments;\n            if (enable)\n            {\n                arguments = global\n                    ? $"global {proxyServer} <local>;localhost;127.*;10.*;172.16.*;172.17.*;172.18.*;172.19.*;172.20.*;172.21.*;172.22.*;172.23.*;172.24.*;172.25.*;172.26.*;172.27.*;172.28.*;172.29.*;172.30.*;172.31.*;172.32.*;192.168.*"\n                    : $"pac {pacURL}";\n            }\n            else\n            {
                arguments = $"set {flags} {proxy_server} {bypass_list} {pac_url}";\n                // have to get new settings\n                _userSettingsRecorded = false;\n            }\n            ExecSysproxy(arguments, out str);\n        }\n        private static void ExecSysproxy(string arguments, out string queryStr)\n        {\n            using (var process = new Process())
            }\n            ExecSysproxy(arguments, out str);\n        }\n        private static void ExecSysproxy(string arguments, out string queryStr)\n        {\n            using (var process = new Process())\n            {\n                // Configure the process using the StartInfo properties.
        }\n        private static void ExecSysproxy(string arguments, out string queryStr)\n        {\n            using (var process = new Process())\n            {\n                // Configure the process using the StartInfo properties.\n                process.StartInfo.FileName = Utils.GetTempPath("sysproxy.exe");\n                process.StartInfo.Arguments = arguments;\n                process.StartInfo.WorkingDirectory = Utils.GetTempPath();\n                process.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;
        {\n            using (var process = new Process())\n            {\n                // Configure the process using the StartInfo properties.\n                process.StartInfo.FileName = Utils.GetTempPath("sysproxy.exe");\n                process.StartInfo.Arguments = arguments;\n                process.StartInfo.WorkingDirectory = Utils.GetTempPath();\n                process.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;\n                process.StartInfo.UseShellExecute = false;\n                process.StartInfo.RedirectStandardError = true;
                }\n                queryStr = stdout;
            }\n        }\n        private static void ParseQueryStr(string str)\n        {\n            _userSettings = str.Split(new string[] { "\r\n" }, StringSplitOptions.RemoveEmptyEntries);\n            for (var i = 0; i < 4; i++)\n            {\n                // handle output from WinINET\n                if (_userSettings[i] == "(null)")\n                    _userSettings[i] = null;
        }\n    }\n}
using System.Collections.Generic;\nusing System.Runtime.InteropServices;\nusing System.Text;\nnamespace Shadowsocks.Encrypt\n{\n    public class PolarSSL\n    {\n        const string DLLNAME = "polarssl";\n        public const int AES_CTX_SIZE = 8 + 4 * 68;
using System.Threading;\nusing System.Windows.Forms;\nnamespace Shadowsocks\n{\n    static class Program\n    {\n        [DllImport("Kernel32.dll")]\n        private static extern IntPtr LoadLibrary(string path);\n        /// <summary>\n        /// 应用程序的主入口点。
        /// <summary>\n        /// 应用程序的主入口点。\n        /// </summary>\n        [STAThread]\n        static void Main()\n        {\n            using (Mutex mutex = new Mutex(false, "Global\\" + "71981632-A427-497F-AB91-241CD227EC1F"))\n            {\n                if (!mutex.WaitOne(0, false))\n                {
        {\n            byte[] hash = new byte[20];\n            updateKeyBuffer();\n            Sodium.ss_sha1_hmac_ex(_keyBuffer, (uint)_keyBuffer.Length,\n                buf, offset, (uint)len, hash);\n            return hash;\n        }\n        protected void reactBuffer4TCP(byte[] buf, ref int length)\n        {\n            if (!_encryptIVSent)
                buf, offset, (uint)len, hash);\n            return hash;\n        }\n        protected void reactBuffer4TCP(byte[] buf, ref int length)\n        {\n            if (!_encryptIVSent)\n            {\n                int headLen = getHeadLen(buf, length);\n                int dataLen = length - headLen;\n                buf[0] |= ONETIMEAUTH_FLAG;
                int dataLen = length - headLen;\n                buf[0] |= ONETIMEAUTH_FLAG;\n                byte[] hash = genOnetimeAuthHash(buf, headLen);\n                Buffer.BlockCopy(buf, headLen, buf, headLen + ONETIMEAUTH_BYTES + AUTH_BYTES, dataLen);\n                Buffer.BlockCopy(hash, 0, buf, headLen, ONETIMEAUTH_BYTES);\n                hash = genHash(buf, headLen + ONETIMEAUTH_BYTES + AUTH_BYTES, dataLen);\n                Buffer.BlockCopy(hash, 0, buf, headLen + ONETIMEAUTH_BYTES + CLEN_BYTES, ONETIMEAUTH_BYTES);\n                byte[] lenBytes = BitConverter.GetBytes((ushort)IPAddress.HostToNetworkOrder((short)dataLen));\n                Buffer.BlockCopy(lenBytes, 0, buf, headLen + ONETIMEAUTH_BYTES, CLEN_BYTES);\n                length = headLen + ONETIMEAUTH_BYTES + AUTH_BYTES + dataLen;
                Buffer.BlockCopy(buf, headLen, buf, headLen + ONETIMEAUTH_BYTES + AUTH_BYTES, dataLen);\n                Buffer.BlockCopy(hash, 0, buf, headLen, ONETIMEAUTH_BYTES);\n                hash = genHash(buf, headLen + ONETIMEAUTH_BYTES + AUTH_BYTES, dataLen);\n                Buffer.BlockCopy(hash, 0, buf, headLen + ONETIMEAUTH_BYTES + CLEN_BYTES, ONETIMEAUTH_BYTES);\n                byte[] lenBytes = BitConverter.GetBytes((ushort)IPAddress.HostToNetworkOrder((short)dataLen));\n                Buffer.BlockCopy(lenBytes, 0, buf, headLen + ONETIMEAUTH_BYTES, CLEN_BYTES);\n                length = headLen + ONETIMEAUTH_BYTES + AUTH_BYTES + dataLen;\n            }\n            else\n            {
            Buffer.BlockCopy(hash, 0, buf, length, ONETIMEAUTH_BYTES);\n            length += ONETIMEAUTH_BYTES;\n        }\n        protected void reactBuffer(byte[] buf, ref int length)\n        {\n            if (OnetimeAuth && ivLen > 0)\n            {\n                if (!IsUDP)\n                {\n                    reactBuffer4TCP(buf, ref length);
                }\n                else\n                {\n                    reactBuffer4UDP(buf, ref length);\n                }\n            }
        }\n        public override void Encrypt(byte[] buf, int length, byte[] outbuf, out int outlength)\n        {\n            if (!_encryptIVSent)\n            {\n                reactBuffer(buf, ref length);
                _encryptIVSent = true;\n                lock (tempbuf)\n                {\n                    cipherUpdate(true, length, buf, tempbuf);\n                    outlength = length + ivLen;\n                    Buffer.BlockCopy(tempbuf, 0, outbuf, ivLen, length);\n                }\n            }\n            else\n            {
    /// <summary>\n    internal class Resources\n    {\n        private static global::System.Resources.ResourceManager resourceMan;\n        private static global::System.Globalization.CultureInfo resourceCulture;\n        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]\n        internal Resources()
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("shadowsocks_csharp.Properties.Resources", typeof(Resources).Assembly);\n                    resourceMan = temp;\n                }\n                return resourceMan;\n            }\n        }\n        /// <summary>\n        internal static global::System.Globalization.CultureInfo Culture\n        {\n            get
            }\n            if (_modifiedConfiguration.configs.Count == 0)\n            {\n                MessageBox.Show(I18N.GetString("Please add at least one server"));\n                return;\n            }\n            int localPort = int.Parse(ProxyPortTextBox.Text);\n            Configuration.CheckLocalPort(localPort);\n            _modifiedConfiguration.localPort = localPort;\n            _modifiedConfiguration.portableMode = PortableModeCheckBox.Checked;
            }\n            int localPort = int.Parse(ProxyPortTextBox.Text);\n            Configuration.CheckLocalPort(localPort);\n            _modifiedConfiguration.localPort = localPort;\n            _modifiedConfiguration.portableMode = PortableModeCheckBox.Checked;\n            controller.SaveServers(_modifiedConfiguration.configs, _modifiedConfiguration.localPort, _modifiedConfiguration.portableMode);\n            // SelectedIndex remains valid\n            // We handled this in event handlers, e.g. Add/DeleteButton, SelectedIndexChanged\n            // and move operations\n            controller.SelectServerIndex(ServersListBox.SelectedIndex);\n            this.Close();
        }\n        private void CancelButton_Click(object sender, EventArgs e)\n        {\n            this.Close();\n        }\n        private void ConfigForm_Shown(object sender, EventArgs e)\n        {\n            IPTextBox.Focus();\n        }\n        private void ConfigForm_FormClosed(object sender, FormClosedEventArgs e)
            this.ApplyButton.Location = new System.Drawing.Point(165, 3);\n            this.ApplyButton.Margin = new System.Windows.Forms.Padding(3, 3, 0, 0);\n            this.ApplyButton.Name = "ApplyButton";\n            this.ApplyButton.Size = new System.Drawing.Size(75, 23);\n            this.ApplyButton.TabIndex = 19;\n            this.ApplyButton.Text = "Apply";\n            this.ApplyButton.UseVisualStyleBackColor = true;\n            this.ApplyButton.Click += new System.EventHandler(this.ApplyButton_Click);\n            // \n            // DeleteButton
        }\n        public void UpdateOutboundCounter(long n)\n        {\n            Interlocked.Add(ref outboundCounter, n);\n            _config.bandwidthOut = outboundCounter;\n        }\n        protected void Reload()\n        {\n            // some logic in configuration updated the config when saving, we need to read it again\n            _config = Configuration.Load();\n            inboundCounter = _config.bandwidthIn;
        }\n        protected void Reload()\n        {\n            // some logic in configuration updated the config when saving, we need to read it again\n            _config = Configuration.Load();\n            inboundCounter = _config.bandwidthIn;\n            outboundCounter = _config.bandwidthOut;\n            StatisticsConfiguration = StatisticsStrategyConfiguration.Load();\n            if (polipoRunner == null)\n            {\n                polipoRunner = new PolipoRunner();
            StatisticsConfiguration = StatisticsStrategyConfiguration.Load();\n            if (polipoRunner == null)\n            {\n                polipoRunner = new PolipoRunner();\n            }\n            if (_pacServer == null)\n            {\n                _pacServer = new PACServer();\n                _pacServer.PACFileChanged += pacServer_PACFileChanged;\n                _pacServer.UserRuleFileChanged += pacServer_UserRuleFileChanged;
            ((System.ComponentModel.ISupportInitialize)(this.StatisticsChart)).BeginInit();\n            ((System.ComponentModel.ISupportInitialize)(this.bindingConfiguration)).BeginInit();\n            this.groupBox1.SuspendLayout();\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer1)).BeginInit();\n            this.splitContainer1.Panel1.SuspendLayout();\n            this.splitContainer1.Panel2.SuspendLayout();\n            this.splitContainer1.SuspendLayout();\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer2)).BeginInit();\n            this.splitContainer2.Panel1.SuspendLayout();\n            this.splitContainer2.Panel2.SuspendLayout();
            this.groupBox1.SuspendLayout();\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer1)).BeginInit();\n            this.splitContainer1.Panel1.SuspendLayout();\n            this.splitContainer1.Panel2.SuspendLayout();\n            this.splitContainer1.SuspendLayout();\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer2)).BeginInit();\n            this.splitContainer2.Panel1.SuspendLayout();\n            this.splitContainer2.Panel2.SuspendLayout();\n            this.splitContainer2.SuspendLayout();\n            ((System.ComponentModel.ISupportInitialize)(this.dataCollectionMinutesNum)).BeginInit();

                             ?? new StatisticsStrategyConfiguration();\n        }\n        private void InitData()\n        {\n            bindingConfiguration.Add(_configuration);\n            foreach (var kv in _configuration.Calculations)
namespace Shadowsocks.Controller\n{\n    class PACServer\n    {\n        private static int PORT = 8093;\n        private static string PAC_FILE = "pac.txt";\n        private static Configuration config;\n        Socket _listener;\n        FileSystemWatcher watcher;\n        public event EventHandler PACFileChanged;
        private static Configuration config;\n        Socket _listener;\n        FileSystemWatcher watcher;\n        public event EventHandler PACFileChanged;\n        public event EventHandler UpdatePACFromGFWListCompleted;\n        public event ErrorEventHandler UpdatePACFromGFWListError;\n        public void Start(Configuration configuration)\n        {\n            try\n            {
        public void Start(Configuration configuration)\n        {\n            try\n            {\n                config = configuration;\n                // Create a TCP/IP socket.\n                _listener = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);\n                _listener.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, true);\n                IPEndPoint localEndPoint = null;\n                if (configuration.shareOverLan)
        public event ErrorEventHandler Error;\n        public void Download()\n        {\n            WebClient http = new WebClient();\n            http.Proxy = proxy;\n            http.DownloadStringCompleted += http_DownloadStringCompleted;\n            http.DownloadStringAsync(new Uri(GFWLIST_URL));\n        }\n        protected void ReportError(Exception e)\n        {
        private void http_DownloadStringCompleted(object sender, DownloadStringCompletedEventArgs e)\n        {\n            try\n            {\n                string response = e.Result;\n                if (DownloadCompleted != null)
                {\n                    DownloadCompleted(this, new GfwListDownloadCompletedArgs\n                    {\n                        Content = response\n                    });\n                }\n            }\n            catch (Exception ex)\n            {
                }\n            }\n            catch (Exception ex)\n            {\n                ReportError(ex);\n            }
            }\n        }\n        public class Parser\n        {\n            private string _Content;\n            public string Content
        {\n            private string _Content;\n            public string Content
            {\n                get { return _Content; }\n            }\n            public Parser(string response)\n            {\n                byte[] bytes = Convert.FromBase64String(response);\n                this._Content = Encoding.ASCII.GetString(bytes);
            }\n            public Parser(string response)\n            {\n                byte[] bytes = Convert.FromBase64String(response);\n                this._Content = Encoding.ASCII.GetString(bytes);\n            }\n            public string[] GetValidLines()\n            {\n                string[] lines = Content.Split(new char[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);\n                List<string> valid_lines = new List<string>(lines.Length);
        }\n    }\n}
        {\n            if (UpdatePACFromGFWListError != null)\n                UpdatePACFromGFWListError(this, e);\n        }\n        private void StartReleasingMemory()\n        {\n            _ramThread = new Thread(new ThreadStart(ReleaseMemory));\n            _ramThread.IsBackground = true;\n            _ramThread.Start();\n        }
    {\n        public static void ReleaseMemory()\n        {\n            // release any unused pages\n            // making the numbers look good in task manager\n            // this is totally nonsense in programming\n            // but good for those users who care\n            // making them happier with their everyday life\n            // which is part of user experience\n            GC.Collect(GC.MaxGeneration);
            try\n            {\n                FileManager.UncompressFile(temppath + "/ss_privoxy.exe", Resources.privoxy_exe);\n                FileManager.UncompressFile(temppath + "/mgwz.dll", Resources.mgwz_dll);\n            }\n            catch (IOException e)\n            {\n                Logging.LogUsefulException(e);\n            }\n        }
        }\n    }\n    class Handler\n    {\n        //public Encryptor encryptor;\n        public IEncryptor encryptor;\n        public Server server;\n        // Client  socket.\n        public Socket remote;\n        public Socket connection;
         return Mode.BYTE;\n      }\n      private static bool isOnlyDoubleByteKanji(String content)\n      {\n         byte[] bytes;\n         try\n         {\n            bytes = Encoding.GetEncoding("Shift_JIS").GetBytes(content);\n         }\n         catch (Exception )
      }\n      private static int chooseMaskPattern(BitArray bits,\n                                           ErrorCorrectionLevel ecLevel,\n                                           Version version,\n                                           ByteMatrix matrix)\n      {\n         int minPenalty = Int32.MaxValue;  // Lower penalty is better.\n         int bestMaskPattern = -1;\n         // We try all mask patterns to choose the best one.\n         for (int maskPattern = 0; maskPattern < QRCode.NUM_MASK_PATTERNS; maskPattern++)
            else\n               if (mode.Equals(Mode.BYTE))\n                  append8BitBytes(content, bits, encoding);\n               else\n                  if (mode.Equals(Mode.KANJI))\n                     appendKanjiBytes(content, bits);\n                  else\n                     throw new WriterException("Invalid mode: " + mode);\n      }\n      internal static void appendNumericBytes(String content, BitArray bits)
      }\n      internal static void appendNumericBytes(String content, BitArray bits)\n      {\n         int length = content.Length;\n         int i = 0;\n         while (i < length)\n         {\n            int num1 = content[i] - '0';\n            if (i + 2 < length)\n            {
      /// <summary> Sets a block of 32 bits, starting at bit i.\n      /// \n      /// </summary>\n      /// <param name="i">first bit to set\n      /// </param>\n      /// <param name="newBits">the new value of the next 32 bits. Note again that the least-significant bit\n      /// corresponds to bit i, the next-least-significant to i+1, and so on.\n      /// </param>\n      public void setBulk(int i, int newBits)\n      {\n      /// <summary>\n      /// Sets a range of bits.\n      /// </summary>\n      /// <param name="start">start of range, inclusive.</param>\n      /// <param name="end">end of range, exclusive</param>\n      public void setRange(int start, int end)
      /// <summary> Clears all bits (sets to false).</summary>\n      public void clear()\n      {\n         int max = bits.Length;\n         for (int i = 0; i < max; i++)\n         {\n            bits[i] = 0;\n         }\n      }\n      /// <summary> Efficient method to check if a range of bits is set, or not set.\n      /// 
      }\n      /// <summary>\n      /// Appends the bit.\n      /// </summary>\n      /// <param name="bit">The bit.</param>\n      public void appendBit(bool bit)\n      {\n         ensureCapacity(size + 1);\n         if (bit)\n         {
using Shadowsocks.Model;\nnamespace Shadowsocks.Controller\n{\n    class AvailabilityStatistics\n    {\n        private const string StatisticsFilesName = "shadowsocks.availability.csv";
        {
            {\n                Logging.Debug("eveluating " + server.FriendlyName());\n                foreach (var _ in Enumerable.Range(0, Repeat))\n                {\n                    //TODO: do simple analyze of data to provide friendly message, like package loss.\n                    var timestamp = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss");\n                    //ICMP echo. we can also set options and special bytes\n                    //seems no need to use SendPingAsync：
                {\n                    //TODO: do simple analyze of data to provide friendly message, like package loss.\n                    var timestamp = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss");\n                    //ICMP echo. we can also set options and special bytes\n                    //seems no need to use SendPingAsync：\n                    var reply = ping.Send(server.server, Timeout);\n                    state.Data = new List<KeyValuePair<string, string>>\n                    {\n                        new KeyValuePair<string, string>("Timestamp", timestamp),\n                        new KeyValuePair<string, string>("Server", server.FriendlyName()),
                }\n            }\n        }\n        private static void Append(List<KeyValuePair<string, string>> data)\n        {\n            var dataLine = string.Join(Delimiter, data.Select(kv => kv.Value).ToArray());\n            string[] lines;\n            if (!File.Exists(AvailabilityStatisticsFile))\n            {
        {\n            var dataLine = string.Join(Delimiter, data.Select(kv => kv.Value).ToArray());\n            string[] lines;\n            if (!File.Exists(AvailabilityStatisticsFile))\n            {\n                var headerLine = string.Join(Delimiter, data.Select(kv => kv.Key).ToArray());\n                lines = new[] { headerLine, dataLine };\n            }\n            else
                Match match = Regex.Match(name, @"^Shadowsocks-(?<version>\d+(?:\.\d+)*)(?:|-(?<suffix>.+))\.\w+$",\n                    RegexOptions.IgnoreCase);\n                if (match.Success)\n                {\n                    string version = match.Groups["version"].Value;\n                    var asset = new Asset\n                    {\n                        browser_download_url = (string) aJObject["browser_download_url"],\n                        name = name,\n                        version = version
                        name = name,\n                        version = version\n                    };\n                    if (match.Groups["suffix"].Success)\n                    {\n                        asset.suffix = match.Groups["suffix"].Value;\n                    }\n                    return asset;\n                }\n                return null;
    public partial class LogForm : Form\n    {\n        long lastOffset;\n        string filename;\n        Timer timer;\n        const int BACK_OFFSET = 65536;\n        ShadowsocksController controller;\n        // global traffic update lock, make it static\n        private static readonly object _lock = new object();\n        #region chart\n        long lastMaxSpeed;
        #endregion\n        public LogForm(ShadowsocksController controller, string filename)\n        {\n            this.controller = controller;\n            this.filename = filename;\n            InitializeComponent();\n            Icon = Icon.FromHandle(Resources.ssw128.GetHicon());\n            LogViewerConfig config = controller.GetConfigurationCopy().logViewer;\n            topMostTrigger = config.topMost;\n            wrapTextTrigger = config.wrapText;
            lock (_lock)\n            {\n                if (traffic.Count == 0)\n                    return;\n                foreach (var trafficPerSecond in traffic)\n                {\n                    inboundPoints.Add(trafficPerSecond.inbound);\n                    outboundPoints.Add(trafficPerSecond.outbound);\n                    maxSpeed = Math.Max(maxSpeed, Math.Max(trafficPerSecond.inbound, trafficPerSecond.outbound));\n                }
                    return;\n                foreach (var trafficPerSecond in traffic)\n                {\n                    inboundPoints.Add(trafficPerSecond.inbound);\n                    outboundPoints.Add(trafficPerSecond.outbound);\n                    maxSpeed = Math.Max(maxSpeed, Math.Max(trafficPerSecond.inbound, trafficPerSecond.outbound));\n                }\n                lastInbound = traffic.Last().inbound;\n                lastOutbound = traffic.Last().outbound;
            }\n            if (maxSpeed > 0)\n            {\n                lastMaxSpeed -= lastMaxSpeed / 32;\n                maxSpeed = Math.Max(minScale, Math.Max(maxSpeed, lastMaxSpeed));\n                lastMaxSpeed = maxSpeed;\n            }\n            else\n            {\n                maxSpeed = lastMaxSpeed = minScale;
        private bool stopped = false;\n        private bool _systemProxyIsDirty = false;\n        public class PathEventArgs : EventArgs\n        {\n            public string Path;\n        }\n        public class QueueLast<T> : Queue<T>\n        {\n            public T Last { get; private set; }\n            public new void Enqueue(T item)
        }\n        public class TrafficPerSecond\n        {\n            public long inboundCounter;\n            public long outboundCounter;\n            public long inboundIncreasement;\n            public long outboundIncreasement;\n        }\n        public event EventHandler ConfigChanged;\n        public event EventHandler EnableStatusChanged;
            for (int i = 0; i < queueMaxSize; i++)\n            {\n                traffic.Enqueue(new TrafficPerSecond());\n            }\n            _trafficThread = new Thread(new ThreadStart(() => TrafficStatistics(queueMaxSize)));\n            _trafficThread.IsBackground = true;\n            _trafficThread.Start();\n        }\n        private void TrafficStatistics(int queueMaxSize)\n        {
            }\n            _trafficThread = new Thread(new ThreadStart(() => TrafficStatistics(queueMaxSize)));\n            _trafficThread.IsBackground = true;\n            _trafficThread.Start();\n        }\n        private void TrafficStatistics(int queueMaxSize)\n        {\n            while (true)\n            {
                TrafficChanged?.Invoke(this, new EventArgs());\n                Thread.Sleep(1000);\n            }\n        }\n        #endregion\n    }\n}
        public DateTime lastActivity;\n        // Size of receive buffer.\n        public const int RecvSize = 8192;\n        public const int RecvReserveSize = IVEncryptor.ONETIMEAUTH_BYTES + IVEncryptor.AUTH_BYTES; // reserve for one-time auth
        private DateTime _startConnectTime;\n        private DateTime _startReceivingTime;\n        private DateTime _startSendingTime;\n        private int _bytesToSend;
        }\n    }\n}
        // remote receive buffer\n        public byte[] remoteBuffer = new byte[BufferSize];\n        // connection receive buffer\n        public byte[] connetionBuffer = new byte[BufferSize];\n        // Received data string.\n        public StringBuilder sb = new StringBuilder();\n        public void Start()\n        {
        // connection receive buffer\n        public byte[] connetionBuffer = new byte[BufferSize];\n        // Received data string.\n        public StringBuilder sb = new StringBuilder();\n        public void Start()\n        {\n            try\n            {\n                // TODO async resolving
        // Received data string.\n        public StringBuilder sb = new StringBuilder();\n        public void Start()\n        {\n            try\n            {\n                // TODO async resolving\n                IPAddress ipAddress;\n                bool parsed = IPAddress.TryParse(config.server, out ipAddress);\n                if (!parsed)
                    new AsyncCallback(pipeRemoteReceiveCallback), null);\n                connection.BeginReceive(connetionBuffer, 0, BufferSize, 0,\n                    new AsyncCallback(pipeConnectionReceiveCallback), null);\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine(e.ToString());\n                this.Close();\n            }\n        }
                    new AsyncCallback(pipeConnectionReceiveCallback), null);\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine(e.ToString());\n                this.Close();\n            }\n        }\n        private void pipeRemoteReceiveCallback(IAsyncResult ar)\n        {
        {\n            if (_encryptCtx == IntPtr.Zero)\n            {\n                byte[] iv = new byte[ivLen];\n                OpenSSL.RAND_bytes(iv, iv.Length);\n                InitCipher(ref _encryptCtx, iv, true);\n                int outLen = length + ivLen;\n                byte[] cipherText = new byte[outLen];\n                OpenSSL.EVP_CipherUpdate(_encryptCtx, cipherText, out outLen, buf, length);\n                byte[] result = new byte[outLen + ivLen];
            }\n            else\n            {\n                int outLen = length + ivLen;\n                byte[] cipherText = new byte[outLen];\n                OpenSSL.EVP_CipherUpdate(_encryptCtx, cipherText, out outLen, buf, length);\n                byte[] result = new byte[outLen];\n                Buffer.BlockCopy(cipherText, 0, result, 0, outLen);\n                return result;
            }\n        }\n        public override byte[] Decrypt(byte[] buf, int length)\n        {\n            if (_decryptCtx == IntPtr.Zero)\n            {\n                byte[] iv = new byte[ivLen];\n                Buffer.BlockCopy(buf, 0, iv, 0, ivLen);\n                InitCipher(ref _decryptCtx, iv, false);\n                int outLen = length + ivLen;
        {\n            if (_decryptCtx == IntPtr.Zero)\n            {\n                byte[] iv = new byte[ivLen];\n                Buffer.BlockCopy(buf, 0, iv, 0, ivLen);\n                InitCipher(ref _decryptCtx, iv, false);\n                int outLen = length + ivLen;\n                outLen -= ivLen;\n                byte[] cipherText = new byte[outLen];\n                byte[] subset = new byte[length - ivLen];
            }\n            else\n            {\n                int outLen = length + ivLen;\n                byte[] cipherText = new byte[outLen];\n                OpenSSL.EVP_CipherUpdate(_decryptCtx, cipherText, out outLen, buf, length);\n                byte[] result = new byte[outLen];\n                Buffer.BlockCopy(cipherText, 0, result, 0, outLen);\n                return result;
            }\n        }\n        private static readonly Dictionary<string, byte[]> CachedKeys = new Dictionary<string, byte[]>();\n        private byte[] _key;\n        private IntPtr _encryptCtx;\n        private IntPtr _decryptCtx;\n        private IntPtr _cipher;\n        private string _method;\n        private int keyLen;\n        private int ivLen;
    {\n        byte[] Encrypt(byte[] buf, int length);\n        byte[] Decrypt(byte[] buf, int length);\n    }\n}
    }\n}
        {\n            byte[] result = new byte[length];\n            for (int i = 0; i < length; i++)\n            {\n                result[i] = _encryptTable[buf[i]];\n            }\n            return result;\n        }\n        public override byte[] Decrypt(byte[] buf, int length)\n        {
            }\n            return result;\n        }\n        public override byte[] Decrypt(byte[] buf, int length)\n        {\n            byte[] result = new byte[length];\n            for (int i = 0; i < length; i++)\n            {\n                result[i] = _decryptTable[buf[i]];\n            }
        }\n        public override byte[] Decrypt(byte[] buf, int length)\n        {\n            byte[] result = new byte[length];\n            for (int i = 0; i < length; i++)\n            {\n                result[i] = _decryptTable[buf[i]];\n            }\n            return result;\n        }
        {\n            byte[] result = new byte[length];\n            for (int i = 0; i < length; i++)\n            {\n                result[i] = _decryptTable[buf[i]];\n            }\n            return result;\n        }\n        private readonly byte[] _encryptTable = new byte[256];\n        private readonly byte[] _decryptTable = new byte[256];
            }\n            return result;\n        }\n        private readonly byte[] _encryptTable = new byte[256];\n        private readonly byte[] _decryptTable = new byte[256];\n        private static long Compare(byte x, byte y, ulong a, int i)\n        {\n            return (long)(a % (ulong)(x + i)) - (long)(a % (ulong)(y + i));\n        }\n        private byte[] MergeSort(byte[] array, ulong a, int j)
        }\n        private readonly byte[] _encryptTable = new byte[256];\n        private readonly byte[] _decryptTable = new byte[256];\n        private static long Compare(byte x, byte y, ulong a, int i)\n        {\n            return (long)(a % (ulong)(x + i)) - (long)(a % (ulong)(y + i));\n        }\n        private byte[] MergeSort(byte[] array, ulong a, int j)\n        {\n            if (array.Length == 1)
    {\n        static string Key = "Shadowsocks_" + Application.StartupPath.GetHashCode();\n        public static bool Set(bool enabled)\n        {\n            RegistryKey runKey = null;\n            try\n            {\n                string path = Application.ExecutablePath;
        public static bool Set(bool enabled)\n        {\n            RegistryKey runKey = null;\n            try\n            {\n                string path = Application.ExecutablePath;\n                runKey = Utils.OpenRegKey(@"Software\Microsoft\Windows\CurrentVersion\Run", true);\n                if ( runKey == null ) {\n                    Logging.Error( @"Cannot find HKCU\Software\Microsoft\Windows\CurrentVersion\Run" );\n                    return false;
                runKey = Utils.OpenRegKey(@"Software\Microsoft\Windows\CurrentVersion\Run", true);\n                if ( runKey == null ) {\n                    Logging.Error( @"Cannot find HKCU\Software\Microsoft\Windows\CurrentVersion\Run" );\n                    return false;\n                }\n                if (enabled)\n                {\n                    runKey.SetValue(Key, path);\n                }\n                else
                }\n                else\n                {\n                    runKey.DeleteValue(Key);\n                }\n                return true;\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);
                            return true;\n                        }\n                    }\n                }\n                return false;\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                return false;
        private AsyncSession _currentRemoteSession;\n        public Socket connection;\n        public ShadowsocksController controller;\n        public TCPRelay tcprelay;\n        public DateTime lastActivity;\n        private const int MaxRetry = 4;\n        private int _retryCount = 0;\n        private bool _proxyConnected;\n        private bool _destConnected;\n        private byte _command;
        private DateTime _startConnectTime;\n        private DateTime _startReceivingTime;\n        private DateTime _startSendingTime;\n        private int _bytesToSend;\n        private TCPRelay _tcprelay;  // TODO: is _tcprelay equals tcprelay declared above?\n        private Configuration _config;\n        public TCPHandler(TCPRelay tcprelay, Configuration config)\n        {
            this._tcprelay = tcprelay;\n            this._config = config;\n        }\n        public void CreateRemote()\n        {
        }\n        public void CreateRemote()\n        {
                if (_closed) return;\n                _closed = true;\n            }\n            try\n            {\n                connection?.Shutdown(SocketShutdown.Both);\n                connection?.Close();
            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n            }\n            try\n            {\n                var remote = _currentRemoteSession?.Remote;\n                remote?.Shutdown(SocketShutdown.Both);\n                remote?.Close();
            if (MbedTLS.cipher_set_iv(ctx, iv, ivLen) != 0)\n                throw new Exception();\n            if (MbedTLS.cipher_reset(ctx) != 0)\n                throw new Exception();\n        }\n        protected override void cipherUpdate(bool isCipher, int length, byte[] buf, byte[] outbuf)\n        {\n            // C# could be multi-threaded\n            if (_disposed)\n            {
            if (MbedTLS.cipher_reset(ctx) != 0)\n                throw new Exception();\n        }\n        protected override void cipherUpdate(bool isCipher, int length, byte[] buf, byte[] outbuf)\n        {\n            // C# could be multi-threaded\n            if (_disposed)\n            {\n                throw new ObjectDisposedException(this.ToString());\n            }
        }\n        protected override void cipherUpdate(bool isCipher, int length, byte[] buf, byte[] outbuf)\n        {\n            // C# could be multi-threaded\n            if (_disposed)\n            {\n                throw new ObjectDisposedException(this.ToString());\n            }\n            IntPtr ctx;\n            if (isCipher)
            }\n            else if (name.StartsWith("Japan", StringComparison.OrdinalIgnoreCase))\n            {\n                Init(Resources.jp);\n            }\n        }\n        public static string GetString(string key)\n        {\n            return _strings.ContainsKey(key)\n                ? _strings[key]
            }\n        }\n        public static string GetString(string key)\n        {\n            return _strings.ContainsKey(key)\n                ? _strings[key]\n                : key;\n        }\n    }\n}
        private LRUCache<IPEndPoint, UDPHandler> _cache;\n        public UDPRelay(Configuration config)\n        {\n            this._config = config;\n            this._cache = new LRUCache<IPEndPoint, UDPHandler>(512);  // todo: choose a smart number\n        }\n        public bool Handle(byte[] firstPacket, int length, Socket socket, object state)\n        {\n            if (socket.ProtocolType != ProtocolType.Udp)\n            {
        {\n            this._config = config;\n            this._cache = new LRUCache<IPEndPoint, UDPHandler>(512);  // todo: choose a smart number\n        }\n        public bool Handle(byte[] firstPacket, int length, Socket socket, object state)\n        {\n            if (socket.ProtocolType != ProtocolType.Udp)\n            {\n                return false;\n            }
            this._cache = new LRUCache<IPEndPoint, UDPHandler>(512);  // todo: choose a smart number\n        }\n        public bool Handle(byte[] firstPacket, int length, Socket socket, object state)\n        {\n            if (socket.ProtocolType != ProtocolType.Udp)\n            {\n                return false;\n            }\n            if (length < 4)\n            {
            _notifyIcon.Text = text.Substring(0, Math.Min(63, text.Length));\n        }\n        private MenuItem CreateMenuItem(string text, EventHandler click)\n        {\n            return new MenuItem(I18N.GetString(text), click);\n        }\n        private MenuItem CreateMenuGroup(string text, MenuItem[] items)\n        {\n            return new MenuItem(I18N.GetString(text), items);\n        }
            modeItem.Enabled = enableItem.Checked;\n        }\n        void controller_ShareOverLANStatusChanged(object sender, EventArgs e)\n        {\n            ShareOverLANItem.Checked = controller.GetConfiguration().shareOverLan;\n        }\n        void controller_EnableGlobalChanged(object sender, EventArgs e)\n        {\n            globalModeItem.Checked = controller.GetConfiguration().global;\n            PACModeItem.Checked = !globalModeItem.Checked;
        }\n        void controller_EnableGlobalChanged(object sender, EventArgs e)\n        {\n            globalModeItem.Checked = controller.GetConfiguration().global;\n            PACModeItem.Checked = !globalModeItem.Checked;\n        }\n        void controller_FileReadyToOpen(object sender, ShadowsocksController.PathEventArgs e)\n        {\n            string argument = @"/select, " + e.Path;\n            System.Diagnostics.Process.Start("explorer.exe", argument);
            PACModeItem.Checked = !globalModeItem.Checked;\n        }\n        void controller_FileReadyToOpen(object sender, ShadowsocksController.PathEventArgs e)\n        {\n            string argument = @"/select, " + e.Path;\n            System.Diagnostics.Process.Start("explorer.exe", argument);\n        }\n        void ShowBalloonTip(string title, string content, ToolTipIcon icon, int timeout)\n        {\n            _notifyIcon.BalloonTipTitle = title;
                MenuItem item = new MenuItem(server.FriendlyName());\n                item.Tag = i;\n                item.Click += AServerItem_Click;\n                items.Add(i, item);\n            }\n            if (configuration.index >= 0 && configuration.index < configuration.configs.Count)\n            {\n                items[configuration.index].Checked = true;
            }\n        }\n        private void ShowConfigForm()\n        {\n            if (configForm != null)\n            {\n                configForm.Activate();\n            }\n            else\n            {
        }\n        public bool Handle(byte[] firstPacket, int length, Socket socket, object state)\n        {\n            if (socket.ProtocolType != ProtocolType.Tcp)\n            {\n                return false;\n            }\n            if (length < 2 || firstPacket[0] != 5)\n            {\n                return false;
        {\n            return Configuration.Load();
            {\n                config.index = 0;\n            }\n            config.isDefault = false;\n            try\n            {\n                using (StreamWriter sw = new StreamWriter(File.Open(CONFIG_FILE, FileMode.Create)))\n                {\n                    string jsonString = SimpleJson.SimpleJson.SerializeObject(config);\n                    sw.Write(jsonString);
            }\n            config.isDefault = false;\n            try\n            {\n                using (StreamWriter sw = new StreamWriter(File.Open(CONFIG_FILE, FileMode.Create)))\n                {\n                    string jsonString = SimpleJson.SimpleJson.SerializeObject(config);\n                    sw.Write(jsonString);\n                    sw.Flush();\n                }
        {\n            try\n            {\n                connection.EndSend(ar);
                    Logging.Info("os suspend");\n                    break;\n            }\n        }\n        private static void Timer_Elapsed(object sender, System.Timers.ElapsedEventArgs e)\n        {\n            try\n            {\n                _controller?.Start();
            }\n            catch (Exception ex)\n            {\n                Logging.LogUsefulException(ex);\n            }\n            finally\n            {\n                try\n                {\n                    System.Timers.Timer timer = (System.Timers.Timer)sender;
            string base64 = Convert.ToBase64String(Encoding.UTF8.GetBytes(parts));\n            return "ss://" + base64;\n        }\n        public void UpdatePACFromGFWList()\n        {
        }\n        public void UpdatePACFromGFWList()\n        {\n            if (gfwListUpdater != null)\n            {\n                gfwListUpdater.UpdatePACFromGFWList(_config);\n            }\n        }\n        public void UpdateStatisticsConfiguration(bool enabled)\n        {
            if (!tag.IsNullOrEmpty())\n                remarks = tag.Substring(1).Trim();\n            match = DetailsParser.Match(Encoding.UTF8.GetString(Convert.FromBase64String(\n                base64.PadRight(base64.Length + (4 - base64.Length % 4) % 4, '='))));\n            method = match.Groups["method"].Value;\n            auth = match.Groups["auth"].Success;\n            password = match.Groups["password"].Value;\n            server = match.Groups["hostname"].Value;\n            server_port = int.Parse(match.Groups["port"].Value);\n        }
            match = DetailsParser.Match(Encoding.UTF8.GetString(Convert.FromBase64String(\n                base64.PadRight(base64.Length + (4 - base64.Length % 4) % 4, '='))));\n            method = match.Groups["method"].Value;\n            auth = match.Groups["auth"].Success;\n            password = match.Groups["password"].Value;\n            server = match.Groups["hostname"].Value;\n            server_port = int.Parse(match.Groups["port"].Value);\n        }\n        public string Identifier()\n        {
                    connection.BeginReceive(_connetionRecvBuffer, 0, RecvSize, SocketFlags.None, new AsyncCallback(ReadAll), null);\n                }\n                else\n                {\n                    int bytesRead = connection.EndReceive(ar);\n                    if (bytesRead > 0)\n                    {\n                        Logging.Debug(remote.LocalEndPoint, remote.DestEndPoint, RecvSize, "TCP Relay");\n                        connection.BeginReceive(_connetionRecvBuffer, 0, RecvSize, SocketFlags.None, new AsyncCallback(ReadAll), null);\n                    }
                        connection.BeginReceive(_connetionRecvBuffer, 0, RecvSize, SocketFlags.None, new AsyncCallback(ReadAll), null);\n                    }\n                    else\n                        Close();\n                }\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();
                {\n                    byte[] response = { 5, 0 };\n                    connection.BeginSend(response, 0, response.Length, 0, new AsyncCallback(handshakeSendCallback), null);\n                }\n                else\n                {
                {\n                    OpenSSL.EVP_CIPHER_CTX_cleanup(_encryptCtx);\n                    OpenSSL.EVP_CIPHER_CTX_free(_encryptCtx);\n                    _encryptCtx = IntPtr.Zero;\n                }\n                if (_decryptCtx != IntPtr.Zero)\n                {\n                    OpenSSL.EVP_CIPHER_CTX_cleanup(_decryptCtx);\n                    OpenSSL.EVP_CIPHER_CTX_free(_decryptCtx);\n                    _decryptCtx = IntPtr.Zero;
                {\n                    OpenSSL.EVP_CIPHER_CTX_cleanup(_decryptCtx);\n                    OpenSSL.EVP_CIPHER_CTX_free(_decryptCtx);\n                    _decryptCtx = IntPtr.Zero;\n                }\n                _disposed = true;\n            }\n        }\n        #endregion\n    }
            }\n            else\n            {\n                defConnection[8] = (byte)(defConnection[8] & ~8);\n                savedLegacySetting[8] = (byte)(savedLegacySetting[8] & ~8);\n            }\n            BitConverter.GetBytes(unchecked(BitConverter.ToUInt32(defConnection, 4) + 1)).CopyTo(defConnection, 4);\n            BitConverter.GetBytes(unchecked(BitConverter.ToUInt32(savedLegacySetting, 4) + 1)).CopyTo(savedLegacySetting, 4);
            }\n            BitConverter.GetBytes(unchecked(BitConverter.ToUInt32(defConnection, 4) + 1)).CopyTo(defConnection, 4);\n            BitConverter.GetBytes(unchecked(BitConverter.ToUInt32(savedLegacySetting, 4) + 1)).CopyTo(savedLegacySetting, 4);\n            registry.SetValue("DefaultConnectionSettings", defConnection);
            registry.SetValue("DefaultConnectionSettings", defConnection);\n            registry.SetValue("SavedLegacySettings", savedLegacySetting);\n        }\n    }\n}
    public sealed class AvailabilityStatistics\n    {
        public Statistics RawStatistics { get; private set; }\n        public Statistics FilteredStatistics { get; private set; }\n        public static readonly DateTime UnknownDateTime = new DateTime(1970, 1, 1);\n        private int Repeat => _config.RepeatTimesNum;\n        private readonly TimeSpan _retryInterval = TimeSpan.FromMinutes(2); //retry 2 minutes after failed\n        private TimeSpan Interval => TimeSpan.FromMinutes(_config.DataCollectionMinutes);\n        private Timer _timer;\n        private Timer _speedMonior;\n        private State _state;\n        private List<Server> _servers;
        private int Repeat => _config.RepeatTimesNum;\n        private readonly TimeSpan _retryInterval = TimeSpan.FromMinutes(2); //retry 2 minutes after failed\n        private TimeSpan Interval => TimeSpan.FromMinutes(_config.DataCollectionMinutes);\n        private Timer _timer;\n        private Timer _speedMonior;\n        private State _state;\n        private List<Server> _servers;\n        private StatisticsStrategyConfiguration _config;\n        private const string Empty = "";\n        public static string AvailabilityStatisticsFile;
        public bool Set(StatisticsStrategyConfiguration config)\n        {\n            _config = config;\n            try\n            {\n                if (config.StatisticsEnabled)\n                {\n                    if (_timer?.Change(_delayBeforeStart, Interval) == null)\n                    {\n                        _state = new State();
                    }\n                }\n                else\n                {\n                    _timer?.Dispose();\n                    _speedMonior?.Dispose();\n                }\n                return true;\n            }\n            catch (Exception e)
                    _speedMonior?.Dispose();\n                }\n                return true;\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                return false;\n            }\n        }
            bytes = _controller.outboundCounter - _lastOutboundCounter;\n            _lastOutboundCounter = _controller.outboundCounter;\n            var outboundSpeed = GetSpeedInKiBPerSecond(bytes, _monitorInterval.TotalSeconds);\n            if (inboundSpeed > _inboundSpeed)\n            {\n                _inboundSpeed = inboundSpeed;\n            }\n            if (outboundSpeed > _outboundSpeed)\n            {\n                _outboundSpeed = outboundSpeed;
        {\n            Logging.Debug("Ping " + server.FriendlyName());\n            if (server.server == "") return null;\n            var ret = new List<DataList>();\n            try {\n                var IP = Dns.GetHostAddresses(server.server).First(ip => (ip.AddressFamily == AddressFamily.InterNetwork || ip.AddressFamily == AddressFamily.InterNetworkV6));
                var ping = new Ping();\n                foreach (var timestamp in Enumerable.Range(0, Repeat).Select(_ => DateTime.Now.ToString(DateTimePattern)))\n                {\n                    //ICMP echo. we can also set options and special bytes\n                    try\n                    {\n                        var reply = await ping.SendTaskAsync(IP, TimeoutMilliseconds);\n                        ret.Add(new List<KeyValuePair<string, string>>\n                    {\n                        new KeyValuePair<string, string>("Timestamp", timestamp),\n                        new KeyValuePair<string, string>("Server", server.FriendlyName()),
                    try\n                    {\n                        var reply = await ping.SendTaskAsync(IP, TimeoutMilliseconds);\n                        ret.Add(new List<KeyValuePair<string, string>>\n                    {\n                        new KeyValuePair<string, string>("Timestamp", timestamp),\n                        new KeyValuePair<string, string>("Server", server.FriendlyName()),\n                        new KeyValuePair<string, string>("Status", reply?.Status.ToString()),\n                        new KeyValuePair<string, string>("RoundtripTime", reply?.RoundtripTime.ToString()),\n                        new KeyValuePair<string, string>("Latency", GetRecentLatency(server)),
                        //Do ICMPTest in a random frequency\n                    }\n                    catch (Exception e)\n                    {\n                        Logging.Error($"An exception occured while eveluating {server.FriendlyName()}");\n                        Logging.LogUsefulException(e);\n                    }\n                }\n            }catch(Exception e)
            FilterRawStatistics();\n            Evaluate();\n            ResetSpeed();\n        }\n        private async void Evaluate()\n        {\n            foreach (var dataLists in await TaskEx.WhenAll(_servers.Select(ICMPTest)))\n            {\n                if (dataLists == null) continue;\n                foreach (var dataList in dataLists.Where(dataList => dataList != null))
        private static void Append(DataList dataList, IEnumerable<DataUnit> extra)\n        {\n            var data = dataList.Concat(extra);\n            var dataLine = string.Join(Delimiter, data.Select(kv => kv.Value).ToArray());\n            string[] lines;\n            if (!File.Exists(AvailabilityStatisticsFile))\n            {\n                var headerLine = string.Join(Delimiter, data.Select(kv => kv.Key).ToArray());\n                lines = new[] { headerLine, dataLine };\n            }
            Set(controller.StatisticsConfiguration);\n            _servers = _controller.GetCurrentConfiguration().configs;\n        }
            }\n        }\n        private void LoadRawStatistics()\n        {\n            try\n            {\n                var path = AvailabilityStatisticsFile;\n                Logging.Debug($"loading statistics from {path}");\n                if (!File.Exists(path))\n                {
                        return;\n                    }\n                }\n                RawStatistics = (from l in File.ReadAllLines(path).Skip(1)\n                                 let strings = l.Split(new[] { "," }, StringSplitOptions.RemoveEmptyEntries)\n                                 let rawData = new RawStatisticsData\n                                 {\n                                     Timestamp = ParseExactOrUnknown(strings[0]),\n                                     ServerName = strings[1],\n                                     ICMPStatus = strings[2],
            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n            }\n        }\n        private DateTime ParseExactOrUnknown(string str)\n        {\n            DateTime dateTime;\n            return !DateTime.TryParseExact(str, DateTimePattern, null, DateTimeStyles.None, out dateTime) ? UnknownDateTime : dateTime;
        }\n        public void UpdateLatency(int latency)\n        {\n            _latency = latency;\n        }\n        private static int GetSpeedInKiBPerSecond(long bytes, double seconds)\n        {
        }\n        private static int GetSpeedInKiBPerSecond(long bytes, double seconds)\n        {
            if (!_controller.availabilityStatistics.FilteredStatistics.TryGetValue(serverName, out statistics)) return;\n            IEnumerable<IGrouping<int, AvailabilityStatistics.RawStatisticsData>> dataGroups;\n            if (allMode.Checked)\n            {\n                dataGroups = statistics.GroupBy(data => data.Timestamp.DayOfYear);\n                StatisticsChart.ChartAreas["DataArea"].AxisX.LabelStyle.Format = "MM/dd/yyyy";\n                StatisticsChart.ChartAreas["DataArea"].AxisX2.LabelStyle.Format = "MM/dd/yyyy";\n            }\n            else\n            {
            if (allMode.Checked)\n            {\n                dataGroups = statistics.GroupBy(data => data.Timestamp.DayOfYear);\n                StatisticsChart.ChartAreas["DataArea"].AxisX.LabelStyle.Format = "MM/dd/yyyy";\n                StatisticsChart.ChartAreas["DataArea"].AxisX2.LabelStyle.Format = "MM/dd/yyyy";\n            }\n            else\n            {\n                dataGroups = statistics.GroupBy(data => data.Timestamp.Hour);\n                StatisticsChart.ChartAreas["DataArea"].AxisX.LabelStyle.Format = "HH:00";
        private int ChoiceKeptMilliseconds\n            => (int) TimeSpan.FromMinutes(_controller.StatisticsConfiguration.ChoiceKeptMinutes).TotalMilliseconds;\n        public StatisticsStrategy(ShadowsocksController controller)\n        {\n            _controller = controller;\n            var servers = controller.GetCurrentConfiguration().configs;\n            var randomIndex = new Random().Next() % servers.Count();\n            _currentServer = servers[randomIndex];  //choose a server randomly at first\n            _timer = new Timer(ReloadStatisticsAndChooseAServer);\n        }
        }\n        //return the score by data\n        //server with highest score will be choosen\n        private float GetScore(string serverName)\n        {\n            var config = _controller.StatisticsConfiguration;\n            List<AvailabilityStatistics.RawStatisticsData> dataList;\n            if (_filteredStatistics == null || !_filteredStatistics.TryGetValue(serverName, out dataList)) return 0;\n            var successTimes = (float) dataList.Count(data => data.ICMPStatus.Equals(IPStatus.Success.ToString()));\n            var timedOutTimes = (float) dataList.Count(data => data.ICMPStatus.Equals(IPStatus.TimedOut.ToString()));\n            var statisticsData = new AvailabilityStatistics.StatisticsData\n            {
            float factor;\n            float score = 0;\n            if (!config.Calculations.TryGetValue("PackageLoss", out factor)) factor = 0;\n            score += statisticsData.PackageLoss*factor;\n            if (!config.Calculations.TryGetValue("AverageResponse", out factor)) factor = 0;
            if (!config.Calculations.TryGetValue("AverageResponse", out factor)) factor = 0;\n            score += statisticsData.AverageResponse*factor;\n            if (!config.Calculations.TryGetValue("MinResponse", out factor)) factor = 0;\n            score += statisticsData.MinResponse*factor;\n            if (!config.Calculations.TryGetValue("MaxResponse", out factor)) factor = 0;\n            score += statisticsData.MaxResponse*factor;\n            Logging.Debug($"{serverName}  {JsonConvert.SerializeObject(statisticsData)}");\n            return score;\n        }\n        private void ChooseNewServer(List<Server> servers)
            if (!config.Calculations.TryGetValue("MinResponse", out factor)) factor = 0;\n            score += statisticsData.MinResponse*factor;\n            if (!config.Calculations.TryGetValue("MaxResponse", out factor)) factor = 0;\n            score += statisticsData.MaxResponse*factor;\n            Logging.Debug($"{serverName}  {JsonConvert.SerializeObject(statisticsData)}");\n            return score;\n        }\n        private void ChooseNewServer(List<Server> servers)\n        {\n            if (_filteredStatistics == null || servers.Count == 0)
            if (!config.Calculations.TryGetValue("MaxResponse", out factor)) factor = 0;\n            score += statisticsData.MaxResponse*factor;\n            Logging.Debug($"{serverName}  {JsonConvert.SerializeObject(statisticsData)}");\n            return score;\n        }\n        private void ChooseNewServer(List<Server> servers)\n        {\n            if (_filteredStatistics == null || servers.Count == 0)\n            {\n                return;
            return score;\n        }\n        private void ChooseNewServer(List<Server> servers)\n        {\n            if (_filteredStatistics == null || servers.Count == 0)\n            {\n                return;\n            }\n            try\n            {
            this.tableLayoutPanel1.SuspendLayout();\n            this.panel1.SuspendLayout();\n            this.panel3.SuspendLayout();\n            this.ServerGroupBox.SuspendLayout();\n            this.SuspendLayout();\n            // \n            // tableLayoutPanel1\n            // \n            this.tableLayoutPanel1.AutoSize = true;\n            this.tableLayoutPanel1.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;
            this.tableLayoutPanel1.Name = "tableLayoutPanel1";\n            this.tableLayoutPanel1.Padding = new System.Windows.Forms.Padding(5);\n            this.tableLayoutPanel1.RowCount = 6;\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel1.RowCount = 6;\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.RemarksTextBox.Name = "RemarksTextBox";\n            this.label6.Location = new System.Drawing.Point(19, 142);\n            this.label6.Name = "label6";
            this.label6.Name = "label6";\n            this.label1.Location = new System.Drawing.Point(17, 11);\n            this.label1.Name = "label1";
            this.label1.Name = "label1";\n            this.label2.Location = new System.Drawing.Point(8, 37);\n            this.label2.Name = "label2";
            this.label2.Name = "label2";\n            this.ProxyPortTextBox.Location = new System.Drawing.Point(74, 113);\n            this.ProxyPortTextBox.Name = "ProxyPortTextBox";
            this.ProxyPortTextBox.Name = "ProxyPortTextBox";\n            this.label4.Location = new System.Drawing.Point(13, 116);\n            this.label4.Name = "label4";
            this.label4.Name = "label4";\n            this.label3.Location = new System.Drawing.Point(15, 63);\n            this.label3.Name = "label3";
            this.label3.Name = "label3";\n            this.IPTextBox.Location = new System.Drawing.Point(74, 8);\n            this.IPTextBox.Name = "IPTextBox";
            this.IPTextBox.Name = "IPTextBox";\n            this.ServerPortTextBox.Location = new System.Drawing.Point(74, 34);\n            this.ServerPortTextBox.Name = "ServerPortTextBox";
            this.ServerPortTextBox.Name = "ServerPortTextBox";\n            this.PasswordTextBox.Location = new System.Drawing.Point(74, 60);\n            this.PasswordTextBox.Name = "PasswordTextBox";\n            this.PasswordTextBox.PasswordChar = '*';
            this.PasswordTextBox.Name = "PasswordTextBox";\n            this.PasswordTextBox.PasswordChar = '*';\n            this.label5.Location = new System.Drawing.Point(11, 90);\n            this.label5.Name = "label5";
            this.label5.Name = "label5";
            this.EncryptionSelect.Name = "EncryptionSelect";\n            this.notifyIcon1.Icon = ((System.Drawing.Icon)(resources.GetObject("notifyIcon1.Icon")));\n            this.notifyIcon1.Text = "Shadowsocks";\n            this.notifyIcon1.Visible = true;\n            this.notifyIcon1.DoubleClick += new System.EventHandler(this.notifyIcon1_DoubleClick);\n            // \n            // panel2\n            // 
            this.notifyIcon1.Text = "Shadowsocks";\n            this.notifyIcon1.Visible = true;\n            this.notifyIcon1.DoubleClick += new System.EventHandler(this.notifyIcon1_DoubleClick);\n            // \n            // panel2\n            // \n            this.panel2.Anchor = System.Windows.Forms.AnchorStyles.Top;\n            this.panel2.AutoSize = true;\n            this.panel2.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;\n            this.panel2.Location = new System.Drawing.Point(164, 175);\n            this.panel2.Name = "panel2";\n            this.panel2.Size = new System.Drawing.Size(0, 0);
            this.notifyIcon1.DoubleClick += new System.EventHandler(this.notifyIcon1_DoubleClick);\n            // \n            // panel2\n            // \n            this.panel2.Anchor = System.Windows.Forms.AnchorStyles.Top;\n            this.panel2.AutoSize = true;\n            this.panel2.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;\n            this.panel2.Location = new System.Drawing.Point(164, 175);\n            this.panel2.Name = "panel2";\n            this.panel2.Size = new System.Drawing.Size(0, 0);\n            this.panel2.TabIndex = 1;\n            // 
            this.panel2.Name = "panel2";\n            this.panel2.Size = new System.Drawing.Size(0, 0);\n            this.panel2.TabIndex = 1;\n            // \n            // OKButton\n            // \n            this.OKButton.DialogResult = System.Windows.Forms.DialogResult.OK;\n            this.OKButton.Location = new System.Drawing.Point(4, 4);\n            this.OKButton.Name = "OKButton";
            this.OKButton.Name = "OKButton";\n            this.MyCancelButton.Location = new System.Drawing.Point(86, 4);\n            this.MyCancelButton.Name = "MyCancelButton";
            this.MyCancelButton.Name = "MyCancelButton";
            this.DeleteButton.Name = "DeleteButton";\n            this.AddButton.Location = new System.Drawing.Point(4, 4);\n            this.AddButton.Name = "AddButton";
            this.AddButton.Name = "AddButton";\n            this.ServerGroupBox.Location = new System.Drawing.Point(222, 12);\n            this.ServerGroupBox.Name = "ServerGroupBox";
            this.ServerGroupBox.Name = "ServerGroupBox";\n            this.ServerGroupBox.Size = new System.Drawing.Size(255, 205);\n            this.ServerGroupBox.TabIndex = 6;\n            this.ServerGroupBox.TabStop = false;\n            this.ServerGroupBox.Text = "Server";\n            // \n            // ServersListBox\n            // \n            this.ServersListBox.FormattingEnabled = true;\n            this.ServersListBox.Location = new System.Drawing.Point(12, 12);
            this.ServerGroupBox.TabIndex = 6;\n            this.ServerGroupBox.TabStop = false;\n            this.ServerGroupBox.Text = "Server";\n            // \n            // ServersListBox\n            // \n            this.ServersListBox.FormattingEnabled = true;\n            this.ServersListBox.Location = new System.Drawing.Point(12, 12);\n            this.ServersListBox.Name = "ServersListBox";
            this.ServersListBox.Name = "ServersListBox";
            {\n                return File.ReadAllText(PAC_FILE, Encoding.UTF8);\n            }\n            else\n            {\n                return Resources.default_abp_rule + Resources.abp_js;\n            }\n        }\n        private void WatchPacFile()
            }\n            else\n            {\n                return Resources.default_abp_rule + Resources.abp_js;\n            }\n        }\n        private void WatchPacFile()\n        {\n            PACFileWatcher?.Dispose();
        }\n        private void WatchPacFile()\n        {\n            PACFileWatcher?.Dispose();\n            PACFileWatcher = new FileSystemWatcher(Directory.GetCurrentDirectory());\n            PACFileWatcher.NotifyFilter = NotifyFilters.LastWrite | NotifyFilters.FileName | NotifyFilters.DirectoryName;\n            PACFileWatcher.Filter = PAC_FILE;\n            PACFileWatcher.Changed += PACFileWatcher_Changed;\n            PACFileWatcher.Created += PACFileWatcher_Changed;\n            PACFileWatcher.Deleted += PACFileWatcher_Changed;
            return true;\n        }\n        public class UDPHandler\n        {\n            private Socket _local;\n            private Socket _remote;\n            private Server _server;\n            private byte[] _buffer = new byte[65536];\n            private IPEndPoint _localEndPoint;\n            private IPEndPoint _remoteEndPoint;
                ServersListBox.SelectedIndexChanged += ServersListBox_SelectedIndexChanged;\n                return true;\n            }\n            else\n                return false;\n        }\n        #region GetServerDetailsFromUI Check\n        private bool? CheckIPTextBox(out string address, bool isSave, bool isCopy)\n        {\n            address = null;
            }\n        }\n        private void DuplicateButton_Click(object sender, EventArgs e)\n        {\n            if (ValidateAndSaveSelectedServerDetails(isCopy: true))\n            {\n                Server currServer = _modifiedConfiguration.configs[_lastSelectedIndex];\n                Configuration.AddDefaultServerOrServer(_modifiedConfiguration, currServer);\n                LoadServerNameListToUI(_modifiedConfiguration);\n                UpdateIndexToEnd();
                LoadServerNameListToUI(_modifiedConfiguration);\n                UpdateIndexToEnd();\n            }\n        }\n        private void DeleteButton_Click(object sender, EventArgs e)\n        {\n            _modifiedConfiguration.configs.RemoveAt(_lastSelectedIndex);\n            if (_modifiedConfiguration.configs.Count == 0)\n            {\n                Configuration.AddDefaultServerOrServer(_modifiedConfiguration);
            }\n        }\n        private void DeleteButton_Click(object sender, EventArgs e)\n        {\n            _modifiedConfiguration.configs.RemoveAt(_lastSelectedIndex);\n            if (_modifiedConfiguration.configs.Count == 0)\n            {\n                Configuration.AddDefaultServerOrServer(_modifiedConfiguration);\n            }\n            LoadServerNameListToUI(_modifiedConfiguration);
            ServersListBox.BeginUpdate();\n            ServersListBox.Enabled = false;\n            _lastSelectedIndex = index + step;\n            ServersListBox.Items.Remove(item);\n            ServersListBox.Items.Insert(index + step, item);\n            ServersListBox.Enabled = true;\n            ServersListBox.SelectedIndex = index + step;
            ServersListBox.EndUpdate();\n            UpdateButtons();\n        }\n        private void OKButton_Click(object sender, EventArgs e)\n        {\n            if (SaveValidConfiguration())\n            {\n                Close();\n            }\n        }
                }\n                else\n                {\n                    _decryptIV = new byte[ivLen];\n                    Array.Copy(iv, _decryptIV, ivLen);\n                }\n            }\n            else if (_cipher == CIPHER_BF)\n            {\n                PolarSSL.blowfish_init(ctx);
            }\n        }\n        static byte[] tempbuf = new byte[32768];\n        public override void Encrypt(byte[] buf, int length, byte[] outbuf, out int outlength)\n        {\n            if (_encryptCtx == null)\n            {\n                randBytes(outbuf, ivLen);\n                InitCipher(ref _encryptCtx, outbuf, true);\n                outlength = length + ivLen;
                            break;\n                        case CIPHER_BF:\n                            PolarSSL.blowfish_crypt_cfb64(_encryptCtx, PolarSSL.BLOWFISH_ENCRYPT, length, ref _encryptIVOffset, _encryptIV, buf, tempbuf);\n                            break;\n                        case CIPHER_RC4:\n                            PolarSSL.arc4_crypt(_encryptCtx, length, buf, tempbuf);\n                            break;\n                    }\n                    outlength = length + ivLen;\n                    Buffer.BlockCopy(tempbuf, 0, outbuf, ivLen, outlength);
                            break;\n                        case CIPHER_RC4:\n                            PolarSSL.arc4_crypt(_encryptCtx, length, buf, tempbuf);\n                            break;\n                    }\n                    outlength = length + ivLen;\n                    Buffer.BlockCopy(tempbuf, 0, outbuf, ivLen, outlength);\n                }\n            }\n            else
                }\n            }\n        }\n        public override void Decrypt(byte[] buf, int length, byte[] outbuf, out int outlength)\n        {\n            if (_decryptCtx == null)\n            {\n                InitCipher(ref _decryptCtx, buf, false);\n                outlength = length - ivLen;\n                lock (tempbuf)
                            break;\n                        case CIPHER_BF:\n                            PolarSSL.blowfish_crypt_cfb64(_decryptCtx, PolarSSL.BLOWFISH_DECRYPT, length - ivLen, ref _decryptIVOffset, _decryptIV, tempbuf, outbuf);\n                            break;\n                        case CIPHER_RC4:\n                            PolarSSL.arc4_crypt(_decryptCtx, length - ivLen, tempbuf, outbuf);\n                            break;\n                    }\n                }\n            }
                            break;\n                        case CIPHER_RC4:\n                            PolarSSL.arc4_crypt(_decryptCtx, length - ivLen, tempbuf, outbuf);\n                            break;\n                    }\n                }\n            }\n            else\n            {\n                outlength = length;
                }\n            }\n        }\n        #region IDisposable\n        private bool _disposed;\n        public override void Dispose()\n        {\n            Dispose(true);\n            GC.SuppressFinalize(this);\n        }
                if (_encryptCtx != null)\n                {\n                    switch (_cipher)\n                    {\n                        case CIPHER_AES:\n                            PolarSSL.aes_free(_encryptCtx);\n                            break;\n                        case CIPHER_BF:\n                            PolarSSL.blowfish_free(_encryptCtx);\n                            break;
                    }\n                }\n                if (_decryptCtx != null)\n                {\n                    switch (_cipher)\n                    {\n                        case CIPHER_AES:\n                            PolarSSL.aes_free(_decryptCtx);\n                            break;\n                        case CIPHER_BF:
            }\n        }\n        #endregion\n    }\n}
Content-Type: application/x-ns-proxy-autoconfig\nContent-Length: {0}\nConnection: Close
Connection: Close
            {\n                return sr.ReadToEnd();
            }\n        }\n    }\n}
        protected ulong _encryptIC;\n        protected ulong _decryptIC;\n        public SodiumEncryptor(string method, string password)\n            : base(method, password)\n        {\n            InitKey(method, password);
            ulong ic;\n            if (isCipher)\n            {\n                bytesRemaining = _encryptBytesRemaining;\n                ic = _encryptIC;\n            }
[assembly: AssemblyDescription("")]\n[assembly: AssemblyConfiguration("")]\n[assembly: AssemblyCompany("clowwindy")]\n[assembly: AssemblyProduct("shadowsocks-csharp")]\n[assembly: AssemblyCopyright("Copyright © clowwindy 2014")]\n[assembly: AssemblyTrademark("")]\n[assembly: AssemblyCulture("")]\n// 将 ComVisible 设置为 false 使此程序集中的类型\n// 对 COM 组件不可见。如果需要从 COM 访问此程序集中的类型，\n// 则将该类型上的 ComVisible 属性设置为 true。
[assembly: AssemblyCopyright("Copyright © clowwindy 2014")]\n[assembly: AssemblyTrademark("")]\n[assembly: AssemblyCulture("")]\n// 将 ComVisible 设置为 false 使此程序集中的类型\n// 对 COM 组件不可见。如果需要从 COM 访问此程序集中的类型，\n// 则将该类型上的 ComVisible 属性设置为 true。\n[assembly: ComVisible(false)]\n// 如果此项目向 COM 公开，则下列 GUID 用于类型库的 ID\n[assembly: Guid("f8334709-4309-436a-8bbd-6165dcf4a660")]\n// 程序集的版本信息由下面四个值组成:
using System.Collections.Generic;\nusing System.IO;\nusing System.Windows.Forms;\nnamespace shadowsocks_csharp\n{\n    static class Program\n    {
                FileStream fs = new FileStream("shadowsocks.log", FileMode.Append);\n                TextWriter tmp = Console.Out;\n                StreamWriter sw = new StreamWriter(fs);\n                sw.AutoFlush = true;\n                Console.SetOut(sw);\n                Console.SetError(sw);\n            }\n            catch (IOException e)\n            {\n                Console.WriteLine(e.ToString());
                foreach(string domain in domains)\n                {\n                    string last_root_domain = null;\n                    int pos;\n                    pos = domain.LastIndexOf('.');\n                    last_root_domain = domain.Substring(pos + 1);\n                    if (!tld_dic.ContainsKey(last_root_domain))\n                        continue;\n                    while(pos > 0)\n                    {
                        continue;\n                    while(pos > 0)\n                    {\n                        pos = domain.LastIndexOf('.', pos - 1);\n                        last_root_domain = domain.Substring(pos + 1);\n                        if (tld_dic.ContainsKey(last_root_domain))\n                            continue;\n                        else\n                            break;\n                    }
            {\n                string[] tlds = GetTlds();\n                IDictionary<string, string> dic = new Dictionary<string, string>(tlds.Length);\n                foreach (string tld in tlds)\n                {\n                    if (!dic.ContainsKey(tld))
                foreach (string tld in tlds)\n                {\n                    if (!dic.ContainsKey(tld))
                        dic.Add(tld, tld);\n                }\n                return dic;
            }\n        }\n    }\n}
                }\n            }\n        }\n        public void UpdateLatency(Model.Server server, TimeSpan latency)\n        {\n            Logging.Debug(String.Format("latency: {0} {1}", server.FriendlyName(), latency));\n            ServerStatus status;\n            if (_serverStatus.TryGetValue(server, out status))\n            {\n                status.latency = latency;
            ServerStatus status;\n            if (_serverStatus.TryGetValue(server, out status))\n            {\n                status.latency = latency;\n                status.lastTimeDetectLatency = DateTime.Now;\n            }\n        }\n        public void UpdateLastRead(Model.Server server)\n        {\n            Logging.Debug(String.Format("last read: {0}", server.FriendlyName()));
            ServerStatus status;\n            if (_serverStatus.TryGetValue(server, out status))\n            {\n                status.lastRead = DateTime.Now;\n            }\n        }\n        public void UpdateLastWrite(Model.Server server)\n        {\n            Logging.Debug(String.Format("last write: {0}", server.FriendlyName()));\n            ServerStatus status;
            ServerStatus status;\n            if (_serverStatus.TryGetValue(server, out status))\n            {\n                status.lastWrite = DateTime.Now;\n            }\n        }\n        public void SetFailure(Model.Server server)\n        {\n            Logging.Debug(String.Format("failure: {0}", server.FriendlyName()));\n            ServerStatus status;
            ServerStatus status;\n            if (_serverStatus.TryGetValue(server, out status))\n            {\n                status.lastFailure = DateTime.Now;\n            }\n        }\n    }\n}
            {\n                Console.WriteLine("Exception caught in process: {0}",\n                                  _Exception.ToString());\n            }\n            return false;\n        }\n        public static void UncompressFile(string fileName, byte[] content)\n        {\n            FileStream destinationFile = File.Create(fileName);
            }\n            return false;\n        }\n        public static void UncompressFile(string fileName, byte[] content)\n        {\n            FileStream destinationFile = File.Create(fileName);\n            // Because the uncompressed size of the file is unknown, \n            // we are using an arbitrary buffer size.\n            byte[] buffer = new byte[4096];\n            int n;
#endif\n        }\n        public static void LogUsefulException(Exception e)\n        {\n            // just log useful exceptions, not all of them\n            if (e is SocketException)\n            {\n                SocketException se = (SocketException)e;\n                if (se.SocketErrorCode == SocketError.ConnectionAborted)\n                {
        #endregion\n        public LogForm(ShadowsocksController controller, string filename)\n        {\n            this.controller = controller;\n            this.filename = filename;\n            InitializeComponent();\n            Icon = Icon.FromHandle(Resources.ssw128.GetHicon());\n            LogViewerConfig config = controller.GetConfigurationCopy().logViewer;\n            topMostTrigger = config.topMost;\n            wrapTextTrigger = config.wrapText;
            const long minScale = 50;\n            long maxSpeed = 0;\n            long lastInbound, lastOutbound;\n            lock (this)\n            {\n                if (traffic.Count == 0)\n                    return;\n                foreach (var trafficPerSecond in traffic)\n                {\n                    inboundPoints.Add(trafficPerSecond.Item1);
            }\n            if (maxSpeed > 0)\n            {\n                lastMaxSpeed -= lastMaxSpeed / 32;\n                maxSpeed = Math.Max(minScale, Math.Max(maxSpeed, lastMaxSpeed));\n                lastMaxSpeed = maxSpeed;\n            }\n            else\n            {\n                maxSpeed = lastMaxSpeed = minScale;
            if (trafficChart.IsHandleCreated)\n            {\n                trafficChart.Series["Inbound"].Points.DataBindY(inboundPoints);\n                trafficChart.Series["Outbound"].Points.DataBindY(outboundPoints);\n                trafficChart.ChartAreas[0].AxisY.LabelStyle.Format = "{0:0.##} " + bandwidthScale.Item2;\n                trafficChart.ChartAreas[0].AxisY.Maximum = bandwidthScale.Item1;\n                inboundAnnotation.AnchorDataPoint = trafficChart.Series["Inbound"].Points.Last();\n                inboundAnnotation.Text = Utils.FormatBandwidth(lastInbound);\n                outboundAnnotation.AnchorDataPoint = trafficChart.Series["Outbound"].Points.Last();\n                outboundAnnotation.Text = Utils.FormatBandwidth(lastOutbound);
                inboundAnnotation.AnchorDataPoint = trafficChart.Series["Inbound"].Points.Last();\n                inboundAnnotation.Text = Utils.FormatBandwidth(lastInbound);\n                outboundAnnotation.AnchorDataPoint = trafficChart.Series["Outbound"].Points.Last();\n                outboundAnnotation.Text = Utils.FormatBandwidth(lastOutbound);\n                trafficChart.Annotations.Clear();\n                trafficChart.Annotations.Add(inboundAnnotation);\n                trafficChart.Annotations.Add(outboundAnnotation);\n            }\n        }\n        private void controller_TrafficChanged(object sender, EventArgs e)
                foreach (var trafficPerSecond in controller.traffic)\n                {\n                    traffic.Enqueue(new Tuple<long, long>(trafficPerSecond.inboundIncreasement, trafficPerSecond.outboundIncreasement));\n                }\n            }\n        }\n        private void UpdateTexts()\n        {\n            FileMenuItem.Text = I18N.GetString("&File");\n            OpenLocationMenuItem.Text = I18N.GetString("&Open Location");
                }\n            }\n        }\n        private void UpdateTexts()\n        {\n            FileMenuItem.Text = I18N.GetString("&File");\n            OpenLocationMenuItem.Text = I18N.GetString("&Open Location");\n            ExitMenuItem.Text = I18N.GetString("E&xit");\n            CleanLogsButton.Text = I18N.GetString("&Clean Logs");\n            ChangeFontButton.Text = I18N.GetString("Change &Font");
        }\n        /// <summary>\n        /// Return scaled bandwidth\n        /// </summary>\n        /// <param name="n">Raw bandwidth</param>\n        /// <returns>\n        public static Tuple<float, string, long> GetBandwidthScale(long n)\n        {\n            long scale = 1;\n            float f = n;\n            string unit = "B";\n            if (f > 1024)\n            {\n                f = f / 1024;\n                scale <<= 10;
        {\n            long scale = 1;\n            float f = n;\n            string unit = "B";\n            if (f > 1024)\n            {\n                f = f / 1024;\n                scale <<= 10;\n                unit = "KiB";\n            }
using Shadowsocks.Model;\nusing Shadowsocks.Util.Sockets;\nnamespace Shadowsocks.Controller\n{\n    class TCPRelay : Listener.Service\n    {\n        private ShadowsocksController _controller;\n        private DateTime _lastSweepTime;\n        private Configuration _config;
{\n    public class Socks5Proxy : IForwardProxy\n    {\n        private class FakeAsyncResult : IAsyncResult\n        {\n            public readonly Socks5State innerState;\n            private readonly IAsyncResult r;\n            public FakeAsyncResult(IAsyncResult orig, Socks5State state)\n            {\n                r = orig;
    {\n        private class FakeAsyncResult : IAsyncResult\n        {\n            public readonly Socks5State innerState;\n            private readonly IAsyncResult r;\n            public FakeAsyncResult(IAsyncResult orig, Socks5State state)\n            {\n                r = orig;\n                innerState = state;\n            }
{\n    public class HttpProxy : IForwardProxy\n    {\n        private class FakeAsyncResult : IAsyncResult\n        {\n            public readonly HttpState innerState;\n            private readonly IAsyncResult r;\n            public FakeAsyncResult(IAsyncResult orig, HttpState state)\n            {\n                r = orig;
    {\n        private class FakeAsyncResult : IAsyncResult\n        {\n            public readonly HttpState innerState;\n            private readonly IAsyncResult r;\n            public FakeAsyncResult(IAsyncResult orig, HttpState state)\n            {\n                r = orig;\n                innerState = state;\n            }
{\n    public interface IForwardProxy\n    {\n        EndPoint LocalEndPoint { get; }\n        EndPoint ProxyEndPoint { get; }\n        EndPoint DestEndPoint { get; }\n        void BeginConnectProxy(EndPoint remoteEP, AsyncCallback callback, object state);\n        void EndConnectProxy(IAsyncResult asyncResult);\n        void BeginConnectDest(EndPoint destEndPoint, AsyncCallback callback, object state);\n        void EndConnectDest(IAsyncResult asyncResult);
    {\n        EndPoint LocalEndPoint { get; }\n        EndPoint ProxyEndPoint { get; }\n        EndPoint DestEndPoint { get; }\n        void BeginConnectProxy(EndPoint remoteEP, AsyncCallback callback, object state);\n        void EndConnectProxy(IAsyncResult asyncResult);\n        void BeginConnectDest(EndPoint destEndPoint, AsyncCallback callback, object state);\n        void EndConnectDest(IAsyncResult asyncResult);\n        void BeginSend(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state);
{\n    public class DirectConnect : IForwardProxy\n    {\n        private class FakeAsyncResult : IAsyncResult\n        {\n            public FakeAsyncResult(object state)\n            {\n                AsyncState = state;\n            }\n            public bool IsCompleted { get; } = true;
    {\n        private class FakeAsyncResult : IAsyncResult\n        {\n            public FakeAsyncResult(object state)\n            {\n                AsyncState = state;\n            }\n            public bool IsCompleted { get; } = true;\n            public WaitHandle AsyncWaitHandle { get; } = null;\n            public object AsyncState { get; }
        public const string Version = "2.5.8";\n        public void CheckUpdate(Configuration config)\n        {\n            // TODO test failures\n            WebClient http = new WebClient();\n            http.Headers.Add("User-Agent", "Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.3319.102 Safari/537.36");\n            http.Proxy = new WebProxy(IPAddress.Loopback.ToString(), config.localPort);\n            http.DownloadStringCompleted += http_DownloadStringCompleted;\n            http.DownloadStringAsync(new Uri(UpdateURL));\n        }
                {\n                    return;\n                }\n                // sort versions\n                SortVersions(versions);\n                LatestVersionURL = versions[versions.Count - 1];
                }\n                // sort versions\n                SortVersions(versions);\n                LatestVersionURL = versions[versions.Count - 1];\n                LatestVersionNumber = ParseVersionFromURL(LatestVersionURL);\n                if (NewVersionFound != null)\n                {\n                    NewVersionFound(this, new EventArgs());\n                }\n            }
                {\n                    NewVersionFound(this, new EventArgs());\n                }\n            }\n            catch (Exception ex)\n            {\n                Logging.Debug(ex.ToString());\n                return;\n            }\n        }
                }\n            }\n            catch (Exception ex)\n            {\n                Logging.Debug(ex.ToString());\n                return;\n            }\n        }\n    }\n}
            LoadCurrentConfiguration();\n            updateChecker.CheckUpdate(controller.GetConfigurationCopy());\n            if (controller.GetConfigurationCopy().isDefault)

using Shadowsocks.Controller;\nnamespace Shadowsocks.Encryption.Stream\n{\n    public abstract class StreamEncryptor\n        : EncryptorBase\n    {\n        // for UDP only\n        protected static byte[] _udpTmpBuf = new byte[65536];\n        // every connection should create its own buffer\n        private CircularBuffer<byte> _encCircularBuffer = new CircularBuffer<byte>(TCPHandler.BufferSize * 2, false);\n        private CircularBuffer<byte> _decCircularBuffer = new CircularBuffer<byte>(TCPHandler.BufferSize * 2, false);\n        protected Dictionary<string, EncryptorInfo> ciphers;
        protected Dictionary<string, EncryptorInfo> ciphers;\n        protected byte[] _encryptIV;\n        protected byte[] _decryptIV;\n        // Is first packet\n        protected bool _decryptIVReceived;\n        protected bool _encryptIVSent;\n        protected string _method;\n        protected int _cipher;\n        // internal name in the crypto library\n        protected string _innerLibName;
        }\n        private void OKButton_Click(object sender, EventArgs e)\n        {\n            // try to register, notify to change settings if failed\n            foreach (var tb in _allTextBoxes)\n            {\n                if (tb.Text.IsNullOrEmpty())\n                {\n                    continue;\n                }\n                if (!TryRegHotkey(tb))
            }\n            // All check passed, saving\n            SaveConfig();\n            Close();\n        }\n        private void RegisterAllButton_Click(object sender, EventArgs e)\n        {
        }\n        private void RegisterAllButton_Click(object sender, EventArgs e)\n        {\n            foreach (var tb in _allTextBoxes)
        }\n        private bool TryRegHotkey(TextBox tb)\n        {\n            var hotkey = HotKeys.Str2HotKey(tb.Text);\n            if (hotkey == null)\n            {\n                MessageBox.Show(string.Format(I18N.GetString("Cannot parse hotkey: {0}"), tb.Text));\n                tb.Clear();\n                return false;\n            }
            lb.BackColor = regResult ? Color.Green : Color.Yellow;\n            return regResult;\n        }\n        private static void UnregPrevHotkey(HotKeys.HotKeyCallBackHandler cb)\n        {\n            GlobalHotKey.HotKey prevHotKey;\n            if (HotKeys.IsCallbackExists(cb, out prevHotKey))\n            {\n                // unregister previous one\n                HotKeys.UnRegist(prevHotKey);\n            }
            }\n        }\n        private void SaveConfig()\n        {\n            _modifiedConfig.SwitchSystemProxy = SwitchSystemProxyTextBox.Text;\n            _modifiedConfig.SwitchSystemProxyMode = SwitchProxyModeTextBox.Text;\n            _modifiedConfig.SwitchAllowLan = SwitchAllowLanTextBox.Text;\n            _modifiedConfig.ShowLogs = ShowLogsTextBox.Text;\n            _modifiedConfig.ServerMoveUp = ServerMoveUpTextBox.Text;\n            _modifiedConfig.ServerMoveDown = ServerMoveDownTextBox.Text;
        }\n        #region Prepare hotkey\n        /// <summary>\n        /// Find correct callback and corresponding label\n        /// </summary>\n        /// <param name="tb"></param>\n        /// <param name="cb"></param>\n        /// <param name="lb"></param>\n        private void PrepareForHotkey(TextBox tb, out HotKeys.HotKeyCallBackHandler cb, out Label lb)\n        {
        }\n    }\n}
        public HighAvailabilityStrategy(ShadowsocksController controller)\n        {\n            _controller = controller;\n            _random = new Random();\n            _serverStatus = new Dictionary<Server, ServerStatus>();\n        }\n        public string Name\n        {\n            get { return I18N.GetString("High Availability"); }\n        }
        }\n        public Server GetAServer(IStrategyCallerType type, System.Net.IPEndPoint localIPEndPoint)\n        {\n            return _currentServer;
namespace Shadowsocks.Model\n{\n    [Serializable]\n    public class StatisticsStrategyConfiguration\n    {
        {\n            var match = UrlFinder.Match(ssURL);\n            if (!match.Success) throw new FormatException();\n            var base64 = match.Groups[1].Value;\n            var tag = match.Groups[3].Value;\n            if (!tag.IsNullOrEmpty())\n                remarks = HttpUtility.UrlDecode(tag, Encoding.UTF8);\n            match = DetailsParser.Match(Encoding.UTF8.GetString(Convert.FromBase64String(\n                base64.PadRight(base64.Length + (4 - base64.Length % 4) % 4, '='))));\n            method = match.Groups["method"].Value;
        }\n        public string Identifier()\n        {\n            return server + ':' + server_port;\n        }\n    }\n}
        {\n            for (int i = 0; i < buf.Length; i++)\n            {\n                buf[i] = encryptTable[buf[i]];\n            }\n        }\n        public void Decrypt(byte[] buf)\n        {\n            for (int i = 0; i < buf.Length; i++)\n            {
            {\n                buf[i] = encryptTable[buf[i]];\n            }\n        }\n        public void Decrypt(byte[] buf)\n        {\n            for (int i = 0; i < buf.Length; i++)\n            {\n                buf[i] = decryptTable[buf[i]];\n            }
        {\n            for (int i = 0; i < buf.Length; i++)\n            {\n                buf[i] = decryptTable[buf[i]];\n            }\n        }\n    }\n}
            {\n                buf[i] = decryptTable[buf[i]];\n            }\n        }\n    }\n}
using System.Net.NetworkInformation;\nusing System.Threading;\nnamespace Shadowsocks.Controller.Strategy\n{\n    class SimplyChooseByStatisticsStrategy : IStrategy\n    {\n        private ShadowsocksController _controller;\n        private Server _currentServer;\n        private Timer timer;
        private Server _currentServer;\n        private Timer timer;\n        private Dictionary<string, StatisticsData> statistics;\n        private static readonly int CachedInterval = 30 * 60 * 1000; //choose a new server every 30 minutes\n        public SimplyChooseByStatisticsStrategy(ShadowsocksController controller)\n        {\n            _controller = controller;\n            var servers = controller.GetCurrentConfiguration().configs;\n            int randomIndex = new Random().Next() % servers.Count();
        public SimplyChooseByStatisticsStrategy(ShadowsocksController controller)\n        {\n            _controller = controller;\n            var servers = controller.GetCurrentConfiguration().configs;\n            int randomIndex = new Random().Next() % servers.Count();\n            _currentServer = servers[randomIndex];  //choose a server randomly at first
            _currentServer = servers[randomIndex];  //choose a server randomly at first\n            List<Server> servers = _controller.GetCurrentConfiguration().configs;\n            LoadStatistics();\n            ChooseNewServer(servers);\n        }
            LoadStatistics();\n            ChooseNewServer(servers);\n        }\n        /*\n        return a dict:\n        {\n            'ServerFriendlyName1':StatisticsData,\n            'ServerFriendlyName2':...\n        }\n        */
                {  \n                    Console.WriteLine("Switch to server: {0} by package loss:{1}", bestResult.server.FriendlyName(), 1 - bestResult.score);\n                }\n                _currentServer = bestResult.server;\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n            }\n        }
                }\n                _currentServer = bestResult.server;\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n            }\n        }\n        public string ID\n        {
        {\n            get { return "com.shadowsocks.strategy.scbs"; }\n        }\n        public string Name\n        {\n            get { return I18N.GetString("Choose By Total Package Loss"); }
        }\n        public string Name\n        {\n            get { return I18N.GetString("Choose By Total Package Loss"); }\n        }\n        public Server GetAServer(IStrategyCallerType type, IPEndPoint localIPEndPoint)\n        {\n            var oldServer = _currentServer;
        public Server GetAServer(IStrategyCallerType type, IPEndPoint localIPEndPoint)\n        {\n            var oldServer = _currentServer;\n            if (oldServer == null)\n            {\n                ChooseNewServer(_controller.GetCurrentConfiguration().configs);\n            }\n            if (oldServer != _currentServer)\n            {\n            }
            return _currentServer;  //current server cached for CachedInterval\n        }\n        public void ReloadServers()\n        {\n            ChooseNewServer(_controller.GetCurrentConfiguration().configs);\n            Logging.Debug(String.Format("failure: {0}", server.FriendlyName()));
        }\n        public void UpdateLastRead(Server server)\n        {\n            //TODO: combine this part of data with ICMP statics\n        }\n        public void UpdateLastWrite(Server server)\n        {\n            //TODO: combine this part of data with ICMP statics\n        }\n        public void UpdateLatency(Server server, TimeSpan latency)
                _isFirstRun = false;
                MessageBox.Show(\n            string errorMsg = $"Exception Type: {e.Exception.GetType().Name}{Environment.NewLine}Stack Trace:{Environment.NewLine}{e.Exception.StackTrace}";\n            Logging.Error(errorMsg);
        }\n        private static void SystemEvents_PowerModeChanged(object sender, PowerModeChangedEventArgs e)\n        {\n            switch (e.Mode)\n            {\n                case PowerModes.Resume:\n                    Logging.Info("os wake up");\n                    if (_controller != null)\n                    {\n                        System.Timers.Timer timer = new System.Timers.Timer(10 * 1000);
        }\n        public static bool IsWinVistaOrHigher() {\n            return Environment.OSVersion.Version.Major > 5;\n        }\n        [DllImport("kernel32.dll")]\n        [return: MarshalAs(UnmanagedType.Bool)]\n        private static extern bool SetProcessWorkingSetSize(IntPtr process,\n            UIntPtr minimumWorkingSetSize, UIntPtr maximumWorkingSetSize);\n    }\n}
using Shadowsocks.Model;\nusing Shadowsocks.Util;\nnamespace Shadowsocks.Controller\n{\n    public static class SystemProxy\n    {\n        [DllImport("wininet.dll")]\n        public static extern bool InternetSetOption(IntPtr hInternet, int dwOption, IntPtr lpBuffer, int dwBufferLength);\n        public const int INTERNET_OPTION_SETTINGS_CHANGED = 39;\n        public const int INTERNET_OPTION_REFRESH = 37;
namespace Shadowsocks.Controller\n{\n    public static class SystemProxy\n    {\n        [DllImport("wininet.dll")]\n        public static extern bool InternetSetOption(IntPtr hInternet, int dwOption, IntPtr lpBuffer, int dwBufferLength);\n        public const int INTERNET_OPTION_SETTINGS_CHANGED = 39;\n        public const int INTERNET_OPTION_REFRESH = 37;\n        static bool _settingsReturn, _refreshReturn;\n        public static void NotifyIE()
        private static string GetTimestamp(DateTime value)\n        {\n            return value.ToString("yyyyMMddHHmmssfff");\n        }\n        public static void Update(Configuration config, bool forceDisable)\n        {\n            bool global = config.global;\n            bool enabled = config.enabled;\n            if (forceDisable)\n            {
                }\n                if ( enabled ) {\n                    if ( global ) {\n                        registry.SetValue( "ProxyEnable", 1 );\n                        registry.SetValue( "ProxyServer", "127.0.0.1:" + config.localPort.ToString() );\n                        registry.SetValue( "AutoConfigURL", "" );\n                    } else {\n                        string pacUrl;\n                        if ( config.useOnlinePac && ! config.pacUrl.IsNullOrEmpty() )\n                            pacUrl = config.pacUrl;
                }\n            }\n        }\n        private static void CopyProxySettingFromLan()\n        {\n            RegistryKey registry = null;\n            try {\n                registry = Utils.OpenUserRegKey( @"Software\Microsoft\Windows\CurrentVersion\Internet Settings\Connections", true );\n                if ( registry == null ) {\n                    Logging.Error( @"Cannot find HKCU\Software\Microsoft\Windows\CurrentVersion\Internet Settings\Connections" );
            }\n        }\n    }\n}
            var defaultValue = registry.GetValue("DefaultConnectionSettings");\n            try\n            {\n                var connections = registry.GetValueNames();\n                foreach (String each in connections)\n                {\n                    if (!(each.Equals("DefaultConnectionSettings")\n                        || each.Equals("LAN Connection")\n                        || each.Equals("SavedLegacySettings")))\n                    {
                {\n                    if (!(each.Equals("DefaultConnectionSettings")\n                        || each.Equals("LAN Connection")\n                        || each.Equals("SavedLegacySettings")))\n                    {\n                        //set all the connections's proxy as the lan\n                        registry.SetValue(each, defaultValue);\n                    }\n                }\n                SystemProxy.NotifyIE();\n            } catch (IOException e) {
                Logging.LogUsefulException(e);\n            }\n        }\n        private static String GetTimestamp(DateTime value)\n        {\n            return value.ToString("yyyyMMddHHmmssffff");\n        }\n        /// <summary>\n        /// Checks or unchecks the IE Options Connection setting of "Automatically detect Proxy"\n        /// </summary>\n            RegistryKey registry =
        }\n        /// <summary>\n        /// Checks or unchecks the IE Options Connection setting of "Automatically detect Proxy"\n        /// </summary>\n        /// <param name="set">Provide 'true' if you want to check the 'Automatically detect Proxy' check box. To uncheck, pass 'false'</param>\n        private static void IEAutoDetectProxy(bool set)\n        {\n            RegistryKey registry =\n                Registry.CurrentUser.OpenSubKey("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Connections",\n                    true);\n            byte[] defConnection = (byte[])registry.GetValue("DefaultConnectionSettings");\n            byte[] savedLegacySetting = (byte[])registry.GetValue("SavedLegacySettings");
            if (set)\n            {\n                defConnection[8] = Convert.ToByte(defConnection[8] & 8);\n                savedLegacySetting[8] = Convert.ToByte(savedLegacySetting[8] & 8);\n            }\n            else\n            {\n                defConnection[8] = Convert.ToByte(defConnection[8] & ~8);\n                savedLegacySetting[8] = Convert.ToByte(savedLegacySetting[8] & ~8);\n            }
            }\n            else\n            {\n                defConnection[8] = Convert.ToByte(defConnection[8] & ~8);\n                savedLegacySetting[8] = Convert.ToByte(savedLegacySetting[8] & ~8);\n            }\n            registry.SetValue("DefaultConnectionSettings", defConnection);\n            registry.SetValue("SavedLegacySettings", savedLegacySetting);
            }\n            registry.SetValue("DefaultConnectionSettings", defConnection);\n            registry.SetValue("SavedLegacySettings", savedLegacySetting);\n        }\n    }\n}
                return true;\n            }\n            catch (Exception _Exception)\n            {\n                Console.WriteLine("Exception caught in process: {0}",\n                                  _Exception.ToString());\n            }\n            return false;\n        }\n        public static void UncompressFile(string fileName, byte[] content)
            {\n                Console.WriteLine("Exception caught in process: {0}",\n                                  _Exception.ToString());\n            }\n            return false;\n        }\n        public static void UncompressFile(string fileName, byte[] content)\n        {\n            FileStream destinationFile = File.Create(fileName);\n            // Because the uncompressed size of the file is unknown,
            }\n            return false;\n        }\n        public static void UncompressFile(string fileName, byte[] content)\n        {\n            FileStream destinationFile = File.Create(fileName);\n            // Because the uncompressed size of the file is unknown,\n            // we are using an arbitrary buffer size.\n            byte[] buffer = new byte[4096];\n            int n;\n            using (GZipStream input = new GZipStream(new MemoryStream(content),
            // Because the uncompressed size of the file is unknown,\n            // we are using an arbitrary buffer size.\n            byte[] buffer = new byte[4096];\n            int n;\n            using (GZipStream input = new GZipStream(new MemoryStream(content),\n                CompressionMode.Decompress, false))\n            {\n                while ((n = input.Read(buffer, 0, buffer.Length)) > 0)\n                {
                CompressionMode.Decompress, false))\n            {\n                while ((n = input.Read(buffer, 0, buffer.Length)) > 0)\n                {\n                    destinationFile.Write(buffer, 0, n);\n                }\n            }\n            destinationFile.Close();\n        }\n    }
                }\n            }\n            destinationFile.Close();\n        }\n    }\n}
        }\n    }\n}
            this.tableLayoutPanel1.SuspendLayout();\n            this.panel1.SuspendLayout();\n            this.tableLayoutPanel2.SuspendLayout();\n            this.tableLayoutPanel3.SuspendLayout();\n            this.SuspendLayout();\n            // \n            // tableLayoutPanel1\n            // \n            this.tableLayoutPanel1.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) \n            | System.Windows.Forms.AnchorStyles.Right)));\n            this.tableLayoutPanel1.AutoSize = true;\n            this.tableLayoutPanel1.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;\n            this.tableLayoutPanel1.ColumnCount = 2;
            this.SuspendLayout();\n            // \n            // tableLayoutPanel1\n            // \n            this.tableLayoutPanel1.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) \n            | System.Windows.Forms.AnchorStyles.Right)));\n            this.tableLayoutPanel1.AutoSize = true;\n            this.tableLayoutPanel1.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;\n            this.tableLayoutPanel1.ColumnCount = 2;\n            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());\n            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());\n            this.tableLayoutPanel1.Controls.Add(this.label5, 0, 4);\n            this.tableLayoutPanel1.Controls.Add(this.label1, 0, 0);
            this.tableLayoutPanel1.AutoSize = true;\n            this.tableLayoutPanel1.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;\n            this.tableLayoutPanel1.ColumnCount = 2;\n            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());\n            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());\n            this.tableLayoutPanel1.Controls.Add(this.label5, 0, 4);\n            this.tableLayoutPanel1.Controls.Add(this.label1, 0, 0);\n            this.tableLayoutPanel1.Controls.Add(this.label2, 0, 1);\n            this.tableLayoutPanel1.Controls.Add(this.EncryptionSelect, 1, 4);
            this.tableLayoutPanel1.Controls.Add(this.label1, 0, 0);\n            this.tableLayoutPanel1.Controls.Add(this.label2, 0, 1);\n            this.tableLayoutPanel1.Controls.Add(this.EncryptionSelect, 1, 4);\n            this.tableLayoutPanel1.Controls.Add(this.label3, 0, 2);\n            this.tableLayoutPanel1.Controls.Add(this.label4, 0, 3);\n            this.tableLayoutPanel1.Controls.Add(this.IPTextBox, 1, 0);\n            this.tableLayoutPanel1.Controls.Add(this.ServerPortTextBox, 1, 1);\n            this.tableLayoutPanel1.Controls.Add(this.PasswordTextBox, 1, 2);
            this.tableLayoutPanel1.Controls.Add(this.label3, 0, 2);\n            this.tableLayoutPanel1.Controls.Add(this.label4, 0, 3);\n            this.tableLayoutPanel1.Controls.Add(this.IPTextBox, 1, 0);\n            this.tableLayoutPanel1.Controls.Add(this.ServerPortTextBox, 1, 1);\n            this.tableLayoutPanel1.Controls.Add(this.PasswordTextBox, 1, 2);\n            this.tableLayoutPanel1.Controls.Add(this.ProxyPortTextBox, 1, 3);\n            this.tableLayoutPanel1.Location = new System.Drawing.Point(246, 10);\n            this.tableLayoutPanel1.Margin = new System.Windows.Forms.Padding(10);\n            this.tableLayoutPanel1.Name = "tableLayoutPanel1";
            this.tableLayoutPanel1.Controls.Add(this.IPTextBox, 1, 0);\n            this.tableLayoutPanel1.Controls.Add(this.ServerPortTextBox, 1, 1);\n            this.tableLayoutPanel1.Controls.Add(this.PasswordTextBox, 1, 2);\n            this.tableLayoutPanel1.Controls.Add(this.ProxyPortTextBox, 1, 3);\n            this.tableLayoutPanel1.Location = new System.Drawing.Point(246, 10);\n            this.tableLayoutPanel1.Margin = new System.Windows.Forms.Padding(10);\n            this.tableLayoutPanel1.Name = "tableLayoutPanel1";\n            this.tableLayoutPanel1.Padding = new System.Windows.Forms.Padding(5);\n            this.tableLayoutPanel1.RowCount = 5;
            this.tableLayoutPanel1.Name = "tableLayoutPanel1";\n            this.tableLayoutPanel1.Padding = new System.Windows.Forms.Padding(5);\n            this.tableLayoutPanel1.RowCount = 5;\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.panel1.AutoSize = true;\n            this.panel1.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;\n            this.panel1.Controls.Add(this.MyCancelButton);\n            this.panel1.Controls.Add(this.OKButton);\n            this.panel1.Location = new System.Drawing.Point(311, 205);\n            this.panel1.Name = "panel1";
            this.panel1.Name = "panel1";
            this.SuspendLayout();\n            // \n            // StatisticsChart\n            // \n            this.StatisticsChart.BackColor = System.Drawing.Color.Transparent;
            this.splitContainer2.TabIndex = 7;\n            // 
            this.numericUpDown1.Maximum = new decimal(new int[] {\n            10,\n            0,\n            0,\n            0});\n            this.numericUpDown1.Name = "numericUpDown1";
using System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.IO.Compression;\nusing System.Text;\nusing System.Net.NetworkInformation;\nusing System.Net;
using System.Text;\nusing System.Net.NetworkInformation;\nusing System.Net;\nusing System.Runtime.InteropServices;\nusing Shadowsocks.Util;\nnamespace Shadowsocks.Controller\n{\n    class PolipoRunner
using Shadowsocks.Util;\nnamespace Shadowsocks.Controller\n{\n    class PolipoRunner\n    {\n        private Process _process;\n        private static string temppath;\n        private int _runningPort;\n        static PolipoRunner()\n        {
        private int _runningPort;\n        static PolipoRunner()\n        {\n            temppath = Utils.GetTempPath();\n            try\n            {\n                FileManager.UncompressFile(temppath + "/ss_privoxy.exe", Resources.privoxy_exe);\n                FileManager.UncompressFile(temppath + "/mgwz.dll", Resources.mgwz_dll);\n            }\n            catch (IOException e)
            try\n            {\n                FileManager.UncompressFile(temppath + "/ss_privoxy.exe", Resources.privoxy_exe);\n                FileManager.UncompressFile(temppath + "/mgwz.dll", Resources.mgwz_dll);\n            }\n            catch (IOException e)\n            {\n                Logging.LogUsefulException(e);\n            }\n        }
            }\n            catch (IOException e)\n            {\n                Logging.LogUsefulException(e);\n            }\n        }\n        public int RunningPort\n        {\n            get\n            {
                _process = new Process();\n                // Configure the process using the StartInfo properties.\n                _process.StartInfo.FileName = temppath + "ss_privoxy.exe";\n                _process.StartInfo.Arguments = " \"" + temppath + "privoxy.conf\"";\n                _process.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;\n                _process.StartInfo.UseShellExecute = true;\n                _process.StartInfo.CreateNoWindow = true;
                _process.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;\n                _process.StartInfo.UseShellExecute = true;\n                _process.StartInfo.CreateNoWindow = true;
using Shadowsocks.Properties;\nusing Shadowsocks.Util;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Runtime.InteropServices;\nusing System.Text;\nnamespace Shadowsocks.Encryption\n{\n    public class PolarSSL
namespace Shadowsocks.Encryption\n{\n    public class PolarSSL\n    {\n        const string DLLNAME = "libsscrypto";\n        public const int AES_CTX_SIZE = 8 + 4 * 68;\n        public const int AES_ENCRYPT = 1;\n        public const int AES_DECRYPT = 0;\n        static PolarSSL()\n        {
using System.Diagnostics;\nusing System.IO;\nusing System.Threading;\nusing System.Windows.Forms;\nnamespace Shadowsocks\n{\n    static class Program
            using (Mutex mutex = new Mutex(false, "Global\\Shadowsocks_" + Application.StartupPath.GetHashCode()))\n            {\n                Application.EnableVisualStyles();\n                Application.SetCompatibleTextRenderingDefault(false);\n                if (!mutex.WaitOne(0, false))\n                {\n                    Process[] oldProcesses = Process.GetProcessesByName("Shadowsocks");\n                    if (oldProcesses.Length > 0)\n                    {\n                        Process oldProcess = oldProcesses[0];
using Shadowsocks.Properties;\nusing Shadowsocks.Util;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Runtime.InteropServices;\nusing System.Text;\nnamespace Shadowsocks.Encryption\n{\n    public class Sodium
namespace Shadowsocks.Encryption\n{\n    public class Sodium\n    {\n        const string DLLNAME = "libsscrypto";\n        static Sodium()\n        {\n            string tempPath = Utils.GetTempPath();\n            string dllPath = tempPath + "/libsscrypto.dll";
            try\n            {\n                FileManager.UncompressFile(dllPath, Resources.libsscrypto_dll);\n            }\n            catch (IOException)\n            {\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);
using Shadowsocks.Properties;\nusing Shadowsocks.Util;\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Runtime.InteropServices;\nusing System.Text;\nnamespace Shadowsocks.Encryption\n{\n    public class MbedTLS
namespace Shadowsocks.Encryption\n{\n    public class MbedTLS\n    {\n        const string DLLNAME = "libsscrypto";\n        static MbedTLS()\n        {\n            string tempPath = Utils.GetTempPath();\n            string dllPath = tempPath + "/libsscrypto.dll";
            try\n            {\n                FileManager.UncompressFile(dllPath, Resources.libsscrypto_dll);\n            }\n            catch (IOException ex)\n            {\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine(e.ToString());
using System.IO;\nusing System.Net.Sockets;\nusing System.Text;\nnamespace Shadowsocks.Controller\n{\n    public class Logging\n    {\n        public static string LogFile;
namespace Shadowsocks.Controller\n{\n    public class Logging\n    {\n        public static string LogFile;\n        public static bool OpenLogFile()\n        {\n            try\n            {\n                string temppath = Utils.GetTempPath();
                FileStream fs = new FileStream(LogFile, FileMode.Append);\n                StreamWriterWithTimestamp sw = new StreamWriterWithTimestamp(fs);\n                sw.AutoFlush = true;\n                Console.SetOut(sw);\n                Console.SetError(sw);\n                return true;\n            }\n            catch (IOException e)\n            {\n                Console.WriteLine(e.ToString());
            {\n                UpdatePACFromGFWList();\n                return;\n            }\n            List<string> lines = GFWListUpdater.ParseResult(File.ReadAllText(Utils.GetTempPath() + "\\gfwlist.txt"));\n            if (File.Exists(PACServer.USER_RULE_FILE))\n            {\n                string local = File.ReadAllText(PACServer.USER_RULE_FILE, Encoding.UTF8);\n                string[] rules = local.Split(new char[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);\n                foreach (string rule in rules)
            if (File.Exists(PACServer.USER_RULE_FILE))\n            {\n                string local = File.ReadAllText(PACServer.USER_RULE_FILE, Encoding.UTF8);\n                string[] rules = local.Split(new char[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);\n                foreach (string rule in rules)\n                {\n                    if (rule.StartsWith("!") || rule.StartsWith("["))\n                        continue;\n                    lines.Add(rule);\n                }
using Shadowsocks.Properties;\nusing SimpleJson;\nusing Shadowsocks.Util;\nusing Shadowsocks.Model;\nnamespace Shadowsocks.Controller\n{\n    public class GFWListUpdater\n    {\n        private const string GFWLIST_URL = "https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt";\n        private static string PAC_FILE = PACServer.PAC_FILE;
using Shadowsocks.Util;\nusing Shadowsocks.Model;\nnamespace Shadowsocks.Controller\n{\n    public class GFWListUpdater\n    {\n        private const string GFWLIST_URL = "https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt";\n        private static string PAC_FILE = PACServer.PAC_FILE;\n        private static string USER_RULE_FILE = PACServer.USER_RULE_FILE;\n        private static string USER_ABP_FILE = PACServer.USER_ABP_FILE;
namespace Shadowsocks.Controller\n{\n    public class GFWListUpdater\n    {\n        private const string GFWLIST_URL = "https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt";\n        private static string PAC_FILE = PACServer.PAC_FILE;\n        private static string USER_RULE_FILE = PACServer.USER_RULE_FILE;\n        private static string USER_ABP_FILE = PACServer.USER_ABP_FILE;\n        public event EventHandler<ResultEventArgs> UpdateCompleted;\n        public event ErrorEventHandler Error;
using System.Collections.Generic;\nusing System.Net;\nusing System.Reflection;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.IO;\nusing SimpleJson;\nusing Shadowsocks.Model;\nusing Shadowsocks.Util;\nnamespace Shadowsocks.Controller
using System.Text.RegularExpressions;\nusing System.IO;\nusing SimpleJson;\nusing Shadowsocks.Model;\nusing Shadowsocks.Util;\nnamespace Shadowsocks.Controller\n{\n    public class UpdateChecker\n    {\n        private const string UpdateURL = "https://api.github.com/repos/shadowsocks/shadowsocks-windows/releases";
using SimpleJson;\nusing Shadowsocks.Model;\nusing Shadowsocks.Util;\nnamespace Shadowsocks.Controller\n{\n    public class UpdateChecker\n    {\n        private const string UpdateURL = "https://api.github.com/repos/shadowsocks/shadowsocks-windows/releases";\n        private const string UserAgent = "Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.3319.102 Safari/537.36";\n        private Configuration config;
            {\n                try\n                {\n                    Directory.CreateDirectory(Application.StartupPath + "\\temp");\n                }\n                catch (Exception e)\n                {\n                    Logging.LogUsefulException(e);\n                }\n                // don't use "/", it will fail when we call explorer /select xxx/temp\xxx.log
            }\n            return Path.GetTempPath();\n        }\n        public static void ReleaseMemory(bool removePages)\n        {
        }\n        public static void ReleaseMemory(bool removePages)\n        {\n            // release any unused pages\n            // making the numbers look good in task manager\n            // this is totally nonsense in programming\n            // but good for those users who care\n            // making them happier with their everyday life\n            // which is part of user experience\n            GC.Collect(GC.MaxGeneration);
                traffic.Enqueue(current);\n                if (traffic.Count > queueMaxSize)\n                    traffic.Dequeue();\n                if (TrafficChanged != null)\n                {\n                    TrafficChanged(this, new EventArgs());\n                }\n                Thread.Sleep(1000);\n            }
                Thread.Sleep(1000);\n            }\n        }\n    }\n}
                var remote = session.Remote;\n                if (bytesRead > 0)\n                {\n                    /*\n                     * Only the first packet contains the socks5 header, it doesn't make sense to parse every packets. \n                     * Also it's unnecessary to parse these data if we turn off the VerboseLogging.\n                     */\n                    if (session.State && _config.isVerboseLogging)\n                    {\n                        int atyp = _connetionRecvBuffer[0];
                }\n                else\n                {\n                    remote.Shutdown(SocketShutdown.Send);\n                    _remoteShutdown = true;\n                    CheckClose();\n                }\n            }\n            catch (Exception e)\n            {
        {\n            IStrategy strategy = GetCurrentStrategy();\n            if (strategy != null)\n            {\n                return strategy.GetAServer(type, localIPEndPoint);\n            }\n            if (_config.index < 0)\n            {\n                _config.index = 0;\n            }
            }\n            if (_config.index < 0)\n            {\n                _config.index = 0;\n            }\n            return GetCurrentServer();\n        }\n        public void SaveServers(List<Server> servers, int localPort)\n        {\n            _config.configs = servers;
                {\n                    /*\n                     * Sometimes Process.GetProcessesByName will return some processes that\n                     * are already dead, and that will cause exceptions here.\n                     * We could simply ignore those exceptions.\n                     */\n                    string path = process.MainModule.FileName;\n                    return Utils.GetTempPath("ss_privoxy.exe").Equals(path);\n                }\n                catch (Exception ex)
                     */\n                    string path = process.MainModule.FileName;\n                    return Utils.GetTempPath("ss_privoxy.exe").Equals(path);\n                }\n                catch (Exception ex)\n                {\n                    Logging.LogUsefulException(ex);\n                    return false;\n                }\n            }
                    return Utils.GetTempPath("ss_privoxy.exe").Equals(path);\n                }\n                catch (Exception ex)\n                {\n                    Logging.LogUsefulException(ex);\n                    return false;\n                }\n            }\n            else\n            {
                {\n                    var cmd = process.GetCommandLine();\n                    return cmd.Contains(UniqueConfigFile);\n                }\n                catch (Win32Exception ex)\n                {\n                    if ((uint) ex.ErrorCode != 0x80004005)\n                    {\n                        throw;\n                    }
                return false;\n            }\n        }\n        private int GetFreePort()\n        {\n            int defaultPort = 8123;\n            try\n            {\n                IPGlobalProperties properties = IPGlobalProperties.GetIPGlobalProperties();\n                IPEndPoint[] tcpEndPoints = properties.GetActiveTcpListeners();
                    if (isCipher)\n                    {\n                        _encryptIVOffset = ivOffset;\n                    }\n                    else\n                    {\n                        _decryptIVOffset = ivOffset;\n                    }\n                    break;\n                case CIPHER_RC4:
        {\n            // run it once before the multi-threading test to initialize global tables\n            RunSingleEncryptionThread();\n            List<Thread> threads = new List<Thread>();\n            for (int i = 0; i < 10; i++)\n            {\n                Thread t = new Thread(new ThreadStart(RunSingleEncryptionThread));\n                threads.Add(t);\n                t.Start();\n            }\n            foreach (Thread t in threads)
                threads.Add(t);\n                t.Start();\n            }\n            foreach (Thread t in threads)\n            {\n                t.Join();\n            }\n            Assert.IsFalse(encryptionFailed);\n        }\n        private static bool encryptionFailed = false;
        {\n            try\n            {\n                if (_lastSelectedIndex == -1 || _lastSelectedIndex >= _modifiedConfiguration.configs.Count)\n                {\n                    return true;\n                }\n                Server server = new Server();\n                if (Uri.CheckHostName(server.server = IPTextBox.Text.Trim()) == UriHostNameType.Unknown)\n                {
                Configuration.CheckServer(server);\n                Configuration.CheckLocalPort(localPort);\n                _modifiedConfiguration.configs[_lastSelectedIndex] = server;\n                _modifiedConfiguration.localPort = localPort;\n                _modifiedConfiguration.portableMode = PortableModeCheckBox.Checked;\n                return true;\n            }\n            catch (Exception ex)\n            {\n                MessageBox.Show(ex.Message);
                _modifiedConfiguration.configs[_lastSelectedIndex] = server;\n                _modifiedConfiguration.localPort = localPort;\n                _modifiedConfiguration.portableMode = PortableModeCheckBox.Checked;\n                return true;\n            }\n            catch (Exception ex)\n            {\n                MessageBox.Show(ex.Message);\n            }\n            return false;
                return true;\n            }\n            catch (Exception ex)\n            {\n                MessageBox.Show(ex.Message);\n            }\n            return false;\n        }\n        private void LoadSelectedServer()
        {\n            if (ServersListBox.SelectedIndex >= 0 && ServersListBox.SelectedIndex < _modifiedConfiguration.configs.Count)\n            {\n                Server server = _modifiedConfiguration.configs[ServersListBox.SelectedIndex];\n                IPTextBox.Text = server.server;\n                ServerPortTextBox.Text = server.server_port.ToString();\n                PasswordTextBox.Text = server.password;\n                ProxyPortTextBox.Text = _modifiedConfiguration.localPort.ToString();\n                EncryptionSelect.Text = server.method ?? "aes-256-cfb";\n                PluginTextBox.Text = server.plugin;
        {\n            ServersListBox.Items.Clear();\n            foreach (Server server in _modifiedConfiguration.configs)\n            {\n                ServersListBox.Items.Add(server.FriendlyName());\n            }\n        }\n        private void LoadCurrentConfiguration()\n        {\n            _modifiedConfiguration = controller.GetConfigurationCopy();
            {\n                ServersListBox.Items.Add(server.FriendlyName());\n            }\n        }\n        private void LoadCurrentConfiguration()\n        {\n            _modifiedConfiguration = controller.GetConfigurationCopy();\n            LoadConfiguration(_modifiedConfiguration);\n            _lastSelectedIndex = _modifiedConfiguration.index;\n            if (_lastSelectedIndex < 0 || _lastSelectedIndex >= ServersListBox.Items.Count)
            _lastSelectedIndex = _modifiedConfiguration.index;\n            if (_lastSelectedIndex < 0 || _lastSelectedIndex >= ServersListBox.Items.Count)\n            {\n                _lastSelectedIndex = 0;\n            }\n            ServersListBox.SelectedIndex = _lastSelectedIndex;\n            UpdateMoveUpAndDownButton();\n            LoadSelectedServer();
            PortableModeCheckBox.Checked = _modifiedConfiguration.portableMode;\n        }\n        private void ConfigForm_Load(object sender, EventArgs e)\n        {\n        }\n        private void ConfigForm_KeyDown(object sender, KeyEventArgs e)\n        {\n            // Sometimes the users may hit enter key by mistake, and the form will close without saving entries.\n            if (e.KeyCode == Keys.Enter)\n            {
        }\n        private void ConfigForm_KeyDown(object sender, KeyEventArgs e)\n        {\n            // Sometimes the users may hit enter key by mistake, and the form will close without saving entries.\n            if (e.KeyCode == Keys.Enter)\n            {\n                Server server = controller.GetCurrentServer();\n                if (!SaveOldSelectedServer())\n                {\n                    return;\n                }
                {\n                    return;\n                }\n                if (_modifiedConfiguration.configs.Count == 0)\n                {\n                    MessageBox.Show(I18N.GetString("Please add at least one server"));\n                    return;\n                }
            {\n                // why this won't cause stack overflow?\n                ServersListBox.SelectedIndex = _lastSelectedIndex;\n                return;\n            }\n            if (_lastSelectedIndex >= 0)\n            {\n                ServersListBox.Items[_lastSelectedIndex] = _modifiedConfiguration.configs[_lastSelectedIndex].FriendlyName();\n            }\n            UpdateMoveUpAndDownButton();\n            LoadSelectedServer();
            _lastSelectedIndex = ServersListBox.SelectedIndex;\n        }\n        private void AddButton_Click(object sender, EventArgs e)\n        {\n            if (!SaveOldSelectedServer())\n            {\n                return;\n            }\n            Server server = Configuration.GetDefaultServer();\n            _modifiedConfiguration.configs.Add(server);
            {\n                return;\n            }\n            Server server = Configuration.GetDefaultServer();\n            _modifiedConfiguration.configs.Add(server);\n            LoadConfiguration(_modifiedConfiguration);\n            ServersListBox.SelectedIndex = _modifiedConfiguration.configs.Count - 1;\n            _lastSelectedIndex = ServersListBox.SelectedIndex;\n        }\n        private void DuplicateButton_Click(object sender, EventArgs e)
            ServersListBox.SelectedIndex = _modifiedConfiguration.configs.Count - 1;\n            _lastSelectedIndex = ServersListBox.SelectedIndex;\n        }\n        private void DuplicateButton_Click(object sender, EventArgs e)\n        {\n            if (!SaveOldSelectedServer())\n            {\n                return;\n            }\n            Server currServer = _modifiedConfiguration.configs[_lastSelectedIndex];
            {\n                return;\n            }\n            Server currServer = _modifiedConfiguration.configs[_lastSelectedIndex];\n            var currIndex = _modifiedConfiguration.configs.IndexOf(currServer);\n            _modifiedConfiguration.configs.Insert(currIndex + 1, currServer);\n            LoadConfiguration(_modifiedConfiguration);\n            ServersListBox.SelectedIndex = currIndex + 1;\n            _lastSelectedIndex = ServersListBox.SelectedIndex;\n        }
            ServersListBox.SelectedIndex = currIndex + 1;\n            _lastSelectedIndex = ServersListBox.SelectedIndex;\n        }\n        private void DeleteButton_Click(object sender, EventArgs e)\n        {\n            _lastSelectedIndex = ServersListBox.SelectedIndex;\n            if (_lastSelectedIndex >= 0 && _lastSelectedIndex < _modifiedConfiguration.configs.Count)\n            {\n                _modifiedConfiguration.configs.RemoveAt(_lastSelectedIndex);\n            }
            ServersListBox.SelectedIndex = _lastSelectedIndex;\n            LoadSelectedServer();\n        }\n        private void OKButton_Click(object sender, EventArgs e)\n        {\n            if (!SaveOldSelectedServer())\n            {\n                return;\n            }\n            if (_modifiedConfiguration.configs.Count == 0)
        }\n        private void OKButton_Click(object sender, EventArgs e)\n        {\n            if (!SaveOldSelectedServer())\n            {\n                return;\n            }\n            if (_modifiedConfiguration.configs.Count == 0)\n            {\n                MessageBox.Show(I18N.GetString("Please add at least one server"));
            {\n                return;\n            }\n            if (_modifiedConfiguration.configs.Count == 0)\n            {\n                MessageBox.Show(I18N.GetString("Please add at least one server"));\n                return;\n            }
        }\n        private void MoveUpButton_Click(object sender, EventArgs e)\n        {\n            if (!SaveOldSelectedServer())\n            {\n                return;\n            }\n            if (ServersListBox.SelectedIndex > 0)\n            {\n                MoveConfigItem(-1);  // -1 means move backward
            {\n                return;\n            }\n            if (ServersListBox.SelectedIndex > 0)\n            {\n                MoveConfigItem(-1);  // -1 means move backward\n            }\n        }\n        private void MoveDownButton_Click(object sender, EventArgs e)\n        {
    {\n        const int CIPHER_AES = 1;\n        const int CIPHER_RC4 = 2;\n        static Dictionary<string, int[]> ciphers = new Dictionary<string, int[]> {\n            {"aes-128-cfb", new int[]{16, 16, CIPHER_AES, PolarSSL.AES_CTX_SIZE}},\n            {"aes-192-cfb", new int[]{24, 16, CIPHER_AES, PolarSSL.AES_CTX_SIZE}},\n            {"aes-256-cfb", new int[]{32, 16, CIPHER_AES, PolarSSL.AES_CTX_SIZE}},\n            {"rc4", new int[]{16, 0, CIPHER_RC4, PolarSSL.ARC4_CTX_SIZE}},\n            {"rc4-md5", new int[]{16, 16, CIPHER_RC4, PolarSSL.ARC4_CTX_SIZE}},\n        };
        private IntPtr _encryptCtx = IntPtr.Zero;\n        private IntPtr _decryptCtx = IntPtr.Zero;\n        private byte[] _encryptIV;\n        private byte[] _decryptIV;\n        private int _encryptIVOffset = 0;\n        private int _decryptIVOffset = 0;\n        private string _method;\n        private int keyLen;\n        private int ivLen;\n        public PolarSSLEncryptor(string method, string password)
        public PolarSSLEncryptor(string method, string password)\n            : base(method, password)\n        {\n            InitKey(method, password);\n        }\n        private static void randBytes(byte[] buf, int length)\n        {\n            byte[] temp = new byte[length];\n            new Random().NextBytes(temp);\n            temp.CopyTo(buf, 0);
        {\n            byte[] temp = new byte[length];\n            new Random().NextBytes(temp);\n            temp.CopyTo(buf, 0);
        }\n        private void bytesToKey(byte[] password, byte[] key)\n        {\n            byte[] result = new byte[password.Length + 16];\n            int i = 0;\n            byte[] md5sum = null;\n            while (i < key.Length)\n            {\n                MD5 md5 = MD5.Create();\n                if (i == 0)
        {\n            byte[] result = new byte[password.Length + 16];\n            int i = 0;\n            byte[] md5sum = null;\n            while (i < key.Length)\n            {\n                MD5 md5 = MD5.Create();\n                if (i == 0)\n                {\n                    md5sum = md5.ComputeHash(password);
            {\n                MD5 md5 = MD5.Create();\n                if (i == 0)\n                {\n                    md5sum = md5.ComputeHash(password);\n                }\n                else\n                {\n                    md5sum.CopyTo(result, 0);\n                    password.CopyTo(result, md5sum.Length);
            }\n            else\n            {\n                byte[] passbuf = Encoding.UTF8.GetBytes(password);\n                _key = new byte[32];\n                byte[] iv = new byte[16];\n                bytesToKey(passbuf, _key);\n                CachedKeys[k] = _key;\n            }
            }\n        }\n        private void InitCipher(ref IntPtr ctx, byte[] iv, bool isCipher)\n        {\n            ctx = Marshal.AllocHGlobal(_cipherInfo[3]);\n            byte[] realkey;\n            if (_method == "rc4-md5")\n            {\n                byte[] temp = new byte[keyLen + ivLen];\n                realkey = new byte[keyLen];
            byte[] realkey;\n            if (_method == "rc4-md5")\n            {\n                byte[] temp = new byte[keyLen + ivLen];\n                realkey = new byte[keyLen];\n                Array.Copy(_key, 0, temp, 0, keyLen);\n                Array.Copy(iv, 0, temp, keyLen, ivLen);\n                realkey = MD5.Create().ComputeHash(temp);\n            }\n            else
            }\n            else if (_cipher == CIPHER_RC4)\n            {\n                PolarSSL.arc4_init(ctx);\n                // PolarSSL RC4 takes key length by byte\n                PolarSSL.arc4_setup(ctx, realkey, keyLen);\n            }\n        }\n        static byte[] tempbuf = new byte[32768];\n        public override void Encrypt(byte[] buf, int length, byte[] outbuf, out int outlength)
        {\n            if (_encryptCtx == IntPtr.Zero)\n            {\n                randBytes(outbuf, ivLen);\n                InitCipher(ref _encryptCtx, outbuf, true);\n                outlength = length + ivLen;\n                lock (tempbuf)\n                {\n                    // C# could be multi-threaded
            {\n                randBytes(outbuf, ivLen);\n                InitCipher(ref _encryptCtx, outbuf, true);\n                outlength = length + ivLen;\n                lock (tempbuf)\n                {\n                    // C# could be multi-threaded\n                    if (_disposed)\n                    {\n                        throw new ObjectDisposedException(this.ToString());
            }\n            else\n            {\n                outlength = length;\n                if (_disposed)\n                {\n                    throw new ObjectDisposedException(this.ToString());\n                }\n                switch (_cipher)\n                {
            }\n        }\n        public override void Decrypt(byte[] buf, int length, byte[] outbuf, out int outlength)\n        {\n            if (_decryptCtx == IntPtr.Zero)\n            {\n                InitCipher(ref _decryptCtx, buf, false);\n                outlength = length - ivLen;\n                lock (tempbuf)
            {\n                InitCipher(ref _decryptCtx, buf, false);\n                outlength = length - ivLen;\n                lock (tempbuf)\n                {\n                    // C# could be multi-threaded\n                    Buffer.BlockCopy(buf, ivLen, tempbuf, 0, length - ivLen);\n                    if (_disposed)
                    {\n                        throw new ObjectDisposedException(this.ToString());\n                    }\n                    switch (_cipher)\n                    {\n                        case CIPHER_AES:\n                            PolarSSL.aes_crypt_cfb128(_decryptCtx, PolarSSL.AES_DECRYPT, length - ivLen, ref _decryptIVOffset, _decryptIV, tempbuf, outbuf);\n                            break;\n                        case CIPHER_RC4:\n                            PolarSSL.arc4_crypt(_decryptCtx, length - ivLen, tempbuf, outbuf);
                    }\n                    switch (_cipher)\n                    {\n                        case CIPHER_AES:\n                            PolarSSL.aes_crypt_cfb128(_decryptCtx, PolarSSL.AES_DECRYPT, length - ivLen, ref _decryptIVOffset, _decryptIV, tempbuf, outbuf);\n                            break;\n                        case CIPHER_RC4:\n                            PolarSSL.arc4_crypt(_decryptCtx, length - ivLen, tempbuf, outbuf);\n                            break;
                    {\n                        case CIPHER_AES:\n                            PolarSSL.aes_crypt_cfb128(_decryptCtx, PolarSSL.AES_DECRYPT, length - ivLen, ref _decryptIVOffset, _decryptIV, tempbuf, outbuf);\n                            break;\n                        case CIPHER_RC4:\n                            PolarSSL.arc4_crypt(_decryptCtx, length - ivLen, tempbuf, outbuf);\n                            break;\n                    }\n                }
                    }\n                }\n            }\n            else\n            {\n                outlength = length;\n                if (_disposed)\n                {\n                    throw new ObjectDisposedException(this.ToString());\n                }
            }\n        }\n        #region IDisposable\n        private bool _disposed;\n        public override void Dispose()\n        {\n            Dispose(true);\n            GC.SuppressFinalize(this);\n        }\n        ~PolarSSLEncryptor()
                FileManager.UncompressFile(dllPath, Resources.polarssl_dll);\n                LoadLibrary(dllPath);\n                FileStream fs = new FileStream("shadowsocks.log", FileMode.Append);
                FileStream fs = new FileStream("shadowsocks.log", FileMode.Append);\n                TextWriter tmp = Console.Out;\n                StreamWriter sw = new StreamWriter(fs);\n                sw.AutoFlush = true;\n                Console.SetOut(sw);\n                Console.SetError(sw);\n            }\n            catch (IOException e)\n            {\n                Console.WriteLine(e.ToString());
            {\n                n = input.Read(buffer, 0, buffer.Length);\n                if (n == 0)
                {\n                    throw new IOException("can not decompress pac");\n                }\n                return System.Text.Encoding.UTF8.GetString(buffer, 0, n);\n            }
                }\n                return System.Text.Encoding.UTF8.GetString(buffer, 0, n);\n            }\n        }\n        private void receiveCallback(IAsyncResult ar)\n        {\n            Socket conn = (Socket)ar.AsyncState;\n            try\n            {\n                int bytesRead = conn.EndReceive(ar);
            }\n        }\n        private void receiveCallback(IAsyncResult ar)\n        {\n            Socket conn = (Socket)ar.AsyncState;\n            try\n            {\n                int bytesRead = conn.EndReceive(ar);\n                string pac = getPACContent();\n                string proxy = "PROXY 127.0.0.1:8123; DIRECT;";
            updateSystemProxy();\n        }\n        public void SaveConfig(Config newConfig)\n        {\n            Config.Save(newConfig);\n            config = newConfig;\n            local.Stop();\n            polipoRunner.Stop();\n            polipoRunner.Start(config);\n            local = new Local(config);
            this.aboutItem.Text = "About";\n            this.aboutItem.Click += new System.EventHandler(this.aboutToolStripMenuItem_Click);\n            // \n            // menuItem3\n            // 
                {"aes-128-cfb", new int[]{16, 16, CIPHER_AES, PolarSSL.AES_CTX_SIZE}},\n                {"aes-192-cfb", new int[]{24, 16, CIPHER_AES, PolarSSL.AES_CTX_SIZE}},\n                {"aes-256-cfb", new int[]{32, 16, CIPHER_AES, PolarSSL.AES_CTX_SIZE}},\n                {"rc4", new int[]{16, 0, CIPHER_RC4, PolarSSL.ARC4_CTX_SIZE}},\n                {"rc4-md5", new int[]{16, 16, CIPHER_RC4, PolarSSL.ARC4_CTX_SIZE}},\n            };
        }\n        protected override void initCipher(byte[] iv, bool isCipher)\n        {\n            base.initCipher(iv, isCipher);\n            IntPtr ctx;\n            ctx = Marshal.AllocHGlobal(_cipherInfo[3]);\n            if (isCipher)\n            {\n                _encryptCtx = ctx;\n            }
        }\n        protected override void cipherUpdate(bool isCipher, int length, byte[] buf, byte[] outbuf)\n        {\n            // TODO write a unidirection cipher so we don't have to if if if\n            int bytesRemaining;\n            ulong ic;\n            byte[] sodiumBuf;\n            byte[] iv;\n            if (isCipher)\n            {
            {\n                return new TableEncryptor(method, password);\n            }\n            return new SodiumEncryptor(method, password);\n        }
            }\n            return new SodiumEncryptor(method, password);\n        }\n    }\n}
        }\n    }\n}
            this.btnOK.Name = "btnOK";\n            this.btnCancel.Location = new System.Drawing.Point(204, 9);\n            this.btnCancel.Name = "btnCancel";
            this.btnCancel.Name = "btnCancel";\n            this.btnRegisterAll.Location = new System.Drawing.Point(75, 9);\n            this.btnRegisterAll.Name = "btnRegisterAll";
            this.btnRegisterAll.Name = "btnRegisterAll";
using System.Drawing;\nusing System.Linq;\nusing System.Text;\nusing System.Windows.Forms;\nusing Shadowsocks.Controller;\nusing Shadowsocks.Model;\nusing Shadowsocks.Properties;\nusing static Shadowsocks.Controller.HotkeyReg;\nnamespace Shadowsocks.View\n{
using System.Text;\nusing System.Windows.Forms;\nusing Shadowsocks.Controller;\nusing Shadowsocks.Model;\nusing Shadowsocks.Properties;\nusing static Shadowsocks.Controller.HotkeyReg;\nnamespace Shadowsocks.View\n{\n    public partial class HotkeySettingsForm : Form\n    {
using static Shadowsocks.Controller.HotkeyReg;\nnamespace Shadowsocks.View\n{\n    public partial class HotkeySettingsForm : Form\n    {\n        private readonly ShadowsocksController _controller;\n        // this is a copy of hotkey configuration that we are working on\n        private HotkeyConfig _modifiedHotkeyConfig;\n        public HotkeySettingsForm(ShadowsocksController controller)\n        {
using System.Globalization;\nusing System.IO;\nnamespace Shadowsocks.Controller\n{\n    using Shadowsocks.Properties;\n    public static class I18N
    public static class I18N\n    {\n        private static Dictionary<string, string> _strings = new Dictionary<string, string>();\n        private static void Init(string res)\n        {\n            using (var sr = new StringReader(res))\n            {\n                foreach (var line in sr.NonWhiteSpaceLines())
        {\n            using (var sr = new StringReader(res))\n            {\n                foreach (var line in sr.NonWhiteSpaceLines())\n                {
            {\n                foreach (var line in sr.NonWhiteSpaceLines())\n                {\n                    if (line[0] == '#')\n                        continue;
                {\n                    if (line[0] == '#')\n                        continue;\n                    var pos = line.IndexOf('=');\n                    if (pos < 1)\n                        continue;\n                    _strings[line.Substring(0, pos)] = line.Substring(pos + 1);
                }\n            }\n        }\n        static I18N()\n        {\n            string name = CultureInfo.CurrentCulture.EnglishName;\n            if (name.StartsWith("Chinese", StringComparison.OrdinalIgnoreCase))\n            {\n                // choose Traditional Chinese only if we get explicit indication\n                Init(name.Contains("Traditional")
        }\n        public static string GetString(string key, params object[] args)\n        {\n            return string.Format(_strings.TryGetValue(key, out var value) ? value : key, args);\n        }
namespace Shadowsocks.View\n{\n    public partial class ConfigForm : Form\n    {\n        private ShadowsocksController controller;\n        // this is a copy of configuration that we are working on\n        private Configuration _modifiedConfiguration;\n        private int _lastSelectedIndex = -1;\n        private bool isChange = false;\n        public ConfigForm(ShadowsocksController controller)
            toolTip1.SetToolTip(PortableModeCheckBox, I18N.GetString("Restart required"));\n            RemarksLabel.Text = I18N.GetString("Remarks");\n            TimeoutLabel.Text = I18N.GetString("Timeout(Sec)");\n            ServerGroupBox.Text = I18N.GetString("Server");\n            OKButton.Text = I18N.GetString("OK");\n            MyCancelButton.Text = I18N.GetString("Cancel");\n            ApplyButton.Text = I18N.GetString("Apply");\n            MoveUpButton.Text = I18N.GetString("Move &Up");\n            MoveDownButton.Text = I18N.GetString("Move D&own");\n            Text = I18N.GetString("Edit Servers");
        }\n        private void SetupValueChangedListeners()\n        {\n            IPTextBox.TextChanged += ConfigValueChanged;\n            ProxyPortTextBox.TextChanged += ConfigValueChanged;\n            PasswordTextBox.TextChanged += ConfigValueChanged;\n            EncryptionSelect.SelectedIndexChanged += ConfigValueChanged;\n            PluginTextBox.TextChanged += ConfigValueChanged;\n            PluginArgumentsTextBox.TextChanged += ConfigValueChanged;\n            PluginOptionsTextBox.TextChanged += ConfigValueChanged;
using Shadowsocks.View;\nnamespace Shadowsocks.Controller.Hotkeys\n{\n    public class HotkeyCallbacks\n    {\n        public static HotkeyCallbacks Instance { get; private set; }\n        public static void InitInstance(ShadowsocksController controller)\n        {\n            if (Instance != null)\n            {
        public static void InitInstance(ShadowsocksController controller)\n        {\n            if (Instance != null)\n            {\n                return;\n            }\n            Instance = new HotkeyCallbacks(controller);\n        }
using Shadowsocks.Model;\nnamespace Shadowsocks.Controller.Strategy\n{\n    class StatisticsStrategy : IStrategy\n    {\n        private readonly ShadowsocksController _controller;\n        private Server _currentServer;
        public StatisticsStrategy(ShadowsocksController controller)\n        {\n            _controller = controller;\n            var servers = controller.GetCurrentConfiguration().configs;\n            var randomIndex = new Random().Next() % servers.Count();\n            _currentServer = servers[randomIndex];  //choose a server randomly at first\n            _timer = new Timer(ReloadStatisticsAndChooseAServer);\n        }\n        private void ReloadStatisticsAndChooseAServer(object obj)\n        {
        private void LoadStatistics()\n        {\n            try\n            {\n                var path = AvailabilityStatistics.AvailabilityStatisticsFile;\n                Logging.Debug($"loading statistics from {path}");\n                if (!File.Exists(path))\n                {\n                    LogWhenEnabled($"statistics file does not exist, try to reload {RetryInterval} minutes later");\n                    _timer.Change(RetryInterval, CachedInterval);
                    return;\n                }\n                _statistics = (from l in File.ReadAllLines(path)\n                                  .Skip(1)\n                                  let strings = l.Split(new[] { "," }, StringSplitOptions.RemoveEmptyEntries)\n                                  let rawData = new\n                                  {\n                                      ServerName = strings[1],\n                                      IPStatus = strings[2],\n                                      RoundtripTime = int.Parse(strings[3])
            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n            }\n        }\n        //return the score by data\n        //server with highest score will be choosen\n        private static double GetScore(StatisticsData data)\n        {\n            return (double)data.SuccessTimes / (data.SuccessTimes + data.TimedOutTimes); //simply choose min package loss
        }\n        public class StatisticsData\n        {\n            public int SuccessTimes;\n            public int TimedOutTimes;\n            public int AverageResponse;\n            public int MinResponse;\n            public int MaxResponse;\n        }
            public int AverageResponse;\n            public int MinResponse;\n            public int MaxResponse;\n        }\n        private void ChooseNewServer(List<Server> servers)\n        {\n            if (_statistics == null || servers.Count == 0)\n            {\n                return;\n            }
            {\n                return;\n            }\n            try\n            {\n                var bestResult = (from server in servers\n                                  let name = server.FriendlyName()\n                                  where _statistics.ContainsKey(name)\n                                  select new\n                                  {
                                  select new\n                                  {\n                                      server,\n                                      score = GetScore(_statistics[name])\n                                  }\n                                  ).Aggregate((result1, result2) => result1.score > result2.score ? result1 : result2);\n                if (!_currentServer.Equals(bestResult.server)) //output when enabled\n                {
                                  }\n                                  ).Aggregate((result1, result2) => result1.score > result2.score ? result1 : result2);\n                if (!_currentServer.Equals(bestResult.server)) //output when enabled\n                {
        {\n            InitializeComponent();\n            valueLabel.Text = value;\n        }\n        public string Value => valueLabel.Text;\n        public float Factor => float.Parse(factorNum.Text);\n    }\n}
        }\n        public string Value => valueLabel.Text;\n        public float Factor => float.Parse(factorNum.Text);\n    }\n}
    }\n}
            this.StatisticsChart = new System.Windows.Forms.DataVisualization.Charting.Chart();\n            this.byISPCheckBox = new System.Windows.Forms.CheckBox();\n            this.label2 = new System.Windows.Forms.Label();\n            this.label3 = new System.Windows.Forms.Label();\n            this.label4 = new System.Windows.Forms.Label();\n            this.groupBox1 = new System.Windows.Forms.GroupBox();\n            this.radioButton2 = new System.Windows.Forms.RadioButton();\n            this.radioButton1 = new System.Windows.Forms.RadioButton();\n            this.splitContainer1 = new System.Windows.Forms.SplitContainer();
            ((System.ComponentModel.ISupportInitialize)(this.StatisticsChart)).BeginInit();\n            this.groupBox1.SuspendLayout();\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer1)).BeginInit();\n            this.splitContainer1.Panel1.SuspendLayout();\n            this.splitContainer1.Panel2.SuspendLayout();\n            this.splitContainer1.SuspendLayout();\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer2)).BeginInit();\n            this.splitContainer2.Panel1.SuspendLayout();\n            this.splitContainer2.Panel2.SuspendLayout();
            series1.Legend = "ChartLegend";\n            series1.Name = "Data Transferred";\n            series2.ChartArea = "ChartArea";\n            series2.ChartType = System.Windows.Forms.DataVisualization.Charting.SeriesChartType.Bubble;\n            series2.Color = System.Drawing.Color.FromArgb(((int)(((byte)(221)))), ((int)(((byte)(88)))), ((int)(((byte)(0)))));\n            series2.Legend = "ChartLegend";\n            series2.Name = "Package Loss";\n            series2.YValuesPerPoint = 4;
            series2.ChartArea = "ChartArea";\n            series2.ChartType = System.Windows.Forms.DataVisualization.Charting.SeriesChartType.Bubble;\n            series2.Color = System.Drawing.Color.FromArgb(((int)(((byte)(221)))), ((int)(((byte)(88)))), ((int)(((byte)(0)))));\n            series2.Legend = "ChartLegend";\n            series2.Name = "Package Loss";\n            series2.YValuesPerPoint = 4;\n            series3.BorderWidth = 4;\n            series3.ChartArea = "ChartArea";\n            series3.ChartType = System.Windows.Forms.DataVisualization.Charting.SeriesChartType.Line;\n            series3.Color = System.Drawing.Color.FromArgb(((int)(((byte)(155)))), ((int)(((byte)(77)))), ((int)(((byte)(150)))));
            series2.Legend = "ChartLegend";\n            series2.Name = "Package Loss";\n            series2.YValuesPerPoint = 4;\n            series3.BorderWidth = 4;\n            series3.ChartArea = "ChartArea";\n            series3.ChartType = System.Windows.Forms.DataVisualization.Charting.SeriesChartType.Line;\n            series3.Color = System.Drawing.Color.FromArgb(((int)(((byte)(155)))), ((int)(((byte)(77)))), ((int)(((byte)(150)))));\n            series3.Legend = "ChartLegend";\n            series3.Name = "Ping";\n            this.StatisticsChart.Series.Add(series1);
            this.StatisticsChart.Series.Add(series1);\n            this.StatisticsChart.Series.Add(series2);\n            this.StatisticsChart.Series.Add(series3);\n            this.StatisticsChart.Size = new System.Drawing.Size(951, 222);\n            this.StatisticsChart.TabIndex = 2;\n            // \n            // byISPCheckBox\n            // \n            this.byISPCheckBox.AutoSize = true;\n            this.byISPCheckBox.DataBindings.Add(new System.Windows.Forms.Binding("Checked", this.bindingConfiguration, "ByIsp", true));
            this.StatisticsChart.TabIndex = 2;\n            // \n            // byISPCheckBox\n            // \n            this.byISPCheckBox.AutoSize = true;\n            this.byISPCheckBox.DataBindings.Add(new System.Windows.Forms.Binding("Checked", this.bindingConfiguration, "ByIsp", true));\n            this.byISPCheckBox.Location = new System.Drawing.Point(12, 56);\n            this.byISPCheckBox.Margin = new System.Windows.Forms.Padding(5, 10, 5, 10);\n            this.byISPCheckBox.Name = "byISPCheckBox";\n            this.byISPCheckBox.Size = new System.Drawing.Size(204, 32);
using Shadowsocks.Util;\nusing Timer = System.Threading.Timer;\nnamespace Shadowsocks.Controller\n{\n    using DataUnit = KeyValuePair<string, string>;\n    using DataList = List<KeyValuePair<string, string>>;\n    internal class AvailabilityStatistics\n    {\n        private const string StatisticsFilesName = "shadowsocks.availability.csv";
        private Timer _timer;\n        private State _state;\n        private List<Server> _servers;\n        public static string AvailabilityStatisticsFile;\n        //static constructor to initialize every public static fields before refereced\n        static AvailabilityStatistics()\n        {\n            string temppath = Utils.GetTempPath();\n            AvailabilityStatisticsFile = Path.Combine(temppath, StatisticsFilesName);\n        }
            AvailabilityStatisticsFile = Path.Combine(temppath, StatisticsFilesName);\n        }\n        public bool Set(bool enabled)\n        {\n            try
        {\n            try\n            {\n                if (enabled)\n                {
                {\n                    if (_timer?.Change(0, Interval) == null)\n                    {\n                        _state = new State();\n                        _timer = new Timer(Evaluate, _state, 0, Interval);\n                    }\n                }\n                else\n                {\n                    _timer?.Dispose();
                    {\n                        _state = new State();\n                        _timer = new Timer(Evaluate, _state, 0, Interval);\n                    }\n                }\n                else\n                {\n                    _timer?.Dispose();\n                }\n                return true;
                    }\n                }\n                else\n                {\n                    _timer?.Dispose();\n                }\n                return true;\n            }\n            catch (Exception e)\n            {
        {\n            var ping = new Ping();\n            var ret = new List<DataList>();\n            foreach (\n                var timestamp in Enumerable.Range(0, Repeat).Select(_ => DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss")))\n            {\n                //ICMP echo. we can also set options and special bytes
            {\n                //ICMP echo. we can also set options and special bytes\n                try\n                {\n                    var reply = await ping.SendTaskAsync(server.server, Timeout);\n                    ret.Add(new List<KeyValuePair<string, string>>\n                    {\n                        new KeyValuePair<string, string>("Timestamp", timestamp),\n                        new KeyValuePair<string, string>("Server", server.FriendlyName()),\n                        new KeyValuePair<string, string>("Status", reply?.Status.ToString()),\n                        new KeyValuePair<string, string>("RoundtripTime", reply?.RoundtripTime.ToString())
                    ret.Add(new List<KeyValuePair<string, string>>\n                    {\n                        new KeyValuePair<string, string>("Timestamp", timestamp),\n                        new KeyValuePair<string, string>("Server", server.FriendlyName()),\n                        new KeyValuePair<string, string>("Status", reply?.Status.ToString()),\n                        new KeyValuePair<string, string>("RoundtripTime", reply?.RoundtripTime.ToString())\n                        //new KeyValuePair<string, string>("data", reply.Buffer.ToString()); // The data of reply\n                    });\n                }\n                catch (Exception e)
        }\n        internal void UpdateConfiguration(Configuration config)\n        {\n            Set(config.availabilityStatistics);\n            _servers = config.configs;\n        }\n        private class State\n        {\n            public DataList dataList = new DataList();\n            public const string Geolocation = "Geolocation";
        {\n            Set(config.availabilityStatistics);\n            _servers = config.configs;\n        }\n        private class State\n        {\n            public DataList dataList = new DataList();\n            public const string Geolocation = "Geolocation";\n            public const string ISP = "ISP";\n            public const string Unknown = "Unknown";
            _servers = config.configs;\n        }\n        private class State\n        {\n            public DataList dataList = new DataList();\n            public const string Geolocation = "Geolocation";\n            public const string ISP = "ISP";\n            public const string Unknown = "Unknown";\n        }\n    }
        {\n            public DataList dataList = new DataList();\n            public const string Geolocation = "Geolocation";\n            public const string ISP = "ISP";\n            public const string Unknown = "Unknown";\n        }\n    }\n}
            try\n            {\n                RegistryKey hkcr = RegistryKey.OpenBaseKey(RegistryHive.ClassesRoot,\n                        Environment.Is64BitOperatingSystem ? RegistryView.Registry64 : RegistryView.Registry32);\n                runKey = hkcr.CreateSubKey("ss",RegistryKeyPermissionCheck.ReadWriteSubTree);\n                if (runKey == null)\n                {
                {\n                    runKey.SetValue("", "URL:Shadowsocks");\n                    runKey.SetValue("URL Protocol", "");\n                    var shellOpen = runKey.CreateSubKey("shell").CreateSubKey("open").CreateSubKey("command");\n                    shellOpen.SetValue("", $"{ExecutablePath} --open-url %1");
                    shellOpen.SetValue("", $"{ExecutablePath} --open-url %1");\n                }\n                else\n                {\n                    hkcr.DeleteSubKeyTree("ss");\n                }\n                return true;
                }\n                return true;\n            }\n            catch (Exception e)\n            {\n                logger.LogUsefulException(e);\n                return false;\n            }\n            finally\n            {
                    }\n                    catch (Exception e)\n                    { logger.LogUsefulException(e); }\n                }\n            }\n        }\n        public static bool Check()\n        {\n            RegistryKey runKey = null;\n            try
            try\n            {\n                runKey = Utils.OpenRegKey(@"ss", true, RegistryHive.ClassesRoot);\n                if (runKey == null)\n                {\n                    logger.Error(@"Cannot find HKCR\ss");\n                    return false;\n                }\n                var shellOpen = runKey.OpenSubKey("shell").OpenSubKey("open").OpenSubKey("command");\n                return (string)shellOpen.GetValue("") == $"{ExecutablePath} --open-url %1";
                {\n                    logger.Error(@"Cannot find HKCR\ss");\n                    return false;\n                }\n                var shellOpen = runKey.OpenSubKey("shell").OpenSubKey("open").OpenSubKey("command");\n                return (string)shellOpen.GetValue("") == $"{ExecutablePath} --open-url %1";\n            }\n            catch (Exception e)\n            {\n                logger.LogUsefulException(e);
                    return false;\n                }\n                var shellOpen = runKey.OpenSubKey("shell").OpenSubKey("open").OpenSubKey("command");\n                return (string)shellOpen.GetValue("") == $"{ExecutablePath} --open-url %1";\n            }\n            catch (Exception e)\n            {\n                logger.LogUsefulException(e);\n                return false;\n            }
                return (string)shellOpen.GetValue("") == $"{ExecutablePath} --open-url %1";\n            }\n            catch (Exception e)\n            {\n                logger.LogUsefulException(e);\n                return false;\n            }\n            finally\n            {\n                if (runKey != null)
                    }\n                    catch (Exception e)\n                    { logger.LogUsefulException(e); }\n                }\n            }\n        }\n    }\n}
[assembly: AssemblyProduct("shadowsocks-csharp")]\n[assembly: AssemblyCopyright("Copyright ©  2014")]\n[assembly: AssemblyTrademark("")]\n[assembly: AssemblyCulture("")]\n// 将 ComVisible 设置为 false 使此程序集中的类型\n// 对 COM 组件不可见。如果需要从 COM 访问此程序集中的类型，\n// 则将该类型上的 ComVisible 属性设置为 true。\n[assembly: ComVisible(false)]\n// 如果此项目向 COM 公开，则下列 GUID 用于类型库的 ID\n[assembly: Guid("f8334709-4309-436a-8bbd-6165dcf4a660")]
[assembly: AssemblyTrademark("")]\n[assembly: AssemblyCulture("")]\n// 将 ComVisible 设置为 false 使此程序集中的类型\n// 对 COM 组件不可见。如果需要从 COM 访问此程序集中的类型，\n// 则将该类型上的 ComVisible 属性设置为 true。\n[assembly: ComVisible(false)]\n// 如果此项目向 COM 公开，则下列 GUID 用于类型库的 ID\n[assembly: Guid("f8334709-4309-436a-8bbd-6165dcf4a660")]\n// 程序集的版本信息由下面四个值组成:\n//
        {\n            // release any unused pages\n            // making the numbers look good in task manager\n            // this is totally nonsense in programming\n            // but good for those users who care\n            // making them happier with their everyday life\n            // which is part of user experience\n            GC.Collect(GC.MaxGeneration);\n            GC.WaitForPendingFinalizers();\n            SetProcessWorkingSetSize(Process.GetCurrentProcess().Handle,\n                (UIntPtr)0xFFFFFFFF, (UIntPtr)0xFFFFFFFF);\n        }\n        public static string UnGzip(byte[] buf)
        }\n        public static string UnGzip(byte[] buf)\n        {\n            byte[] buffer = new byte[1024];\n            int n;\n            using (MemoryStream sb = new MemoryStream())\n            {\n                using (GZipStream input = new GZipStream(new MemoryStream(buf),\n                    CompressionMode.Decompress, false))\n                {
        }\n        private void ConnectCallback(IAsyncResult ar)\n        {\n            try\n            {\n                // Complete the connection.
                    connection.BeginSend(remoteSendBuffer, 0, bytesToSend, 0, new AsyncCallback(PipeConnectionSendCallback), null);\n                }\n                else\n                {\n                    //Console.WriteLine("bytesRead: " + bytesRead.ToString());\n                    connection.Shutdown(SocketShutdown.Send);\n                    connectionShutdown = true;\n                    CheckClose();\n                }\n            }
                    remote.BeginSend(connetionSendBuffer, 0, bytesToSend, 0, new AsyncCallback(PipeRemoteSendCallback), null);\n                }\n                else\n                {\n                    remote.Shutdown(SocketShutdown.Send);\n                    remoteShutdown = true;\n                    CheckClose();\n                }\n            }\n            catch (Exception e)
            }\n        }\n        private string GetPACContent()\n        {\n            if (File.Exists(PAC_FILE))\n            {\n                return File.ReadAllText(PAC_FILE, Encoding.UTF8);\n            }\n            else\n            {
            {\n                AppDomain.CurrentDomain.UnhandledException += CurrentDomain_UnhandledException;\n                Application.ApplicationExit += Application_ApplicationExit;\n                SystemEvents.PowerModeChanged += SystemEvents_PowerModeChanged;\n                Application.EnableVisualStyles();\n                Application.SetCompatibleTextRenderingDefault(false);\n                Application.ApplicationExit += (sender, args) => HotKeys.Destroy();\n                if (!mutex.WaitOne(0, false))
                    "Shadowsocks Error", MessageBoxButtons.OK, MessageBoxIcon.Error);\n                Application.Exit();\n            }
                    }\n                    _connection.BeginSend(response, 0, response.Length, SocketFlags.None,\n                        HandshakeSendCallback, null);\n                }\n                else\n                    Close();\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);
                Close();\n            }\n        }\n        private void HandshakeSendCallback(IAsyncResult ar)\n        {\n            if (_closed) return;\n            try\n            {\n                _connection.EndSend(ar);\n                // +-----+-----+-------+------+----------+----------+
                            Close();\n                            break;\n                    }\n                }\n                else\n                {\n                    Logging.Debug(\n                        "failed to recv data in Shadowsocks.Controller.TCPHandler.handshakeReceive2Callback()");\n                    Close();\n                }
                Close();\n            }\n        }\n        private void ResponseCallback(IAsyncResult ar)\n        {\n            try\n            {\n                _connection.EndSend(ar);\n                ReadAddress(StartConnect);\n            }
                    }\n                    _destEndPoint = SocketUtil.GetEndPoint(dstAddr, dstPort);\n                    onSuccess.Invoke(); /* StartConnect() */\n                }\n                else\n                {\n                    Logging.Debug("failed to recv data in Shadowsocks.Controller.TCPHandler.OnAddressFullyRead()");\n                    Close();\n                }\n            }
                    Close();\n                }\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void HandleUDPAssociate()
                Close();\n            }\n        }\n        private void HandleUDPAssociate()\n        {\n            IPEndPoint endPoint = (IPEndPoint)_connection.LocalEndPoint;\n            byte[] address = endPoint.Address.GetAddressBytes();\n            int port = endPoint.Port;\n            byte[] response = new byte[4 + address.Length + ADDR_PORT_LEN];\n            response[0] = 5;
                SendToServer(_firstPacketLength, session);\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void PipeRemoteReceiveCallback(IAsyncResult ar)\n        {
                Close();\n            }\n        }\n        private void PipeRemoteReceiveCallback(IAsyncResult ar)\n        {\n            if (_closed) return;\n            try\n            {\n                var session = (AsyncSession)ar.AsyncState;\n                int bytesRead = session.Remote.EndReceive(ar);
                            Close();\n                            return;\n                        }\n                    }\n                    if (bytesToSend == 0)\n                    {\n                        // need more to decrypt\n                        Logging.Debug("Need more to decrypt");\n                        session.Remote.BeginReceive(_remoteRecvBuffer, 0, RecvSize, SocketFlags.None,\n                            PipeRemoteReceiveCallback, session);\n                        return;
                        $"Started SIP003 plugin for {server.Identifier()} on {plugin.LocalEndPoint} - PID: {plugin.ProcessId}");\n                }\n            }\n            catch (Exception ex)\n            {\n                Logging.Error("Failed to start SIP003 plugin: " + ex.Message);\n                throw;\n            }\n            return plugin.LocalEndPoint;\n        }
                throw;\n            }\n            return plugin.LocalEndPoint;\n        }\n        public void SaveServers(List<Server> servers, int localPort, bool portableMode)\n        {\n            _config.configs = servers;\n            _config.localPort = localPort;\n            _config.portableMode = portableMode;\n            Configuration.Save(_config);
            }\n        }\n        private void Save()\n        {\n            Logging.Debug($"save statistics to {AvailabilityStatisticsFile}");\n            if (RawStatistics.Count == 0)\n            {\n                return;\n            }\n            try
            if (RawStatistics.Count == 0)\n            {\n                return;\n            }\n            try\n            {\n                string content;\n#if DEBUG\n                content = JsonConvert.SerializeObject(RawStatistics, Formatting.Indented);\n#else
            }\n        }\n        private void LoadRawStatistics()\n        {\n            try\n            {\n                var path = AvailabilityStatisticsFile;\n                Logging.Debug($"loading statistics from {path}");\n                if (!File.Exists(path))\n                {
                if (!File.Exists(path))\n                {\n                    using (File.Create(path))\n                    {\n                        //do nothing\n                    }\n                }\n                var content = File.ReadAllText(path);\n                RawStatistics = JsonConvert.DeserializeObject<Statistics>(content) ?? RawStatistics;\n            }
                    FireCompleted(e, userstate);\n                }\n            }\n            private void Ping_PingCompleted(object sender, PingCompletedEventArgs e)\n            {\n                try\n                {\n                    if (e.Reply.Status == IPStatus.Success)\n                    {\n                        Logging.Debug($"Ping {server.FriendlyName()} {e.Reply.RoundtripTime} ms");
                    FireCompleted(ex, e.UserState);\n                }\n            }\n            private void TestNext(object userstate)\n            {\n                if (repeat > 0)\n                {\n                    //Do ICMPTest in a random frequency\n                    int delay = TimeoutMilliseconds + new Random().Next() % TimeoutMilliseconds;\n                    new Task(() => ICMPTest(delay, userstate)).Start();
        }\n        public static void randBytes(byte[] buf, int length) { RNG.GetBytes(buf, length); }\n        public abstract void cipherEncrypt(byte[] plaintext, uint plen, byte[] ciphertext, ref uint clen);\n        public abstract void cipherDecrypt(byte[] ciphertext, uint clen, byte[] plaintext, ref uint plen);\n        #region TCP\n        public override void Encrypt(byte[] buf, int length, byte[] outbuf, out int outlength)\n        {\n            Debug.Assert(_encCircularBuffer != null, "_encCircularBuffer != null");\n            _encCircularBuffer.Put(buf, 0, length);\n            outlength = 0;\n            Logging.Debug("---Start Encryption");
                    throw new CryptoErrorException();\n                }\n                Logging.Debug("Get the real chunk len:" + chunkLen);\n                bufSize = _decCircularBuffer.Size;\n                if (bufSize < CHUNK_LEN_BYTES + tagLen /* we haven't remove them */+ chunkLen + tagLen) {\n                    Logging.Debug("No more data to decrypt one chunk");\n                    return;\n                }\n                IncrementNonce(false);\n                // we have enough data to decrypt one chunk
using System.IO;\nusing System.IO.Compression;\nusing System.Text;\nnamespace Shadowsocks.Controller\n{\n    public static class FileManager\n    {\n        public static bool ByteArrayToFile(string fileName, byte[] content)\n        {
using System;\nusing System.Collections.Generic;\nusing System.Net;\nusing System.Text;\nnamespace Shadowsocks.Controller.Strategy\n{\n    class HighAvailabilityStrategy : IStrategy\n    {
                }\n            }\n        }\n        public void UpdateLatency(Model.Server server, TimeSpan latency)\n        {\n            Logging.Debug($"latency: {server.FriendlyName()} {latency}");\n            ServerStatus status;\n            if (_serverStatus.TryGetValue(server, out status))\n            {\n                status.latency = latency;
                }\n                _tcpSocket.BeginAccept(new AsyncCallback(AcceptCallback), _tcpSocket);\n                UDPState udpState = new UDPState(_udpSocket);\n                _udpSocket.BeginReceiveFrom(udpState.buffer, 0, udpState.buffer.Length, 0, ref udpState.remoteEndPoint, new AsyncCallback(RecvFromCallback), udpState);\n            }\n            catch (SocketException)\n            {\n                _tcpSocket.Close();\n                throw;\n            }
                WebClient http = CreateWebClient();\n                http.DownloadStringCompleted += http_DownloadStringCompleted;\n                http.DownloadStringAsync(new Uri(UpdateURL));\n            }\n            catch (Exception ex)\n            {\n                Logging.LogUsefulException(ex);\n            }\n        }\n        private void http_DownloadStringCompleted(object sender, DownloadStringCompletedEventArgs e)
            }\n        }\n        private void http_DownloadStringCompleted(object sender, DownloadStringCompletedEventArgs e)\n        {\n            try\n            {\n                string response = e.Result;\n                JArray result = JArray.Parse(response);\n                List<Asset> asserts = new List<Asset>();\n                if (result != null)
                    if (CheckUpdateCompleted != null)\n                    {\n                        CheckUpdateCompleted(this, new EventArgs());\n                    }\n                }\n            }\n            catch (Exception ex)\n            {\n                Logging.LogUsefulException(ex);\n            }
            }\n        }\n        private void startDownload()\n        {\n            try\n            {\n                LatestVersionLocalName = Utils.GetTempPath(LatestVersionName);\n                WebClient http = CreateWebClient();\n                http.DownloadFileCompleted += Http_DownloadFileCompleted;\n                http.DownloadFileAsync(new Uri(LatestVersionURL), LatestVersionLocalName);
                if (CheckUpdateCompleted != null)\n                {\n                    CheckUpdateCompleted(this, new EventArgs());\n                }\n            }\n            catch (Exception ex)\n            {\n                Logging.LogUsefulException(ex);\n            }\n        }
            }\n        }\n        private WebClient CreateWebClient()\n        {\n            WebClient http = new WebClient();\n            http.Headers.Add("User-Agent", UserAgent);\n            http.Proxy = new WebProxy(config.localHost, config.localPort);\n            return http;\n        }\n        private void SortByVersions(List<Asset> asserts)
            switch (_cipher)\n            {\n                case CIPHER_CHACHA20IETFPOLY1305:\n                    ret = Sodium.crypto_aead_chacha20poly1305_ietf_decrypt(plaintext, ref decPlen,\n                        null,\n                        ciphertext, (ulong) clen,\n                        null, 0,\n                        _decNonce, _sodiumDecSubkey);\n                    break;\n                case CIPHER_XCHACHA20IETFPOLY1305:
                _remote?.SendTo(dataOut, outlen, SocketFlags.None, _remoteEndPoint);\n            }\n            public void Receive()\n            {\n                EndPoint remoteEndPoint = new IPEndPoint(GetIPAddress(), 0);\n                Logging.Debug($"++++++Receive Server Port, size:" + _buffer.Length);\n                _remote?.BeginReceiveFrom(_buffer, 0, _buffer.Length, 0, ref remoteEndPoint, new AsyncCallback(RecvFromCallback), null);\n            }\n            public void RecvFromCallback(IAsyncResult ar)\n            {
                // truncate privoxy log file while debugging\n                string privoxyLogFilename = Utils.GetTempPath("privoxy.log");\n                if (File.Exists(privoxyLogFilename))\n                    using (new FileStream(privoxyLogFilename, FileMode.Truncate)) { }\n#else\n                Logging.OpenLogFile();\n#endif\n                MainController = new ShadowsocksController();\n                MenuController = new MenuViewController(MainController);\n                HotKeys.Init(MainController);\n                MainController.Start();\n                Application.Run();
#endif\n                MainController = new ShadowsocksController();\n                MenuController = new MenuViewController(MainController);\n                HotKeys.Init(MainController);\n                MainController.Start();\n                Application.Run();\n            }\n        }
                MessageBox.Show(\n                    $"{I18N.GetString("Unexpected error, shadowsocks will exit. Please report to")} https://github.com/shadowsocks/shadowsocks-windows/issues {Environment.NewLine}{errMsg}",\n                    "Shadowsocks non-UI Error", MessageBoxButtons.OK, MessageBoxIcon.Error);\n                Application.Exit();\n            }\n        }\n        private static void Application_ThreadException(object sender, ThreadExceptionEventArgs e)\n        {\n            if (Interlocked.Increment(ref exited) == 1)\n            {
                            }\n                        });\n                    }\n                    break;\n                case PowerModes.Suspend:\n                    if (MainController != null)\n                    {\n                        MainController.Stop();\n                        Logging.Info("controller stopped");\n                    }
                // Create the state object.\n                Handler handler = new Handler();\n                handler.connection = conn;\n                //if (encryptor.method == "table")\n                //{\n                //    handler.encryptor = encryptor;\n                //}\n                //else\n                //{\n                //    handler.encryptor = new Encryptor(config.method, config.password);\n            catch (Exception e)\n            {\n                //Console.WriteLine(e.ToString());\n            }
            {\n                //Console.WriteLine(e.ToString());\n            }\n        }\n    }\n    class Handler\n    {\n        //public Encryptor encryptor;\n        public IEncryptor encryptor;\n        public Config config;
        {\n            return _strings.ContainsKey(key)\n                ? _strings[key]\n                : key;\n        }\n    }\n}
        }\n    }\n}
        }\n        public void Start(Configuration config)\n        {\n            this._config = config;\n            this._shareOverLAN = config.shareOverLan;\n            if (CheckIfPortInUse(_config.localPort))\n                throw new Exception(I18N.GetString("Port already in use"));\n            try\n            {\n                // Create a TCP/IP socket.
            try\n            {\n                // Create a TCP/IP socket.\n                _tcpSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);\n                _udpSocket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);\n                _tcpSocket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, true);\n                _udpSocket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, true);\n                IPEndPoint localEndPoint = null;\n                localEndPoint = _shareOverLAN\n                    ? new IPEndPoint(IPAddress.Any, _config.localPort)
            DestHost = host;\n            DestPort = port;\n            byte[] request = null;\n            byte atyp = 0;\n            switch (ep.AddressFamily)\n            {\n                case AddressFamily.InterNetwork:\n                    request = new byte[4 + 4 + 2];\n                    atyp = 1;\n                    break;
            request[0] = 5;\n            request[1] = 1;\n            request[2] = 0;\n            request[3] = atyp;\n            Array.Copy(addr, 0, request, 4, request.Length - 4 - 2);\n            request[request.Length - 2] = (byte) ((ep.Port >> 8) & 0xff);\n            request[request.Length - 1] = (byte) (ep.Port & 0xff);\n            var st = new Socks5State();
            var st = new Socks5State();\n            st.Callback = callback;\n            st.AsyncState = state;\n            _remote?.BeginSend(request, 0, request.Length, 0, Socks5RequestSendCallback, st);\n        }\n        public void EndConnectDest(IAsyncResult asyncResult)\n        {\n            var state = ((FakeAsyncResult)asyncResult).innerState;\n            if (state.ex != null)\n            {
                            break;\n                        case 3:  // domain name, length + str\n                            int len = _connetionRecvBuffer[1];\n                            dst_addr = System.Text.Encoding.UTF8.GetString(_connetionRecvBuffer, 2, len);\n                            dst_port = (_connetionRecvBuffer[len + 2] << 8) + _connetionRecvBuffer[len + 3];\n                            Logging.Debug($"connect to {dst_addr}:{dst_port}");\n                            break;
                            break;\n                        case 4:  // IPv6 address, 16 bytes\n                            dst_addr = new IPAddress(_connetionRecvBuffer.Skip(1).Take(16).ToArray()).ToString();\n                            dst_port = (_connetionRecvBuffer[17] << 8) + _connetionRecvBuffer[18];\n                            Logging.Debug($"connect to [{dst_addr}]:{dst_port}");\n                            break;\n                    }
                            break;\n                    }\n                    int bytesToSend;\n                    lock (_encryptionLock)\n                    {\n                        if (_closed) return;\n                        encryptor.Encrypt(_connetionRecvBuffer, bytesRead, _connetionSendBuffer, out bytesToSend);\n                    }\n                    _tcprelay.UpdateOutboundCounter(server, bytesToSend);\n                    _startSendingTime = DateTime.Now;
            {\n                using (var sr = new StringReader(Resources.cn))\n                {\n                    foreach (var line in sr.NonWhiteSpaceLines())\n                    {\n                        if (line[0] == '#')\n                            continue;\n                        var pos = line.IndexOf('=');\n                        if (pos < 1)\n                            continue;
                {\n                    foreach (var line in sr.NonWhiteSpaceLines())\n                    {\n                        if (line[0] == '#')\n                            continue;\n                        var pos = line.IndexOf('=');\n                        if (pos < 1)\n                            continue;\n                        Strings[line.Substring(0, pos)] = line.Substring(pos + 1);\n                    }
                }\n            }\n        }\n        public static string GetString(string key)\n        {\n            if (Strings.ContainsKey(key))\n            {\n                return Strings[key];\n            }\n            else
            {\n                byte[] strByte = Encoding.ASCII.GetBytes(str);\n                str = Encoding.Unicode.GetString(strByte);\n                userSettingsArr = str.Split(new string[] { "\r\n" }, StringSplitOptions.RemoveEmptyEntries);\n            }\n            _userSettings.Flags = userSettingsArr[0];
            {\n                sb.Append($"0x{arr[i]:X2}, ");\n            }
            }\n            sb.Append($"0x{arr[length - 1]:X2}");\n            sb.Append(Environment.NewLine);\n            logger.Debug(sb.ToString());\n        }\n        public static void Debug(this Logger logger, EndPoint local, EndPoint remote, int len, string header = null, string tailer = null)\n        {\n            if (header == null && tailer == null)\n                logger.Debug($"{local} => {remote} (size={len})");\n            else if (header == null && tailer != null)
        }\n        public static void Debug(this Logger logger, EndPoint local, EndPoint remote, int len, string header = null, string tailer = null)\n        {\n            if (header == null && tailer == null)\n                logger.Debug($"{local} => {remote} (size={len})");\n            else if (header == null && tailer != null)\n                logger.Debug($"{local} => {remote} (size={len}), {tailer}");\n            else if (header != null && tailer == null)\n                logger.Debug($"{header}: {local} => {remote} (size={len})");\n            else
        }\n        public static void Debug(this Logger logger, Socket sock, int len, string header = null, string tailer = null)\n        {\n            logger.Debug(sock.LocalEndPoint, sock.RemoteEndPoint, len, header, tailer);\n        }\n        public static void LogUsefulException(this Logger logger, Exception e)\n        {
        }\n        public static void LogUsefulException(this Logger logger, Exception e)\n        {\n            // just log useful exceptions, not all of them\n            if (e is SocketException)\n            {\n                SocketException se = (SocketException)e;\n                if (se.SocketErrorCode == SocketError.ConnectionAborted)\n                {\n                    // closed by browser when sending
                return configuration;\n            }\n            catch (FileNotFoundException e)\n            {\n                var configuration = new StatisticsStrategyConfiguration();\n                Save(configuration);\n                return configuration;\n            }\n            catch (Exception e)\n            {
            {\n                var configuration = new StatisticsStrategyConfiguration();\n                Save(configuration);\n                return configuration;\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                return new StatisticsStrategyConfiguration();\n            }
        {\n            bool success = true;\n            if (value is string)\n                success = SerializeString((string)value, builder);\n            else if (value is IDictionary<string, object>)\n            {\n                IDictionary<string, object> dict = (IDictionary<string, object>)value;\n                success = SerializeObject(jsonSerializerStrategy, dict.Keys, dict.Values, builder);\n            }\n            else if (value is IDictionary<string, string>)
            }\n            else if (value is IDictionary<string, string>)\n            {\n                IDictionary<string, string> dict = (IDictionary<string, string>)value;\n                success = SerializeObject(jsonSerializerStrategy, dict.Keys, dict.Values, builder);\n            }\n            else if (value is IEnumerable)\n                success = SerializeArray(jsonSerializerStrategy, (IEnumerable)value, builder);\n            else if (IsNumeric(value))\n                success = SerializeNumber(value, builder);
            }\n            else if (value is IEnumerable)\n                success = SerializeArray(jsonSerializerStrategy, (IEnumerable)value, builder);\n            else if (IsNumeric(value))\n                success = SerializeNumber(value, builder);\n            else if (value is Boolean)\n                builder.Append((bool)value ? "true" : "false");\n            else if (value == null)\n                builder.Append("null");\n            else
            else if (IsNumeric(value))\n                success = SerializeNumber(value, builder);\n            else if (value is Boolean)\n                builder.Append((bool)value ? "true" : "false");\n            else if (value == null)\n                builder.Append("null");\n            else\n            {\n                object serializedObject;\n                success = jsonSerializerStrategy.SerializeNonPrimitiveObject(value, out serializedObject);
            }\n            return success;\n        }\n        protected static bool SerializeObject(IJsonSerializerStrategy jsonSerializerStrategy, IEnumerable keys, IEnumerable values, StringBuilder builder)\n        {\n            builder.Append("{\r\n");\n            IEnumerator ke = keys.GetEnumerator();\n            IEnumerator ve = values.GetEnumerator();\n            bool first = true;
        {\n            builder.Append("{\r\n");\n            IEnumerator ke = keys.GetEnumerator();\n            IEnumerator ve = values.GetEnumerator();\n            bool first = true;\n            while (ke.MoveNext() && ve.MoveNext())\n            {\n                object key = ke.Current;\n                object value = ve.Current;
                builder.Append(" : ");\n                if (!SerializeValue(jsonSerializerStrategy, value, builder))\n                    return false;\n                first = false;\n            }\n            builder.Append("}\r\n");\n            return true;\n        }
                    return false;\n                first = false;\n            }\n            builder.Append("}\r\n");\n            return true;\n        }\n        protected static bool SerializeArray(IJsonSerializerStrategy jsonSerializerStrategy, IEnumerable anArray, StringBuilder builder)\n        {
            return true;\n        }\n        protected static bool SerializeArray(IJsonSerializerStrategy jsonSerializerStrategy, IEnumerable anArray, StringBuilder builder)\n        {\n            builder.Append("[\r\n  ");\n            bool first = true;\n            foreach (object value in anArray)\n            {\n                if (!first)
            bool first = true;\n            foreach (object value in anArray)\n            {\n                if (!first)\n                    builder.Append(",\r\n  ");\n                if (!SerializeValue(jsonSerializerStrategy, value, builder))\n                    return false;\n                first = false;\n            }
                    return false;\n                first = false;\n            }\n            builder.Append("\r\n]");\n            return true;\n        }\n        protected static bool SerializeString(string aString, StringBuilder builder)\n        {
            return true;\n        }\n        protected static bool SerializeString(string aString, StringBuilder builder)\n        {\n            builder.Append("\"");\n            char[] charArray = aString.ToCharArray();\n            for (int i = 0; i < charArray.Length; i++)\n            {\n                char c = charArray[i];\n                if (c == '"')
        }\n        public static void Close()\n        {\n            if (_rng == null) return;\n            _rng.Dispose();\n            _rng = null;\n        }\n        public static void Reload()\n        {
            _rng = null;\n        }\n        public static void Reload()\n        {\n            Close();\n            Init();\n        }\n        public static void GetBytes(byte[] buf)\n        {\n            GetBytes(buf, buf.Length);
            try\n            {\n                _rng.GetBytes(buf, 0, len);\n            }\n            catch (System.Exception)\n            {\n                // the backup way\n                byte[] tmp = new byte[len];\n                _rng.GetBytes(tmp);\n                Buffer.BlockCopy(tmp, 0, buf, 0, len);
            {\n                // the backup way\n                byte[] tmp = new byte[len];\n                _rng.GetBytes(tmp);\n                Buffer.BlockCopy(tmp, 0, buf, 0, len);\n            }\n        }\n    }\n}
                string abpContent = Utils.UnGzip(Resources.abp_js);\n                abpContent = abpContent.Replace("__RULES__", rules.ToString());\n                File.WriteAllText(PAC_FILE, abpContent, Encoding.UTF8);\n                if (UpdateCompleted != null)\n                {\n                    UpdateCompleted(this, new EventArgs());\n                }\n            }\n            catch (Exception ex)\n            {
                File.WriteAllText(PAC_FILE, abpContent, Encoding.UTF8);\n                if (UpdateCompleted != null)\n                {\n                    UpdateCompleted(this, new EventArgs());\n                }\n            }\n            catch (Exception ex)\n            {\n                if (Error != null)\n                {
        {\n            byte[] bytes = Convert.FromBase64String(response);\n            string content = Encoding.ASCII.GetString(bytes);\n            string[] lines = content.Split(new char[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);\n            List<string> valid_lines = new List<string>(lines.Length);\n            foreach (string line in lines)\n            {\n                if (line.StartsWith("!") || line.StartsWith("["))\n                    continue;\n                valid_lines.Add(line);
            {\n                MessageBox.Show("can not change registry!");\n                throw;\n            }\n        }\n        public static void Disable()\n        {\n            try
            }\n        }\n        public static void Disable()\n        {\n            try\n            {\n                RegistryKey registry =\n                    Registry.CurrentUser.OpenSubKey("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings",\n                        true);\n                registry.SetValue("ProxyEnable", 0);
            {\n                MessageBox.Show("can not change registry!");\n                throw;\n            }\n        }\n        private static void CopyProxySettingFromLan()\n        {\n            RegistryKey registry =
            }\n        }\n        private static void CopyProxySettingFromLan()\n        {\n            RegistryKey registry =\n                Registry.CurrentUser.OpenSubKey("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Connections",\n                    true);\n            var defaultValue = registry.GetValue("DefaultConnectionSettings");\n            try\n            {
        Socket listener;\n        public Local(Config config)\n        {\n            this.config = config;\n            this.encryptor = new Encryptor(config.method, config.password);\n        }\n        public void Start()\n        {\n            // Create a TCP/IP socket.\n            listener = new Socket(AddressFamily.InterNetwork,
        }\n        public void Start()\n        {\n            // Create a TCP/IP socket.\n            listener = new Socket(AddressFamily.InterNetwork,\n                SocketType.Stream, ProtocolType.Tcp);\n            IPEndPoint localEndPoint = new IPEndPoint(0, config.local_port);\n            // Bind the socket to the local endpoint and listen for incoming connections.\n            listener.Bind(localEndPoint);\n            listener.Listen(100);
            {\n                if (global)\n                {\n                    WinINet.SetIEProxy(true, true, "127.0.0.1:" + config.localPort.ToString(), "");
                {\n                    WinINet.SetIEProxy(true, true, "127.0.0.1:" + config.localPort.ToString(), "");
                }\n                else\n                {\n                    string pacUrl;\n                    if (config.useOnlinePac && !config.pacUrl.IsNullOrEmpty())\n                        pacUrl = config.pacUrl;\n                    else\n                        pacUrl = $"http://127.0.0.1:{config.localPort}/pac?t={GetTimestamp(DateTime.Now)}";\n                    WinINet.SetIEProxy(true, false, "", pacUrl);
                }\n            }\n            else\n            {\n                WinINet.SetIEProxy(false, false, "", "");\n            }\n        }\n    }\n}
            {\n                WinINet.SetIEProxy(false, false, "", "");\n            }\n        }\n    }\n}
            }\n        }\n    }\n}
        }\n        private void LogForm_FormClosing(object sender, FormClosingEventArgs e)\n        {\n            timer.Stop();
        }\n        public static void LegacyDeriveKey(byte[] password, byte[] key)\n        {\n            byte[] result = new byte[password.Length + 16];\n            int i = 0;\n            byte[] md5sum = null;\n            while (i < key.Length) {\n                if (i == 0) {\n                    md5sum = MbedTLS.MD5(password);\n                } else {
        {\n            byte[] result = new byte[password.Length + 16];\n            int i = 0;\n            byte[] md5sum = null;\n            while (i < key.Length) {\n                if (i == 0) {\n                    md5sum = MbedTLS.MD5(password);\n                } else {\n                    md5sum.CopyTo(result, 0);\n                    password.CopyTo(result, md5sum.Length);
            int i = 0;\n            byte[] md5sum = null;\n            while (i < key.Length) {\n                if (i == 0) {\n                    md5sum = MbedTLS.MD5(password);\n                } else {\n                    md5sum.CopyTo(result, 0);\n                    password.CopyTo(result, md5sum.Length);\n                    md5sum = MbedTLS.MD5(result);\n                }
                if (i == 0) {\n                    md5sum = MbedTLS.MD5(password);\n                } else {\n                    md5sum.CopyTo(result, 0);\n                    password.CopyTo(result, md5sum.Length);\n                    md5sum = MbedTLS.MD5(result);\n                }\n                md5sum.CopyTo(key, i);\n                i += md5sum.Length;\n            }
                    md5sum = MbedTLS.MD5(result);\n                }\n                md5sum.CopyTo(key, i);\n                i += md5sum.Length;\n            }\n        }\n        protected virtual void initCipher(byte[] iv, bool isEncrypt)\n        {\n            if (isEncrypt) {\n                _encryptIV = new byte[ivLen];
            }\n        }\n        protected virtual void initCipher(byte[] iv, bool isEncrypt)\n        {\n            if (isEncrypt) {\n                _encryptIV = new byte[ivLen];\n                Array.Copy(iv, _encryptIV, ivLen);\n            } else {\n                _decryptIV = new byte[ivLen];\n                Array.Copy(iv, _decryptIV, ivLen);
            // init session key\n            if (_sessionKey == null) _sessionKey = new byte[keyLen];\n        }\n        public void DeriveKey(byte[] password, byte[] key)\n        {\n            StreamEncryptor.LegacyDeriveKey(password, key);\n        }\n        public void DeriveSessionKey(byte[] salt, byte[] masterKey, byte[] sessionKey)\n        {\n            int ret = MbedTLS.hkdf(salt, saltLen, masterKey, keyLen, InfoBytes, InfoBytes.Length, sessionKey,\n                keyLen);
        }\n        public void DeriveSessionKey(byte[] salt, byte[] masterKey, byte[] sessionKey)\n        {\n            int ret = MbedTLS.hkdf(salt, saltLen, masterKey, keyLen, InfoBytes, InfoBytes.Length, sessionKey,\n                keyLen);\n            if (ret != 0) throw new System.Exception("failed to generate session key");\n        }\n        protected void IncrementNonce(bool isEncrypt)\n        {\n            lock (_nonceIncrementLock) {
        {\n            get\n            {\n                if (string.IsNullOrEmpty(server))\n                {\n                    return I18N.GetString("New server");\n                }\n                return string.IsNullOrEmpty(remarks) ? server + ":" + server_port : server + ":" + server_port + " (" + remarks + ")";\n            }
            {\n                if (string.IsNullOrEmpty(server))\n                {\n                    return I18N.GetString("New server");\n                }\n                return string.IsNullOrEmpty(remarks) ? server + ":" + server_port : server + ":" + server_port + " (" + remarks + ")";\n            }\n        }\n    }
            }\n        }\n    }\n}
                string polipoConfig = Resources.polipo_config; \n                polipoConfig = polipoConfig.Replace("__SOCKS_PORT__", server.local_port.ToString());\n                polipoConfig = polipoConfig.Replace("__POLIPO_BIND_IP__", configuration.shareOverLan ? "0.0.0.0" : "127.0.0.1");\n                FileManager.ByteArrayToFile(temppath + "/polipo.conf", System.Text.Encoding.UTF8.GetBytes(polipoConfig));\n                FileManager.UncompressFile(temppath + "/ss_polipo.exe", Resources.polipo_exe);\n                _process = new Process();\n                // Configure the process using the StartInfo properties.\n                _process.StartInfo.FileName = temppath + "/ss_polipo.exe";\n                _process.StartInfo.Arguments = "-c \"" + temppath + "/polipo.conf\"";\n                _process.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;
                _process = new Process();\n                // Configure the process using the StartInfo properties.\n                _process.StartInfo.FileName = temppath + "/ss_polipo.exe";\n                _process.StartInfo.Arguments = "-c \"" + temppath + "/polipo.conf\"";\n                _process.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;\n                _process.StartInfo.UseShellExecute = true;\n                _process.StartInfo.CreateNoWindow = true;\n                //_process.StartInfo.RedirectStandardOutput = true;\n                //_process.StartInfo.RedirectStandardError = true;\n                _process.Start();
        public Socket connection;\n        public ShadowsocksController controller;\n        public TCPRelay tcprelay;\n        public DateTime lastActivity;\n        private const int MaxRetry = 4;\n        private int _retryCount = 0;\n        private bool _proxyConnected;\n        private bool _destConnected;\n        private byte _command;\n        private byte[] _firstPacket;
            public EndPoint DestEndPoint;\n            public Server Server;\n            public ProxyTimer(int p) : base(p)\n            {\n            }\n        }\n        private class ServerTimer : Timer\n        {\n            public Server Server;
                proxyTimer.DestEndPoint = SocketUtil.GetEndPoint(server.server, server.server_port);\n                proxyTimer.Server = server;\n                _proxyConnected = false;\n                // Connect to the proxy server.\n                remote.BeginConnectProxy(proxyEP, new AsyncCallback(ProxyConnectCallback), proxyTimer);\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }
            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void proxyConnectTimer_Elapsed(object sender, ElapsedEventArgs e)\n        {\n            if (_proxyConnected || _destConnected)
            Logging.Info($"Proxy {proxy.ProxyEndPoint} timed out");\n            remote?.Close();\n            RetryConnect();\n        }\n        private void ProxyConnectCallback(IAsyncResult ar)\n        {\n            Server server = null;\n            if (_closed)\n            {\n                return;
            RetryConnect();\n        }\n        private void ProxyConnectCallback(IAsyncResult ar)\n        {\n            Server server = null;\n            if (_closed)\n            {\n                return;\n            }\n            try
                var destEndPoint = timer.DestEndPoint;\n                server = timer.Server;\n                timer.Elapsed -= proxyConnectTimer_Elapsed;\n                timer.Enabled = false;\n                timer.Dispose();\n                // Complete the connection.\n                remote.EndConnectProxy(ar);\n                _proxyConnected = true;\n                if (_config.isVerboseLogging)
            }\n            catch (ArgumentException)\n            {\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                RetryConnect();\n            }\n        }
            RetryConnect();\n        }\n        private void RetryConnect()\n        {\n            if (_retryCount < MaxRetry)\n            {\n                Logging.Debug($"Connection failed, retry ({_retryCount})");\n                StartConnect();\n                _retryCount++;\n            }
                server = timer.Server;\n                timer.Elapsed -= destConnectTimer_Elapsed;\n                timer.Enabled = false;\n                timer.Dispose();\n                // Complete the connection.\n                remote?.EndConnectDest(ar);\n                _destConnected = true;\n                if (_config.isVerboseLogging)\n                {
        {\n            if (_closed) return;\n            try\n            {\n                _startReceivingTime = DateTime.Now;\n                remote?.BeginReceive(_remoteRecvBuffer, 0, RecvSize, SocketFlags.None, new AsyncCallback(PipeRemoteReceiveCallback), null);\n                connection?.BeginReceive(_connetionRecvBuffer, 0, RecvSize, SocketFlags.None, new AsyncCallback(PipeConnectionReceiveCallback), \n                    true /* to tell the callback this is the first time reading packet, and we haven't found the header yet. */);\n            }\n            catch (Exception e)
                connection?.BeginReceive(_connetionRecvBuffer, 0, RecvSize, SocketFlags.None, new AsyncCallback(PipeConnectionReceiveCallback), \n                    true /* to tell the callback this is the first time reading packet, and we haven't found the header yet. */);\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void PipeRemoteReceiveCallback(IAsyncResult ar)
            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void PipeRemoteReceiveCallback(IAsyncResult ar)\n        {\n            if (_closed) return;
                    {\n                        int atyp = _connetionRecvBuffer[0];\n                        string dst_addr;\n                        int dst_port;\n                        switch (atyp)\n                        {\n                            case 1: // IPv4 address, 4 bytes\n                                dst_addr = new IPAddress(_connetionRecvBuffer.Skip(1).Take(4).ToArray()).ToString();\n                                dst_port = (_connetionRecvBuffer[5] << 8) + _connetionRecvBuffer[6];\n                                Logging.Info($"connect to {dst_addr}:{dst_port}");
                                break;\n                        }\n                    }\n                    int bytesToSend;\n                    lock (_encryptionLock)\n                    {\n                        if (_closed) return;\n                        encryptor.Encrypt(_connetionRecvBuffer, bytesRead, _connetionSendBuffer, out bytesToSend);\n                    }\n                    _tcprelay.UpdateOutboundCounter(server, bytesToSend);
            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }\n    }\n}
        static Dictionary<string, int[]> ciphers = new Dictionary<string, int[]> {\n            {"aes-128-cfb", new int[]{16, 16, CIPHER_AES, PolarSSL.AES_CTX_SIZE}},\n            {"aes-192-cfb", new int[]{24, 16, CIPHER_AES, PolarSSL.AES_CTX_SIZE}},\n            {"aes-256-cfb", new int[]{32, 16, CIPHER_AES, PolarSSL.AES_CTX_SIZE}},\n            {"bf-cfb", new int[]{16, 8, CIPHER_BF, PolarSSL.BLOWFISH_CTX_SIZE}},\n            {"rc4", new int[]{16, 0, CIPHER_RC4, PolarSSL.ARC4_CTX_SIZE}},\n            {"rc4-md5", new int[]{16, 16, CIPHER_RC4, PolarSSL.ARC4_CTX_SIZE}},\n        };\n        private static readonly Dictionary<string, byte[]> CachedKeys = new Dictionary<string, byte[]>();\n        private int _cipher;
            {"rc4", new int[]{16, 0, CIPHER_RC4, PolarSSL.ARC4_CTX_SIZE}},\n            {"rc4-md5", new int[]{16, 16, CIPHER_RC4, PolarSSL.ARC4_CTX_SIZE}},\n        };\n        private static readonly Dictionary<string, byte[]> CachedKeys = new Dictionary<string, byte[]>();\n        private int _cipher;\n        private int[] _cipherInfo;\n        private byte[] _key;\n        private IntPtr _encryptCtx = IntPtr.Zero;\n        private IntPtr _decryptCtx = IntPtr.Zero;\n        private byte[] _encryptIV;
                    // Connect to the remote endpoint.\n                    _remote.BeginConnect(remoteEP,\n                        new AsyncCallback(ConnectCallback), null);\n                }\n                catch (Exception e)\n                {\n                    Logging.LogUsefulException(e);\n                    this.Close();\n                }\n            }
                }\n                catch (Exception e)\n                {\n                    Logging.LogUsefulException(e);\n                    this.Close();\n                }\n            }\n            private void ConnectCallback(IAsyncResult ar)\n            {\n                if (_closed)
        }\n        public void EndConnectDest(IAsyncResult asyncResult)\n        {\n            _remote?.EndConnect(asyncResult);\n        }\n        public void BeginSend(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state)\n        {\n            _remote?.BeginSend(buffer, offset, size, socketFlags, callback, state);\n        }
        }\n        public void BeginSend(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state)\n        {\n            _remote?.BeginSend(buffer, offset, size, socketFlags, callback, state);\n        }\n        public int EndSend(IAsyncResult asyncResult)\n        {\n            return _remote.EndSend(asyncResult);\n        }
            var st = new Socks5State();\n            st.Callback = callback;\n            st.AsyncState = state;\n            ProxyEndPoint = remoteEP;\n            _remote.BeginConnect(remoteEP, ConnectCallback, st);\n        }\n        public void EndConnectProxy(IAsyncResult asyncResult)\n        {\n            var state = ((FakeAsyncResult)asyncResult).innerState;\n            if (state.ex != null)
        }\n        public void EndConnectProxy(IAsyncResult asyncResult)\n        {\n            var state = ((FakeAsyncResult)asyncResult).innerState;\n            if (state.ex != null)\n            {\n                throw state.ex;\n            }\n        }\n        public void BeginConnectDest(EndPoint destEndPoint, AsyncCallback callback, object state)
        {\n            SocketType socketType;\n            switch (protocolType)\n            {\n                case ProtocolType.Tcp:\n                    socketType = SocketType.Stream;\n                    break;
            {\n                case ProtocolType.Tcp:\n                    socketType = SocketType.Stream;\n                    break;\n                case ProtocolType.Udp:\n                    socketType = SocketType.Dgram;\n                    break;\n                default:\n                    throw new NotSupportedException("Protocol " + protocolType + " doesn't supported!");
            }\n            if (endPoint is DnsEndPoint)
            {\n                // use dual-mode socket\n                var socket = new Socket(AddressFamily.InterNetworkV6, socketType, protocolType);\n                socket.SetSocketOption(SocketOptionLevel.IPv6, (SocketOptionName)27, false);\n                return socket;\n            }\n            else\n            {
            }\n            else\n            {\n                return new Socket(endPoint.AddressFamily, socketType, protocolType);
            {\n                return new Socket(endPoint.AddressFamily, socketType, protocolType);\n            }
            }\n        }\n    }\n}
                        {\n                            continue;\n                        }\n                        foreach (JObject asset in (JArray)release["assets"])\n                        {\n                            Asset ass = new Asset();\n                            ass.Parse(asset);\n                            if (ass.IsNewVersion(Version))
                            {\n                                asserts.Add(ass);\n                            }\n                        }\n                    }\n                }
                            }\n                        }\n                    }\n                }\n                if (asserts.Count != 0)\n                {\n                    SortByVersions(asserts);\n                    Asset asset = asserts[asserts.Count - 1];\n                    NewVersionFound = true;\n                    LatestVersionURL = asset.browser_download_url;
                {\n                    return false;\n                }\n                if (version == null)\n                {\n                    return false;\n                }\n                return CompareVersion(version, currentVersion) > 0;\n            }\n            public void Parse(JObject asset)
            }\n            public static int CompareVersion(string l, string r)\n            {\n                var ls = l.Split('.');\n                var rs = r.Split('.');\n                for (int i = 0; i < Math.Max(ls.Length, rs.Length); i++)\n                {\n                    int lp = (i < ls.Length) ? int.Parse(ls[i]) : 0;\n                    int rp = (i < rs.Length) ? int.Parse(rs[i]) : 0;\n                    if (lp != rp)
            }\n        }\n        private void pacServer_PACFileChanged(object sender, EventArgs e)\n        {\n            UpdateSystemProxy();\n        }\n        private void StartReleasingMemory()\n        {\n            _ramThread = new Thread(new ThreadStart(ReleaseMemory));\n            _ramThread.IsBackground = true;
                    break;\n                case PowerModes.Suspend:\n                    _controller?.Stop();\n                    Logging.Info("os suspend");\n                    break;
            {\n                st.innerState.ex = new Exception(I18N.GetString("Proxy request failed"));\n            }\n            st.innerState.Callback?.Invoke(st);\n        }\n        private void OnException(Exception ex, object state)\n        {
            }\n            st.innerState.Callback?.Invoke(st);\n        }\n        private void OnException(Exception ex, object state)\n        {\n            var st = (FakeAsyncResult) state;\n            st.innerState.ex = ex;\n            st.innerState.Callback?.Invoke(st);\n        }\n        private static readonly Regex HttpRespondHeaderRegex = new Regex(@"^(HTTP/1\.\d) (\d{3}) (.+)$");
        }\n        private static readonly Regex HttpRespondHeaderRegex = new Regex(@"^(HTTP/1\.\d) (\d{3}) (.+)$");\n        private int _respondLineCount = 0;\n        private bool _established = false;\n        private bool OnLineRead(string line, object state)\n        {\n            Logging.Debug(line);\n            if (_respondLineCount == 0)\n            {\n                var m = HttpRespondHeaderRegex.Match(line);
                    return true;\n                }\n                return false;\n            }\n            catch (ArgumentException)\n            {\n                return false;\n            }\n        }\n        public string TouchPACFile()
            byte[] plain2 = new byte[plain.Length + 16];\n            int outLen = 0;\n            int outLen2 = 0;\n            var random = new Random();\n            random.NextBytes(plain);\n            encryptor.Encrypt(plain, plain.Length, cipher, out outLen);\n            decryptor.Decrypt(cipher, outLen, plain2, out outLen2);\n            Assert.AreEqual(plain.Length, outLen2);\n            for (int j = 0; j < plain.Length; j++)\n            {
            decryptor.Decrypt(cipher, outLen, plain2, out outLen2);\n            Assert.AreEqual(plain.Length, outLen2);\n            for (int j = 0; j < plain.Length; j++)\n            {\n                Assert.AreEqual(plain[j], plain2[j]);\n            }\n            encryptor.Encrypt(plain, 1000, cipher, out outLen);\n            decryptor.Decrypt(cipher, outLen, plain2, out outLen2);\n            Assert.AreEqual(1000, outLen2);\n            for (int j = 0; j < outLen2; j++)
            decryptor.Decrypt(cipher, outLen, plain2, out outLen2);\n            Assert.AreEqual(1000, outLen2);\n            for (int j = 0; j < outLen2; j++)\n            {\n                Assert.AreEqual(plain[j], plain2[j]);\n            }\n            encryptor.Encrypt(plain, 12333, cipher, out outLen);\n            decryptor.Decrypt(cipher, outLen, plain2, out outLen2);\n            Assert.AreEqual(12333, outLen2);\n            for (int j = 0; j < outLen2; j++)
            decryptor.Decrypt(cipher, outLen, plain2, out outLen2);\n            Assert.AreEqual(12333, outLen2);\n            for (int j = 0; j < outLen2; j++)\n            {\n                Assert.AreEqual(plain[j], plain2[j]);\n            }\n        }\n        private static bool encryptionFailed = false;\n        private static object locker = new object();\n        [TestMethod]
        public const int CLEN_BYTES = 2;\n        public const int AUTH_BYTES = HASH_BYTES + CLEN_BYTES;\n        protected static byte[] tempbuf = new byte[MAX_INPUT_SIZE];\n        protected Dictionary<string, int[]> ciphers;\n        private static readonly Dictionary<string, byte[]> CachedKeys = new Dictionary<string, byte[]>();\n        protected byte[] _encryptIV;\n        protected byte[] _decryptIV;\n        protected bool _decryptIVReceived;\n        protected bool _encryptIVSent;\n        protected int _encryptIVOffset = 0;
        protected static byte[] tempbuf = new byte[MAX_INPUT_SIZE];\n        protected Dictionary<string, int[]> ciphers;\n        private static readonly Dictionary<string, byte[]> CachedKeys = new Dictionary<string, byte[]>();\n        protected byte[] _encryptIV;\n        protected byte[] _decryptIV;\n        protected bool _decryptIVReceived;\n        protected bool _encryptIVSent;\n        protected int _encryptIVOffset = 0;\n        protected int _decryptIVOffset = 0;\n        protected string _method;
            if (_keyBuffer == null)\n            {\n                _keyBuffer = new byte[MAX_IV_LENGTH + 4];\n                Buffer.BlockCopy(_encryptIV, 0, _keyBuffer, 0, ivLen);\n            }\n            byte[] counter_bytes = BitConverter.GetBytes((uint)IPAddress.HostToNetworkOrder((int)counter));\n            Buffer.BlockCopy(counter_bytes, 0, _keyBuffer, ivLen, 4);\n            byte[] hash = new byte[HASH_BYTES];\n            byte[] tmp = new byte[len];\n            Buffer.BlockCopy(buf, offset, tmp, 0, len);
            counter++;\n            len += AUTH_BYTES;\n            offset += len;\n        }\n        public override void Encrypt(byte[] buf, int length, byte[] outbuf, out int outlength)
        {\n            if (!_encryptIVSent)\n            {\n                _encryptIVSent = true;\n                randBytes(outbuf, ivLen);\n                initCipher(outbuf, true);\n                outlength = length + ivLen;
                    cipherUpdate(true, length, buf, tempbuf);\n                    outlength = length + ivLen;\n                    Buffer.BlockCopy(tempbuf, 0, outbuf, ivLen, length);\n                }\n            }\n            else\n            {\n                if (OnetimeAuth)\n                {\n                    int offset = 0;
                }\n                outlength = length;\n                cipherUpdate(true, length, buf, outbuf);\n            }\n        }\n        public override void Decrypt(byte[] buf, int length, byte[] outbuf, out int outlength)\n        {\n            if (!_decryptIVReceived)\n            {\n                _decryptIVReceived = true;
                Array.Copy(data, 3, dataIn, 0, length - 3);\n                byte[] dataOut = new byte[length - 3 + 16];\n                int outlen;\n                encryptor.Encrypt(dataIn, dataIn.Length, dataOut, out outlen);\n                _remote.SendTo(dataOut, _remoteEndPoint);\n            }\n            public void Receive()\n            {\n                EndPoint remoteEndPoint = new IPEndPoint(IPAddress.Any, 0);\n                _remote.BeginReceiveFrom(_buffer, 0, _buffer.Length, 0, ref remoteEndPoint, new AsyncCallback(RecvFromCallback), null);
                int outlen;\n                encryptor.Encrypt(dataIn, dataIn.Length, dataOut, out outlen);\n                _remote.SendTo(dataOut, _remoteEndPoint);\n            }\n            public void Receive()\n            {\n                EndPoint remoteEndPoint = new IPEndPoint(IPAddress.Any, 0);\n                _remote.BeginReceiveFrom(_buffer, 0, _buffer.Length, 0, ref remoteEndPoint, new AsyncCallback(RecvFromCallback), null);\n            }\n            public void RecvFromCallback(IAsyncResult ar)
            }\n            public void Receive()\n            {\n                EndPoint remoteEndPoint = new IPEndPoint(IPAddress.Any, 0);\n                _remote.BeginReceiveFrom(_buffer, 0, _buffer.Length, 0, ref remoteEndPoint, new AsyncCallback(RecvFromCallback), null);\n            }\n            public void RecvFromCallback(IAsyncResult ar)\n            {\n                try\n                {
            this.notifyIcon1 = new System.Windows.Forms.NotifyIcon(this.components);\n            this.contextMenuStrip1 = new System.Windows.Forms.ContextMenuStrip(this.components);\n            this.ConfigItem = new System.Windows.Forms.ToolStripMenuItem();\n            this.QuitItem = new System.Windows.Forms.ToolStripMenuItem();\n            this.tableLayoutPanel1.SuspendLayout();\n            this.panel1.SuspendLayout();\n            this.tableLayoutPanel2.SuspendLayout();

            this.Controls.Add(this.tableLayoutPanel1);\n            this.Name = "Form1";\n            this.Text = "Shadowsocks";\n            this.FormClosed += new System.Windows.Forms.FormClosedEventHandler(this.Form1_FormClosed);\n            this.tableLayoutPanel1.ResumeLayout(false);\n            this.tableLayoutPanel1.PerformLayout();\n            this.panel1.ResumeLayout(false);\n            this.tableLayoutPanel2.ResumeLayout(false);
            this.contextMenuStrip1.ResumeLayout(false);\n            this.ResumeLayout(false);\n            this.PerformLayout();\n        }\n        #endregion\n        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel1;\n        private System.Windows.Forms.Label label1;\n        private System.Windows.Forms.Label label2;\n        private System.Windows.Forms.Label label3;\n        private System.Windows.Forms.Label label4;
        {\n            SwitchSystemProxyTextBox.Text = config.SwitchSystemProxy;\n            SwitchProxyModeTextBox.Text = config.SwitchSystemProxyMode;\n            SwitchAllowLanTextBox.Text = config.SwitchAllowLan;\n            ShowLogsTextBox.Text = config.ShowLogs;\n            ServerMoveUpTextBox.Text = config.ServerMoveUp;\n            ServerMoveDownTextBox.Text = config.ServerMoveDown;\n        }
            {\n                MessageBox.Show(I18N.GetString("Register hotkey failed"));\n            }\n            // All check passed, saving\n            SaveConfig();\n            this.Close();\n        }\n        private void RegisterAllButton_Click(object sender, EventArgs e)\n        {\n            RegisterAllHotkeys(out _);  // declare out as an inline discard variable\n        }
        {\n            bool isSuccess = true;\n            StringBuilder failureInfo = new StringBuilder();\n            foreach (var tb in _allTextBoxes)\n            {\n                if (tb.Text.IsNullOrEmpty())\n                {\n                    continue;\n                }\n                if (!TryRegHotkey(tb))
            foreach (var tb in _allTextBoxes)\n            {\n                if (tb.Text.IsNullOrEmpty())\n                {\n                    continue;\n                }\n                if (!TryRegHotkey(tb))\n                {\n                    isSuccess = false;\n                    failureInfo.AppendLine(tb.Text);
            return isSuccess;\n        }\n        private bool TryRegHotkey(TextBox tb)\n        {\n            var hotkey = HotKeys.Str2HotKey(tb.Text);\n            if (hotkey == null)\n            {\n                MessageBox.Show(string.Format(I18N.GetString("Cannot parse hotkey: {0}"), tb.Text));\n                tb.Clear();\n                return false;
                privoxyConfig = privoxyConfig.Replace("__SOCKS_PORT__", configuration.localPort.ToString());\n                privoxyConfig = privoxyConfig.Replace("__PRIVOXY_BIND_PORT__", _runningPort.ToString());\n                privoxyConfig = privoxyConfig.Replace("__PRIVOXY_BIND_IP__", configuration.shareOverLan ? "0.0.0.0" : "127.0.0.1");\n                FileManager.ByteArrayToFile(Utils.GetTempPath(_uniqueConfigFile), Encoding.UTF8.GetBytes(privoxyConfig));\n                _process = new Process
                FileManager.ByteArrayToFile(Utils.GetTempPath(_uniqueConfigFile), Encoding.UTF8.GetBytes(privoxyConfig));\n                _process = new Process\n                {\n                    // Configure the process using the StartInfo properties.\n                    StartInfo =\n                    {\n                        FileName = "ss_privoxy.exe",\n                        Arguments = _uniqueConfigFile,\n                        WorkingDirectory = Utils.GetTempPath(),\n                        WindowStyle = ProcessWindowStyle.Hidden,
        {\n            int defaultPort = 8123;\n            try\n            {\n                // TCP stack please do me a favor\n                TcpListener l = new TcpListener(IPAddress.Loopback, 0);\n                l.Start();\n                var port = ((IPEndPoint)l.LocalEndpoint).Port;\n                l.Stop();\n                return port;\n            }
                l.Start();\n                var port = ((IPEndPoint)l.LocalEndpoint).Port;\n                l.Stop();\n                return port;\n            }\n            catch (Exception e)\n            {\n                // in case access denied\n                Logging.LogUsefulException(e);\n                return defaultPort;
        }\n        Configuration _config;\n        bool _shareOverLAN;\n        Socket _tcpSocket;\n        Socket _udpSocket;\n        List<IService> _services;\n        public Listener(List<IService> services)\n        {\n            this._services = services;\n        }
                _tcpSocket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, true);\n                _udpSocket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, true);\n                IPEndPoint localEndPoint = null;\n                localEndPoint = _shareOverLAN\n                    ? new IPEndPoint(IPAddress.Any, _config.localPort)\n                    : new IPEndPoint(IPAddress.Loopback, _config.localPort);\n                // Bind the socket to the local endpoint and listen for incoming connections.\n                _tcpSocket.Bind(localEndPoint);\n                _udpSocket.Bind(localEndPoint);\n                _tcpSocket.Listen(1024);
                // Bind the socket to the local endpoint and listen for incoming connections.\n                _tcpSocket.Bind(localEndPoint);\n                _udpSocket.Bind(localEndPoint);\n                _tcpSocket.Listen(1024);\n                // Start an asynchronous socket to listen for connections.\n                Logging.Info($"Shadowsocks started ({UpdateChecker.Version})");\n                if (_config.isVerboseLogging)\n                {\n                    Logging.Info(Encryption.EncryptorFactory.DumpRegisteredEncryptor());\n                }\n                UDPState udpState = new UDPState();
                _udpSocket.BeginReceiveFrom(udpState.buffer, 0, udpState.buffer.Length, 0, ref udpState.remoteEndPoint, new AsyncCallback(RecvFromCallback), udpState);\n            }\n            catch (SocketException)\n            {\n                _tcpSocket.Close();\n                throw;\n            }\n        }\n        public void Stop()\n        {
                Logging.Debug($"++++++Receive Server Port, size:" + _buffer.Length);\n                _remote?.BeginReceiveFrom(_buffer, 0, _buffer.Length, 0, ref remoteEndPoint, new AsyncCallback(RecvFromCallback), null);\n            }\n            public void RecvFromCallback(IAsyncResult ar)\n            {\n                try\n                {\n                    if (_remote == null) return;\n                    EndPoint remoteEndPoint = new IPEndPoint(IPAddress.Any, 0);\n                    int bytesRead = _remote.EndReceiveFrom(ar, ref remoteEndPoint);
                    int bytesRead = _remote.EndReceiveFrom(ar, ref remoteEndPoint);\n                    byte[] dataOut = new byte[bytesRead];\n                    int outlen;\n                    IEncryptor encryptor = EncryptorFactory.GetEncryptor(_server.method, _server.password);\n                    encryptor.DecryptUDP(_buffer, bytesRead, dataOut, out outlen);\n                    byte[] sendBuf = new byte[outlen + 3];\n                    Array.Copy(dataOut, 0, sendBuf, 3, outlen);\n                    Logging.Debug(_localEndPoint, _remoteEndPoint, outlen, "UDP Relay");\n                    _local?.SendTo(sendBuf, outlen + 3, 0, _localEndPoint);\n                    Receive();
                foreach (IService service in _services)\n                {\n                    if (service.Handle(state.buffer, bytesRead, _udpSocket, state))\n                    {\n                        break;\n                    }\n                }\n            }\n            catch (ObjectDisposedException)\n            {
                    {\n                        break;\n                    }\n                }\n            }\n            catch (ObjectDisposedException)\n            {\n            }\n            catch (Exception ex)\n            {
        public Server GetCurrentServer()\n        {\n            return _config.GetCurrentServer();\n        }\n        // always return copy\n        public Configuration GetConfiguration()\n        {\n            return Configuration.Load();
        {\n            Server server = GetCurrentServer();\n            return GetQRCode(server);\n        }\n        public static string GetQRCode(Server server)\n        {\n            string tag = string.Empty;\n            string url = string.Empty;\n            if (string.IsNullOrWhiteSpace(server.plugin))\n            {
        }\n        public void BeginSend(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state)\n        {\n            _remote.BeginSend(buffer, offset, size, socketFlags, callback, state);\n        }\n        public int EndSend(IAsyncResult asyncResult)\n        {\n            return _remote.EndSend(asyncResult);\n        }
        }\n        public int EndSend(IAsyncResult asyncResult)\n        {\n            return _remote.EndSend(asyncResult);\n        }\n        public void BeginReceive(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state)\n        {\n            _remote.BeginReceive(buffer, offset, size, socketFlags, callback, state);\n        }
        }\n        public int EndReceive(IAsyncResult asyncResult)\n        {\n            return _remote.EndReceive(asyncResult);\n        }\n        public void Shutdown(SocketShutdown how)\n        {\n            _remote?.Shutdown(how);\n        }\n        public void Close()
        }\n        public int EndSend(IAsyncResult asyncResult)\n        {\n            return _remote.EndSend(asyncResult);\n        }\n        public void BeginReceive(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state)\n        {\n            _remote.BeginReceive(buffer, offset, size, socketFlags, callback, state);\n        }
        }\n        public int EndReceive(IAsyncResult asyncResult)\n        {\n            return _remote.EndReceive(asyncResult);\n        }\n        public void Shutdown(SocketShutdown how)\n        {\n            _remote?.Shutdown(how);\n        }\n        public void Close()
            }\n            public void Receive()\n            {\n                EndPoint remoteEndPoint = new IPEndPoint(IPAddress.Any, 0);\n                Logging.Debug($"++++++Receive Server Port, size:" + _buffer.Length);\n                _remote.BeginReceiveFrom(_buffer, 0, _buffer.Length, 0, ref remoteEndPoint, new AsyncCallback(RecvFromCallback), null);\n            }\n            public void RecvFromCallback(IAsyncResult ar)\n            {\n                try
            }\n            public void RecvFromCallback(IAsyncResult ar)\n            {\n                try\n                {\n                    EndPoint remoteEndPoint = new IPEndPoint(IPAddress.Any, 0);\n                    int bytesRead = _remote.EndReceiveFrom(ar, ref remoteEndPoint);\n                    byte[] dataOut = new byte[bytesRead];\n                    int outlen;
                    Receive();\n                }\n                catch (ObjectDisposedException)\n                {\n                    // TODO: handle the ObjectDisposedException\n                }\n                catch (Exception)\n                {\n                    // TODO: need more think about handle other Exceptions, or should remove this catch().\n                }
using Newtonsoft.Json;\nnamespace Shadowsocks.Util.SystemProxy\n{\n    public static class Sysproxy\n    {\n        private const string _userWininetConfigFile = "user-wininet.json";\n        private static string _queryStr;\n        // In general, this won't change\n        // format:\n        //  <flags><CR-LF>
            {\n                // Configure the process using the StartInfo properties.\n                process.StartInfo.FileName = Utils.GetTempPath("sysproxy.exe");\n                process.StartInfo.Arguments = arguments;\n                process.StartInfo.WorkingDirectory = Utils.GetTempPath();\n                process.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;\n                process.StartInfo.UseShellExecute = false;\n                process.StartInfo.RedirectStandardError = true;\n                process.StartInfo.RedirectStandardOutput = true;\n                // Need to provide encoding info, or output/error strings we got will be wrong.
                {\n                    throw new ProxyException(stderr);\n                }\n                if (arguments == "query")\n                {\n                    if (stdout.IsNullOrWhiteSpace() || stdout.IsNullOrEmpty())
                    {\n                        // we cannot get user settings\n                        throw new ProxyException("failed to query wininet settings");
                    }\n                    _queryStr = stdout;\n                }\n            }\n        }
                }\n            }\n        }\n        private static void Save()\n        {\n            try\n            {\n                using (StreamWriter sw = new StreamWriter(File.Open(Utils.GetTempPath(_userWininetConfigFile), FileMode.Create)))\n                {\n                    string jsonString = JsonConvert.SerializeObject(_userSettings, Formatting.Indented);
                item.Tag = strategy.ID;\n                item.Click += AStrategyItem_Click;\n                items.Add(i, item);\n                i++;\n            }\n            Configuration configuration = controller.GetConfigurationCopy();\n            foreach (var server in configuration.configs)\n            {\n                MenuItem item = new MenuItem(server.FriendlyName());

        }\n        public string ID\n        {\n            get\n            {\n                return "com.shadowsocks.strategy.balancing";\n            }\n        }
        }\n        public Server GetAServer(IStrategyCallerType type, IPEndPoint localIPEndPoint)\n        {\n            var configs = _controller.GetCurrentConfiguration().configs;\n            int index;\n            if (type == IStrategyCallerType.TCP)\n            {\n                index = _random.Next();\n            }\n            else
        void UpdateLastRead(Server server);\n        void UpdateLastWrite(Server server);\n        void SetFailure(Server server);\n    }\n}
            this.RemarksTextBox.Name = "RemarksTextBox";\n            this.label6.Location = new System.Drawing.Point(27, 197);\n            this.label6.Margin = new System.Windows.Forms.Padding(5, 0, 5, 0);\n            this.label6.Name = "label6";
            this.label6.Name = "label6";\n            this.label1.Location = new System.Drawing.Point(26, 15);\n            this.label1.Margin = new System.Windows.Forms.Padding(5, 0, 5, 0);\n            this.label1.Name = "label1";
            this.label1.Name = "label1";\n            this.label2.Location = new System.Drawing.Point(12, 51);\n            this.label2.Margin = new System.Windows.Forms.Padding(5, 0, 5, 0);\n            this.label2.Name = "label2";
            this.label2.Name = "label2";\n            this.ProxyPortTextBox.Location = new System.Drawing.Point(110, 158);\n            this.ProxyPortTextBox.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);\n            this.ProxyPortTextBox.Name = "ProxyPortTextBox";
            this.ProxyPortTextBox.Name = "ProxyPortTextBox";\n            this.label4.Location = new System.Drawing.Point(20, 161);\n            this.label4.Margin = new System.Windows.Forms.Padding(5, 0, 5, 0);\n            this.label4.Name = "label4";
            this.label4.Name = "label4";\n            this.label3.Location = new System.Drawing.Point(22, 87);\n            this.label3.Margin = new System.Windows.Forms.Padding(5, 0, 5, 0);\n            this.label3.Name = "label3";
            this.label3.Name = "label3";\n            this.IPTextBox.Location = new System.Drawing.Point(110, 12);\n            this.IPTextBox.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);\n            this.IPTextBox.Name = "IPTextBox";
            this.IPTextBox.Name = "IPTextBox";\n            this.ServerPortTextBox.Location = new System.Drawing.Point(110, 48);\n            this.ServerPortTextBox.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);\n            this.ServerPortTextBox.Name = "ServerPortTextBox";
            this.ServerPortTextBox.Name = "ServerPortTextBox";\n            this.PasswordTextBox.Location = new System.Drawing.Point(110, 84);\n            this.PasswordTextBox.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);\n            this.PasswordTextBox.Name = "PasswordTextBox";\n            this.PasswordTextBox.PasswordChar = '*';
            this.PasswordTextBox.Name = "PasswordTextBox";\n            this.PasswordTextBox.PasswordChar = '*';\n            this.label5.Location = new System.Drawing.Point(16, 124);\n            this.label5.Margin = new System.Windows.Forms.Padding(5, 0, 5, 0);\n            this.label5.Name = "label5";
            this.label5.Name = "label5";
            this.EncryptionSelect.Name = "EncryptionSelect";\n            this.panel2.Location = new System.Drawing.Point(246, 263);\n            this.panel2.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);
            this.panel2.Name = "panel2";\n            this.panel2.Size = new System.Drawing.Size(0, 0);\n            this.panel2.TabIndex = 1;\n            // \n            // OKButton\n            // \n            this.OKButton.DialogResult = System.Windows.Forms.DialogResult.OK;\n            this.OKButton.Location = new System.Drawing.Point(6, 6);\n            this.OKButton.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);\n            this.OKButton.Name = "OKButton";
            this.OKButton.Name = "OKButton";\n            this.MyCancelButton.Location = new System.Drawing.Point(130, 6);\n            this.MyCancelButton.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);\n            this.MyCancelButton.Name = "MyCancelButton";
            this.MyCancelButton.Name = "MyCancelButton";
            this.ShareOverLANItem,\n            this.ServersItem,\n            this.menuItem4,\n            this.editPACFileItem,\n            this.QRCodeItem,\n            this.ShowLogItem,\n            this.aboutItem,\n            this.menuItem3,\n            this.quitItem});\nthis.contextMenu1.Popup += new System.EventHandler(this.contextMenu1_Popup);
            this.menuItem4,\n            this.editPACFileItem,\n            this.QRCodeItem,\n            this.ShowLogItem,\n            this.aboutItem,\n            this.menuItem3,\n            this.quitItem});\nthis.contextMenu1.Popup += new System.EventHandler(this.contextMenu1_Popup);\n            // \n            // enableItem
            this.QRCodeItem,\n            this.ShowLogItem,\n            this.aboutItem,\n            this.menuItem3,\n            this.quitItem});\nthis.contextMenu1.Popup += new System.EventHandler(this.contextMenu1_Popup);\n            // \n            // enableItem\n            // \n            this.enableItem.Index = 0;
            // \n            // enableItem\n            // \n            this.enableItem.Index = 0;\n            this.enableItem.Text = "&Enable";\n            this.enableItem.Click += new System.EventHandler(this.EnableItem_Click);\n            // \n            // ShareOverLANItem\n            // \nthis.ShareOverLANItem.Index = 2;\n            this.ShareOverLANItem.Text = "Share over LAN";\n            this.ShareOverLANItem.Click += new System.EventHandler(this.ShareOverLANItem_Click);\n            // \nthis.ServersItem.Index = 3;
            this.ShareOverLANItem.Text = "Share over LAN";\n            this.ShareOverLANItem.Click += new System.EventHandler(this.ShareOverLANItem_Click);\n            // \n            // ServersItem\n            // \nthis.ServersItem.Index = 3;\n            this.ServersItem.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {\n            this.SeperatorItem,\n            this.ConfigItem});\n            this.ServersItem.Text = "&Servers";\n            // \n            // SeperatorItem\n            // 
            this.ServersItem.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {\n            this.SeperatorItem,\n            this.ConfigItem});\n            this.ServersItem.Text = "&Servers";\n            // \n            // SeperatorItem\n            // \n            this.SeperatorItem.Index = 0;\n            this.SeperatorItem.Text = "-";\n            // 
            this.DeleteButton.Name = "DeleteButton";\n            this.AddButton.Location = new System.Drawing.Point(6, 6);\n            this.AddButton.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);\n            this.AddButton.Name = "AddButton";
            this.AddButton.Name = "AddButton";\n            this.ServerGroupBox.Location = new System.Drawing.Point(334, 18);\n            this.ServerGroupBox.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);\n            this.ServerGroupBox.Name = "ServerGroupBox";
            this.ServerGroupBox.Name = "ServerGroupBox";\n            this.ServerGroupBox.Padding = new System.Windows.Forms.Padding(5, 5, 5, 5);\n            this.ServerGroupBox.Size = new System.Drawing.Size(383, 307);\n            this.ServerGroupBox.TabIndex = 6;\n            this.ServerGroupBox.TabStop = false;\n            this.ServerGroupBox.Text = "Server";\n            // \n            // ServersListBox\n            // \n            this.ServersListBox.FormattingEnabled = true;\n            this.ServersListBox.ItemHeight = 20;\n            this.ServersListBox.Location = new System.Drawing.Point(18, 18);\n            this.ServersListBox.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);
            this.ServerGroupBox.TabIndex = 6;\n            this.ServerGroupBox.TabStop = false;\n            this.ServerGroupBox.Text = "Server";\n            // \n            // ServersListBox\n            // \n            this.ServersListBox.FormattingEnabled = true;\n            this.ServersListBox.ItemHeight = 20;\n            this.ServersListBox.Location = new System.Drawing.Point(18, 18);\n            this.ServersListBox.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);\n            this.ServersListBox.Name = "ServersListBox";
            this.ServersListBox.Name = "ServersListBox";\n// \n// autoStartup\n// \nthis.autoStartup.Index = 1;\nthis.autoStartup.Text = "Start on boot";\nthis.autoStartup.Click += new System.EventHandler(this.autoStartup_Click);\n            // ConfigForm\n            // \n            this.AcceptButton = this.OKButton;
            // ConfigForm\n            // \n            this.AcceptButton = this.OKButton;
MessageBox.Show("Failed to edit registry");\n}\n}\nprivate void contextMenu1_Popup(object sender, EventArgs e) {\nautoStartup.Checked = AutoStartup.Check();\n}\n    }\n}
    }\n}
            _notifyIcon.BalloonTipClicked -= notifyIcon1_BalloonTipClicked;
using System.Collections;\nusing System.Collections.Generic;\nusing System.Net;\nusing System.Reflection;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing SimpleJson;
            {\n                int lp = (i < ls.Length) ? int.Parse(ls[i]) : 0;\n                int rp = (i < rs.Length) ? int.Parse(rs[i]) : 0;\n                if (lp != rp)\n                {\n                    return lp - rp;\n                }
            }\n            return 0;\n        }\n        public class VersionComparer : IComparer<string>\n        {\n            // Calls CaseInsensitiveComparer.Compare with the parameters reversed. \n            public int Compare(string x, string y)\n            {\n                return CompareVersion(ParseVersionFromURL(x), ParseVersionFromURL(y));\n            }
            {\n                return CompareVersion(ParseVersionFromURL(x), ParseVersionFromURL(y));\n            }\n        }\n        private static string ParseVersionFromURL(string url)\n        {\n            Match match = Regex.Match(url, @".*Shadowsocks-win.*?-([\d\.]+)\.\w+", RegexOptions.IgnoreCase);\n            if (match.Success)\n            {\n                if (match.Groups.Count == 2)
            }\n        }\n        private static string ParseVersionFromURL(string url)\n        {\n            Match match = Regex.Match(url, @".*Shadowsocks-win.*?-([\d\.]+)\.\w+", RegexOptions.IgnoreCase);\n            if (match.Success)\n            {\n                if (match.Groups.Count == 2)\n                {\n                    return match.Groups[1].Value;
        }\n        private void http_DownloadStringCompleted(object sender, DownloadStringCompletedEventArgs e)\n        {\n            try\n            {\n                string response = e.Result;\n                JsonArray result = (JsonArray)SimpleJson.SimpleJson.DeserializeObject(e.Result);\n                List<string> versions = new List<string>();\n                foreach (JsonObject release in result)\n                {
                foreach (JsonObject release in result)\n                {\n                    if ((bool)release["prerelease"])\n                    {\n                        continue;\n                    }\n                    foreach (JsonObject asset in (JsonArray)release["assets"])\n                    {\n                        string url = (string)asset["browser_download_url"];\n                        if (IsNewVersion(url))
                        {\n                            versions.Add(url);\n                        }\n                    }\n                }\n                if (versions.Count != 0)\n                {\n                    // sort versions\n                    SortVersions(versions);\n                    NewVersionFound = true;
                        }\n                    }\n                }\n                if (versions.Count != 0)\n                {\n                    // sort versions\n                    SortVersions(versions);\n                    NewVersionFound = true;\n                    LatestVersionURL = versions[versions.Count - 1];\n                    LatestVersionNumber = ParseVersionFromURL(LatestVersionURL);
                {\n                    // sort versions\n                    SortVersions(versions);\n                    NewVersionFound = true;\n                    LatestVersionURL = versions[versions.Count - 1];\n                    LatestVersionNumber = ParseVersionFromURL(LatestVersionURL);
                    NewVersionFound = true;\n                    LatestVersionURL = versions[versions.Count - 1];\n                    LatestVersionNumber = ParseVersionFromURL(LatestVersionURL);
                }\n                if (CheckUpdateCompleted != null)\n                {\n                    CheckUpdateCompleted(this, new EventArgs());\n                }\n            }\n            catch (Exception ex)\n            {\n                Logging.Debug(ex.ToString());\n                return;
            }\n        }\n    }\n}
        {\n            try\n            {\n                string pac = GetPACContent();\n                IPEndPoint localEndPoint = (IPEndPoint)socket.LocalEndPoint;\n                string proxy = GetPACAddress(firstPacket, length, localEndPoint);\n                pac = pac.Replace("__PROXY__", proxy);\n                string text = String.Format(@"HTTP/1.1 200 OK\nServer: Shadowsocks\nContent-Type: application/x-ns-proxy-autoconfig
                pac = pac.Replace("__PROXY__", proxy);\n                string text = String.Format(@"HTTP/1.1 200 OK\nServer: Shadowsocks\nContent-Type: application/x-ns-proxy-autoconfig\nContent-Length: {0}\nConnection: Close\n", System.Text.Encoding.UTF8.GetBytes(pac).Length) + pac;\n                byte[] response = System.Text.Encoding.UTF8.GetBytes(text);\n                socket.BeginSend(response, 0, response.Length, 0, new AsyncCallback(SendCallback), socket);\n                Util.Utils.ReleaseMemory();
        {\n            return "PROXY " + localEndPoint.Address + ":" + this._config.localPort + ";";\n        }\n    }\n}
        }\n    }\n}
                polipoConfig = polipoConfig.Replace("__POLIPO_BIND_IP__", configuration.shareOverLan ? "0.0.0.0" : "127.0.0.1");\n                FileManager.ByteArrayToFile(temppath + "/polipo.conf", System.Text.Encoding.UTF8.GetBytes(polipoConfig));\n                _process = new Process();\n                // Configure the process using the StartInfo properties.\n                _process.StartInfo.FileName = temppath + "/ss_polipo.exe";\n                _process.StartInfo.Arguments = "-c \"" + temppath + "/polipo.conf\"";\n                _process.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;\n                _process.StartInfo.UseShellExecute = true;\n                _process.StartInfo.CreateNoWindow = true;\n                //_process.StartInfo.RedirectStandardOutput = true;
                        Sysproxy.SetIEProxy(true, false, "", pacUrl);\n                    }\n                }\n                else\n                {\n                    Sysproxy.SetIEProxy(false, false, "", "");\n                }\n            }\n            catch (ProxyException ex)\n            {
                server =>\n                    new KeyValuePair<string, string>(server.URL, server.ToString())\n                ).ToList();\n            listBox1.DataSource = serverDatas;\n            var selectIndex = serverDatas.FindIndex(serverData => serverData.Key.StartsWith(code));\n            if (selectIndex >= 0) listBox1.SetSelected(selectIndex, true);\n        }\n        private void listBox1_SelectedIndexChanged(object sender, EventArgs e)\n        {\n            var url = (sender as ListBox)?.SelectedValue.ToString();
                ).ToList();\n            listBox1.DataSource = serverDatas;\n            var selectIndex = serverDatas.FindIndex(serverData => serverData.Key.StartsWith(code));\n            if (selectIndex >= 0) listBox1.SetSelected(selectIndex, true);\n        }\n        private void listBox1_SelectedIndexChanged(object sender, EventArgs e)\n        {\n            var url = (sender as ListBox)?.SelectedValue.ToString();\n            GenQR(url);\n            textBoxURL.Text = url;
            if (selectIndex >= 0) listBox1.SetSelected(selectIndex, true);\n        }\n        private void listBox1_SelectedIndexChanged(object sender, EventArgs e)\n        {\n            var url = (sender as ListBox)?.SelectedValue.ToString();\n            GenQR(url);\n            textBoxURL.Text = url;\n        }\n        private void textBoxURL_Click(object sender, EventArgs e)\n        {
                    string pluginPart = plugin;\n                    if (!string.IsNullOrWhiteSpace(plugin_opts))\n                    {\n                        pluginPart += ";" + plugin_opts;\n                    }\n                    url = string.Format(\n                        "{0}@{1}:{2}/?plugin={3}",\n                        websafeBase64,\n                        FormalHostName,\n                        server_port,
        }\n        public string FormalHostName\n        {\n            get\n            {\n                // CheckHostName() won't do a real DNS lookup\n                switch (Uri.CheckHostName(server))\n                {\n                    case UriHostNameType.IPv6:  // Add square bracket when IPv6 (RFC3986)\n                        return $"[{server}]";
            Func<string, object, bool> onLineRead, Action<Exception, object> onException,\n            Action<byte[], int, int, object> onFinish,\n            Encoding encoding, string delimiter,\n            object state)\n        {\n            if (buffer == null)\n            {\n                throw new ArgumentNullException(nameof(buffer));\n            }\n            if (socket == null)
            object state)\n        {\n            if (buffer == null)\n            {\n                throw new ArgumentNullException(nameof(buffer));\n            }\n            if (socket == null)\n            {\n                throw new ArgumentNullException(nameof(socket));\n            }
            if (socket == null)\n            {\n                throw new ArgumentNullException(nameof(socket));\n            }\n            if (onLineRead == null)\n            {\n                throw new ArgumentNullException(nameof(onLineRead));\n            }\n            if (encoding == null)\n            {
            {\n                throw new ArgumentException("Line buffer length can't less than first package length!", nameof(buffer));\n            }\n            if (length > 0)\n            {\n                if (firstPackge == null)\n                {\n                    throw new ArgumentNullException(nameof(firstPackge));\n                }\n            }
            }\n            if (length > 0)\n            {\n                if (firstPackge == null)\n                {\n                    throw new ArgumentNullException(nameof(firstPackge));\n                }\n            }\n            _socket = socket;\n            _onLineRead = onLineRead;
            {\n                throw new ArgumentException("Too small!", nameof(buffer));\n            }\n            _delimiterSearch = new ByteSearch.SearchTarget(_delimiterBytes);\n            _lineBuffer = buffer;\n            if (length > 0)\n            {\n                // process first package\n                if (buffer == firstPackge)\n                {\n                    _bufferDataIndex = index;
            }\n            _delimiterSearch = new ByteSearch.SearchTarget(_delimiterBytes);\n            _lineBuffer = buffer;\n            if (length > 0)\n            {\n                // process first package\n                if (buffer == firstPackge)\n                {\n                    _bufferDataIndex = index;\n                }\n                else
            if (length > 0)\n            {\n                // process first package\n                if (buffer == firstPackge)\n                {\n                    _bufferDataIndex = index;\n                }\n                else\n                {\n                    Array.Copy(firstPackge, index, _lineBuffer, 0, length);\n                }
                _bufferDataLength = length;\n                try\n                {\n                    NewPackageRecv();\n                }\n                catch (Exception ex)\n                {\n                    OnException(ex);\n                    OnFinish();\n                }
            }\n        }\n        public LineReader(int maxLineBytes, WrappedSocket socket, Func<string, object, bool> onLineRead,\n            Action<Exception, object> onException, Action<byte[], int, int, object> onFinish, Encoding encoding,\n            string delimiter, object state)\n            : this(\n                new byte[maxLineBytes], socket, null, 0, 0, onLineRead, onException, onFinish, encoding, delimiter,\n                state)
        {\n        }\n        private void ReceiveCallback(IAsyncResult ar)\n        {\n            try\n            {\n                var bytesRead = _socket.EndReceive(ar);\n                if (bytesRead == 0)\n                {\n                    OnFinish();
                    }\n                    else\n                    {\n                        string pacUrl;\n                        if (config.useOnlinePac && !config.pacUrl.IsNullOrEmpty())\n                            pacUrl = config.pacUrl;\n                        else\n                            pacUrl = $"http://127.0.0.1:{config.localPort}/pac?t={GetTimestamp(DateTime.Now)}{pacSrv.PacSecret}";\n                        WinINet.SetIEProxy(true, false, "", pacUrl);\n                    }
                if (ssURLAssociation == null)\n                {
                string configContent = File.ReadAllText(CONFIG_FILE);\n                Configuration config = SimpleJson.SimpleJson.DeserializeObject<Configuration>(configContent);\n                config.isDefault = false;\n                return config;\n            }\n            catch (Exception e)\n            {\n                if (!(e is FileNotFoundException))\n                {\n                    Console.WriteLine(e);
                config.isDefault = false;\n                return config;\n            }\n            catch (Exception e)\n            {\n                if (!(e is FileNotFoundException))\n                {\n                    Console.WriteLine(e);\n                }\n                return new Configuration
            using (Graphics g = Graphics.FromImage(drawArea))\n            {\n                g.Clear(Color.White);\n                using (Brush b = new SolidBrush(Color.Black))\n                {\n                    for (int row = 0; row < qrCoded.GetModuleCount(); row++)\n                    {\n                        for (int col = 0; col < qrCoded.GetModuleCount(); col++)\n                        {\n                            if (qrCoded.IsDark(row, col))
                    {\n                        for (int col = 0; col < qrCoded.GetModuleCount(); col++)\n                        {\n                            if (qrCoded.IsDark(row, col))\n                            {\n                                g.FillRectangle(b, blockSize * row, blockSize * col, blockSize, blockSize);\n                            }\n                        }\n                    }\n                }
                        {\n                            if (qrCoded.IsDark(row, col))\n                            {\n                                g.FillRectangle(b, blockSize * row, blockSize * col, blockSize, blockSize);\n                            }\n                        }\n                    }\n                }\n            }\n            pictureBox1.Image = drawArea;
                            {\n                                g.FillRectangle(b, blockSize * row, blockSize * col, blockSize, blockSize);\n                            }\n                        }\n                    }\n                }\n            }\n            pictureBox1.Image = drawArea;\n        }\n        private void QRCodeForm_Load(object sender, EventArgs e)
        }\n        private MenuItem CreateMenuGroup(string text, MenuItem[] items)\n        {\n            for (int i = 0; i < items.Length; i++)\n            {\n                items[i].Index = i;\n            }\n            MenuItem result = new MenuItem(I18N.GetString(text), items);\n            return result;
        }\n        private void LoadMenu()\n        {\n            this.contextMenu1 = new System.Windows.Forms.ContextMenu();\n            this.contextMenu1.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {\n                this.enableItem = CreateMenuItem("Enable", new System.EventHandler(this.EnableItem_Click)),\n                CreateMenuGroup("Mode", new System.Windows.Forms.MenuItem[] {\n                    this.PACModeItem = CreateMenuItem("PAC", new System.EventHandler(this.PACModeItem_Click)),\n                    this.globalModeItem = CreateMenuItem("Global", new System.EventHandler(this.GlobalModeItem_Click))\n                }),
                    this.ConfigItem = CreateMenuItem("Edit Servers...", new System.EventHandler(this.Config_Click))\n                }),\n                CreateSeperatorItem(),\n                this.AutoStartupItem = CreateMenuItem("Start on Boot", new System.EventHandler(this.AutoStartupItem_Click)),\n                this.ShareOverLANItem = CreateMenuItem("Share over LAN", new System.EventHandler(this.ShareOverLANItem_Click)),\n                CreateMenuItem("Edit PAC File...", new System.EventHandler(this.EditPACFileItem_Click)),\n                CreateSeperatorItem(),\n                CreateMenuItem("Show QRCode...", new System.EventHandler(this.QRCodeItem_Click)),\n                CreateMenuItem("Show Logs...", new System.EventHandler(this.ShowLogItem_Click)),\n                CreateMenuItem("About...", new System.EventHandler(this.Config_Click)),
                this.AutoStartupItem = CreateMenuItem("Start on Boot", new System.EventHandler(this.AutoStartupItem_Click)),\n                this.ShareOverLANItem = CreateMenuItem("Share over LAN", new System.EventHandler(this.ShareOverLANItem_Click)),\n                CreateMenuItem("Edit PAC File...", new System.EventHandler(this.EditPACFileItem_Click)),\n                CreateSeperatorItem(),\n                CreateMenuItem("Show QRCode...", new System.EventHandler(this.QRCodeItem_Click)),\n                CreateMenuItem("Show Logs...", new System.EventHandler(this.ShowLogItem_Click)),\n                CreateMenuItem("About...", new System.EventHandler(this.Config_Click)),\n                CreateSeperatorItem(),\n                CreateMenuItem("Quit", new System.EventHandler(this.Quit_Click))\n            });
                CreateMenuItem("Show QRCode...", new System.EventHandler(this.QRCodeItem_Click)),\n                CreateMenuItem("Show Logs...", new System.EventHandler(this.ShowLogItem_Click)),\n                CreateMenuItem("About...", new System.EventHandler(this.Config_Click)),\n                CreateSeperatorItem(),\n                CreateMenuItem("Quit", new System.EventHandler(this.Quit_Click))\n            });\n        }\n        private void controller_ConfigChanged(object sender, EventArgs e)\n        {\n            LoadCurrentConfiguration();
                CreateMenuItem("Quit", new System.EventHandler(this.Quit_Click))\n            });\n        }\n        private void controller_ConfigChanged(object sender, EventArgs e)\n        {\n            LoadCurrentConfiguration();\n            UpdateTrayIcon();\n        }\n        private void controller_EnableStatusChanged(object sender, EventArgs e)\n        {
        {\n            byte[] bytes = Convert.FromBase64String(response);\n            string content = Encoding.ASCII.GetString(bytes);\n            List<string> valid_lines = new List<string>();\n            using (var sr = new StringReader(content))\n            {
                }\n                else\n                {\n                    arguments = "pac " + pacURL;\n                }\n            }\n            else\n            {\n                arguments = "off";\n            }
                }\n            }\n            else\n            {\n                arguments = "off";\n            }\n            using (var process = new Process())\n            {\n                // Configure the process using the StartInfo properties.\n                process.StartInfo.FileName = Utils.GetTempPath("sysproxy.exe");
            controller.EnableStatusChanged += controller_EnableStatusChanged;\n            controller.ConfigChanged += controller_ConfigChanged;\n            controller.PACFileReadyToOpen += controller_PACFileReadyToOpen;\n            controller.ShareOverLANStatusChanged += controller_ShareOverLANStatusChanged;\n            controller.EnableGlobalChanged += controller_EnableGlobalChanged;\n            controller.Errored += controller_Errored;
            this.enableItem.Click += new System.EventHandler(this.EnableItem_Click);\n            //\n            // modeMenu\n            //\n            this.modeItem.Index = 1;\n            this.modeItem.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {\n            this.PACModeItem,\n            this.globalModeItem});\n            this.modeItem.Text = "Mode";\n            //\n            // PACModeItem\n            //\n            this.PACModeItem.Index = 0;\n            this.PACModeItem.Text = "PAC";\n            this.PACModeItem.Click += new System.EventHandler(this.PACModeItem_Click);\n            //
            //\n            // PACModeItem\n            //\n            this.PACModeItem.Index = 0;\n            this.PACModeItem.Text = "PAC";\n            this.PACModeItem.Click += new System.EventHandler(this.PACModeItem_Click);\n            //\n            // globalModeItem\n            //\n            this.globalModeItem.Index = 1;\n            this.globalModeItem.Text = "Global";\n            this.globalModeItem.Click += new System.EventHandler(this.GlobalModeItem_Click);\n            // \n            // ServersItem\n            // \n            this.ServersItem.Index = 2;
            this.PACModeItem.Click += new System.EventHandler(this.PACModeItem_Click);\n            //\n            // globalModeItem\n            //\n            this.globalModeItem.Index = 1;\n            this.globalModeItem.Text = "Global";\n            this.globalModeItem.Click += new System.EventHandler(this.GlobalModeItem_Click);\n            // \n            // ServersItem\n            // \n            this.ServersItem.Index = 2;\n            this.ServersItem.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {\n            this.SeperatorItem,\n            this.ServersItem.Text = "&Servers";\n            // 
            this.globalModeItem.Click += new System.EventHandler(this.GlobalModeItem_Click);\n            // \n            // ServersItem\n            // \n            this.ServersItem.Index = 2;\n            this.ServersItem.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {\n            this.SeperatorItem,\n            this.ConfigItem});\n            this.ServersItem.Text = "&Servers";\n            // \n            // SeperatorItem\n            // \n            this.SeperatorItem.Index = 0;\n            this.ConfigItem.Text = "Edit Servers...";
            // \n            // SeperatorItem\n            // \n            this.SeperatorItem.Index = 0;\n            this.SeperatorItem.Text = "-";\n            // \n            // ConfigItem\n            // \n            this.ConfigItem.Index = 1;\n            this.ConfigItem.Text = "Edit Servers...";\n            this.ConfigItem.Click += new System.EventHandler(this.Config_Click);\n            // \n            // menuItem1\n            // \n            this.menuItem1.Index = 3;\n            this.menuItem1.Text = "-";\n            this.AutoStartupItem.Text = "Start on Boot";\n            this.AutoStartupItem.Click += new System.EventHandler(this.AutoStartupItem_Click);
            this.ConfigItem.Click += new System.EventHandler(this.Config_Click);\n            // \n            // menuItem1\n            // \n            this.menuItem1.Index = 3;\n            this.menuItem1.Text = "-";\n            // \n            // AutoStartupItem\n            // \n            this.AutoStartupItem.Index = 4;\n            this.AutoStartupItem.Text = "Start on Boot";\n            this.AutoStartupItem.Click += new System.EventHandler(this.AutoStartupItem_Click);\n            // \n            // ShareOverLANItem\n            // \n            this.ShareOverLANItem.Index = 5;\n            this.ShareOverLANItem.Text = "Share over LAN";\n            this.ShareOverLANItem.Click += new System.EventHandler(this.ShareOverLANItem_Click);\n            // 
            this.AutoStartupItem.Click += new System.EventHandler(this.AutoStartupItem_Click);\n            // \n            // ShareOverLANItem\n            // \n            this.ShareOverLANItem.Index = 5;\n            this.ShareOverLANItem.Text = "Share over LAN";\n            this.ShareOverLANItem.Click += new System.EventHandler(this.ShareOverLANItem_Click);\n            // \n            // editPACFileItem\n            // \n            this.editPACFileItem.Index = 6;\n            this.editPACFileItem.Text = "Edit &PAC File...";\n            this.editPACFileItem.Click += new System.EventHandler(this.EditPACFileItem_Click);\n            // \n            // menuItem4\n            // 
            this.ShareOverLANItem.Click += new System.EventHandler(this.ShareOverLANItem_Click);\n            // \n            // editPACFileItem\n            // \n            this.editPACFileItem.Index = 6;\n            this.editPACFileItem.Text = "Edit &PAC File...";\n            this.editPACFileItem.Click += new System.EventHandler(this.EditPACFileItem_Click);\n            // \n            // menuItem4\n            // \n            this.menuItem4.Index = 7;\n            this.menuItem4.Text = "-";\n            // \n            this.QRCodeItem.Text = "Show &QRCode...";\n            this.QRCodeItem.Click += new System.EventHandler(this.QRCodeItem_Click);\n            // 
            this.editPACFileItem.Click += new System.EventHandler(this.EditPACFileItem_Click);\n            // \n            // menuItem4\n            // \n            this.menuItem4.Index = 7;\n            this.menuItem4.Text = "-";\n            // \n            // QRCodeItem\n            // \n            this.QRCodeItem.Index = 8;\n            this.QRCodeItem.Text = "Show &QRCode...";\n            this.QRCodeItem.Click += new System.EventHandler(this.QRCodeItem_Click);\n            // \n            // ShowLogItem\n            // \n            this.ShowLogItem.Index = 9;\n            this.ShowLogItem.Text = "Show Logs...";\n            this.ShowLogItem.Click += new System.EventHandler(this.ShowLogItem_Click);\n            // 
            this.QRCodeItem.Click += new System.EventHandler(this.QRCodeItem_Click);\n            // \n            // ShowLogItem\n            // \n            this.ShowLogItem.Index = 9;\n            this.ShowLogItem.Text = "Show Logs...";\n            this.ShowLogItem.Click += new System.EventHandler(this.ShowLogItem_Click);\n            // \n            // aboutItem\n            // \n            this.aboutItem.Index = 10;\n            this.aboutItem.Text = "About...";\n            this.aboutItem.Click += new System.EventHandler(this.AboutItem_Click);\n            // \n            // menuItem3\n            // 
            this.ShowLogItem.Click += new System.EventHandler(this.ShowLogItem_Click);\n            // \n            // aboutItem\n            // \n            this.aboutItem.Index = 10;\n            this.aboutItem.Text = "About...";\n            this.aboutItem.Click += new System.EventHandler(this.AboutItem_Click);\n            // \n            // menuItem3\n            // \n            this.menuItem3.Index = 11;\n            this.menuItem3.Text = "-";\n            // \n            this.quitItem.Text = "&Quit";\n            this.quitItem.Click += new System.EventHandler(this.Quit_Click);\n        }
            this.aboutItem.Click += new System.EventHandler(this.AboutItem_Click);\n            // \n            // menuItem3\n            // \n            this.menuItem3.Index = 11;\n            this.menuItem3.Text = "-";\n            // \n            // quitItem\n            // \n            this.quitItem.Index = 12;\n            this.quitItem.Text = "&Quit";\n            this.quitItem.Click += new System.EventHandler(this.Quit_Click);\n        }\n        private void controller_ConfigChanged(object sender, EventArgs e)\n        {\n            LoadCurrentConfiguration();
            this.quitItem.Click += new System.EventHandler(this.Quit_Click);\n        }\n        private void controller_ConfigChanged(object sender, EventArgs e)\n        {\n            LoadCurrentConfiguration();\n        }\n        private void controller_EnableStatusChanged(object sender, EventArgs e)\n        {\n            enableItem.Checked = controller.GetConfiguration().enabled;
            this.ProxyPortTextBox = new System.Windows.Forms.TextBox();\n            this.label4 = new System.Windows.Forms.Label();\n            this.label3 = new System.Windows.Forms.Label();\n            this.IPTextBox = new System.Windows.Forms.TextBox();\n            this.ServerPortTextBox = new System.Windows.Forms.TextBox();\n            this.PasswordTextBox = new System.Windows.Forms.TextBox();\n            this.label5 = new System.Windows.Forms.Label();\n            this.EncryptionSelect = new System.Windows.Forms.ComboBox();\n            this.panel2 = new System.Windows.Forms.Panel();\n            this.OKButton = new System.Windows.Forms.Button();
            this.IPTextBox = new System.Windows.Forms.TextBox();\n            this.ServerPortTextBox = new System.Windows.Forms.TextBox();\n            this.PasswordTextBox = new System.Windows.Forms.TextBox();\n            this.label5 = new System.Windows.Forms.Label();\n            this.EncryptionSelect = new System.Windows.Forms.ComboBox();\n            this.panel2 = new System.Windows.Forms.Panel();\n            this.OKButton = new System.Windows.Forms.Button();\n            this.MyCancelButton = new System.Windows.Forms.Button();\n            this.panel1 = new System.Windows.Forms.Panel();\n            this.panel3 = new System.Windows.Forms.Panel();
            this.EncryptionSelect = new System.Windows.Forms.ComboBox();\n            this.panel2 = new System.Windows.Forms.Panel();\n            this.OKButton = new System.Windows.Forms.Button();\n            this.MyCancelButton = new System.Windows.Forms.Button();\n            this.panel1 = new System.Windows.Forms.Panel();\n            this.panel3 = new System.Windows.Forms.Panel();\n            this.DeleteButton = new System.Windows.Forms.Button();\n            this.AddButton = new System.Windows.Forms.Button();\n            this.ServerGroupBox = new System.Windows.Forms.GroupBox();\n            this.ServersListBox = new System.Windows.Forms.ListBox();
            this.tableLayoutPanel1.Controls.Add(this.ProxyPortTextBox, 1, 4);\n            this.tableLayoutPanel1.Controls.Add(this.label4, 0, 4);\n            this.tableLayoutPanel1.Controls.Add(this.label3, 0, 2);\n            this.tableLayoutPanel1.Controls.Add(this.IPTextBox, 1, 0);\n            this.tableLayoutPanel1.Controls.Add(this.ServerPortTextBox, 1, 1);\n            this.tableLayoutPanel1.Controls.Add(this.PasswordTextBox, 1, 2);\n            this.tableLayoutPanel1.Controls.Add(this.label5, 0, 3);\n            this.tableLayoutPanel1.Controls.Add(this.EncryptionSelect, 1, 3);\n            this.tableLayoutPanel1.Location = new System.Drawing.Point(8, 21);\n            this.tableLayoutPanel1.Margin = new System.Windows.Forms.Padding(5);
            this.tableLayoutPanel1.Controls.Add(this.IPTextBox, 1, 0);\n            this.tableLayoutPanel1.Controls.Add(this.ServerPortTextBox, 1, 1);\n            this.tableLayoutPanel1.Controls.Add(this.PasswordTextBox, 1, 2);\n            this.tableLayoutPanel1.Controls.Add(this.label5, 0, 3);\n            this.tableLayoutPanel1.Controls.Add(this.EncryptionSelect, 1, 3);\n            this.tableLayoutPanel1.Location = new System.Drawing.Point(8, 21);\n            this.tableLayoutPanel1.Margin = new System.Windows.Forms.Padding(5);\n            this.tableLayoutPanel1.Name = "tableLayoutPanel1";\n            this.tableLayoutPanel1.Padding = new System.Windows.Forms.Padding(5);\n            this.tableLayoutPanel1.RowCount = 6;
            this.tableLayoutPanel1.Controls.Add(this.EncryptionSelect, 1, 3);\n            this.tableLayoutPanel1.Location = new System.Drawing.Point(8, 21);\n            this.tableLayoutPanel1.Margin = new System.Windows.Forms.Padding(5);\n            this.tableLayoutPanel1.Name = "tableLayoutPanel1";\n            this.tableLayoutPanel1.Padding = new System.Windows.Forms.Padding(5);\n            this.tableLayoutPanel1.RowCount = 6;\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());
            // \n            // ProxyPortTextBox\n            // \n            this.ProxyPortTextBox.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));\n            this.ProxyPortTextBox.Location = new System.Drawing.Point(74, 113);\n            this.ProxyPortTextBox.Name = "ProxyPortTextBox";\n            this.ProxyPortTextBox.Size = new System.Drawing.Size(160, 20);\n            this.ProxyPortTextBox.TabIndex = 4;\n            this.ProxyPortTextBox.WordWrap = false;\n            // \n            // label4\n            // \n            this.label4.Anchor = System.Windows.Forms.AnchorStyles.Right;\n            this.label4.AutoSize = true;
            // \n            // IPTextBox\n            // \n            this.IPTextBox.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));\n            this.IPTextBox.Location = new System.Drawing.Point(74, 8);\n            this.IPTextBox.Name = "IPTextBox";\n            this.IPTextBox.Size = new System.Drawing.Size(160, 20);\n            this.IPTextBox.TabIndex = 0;\n            this.IPTextBox.WordWrap = false;\n            // 
        private System.Windows.Forms.TextBox IPTextBox;\n        private System.Windows.Forms.TextBox ServerPortTextBox;\n        private System.Windows.Forms.TextBox PasswordTextBox;\n        private System.Windows.Forms.TextBox ProxyPortTextBox;\n        private System.Windows.Forms.Label label5;\n        private System.Windows.Forms.ComboBox EncryptionSelect;\n        private System.Windows.Forms.Panel panel2;\n        private System.Windows.Forms.Button OKButton;\n        private System.Windows.Forms.Button MyCancelButton;\n        private System.Windows.Forms.Panel panel1;
        private System.Windows.Forms.ComboBox EncryptionSelect;\n        private System.Windows.Forms.Panel panel2;\n        private System.Windows.Forms.Button OKButton;\n        private System.Windows.Forms.Button MyCancelButton;\n        private System.Windows.Forms.Panel panel1;\n        private System.Windows.Forms.Panel panel3;\n        private System.Windows.Forms.Button DeleteButton;\n        private System.Windows.Forms.Button AddButton;\n        private System.Windows.Forms.GroupBox ServerGroupBox;\n        private System.Windows.Forms.ListBox ServersListBox;
            LoadConfiguration(_modifiedConfiguration);\n            ServersListBox.SelectedIndex = _modifiedConfiguration.configs.Count - 1;\n            _lastSelectedIndex = ServersListBox.SelectedIndex;\n        }\n        private void DeleteButton_Click(object sender, EventArgs e)\n        {\n            _lastSelectedIndex = ServersListBox.SelectedIndex;\n            if (_lastSelectedIndex >= 0 && _lastSelectedIndex < _modifiedConfiguration.configs.Count)\n            {\n                _modifiedConfiguration.configs.RemoveAt(_lastSelectedIndex);
            _lastSelectedIndex = ServersListBox.SelectedIndex;\n        }\n        private void DeleteButton_Click(object sender, EventArgs e)\n        {\n            _lastSelectedIndex = ServersListBox.SelectedIndex;\n            if (_lastSelectedIndex >= 0 && _lastSelectedIndex < _modifiedConfiguration.configs.Count)\n            {\n                _modifiedConfiguration.configs.RemoveAt(_lastSelectedIndex);\n            }\n            if (_lastSelectedIndex >= _modifiedConfiguration.configs.Count)
            }\n            catch (IOException e)\n            {\n                Console.WriteLine(e.ToString());\n            }\n            LoadLibrary(dllPath);
            {\n                Console.WriteLine(e.ToString());\n            }\n            LoadLibrary(dllPath);\n        }\n        [DllImport("Kernel32.dll")]\n        private static extern IntPtr LoadLibrary(string path);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void aes_init(IntPtr ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
        }\n        [DllImport("Kernel32.dll")]\n        private static extern IntPtr LoadLibrary(string path);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void aes_init(IntPtr ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void aes_free(IntPtr ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int aes_setkey_enc(IntPtr ctx, byte[] key, int keysize);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
            get {\n                object obj = ResourceManager.GetObject("libsodium_dll", resourceCulture);\n                return ((byte[])(obj));\n            }\n        }\n        /// <summary>\n        ///   Looks up a localized resource of type System.Byte[].\n        /// </summary>\n        internal static byte[] polarssl_dll {\n            get {\n                return ((byte[])(obj));\n            }
                return ((byte[])(obj));\n            }\n        }\n        /// <summary>\n        ///   Looks up a localized string similar to proxyAddress = &quot;__POLIPO_BIND_IP__&quot;\n        ///\n        ///socksParentProxy = &quot;127.0.0.1:__SOCKS_PORT__&quot;\n        ///socksProxyType = socks5\n        ///diskCacheRoot = &quot;&quot;\n        ///localDocumentRoot = &quot;&quot;
            }\n            catch (IOException e)\n            {\n                Console.WriteLine(e.ToString());\n            }\n            LoadLibrary(dllPath);
            {\n                Console.WriteLine(e.ToString());\n            }\n            LoadLibrary(dllPath);\n        }\n        [DllImport("Kernel32.dll")]\n        private static extern IntPtr LoadLibrary(string path);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void crypto_stream_salsa20_xor_ic(byte[] c, byte[] m, ulong mlen, byte[] n, ulong ic, byte[] k);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
        }\n        [DllImport("Kernel32.dll")]\n        private static extern IntPtr LoadLibrary(string path);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void crypto_stream_salsa20_xor_ic(byte[] c, byte[] m, ulong mlen, byte[] n, ulong ic, byte[] k);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void crypto_stream_chacha20_xor_ic(byte[] c, byte[] m, ulong mlen, byte[] n, ulong ic, byte[] k);\n    }\n}
        }\n        private void LogForm_FormClosing(object sender, FormClosingEventArgs e)\n        {\n            timer.Stop();
                    }\n                }\n                else\n                {\n                    if (line.IsNullOrEmpty())\n                    {\n                        _headers.Enqueue("");\n                        return true;\n                    }\n                    if (!line.StartsWith("Proxy-"))
                        return true;\n                    }\n                    if (!line.StartsWith("Proxy-"))\n                    {\n                        _headers.Enqueue(line);\n                    }\n                    if (!_isConnect)\n                    {\n                        if (line.StartsWith("Host: "))\n                        {
                    }\n                    if (!_isConnect)\n                    {\n                        if (line.StartsWith("Host: "))\n                        {\n                            var location = line.Substring(6).Trim();\n                            var locs = location.Split(':');\n                            _targetHost = locs[0];\n                            if (locs.Length > 1)\n                            {
            {\n                var key = _keymap.First(x => x.Value == cb).Key;\n                hotkey = key;\n                return true;\n            }\n            catch (InvalidOperationException)\n            {
                return true;\n            }\n            catch (InvalidOperationException)\n            {
            {
        private void CancelButton_Click(object sender, EventArgs e)\n        {\n            this.Close();\n        }\n        private void OKButton_Click(object sender, EventArgs e)\n        {\n            // try to register, notify to change settings if failed\n            if (!RegisterAllHotkeys())\n            {\n                MessageBox.Show(I18N.GetString("Register hotkey failed"));
            {\n                MessageBox.Show(I18N.GetString("Register hotkey failed"));\n            }\n            // All check passed, saving\n            SaveConfig();\n            this.Close();\n        }\n        private void RegisterAllButton_Click(object sender, EventArgs e)\n        {\n            RegisterAllHotkeys();\n        }
        }\n        private static void UnregPrevHotkey(HotKeys.HotKeyCallBackHandler cb)\n        {\n            GlobalHotKey.HotKey prevHotKey;\n            if (HotKeys.IsCallbackExists(cb, out prevHotKey))\n            {\n                // unregister previous one\n                HotKeys.Unregister(prevHotKey);\n            }\n        }\n        #region Prepare hotkey
    }\n}
            this.SwitchSystemProxyTextBox.KeyDown += new System.Windows.Forms.KeyEventHandler(this.HotkeyDown);\n            this.SwitchSystemProxyTextBox.KeyUp += new System.Windows.Forms.KeyEventHandler(this.HotkeyUp);\n            // \n            // SwitchProxyModeTextBox\n            // \n            this.SwitchProxyModeTextBox.Dock = System.Windows.Forms.DockStyle.Fill;\n            this.SwitchProxyModeTextBox.Location = new System.Drawing.Point(208, 37);\n            this.SwitchProxyModeTextBox.Margin = new System.Windows.Forms.Padding(3, 3, 16, 3);\n            this.SwitchProxyModeTextBox.Name = "SwitchProxyModeTextBox";\n            this.SwitchProxyModeTextBox.ReadOnly = true;\n            this.SwitchProxyModeTextBox.TextChanged += new System.EventHandler(this.TextBox_TextChanged);
            this.SwitchProxyModeTextBox.KeyDown += new System.Windows.Forms.KeyEventHandler(this.HotkeyDown);\n            this.SwitchProxyModeTextBox.KeyUp += new System.Windows.Forms.KeyEventHandler(this.HotkeyUp);\n            // \n            // SwitchAllowLanTextBox\n            // \n            this.SwitchAllowLanTextBox.Dock = System.Windows.Forms.DockStyle.Fill;\n            this.SwitchAllowLanTextBox.Location = new System.Drawing.Point(208, 71);\n            this.SwitchAllowLanTextBox.Margin = new System.Windows.Forms.Padding(3, 3, 16, 3);\n            this.SwitchAllowLanTextBox.Name = "SwitchAllowLanTextBox";\n            this.SwitchAllowLanTextBox.ReadOnly = true;\n            this.SwitchAllowLanTextBox.TextChanged += new System.EventHandler(this.TextBox_TextChanged);
            this.SwitchAllowLanTextBox.KeyDown += new System.Windows.Forms.KeyEventHandler(this.HotkeyDown);\n            this.SwitchAllowLanTextBox.KeyUp += new System.Windows.Forms.KeyEventHandler(this.HotkeyUp);\n            // \n            // ShowLogsTextBox\n            // \n            this.ShowLogsTextBox.Dock = System.Windows.Forms.DockStyle.Fill;\n            this.ShowLogsTextBox.Location = new System.Drawing.Point(208, 105);\n            this.ShowLogsTextBox.Margin = new System.Windows.Forms.Padding(3, 3, 16, 3);\n            this.ShowLogsTextBox.Name = "ShowLogsTextBox";\n            this.ShowLogsTextBox.ReadOnly = true;\n            this.ShowLogsTextBox.TextChanged += new System.EventHandler(this.TextBox_TextChanged);
            this.ShowLogsTextBox.KeyDown += new System.Windows.Forms.KeyEventHandler(this.HotkeyDown);\n            this.ShowLogsTextBox.KeyUp += new System.Windows.Forms.KeyEventHandler(this.HotkeyUp);\n            // \n            // ServerMoveUpTextBox\n            // \n            this.ServerMoveUpTextBox.Dock = System.Windows.Forms.DockStyle.Fill;\n            this.ServerMoveUpTextBox.Location = new System.Drawing.Point(208, 139);\n            this.ServerMoveUpTextBox.Margin = new System.Windows.Forms.Padding(3, 3, 16, 3);\n            this.ServerMoveUpTextBox.Name = "ServerMoveUpTextBox";\n            this.ServerMoveUpTextBox.ReadOnly = true;\n            this.ServerMoveUpTextBox.TextChanged += new System.EventHandler(this.TextBox_TextChanged);
            this.ServerMoveUpTextBox.KeyDown += new System.Windows.Forms.KeyEventHandler(this.HotkeyDown);\n            this.ServerMoveUpTextBox.KeyUp += new System.Windows.Forms.KeyEventHandler(this.HotkeyUp);\n            // \n            // ServerMoveDownTextBox\n            // \n            this.ServerMoveDownTextBox.Dock = System.Windows.Forms.DockStyle.Fill;\n            this.ServerMoveDownTextBox.Location = new System.Drawing.Point(208, 174);\n            this.ServerMoveDownTextBox.Margin = new System.Windows.Forms.Padding(3, 3, 16, 3);\n            this.ServerMoveDownTextBox.Name = "ServerMoveDownTextBox";\n            this.ServerMoveDownTextBox.ReadOnly = true;\n            this.ServerMoveDownTextBox.TextChanged += new System.EventHandler(this.TextBox_TextChanged);

        {\n            _controller = controller;\n            Handlers = new HashSet<TCPHandler>();\n            _lastSweepTime = DateTime.Now;\n        }\n        public bool Handle(byte[] firstPacket, int length, Socket socket, object state)\n        {\n            if (socket.ProtocolType != ProtocolType.Tcp)\n            {
        public Socket connection;\n        public ShadowsocksController controller;\n        public TCPRelay relay;\n        public DateTime lastActivity;\n        private const int maxRetry = 4;\n        private int retryCount = 0;\n        private bool connected;\n        private byte command;
        private byte command;\n        private byte[] _firstPacket;\n        private int _firstPacketLength;\n        // Size of receive buffer.\n        public const int RecvSize = 8192;\n        public const int RecvReserveSize = IVEncryptor.ONETIMEAUTH_BYTES + IVEncryptor.AUTH_BYTES; // reserve for one-time auth\n        public const int BufferSize = RecvSize + RecvReserveSize + 32;\n        private int totalRead = 0;\n        private int totalWrite = 0;\n        // remote receive buffer
                    connection.BeginReceive(connetionRecvBuffer, 0, RecvSize, 0, new AsyncCallback(ReadAll), null);\n                }\n                else\n                {\n                    int bytesRead = connection.EndReceive(ar);\n                    if (bytesRead > 0)\n                    {\n                        Logging.Debug(remote, RecvSize, "TCP Relay");\n                        connection.BeginReceive(connetionRecvBuffer, 0, RecvSize, 0, new AsyncCallback(ReadAll), null);\n                    }
                        connection.BeginReceive(connetionRecvBuffer, 0, RecvSize, 0, new AsyncCallback(ReadAll), null);\n                    }\n                    else\n                    {\n                        Close();\n                    }\n                }\n            }\n            catch (Exception e)\n            {
                _startConnectTime = DateTime.Now;\n                ServerTimer connectTimer = new ServerTimer(3000);\n                connectTimer.AutoReset = false;\n                connectTimer.Elapsed += connectTimer_Elapsed;\n                connectTimer.Enabled = true;\n                connectTimer.Server = server;\n                connected = false;\n                // Connect to the remote endpoint.\n                remote.BeginConnect(remoteEP, new AsyncCallback(ConnectCallback), connectTimer);\n            }\n            catch (Exception e)
                connectTimer.Enabled = true;\n                connectTimer.Server = server;\n                connected = false;\n                // Connect to the remote endpoint.\n                remote.BeginConnect(remoteEP, new AsyncCallback(ConnectCallback), connectTimer);\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }
                // Connect to the remote endpoint.\n                remote.BeginConnect(remoteEP, new AsyncCallback(ConnectCallback), connectTimer);\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void connectTimer_Elapsed(object sender, ElapsedEventArgs e)\n        {
            {\n                return;\n            }\n            Server server = ((ServerTimer)sender).Server;\n            IStrategy strategy = controller.GetCurrentStrategy();\n            if (strategy != null)\n            {\n                strategy.SetFailure(server);\n            }\n            Logging.Info($"{server.FriendlyName()} timed out");
                timer.Enabled = false;\n                timer.Dispose();\n                // Complete the connection.\n                remote.EndConnect(ar);\n                connected = true;\n                Logging.Debug($"Socket connected to {remote.RemoteEndPoint}");\n                var latency = DateTime.Now - _startConnectTime;\n                IStrategy strategy = controller.GetCurrentStrategy();\n                strategy?.UpdateLatency(server, latency);\n                tcprelay.UpdateLatency(server, latency);\n                StartPipe();
                var latency = DateTime.Now - _startConnectTime;\n                IStrategy strategy = controller.GetCurrentStrategy();\n                strategy?.UpdateLatency(server, latency);\n                tcprelay.UpdateLatency(server, latency);\n                StartPipe();\n            }\n            catch (ArgumentException)\n            {\n            }\n            catch (Exception e)
        {\n            this.name = name;\n            this.key_size = key_size;\n            this.iv_size = iv_size;\n            this.type = type;
        }\n    }\n    public abstract class EncryptorBase\n        : IEncryptor\n    {\n        public const int MAX_INPUT_SIZE = 32768;\n        protected EncryptorBase(string method, string password, bool onetimeauth, bool isudp)\n        {\n            Method = method;\n            Password = password;
            {\n                FileManager.UncompressFile(dllPath, Resources.polarssl_dll);
            }\n            catch (IOException e)\n            {\n                Console.WriteLine(e.ToString());\n            }\n            LoadLibrary(dllPath);\n            try\n            {\n                FileStream fs = new FileStream("shadowsocks.log", FileMode.Append);\n                TextWriter tmp = Console.Out;
        }\n    }\n}
            series1.IsXValueIndexed = true;\n            series1.Legend = "Legend1";\n            series1.Name = "Inbound";\n            series2.ChartArea = "ChartArea1";\n            series2.ChartType = System.Windows.Forms.DataVisualization.Charting.SeriesChartType.Line;\n            series2.Color = System.Drawing.Color.FromArgb(((int)(((byte)(128)))), ((int)(((byte)(128)))), ((int)(((byte)(255)))));

        public const int HASH_BYTES = 4;\n        protected static byte[] tempbuf = new byte[MAX_INPUT_SIZE];\n        protected Dictionary<string, int[]> ciphers;\n        private static readonly Dictionary<string, byte[]> CachedKeys = new Dictionary<string, byte[]>();\n        protected byte[] _encryptIV;\n        protected byte[] _decryptIV;\n        protected bool _decryptIVReceived;\n        protected bool _encryptIVSent;
        public IVEncryptor(string method, string password, bool onetimeauth)\n            : base(method, password, onetimeauth)\n        {\n            InitKey(method, password);\n            if (OnetimeAuth)\n            {\n                hash_buf = new byte[HASH_BUF_LEN];\n            }\n        }\n        protected abstract Dictionary<string, int[]> getCiphers();
        }\n        protected abstract Dictionary<string, int[]> getCiphers();\n        protected void InitKey(string method, string password)\n        {\n            method = method.ToLower();\n            _method = method;\n            string k = method + ":" + password;\n            ciphers = getCiphers();\n            _cipherInfo = ciphers[_method];\n            _cipher = _cipherInfo[2];
        {\n            byte[] auth_key = new byte[ONETIMEAUTH_KEYBYTES];\n            byte[] auth_bytes = new byte[MAX_IV_LENGTH + MAX_KEY_LENGTH];\n            Buffer.BlockCopy(iv, 0, auth_bytes, 0, ivLen);\n            Buffer.BlockCopy(key, 0, auth_bytes, ivLen, key_len);\n            Sodium.crypto_generichash(auth_key, ONETIMEAUTH_KEYBYTES, auth_bytes, (ulong)(iv_len + key_len), null, 0);\n            return Sodium.crypto_onetimeauth(auth, msg, (ulong)msg_len, auth_key);\n        }\n        protected void ss_gen_hash(byte[] in_buf, ref int in_offset, ref int in_len,\n            byte[] hash_buf, ref int hash_idx, int buf_size)
            return Sodium.crypto_onetimeauth(auth, msg, (ulong)msg_len, auth_key);\n        }\n        protected void ss_gen_hash(byte[] in_buf, ref int in_offset, ref int in_len,\n            byte[] hash_buf, ref int hash_idx, int buf_size)\n        {\n            int i, j;\n            int offset = in_offset;\n            int blen = in_len;\n            int cidx = hash_idx;\n            int size = (blen / HASH_BUF_LEN + 1) * HASH_BYTES + blen;
            if (buf_size < (size + offset))\n                throw new Exception("failed to generate hash:  buffer size insufficient");\n            byte[] hash = new byte[HASH_BYTES];
        }\n        public override void Encrypt(byte[] buf, int length, byte[] outbuf, out int outlength)\n        {\n            if (!_encryptIVSent)\n            {\n                _encryptIVSent = true;\n                randBytes(outbuf, ivLen);\n                initCipher(outbuf, true);\n                outlength = length + ivLen;\n                lock (tempbuf)
                        // we need a panel because a window has a minimal size\n                        splash.Panel.Size = new Size((int)maxX - (int)minX, (int)maxY - (int)minY);\n                        splash.Size = splash.Panel.Size;\n                        splash.Show();\n                        return;\n                    }\n                }\n            }\n            MessageBox.Show(I18N.GetString("Failed to find QRCode"));\n        }\n        void splash_FormClosed(object sender, FormClosedEventArgs e)
                        splash.Show();\n                        return;\n                    }\n                }\n            }\n            MessageBox.Show(I18N.GetString("Failed to find QRCode"));\n        }\n        void splash_FormClosed(object sender, FormClosedEventArgs e)\n        {\n            ShowConfigForm();
    {
        }\n        private Timer timer;\n            step = 0;
            timer = new Timer();\n            timer.Interval = 300;\n            timer.Tick += timer_Tick;\n            timer.Start();
            timer.Tick += timer_Tick;\n            timer.Start();
            {\n                return PAC_FILE;\n            }\n            else\n            {\n                FileManager.UncompressFile(PAC_FILE, Resources.proxy_pac_txt);\n                return PAC_FILE;\n            }\n        }\n        internal string TouchUserRuleFile()
            }\n            else\n            {\n                FileManager.UncompressFile(PAC_FILE, Resources.proxy_pac_txt);\n                return PAC_FILE;\n            }\n        }\n        internal string TouchUserRuleFile()\n        {\n            if (File.Exists(USER_RULE_FILE))
        }\n        internal string TouchUserRuleFile()\n        {\n            if (File.Exists(USER_RULE_FILE))\n            {\n                return USER_RULE_FILE;\n            }\n            else\n            {
            {\n                File.WriteAllText(USER_RULE_FILE, Resources.user_rule);\n                return USER_RULE_FILE;\n            }\n        }\n        internal string GetPACContent()\n        {\n            if (File.Exists(PAC_FILE))\n            {
            }\n        }\n        internal string GetPACContent()\n        {\n            if (File.Exists(PAC_FILE))\n            {\n                return File.ReadAllText(PAC_FILE, Encoding.UTF8);\n            }\n            else
            }\n        }\n        private void WatchPacFile()\n        {\n            PACFileWatcher?.Dispose();\n            PACFileWatcher = new FileSystemWatcher(Directory.GetCurrentDirectory());\n            PACFileWatcher.NotifyFilter = NotifyFilters.LastWrite | NotifyFilters.FileName | NotifyFilters.DirectoryName;\n            PACFileWatcher.Filter = PAC_FILE;\n            PACFileWatcher.Changed += PACFileWatcher_Changed;\n            PACFileWatcher.Created += PACFileWatcher_Changed;
            {\n                logger.Info("Found custom GFWListURL in config file");\n                gfwListUrl = config.gfwListUrl;\n            }\n            logger.Info($"Checking GFWList from {gfwListUrl}");
            }\n            logger.Info($"Checking GFWList from {gfwListUrl}");\n            WebClient http = new WebClient();\n            if (config.enabled)\n            {
            WebClient http = new WebClient();\n            if (config.enabled)\n            {\n                http.Proxy = new WebProxy(\n                    config.isIPv6Enabled\n                    ? $"[{IPAddress.IPv6Loopback}]"\n                    : IPAddress.Loopback.ToString(),\n                    config.localPort);\n            }\n            http.DownloadDataCompleted += (o, e) =>
                    UpdateCompleted?.Invoke(null, new GeositeResultEventArgs(pacFileChanged));\n                }\n                catch (Exception ex)\n                {\n                    Error?.Invoke(null, new ErrorEventArgs(ex));\n                }\n            };\n            http.DownloadDataAsync(new Uri(gfwListUrl));\n        }\n        public static bool MergeAndWritePACFile()
        }\n        public static bool MergeAndWritePACFile()\n        {\n            return MergeAndWritePACFile(Geosites["cn"]);\n        }\n        private static bool MergeAndWritePACFile(IList<DomainObject> domains)\n        {\n            string abpContent = MergePACFile(domains);
        {\n            return MergeAndWritePACFile(Geosites["cn"]);\n        }\n        private static bool MergeAndWritePACFile(IList<DomainObject> domains)\n        {\n            string abpContent = MergePACFile(domains);\n            if (File.Exists(PACDaemon.PAC_FILE))\n            {
            if (File.Exists(PACDaemon.PAC_FILE))\n            {\n                string original = FileManager.NonExclusiveReadAllText(PACDaemon.PAC_FILE, Encoding.UTF8);\n                if (original == abpContent)\n                {\n                    return false;\n                }\n            }\n            File.WriteAllText(PACDaemon.PAC_FILE, abpContent, Encoding.UTF8);\n            return true;
            }\n            List<string> gfwLines = ParseToValidList(domains);\n            abpContent =\n$@"var __USERRULES__ = {JsonConvert.SerializeObject(userruleLines, Formatting.Indented)};\nvar __RULES__ = {JsonConvert.SerializeObject(gfwLines, Formatting.Indented)};\n{abpContent}";\n            return abpContent;\n        }\n        private static readonly IEnumerable<char> IgnoredLineBegins = new[] { '!', '[' };\n        private static List<string> ParseToValidList(string content)
            abpContent =\n$@"var __USERRULES__ = {JsonConvert.SerializeObject(userruleLines, Formatting.Indented)};\nvar __RULES__ = {JsonConvert.SerializeObject(gfwLines, Formatting.Indented)};\n{abpContent}";\n            return abpContent;\n        }\n        private static readonly IEnumerable<char> IgnoredLineBegins = new[] { '!', '[' };\n        private static List<string> ParseToValidList(string content)\n        {\n            List<string> valid_lines = new List<string>();
        {\n            List<string> valid_lines = new List<string>();\n            using (var sr = new StringReader(content))\n            {\n                foreach (var line in sr.NonWhiteSpaceLines())\n                {\n                    if (line.BeginWithAny(IgnoredLineBegins))\n                        continue;\n                    valid_lines.Add(line);\n                }
        {\n            List<string> ret = new List<string>(domains.Count + 100)// 100 overhead\n            {\n                "/.*/" // match any domain, so all non-cn domain go through proxy\n            }; \n            foreach (var d in domains)\n            {\n                string domain = d.Value;
            foreach (var d in domains)\n            {\n                string domain = d.Value;\n                switch (d.Type)\n                {\n                    case DomainObject.Types.Type.Plain:\n                        ret.Add($"@@{domain}");\n                        break;\n                    case DomainObject.Types.Type.Regex:
                        break;\n                    case DomainObject.Types.Type.Regex:
        {\n            TouchPACFile();\n            TouchUserRuleFile();\n            this.WatchPacFile();\n            this.WatchUserRuleFile();\n        }\n        public string TouchPACFile()\n        {\n            if (!File.Exists(PAC_FILE))
            }\n            return PAC_FILE;\n        }\n        internal string TouchUserRuleFile()\n        {\n            if (!File.Exists(USER_RULE_FILE))\n            {\n                File.WriteAllText(USER_RULE_FILE, Resources.user_rule);\n            }\n            return USER_RULE_FILE;
        {\n            // we are building x86 binary for both x86 and x64, which will\n            // cause problem when opening registry key\n            // detect operating system instead of CPU\n            if (name.IsNullOrEmpty()) throw new ArgumentException(nameof(name));\n            try\n            {\n                RegistryKey userKey = RegistryKey.OpenBaseKey(RegistryHive.CurrentUser,\n                        Environment.Is64BitOperatingSystem ? RegistryView.Registry64 : RegistryView.Registry32)\n                    .OpenSubKey(name, writable);\n                return userKey;\n            }\n            catch (UnauthorizedAccessException uae)
                        Environment.Is64BitOperatingSystem ? RegistryView.Registry64 : RegistryView.Registry32)\n                    .OpenSubKey(name, writable);\n                return userKey;\n            }\n            catch (UnauthorizedAccessException uae)\n            {\n                Logging.LogUsefulException(uae);\n                return null;\n            }\n            catch (SecurityException se)
        }\n        public void UpdateOutboundCounter(long n)\n        {\n            outboundCounter += n;\n        }\n        protected void Reload()\n        {\n            // some logic in configuration updated the config when saving, we need to read it again\n            _config = Configuration.Load();\n            StatisticsConfiguration = StatisticsStrategyConfiguration.Load();
        }\n        protected void Reload()\n        {\n            // some logic in configuration updated the config when saving, we need to read it again\n            _config = Configuration.Load();\n            StatisticsConfiguration = StatisticsStrategyConfiguration.Load();\n            if (polipoRunner == null)\n            {\n                polipoRunner = new PolipoRunner();\n            }
            polipoRunner = new PolipoRunner();\n            polipoRunner.Start(config);\n            local = new Local(config);\n            try\n            {\n                local.Start();\n                pacServer = new PACServer();\n                pacServer.PACFileChanged += pacServer_PACFileChanged;\n                pacServer.Start();\n            }
            try\n            {\n                local.Start();\n                pacServer = new PACServer();\n                pacServer.PACFileChanged += pacServer_PACFileChanged;\n                pacServer.Start();\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine(e.Message);
        {\n            Config.Save(newConfig);\n            config = newConfig;\n            local.Stop();\n            polipoRunner.Stop();\n            polipoRunner.Start(config);\n            local = new Local(config);\n            local.Start();\n            if (ConfigChanged != null)\n            {
            config = newConfig;\n            local.Stop();\n            polipoRunner.Stop();\n            polipoRunner.Start(config);\n            local = new Local(config);\n            local.Start();\n            if (ConfigChanged != null)\n            {\n                ConfigChanged(this, new EventArgs());\n            }
            local.Start();\n            if (ConfigChanged != null)\n            {\n                ConfigChanged(this, new EventArgs());\n            }\n        }\n        public Config GetConfig()
        {\n            return config;\n        }\n        public void ToggleEnable(bool enabled)\n        {\n            config.enabled = enabled;\n            updateSystemProxy();\n            SaveConfig(config);\n            if (EnableStatusChanged != null)\n            {
        }\n        private void Form1_Load(object sender, EventArgs e)\n        {\n            if (!controller.GetConfig().isDefault)\n            {\n                this.Opacity = 0;\n                BeginInvoke(new MethodInvoker(delegate\n                {\n                    this.Hide();\n                }));
            {\n                this.Opacity = 0;\n                BeginInvoke(new MethodInvoker(delegate\n                {\n                    this.Hide();\n                }));\n            }\n        }\n        private void Config_Click(object sender, EventArgs e)\n        {
                {\n                    server = textBox1.Text,\n                    server_port = int.Parse(textBox2.Text),\n                    password = textBox3.Text,\n                    local_port = int.Parse(textBox4.Text),\n                    method = comboBox1.Text,\n                    isDefault = false\n                };
                };\n                controller.SaveConfig(config);\n                this.Hide();\n            }\n            catch (FormatException)\n            {
                            {\n                                throw new Exception("Bad http header: " + line);\n                            }
                            }\n                        }\n                    }\n                }\n                else\n                {\n                    if (line.IsNullOrEmpty())\n                    {\n                        return true;\n                    }
                            {\n                                throw new Exception("Bad http header: " + line);\n                            }
                            }\n                        }\n                    }\n                }\n                _requestLineCount++;\n                return false;\n            }\n            private void OnFinish(byte[] lastBytes, int index, int length, object state)\n            {\n                if (_closed)
                            byte[] response = { 5, 0, 0, 1, 0, 0, 0, 0, 0, 0 };\n                            _connection.BeginSend(response, 0, response.Length, SocketFlags.None,\n                                ResponseCallback, null);\n                        }\n                        else if (_command == CMD_UDP_ASSOC)\n                        {\n                            ReadAddress(HandleUDPAssociate);\n                        }
                            ReadAddress(HandleUDPAssociate);\n                        }\n                    }\n                }
                    }\n                }\n                else\n                {\n                    Logging.Debug(\n                        "failed to recv data in Shadowsocks.Controller.TCPHandler.handshakeReceive2Callback()");\n                    Close();\n                }\n            }\n            catch (Exception e)
using System.Diagnostics;\nusing System.IO;\nusing System.IO.Compression;\nusing System.Linq;\nusing System.Runtime.InteropServices;\nusing System.Security;
using System.Runtime.InteropServices;\nusing System.Security;

                return null;\n            }\n            catch (SecurityException se)\n            {\n                Logging.LogUsefulException(se);\n                return null;\n            }\n            catch (ArgumentException ae)\n            {\n                MessageBox.Show("OpenRegKey: " + ae.ToString());
                return null;\n            }\n        }\n        public static bool IsWinVistaOrHigher() {\n            return Environment.OSVersion.Version.Major > 5;\n        }\n        [DllImport("kernel32.dll")]\n        [return: MarshalAs(UnmanagedType.Bool)]\n        private static extern bool SetProcessWorkingSetSize(IntPtr process,\n            UIntPtr minimumWorkingSetSize, UIntPtr maximumWorkingSetSize);
namespace Shadowsocks.Util.SystemProxy\n{\n    public static class RAS\n    {\n        private enum RasFieldSizeConstants\n        {\n            #region original header\n            //#if (WINVER >= 0x400)\n            //#define RAS_MaxEntryName      256\n            //#define RAS_MaxDeviceName     128
    {\n        private enum RasFieldSizeConstants\n        {\n            #region original header\n            //#if (WINVER >= 0x400)\n            //#define RAS_MaxEntryName      256\n            //#define RAS_MaxDeviceName     128\n            //#define RAS_MaxCallbackNumber RAS_MaxPhoneNumber\n            //#else\n            //#define RAS_MaxEntryName      20
using System.Collections;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.IO.Compression;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Text;
using System.IO;\nusing System.IO.Compression;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Text;\nnamespace Shadowsocks.Controller\n{
using System.Net;\nusing System.Net.Sockets;\nusing System.Text;\nnamespace Shadowsocks.Controller\n{\n    class PACServer : Listener.Service\n    {
        FileSystemWatcher PACFileWatcher;\n        FileSystemWatcher UserRuleFileWatcher;\n        private Configuration _config;\n        public event EventHandler PACFileChanged;\n        public event EventHandler UserRuleFileChanged;\n        public PACServer()\n        {\n            this.WatchPacFile();\n            this.WatchUserRuleFile();\n        }
                {\n                    string local = File.ReadAllText(USER_RULE_FILE, Encoding.UTF8);\n                    string[] rules = local.Split(new char[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);\n                    foreach (string rule in rules)\n                    {\n                        if (rule.StartsWith("!") || rule.StartsWith("["))\n                            continue;\n                        lines.Add(rule);\n                    }\n                }
                    string[] rules = local.Split(new char[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);\n                    foreach (string rule in rules)\n                    {\n                        if (rule.StartsWith("!") || rule.StartsWith("["))\n                            continue;\n                        lines.Add(rule);\n                    }\n                }\n                string abpContent;\n                if (File.Exists(USER_ABP_FILE))
                {\n                    abpContent = File.ReadAllText(USER_ABP_FILE, Encoding.UTF8);\n                }\n                else\n                {\n                    abpContent = Utils.UnGzip(Resources.abp_js);\n                }\n                abpContent = abpContent.Replace("__RULES__", JsonConvert.SerializeObject(lines, Formatting.Indented));\n                if (File.Exists(PACServer.PAC_FILE))\n                {
                }\n                else\n                {\n                    abpContent = Utils.UnGzip(Resources.abp_js);\n                }\n                abpContent = abpContent.Replace("__RULES__", JsonConvert.SerializeObject(lines, Formatting.Indented));\n                if (File.Exists(PACServer.PAC_FILE))\n                {\n                    string original = File.ReadAllText(PAC_FILE, Encoding.UTF8);\n                    if (original == abpContent)
                    if (original == abpContent)\n                    {\n                        UpdateCompleted(this, new ResultEventArgs(false));\n                        return;\n                    }\n                }\n                File.WriteAllText(PAC_FILE, abpContent, Encoding.UTF8);\n                if (UpdateCompleted != null)\n                {\n                    UpdateCompleted(this, new ResultEventArgs(true));
                if (UpdateCompleted != null)\n                {\n                    UpdateCompleted(this, new ResultEventArgs(true));\n                }\n            }\n            catch (Exception ex)\n            {\n                if (Error != null)\n                {\n                    Error(this, new ErrorEventArgs(ex));
                {\n                    new KeyValuePair<string, string>("Timestamp", timestamp),\n                    new KeyValuePair<string, string>("Server", server.FriendlyName()),\n                    new KeyValuePair<string, string>("Status", reply?.Status.ToString()),\n                    new KeyValuePair<string, string>("RoundtripTime", reply?.RoundtripTime.ToString())\n                    //new KeyValuePair<string, string>("data", reply.Buffer.ToString()); // The data of reply\n                });
            }\n            return ret;\n        }\n        private async void Evaluate(object obj)\n        {\n            var geolocationAndIsp = getGeolocationAndISP();\n            foreach (var dataLists in await TaskEx.WhenAll(_servers.Select(ICMPTest)))\n            {\n                if (dataLists == null) continue;\n                foreach (var dataList in dataLists.Where(dataList => dataList != null))
            return output;\n        }\n        [DllImport("Kernel32.dll")]\n        private static extern IntPtr LoadLibrary(string path);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public static extern void md5(byte[] input, uint ilen, byte[] output);\n        /// <summary>\n        /// Get cipher ctx size for unmanaged memory allocation\n        /// </summary>\n        /// <returns></returns>
        /// <summary>\n        /// Get cipher ctx size for unmanaged memory allocation\n        /// </summary>\n        /// <returns></returns>\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public static extern int cipher_get_size_ex();\n        #region Cipher layer wrappers\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public static extern IntPtr cipher_info_from_string(string cipher_name);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
    {\n        private Configuration _config;\n        private bool _shareOverLAN;\n        //private Encryptor encryptor;\n        Socket _listener;\n        public Local(Configuration config)\n        {\n            this._config = config;\n            _shareOverLAN = config.shareOverLan;\n            //this.encryptor = new Encryptor(config.method, config.password);\n        }
        public Local(Configuration config)\n        {\n            this._config = config;\n            _shareOverLAN = config.shareOverLan;\n            //this.encryptor = new Encryptor(config.method, config.password);\n        }\n        public void Start()\n        {\n            try\n            {
        }\n    }\n    class Handler\n    {\n        //public Encryptor encryptor;\n        public IEncryptor encryptor;\n        public Server server;\n        // Client  socket.\n        public Socket remote;\n        public Socket connection;
                if (bytesRead > 1)\n                {\n                    byte[] response = { 5, 0 };\n                    if (connetionRecvBuffer[0] != 5)\n                    {\n                        // reject socks 4
                    {\n                        // reject socks 4
            }\n            // don't put polipoRunner.Start() before pacServer.Stop()\n            // or bind will fail when switching bind address from 0.0.0.0 to 127.0.0.1\n            // though UseShellExecute is set to true now\n            // http://stackoverflow.com/questions/10235093/socket-doesnt-close-after-application-exits-if-a-launched-process-is-open\n            polipoRunner.Stop();\n            try\n            {\n                polipoRunner.Start(_config);\n                local = new Local(_config);\n                local.Start();
                pacServer.Start(_config);\n            }\n            catch (Exception e)\n            {\n                // translate Microsoft language into human language\n                // i.e. An attempt was made to access a socket in a way forbidden by its access permissions => Port already in use\n                if (e is SocketException)\n                {\n                    SocketException se = (SocketException)e;\n                    if (se.SocketErrorCode == SocketError.AccessDenied)
            this.valueLabel.TabIndex = 7;
            {\n                new DataUnit(State.Geolocation, State.Unknown),\n                new DataUnit(State.ISP, State.Unknown)\n            };\n            string jsonString;\n            try\n            {
            }\n            dynamic obj;\n            if (!SimpleJson.SimpleJson.TryDeserializeObject(jsonString, out obj)) return ret;\n            string country = obj["country"];\n            string city = obj["city"];\n            string isp = obj["isp"];\n            string regionName = obj["regionName"];\n            if (country == null || city == null || isp == null || regionName == null) return ret;\n            ret[0] = new DataUnit(State.Geolocation, $"{country} | {regionName} | {city}");\n            ret[1] = new DataUnit(State.ISP, isp);
            string country = obj["country"];\n            string city = obj["city"];\n            string isp = obj["isp"];\n            string regionName = obj["regionName"];\n            if (country == null || city == null || isp == null || regionName == null) return ret;\n            ret[0] = new DataUnit(State.Geolocation, $"{country} | {regionName} | {city}");\n            ret[1] = new DataUnit(State.ISP, isp);\n            return ret;\n        }\n        private async Task<List<DataList>> ICMPTest(Server server)
        }\n        private async Task<List<DataList>> ICMPTest(Server server)\n        {\n            Logging.Debug("Ping " + server.FriendlyName());\n            if (server.server == "") return null;\n            var IP = Dns.GetHostAddresses(server.server).First(ip => ip.AddressFamily == AddressFamily.InterNetwork);\n            var ping = new Ping();\n            var ret = new List<DataList>();\n            foreach (\n                var timestamp in Enumerable.Range(0, Repeat).Select(_ => DateTime.Now.ToString(DateTimePattern)))
        {\n            _dataTable.Rows.Clear();\n            List<AvailabilityStatistics.RawStatisticsData> statistics;\n            if (!_controller.availabilityStatistics.FilteredStatistics.TryGetValue(serverName, out statistics)) return;\n            foreach (var data in statistics)\n            {\n                _dataTable.Rows.Add(data.Timestamp, (float) new Random().Next() % 50, new Random().Next() % 200);
            {\n                _dataTable.Rows.Add(data.Timestamp, (float) new Random().Next() % 50, new Random().Next() % 200);\n            }
            }
        }\n    }\n}
            ((System.ComponentModel.ISupportInitialize)(this.StatisticsChart)).BeginInit();\n            this.groupBox1.SuspendLayout();\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer1)).BeginInit();\n            this.splitContainer1.Panel1.SuspendLayout();\n            this.splitContainer1.Panel2.SuspendLayout();\n            this.splitContainer1.SuspendLayout();\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer2)).BeginInit();\n            this.splitContainer2.Panel1.SuspendLayout();\n            this.splitContainer2.Panel2.SuspendLayout();\n            this.splitContainer2.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.splitContainer1)).BeginInit();\n            this.splitContainer1.Panel1.SuspendLayout();\n            this.splitContainer1.Panel2.SuspendLayout();\n            this.splitContainer1.SuspendLayout();\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer2)).BeginInit();\n            this.splitContainer2.Panel1.SuspendLayout();\n            this.splitContainer2.Panel2.SuspendLayout();\n            this.splitContainer2.SuspendLayout();\n            ((System.ComponentModel.ISupportInitialize)(this.dataCollectionMinutesNum)).BeginInit();\n            ((System.ComponentModel.ISupportInitialize)(this.choiceKeptMinutesNum)).BeginInit();
            // StatisticsStrategyConfigurationForm\n            // \n            this.groupBox1.ResumeLayout(false);
            this.splitContainer1.Panel1.ResumeLayout(false);\n            this.splitContainer1.Panel2.ResumeLayout(false);\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer1)).EndInit();\n            this.splitContainer1.ResumeLayout(false);\n            this.splitContainer2.Panel1.ResumeLayout(false);\n            this.splitContainer2.Panel1.PerformLayout();\n            this.splitContainer2.Panel2.ResumeLayout(false);\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer2)).EndInit();\n            this.splitContainer2.ResumeLayout(false);\n            ((System.ComponentModel.ISupportInitialize)(this.dataCollectionMinutesNum)).EndInit();

                    }\n                }\n                else\n                {\n                    registry.SetValue("ProxyEnable", 0);\n                    registry.SetValue("ProxyServer", "");\n                    registry.SetValue("AutoConfigURL", "");\n                }\n                SystemProxy.NotifyIE();\n                //Must Notify IE first, or the connections do not chanage
                {\n                    string argument = "/select, \"" + updateChecker.LatestVersionLocalName + "\"";\n                    System.Diagnostics.Process.Start("explorer.exe", argument);\n                }\n            }\n        }\n        private void _notifyIcon_BalloonTipClosed(object sender, EventArgs e)\n        {\n            if (updateChecker.NewVersionFound)\n            {
                }\n            }\n        }\n        private void _notifyIcon_BalloonTipClosed(object sender, EventArgs e)\n        {\n            if (updateChecker.NewVersionFound)\n            {\n                updateChecker.NewVersionFound = false; /* Reset the flag */\n            }\n        }
namespace Shadowsocks.Controller\n{\n    class AvailabilityStatistics\n    {\n        private static readonly string StatisticsFilesName = "shadowsocks.availability.csv";\n        private static readonly string Delimiter = ",";\n        private static readonly int Timeout = 500;\n        private static readonly int Repeat = 4; //repeat times every evaluation\n        private static readonly int Interval = 10 * 60 * 1000;  //evaluate proxies every 15 minutes\n        private Timer timer = null;
        public static string AvailabilityStatisticsFile;\n        //static constructor to initialize every public static fields before refereced\n        static AvailabilityStatistics()\n        {\n            string temppath = Path.GetTempPath();\n            AvailabilityStatisticsFile = Path.Combine(temppath, StatisticsFilesName);\n        }\n        public bool Set(bool enabled)\n        {\n            try\n            {
            AvailabilityStatisticsFile = Path.Combine(temppath, StatisticsFilesName);\n        }\n        public bool Set(bool enabled)\n        {\n            try\n            {\n                if (enabled)\n                {\n                    if (timer?.Change(0, Interval) == null)\n                    {
                }\n                else\n                {
            {\n                Logging.Debug("eveluating " + server.FriendlyName());\n                foreach (var _ in Enumerable.Range(0, Repeat))\n                {\n                    //TODO: do simple analyze of data to provide friendly message, like package loss.\n                    string timestamp = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss");\n                    //ICMP echo. we can also set options and special bytes\n                    //seems no need to use SendPingAsync\n                    PingReply reply = ping.Send(server.server, Timeout);\n                    state.data = new List<KeyValuePair<string, string>>();\n                    state.data.Add(new KeyValuePair<string, string>("Timestamp", timestamp));\n                    state.data.Add(new KeyValuePair<string, string>("Server", server.FriendlyName()));
                    //ICMP echo. we can also set options and special bytes\n                    //seems no need to use SendPingAsync\n                    PingReply reply = ping.Send(server.server, Timeout);\n                    state.data = new List<KeyValuePair<string, string>>();\n                    state.data.Add(new KeyValuePair<string, string>("Timestamp", timestamp));\n                    state.data.Add(new KeyValuePair<string, string>("Server", server.FriendlyName()));\n                    state.data.Add(new KeyValuePair<string, string>("Status", reply.Status.ToString()));\n                    state.data.Add(new KeyValuePair<string, string>("RoundtripTime", reply.RoundtripTime.ToString()));\n                    //state.data.Add(new KeyValuePair<string, string>("data", reply.Buffer.ToString())); // The data of reply
                    //state.data.Add(new KeyValuePair<string, string>("data", reply.Buffer.ToString())); // The data of reply\n            string dataLine = string.Join(Delimiter, data.Select(kv => kv.Value).ToArray());\n            string[] lines;\n            if (!File.Exists(AvailabilityStatisticsFile))\n            {
            string[] lines;\n            if (!File.Exists(AvailabilityStatisticsFile))\n            {\n                string headerLine = string.Join(Delimiter, data.Select(kv => kv.Key).ToArray());\n                lines = new string[] { headerLine, dataLine };\n            }\n            else\n            {\n                lines = new string[] { dataLine };\n            }
            }\n            else\n            {\n                lines = new string[] { dataLine };\n            }\n            File.AppendAllLines(AvailabilityStatisticsFile, lines);\n        }
            }\n            File.AppendAllLines(AvailabilityStatisticsFile, lines);\n        }
using System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Timers;\nusing Shadowsocks.Controller.Strategy;\nusing Shadowsocks.Encryption;\nusing Shadowsocks.Encryption.AEAD;\nusing Shadowsocks.Encryption.Exception;
    {\n        public event EventHandler<SSTCPConnectedEventArgs> OnConnected;\n        public event EventHandler<SSTransmitEventArgs> OnInbound;\n        public event EventHandler<SSTransmitEventArgs> OnOutbound;\n        public event EventHandler<SSRelayEventArgs> OnFailed;\n        private static Logger logger = LogManager.GetCurrentClassLogger();\n        private ShadowsocksController _controller;\n        private DateTime _lastSweepTime;\n        private Configuration _config;\n        public ISet<TCPHandler> Handlers { get; set; }
        private DateTime _lastSweepTime;\n        private Configuration _config;\n        public ISet<TCPHandler> Handlers { get; set; }\n        public TCPRelay(ShadowsocksController controller, Configuration conf)\n        {\n            _controller = controller;\n            _config = conf;\n            Handlers = new HashSet<TCPHandler>();\n            _lastSweepTime = DateTime.Now;\n        }
        public ISet<TCPHandler> Handlers { get; set; }\n        public TCPRelay(ShadowsocksController controller, Configuration conf)\n        {\n            _controller = controller;\n            _config = conf;\n            Handlers = new HashSet<TCPHandler>();\n            _lastSweepTime = DateTime.Now;\n        }\n        public override bool Handle(byte[] firstPacket, int length, Socket socket, object state)\n        {
        {\n            public IProxy Remote { get; }\n            public AsyncSession(IProxy remote)\n            {\n                Remote = remote;\n            }\n        }\n        class AsyncSession<T> : AsyncSession\n        {\n            public T State { get; set; }
        {\n            public T State { get; set; }\n            public AsyncSession(IProxy remote, T state) : base(remote)\n            {\n                State = state;\n            }\n            public AsyncSession(AsyncSession session, T state) : base(session.Remote)\n            {\n                State = state;\n            }
        private readonly int _serverTimeout;\n        private readonly int _proxyTimeout;\n        // each recv size.\n        public const int RecvSize = 2048;\n        // overhead of one chunk, reserved for AEAD ciphers\n        public const int ChunkOverheadSize = 16 * 2 /* two tags */ + AEADEncryptor.CHUNK_LEN_BYTES;\n        // max chunk size\n        public const uint MaxChunkSize = AEADEncryptor.CHUNK_LEN_MASK + AEADEncryptor.CHUNK_LEN_BYTES + 16 * 2;\n        // In general, the ciphertext length, we should take overhead into account\n        public const int BufferSize = RecvSize + (int)MaxChunkSize + 32 /* max salt len */;\n        private ShadowsocksController _controller;\n        private ProxyConfig _config;\n        private Socket _connection;
        private IEncryptor _encryptor;\n        private Server _server;\n        private AsyncSession _currentRemoteSession;\n        private bool _proxyConnected;\n        private bool _destConnected;\n        private byte _command;\n        private byte[] _firstPacket;\n        private int _firstPacketLength;\n        private const int CMD_CONNECT = 0x01;\n        private const int CMD_BIND = 0x02;
        // client -> local proxy (plaintext, before encrypt)\n        private byte[] _connetionRecvBuffer = new byte[BufferSize];\n        // local proxy -> remote (plaintext, after decrypt)\n        private byte[] _remoteSendBuffer = new byte[BufferSize];\n        // local proxy -> client (ciphertext, before decrypt)\n        private byte[] _connetionSendBuffer = new byte[BufferSize];\n        private bool _connectionShutdown = false;\n        private bool _remoteShutdown = false;\n        private bool _closed = false;\n        // instance-based lock without static\n        private readonly object _encryptionLock = new object();\n        private readonly object _decryptionLock = new object();\n        private readonly object _closeConnLock = new object();
        // local proxy -> remote (plaintext, after decrypt)\n        private byte[] _remoteSendBuffer = new byte[BufferSize];\n        // local proxy -> client (ciphertext, before decrypt)\n        private byte[] _connetionSendBuffer = new byte[BufferSize];\n        private bool _connectionShutdown = false;\n        private bool _remoteShutdown = false;\n        private bool _closed = false;\n        // instance-based lock without static\n        private readonly object _encryptionLock = new object();\n        private readonly object _decryptionLock = new object();\n        private readonly object _closeConnLock = new object();\n        private DateTime _startConnectTime;
        // local proxy -> client (ciphertext, before decrypt)\n        private byte[] _connetionSendBuffer = new byte[BufferSize];\n        private bool _connectionShutdown = false;\n        private bool _remoteShutdown = false;\n        private bool _closed = false;\n        // instance-based lock without static\n        private readonly object _encryptionLock = new object();\n        private readonly object _decryptionLock = new object();\n        private readonly object _closeConnLock = new object();\n        private DateTime _startConnectTime;\n        private DateTime _startReceivingTime;
        private bool _connectionShutdown = false;\n        private bool _remoteShutdown = false;\n        private bool _closed = false;\n        // instance-based lock without static\n        private readonly object _encryptionLock = new object();\n        private readonly object _decryptionLock = new object();\n        private readonly object _closeConnLock = new object();\n        private DateTime _startConnectTime;\n        private DateTime _startReceivingTime;\n        private DateTime _startSendingTime;
            /* prepare address buffer length for AEAD */\n            Logger.Trace($"_addrBufLength={_addrBufLength}");\n            _encryptor.AddrBufLength = _addrBufLength;\n        }\n        public void Start(byte[] firstPacket, int length)\n        {\n            _firstPacket = firstPacket;\n            _firstPacketLength = length;\n            HandshakeReceive();\n        }
                _closed = true;\n            }\n            OnClosed?.Invoke(this, new SSRelayEventArgs(_server));\n            try\n            {\n                _connection.Shutdown(SocketShutdown.Both);\n                _connection.Close();\n            }\n            catch (Exception e)\n            {
            }\n        }\n        private void HandshakeSendCallback(IAsyncResult ar)\n        {\n            if (_closed) return;\n            try
            try\n            {\n                _connection.EndSend(ar);\n                // +-----+-----+-------+------+----------+----------+\n                // | VER | CMD |  RSV  | ATYP | DST.ADDR | DST.PORT |\n                // +-----+-----+-------+------+----------+----------+\n                // |  1  |  1  | X'00' |  1   | Variable |    2     |\n                // +-----+-----+-------+------+----------+----------+\n                // Skip first 3 bytes, and read 2 more bytes to analysis the address.\n                // 2 more bytes is designed if address is domain then we don't need to read once more to get the addr length.\n                    HandshakeReceive2Callback, null);\n            }\n            catch (Exception e)\n            {\n                Logger.LogUsefulException(e);\n                Close();
            try\n            {\n                int bytesRead = _connection.EndReceive(ar);\n                if (bytesRead >= 5)\n                {\n                    _command = _connetionRecvBuffer[1];\n                    switch (_command)\n                    {\n                        case CMD_CONNECT:\n                            // +----+-----+-------+------+----------+----------+
        {\n            try\n            {\n                _connection.EndSend(ar);\n                ReadAddress(StartConnect);\n            }\n            catch (Exception e)\n            {\n                Logger.LogUsefulException(e);\n                Close();
            }\n        }\n        private void ReadAddress(Action onSuccess)\n        {\n            int atyp = _connetionRecvBuffer[3];\n            switch (atyp)\n            {\n                case ATYP_IPv4: // IPv4 address, 4 bytes\n                    ReadAddress(4 + ADDR_PORT_LEN - 1, onSuccess);\n                    break;
            try\n            {\n                int bytesRead = _connection.EndReceive(ar);\n                var states = (object[])ar.AsyncState;\n                int bytesRemain = (int)states[0];\n                var onSuccess = (Action)states[1];\n                if (bytesRead >= bytesRemain)\n                {\n                    _firstPacketLength = bytesRead + 2;\n                    int atyp = _connetionRecvBuffer[0];
                int bytesRemain = (int)states[0];\n                var onSuccess = (Action)states[1];\n                if (bytesRead >= bytesRemain)\n                {\n                    _firstPacketLength = bytesRead + 2;\n                    int atyp = _connetionRecvBuffer[0];\n                    string dstAddr = "Unknown";\n                    int dstPort = -1;\n                    switch (atyp)\n                    {
                if (bytesRead >= bytesRemain)\n                {\n                    _firstPacketLength = bytesRead + 2;\n                    int atyp = _connetionRecvBuffer[0];\n                    string dstAddr = "Unknown";\n                    int dstPort = -1;\n                    switch (atyp)\n                    {\n                        case ATYP_IPv4: // IPv4 address, 4 bytes\n                            dstAddr = new IPAddress(_connetionRecvBuffer.Skip(1).Take(4).ToArray()).ToString();
            }\n        }\n        // inner class\n        private class ProxyTimer : Timer\n        {\n            public AsyncSession Session;\n            public EndPoint DestEndPoint;\n            public Server Server;\n            public ProxyTimer(int p) : base(p)\n            {
            }\n        }\n        private void ProxyConnectTimer_Elapsed(object sender, ElapsedEventArgs e)\n        {\n            var timer = (ProxyTimer)sender;\n            timer.Elapsed -= ProxyConnectTimer_Elapsed;\n            timer.Enabled = false;\n            timer.Dispose();\n            if (_proxyConnected || _destConnected || _closed)\n            {
            timer.Elapsed -= ProxyConnectTimer_Elapsed;\n            timer.Enabled = false;\n            timer.Dispose();\n            if (_proxyConnected || _destConnected || _closed)\n            {\n                return;\n            }\n            var proxy = timer.Session.Remote;\n            Logger.Info($"Proxy {proxy.ProxyEndPoint} timed out");\n            proxy.Close();
            Logger.Info($"Proxy {proxy.ProxyEndPoint} timed out");\n            proxy.Close();\n            Close();\n        }\n        private void ProxyConnectCallback(IAsyncResult ar)\n        {\n            if (_closed)\n            {\n                return;\n            }
                ProxyTimer timer = session.State;\n                var destEndPoint = timer.DestEndPoint;\n                var server = timer.Server;\n                timer.Elapsed -= ProxyConnectTimer_Elapsed;\n                timer.Enabled = false;\n                timer.Dispose();\n                var remote = session.Remote;\n                // Complete the connection.\n                remote.EndConnectProxy(ar);\n                _proxyConnected = true;
                timer.Elapsed -= ProxyConnectTimer_Elapsed;\n                timer.Enabled = false;\n                timer.Dispose();\n                var remote = session.Remote;\n                // Complete the connection.\n                remote.EndConnectProxy(ar);\n                _proxyConnected = true;\n                if (!(remote is DirectConnect))\n                {\n                    Logger.Debug($"Socket connected to proxy {remote.ProxyEndPoint}");
                // Complete the connection.\n                remote.EndConnectProxy(ar);\n                _proxyConnected = true;\n                if (!(remote is DirectConnect))\n                {\n                    Logger.Debug($"Socket connected to proxy {remote.ProxyEndPoint}");\n                }\n                _startConnectTime = DateTime.Now;\n                ServerTimer connectTimer = new ServerTimer(_serverTimeout) { AutoReset = false };\n                connectTimer.Elapsed += DestConnectTimer_Elapsed;
            }\n        }\n        private void DestConnectTimer_Elapsed(object sender, ElapsedEventArgs e)\n        {\n            var timer = (ServerTimer)sender;\n            timer.Elapsed -= DestConnectTimer_Elapsed;\n            timer.Enabled = false;\n            timer.Dispose();\n            if (_destConnected || _closed)\n            {
            timer.Elapsed -= DestConnectTimer_Elapsed;\n            timer.Enabled = false;\n            timer.Dispose();\n            if (_destConnected || _closed)\n            {\n                return;\n            }\n            var session = timer.Session;\n            Server server = timer.Server;\n            OnFailed?.Invoke(this, new SSRelayEventArgs(_server));
            Server server = timer.Server;\n            OnFailed?.Invoke(this, new SSRelayEventArgs(_server));\n            Logger.Info($"{server.FriendlyName()} timed out");\n            session.Remote.Close();\n            Close();\n        }\n        private void ConnectCallback(IAsyncResult ar)\n        {\n            if (_closed) return;\n            try
                ServerTimer timer = session.State;\n                _server = timer.Server;\n                timer.Elapsed -= DestConnectTimer_Elapsed;\n                timer.Enabled = false;\n                timer.Dispose();\n                var remote = session.Remote;\n                // Complete the connection.\n                remote.EndConnectDest(ar);\n                _destConnected = true;\n                Logger.Debug($"Socket connected to ss server: {_server.FriendlyName()}");\n                var latency = DateTime.Now - _startConnectTime;
                // Complete the connection.\n                remote.EndConnectDest(ar);\n                _destConnected = true;\n                Logger.Debug($"Socket connected to ss server: {_server.FriendlyName()}");\n                var latency = DateTime.Now - _startConnectTime;\n                OnConnected?.Invoke(this, new SSTCPConnectedEventArgs(_server, latency));\n                StartPipe(session);\n            }\n            catch (ArgumentException)\n            {\n            }
                OnConnected?.Invoke(this, new SSTCPConnectedEventArgs(_server, latency));\n                StartPipe(session);\n            }\n            catch (ArgumentException)\n            {\n            }\n            catch (Exception e)\n            {\n                if (_server != null)\n                {
            }\n        }\n        private void TryReadAvailableData()\n        {\n            int available = Math.Min(_connection.Available, RecvSize - _firstPacketLength);\n            if (available > 0)\n            {\n                var size = _connection.Receive(_connetionRecvBuffer, _firstPacketLength, available,\n                    SocketFlags.None);\n                _firstPacketLength += size;
                    SocketFlags.None);\n                _firstPacketLength += size;\n            }\n        }\n        private void StartPipe(AsyncSession session)\n        {\n            if (_closed) return;
            try\n            {\n                _startReceivingTime = DateTime.Now;\n                session.Remote.BeginReceive(_remoteRecvBuffer, 0, RecvSize, SocketFlags.None,\n                    PipeRemoteReceiveCallback, session);\n                TryReadAvailableData();\n                Logger.Trace($"_firstPacketLength = {_firstPacketLength}");\n                SendToServer(_firstPacketLength, session);\n            }\n            catch (Exception e)
            }\n        }\n        private void PipeRemoteReceiveCallback(IAsyncResult ar)\n        {\n            if (_closed) return;\n            try\n            {\n                var session = (AsyncSession)ar.AsyncState;
                int bytesRead = session.Remote.EndReceive(ar);\n                _totalRead += bytesRead;\n                OnInbound?.Invoke(this, new SSTransmitEventArgs(_server, bytesRead));\n                if (bytesRead > 0)\n                {\n                    lastActivity = DateTime.Now;\n                    int bytesToSend = -1;\n                    lock (_decryptionLock)\n                    {\n                        try
            }\n        }\n        private void PipeConnectionReceiveCallback(IAsyncResult ar)\n        {\n            if (_closed) return;\n            try
            try\n            {\n                int bytesRead = _connection.EndReceive(ar);\n                var session = (AsyncSession)ar.AsyncState;\n                var remote = session.Remote;\n                if (bytesRead > 0)\n                {\n                    SendToServer(bytesRead, session);\n                }\n                else
                if (bytesRead > 0)\n                {\n                    SendToServer(bytesRead, session);\n                }\n                else\n                {\n                    remote.Shutdown(SocketShutdown.Send);\n                    _remoteShutdown = true;\n                    CheckClose();\n                }
            }\n        }\n        // In general, we assume there is no delay between local proxy and client, add this for sanity\n        private void PipeConnectionSendCallback(IAsyncResult ar)\n        {\n            try\n            {\n                var container = (object[])ar.AsyncState;\n                var session = (AsyncSession)container[0];\n                var bytesShouldSend = (int)container[1];\n                var bytesSent = _connection.EndSend(ar);
                if (bytesRemaining > 0)\n                {\n                    Logger.Info("reconstruct _remoteSendBuffer to re-send");\n                    Buffer.BlockCopy(_remoteSendBuffer, bytesSent, _remoteSendBuffer, 0, bytesRemaining);\n                    _connection.BeginSend(_remoteSendBuffer, 0, bytesRemaining, SocketFlags.None,\n                        PipeConnectionSendCallback, new object[] { session, bytesRemaining });\n                    return;\n                }\n                session.Remote.BeginReceive(_remoteRecvBuffer, 0, RecvSize, SocketFlags.None,\n                    PipeRemoteReceiveCallback, session);
        private MenuItem editPACFileItem;\n        private MenuItem QRCodeItem;\n        private MenuItem ShowLogItem;\n        private MenuItem aboutItem;\n        private MenuItem ServersItem;\n        private MenuItem menuItem3;\n        private MenuItem quitItem;\n        private MenuItem menuItem1;
        private MenuItem quitItem;\n        private MenuItem menuItem1;

            // \n            // contextMenu1\n            // \n            this.contextMenu1.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {\n            this.enableItem,\n            this.modeItem,\n            this.ServersItem,\n            this.menuItem1,\n            this.AutoStartupItem,\n            this.ShareOverLANItem,\n            this.editPACFileItem,\n            this.menuItem4,\n            this.QRCodeItem,
            this.AutoStartupItem,\n            this.ShareOverLANItem,\n            this.editPACFileItem,\n            this.menuItem4,\n            this.QRCodeItem,\n            this.ShowLogItem,\n            this.aboutItem,\n            this.menuItem3,\n            this.quitItem});\n            // 
            this.QRCodeItem,\n            this.ShowLogItem,\n            this.aboutItem,\n            this.menuItem3,\n            this.quitItem});\n            // \n            // enableItem\n            // \n            this.enableItem.Index = 0;\n            this.enableItem.Text = I18N.GetString("Enable");
            this.quitItem});\n            // \n            // enableItem\n            // \n            this.enableItem.Index = 0;\n            this.enableItem.Text = I18N.GetString("Enable");\n            this.enableItem.Click += new System.EventHandler(this.EnableItem_Click);\n            //\n            // modeMenu\n            //
        }\n        private void controller_ConfigChanged(object sender, EventArgs e)\n        {\n            LoadCurrentConfiguration();\n            UpdateTrayIcon();\n        }\n        private void controller_EnableStatusChanged(object sender, EventArgs e)\n        {\n            enableItem.Checked = controller.GetConfiguration().enabled;\n        }
            handler.Send(firstPacket, length);\n            handler.Receive();\n            return true;\n        }\n        class UDPHandler\n        {\n            private Socket _local;\n            private Socket _remote;\n            private Server _server;\n            private byte[] _buffer = new byte[1500];
        {\n            private Socket _local;\n            private Socket _remote;\n            private Server _server;\n            private byte[] _buffer = new byte[1500];\n            private IPEndPoint _localEndPoint;\n            private IPEndPoint _remoteEndPoint;\n            public UDPHandler(Socket local, Server server, IPEndPoint localEndPoint)\n            {
        }\n        private void OKButton_Click(object sender, EventArgs e)\n        {\n            if (UseProxyCheckBox.Checked)\n            {\n                int port;\n                int timeout;\n                if (!int.TryParse(ProxyPortTextBox.Text, out port))\n                {
            {\n                int port;\n                int timeout;\n                if (!int.TryParse(ProxyPortTextBox.Text, out port))\n                {\n                    MessageBox.Show(I18N.GetString("Illegal port number format"));\n                    return;\n                }\n                if (!int.TryParse(ProxyTimeoutTextBox.Text, out timeout))
                {\n                    MessageBox.Show(I18N.GetString("Illegal port number format"));\n                    return;\n                }\n                if (!int.TryParse(ProxyTimeoutTextBox.Text, out timeout))\n                {\n                    MessageBox.Show(I18N.GetString("Illegal timeout format"));\n                    return;\n                }\n                var type = ProxyTypeComboBox.SelectedIndex;
                {\n                    MessageBox.Show(I18N.GetString("Illegal timeout format"));\n                    return;\n                }\n                var type = ProxyTypeComboBox.SelectedIndex;\n                var proxy = ProxyServerTextBox.Text;\n                try\n                {\n                    Configuration.CheckServer(proxy);
                try\n                {\n                    Configuration.CheckServer(proxy);\n                    Configuration.CheckPort(port);\n                    Configuration.CheckTimeout(timeout, ProxyConfig.MaxProxyTimeoutSec);\n                }\n                catch (Exception ex)\n                {\n                    MessageBox.Show(ex.Message);\n                    return;
                }\n                catch (Exception ex)\n                {\n                    MessageBox.Show(ex.Message);\n                    return;\n                }\n                controller.EnableProxy(type, proxy, port, timeout);\n            }\n            else\n            {
            }\n            else\n            {\n                controller.DisableProxy();\n            }\n            this.Close();\n        }\n        private void CancelButton_Click(object sender, EventArgs e)\n        {
            this.Close();\n        }\n        private void CancelButton_Click(object sender, EventArgs e)\n        {\n            this.Close();\n        }\n        private void ProxyForm_FormClosed(object sender, FormClosedEventArgs e)\n        {\n            controller.ConfigChanged -= controller_ConfigChanged;\n        }
                ProxyTypeComboBox.Enabled = true;\n            }\n            else\n            {\n                ProxyServerTextBox.Enabled = false;\n                ProxyPortTextBox.Enabled = false;\n                ProxyTimeoutTextBox.Enabled = false;\n                ProxyTypeComboBox.Enabled = false;\n            }\n        }
            }\n        }\n    }\n}
        public void Start(Configuration configuration)\n        {\n            Server server = configuration.GetCurrentServer();\n            if (_process == null)\n            {\n                Process[] existingPrivoxy = Process.GetProcessesByName("ss_privoxy");\n                foreach (Process p in existingPrivoxy.Where(IsChildProcess))\n                {\n                    KillProcess(p);\n                }
            if (_process == null)\n            {\n                Process[] existingPrivoxy = Process.GetProcessesByName("ss_privoxy");\n                foreach (Process p in existingPrivoxy.Where(IsChildProcess))\n                {\n                    KillProcess(p);\n                }\n                string privoxyConfig = Resources.privoxy_conf;\n                _runningPort = this.GetFreePort();\n                privoxyConfig = privoxyConfig.Replace("__SOCKS_PORT__", configuration.localPort.ToString());
            }\n            catch (Exception e)\n            {\n                // in case access denied\n                Logging.LogUsefulException(e);\n                return defaultPort;\n            }\n            throw new Exception("No free port found.");\n        }\n        [StructLayout(LayoutKind.Sequential)]\n        public struct RECT
        }\n        [StructLayout(LayoutKind.Sequential)]\n        public struct RECT\n        {\n            public int left;\n            public int top;\n            public int right;\n            public int bottom;\n        }\n        [DllImport("user32.dll")]
                    {\n                        if (rule[0] == '!' || rule[0] == '[')\n                            continue;\n                        lines.Add(rule);\n                    }\n                }
                    }\n                }\n                string abpContent;\n                if (File.Exists(PACServer.USER_ABP_FILE))\n                {\n                    abpContent = File.ReadAllText(PACServer.USER_ABP_FILE, Encoding.UTF8);\n                }\n                else\n                {\n                    abpContent = Utils.UnGzip(Resources.abp_js);
            {\n                if (line[0] == '!' || line[0] == '[')\n                    continue;\n                valid_lines.Add(line);\n            }\n            return valid_lines;
            }\n            return valid_lines;\n        }\n    }\n}
using System.Drawing;\nusing System.Windows.Forms;\nnamespace Shadowsocks.Model\n{\n    [Serializable]\n    public class LogViewerConfig\n    {\n        public string fontName;\n        public float fontSize;
        public bool topMost;\n        public bool wrapText;\n        public bool toolbarShown;
            topMost = false;\n            wrapText = false;\n            toolbarShown = false;\n            width = 600;\n            height = 400;\n            left = GetBestLeft();\n            top = GetBestTop();\n            maximized = true;\n        }
        }
        {\n            width = (width >= 400) ? width : 400;  // set up the minimum size\n            return Screen.PrimaryScreen.WorkingArea.Width - width;\n        }\n        public int GetBestTop()\n        {\n            height = (height >= 200) ? height : 200;  // set up the minimum size\n            return Screen.PrimaryScreen.WorkingArea.Height - height;\n        }\n        public Font GetFont()
            {\n        public void SetFont(Font font)
        {\n            fontName = font.Name;\n            fontSize = font.Size;\n        }\n        public Color GetBackgroundColor()\n        {\n            try\n            {\n                return ColorTranslator.FromHtml(bgColor);
            {\n                return ColorTranslator.FromHtml(bgColor);\n            }\n            catch (Exception)\n            {\n                return ColorTranslator.FromHtml("black");\n            }
            }\n        }\n        public void SetBackgroundColor(Color color)\n        {\n            bgColor = ColorTranslator.ToHtml(color);\n        }\n        public Color GetTextColor()\n        {\n            try\n            {
    }\n}
                }\n                catch (FormatException)\n                {\n                    MessageBox.Show(I18N.GetString("Illegal port number format"));\n                    return;\n                }\n                catch (Exception ex)\n                {\n                    MessageBox.Show(ex.Message);\n                    return;
namespace Shadowsocks.Model\n{\n    [Serializable]\n    public class ProxyConfig\n    {\n        public bool useProxy;\n        public string proxyServer;
            this.tableLayoutPanel1.Controls.Add(this.UseProxyCheckBox, 0, 0);\n            this.tableLayoutPanel1.Controls.Add(this.tableLayoutPanel2, 0, 1);\n            this.tableLayoutPanel1.Location = new System.Drawing.Point(15, 15);\n            this.tableLayoutPanel1.Name = "tableLayoutPanel1";\n            this.tableLayoutPanel1.RowCount = 3;\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.Size = new System.Drawing.Size(395, 87);
            this.tableLayoutPanel1.Location = new System.Drawing.Point(15, 15);\n            this.tableLayoutPanel1.Name = "tableLayoutPanel1";\n            this.tableLayoutPanel1.RowCount = 3;\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.Size = new System.Drawing.Size(395, 87);

        }\n        public int EndSend(IAsyncResult asyncResult)\n        {\n            return _remote.EndSend(asyncResult);\n        }\n        public void BeginReceive(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state)\n        {\n            _remote?.BeginReceive(buffer, offset, size, socketFlags, callback, state);\n        }
        }\n        public int EndReceive(IAsyncResult asyncResult)\n        {\n            return _remote.EndReceive(asyncResult);\n        }\n        public void Shutdown(SocketShutdown how)\n        {\n            _remote?.Shutdown(how);\n        }\n        public void Close()
        }\n        public void Close()\n        {\n            _remote?.Dispose();\n        }\n        private void ConnectCallback(IAsyncResult ar)\n        {\n            var state = (Socks5State) ar.AsyncState;\n            try\n            {
        }\n        private void ConnectCallback(IAsyncResult ar)\n        {\n            var state = (Socks5State) ar.AsyncState;\n            try\n            {\n                _remote.EndConnect(ar);\n                _remote.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n                byte[] handshake = {5, 1, 0};\n                _remote.BeginSend(handshake, 0, handshake.Length, 0, Socks5HandshakeSendCallback, state);
        {\n            _config.proxy.useProxy = true;\n            _config.proxy.proxyServer = proxy;\n            _config.proxy.proxyPort = port;\n            SaveConfig(_config);\n        }\n        public void ToggleVerboseLogging(bool enabled)\n        {\n            _config.isVerboseLogging = enabled;
        XmlDocument doc = new XmlDocument();\n        XmlElement logLevelElement;\n        XmlElement logFileNameElement;\n        /// <summary>\n        /// Load the NLog config xml file content\n        /// </summary>\n        public static NLogConfig LoadXML()\n        {\n            NLogConfig config = new NLogConfig();
        /// <summary>\n        /// Load the NLog config xml file content\n        /// </summary>\n        public static NLogConfig LoadXML()\n        {\n            NLogConfig config = new NLogConfig();\n            config.doc.Load(NLOG_CONFIG_FILE_NAME);\n            config.logLevelElement = (XmlElement)SelectSingleNode(config.doc, "//nlog:logger[@name='*']");\n            config.logFileNameElement = (XmlElement)SelectSingleNode(config.doc, "//nlog:target[@name='file']");\n            return config;
        }\n        /// <summary>\n        /// Set the target fileName to xml file\n        /// </summary>\n        /// <param name="fileName"></param>\n        public void SetLogFileName(string fileName)\n        {\n            logFileNameElement.SetAttribute(FILE_NAME_ATTRIBUTE, fileName);\n        }
using System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Drawing;\nusing System.Text;\nusing System.Windows.Forms;\nusing ZXing;\nusing ZXing.Common;\nusing ZXing.QrCode;
using System.Windows.Forms;\nusing ZXing;\nusing ZXing.Common;\nusing ZXing.QrCode;\nnamespace Shadowsocks.View\n{\n    public class MenuViewController
            this.notifyIcon1 = new System.Windows.Forms.NotifyIcon(this.components);\n            this.contextMenuStrip1 = new System.Windows.Forms.ContextMenuStrip(this.components);\n            this.ConfigItem = new System.Windows.Forms.ToolStripMenuItem();\n            this.aboutToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();\n            this.toolStripSeparator2 = new System.Windows.Forms.ToolStripSeparator();\n            this.QuitItem = new System.Windows.Forms.ToolStripMenuItem();
            this.SuspendLayout();\n            // \n            // tableLayoutPanel1\n            // \n            this.tableLayoutPanel1.AutoSize = true;\n            this.tableLayoutPanel1.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;\n            this.tableLayoutPanel1.ColumnCount = 2;\n            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());\n            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());\n            this.tableLayoutPanel1.Controls.Add(this.label1, 0, 0);\n            this.tableLayoutPanel1.Controls.Add(this.label2, 0, 1);
            this.ResumeLayout(false);\n            this.PerformLayout();\n        }\n        #endregion\n        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel1;\n        private System.Windows.Forms.Label label1;\n        private System.Windows.Forms.Label label2;\n        private System.Windows.Forms.Label label3;\n        private System.Windows.Forms.Label label4;\n        private System.Windows.Forms.TextBox textBox1;
        private System.Windows.Forms.NotifyIcon notifyIcon1;\n        private System.Windows.Forms.ContextMenuStrip contextMenuStrip1;\n        private System.Windows.Forms.ToolStripMenuItem ConfigItem;\n        private System.Windows.Forms.ToolStripMenuItem QuitItem;\n        private System.Windows.Forms.ToolStripMenuItem aboutToolStripMenuItem;\n        private System.Windows.Forms.ToolStripSeparator toolStripSeparator2;
        {\n            MD5 md5 = System.Security.Cryptography.MD5.Create();\n            byte[] inputBytes = System.Text.Encoding.UTF8.GetBytes(password);\n            byte[] hash = md5.ComputeHash(inputBytes);\n            // TODO endian\n            var a = BitConverter.ToUInt64(hash, 0);\n            for (int i = 0; i < 256; i++)\n            {\n                encryptTable[i] = (byte)i;\n            }
            }\n        }\n        public void Encrypt(byte[] buf, int length)\n        {\n            for (int i = 0; i < length; i++)\n            {\n                buf[i] = encryptTable[buf[i]];
            {\n                buf[i] = encryptTable[buf[i]];\n            }\n        }
            }\n        }\n        public void Decrypt(byte[] buf, int length)\n        {\n            for (int i = 0; i < length; i++)\n            {\n                buf[i] = decryptTable[buf[i]];
            {\n                buf[i] = decryptTable[buf[i]];\n            }\n        }
            }\n        }\n    }\n}
using System.Net.Sockets;\nusing System.Net;\nusing Shadowsocks.Encryption;\nusing Shadowsocks.Model;\nusing Shadowsocks.Controller.Strategy;\nusing System.Timers;\nnamespace Shadowsocks.Controller\n{
using Shadowsocks.Encryption;\nusing Shadowsocks.Model;\nusing Shadowsocks.Controller.Strategy;\nusing System.Timers;\nnamespace Shadowsocks.Controller\n{\n    class TCPRelay : Listener.Service\n    {\n        private ShadowsocksController _controller;\n        private DateTime _lastSweepTime;
namespace Shadowsocks.Controller\n{\n    class TCPRelay : Listener.Service\n    {\n        private ShadowsocksController _controller;\n        private DateTime _lastSweepTime;\n        public ISet<Handler> Handlers\n        {\n            get; set;\n        }
        {\n            get; set;\n        }\n        public TCPRelay(ShadowsocksController controller)\n        {\n            this._controller = controller;\n            this.Handlers = new HashSet<Handler>();\n            this._lastSweepTime = DateTime.Now;\n        }\n        public bool Handle(byte[] firstPacket, int length, Socket socket, object state)
        }\n        public bool Handle(byte[] firstPacket, int length, Socket socket, object state)\n        {\n            if (socket.ProtocolType != ProtocolType.Tcp)\n            {\n                return false;\n            }\n            if (length < 2 || firstPacket[0] != 5)\n            {\n                return false;
            handler.connection = socket;\n            handler.controller = _controller;\n            handler.relay = this;\n            handler.Start(firstPacket, length);\n            IList<Handler> handlersToClose = new List<Handler>();\n            lock (this.Handlers)\n            {\n                this.Handlers.Add(handler);\n                Logging.Debug($"TCP connections: {Handlers.Count}");\n                DateTime now = DateTime.Now;
                DateTime now = DateTime.Now;\n                if (now - _lastSweepTime > TimeSpan.FromSeconds(1))\n                {\n                    _lastSweepTime = now;\n                    foreach (Handler handler1 in this.Handlers)\n                    {\n                        if (now - handler1.lastActivity > TimeSpan.FromSeconds(900))\n                        {\n                            handlersToClose.Add(handler1);\n                        }
                    {\n                        if (now - handler1.lastActivity > TimeSpan.FromSeconds(900))\n                        {\n                            handlersToClose.Add(handler1);\n                        }\n                    }\n                }\n            }\n            foreach (Handler handler1 in handlersToClose)\n            {
            {\n                Logging.Debug("Closing timed out TCP connection.");\n                handler1.Close();\n            }\n            return true;\n        }
    {\n        private int retryCount = 0;
            this.server = server;\n        }\n        public void Start(byte[] firstPacket, int length)\n        {\n            this._firstPacket = firstPacket;\n            this._firstPacketLength = length;\n            this.HandshakeReceive();\n            this.lastActivity = DateTime.Now;\n        }\n        private void CheckClose()
        }\n        private void CheckClose()\n        {\n            if (connectionShutdown && remoteShutdown)\n            {\n                this.Close();\n            }\n        }\n        public void Close()\n        {
            }\n        }\n        public void Close()\n        {\n            lock (relay.Handlers)\n            {\n                Logging.Debug($"TCP connections: {relay.Handlers.Count}");\n                relay.Handlers.Remove(this);\n            }\n            lock (this)
                relay.Handlers.Remove(this);\n            }\n            lock (this)\n            {\n                if (closed)\n                {\n                    return;\n                }\n                closed = true;\n            }
                    connection.BeginSend(response, 0, response.Length, 0, new AsyncCallback(HandshakeSendCallback), null);\n                }\n                else\n                {\n                    this.Close();\n                }\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);
            }\n        }\n        private void HandshakeSendCallback(IAsyncResult ar)\n        {\n            if (closed)\n            {\n                return;\n            }\n            try\n            {
                        connection.BeginSend(response, 0, response.Length, 0, new AsyncCallback(ResponseCallback), null);\n                    }\n                    else if (command == 3)\n                    {\n                        HandleUDPAssociate();\n                    }\n                }\n                else\n                {\n                    Logging.Error("failed to recv data in handshakeReceive2Callback");
            }\n        }\n        private void HandleUDPAssociate()\n        {\n            IPEndPoint endPoint = (IPEndPoint)connection.LocalEndPoint;\n            byte[] address = endPoint.Address.GetAddressBytes();\n            int port = endPoint.Port;\n            byte[] response = new byte[4 + address.Length + 2];\n            response[0] = 5;\n            if (endPoint.AddressFamily == AddressFamily.InterNetwork)
                }\n                else\n                {\n                    int bytesRead = connection.EndReceive(ar);\n                    if (bytesRead > 0)\n                    {\n                        Logging.Debug($"======Receive Local Port, size:" + RecvSize);\n                        connection.BeginReceive(connetionRecvBuffer, 0, RecvSize, 0,\n                            new AsyncCallback(ReadAll), null);
                    }\n                    else\n                    {\n                        this.Close();\n                    }\n                }\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);
            }\n        }\n        private void ResponseCallback(IAsyncResult ar)\n        {\n            try\n            {\n                connection.EndSend(ar);\n                StartConnect();\n            }\n            catch (Exception e)
                StartConnect();\n                retryCount++;\n            }\n            else\n            {\n                this.Close();\n            }\n        }\n        private void ConnectCallback(IAsyncResult ar)\n        {
            }\n        }\n        private void ConnectCallback(IAsyncResult ar)\n        {\n            Server server = null;\n            if (closed)\n            {\n                return;\n            }\n            try
                    int bytesToSend;\n                    lock (decryptionLock)\n                    {\n                        if (closed)\n                        {\n                            return;\n                        }\n                        encryptor.Decrypt(remoteRecvBuffer, bytesRead, remoteSendBuffer, out bytesToSend);\n                    }\n                    Logging.Debug($"======Send Local Port, size:" + bytesToSend);
                    connection.BeginSend(remoteSendBuffer, 0, bytesToSend, 0, new AsyncCallback(PipeConnectionSendCallback), null);\n                    IStrategy strategy = controller.GetCurrentStrategy();\n                    if (strategy != null)\n                    {\n                        strategy.UpdateLastRead(this.server);\n                    }\n                }\n                else\n                {\n                    connection.Shutdown(SocketShutdown.Send);
                    }\n                }\n                else\n                {\n                    connection.Shutdown(SocketShutdown.Send);\n                    connectionShutdown = true;\n                    CheckClose();\n                    if (totalRead == 0)\n                    {\n                        // closed before anything received, reports as failure
            }\n        }\n        private void PipeConnectionReceiveCallback(IAsyncResult ar)\n        {\n            if (closed)\n            {\n                return;\n            }\n            try\n            {
                    remote.BeginSend(connetionSendBuffer, 0, bytesToSend, 0, new AsyncCallback(PipeRemoteSendCallback), null);\n                    IStrategy strategy = controller.GetCurrentStrategy();\n                    if (strategy != null)\n                    {\n                        strategy.UpdateLastWrite(this.server);\n                    }\n                }\n                else\n                {\n                    remote.Shutdown(SocketShutdown.Send);
                    }\n                }\n                else\n                {\n                    remote.Shutdown(SocketShutdown.Send);\n                    remoteShutdown = true;\n                    CheckClose();\n                }\n            }\n            catch (Exception e)
using System.Collections.Generic;\nusing System.Net;\nusing System.Net.NetworkInformation;\nusing System.Net.Sockets;\nusing System.Text;\nnamespace Shadowsocks.Controller\n{\n    public class Listener\n    {\n        public interface Service
namespace Shadowsocks.Controller\n{\n    public class Listener\n    {\n        public interface Service\n        {\n            bool Handle(byte[] firstPacket, int length, Socket socket, object state);\n        }\n        public class UDPState\n        {
using System.Collections.Generic;\nusing System.Text;\nusing System.Threading;\nusing System.Net.Sockets;\nusing Shadowsocks.Controller.Strategy;\nusing System.Net;
using Shadowsocks.Controller.Strategy;\nusing System.Net;\nusing Shadowsocks.Util;\nusing Shadowsocks.Properties;\nnamespace Shadowsocks.Controller\n{\n    public class ShadowsocksController\n    {
using Shadowsocks.Util;\nusing Shadowsocks.Properties;\nnamespace Shadowsocks.Controller\n{\n    public class ShadowsocksController\n    {\n        // controller:\n        // handle user actions\n        // manipulates UI\n        // interacts with low level logic
namespace Shadowsocks.Controller\n{\n    public class ShadowsocksController\n    {\n        // controller:\n        // handle user actions\n        // manipulates UI\n        // interacts with low level logic\n        private Thread _ramThread;\n        private Listener _listener;
using Shadowsocks.Encryption;\nusing Shadowsocks.Model;\nusing System.Net.Sockets;\nusing System.Net;\nusing System.Runtime.CompilerServices;\nusing Shadowsocks.Controller.Strategy;\nnamespace Shadowsocks.Controller\n{\n    class UDPRelay : Listener.Service\n    {
namespace Shadowsocks.Controller\n{\n    class UDPRelay : Listener.Service\n    {\n        private ShadowsocksController _controller;\n        private LRUCache<IPEndPoint, UDPHandler> _cache;\n        public UDPRelay(ShadowsocksController controller)\n        {
using System.Diagnostics;\nusing System.IO;\nusing System.IO.Compression;\nusing System.Runtime.InteropServices;\nusing System.Text;\nusing System.Windows.Forms;\nusing Shadowsocks.Controller;\nnamespace Shadowsocks.Util\n{\n    public class Utils
using System.Windows.Forms;\nusing Shadowsocks.Controller;\nnamespace Shadowsocks.Util\n{\n    public class Utils\n    {\n        // return path to store temporary files\n        public static string GetTempPath()\n        {\n            if (File.Exists(Application.StartupPath + "\\shadowsocks_portable_mode.txt"))
using System.Drawing;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Windows.Forms;\nusing Shadowsocks.Controller;\nusing Shadowsocks.Properties;\nusing Shadowsocks.Model;\nnamespace Shadowsocks.View
using System.Windows.Forms;\nusing Shadowsocks.Controller;\nusing Shadowsocks.Properties;\nusing Shadowsocks.Model;\nnamespace Shadowsocks.View\n{\n    public partial class LogForm : Form\n    {\n        long lastOffset;
using System.Net;\nusing System.Net.Sockets;\nusing System.Text;\nnamespace Shadowsocks.Controller\n{\n    class PortForwarder : Listener.Service\n    {\n        int _targetPort;\n        public PortForwarder(int targetPort)\n        {
namespace Shadowsocks.Controller\n{\n    class PortForwarder : Listener.Service\n    {\n        int _targetPort;\n        public PortForwarder(int targetPort)\n        {\n            this._targetPort = targetPort;\n        }\n        public bool Handle(byte[] firstPacket, int length, Socket socket, object state)
            public void UpdateInbound(long delta)\n            {\n                bool lockTaken = false;\n                try\n                {\n                    _lock.Enter(ref lockTaken);\n                    Interlocked.Add(ref _inbound, delta);\n                }\n                finally\n                {
            }\n            public void UpdateOutbound(long delta)\n            {\n                bool lockTaken = false;\n                try\n                {\n                    _lock.Enter(ref lockTaken);\n                    Interlocked.Add(ref _outbound, delta);\n                }\n                finally
            }\n            public void GetDelta(out long inboundDelta, out long outboundDelta)\n            {\n                bool lockTaken = false;\n                try\n                {\n                    _lock.Enter(ref lockTaken);\n                    var i = Interlocked.Read(ref _inbound);\n                    var il = Interlocked.Exchange(ref _lastInbound, i);\n                    inboundDelta = i - il;
            }\n        }\n        //tasks\n        private readonly TimeSpan _delayBeforeStart = TimeSpan.FromSeconds(1);\n        private readonly TimeSpan _retryInterval = TimeSpan.FromMinutes(2);\n        private Timer _recorder; //analyze and save cached records to RawStatistics and filter records\n        private TimeSpan RecordingInterval => TimeSpan.FromMinutes(Config.DataCollectionMinutes);\n        private Timer _speedMonior;\n        private readonly TimeSpan _monitorInterval = TimeSpan.FromSeconds(1);\n        //private Timer _writer; //write RawStatistics to file
        void BeginConnectProxy(EndPoint remoteEP, AsyncCallback callback, object state);\n        void EndConnectProxy(IAsyncResult asyncResult);\n        void BeginConnectDest(string host, int port, AsyncCallback callback, object state);\n        void EndConnectDest(IAsyncResult asyncResult);\n        void BeginSend(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state);\n        int EndSend(IAsyncResult asyncResult);\n        void BeginReceive(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state);\n        int EndReceive(IAsyncResult asyncResult);
        void EndConnectDest(IAsyncResult asyncResult);\n        void BeginSend(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state);\n        int EndSend(IAsyncResult asyncResult);\n        void BeginReceive(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state);\n        int EndReceive(IAsyncResult asyncResult);\n        void Shutdown(SocketShutdown how);\n        void Close();\n    }
            byte[] request = null;\n            byte atyp = 0;\n            IPAddress ipAddress;\n            bool parsed = IPAddress.TryParse(host, out ipAddress);\n            if (parsed)\n            {\n                IPEndPoint ep = new IPEndPoint(ipAddress, port);\n                switch (ep.AddressFamily)
                {\n                    case AddressFamily.InterNetwork:\n                        request = new byte[4 + 4 + 2];\n                        atyp = 1; // IP V4 address\n                        break;\n                    case AddressFamily.InterNetworkV6:\n                        request = new byte[4 + 16 + 2];\n                        atyp = 4; // IP V6 address\n                        break;\n                    default:
                Array.Copy(addr, 0, request, 4, request.Length - 4 - 2);\n            }\n            else\n            {\n                // maybe is a domain name, we will leave it to server\n                // need ValidateTcpPort? porttest > 1 && porttest < 65535?\n                atyp = 3; // DOMAINNAME\n                var enc = Encoding.UTF8;\n                var hostByteCount = enc.GetByteCount(host);\n                request = new byte[4 + 1/*length byte*/ + hostByteCount + 2];
            }\n            // 构造request包剩余部分\n            request[0] = 5;\n            request[1] = 1;\n            request[2] = 0;\n            request[3] = atyp;\n            request[request.Length - 2] = (byte) ((port >> 8) & 0xff);\n            request[request.Length - 1] = (byte) (port & 0xff);\n            var st = new Socks5State();\n            st.Callback = callback;
        public void BeginConnectProxy(EndPoint remoteEP, AsyncCallback callback, object state)\n        {\n            // do nothing\n            var r = new FakeAsyncResult(state);\n            callback?.Invoke(r);\n        }\n        public void EndConnectProxy(IAsyncResult asyncResult)\n        {\n            // do nothing\n        }\n        public void BeginConnectDest(string host, int port, AsyncCallback callback, object state)\n        {
        {\n            // TODO async resolving\n            IPAddress ipAddress;\n            bool parsed = IPAddress.TryParse(host, out ipAddress);\n            if (!parsed)
            {\n                IPHostEntry ipHostInfo = Dns.GetHostEntry(host);\n                ipAddress = ipHostInfo.AddressList[0];\n            }\n            IPEndPoint remoteEP = new IPEndPoint(ipAddress, port);\n            DestHost = host;\n            DestPort = port;
            }\n            IPEndPoint remoteEP = new IPEndPoint(ipAddress, port);\n            DestHost = host;\n            DestPort = port;\n            if (_remote == null)\n            {\n                _remote = new Socket(remoteEP.AddressFamily, SocketType.Stream, ProtocolType.Tcp);\n                _remote.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n            }\n            _remote.BeginConnect(remoteEP, callback, state);
            if (_remote == null)\n            {\n                _remote = new Socket(remoteEP.AddressFamily, SocketType.Stream, ProtocolType.Tcp);\n                _remote.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n            }\n            _remote.BeginConnect(remoteEP, callback, state);\n        }\n        public void EndConnectDest(IAsyncResult asyncResult)\n        {\n            _remote?.EndConnect(asyncResult);
                _remote.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n            }\n            _remote.BeginConnect(remoteEP, callback, state);\n        }\n        public void EndConnectDest(IAsyncResult asyncResult)\n        {\n            _remote?.EndConnect(asyncResult);\n        }\n        public void BeginSend(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state)
        }\n        public void EndConnectDest(IAsyncResult asyncResult)\n        {\n            _remote?.EndConnect(asyncResult);\n        }\n        public void BeginSend(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state)\n        {\n            _remote?.BeginSend(buffer, offset, size, socketFlags, callback, state);\n        }
        {\n            this.controller = controller;\n            this.filename = filename;\n            InitializeComponent();\n            Icon = Icon.FromHandle(Resources.ssw128.GetHicon());\n            LogViewerConfig config = controller.GetConfigurationCopy().logViewer;\n            topMostTrigger = config.topMost;\n            wrapTextTrigger = config.wrapText;
            InitializeComponent();\n            Icon = Icon.FromHandle(Resources.ssw128.GetHicon());\n            LogViewerConfig config = controller.GetConfigurationCopy().logViewer;\n            topMostTrigger = config.topMost;\n            wrapTextTrigger = config.wrapText;\n            toolbarTrigger = config.toolbarShown;\n            LogMessageTextBox.BackColor = config.BackgroundColor;\n            LogMessageTextBox.ForeColor = config.TextColor;
{\n    public class SodiumEncryptor\n        : IVEncryptor, IDisposable\n    {\n        const int CIPHER_SALSA20 = 1;\n        const int CIPHER_CHACHA20 = 2;\n        const int CIPHER_CHACHA20_IETF = 3;\n        const int SODIUM_BLOCK_SIZE = 64;\n        protected int _encryptBytesRemaining;\n        protected int _decryptBytesRemaining;
    {\n        const int CIPHER_SALSA20 = 1;\n        const int CIPHER_CHACHA20 = 2;\n        const int CIPHER_CHACHA20_IETF = 3;\n        const int SODIUM_BLOCK_SIZE = 64;\n        protected int _encryptBytesRemaining;\n        protected int _decryptBytesRemaining;\n        protected ulong _encryptIC;\n        protected ulong _decryptIC;\n        protected byte[] _encryptBuf;
        {\n            // TODO write a unidirection cipher so we don't have to if if if\n            int bytesRemaining;\n            ulong ic;\n            byte[] sodiumBuf;\n            byte[] iv;\n            if (isCipher)\n            {\n                bytesRemaining = _encryptBytesRemaining;
            {\n                bytesRemaining = _encryptBytesRemaining;\n                ic = _encryptIC;\n                sodiumBuf = _encryptBuf;\n                iv = _encryptIV;\n            }\n            else\n            {\n                bytesRemaining = _decryptBytesRemaining;\n                ic = _decryptIC;
                    break;\n                case CIPHER_CHACHA20:\n                    Sodium.crypto_stream_chacha20_xor_ic(sodiumBuf, sodiumBuf, (ulong)(padding + length), iv, ic, _key);\n                    break;\n                case CIPHER_CHACHA20_IETF:\n                    Sodium.crypto_stream_chacha20_ietf_xor_ic(sodiumBuf, sodiumBuf, (ulong)(padding + length), iv, (uint)ic, _key);\n                    break;\n            }\n            Buffer.BlockCopy(sodiumBuf, padding, outbuf, 0, length);
                    break;\n                case CIPHER_CHACHA20_IETF:\n                    Sodium.crypto_stream_chacha20_ietf_xor_ic(sodiumBuf, sodiumBuf, (ulong)(padding + length), iv, (uint)ic, _key);\n                    break;\n            }\n            Buffer.BlockCopy(sodiumBuf, padding, outbuf, 0, length);\n            padding += length;\n            ic += (ulong)padding / SODIUM_BLOCK_SIZE;\n            bytesRemaining = padding % SODIUM_BLOCK_SIZE;
                    break;\n            }\n            Buffer.BlockCopy(sodiumBuf, padding, outbuf, 0, length);\n            padding += length;\n            ic += (ulong)padding / SODIUM_BLOCK_SIZE;\n            bytesRemaining = padding % SODIUM_BLOCK_SIZE;\n            if (isCipher)\n            {\n                _encryptBytesRemaining = bytesRemaining;
            {\n                _encryptBytesRemaining = bytesRemaining;\n                _encryptIC = ic;\n            }\n            else\n            {\n                _decryptBytesRemaining = bytesRemaining;\n                _decryptIC = ic;\n            }\n        }
{\n    public struct EncryptorInfo\n    {\n        public int KeySize;\n        public int IvSize;\n        public int Type;\n        public string InnerLibName;
    {\n        public int KeySize;\n        public int IvSize;\n        public int Type;\n        public string InnerLibName;\n        // For those who make use of internal crypto method name\n        // e.g. mbed TLS
        {\n            Method = method;\n            Password = password;\n            OnetimeAuth = onetimeauth;\n            IsUDP = isudp;\n        }\n        protected string Method;\n        protected string Password;\n        protected bool OnetimeAuth;\n        protected bool IsUDP;
        }\n        protected string Method;\n        protected string Password;\n        protected bool OnetimeAuth;\n        protected bool IsUDP;\n        protected byte[] GetPasswordHash()\n        {\n            byte[] inputBytes = Encoding.UTF8.GetBytes(Password);\n            byte[] hash = MbedTLS.MD5(inputBytes);\n            return hash;
        public abstract void Encrypt(byte[] buf, int length, byte[] outbuf, out int outlength);\n        public abstract void Decrypt(byte[] buf, int length, byte[] outbuf, out int outlength);\n        public abstract void Dispose();\n    }\n}
    {\n        const string DLLNAME = "libsscrypto";\n        static Sodium()\n        {\n            string dllPath = Utils.GetTempPath("libsscrypto.dll");\n            try\n            {
        static Sodium()\n        {\n            string dllPath = Utils.GetTempPath("libsscrypto.dll");\n            try\n            {\n                FileManager.UncompressFile(dllPath, Resources.libsscrypto_dll);\n            }\n            catch (IOException)\n            {\n            }
            try\n            {\n                FileManager.UncompressFile(dllPath, Resources.libsscrypto_dll);\n            }\n            catch (IOException)\n            {\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);
            {\n                Logging.LogUsefulException(e);\n            }\n            LoadLibrary(dllPath);
        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public static extern int crypto_stream_chacha20_xor_ic(byte[] c, byte[] m, ulong mlen, byte[] n, ulong ic, byte[] k);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public static extern int crypto_stream_chacha20_ietf_xor_ic(byte[] c, byte[] m, ulong mlen, byte[] n, uint ic, byte[] k);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public static extern void ss_sha1_hmac_ex(byte[] key, uint keylen,\n            byte[] input, int ioff, uint ilen,\n            byte[] output);
        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public static extern int crypto_stream_chacha20_ietf_xor_ic(byte[] c, byte[] m, ulong mlen, byte[] n, uint ic, byte[] k);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public static extern void ss_sha1_hmac_ex(byte[] key, uint keylen,\n            byte[] input, int ioff, uint ilen,\n            byte[] output);
        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public static extern void ss_sha1_hmac_ex(byte[] key, uint keylen,\n            byte[] input, int ioff, uint ilen,\n            byte[] output);
    }\n}
        }\n        public static void GetBytes(byte[] buf, int len)\n        {\n            try\n            {\n                _rng.GetBytes(buf, 0, len);\n            }\n            catch (Exception)\n            {
            {\n                // the backup way\n                byte[] tmp = new byte[len];\n                _rng.GetBytes(tmp);\n                Buffer.BlockCopy(tmp, 0, buf, 0, len);\n            }\n        }\n    }\n}
        public long outbound = 0;\n        public long inbound = 0;\n        public UDPRelay(ShadowsocksController controller)\n        {\n            this._controller = controller;\n            this._cache = new LRUCache<IPEndPoint, UDPHandler>(512);  // todo: choose a smart number\n        }\n        public override bool Handle(byte[] firstPacket, int length, Socket socket, object state)\n        {\n            if (socket.ProtocolType != ProtocolType.Udp)
        }\n        public override bool Handle(byte[] firstPacket, int length, Socket socket, object state)\n        {\n            if (socket.ProtocolType != ProtocolType.Udp)\n            {\n                return false;\n            }\n            if (length < 4)\n            {\n                return false;
                Array.Copy(data, 3, dataIn, 0, length - 3);\n                byte[] dataOut = new byte[length - 3 + 16 + IVEncryptor.ONETIMEAUTH_BYTES];\n                int outlen;\n                encryptor.Encrypt(dataIn, length - 3, dataOut, out outlen);\n                Logging.Debug(_localEndPoint, _remoteEndPoint, outlen, "UDP Relay");\n                _remote?.SendTo(dataOut, outlen, SocketFlags.None, _remoteEndPoint);\n            }\n            public void Receive()\n            {\n                EndPoint remoteEndPoint = new IPEndPoint(IPAddress.Any, 0);
                int outlen;\n                encryptor.Encrypt(dataIn, length - 3, dataOut, out outlen);\n                Logging.Debug(_localEndPoint, _remoteEndPoint, outlen, "UDP Relay");\n                _remote?.SendTo(dataOut, outlen, SocketFlags.None, _remoteEndPoint);\n            }\n            public void Receive()\n            {\n                EndPoint remoteEndPoint = new IPEndPoint(IPAddress.Any, 0);\n                Logging.Debug($"++++++Receive Server Port, size:" + _buffer.Length);\n                _remote?.BeginReceiveFrom(_buffer, 0, _buffer.Length, 0, ref remoteEndPoint, new AsyncCallback(RecvFromCallback), null);
                Logging.Debug(_localEndPoint, _remoteEndPoint, outlen, "UDP Relay");\n                _remote?.SendTo(dataOut, outlen, SocketFlags.None, _remoteEndPoint);\n            }\n            public void Receive()\n            {\n                EndPoint remoteEndPoint = new IPEndPoint(IPAddress.Any, 0);\n                Logging.Debug($"++++++Receive Server Port, size:" + _buffer.Length);\n                _remote?.BeginReceiveFrom(_buffer, 0, _buffer.Length, 0, ref remoteEndPoint, new AsyncCallback(RecvFromCallback), null);\n            }\n            public void RecvFromCallback(IAsyncResult ar)
        public DateTime lastActivity;\n        private bool        _proxyConnected;\n        private bool        _destConnected;
        // instance-based lock without static
            this._server = server;\n        }\n        public void Start(byte[] firstPacket, int length)\n        {\n            _firstPacket = firstPacket;\n            _firstPacketLength = length;\n            HandshakeReceive();\n        }
        {\n            if (_closed) return;\n            try\n            {\n                int bytesRead = _connection.EndReceive(ar);\n                if (bytesRead >= 5)\n                {\n                    _command = _connetionRecvBuffer[1];\n                    if (_command != 1 && _command != 3)\n                    {
                    {\n                        Logging.Debug("Unsupported CMD=" + _command);\n                        Close();\n                    }\n                    else\n                    {\n                        if (_command == 1)\n                        {\n                            byte[] response = { 5, 0, 0, 1, 0, 0, 0, 0, 0, 0 };\n                            _connection.BeginSend(response, 0, response.Length, SocketFlags.None,
                        {\n                            byte[] response = { 5, 0, 0, 1, 0, 0, 0, 0, 0, 0 };\n                            _connection.BeginSend(response, 0, response.Length, SocketFlags.None,\n                                new AsyncCallback(ResponseCallback), null);\n                        }\n                        else if (_command == 3)\n                        {\n                            ReadAddress(HandleUDPAssociate);\n                        }\n                    }
                        }\n                        else if (_command == 3)\n                        {\n                            ReadAddress(HandleUDPAssociate);\n                        }\n                    }\n                }\n                else\n                {\n                    Logging.Debug("failed to recv data in Shadowsocks.Controller.TCPHandler.handshakeReceive2Callback()");
                        {\n                            ReadAddress(HandleUDPAssociate);\n                        }\n                    }\n                }\n                else\n                {\n                    Logging.Debug("failed to recv data in Shadowsocks.Controller.TCPHandler.handshakeReceive2Callback()");
                    break;\n                case 3: // domain name, length + str\n                    int len = _connetionRecvBuffer[4];\n                    ReadAddress(len + 2, onSuccess);\n                    break;\n                case 4: // IPv6 address, 16 bytes\n                    ReadAddress(16 + 2 - 1, onSuccess);\n                    break;\n                default:\n                    Logging.Debug("Unsupported ATYP=" + atyp);
                    int len = _connetionRecvBuffer[4];\n                    ReadAddress(len + 2, onSuccess);\n                    break;\n                case 4: // IPv6 address, 16 bytes\n                    ReadAddress(16 + 2 - 1, onSuccess);\n                    break;\n                default:\n                    Logging.Debug("Unsupported ATYP=" + atyp);\n                    Close();\n                    break;
                    break;\n                case 4: // IPv6 address, 16 bytes\n                    ReadAddress(16 + 2 - 1, onSuccess);\n                    break;\n                default:\n                    Logging.Debug("Unsupported ATYP=" + atyp);\n                    Close();\n                    break;\n            }\n        }
                    break;\n                default:\n                    Logging.Debug("Unsupported ATYP=" + atyp);\n                    Close();\n                    break;\n            }\n        }\n        private void ReadAddress(int bytesRemain, Action onSuccess)\n        {\n            Array.Copy(_connetionRecvBuffer, 3, _connetionRecvBuffer, 0, 2);
            // Read the remain address bytes\n            _connection.BeginReceive(_connetionRecvBuffer, 2, RecvSize - 2, SocketFlags.None, OnAddressFullyRead, new object[] {bytesRemain, onSuccess});\n        }\n        private void OnAddressFullyRead(IAsyncResult ar)\n        {\n            if (_closed) return;\n            try\n            {\n                int bytesRead = _connection.EndReceive(ar);
                            break;\n                        case 3: // domain name, length + str\n                            int len = _connetionRecvBuffer[1];\n                            dst_addr = System.Text.Encoding.UTF8.GetString(_connetionRecvBuffer, 2, len);\n                            dst_port = (_connetionRecvBuffer[len + 2] << 8) + _connetionRecvBuffer[len + 3];\n                            break;\n                        case 4: // IPv6 address, 16 bytes\n                            dst_addr = $"[{new IPAddress(_connetionRecvBuffer.Skip(1).Take(16).ToArray())}]";\n                            dst_port = (_connetionRecvBuffer[17] << 8) + _connetionRecvBuffer[18];
                            int len = _connetionRecvBuffer[1];\n                            dst_addr = System.Text.Encoding.UTF8.GetString(_connetionRecvBuffer, 2, len);\n                            dst_port = (_connetionRecvBuffer[len + 2] << 8) + _connetionRecvBuffer[len + 3];\n                            break;\n                        case 4: // IPv6 address, 16 bytes\n                            dst_addr = $"[{new IPAddress(_connetionRecvBuffer.Skip(1).Take(16).ToArray())}]";\n                            dst_port = (_connetionRecvBuffer[17] << 8) + _connetionRecvBuffer[18];\n                            break;
                            break;\n                        case 4: // IPv6 address, 16 bytes\n                            dst_addr = $"[{new IPAddress(_connetionRecvBuffer.Skip(1).Take(16).ToArray())}]";\n                            dst_port = (_connetionRecvBuffer[17] << 8) + _connetionRecvBuffer[18];\n                            break;\n                    }\n                    if (_config.isVerboseLogging)\n                    {
                            break;\n                    }\n                    if (_config.isVerboseLogging)\n                    {
            response[0] = 5;\n            switch (endPoint.AddressFamily)\n            {\n                case AddressFamily.InterNetwork:\n                    response[3] = 1;\n                    break;\n                case AddressFamily.InterNetworkV6:\n                    response[3] = 4;\n                    break;\n            }
                    break;\n                case AddressFamily.InterNetworkV6:\n                    response[3] = 4;\n                    break;\n            }\n            address.CopyTo(response, 4);\n            response[response.Length - 1] = (byte)(port & 0xFF);\n            response[response.Length - 2] = (byte)((port >> 8) & 0xFF);\n            _connection.BeginSend(response, 0, response.Length, SocketFlags.None, new AsyncCallback(ReadAll), true);\n        }
                    break;\n            }\n            address.CopyTo(response, 4);\n            response[response.Length - 1] = (byte)(port & 0xFF);\n            response[response.Length - 2] = (byte)((port >> 8) & 0xFF);\n            _connection.BeginSend(response, 0, response.Length, SocketFlags.None, new AsyncCallback(ReadAll), true);\n        }\n        private void ReadAll(IAsyncResult ar)\n        {\n            if (_closed) return;
        }\n        private void ReadAll(IAsyncResult ar)\n        {\n            if (_closed) return;\n            try\n            {\n                if (ar.AsyncState != null)\n                {\n                    _connection.EndSend(ar);\n                    _connection.BeginReceive(_connetionRecvBuffer, 0, RecvSize, SocketFlags.None, new AsyncCallback(ReadAll), null);
                }\n                else\n                {\n                    int bytesRead = _connection.EndReceive(ar);\n                    if (bytesRead > 0)\n                    {\n                        _connection.BeginReceive(_connetionRecvBuffer, 0, RecvSize, SocketFlags.None, new AsyncCallback(ReadAll), null);\n                    }
                    }\n                    else\n                        Close();\n                }\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }
                if (_config.proxy.useProxy)\n                {\n                    switch (_config.proxy.proxyType)\n                    {\n                        case ProxyConfig.PROXY_SOCKS5:\n                            remote = new Socks5Proxy();\n                            break;\n                        case ProxyConfig.PROXY_HTTP:\n                            remote = new HttpProxy();\n                            break;
                proxyTimer.Enabled = true;\n                proxyTimer.Session = session;\n                proxyTimer.DestEndPoint = SocketUtil.GetEndPoint(_server.server, _server.server_port);\n                proxyTimer.Server = _server;\n                _proxyConnected = false;\n                // Connect to the proxy server.\n                remote.BeginConnectProxy(proxyEP, new AsyncCallback(ProxyConnectCallback), new AsyncSession<ProxyTimer>(remote, proxyTimer));\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);
            timer.Enabled = false;\n            timer.Dispose();\n            if (_proxyConnected || _destConnected || _closed)\n            {\n                return;\n            }\n            var proxy = timer.Session.Remote;\n            Logging.Info($"Proxy {proxy.ProxyEndPoint} timed out");\n            proxy.Close();\n            Close();
            if (_closed)\n            {\n                return;\n            }\n            try\n            {\n                server = timer.Server;
                timer.Enabled = false;\n                timer.Dispose();\n                var remote = session.Remote;\n                // Complete the connection.\n                remote.EndConnectProxy(ar);\n                _proxyConnected = true;\n                if (_config.isVerboseLogging)\n                {\n                    if (!(remote is DirectConnect))\n                    {
                connectTimer.Enabled = true;\n                connectTimer.Session = session;\n                connectTimer.Server = server;\n                _destConnected = false;\n                // Connect to the remote endpoint.\n                remote.BeginConnectDest(destEndPoint, new AsyncCallback(ConnectCallback), new AsyncSession<ServerTimer>(session, connectTimer));\n            }\n            catch (ArgumentException)\n            {
            }\n            catch (ArgumentException)\n            {\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }
                    lock (_decryptionLock)\n                    {\n                        _encryptor.Decrypt(_remoteRecvBuffer, bytesRead, _remoteSendBuffer, out bytesToSend);\n                    }\n                    _connection.BeginSend(_remoteSendBuffer, 0, bytesToSend, SocketFlags.None, new AsyncCallback(PipeConnectionSendCallback), session);
                    IStrategy strategy = _controller.GetCurrentStrategy();\n                    strategy?.UpdateLastRead(_server);\n                }\n                else\n                {\n                    _connection.Shutdown(SocketShutdown.Send);\n                    _connectionShutdown = true;\n                    CheckClose();\n                }\n            }
            }\n            _tcprelay.UpdateOutboundCounter(_server, bytesToSend);\n            _startSendingTime = DateTime.Now;\n            session.Remote.BeginSend(_connetionSendBuffer, 0, bytesToSend, SocketFlags.None, new AsyncCallback(PipeRemoteSendCallback), session);\n            IStrategy strategy = _controller.GetCurrentStrategy();\n            strategy?.UpdateLastWrite(_server);\n        }\n        private void PipeRemoteSendCallback(IAsyncResult ar)
            IStrategy strategy = _controller.GetCurrentStrategy();\n            strategy?.UpdateLastWrite(_server);\n        }\n        private void PipeRemoteSendCallback(IAsyncResult ar)\n        {\n            if (_closed) return;\n            try\n            {\n                var session = (AsyncSession)ar.AsyncState;\n                session.Remote.EndSend(ar);
        private void PipeConnectionSendCallback(IAsyncResult ar)\n        {\n            try\n            {\n                var session = (AsyncSession)ar.AsyncState;\n                _connection.EndSend(ar);\n                session.Remote.BeginReceive(_remoteRecvBuffer, 0, RecvSize, SocketFlags.None, new AsyncCallback(PipeRemoteReceiveCallback), session);
            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }\n    }\n}
{\n    public class MbedTLSEncryptor\n        : IVEncryptor, IDisposable\n    {\n        const int CIPHER_RC4 = 1;\n        const int CIPHER_AES = 2;\n        const int CIPHER_BLOWFISH = 3;\n        const int CIPHER_CAMELLIA = 4;\n        private IntPtr _encryptCtx = IntPtr.Zero;\n        private IntPtr _decryptCtx = IntPtr.Zero;
    {\n        const int CIPHER_RC4 = 1;\n        const int CIPHER_AES = 2;\n        const int CIPHER_BLOWFISH = 3;\n        const int CIPHER_CAMELLIA = 4;\n        private IntPtr _encryptCtx = IntPtr.Zero;\n        private IntPtr _decryptCtx = IntPtr.Zero;\n        public MbedTLSEncryptor(string method, string password, bool onetimeauth, bool isudp)\n            : base(method, password, onetimeauth, isudp)\n        {
        {\n        }\n        private static Dictionary<string, EncryptorInfo> _ciphers = new Dictionary<string, EncryptorInfo> {\n            { "aes-128-cfb", new EncryptorInfo("AES-128-CFB128", 16, 16, CIPHER_AES) },\n            { "aes-192-cfb", new EncryptorInfo("AES-192-CFB128", 24, 16, CIPHER_AES) },\n            { "aes-256-cfb", new EncryptorInfo("AES-256-CFB128", 32, 16, CIPHER_AES) },\n            { "aes-128-ctr", new EncryptorInfo("AES-128-CTR", 16, 16, CIPHER_AES) },\n            { "aes-192-ctr", new EncryptorInfo("AES-192-CTR", 24, 16, CIPHER_AES) },\n            { "aes-256-ctr", new EncryptorInfo("AES-256-CTR", 32, 16, CIPHER_AES) },\n            { "bf-cfb", new EncryptorInfo("BLOWFISH-CFB64", 16, 8, CIPHER_BLOWFISH) },
            IntPtr ctx = Marshal.AllocHGlobal(MbedTLS.cipher_get_size_ex());\n            if (isCipher)\n            {\n                _encryptCtx = ctx;\n            }\n            else\n            {\n                _decryptCtx = ctx;\n            }\n            byte[] realkey;
            if (MbedTLS.cipher_set_iv(ctx, iv, ivLen) != 0)\n                throw new Exception("Cannot set mbed TLS cipher IV");\n            if (MbedTLS.cipher_reset(ctx) != 0)\n                throw new Exception("Cannot finalize mbed TLS cipher context");\n        }\n        protected override void cipherUpdate(bool isCipher, int length, byte[] buf, byte[] outbuf)\n        {\n            // C# could be multi-threaded\n            if (_disposed)\n            {
            if (MbedTLS.cipher_reset(ctx) != 0)\n                throw new Exception("Cannot finalize mbed TLS cipher context");\n        }\n        protected override void cipherUpdate(bool isCipher, int length, byte[] buf, byte[] outbuf)\n        {\n            // C# could be multi-threaded\n            if (_disposed)\n            {\n                throw new ObjectDisposedException(this.ToString());\n            }\n            if (MbedTLS.cipher_update(isCipher ? _encryptCtx : _decryptCtx,
        }\n        protected override void cipherUpdate(bool isCipher, int length, byte[] buf, byte[] outbuf)\n        {\n            // C# could be multi-threaded\n            if (_disposed)\n            {\n                throw new ObjectDisposedException(this.ToString());\n            }\n            if (MbedTLS.cipher_update(isCipher ? _encryptCtx : _decryptCtx,\n                buf, length, outbuf, ref length) != 0 )\n                throw new Exception("Cannot update mbed TLS cipher context");
        {\n            // C# could be multi-threaded\n            if (_disposed)\n            {\n                throw new ObjectDisposedException(this.ToString());\n            }\n            if (MbedTLS.cipher_update(isCipher ? _encryptCtx : _decryptCtx,\n                buf, length, outbuf, ref length) != 0 )\n                throw new Exception("Cannot update mbed TLS cipher context");\n        }\n        #region IDisposable
                buf, length, outbuf, ref length) != 0 )\n                throw new Exception("Cannot update mbed TLS cipher context");\n        }\n        #region IDisposable\n        private bool _disposed;\n        // instance based lock\n        private readonly object _lock = new object();\n        public override void Dispose()\n        {\n            Dispose(true);
        }\n        #region IDisposable\n        private bool _disposed;\n        // instance based lock\n        private readonly object _lock = new object();\n        public override void Dispose()\n        {\n            Dispose(true);\n            GC.SuppressFinalize(this);\n        }\n        ~MbedTLSEncryptor()\n        {
        {\n            Dispose(false);\n        }\n        protected virtual void Dispose(bool disposing)\n        {\n            lock (_lock)\n            {\n                if (_disposed) return;\n                _disposed = true;\n            }
        static EncryptorFactory()\n        {\n            _registeredEncryptors = new Dictionary<string, Type>();\n            foreach (string method in MbedTLSEncryptor.SupportedCiphers())\n            {\n                _registeredEncryptors.Add(method, typeof(MbedTLSEncryptor));\n            }\n            foreach (string method in SodiumEncryptor.SupportedCiphers())\n            {
            {\n                _registeredEncryptors.Add(method, typeof(MbedTLSEncryptor));\n            }\n            foreach (string method in SodiumEncryptor.SupportedCiphers())\n            {\n                _registeredEncryptors.Add(method, typeof(SodiumEncryptor));
            }\n            foreach (string method in SodiumEncryptor.SupportedCiphers())\n            {\n                _registeredEncryptors.Add(method, typeof(SodiumEncryptor));
            {\n                _registeredEncryptors.Add(method, typeof(SodiumEncryptor));
            }\n        }\n        public static IEncryptor GetEncryptor(string method, string password, bool onetimeauth, bool isudp)\n        {\n            if (method.IsNullOrEmpty())\n            {\n                method = "aes-256-cfb";\n            }\n            method = method.ToLowerInvariant();\n            Type t = _registeredEncryptors[method];
        {\n            if (method.IsNullOrEmpty())\n            {\n                method = "aes-256-cfb";\n            }\n            method = method.ToLowerInvariant();\n            Type t = _registeredEncryptors[method];\n            ConstructorInfo c = t.GetConstructor(_constructorTypes);\n            IEncryptor result = (IEncryptor)c.Invoke(new object[] { method, password, onetimeauth, isudp });
            return result;\n        }\n    }\n}
    {\n        const string DLLNAME = "libsscrypto";\n        public const int MBEDTLS_ENCRYPT = 1;\n        public const int MBEDTLS_DECRYPT = 0;\n        static MbedTLS()\n        {\n            string dllPath = Utils.GetTempPath("libsscrypto.dll");\n            try\n            {\n                FileManager.UncompressFile(dllPath, Resources.libsscrypto_dll);
        public const int MBEDTLS_ENCRYPT = 1;\n        public const int MBEDTLS_DECRYPT = 0;\n        static MbedTLS()\n        {\n            string dllPath = Utils.GetTempPath("libsscrypto.dll");\n            try\n            {\n                FileManager.UncompressFile(dllPath, Resources.libsscrypto_dll);\n            }\n            catch (IOException)
            try\n            {\n                FileManager.UncompressFile(dllPath, Resources.libsscrypto_dll);\n            }\n            catch (IOException)\n            {\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);
            {\n                Logging.LogUsefulException(e);\n            }\n            LoadLibrary(dllPath);\n        }\n        public static byte[] MD5(byte[] input)\n        {\n            byte[] output = new byte[16];
        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public static extern int cipher_get_size_ex();
    }\n}
        }\n        /**\n         * once failed, try after 5 min\n         * and (last write - last read) < 5s\n         * and (now - last read) <  5s  // means not stuck\n         * and latency < 200ms, try after 30s\n         */\n        public void ChooseNewServer()\n        {\n            Server oldServer = _currentServer;

                {\n                    Console.WriteLine("HA switching to server: {0}", _currentServer.FriendlyName());\n                }\n                Logging.Debug(String.Format("choosing server: {0}", _currentServer.FriendlyName()));\n            }\n        }\n        public void UpdateLatency(Model.Server server, TimeSpan latency)\n        {
                }\n                Logging.Debug(String.Format("choosing server: {0}", _currentServer.FriendlyName()));\n            }\n        }\n        public void UpdateLatency(Model.Server server, TimeSpan latency)\n        {\n            Logging.Debug(String.Format("latency: {0} {1}", server.FriendlyName(), latency));\n            ServerStatus status;\n            if (_serverStatus.TryGetValue(server, out status))\n            {
            }\n        }\n        public void UpdateLatency(Model.Server server, TimeSpan latency)\n        {\n            Logging.Debug(String.Format("latency: {0} {1}", server.FriendlyName(), latency));\n            ServerStatus status;\n            if (_serverStatus.TryGetValue(server, out status))\n            {\n                status.latency = latency;\n                status.lastTimeDetectLatency = DateTime.Now;
            this.PasswordTextBox.Size = new System.Drawing.Size(160, 21);\n            this.PasswordTextBox.TabIndex = 2;\n            this.PasswordTextBox.WordWrap = false;
                        //new KeyValuePair<string, string>("data", reply.Buffer.ToString()); // The data of reply\n                    });\n                    Thread.Sleep(Timeout + new Random().Next() % Timeout);\n                    //Do ICMPTest in a random frequency\n                }\n                catch (Exception e)\n                {\n                    Logging.Error($"An exception occured while eveluating {server.FriendlyName()}");\n                    Logging.LogUsefulException(e);\n                }
            foreach (var dataLists in await TaskEx.WhenAll(_servers.Select(ICMPTest)))\n            {\n                if (dataLists == null) continue;\n                foreach (var dataList in dataLists.Where(dataList => dataList != null))\n                {\n                    Append(dataList, geolocationAndIsp.Result);\n                }\n            }\n        }\n        private static void Append(DataList dataList, IEnumerable<DataUnit> extra)
                }\n            }\n        }\n        private static void Append(DataList dataList, IEnumerable<DataUnit> extra)\n        {\n            var data = dataList.Concat(extra);\n            var dataLine = string.Join(Delimiter, data.Select(kv => kv.Value).ToArray());\n            string[] lines;\n            if (!File.Exists(AvailabilityStatisticsFile))\n            {
            public const string Unknown = "Unknown";\n        }\n        //TODO: redesign model\n        public class RawStatisticsData\n        {\n            public DateTime Timestamp;\n            public string ServerName;\n            public string ICMPStatus;\n            public int RoundtripTime;\n            public string Geolocation;\n            public string ISP;
        }\n        public class StatisticsData\n        {\n            public float PackageLoss;\n            public int AverageResponse;\n            public int MinResponse;\n            public int MaxResponse;\n        }\n        public void UpdateLatency(int latency)\n        {
                    Array.Copy(iv, _encryptIV, ivLen);\n                }\n                else\n                {\n                    _decryptIV = new byte[ivLen];\n                    _decryptIVOffset = new byte[8];\n                    Array.Copy(iv, _decryptIV, ivLen);\n                }\n            }\n            else if (_cipher == CIPHER_BF)
                    Array.Copy(iv, _decryptIV, ivLen);\n                }\n            }\n            else if (_cipher == CIPHER_BF)\n            {\n                PolarSSL.blowfish_init(ctx);\n                // PolarSSL takes key length by bit\n                PolarSSL.blowfish_setkey(ctx, realkey, keyLen * 8);\n                if (isCipher)\n                {
                    Array.Copy(iv, _encryptIV, ivLen);\n                }\n                else\n                {\n                    _decryptIV = new byte[ivLen];\n                    _decryptIVOffset = new byte[8];\n                    Array.Copy(iv, _decryptIV, ivLen);\n                }\n            }\n            else if (_cipher == CIPHER_RC4)
                    Array.Copy(iv, _decryptIV, ivLen);\n                }\n            }\n            else if (_cipher == CIPHER_RC4)\n            {\n                PolarSSL.arc4_init(ctx);\n                // PolarSSL RC4 takes key length by byte\n                PolarSSL.arc4_setup(ctx, realkey, keyLen);\n            }\n        }
                            break;\n                        case CIPHER_BF:\n                            PolarSSL.blowfish_crypt_cfb64(_encryptCtx, PolarSSL.BLOWFISH_ENCRYPT, length, _encryptIVOffset, _encryptIV, buf, tempbuf);\n                            break;\n                        case CIPHER_RC4:\n                            PolarSSL.arc4_crypt(_encryptCtx, length, buf, tempbuf);\n                            break;\n                    }\n                    outlength = length + ivLen;\n                    Buffer.BlockCopy(tempbuf, 0, outbuf, ivLen, length);
                            break;\n                        case CIPHER_RC4:\n                            PolarSSL.arc4_crypt(_encryptCtx, length, buf, tempbuf);\n                            break;\n                    }\n                    outlength = length + ivLen;\n                    Buffer.BlockCopy(tempbuf, 0, outbuf, ivLen, length);\n                }\n            }\n            else
                        break;\n                    case CIPHER_BF:\n                        PolarSSL.blowfish_crypt_cfb64(_encryptCtx, PolarSSL.BLOWFISH_ENCRYPT, length, _encryptIVOffset, _encryptIV, buf, outbuf);\n                        break;\n                    case CIPHER_RC4:\n                        PolarSSL.arc4_crypt(_encryptCtx, length, buf, outbuf);\n                        break;\n                }\n            }\n        }
                        break;\n                    case CIPHER_RC4:\n                        PolarSSL.arc4_crypt(_encryptCtx, length, buf, outbuf);\n                        break;\n                }\n            }\n        }\n        public override void Decrypt(byte[] buf, int length, byte[] outbuf, out int outlength)\n        {\n            if (_decryptCtx == IntPtr.Zero)
                            break;\n                        case CIPHER_BF:\n                            PolarSSL.blowfish_crypt_cfb64(_decryptCtx, PolarSSL.BLOWFISH_DECRYPT, length - ivLen, _decryptIVOffset, _decryptIV, tempbuf, outbuf);\n                            break;\n                        case CIPHER_RC4:\n                            PolarSSL.arc4_crypt(_decryptCtx, length - ivLen, tempbuf, outbuf);\n                            break;\n                    }\n                }\n            }
                            break;\n                        case CIPHER_RC4:\n                            PolarSSL.arc4_crypt(_decryptCtx, length - ivLen, tempbuf, outbuf);\n                            break;\n                    }\n                }\n            }\n            else\n            {\n                outlength = length;
                        break;\n                    case CIPHER_BF:\n                        PolarSSL.blowfish_crypt_cfb64(_decryptCtx, PolarSSL.BLOWFISH_DECRYPT, length, _decryptIVOffset, _decryptIV, buf, outbuf);\n                        break;\n                    case CIPHER_RC4:\n                        PolarSSL.arc4_crypt(_decryptCtx, length, buf, outbuf);\n                        break;\n                }\n            }\n        }
                        break;\n                    case CIPHER_RC4:\n                        PolarSSL.arc4_crypt(_decryptCtx, length, buf, outbuf);\n                        break;\n                }\n            }\n        }\n        #region IDisposable\n        private bool _disposed;\n        public override void Dispose()
            this.MyCancelButton.Name = "MyCancelButton";\n            this.MyCancelButton.Size = new System.Drawing.Size(75, 23);\n            this.MyCancelButton.TabIndex = 18;\n            this.MyCancelButton.Text = "Cancel";\n            this.MyCancelButton.UseVisualStyleBackColor = true;\n            this.MyCancelButton.Click += new System.EventHandler(this.CancelButton_Click);
using System.Drawing;\nusing System.Text;\nusing System.Windows.Forms;\nusing System.Diagnostics;\nusing Microsoft.Win32;\nusing Shadowsocks.Controller;\nusing Shadowsocks.Model;\nusing Shadowsocks.Properties;\nusing System.Threading.Tasks;\nnamespace Shadowsocks.View
using System.Windows.Forms;\nusing System.Diagnostics;\nusing Microsoft.Win32;\nusing Shadowsocks.Controller;\nusing Shadowsocks.Model;\nusing Shadowsocks.Properties;\nusing System.Threading.Tasks;\nnamespace Shadowsocks.View\n{\n    public partial class ConfigForm : Form
using Shadowsocks.Controller;\nusing Shadowsocks.Model;\nusing Shadowsocks.Properties;\nusing System.Threading.Tasks;\nnamespace Shadowsocks.View\n{\n    public partial class ConfigForm : Form\n    {\n        private ShadowsocksController controller;\n        // this is a copy of configuration that we are working on
namespace Shadowsocks.View\n{\n    public partial class ConfigForm : Form\n    {\n        private ShadowsocksController controller;\n        // this is a copy of configuration that we are working on\n        private Configuration _modifiedConfiguration;\n        private int _lastSelectedIndex = -1;\n        public ConfigForm(ShadowsocksController controller)\n        {
                byte[] dataIn = new byte[length - 3 + IVEncryptor.ONETIMEAUTH_BYTES];\n                Array.Copy(data, 3, dataIn, 0, length - 3);\n                byte[] dataOut = new byte[length - 3 + 16 + IVEncryptor.ONETIMEAUTH_BYTES];\n                int outlen;\n                encryptor.Encrypt(dataIn, length - 3, dataOut, out outlen, true);\n                _remote.SendTo(dataOut, outlen, SocketFlags.None, _remoteEndPoint);\n            }\n            public void Receive()\n            {\n                EndPoint remoteEndPoint = new IPEndPoint(IPAddress.Any, 0);
                _remote.SendTo(dataOut, outlen, SocketFlags.None, _remoteEndPoint);\n            }\n            public void Receive()\n            {\n                EndPoint remoteEndPoint = new IPEndPoint(IPAddress.Any, 0);\n                _remote.BeginReceiveFrom(_buffer, 0, _buffer.Length, 0, ref remoteEndPoint, new AsyncCallback(RecvFromCallback), null);\n            }\n            public void RecvFromCallback(IAsyncResult ar)\n            {\n                try
        {\n            if (!_encryptIVSent)\n            {\n                _encryptIVSent = true;
                randBytes(outbuf, ivLen);\n                initCipher(outbuf, true);\n                outlength = length + ivLen;\n                if (OnetimeAuth && ivLen > 0)\n                {\n                    if(!udp)\n                    {\n                        int headLen = getHeadLen(buf, length);\n                        int dataLen = length - headLen;\n                        buf[0] |= ONETIMEAUTH_FLAG;
                lock (tempbuf)\n                {\n                    cipherUpdate(true, length, buf, tempbuf);\n                    outlength = length + ivLen;\n                    Buffer.BlockCopy(tempbuf, 0, outbuf, ivLen, length);\n                }\n            }\n            else\n            {\n                if (OnetimeAuth && ivLen > 0)
                outlength = length;\n                cipherUpdate(true, length, buf, outbuf);\n            }\n        }\n        public override void Decrypt(byte[] buf, int length, byte[] outbuf, out int outlength)\n        {\n            if (!_decryptIVReceived)\n            {\n                _decryptIVReceived = true;\n                initCipher(buf, false);
        {\n            Method = method;\n            Password = password;\n            OnetimeAuth = onetimeauth;\n        }\n        protected string Method;\n        protected string Password;\n        protected bool OnetimeAuth;
        public abstract void Decrypt(byte[] buf, int length, byte[] outbuf, out int outlength);\n        public abstract void Dispose();\n    }\n}
        {\n            if (string.IsNullOrEmpty(method))\n            {\n                method = "table";\n            }\n            method = method.ToLowerInvariant();\n            Type t = _registeredEncryptors[method];\n            ConstructorInfo c = t.GetConstructor(_constructorTypes);\n            IEncryptor result = (IEncryptor)c.Invoke(new object[] { method, password, onetimeauth });\n            return result;
            return result;\n        }\n    }\n}
            decryptor.Decrypt(cipher, outLen, plain2, out outLen2);\n            Assert.AreEqual(plain.Length, outLen2);\n            for (int j = 0; j < plain.Length; j++)\n            {\n                Assert.AreEqual(plain[j], plain2[j]);\n            }\n            encryptor.Encrypt(plain, 1000, cipher, out outLen, false);\n            decryptor.Decrypt(cipher, outLen, plain2, out outLen2);\n            Assert.AreEqual(1000, outLen2);\n            for (int j = 0; j < outLen2; j++)
            decryptor.Decrypt(cipher, outLen, plain2, out outLen2);\n            Assert.AreEqual(1000, outLen2);\n            for (int j = 0; j < outLen2; j++)\n            {\n                Assert.AreEqual(plain[j], plain2[j]);\n            }\n            encryptor.Encrypt(plain, 12333, cipher, out outLen, false);\n            decryptor.Decrypt(cipher, outLen, plain2, out outLen2);\n            Assert.AreEqual(12333, outLen2);\n            for (int j = 0; j < outLen2; j++)
            decryptor.Decrypt(cipher, outLen, plain2, out outLen2);\n            Assert.AreEqual(12333, outLen2);\n            for (int j = 0; j < outLen2; j++)\n            {\n                Assert.AreEqual(plain[j], plain2[j]);\n            }\n        }\n        private static bool encryptionFailed = false;\n        private static object locker = new object();\n        [TestMethod]
            this.tableLayoutPanel2 = new System.Windows.Forms.TableLayoutPanel();\n            this.tableLayoutPanel1.SuspendLayout();\n            this.panel1.SuspendLayout();\n            this.tableLayoutPanel2.SuspendLayout();

        //speed in KiB/s\n        private long _lastInboundCounter;\n        private List<int> _inboundSpeedRecords;\n        private long _lastOutboundCounter;\n        private List<int> _outboundSpeedRecords;
        //tasks\n        private readonly TimeSpan _delayBeforeStart = TimeSpan.FromSeconds(1);\n        private readonly TimeSpan _retryInterval = TimeSpan.FromMinutes(2);\n        private Timer _recorder; //analyze and save cached records to RawStatistics and filter records\n        private TimeSpan RecordingInterval => TimeSpan.FromMinutes(Config.DataCollectionMinutes);\n        private Timer _speedMonior;\n        private readonly TimeSpan _monitorInterval = TimeSpan.FromSeconds(1);\n        private Timer _writer; //write RawStatistics to file\n        private readonly TimeSpan _writingInterval = TimeSpan.FromMinutes(1);\n        private ShadowsocksController _controller;\n        private StatisticsStrategyConfiguration Config => _controller.StatisticsConfiguration;
        private ShadowsocksController _controller;\n        private StatisticsStrategyConfiguration Config => _controller.StatisticsConfiguration;\n        private Server CurrentServer => _controller.GetCurrentServer();\n        // Static Singleton Initialization\n        public static AvailabilityStatistics Instance { get; } = new AvailabilityStatistics();\n        public Statistics RawStatistics { get; private set; }\n        public Statistics FilteredStatistics { get; private set; }\n        private AvailabilityStatistics()\n        {\n            RawStatistics = new Statistics();
        // Static Singleton Initialization\n        public static AvailabilityStatistics Instance { get; } = new AvailabilityStatistics();\n        public Statistics RawStatistics { get; private set; }\n        public Statistics FilteredStatistics { get; private set; }\n        private AvailabilityStatistics()\n        {\n            RawStatistics = new Statistics();\n        }\n        internal void UpdateConfiguration(ShadowsocksController controller)\n        {
                }\n                else\n                {\n                    _recorder?.Dispose();\n                    _speedMonior?.Dispose();\n                    _writer?.Dispose();\n                }\n            }\n            catch (Exception e)\n            {
                }\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n            }\n        }\n        private void StartTimerWithoutState(ref Timer timer, TimerCallback callback, TimeSpan interval)\n        {\n            if (timer?.Change(_delayBeforeStart, interval) == null)
        }\n        private void Run(object _)\n        {\n            UpdateRecords();\n            Reset();\n            FilterRawStatistics();\n        }\n        private async void UpdateRecords()\n        {
                return;\n            }\n            var icmpResults = TaskEx.WhenAll(_controller.GetCurrentConfiguration().configs.Select(ICMPTest));\n            foreach (var result in (await icmpResults).Where(result => result != null))\n            {\n                if (result.Server.Equals(CurrentServer))\n                {\n                    currentServerRecord.setResponse(result.RoundtripTime);\n                    AppendRecord(CurrentServer, currentServerRecord);\n                }
            try\n            {\n                File.WriteAllText(AvailabilityStatisticsFile,\n                    JsonConvert.SerializeObject(RawStatistics, Formatting.None));\n            }\n            catch (IOException e)\n            {\n                Logging.LogUsefulException(e);\n                _writer.Change(_retryInterval, _writingInterval);\n            }
            }\n            catch (IOException e)\n            {\n                Logging.LogUsefulException(e);\n                _writer.Change(_retryInterval, _writingInterval);\n            }\n        }\n        private bool IsValidRecord(StatisticsRecord record)\n        {\n            if (Config.ByHourOfDay)
            }\n        }\n        private bool IsValidRecord(StatisticsRecord record)\n        {\n            if (Config.ByHourOfDay)\n            {\n                if (!record.Timestamp.Hour.Equals(DateTime.Now.Hour)) return false;\n            }\n            return true;\n        }
            _speedMonior.Dispose();
        {\n            Interlocked.Add(ref inboundCounter, n);\n        }\n        public void UpdateOutboundCounter(long n)\n        {\n            Interlocked.Add(ref outboundCounter, n);
        {\n            Interlocked.Add(ref outboundCounter, n);\n        }\n        protected void Reload()\n        {\n            // some logic in configuration updated the config when saving, we need to read it again
        // in ping-only records, these fields would be null\n        public int? AverageLatency;\n        public int? MinLatency;\n        public int? MaxLatency;\n        public int? AverageInboundSpeed;\n        public int? MinInboundSpeed;\n        public int? MaxInboundSpeed;\n        public int? AverageOutboundSpeed;
        {\n            ServerName = identifier;\n            if (inboundSpeedRecords != null && inboundSpeedRecords.Any())\n            {\n                AverageInboundSpeed = (int) inboundSpeedRecords.Average();\n                MinInboundSpeed = inboundSpeedRecords.Min();\n                MaxInboundSpeed = inboundSpeedRecords.Max();\n            }\n            if (outboundSpeedRecords != null && outboundSpeedRecords.Any())\n            {
            if (inboundSpeedRecords != null && inboundSpeedRecords.Any())\n            {\n                AverageInboundSpeed = (int) inboundSpeedRecords.Average();\n                MinInboundSpeed = inboundSpeedRecords.Min();\n                MaxInboundSpeed = inboundSpeedRecords.Max();\n            }\n            if (outboundSpeedRecords != null && outboundSpeedRecords.Any())\n            {\n                AverageOutboundSpeed = (int) outboundSpeedRecords.Average();\n                MinOutboundSpeed = outboundSpeedRecords.Min();
        }\n        public void setResponse(IEnumerable<int?> responseRecords)\n        {\n            if (responseRecords == null) return;\n            var records = responseRecords.Where(response => response != null).Select(response => response.Value).ToList();\n            if (!records.Any()) return;\n            AverageResponse = (int?) records.Average();\n            MinResponse = records.Min();\n            MaxResponse = records.Max();\n            PackageLoss = responseRecords.Count(response => response != null)/(float) responseRecords.Count();
        {\n            if (responseRecords == null) return;\n            var records = responseRecords.Where(response => response != null).Select(response => response.Value).ToList();\n            if (!records.Any()) return;\n            AverageResponse = (int?) records.Average();\n            MinResponse = records.Min();\n            MaxResponse = records.Max();\n            PackageLoss = responseRecords.Count(response => response != null)/(float) responseRecords.Count();\n        }\n    }
        }\n    }\n}
        {\n            var config = _controller.StatisticsConfiguration;\n            List<StatisticsRecord> records;\n            if (_filteredStatistics == null || !_filteredStatistics.TryGetValue(serverName, out records)) return 0;\n            float factor;\n            float score = 0;\n            var averageRecord = new StatisticsRecord(serverName,\n                records.FindAll(record => record.MaxInboundSpeed != null).Select(record => record.MaxInboundSpeed.Value),\n                records.FindAll(record => record.MaxOutboundSpeed != null).Select(record => record.MaxOutboundSpeed.Value),\n                records.FindAll(record => record.AverageLatency != null).Select(record => record.AverageLatency.Value));
            return score;\n        }\n        private void ChooseNewServer(List<Server> servers)\n        {\n            if (_filteredStatistics == null || servers.Count == 0)\n            {\n                return;\n            }\n            try\n            {
            ((System.ComponentModel.ISupportInitialize)(this.StatisticsChart)).BeginInit();\n            this.chartModeSelector.SuspendLayout();\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer1)).BeginInit();\n            this.splitContainer1.Panel1.SuspendLayout();\n            this.splitContainer1.Panel2.SuspendLayout();\n            this.splitContainer1.SuspendLayout();\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer2)).BeginInit();\n            this.splitContainer2.Panel1.SuspendLayout();\n            this.splitContainer2.Panel2.SuspendLayout();
            this.ServersListBox.Location = new System.Drawing.Point(12, 12);\n            this.ServersListBox.Name = "ServersListBox";\n            // \n            // label6\n            // \n            this.label6.Anchor = System.Windows.Forms.AnchorStyles.Right;\n            this.label6.AutoSize = true;

                    {\n                        if (line.BeginWith('#'))\n                            continue;\n                        var pos = line.IndexOf('=');\n                        if (pos < 1)\n                            continue;\n                        Strings[line.Substring(0, pos)] = line.Substring(pos + 1);\n                    }\n                }\n            }
                            continue;\n                        var pos = line.IndexOf('=');\n                        if (pos < 1)\n                            continue;\n                        Strings[line.Substring(0, pos)] = line.Substring(pos + 1);\n                    }\n                }\n            }\n        }\n        public static string GetString(string key)
        private Encryptor encryptor;\n        Socket listener;\n        public Local(int port)\n        {\n            this.port = port;\n            this.encryptor = new Encryptor("barfoo!");\n        }\n        public void Start()\n        {\n            // Create a TCP/IP socket.
        }\n        public void Start()\n        {\n            // Create a TCP/IP socket.\n            listener = new Socket(AddressFamily.InterNetwork,\n                SocketType.Stream, ProtocolType.Tcp);\n            IPEndPoint localEndPoint = new IPEndPoint(0, port);\n            // Bind the socket to the local endpoint and listen for incoming connections.\n                listener.Bind(localEndPoint);\n                listener.Listen(100);\n            // Start an asynchronous socket to listen for connections.
            // Bind the socket to the local endpoint and listen for incoming connections.\n                listener.Bind(localEndPoint);\n                listener.Listen(100);\n            // Start an asynchronous socket to listen for connections.\n            Console.WriteLine("Waiting for a connection...");\n            listener.BeginAccept(\n                new AsyncCallback(AcceptCallback),\n                listener);\n        }\n        public void Stop()
            IPAddress ipAddress = ipHostInfo.AddressList[0];\n            IPEndPoint remoteEP = new IPEndPoint(ipAddress, 8388);\n            remote = new Socket(AddressFamily.InterNetwork,\n                SocketType.Stream, ProtocolType.Tcp);\n            // Connect to the remote endpoint.\n            remote.BeginConnect(remoteEP,\n                new AsyncCallback(connectCallback), null);\n        }
            remote = new Socket(AddressFamily.InterNetwork,\n                SocketType.Stream, ProtocolType.Tcp);\n            // Connect to the remote endpoint.\n            remote.BeginConnect(remoteEP,\n                new AsyncCallback(connectCallback), null);\n        }
        {\n            ShowBalloonTip(I18N.GetString("Failed to update PAC file"), e.GetException().Message, ToolTipIcon.Error, 5000);\n            logger.LogUsefulException(e.GetException());\n        }\n        void controller_UpdatePACFromGFWListCompleted(object sender, GeositeResultEventArgs e)\n        {\n            string result = e.Success\n                ? I18N.GetString("PAC updated")
        {\n            string result = e.Success\n                ? I18N.GetString("PAC updated")
        }\n        private void PacServer_PACUpdateError(object sender, ErrorEventArgs e)\n        {\n            UpdatePACFromGFWListError?.Invoke(this, e);\n        }\n        private static readonly IEnumerable<char> IgnoredLineBegins = new[] { '!', '[' };\n        private void PacDaemon_UserRuleFileChanged(object sender, EventArgs e)\n        {\n            GeositeUpdater.MergeAndWritePACFile();\n            UpdateSystemProxy();
        }\n        private static readonly IEnumerable<char> IgnoredLineBegins = new[] { '!', '[' };\n        private void PacDaemon_UserRuleFileChanged(object sender, EventArgs e)\n        {\n            GeositeUpdater.MergeAndWritePACFile();\n            UpdateSystemProxy();\n        }\n        public void CopyPacUrl()\n        {\n            Clipboard.SetDataObject(_pacServer.PacUrl);
        }\n        public static void Disable()\n        {\n            RegistryKey registry = Registry.CurrentUser.OpenSubKey("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings", true);\n            registry.SetValue("ProxyEnable", 0);\n            registry.SetValue("ProxyServer", "");\n            registry.SetValue("AutoConfigURL", "");\n            SystemProxy.NotifyIE();
        }\n        private static String GetTimestamp(DateTime value)\n        {\n            return value.ToString("yyyyMMddHHmmssffff");\n        }\n    }\n}
            {\n                string original = FileManager.NonExclusiveReadAllText(PACServer.PAC_FILE, Encoding.UTF8);\n                if (original == abpContent)\n                {\n                    return false;\n                }\n            }\n            File.WriteAllText(PACServer.PAC_FILE, abpContent, Encoding.UTF8);\n            return true;\n        }
                if (original == abpContent)\n                {\n                    return false;\n                }\n            }\n            File.WriteAllText(PACServer.PAC_FILE, abpContent, Encoding.UTF8);\n            return true;\n        }\n        private static string MergePACFile(string gfwListResult)\n        {
            return true;\n        }\n        private static string MergePACFile(string gfwListResult)\n        {\n            string abpContent;\n            if (File.Exists(PACServer.USER_ABP_FILE))\n            {\n                abpContent = FileManager.NonExclusiveReadAllText(PACServer.USER_ABP_FILE, Encoding.UTF8);\n            }\n            else
            PACFileReadyToOpen?.Invoke(this, new PathEventArgs() { Path = pacFilename });\n        }\n        public void TouchUserRuleFile()\n        {\n            string userRuleFilename = _pacServer.TouchUserRuleFile();\n            UserRuleFileReadyToOpen?.Invoke(this, new PathEventArgs() { Path = userRuleFilename });\n        }\n        public string GetServerURLForCurrentServer()\n        {\n            Server server = GetCurrentServer();
            UserRuleFileReadyToOpen?.Invoke(this, new PathEventArgs() { Path = userRuleFilename });\n        }\n        public string GetServerURLForCurrentServer()\n        {\n            Server server = GetCurrentServer();\n            return GetServerURL(server);\n        }\n        public static string GetServerURL(Server server)\n        {\n            string tag = string.Empty;
            if (gfwListUpdater == null)\n            {\n                gfwListUpdater = new GFWListUpdater();\n                gfwListUpdater.UpdateCompleted += PacServer_PACUpdateCompleted;\n                gfwListUpdater.Error += PacServer_PACUpdateError;\n            }\n            availabilityStatistics.UpdateConfiguration(this);\n            if (_listener != null)\n            {\n                _listener.Stop();
        private string PacSecret { get; set; } = "";\n        public string PacUrl { get; private set; } = "";\n        FileSystemWatcher PACFileWatcher;\n        FileSystemWatcher UserRuleFileWatcher;\n        private Configuration _config;\n        public event EventHandler PACFileChanged;\n        public event EventHandler UserRuleFileChanged;\n        public PACServer()
        private Configuration _config;\n        public event EventHandler PACFileChanged;\n        public event EventHandler UserRuleFileChanged;\n        public PACServer()\n        {\n            this.WatchPacFile();\n            this.WatchUserRuleFile();
        {\n            this.WatchPacFile();\n            this.WatchUserRuleFile();\n        }\n        public void UpdateConfiguration(Configuration config)\n        {\n            this._config = config;\n            if (config.secureLocalPac)\n            {
        }\n        public void UpdateConfiguration(Configuration config)\n        {\n            this._config = config;\n            if (config.secureLocalPac)\n            {\n                var rd = new byte[32];\n                RNG.GetBytes(rd);\n                PacSecret = $"&secret={Convert.ToBase64String(rd)}";\n            }
        {\n            this._config = config;\n            if (config.secureLocalPac)\n            {\n                var rd = new byte[32];\n                RNG.GetBytes(rd);\n                PacSecret = $"&secret={Convert.ToBase64String(rd)}";\n            }\n            else\n            {
                {\n                    string[] kv = line.Split(new char[] { ':' }, 2);
                    if (kv.Length == 2)\n                    {\n                        if (kv[0] == "Host")\n                        {\n                            if (kv[1].Trim() == ((IPEndPoint)socket.LocalEndPoint).ToString())\n                            {\n                                hostMatch = true;\n                            }\n                        }\n                        //else if (kv[0] == "User-Agent")\n                    }
                    }\n                }\n                if (hostMatch && pathMatch)\n                {\n                    if (!secretMatch)\n                    {\n                        socket.Close(); // Close immediately\n                    }\n                    else\n                    {
        public void SendResponse(Socket socket, bool useSocks)\n        {\n            try\n            {\n                IPEndPoint localEndPoint = (IPEndPoint)socket.LocalEndPoint;\n                string proxy = GetPACAddress(localEndPoint, useSocks);\n                string pacContent = GetPACContent().Replace("__PROXY__", proxy);\n                string responseHead = String.Format(@"HTTP/1.1 200 OK\nServer: Shadowsocks\nContent-Type: application/x-ns-proxy-autoconfig
                string responseHead = String.Format(@"HTTP/1.1 200 OK\nServer: Shadowsocks\nContent-Type: application/x-ns-proxy-autoconfig\nContent-Length: {0}\nConnection: Close\n", Encoding.UTF8.GetBytes(pacContent).Length);\n                byte[] response = Encoding.UTF8.GetBytes(responseHead + pacContent);\n                socket.BeginSend(response, 0, response.Length, 0, new AsyncCallback(SendCallback), socket);\n                Utils.ReleaseMemory(true);\n            }
        private TimeSpan RecordingInterval => TimeSpan.FromMinutes(Config.DataCollectionMinutes);\n        private Timer _speedMonior;\n        private readonly TimeSpan _monitorInterval = TimeSpan.FromSeconds(1);\n        //private Timer _writer; //write RawStatistics to file\n        //private readonly TimeSpan _writingInterval = TimeSpan.FromMinutes(1);\n        private ShadowsocksController _controller;\n        private StatisticsStrategyConfiguration Config => _controller.StatisticsConfiguration;\n        // Static Singleton Initialization\n        public static AvailabilityStatistics Instance { get; } = new AvailabilityStatistics();\n        public Statistics RawStatistics { get; private set; }
        private readonly TimeSpan _monitorInterval = TimeSpan.FromSeconds(1);\n        //private Timer _writer; //write RawStatistics to file\n        //private readonly TimeSpan _writingInterval = TimeSpan.FromMinutes(1);\n        private ShadowsocksController _controller;\n        private StatisticsStrategyConfiguration Config => _controller.StatisticsConfiguration;\n        // Static Singleton Initialization\n        public static AvailabilityStatistics Instance { get; } = new AvailabilityStatistics();\n        public Statistics RawStatistics { get; private set; }\n        public Statistics FilteredStatistics { get; private set; }\n        private AvailabilityStatistics()
                    LoadRawStatistics();\n                    StartTimerWithoutState(ref _speedMonior, UpdateSpeed, _monitorInterval);\n                }\n                else\n                {\n                    _recorder?.Dispose();
                }\n                else\n                {\n                    _recorder?.Dispose();\n                    _speedMonior?.Dispose();\n                }\n            }\n            catch (Exception e)\n            {
                }\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n            }\n        }\n        private void StartTimerWithoutState(ref Timer timer, TimerCallback callback, TimeSpan interval)\n        {\n            if (timer?.Change(_delayBeforeStart, interval) == null)
        {\n            foreach (var kv in _inOutBoundRecords)\n            {\n                var id = kv.Key;\n                var record = kv.Value;\n                long inboundDelta, outboundDelta;\n                record.GetDelta(out inboundDelta, out outboundDelta);\n                var inboundSpeed = GetSpeedInKiBPerSecond(inboundDelta, _monitorInterval.TotalSeconds);\n                var outboundSpeed = GetSpeedInKiBPerSecond(outboundDelta, _monitorInterval.TotalSeconds);
        {\n            UpdateRecords();\n            Reset();\n        }\n        private void UpdateRecords()\n        {\n            var records = new Dictionary<string, StatisticsRecord>();\n            UpdateRecordsState state = new UpdateRecordsState();\n            state.counter = _controller.GetCurrentConfiguration().configs.Count;\n            foreach (var server in _controller.GetCurrentConfiguration().configs)
            {\n                Save();\n                FilterRawStatistics();\n            }\n        }\n        private void ping_Completed(object sender, MyPing.CompletedEventArgs e)\n        {\n            PingState pingState = (PingState)e.UserState;\n            UpdateRecordsState state = pingState.state;\n            Server server = e.Server;
                foreach (var serverAndRecords in RawStatistics)\n                {\n                    var server = serverAndRecords.Key;\n                    var filteredRecords = serverAndRecords.Value.FindAll(IsValidRecord);\n                    FilteredStatistics[server] = filteredRecords;\n                }\n            }\n            catch (Exception e)\n            {
            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n            }\n        }\n        private void LoadRawStatistics()\n        {\n            try\n            {
            }\n        }\n        private static int GetSpeedInKiBPerSecond(long bytes, double seconds)\n        {\n            var result = (int)(bytes / seconds) / 1024;\n            return result;\n        }\n        public void Dispose()\n        {\n            _recorder.Dispose();
        }\n        public void UpdateLatency(Server server, int latency)\n        {\n            _latencyRecords.GetOrAdd(server.Identifier(), (k) =>\n            {\n                List<int> records = new List<int>();\n                records.Add(latency);\n                return records;\n            });\n        }
        public string PacUrl { get; private set; } = "";\n        private Configuration _config;\n        private PACDaemon _pacDaemon;\n        public PACServer(PACDaemon pacDaemon)\n        {\n            _pacDaemon = pacDaemon;\n        }\n        public void UpdatePACURL(Configuration config)\n        {\n            this._config = config;
        }\n        private static string GetHash(string content)\n        {\n            var contentBytes = Encoding.ASCII.GetBytes(content);\n            using (var md5 = System.Security.Cryptography.MD5.Create())\n            {\n                var md5Bytes = md5.ComputeHash(contentBytes);\n                return BitConverter.ToString(md5Bytes).Replace("-", "");

    {\n        protected static Dictionary<string, string> Strings;\n        static void Init(string res)\n        {\n            using (var sr = new StringReader(res))\n            {\n                foreach (var line in sr.NonWhiteSpaceLines())\n                {\n                    if (line[0] == '#')\n                        continue;
        {\n            using (var sr = new StringReader(res))\n            {\n                foreach (var line in sr.NonWhiteSpaceLines())\n                {\n                    if (line[0] == '#')\n                        continue;\n                    var pos = line.IndexOf('=');\n                    if (pos < 1)\n                        continue;
            {\n                if (name == "zh" || name == "zh-CN")\n                {\n                    Init(Resources.cn);\n                }\n                else\n                {\n                    Init(Resources.zh_tw);\n                }
            }\n        }\n        public static string GetString(string key)\n        {\n            if (Strings.ContainsKey(key))\n            {\n                return Strings[key];\n            }\n            else\n            {
        }\n    }\n}
            }\n            else\n            {\n                i18n = File.ReadAllText(I18N_FILE, Encoding.UTF8);\n            }\n            Logging.Info("Current language is: " + locale);\n            Init(i18n, locale);\n        }\n        public static string GetString(string key, params object[] args)
using System.Diagnostics;\nusing System.Drawing;\nusing System.Drawing.Imaging;\nusing System.Windows.Forms;\nusing ZXing;\nusing ZXing.Common;\nusing ZXing.QrCode;
using System.Windows.Forms;\nusing ZXing;\nusing ZXing.Common;\nusing ZXing.QrCode;\nusing Shadowsocks.Controller;\nusing Shadowsocks.Model;\nusing Shadowsocks.Properties;\nusing Shadowsocks.Util;\nusing System.Linq;\nusing Microsoft.Win32;
namespace Shadowsocks.View\n{\n    public class MenuViewController\n    {\n        // yes this is just a menu view controller\n        // when config form is closed, it moves away from RAM\n        // and it should just do anything related to the config form\n        private ShadowsocksController controller;\n        private UpdateChecker updateChecker;\n        private NotifyIcon _notifyIcon;
                List<Listener.Service> services = new List<Listener.Service>();\n                services.Add(local);\n                services.Add(_pacServer);\n                services.Add(new PortForwarder(polipoRunner.RunningPort));\n                _listener = new Listener(services);\n                _listener.Start(_config);\n            }\n            catch (Exception e)
                services.Add(_pacServer);\n                services.Add(new PortForwarder(polipoRunner.RunningPort));\n                _listener = new Listener(services);\n                _listener.Start(_config);\n            }\n            catch (Exception e)\n            {\n                // translate Microsoft language into human language\n                // i.e. An attempt was made to access a socket in a way forbidden by its access permissions => Port already in use\n                if (e is SocketException)
        }\n        Configuration _config;\n        bool _shareOverLAN;\n        Socket _socket;\n        IList<Service> _services;\n        public Listener(IList<Service> services)\n        {\n            this._services = services;
        IList<Service> _services;\n        public Listener(IList<Service> services)\n        {\n            this._services = services;\n        }\n        private bool CheckIfPortInUse(int port)\n        {\n            IPGlobalProperties ipProperties = IPGlobalProperties.GetIPGlobalProperties();\n            IPEndPoint[] ipEndPoints = ipProperties.GetActiveTcpListeners();\n            foreach (IPEndPoint endPoint in ipEndPoints)
                IPEndPoint localEndPoint = null;\n                if (_shareOverLAN)\n                {\n                    localEndPoint = new IPEndPoint(IPAddress.Any, _config.localPort);\n                }\n                else\n                {\n                    localEndPoint = new IPEndPoint(IPAddress.Loopback, _config.localPort);\n                }\n                // Bind the socket to the local endpoint and listen for incoming connections.\n                _socket.Bind(localEndPoint);
                // Start an asynchronous socket to listen for connections.\n                Console.WriteLine("Shadowsocks started");\n                _socket.BeginAccept(\n                    new AsyncCallback(AcceptCallback),\n                    _socket);\n            }\n            catch (SocketException)\n            {
                    new AsyncCallback(AcceptCallback),\n                    _socket);\n            }\n            catch (SocketException)\n            {\n                _socket.Close();\n                throw;
            }\n            catch (SocketException)\n            {\n                _socket.Close();\n                throw;\n            }\n        }\n        public void Stop()\n        {\n            if (_socket != null)
                throw;\n            }\n        }\n        public void Stop()\n        {\n            if (_socket != null)\n            {\n                _socket.Close();\n                _socket = null;
            {\n                _socket.Close();\n                _socket = null;
            }\n        }\n        public void AcceptCallback(IAsyncResult ar)\n        {\n            Socket listener = (Socket)ar.AsyncState;\n            try\n            {\n                Socket conn = listener.EndAccept(ar);\n                byte[] buf = new byte[4096];\n                object[] state = new object[] {
                    {\n                        return;\n                    }\n                }\n                // no service found for this\n                // shouldn't happen\n                conn.Close();\n            }\n            catch (Exception e)
            }\n            catch (Exception e)\n            {\n                Console.WriteLine(e);\n                conn.Close();\n            }\n        }\n    }\n}
    {\n        private Configuration _config;\n        public Local(Configuration config)\n        {\n            this._config = config;\n        }\n        public bool Handle(byte[] firstPacket, int length, Socket socket)\n        {
        {\n            this._config = config;\n        }\n        public bool Handle(byte[] firstPacket, int length, Socket socket)\n        {\n            if (length < 2 || firstPacket[0] != 5)
            if (length < 2 || firstPacket[0] != 5)\n            {\n                return false;\n            }\n            socket.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n            Handler handler = new Handler();\n            handler.connection = socket;\n            Server server = _config.GetCurrentServer();\n            handler.encryptor = EncryptorFactory.GetEncryptor(server.method, server.password);\n            handler.server = server;
        {\n            try\n            {\n                string request = Encoding.UTF8.GetString(firstPacket, 0, length);\n                string[] lines = request.Split('\r', '\n');\n                bool hostMatch = false, pathMatch = false, useSocks = false;
        {\n            new Handler().Start(firstPacket, length, socket, this._targetPort);\n            return true;\n        }\n        class Handler\n        {
        void EndConnectProxy(IAsyncResult asyncResult);\n        IAsyncResult BeginConnectDest(EndPoint remoteEP, AsyncCallback callback, object state);\n        void EndConnectDest(IAsyncResult asyncResult);\n        IAsyncResult BeginSend(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state);\n        int EndSend(IAsyncResult asyncResult);\n        IAsyncResult BeginReceive(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state);\n        int EndReceive(IAsyncResult asyncResult);\n        void Shutdown(SocketShutdown how);
        void EndConnectDest(IAsyncResult asyncResult);\n        IAsyncResult BeginSend(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state);\n        int EndSend(IAsyncResult asyncResult);\n        IAsyncResult BeginReceive(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state);\n        int EndReceive(IAsyncResult asyncResult);\n        void Shutdown(SocketShutdown how);\n        void Close();\n    }
            object state);\n        int EndSend(IAsyncResult asyncResult);\n        IAsyncResult BeginReceive(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state);\n        int EndReceive(IAsyncResult asyncResult);\n        void Shutdown(SocketShutdown how);\n        void Close();\n    }\n}
            object state);\n        int EndReceive(IAsyncResult asyncResult);\n        void Shutdown(SocketShutdown how);\n        void Close();\n    }\n}
        {\n            // do nothing\n            ProxyEndPoint = remoteEP;\n            var r = new FakeAsyncResult(state);\n            callback?.Invoke(r);\n            return r;\n        }\n        public void EndConnectProxy(IAsyncResult asyncResult)\n        {\n            // do nothing\n        }\n        public IAsyncResult BeginConnectDest(EndPoint remoteEP, AsyncCallback callback, object state)
        }\n        public void EndConnectProxy(IAsyncResult asyncResult)\n        {\n            // do nothing\n        }\n        public IAsyncResult BeginConnectDest(EndPoint remoteEP, AsyncCallback callback, object state)\n        {\n            if (_remote == null)\n            {\n                _remote = new Socket(remoteEP.AddressFamily, SocketType.Stream, ProtocolType.Tcp);\n                _remote.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);
        {\n            if (_remote == null)\n            {\n                _remote = new Socket(remoteEP.AddressFamily, SocketType.Stream, ProtocolType.Tcp);\n                _remote.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n            }\n            DestEndPoint = remoteEP;\n            return _remote.BeginConnect(remoteEP, callback, state);\n        }\n        public void EndConnectDest(IAsyncResult asyncResult)
        }\n        public void EndConnectDest(IAsyncResult asyncResult)\n        {\n            _remote.EndConnect(asyncResult);\n        }\n        public IAsyncResult BeginSend(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state)\n        {\n            return _remote.BeginSend(buffer, offset, size, socketFlags, callback, state);\n        }
            object state)\n        {\n            return _remote.BeginSend(buffer, offset, size, socketFlags, callback, state);\n        }\n        public int EndSend(IAsyncResult asyncResult)\n        {\n            return _remote.EndSend(asyncResult);\n        }\n        public IAsyncResult BeginReceive(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state)
        }\n        public int EndSend(IAsyncResult asyncResult)\n        {\n            return _remote.EndSend(asyncResult);\n        }\n        public IAsyncResult BeginReceive(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state)\n        {\n            return _remote.BeginReceive(buffer, offset, size, socketFlags, callback, state);\n        }
            object state)\n        {\n            return _remote.BeginReceive(buffer, offset, size, socketFlags, callback, state);\n        }\n        public int EndReceive(IAsyncResult asyncResult)\n        {\n            return _remote.EndReceive(asyncResult);\n        }\n        public void Shutdown(SocketShutdown how)\n        {
        }\n        public int EndReceive(IAsyncResult asyncResult)\n        {\n            return _remote.EndReceive(asyncResult);\n        }\n        public void Shutdown(SocketShutdown how)\n        {\n            _remote?.Shutdown(how);\n        }\n        public void Close()
                {\n                    KillProcess(p);\n                }\n                string polipoConfig = Resources.privoxy_conf;\n                _runningPort = this.GetFreePort();\n                polipoConfig = polipoConfig.Replace("__SOCKS_PORT__", configuration.localPort.ToString());\n                polipoConfig = polipoConfig.Replace("__POLIPO_BIND_PORT__", _runningPort.ToString());\n                polipoConfig = polipoConfig.Replace("__POLIPO_BIND_IP__", configuration.shareOverLan ? "0.0.0.0" : "127.0.0.1");\n                FileManager.ByteArrayToFile(Utils.GetTempPath("privoxy.conf"), Encoding.UTF8.GetBytes(polipoConfig));\n                _process = new Process();
                _process = new Process();\n                // Configure the process using the StartInfo properties.\n                _process.StartInfo.FileName = "ss_privoxy.exe";\n                _process.StartInfo.Arguments = "privoxy.conf";\n                _process.StartInfo.WorkingDirectory = Utils.GetTempPath();\n                _process.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;\n                _process.StartInfo.UseShellExecute = true;\n                _process.StartInfo.CreateNoWindow = true;\n                _process.Start();
                _process.StartInfo.WorkingDirectory = Utils.GetTempPath();\n                _process.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;\n                _process.StartInfo.UseShellExecute = true;\n                _process.StartInfo.CreateNoWindow = true;\n                _process.Start();\n            }
                    try\n                    {\n                        Directory.CreateDirectory(Path.Combine(Application.StartupPath, "temp"));\n                    }\n                    catch (Exception e)\n                    {\n                        TempPath = Path.GetTempPath();\n                        Logging.LogUsefulException(e);\n                    }\n                    finally
                LogMessageTextBox.ScrollToCaret();\n                lastOffset = reader.BaseStream.Position;\n            }\n        }\n        private void UpdateContent()\n        {\n            try\n            {\n                using (StreamReader reader = new StreamReader(new FileStream(filename,\n                         FileMode.Open, FileAccess.Read, FileShare.ReadWrite)))
                    }\n                    if (changed)\n                    {\n                        LogMessageTextBox.ScrollToCaret();\n                    }\n                    lastOffset = reader.BaseStream.Position;\n                }\n            }\n            catch (FileNotFoundException)
        // return path to store temporary files\n        public static string GetTempPath()\n        {\n            if (_tempPath == null)\n            {\n                try\n                {\n                    var tempFolder = Configuration.Load().tempFolder;\n                    if (string.IsNullOrWhiteSpace(tempFolder))
                        // don't use "/", it will fail when we call explorer /select xxx/ss_win_temp\xxx.log\n                        tempFolder = "ss_win_temp";\n                    else if (COMMON_ENV.Contains(tempFolder, StringComparer.OrdinalIgnoreCase))\n                        // add subfolder for these common folders\n                        tempFolder += (@"\Shadowsocks\ss_win_temp_" + Application.ExecutablePath.GetHashCode());\n                    tempFolder = Environment.ExpandEnvironmentVariables(tempFolder);\n                    // If `tempFolder` is an absolute path, `Application.StartupPath` will be ignored.\n                    var tempDirectory = Directory.CreateDirectory(Path.Combine(Application.StartupPath, tempFolder));\n                    _tempPath = tempDirectory.FullName;\n                    File.AppendAllText(Path.Combine(_tempPath, TEMP_LOG), $"[{DateTimeOffset.Now.ToString("u")}] Temp folder used by \"{Application.ExecutablePath}\"{Environment.NewLine}");

                Configuration.CheckServer(server);\n                Configuration.CheckLocalPort(localPort);\n                _modifiedConfiguration.configs[_lastSelectedIndex] = server;\n                _modifiedConfiguration.localPort = localPort;\n                return true;\n            }\n            catch (Exception ex)\n            {\n                MessageBox.Show(ex.Message);
        {\n            _config.configs = servers;\n            _config.localPort = localPort;\n            Configuration.Save(_config);\n        }\n        public void SaveTempFolder(string tempFolder)\n        {\n            _config.tempFolder = tempFolder;\n            Configuration.Save(_config);
            Configuration.Save(_config);\n        }\n        public void SaveStrategyConfigurations(StatisticsStrategyConfiguration configuration)\n        {\n            StatisticsConfiguration = configuration;\n            StatisticsStrategyConfiguration.Save(configuration);\n        }\n        public bool AddServerBySSURL(string ssURL)\n        {\n            try
        private System.Windows.Forms.TextBox PluginArgumentsTextBox;\n        private System.Windows.Forms.Label PluginArgumentsLabel;\n        private System.Windows.Forms.ToolTip toolTip1;\n        private System.Windows.Forms.TextBox TempFolderTextBox;\n    }\n}
    }\n}
            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void PipeConnectionSendCallback(IAsyncResult ar)\n        {\n            if (_closed) return;
            try\n            {\n                var session = (AsyncSession)ar.AsyncState;\n                _connection?.EndSend(ar);\n                session.Remote.BeginReceive(_remoteRecvBuffer, 0, RecvSize, SocketFlags.None, new AsyncCallback(PipeRemoteReceiveCallback), session);\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();
                session.Remote.BeginReceive(_remoteRecvBuffer, 0, RecvSize, SocketFlags.None, new AsyncCallback(PipeRemoteReceiveCallback), session);\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }\n    }\n}
            this.ClientSize = new System.Drawing.Size(284, 262);\n            this.ControlBox = false;
                                            Screen.PrimaryScreen.Bounds.Height))\n            {\n                using (Graphics g = Graphics.FromImage(image))\n                {\n                    g.CopyFromScreen(Screen.PrimaryScreen.Bounds.X,\n                                     Screen.PrimaryScreen.Bounds.Y,\n                                     0, 0,\n                                     image.Size,\n                                     CopyPixelOperation.SourceCopy);\n                }
                {\n                    g.CopyFromScreen(Screen.PrimaryScreen.Bounds.X,\n                                     Screen.PrimaryScreen.Bounds.Y,\n                                     0, 0,\n                                     image.Size,\n                                     CopyPixelOperation.SourceCopy);\n                }\n                var reader = new BarcodeReader\n                {\n                    TryHarder = true,
                                     CopyPixelOperation.SourceCopy);\n                }\n                var reader = new BarcodeReader\n                {\n                    TryHarder = true,\n                    PossibleFormats = new List<BarcodeFormat>
                {\n                    TryHarder = true,\n                    PossibleFormats = new List<BarcodeFormat>\n                    {\n                        BarcodeFormat.QR_CODE
                    {\n                        BarcodeFormat.QR_CODE\n                    }\n                };\n                var result = reader.Decode(image);\n                if (result != null)\n                {
                    }\n                };\n                var result = reader.Decode(image);\n                if (result != null)\n                {\n                    var success = controller.AddServerBySSURL(result.Text);\n                    if (success)\n                    {
                    {
                        splash.Location = new Point((int)minX, (int)minY);\n                        splash.Size = new Size((int)maxX - (int)minX, (int)maxY - (int)minY);\n                        splash.Show();\n                        return;\n                    }\n                }\n                MessageBox.Show(I18N.GetString("Failed to scan QRCode"));\n            }
                        splash.Show();\n                        return;\n                    }\n                }\n                MessageBox.Show(I18N.GetString("Failed to scan QRCode"));\n            }\n        }\n        void splash_FormClosed(object sender, FormClosedEventArgs e)\n        {\n            ShowConfigForm();
        }\n        void splash_FormClosed(object sender, FormClosedEventArgs e)\n        {\n            ShowConfigForm();\n        }\nprivate void AutoStartupItem_Click(object sender, EventArgs e) {
        // this is a copy of configuration that we are working on\n        private HotkeyConfig _modifiedConfig;\n        private StringBuilder _sb = new StringBuilder();\n        private IEnumerable<TextBox> _allTextBoxes;\n        private Label _lb = null;\n        private HotKeys.HotKeyCallBackHandler _callBack = null;\n        public HotkeySettingsForm(ShadowsocksController controller)\n        {\n            InitializeComponent();\n            UpdateTexts();
        public HotkeySettingsForm(ShadowsocksController controller)\n        {\n            InitializeComponent();\n            UpdateTexts();\n            this.Icon = Icon.FromHandle(Resources.ssw128.GetHicon());\n            _controller = controller;\n            _controller.ConfigChanged += controller_ConfigChanged;\n            LoadCurrentConfiguration();\n            // get all textboxes belong to this form\n            _allTextBoxes = HotKeys.GetChildControls<TextBox>(this.tableLayoutPanel1);\n            if (!_allTextBoxes.Any()) throw new Exception("Cannot get all textboxes");
            _controller = controller;\n            _controller.ConfigChanged += controller_ConfigChanged;\n            LoadCurrentConfiguration();\n            // get all textboxes belong to this form\n            _allTextBoxes = HotKeys.GetChildControls<TextBox>(this.tableLayoutPanel1);\n            if (!_allTextBoxes.Any()) throw new Exception("Cannot get all textboxes");\n        }\n        private void controller_ConfigChanged(object sender, EventArgs e)\n        {\n            LoadCurrentConfiguration();\n        }
            if (!_allTextBoxes.Any()) throw new Exception("Cannot get all textboxes");\n        }\n        private void controller_ConfigChanged(object sender, EventArgs e)\n        {\n            LoadCurrentConfiguration();\n        }\n        private void LoadCurrentConfiguration()\n        {\n            _modifiedConfig = _controller.GetConfigurationCopy().hotkey;\n            LoadConfiguration(_modifiedConfig);
        }\n        /// <summary>\n        /// Capture hotkey - Press key\n        /// </summary>\n        private void HotkeyDown(object sender, KeyEventArgs e)\n        {\n            _sb.Length = 0;\n            //Combination key only\n            if (e.Modifiers != 0)\n            {\n                // XXX: Hotkey parsing depends on the sequence, more specifically, ModifierKeysConverter.\n                // Windows key is reserved by operating system, we deny this key.\n                if (e.Control)
            //Combination key only\n            if (e.Modifiers != 0)\n            {\n                // XXX: Hotkey parsing depends on the sequence, more specifically, ModifierKeysConverter.\n                // Windows key is reserved by operating system, we deny this key.\n                if (e.Control)\n                {
            if (content.Length >= 1 && content[content.Length - 1] == '+')\n            {\n                tb.Text = "";\n            }\n        }\n        private void TextBox_TextChanged(object sender, EventArgs e)\n        {\n            TextBox tb = sender as TextBox;\n            if (tb.Text == "")\n            {
            if (tb.Text == "")\n            {\n                // unreg\n                UnregHotkey(tb);\n            }\n        }\n        private void UnregHotkey(TextBox tb)\n        {\n            PrepareForHotkey(tb, out _callBack, out _lb);\n            UnregPrevHotkey(_callBack);
        }\n        private void CancelButton_Click(object sender, EventArgs e)\n        {\n            this.Close();\n        }\n        private void OKButton_Click(object sender, EventArgs e)\n        {\n            // try to register, notify to change settings if failed\n            foreach (var tb in _allTextBoxes)\n            {
        }\n        private void OKButton_Click(object sender, EventArgs e)\n        {\n            // try to register, notify to change settings if failed\n            foreach (var tb in _allTextBoxes)\n            {\n                if (tb.Text.IsNullOrEmpty())\n                {\n                    continue;\n                }
                        Logging.Info("controller stopped");\n                    }\n                    Logging.Info("os suspend");\n                    break;\n            }\n        }\n        private static void Timer_Elapsed(object sender, System.Timers.ElapsedEventArgs e)\n        {\n            try\n            {
                    Logging.Info("controller started");\n                }\n            }\n            catch (Exception ex)\n            {\n                Logging.LogUsefulException(ex);\n            }\n            finally\n            {\n                try
            }\n        }\n    }\n}
            }\n            catch (IOException)\n            {\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine(e.ToString());\n            }\n        }
            Logging.Info($"Proxy {proxy.ProxyEndPoint} timed out");\n            proxy.Close();\n            RetryConnect();\n        }\n        private void ProxyConnectCallback(IAsyncResult ar)\n        {\n            Server server = null;\n            if (_closed)\n            {\n                return;
            IStrategy strategy = controller.GetCurrentStrategy();\n            strategy?.SetFailure(server);\n            Logging.Info($"{server.FriendlyName()} timed out");\n            session.Remote.Close();\n            RetryConnect();\n        }\n        private void RetryConnect()\n        {\n            if (_retryCount < MaxRetry)\n            {
        {\n            public AsyncCallback Callback { get; }\n            public SocketAsyncEventArgs Args { get; }
            public TcpUserToken(AsyncCallback callback, object state, SocketAsyncEventArgs args)\n            {\n                Callback = callback;\n                AsyncState = state;\n                Args = args;\n            }\n            public bool IsCompleted { get; } = true;\n            public WaitHandle AsyncWaitHandle { get; } = null;\n            public object AsyncState { get; }\n            public bool CompletedSynchronously { get; } = true;
        }\n        private static void OnTcpConnectCompleted(object sender, SocketAsyncEventArgs args)\n        {\n            TcpUserToken token = (TcpUserToken) args.UserToken;\n            token.Callback(token);
        }\n        public static void BeginConnectTcp(EndPoint endPoint, AsyncCallback callback, object state)\n        {\n            var arg = new SocketAsyncEventArgs();\n            arg.RemoteEndPoint = endPoint;\n            arg.Completed += OnTcpConnectCompleted;\n            arg.UserToken = new TcpUserToken(callback, state, arg);\n            Socket.ConnectAsync(SocketType.Stream, ProtocolType.Tcp, arg);\n        }\n        public static Socket EndConnectTcp(IAsyncResult asyncResult)
            {\n                throw new ArgumentException("Invalid asyncResult.", nameof(asyncResult));\n            }\n            var arg = tut.Args;\n            if (arg.SocketError != SocketError.Success)\n            {\n                if (arg.ConnectByNameError != null)\n                {\n                    throw arg.ConnectByNameError;
            this.panel2 = new System.Windows.Forms.Panel();\n            this.OKButton = new System.Windows.Forms.Button();\n            this.MyCancelButton = new System.Windows.Forms.Button();\n            this.panel1 = new System.Windows.Forms.Panel();\n            this.contextMenu1 = new System.Windows.Forms.ContextMenu();\n            this.enableItem = new System.Windows.Forms.MenuItem();\n            this.AutoStartupItem = new System.Windows.Forms.MenuItem();\n            this.ShareOverLANItem = new System.Windows.Forms.MenuItem();\n            this.ServersItem = new System.Windows.Forms.MenuItem();\n            this.SeperatorItem = new System.Windows.Forms.MenuItem();
            this.panel3 = new System.Windows.Forms.Panel();\n            this.DeleteButton = new System.Windows.Forms.Button();\n            this.AddButton = new System.Windows.Forms.Button();\n            this.ServerGroupBox = new System.Windows.Forms.GroupBox();\n            this.ServersListBox = new System.Windows.Forms.ListBox();\n            this.menuItem1 = new System.Windows.Forms.MenuItem();\n            this.tableLayoutPanel1.SuspendLayout();\n            this.panel1.SuspendLayout();\n            this.panel3.SuspendLayout();\n            this.ServerGroupBox.SuspendLayout();
            this.tableLayoutPanel1.SuspendLayout();\n            this.panel1.SuspendLayout();\n            this.panel3.SuspendLayout();\n            this.ServerGroupBox.SuspendLayout();\n            this.SuspendLayout();\n            // \n            // tableLayoutPanel1\n            // \n            this.tableLayoutPanel1.AutoSize = true;\n            this.tableLayoutPanel1.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;
            this.tableLayoutPanel1.Name = "tableLayoutPanel1";\n            this.tableLayoutPanel1.Padding = new System.Windows.Forms.Padding(5, 5, 5, 5);\n            this.tableLayoutPanel1.RowCount = 6;\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.Size = new System.Drawing.Size(242, 167);
            this.tableLayoutPanel1.RowCount = 6;\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.Size = new System.Drawing.Size(242, 167);\n            this.tableLayoutPanel1.TabIndex = 0;\n            // 
        private System.Windows.Forms.Label label5;\n        private System.Windows.Forms.ComboBox EncryptionSelect;\n        private System.Windows.Forms.Panel panel2;\n        private System.Windows.Forms.Button OKButton;\n        private System.Windows.Forms.Button MyCancelButton;\n        private System.Windows.Forms.Panel panel1;\n        private System.Windows.Forms.ContextMenu contextMenu1;\n        private System.Windows.Forms.MenuItem enableItem;\n        private System.Windows.Forms.MenuItem aboutItem;\n        private System.Windows.Forms.MenuItem menuItem3;
        private System.Windows.Forms.Panel panel3;\n        private System.Windows.Forms.Button DeleteButton;\n        private System.Windows.Forms.Button AddButton;\n        private System.Windows.Forms.GroupBox ServerGroupBox;\n        private System.Windows.Forms.ListBox ServersListBox;\n        private System.Windows.Forms.MenuItem ServersItem;\n        private System.Windows.Forms.MenuItem SeperatorItem;\n        private System.Windows.Forms.MenuItem menuItem4;\n        private System.Windows.Forms.TextBox RemarksTextBox;\n        private System.Windows.Forms.Label label6;
        private System.Windows.Forms.TextBox RemarksTextBox;\n        private System.Windows.Forms.Label label6;\n        private System.Windows.Forms.MenuItem QRCodeItem;\n        private System.Windows.Forms.MenuItem ShowLogItem;\n        private System.Windows.Forms.MenuItem ShareOverLANItem;\nprivate System.Windows.Forms.MenuItem AutoStartupItem;\n        private System.Windows.Forms.MenuItem menuItem1;\n    }\n}
    }\n}
            this.controller = controller;\n            controller.EnableStatusChanged += controller_EnableStatusChanged;\n            controller.ConfigChanged += controller_ConfigChanged;\n            controller.PACFileReadyToOpen += controller_PACFileReadyToOpen;\n            controller.ShareOverLANStatusChanged += controller_ShareOverLANStatusChanged;\n            this.updateChecker = new UpdateChecker();\n            updateChecker.NewVersionFound += updateChecker_NewVersionFound;\n            LoadCurrentConfiguration();\n        }\n        private void LoadTrayIcon()
            controller.ConfigChanged += controller_ConfigChanged;\n            controller.PACFileReadyToOpen += controller_PACFileReadyToOpen;\n            controller.ShareOverLANStatusChanged += controller_ShareOverLANStatusChanged;\n            this.updateChecker = new UpdateChecker();\n            updateChecker.NewVersionFound += updateChecker_NewVersionFound;\n            LoadCurrentConfiguration();\n        }\n        private void LoadTrayIcon()\n        {\n            int dpi;
            LoadCurrentConfiguration();\n        }\n        private void LoadTrayIcon()\n        {\n            int dpi;\n            Graphics graphics = this.CreateGraphics();\n            dpi = (int)graphics.DpiX;\n            graphics.Dispose();\n            Bitmap icon = null;\n            if (dpi < 97)
        }\n        private void controller_ConfigChanged(object sender, EventArgs e)\n        {\n            LoadCurrentConfiguration();\n        }\n        private void controller_EnableStatusChanged(object sender, EventArgs e)\n        {\n            enableItem.Checked = controller.GetConfiguration().enabled;\n        }\n        void controller_ShareOverLANStatusChanged(object sender, EventArgs e)
        }\n        void notifyIcon1_BalloonTipClicked(object sender, EventArgs e)\n        {\n            Process.Start(updateChecker.LatestVersionURL);\n        }\n        private void ShowWindow()\n        {\n            this.Opacity = 1;\n            this.Show();\n            IPTextBox.Focus();
        }\n        private void ConfigForm_Load(object sender, EventArgs e)\n        {\n            if (!controller.GetConfiguration().isDefault)\n            {\n                this.Opacity = 0;\n                BeginInvoke(new MethodInvoker(delegate\n                {\n                    this.Hide();\n                }));
        }\n        private void ServersListBox_SelectedIndexChanged(object sender, EventArgs e)\n        {\n            if (_oldSelectedIndex == ServersListBox.SelectedIndex)\n            {\n                // we are moving back to oldSelectedIndex or doing a force move\n                return;\n            }\n            if (!SaveOldSelectedServer())\n            {
        }\n        private void CancelButton_Click(object sender, EventArgs e)\n        {\n            this.Hide();\n            LoadCurrentConfiguration();\n            ShowFirstTimeBalloon();\n        }\n        private void ConfigForm_FormClosed(object sender, FormClosedEventArgs e)\n        {\n            controller.Stop();
        }\n        private void ConfigForm_Shown(object sender, EventArgs e)\n        {\n            IPTextBox.Focus();\n        }\n        private void QRCodeItem_Click(object sender, EventArgs e)\n        {\n            QRCodeForm qrCodeForm = new QRCodeForm(controller.GetQRCodeForCurrentServer());\n            qrCodeForm.Icon = this.Icon;\n            qrCodeForm.Show();
        {\n            QRCodeForm qrCodeForm = new QRCodeForm(controller.GetQRCodeForCurrentServer());\n            qrCodeForm.Icon = this.Icon;\n            qrCodeForm.Show();\n        }\nprivate void AutoStartupItem_Click(object sender, EventArgs e) {\nAutoStartupItem.Checked = !AutoStartupItem.Checked;\nif (!AutoStartup.Set(AutoStartupItem.Checked)) {\nMessageBox.Show("Failed to edit registry");
        }\nprivate void AutoStartupItem_Click(object sender, EventArgs e) {\nAutoStartupItem.Checked = !AutoStartupItem.Checked;\nif (!AutoStartup.Set(AutoStartupItem.Checked)) {\nMessageBox.Show("Failed to edit registry");\n}\n}\n    }\n}
    }\n}
                Socket conn = listener.EndAccept(ar);\n                conn.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n                listener.BeginAccept(\n                    new AsyncCallback(AcceptCallback),\n                    listener);\n                Handler handler = new Handler();\n                handler.connection = conn;\n                handler.encryptor = EncryptorFactory.GetEncryptor(_server.method, _server.password);\n                handler.config = _server;\n                handler.Start();
                Handler handler = new Handler();\n                handler.connection = conn;\n                handler.encryptor = EncryptorFactory.GetEncryptor(_server.method, _server.password);\n                handler.config = _server;\n                handler.Start();\n            }\n            catch\n            {\n                //Console.WriteLine(e.Message);
                Socket conn = listener.EndAccept(ar);\n                listener.BeginAccept(\n                    new AsyncCallback(AcceptCallback),\n                    listener);\n                byte[] buf = new byte[2048];\n                object[] state = new object[] {\n                    conn,\n                    buf\n                };\n                conn.BeginReceive(buf, 0, 1024, 0,
                byte[] buf = new byte[2048];\n                object[] state = new object[] {\n                    conn,\n                    buf\n                };\n                conn.BeginReceive(buf, 0, 1024, 0,\n                    new AsyncCallback(ReceiveCallback), state);\n            }\n            catch (ObjectDisposedException)\n            {
            this.DeleteButton = new System.Windows.Forms.Button();\n            this.AddButton = new System.Windows.Forms.Button();\n            this.ServerGroupBox = new System.Windows.Forms.GroupBox();\n            this.ServersListBox = new System.Windows.Forms.ListBox();\n            this.tableLayoutPanel1.SuspendLayout();\n            this.panel1.SuspendLayout();\n            this.panel3.SuspendLayout();
            this.ServerGroupBox.SuspendLayout();\n            this.SuspendLayout();\n            // \n            // tableLayoutPanel1\n            // \n            this.tableLayoutPanel1.AutoSize = true;\n            this.tableLayoutPanel1.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;
            this.OKButton.Name = "OKButton";\n            this.OKButton.Size = new System.Drawing.Size(75, 23);\n            this.OKButton.TabIndex = 8;\n            this.OKButton.Text = "OK";\n            this.OKButton.UseVisualStyleBackColor = true;\n            this.OKButton.Click += new System.EventHandler(this.OKButton_Click);\n            // \n            // MyCancelButton\n            // \n            this.MyCancelButton.DialogResult = System.Windows.Forms.DialogResult.Cancel;\n            this.MyCancelButton.Location = new System.Drawing.Point(87, 4);
            this.MyCancelButton.Name = "MyCancelButton";\n            this.MyCancelButton.Size = new System.Drawing.Size(75, 23);\n            this.MyCancelButton.TabIndex = 9;\n            this.MyCancelButton.Text = "Cancel";\n            this.MyCancelButton.UseVisualStyleBackColor = true;\n            this.MyCancelButton.Click += new System.EventHandler(this.CancelButton_Click);\n            // \n            // panel1\n            // \n            this.panel1.AutoSize = true;\n            this.panel1.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;
            // DeleteButton\n            // \n            this.DeleteButton.Location = new System.Drawing.Point(100, 4);\n            this.DeleteButton.Name = "DeleteButton";\n            this.AddButton.Location = new System.Drawing.Point(4, 4);
            this.DeleteButton.Name = "DeleteButton";\n            this.AddButton.Location = new System.Drawing.Point(4, 4);
            this.AddButton.Name = "AddButton";\n            this.ServerGroupBox.Controls.Add(this.tableLayoutPanel1);\n            this.ServerGroupBox.Location = new System.Drawing.Point(220, 12);
            this.ServerGroupBox.Name = "ServerGroupBox";\n            this.ServersListBox.Location = new System.Drawing.Point(12, 12);
            this.ServersListBox.Name = "ServersListBox";\n            this.CancelButton = this.MyCancelButton;\n            this.ClientSize = new System.Drawing.Size(489, 287);\n            this.Controls.Add(this.ServersListBox);\n            this.Controls.Add(this.ServerGroupBox);
            this.Controls.Add(this.panel2);\n            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedSingle;\n            this.MaximizeBox = false;\n            this.MinimizeBox = false;\n            this.Name = "ConfigForm";\n            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;\n            this.Text = "Edit Servers";\n            this.FormClosed += new System.Windows.Forms.FormClosedEventHandler(this.ConfigForm_FormClosed);\n            this.Load += new System.EventHandler(this.ConfigForm_Load);
            this.ServerGroupBox.ResumeLayout(false);\n            this.ServerGroupBox.PerformLayout();\n            this.ResumeLayout(false);\n            this.PerformLayout();\n        }\n        #endregion
        private System.Windows.Forms.Button DeleteButton;\n        private System.Windows.Forms.Button AddButton;\n        private System.Windows.Forms.GroupBox ServerGroupBox;\n        private System.Windows.Forms.ListBox ServersListBox;\n        private System.Windows.Forms.TextBox RemarksTextBox;\n        private System.Windows.Forms.Label RemarksLabel;\n    }
using System.Net.Sockets;\nusing System.Text;\nusing System.Threading.Tasks;\nusing Shadowsocks.Util.Sockets;\nnamespace Shadowsocks.Controller.Service\n{\n    class Http2Socks5 : Listener.Service\n    {
using Shadowsocks.Util.Sockets;\nnamespace Shadowsocks.Controller.Service\n{\n    class Http2Socks5 : Listener.Service\n    {
                        registry.SetValue("AutoConfigURL", pacUrl);\n                    }\n                }\n                else\n                {\n                    registry.SetValue("ProxyEnable", 0);\n                    registry.SetValue("ProxyServer", "");
                    registry.SetValue("AutoConfigURL", "");\n                }\n                SystemProxy.NotifyIE();\n                //Must Notify IE first, or the connections do not chanage\n                CopyProxySettingFromLan();\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);
using System.Collections.Generic;\nusing System.Text;\nnamespace shadowsocks_csharp\n{\n    public class ShadowsocksController\n    {\n        // controller:\n        // handle user actions\n        // manipulates UI\n        // interacts with low level logic
{\n    public class ShadowsocksController\n    {\n        // controller:\n        // handle user actions\n        // manipulates UI\n        // interacts with low level logic\n        private Local local;\n        private PACServer pacServer;\n        private Config config;
using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.IO.Compression;\nusing System.Text;\nnamespace shadowsocks_csharp\n{\n    class PolipoRunner\n    {
{\n    class PolipoRunner\n    {\n        private Process process;\n        private bool ByteArrayToFile(string fileName, byte[] content)\n        {\n            try\n            {\n                System.IO.FileStream _FileStream =\n                   new System.IO.FileStream(fileName, System.IO.FileMode.Create,
        public void Start(Config config)\n        {\n            if (process == null)\n            {\n                Process[] existingPolipo = Process.GetProcessesByName("ss_polipo");\n                foreach (Process p in existingPolipo)\n                {\n                    p.Kill();\n                    p.WaitForExit();\n                }
{\n    class SystemProxy\n    {\n        [DllImport("wininet.dll")]\n        public static extern bool InternetSetOption(IntPtr hInternet, int dwOption, IntPtr lpBuffer, int dwBufferLength);\n        public const int INTERNET_OPTION_SETTINGS_CHANGED = 39;\n        public const int INTERNET_OPTION_REFRESH = 37;\n        static bool settingsReturn, refreshReturn;\n        public static void NotifyIE()\n        {
    {\n        [DllImport("wininet.dll")]\n        public static extern bool InternetSetOption(IntPtr hInternet, int dwOption, IntPtr lpBuffer, int dwBufferLength);\n        public const int INTERNET_OPTION_SETTINGS_CHANGED = 39;\n        public const int INTERNET_OPTION_REFRESH = 37;\n        static bool settingsReturn, refreshReturn;\n        public static void NotifyIE()\n        {\n            // These lines implement the Interface in the beginning of program \n            // They cause the OS to refresh the settings, causing IP to realy update
                }\n            }\n            else if (e is ObjectDisposedException)\n            {\n            }\n            else\n            {\n                Console.WriteLine(e);\n            }\n        }
            }\n        }\n    }\n    // Simply extended System.IO.StreamWriter for adding timestamp workaround\n    public class StreamWriterWithTimestamp : StreamWriter\n    {\n        public StreamWriterWithTimestamp(Stream stream) : base(stream)\n        {\n        }\n        private string GetTimestamp()
        {\n            bool Handle(byte[] firstPacket, int length, Socket socket, object state);\n        }\n        public class UDPState
                {\n                    if (service.Handle(state.buffer, bytesRead, _udpSocket, state))\n                    {\n                        break;\n                    }\n                }\n            }\n            catch (ObjectDisposedException)\n            {\n            }
            {\n            // request unregist, unregist has no side effect\n            else if (!regist)\n            {\n                UnregisterApplicationRestart();\n                Logging.Debug("Unregister restart after system reboot");\n            }\n        }
        {\n            // TODO test failures\n            WebClient http = new WebClient();\n            http.Proxy = new WebProxy(IPAddress.Loopback.ToString(), 8123);\n            http.DownloadStringCompleted += http_DownloadStringCompleted;\n            http.DownloadStringAsync(new Uri(UpdateURL));\n        }\n        public static int CompareVersion(string l, string r)\n        {\n            var ls = l.Split('.');\n            var rs = r.Split('.');
            http.DownloadStringCompleted += http_DownloadStringCompleted;\n            http.DownloadStringAsync(new Uri(UpdateURL));\n        }\n        public static int CompareVersion(string l, string r)\n        {\n            var ls = l.Split('.');\n            var rs = r.Split('.');\n            for (int i = 0; i < Math.Max(ls.Length, rs.Length); i++)\n            {\n                int lp = (i < ls.Length) ? int.Parse(ls[i]) : 0;
            this.tableLayoutPanel1.Controls.Add(this.ToolbarFlowLayoutPanel, 0, 0);\n            this.tableLayoutPanel1.Dock = System.Windows.Forms.DockStyle.Fill;\n            this.tableLayoutPanel1.Location = new System.Drawing.Point(0, 0);\n            this.tableLayoutPanel1.Name = "tableLayoutPanel1";\n            this.tableLayoutPanel1.RowCount = 2;\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());
        }\n        [DllImport("kernel32.dll")]\n        [return: MarshalAs(UnmanagedType.Bool)]\n        private static extern bool SetProcessWorkingSetSize(IntPtr process,\n            UIntPtr minimumWorkingSetSize, UIntPtr maximumWorkingSetSize);\n    }\n}
            if (dpi < 97)\n            {\n                // dpi = 96;\n                icon = Resources.ss16;\n            }\n            else if (dpi < 121)\n            {\n                // dpi = 120;\n                icon = Resources.ss20;\n            }\n            else\n            {
            }\n            else if (dpi < 121)\n            {\n                // dpi = 120;\n                icon = Resources.ss20;\n            }\n            else\n            {\n                icon = Resources.ss24;\n            }\n            Configuration config = controller.GetConfigurationCopy();
            }\n            else\n            {\n                icon = Resources.ss24;\n            }\n            Configuration config = controller.GetConfigurationCopy();\n            bool enabled = config.enabled;\n            bool global = config.global;\n            icon = getTrayIconByState(icon, enabled, global);\n            _notifyIcon.Icon = Icon.FromHandle(icon.GetHicon());
            }\n            Configuration config = controller.GetConfigurationCopy();\n            bool enabled = config.enabled;\n            bool global = config.global;\n            icon = getTrayIconByState(icon, enabled, global);\n            _notifyIcon.Icon = Icon.FromHandle(icon.GetHicon());

                {\n                    g.CopyFromScreen(Screen.PrimaryScreen.Bounds.X,\n                                     Screen.PrimaryScreen.Bounds.Y,\n                                     0, 0,\n                                     fullImage.Size,\n                                     CopyPixelOperation.SourceCopy);\n                }\n                for (int i = 0; i < 5; i++)\n                {\n                    int marginLeft = fullImage.Width * i / 3 / 5;
                    {\n                        g.DrawImage(fullImage, new Rectangle(0, 0, target.Width, target.Height),\n                                        cropRect,\n                                        GraphicsUnit.Pixel);\n                    }
                    }\n                    var source = new BitmapLuminanceSource(target);\n                    var bitmap = new BinaryBitmap(new HybridBinarizer(source));\n                    QRCodeReader reader = new QRCodeReader();\n                    var result = reader.decode(bitmap);\n                    if (result != null)\n                    {\n                        var success = controller.AddServerBySSURL(result.Text);
                    {\n                        var success = controller.AddServerBySSURL(result.Text);\n                        QRCodeSplashForm splash = new QRCodeSplashForm();\n                        if (success)\n                        {
                        {\n                            splash.FormClosed += splash_FormClosed;\n                        }\n                        else if (result.Text.StartsWith("http://") || result.Text.StartsWith("https://"))
                        }\n                        else if (result.Text.StartsWith("http://") || result.Text.StartsWith("https://"))\n                        {
                        {
                    break;\n                case "rc4":\n                    rc4.Encrypt(encryptTable, buf, length);\n                    return buf;\n                    break;\n                default:\n                    return sslEncrypt(buf, length);\n            }\n        }\n        public byte[] Decrypt(byte[] buf, int length)
                    break;\n                default:\n                    return sslEncrypt(buf, length);\n            }\n        }\n        public byte[] Decrypt(byte[] buf, int length)\n        {\n            switch (method)\n            {\n                case "table":
                    break;\n                case "rc4":\n                    rc4.Decrypt(decryptTable, buf, length);\n                    return buf;\n                    break;\n                default:\n                    return sslDecrypt(buf, length);\n            }\n        }\n    }
                    break;\n                default:\n                    return sslDecrypt(buf, length);\n            }\n        }\n    }\n}
        {\n            config = Config.Load();\n            InitializeComponent();\n            notifyIcon1.ContextMenu = contextMenu1;\n            enableItem.Checked = config.enabled;\n            configToTextBox();
            InitializeComponent();\n            notifyIcon1.ContextMenu = contextMenu1;\n            enableItem.Checked = config.enabled;\n            configToTextBox();
        }\n        private void showWindow()\n        {\n            this.Opacity = 1;\n            this.Show();\n        }\n        private void configToTextBox()\n        {\n            textBox1.Text = config.server;
        {\n            textBox1.Text = config.server;\n            textBox2.Text = config.server_port.ToString();\n            textBox3.Text = config.password;\n            textBox4.Text = config.local_port.ToString();\n            comboBox1.Text = config.method == null ? "table" : config.method;\n        }\n        private void Form1_Load(object sender, EventArgs e)
        }\n        private void Form1_Load(object sender, EventArgs e)\n        {\n            if (!config.isDefault)\n            {\n                this.Opacity = 0;\n                reload(config); BeginInvoke(new MethodInvoker(delegate\n                {\n                    this.Hide();\n                }));
            {\n                this.Opacity = 0;\n                reload(config); BeginInvoke(new MethodInvoker(delegate\n                {\n                    this.Hide();\n                }));\n            }\n            pacServer = new PACServer();\n            pacServer.Start();\n            updateSystemProxy();
                {\n                    this.Hide();\n                }));\n            }\n            pacServer = new PACServer();\n            pacServer.Start();\n            updateSystemProxy();\n        }\n        private void reload(Config config)\n        {
        }\n        private void Config_Click(object sender, EventArgs e)\n        {\n            showWindow();\n        }\n        private void Quit_Click(object sender, EventArgs e)\n        {\n            this.Close();\n        }\n        private void OKButton_Click(object sender, EventArgs e)
        }\n        private void Form1_FormClosed(object sender, FormClosedEventArgs e)\n        {\n            if (local != null) local.Stop();\n            if (polipoRunner != null) polipoRunner.Stop();\n            if (config.enabled)\n            {\n                SystemProxy.Disable();\n            }
        }\n        private void aboutToolStripMenuItem_Click(object sender, EventArgs e)\n        {\n            Process.Start("https://github.com/clowwindy/shadowsocks-csharp");\n        }\n        private void notifyIcon1_DoubleClick(object sender, EventArgs e)\n        {\n            showWindow();\n        }\n        private void updateSystemProxy()
        private void EnableItem_Click(object sender, EventArgs e)\n        {\n            enableItem.Checked = !enableItem.Checked;\n            config.enabled = enableItem.Checked;\n            Config.Save(config);\n            updateSystemProxy();\n        }\n    }\n}
        }\n    }\n}
        {\n            _config.proxy.useProxy = true;\n            _config.proxy.proxyType = type;\n            _config.proxy.proxyServer = proxy;\n            _config.proxy.proxyPort = port;\n            SaveConfig(_config);\n        }\n        public void ToggleVerboseLogging(bool enabled)\n        {
            if (UseProxyCheckBox.Checked)\n            {\n                try\n                {\n                    port = int.Parse(ProxyPortTextBox.Text);\n                }\n                catch (FormatException)
                {\n                    MessageBox.Show(I18N.GetString("Illegal port number format"));\n                    ProxyPortTextBox.Clear();\n                    return;\n                }\n                try\n                {\n                    timeout = int.Parse(ProxyTimeoutTextBox.Text);\n                }\n                catch (FormatException)
                    return;\n                }\n                try\n                {\n                    timeout = int.Parse(ProxyTimeoutTextBox.Text);\n                }\n                catch (FormatException)\n                {\n                    MessageBox.Show(I18N.GetString("Illegal timeout format"));
                {\n                    MessageBox.Show(I18N.GetString("Illegal timeout format"));\n                    ProxyTimeoutTextBox.Clear();\n                    return;\n                }\n                try\n                {\n                    Configuration.CheckServer(proxy);
                    return;\n                }\n                try\n                {\n                    Configuration.CheckServer(proxy);\n                    Configuration.CheckPort(port);\n                    Configuration.CheckTimeout(timeout, ProxyConfig.MaxProxyTimeoutSec);\n                }
            }\n            else\n            {\n                controller.DisableProxy();\n            }\n            _modifiedConfiguration.useProxy = UseProxyCheckBox.Checked;\n            _modifiedConfiguration.proxyType = type;\n            _modifiedConfiguration.proxyServer = proxy;\n            _modifiedConfiguration.proxyPort = port;\n            _modifiedConfiguration.proxyTimeout = timeout;
            this.Close();\n        }\n        private void CancelButton_Click(object sender, EventArgs e)\n        {\n            this.Close();\n        }\n        private void ProxyForm_FormClosed(object sender, FormClosedEventArgs e)\n        {\n            controller.ConfigChanged -= controller_ConfigChanged;\n        }
                    if (method == "CONNECT")\n                    {\n                        _isConnect = true;\n                        if (!ParseHost(path))\n                        {\n                            throw new Exception("Bad http header: " + line);\n                        }\n                    }\n                    else\n                    {
                        {\n                            throw new Exception("Bad http header: " + line);\n                        }\n                    }\n                    else\n                    {\n                        var targetUrl = new Uri(path);\n                        if (!ParseHost(targetUrl.Authority))\n                        {\n                            throw new Exception("Bad http header: " + line);
                if (line.IsNullOrEmpty())\n                {\n                    return true;\n                }\n                if (!_isConnect)\n                {\n                    if (line.StartsWith("Host: "))\n                    {\n                        if (!ParseHost(line.Substring(6).Trim()))\n                        {
            if (_config.availabilityStatistics)\n            {\n                availabilityStatistics.UpdateLatency(server, (int)latency.TotalMilliseconds);\n            }\n        }\n        public void UpdateInboundCounter(Server server, long n)\n        {\n            Interlocked.Add(ref _inboundCounter, n);\n            if (_config.availabilityStatistics)
            if (_config.availabilityStatistics)\n            {\n                availabilityStatistics.UpdateInboundCounter(server, n);\n            }\n        }\n        public void UpdateOutboundCounter(Server server, long n)\n        {\n            Interlocked.Add(ref _outboundCounter, n);\n            if (_config.availabilityStatistics)
            if (_config.availabilityStatistics)\n            {\n                availabilityStatistics.UpdateOutboundCounter(server, n);\n            }\n        }\n        protected void Reload()\n        {\n            Encryption.RNG.Reload();\n            // some logic in configuration updated the config when saving, we need to read it again\n            _config = Configuration.Load();
            }\n        }\n        protected void Reload()\n        {\n            Encryption.RNG.Reload();\n            // some logic in configuration updated the config when saving, we need to read it again\n            _config = Configuration.Load();\n            NLogConfig.LoadConfiguration();\n            StatisticsConfiguration = StatisticsStrategyConfiguration.Load();\n            privoxyRunner = privoxyRunner ?? new PrivoxyRunner();
    }\n    class SSRelayEventArgs : EventArgs\n    {\n        public readonly Server server;\n        public SSRelayEventArgs(Server server)\n        {\n            this.server = server;\n        }\n    }\n    class SSInboundEventArgs : SSRelayEventArgs
    {\n        public readonly Server server;\n        public SSRelayEventArgs(Server server)\n        {\n            this.server = server;\n        }\n    }\n    class SSInboundEventArgs : SSRelayEventArgs\n    {\n        public readonly long length;
    {\n        public readonly long length;\n        public SSInboundEventArgs(Server server, long length) : base(server)\n        {\n            this.length = length;\n        }\n    }\n    class SSOutboundEventArgs : SSRelayEventArgs\n    {\n        public readonly long length;
        {\n            this.length = length;\n        }\n    }\n    class SSOutboundEventArgs : SSRelayEventArgs\n    {\n        public readonly long length;\n        public SSOutboundEventArgs(Server server, long length) : base(server)\n        {\n            this.length = length;
    {\n        public readonly TimeSpan latency;\n        public SSTCPConnectedEventArgs(Server server, TimeSpan latency) : base(server)\n        {\n            this.latency = latency;\n        }\n    }\n    class SSTCPClosedEventArgs : SSRelayEventArgs\n    {\n        public readonly TCPHandler handler;
        }\n    }\n    internal class TCPHandler\n    {\n        public event EventHandler<SSTCPConnectedEventArgs> OnConnected;\n        public event EventHandler<SSInboundEventArgs> OnInbound;\n        public event EventHandler<SSOutboundEventArgs> OnOutbound;\n        public event EventHandler<SSTCPClosedEventArgs> OnClosed;
        class AsyncSession\n        {\n            public IProxy Remote { get; }\n            public AsyncSession(IProxy remote)\n            {\n                Remote = remote;\n            }\n        }\n        class AsyncSession<T> : AsyncSession\n        {
            _startSendingTime = DateTime.Now;\n            session.Remote.BeginSend(_connetionSendBuffer, 0, bytesToSend, SocketFlags.None,\n                PipeRemoteSendCallback, new object[] { session, bytesToSend });\n            IStrategy strategy = _controller.GetCurrentStrategy();\n            strategy?.UpdateLastWrite(_server);\n        }\n        private void PipeRemoteSendCallback(IAsyncResult ar)\n        {\n            if (_closed) return;\n            try
        }\n        private void PipeRemoteSendCallback(IAsyncResult ar)\n        {\n            if (_closed) return;\n            try\n            {\n                var container = (object[])ar.AsyncState;\n                var session = (AsyncSession)container[0];\n                var bytesShouldSend = (int)container[1];\n                int bytesSent = session.Remote.EndSend(ar);
        {\n            InitKey(method, password);\n        }\n        protected abstract Dictionary<string, int[]> getCiphers();\n        protected void InitKey(string method, string password)\n        {
        }\n        [DllImport("Kernel32.dll")]\n        private static extern IntPtr LoadLibrary(string path);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void crypto_stream_salsa20_xor_ic(byte[] c, byte[] m, ulong mlen, byte[] n, ulong ic, byte[] k);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void crypto_stream_chacha20_xor_ic(byte[] c, byte[] m, ulong mlen, byte[] n, ulong ic, byte[] k);
        {\n            Method = method;\n            Password = password;\n        }\n        protected string Method;\n        protected string Password;\n        protected byte[] GetPasswordHash()\n        {
            this.tableLayoutPanel1.TabIndex = 0;\n            // \n            // RemarksTextBox\n            // \n            this.RemarksTextBox.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));\n            this.RemarksTextBox.Location = new System.Drawing.Point(72, 111);\n            this.RemarksTextBox.MaxLength = 32;\n            this.RemarksTextBox.Name = "RemarksTextBox";\n            this.RemarksTextBox.Size = new System.Drawing.Size(160, 20);
            this.ServerGroupBox.TabStop = false;\n            this.ServerGroupBox.Text = "Server";\n            // \n            // ServersListBox\n            // \n            this.ServersListBox.FormattingEnabled = true;\n            this.ServersListBox.IntegralHeight = false;\n            this.ServersListBox.ItemHeight = 12;\n            this.ServersListBox.Location = new System.Drawing.Point(0, 0);\n            this.ServersListBox.Margin = new System.Windows.Forms.Padding(0);\n            this.ServersListBox.Name = "ServersListBox";\n            this.ServersListBox.Size = new System.Drawing.Size(166, 148);
            this.ServersListBox.Location = new System.Drawing.Point(0, 0);\n            this.ServersListBox.Margin = new System.Windows.Forms.Padding(0);\n            this.ServersListBox.Name = "ServersListBox";\n            this.ServersListBox.Size = new System.Drawing.Size(166, 148);
        {\n            if (string.IsNullOrEmpty(method))\n            {\n                method = "table";\n            }\n            method = method.ToLowerInvariant();\n            Type t = _registeredEncryptors[method];\n            ConstructorInfo c = t.GetConstructor(_constructorTypes);\n            IEncryptor result = (IEncryptor)c.Invoke(new object[] { method, password });\n            return result;
            return result;\n        }\n    }\n}
            this.PluginOptionsLabel.Name = "PluginOptionsLabel";\n            this.PluginTextBox.Location = new System.Drawing.Point(113, 135);\n            this.PluginTextBox.MaxLength = 256;\n            this.PluginTextBox.Name = "PluginTextBox";
            this.PluginTextBox.MaxLength = 256;\n            this.PluginTextBox.Name = "PluginTextBox";\n            this.RemarksTextBox.Location = new System.Drawing.Point(113, 238);\n            this.RemarksTextBox.MaxLength = 32;\n            this.RemarksTextBox.Name = "RemarksTextBox";
            this.RemarksTextBox.MaxLength = 32;\n            this.RemarksTextBox.Name = "RemarksTextBox";\n            this.IPLabel.Location = new System.Drawing.Point(48, 10);\n            this.IPLabel.Name = "IPLabel";
            this.IPLabel.Name = "IPLabel";\n            this.ServerPortLabel.Location = new System.Drawing.Point(36, 37);\n            this.ServerPortLabel.Name = "ServerPortLabel";
            this.ServerPortLabel.Name = "ServerPortLabel";\n            this.PasswordLabel.Location = new System.Drawing.Point(54, 64);\n            this.PasswordLabel.Name = "PasswordLabel";
            this.PasswordLabel.Name = "PasswordLabel";\n            this.IPTextBox.Location = new System.Drawing.Point(113, 6);\n            this.IPTextBox.MaxLength = 512;\n            this.IPTextBox.Name = "IPTextBox";
            this.IPTextBox.MaxLength = 512;\n            this.IPTextBox.Name = "IPTextBox";\n            this.ServerPortTextBox.Location = new System.Drawing.Point(113, 33);\n            this.ServerPortTextBox.MaxLength = 10;\n            this.ServerPortTextBox.Name = "ServerPortTextBox";
            this.ServerPortTextBox.MaxLength = 10;\n            this.ServerPortTextBox.Name = "ServerPortTextBox";\n            this.PasswordTextBox.Location = new System.Drawing.Point(113, 60);\n            this.PasswordTextBox.MaxLength = 256;\n            this.PasswordTextBox.Name = "PasswordTextBox";
            this.PasswordTextBox.MaxLength = 256;\n            this.PasswordTextBox.Name = "PasswordTextBox";\n            this.EncryptionLabel.Location = new System.Drawing.Point(42, 113);
            this.EncryptionLabel.Name = "EncryptionLabel";\n            this.EncryptionSelect.ItemHeight = 12;
            this.EncryptionSelect.Name = "EncryptionSelect";\n            this.TimeoutLabel.Location = new System.Drawing.Point(30, 269);\n            this.TimeoutLabel.Name = "TimeoutLabel";\n            this.TimeoutLabel.RightToLeft = System.Windows.Forms.RightToLeft.No;
            this.TimeoutLabel.Name = "TimeoutLabel";\n            this.TimeoutLabel.RightToLeft = System.Windows.Forms.RightToLeft.No;\n            this.TimeoutTextBox.Location = new System.Drawing.Point(113, 265);\n            this.TimeoutTextBox.MaxLength = 5;\n            this.TimeoutTextBox.Name = "TimeoutTextBox";
            this.TimeoutTextBox.MaxLength = 5;\n            this.TimeoutTextBox.Name = "TimeoutTextBox";\n            this.PluginLabel.Location = new System.Drawing.Point(18, 139);\n            this.PluginLabel.Name = "PluginLabel";
            this.PluginLabel.Name = "PluginLabel";\n            this.PluginOptionsTextBox.Location = new System.Drawing.Point(113, 162);\n            this.PluginOptionsTextBox.MaxLength = 256;\n            this.PluginOptionsTextBox.Name = "PluginOptionsTextBox";
            this.PluginOptionsTextBox.MaxLength = 256;\n            this.PluginOptionsTextBox.Name = "PluginOptionsTextBox";\n            this.ShowPasswdCheckBox.Location = new System.Drawing.Point(113, 87);
            this.ShowPasswdCheckBox.Name = "ShowPasswdCheckBox";\n            this.PluginArgumentsTextBox.Location = new System.Drawing.Point(113, 211);
            this.PluginArgumentsTextBox.MaxLength = 512;\n            this.PluginArgumentsTextBox.Name = "PluginArgumentsTextBox";\n            this.PluginArgumentsLabel.Location = new System.Drawing.Point(6, 215);\n            this.PluginArgumentsLabel.Name = "PluginArgumentsLabel";
            this.PluginArgumentsLabel.Name = "PluginArgumentsLabel";\n            this.RemarksLabel.Location = new System.Drawing.Point(60, 242);
            this.RemarksLabel.Name = "RemarksLabel";\n            this.NeedPluginArgCheckBox.Location = new System.Drawing.Point(113, 189);\n            this.NeedPluginArgCheckBox.Name = "NeedPluginArgCheckBox";
            this.NeedPluginArgCheckBox.Name = "NeedPluginArgCheckBox";\n            this.panel2.Location = new System.Drawing.Point(165, 187);
            this.panel2.Name = "panel2";\n            this.panel2.Size = new System.Drawing.Size(0, 0);\n            this.panel2.TabIndex = 1;\n            // \n            // OKButton\n            // \n            this.OKButton.DialogResult = System.Windows.Forms.DialogResult.OK;\n            this.OKButton.Dock = System.Windows.Forms.DockStyle.Right;
            this.tableLayoutPanel5.RowCount = 2;\n            this.tableLayoutPanel5.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel5.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.ProxyPortTextBox.Location = new System.Drawing.Point(77, 6);\n            this.ProxyPortTextBox.MaxLength = 10;\n            this.ProxyPortTextBox.Name = "ProxyPortTextBox";
            this.ProxyPortTextBox.MaxLength = 10;\n            this.ProxyPortTextBox.Name = "ProxyPortTextBox";\n            this.ProxyPortLabel.Location = new System.Drawing.Point(6, 10);\n            this.ProxyPortLabel.Name = "ProxyPortLabel";
            this.ProxyPortLabel.Name = "ProxyPortLabel";\n            this.PortableModeCheckBox.Location = new System.Drawing.Point(6, 37);\n            this.PortableModeCheckBox.Name = "PortableModeCheckBox";
            this.PortableModeCheckBox.Name = "PortableModeCheckBox";
using GlobalHotKey;\nusing System.Windows.Input;\nusing System.Threading;\nusing System.Collections.Generic;\nusing Shadowsocks.Controller.Hotkeys;\nusing Shadowsocks.Encryption.Stream;\nusing Shadowsocks.Model;\nusing Shadowsocks.Controller.Service;\nusing System.Diagnostics;\nusing System.Net;
using System.Diagnostics;\nusing System.Net;\nnamespace test\n{\n    [TestClass]\n    public class UnitTest\n    {\n        [TestMethod]\n        public void TestCompareVersion()
{\n    [TestClass]\n    public class UnitTest\n    {\n        [TestMethod]\n        public void TestCompareVersion()\n        {\n            Assert.IsTrue(UpdateChecker.Asset.CompareVersion("2.3.1.0", "2.3.1") == 0);\n            Assert.IsTrue(UpdateChecker.Asset.CompareVersion("1.2", "1.3") < 0);\n            Assert.IsTrue(UpdateChecker.Asset.CompareVersion("1.3", "1.2") > 0);
        {\n            try\n            {\n                string pac = GetPACContent();\n                IPEndPoint localEndPoint = (IPEndPoint)socket.LocalEndPoint;\n                string proxy = GetPACAddress(firstPacket, length, localEndPoint, useSocks);\n                pac = pac.Replace("__PROXY__", proxy);\n                string text = String.Format(@"HTTP/1.1 200 OK\nServer: Shadowsocks\nContent-Type: application/x-ns-proxy-autoconfig
                IPEndPoint localEndPoint = (IPEndPoint)socket.LocalEndPoint;\n                string proxy = GetPACAddress(firstPacket, length, localEndPoint, useSocks);\n                pac = pac.Replace("__PROXY__", proxy);\n                string text = String.Format(@"HTTP/1.1 200 OK\nServer: Shadowsocks\nContent-Type: application/x-ns-proxy-autoconfig\nContent-Length: {0}\nConnection: Close\n", Encoding.UTF8.GetBytes(pac).Length) + pac;\n                byte[] response = Encoding.UTF8.GetBytes(text);
Server: Shadowsocks\nContent-Type: application/x-ns-proxy-autoconfig\nContent-Length: {0}\nConnection: Close\n", Encoding.UTF8.GetBytes(pac).Length) + pac;\n                byte[] response = Encoding.UTF8.GetBytes(text);\n                socket.BeginSend(response, 0, response.Length, 0, new AsyncCallback(SendCallback), socket);\n                Utils.ReleaseMemory(true);\n            }\n            catch (Exception e)
                socket.BeginSend(response, 0, response.Length, 0, new AsyncCallback(SendCallback), socket);\n                Utils.ReleaseMemory(true);\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                socket.Close();\n            }\n        }\n        private void SendCallback(IAsyncResult ar)
                }\n                catch (IOException e)\n                {\n                    Console.WriteLine(e.ToString());\n                }\n                //LoadLibrary(dllPath);\n#if !DEBUG\n                Logging.OpenLogFile();\n#endif\n                Application.EnableVisualStyles();
    {\n        // A value in INTERNET_OPTION_PER_CONN_FLAGS.\n        [FieldOffset(0)]\n        public int dwValue;\n        [FieldOffset(0)]\n        public System.IntPtr pszValue;\n        [FieldOffset(0)]\n        public System.Runtime.InteropServices.ComTypes.FILETIME ftValue;
    {\n        public int Size;\n        // The connection to be set. NULL means LAN.\n        public System.IntPtr Connection;\n        public int OptionCount;\n        public int OptionError;\n        // List of INTERNET_PER_CONN_OPTIONs.\n        public System.IntPtr pOptions;
                return true;\n            }\n            catch (IOException e)\n            {\n                Console.WriteLine(e.ToString());\n                return false;\n            }\n        }\n        private static void RollLogFile()\n        {
        private static void WriteToLogFile(object o)\n        {\n            if ((DateTime.Now - LogFileCreationTime).Days >= 1)\n                RollLogFile();\n            Console.WriteLine(o);\n        }\n        public static void Error(object o)\n        {\n            WriteToLogFile("[E] " + o);\n        }
            Console.WriteLine(o);\n        }\n        public static void Error(object o)\n        {\n            WriteToLogFile("[E] " + o);\n        }\n        public static void Info(object o)\n        {\n            WriteToLogFile(o);\n        }
        // this is a copy of configuration that we are working on\n        private Configuration _modifiedConfiguration;\n        private int _oldSelectedIndex = -1;\n        private bool _isFirstRun;\n        public ConfigForm(ShadowsocksController controller)\n        {\n            InitializeComponent();\n            this.Icon = Icon.FromHandle(Resources.ssw128.GetHicon());\n            this.controller = controller;\n            controller.ConfigChanged += controller_ConfigChanged;\n            LoadCurrentConfiguration();
        public ConfigForm(ShadowsocksController controller)\n        {\n            InitializeComponent();\n            this.Icon = Icon.FromHandle(Resources.ssw128.GetHicon());\n            this.controller = controller;\n            controller.ConfigChanged += controller_ConfigChanged;\n            LoadCurrentConfiguration();\n        }\n        private void controller_ConfigChanged(object sender, EventArgs e)\n        {
        private static readonly ConcurrentDictionary<string, byte[]> CachedKeys = new ConcurrentDictionary<string, byte[]>();\n        protected byte[] _encryptIV;\n        protected byte[] _decryptIV;\n        protected bool _decryptIVReceived;\n        protected bool _encryptIVSent;\n        protected string _method;\n        protected int _cipher;\n        // cipher name in MbedTLS, useless when using LibSodium\n        protected string _cipherMbedName;\n        protected int[] _cipherInfo;\n        protected byte[] _key;
        protected byte[] _key;\n        protected int keyLen;\n        protected int ivLen;\n        public IVEncryptor(string method, string password, bool onetimeauth, bool isudp)\n            : base(method, password, onetimeauth, isudp)\n        {\n            InitKey(method, password);\n        }\n        protected abstract Dictionary<string, Dictionary<string, int[]>> getCiphers();\n        private void InitKey(string method, string password)
        private void InitKey(string method, string password)\n        {\n            method = method.ToLower();\n            _method = method;\n            string k = method + ":" + password;\n            ciphers = getCiphers();\n            ciphersDetail = ciphers[_method];\n            _cipherMbedName = ciphersDetail.Keys.FirstOrDefault();\n            _cipherInfo = ciphers[_method][_cipherMbedName];\n            _cipher = _cipherInfo[2];
            if (_cipher == 0)\n            {\n                throw new Exception("method not found");\n            }\n            keyLen = _cipherInfo[0];\n            ivLen = _cipherInfo[1];\n            _key = CachedKeys.GetOrAdd(k, (nk) =>\n            {\n                byte[] passbuf = Encoding.UTF8.GetBytes(password);\n                byte[] key = new byte[32];
            _key = CachedKeys.GetOrAdd(k, (nk) =>\n            {\n                byte[] passbuf = Encoding.UTF8.GetBytes(password);\n                byte[] key = new byte[32];\n                bytesToKey(passbuf, key);\n                return key;\n            });\n        }\n        protected void bytesToKey(byte[] password, byte[] key)\n        {
        };\n        public static List<string> SupportedCiphers()\n        {\n            return new List<string>(_ciphers.Keys);\n        }\n        protected override Dictionary<string, Dictionary<string, int[]>> getCiphers()\n        {\n            return _ciphers;\n        }\n        protected override void initCipher(byte[] iv, bool isCipher)
        {\n            return _ciphers;\n        }\n        protected override void initCipher(byte[] iv, bool isCipher)\n        {\n            base.initCipher(iv, isCipher);\n            IntPtr ctx = Marshal.AllocHGlobal(MbedTLS.cipher_get_size_ex());\n            if (isCipher)\n            {\n                _encryptCtx = ctx;
        };\n        protected override Dictionary<string, Dictionary<string, int[]>> getCiphers()\n        {\n            return _ciphers;\n        }\n        public static List<string> SupportedCiphers()\n        {\n            return new List<string>(_ciphers.Keys);\n        }\n        protected override void cipherUpdate(bool isCipher, int length, byte[] buf, byte[] outbuf)
        {\n            return _ciphers;\n        }\n        public static List<string> SupportedCiphers()\n        {\n            return new List<string>(_ciphers.Keys);\n        }\n        protected override void cipherUpdate(bool isCipher, int length, byte[] buf, byte[] outbuf)\n        {\n            // TODO write a unidirection cipher so we don't have to if if if
        }\n        #endregion
        protected static byte[] tempbuf = new byte[MAX_INPUT_SIZE];\n        protected Dictionary<string, int[]> ciphers;\n        private static readonly Dictionary<string, byte[]> CachedKeys = new Dictionary<string, byte[]>();\n        protected byte[] _encryptIV;\n        protected byte[] _decryptIV;\n        protected bool _decryptIVReceived;\n        protected bool _encryptIVSent;\n        protected int _encryptIVOffset = 0;\n        protected int _decryptIVOffset = 0;\n        protected string _method;
        public IVEncryptor(string method, string password, bool onetimeauth)\n            : base(method, password, onetimeauth)\n        {\n            InitKey(method, password);\n            if (OnetimeAuth)\n            {\n                crc_buf = new byte[CRC_BUF_LEN];\n            }\n        }\n        protected abstract Dictionary<string, int[]> getCiphers();
            }\n        }\n        protected abstract Dictionary<string, int[]> getCiphers();\n        protected void InitKey(string method, string password)\n        {\n            method = method.ToLower();\n            _method = method;\n            string k = method + ":" + password;\n            ciphers = getCiphers();\n            _cipherInfo = ciphers[_method];
                        {\n                            int headLen = GetSSHeadLength(buf, length);\n                            int data_len = length - headLen;\n                            Buffer.BlockCopy(buf, headLen, buf, headLen + ONETIMEAUTH_BYTES, data_len);\n                            buf[0] |= ONETIMEAUTH_FLAG;\n                            byte[] auth = new byte[ONETIMEAUTH_BYTES];\n                            Sodium.ss_onetimeauth(auth, buf, headLen, _encryptIV, ivLen, _key, keyLen);\n                            Buffer.BlockCopy(auth, 0, buf, headLen, ONETIMEAUTH_BYTES);\n                            int buf_offset = headLen + ONETIMEAUTH_BYTES;\n                            int rc = Sodium.ss_gen_crc(buf, ref buf_offset, ref data_len, crc_buf, ref crc_idx, buf.Length);
                            int data_len = length - headLen;\n                            Buffer.BlockCopy(buf, headLen, buf, headLen + ONETIMEAUTH_BYTES, data_len);\n                            buf[0] |= ONETIMEAUTH_FLAG;\n                            byte[] auth = new byte[ONETIMEAUTH_BYTES];\n                            Sodium.ss_onetimeauth(auth, buf, headLen, _encryptIV, ivLen, _key, keyLen);\n                            Buffer.BlockCopy(auth, 0, buf, headLen, ONETIMEAUTH_BYTES);\n                            int buf_offset = headLen + ONETIMEAUTH_BYTES;\n                            int rc = Sodium.ss_gen_crc(buf, ref buf_offset, ref data_len, crc_buf, ref crc_idx, buf.Length);\n                            if (rc != 0)\n                                throw new Exception("failed to generate crc");
                            Buffer.BlockCopy(auth, 0, buf, headLen, ONETIMEAUTH_BYTES);\n                            int buf_offset = headLen + ONETIMEAUTH_BYTES;\n                            int rc = Sodium.ss_gen_crc(buf, ref buf_offset, ref data_len, crc_buf, ref crc_idx, buf.Length);\n                            if (rc != 0)\n                                throw new Exception("failed to generate crc");\n                            length = headLen + ONETIMEAUTH_BYTES + data_len;\n                        }\n                    }\n                    cipherUpdate(true, length, buf, tempbuf);
                            length = headLen + ONETIMEAUTH_BYTES + data_len;\n                        }\n                    }\n                    cipherUpdate(true, length, buf, tempbuf);\n                    outlength = length + ivLen;\n                    Buffer.BlockCopy(tempbuf, 0, outbuf, ivLen, length);\n                }\n            }\n            else\n            {
                    {\n                        int buf_offset = 0;\n                        int rc = Sodium.ss_gen_crc(buf, ref buf_offset, ref length, crc_buf, ref crc_idx, buf.Length);\n                        if (rc != 0)\n                            throw new Exception("failed to generate crc");\n                    }\n                }\n                outlength = length;\n                cipherUpdate(true, length, buf, outbuf);
                    }\n                }\n                outlength = length;\n                cipherUpdate(true, length, buf, outbuf);\n            }\n        }\n        public override void Decrypt(byte[] buf, int length, byte[] outbuf, out int outlength)\n        {\n            if (!_decryptIVReceived)\n            {
        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int ss_onetimeauth(byte[] auth, \n            byte[] msg, int msg_len, \n            byte[] iv, int iv_len,\n            byte[] key, int key_len);\n    }\n}
    }\n}
private void autoStartup_Click(object sender, EventArgs e) {\nautoStartup.Checked = !autoStartup.Checked;\nif (!setAutoStartup(autoStartup.Checked)) {\n//MessageBox.Show("Failed to edit registry");\n}\n}\nprivate void contextMenu1_Popup(object sender, EventArgs e) {\nautoStartup.Checked = checkAutoStartup();\n}\n    }
}\n}\nprivate void contextMenu1_Popup(object sender, EventArgs e) {\nautoStartup.Checked = checkAutoStartup();\n}\n    }\n}
}\n    }\n}
            using (Graphics g = Graphics.FromImage(drawArea))\n            {\n                g.Clear(Color.White);\n                using (Brush b = new SolidBrush(Color.Black))\n                {\n                    for (int row = 0; row < m.Height; row++)\n                    {\n                        for (int col = 0; col < m.Height; col++)\n                        {\n                            if (m[row, col] != 0)
         // Determine what character encoding has been specified by the caller, if any\n#if !SILVERLIGHT || WINDOWS_PHONE\n         String encoding = hints == null || !hints.ContainsKey(EncodeHintType.CHARACTER_SET) ? null : (String)hints[EncodeHintType.CHARACTER_SET];\n         if (encoding == null)\n         {\n            encoding = DEFAULT_BYTE_MODE_ENCODING;\n         }\n         bool generateECI = !DEFAULT_BYTE_MODE_ENCODING.Equals(encoding);\n#else\n         // Silverlight supports only UTF-8 and UTF-16 out-of-the-box\n         const string encoding = "UTF-8";\n         Mode mode = chooseMode(content, encoding);
#else\n         // Silverlight supports only UTF-8 and UTF-16 out-of-the-box\n         const string encoding = "UTF-8";\n         // caller of the method can only control if the ECI segment should be written\n         // character set is fixed to UTF-8; but some scanners doesn't like the ECI segment\n         bool generateECI = (hints != null && hints.ContainsKey(EncodeHintType.CHARACTER_SET));\n#endif\n         // Pick an encoding mode appropriate for the content. Note that this will not attempt to use\n         // multiple modes / segments even if that were more efficient. Twould be nice.\n         Mode mode = chooseMode(content, encoding);\n         // This will store the header information, like mode and\n         // length, as well as "header" segments like an ECI segment.\n         BitArray headerBits = new BitArray();\n         /*\n          // Append ECI segment if applicable\n         if (mode == Mode.BYTE && generateECI)\n         {
         // This will store the header information, like mode and\n         // length, as well as "header" segments like an ECI segment.\n         BitArray headerBits = new BitArray();\n         /*\n          // Append ECI segment if applicable\n         if (mode == Mode.BYTE && generateECI)\n         {\n            CharacterSetECI eci = CharacterSetECI.getCharacterSetECIByName(encoding);\n            if (eci != null)\n            {
               if (mode.Equals(Mode.BYTE))\n                  append8BitBytes(content, bits, encoding);\n               else\n                  if (mode.Equals(Mode.KANJI))\n                     appendKanjiBytes(content, bits);\n                  else\n                      throw new Exception("Invalid mode: " + mode);\n      }\n      internal static void appendNumericBytes(String content, BitArray bits)\n      {
                  else\n                      throw new Exception("Invalid mode: " + mode);\n      }\n      internal static void appendNumericBytes(String content, BitArray bits)\n      {\n         int length = content.Length;\n         int i = 0;\n         while (i < length)\n         {\n            int num1 = content[i] - '0';
      }\n      internal static void append8BitBytes(String content, BitArray bits, String encoding)\n      {\n         byte[] bytes;\n         try\n         {\n            bytes = Encoding.GetEncoding(encoding).GetBytes(content);\n         }\n#if WindowsCE\n         catch (PlatformNotSupportedException)
      /// <summary>\n      /// Gets the version for number.\n      /// </summary>\n      /// <param name="versionNumber">The version number.</param>\n      /// <returns></returns>\n      public static Version getVersionForNumber(int versionNumber)\n      {\n         if (versionNumber < 1 || versionNumber > 40)\n         {\n            throw new ArgumentException();\n      }\n      internal static Version decodeVersionInformation(int versionBits)\n      {
      }\n      /// <summary> <p>Encapsulates a set of error-correction blocks in one symbol version. Most versions will\n      /// use blocks of differing sizes within one version, so, this encapsulates the parameters for\n      /// each set of blocks. It also holds the number of error-correction codewords per block since it\n      /// will be the same across all blocks within one version.</p>\n      /// </summary>\n      public sealed class ECBlocks\n      {\n         private readonly int ecCodewordsPerBlock;\n         private readonly ECB[] ecBlocks;
      /// Gets the generator base.\n      /// </summary>\n      public int GeneratorBase\n      {\n         get { return generatorBase; }\n      }\n      /// <summary>\n      /// Returns a <see cref="System.String"/> that represents this instance.\n      /// </summary>\n      /// <returns>\n      /// A <see cref="System.String"/> that represents this instance.\n      /// </returns>\n   }\n}
   }\n}
      }\n      public BitArray()\n      {\n         this.size = 0;\n         this.bits = new int[1];\n      }\n      public BitArray(int size)\n      {\n         if (size < 1)\n         {
      }\n      private void ensureCapacity(int size)\n      {\n         if (size > bits.Length << 5)\n         {\n            int[] newBits = makeArray(size);\n            System.Array.Copy(bits, 0, newBits, 0, bits.Length);\n            bits = newBits;\n         }
      private static int[] makeArray(int size)\n      {\n         return new int[(size + 31) >> 5];\n      }\n      /// <summary>\n      /// Determines whether the specified <see cref="System.Object"/> is equal to this instance.\n      /// </summary>\n      /// <param name="o">The <see cref="System.Object"/> to compare with this instance.</param>\n      /// <returns>\n      ///   <c>true</c> if the specified <see cref="System.Object"/> is equal to this instance; otherwise, <c>false</c>.
   }\n}
            }\n            else\n            {\n                logFormsVisible = !logFormsVisible;\n                foreach (LogForm f in logForms)\n                {\n                    f.Visible = logFormsVisible;\n                }
            }\n        }\n        void logForm_FormClosed(object sender, FormClosedEventArgs e)\n        {\n            logForms.Remove((LogForm)sender);\n        }\n        void configForm_FormClosed(object sender, FormClosedEventArgs e)\n        {
        }\n        void configForm_FormClosed(object sender, FormClosedEventArgs e)\n        {\n            configForm = null;\n            Utils.ReleaseMemory(true);\n            if (_isFirstRun)\n            {\n                CheckUpdateForFirstRun();\n                ShowFirstTimeBalloon();\n                _isFirstRun = false;
                bytesToKey(passbuf, key);\n                return key;\n            });\n        }\n        protected void bytesToKey(byte[] password, byte[] key)\n        {\n            byte[] result = new byte[password.Length + 16];\n            int i = 0;\n            byte[] md5sum = null;\n            while (i < key.Length)
        {\n            byte[] result = new byte[password.Length + 16];\n            int i = 0;\n            byte[] md5sum = null;\n            while (i < key.Length)\n            {\n                if (i == 0)\n                {\n                    md5sum = MbedTLS.MD5(password);\n                }
            {\n                File.WriteAllText(NLOG_CONFIG_FILE_NAME, Properties.Resources.NLog_config);\n                LogManager.LoadConfiguration(NLOG_CONFIG_FILE_NAME);\n            }
            }\n        }\n        /// <summary>\n        /// NLog reload the config file and apply to current LogManager
        }\n        private Sip003Plugin(string plugin, string pluginOpts, string serverAddress, int serverPort)\n        {\n            if (plugin == null) throw new ArgumentNullException(nameof(plugin));\n            if (string.IsNullOrWhiteSpace(serverAddress))\n            {\n                throw new ArgumentException("Value cannot be null or whitespace.", nameof(serverAddress));\n            }\n            if (serverPort <= 0 || serverPort > 65535)\n            {
        {\n            if (plugin == null) throw new ArgumentNullException(nameof(plugin));\n            if (string.IsNullOrWhiteSpace(serverAddress))\n            {\n                throw new ArgumentException("Value cannot be null or whitespace.", nameof(serverAddress));\n            }\n            if (serverPort <= 0 || serverPort > 65535)\n            {\n                throw new ArgumentOutOfRangeException("serverPort");\n            }
            this.tableLayoutPanel1.TabIndex = 0;\n            // \n            // PluginOptionsLabel\n            // \n            this.PluginOptionsLabel.Anchor = System.Windows.Forms.AnchorStyles.Right;\n            this.PluginOptionsLabel.AutoSize = true;
        private System.Windows.Forms.TextBox IPTextBox;\n        private System.Windows.Forms.TextBox ServerPortTextBox;\n        private System.Windows.Forms.TextBox PasswordTextBox;\n        private System.Windows.Forms.TextBox ProxyPortTextBox;\n        private System.Windows.Forms.Label EncryptionLabel;\n        private System.Windows.Forms.ComboBox EncryptionSelect;\n        private System.Windows.Forms.Panel panel2;\n        private System.Windows.Forms.Button OKButton;\n        private System.Windows.Forms.Button MyCancelButton;\n        private System.Windows.Forms.Button DeleteButton;
        private System.Windows.Forms.Label EncryptionLabel;\n        private System.Windows.Forms.ComboBox EncryptionSelect;\n        private System.Windows.Forms.Panel panel2;\n        private System.Windows.Forms.Button OKButton;\n        private System.Windows.Forms.Button MyCancelButton;\n        private System.Windows.Forms.Button DeleteButton;\n        private System.Windows.Forms.Button AddButton;\n        private System.Windows.Forms.GroupBox ServerGroupBox;\n        private System.Windows.Forms.ListBox ServersListBox;\n        private System.Windows.Forms.TextBox RemarksTextBox;
            this.panel3 = new System.Windows.Forms.Panel();\n            this.AddButton = new System.Windows.Forms.Button();\n            this.DeleteButton = new System.Windows.Forms.Button();\n            this.groupBox1 = new System.Windows.Forms.GroupBox();\n            this.tableLayoutPanel1.SuspendLayout();\n            this.panel1.SuspendLayout();\n            this.panel3.SuspendLayout();\n            this.groupBox1.SuspendLayout();\n            this.SuspendLayout();
            this.Controls.Add(this.panel1);\n            this.Controls.Add(this.panel3);\n            this.Controls.Add(this.panel2);\n            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedSingle;\n            this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));\n            this.MaximizeBox = false;\n            this.Name = "ConfigForm";\n            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;\n            this.Text = "Shadowsocks";\n            this.FormClosed += new System.Windows.Forms.FormClosedEventHandler(this.ConfigForm_FormClosed);
        private System.Windows.Forms.Panel panel3;\n        private System.Windows.Forms.Button DeleteButton;\n        private System.Windows.Forms.Button AddButton;\n        private System.Windows.Forms.GroupBox groupBox1;\n    }\n}
[assembly: AssemblyProduct("Shadowsocks")]\n[assembly: AssemblyCopyright("Copyright © clowwindy 2014")]\n[assembly: AssemblyTrademark("")]\n[assembly: AssemblyCulture("")]\n// 将 ComVisible 设置为 false 使此程序集中的类型\n// 对 COM 组件不可见。如果需要从 COM 访问此程序集中的类型，\n// 则将该类型上的 ComVisible 属性设置为 true。\n[assembly: ComVisible(false)]\n// 如果此项目向 COM 公开，则下列 GUID 用于类型库的 ID\n[assembly: Guid("f8334709-4309-436a-8bbd-6165dcf4a660")]\n[assembly: AssemblyFileVersion("2.0.0")]

    _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);\n  }\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n  public Geosite Clone() {\n    return new Geosite(this);\n  }\n  /// <summary>Field number for the "country_code" field.</summary>\n  public const int CountryCodeFieldNumber = 1;\n  private string countryCode_ = "";\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    set {\n      countryCode_ = pb::ProtoPreconditions.CheckNotNull(value, "value");\n    }\n  }\n  /// <summary>Field number for the "domain" field.</summary>\n  public const int DomainFieldNumber = 2;\n  private static readonly pb::FieldCodec<global::DomainObject> _repeated_domain_codec\n      = pb::FieldCodec.ForMessage(18, global::DomainObject.Parser);\n  private readonly pbc::RepeatedField<global::DomainObject> domain_ = new pbc::RepeatedField<global::DomainObject>();\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n  public pbc::RepeatedField<global::DomainObject> Domain {
      = pb::FieldCodec.ForMessage(18, global::DomainObject.Parser);\n  private readonly pbc::RepeatedField<global::DomainObject> domain_ = new pbc::RepeatedField<global::DomainObject>();\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n  public pbc::RepeatedField<global::DomainObject> Domain {\n    get { return domain_; }\n  }\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n  public override bool Equals(object other) {\n    return Equals(other as Geosite);\n  }
  }\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n  public override bool Equals(object other) {\n    return Equals(other as Geosite);\n  }\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n  public bool Equals(Geosite other) {\n    if (ReferenceEquals(other, null)) {\n      return false;\n    }
    return Equals(_unknownFields, other._unknownFields);\n  }\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n  public override int GetHashCode() {\n    int hash = 1;\n    if (CountryCode.Length != 0) hash ^= CountryCode.GetHashCode();\n    hash ^= domain_.GetHashCode();\n    if (_unknownFields != null) {\n      hash ^= _unknownFields.GetHashCode();\n    }
    if (_unknownFields != null) {\n      hash ^= _unknownFields.GetHashCode();\n    }\n    return hash;\n  }\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n  public override string ToString() {\n    return pb::JsonFormatter.ToDiagnosticString(this);\n  }\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      output.WriteRawTag(10);\n      output.WriteString(CountryCode);\n    }\n    domain_.WriteTo(output, _repeated_domain_codec);\n    if (_unknownFields != null) {\n      _unknownFields.WriteTo(output);\n    }\n  }\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n  public int CalculateSize() {
    if (_unknownFields != null) {\n      _unknownFields.WriteTo(output);\n    }\n  }\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n  public int CalculateSize() {\n    int size = 0;\n    if (CountryCode.Length != 0) {\n      size += 1 + pb::CodedOutputStream.ComputeStringSize(CountryCode);\n    }
    if (_unknownFields != null) {\n      size += _unknownFields.CalculateSize();\n    }\n    return size;\n  }\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n  public void MergeFrom(Geosite other) {\n    if (other == null) {\n      return;\n    }
          break;\n        }\n        case 18: {\n          domain_.AddEntriesFrom(input, _repeated_domain_codec);\n          break;\n        }\n      }\n    }\n  }\n}
          break;\n        }\n      }\n    }\n  }\n}\npublic sealed partial class GeositeList : pb::IMessage<GeositeList> {\n  private static readonly pb::MessageParser<GeositeList> _parser = new pb::MessageParser<GeositeList>(() => new GeositeList());\n  private pb::UnknownFieldSet _unknownFields;\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      = pb::FieldCodec.ForMessage(10, global::Geosite.Parser);\n  private readonly pbc::RepeatedField<global::Geosite> entry_ = new pbc::RepeatedField<global::Geosite>();\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n  public pbc::RepeatedField<global::Geosite> Entry {\n    get { return entry_; }\n  }\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n  public override bool Equals(object other) {\n    return Equals(other as GeositeList);\n  }
  }\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n  public override bool Equals(object other) {\n    return Equals(other as GeositeList);\n  }\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n  public bool Equals(GeositeList other) {\n    if (ReferenceEquals(other, null)) {\n      return false;\n    }
    return Equals(_unknownFields, other._unknownFields);\n  }\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n  public override int GetHashCode() {\n    int hash = 1;\n    hash ^= entry_.GetHashCode();\n    if (_unknownFields != null) {\n      hash ^= _unknownFields.GetHashCode();\n    }\n    return hash;
        static GeositeUpdater()\n        {\n            List = GeositeList.Parser.ParseFrom(File.ReadAllBytes(DatabasePath));\n            foreach (var item in List.Entry)
            {\n                Geosites[item.CountryCode] = item.Domain.ToList();\n            }
            }
                        line = line.Replace("*", "/");\n                    if (line.StartsWith("||"))\n                        line = line.Substring(2);\n                    else if (line.StartsWith("|"))\n                        line = line.Substring(1);\n                    else if (line.StartsWith("."))\n                        line = line.Substring(1);\n                    if (line.StartsWith("!"))\n                        continue;
                    else if (line.StartsWith("|"))\n                        line = line.Substring(1);\n                    else if (line.StartsWith("."))\n                        line = line.Substring(1);\n                    if (line.StartsWith("!"))\n                        continue;\n                    else if (line.StartsWith("["))\n                        continue;\n                    else if (line.StartsWith("@"))\n                        continue; /*ignore white list*/
                    else if (line.StartsWith("."))\n                        line = line.Substring(1);\n                    if (line.StartsWith("!"))\n                        continue;\n                    else if (line.StartsWith("["))\n                        continue;\n                    else if (line.StartsWith("@"))\n                        continue; /*ignore white list*/\n                    domains.Add(line);\n                }
                    if (line.StartsWith("!"))\n                        continue;\n                    else if (line.StartsWith("["))\n                        continue;\n                    else if (line.StartsWith("@"))\n                        continue; /*ignore white list*/\n                    domains.Add(line);\n                }\n                return domains.ToArray();
            }\n            /* refer https://github.com/clowwindy/gfwlist2pac/blob/master/gfwlist2pac/main.py */\n            public string[] GetReducedDomains()\n            {\n                string[] domains = GetDomains();\n                List<string> new_domains = new List<string>(domains.Length);\n                TldIndex tldIndex = GetTldIndex();\n                foreach(string domain in domains)\n                {\n                    string last_root_domain = null;
                    {\n                        e = new Exception(I18N.GetString("Port {0} already in use", _config.localPort), e);\n                    }\n                }\n                Logging.LogUsefulException(e);\n                ReportError(e);
    }\n}
            InitializeComponent();\n            // a dirty hack\n            this.ServersListBox.Dock = DockStyle.Fill;\n            this.tableLayoutPanel5.Dock = DockStyle.Fill;\n            this.PerformLayout();\n            UpdateTexts();\n            SetupValueChangedListeners();\n            this.Icon = Icon.FromHandle(Resources.ssw128.GetHicon());\n            this.controller = controller;
            UpdateTexts();\n            SetupValueChangedListeners();\n            this.Icon = Icon.FromHandle(Resources.ssw128.GetHicon());\n            this.controller = controller;
            this.controller = controller;
            RemarksLabel.Text = I18N.GetString("Remarks");\n            TimeoutLabel.Text = I18N.GetString("Timeout(Sec)");\n            ServerGroupBox.Text = I18N.GetString("Server");\n            OKButton.Text = I18N.GetString("OK");\n            MyCancelButton.Text = I18N.GetString("Cancel");\n            ApplyButton.Text = I18N.GetString("Apply");\n            MoveUpButton.Text = I18N.GetString("Move &Up");\n            MoveDownButton.Text = I18N.GetString("Move D&own");\n            this.Text = I18N.GetString("Edit Servers");\n        }
        }\n        private void SetupValueChangedListeners()\n        {\n            IPTextBox.TextChanged += ConfigValueChanged;\n            ProxyPortTextBox.TextChanged += ConfigValueChanged;\n            PasswordTextBox.TextChanged += ConfigValueChanged;\n            EncryptionSelect.SelectedIndexChanged += ConfigValueChanged;\n            PluginTextBox.TextChanged += ConfigValueChanged;\n            PluginArgumentsTextBox.TextChanged += ConfigValueChanged;\n            PluginOptionsTextBox.TextChanged += ConfigValueChanged;
        {\n            try\n            {\n                if (_lastSelectedIndex == -1 || _lastSelectedIndex >= _modifiedConfiguration.configs.Count)\n                {\n                    return true;\n                }\n                Server server = GetServerDetailsFromUI();\n                if (server == null)\n                {
                return true;\n            }
            LoadServerNameListToUI(_modifiedConfiguration);\n            ServersListBox.SelectedIndex = _modifiedConfiguration.configs.Count - 1;\n            _lastSelectedIndex = ServersListBox.SelectedIndex;\n        }\n        private void DuplicateButton_Click(object sender, EventArgs e)\n        {\n            if (_lastSelectedIndex == -1 || _lastSelectedIndex > _modifiedConfiguration.configs.Count\n                || !ValidateAndSaveSelectedServerDetails())\n            {\n                return;
            LoadSelectedServerDetails();\n            UpdateButtons();\n        }\n        private void OKButton_Click(object sender, EventArgs e)\n        {\n            if (SaveValidConfiguration())\n            {\n                this.Close();\n            }\n        }
        }\n        private void MoveConfigItem(int step)\n        {\n            int index = ServersListBox.SelectedIndex;\n            Server server = _modifiedConfiguration.configs[index];\n            object item = ServersListBox.Items[index];\n            _modifiedConfiguration.configs.Remove(server);\n            _modifiedConfiguration.configs.Insert(index + step, server);\n            _modifiedConfiguration.index += step;\n            ServersListBox.BeginUpdate();
        }\n        private void ShowPasswdCheckBox_CheckedChanged(object sender, EventArgs e)\n        {\n            this.PasswordTextBox.UseSystemPasswordChar = !this.ShowPasswdCheckBox.Checked;\n        }\n        private void UsePluginArgCheckBox_CheckedChanged(object sender, EventArgs e)\n        {\n            ShowHidePluginArgInput(this.NeedPluginArgCheckBox.Checked);\n        }\n    }
        }\n        private void UsePluginArgCheckBox_CheckedChanged(object sender, EventArgs e)\n        {\n            ShowHidePluginArgInput(this.NeedPluginArgCheckBox.Checked);\n        }\n    }\n}
        }\n    }\n}
namespace Shadowsocks.Model\n{\n    [Serializable]\n    public class Configuration\n    {\n        public string version;\n        public List<Server> configs;\n        // when strategy is set, index is ignored\n        public string strategy;\n        public int index;
        public Server GetCurrentServer()\n        {\n            if (index >= 0 && index < configs.Count)\n                return configs[index];\n            else\n                return GetDefaultServer();\n        }\n        public static void CheckServer(Server server)\n        {
            CheckTimeout(server.timeout, Server.MaxServerTimeoutSec);
        {\n            if (config != null && config.configs != null)\n            {\n                server = (server ?? GetDefaultServer());\n                config.configs.Add(server);\n            }\n            return server;\n        }\n        public static Server GetDefaultServer()
            }\n            return server;\n        }\n        public static Server GetDefaultServer()\n        {\n            return new Server();\n        }\n        private static void Assert(bool condition)\n        {\n            if (!condition)
        private void PACFileWatcher_Changed(object sender, FileSystemEventArgs e)\n        {\n            string path = e.FullPath.ToString();\n            string currentLastWriteTime = File.GetLastWriteTime(e.FullPath).ToString(CultureInfo.InvariantCulture);\n            // if there is no path info stored yet or stored path has different time of write then the one now is inspected\n            if (!fileChangedTime.ContainsKey(path) || fileChangedTime[path].ToString() != currentLastWriteTime)\n            {\n                if (PACFileChanged != null)\n                {\n                    Logging.Info($"Detected: PAC file '{e.Name}' was {e.ChangeType.ToString().ToLower()}.");
                    PACFileChanged(this, new EventArgs());\n                }\n                // lastly we update the last write time in the hashtable\n                fileChangedTime[path] = currentLastWriteTime;\n            }\n        }\n        private void UserRuleFileWatcher_Changed(object sender, FileSystemEventArgs e)\n        {\n            string path = e.FullPath.ToString();
            }\n        }\n        private void UserRuleFileWatcher_Changed(object sender, FileSystemEventArgs e)\n        {\n            string path = e.FullPath.ToString();\n            string currentLastWriteTime = File.GetLastWriteTime(e.FullPath).ToString(CultureInfo.InvariantCulture);\n            // if there is no path info stored yet or stored path has different time of write then the one now is inspected\n            if (!fileChangedTime.ContainsKey(path) || fileChangedTime[path].ToString() != currentLastWriteTime)\n            {\n                if (UserRuleFileChanged != null)
                    UserRuleFileChanged(this, new EventArgs());\n                }\n                // lastly we update the last write time in the hashtable\n                fileChangedTime[path] = currentLastWriteTime;\n            }\n        }\n        #endregion\n        private string GetPACAddress(byte[] requestBuf, int length, IPEndPoint localEndPoint, bool useSocks)\n        {
            }\n        }\n        #endregion\n        private string GetPACAddress(byte[] requestBuf, int length, IPEndPoint localEndPoint, bool useSocks)\n        {\n            //try\n            //{\n            //    string requestString = Encoding.UTF8.GetString(requestBuf);\n            //    if (requestString.IndexOf("AppleWebKit") >= 0)\n            //    {
using NLog;\nusing Microsoft.Win32;\nusing Shadowsocks.Controller;\nusing Shadowsocks.Controller.Hotkeys;\nusing Shadowsocks.Util;\nusing Shadowsocks.View;
using Shadowsocks.Controller;\nusing Shadowsocks.Controller.Hotkeys;\nusing Shadowsocks.Util;\nusing Shadowsocks.View;\nusing System.Linq;
using System.Text;\nusing System.Net;\nusing System.Threading.Tasks;\nusing System.Collections.Generic;\nnamespace Shadowsocks\n{\n    static class Program\n    {\n        private static Logger logger = LogManager.GetCurrentClassLogger();\n        public static ShadowsocksController MainController { get; private set; }
using System.Threading.Tasks;\nusing System.Collections.Generic;\nnamespace Shadowsocks\n{\n    static class Program\n    {\n        private static Logger logger = LogManager.GetCurrentClassLogger();\n        public static ShadowsocksController MainController { get; private set; }\n        public static MenuViewController MenuController { get; private set; }\n        public static string[] Args { get; private set; }
namespace Shadowsocks\n{\n    static class Program\n    {\n        private static Logger logger = LogManager.GetCurrentClassLogger();\n        public static ShadowsocksController MainController { get; private set; }\n        public static MenuViewController MenuController { get; private set; }\n        public static string[] Args { get; private set; }\n        /// <summary>\n        /// 应用程序的主入口点。\n        static void Main(string[] args)
    {\n        private static Logger logger = LogManager.GetCurrentClassLogger();\n        public static ShadowsocksController MainController { get; private set; }\n        public static MenuViewController MenuController { get; private set; }\n        public static string[] Args { get; private set; }\n        /// <summary>\n        /// 应用程序的主入口点。\n        /// </summary>\n        /// </summary>\n        [STAThread]\n        static void Main(string[] args)\n        {\n            Directory.SetCurrentDirectory(Application.StartupPath);\n            // todo: initialize the NLog configuartion
        public static ShadowsocksController MainController { get; private set; }\n        public static MenuViewController MenuController { get; private set; }\n        public static string[] Args { get; private set; }\n        /// <summary>\n        /// 应用程序的主入口点。\n        /// </summary>\n        /// </summary>\n        [STAThread]\n        static void Main(string[] args)\n        {\n            Directory.SetCurrentDirectory(Application.StartupPath);\n            // todo: initialize the NLog configuartion\n            Model.NLogConfig.TouchAndApplyNLogConfig();\n            // .NET Framework 4.7.2 on Win7 compatibility\n            System.Net.ServicePointManager.SecurityProtocol |=\n                System.Net.SecurityProtocolType.Tls | System.Net.SecurityProtocolType.Tls11 | System.Net.SecurityProtocolType.Tls12;
        {\n            Directory.SetCurrentDirectory(Application.StartupPath);\n            // todo: initialize the NLog configuartion\n            Model.NLogConfig.TouchAndApplyNLogConfig();\n            // .NET Framework 4.7.2 on Win7 compatibility\n            System.Net.ServicePointManager.SecurityProtocol |=\n                System.Net.SecurityProtocolType.Tls | System.Net.SecurityProtocolType.Tls11 | System.Net.SecurityProtocolType.Tls12;\n            // store args for further use\n            Args = args;\n            // Check OS since we are using dual-mode socket\n            if (!Utils.IsWinVistaOrHigher())\n            {
            // store args for further use\n            Args = args;\n            // Check OS since we are using dual-mode socket\n            if (!Utils.IsWinVistaOrHigher())\n            {\n                MessageBox.Show(I18N.GetString("Unsupported operating system, use Windows Vista at least."),\n                "Shadowsocks Error", MessageBoxButtons.OK, MessageBoxIcon.Error);\n                return;\n            }\n            // Check .NET Framework version
                int urlidx = alist.IndexOf("--open-url") + 1;\n                if (urlidx > 0)\n                {\n                    if (Args.Length <= urlidx) return;\n                    if (!pipeExist) return;\n                    byte[] b = Encoding.UTF8.GetBytes(Args[urlidx]);\n                    byte[] opAddUrl = BitConverter.GetBytes(IPAddress.HostToNetworkOrder(1));\n                    byte[] blen = BitConverter.GetBytes(IPAddress.HostToNetworkOrder(b.Length));\n                    pipe.Write(opAddUrl, 0, 4); // opcode addurl\n                    pipe.Write(blen, 0, 4);
                else if (pipeExist)\n                {\n                    Process[] oldProcesses = Process.GetProcessesByName("Shadowsocks");\n                    if (oldProcesses.Length > 0)\n                    {\n                        Process oldProcess = oldProcesses[0];\n                    }\n                    MessageBox.Show(I18N.GetString("Find Shadowsocks icon in your notify tray.")\n                        + Environment.NewLine\n                        + I18N.GetString("If you want to start multiple Shadowsocks, make a copy in another directory."),
    {\n        public Rectangle TargetRect;\n        public QRCodeSplashForm()\n        {
        public event EventHandler ConfigChanged;\n        public event EventHandler EnableStatusChanged;\n        public event EventHandler<ErrorEventArgs> LocalFailToStart;\n        // when user clicked Edit PAC, and PAC file has already created\n        public event EventHandler<PathEventArgs> PACFileReadyToOpen;\n        public ShadowsocksController()\n        {\n            config = Configuration.Load();\n            polipoRunner = new PolipoRunner();\n            polipoRunner.Start(config.GetCurrentServer());
        // when user clicked Edit PAC, and PAC file has already created\n        public event EventHandler<PathEventArgs> PACFileReadyToOpen;\n        public ShadowsocksController()\n        {\n            config = Configuration.Load();\n            polipoRunner = new PolipoRunner();\n            polipoRunner.Start(config.GetCurrentServer());\n            local = new Local(config.GetCurrentServer());\n            try\n            {
            enableItem.Checked = controller.GetConfiguration().enabled;\n        }\n        private void Form1_Load(object sender, EventArgs e)\n        {\n            if (!controller.GetConfiguration().isDefault)\n            {\n                this.Opacity = 0;\n                BeginInvoke(new MethodInvoker(delegate\n                {\n                    this.Hide();
        {\n            if (!controller.GetConfiguration().isDefault)\n            {\n                this.Opacity = 0;\n                BeginInvoke(new MethodInvoker(delegate\n                {\n                    this.Hide();\n                }));\n            }\n        }
        {\n            controller.Stop();\n        }\n        private void aboutToolStripMenuItem_Click(object sender, EventArgs e)\n        {\n            Process.Start("https://github.com/clowwindy/shadowsocks-csharp");\n        }\n        private void notifyIcon1_DoubleClick(object sender, EventArgs e)\n        {\n            showWindow();
            this.label3 = new System.Windows.Forms.Label();\n            this.label4 = new System.Windows.Forms.Label();\n            this.textBox1 = new System.Windows.Forms.TextBox();\n            this.textBox2 = new System.Windows.Forms.TextBox();\n            this.textBox3 = new System.Windows.Forms.TextBox();\n            this.textBox4 = new System.Windows.Forms.TextBox();\n            this.notifyIcon1 = new System.Windows.Forms.NotifyIcon(this.components);\n            this.panel2 = new System.Windows.Forms.Panel();\n            this.button1 = new System.Windows.Forms.Button();\n            this.button2 = new System.Windows.Forms.Button();
            this.notifyIcon1 = new System.Windows.Forms.NotifyIcon(this.components);\n            this.panel2 = new System.Windows.Forms.Panel();\n            this.button1 = new System.Windows.Forms.Button();\n            this.button2 = new System.Windows.Forms.Button();\n            this.panel1 = new System.Windows.Forms.Panel();\n            this.contextMenu1 = new System.Windows.Forms.ContextMenu();\n            this.enableItem = new System.Windows.Forms.MenuItem();\n            this.configItem = new System.Windows.Forms.MenuItem();\n            this.aboutItem = new System.Windows.Forms.MenuItem();
            this.panel1 = new System.Windows.Forms.Panel();\n            this.contextMenu1 = new System.Windows.Forms.ContextMenu();\n            this.enableItem = new System.Windows.Forms.MenuItem();\n            this.configItem = new System.Windows.Forms.MenuItem();\n            this.aboutItem = new System.Windows.Forms.MenuItem();\n            this.menuItem3 = new System.Windows.Forms.MenuItem();\n            this.quitItem = new System.Windows.Forms.MenuItem();\n            this.editPACFileItem = new System.Windows.Forms.MenuItem();
            this.tableLayoutPanel1.SuspendLayout();\n            this.panel1.SuspendLayout();\n            this.SuspendLayout();\n            // \n            // tableLayoutPanel1\n            // \n            this.tableLayoutPanel1.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) \n            | System.Windows.Forms.AnchorStyles.Right)));
            this.tableLayoutPanel1.Controls.Add(this.label3, 0, 2);\n            this.tableLayoutPanel1.Controls.Add(this.label4, 0, 3);\n            this.tableLayoutPanel1.Controls.Add(this.textBox1, 1, 0);\n            this.tableLayoutPanel1.Controls.Add(this.textBox2, 1, 1);\n            this.tableLayoutPanel1.Controls.Add(this.textBox3, 1, 2);\n            this.tableLayoutPanel1.Controls.Add(this.textBox4, 1, 3);\n            this.tableLayoutPanel1.Location = new System.Drawing.Point(19, 19);\n            this.tableLayoutPanel1.Margin = new System.Windows.Forms.Padding(10);\n            this.tableLayoutPanel1.Name = "tableLayoutPanel1";\n            this.tableLayoutPanel1.Padding = new System.Windows.Forms.Padding(5);
            this.tableLayoutPanel1.Margin = new System.Windows.Forms.Padding(10);\n            this.tableLayoutPanel1.Name = "tableLayoutPanel1";\n            this.tableLayoutPanel1.Padding = new System.Windows.Forms.Padding(5);\n            this.tableLayoutPanel1.RowCount = 5;\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());
            "table",\n            "rc4-md5",\n            "aes-256-cfb",\n            "aes-192-cfb",\n            "aes-128-cfb",\n            "bf-cfb",\n            "rc4"});\n            this.comboBox1.Location = new System.Drawing.Point(74, 112);\n            this.comboBox1.Name = "comboBox1";\n            this.comboBox1.Size = new System.Drawing.Size(124, 21);
            // \n            // panel1\n            // \n            this.panel1.Anchor = System.Windows.Forms.AnchorStyles.Top;\n            this.panel1.AutoSize = true;\n            this.panel1.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;\n            this.panel1.Controls.Add(this.button2);\n            this.panel1.Controls.Add(this.button1);\n            this.panel1.Location = new System.Drawing.Point(61, 173);\n            this.panel1.Name = "panel1";
            this.panel1.AutoSize = true;\n            this.panel1.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;\n            this.panel1.Controls.Add(this.button2);\n            this.panel1.Controls.Add(this.button1);\n            this.panel1.Location = new System.Drawing.Point(61, 173);\n            this.panel1.Name = "panel1";
            this.panel1.Name = "panel1";
            // \n            // menuItem3\n            // \n            this.menuItem3.Index = 4;\n            this.menuItem3.Text = "-";\n            // \n            // quitItem\n            // \n            this.quitItem.Index = 5;\n            this.quitItem.Text = "Quit";
            this.Controls.Add(this.panel2);\n            this.Controls.Add(this.tableLayoutPanel1);\n            this.Controls.Add(this.panel1);\n            this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));\n            this.Name = "ConfigForm";\n            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;\n            this.Text = "Shadowsocks";\n            this.FormClosed += new System.Windows.Forms.FormClosedEventHandler(this.Form1_FormClosed);
            this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));\n            this.Name = "ConfigForm";\n            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;\n            this.Text = "Shadowsocks";\n            this.FormClosed += new System.Windows.Forms.FormClosedEventHandler(this.Form1_FormClosed);\n            this.Load += new System.EventHandler(this.Form1_Load);\n            this.tableLayoutPanel1.ResumeLayout(false);\n            this.tableLayoutPanel1.PerformLayout();\n            this.panel1.ResumeLayout(false);
            this.tableLayoutPanel1.ResumeLayout(false);\n            this.tableLayoutPanel1.PerformLayout();\n            this.panel1.ResumeLayout(false);\n            this.ResumeLayout(false);\n            this.PerformLayout();\n        }
        private System.Windows.Forms.NotifyIcon notifyIcon1;\n        private System.Windows.Forms.Label label5;\n        private System.Windows.Forms.ComboBox comboBox1;\n        private System.Windows.Forms.Panel panel2;\n        private System.Windows.Forms.Button button1;\n        private System.Windows.Forms.Button button2;\n        private System.Windows.Forms.Panel panel1;\n        private System.Windows.Forms.ContextMenu contextMenu1;\n        private System.Windows.Forms.MenuItem enableItem;\n        private System.Windows.Forms.MenuItem aboutItem;
        private System.Windows.Forms.Panel panel2;\n        private System.Windows.Forms.Button button1;\n        private System.Windows.Forms.Button button2;\n        private System.Windows.Forms.Panel panel1;\n        private System.Windows.Forms.ContextMenu contextMenu1;\n        private System.Windows.Forms.MenuItem enableItem;\n        private System.Windows.Forms.MenuItem aboutItem;\n        private System.Windows.Forms.MenuItem menuItem3;\n        private System.Windows.Forms.MenuItem quitItem;\n        private System.Windows.Forms.MenuItem configItem;
        private System.Windows.Forms.Panel panel1;\n        private System.Windows.Forms.ContextMenu contextMenu1;\n        private System.Windows.Forms.MenuItem enableItem;\n        private System.Windows.Forms.MenuItem aboutItem;\n        private System.Windows.Forms.MenuItem menuItem3;\n        private System.Windows.Forms.MenuItem quitItem;\n        private System.Windows.Forms.MenuItem configItem;\n        private System.Windows.Forms.MenuItem editPACFileItem;
using System.Net;\nusing System.IO;\nusing System.IO.Compression;\nusing System.Security.Cryptography;\nusing System.Text.RegularExpressions;\nusing Shadowsocks.Model;\nusing Shadowsocks.Properties;\nnamespace Shadowsocks.Controller\n{\n    public class GfwListUpdater
namespace Shadowsocks.Controller\n{\n    public class GfwListUpdater\n    {\n        private const string GFWLIST_URL = "https://autoproxy-gfwlist.googlecode.com/svn/trunk/gfwlist.txt";\n        public IWebProxy proxy = null;\n        public class GfwListDownloadCompletedArgs : EventArgs\n        {\n            public string Content;\n        }
using System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.IO.Compression;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Text;\nusing System.Text.RegularExpressions;\nnamespace Shadowsocks.Controller\n{
namespace Shadowsocks.Controller\n{\n    class PACServer\n    {\n        private static int PORT = 8093;\n        private static string PAC_FILE = "pac.txt";\n        private static Configuration config;\n        Socket _listener;\n        FileSystemWatcher watcher;\n        public event EventHandler PACFileChanged;
            flashStep = 0;\n            x = 0;\n            y = 0;\n            w = Width;\n            h = Height;\n            timer = new Timer();\n            timer.Interval = (int)(ANIMATION_TIME * 1000 / ANIMATION_STEPS);\n            timer.Tick += timer_Tick;\n            timer.Start();
                if (flashStep == 0)\n                {\n                    g.Clear(Color.Transparent);\n                    SetBitmap(bitmap);\n                }\n                else if (flashStep == 1)\n                {\n                    g.FillRectangle(brush, x, y, w, h);
                        registry.SetValue("AutoConfigURL", pacUrl);\n                    }\n                }\n                else\n                {\n                    registry.SetValue("ProxyEnable", 0);\n                    if (global)\n                    {\n                        registry.SetValue("ProxyServer", "");\n                    }
                    registry.SetValue("AutoConfigURL", "");\n                }\n                //Set AutoDetectProxy Off\n                IEAutoDetectProxy(false);\n                SystemProxy.NotifyIE();\n                //Must Notify IE first, or the connections do not chanage\n                CopyProxySettingFromLan();\n            }\n            catch (Exception e)\n            {
                string beforeAt = data.Substring(0, indexLastAt);\n                string[] parts = beforeAt.Split(new[] { ':' });\n                this.method = parts[0];\n                this.password = parts[1];\n                //TODO: read one_time_auth\n            }\n            catch (IndexOutOfRangeException)\n            {\n                throw new FormatException();\n            }
                //TODO: read one_time_auth\n            }\n            catch (IndexOutOfRangeException)\n            {\n                throw new FormatException();\n            }\n        }\n    }\n}
                return configs[index];\n            }\n            else\n            {\n                return GetDefaultServer();\n            }\n        }\n        public static void CheckServer(Server server)\n        {\n            CheckPort(server.server_port);
            else\n            {\n                return GetDefaultServer();\n            }\n        }\n        public static void CheckServer(Server server)\n        {\n            CheckPort(server.server_port);\n            CheckPassword(server.password);\n            CheckServer(server.server);
                return GetDefaultServer();\n            }\n        }\n        public static void CheckServer(Server server)\n        {\n            CheckPort(server.server_port);\n            CheckPassword(server.password);\n            CheckServer(server.server);\n        }\n        public static Configuration Load()
        }\n        public static void CheckServer(Server server)\n        {\n            CheckPort(server.server_port);\n            CheckPassword(server.password);\n            CheckServer(server.server);\n        }\n        public static Configuration Load()\n        {\n            try
                    config.localPort = 1080;\n                }\n                if (config.index == -1)\n                {\n                    if (config.strategy == null)\n                    {\n                        config.index = 0;\n                    }\n                }\n                return config;
                return config;\n            }\n            catch (Exception e)\n            {\n                if (!(e is FileNotFoundException))\n                {\n                    Logging.LogUsefulException(e);\n                }\n                return new Configuration\n                {
                    Logging.LogUsefulException(e);\n                }\n                return new Configuration\n                {\n                    index = 0,\n                    isDefault = true,\n                    localPort = 1080,\n                    autoCheckUpdate = true,\n                    configs = new List<Server>()\n                    {
                return new Configuration\n                {\n                    index = 0,\n                    isDefault = true,\n                    localPort = 1080,\n                    autoCheckUpdate = true,\n                    configs = new List<Server>()\n                    {\n                        GetDefaultServer()\n                    }
                config.index = config.configs.Count - 1;\n            }\n            if (config.index < -1)\n            {\n                config.index = -1;\n            }\n            if (config.index == -1)\n            {\n                if (config.strategy == null)\n                {
            if (config.index < -1)\n            {\n                config.index = -1;\n            }\n            if (config.index == -1)\n            {\n                if (config.strategy == null)\n                {\n                    config.index = 0;\n                }
                config.index = -1;\n            }\n            if (config.index == -1)\n            {\n                if (config.strategy == null)\n                {\n                    config.index = 0;\n                }\n            }\n            config.isDefault = false;
            config.isDefault = false;\n            try\n            {\n                using (StreamWriter sw = new StreamWriter(File.Open(CONFIG_FILE, FileMode.Create)))\n                {\n                    string jsonString = JsonConvert.SerializeObject(config, Formatting.Indented);\n                    sw.Write(jsonString);\n                    sw.Flush();\n                }\n            }
                throw new Exception(I18N.GetString("assertion failure"));\n            }\n        }\n        public static void CheckPort(int port)\n        {\n            if (port <= 0 || port > 65535)\n            {\n                throw new ArgumentException(I18N.GetString("Port out of range"));\n            }\n        }
        }\n        public static void CheckPort(int port)\n        {\n            if (port <= 0 || port > 65535)\n            {\n                throw new ArgumentException(I18N.GetString("Port out of range"));\n            }\n        }\n        public static void CheckLocalPort(int port)\n        {
                throw new ArgumentException(I18N.GetString("Port out of range"));\n            }\n        }\n        public static void CheckLocalPort(int port)\n        {\n            CheckPort(port);\n            if (port == 8123)\n            {\n                throw new ArgumentException(I18N.GetString("Port can't be 8123"));\n            }
        }\n        public static void CheckLocalPort(int port)\n        {\n            CheckPort(port);\n            if (port == 8123)\n            {\n                throw new ArgumentException(I18N.GetString("Port can't be 8123"));\n            }\n        }\n        private static void CheckPassword(string password)
                throw new ArgumentException(I18N.GetString("Port can't be 8123"));\n            }\n        }\n        private static void CheckPassword(string password)\n        {\n            if (string.IsNullOrEmpty(password))\n            {\n                throw new ArgumentException(I18N.GetString("Password can not be blank"));\n            }\n        }
        }\n        private static void CheckPassword(string password)\n        {\n            if (string.IsNullOrEmpty(password))\n            {\n                throw new ArgumentException(I18N.GetString("Password can not be blank"));\n            }\n        }\n        private static void CheckServer(string server)\n        {
                throw new ArgumentException(I18N.GetString("Password can not be blank"));\n            }\n        }\n        private static void CheckServer(string server)\n        {\n            if (string.IsNullOrEmpty(server))\n            {\n                throw new ArgumentException(I18N.GetString("Server IP can not be blank"));\n            }\n        }
        }\n        private static void CheckServer(string server)\n        {\n            if (string.IsNullOrEmpty(server))\n            {\n                throw new ArgumentException(I18N.GetString("Server IP can not be blank"));\n            }\n        }\n    }\n}
                throw new ArgumentException(I18N.GetString("Server IP can not be blank"));\n            }\n        }\n    }\n}
        }\n    }\n}
using System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing Shadowsocks.Controller;\nusing Shadowsocks.Properties;\nnamespace Shadowsocks.Util.SystemProxy\n{\n    public static class Sysproxy
using System.Text;\nusing System.Threading.Tasks;\nusing Shadowsocks.Controller;\nusing Shadowsocks.Properties;\nnamespace Shadowsocks.Util.SystemProxy\n{\n    public static class Sysproxy\n    {
using Shadowsocks.Controller;\nusing Shadowsocks.Properties;\nnamespace Shadowsocks.Util.SystemProxy\n{\n    public static class Sysproxy\n    {\n        enum RET_ERRORS : int\n        {
            }\n            else\n            {\n                arguments = "off";
            }\n            using (var process = new Process())\n            {\n                // Configure the process using the StartInfo properties.\n                process.StartInfo.FileName = Utils.GetTempPath("sysproxy.exe");\n                process.StartInfo.Arguments = arguments;
                process.WaitForExit();\n                var exitCode = process.ExitCode;\n                    throw new ProxyException(error);\n                }
                }
                    }\n                }\n                else\n                {\n                    Sysproxy.SetIEProxy(false, false, "", "");\n                }\n            }\n            catch (ProxyException ex)\n            {\n                Logging.LogUsefulException(ex);
                }\n            }\n            catch (ProxyException ex)\n            {\n                Logging.LogUsefulException(ex);\n            }\n        }\n    }\n}
                            {\n                                useSocks = true;\n                            }\n                        }\n                    }\n                    else if (kv.Length == 1)\n                    {\n                        if (line.IndexOf("pac") >= 0)\n                        {\n                            pathMatch = true;
                        }\n                    }\n                    else if (kv.Length == 1)\n                    {\n                        if (line.IndexOf("pac") >= 0)\n                        {\n                            pathMatch = true;\n                        }\n                    }\n                }
                _systemProxyIsDirty = true;\n            }\n            else\n            {\n                // only switch it off if we have switched it on\n                if (_systemProxyIsDirty)\n                {\n                    SystemProxy.Disable();\n                    _systemProxyIsDirty = false;\n                }\n            }
                    _systemProxyIsDirty = false;\n                }\n            }\n        }\n        private void pacServer_PACFileChanged(object sender, EventArgs e)\n        {\n            UpdateSystemProxy();\n        }\n        private void pacServer_PACUpdateCompleted(object sender, EventArgs e)\n        {
        {\n            try\n            {\n                RegistryKey registry =
                {\n                    registry.SetValue("ProxyEnable", 1);\n                    registry.SetValue("ProxyServer", "127.0.0.1:8123");\n                    registry.SetValue("AutoConfigURL", "");
                }\n                else\n                {\n                    registry.SetValue("ProxyEnable", 0);\n                    registry.SetValue("ProxyServer", "");\n                    registry.SetValue("AutoConfigURL", "http://127.0.0.1:8093/pac?t=" + GetTimestamp(DateTime.Now));\n                }\n                SystemProxy.NotifyIE();\n                //Must Notify IE first, or the connections do not chanage\n                CopyProxySettingFromLan();\n            }
                }\n                SystemProxy.NotifyIE();\n                //Must Notify IE first, or the connections do not chanage\n                CopyProxySettingFromLan();\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                // TODO this should be moved into views\n                MessageBox.Show(I18N.GetString("Failed to update registry"));\n            }
                CopyProxySettingFromLan();\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                // TODO this should be moved into views\n                MessageBox.Show(I18N.GetString("Failed to update registry"));\n            }\n        }\n        private static void CopyProxySettingFromLan()
                }\n                if (changed)\n                {\n                    textBox1.ScrollToCaret();\n                }\n                lastOffset = reader.BaseStream.Position;\n            }\n        }\n        private void LogForm_Load(object sender, EventArgs e)\n        {
                }\n                lastOffset = reader.BaseStream.Position;\n            }\n        }\n        private void LogForm_Load(object sender, EventArgs e)\n        {\n            InitContent();\n            timer = new Timer();\n            timer.Interval = 300;\n            timer.Tick += Timer_Tick;
        {\n            string argument = @"/select, " + filename;\n            System.Diagnostics.Process.Start("explorer.exe", argument);\n        }\n        private void menuItem3_Click(object sender, EventArgs e)\n        {\n        }\n        private void menuItem4_Click(object sender, EventArgs e)\n        {
        {\n            this.Close();\n        }\n        private void LogForm_Shown(object sender, EventArgs e)\n        {\n            textBox1.ScrollToCaret();
        }\n    }\n}
            this.contextMenuStrip1 = new System.Windows.Forms.ContextMenuStrip(this.components);\n            this.mainMenu1 = new System.Windows.Forms.MainMenu(this.components);\n            this.menuItem1 = new System.Windows.Forms.MenuItem();\n            this.menuItem2 = new System.Windows.Forms.MenuItem();\n            this.menuItem4 = new System.Windows.Forms.MenuItem();
            this.SuspendLayout();\n            // \n            this.menuItem1});\n            // \n            this.menuItem1.Index = 0;\n            this.menuItem1.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {\n            this.menuItem2,
            // \n            this.menuItem1.Index = 0;\n            this.menuItem1.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {\n            this.menuItem2,\n            this.menuItem4});\n            this.menuItem1.Text = "&File";\n            // \n            this.menuItem2.Index = 0;\n            this.menuItem2.Text = "&Open Location";\n            this.menuItem2.Click += new System.EventHandler(this.menuItem2_Click);\n            // 
            // \n            this.menuItem2.Index = 0;\n            this.menuItem2.Text = "&Open Location";\n            this.menuItem2.Click += new System.EventHandler(this.menuItem2_Click);\n            // \n            this.ClientSize = new System.Drawing.Size(547, 382);\n            this.Controls.Add(this.textBox1);\n            this.Menu = this.mainMenu1;
            // \n            this.ClientSize = new System.Drawing.Size(547, 382);\n            this.Controls.Add(this.textBox1);\n            this.Menu = this.mainMenu1;\n            this.Name = "LogForm";\n            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;\n            this.Text = "Log Viewer";
            this.Menu = this.mainMenu1;\n            this.Name = "LogForm";\n            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;\n            this.Text = "Log Viewer";\n            this.FormClosing += new System.Windows.Forms.FormClosingEventHandler(this.LogForm_FormClosing);\n            this.Load += new System.EventHandler(this.LogForm_Load);\n            this.Shown += new System.EventHandler(this.LogForm_Shown);
        }\n        #endregion\n        private System.Windows.Forms.TextBox textBox1;\n        private System.Windows.Forms.ContextMenuStrip contextMenuStrip1;\n        private System.Windows.Forms.MainMenu mainMenu1;\n        private System.Windows.Forms.MenuItem menuItem1;\n        private System.Windows.Forms.MenuItem menuItem2;\n        private System.Windows.Forms.MenuItem menuItem4;
        private System.Windows.Forms.ContextMenuStrip contextMenuStrip1;\n        private System.Windows.Forms.MainMenu mainMenu1;\n        private System.Windows.Forms.MenuItem menuItem1;\n        private System.Windows.Forms.MenuItem menuItem2;\n        private System.Windows.Forms.MenuItem menuItem4;
    }\n}
            }\n        }\n        private static void CheckPort(int port)\n        {\n            if (port <= 0 || port > 65535)\n            {\n                throw new ArgumentException("port out of range");\n            }\n        }\n        private static void CheckPassword(string password)
            }\n        }\n        private static void CheckPassword(string password)\n        {\n            if (string.IsNullOrEmpty(password))\n            {\n                throw new ArgumentException("password can not be blank");\n            }\n        }\n        private static void CheckServer(string server)
            }\n        }\n        private static void CheckServer(string server)\n        {\n            if (string.IsNullOrEmpty(server))\n            {\n                throw new ArgumentException("server IP can not be blank");\n            }\n        }\n        private static void CheckRemark(string remark)
            }\n        }\n        private static void CheckRemark(string remark)\n        {\n            //remark is optional\n        }\n        private class JsonSerializerStrategy : SimpleJson.PocoJsonSerializerStrategy\n        {\n            // convert string to int\n            public override object DeserializeObject(object value, Type type)
        public event ErrorEventHandler Error;\n        private void http_DownloadStringCompleted(object sender, DownloadStringCompletedEventArgs e)
                }\n            }\n            catch (Exception ex)\n            {\n                if (Error != null)\n                {\n                    Error(this, new ErrorEventArgs(ex));\n                }\n            }\n        }
                StreamWriterWithTimestamp sw = new StreamWriterWithTimestamp(fs);\n                sw.AutoFlush = true;\n                Console.SetOut(sw);\n                Console.SetError(sw);\n                return true;\n            }\n            catch (IOException e)\n            {\n                Console.WriteLine(e.ToString());\n                return false;
        }\n        private void ReceiveCallback(IAsyncResult ar)\n        {\n            int length = (int)ar.AsyncState;\n            try\n            {\n                var bytesRead = _socket.EndReceive(ar);\n                if (bytesRead == 0)\n                {\n                    OnFinish(length);
            try\n            {\n                var bytesRead = _socket.EndReceive(ar);\n                if (bytesRead == 0)\n                {\n                    OnFinish(length);\n                    return;\n                }\n                length += bytesRead;\n                int i;
                    return;\n                }\n                length += bytesRead;\n                int i;\n                while ((i = IndexOf(_lineBuffer, _bufferIndex, length, _delimiterBytes, _delimiterSearchOffsetTable,\n                           _delimiterSearchCharTable)) != -1)\n                {\n                    var decodeLen = i - _bufferIndex;\n                    string line = _encoding.GetString(_lineBuffer, _bufferIndex, decodeLen);\n                    _bufferIndex = i + _delimiterBytes.Length;
                    return;\n                }\n                if (_bufferIndex > 0)\n                {\n                    Buffer.BlockCopy(_lineBuffer, _bufferIndex, _lineBuffer, 0, length);\n                    _bufferIndex = 0;\n                }\n                _socket.BeginReceive(_lineBuffer, length, _lineBuffer.Length - length, 0, ReceiveCallback, length);\n            }\n            catch (Exception ex)
        }\n        private void OnException(Exception ex)\n        {\n            _onException?.Invoke(ex, _state);\n        }\n        private void OnFinish(int length)\n        {\n            _onFinish?.Invoke(_lineBuffer, _bufferIndex, length, _state);\n        }\n        #region Boyer-Moore string search\n        public static int IndexOf(byte[] haystack, int index, int length, byte[] needle, int[] offsetTable, int[] charTable)
        }\n        #region Boyer-Moore string search\n        public static int IndexOf(byte[] haystack, int index, int length, byte[] needle, int[] offsetTable, int[] charTable)\n        {\n            var end = index + length;\n            for (int i = needle.Length - 1 + index, j; i < end;)\n            {\n                for (j = needle.Length - 1; needle[j] == haystack[i]; --i, --j)\n                {\n                    if (j == 0)\n                    {
        {\n            var end = index + length;\n            for (int i = needle.Length - 1 + index, j; i < end;)\n            {\n                for (j = needle.Length - 1; needle[j] == haystack[i]; --i, --j)\n                {\n                    if (j == 0)\n                    {\n                        return i;\n                    }
using System.Runtime.InteropServices;\nusing System.Text;\nusing System.IO;\nusing Shadowsocks.Model;\nnamespace Shadowsocks.Controller\n{\n    public static class SystemProxy\n    {\n        [DllImport("wininet.dll")]
using System.IO;\nusing Shadowsocks.Model;\nnamespace Shadowsocks.Controller\n{\n    public static class SystemProxy\n    {\n        [DllImport("wininet.dll")]\n        public static extern bool InternetSetOption(IntPtr hInternet, int dwOption, IntPtr lpBuffer, int dwBufferLength);\n        public const int INTERNET_OPTION_SETTINGS_CHANGED = 39;
            }\n        }\n        private static void CopyProxySettingFromLan()\n        {\n            var registry = Registry.CurrentUser\n                .OpenSubKey(@"Software\Microsoft\Windows\CurrentVersion\Internet Settings\Connections", true);\n            var defaultValue = registry.GetValue("DefaultConnectionSettings");\n            try\n            {
                var connections = registry.GetValueNames();\n                foreach (var each in connections)\n                {\n                    switch (each.ToUpperInvariant())\n                    {\n                        case "DEFAULTCONNECTIONSETTINGS":\n                        case "LAN CONNECTION":\n                        case "SAVEDLEGACYSETTINGS":
            }\n        }\n        /// <summary>\n        /// Checks or unchecks the IE Options Connection setting of "Automatically detect Proxy"\n        /// </summary>\n        /// <param name="set">Provide 'true' if you want to check the 'Automatically detect Proxy' check box. To uncheck, pass 'false'</param>\n        private static void IEAutoDetectProxy(bool set)\n        {\n            var registry = Registry.CurrentUser\n                .OpenSubKey(@"Software\Microsoft\Windows\CurrentVersion\Internet Settings\Connections", true);\n            var defConnection = (byte[])registry.GetValue("DefaultConnectionSettings");\n            var savedLegacySetting = (byte[])registry.GetValue("SavedLegacySettings");\n            const int versionOffset = 4;\n            const int optionsOffset = 8;
            }\n            else\n            {\n                defConnection[optionsOffset] = (byte)(defConnection[optionsOffset] & ~8);\n                savedLegacySetting[optionsOffset] = (byte)(savedLegacySetting[optionsOffset] & ~8);\n            }\n            BitConverter.GetBytes(\n                unchecked(BitConverter.ToUInt32(defConnection, versionOffset) + 1))\n                .CopyTo(defConnection, versionOffset);\n            BitConverter.GetBytes(
        }\n    }\n}
            {\n                Application.SetUnhandledExceptionMode(UnhandledExceptionMode.CatchException);\n                // handle UI exceptions\n                Application.ThreadException += Application_ThreadException;\n                // handle non-UI exceptions\n                AppDomain.CurrentDomain.UnhandledException += CurrentDomain_UnhandledException;\n                Application.ApplicationExit += Application_ApplicationExit;\n                SystemEvents.PowerModeChanged += SystemEvents_PowerModeChanged;\n                Application.EnableVisualStyles();\n                Application.SetCompatibleTextRenderingDefault(false);
                {\n                    Process[] oldProcesses = Process.GetProcessesByName("Shadowsocks");\n                    if (oldProcesses.Length > 0)\n                    {\n                        Process oldProcess = oldProcesses[0];\n                    }\n                    MessageBox.Show(I18N.GetString("Find Shadowsocks icon in your notify tray.")\n                        + Environment.NewLine\n                        + I18N.GetString("If you want to start multiple Shadowsocks, make a copy in another directory."),\n                        I18N.GetString("Shadowsocks is already running."));
#if DEBUG\n                MainController = new ShadowsocksController();\n                MenuController = new MenuViewController(MainController);\n                HotKeys.Init(MainController);\n                MainController.Start();\n                Application.Run();\n            }\n        }
        }\n        private static int exited = 0;\n        private static void CurrentDomain_UnhandledException(object sender, UnhandledExceptionEventArgs e)\n        {\n            if (Interlocked.Increment(ref exited) == 1)\n            {\n                string errMsg = e.ExceptionObject.ToString();\n                logger.Error(errMsg);\n                MessageBox.Show(\n                    $"{I18N.GetString("Unexpected error, shadowsocks will exit. Please report to")} https://github.com/shadowsocks/shadowsocks-windows/issues {Environment.NewLine}{errMsg}",
            StatisticsChart.DataSource = _dataTable;\n            LoadChartData();\n            StatisticsChart.DataBind();\n        }\n        private void CancelButton_Click(object sender, EventArgs e)\n        {\n            Close();\n        }\n        private void OKButton_Click(object sender, EventArgs e)\n        {
            foreach (var data in finalData)\n            {\n                _dataTable.Rows.Add(data.Timestamp, data.PackageLoss, data.Ping);\n            }\n            StatisticsChart.DataBind();\n        }\n        private void serverSelector_SelectedIndexChanged(object sender, EventArgs e)\n        {\n            LoadChartData();\n        }
            }\n            StatisticsChart.DataBind();\n        }\n        private void serverSelector_SelectedIndexChanged(object sender, EventArgs e)\n        {\n            LoadChartData();\n        }\n        private void chartModeSelector_Enter(object sender, EventArgs e)\n        {\n        }
        {\n            LoadChartData();\n        }\n        private void chartModeSelector_Enter(object sender, EventArgs e)\n        {\n        }\n        private void dayMode_CheckedChanged(object sender, EventArgs e)\n        {\n            LoadChartData();\n        }
        }\n        private void dayMode_CheckedChanged(object sender, EventArgs e)\n        {\n            LoadChartData();\n        }\n        private void allMode_CheckedChanged(object sender, EventArgs e)\n        {\n            LoadChartData();\n        }\n        private void PingCheckBox_CheckedChanged(object sender, EventArgs e)
            this.chartModeSelector.SuspendLayout();\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer1)).BeginInit();\n            this.splitContainer1.Panel1.SuspendLayout();\n            this.splitContainer1.Panel2.SuspendLayout();\n            this.splitContainer1.SuspendLayout();\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer2)).BeginInit();\n            this.splitContainer2.Panel1.SuspendLayout();\n            this.splitContainer2.Panel2.SuspendLayout();\n            this.splitContainer2.SuspendLayout();\n            ((System.ComponentModel.ISupportInitialize)(this.dataCollectionMinutesNum)).BeginInit();
            series1.Legend = "ChartLegend";\n            series1.Name = "Package Loss";\n            series1.XValueType = System.Windows.Forms.DataVisualization.Charting.ChartValueType.DateTime;\n            series1.YValuesPerPoint = 2;\n            series2.BorderWidth = 4;\n            series2.ChartArea = "DataArea";\n            series2.ChartType = System.Windows.Forms.DataVisualization.Charting.SeriesChartType.Line;\n            series2.Color = System.Drawing.Color.FromArgb(((int)(((byte)(155)))), ((int)(((byte)(77)))), ((int)(((byte)(150)))));
            series2.ChartArea = "DataArea";\n            series2.ChartType = System.Windows.Forms.DataVisualization.Charting.SeriesChartType.Line;\n            series2.Color = System.Drawing.Color.FromArgb(((int)(((byte)(155)))), ((int)(((byte)(77)))), ((int)(((byte)(150)))));\n            series2.Legend = "ChartLegend";\n            series2.Name = "Ping";\n            series2.XValueType = System.Windows.Forms.DataVisualization.Charting.ChartValueType.DateTime;
            series2.Legend = "ChartLegend";\n            series2.Name = "Ping";\n            series2.XValueType = System.Windows.Forms.DataVisualization.Charting.ChartValueType.DateTime;\n            series3.ChartArea = "DataArea";\n            series3.ChartType = System.Windows.Forms.DataVisualization.Charting.SeriesChartType.Area;
            series3.ChartArea = "DataArea";\n            series3.ChartType = System.Windows.Forms.DataVisualization.Charting.SeriesChartType.Area;\n            series3.Legend = "ChartLegend";\n            series3.Name = "Speed";\n            this.StatisticsChart.Series.Add(series1);
            series3.Legend = "ChartLegend";\n            series3.Name = "Speed";\n            this.StatisticsChart.Series.Add(series1);\n            this.StatisticsChart.Series.Add(series2);\n            this.StatisticsChart.Series.Add(series3);
            this.StatisticsChart.Series.Add(series1);\n            this.StatisticsChart.Series.Add(series2);\n            this.StatisticsChart.Series.Add(series3);\n            this.StatisticsChart.Click += new System.EventHandler(this.StatisticsChart_Click);\n            // \n            // PingCheckBox\n            // \n            this.PingCheckBox.AutoSize = true;
            // \n            // PingCheckBox\n            // \n            this.PingCheckBox.AutoSize = true;\n            this.PingCheckBox.DataBindings.Add(new System.Windows.Forms.Binding("Checked", this.bindingConfiguration, "Ping", true));\n            this.PingCheckBox.Location = new System.Drawing.Point(13, 54);\n            this.PingCheckBox.Margin = new System.Windows.Forms.Padding(5, 10, 5, 10);\n            this.PingCheckBox.Name = "PingCheckBox";
            this.chartModeSelector.ResumeLayout(false);\n            this.chartModeSelector.PerformLayout();\n            this.splitContainer1.Panel1.ResumeLayout(false);\n            this.splitContainer1.Panel2.ResumeLayout(false);\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer1)).EndInit();\n            this.splitContainer1.ResumeLayout(false);\n            this.splitContainer2.Panel1.ResumeLayout(false);\n            this.splitContainer2.Panel1.PerformLayout();\n            this.splitContainer2.Panel2.ResumeLayout(false);\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer2)).EndInit();
      public static readonly Mode BYTE = new Mode(new int[] { 8, 16, 16 }, 0x04, "BYTE");\n      /// <summary>\n      /// \n      /// </summary>\n      public static readonly Mode ECI = new Mode(null, 0x07, "ECI"); // character counts don't apply\n      /// <summary>\n      /// \n      /// </summary>\n      public static readonly Mode KANJI = new Mode(new int[] { 8, 10, 12 }, 0x08, "KANJI");\n      /// <summary>\n      private readonly int[] characterCountBitsForVersions;\n      private readonly int bits;\n      private readonly String name;\n      private Mode(int[] characterCountBitsForVersions, int bits, System.String name)
      private readonly int[] characterCountBitsForVersions;\n      private readonly int bits;\n      private readonly String name;\n      private Mode(int[] characterCountBitsForVersions, int bits, System.String name)\n      {\n         this.characterCountBitsForVersions = characterCountBitsForVersions;\n         this.bits = bits;\n         this.name = name;\n      }\n      /// <summary>
            case 0x4:\n               return BYTE;\n            case 0x5:\n               return FNC1_FIRST_POSITION;\n            case 0x7:\n               return ECI;\n            case 0x8:\n               return KANJI;\n            case 0x9:\n               return FNC1_SECOND_POSITION;
            default:\n               throw new ArgumentException();\n         }\n      }\n      /// <param name="version">version in question\n      /// </param>\n      /// <returns> number of bits used, in this QR Code symbol {@link Version}, to encode the\n      /// count of characters that will follow encoded in this {@link Mode}\n      /// </returns>\n      public int getCharacterCountBits(Version version)
      public static GenericGF QR_CODE_FIELD_256 = new GenericGF(0x011D, 256, 0); // x^8 + x^4 + x^3 + x^2 + 1\n      public static GenericGF DATA_MATRIX_FIELD_256 = new GenericGF(0x012D, 256, 1); // x^8 + x^5 + x^3 + x^2 + 1\n      public static GenericGF AZTEC_DATA_8 = DATA_MATRIX_FIELD_256;\n      public static GenericGF MAXICODE_FIELD_64 = AZTEC_DATA_6;\n      private int[] expTable;\n      private int[] logTable;\n      private GenericGFPoly zero;\n      private GenericGFPoly one;\n      private readonly int size;\n      private readonly int primitive;
      private int[] expTable;\n      private int[] logTable;\n      private GenericGFPoly zero;\n      private GenericGFPoly one;\n      private readonly int size;\n      private readonly int primitive;\n      private readonly int generatorBase;\n      /// <summary>\n      /// Create a representation of GF(size) using the given primitive polynomial.\n      /// </summary>
    {\n        private static Logger logger = LogManager.GetCurrentClassLogger();\n        public static event EventHandler<ResultEventArgs> UpdateCompleted;\n        public class ResultEventArgs : EventArgs\n        {\n            public bool Success;\n            public ResultEventArgs(bool success)\n            {\n                this.Success = success;\n            }
        public static event ErrorEventHandler Error;\n        private static readonly string DATABASE_PATH = Utils.GetTempPath("dlc.dat");\n        // temporary workaround\n        private static readonly string GEOSITE_URL = "https://github.com/v2ray/domain-list-community/releases/download/202005010407/dlc.dat";\n        public static readonly Dictionary<string, IList<DomainObject>> Geosites = new Dictionary<string, IList<DomainObject>>();\n        static GeositeUpdater()\n        {\n            if (!File.Exists(DATABASE_PATH))\n            {\n                File.WriteAllBytes(DATABASE_PATH, Resources.dlc_dat);
            }\n            UpdateSystemProxy();\n        }\n        public Server GetCurrentServer()\n        {\n            return _config.GetCurrentServer();\n        }\n        // always return copy\n        public Configuration GetConfiguration()\n        {
            if (methodname.IsNullOrEmpty()) throw new ArgumentException(nameof(methodname));\n            //HotkeySettingsForm form = new HotkeySettingsForm(_controller);\n            Type delegateType = Type.GetType("Shadowsocks.Util.HotKeys").GetNestedType("HotKeyCallBackHandler");\n            MethodInfo dynMethod = type.GetMethod(methodname,\n                BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.IgnoreCase);\n            return dynMethod == null ? null : Delegate.CreateDelegate(delegateType, this, dynMethod);\n        }\n        #endregion\n    }\n}
                BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.IgnoreCase);\n            return dynMethod == null ? null : Delegate.CreateDelegate(delegateType, this, dynMethod);\n        }\n        #endregion\n    }\n}
        }\n        #endregion\n    }\n}
using GlobalHotKey;\nusing System.Windows.Input;\nusing System.Threading;\nusing System.Collections.Generic;\nnamespace test\n{\n    [TestClass]\n    public class UnitTest\n    {
{\n    public static class HotKeys\n    {\n        private static HotKeyManager _hotKeyManager;\n        public delegate void HotKeyCallBackHandler();\n        // map key and corresponding handler function\n        private static Dictionary<HotKey, HotKeyCallBackHandler> _keymap = new Dictionary<HotKey, HotKeyCallBackHandler>();\n        public static void Init()\n        {\n            _hotKeyManager = new HotKeyManager();\n            _hotKeyManager.KeyPressed += HotKeyManagerPressed;
        {\n            _hotKeyManager = new HotKeyManager();\n            _hotKeyManager.KeyPressed += HotKeyManagerPressed;\n        }\n        public static void Destroy()\n        {\n            _hotKeyManager.KeyPressed -= HotKeyManagerPressed;\n            _hotKeyManager.Dispose();\n        }
                            // Multiply with flyBlue\n                            int red = color.R * flyBlue.R / 255;\n                            int green = color.G * flyBlue.G / 255;\n                            int blue = color.B * flyBlue.B / 255;\n                            iconCopy.SetPixel(x, y, Color.FromArgb(color.A, red, green, blue));\n                        }\n                        else if (global)\n                        {\n                            Color flyBlue = Color.FromArgb(25, 125, 191);
                        }\n                        else if (global)\n                        {\n                            Color flyBlue = Color.FromArgb(25, 125, 191);\n                            // Multiply with flyBlue\n                            int red = color.R * flyBlue.R / 255;\n                            int green = color.G * flyBlue.G / 255;\n                            int blue = color.B * flyBlue.B / 255;\n                            iconCopy.SetPixel(x, y, Color.FromArgb(color.A, red, green, blue));\n                        }
            try\n            {\n                var strategy = GetCurrentStrategy();\n                if (strategy != null)\n                {\n                    strategy.ReloadServers();\n                }\n                privoxyRunner.Start(_config);\n                TCPRelay tcpRelay = new TCPRelay(this, _config);\n                UDPRelay udpRelay = new UDPRelay(this);
                TCPRelay tcpRelay = new TCPRelay(this, _config);\n                UDPRelay udpRelay = new UDPRelay(this);\n                List<Listener.IService> services = new List<Listener.IService>();\n                services.Add(tcpRelay);\n                services.Add(udpRelay);\n                services.Add(_pacServer);\n                services.Add(new PortForwarder(privoxyRunner.RunningPort));\n                _listener = new Listener(services);\n                _listener.Start(_config);\n            }
                _listener = new Listener(services);\n                _listener.Start(_config);\n            }\n            catch (Exception e)\n            {\n                // translate Microsoft language into human language\n                // i.e. An attempt was made to access a socket in a way forbidden by its access permissions => Port already in use\n                if (e is SocketException)\n                {\n                    SocketException se = (SocketException)e;
        [DllImport("kernel32.dll")]\n        static extern bool SetInformationJobObject(IntPtr hJob, JobObjectInfoType infoType, IntPtr lpJobObjectInfo, UInt32 cbJobObjectInfoLength);\n        [DllImport("kernel32.dll", SetLastError = true)]\n        static extern bool AssignProcessToJobObject(IntPtr job, IntPtr process);\n        [DllImport("kernel32.dll", SetLastError = true)]\n        [return: MarshalAs(UnmanagedType.Bool)]\n        static extern bool CloseHandle(IntPtr hObject);\n        private IntPtr handle;\n        private bool disposed;\n        public Job()
        [DllImport("kernel32.dll", SetLastError = true)]\n        static extern bool AssignProcessToJobObject(IntPtr job, IntPtr process);\n        [DllImport("kernel32.dll", SetLastError = true)]\n        [return: MarshalAs(UnmanagedType.Bool)]\n        static extern bool CloseHandle(IntPtr hObject);\n        private IntPtr handle;\n        private bool disposed;\n        public Job()\n        {\n            handle = CreateJobObject(IntPtr.Zero, null);
        [DllImport("kernel32.dll", SetLastError = true)]\n        [return: MarshalAs(UnmanagedType.Bool)]\n        static extern bool CloseHandle(IntPtr hObject);\n        private IntPtr handle;\n        private bool disposed;\n        public Job()\n        {\n            handle = CreateJobObject(IntPtr.Zero, null);\n            var info = new JOBOBJECT_BASIC_LIMIT_INFORMATION
        private IntPtr handle;\n        private bool disposed;\n        public Job()\n        {\n            handle = CreateJobObject(IntPtr.Zero, null);\n            var info = new JOBOBJECT_BASIC_LIMIT_INFORMATION\n            {\n                LimitFlags = 0x2000\n            };
        }\n        public void Dispose()\n        {\n            Dispose(true);\n            GC.SuppressFinalize(this);\n        }\n        private void Dispose(bool disposing)\n        {\n            if (disposed)\n                return;
            ServersListBox.SelectedIndex = modifiedConfiguration.index;\n            oldSelectedIndex = ServersListBox.SelectedIndex;\n            enableItem.Checked = modifiedConfiguration.enabled;\n        }\n        private void ConfigForm_Load(object sender, EventArgs e)\n        {\n            if (!controller.GetConfiguration().isDefault)\n            {\n                this.Opacity = 0;\n                BeginInvoke(new MethodInvoker(delegate
            enableItem.Checked = modifiedConfiguration.enabled;\n        }\n        private void ConfigForm_Load(object sender, EventArgs e)\n        {\n            if (!controller.GetConfiguration().isDefault)\n            {\n                this.Opacity = 0;\n                BeginInvoke(new MethodInvoker(delegate\n                {\n                    this.Hide();

using System.Collections.Generic;\nusing System.Runtime.InteropServices;\nusing System.Text;\nnamespace shadowsocks_csharp.Encrypt\n{\n    public class OpensslEncryptor\n        : EncryptorBase, IDisposable\n    {
                byte[] iv = new byte[ivLen];\n                Native.RAND_bytes(iv, iv.Length);\n                InitCipher(ref _encryptCtx, iv, true);\n                int outLen = length + _cipher.BlockSize;\n                byte[] cipherText = new byte[outLen];\n                Native.EVP_CipherUpdate(_encryptCtx, cipherText, out outLen, buf, length);\n                byte[] result = new byte[outLen + ivLen];\n                Buffer.BlockCopy(iv, 0, result, 0, ivLen);\n                Buffer.BlockCopy(cipherText, 0, result, ivLen, outLen);\n                return result;
                InitCipher(ref _encryptCtx, iv, true);\n                int outLen = length + _cipher.BlockSize;\n                byte[] cipherText = new byte[outLen];\n                Native.EVP_CipherUpdate(_encryptCtx, cipherText, out outLen, buf, length);\n                byte[] result = new byte[outLen + ivLen];\n                Buffer.BlockCopy(iv, 0, result, 0, ivLen);\n                Buffer.BlockCopy(cipherText, 0, result, ivLen, outLen);\n                return result;\n            }\n            else
                byte[] cipherText = new byte[outLen];\n                Native.EVP_CipherUpdate(_encryptCtx, cipherText, out outLen, buf, length);\n                byte[] result = new byte[outLen + ivLen];\n                Buffer.BlockCopy(iv, 0, result, 0, ivLen);\n                Buffer.BlockCopy(cipherText, 0, result, ivLen, outLen);\n                return result;\n            }\n            else\n            {\n                int outLen = length + _cipher.BlockSize;
                byte[] result = new byte[outLen + ivLen];\n                Buffer.BlockCopy(iv, 0, result, 0, ivLen);\n                Buffer.BlockCopy(cipherText, 0, result, ivLen, outLen);\n                return result;\n            }\n            else\n            {\n                int outLen = length + _cipher.BlockSize;\n                byte[] cipherText = new byte[outLen];\n                Native.EVP_CipherUpdate(_encryptCtx, cipherText, out outLen, buf, length);
                byte[] cipherText = new byte[outLen];\n                Native.EVP_CipherUpdate(_encryptCtx, cipherText, out outLen, buf, length);\n                byte[] result = new byte[outLen];\n                Buffer.BlockCopy(cipherText, 0, result, 0, outLen);\n                return result;\n            }\n        }\n        public override byte[] Decrypt(byte[] buf, int length)\n        {\n            if (_decryptCtx == IntPtr.Zero)
                byte[] result = new byte[outLen];\n                Buffer.BlockCopy(cipherText, 0, result, 0, outLen);\n                return result;\n            }\n        }\n        public override byte[] Decrypt(byte[] buf, int length)\n        {\n            if (_decryptCtx == IntPtr.Zero)\n            {\n                int ivLen = _cipher.IVLength;
                byte[] iv = new byte[ivLen];\n                Buffer.BlockCopy(buf, 0, iv, 0, ivLen);\n                InitCipher(ref _decryptCtx, iv, false);\n                int outLen = length + _cipher.BlockSize;\n                outLen -= ivLen;\n                byte[] cipherText = new byte[outLen];\n                byte[] subset = new byte[length - ivLen];\n                Buffer.BlockCopy(buf, ivLen, subset, 0, length - ivLen);\n                Native.EVP_CipherUpdate(_decryptCtx, cipherText, out outLen, subset, length - ivLen);\n                byte[] result = new byte[outLen];
                outLen -= ivLen;\n                byte[] cipherText = new byte[outLen];\n                byte[] subset = new byte[length - ivLen];\n                Buffer.BlockCopy(buf, ivLen, subset, 0, length - ivLen);\n                Native.EVP_CipherUpdate(_decryptCtx, cipherText, out outLen, subset, length - ivLen);\n                byte[] result = new byte[outLen];\n                Buffer.BlockCopy(cipherText, 0, result, 0, outLen);\n                return result;\n            }\n            else
                byte[] result = new byte[outLen];\n                Buffer.BlockCopy(cipherText, 0, result, 0, outLen);\n                return result;\n            }\n            else\n            {\n                int outLen = length + _cipher.BlockSize;\n                byte[] cipherText = new byte[outLen];\n                Native.EVP_CipherUpdate(_decryptCtx, cipherText, out outLen, buf, length);\n                byte[] result = new byte[outLen];
                byte[] cipherText = new byte[outLen];\n                Native.EVP_CipherUpdate(_decryptCtx, cipherText, out outLen, buf, length);\n                byte[] result = new byte[outLen];\n                Buffer.BlockCopy(cipherText, 0, result, 0, outLen);\n                return result;\n            }\n        }\n        private static readonly Dictionary<string, byte[]> CachedKeys = new Dictionary<string, byte[]>();\n        private static readonly Dictionary<string, Cipher> CachedCiphers = new Dictionary<string, Cipher>();\n        private byte[] _key;
                byte[] result = new byte[outLen];\n                Buffer.BlockCopy(cipherText, 0, result, 0, outLen);\n                return result;\n            }\n        }\n        private static readonly Dictionary<string, byte[]> CachedKeys = new Dictionary<string, byte[]>();\n        private static readonly Dictionary<string, Cipher> CachedCiphers = new Dictionary<string, Cipher>();\n        private byte[] _key;\n        private Cipher _cipher;\n        private IntPtr _encryptCtx;
        private byte[] _key;\n        private Cipher _cipher;\n        private IntPtr _encryptCtx;\n        private IntPtr _decryptCtx;\n        private void InitKey(string method, string password)\n        {
        private IntPtr _encryptCtx;\n        private IntPtr _decryptCtx;\n        private void InitKey(string method, string password)\n        {\n            string k = method + ":" + password;
            }\n            _cipher = Cipher.CreateByName(method);\n            if (_cipher == null)\n            {\n                throw new NullReferenceException();
            {\n                throw new NullReferenceException();\n            }\n            byte[] passbuf = Encoding.UTF8.GetBytes(password);\n            _key = new byte[_cipher.KeyLength];
            }\n            byte[] passbuf = Encoding.UTF8.GetBytes(password);\n            _key = new byte[_cipher.KeyLength];\n            byte[] iv = new byte[_cipher.IVLength];\n            Native.EVP_BytesToKey(_cipher.Handle, MessageDigest.MD5.Handle, null, passbuf, passbuf.Length, 1, _key, iv);\n            CachedKeys[k] = _key;\n            CachedCiphers[k] = _cipher;\n        }\n        private void InitCipher(ref IntPtr ctx, byte[] iv, bool isCipher)\n        {
        }\n        private void InitCipher(ref IntPtr ctx, byte[] iv, bool isCipher)\n        {\n            ctx = Native.OPENSSL_malloc(Marshal.SizeOf(typeof(CipherContext.EVP_CIPHER_CTX)));\n            int enc = isCipher ? 1 : 0;\n            Native.EVP_CIPHER_CTX_init(ctx);\n            Native.ExpectSuccess(Native.EVP_CipherInit_ex(ctx, _cipher.Handle, IntPtr.Zero, null, null, enc));\n            Native.ExpectSuccess(Native.EVP_CIPHER_CTX_set_key_length(ctx, _key.Length));\n            Native.ExpectSuccess(Native.EVP_CIPHER_CTX_set_padding(ctx, 1));\n            Native.ExpectSuccess(Native.EVP_CipherInit_ex(ctx, _cipher.Handle, IntPtr.Zero, _key, iv, enc));
            int enc = isCipher ? 1 : 0;\n            Native.EVP_CIPHER_CTX_init(ctx);\n            Native.ExpectSuccess(Native.EVP_CipherInit_ex(ctx, _cipher.Handle, IntPtr.Zero, null, null, enc));\n            Native.ExpectSuccess(Native.EVP_CIPHER_CTX_set_key_length(ctx, _key.Length));\n            Native.ExpectSuccess(Native.EVP_CIPHER_CTX_set_padding(ctx, 1));\n            Native.ExpectSuccess(Native.EVP_CipherInit_ex(ctx, _cipher.Handle, IntPtr.Zero, _key, iv, enc));\n        }\n        #region IDisposable\n        private bool _disposed;
        }\n        #region IDisposable\n        private bool _disposed;\n        public void Dispose()\n        {\n            Dispose(true);\n            GC.SuppressFinalize(this);\n        }\n        ~OpensslEncryptor()\n        {
            availabilityStatistics.UpdateConfiguration(this);\n            if (_listener != null)\n            {\n                _listener.Stop();\n            }\n            StopPlugins();\n            // don't put PrivoxyRunner.Start() before pacServer.Stop()\n            // or bind will fail when switching bind address from 0.0.0.0 to 127.0.0.1\n            // though UseShellExecute is set to true now
            StopPlugins();\n            // don't put PrivoxyRunner.Start() before pacServer.Stop()\n            // or bind will fail when switching bind address from 0.0.0.0 to 127.0.0.1\n            // though UseShellExecute is set to true now\n            // http://stackoverflow.com/questions/10235093/socket-doesnt-close-after-application-exits-if-a-launched-process-is-open\n            privoxyRunner.Stop();\n            try\n            {\n                var strategy = GetCurrentStrategy();\n                if (strategy != null)\n                {\n                    strategy.ReloadServers();\n                }
                StartPlugin();\n                privoxyRunner.Start(_config);\n                TCPRelay tcpRelay = new TCPRelay(this, _config);\n                UDPRelay udpRelay = new UDPRelay(this);\n                List<Listener.IService> services = new List<Listener.IService>\n                {\n                    tcpRelay,\n                    udpRelay,\n                    _pacServer,\n                    new PortForwarder(privoxyRunner.RunningPort)
            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\nreturn false;
}\n}\n}\n}

                new MenuItem("-"),\n                CreateMenuItem("Show Logs...", new EventHandler(this.ShowLogItem_Click)),\n                CreateMenuItem("About...", new EventHandler(this.AboutItem_Click)),\n                new MenuItem("-"),\n                CreateMenuItem("Quit", new EventHandler(this.Quit_Click))\n            });\n        }\n        private void controller_ConfigChanged(object sender, EventArgs e)\n        {\n            LoadCurrentConfiguration();
                {\n                    // do nothing\n                }\n                _process = null;\n            }\n        }\n    }\n}
            return remarks.IsNullOrEmpty()\n                ? serverStr\n                : $"{remarks} ({serverStr})";
        private static string GetTimestamp(DateTime value)\n        {\n            return value.ToString("yyyyMMddHHmmssfff");\n        }\n        public static void Update(Configuration config, bool forceDisable, PACServer pacSrv)\n        {\n            if (failed) return;\n            bool global = config.global;\n            bool enabled = config.enabled;\n            if (forceDisable)
        {\n            if (failed) return;\n            bool global = config.global;\n            bool enabled = config.enabled;\n            if (forceDisable)\n            {\n                enabled = false;\n            }\n            try\n            {
            bool global = config.global;\n            bool enabled = config.enabled;\n            if (forceDisable)\n            {\n                enabled = false;\n            }\n            try\n            {\n                if (enabled)\n                {
                {\n                    case ProxyExceptionType.FailToRun:\n                        MessageBox.Show(I18N.GetString("Error when running sysproxy, check your proxy config"), I18N.GetString("Shadowsocks"));\n                        break;\n                    case ProxyExceptionType.QueryReturnMalformed:\n                    case ProxyExceptionType.QueryReturnEmpty:\n                        MessageBox.Show(I18N.GetString("Can't query proxy config, check your proxy config"), I18N.GetString("Shadowsocks"));\n                        break;\n                    case ProxyExceptionType.SysproxyExitError:\n                        MessageBox.Show(I18N.GetString("Sysproxy return a error:") + ex.Message, I18N.GetString("Shadowsocks"));
                }\n            }\n        }\n    }\n}
        {\n            RegistryKey registry = Registry.CurrentUser.OpenSubKey("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings", true);\n            registry.SetValue("ProxyEnable", 1);\n            registry.SetValue("ProxyServer", "127.0.0.1:8123");\n            // These lines implement the Interface in the beginning of program \n            // They cause the OS to refresh the settings, causing IP to realy update\n            settingsReturn = InternetSetOption(IntPtr.Zero, INTERNET_OPTION_SETTINGS_CHANGED, IntPtr.Zero, 0);\n            refreshReturn = InternetSetOption(IntPtr.Zero, INTERNET_OPTION_REFRESH, IntPtr.Zero, 0);\n        }\n        public void Disable()
            // These lines implement the Interface in the beginning of program \n            // They cause the OS to refresh the settings, causing IP to realy update\n            settingsReturn = InternetSetOption(IntPtr.Zero, INTERNET_OPTION_SETTINGS_CHANGED, IntPtr.Zero, 0);\n            refreshReturn = InternetSetOption(IntPtr.Zero, INTERNET_OPTION_REFRESH, IntPtr.Zero, 0);\n        }\n        public void Disable()
        {\n            RegistryKey registry = Registry.CurrentUser.OpenSubKey("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings", true);\n            registry.SetValue("ProxyEnable", 0);\n            registry.SetValue("ProxyServer", "");\n            // These lines implement the Interface in the beginning of program \n            // They cause the OS to refresh the settings, causing IP to realy update\n            settingsReturn = InternetSetOption(IntPtr.Zero, INTERNET_OPTION_SETTINGS_CHANGED, IntPtr.Zero, 0);\n            refreshReturn = InternetSetOption(IntPtr.Zero, INTERNET_OPTION_REFRESH, IntPtr.Zero, 0);\n        }\n    }\n}
        }\n    }\n}
    public class AvailabilityStatistics\n    {\n        public static readonly string DateTimePattern = "yyyy-MM-dd HH:mm:ss";\n        private const string StatisticsFilesName = "shadowsocks.availability.csv";\n        private const string Delimiter = ",";\n        private const int Timeout = 500;\n        private const int DelayBeforeStart = 1000;\n        public RawStatistics rawStatistics { get; private set; }\n        public RawStatistics filteredStatistics { get; private set; }\n        private int _repeat => _config.RepeatTimesNum;
        private const int RetryInterval = 2*60*1000; //retry 2 minutes after failed
                    ret.Add(new List<KeyValuePair<string, string>>\n                    {\n                        new KeyValuePair<string, string>("Timestamp", timestamp),\n                        new KeyValuePair<string, string>("Server", server.FriendlyName()),\n                        new KeyValuePair<string, string>("Status", reply?.Status.ToString()),\n                        new KeyValuePair<string, string>("RoundtripTime", reply?.RoundtripTime.ToString())\n                        //new KeyValuePair<string, string>("data", reply.Buffer.ToString()); // The data of reply\n                    });\n                    Thread.Sleep(new Random().Next() % Timeout);\n                    //Do ICMPTest in a random frequency\n                }
                    //Do ICMPTest in a random frequency\n                }\n                catch (Exception e)\n                {\n                    Console.WriteLine($"An exception occured when eveluating {server.FriendlyName()}");\n                    Logging.LogUsefulException(e);\n                }\n            }\n            return ret;\n        }
                    tcprelay.UpdateOutboundCounter(server, bytesToSend);\n                    _startSendingTime = DateTime.Now;\n                    _bytesToSend = bytesToSend;\n                    remote.BeginSend(connetionSendBuffer, 0, bytesToSend, 0, new AsyncCallback(PipeRemoteSendCallback), null);\n                    IStrategy strategy = controller.GetCurrentStrategy();\n                    strategy?.UpdateLastWrite(server);\n                }\n                else\n                {\n                    remote.Shutdown(SocketShutdown.Send);
            this.label2 = new System.Windows.Forms.Label();\n            this.label3 = new System.Windows.Forms.Label();\n            this.label4 = new System.Windows.Forms.Label();\n            this.chartModeSelector = new System.Windows.Forms.GroupBox();\n            this.allMode = new System.Windows.Forms.RadioButton();\n            this.dayMode = new System.Windows.Forms.RadioButton();\n            this.splitContainer1 = new System.Windows.Forms.SplitContainer();\n            this.splitContainer2 = new System.Windows.Forms.SplitContainer();\n            this.label9 = new System.Windows.Forms.Label();\n            this.label8 = new System.Windows.Forms.Label();
            this.chartModeSelector = new System.Windows.Forms.GroupBox();\n            this.allMode = new System.Windows.Forms.RadioButton();\n            this.dayMode = new System.Windows.Forms.RadioButton();\n            this.splitContainer1 = new System.Windows.Forms.SplitContainer();\n            this.splitContainer2 = new System.Windows.Forms.SplitContainer();\n            this.label9 = new System.Windows.Forms.Label();\n            this.label8 = new System.Windows.Forms.Label();\n            this.dataCollectionMinutesNum = new System.Windows.Forms.NumericUpDown();\n            this.StatisticsEnabledCheckBox = new System.Windows.Forms.CheckBox();\n            this.choiceKeptMinutesNum = new System.Windows.Forms.NumericUpDown();
        private System.Windows.Forms.Label label2;\n        private System.Windows.Forms.Label label3;\n        private System.Windows.Forms.Label label4;\n        private System.Windows.Forms.GroupBox chartModeSelector;\n        private System.Windows.Forms.RadioButton allMode;\n        private System.Windows.Forms.RadioButton dayMode;\n        private System.Windows.Forms.SplitContainer splitContainer1;\n        private System.Windows.Forms.Label label1;\n        private System.Windows.Forms.SplitContainer splitContainer2;\n        private System.Windows.Forms.FlowLayoutPanel calculationContainer;
        private System.Windows.Forms.GroupBox chartModeSelector;\n        private System.Windows.Forms.RadioButton allMode;\n        private System.Windows.Forms.RadioButton dayMode;\n        private System.Windows.Forms.SplitContainer splitContainer1;\n        private System.Windows.Forms.Label label1;\n        private System.Windows.Forms.SplitContainer splitContainer2;\n        private System.Windows.Forms.FlowLayoutPanel calculationContainer;\n        private System.Windows.Forms.SplitContainer splitContainer3;\n        private System.Windows.Forms.NumericUpDown repeatTimesNum;\n        private System.Windows.Forms.Label label6;
        public static string AvailabilityStatisticsFile;\n        private readonly TimeSpan _delayBeforeStart = TimeSpan.FromSeconds(1);\n        private readonly TimeSpan _monitorInterval = TimeSpan.FromSeconds(1);\n        private readonly TimeSpan _retryInterval = TimeSpan.FromMinutes(2); //retry 2 minutes after failed\n        private readonly TimeSpan _writingInterval = TimeSpan.FromMinutes(1);\n        private StatisticsStrategyConfiguration _config;\n        private ShadowsocksController _controller;\n        private Server _currentServer;\n        //speed in KiB/s\n        private List<int> _inboundSpeedRecords;
        //static constructor to initialize every public static fields before refereced\n        static AvailabilityStatistics()\n        {\n            AvailabilityStatisticsFile = Utils.GetTempPath(StatisticsFilesName);\n        }\n        private AvailabilityStatistics()\n        {\n            RawStatistics = new Statistics();\n        }
        // Static Singleton Initialization\n        public static AvailabilityStatistics Instance { get; } = new AvailabilityStatistics();\n        public Statistics RawStatistics { get; private set; }\n        public Statistics FilteredStatistics { get; private set; }\n        private int Repeat => _config.RepeatTimesNum;\n        private TimeSpan RecordingInterval => TimeSpan.FromMinutes(_config.DataCollectionMinutes);\n        public bool Set(StatisticsStrategyConfiguration config)\n        {\n            _config = config;\n            try\n            {
                    LoadRawStatistics();\n                    if (_speedMonior?.Change(_delayBeforeStart, _monitorInterval) == null)\n                    {\n                        _speedMonior = new Timer(UpdateSpeed, null, _delayBeforeStart, _monitorInterval);\n                    }\n                    if (_writer?.Change(_delayBeforeStart, RecordingInterval) == null)\n                    {\n                        _writer = new Timer(Save, null, _delayBeforeStart, RecordingInterval);\n                    }
                }\n                else\n                {\n                    _recorder?.Dispose();\n                    _speedMonior?.Dispose();\n                }\n                return true;\n            }\n            catch (Exception e)\n            {
            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                return false;\n            }\n        }\n        private void UpdateSpeed(object state)
        {\n            var bytes = _controller.inboundCounter - _lastInboundCounter;\n            _lastInboundCounter = _controller.inboundCounter;\n            var inboundSpeed = GetSpeedInKiBPerSecond(bytes, _monitorInterval.TotalSeconds);\n            _inboundSpeedRecords.Add(inboundSpeed);\n            bytes = _controller.outboundCounter - _lastOutboundCounter;\n            _lastOutboundCounter = _controller.outboundCounter;\n            var outboundSpeed = GetSpeedInKiBPerSecond(bytes, _monitorInterval.TotalSeconds);\n            _outboundSpeedRecords.Add(outboundSpeed);\n            Logging.Debug(
            Reset();\n            FilterRawStatistics();\n        }\n        private async void AppendRecord()\n        {\n            //todo: option for icmp test\n            var icmpResults = TaskEx.WhenAll(_servers.Select(ICMPTest));\n            var currentServerRecord = new StatisticsRecord(_currentServer.Identifier(),\n                _inboundSpeedRecords, _outboundSpeedRecords, _latencyRecords);
            foreach (var result in (await icmpResults).Where(result => result != null))\n            {\n                List<StatisticsRecord> records;\n                if (!RawStatistics.TryGetValue(result.Server.Identifier(), out records))\n                {\n                    records = new List<StatisticsRecord>();\n                }\n                if (result.Server.Equals(_currentServer))\n                {\n                    currentServerRecord.setResponse(result.RoundtripTime);
                {\n                    currentServerRecord.setResponse(result.RoundtripTime);\n                    records.Add(currentServerRecord);\n                }\n                else\n                {\n                    records.Add(new StatisticsRecord(result.Server.Identifier(), result.RoundtripTime));\n                }\n                RawStatistics[result.Server.Identifier()] = records;\n            }
                }\n                else\n                {\n                    records.Add(new StatisticsRecord(result.Server.Identifier(), result.RoundtripTime));\n                }\n                RawStatistics[result.Server.Identifier()] = records;\n            }
        }\n        private void Save(object _)\n        {\n            try\n            {\n                File.WriteAllText(AvailabilityStatisticsFile,\n                    JsonConvert.SerializeObject(RawStatistics, Formatting.None));\n            }\n            catch (IOException e)\n            {
        private bool IsValidRecord(StatisticsRecord record)\n        {\n            if (_config.ByHourOfDay)\n            {\n                var currentHour = DateTime.Now.Hour;\n                if (record.Timestamp == UnknownDateTime) return false;\n                if (!record.Timestamp.Hour.Equals(DateTime.Now.Hour)) return false;\n            }\n            return true;\n        }
                if (record.Timestamp == UnknownDateTime) return false;\n                if (!record.Timestamp.Hour.Equals(DateTime.Now.Hour)) return false;\n            }\n            return true;\n        }\n        private void FilterRawStatistics()\n        {\n            if (RawStatistics == null) return;\n            if (FilteredStatistics == null)\n            {
            {\n                ChooseNewServer(_controller.GetCurrentConfiguration().configs);\n            }\n            if (oldServer != _currentServer)\n            {\n            }\n            return _currentServer;  //current server cached for CachedInterval\n        }\n        public void ReloadServers()\n        {
            }\n            return _currentServer;  //current server cached for CachedInterval\n        }\n        public void ReloadServers()\n        {\n            ChooseNewServer(_controller.GetCurrentConfiguration().configs);\n            _timer?.Change(0, ChoiceKeptMilliseconds);\n        }\n        public void SetFailure(Server server)\n        {
        }\n        private void CleanLogsButton_Click(object sender, EventArgs e)\n        {\n            LogMessageTextBox.Clear();\n        }\n        private void ChangeFontButton_Click(object sender, EventArgs e)\n        {\n            try\n            {
        {\n            try\n            {\n                FontDialog fd = new FontDialog();\n                fd.Font = LogMessageTextBox.Font;\n                if (fd.ShowDialog() == DialogResult.OK)\n                {\n                    LogMessageTextBox.Font = new Font(fd.Font.FontFamily, fd.Font.Size, fd.Font.Style);\n                }\n            }
        }\n    }\n}
            this.FileMenuItem = new System.Windows.Forms.MenuItem();\n            this.OpenLocationMenuItem = new System.Windows.Forms.MenuItem();\n            this.ExitMenuItem = new System.Windows.Forms.MenuItem();\n            this.panel1 = new System.Windows.Forms.Panel();
            this.ChangeFontButton = new System.Windows.Forms.Button();\n            this.CleanLogsButton = new System.Windows.Forms.Button();\n            this.WrapTextCheckBox = new System.Windows.Forms.CheckBox();\n            this.tableLayoutPanel1 = new System.Windows.Forms.TableLayoutPanel();\n            this.TopMostCheckBox = new System.Windows.Forms.CheckBox();\n            this.panel1.SuspendLayout();\n            this.tableLayoutPanel1.SuspendLayout();
            this.tableLayoutPanel1.SuspendLayout();
            // \n            // ChangeFontButton\n            // \n            this.ChangeFontButton.Location = new System.Drawing.Point(107, 4);\n            this.ChangeFontButton.Name = "ChangeFontButton";\n            this.ChangeFontButton.Size = new System.Drawing.Size(75, 23);\n            this.ChangeFontButton.TabIndex = 2;\n            this.ChangeFontButton.Text = "&Font";\n            this.ChangeFontButton.UseVisualStyleBackColor = true;\n            this.ChangeFontButton.Click += new System.EventHandler(this.ChangeFontButton_Click);\n            // \n            // CleanLogsButton\n            this.CleanLogsButton.Location = new System.Drawing.Point(9, 4);
            this.ChangeFontButton.Name = "ChangeFontButton";\n            this.ChangeFontButton.Size = new System.Drawing.Size(75, 23);\n            this.ChangeFontButton.TabIndex = 2;\n            this.ChangeFontButton.Text = "&Font";\n            this.ChangeFontButton.UseVisualStyleBackColor = true;\n            this.ChangeFontButton.Click += new System.EventHandler(this.ChangeFontButton_Click);\n            // \n            // CleanLogsButton\n            // \n            this.CleanLogsButton.Location = new System.Drawing.Point(9, 4);\n            this.CleanLogsButton.Name = "CleanLogsButton";\n            this.CleanLogsButton.Size = new System.Drawing.Size(75, 23);
            this.CleanLogsButton.Name = "CleanLogsButton";\n            this.CleanLogsButton.Size = new System.Drawing.Size(75, 23);\n            this.CleanLogsButton.TabIndex = 1;\n            this.CleanLogsButton.Text = "&Clean logs";\n            this.CleanLogsButton.UseVisualStyleBackColor = true;\n            this.CleanLogsButton.Click += new System.EventHandler(this.CleanLogsButton_Click);\n            // \n            // WrapTextCheckBox\n            // \n            this.WrapTextCheckBox.AutoSize = true;
            this.tableLayoutPanel1.Controls.Add(this.LogMessageTextBox, 0, 1);\n            this.tableLayoutPanel1.Dock = System.Windows.Forms.DockStyle.Fill;\n            this.tableLayoutPanel1.Location = new System.Drawing.Point(0, 0);\n            this.tableLayoutPanel1.Name = "tableLayoutPanel1";\n            this.tableLayoutPanel1.RowCount = 2;\n            this.tableLayoutPanel1.Size = new System.Drawing.Size(547, 353);\n            this.tableLayoutPanel1.TabIndex = 2;
            this.tableLayoutPanel1.TabIndex = 2;\n            // \n            // TopMostCheckBox\n            // \n            this.TopMostCheckBox.AutoSize = true;\n            this.TopMostCheckBox.Location = new System.Drawing.Point(311, 9);\n            this.TopMostCheckBox.Name = "TopMostCheckBox";\n            this.TopMostCheckBox.Size = new System.Drawing.Size(72, 16);\n            this.TopMostCheckBox.TabIndex = 3;\n            this.TopMostCheckBox.Text = "&Top most";\n            this.TopMostCheckBox.UseVisualStyleBackColor = true;

            this.tableLayoutPanel1.ResumeLayout(false);\n            this.tableLayoutPanel1.PerformLayout();\n            this.ResumeLayout(false);\n        }\n        #endregion\n        private System.Windows.Forms.TextBox LogMessageTextBox;\n        private System.Windows.Forms.ContextMenuStrip contextMenuStrip1;\n        private System.Windows.Forms.MainMenu mainMenu1;\n        private System.Windows.Forms.MenuItem FileMenuItem;
        private System.Windows.Forms.MenuItem FileMenuItem;\n        private System.Windows.Forms.MenuItem OpenLocationMenuItem;\n        private System.Windows.Forms.MenuItem ExitMenuItem;\n        private System.Windows.Forms.Panel panel1;\n        private System.Windows.Forms.CheckBox WrapTextCheckBox;\n        private System.Windows.Forms.Button CleanLogsButton;\n        private System.Windows.Forms.Button ChangeFontButton;\n        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel1;\n        private System.Windows.Forms.CheckBox TopMostCheckBox;
        private System.Windows.Forms.CheckBox WrapTextCheckBox;\n        private System.Windows.Forms.Button CleanLogsButton;\n        private System.Windows.Forms.Button ChangeFontButton;\n        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel1;\n        private System.Windows.Forms.CheckBox TopMostCheckBox;
        public PortForwarder(int targetPort)\n        {\n            this._targetPort = targetPort;\n        }\n        public override bool Handle(byte[] firstPacket, int length, Socket socket, object state)\n        {\n            if (socket.ProtocolType != ProtocolType.Tcp)\n            {\n                return false;\n            }
        }\n        public override bool Handle(byte[] firstPacket, int length, Socket socket, object state)\n        {\n            if (socket.ProtocolType != ProtocolType.Tcp)\n            {\n                return false;\n            }\n            new Handler().Start(firstPacket, length, socket, this._targetPort);\n            return true;\n        }
            return true;\n        }\n        class Handler\n        {\n            private byte[] _firstPacket;\n            private int _firstPacketLength;\n            private Socket _local;\n            private WrappedSocket _remote;\n            private bool _closed = false;\n            private bool _localShutdown = false;
        {\n            private byte[] _firstPacket;\n            private int _firstPacketLength;\n            private Socket _local;\n            private WrappedSocket _remote;\n            private bool _closed = false;\n            private bool _localShutdown = false;\n            private bool _remoteShutdown = false;\n            public const int RecvSize = 16384;\n            // remote receive buffer
            // remote receive buffer\n            private byte[] remoteRecvBuffer = new byte[RecvSize];\n            // connection receive buffer\n            private byte[] connetionRecvBuffer = new byte[RecvSize];\n            // instance-based lock\n            private readonly object _Lock = new object();\n            public void Start(byte[] firstPacket, int length, Socket socket, int targetPort)\n            {\n                this._firstPacket = firstPacket;\n                this._firstPacketLength = length;\n                this._local = socket;\n                try\n                {
                try\n                {\n                    EndPoint remoteEP = SocketUtil.GetEndPoint("127.0.0.1", targetPort);\n                    // Connect to the remote endpoint.\n                    _remote = new WrappedSocket();\n                    _remote.BeginConnect(remoteEP, ConnectCallback, null);\n                }\n                catch (Exception e)\n                {\n                    Logging.LogUsefulException(e);\n                    this.Close();
                }\n            }\n            private void ConnectCallback(IAsyncResult ar)\n            {\n                if (_closed)\n                {\n                    return;\n                }\n                try\n                {
                    _local.BeginReceive(connetionRecvBuffer, 0, RecvSize, 0,\n                        new AsyncCallback(PipeConnectionReceiveCallback), null);\n                }\n                catch (Exception e)\n                {\n                    Logging.LogUsefulException(e);\n                    this.Close();\n                }\n            }\n            private void PipeRemoteReceiveCallback(IAsyncResult ar)
                }\n            }\n            private void PipeRemoteReceiveCallback(IAsyncResult ar)\n            {\n                if (_closed)\n                {\n                    return;\n                }\n                try\n                {
                }\n            }\n            private void CheckClose()\n            {\n                if (_localShutdown && _remoteShutdown)\n                {\n                    this.Close();\n                }\n            }\n            public void Close()
                }\n            }\n            public void Close()\n            {\n                lock (_Lock)\n                {\n                    if (_closed)\n                    {\n                        return;\n                    }
                _key = CachedKeys[k];\n            }\n            else\n            {\n                byte[] passbuf = Encoding.UTF8.GetBytes(password);\n                _key = new byte[32];\n                byte[] iv = new byte[16];\n                bytesToKey(passbuf, _key);\n                CachedKeys[k] = _key;\n            }
        }\n        protected void bytesToKey(byte[] password, byte[] key)\n        {\n            byte[] result = new byte[password.Length + 16];\n            int i = 0;\n            byte[] md5sum = null;\n            while (i < key.Length)\n            {\n                if (i == 0)\n                {
{\n    public class DirectConnect : IProxy\n    {\n        private class FakeAsyncResult : IAsyncResult\n        {\n            public FakeAsyncResult(object state)\n            {\n                AsyncState = state;\n            }\n            public bool IsCompleted { get; } = true;
    {\n        private class FakeAsyncResult : IAsyncResult\n        {\n            public FakeAsyncResult(object state)\n            {\n                AsyncState = state;\n            }\n            public bool IsCompleted { get; } = true;\n            public WaitHandle AsyncWaitHandle { get; } = null;\n            public object AsyncState { get; }
{\n    public class HttpProxy : IProxy\n    {\n        private class FakeAsyncResult : IAsyncResult\n        {\n            public readonly HttpState innerState;\n            private readonly IAsyncResult r;\n            public FakeAsyncResult(IAsyncResult orig, HttpState state)\n            {\n                r = orig;
    {\n        private class FakeAsyncResult : IAsyncResult\n        {\n            public readonly HttpState innerState;\n            private readonly IAsyncResult r;\n            public FakeAsyncResult(IAsyncResult orig, HttpState state)\n            {\n                r = orig;\n                innerState = state;\n            }
using Shadowsocks.Util.Sockets;\nnamespace Shadowsocks.Controller\n{\n    class TCPRelay : Listener.Service\n    {\n        private ShadowsocksController _controller;\n        private DateTime _lastSweepTime;\n        private Configuration _config;\n        public ISet<TCPHandler> Handlers { get; set; }\n        public TCPRelay(ShadowsocksController controller, Configuration conf)
{\n    public interface IProxy\n    {\n        EndPoint LocalEndPoint { get; }\n        EndPoint ProxyEndPoint { get; }\n        EndPoint DestEndPoint { get; }\n        void BeginConnectProxy(EndPoint remoteEP, AsyncCallback callback, object state);\n        void EndConnectProxy(IAsyncResult asyncResult);\n        void BeginConnectDest(EndPoint destEndPoint, AsyncCallback callback, object state);\n        void EndConnectDest(IAsyncResult asyncResult);
    {\n        EndPoint LocalEndPoint { get; }\n        EndPoint ProxyEndPoint { get; }\n        EndPoint DestEndPoint { get; }\n        void BeginConnectProxy(EndPoint remoteEP, AsyncCallback callback, object state);\n        void EndConnectProxy(IAsyncResult asyncResult);\n        void BeginConnectDest(EndPoint destEndPoint, AsyncCallback callback, object state);\n        void EndConnectDest(IAsyncResult asyncResult);\n        void BeginSend(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state);
{\n    public class Socks5Proxy : IProxy\n    {\n        private class FakeAsyncResult : IAsyncResult\n        {\n            public readonly Socks5State innerState;\n            private readonly IAsyncResult r;\n            public FakeAsyncResult(IAsyncResult orig, Socks5State state)\n            {\n                r = orig;
    {\n        private class FakeAsyncResult : IAsyncResult\n        {\n            public readonly Socks5State innerState;\n            private readonly IAsyncResult r;\n            public FakeAsyncResult(IAsyncResult orig, Socks5State state)\n            {\n                r = orig;\n                innerState = state;\n            }
            this.StatisticsChart = new System.Windows.Forms.DataVisualization.Charting.Chart();\n            this.checkBox1 = new System.Windows.Forms.CheckBox();\n            this.label2 = new System.Windows.Forms.Label();\n            this.label3 = new System.Windows.Forms.Label();\n            this.label4 = new System.Windows.Forms.Label();\n            this.groupBox1 = new System.Windows.Forms.GroupBox();\n            this.radioButton2 = new System.Windows.Forms.RadioButton();\n            this.radioButton1 = new System.Windows.Forms.RadioButton();
            this.label2 = new System.Windows.Forms.Label();\n            this.label3 = new System.Windows.Forms.Label();\n            this.label4 = new System.Windows.Forms.Label();\n            this.groupBox1 = new System.Windows.Forms.GroupBox();\n            this.radioButton2 = new System.Windows.Forms.RadioButton();\n            this.radioButton1 = new System.Windows.Forms.RadioButton();\n            this.splitContainer1 = new System.Windows.Forms.SplitContainer();\n            this.splitContainer2 = new System.Windows.Forms.SplitContainer();\n            this.numericUpDown2 = new System.Windows.Forms.NumericUpDown();\n            this.checkBox2 = new System.Windows.Forms.CheckBox();
            this.label6 = new System.Windows.Forms.Label();\n            this.splitContainer3 = new System.Windows.Forms.SplitContainer();\n            this.label1 = new System.Windows.Forms.Label();\n            this.flowLayoutPanel1 = new System.Windows.Forms.FlowLayoutPanel();\n            this.panel3 = new System.Windows.Forms.Panel();\n            this.label5 = new System.Windows.Forms.Label();\n            this.label7 = new System.Windows.Forms.Label();\n            this.textBox5 = new System.Windows.Forms.TextBox();\n            this.comboBox3 = new System.Windows.Forms.ComboBox();
            ((System.ComponentModel.ISupportInitialize)(this.StatisticsChart)).BeginInit();\n            this.groupBox1.SuspendLayout();\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer1)).BeginInit();\n            this.splitContainer1.Panel1.SuspendLayout();\n            this.splitContainer1.Panel2.SuspendLayout();\n            this.splitContainer1.SuspendLayout();\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer2)).BeginInit();\n            this.splitContainer2.Panel1.SuspendLayout();\n            this.splitContainer2.Panel2.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.splitContainer3)).BeginInit();\n            this.splitContainer3.Panel1.SuspendLayout();\n            this.splitContainer3.Panel2.SuspendLayout();\n            this.splitContainer3.SuspendLayout();\n            this.flowLayoutPanel1.SuspendLayout();\n            this.panel3.SuspendLayout();\n            this.SuspendLayout();\n            // \n            // StatisticsChart\n            // 
            this.SuspendLayout();\n            // \n            // StatisticsChart\n            // \n            this.StatisticsChart.BackColor = System.Drawing.Color.Transparent;
            // \n            // splitContainer1.Panel2\n            // \n            this.splitContainer1.Panel2.Controls.Add(this.groupBox1);\n            this.splitContainer1.Panel2.Controls.Add(this.StatisticsChart);
            this.splitContainer2.Panel1.Controls.Add(this.label6);\n            this.splitContainer2.Panel1.Controls.Add(this.label2);\n            this.splitContainer2.Panel1.Controls.Add(this.label4);\n            this.splitContainer2.Panel1.Controls.Add(this.checkBox1);\n            this.splitContainer2.Panel1.Controls.Add(this.label3);\n            // \n            // splitContainer2.Panel2\n            // \n            this.splitContainer2.Panel2.Controls.Add(this.splitContainer3);
            this.splitContainer2.Panel1.Controls.Add(this.label3);\n            // \n            // splitContainer2.Panel2\n            // \n            this.splitContainer2.Panel2.Controls.Add(this.splitContainer3);\n            // numericUpDown2\n            // \n            this.numericUpDown2.Location = new System.Drawing.Point(16, 145);\n            this.numericUpDown2.Margin = new System.Windows.Forms.Padding(3, 4, 3, 4);
            10,\n            0,\n            0,\n            0});\n            this.numericUpDown1.Name = "numericUpDown1";\n            this.numericUpDown1.Size = new System.Drawing.Size(91, 34);\n            this.numericUpDown1.TabIndex = 14;\n            this.numericUpDown1.Value = new decimal(new int[] {
            4,\n            0,\n            0,\n            0});\n            // \n            // label6\n            // \n            this.label6.AutoSize = true;
            ((System.ComponentModel.ISupportInitialize)(this.StatisticsChart)).EndInit();\n            this.groupBox1.ResumeLayout(false);\n            this.groupBox1.PerformLayout();\n            this.splitContainer1.Panel1.ResumeLayout(false);\n            this.splitContainer1.Panel2.ResumeLayout(false);\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer1)).EndInit();\n            this.splitContainer1.ResumeLayout(false);\n            this.splitContainer2.Panel1.ResumeLayout(false);\n            this.splitContainer2.Panel1.PerformLayout();
            this.splitContainer3.Panel1.ResumeLayout(false);\n            this.splitContainer3.Panel1.PerformLayout();\n            this.splitContainer3.Panel2.ResumeLayout(false);\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer3)).EndInit();\n            this.splitContainer3.ResumeLayout(false);\n            this.flowLayoutPanel1.ResumeLayout(false);\n            this.flowLayoutPanel1.PerformLayout();\n            this.panel3.ResumeLayout(false);\n            this.panel3.PerformLayout();\n            this.ResumeLayout(false);
            this.ResumeLayout(false);\n        }\n        #endregion\n        private System.Windows.Forms.DataVisualization.Charting.Chart StatisticsChart;\n        private System.Windows.Forms.CheckBox checkBox1;\n        private System.Windows.Forms.Label label2;\n        private System.Windows.Forms.Label label3;\n        private System.Windows.Forms.Label label4;\n        private System.Windows.Forms.GroupBox groupBox1;\n        private System.Windows.Forms.RadioButton radioButton2;\n        private System.Windows.Forms.RadioButton radioButton1;
        private System.Windows.Forms.Label label2;\n        private System.Windows.Forms.Label label3;\n        private System.Windows.Forms.Label label4;\n        private System.Windows.Forms.GroupBox groupBox1;\n        private System.Windows.Forms.RadioButton radioButton2;\n        private System.Windows.Forms.RadioButton radioButton1;\n        private System.Windows.Forms.SplitContainer splitContainer1;\n        private System.Windows.Forms.Label label1;\n        private System.Windows.Forms.SplitContainer splitContainer2;\n        private System.Windows.Forms.FlowLayoutPanel flowLayoutPanel1;
        private System.Windows.Forms.SplitContainer splitContainer3;\n        private System.Windows.Forms.Panel panel3;\n        private System.Windows.Forms.Label label5;\n        private System.Windows.Forms.Label label7;\n        private System.Windows.Forms.TextBox textBox5;\n        private System.Windows.Forms.ComboBox comboBox3;\n        private System.Windows.Forms.NumericUpDown numericUpDown1;\n        private System.Windows.Forms.Label label6;\n        private System.Windows.Forms.CheckBox checkBox2;
        private System.Windows.Forms.Label label6;\n        private System.Windows.Forms.CheckBox checkBox2;\n        private System.Windows.Forms.NumericUpDown numericUpDown2;
    }\n}
    {\n        private readonly ShadowsocksController _controller;\n        private Server _currentServer;\n        private readonly Timer _timer;\n        private Dictionary<string, StatisticsData> _statistics;\n        private const int CachedInterval = 30*60*1000; //choose a new server every 30 minutes\n        private const int RetryInterval = 2*60*1000; //choose a new server every 30 minutes\n        public SimplyChooseByStatisticsStrategy(ShadowsocksController controller)
        {\n            _controller = controller;\n            var servers = controller.GetCurrentConfiguration().configs;\n            var randomIndex = new Random().Next() % servers.Count();\n            _currentServer = servers[randomIndex];  //choose a server randomly at first\n            _timer = new Timer(ReloadStatisticsAndChooseAServer);\n        }\n        private void ReloadStatisticsAndChooseAServer(object obj)\n        {\n            Logging.Debug("Reloading statistics and choose a new server....");
        {\n            //TODO: Load options\n            var statisticsStrategyOptionsForm = new StatisticsStrategyOptionsForm();

                _currentServer = bestResult.server;\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n            }\n        }\n        string IStrategy.ID\n        {\n            get { return "com.shadowsocks.strategy.scbs"; }
        {\n            get { return "com.shadowsocks.strategy.scbs"; }\n        }\n        string IStrategy.Name\n        {\n            get { return I18N.GetString("Choose By Total Package Loss"); }\n        }\n        Server IStrategy.GetAServer(IStrategyCallerType type, IPEndPoint localIPEndPoint)\n        {\n            Console.WriteLine("Switch to server by statistics: {0}", _currentServer.FriendlyName());
        {\n            get { return I18N.GetString("Choose By Total Package Loss"); }\n        }\n        Server IStrategy.GetAServer(IStrategyCallerType type, IPEndPoint localIPEndPoint)\n        {\n            Console.WriteLine("Switch to server by statistics: {0}", _currentServer.FriendlyName());
        {\n            Console.WriteLine("Switch to server by statistics: {0}", _currentServer.FriendlyName());
            return _currentServer;  //current server cached for CachedInterval\n        }\n        void IStrategy.ReloadServers()\n        {\n            ChooseNewServer(_controller.GetCurrentConfiguration().configs);\n            timer?.Change(0, CachedInterval);\n        }\n        void IStrategy.SetFailure(Server server)\n        {\n            Logging.Debug(String.Format("failure: {0}", server.FriendlyName()));
        {\n            ChooseNewServer(_controller.GetCurrentConfiguration().configs);\n            timer?.Change(0, CachedInterval);\n        }\n        void IStrategy.SetFailure(Server server)\n        {\n            Logging.Debug(String.Format("failure: {0}", server.FriendlyName()));\n        }\n        void IStrategy.UpdateLastRead(Server server)\n        {
        {\n            Logging.Debug(String.Format("failure: {0}", server.FriendlyName()));\n        }\n        void IStrategy.UpdateLastRead(Server server)\n        {\n            //TODO: combine this part of data with ICMP statics\n        }\n        void IStrategy.UpdateLastWrite(Server server)\n        {\n            //TODO: combine this part of data with ICMP statics\n        }\n        void IStrategy.UpdateLatency(Server server, TimeSpan latency)
        {\n            //TODO: combine this part of data with ICMP statics\n        }\n        void IStrategy.UpdateLastWrite(Server server)\n        {\n            //TODO: combine this part of data with ICMP statics\n        }\n        void IStrategy.UpdateLatency(Server server, TimeSpan latency)\n        {\n            //TODO: combine this part of data with ICMP statics\n        }\n    }
        {\n            //TODO: combine this part of data with ICMP statics\n        }\n        void IStrategy.UpdateLatency(Server server, TimeSpan latency)\n        {\n            //TODO: combine this part of data with ICMP statics\n        }\n    }\n}
        {\n            //TODO: combine this part of data with ICMP statics\n        }\n    }\n}
            LoadServerNameListToUI(_modifiedConfiguration);\n            ServersListBox.SelectedIndex = _modifiedConfiguration.configs.Count - 1;\n            _lastSelectedIndex = ServersListBox.SelectedIndex;\n        }\n        private void DuplicateButton_Click(object sender, EventArgs e)\n        {\n            if (!ValidateAndSaveSelectedServerDetails())\n            {
            {\n                return;\n            }\n            Server currServer = _modifiedConfiguration.configs[_lastSelectedIndex];\n            var currIndex = _modifiedConfiguration.configs.IndexOf(currServer);\n            _modifiedConfiguration.configs.Insert(currIndex + 1, currServer);\n            LoadServerNameListToUI(_modifiedConfiguration);\n            ServersListBox.SelectedIndex = currIndex + 1;\n            _lastSelectedIndex = ServersListBox.SelectedIndex;\n        }
            }\n            // requested unregister, which has no side effect\n            else if (!register)\n            {\n                UnregisterApplicationRestart();\n                Logging.Debug("Unregister restart after system reboot");\n            }\n        }\n    }\n}
        {\n            // Check OS since we are using dual-mode socket\n            if (!Utils.IsWinVistaOrHigher())\n            {\n                MessageBox.Show(I18N.GetString("Unsupported operating system, use Windows Vista at least."),\n                "Shadowsocks Error", MessageBoxButtons.OK, MessageBoxIcon.Error);\n                return;\n            }\n            // Check .NET Framework version
        }\n        private byte[] mergeSort(byte[] array, UInt64 a, int j)\n        {\n            if (array.Length == 1)\n                return array;\n            int middle = array.Length / 2;\n            byte[] left = new byte[middle];\n            for (int i = 0; i < middle; i++)\n            {\n                left[i] = array[i];
        {\n            if (array.Length == 1)\n                return array;\n            int middle = array.Length / 2;\n            byte[] left = new byte[middle];\n            for (int i = 0; i < middle; i++)\n            {\n                left[i] = array[i];\n            }\n            byte[] right = new byte[array.Length - middle];
                SocketType.Stream, ProtocolType.Tcp);\n            IPEndPoint localEndPoint = new IPEndPoint(0, port);\n            // Bind the socket to the local endpoint and listen for incoming connections.\n                listener.Bind(localEndPoint);\n                listener.Listen(100);\n            // Start an asynchronous socket to listen for connections.\n            Console.WriteLine("Waiting for a connection...");\n            listener.BeginAccept(\n                new AsyncCallback(AcceptCallback),\n                listener);
            Application.EnableVisualStyles();\n            Application.SetCompatibleTextRenderingDefault(false);\n            Application.Run(new Form1());\n        }\n    }\n}
                }\n                else\n                {\n                    remote.Shutdown(SocketShutdown.Send);\n                    remoteShutdown = true;\n                    CheckClose();\n                }\n            }\n            catch (Exception e)\n            {
        private const string StatisticsFilesName = "shadowsocks.availability.csv";\n        private const string Delimiter = ",";\n        private const int Timeout = 500;\n        private const int DelayBeforeStart = 1000;\n        public Statistics RawStatistics { get; private set; }\n        public Statistics FilteredStatistics { get; private set; }\n        public static readonly DateTime UnknownDateTime = new DateTime(1970, 1, 1);\n        private int Repeat => _config.RepeatTimesNum;\n        private const int RetryInterval = 2 * 60 * 1000; //retry 2 minutes after failed\n        private int Interval => (int)TimeSpan.FromMinutes(_config.DataCollectionMinutes).TotalMilliseconds;
        public Statistics RawStatistics { get; private set; }\n        public Statistics FilteredStatistics { get; private set; }\n        public static readonly DateTime UnknownDateTime = new DateTime(1970, 1, 1);\n        private int Repeat => _config.RepeatTimesNum;\n        private const int RetryInterval = 2 * 60 * 1000; //retry 2 minutes after failed\n        private int Interval => (int)TimeSpan.FromMinutes(_config.DataCollectionMinutes).TotalMilliseconds;\n        private Timer _timer;\n        private State _state;\n        private List<Server> _servers;
        private Timer _timer;\n        private State _state;\n        private List<Server> _servers;\n        private StatisticsStrategyConfiguration _config;\n        public static string AvailabilityStatisticsFile;
        }\n        public bool Set(StatisticsStrategyConfiguration config)\n        {\n            _config = config;\n            try\n            {\n                if (config.StatisticsEnabled)\n                {\n                    if (_timer?.Change(DelayBeforeStart, Interval) == null)\n                    {
                    Append(dataList, geolocationAndIsp.Result);\n                }\n            }\n        }\n        private static void Append(DataList dataList, IEnumerable<DataUnit> extra)\n        {\n            var data = dataList.Concat(extra);\n            var dataLine = string.Join(Delimiter, data.Select(kv => kv.Value).ToArray());\n            string[] lines;\n            if (!File.Exists(AvailabilityStatisticsFile))
                try\n                {\n                    process.WaitForExit();\n                }\n                catch (InvalidOperationException)\n                {\n                    // do nothing\n                }\n                process = null;
            {\n                usedPorts.Add(endPoint.Port);
            }\n            for (int port = 8123; port < 65535; port++)\n            {\n                if (!usedPorts.Contains(port))\n                {\n                    return port;\n                }\n            }
            {\n                if (!usedPorts.Contains(port))\n                {\n                    return port;\n                }\n            }\n            throw new Exception("No free port found.");\n        }
            }\n            throw new Exception("No free port found.");\n        }\n    }\n}
            SwitchAllowLanTextBox.Text = config.SwitchAllowLan;\n            ShowLogsTextBox.Text = config.ShowLogs;\n            ServerMoveUpTextBox.Text = config.ServerMoveUp;\n            ServerMoveDownTextBox.Text = config.ServerMoveDown;\n        }\n        private void UpdateTexts()\n        {\n            // I18N stuff\n            SwitchSystemProxyLabel.Text = I18N.GetString("Switch system proxy");\n            ChangeToPacLabel.Text = I18N.GetString("Switch to PAC mode");\n            ChangeToGlobalLabel.Text = I18N.GetString("Switch to Global mode");
            SwitchAllowLanLabel.Text = I18N.GetString("Switch share over LAN");\n            ShowLogsLabel.Text = I18N.GetString("Show Logs");\n            ServerMoveUpLabel.Text = I18N.GetString("Switch to prev server");\n            ServerMoveDownLabel.Text = I18N.GetString("Switch to next server");\n            btnOK.Text = I18N.GetString("OK");\n            btnCancel.Text = I18N.GetString("Cancel");\n            btnRegisterAll.Text = I18N.GetString("Reg All");\n            this.Text = I18N.GetString("Edit Hotkeys...");\n        }\n        /// <summary>
        public string SwitchAllowLan;\n        public string ShowLogs;\n        public string ServerMoveUp;\n        public string ServerMoveDown;\n        public HotkeyConfig()\n        {\n            SwitchSystemProxy = "";\n            ChangeToPac = "";\n            ChangeToGlobal = "";
            SwitchAllowLan = "";\n            ShowLogs = "";\n            ServerMoveUp = "";\n            ServerMoveDown = "";\n        }\n    }\n}
            this.SwitchAllowLanLabel = new System.Windows.Forms.Label();\n            this.ShowLogsLabel = new System.Windows.Forms.Label();\n            this.ServerMoveUpLabel = new System.Windows.Forms.Label();\n            this.ServerMoveDownLabel = new System.Windows.Forms.Label();\n            this.SwitchSystemProxyTextBox = new System.Windows.Forms.TextBox();\n            this.ChangeToPacTextBox = new System.Windows.Forms.TextBox();\n            this.ChangeToGlobalTextBox = new System.Windows.Forms.TextBox();\n            this.SwitchAllowLanTextBox = new System.Windows.Forms.TextBox();\n            this.ShowLogsTextBox = new System.Windows.Forms.TextBox();
            this.SwitchAllowLanTextBox = new System.Windows.Forms.TextBox();\n            this.ShowLogsTextBox = new System.Windows.Forms.TextBox();\n            this.ServerMoveUpTextBox = new System.Windows.Forms.TextBox();\n            this.ServerMoveDownTextBox = new System.Windows.Forms.TextBox();\n            flowLayoutPanel1 = new System.Windows.Forms.FlowLayoutPanel();\n            flowLayoutPanel1.SuspendLayout();\n            this.tableLayoutPanel1.SuspendLayout();\n            this.SuspendLayout();\n            // \n            // flowLayoutPanel1
            this.tableLayoutPanel1.Controls.Add(this.SwitchSystemProxyTextBox, 1, 0);\n            this.tableLayoutPanel1.Controls.Add(this.ChangeToPacTextBox, 1, 1);\n            this.tableLayoutPanel1.Controls.Add(this.ChangeToGlobalTextBox, 1, 2);\n            this.tableLayoutPanel1.Controls.Add(this.SwitchAllowLanTextBox, 1, 3);\n            this.tableLayoutPanel1.Controls.Add(this.ShowLogsTextBox, 1, 4);\n            this.tableLayoutPanel1.Controls.Add(this.ServerMoveUpTextBox, 1, 5);\n            this.tableLayoutPanel1.Controls.Add(this.ServerMoveDownTextBox, 1, 6);\n            this.tableLayoutPanel1.Dock = System.Windows.Forms.DockStyle.Fill;\n            this.tableLayoutPanel1.Location = new System.Drawing.Point(0, 0);\n            this.tableLayoutPanel1.Name = "tableLayoutPanel1";
            this.tableLayoutPanel1.Dock = System.Windows.Forms.DockStyle.Fill;\n            this.tableLayoutPanel1.Location = new System.Drawing.Point(0, 0);\n            this.tableLayoutPanel1.Name = "tableLayoutPanel1";
        private System.Windows.Forms.Label SwitchAllowLanLabel;\n        private System.Windows.Forms.Label ShowLogsLabel;\n        private System.Windows.Forms.Label ServerMoveUpLabel;\n        private System.Windows.Forms.Label ServerMoveDownLabel;\n        private System.Windows.Forms.Button btnOK;\n        private System.Windows.Forms.Button btnCancel;\n        private System.Windows.Forms.TextBox ShowLogsTextBox;\n        private System.Windows.Forms.TextBox SwitchAllowLanTextBox;\n        private System.Windows.Forms.TextBox ChangeToGlobalTextBox;\n        private System.Windows.Forms.TextBox ChangeToPacTextBox;
        private System.Windows.Forms.TextBox SwitchSystemProxyTextBox;\n        private System.Windows.Forms.TextBox ServerMoveUpTextBox;\n        private System.Windows.Forms.TextBox ServerMoveDownTextBox;\n        private System.Windows.Forms.Button btnRegisterAll;\n        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel1;\n    }\n}
                string[] runList = runKey.GetValueNames();\n                foreach (string item in runList)\n                {\n                    if (item.Equals(Key))\n                        return true;\n                    else if (item.Equals("Shadowsocks")) // Compatibility with older versions\n                    {\n                        string value = Convert.ToString(runKey.GetValue(item));\n                        if (path.Equals(value, StringComparison.InvariantCultureIgnoreCase))\n                        {
                        return true;\n                    else if (item.Equals("Shadowsocks")) // Compatibility with older versions\n                    {\n                        string value = Convert.ToString(runKey.GetValue(item));\n                        if (path.Equals(value, StringComparison.InvariantCultureIgnoreCase))\n                        {\n                            runKey.DeleteValue(item);\n                            runKey.SetValue(Key, path);\n                            return true;\n                        }
                    {\n                        string value = Convert.ToString(runKey.GetValue(item));\n                        if (path.Equals(value, StringComparison.InvariantCultureIgnoreCase))\n                        {\n                            runKey.DeleteValue(item);\n                            runKey.SetValue(Key, path);\n                            return true;\n                        }\n                    }\n                }
        private IntPtr handle = IntPtr.Zero;\n        private bool disposed;\n        public Job()\n        {\n            handle = CreateJobObject(IntPtr.Zero, null);\n            var extendedInfoPtr = IntPtr.Zero;\n            var info = new JOBOBJECT_BASIC_LIMIT_INFORMATION\n            {\n                LimitFlags = 0x2000\n            };
        public Job()\n        {\n            handle = CreateJobObject(IntPtr.Zero, null);\n            var extendedInfoPtr = IntPtr.Zero;\n            var info = new JOBOBJECT_BASIC_LIMIT_INFORMATION\n            {\n                LimitFlags = 0x2000\n            };\n            var extendedInfo = new JOBOBJECT_EXTENDED_LIMIT_INFORMATION\n            {


            this.tableLayoutPanel1.ResumeLayout(false);\n            this.tableLayoutPanel1.PerformLayout();\n            this.panel1.ResumeLayout(false);\n            this.contextMenuStrip1.ResumeLayout(false);\n            this.ResumeLayout(false);\n            this.PerformLayout();\n        }\n        #endregion\n        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel1;\n        private System.Windows.Forms.Label label1;
        }\n        public void Close()\n        {\n            connection.Close();\n            remote.Close();\n        }\n        private void connectCallback(IAsyncResult ar)
        }\n        private void connectCallback(IAsyncResult ar)\n        {\n            try\n            {\n                // Complete the connection.\n                remote.EndConnect(ar);\n                Console.WriteLine("Socket connected to {0}",\n                    remote.RemoteEndPoint.ToString());\n                handshakeReceive();
using System.Text;\nusing System.IO;\nusing System.Diagnostics;\nnamespace shadowsocks_csharp\n{\n    [Serializable]\n    public class Config\n    {\n        public string server;
        public bool isDefault;\n        private static void assert(bool condition)\n        {\n            if(!condition) \n            {\n                throw new Exception("assertion failure");\n            }\n        }\n        public static Config Load()\n        {
            try\n            {\n                using (FileStream fs = File.OpenRead(@"config.json"))\n                {\n                    Config config = ser.ReadObject(fs) as Config;\n                    assert(!string.IsNullOrEmpty(config.server));\n                    assert(!string.IsNullOrEmpty(config.password));\n                    assert(config.local_port > 0);\n                    assert(config.server_port > 0);\n                    config.isDefault = false;
                {\n                    Config config = ser.ReadObject(fs) as Config;\n                    assert(!string.IsNullOrEmpty(config.server));\n                    assert(!string.IsNullOrEmpty(config.password));\n                    assert(config.local_port > 0);\n                    assert(config.server_port > 0);\n                    config.isDefault = false;\n                    return config;\n                }\n            }
                    assert(!string.IsNullOrEmpty(config.server));\n                    assert(!string.IsNullOrEmpty(config.password));\n                    assert(config.local_port > 0);\n                    assert(config.server_port > 0);\n                    config.isDefault = false;\n                    return config;\n                }\n            }\n            catch (Exception e)\n            {
            try\n            {\n                using (FileStream fs = File.Open(@"config.json", FileMode.Create))\n                {\n                    ser.WriteObject(fs, config);
                {\n                    ser.WriteObject(fs, config);
                }\n            }\n            catch (IOException e)\n            {\n                Console.Error.WriteLine(e);\n            }\n        }\n    }\n}
                }),\n                this.ServersItem = CreateMenuGroup("Servers", new System.Windows.Forms.MenuItem[] {\n                    this.SeperatorItem = new MenuItem("-"),\n                    this.ConfigItem = CreateMenuItem("Edit Servers...", new System.EventHandler(this.Config_Click))\n                }),\n                new MenuItem("-"),\n                this.AutoStartupItem = CreateMenuItem("Start on Boot", new System.EventHandler(this.AutoStartupItem_Click)),\n                this.ShareOverLANItem = CreateMenuItem("Share over LAN", new System.EventHandler(this.ShareOverLANItem_Click)),\n                CreateMenuItem("Edit PAC File...", new System.EventHandler(this.EditPACFileItem_Click)),\n                new MenuItem("-"),
                    this.SeperatorItem = new MenuItem("-"),\n                    this.ConfigItem = CreateMenuItem("Edit Servers...", new System.EventHandler(this.Config_Click))\n                }),\n                new MenuItem("-"),\n                this.AutoStartupItem = CreateMenuItem("Start on Boot", new System.EventHandler(this.AutoStartupItem_Click)),\n                this.ShareOverLANItem = CreateMenuItem("Share over LAN", new System.EventHandler(this.ShareOverLANItem_Click)),\n                CreateMenuItem("Edit PAC File...", new System.EventHandler(this.EditPACFileItem_Click)),\n                new MenuItem("-"),\n                CreateMenuItem("Show QRCode...", new System.EventHandler(this.QRCodeItem_Click)),\n                CreateMenuItem("Show Logs...", new System.EventHandler(this.ShowLogItem_Click)),
                }),\n                new MenuItem("-"),\n                this.AutoStartupItem = CreateMenuItem("Start on Boot", new System.EventHandler(this.AutoStartupItem_Click)),\n                this.ShareOverLANItem = CreateMenuItem("Share over LAN", new System.EventHandler(this.ShareOverLANItem_Click)),\n                CreateMenuItem("Edit PAC File...", new System.EventHandler(this.EditPACFileItem_Click)),\n                new MenuItem("-"),\n                CreateMenuItem("Show QRCode...", new System.EventHandler(this.QRCodeItem_Click)),\n                CreateMenuItem("Show Logs...", new System.EventHandler(this.ShowLogItem_Click)),\n                CreateMenuItem("About...", new System.EventHandler(this.Config_Click)),\n                new MenuItem("-"),
                new MenuItem("-"),\n                CreateMenuItem("Show QRCode...", new System.EventHandler(this.QRCodeItem_Click)),\n                CreateMenuItem("Show Logs...", new System.EventHandler(this.ShowLogItem_Click)),\n                CreateMenuItem("About...", new System.EventHandler(this.Config_Click)),\n                new MenuItem("-"),\n                CreateMenuItem("Quit", new System.EventHandler(this.Quit_Click))\n            });\n        }\n        private void controller_ConfigChanged(object sender, EventArgs e)\n        {
                new MenuItem("-"),\n                CreateMenuItem("Quit", new System.EventHandler(this.Quit_Click))\n            });\n        }\n        private void controller_ConfigChanged(object sender, EventArgs e)\n        {\n            LoadCurrentConfiguration();\n            UpdateTrayIcon();\n        }\n        private void controller_EnableStatusChanged(object sender, EventArgs e)
            });\n        }\n        private void controller_ConfigChanged(object sender, EventArgs e)\n        {\n            LoadCurrentConfiguration();\n            UpdateTrayIcon();\n        }\n        private void controller_EnableStatusChanged(object sender, EventArgs e)\n        {\n            enableItem.Checked = controller.GetConfiguration().enabled;
            }\n            LoadLibrary(dllPath);\n        }\n        [DllImport("Kernel32.dll")]\n        private static extern IntPtr LoadLibrary(string path);\n        public const int MD5_CTX_SIZE = 88;\n        public static byte[] MD5(byte[] input)\n        {\n            byte[] output = new byte[16];\n            MbedTLS.md5(input, (uint)input.Length, output);
        public static byte[] MD5(byte[] input)\n        {\n            byte[] output = new byte[16];\n            MbedTLS.md5(input, (uint)input.Length, output);\n            return output;\n        }\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void md5(byte[] input, uint ilen, byte[] output);
            return output;\n        }\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void md5(byte[] input, uint ilen, byte[] output);
    }\n}
        private static readonly ConcurrentDictionary<string, byte[]> CachedKeys = new ConcurrentDictionary<string, byte[]>();\n        protected byte[] _encryptIV;\n        protected byte[] _decryptIV;\n        protected bool _decryptIVReceived;\n        protected bool _encryptIVSent;\n        protected int _encryptIVOffset = 0;\n        protected int _decryptIVOffset = 0;\n        protected string _method;\n        protected int _cipher;
        protected string _method;\n        protected int _cipher;\n        protected int[] _cipherInfo;\n        protected byte[] _key;\n        protected int keyLen;\n        protected int ivLen;\n        protected uint counter = 0;\n        protected byte[] _keyBuffer = null;\n        public IVEncryptor(string method, string password, bool onetimeauth, bool isudp)
        protected void InitKey(string method, string password)\n        {\n            method = method.ToLower();\n            _method = method;\n            string k = method + ":" + password;\n            ciphers = getCiphers();\n            _cipherInfo = ciphers[_method];
            _cipher = _cipherInfo[2];\n            if (_cipher == 0)\n            {\n                throw new Exception("method not found");\n            }\n            keyLen = ciphers[_method][0];\n            ivLen = ciphers[_method][1];\n            _key = CachedKeys.GetOrAdd(k, (nk) =>\n            {\n                byte[] passbuf = Encoding.UTF8.GetBytes(password);
            _key = CachedKeys.GetOrAdd(k, (nk) =>\n            {\n                byte[] passbuf = Encoding.UTF8.GetBytes(password);\n                byte[] key = new byte[32];\n                byte[] iv = new byte[16];\n                bytesToKey(passbuf, key);\n                return key;\n            });\n        }\n        protected void bytesToKey(byte[] password, byte[] key)
        };\n        protected override Dictionary<string, int[]> getCiphers()\n        {\n            return _ciphers;\n        }\n        public static List<string> SupportedCiphers()\n        {\n            return new List<string>(_ciphers.Keys);\n        }\n        protected override void cipherUpdate(bool isCipher, int length, byte[] buf, byte[] outbuf)
        {\n            return _ciphers;\n        }\n        public static List<string> SupportedCiphers()\n        {\n            return new List<string>(_ciphers.Keys);\n        }\n        protected override void cipherUpdate(bool isCipher, int length, byte[] buf, byte[] outbuf)\n        {\n            // TODO write a unidirection cipher so we don't have to if if if
        {\n            // run it once before the multi-threading test to initialize global tables\n            RunSinglePolarSSLEncryptionThread();\n            List<Thread> threads = new List<Thread>();\n            for (int i = 0; i < 10; i++)\n            {\n                Thread t = new Thread(new ThreadStart(RunSinglePolarSSLEncryptionThread));\n                threads.Add(t);\n                t.Start();\n            }\n            foreach (Thread t in threads)
                threads.Add(t);\n                t.Start();\n            }\n            foreach (Thread t in threads)\n            {\n                t.Join();\n            }\n            Assert.IsFalse(encryptionFailed);\n        }\n        private void RunSinglePolarSSLEncryptionThread()
        {\n            try\n            {\n                for (int i = 0; i < 100; i++)\n                {\n                    IEncryptor encryptor;\n                    IEncryptor decryptor;\n                    encryptor = new PolarSSLEncryptor("aes-256-cfb", "barfoo!", false, false);\n                    decryptor = new PolarSSLEncryptor("aes-256-cfb", "barfoo!", false, false);\n                    RunEncryptionRound(encryptor, decryptor);
                    RunEncryptionRound(encryptor, decryptor);\n                }\n            }\n            catch\n            {\n                encryptionFailed = true;\n                throw;\n            }\n        }\n        [TestMethod]
            Logging.Dump("after cipherEncrypt: cipher", ciphertext, (int) encClen);\n            clen = (uint) encClen;\n            return ret;\n        }\n        public override int cipherDecrypt(byte[] ciphertext, uint clen, byte[] plaintext, ref uint plen)\n        {\n            Debug.Assert(_sodiumDecSubkey != null);\n            // buf: ciphertext + tag\n            // outbuf: plaintext\n            int ret;
        }\n        public override int cipherDecrypt(byte[] ciphertext, uint clen, byte[] plaintext, ref uint plen)\n        {\n            Debug.Assert(_sodiumDecSubkey != null);\n            // buf: ciphertext + tag\n            // outbuf: plaintext\n            int ret;\n            ulong decPlen = 0;\n            Logging.Dump("_decNonce before dec", _decNonce, nonceLen);\n            Logging.Dump("_sodiumDecSubkey", _sodiumDecSubkey, keyLen);
        {\n            Debug.Assert(_sodiumDecSubkey != null);\n            // buf: ciphertext + tag\n            // outbuf: plaintext\n            int ret;\n            ulong decPlen = 0;\n            Logging.Dump("_decNonce before dec", _decNonce, nonceLen);\n            Logging.Dump("_sodiumDecSubkey", _sodiumDecSubkey, keyLen);\n            Logging.Dump("before cipherDecrypt: cipher", ciphertext, (int) clen);\n            switch (_cipher)
            Logging.Dump("after cipherDecrypt: plain", plaintext, (int) decPlen);\n            plen = (uint) decPlen;\n            return ret;\n        }\n        public override void Dispose()\n        {\n        }\n    }\n}
        }\n        public override void Dispose()\n        {\n        }\n    }\n}
            {\n                _registeredEncryptors.Add(method, typeof(StreamMbedTLSEncryptor));\n            }\n            foreach (string method in StreamSodiumEncryptor.SupportedCiphers())\n            {\n                _registeredEncryptors.Add(method, typeof(StreamSodiumEncryptor));
            }\n            foreach (string method in StreamSodiumEncryptor.SupportedCiphers())\n            {\n                _registeredEncryptors.Add(method, typeof(StreamSodiumEncryptor));
            }\n            foreach (string method in AEADMbedTLSEncryptorSupportedCiphers)\n            {\n                _registeredEncryptors.Add(method, typeof(AEADMbedTLSEncryptor));\n            }\n            foreach (string method in AEADSodiumEncryptorSupportedCiphers)\n            {\n                _registeredEncryptors.Add(method, typeof(AEADSodiumEncryptor));\n            }
            }\n        }\n        public static IEncryptor GetEncryptor(string method, string password)\n        {\n            if (method.IsNullOrEmpty())\n            {\n                method = "aes-256-cfb";\n            }\n            method = method.ToLowerInvariant();\n            Type t = _registeredEncryptors[method];
                    Debug.Assert(olen == plen);\n                    // attach tag to ciphertext\n                    Array.Copy(tagbuf, 0, ciphertext, (int) plen, tagLen);\n                    clen = olen + (uint) tagLen;\n                    return ret;\n                default:\n                    throw new System.Exception("not implemented");\n            }\n        }\n        public override int cipherDecrypt(byte[] ciphertext, uint clen, byte[] plaintext, ref uint plen)\n        {
                default:\n                    throw new System.Exception("not implemented");\n            }\n        }\n        public override int cipherDecrypt(byte[] ciphertext, uint clen, byte[] plaintext, ref uint plen)\n        {\n            // buf: ciphertext + tag\n            // outbuf: plaintext\n            int ret;\n            uint olen = 0;
        {\n            // buf: ciphertext + tag\n            // outbuf: plaintext\n            int ret;\n            uint olen = 0;\n            // split tag\n            byte[] tagbuf = new byte[tagLen];\n            Array.Copy(ciphertext, (int) (clen - tagLen), tagbuf, 0, tagLen);\n            switch (_cipher)\n            {
                    Debug.Assert(olen == clen - tagLen);\n                    plen = olen;\n                    return ret;\n                default:\n                    throw new System.Exception("not implemented");\n            }\n        }\n        #region IDisposable\n        private bool _disposed;\n        // instance based lock
                default:\n                    throw new System.Exception("not implemented");\n            }\n        }\n        #region IDisposable\n        private bool _disposed;\n        // instance based lock\n        private readonly object _lock = new object();\n        public override void Dispose()\n        {
            this.FileMenuItem = new System.Windows.Forms.MenuItem();\n            this.OpenLocationMenuItem = new System.Windows.Forms.MenuItem();\n            this.ExitMenuItem = new System.Windows.Forms.MenuItem();\n            this.panel1 = new System.Windows.Forms.Panel();
            this.ChangeFontButton = new System.Windows.Forms.Button();\n            this.CleanLogsButton = new System.Windows.Forms.Button();\n            this.WrapTextCheckBox = new System.Windows.Forms.CheckBox();\n            this.tableLayoutPanel1 = new System.Windows.Forms.TableLayoutPanel();\n            this.TopMostCheckBox = new System.Windows.Forms.CheckBox();\n            this.panel1.SuspendLayout();\n            this.tableLayoutPanel1.SuspendLayout();
            this.tableLayoutPanel1.SuspendLayout();
            // \n            // ChangeFontButton\n            // \n            this.ChangeFontButton.Location = new System.Drawing.Point(107, 4);\n            this.ChangeFontButton.Name = "ChangeFontButton";\n            this.ChangeFontButton.Size = new System.Drawing.Size(75, 23);\n            this.ChangeFontButton.TabIndex = 2;\n            this.ChangeFontButton.Text = "&Font";\n            this.ChangeFontButton.UseVisualStyleBackColor = true;\n            this.ChangeFontButton.Click += new System.EventHandler(this.ChangeFontButton_Click);\n            // \n            // CleanLogsButton\n            this.CleanLogsButton.Location = new System.Drawing.Point(9, 4);
            this.ChangeFontButton.Name = "ChangeFontButton";\n            this.ChangeFontButton.Size = new System.Drawing.Size(75, 23);\n            this.ChangeFontButton.TabIndex = 2;\n            this.ChangeFontButton.Text = "&Font";\n            this.ChangeFontButton.UseVisualStyleBackColor = true;\n            this.ChangeFontButton.Click += new System.EventHandler(this.ChangeFontButton_Click);\n            // \n            // CleanLogsButton\n            // \n            this.CleanLogsButton.Location = new System.Drawing.Point(9, 4);\n            this.CleanLogsButton.Name = "CleanLogsButton";\n            this.CleanLogsButton.Size = new System.Drawing.Size(75, 23);
            this.CleanLogsButton.Name = "CleanLogsButton";\n            this.CleanLogsButton.Size = new System.Drawing.Size(75, 23);\n            this.CleanLogsButton.TabIndex = 1;\n            this.CleanLogsButton.Text = "&Clean logs";\n            this.CleanLogsButton.UseVisualStyleBackColor = true;\n            this.CleanLogsButton.Click += new System.EventHandler(this.CleanLogsButton_Click);\n            // \n            // WrapTextCheckBox\n            // \n            this.WrapTextCheckBox.AutoSize = true;
            this.tableLayoutPanel1.Controls.Add(this.LogMessageTextBox, 0, 1);\n            this.tableLayoutPanel1.Dock = System.Windows.Forms.DockStyle.Fill;\n            this.tableLayoutPanel1.Location = new System.Drawing.Point(0, 0);\n            this.tableLayoutPanel1.Name = "tableLayoutPanel1";\n            this.tableLayoutPanel1.RowCount = 2;\n            this.tableLayoutPanel1.Size = new System.Drawing.Size(547, 353);\n            this.tableLayoutPanel1.TabIndex = 2;
            this.tableLayoutPanel1.TabIndex = 2;\n            // \n            // TopMostCheckBox\n            // \n            this.TopMostCheckBox.AutoSize = true;\n            this.TopMostCheckBox.Location = new System.Drawing.Point(311, 9);\n            this.TopMostCheckBox.Name = "TopMostCheckBox";\n            this.TopMostCheckBox.Size = new System.Drawing.Size(72, 16);\n            this.TopMostCheckBox.TabIndex = 3;\n            this.TopMostCheckBox.Text = "&Top most";\n            this.TopMostCheckBox.UseVisualStyleBackColor = true;

            this.tableLayoutPanel1.ResumeLayout(false);\n            this.tableLayoutPanel1.PerformLayout();\n            this.ResumeLayout(false);\n        }\n        #endregion\n        private System.Windows.Forms.TextBox LogMessageTextBox;\n        private System.Windows.Forms.ContextMenuStrip contextMenuStrip1;\n        private System.Windows.Forms.MainMenu mainMenu1;\n        private System.Windows.Forms.MenuItem FileMenuItem;
        private System.Windows.Forms.MenuItem FileMenuItem;\n        private System.Windows.Forms.MenuItem OpenLocationMenuItem;\n        private System.Windows.Forms.MenuItem ExitMenuItem;\n        private System.Windows.Forms.Panel panel1;\n        private System.Windows.Forms.CheckBox WrapTextCheckBox;\n        private System.Windows.Forms.Button CleanLogsButton;\n        private System.Windows.Forms.Button ChangeFontButton;\n        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel1;\n        private System.Windows.Forms.CheckBox TopMostCheckBox;
        private System.Windows.Forms.CheckBox WrapTextCheckBox;\n        private System.Windows.Forms.Button CleanLogsButton;\n        private System.Windows.Forms.Button ChangeFontButton;\n        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel1;\n        private System.Windows.Forms.CheckBox TopMostCheckBox;
        }\n        private void CleanLogsButton_Click(object sender, EventArgs e)\n        {\n            LogMessageTextBox.Clear();\n        }\n        private void ChangeFontButton_Click(object sender, EventArgs e)\n        {\n            FontDialog fd = new FontDialog();\n            fd.Font = LogMessageTextBox.Font;
        {\n            FontDialog fd = new FontDialog();\n            fd.Font = LogMessageTextBox.Font;\n            if (fd.ShowDialog() == DialogResult.OK)\n            {\n                LogMessageTextBox.Font = fd.Font;\n            }\n        }
        }\n    }\n}
                        {\n                            case 1: // IPv4 address, 4 bytes\n                                ReadAddress(4 + 2 - 1);\n                                break;\n                            case 3: // domain name, length + str\n                                int len = _connetionRecvBuffer[4];\n                                ReadAddress(len + 2);\n                                break;\n                            case 4: // IPv6 address, 16 bytes\n                                ReadAddress(16 + 2 - 1);
                        }\n                    }\n                }\n                else\n                {\n                    Logging.Debug("failed to recv data in Shadowsocks.Controller.TCPHandler.handshakeReceive2Callback()");\n                    Close();\n                }\n            }\n            catch (Exception e)
        {\n            Array.Copy(_connetionRecvBuffer, 3, _connetionRecvBuffer, 0, 2);\n            // Read the remain address bytes\n            _connection.BeginReceive(_connetionRecvBuffer, 2, RecvSize - 2, SocketFlags.None, OnAddressFullyRead, bytesRemain);\n        }\n        private void OnAddressFullyRead(IAsyncResult ar)\n        {\n            if (_closed) return;\n            try\n            {\n                int bytesRead = _connection.EndReceive(ar);
        }\n        private void OnAddressFullyRead(IAsyncResult ar)\n        {\n            if (_closed) return;\n            try\n            {\n                int bytesRead = _connection.EndReceive(ar);\n                int bytesRemain = (int) ar.AsyncState;
                if (bytesRead >= bytesRemain)\n                {\n                    _firstPacketLength = bytesRead + 2;\n                    int atyp = _connetionRecvBuffer[0];\n                    string dst_addr = "Unknown";\n                    int dst_port = -1;\n                    switch (atyp)\n                    {\n                        case 1: // IPv4 address, 4 bytes\n                            dst_addr = new IPAddress(_connetionRecvBuffer.Skip(1).Take(4).ToArray()).ToString();
            }\n            else\n            {\n                return remarks + " (" + server + ":" + server_port + ")";\n            }\n        }\n        public Server()\n        {\n            server = "";
        }\n        public Server()\n        {\n            server = "";\n            server_port = 8388;\n            method = "aes-256-cfb";\n            password = "";\n            remarks = "";\n            auth = false;\n        }
            if (_requestLineCount == 0)\n            {\n                var m = HttpRequestHeaderRegex.Match(line);\n                if (m.Success)\n                {\n                    var method = m.Groups[1].Value;\n                    if (method == "CONNECT")\n                    {
                    if (method == "CONNECT")\n                    {\n                        _isConnect = true;\n                        if (!ParseHost(m.Groups[2].Value))\n                        {\n                            throw new Exception("Bad http header: " + line);\n                        }\n                    }\n                }\n            }
                        {\n                            throw new Exception("Bad http header: " + line);\n                        }\n                    }\n                }\n            }\n            else\n            {
                if (line.IsNullOrEmpty())\n                {\n                    return true;\n                }\n                if (!_isConnect)\n                {\n                    if (line.StartsWith("Host: "))\n                    {\n                        if (!ParseHost(line.Substring(6).Trim()))\n                        {
                    byte[] response = { 5, 0, 0, 1, 0, 0, 0, 0, 0, 0 };\n                    connection.BeginSend(response, 0, response.Length, 0, new AsyncCallback(StartPipe), null);\n                }\n                else\n                {\n                    Console.WriteLine("failed to recv data in handshakeReceive2Callback");\n                    this.Close();\n                }\n            }\n            catch (Exception e)
                }\n                else\n                {\n                    Console.WriteLine("failed to recv data in handshakeReceive2Callback");\n                    this.Close();\n                }\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);
            this.PACUrlTextBox.MaxLength = 256;\n            this.PACUrlTextBox.Name = "PACUrlTextBox";\n            this.PACUrlTextBox.Size = new System.Drawing.Size(245, 20);\n            this.PACUrlTextBox.TabIndex = 4;\n            this.PACUrlTextBox.WordWrap = false;\n            // \n            // PACUrlLabel\n            // \n            this.PACUrlLabel.AutoSize = true;\n            this.PACUrlLabel.Location = new System.Drawing.Point(6, 15);\n            this.PACUrlLabel.Name = "PACUrlLabel";
            this.PACUrlLabel.Name = "PACUrlLabel";\n            this.PACUrlLabel.Size = new System.Drawing.Size(44, 13);\n            this.PACUrlLabel.TabIndex = 3;\n            this.PACUrlLabel.Text = "PAC Url";\n            // \n            // OkButton\n            // 
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedSingle;\n            this.MaximizeBox = false;\n            this.MinimizeBox = false;\n            this.Name = "PACUrlForm";\n            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;\n            this.Text = "Update Online PAC URL";\n            this.Load += new System.EventHandler(this.PACUrlForm_Load);
#else\n         // Silverlight supports only UTF-8 and UTF-16 out-of-the-box\n         const string encoding = "UTF-8";\n         // caller of the method can only control if the ECI segment should be written\n         // character set is fixed to UTF-8; but some scanners doesn't like the ECI segment\n         bool generateECI = (hints != null && hints.ContainsKey(EncodeHintType.CHARACTER_SET));\n#endif\n         // Pick an encoding mode appropriate for the content. Note that this will not attempt to use\n         // multiple modes / segments even if that were more efficient. Twould be nice.\n         Mode mode = Mode.BYTE;\n         // This will store the header information, like mode and\n         // length, as well as "header" segments like an ECI segment.\n         BitArray headerBits = new BitArray();\n         /*\n          // Append ECI segment if applicable\n         if (mode == Mode.BYTE && generateECI)\n         {\n            CharacterSetECI eci = CharacterSetECI.getCharacterSetECIByName(encoding);\n            if (eci != null)
         // This will store the header information, like mode and\n         // length, as well as "header" segments like an ECI segment.\n         BitArray headerBits = new BitArray();\n         /*\n          // Append ECI segment if applicable\n         if (mode == Mode.BYTE && generateECI)\n         {\n            CharacterSetECI eci = CharacterSetECI.getCharacterSetECIByName(encoding);\n            if (eci != null)\n            {\n               var eciIsExplicitDisabled = (hints != null && hints.ContainsKey(EncodeHintType.DISABLE_ECI) ? (bool)hints[EncodeHintType.DISABLE_ECI] : false);\n               if (!eciIsExplicitDisabled)
         // (With ECI in place,) Write the mode marker\n         appendModeInfo(mode, headerBits);\n         // Collect data within the main segment, separately, to count its size if needed. Don't add it to\n         // main payload yet.\n         BitArray dataBits = new BitArray();\n         appendBytes(content, mode, dataBits, encoding);\n         // Hard part: need to know version to know how many bits length takes. But need to know how many\n         // bits it takes to know version. First we take a guess at version by assuming version will be\n         // the minimum, 1:\n         int provisionalBitsNeeded = headerBits.Size
      }\n      /// <summary>\n      /// Terminate bits as described in 8.4.8 and 8.4.9 of JISX0510:2004 (p.24).\n      /// </summary>\n      /// <param name="numDataBytes">The num data bytes.</param>\n      /// <param name="bits">The bits.</param>\n      internal static void terminateBits(int numDataBytes, BitArray bits)\n      {\n         int capacity = numDataBytes << 3;\n         if (bits.Size > capacity)\n             throw new Exception("data bits cannot fit in the QR Code" + bits.Size + " > " +\n                capacity);\n         }\n         for (int i = 0; i < 4 && bits.Size < capacity; ++i)
         }\n         // 5 = 4 + 1.\n         if (numRSBlocks != numRsBlocksInGroup1 + numRsBlocksInGroup2)\n         {\n             throw new Exception("RS blocks mismatch");\n         }\n         // 196 = (13 + 26) * 4 + (14 + 26) * 1\n         if (numTotalBytes !=\n             ((numDataBytesInGroup1 + numEcBytesInGroup1) *\n                 numRsBlocksInGroup1) +\n                 ((numDataBytesInGroup2 + numEcBytesInGroup2) *
         }\n         // 196 = (13 + 26) * 4 + (14 + 26) * 1\n         if (numTotalBytes !=\n             ((numDataBytesInGroup1 + numEcBytesInGroup1) *\n                 numRsBlocksInGroup1) +\n                 ((numDataBytesInGroup2 + numEcBytesInGroup2) *\n                     numRsBlocksInGroup2))\n         {\n             throw new Exception("Total bytes mismatch");\n         }\n         if (blockID < numRsBlocksInGroup1)
         }\n         if (blockID < numRsBlocksInGroup1)\n         {\n            numDataBytesInBlock[0] = numDataBytesInGroup1;\n            numECBytesInBlock[0] = numEcBytesInGroup1;\n         }\n         else\n         {\n            numDataBytesInBlock[0] = numDataBytesInGroup2;\n            numECBytesInBlock[0] = numEcBytesInGroup2;
         }\n         bits.appendBits(numLetters, numBits);\n      }\n      /// <summary>\n      /// Append "bytes" in "mode" mode (encoding) into "bits". On success, store the result in "bits".\n      /// </summary>\n      /// <param name="content">The content.</param>\n      /// <param name="mode">The mode.</param>\n      /// <param name="bits">The bits.</param>\n      /// <param name="encoding">The encoding.</param>
      }\n      internal static void append8BitBytes(String content, BitArray bits, String encoding)\n      {\n         byte[] bytes;\n         try\n         {\n            bytes = Encoding.GetEncoding(encoding).GetBytes(content);\n         }\n#if WindowsCE\n         catch (PlatformNotSupportedException)
         }\n         foreach (byte b in bytes)\n         {\n            bits.appendBits(b, 8);
         }\n         matrix[8, matrix.Height - 8] = 1;\n      }\n      private static void embedHorizontalSeparationPattern(int xStart, int yStart, ByteMatrix matrix)\n      {\n         for (int x = 0; x < 8; ++x)\n         {\n            if (!isEmpty(matrix[xStart + x, yStart]))\n            {\n                throw new Exception();
            }\n            matrix[xStart + x, yStart] = 0;\n         }\n      }\n      private static void embedVerticalSeparationPattern(int xStart, int yStart, ByteMatrix matrix)\n      {\n         for (int y = 0; y < 7; ++y)\n         {\n            if (!isEmpty(matrix[xStart, yStart + y]))\n            {
            }\n            catch (Exception e)\n            {\n                // translate Microsoft language into human language\n                // i.e. An attempt was made to access a socket in a way forbidden by its access permissions => Port already in use\n                if (e is SocketException)\n                {\n                    SocketException se = (SocketException)e;\n                    if (se.SocketErrorCode == SocketError.AccessDenied)\n                    {
    {\n        private static int PORT = 8093;\n        public static string PAC_FILE = "pac.txt";\n        private static Configuration config;\n        Socket _listener;\n        FileSystemWatcher watcher;\n        public event EventHandler PACFileChanged;\n        public void Start(Configuration configuration)
        FileSystemWatcher watcher;\n        public event EventHandler PACFileChanged;\n        public void Start(Configuration configuration)\n        {\n            try
        {\n            try\n            {\n                config = configuration;\n                // Create a TCP/IP socket.\n                _listener = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);\n                _listener.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, true);\n                IPEndPoint localEndPoint = null;\n                if (configuration.shareOverLan)
                {\n                    localEndPoint = new IPEndPoint(IPAddress.Any, PORT);
                }\n                else\n                {\n                    localEndPoint = new IPEndPoint(IPAddress.Loopback, PORT);\n                }\n                // Bind the socket to the local endpoint and listen for incoming connections.\n                _listener.Bind(localEndPoint);\n                _listener.Listen(100);
                {\n                    localEndPoint = new IPEndPoint(IPAddress.Loopback, PORT);\n                }\n                // Bind the socket to the local endpoint and listen for incoming connections.\n                _listener.Bind(localEndPoint);\n                _listener.Listen(100);\n                _listener.BeginAccept(\n                    new AsyncCallback(AcceptCallback),
                }\n                // Bind the socket to the local endpoint and listen for incoming connections.\n                _listener.Bind(localEndPoint);\n                _listener.Listen(100);\n                _listener.BeginAccept(\n                    new AsyncCallback(AcceptCallback),\n                    _listener);\n                WatchPacFile();\n            }\n            catch (SocketException)
            }\n            catch (SocketException)\n            {\n                _listener.Close();\n                throw;\n            }\n        }\n        public void Stop()\n        {\n            if (_listener != null)
            {\n                _listener.Close();\n                throw;\n            }\n        }\n        public void Stop()\n        {\n            if (_listener != null)\n            {\n                _listener.Close();
            }\n        }\n        public string TouchPACFile()\n        {\n            if (File.Exists(PAC_FILE))\n            {\n                return PAC_FILE;\n            }\n            else\n            {
        {\n            object[] state = (object[])ar.AsyncState;\n            Socket conn = (Socket)state[0];\n            byte[] requestBuf = (byte[])state[1];\n            try\n            {\n                int bytesRead = conn.EndReceive(ar);\n                string pac = GetPACContent();\n                IPEndPoint localEndPoint = (IPEndPoint)conn.LocalEndPoint;\n                string proxy = GetPACAddress(requestBuf, localEndPoint);
            try\n            {\n                int bytesRead = conn.EndReceive(ar);\n                string pac = GetPACContent();\n                IPEndPoint localEndPoint = (IPEndPoint)conn.LocalEndPoint;\n                string proxy = GetPACAddress(requestBuf, localEndPoint);\n                pac = pac.Replace("__PROXY__", proxy);\n                if (bytesRead > 0)\n                {\n                    string text = String.Format(@"HTTP/1.1 200 OK
                string pac = GetPACContent();\n                IPEndPoint localEndPoint = (IPEndPoint)conn.LocalEndPoint;\n                string proxy = GetPACAddress(requestBuf, localEndPoint);\n                pac = pac.Replace("__PROXY__", proxy);\n                if (bytesRead > 0)\n                {\n                    string text = String.Format(@"HTTP/1.1 200 OK\nServer: Shadowsocks\nContent-Type: application/x-ns-proxy-autoconfig\nContent-Length: {0}
                pac = pac.Replace("__PROXY__", proxy);\n                if (bytesRead > 0)\n                {\n                    string text = String.Format(@"HTTP/1.1 200 OK\nServer: Shadowsocks\nContent-Type: application/x-ns-proxy-autoconfig\nContent-Length: {0}\nConnection: Close\n", System.Text.Encoding.UTF8.GetBytes(pac).Length) + pac;\n                    byte[] response = System.Text.Encoding.UTF8.GetBytes(text);
Server: Shadowsocks\nContent-Type: application/x-ns-proxy-autoconfig\nContent-Length: {0}\nConnection: Close\n", System.Text.Encoding.UTF8.GetBytes(pac).Length) + pac;\n                    byte[] response = System.Text.Encoding.UTF8.GetBytes(text);\n                    conn.BeginSend(response, 0, response.Length, 0, new AsyncCallback(SendCallback), conn);\n                    Util.Utils.ReleaseMemory();\n                }\n                else
            }\n            catch (Exception e)\n            {\n                Console.WriteLine(e);\n                conn.Close();\n            }\n        }\n        private void SendCallback(IAsyncResult ar)\n        {\n            Socket conn = (Socket)ar.AsyncState;
            }\n        }\n        private void SendCallback(IAsyncResult ar)\n        {\n            Socket conn = (Socket)ar.AsyncState;\n            try\n            {\n                conn.Shutdown(SocketShutdown.Send);\n            }\n            catch
        {\n            string proxy = "PROXY " + localEndPoint.Address + ":8123;";\n            //try\n            //{\n            //    string requestString = Encoding.UTF8.GetString(requestBuf);\n            //    if (requestString.IndexOf("AppleWebKit") >= 0)\n            //    {\n            //        string address = "" + localEndPoint.Address + ":" + config.GetCurrentServer().local_port;\n            //        proxy = "SOCKS5 " + address + "; SOCKS " + address + ";";\n            //    }\n        }\n    }\n}
        }\n    }\n}
            socket.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n            Handler handler = new Handler();\n            handler.connection = socket;\n            Server server = _config.GetCurrentServer();\n            handler.encryptor = EncryptorFactory.GetEncryptor(server.method, server.password);\n            handler.server = server;\n            handler.Start(firstPacket, length);\n        }\n    }
            {\n                server = "192.168.100.1",\n                server_port = 8888,\n                password = "test",\n                method = "bf-cfb"\n            };\n            var serverCanonUrl = "ss://YmYtY2ZiOnRlc3RAMTkyLjE2OC4xMDAuMTo4ODg4";\n            var server2 = new Server
            {\n                server = "192.168.1.1",\n                server_port = 8388,\n                password = "test",\n                method = "bf-cfb"\n            };\n            var server2CanonUrl = "ss://YmYtY2ZiOnRlc3RAMTkyLjE2OC4xLjE6ODM4OA==";\n            var serverWithRemark = new Server\n            {\n                server = server.server,
                remarks = "example-server"\n            };\n            var serverWithRemarkCanonUrl = "ss://YmYtY2ZiOnRlc3RAMTkyLjE2OC4xMDAuMTo4ODg4#example-server";\n            var server2WithRemark = new Server\n            {\n                server = server2.server,\n                server_port = server2.server_port,\n                password = server2.password,\n                method = server2.method,\n                remarks = "example-server"
            {\n                server = server2.server,\n                server_port = server2.server_port,\n                password = server2.password,\n                method = server2.method,\n                remarks = "example-server"\n            };\n            var server2WithRemarkCanonUrl = "ss://YmYtY2ZiOnRlc3RAMTkyLjE2OC4xLjE6ODM4OA==#example-server";\n            var serverWithPlugin = new Server\n            {
                plugin = "obfs-local",\n                plugin_opts = "obfs=http;obfs-host=google.com"\n            };\n            var serverWithPluginCanonUrl =\n                "ss://YmYtY2ZiOnRlc3Q@192.168.100.1:8888/?plugin=obfs-local%3bobfs%3dhttp%3bobfs-host%3dgoogle.com";\n            var server2WithPlugin = new Server\n            {\n                server = server2.server,\n                server_port = server2.server_port,\n                password = server2.password,
                "ss://YmYtY2ZiOnRlc3Q@192.168.100.1:8888/?plugin=obfs-local%3bobfs%3dhttp%3bobfs-host%3dgoogle.com";\n            var server2WithPlugin = new Server\n            {\n                server = server2.server,\n                server_port = server2.server_port,\n                password = server2.password,\n                method = server2.method,\n                plugin = "obfs-local",\n                plugin_opts = "obfs=http;obfs-host=google.com"\n            };
            {\n                server = server2.server,\n                server_port = server2.server_port,\n                password = server2.password,\n                method = server2.method,\n                plugin = "obfs-local",\n                plugin_opts = "obfs=http;obfs-host=google.com"\n            };\n            var server2WithPluginCanonUrl =\n                "ss://YmYtY2ZiOnRlc3Q@192.168.1.1:8388/?plugin=obfs-local%3bobfs%3dhttp%3bobfs-host%3dgoogle.com";
                "ss://YmYtY2ZiOnRlc3Q@192.168.1.1:8388/?plugin=obfs-local%3bobfs%3dhttp%3bobfs-host%3dgoogle.com";\n            var serverWithPluginAndRemark = new Server\n            {\n                server = server.server,\n                server_port = server.server_port,\n                password = server.password,\n                method = server.method,\n                plugin = serverWithPlugin.plugin,\n                plugin_opts = serverWithPlugin.plugin_opts,\n                remarks = serverWithRemark.remarks
                "ss://YmYtY2ZiOnRlc3Q@192.168.100.1:8888/?plugin=obfs-local%3bobfs%3dhttp%3bobfs-host%3dgoogle.com#example-server";\n            var server2WithPluginAndRemark = new Server\n            {\n                server = server2.server,\n                server_port = server2.server_port,\n                password = server2.password,\n                method = server2.method,\n                plugin = server2WithPlugin.plugin,\n                plugin_opts = server2WithPlugin.plugin_opts,\n                remarks = server2WithRemark.remarks
            {\n                server = server2.server,\n                server_port = server2.server_port,\n                password = server2.password,\n                method = server2.method,\n                plugin = server2WithPlugin.plugin,\n                plugin_opts = server2WithPlugin.plugin_opts,\n                remarks = server2WithRemark.remarks\n            };\n            var server2WithPluginAndRemarkCanonUrl =
                "ss://YmYtY2ZiOnRlc3Q@192.168.1.1:8388/?plugin=obfs-local%3bobfs%3dhttp%3bobfs-host%3dgoogle.com#example-server";\n            RunParseShadowsocksUrlTest(\n                string.Join(\n                    "\r\n",\n                    serverCanonUrl,\n                    "\r\n",
                    "\r\n",\n                    "ss://YmYtY2ZiOnRlc3RAMTkyLjE2OC4xMDAuMTo4ODg4/",\n                    server,\n                    server,\n                    serverWithRemark,\n                    serverWithRemark
            RunParseShadowsocksUrlTest(\n                string.Join(\n                    "\r\n",\n                    server2CanonUrl,\n                    "\r\n",\n                    "ss://YmYtY2ZiOnRlc3RAMTkyLjE2OC4xLjE6ODM4OA==/",\n                    server2WithRemarkCanonUrl,\n                    "ss://YmYtY2ZiOnRlc3RAMTkyLjE2OC4xLjE6ODM4OA==/#example-server"),\n                new[]\n                {
        {\n            string fake_plugin = "ftp";\n            var NoPlugin = Sip003Plugin.CreateIfConfigured(new Server\n            {\n                server = "192.168.100.1",\n                server_port = 8888,\n                password = "test",\n                method = "bf-cfb"\n            });\n            RunPluginSupportTest(
            var NoPlugin = Sip003Plugin.CreateIfConfigured(new Server\n            {\n                server = "192.168.100.1",\n                server_port = 8888,\n                password = "test",\n                method = "bf-cfb"\n            });\n            RunPluginSupportTest(\n                NoPlugin,\n                "",
        public HotkeySettingsForm(ShadowsocksController controller)\n        {\n            InitializeComponent();\n            UpdateTexts();\n            Icon = Icon.FromHandle(Resources.ssw128.GetHicon());\n            _controller = controller;\n            _controller.ConfigChanged += controller_ConfigChanged;\n            LoadCurrentConfiguration();\n            // get all textboxes belong to this form\n            _allTextBoxes = tableLayoutPanel1.GetChildControls<TextBox>();
        }\n        private void UpdateTexts()\n        {\n            // I18N stuff\n            SwitchSystemProxyLabel.Text = I18N.GetString("Switch system proxy");\n            SwitchProxyModeLabel.Text = I18N.GetString("Switch system proxy mode");\n            SwitchAllowLanLabel.Text = I18N.GetString("Switch share over LAN");\n            ShowLogsLabel.Text = I18N.GetString("Show Logs");\n            ServerMoveUpLabel.Text = I18N.GetString("Switch to prev server");\n            ServerMoveDownLabel.Text = I18N.GetString("Switch to next server");
        }\n        private bool TryRegHotkeyFromString(string hotkeyStr, string callbackName, Label indicator = null)\n        {\n            var _callback = HotkeyCallbacks.GetCallback(callbackName);\n            if (_callback == null)\n            {\n                throw new Exception($"{callbackName} not found");\n            }\n            var callback = _callback as HotKeys.HotKeyCallBackHandler;\n            if (hotkeyStr.IsNullOrEmpty())
        {\n            var _callback = HotkeyCallbacks.GetCallback(callbackName);\n            if (_callback == null)\n            {\n                throw new Exception($"{callbackName} not found");\n            }\n            var callback = _callback as HotKeys.HotKeyCallBackHandler;\n            if (hotkeyStr.IsNullOrEmpty())\n            {\n                UnregPrevHotkey(callback);
                return true;\n            }\n            else\n            {\n                var hotkey = HotKeys.Str2HotKey(hotkeyStr);\n                if (hotkey == null)\n                {\n                    MessageBox.Show(string.Format(I18N.GetString("Cannot parse hotkey: {0}"), hotkeyStr));\n                    return false;\n                }
                    if (indicator != null)\n                    {\n                        indicator.BackColor = regResult ? Color.Green : Color.Yellow;\n                    }\n                    return regResult;\n                }\n            }\n        }\n        private bool TryRegHotkey(GlobalHotKey.HotKey hotkey, HotKeys.HotKeyCallBackHandler callback)\n        {
    }\n}
            foreach (var d in domains)\n            {\n                string domain = d.Value;\n                switch (d.Type)\n                {\n                    case DomainObject.Types.Type.Plain:\n                        ret.Add(domain);\n                        break;\n                    case DomainObject.Types.Type.Regex:
                        break;\n                    case DomainObject.Types.Type.Regex:

            this.tableLayoutPanel1.Location = new System.Drawing.Point(8, 21);\n            this.tableLayoutPanel1.Margin = new System.Windows.Forms.Padding(0);\n            this.tableLayoutPanel1.Name = "tableLayoutPanel1";\n            this.tableLayoutPanel1.Padding = new System.Windows.Forms.Padding(3);\n            this.tableLayoutPanel1.RowCount = 9;\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel1.TabIndex = 0;\n            // \n            // PluginOptionsLabel\n            // \n            this.PluginOptionsLabel.Anchor = System.Windows.Forms.AnchorStyles.Right;\n            this.PluginOptionsLabel.AutoSize = true;
                return configuration;\n            }\n            catch (FileNotFoundException)\n            {\n                var configuration = new StatisticsStrategyConfiguration();\n                Save(configuration);\n                return configuration;\n            }\n            catch (Exception e)\n            {
            {\n                var configuration = new StatisticsStrategyConfiguration();\n                Save(configuration);\n                return configuration;\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                return new StatisticsStrategyConfiguration();\n            }
            this.chartModeSelector = new System.Windows.Forms.GroupBox();\n            this.allMode = new System.Windows.Forms.RadioButton();\n            this.dayMode = new System.Windows.Forms.RadioButton();\n            this.splitContainer1 = new System.Windows.Forms.SplitContainer();\n            this.splitContainer2 = new System.Windows.Forms.SplitContainer();\n            this.label9 = new System.Windows.Forms.Label();\n            this.label8 = new System.Windows.Forms.Label();\n            this.dataCollectionMinutesNum = new System.Windows.Forms.NumericUpDown();\n            this.StatisticsEnabledCheckBox = new System.Windows.Forms.CheckBox();\n            this.choiceKeptMinutesNum = new System.Windows.Forms.NumericUpDown();
            this.dataCollectionMinutesNum = new System.Windows.Forms.NumericUpDown();\n            this.StatisticsEnabledCheckBox = new System.Windows.Forms.CheckBox();\n            this.choiceKeptMinutesNum = new System.Windows.Forms.NumericUpDown();\n            this.byHourOfDayCheckBox = new System.Windows.Forms.CheckBox();\n            this.repeatTimesNum = new System.Windows.Forms.NumericUpDown();\n            this.label6 = new System.Windows.Forms.Label();\n            this.splitContainer3 = new System.Windows.Forms.SplitContainer();\n            this.label1 = new System.Windows.Forms.Label();\n            this.calculationContainer = new System.Windows.Forms.FlowLayoutPanel();\n            this.serverSelector = new System.Windows.Forms.ComboBox();
            this.splitContainer3 = new System.Windows.Forms.SplitContainer();\n            this.label1 = new System.Windows.Forms.Label();\n            this.calculationContainer = new System.Windows.Forms.FlowLayoutPanel();\n            this.serverSelector = new System.Windows.Forms.ComboBox();\n            this.CancelButton = new System.Windows.Forms.Button();\n            this.OKButton = new System.Windows.Forms.Button();\n            this.CalculatinTip = new System.Windows.Forms.ToolTip(this.components);\n            ((System.ComponentModel.ISupportInitialize)(this.StatisticsChart)).BeginInit();\n            ((System.ComponentModel.ISupportInitialize)(this.bindingConfiguration)).BeginInit();
            this.calculationContainer = new System.Windows.Forms.FlowLayoutPanel();\n            this.serverSelector = new System.Windows.Forms.ComboBox();\n            this.CancelButton = new System.Windows.Forms.Button();\n            this.OKButton = new System.Windows.Forms.Button();\n            this.CalculatinTip = new System.Windows.Forms.ToolTip(this.components);\n            ((System.ComponentModel.ISupportInitialize)(this.StatisticsChart)).BeginInit();\n            ((System.ComponentModel.ISupportInitialize)(this.bindingConfiguration)).BeginInit();\n            this.chartModeSelector.SuspendLayout();\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer1)).BeginInit();
            this.chartModeSelector.SuspendLayout();\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer1)).BeginInit();\n            this.splitContainer1.Panel1.SuspendLayout();\n            this.splitContainer1.Panel2.SuspendLayout();\n            this.splitContainer1.SuspendLayout();\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer2)).BeginInit();\n            this.splitContainer2.Panel1.SuspendLayout();\n            this.splitContainer2.Panel2.SuspendLayout();\n            this.splitContainer2.SuspendLayout();\n            ((System.ComponentModel.ISupportInitialize)(this.dataCollectionMinutesNum)).BeginInit();
            this.splitContainer2.Panel1.Controls.Add(this.dataCollectionMinutesNum);\n            this.splitContainer2.Panel1.Controls.Add(this.StatisticsEnabledCheckBox);\n            this.splitContainer2.Panel1.Controls.Add(this.choiceKeptMinutesNum);\n            this.splitContainer2.Panel1.Controls.Add(this.byHourOfDayCheckBox);\n            this.splitContainer2.Panel1.Controls.Add(this.repeatTimesNum);\n            this.splitContainer2.Panel1.Controls.Add(this.label6);\n            this.splitContainer2.Panel1.Controls.Add(this.label2);\n            this.splitContainer2.Panel1.Controls.Add(this.PingCheckBox);\n            this.splitContainer2.Panel1.Controls.Add(this.label3);\n            // 
            this.splitContainer2.Panel1.Controls.Add(this.PingCheckBox);\n            this.splitContainer2.Panel1.Controls.Add(this.label3);\n            // \n            // splitContainer2.Panel2\n            // \n            this.splitContainer2.Panel2.Controls.Add(this.splitContainer3);
            // \n            // splitContainer2.Panel2\n            // \n            this.splitContainer2.Panel2.Controls.Add(this.splitContainer3);
            // \n            // splitContainer3.Panel2\n            // \n            this.splitContainer3.Panel2.Controls.Add(this.calculationContainer);\n            // label1\n            // \n            this.label1.AutoSize = true;\n            this.label1.Location = new System.Drawing.Point(5, 9);\n            this.label1.Margin = new System.Windows.Forms.Padding(5, 0, 5, 0);
            // \n            // calculationContainer\n            // \n            this.calculationContainer.AutoScroll = true;\n            this.calculationContainer.Dock = System.Windows.Forms.DockStyle.Fill;\n            this.calculationContainer.Location = new System.Drawing.Point(0, 0);\n            this.calculationContainer.Margin = new System.Windows.Forms.Padding(5, 10, 5, 10);\n            this.calculationContainer.Name = "calculationContainer";
            this.chartModeSelector.ResumeLayout(false);\n            this.chartModeSelector.PerformLayout();\n            this.splitContainer1.Panel1.ResumeLayout(false);\n            this.splitContainer1.Panel2.ResumeLayout(false);\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer1)).EndInit();\n            this.splitContainer1.ResumeLayout(false);\n            this.splitContainer2.Panel1.ResumeLayout(false);\n            this.splitContainer2.Panel1.PerformLayout();\n            this.splitContainer2.Panel2.ResumeLayout(false);\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer2)).EndInit();
        private System.Windows.Forms.GroupBox chartModeSelector;\n        private System.Windows.Forms.RadioButton allMode;\n        private System.Windows.Forms.RadioButton dayMode;\n        private System.Windows.Forms.SplitContainer splitContainer1;\n        private System.Windows.Forms.Label label1;\n        private System.Windows.Forms.SplitContainer splitContainer2;\n        private System.Windows.Forms.FlowLayoutPanel calculationContainer;\n        private System.Windows.Forms.SplitContainer splitContainer3;\n        private System.Windows.Forms.NumericUpDown repeatTimesNum;\n        private System.Windows.Forms.Label label6;
        private System.Windows.Forms.SplitContainer splitContainer2;\n        private System.Windows.Forms.FlowLayoutPanel calculationContainer;\n        private System.Windows.Forms.SplitContainer splitContainer3;\n        private System.Windows.Forms.NumericUpDown repeatTimesNum;\n        private System.Windows.Forms.Label label6;\n        private System.Windows.Forms.CheckBox byHourOfDayCheckBox;\n        private System.Windows.Forms.NumericUpDown choiceKeptMinutesNum;\n        private System.Windows.Forms.CheckBox StatisticsEnabledCheckBox;\n        private System.Windows.Forms.Label label9;\n        private System.Windows.Forms.Label label8;
        private System.Windows.Forms.CheckBox byHourOfDayCheckBox;\n        private System.Windows.Forms.NumericUpDown choiceKeptMinutesNum;\n        private System.Windows.Forms.CheckBox StatisticsEnabledCheckBox;\n        private System.Windows.Forms.Label label9;\n        private System.Windows.Forms.Label label8;\n        private System.Windows.Forms.NumericUpDown dataCollectionMinutesNum;\n        private System.Windows.Forms.BindingSource bindingConfiguration;\n        private new System.Windows.Forms.Button CancelButton;\n        private System.Windows.Forms.Button OKButton;\n        private System.Windows.Forms.ComboBox serverSelector;
        private System.Windows.Forms.NumericUpDown dataCollectionMinutesNum;\n        private System.Windows.Forms.BindingSource bindingConfiguration;\n        private new System.Windows.Forms.Button CancelButton;\n        private System.Windows.Forms.Button OKButton;\n        private System.Windows.Forms.ComboBox serverSelector;\n        private System.Windows.Forms.ToolTip CalculatinTip;\n    }\n}
                this.hotKeyItem = CreateMenuItem("Edit Hotkeys...", new EventHandler(this.hotKeyItem_Click)),\n                CreateMenuGroup("Updates...", new MenuItem[] {\n                    CreateMenuItem("Check for Updates...", new EventHandler(this.checkUpdatesItem_Click)),\n                    new MenuItem("-"),\n                    this.autoCheckUpdatesToggleItem = CreateMenuItem("Check for Updates at Startup", new EventHandler(this.autoCheckUpdatesToggleItem_Click)),\n                    this.checkPreReleaseToggleItem = CreateMenuItem("Check Pre-release Version", new EventHandler(this.checkPreReleaseToggleItem_Click)),
                }),\n                CreateMenuItem("About...", new EventHandler(this.AboutItem_Click)),

using Shadowsocks.Controller.Strategy;\nusing Shadowsocks.Model;\nusing Shadowsocks.Properties;\nusing Shadowsocks.Util;\nusing System.Linq;\nusing Shadowsocks.Controller.Service;\nusing Shadowsocks.Proxy;\nnamespace Shadowsocks.Controller\n{\n    public class ShadowsocksController
using Shadowsocks.Util;\nusing System.Linq;\nusing Shadowsocks.Controller.Service;\nusing Shadowsocks.Proxy;\nnamespace Shadowsocks.Controller\n{\n    public class ShadowsocksController\n    {\n        // controller:\n        // handle user actions
namespace Shadowsocks.Controller\n{\n    public class ShadowsocksController\n    {\n        // controller:\n        // handle user actions\n        // manipulates UI\n        // interacts with low level logic\n        private Thread _ramThread;\n        private Thread _trafficThread;
        }\n        public void ToggleGlobal(bool global)\n        {\n            _config.global = global;\n            SaveConfig(_config);\n            if (EnableGlobalChanged != null)\n            {\n                EnableGlobalChanged(this, new EventArgs());\n            }
        }\n        public void ToggleShareOverLAN(bool enabled)\n        {\n            _config.shareOverLan = enabled;\n            SaveConfig(_config);\n            if (ShareOverLANStatusChanged != null)\n            {\n                ShareOverLANStatusChanged(this, new EventArgs());\n            }
        }\n        public void SaveProxy(ProxyConfig proxyConfig)\n        {\n            _config.proxy = proxyConfig;\n            SaveConfig(_config);\n        }\n        public void ToggleVerboseLogging(bool enabled)\n        {\n            _config.isVerboseLogging = enabled;\n            SaveConfig(_config);
        }\n        public void TouchUserRuleFile()\n        {\n            string userRuleFilename = _pacServer.TouchUserRuleFile();\n            if (UserRuleFileReadyToOpen != null)\n            {\n                UserRuleFileReadyToOpen(this, new PathEventArgs() { Path = userRuleFilename });\n            }\n        }
        }\n        public string GetServerURLForCurrentServer()\n        {\n            Server server = GetCurrentServer();\n            return GetServerURL(server);\n        }\n        public static string GetServerURL(Server server)\n        {\n            string tag = string.Empty;\n            string url = string.Empty;
        }\n        public void SavePACUrl(string pacUrl)\n        {\n            _config.pacUrl = pacUrl;\n            SaveConfig(_config);\n            if (ConfigChanged != null)\n            {\n                ConfigChanged(this, new EventArgs());\n            }
        }\n        public void UseOnlinePAC(bool useOnlinePac)\n        {\n            _config.useOnlinePac = useOnlinePac;\n            SaveConfig(_config);\n            if (ConfigChanged != null)\n            {\n                ConfigChanged(this, new EventArgs());\n            }
        }\n        public void ToggleSecureLocalPac(bool enabled)\n        {\n            _config.secureLocalPac = enabled;\n            SaveConfig(_config);\n            if (ConfigChanged != null)\n            {\n                ConfigChanged(this, new EventArgs());\n            }
        }\n        public void ToggleCheckingUpdate(bool enabled)\n        {\n            _config.autoCheckUpdate = enabled;\n            Configuration.Save(_config);\n            if (ConfigChanged != null)\n            {\n                ConfigChanged(this, new EventArgs());\n            }
        }\n        public void ToggleCheckingPreRelease(bool enabled)\n        {\n            _config.checkPreRelease = enabled;\n            Configuration.Save(_config);\n            if (ConfigChanged != null)\n            {\n                ConfigChanged(this, new EventArgs());\n            }
        }\n        public void SaveLogViewerConfig(LogViewerConfig newConfig)\n        {\n            _config.logViewer = newConfig;\n            newConfig.SaveSize();\n            Configuration.Save(_config);\n            if (ConfigChanged != null)\n            {\n                ConfigChanged(this, new EventArgs());\n            }
        }\n        public void SaveHotkeyConfig(HotkeyConfig newConfig)\n        {\n            _config.hotkey = newConfig;\n            SaveConfig(_config);\n            if (ConfigChanged != null)\n            {\n                ConfigChanged(this, new EventArgs());\n            }
        }\n        public void UpdateLatency(Server server, TimeSpan latency)\n        {\n            if (_config.availabilityStatistics)\n            {\n                availabilityStatistics.UpdateLatency(server, (int)latency.TotalMilliseconds);\n            }\n        }\n        public void UpdateInboundCounter(Server server, long n)\n        {
                _listener = new Listener(services);\n                _listener.Start(_config);\n            }\n            catch (Exception e)\n            {\n                // translate Microsoft language into human language\n                // i.e. An attempt was made to access a socket in a way forbidden by its access permissions => Port already in use\n                if (e is SocketException)\n                {\n                    SocketException se = (SocketException)e;\n                    if (se.SocketErrorCode == SocketError.AddressAlreadyInUse)\n                    {
                    if (se.SocketErrorCode == SocketError.AddressAlreadyInUse)\n                    {\n                        e = new Exception(I18N.GetString("Port {0} already in use", _config.localPort), e);\n                    }\n                    else if (se.SocketErrorCode == SocketError.AccessDenied)\n                    {\n                        e = new Exception(I18N.GetString("Port {0} is reserved by system", _config.localPort), e);\n                    }\n                }\n                Logging.LogUsefulException(e);
            _trafficThread.Start();\n        }\n        private void TrafficStatistics(int queueMaxSize)\n        {\n            TrafficPerSecond previous, current;\n            while (true)\n            {\n                previous = trafficPerSecondQueue.Last();\n                current = new TrafficPerSecond();\n                current.inboundCounter = InboundCounter;
                current.inboundIncreasement = current.inboundCounter - previous.inboundCounter;\n                current.outboundIncreasement = current.outboundCounter - previous.outboundCounter;\n                trafficPerSecondQueue.Enqueue(current);\n                if (trafficPerSecondQueue.Count > queueMaxSize)\n                    trafficPerSecondQueue.Dequeue();\n                TrafficChanged?.Invoke(this, new EventArgs());\n                Thread.Sleep(1000);\n            }\n        }\n        #endregion
        }\n        private void ReceiveCallback(IAsyncResult ar)\n        {\n            try\n            {\n                var bytesRead = _socket.EndReceive(ar);\n                if (bytesRead == 0)\n                {\n                    OnFinish();
                    return;\n                }\n                _bufferDataLength += bytesRead;\n                NewPackageRecv();
            }\n            catch (Exception ex)\n            {\n                OnException(ex);\n                OnFinish();\n            }\n        }\n        private void NewPackageRecv()\n        {\n            int i;
        }\n        private void OnException(Exception ex)\n        {\n            _onException?.Invoke(ex, _state);\n        }\n        private void OnFinish()\n        {\n            _onFinish?.Invoke(_lineBuffer, _bufferDataIndex, _bufferDataLength, _state);\n        }\n        #region Boyer-Moore string search\n        private static int IndexOf(byte[] haystack, int index, int length, byte[] needle, int[] offsetTable, int[] charTable)
        }\n        #region Boyer-Moore string search\n        private static int IndexOf(byte[] haystack, int index, int length, byte[] needle, int[] offsetTable, int[] charTable)\n        {\n            var end = index + length;\n            for (int i = needle.Length - 1 + index, j; i < end;)\n            {\n                for (j = needle.Length - 1; needle[j] == haystack[i]; --i, --j)\n                {\n                    if (j == 0)\n                    {
        {\n            var end = index + length;\n            for (int i = needle.Length - 1 + index, j; i < end;)\n            {\n                for (j = needle.Length - 1; needle[j] == haystack[i]; --i, --j)\n                {\n                    if (j == 0)\n                    {\n                        return i;\n                    }
            {\n            }\n            finally\n            {\n                try\n                {\n                    _udpSocket.BeginReceiveFrom(state.buffer, 0, state.buffer.Length, 0, ref state.remoteEndPoint, new AsyncCallback(RecvFromCallback), state);\n                }\n                catch (ObjectDisposedException)
            public UDPHandler(Socket local, Server server, IPEndPoint localEndPoint)\n            {\n                _local = local;\n                _server = server;\n                _localEndPoint = localEndPoint;\n                _remoteEndPoint = SocketUtil.GetEndPoint(server.server, server.server_port);\n                _remote = SocketUtil.CreateSocket(_remoteEndPoint, ProtocolType.Udp);
            }\n            public void Send(byte[] data, int length)\n            {\n                IEncryptor encryptor = EncryptorFactory.GetEncryptor(_server.method, _server.password, _server.auth, true);\n                byte[] dataIn = new byte[length - 3 + IVEncryptor.ONETIMEAUTH_BYTES];\n                Array.Copy(data, 3, dataIn, 0, length - 3);\n                byte[] dataOut = new byte[length - 3 + 16 + IVEncryptor.ONETIMEAUTH_BYTES];\n                int outlen;\n                encryptor.Encrypt(dataIn, length - 3, dataOut, out outlen);\n                Logging.Debug(_localEndPoint, _remoteEndPoint, outlen, "UDP Relay");
                        }\n                        else if (global)\n                        {\n                            iconCopy.SetPixel(x, y, Color.FromArgb(color.A, 52, 168, 83));\n                        }\n                        else\n                        {\n                            iconCopy.SetPixel(x, y, Color.FromArgb(color.A, 251, 188, 5));
                        }\n                        else\n                        {\n                            iconCopy.SetPixel(x, y, Color.FromArgb(color.A, 251, 188, 5));

            var ret = new List<DataList>();\n            foreach (var timestamp in Enumerable.Range(0, Repeat).Select(_ => DateTime.Now.ToString(DateTimePattern)))\n            {\n                //ICMP echo. we can also set options and special bytes\n                try\n                {\n                    var reply = await ping.SendTaskAsync(IP, Timeout);\n                    ret.Add(new List<KeyValuePair<string, string>>
                    {\n                        new KeyValuePair<string, string>("Timestamp", timestamp),\n                        new KeyValuePair<string, string>("Server", server.FriendlyName()),\n                        new KeyValuePair<string, string>("Status", reply?.Status.ToString()),\n                        new KeyValuePair<string, string>("RoundtripTime", reply?.RoundtripTime.ToString())\n                        //new KeyValuePair<string, string>("data", reply.Buffer.ToString()); // The data of reply\n                    });\n                    Thread.Sleep(Timeout + new Random().Next() % Timeout);\n                    //Do ICMPTest in a random frequency\n                }\n                catch (Exception e)
            }\n            return ret;\n        }\n        private void Run(object obj)\n        {\n            LoadRawStatistics();\n            FilterRawStatistics();\n            evaluate();\n        }\n        private async void evaluate()
        }\n        public void EndConnectDest(IAsyncResult asyncResult)\n        {\n            _remote = SocketUtil.EndConnectTcp(asyncResult);\n        }\n        public void BeginSend(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state)\n        {
        }\n        public void BeginSend(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state)\n        {\n            _remote?.BeginSend(buffer, offset, size, socketFlags, callback, state);\n        }\n        public int EndSend(IAsyncResult asyncResult)\n        {\n            return _remote.EndSend(asyncResult);\n        }
using System.Net;\nusing System.Net.Sockets;\nusing System.Text;\nusing System.Threading;\nusing Shadowsocks.Controller;\nusing Shadowsocks.Util;\nnamespace Shadowsocks.Proxy\n{\n    public class Socks5Proxy : IProxy\n    {
namespace Shadowsocks.Proxy\n{\n    public class Socks5Proxy : IProxy\n    {\n        private class FakeAsyncResult : IAsyncResult\n        {\n            public readonly Socks5State innerState;\n            private readonly IAsyncResult r;\n            public FakeAsyncResult(IAsyncResult orig, Socks5State state)\n            {
        }\n        private void ConnectCallback(IAsyncResult ar)\n        {\n            var state = (Socks5State) ar.AsyncState;\n            try\n            {\n                _remote = SocketUtil.EndConnectTcp(ar);\n                byte[] handshake = {5, 1, 0};
                byte[] handshake = {5, 1, 0};\n                _remote.BeginSend(handshake, 0, handshake.Length, 0, Socks5HandshakeSendCallback, state);\n            }\n            catch (Exception ex)\n            {\n                state.ex = ex;\n                state.Callback?.Invoke(new FakeAsyncResult(ar, state));\n            }\n        }\n        private void Socks5HandshakeSendCallback(IAsyncResult ar)
        {\n            EnableItem.Checked = !EnableItem.Checked;\n            if (EnableItem.Checked)\n            {\n                SystemProxy.Enable();\n            }\n            else\n            {\n                SystemProxy.Disable();
            {\n                SystemProxy.Enable();\n            }\n            else\n            {\n                SystemProxy.Disable();\n            }\n        }
            get {\n                return ResourceManager.GetString("proxy_pac", resourceCulture);\n            }\n        }\n    }\n}
            }\n        }\n    }\n}
                string proxy = "PROXY 127.0.0.1:8123; DIRECT;";\n                pac = pac.Replace("__PROXY__", proxy);\n                if (bytesRead > 0)\n                {\n                    string text = String.Format(@"HTTP/1.1 200 OK\nServer: Shadowsocks\nContent-Type: application/x-ns-proxy-autoconfig\nContent-Length: {0}\nConnection: Close\n", System.Text.Encoding.UTF8.GetBytes(pac).Length) + pac;
            this.panel2 = new System.Windows.Forms.Panel();\n            this.button1 = new System.Windows.Forms.Button();\n            this.button2 = new System.Windows.Forms.Button();\n            this.panel1 = new System.Windows.Forms.Panel();\n            this.EnableItem = new System.Windows.Forms.ToolStripMenuItem();
            this.tableLayoutPanel1.SuspendLayout();\n            this.contextMenuStrip1.SuspendLayout();\n            this.panel1.SuspendLayout();\n            this.SuspendLayout();\n            // \n            // tableLayoutPanel1\n            // \n            this.tableLayoutPanel1.AutoSize = true;\n            this.tableLayoutPanel1.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;\n            this.tableLayoutPanel1.ColumnCount = 2;
            this.panel1.SuspendLayout();\n            this.SuspendLayout();\n            // \n            // tableLayoutPanel1\n            // \n            this.tableLayoutPanel1.AutoSize = true;\n            this.tableLayoutPanel1.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;\n            this.tableLayoutPanel1.ColumnCount = 2;\n            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());\n            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());
            this.notifyIcon1.Icon = ((System.Drawing.Icon)(resources.GetObject("notifyIcon1.Icon")));\n            this.notifyIcon1.Text = "shadowsocks";\n            this.notifyIcon1.Visible = true;\n            this.notifyIcon1.DoubleClick += new System.EventHandler(this.notifyIcon1_DoubleClick);\n            // \n            // contextMenuStrip1\n            // \n            this.contextMenuStrip1.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {\n            this.EnableItem,\n            this.ConfigItem,
            // \n            // panel2\n            // \n            this.panel2.Anchor = System.Windows.Forms.AnchorStyles.Top;\n            this.panel2.AutoSize = true;\n            this.panel2.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;\n            this.panel2.Location = new System.Drawing.Point(61, 175);\n            this.panel2.Name = "panel2";\n            this.panel2.Size = new System.Drawing.Size(0, 0);\n            this.panel2.TabIndex = 1;
        private System.Windows.Forms.Label label5;\n        private System.Windows.Forms.ComboBox comboBox1;\n        private System.Windows.Forms.Panel panel2;\n        private System.Windows.Forms.Button button1;\n        private System.Windows.Forms.Button button2;\n        private System.Windows.Forms.Panel panel1;\n        private System.Windows.Forms.ToolStripMenuItem EnableItem;
    }\n}
            this.tableLayoutPanel1.SuspendLayout();\n            this.panel1.SuspendLayout();\n            this.SuspendLayout();\n            // \n            // tableLayoutPanel1\n            // \n            this.tableLayoutPanel1.AutoSize = true;\n            this.tableLayoutPanel1.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;\n            this.tableLayoutPanel1.ColumnCount = 2;\n            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());\n            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());
            this.tableLayoutPanel1.Name = "tableLayoutPanel1";\n            this.tableLayoutPanel1.RowCount = 5;\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());

        private void UpdateOnlinePACURLItem_Click(object sender, EventArgs e)\n        {\n            showPACUrlForm();
        }\n    }\n}
            }\n            catch (Exception ex)\n            {\n                if (Error != null)\n                {\n                    Error(this, new ErrorEventArgs(ex));\n                }\n            }\n        }
            }\n        }\n        public void UpdatePACFromGFWList(Configuration config)\n        {\n            WebClient http = new WebClient();\n            http.Proxy = new WebProxy(IPAddress.Loopback.ToString(), config.localPort);\n            http.DownloadStringCompleted += http_DownloadStringCompleted;\n            http.DownloadStringAsync(new Uri(GFWLIST_URL));\n        }\n        public static List<string> ParseResult(string response)
using System.Collections.Generic;\nusing System.Text;\nusing System.Text.RegularExpressions;\nnamespace Shadowsocks.Controller\n{\n    public class I18N\n    {\n        protected static Dictionary<string, string> Strings;\n        static I18N()
namespace Shadowsocks.Controller\n{\n    public class I18N\n    {\n        protected static Dictionary<string, string> Strings;\n        static I18N()\n        {\n            Strings = new Dictionary<string, string>();\n            if (System.Globalization.CultureInfo.CurrentCulture.IetfLanguageTag.ToLowerInvariant().StartsWith("zh"))
            {\n                string[] lines = Regex.Split(Resources.cn, "\r\n|\r|\n");\n                foreach (string line in lines)\n                {\n                    if (line.StartsWith("#"))\n                    {\n                        continue;
                {\n                    if (line.StartsWith("#"))\n                    {\n                        continue;\n                    }\n                    string[] kv = Regex.Split(line, "=");\n                    if (kv.Length == 2)\n                    {
                    {\n                        continue;\n                    }\n                    string[] kv = Regex.Split(line, "=");\n                    if (kv.Length == 2)\n                    {\n                        Strings[kv[0]] = kv[1];\n                    }\n                }\n            }
                    }\n                }\n            }\n        }\n        public static string GetString(string key)\n        {\n            if (Strings.ContainsKey(key))\n            {\n                return Strings[key];\n            }
                        return true;\n                    else if (item == "Shadowsocks") // Compatibility with older versions\n                    {\n                        string value = Convert.ToString(runKey.GetValue(item));\n                        if (path.Equals(value, StringComparison.InvariantCultureIgnoreCase))\n                        {\n                            runKey.DeleteValue(item);\n                            runKey.SetValue(Key, path);\n                            return true;\n                        }
                    {\n                        string value = Convert.ToString(runKey.GetValue(item));\n                        if (path.Equals(value, StringComparison.InvariantCultureIgnoreCase))\n                        {\n                            runKey.DeleteValue(item);\n                            runKey.SetValue(Key, path);\n                            return true;\n                        }\n                    }\n                }
                        {\n                            runKey.DeleteValue(item);\n                            runKey.SetValue(Key, path);\n                            return true;\n                        }\n                    }\n                }\n                return false;\n            }\n            catch (Exception e)
            try\n            {\n                int bytesRead = conn.EndReceive(ar);\n                string pac = GetPACContent();\n                IPEndPoint localEndPoint = (IPEndPoint)conn.LocalEndPoint;\n                string proxy = "PROXY " + localEndPoint.Address + ":8123;";\n                pac = pac.Replace("__PROXY__", proxy);\n                if (bytesRead > 0)\n                {\n                    string text = String.Format(@"HTTP/1.1 200 OK
                pac = pac.Replace("__PROXY__", proxy);\n                if (bytesRead > 0)\n                {\n                    string text = String.Format(@"HTTP/1.1 200 OK\nServer: Shadowsocks\nContent-Type: application/x-ns-proxy-autoconfig\nContent-Length: {0}\nConnection: Close\n", System.Text.Encoding.UTF8.GetBytes(pac).Length) + pac;\n                    byte[] response = System.Text.Encoding.UTF8.GetBytes(text);
                    method = EncryptionSelect.Text,\n                    remarks = RemarksTextBox.Text\n                };\n                Configuration.CheckServer(server);\n                _modifiedConfiguration.configs[_oldSelectedIndex] = server;\n                return true;\n            }
        private bool _shareOverLAN;\n        //private Encryptor encryptor;\n        Socket _listener;\n        public Local(Configuration config)\n        {\n            this._server = config.GetCurrentServer();\n            _shareOverLAN = config.shareOverLan;\n            //this.encryptor = new Encryptor(config.method, config.password);\n        }\n        public void Start()\n        {
            _shareOverLAN = config.shareOverLan;\n            //this.encryptor = new Encryptor(config.method, config.password);\n        }\n        public void Start()\n        {\n            try\n            {\n                // Create a TCP/IP socket.\n                _listener = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);\n                _listener.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, true);
                }\n                else\n                {\n                    localEndPoint = new IPEndPoint(IPAddress.Loopback, _server.local_port);\n                }\n                // Bind the socket to the local endpoint and listen for incoming connections.\n                _listener.Bind(localEndPoint);\n                _listener.Listen(100);\n                // Start an asynchronous socket to listen for connections.\n                Console.WriteLine("Shadowsocks started");
                }\n                // Bind the socket to the local endpoint and listen for incoming connections.\n                _listener.Bind(localEndPoint);\n                _listener.Listen(100);\n                // Start an asynchronous socket to listen for connections.\n                Console.WriteLine("Shadowsocks started");\n                _listener.BeginAccept(\n                    new AsyncCallback(AcceptCallback),\n                    _listener);\n            }
                if (!parsed)\n                {\n                    IPHostEntry ipHostInfo = Dns.GetHostEntry(config.server);\n                    ipAddress = ipHostInfo.AddressList[0];\n                }\n                IPEndPoint remoteEP = new IPEndPoint(ipAddress, config.server_port);\n                remote = new Socket(ipAddress.AddressFamily,\n                    SocketType.Stream, ProtocolType.Tcp);\n                remote.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n                // Connect to the remote endpoint.
                    ipAddress = ipHostInfo.AddressList[0];\n                }\n                IPEndPoint remoteEP = new IPEndPoint(ipAddress, config.server_port);\n                remote = new Socket(ipAddress.AddressFamily,\n                    SocketType.Stream, ProtocolType.Tcp);\n                remote.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n                // Connect to the remote endpoint.\n                remote.BeginConnect(remoteEP,\n                    new AsyncCallback(ConnectCallback), null);\n            }
                remote = new Socket(ipAddress.AddressFamily,\n                    SocketType.Stream, ProtocolType.Tcp);\n                remote.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n                // Connect to the remote endpoint.\n                remote.BeginConnect(remoteEP,\n                    new AsyncCallback(ConnectCallback), null);\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);
using System.Collections.Generic;\nusing System.Globalization;\nusing System.IO;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Net.NetworkInformation;\nusing System.Net.Sockets;\nusing System.Threading;\nusing System.Threading.Tasks;
using System.Net.NetworkInformation;\nusing System.Net.Sockets;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Newtonsoft.Json;\nusing Newtonsoft.Json.Linq;\nusing Shadowsocks.Model;\nusing Shadowsocks.Util;\nnamespace Shadowsocks.Controller\n{
using Shadowsocks.Model;\nusing Shadowsocks.Util;\nnamespace Shadowsocks.Controller\n{\n    using DataUnit = KeyValuePair<string, string>;\n    using DataList = List<KeyValuePair<string, string>>;\n    using Statistics = Dictionary<string, List<AvailabilityStatistics.RawStatisticsData>>;\n    //TODO: change to singleton\n    public class AvailabilityStatistics\n    {
    {\n        public const string DateTimePattern = "yyyy-MM-dd HH:mm:ss";\n        private const string StatisticsFilesName = "shadowsocks.availability.csv";\n        private const string Delimiter = ",";\n        private const int Timeout = 500;\n        private readonly TimeSpan DelayBeforeStart = TimeSpan.FromSeconds(1);\n        public Statistics RawStatistics { get; private set; }\n        public Statistics FilteredStatistics { get; private set; }
        public Statistics RawStatistics { get; private set; }\n        public Statistics FilteredStatistics { get; private set; }\n        public static readonly DateTime UnknownDateTime = new DateTime(1970, 1, 1);\n        private int Repeat => _config.RepeatTimesNum;
        private long _lastInboundCounter = 0;\n        private long _lastOutboundCounter = 0;\n        public AvailabilityStatistics(ShadowsocksController controller)\n        {\n            _controller = controller;
        public bool Set(StatisticsStrategyConfiguration config)\n        {\n            _config = config;\n            try\n            {\n                if (config.StatisticsEnabled)\n                {
        }\n        private string GetRecentInboundSpeed(Server server)\n        {\n            if (server != _currentServer) return Empty;\n            return _inboundSpeed.ToString();\n        }\n        private string GetRecentLatency(Server server)\n        {\n            if (server != _currentServer) return Empty;
        }\n        private string GetRecentLatency(Server server)\n        {\n            if (server != _currentServer) return Empty;\n            return _latency == null ? Empty : _latency.ToString();\n        }\n        private void ResetSpeed()\n        {\n            _currentServer = _globalConfig.GetCurrentServer();\n            _latency = null;
            _latency = null;\n            _inboundSpeed = 0;\n            _outboundSpeed = 0;\n        }\n        private void Run(object obj)\n        {
            ResetSpeed();\n        }\n        private async void FilterRawStatistics()\n        {\n            if (RawStatistics == null) return;\n            if (FilteredStatistics == null)\n            {\n                FilteredStatistics = new Statistics();
        {\n            if (RawStatistics == null) return;\n            if (FilteredStatistics == null)\n            {\n                FilteredStatistics = new Statistics();\n            }\n            foreach (IEnumerable<RawStatisticsData> rawData in RawStatistics.Values)\n            {\n                var filteredData = rawData;\n                if (_config.ByHourOfDay)
            }\n        }\n        public void UpdateInboundCounter(Server server, long n)\n        {\n            Interlocked.Add(ref inboundCounter, n);\n            if (_config.availabilityStatistics)\n            {\n                new Task(() => availabilityStatistics.UpdateInboundCounter(server, n)).Start();\n            }\n        }
            }\n        }\n        public void UpdateOutboundCounter(Server server, long n)\n        {\n            Interlocked.Add(ref outboundCounter, n);\n            if (_config.availabilityStatistics)\n            {\n                new Task(() => availabilityStatistics.UpdateOutboundCounter(server, n)).Start();\n            }\n        }
            }\n        }\n        protected void Reload()\n        {\n            // some logic in configuration updated the config when saving, we need to read it again\n            _config = Configuration.Load();\n            StatisticsConfiguration = StatisticsStrategyConfiguration.Load();\n            if (polipoRunner == null)\n            {\n                polipoRunner = new PolipoRunner();
                _process = null;\n            }\n            RefreshTrayArea();
                var lastOutbound = _lastOutboundCounter[id];\n                var outbound = _outboundCounter[id];\n                bytes = outbound - lastOutbound;\n                _lastOutboundCounter[id] = outbound;\n                var outboundSpeed = GetSpeedInKiBPerSecond(bytes, _monitorInterval.TotalSeconds);\n                _outboundSpeedRecords.GetOrAdd(id, new List<int> {outboundSpeed}).Add(outboundSpeed);
                Logging.Debug(\n                    $"{id}: current/max inbound {inboundSpeed}/{_inboundSpeedRecords[id].Max()} KiB/s, current/max outbound {outboundSpeed}/{_outboundSpeedRecords[id].Max()} KiB/s");\n            }\n        }\n        private async Task<ICMPResult> ICMPTest(Server server)\n        {\n            Logging.Debug("Ping " + server.FriendlyName());\n            if (server.server == "") return null;\n            var result = new ICMPResult(server);\n            try
        }\n        private void Reset()\n        {\n            _inboundSpeedRecords.Clear();\n            _outboundSpeedRecords.Clear();\n            _latencyRecords.Clear();\n        }\n        private void Run(object _)\n        {\n            UpdateRecords();
            Reset();\n            FilterRawStatistics();\n        }\n        private async void UpdateRecords()\n        {\n            var records = new Dictionary<string, StatisticsRecord>();\n            foreach (var server in _controller.GetCurrentConfiguration().configs)\n            {
        {\n            var records = new Dictionary<string, StatisticsRecord>();\n            foreach (var server in _controller.GetCurrentConfiguration().configs)\n            {\n                var id = server.Identifier();\n                List<int> inboundSpeedRecords = null;\n                List<int> outboundSpeedRecords = null;\n                List<int> latencyRecords = null;
            }\n        }\n        private void AppendRecord(string serverIdentifier, StatisticsRecord record)\n        {\n            List<StatisticsRecord> records;\n            if (!RawStatistics.TryGetValue(serverIdentifier, out records))\n            {\n                records = new List<StatisticsRecord>();\n            }\n            records.Add(record);
        }\n        private void Save()\n        {\n            if (RawStatistics.Count == 0)\n            {\n                return;\n            }\n            try\n            {
                File.WriteAllText(AvailabilityStatisticsFile, content);\n            }\n            catch (IOException e)\n            {\n                Logging.LogUsefulException(e);\n            }\n        }\n        private bool IsValidRecord(StatisticsRecord record)\n        {\n            if (Config.ByHourOfDay)
        }\n        public void Dispose()\n        {\n            _recorder.Dispose();\n            _speedMonior.Dispose();\n        }\n        public void UpdateLatency(Server server, int latency)\n        {\n            List<int> records;\n            _latencyRecords.TryGetValue(server.Identifier(), out records);
        }\n        public void UpdateInboundCounter(Server server, long n)\n        {\n            long count;\n            if (_inboundCounter.TryGetValue(server.Identifier(), out count))\n            {\n                count += n;\n            }\n            else\n            {
        }\n        public void UpdateOutboundCounter(Server server, long n)\n        {\n            long count;\n            if (_outboundCounter.TryGetValue(server.Identifier(), out count))\n            {\n                count += n;\n            }\n            else\n            {
        }\n    }\n}
                // truncate privoxy log file while debugging\n                string privoxyLogFilename = Utils.GetTempPath("privoxy.log");\n                if (File.Exists(privoxyLogFilename))\n                    using (new FileStream(privoxyLogFilename, FileMode.Truncate)) { }\n#else\n                Logging.OpenLogFile();\n#endif\n                MainController = new ShadowsocksController();\n                MenuController = new MenuViewController(MainController);
#endif\n                MainController = new ShadowsocksController();\n                MenuController = new MenuViewController(MainController);\n                HotKeys.Init(MainController);\n                MainController.Start();\n                Application.Run();\n            }
                _systemProxyIsDirty = true;\n            }\n            else\n            {\n                // only switch it off if we have switched it on\n                if (_systemProxyIsDirty)\n                {\n                    SystemProxy.Update(_config, false);\n                    _systemProxyIsDirty = false;\n                }\n            }
                    _systemProxyIsDirty = false;\n                }\n            }\n        }\n        private void pacServer_PACFileChanged(object sender, EventArgs e)\n        {\n            UpdateSystemProxy();\n        }\n        private void pacServer_PACUpdateCompleted(object sender, GFWListUpdater.ResultEventArgs e)\n        {
    {\n        public const string PAC_FILE = "pac.txt";\n        public const string USER_RULE_FILE = "user-rule.txt";\n        public const string USER_ABP_FILE = "abp.txt";\n        FileSystemWatcher PACFileWatcher;\n        FileSystemWatcher UserRuleFileWatcher;\n        private Configuration _config;\n        public event EventHandler PACFileChanged;\n        public event EventHandler UserRuleFileChanged;
                object[] state = new object[] {\n                    conn,\n                    buf\n                };\n                conn.BeginReceive(buf, 0, 1024, 0,\n                    new AsyncCallback(ReceiveCallback), state);\n            }\n            catch (ObjectDisposedException)\n            {\n            }
                };\n                conn.BeginReceive(buf, 0, 1024, 0,\n                    new AsyncCallback(ReceiveCallback), state);\n            }\n            catch (ObjectDisposedException)\n            {\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine(e);
                    new AsyncCallback(ReceiveCallback), state);\n            }\n            catch (ObjectDisposedException)\n            {\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine(e);\n            }\n            finally
                int n;\n                using (GZipStream input = new GZipStream(new MemoryStream(pacGZ),\n                    CompressionMode.Decompress, false))\n                {\n                    n = input.Read(buffer, 0, buffer.Length);\n                    if (n == 0)\n                    {\n                        throw new IOException("can not decompress pac");\n                    }
                    {\n                        throw new IOException("can not decompress pac");\n                    }\n                    return System.Text.Encoding.UTF8.GetString(buffer, 0, n);\n                }\n            }\n        }\n        private void ReceiveCallback(IAsyncResult ar)\n        {\n            object[] state = (object[])ar.AsyncState;
                    }\n                    return System.Text.Encoding.UTF8.GetString(buffer, 0, n);\n                }\n            }\n        }\n        private void ReceiveCallback(IAsyncResult ar)\n        {\n            object[] state = (object[])ar.AsyncState;\n            Socket conn = (Socket)state[0];\n            byte[] requestBuf = (byte[])state[1];
                }\n            }\n        }\n        private void ReceiveCallback(IAsyncResult ar)\n        {\n            object[] state = (object[])ar.AsyncState;\n            Socket conn = (Socket)state[0];\n            byte[] requestBuf = (byte[])state[1];\n            try\n            {
        {\n            DestEndPoint = destEndPoint;\n            string request = string.Format(HTTP_CONNECT_TEMPLATE, destEndPoint);
            var b = Encoding.UTF8.GetBytes(request);\n            var st = new HttpState();\n            st.Callback = callback;\n            st.AsyncState = state;\n            _remote.BeginSend(b, 0, b.Length, 0, HttpRequestSendCallback, st);\n        }\n        public void EndConnectDest(IAsyncResult asyncResult)\n        {\n            var state = ((FakeAsyncResult)asyncResult).innerState;\n            if (state.ex != null)
            }\n            catch (ArgumentException)\n            {\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }
            }
                _modifiedConfiguration = new ProxyConfig();\n            UseProxyCheckBox.Checked = _modifiedConfiguration.useProxy;\n            ProxyServerTextBox.Text = _modifiedConfiguration.proxyServer;\n            ProxyPortTextBox.Text = _modifiedConfiguration.proxyPort.ToString();\n        }\n        private void OKButton_Click(object sender, EventArgs e)\n        {\n            if (UseProxyCheckBox.Checked)
        }\n        private void UseProxyCheckBox_CheckedChanged(object sender, EventArgs e)\n        {\n            UpdateEnabled();\n        }\n        private void UpdateEnabled()\n        {\n            if (UseProxyCheckBox.Checked)\n            {\n                ProxyServerTextBox.Enabled = true;
            byte[] input, int ioff, uint ilen,\n            byte[] output);\n    }\n}
                _disposed = true;\n            }\n            if (disposing)\n            {\n                if (_encryptCtx != IntPtr.Zero)\n                {\n                    MbedTLS.cipher_free(_encryptCtx);\n                    Marshal.FreeHGlobal(_encryptCtx);\n                    _encryptCtx = IntPtr.Zero;\n                }
            }\n        }\n        #endregion\n    }\n}
            if (disposing) { }\n            Close();\n            disposed = true;\n        }\n        public void Close()\n        {\n            CloseHandle(handle);\n            handle = IntPtr.Zero;
        }\n        public void Close()\n        {\n            CloseHandle(handle);\n            handle = IntPtr.Zero;
        {\n            CloseHandle(handle);\n            handle = IntPtr.Zero;
        }\n        public bool AddProcess(IntPtr processHandle)\n        {\n            var succ = AssignProcessToJobObject(handle, processHandle);\n            if (!succ)\n            {\n                Logging.Error("Failed to call AssignProcessToJobObject! GetLastError=" + Marshal.GetLastWin32Error());\n            }\n            return succ;\n        }
            {\n                AverageInboundSpeed = (int) inboundSpeedRecords.Average();\n                MinInboundSpeed = inboundSpeedRecords.Min();\n                MaxInboundSpeed = inboundSpeedRecords.Max();\n            }\n            if (outboundSpeedRecords != null && outboundSpeedRecords.Any())\n            {\n                AverageOutboundSpeed = (int) outboundSpeedRecords.Average();
            }\n            if (outboundSpeedRecords != null && outboundSpeedRecords.Any())\n            {\n                AverageOutboundSpeed = (int) outboundSpeedRecords.Average();\n                MinOutboundSpeed = outboundSpeedRecords.Min();\n                MaxOutboundSpeed = outboundSpeedRecords.Max();\n            }\n            if (latencyRecords != null && latencyRecords.Any())
            {\n                AverageOutboundSpeed = (int) outboundSpeedRecords.Average();\n                MinOutboundSpeed = outboundSpeedRecords.Min();\n                MaxOutboundSpeed = outboundSpeedRecords.Max();\n            }\n            if (latencyRecords != null && latencyRecords.Any())\n            {\n                AverageLatency = (int) latencyRecords.Average();
            }\n            if (latencyRecords != null && latencyRecords.Any())\n            {\n                AverageLatency = (int) latencyRecords.Average();\n                MinLatency = latencyRecords.Min();\n                MaxLatency = latencyRecords.Max();\n            }\n        }
            {\n                AverageLatency = (int) latencyRecords.Average();\n                MinLatency = latencyRecords.Min();\n                MaxLatency = latencyRecords.Max();\n            }\n        }\n        public StatisticsRecord(string identifier, ICollection<int?> responseRecords)\n        {\n            ServerIdentifier = identifier;\n            SetResponse(responseRecords);
            }\n        }\n        public StatisticsRecord(string identifier, ICollection<int?> responseRecords)\n        {\n            ServerIdentifier = identifier;\n            SetResponse(responseRecords);\n        }\n        public void SetResponse(ICollection<int?> responseRecords)\n        {\n            if (responseRecords == null) return;
                            };\n            foreach (var data in finalData)\n            {\n                _dataTable.Rows.Add(data.Timestamp, data.Speed, data.PackageLossPercentage, data.Ping);\n            }\n            StatisticsChart.DataBind();\n        }\n        private void serverSelector_SelectionChangeCommitted(object sender, EventArgs e)\n        {\n            LoadChartData();
            {\n                _dataTable.Rows.Add(data.Timestamp, data.Speed, data.PackageLossPercentage, data.Ping);\n            }\n            StatisticsChart.DataBind();\n        }\n        private void serverSelector_SelectionChangeCommitted(object sender, EventArgs e)\n        {\n            LoadChartData();\n        }\n        private void dayMode_CheckedChanged(object sender, EventArgs e)
using System.Net.NetworkInformation;\nusing System.Windows.Forms;\nusing Newtonsoft.Json;\nusing Shadowsocks.Model;\nusing Timer = System.Threading.Timer;\nnamespace Shadowsocks.Controller.Strategy\n{\n    using DataUnit = KeyValuePair<string, string>;\n    using DataList = List<KeyValuePair<string, string>>;\n    class StatisticsStrategy : IStrategy
using Newtonsoft.Json;\nusing Shadowsocks.Model;\nusing Timer = System.Threading.Timer;\nnamespace Shadowsocks.Controller.Strategy\n{\n    using DataUnit = KeyValuePair<string, string>;\n    using DataList = List<KeyValuePair<string, string>>;\n    class StatisticsStrategy : IStrategy\n    {\n        private readonly ShadowsocksController _controller;
namespace Shadowsocks.Controller.Strategy\n{\n    using DataUnit = KeyValuePair<string, string>;\n    using DataList = List<KeyValuePair<string, string>>;\n    class StatisticsStrategy : IStrategy\n    {\n        private readonly ShadowsocksController _controller;\n        private Server _currentServer;\n        private readonly Timer _timer;\n        private Dictionary<string, List<StatisticsRawData>> _rawStatistics;
    class StatisticsStrategy : IStrategy\n    {\n        private readonly ShadowsocksController _controller;\n        private Server _currentServer;\n        private readonly Timer _timer;\n        private Dictionary<string, List<StatisticsRawData>> _rawStatistics;\n        private int ChoiceKeptMilliseconds\n            => (int) TimeSpan.FromMinutes(_controller.StatisticsConfiguration.ChoiceKeptMinutes).TotalMilliseconds;\n        private const int RetryInterval = 2*60*1000; //retry 2 minutes after failed\n        public StatisticsStrategy(ShadowsocksController controller)
        private int ChoiceKeptMilliseconds\n            => (int) TimeSpan.FromMinutes(_controller.StatisticsConfiguration.ChoiceKeptMinutes).TotalMilliseconds;\n        private const int RetryInterval = 2*60*1000; //retry 2 minutes after failed\n        public StatisticsStrategy(ShadowsocksController controller)\n        {\n            _controller = controller;\n            var servers = controller.GetCurrentConfiguration().configs;\n            var randomIndex = new Random().Next() % servers.Count();\n            _currentServer = servers[randomIndex];  //choose a server randomly at first\n            _timer = new Timer(ReloadStatisticsAndChooseAServer);
        public StatisticsStrategy(ShadowsocksController controller)\n        {\n            _controller = controller;\n            var servers = controller.GetCurrentConfiguration().configs;\n            var randomIndex = new Random().Next() % servers.Count();\n            _currentServer = servers[randomIndex];  //choose a server randomly at first\n            _timer = new Timer(ReloadStatisticsAndChooseAServer);\n        }\n        private void ReloadStatisticsAndChooseAServer(object obj)\n        {
        }\n        //return the score by data\n        //server with highest score will be choosen\n        private float GetScore(IEnumerable<StatisticsRawData> rawDataList)\n        {\n            var config = _controller.StatisticsConfiguration;\n            if (config.ByIsp)\n            {\n                var current = AvailabilityStatistics.GetGeolocationAndIsp().Result;\n                rawDataList = rawDataList.Where(data => data.Geolocation == current[0].Value || data.Geolocation == AvailabilityStatistics.State.Unknown);\n                rawDataList = rawDataList.Where(data => data.ISP == current[1].Value || data.ISP == AvailabilityStatistics.State.Unknown);\n                if (rawDataList.LongCount() == 0) return 0; 
        {\n            var config = _controller.StatisticsConfiguration;\n            if (config.ByIsp)\n            {\n                var current = AvailabilityStatistics.GetGeolocationAndIsp().Result;\n                rawDataList = rawDataList.Where(data => data.Geolocation == current[0].Value || data.Geolocation == AvailabilityStatistics.State.Unknown);\n                rawDataList = rawDataList.Where(data => data.ISP == current[1].Value || data.ISP == AvailabilityStatistics.State.Unknown);\n                if (rawDataList.LongCount() == 0) return 0; \n            }\n            if (config.ByHourOfDay)
            var SuccessTimes = (float) dataList.Count(data => data.ICMPStatus.Equals(IPStatus.Success.ToString()));\n            var TimedOutTimes = (float) dataList.Count(data => data.ICMPStatus.Equals(IPStatus.TimedOut.ToString()));\n            var statisticsData = new StatisticsData()\n            {
            {
        private void ChooseNewServer(List<Server> servers)\n        {\n            if (_rawStatistics == null || servers.Count == 0)\n            {\n                return;\n            }\n            try\n            {\n                var bestResult = (from server in servers\n                                  let name = server.FriendlyName()
            {\n                return;\n            }\n            try\n            {\n                var bestResult = (from server in servers\n                                  let name = server.FriendlyName()\n                                  where _rawStatistics.ContainsKey(name)\n                                  select new\n                                  {
                                  select new\n                                  {\n                                      server,\n                                      score = GetScore(_rawStatistics[name])\n                                  }\n                                  ).Aggregate((result1, result2) => result1.score > result2.score ? result1 : result2);\n                if (!_currentServer.Equals(bestResult.server)) //output when enabled\n                {\n                   LogWhenEnabled($"Switch to server: {bestResult.server.FriendlyName()} by statistics: score {bestResult.score}");\n                }
                                  }\n                                  ).Aggregate((result1, result2) => result1.score > result2.score ? result1 : result2);\n                if (!_currentServer.Equals(bestResult.server)) //output when enabled\n                {\n                   LogWhenEnabled($"Switch to server: {bestResult.server.FriendlyName()} by statistics: score {bestResult.score}");\n                }\n                _currentServer = bestResult.server;\n            }\n            catch (Exception e)\n            {
using System.Net.Http;\nusing System.Net.NetworkInformation;\nusing System.Net.Sockets;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing System.Windows.Forms;\nusing Shadowsocks.Model;\nusing Shadowsocks.Util;\nusing Timer = System.Threading.Timer;\nnamespace Shadowsocks.Controller
using Shadowsocks.Model;\nusing Shadowsocks.Util;\nusing Timer = System.Threading.Timer;\nnamespace Shadowsocks.Controller\n{\n    using DataUnit = KeyValuePair<string, string>;\n    using DataList = List<KeyValuePair<string, string>>;\n    internal class AvailabilityStatistics
namespace Shadowsocks.Controller\n{\n    using DataUnit = KeyValuePair<string, string>;\n    using DataList = List<KeyValuePair<string, string>>;\n    internal class AvailabilityStatistics\n    {\n        public static readonly string DateTimePattern = "yyyy-MM-dd HH:mm:ss";
    {\n        public static readonly string DateTimePattern = "yyyy-MM-dd HH:mm:ss";\n        private const string StatisticsFilesName = "shadowsocks.availability.csv";\n        private const string Delimiter = ",";\n        private const int Timeout = 500;\n        private const int DelayBeforeStart = 1000;\n        private int _repeat => _config.RepeatTimesNum;
            ((System.ComponentModel.ISupportInitialize)(this.StatisticsChart)).BeginInit();\n            this.chartModeSelector.SuspendLayout();\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer1)).BeginInit();\n            this.splitContainer1.Panel1.SuspendLayout();\n            this.splitContainer1.Panel2.SuspendLayout();\n            this.splitContainer1.SuspendLayout();\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer2)).BeginInit();\n            this.splitContainer2.Panel1.SuspendLayout();\n            this.splitContainer2.Panel2.SuspendLayout();
            {\n                _registeredEncryptors.Add(method, typeof(AEADMbedTLSEncryptor));\n            }\n            foreach (string method in AEADSodiumEncryptor.SupportedCiphers())\n            {\n                _registeredEncryptors.Add(method, typeof(AEADSodiumEncryptor));\n            }\n        }\n        public static IEncryptor GetEncryptor(string method, string password)\n        {
            {\n                _registeredEncryptors.Add(method, typeof(AEADSodiumEncryptor));\n            }\n        }\n        public static IEncryptor GetEncryptor(string method, string password)\n        {\n            if (method.IsNullOrEmpty())\n            {\n                method = "aes-256-cfb";\n            }
                this.Close();\n            }\n        }\n        private void ConnectCallback(IAsyncResult ar)\n        {\n            if (closed)\n            {\n                return;\n            }\n            try
                // Complete the connection.\n                remote.EndConnect(ar);\n                //Console.WriteLine("Socket connected to {0}",\n                //    remote.RemoteEndPoint.ToString());\n                var latency = DateTime.Now - _startConnectTime;\n                controller.GetCurrentStrategy().UpdateLatency(this.server, latency);\n                StartPipe();\n            }\n            catch (Exception e)\n            {\n                controller.GetCurrentStrategy().SetFailure(this.server);\n                Logging.LogUsefulException(e);
                StartPipe();\n            }\n            catch (Exception e)\n            {\n                controller.GetCurrentStrategy().SetFailure(this.server);\n                Logging.LogUsefulException(e);\n                if (retryCount < 3)\n                {\n                    Console.WriteLine("Connection failed, retrying");\n                    StartConnect();
            }\n        }\n        private void StartPipe()\n        {\n            if (closed)\n            {\n                return;\n            }\n            try\n            {
                {\n                    //set all the connections's proxy as the lan\n                    registry.SetValue(each, defulatValue);\n                }
                }\n            }\n            NotifyIE();\n        }\n        private static String GetTimestamp(DateTime value)\n        {\n            return value.ToString("yyyyMMddHHmmssffff");
        }\n        private static String GetTimestamp(DateTime value)\n        {\n            return value.ToString("yyyyMMddHHmmssffff");\n        }\n    }\n}
                {\n                    g.CopyFromScreen(Screen.PrimaryScreen.Bounds.X,\n                                     Screen.PrimaryScreen.Bounds.Y,\n                                     0, 0,\n                                     bmpScreenCapture.Size,\n                                     CopyPixelOperation.SourceCopy);\n                }\n                resultPoints.Clear();\n             /*   var reader = new BarcodeReader\n                {
                                     CopyPixelOperation.SourceCopy);\n                }\n                resultPoints.Clear();\n             /*   var reader = new BarcodeReader\n                {\n                    PossibleFormats = new List<BarcodeFormat>
                {\n                    PossibleFormats = new List<BarcodeFormat>\n                var result = barcodeReader.Decode(image);\n                var timerStart = DateTime.Now.Ticks;
                {\n                    txtDecoderContent.Text = "No barcode recognized";\n                }\n                labDuration.Text = new TimeSpan(timerStop - timerStart).Milliseconds.ToString("0 ms");\n            }\n         }\n             * */\n        }\nprivate void AutoStartupItem_Click(object sender, EventArgs e) {\nAutoStartupItem.Checked = !AutoStartupItem.Checked;
                }\n                labDuration.Text = new TimeSpan(timerStop - timerStart).Milliseconds.ToString("0 ms");\n            }\n         }\n             * */\n        }\nprivate void AutoStartupItem_Click(object sender, EventArgs e) {\nAutoStartupItem.Checked = !AutoStartupItem.Checked;\nif (!AutoStartup.Set(AutoStartupItem.Checked)) {\nMessageBox.Show("Failed to edit registry");
        }\nprivate void AutoStartupItem_Click(object sender, EventArgs e) {\nAutoStartupItem.Checked = !AutoStartupItem.Checked;\nif (!AutoStartup.Set(AutoStartupItem.Checked)) {\nMessageBox.Show("Failed to edit registry");\n}\n}\n    }\n}
            {\n                return new Config\n                {\n                    server = "127.0.0.1",\n                    server_port = 8388,\n                    local_port = 1081,\n                    password = "barfoo!"
                };\n            }\n        }\n        public static void Save(Config config)\n        {\n            DataContractJsonSerializer ser = new DataContractJsonSerializer(typeof(Config));\n            try\n            {\n                using (FileStream fs = File.Open(@"config.json", FileMode.Create))\n                {
            InitializeComponent();
        {\n            reload(Config.Load());
        }\n        private void button2_Click(object sender, EventArgs e)\n        {\n        }\n        private void Form1_FormClosed(object sender, FormClosedEventArgs e)\n        {\n            local.Stop();\n        }
        {\n        }\n        private void Form1_FormClosed(object sender, FormClosedEventArgs e)\n        {\n            local.Stop();\n        }
            // \n            // button1\n            // \n            this.button1.DialogResult = System.Windows.Forms.DialogResult.OK;\n            this.button1.Location = new System.Drawing.Point(4, 4);\n            this.button1.Name = "button1";\n            this.button1.Size = new System.Drawing.Size(75, 23);\n            this.button1.TabIndex = 0;\n            this.button1.Text = "OK";\n            this.button1.UseVisualStyleBackColor = true;\n            this.button1.Click += new System.EventHandler(this.button1_Click);\n            // \n            // notifyIcon1
            // \n            // notifyIcon1\n            // \n            this.notifyIcon1.ContextMenuStrip = this.contextMenuStrip1;\n            this.notifyIcon1.Icon = ((System.Drawing.Icon)(resources.GetObject("notifyIcon1.Icon")));\n            // \n            // contextMenuStrip1\n            // \n            this.contextMenuStrip1.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {\n            this.ConfigItem,\n            this.QuitItem});
            // \n            // ConfigItem\n            // \n            // QuitItem\n            // 
        }\n        public static string GetString(string key, params object[] args)\n        {\n            return string.Format(_strings.TryGetValue(key.Trim(), out var value) ? value : key, args);\n        }\n        public static void TranslateForm(Form c)\n        {\n            if (c == null) return;\n            c.Text = GetString(c.Text);\n            foreach (var item in ViewUtils.GetChildControls<Control>(c))
        // remote send buffer\n        public byte[] remoteSendBuffer = new byte[BufferSize];\n        // connection receive buffer\n        public byte[] connetionRecvBuffer = new byte[RecvSize];\n        // connection send buffer\n        public byte[] connetionSendBuffer = new byte[BufferSize];\n        // Received data string.\n        public StringBuilder sb = new StringBuilder();\n        private bool connectionShutdown = false;\n        private bool remoteShutdown = false;\n        private bool closed = false;\n        public void Start()\n        {\n            try
        // connection receive buffer\n        public byte[] connetionRecvBuffer = new byte[RecvSize];\n        // connection send buffer\n        public byte[] connetionSendBuffer = new byte[BufferSize];\n        // Received data string.\n        public StringBuilder sb = new StringBuilder();\n        private bool connectionShutdown = false;\n        private bool remoteShutdown = false;\n        private bool closed = false;\n        public void Start()\n        {\n            try\n            {
        // connection send buffer\n        public byte[] connetionSendBuffer = new byte[BufferSize];\n        // Received data string.\n        public StringBuilder sb = new StringBuilder();\n        private bool connectionShutdown = false;\n        private bool remoteShutdown = false;\n        private bool closed = false;\n        public void Start()\n        {\n            try\n            {\n                // TODO async resolving
        // Received data string.\n        public StringBuilder sb = new StringBuilder();\n        private bool connectionShutdown = false;\n        private bool remoteShutdown = false;\n        private bool closed = false;\n        public void Start()\n        {\n            try\n            {\n                // TODO async resolving\n                IPAddress ipAddress;
        private bool connectionShutdown = false;\n        private bool remoteShutdown = false;\n        private bool closed = false;\n        public void Start()\n        {\n            try\n            {\n                // TODO async resolving\n                IPAddress ipAddress;\n                bool parsed = IPAddress.TryParse(config.server, out ipAddress);
            this.tableLayoutPanel4.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel4.Size = new System.Drawing.Size(166, 32);\n            this.tableLayoutPanel4.TabIndex = 8;
            this.tableLayoutPanel4.TabIndex = 8;
        }\n        public void UpdateOutboundCounter(long n)\n        {\n            Interlocked.Add(ref outboundCounter, n);\n            _config.GetCurrentServer().bandwidthOut = outboundCounter;\n        }\n        protected void Reload()\n        {\n            // some logic in configuration updated the config when saving, we need to read it again\n            _config = Configuration.Load();\n            inboundCounter = _config.GetCurrentServer().bandwidthIn;
        }\n        protected void Reload()\n        {\n            // some logic in configuration updated the config when saving, we need to read it again\n            _config = Configuration.Load();\n            inboundCounter = _config.GetCurrentServer().bandwidthIn;\n            outboundCounter = _config.GetCurrentServer().bandwidthOut;\n            StatisticsConfiguration = StatisticsStrategyConfiguration.Load();\n            if (polipoRunner == null)\n            {\n                polipoRunner = new PolipoRunner();
            StatisticsConfiguration = StatisticsStrategyConfiguration.Load();\n            if (polipoRunner == null)\n            {\n                polipoRunner = new PolipoRunner();\n            }\n            if (_pacServer == null)\n            {\n                _pacServer = new PACServer();\n                _pacServer.PACFileChanged += pacServer_PACFileChanged;\n                _pacServer.UserRuleFileChanged += pacServer_UserRuleFileChanged;
            public UDPHandler(Socket local, Server server, IPEndPoint localEndPoint)\n            {\n                _local = local;\n                _server = server;\n                _localEndPoint = localEndPoint;\n                // TODO async resolving\n                IPAddress ipAddress;\n                bool parsed = IPAddress.TryParse(server.server, out ipAddress);\n                if (!parsed)\n                {
            }\n            public void Send(byte[] data, int length)\n            {\n                IEncryptor encryptor = EncryptorFactory.GetEncryptor(_server.method, _server.password, _server.auth, true);\n                byte[] dataIn = new byte[length - 3 + IVEncryptor.ONETIMEAUTH_BYTES];\n                Array.Copy(data, 3, dataIn, 0, length - 3);\n                byte[] dataOut = new byte[length - 3 + 16 + IVEncryptor.ONETIMEAUTH_BYTES];\n                int outlen;\n                encryptor.Encrypt(dataIn, length - 3, dataOut, out outlen);\n                Logging.Debug(_localEndPoint, _remoteEndPoint, outlen, "UDP Relay");
            if (_remote == null)\n            {\n                _remote = new Socket(realEndPoint.AddressFamily, SocketType.Stream, ProtocolType.Tcp);\n                _remote.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n            }\n            _remote.BeginConnect(realEndPoint, callback, state);\n        }\n        public void EndConnectDest(IAsyncResult asyncResult)\n        {\n            _remote?.EndConnect(asyncResult);
                _remote.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n            }\n            _remote.BeginConnect(realEndPoint, callback, state);\n        }\n        public void EndConnectDest(IAsyncResult asyncResult)\n        {\n            _remote?.EndConnect(asyncResult);\n        }\n        public void BeginSend(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state)
        }\n        public void EndConnectDest(IAsyncResult asyncResult)\n        {\n            _remote?.EndConnect(asyncResult);\n        }\n        public void BeginSend(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state)\n        {\n            _remote?.BeginSend(buffer, offset, size, socketFlags, callback, state);\n        }
                if (_config.useProxy)\n                {\n                    IPAddress ipAddress;\n                    bool parsed = IPAddress.TryParse(_config.proxyServer, out ipAddress);\n                    if (!parsed)\n                    {\n                        /*\n                         * TODO really necessary to resolve a proxy's address? Maybe from local hosts?\n                         * also we may simplify it by using dual-mode socket with \n                         * the approach described in DirectConnect.BeginConnectDest
                    remote = new Socks5Proxy();\n                    proxyEP = new IPEndPoint(ipAddress, _config.proxyPort);\n                }\n                else\n                {\n                    remote = new DirectConnect();\n                    proxyEP = null;\n                }\n                ProxyTimer proxyTimer = new ProxyTimer(3000);\n                proxyTimer.AutoReset = false;
                }\n                else\n                {\n                    remote = new DirectConnect();\n                    proxyEP = null;\n                }\n                ProxyTimer proxyTimer = new ProxyTimer(3000);\n                proxyTimer.AutoReset = false;\n                proxyTimer.Elapsed += proxyConnectTimer_Elapsed;\n                proxyTimer.Enabled = true;
            _notifyIcon.Visible = true;\n            _notifyIcon.Text = I18N.GetString("Shadowsocks");\n            _notifyIcon.ContextMenu = contextMenu1;\n            _notifyIcon.DoubleClick += notifyIcon1_DoubleClick;\n            this.updateChecker = new UpdateChecker();\n            updateChecker.NewVersionFound += updateChecker_NewVersionFound;\n            LoadCurrentConfiguration();\n            updateChecker.CheckUpdate();\n            if (controller.GetConfiguration().isDefault)\n            {
            _notifyIcon.ContextMenu = contextMenu1;\n            _notifyIcon.DoubleClick += notifyIcon1_DoubleClick;\n            this.updateChecker = new UpdateChecker();\n            updateChecker.NewVersionFound += updateChecker_NewVersionFound;\n            LoadCurrentConfiguration();\n            updateChecker.CheckUpdate();\n            if (controller.GetConfiguration().isDefault)\n            {\n                _isFirstRun = true;\n                ShowConfigForm();
        }\n        void controller_ShareOverLANStatusChanged(object sender, EventArgs e)\n        {\n            ShareOverLANItem.Checked = controller.GetConfiguration().shareOverLan;\n        }\n        void controller_EnableGlobalChanged(object sender, EventArgs e)\n        {\n            globalModeItem.Checked = controller.GetConfiguration().global;\n            PACModeItem.Checked = !globalModeItem.Checked;\n        }
            // \n            // EncryptionLabel\n            // \n            this.EncryptionLabel.Anchor = System.Windows.Forms.AnchorStyles.Right;\n            this.EncryptionLabel.AutoSize = true;\n            this.EncryptionLabel.Location = new System.Drawing.Point(12, 91);\n            this.EncryptionLabel.Name = "EncryptionLabel";\n            this.EncryptionLabel.Size = new System.Drawing.Size(65, 12);\n            this.EncryptionLabel.TabIndex = 8;\n            this.EncryptionLabel.Text = "Encryption";
        private bool _isFirstRun;\n        private bool _isStartupChecking;\n        private MenuItem disableItem;\n        private MenuItem AutoStartupItem;\n        private MenuItem ShareOverLANItem;\n        private MenuItem SeperatorItem;\n        private MenuItem ConfigItem;\n        private MenuItem ServersItem;
                _notifyIcon.Icon = newIcon;\n            }\n        }\n        void controller_Errored(object sender, System.IO.ErrorEventArgs e)\n        {\n            MessageBox.Show(e.GetException().ToString(), I18N.GetString("Shadowsocks Error: {0}", e.GetException().Message));\n        }\n        #region Tray Icon\n        private void UpdateTrayIcon()\n        {\n            int dpi;
            Configuration config = controller.GetConfigurationCopy();\n            bool enabled = config.enabled;\n            bool global = config.global;\n            // set Windows 10 Theme color (1903+)\n            currentWindowsThemeMode = Utils.GetWindows10SystemThemeSetting();\n            if (currentWindowsThemeMode == Utils.WindowsThemeMode.Light)\n                if (!global || !enabled)\n                    icon_baseBitmap = getDarkTrayIcon(icon_baseBitmap);\n            icon_baseBitmap = getTrayIconByState(icon_baseBitmap, enabled, global);\n            icon_base = Icon.FromHandle(icon_baseBitmap.GetHicon());
            string serverInfo = null;\n            if (controller.GetCurrentStrategy() != null)\n            {\n                serverInfo = controller.GetCurrentStrategy().Name;\n            }\n            else\n            {\n                serverInfo = config.GetCurrentServer().FriendlyName();\n            }\n            // show more info by hacking the P/Invoke declaration for NOTIFYICONDATA inside Windows Forms
                    {\n                        Color flyBlue = Color.FromArgb(192, 0, 0, 0);\n                        // Multiply with flyBlue\n                        int red = color.R * flyBlue.R / 255;\n                        int green = color.G * flyBlue.G / 255;\n                        int blue = color.B * flyBlue.B / 255;\n                        int alpha = color.A;\n                        iconCopy.SetPixel(x, y, Color.FromArgb(alpha, red, green, blue));\n                    }\n                    else
                    }\n                    else\n                    {\n                        iconCopy.SetPixel(x, y, Color.FromArgb(color.A, color.R, color.G, color.B));\n                    }\n                }\n            }\n            return iconCopy;\n        }\n        private Bitmap getTrayIconByState(Bitmap originIcon, bool enabled, bool global)
        }\n        #endregion\n        #region MenuItems and MenuGroups\n        private MenuItem CreateMenuItem(string text, EventHandler click)\n        {\n            return new MenuItem(I18N.GetString(text), click);\n        }\n        private MenuItem CreateMenuGroup(string text, MenuItem[] items)\n        {\n            return new MenuItem(I18N.GetString(text), items);
            try\n            {\n                RegistryKey reg_HKCU = Registry.CurrentUser;\n                RegistryKey reg_ThemesPersonalize = reg_HKCU.OpenSubKey(@"Software\Microsoft\Windows\CurrentVersion\Themes\Personalize", false);\n                if (reg_ThemesPersonalize.GetValue("SystemUsesLightTheme") != null)\n                {\n                    if (Convert.ToInt32(reg_ThemesPersonalize.GetValue("SystemUsesLightTheme").ToString()) == 0) // 0:dark mode, 1:light mode\n                        registData = WindowsThemeMode.Dark;\n                    else
                if (reg_ThemesPersonalize.GetValue("SystemUsesLightTheme") != null)\n                {\n                    if (Convert.ToInt32(reg_ThemesPersonalize.GetValue("SystemUsesLightTheme").ToString()) == 0) // 0:dark mode, 1:light mode\n                        registData = WindowsThemeMode.Dark;\n                    else\n                        registData = WindowsThemeMode.Light;\n                    //Console.WriteLine(registData);\n                }\n                else\n                {
                    else\n                        registData = WindowsThemeMode.Light;\n                    //Console.WriteLine(registData);\n                }\n                else\n                {\n                    throw new Exception("Reg-Value SystemUsesLightTheme not found.");\n                }\n            }\n            catch
                }\n                else\n                {\n                    throw new Exception("Reg-Value SystemUsesLightTheme not found.");\n                }\n            }\n            catch\n            {\n                Logging.Info(\n                        $"Cannot get Windows 10 system theme mode, return default value 0 (dark mode).");

            InitializeComponent();\n            // a dirty hack\n            this.ServersListBox.Dock = System.Windows.Forms.DockStyle.Fill;\n            this.PerformLayout();\n            UpdateTexts();\n            this.Icon = Icon.FromHandle(Resources.ssw128.GetHicon());\n            this.controller = controller;\n            controller.ConfigChanged += controller_ConfigChanged;\n            LoadCurrentConfiguration();
            this.PerformLayout();\n            UpdateTexts();\n            this.Icon = Icon.FromHandle(Resources.ssw128.GetHicon());\n            this.controller = controller;\n            controller.ConfigChanged += controller_ConfigChanged;\n            LoadCurrentConfiguration();\n        }\n        private void UpdateTexts()\n        {\n            AddButton.Text = I18N.GetString("&Add");
            this.PluginArgumentsTextBox = new System.Windows.Forms.TextBox();\n            this.PluginArgumentsLabel = new System.Windows.Forms.Label();\n            this.panel2 = new System.Windows.Forms.Panel();\n            this.OKButton = new System.Windows.Forms.Button();\n            this.MyCancelButton = new System.Windows.Forms.Button();\n            this.DeleteButton = new System.Windows.Forms.Button();\n            this.AddButton = new System.Windows.Forms.Button();\n            this.ServerGroupBox = new System.Windows.Forms.GroupBox();\n            this.ServersListBox = new System.Windows.Forms.ListBox();
            this.tableLayoutPanel5.AutoSize = true;\n            this.tableLayoutPanel5.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;\n            this.tableLayoutPanel5.ColumnCount = 2;\n            this.tableLayoutPanel5.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());\n            this.tableLayoutPanel5.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());\n            this.tableLayoutPanel5.Controls.Add(this.ProxyPortTextBox, 1, 0);\n            this.tableLayoutPanel5.Controls.Add(this.ProxyPortLabel, 0, 0);\n            this.tableLayoutPanel5.Location = new System.Drawing.Point(272, 308);
            this.tableLayoutPanel5.Margin = new System.Windows.Forms.Padding(0);\n            this.tableLayoutPanel5.Name = "tableLayoutPanel5";\n            this.tableLayoutPanel5.Padding = new System.Windows.Forms.Padding(3);\n            this.tableLayoutPanel5.RowCount = 1;\n            this.tableLayoutPanel5.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel5.RowStyles.Add(new System.Windows.Forms.RowStyle());
                    string jsonString = JsonConvert.SerializeObject(_userSettings, Formatting.Indented);\n                    sw.Write(jsonString);\n                    sw.Flush();\n                }\n            } catch (IOException e) {\n                Logging.LogUsefulException(e);\n            }
                _userSettings = JsonConvert.DeserializeObject<SysproxyConfig>(configContent);\n            } catch(Exception) {\n               // Suppress all exceptions. finally block will initialize new user config settings.\n            } finally {\n                if (_userSettings == null) _userSettings = new SysproxyConfig();\n            }\n        }
using System.Net;\nusing System.Net.Sockets;\nusing System.Timers;\nusing Shadowsocks.Controller.Strategy;\nusing Shadowsocks.Encryption;\nusing Shadowsocks.ForwardProxy;\nusing Shadowsocks.Model;\nusing Shadowsocks.Util.Sockets;\nnamespace Shadowsocks.Controller\n{
{\n    class TCPRelay : Listener.Service\n    {\n        private ShadowsocksController _controller;\n        private DateTime _lastSweepTime;\n        private Configuration _config;\n        public ISet<TCPHandler> Handlers { get; set; }\n        public TCPRelay(ShadowsocksController controller, Configuration conf)
        public TCPRelay(ShadowsocksController controller, Configuration conf)\n        {\n            _controller = controller;\n            _config = conf;\n            Handlers = new HashSet<TCPHandler>();\n            _lastSweepTime = DateTime.Now;\n        }\n        public override bool Handle(byte[] firstPacket, int length, Socket socket, object state)
            _lastSweepTime = DateTime.Now;\n        }\n        public override bool Handle(byte[] firstPacket, int length, Socket socket, object state)\n        {\n            if (socket.ProtocolType != ProtocolType.Tcp\n                || (length < 2 || firstPacket[0] != 5))
                return false;\n            socket.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n            TCPHandler handler = new TCPHandler(_controller, _config, this, socket);\n            IList<TCPHandler> handlersToClose = new List<TCPHandler>();\n            lock (Handlers)\n            {\n                Handlers.Add(handler);\n                DateTime now = DateTime.Now;\n                if (now - _lastSweepTime > TimeSpan.FromSeconds(1))
            IList<TCPHandler> handlersToClose = new List<TCPHandler>();\n            lock (Handlers)\n            {\n                Handlers.Add(handler);\n                DateTime now = DateTime.Now;\n                if (now - _lastSweepTime > TimeSpan.FromSeconds(1))\n                {\n                    _lastSweepTime = now;\n                    foreach (TCPHandler handler1 in Handlers)\n                        if (now - handler1.lastActivity > TimeSpan.FromSeconds(900))
    {\n        class AsyncSession
        {\n            public IForwardProxy Remote { get; }\n            public AsyncSession(IForwardProxy remote)\n            {\n                Remote = remote;\n            }\n        }\n        class AsyncSession<T> : AsyncSession\n        {\n            public T State { get; set; }
        {\n            public T State { get; set; }\n            public AsyncSession(IForwardProxy remote, T state) : base(remote)\n            {\n                State = state;\n            }
        private AsyncSession _currentRemoteSession;\n        private bool        _proxyConnected;\n        private bool        _destConnected;\n        private byte    _command;\n        private byte[]  _firstPacket;\n        private int     _firstPacketLength;\n        private int     _totalRead = 0;\n        private int     _totalWrite = 0;\n        private byte[]  _remoteRecvBuffer = new byte[BufferSize];\n        private byte[]  _remoteSendBuffer = new byte[BufferSize];
        private DateTime _startConnectTime;\n        private DateTime _startReceivingTime;\n        private DateTime _startSendingTime;\n        private EndPoint _destEndPoint = null;\n        public TCPHandler(ShadowsocksController controller, Configuration config, TCPRelay tcprelay, Socket socket)\n        {\n            _controller = controller;
        {\n            _controller = controller;\n        }\n        public void CreateRemote()
            if (server == null || server.server == "")\n                throw new ArgumentException("No server configured");\n            lock (_encryptionLock)\n            {\n                lock (_decryptionLock)\n                {\n                    _encryptor = EncryptorFactory.GetEncryptor(server.method, server.password, server.auth, false);\n                }\n            }\n            this._server = server;
            try\n            {\n                _startReceivingTime = DateTime.Now;\n                session.Remote.BeginReceive(_remoteRecvBuffer, 0, RecvSize, SocketFlags.None, new AsyncCallback(PipeRemoteReceiveCallback), session);\n                SendToServer(_firstPacketLength, session);\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();
            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void PipeRemoteReceiveCallback(IAsyncResult ar)\n        {
            IStrategy strategy = _controller.GetCurrentStrategy();\n            strategy?.UpdateLastWrite(_server);\n        }\n        private void PipeRemoteSendCallback(IAsyncResult ar)
            try\n            {\n                var session = (AsyncSession)ar.AsyncState;\n                session.Remote.EndSend(ar);\n                _connection.BeginReceive(_connetionRecvBuffer, 0, RecvSize, SocketFlags.None, new AsyncCallback(PipeConnectionReceiveCallback), session);\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();
            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }\n    }\n}
                _listener = new Listener(services);\n                _listener.Start(_config);\n            }\n            catch (Exception e)\n            {\n                // translate Microsoft language into human language\n                // i.e. An attempt was made to access a socket in a way forbidden by its access permissions => Port already in use\n                if (e is SocketException)\n                {\n                    SocketException se = (SocketException)e;
            // 构造request包剩余部分\n            request[0] = 5;\n            request[1] = 1;\n            request[2] = 0;\n            request[3] = atyp;\n            request[request.Length - 2] = (byte) ((port >> 8) & 0xff);\n            request[request.Length - 1] = (byte) (port & 0xff);\n            var st = new Socks5State();\n            st.Callback = callback;\n            st.AsyncState = state;\n            _remote.BeginSend(request, 0, request.Length, 0, Socks5RequestSendCallback, st);
            var st = new Socks5State();\n            st.Callback = callback;\n            st.AsyncState = state;\n            _remote.BeginSend(request, 0, request.Length, 0, Socks5RequestSendCallback, st);\n        }\n        public void EndConnectDest(IAsyncResult asyncResult)\n        {\n            var state = ((FakeAsyncResult)asyncResult).innerState;\n            if (state.ex != null)\n            {
            int entryNameSize = 0;\n            int lpSize = 0;\n            uint retval = ERROR_SUCCESS;\n            RasEntryName[] names = null;\n            entryNameSize = Marshal.SizeOf(typeof(RasEntryName));\n            lpSize = lpNames * entryNameSize;\n            names = new RasEntryName[lpNames];\n            names[0].dwSize = entryNameSize;\n            retval = RAS.RasEnumEntries(null, null, names, ref lpSize, out lpNames);\n            //if we have more than one connection, we need to resize
            if (retval == ERROR_BUFFER_TOO_SMALL)\n            {\n                names = new RasEntryName[lpNames];\n                for (int i = 0; i < names.Length; i++)\n                {\n                    names[i].dwSize = entryNameSize;\n                }\n                retval = RAS.RasEnumEntries(null, null, names, ref lpSize, out lpNames);\n            }\n            if (retval == ERROR_SUCCESS)
            }\n            if (retval == ERROR_SUCCESS)\n            {\n                if (lpNames == 0)\n                {\n                    // no entries found.\n                    return 1;\n                }\n                allConns = new string[names.Length];\n                for (int i = 0; i < names.Length; i++)
            foreach (var strategy in controller.GetStrategies())\n            {\n                MenuItem item = new MenuItem(strategy.Name);\n                item.Tag = strategy.ID;\n                item.Click += AStrategyItem_Click;\n                items.Add(i, item);\n                i++;\n            }\n            // user wants a seperator item between strategy and servers menugroup\n            items.Add(i++, new MenuItem("-"));\n            int strategyCount = i;
            }\n            // user wants a seperator item between strategy and servers menugroup\n            items.Add(i++, new MenuItem("-"));\n            int strategyCount = i;\n            Configuration configuration = controller.GetConfigurationCopy();\n            foreach (var server in configuration.configs)\n            {\n                if (Configuration.ChecksServer(server))\n                {\n                    MenuItem item = new MenuItem(server.FriendlyName());\n                    item.Tag = i - strategyCount;
            Configuration configuration = controller.GetConfigurationCopy();\n            foreach (var server in configuration.configs)\n            {\n                if (Configuration.ChecksServer(server))\n                {\n                    MenuItem item = new MenuItem(server.FriendlyName());\n                    item.Tag = i - strategyCount;\n                    item.Click += AServerItem_Click;\n                    items.Add(i, item);\n                    i++;
                    item.Click += AServerItem_Click;\n                    items.Add(i, item);\n                    i++;

                }),\n                new MenuItem("-"),\n                this.AutoStartupItem = CreateMenuItem("Start on Boot", new EventHandler(this.AutoStartupItem_Click)),\n                this.ShareOverLANItem = CreateMenuItem("Share over LAN", new EventHandler(this.ShareOverLANItem_Click)),\n                CreateMenuItem("Edit PAC File...", new EventHandler(this.EditPACFileItem_Click)),\n                CreateMenuItem("Update PAC from GFWList", new EventHandler(this.UpdatePACFromGFWListItem_Click)),\n                new MenuItem("-"),\n                CreateMenuItem("Show QRCode...", new EventHandler(this.QRCodeItem_Click)),\n                CreateMenuItem("Scan QRCode...", new EventHandler(this.ScanQRCodeItem_Click)),\n                CreateMenuItem("Show Logs...", new EventHandler(this.ShowLogItem_Click)),
                CreateMenuItem("Show Logs...", new EventHandler(this.ShowLogItem_Click)),\n                CreateMenuItem("About...", new EventHandler(this.AboutItem_Click)),\n                new MenuItem("-"),\n                CreateMenuItem("Quit", new EventHandler(this.Quit_Click))\n            });\n        }\n        private void controller_ConfigChanged(object sender, EventArgs e)\n        {\n            LoadCurrentConfiguration();\n            UpdateTrayIcon();
            Configuration configuration = controller.GetConfiguration();\n            for (int i = 0; i < configuration.configs.Count; i++)\n            {\n                Server server = configuration.configs[i];\n                MenuItem item = new MenuItem(server.FriendlyName());\n                item.Tag = i;\n                item.Click += AServerItem_Click;\n                items.Add(item);\n            }\n            items.Add(SeperatorItem);
            if (configuration.index >= 0 && configuration.index < configuration.configs.Count)\n            {\n                items[configuration.index].Checked = true;\n            }\n        }\n        private void ShowConfigForm()\n        {\n            if (configForm != null)\n            {\n                configForm.Activate();
                }\n            }\n        }\nprivate void AutoStartupItem_Click(object sender, EventArgs e) {\nAutoStartupItem.Checked = !AutoStartupItem.Checked;\nif (!AutoStartup.Set(AutoStartupItem.Checked)) {\nMessageBox.Show("Failed to edit registry");\n}\n}
            if (File.Exists(PACServer.USER_RULE_FILE))\n            {\n                string local = File.ReadAllText(PACServer.USER_RULE_FILE, Encoding.UTF8);\n                using (var sr = new StringReader(local))\n                {\n                    foreach (var rule in sr.NonWhiteSpaceLines())\n                    {\n                        if (rule.BeginWithAny(IgnoredLineBegins))\n                            continue;\n                        lines.Add(rule);
                using (var sr = new StringReader(local))\n                {\n                    foreach (var rule in sr.NonWhiteSpaceLines())\n                    {\n                        if (rule.BeginWithAny(IgnoredLineBegins))\n                            continue;\n                        lines.Add(rule);\n                    }\n                }\n            }
        }\n        void controller_ShareOverLANStatusChanged(object sender, EventArgs e)\n        {\n            ShareOverLANItem.Checked = controller.GetConfigurationCopy().shareOverLan;\n        }\n        void controller_VerboseLoggingStatusChanged(object sender, EventArgs e) {\n            VerboseLoggingToggleItem.Checked = controller.GetConfigurationCopy().isVerboseLogging;\n        }
        }\n        private void GlobalModeItem_Click(object sender, EventArgs e)\n        {\n            controller.ToggleGlobal(true);\n        }\n        private void PACModeItem_Click(object sender, EventArgs e)\n        {
                StreamWriterWithTimestamp sw = new StreamWriterWithTimestamp(fs);\n                sw.AutoFlush = true;\n                Console.SetOut(sw);\n                Console.SetError(sw);\n                return true;\n            }\n            catch (IOException e)\n            {\n                Console.WriteLine(e.ToString());\n                return false;
            if (polipoRunner == null)\n            {\n                polipoRunner = new PolipoRunner();\n            }\n            polipoRunner.Start(config);\n        }\n        private void Config_Click(object sender, EventArgs e)\n        {
        {\n            MenuItem result = new MenuItem(I18N.GetString(text), click);\n            result.Index = index;\n            return result;\n        }\n        private MenuItem CreateSeperatorItem(int index)\n        {\n            MenuItem result = new MenuItem("-");\n            result.Index = index;\n            return result;
            return result;\n        }\n        private MenuItem CreateSeperatorItem(int index)\n        {\n            MenuItem result = new MenuItem("-");\n            result.Index = index;\n            return result;\n        }\n        private MenuItem CreateMenuGroup(int index, string text, MenuItem[] items)\n        {
        {\n            MenuItem result = new MenuItem("-");\n            result.Index = index;\n            return result;\n        }\n        private MenuItem CreateMenuGroup(int index, string text, MenuItem[] items)\n        {
            return result;\n        }\n        private MenuItem CreateMenuGroup(int index, string text, MenuItem[] items)\n        {\n            MenuItem result = new MenuItem(I18N.GetString(text), items);\n            result.Index = index;
            MenuItem result = new MenuItem(I18N.GetString(text), items);\n            result.Index = index;\n            return result;\n        }\n        private void LoadMenu()\n        {\n            this.contextMenu1 = new System.Windows.Forms.ContextMenu();\n            this.PACModeItem = CreateMenuItem(0, "PAC", new System.EventHandler(this.PACModeItem_Click));\n            this.globalModeItem = CreateMenuItem(1, "Global", new System.EventHandler(this.GlobalModeItem_Click));\n            this.SeperatorItem = CreateSeperatorItem(0);
            return result;\n        }\n        private void LoadMenu()\n        {\n            this.contextMenu1 = new System.Windows.Forms.ContextMenu();\n            this.PACModeItem = CreateMenuItem(0, "PAC", new System.EventHandler(this.PACModeItem_Click));\n            this.globalModeItem = CreateMenuItem(1, "Global", new System.EventHandler(this.GlobalModeItem_Click));\n            this.SeperatorItem = CreateSeperatorItem(0);\n            this.ConfigItem = CreateMenuItem(1, "Edit Servers...", new System.EventHandler(this.Config_Click));\n            this.enableItem = CreateMenuItem(0, "Enable", new System.EventHandler(this.EnableItem_Click));
            });\n            this.AutoStartupItem = CreateMenuItem(4, "Start on Boot", new System.EventHandler(this.AutoStartupItem_Click));\n            this.ShareOverLANItem = CreateMenuItem(5, "Share over LAN", new System.EventHandler(this.ShareOverLANItem_Click));\n            this.contextMenu1.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {\n            this.enableItem,\n            CreateMenuGroup(1, "Mode", new System.Windows.Forms.MenuItem[] {\n                this.PACModeItem,\n                this.globalModeItem\n            }),\n            this.ServersItem,
        }\n        private void controller_ConfigChanged(object sender, EventArgs e)\n        {\n            LoadCurrentConfiguration();\n            UpdateTrayIcon();\n        }\n        private void controller_EnableStatusChanged(object sender, EventArgs e)\n        {\n            enableItem.Checked = controller.GetConfiguration().enabled;\n        }
                    {\n                        case 1:  // IPv4 address, 4 bytes\n                            dst_addr = new IPAddress(_connetionRecvBuffer.Skip(1).Take(4).ToArray()).ToString();\n                            dst_port = (_connetionRecvBuffer[5] << 8) + _connetionRecvBuffer[6];\n                            if ( _config.isVerboseLogging ) {\n                                Logging.Info( $"connect to {dst_addr}:{dst_port}" );\n                            }\n                            break;\n                        case 3:  // domain name, length + str\n                            int len = _connetionRecvBuffer[1];
                    }\n                    int bytesToSend;\n                    lock (_encryptionLock)\n                    {\n                        if (_closed) return;\n                        encryptor.Encrypt(_connetionRecvBuffer, bytesRead, _connetionSendBuffer, out bytesToSend);\n                    }\n                    _tcprelay.UpdateOutboundCounter(server, bytesToSend);\n                    _startSendingTime = DateTime.Now;\n                    _bytesToSend = bytesToSend;
        public string version;\n        public List<Server> configs;\n        // when strategy is set, index is ignored\n        public string strategy;\n        public int index;\n        public bool global;\n        public bool enabled;\n        public bool shareOverLan;\n        public bool isDefault;\n        // hidden\n        public bool isIPv6Enabled = false;\n        public int localPort;
        public int localPort;\n        public bool portableMode = true;\n        public bool showPluginOutput;\n        public string pacUrl;\n        // geosite config is hidden\n        public string geositeUrl;\n        public string geositeGroup = "geolocation-!cn";\n        public bool geositeBlacklistMode = true;\n        public bool useOnlinePac;\n        public bool secureLocalPac = true;\n        public bool availabilityStatistics;
        public bool useOnlinePac;\n        public bool secureLocalPac = true;\n        public bool availabilityStatistics;\n        public bool autoCheckUpdate;\n        public bool checkPreRelease;\n        public bool isVerboseLogging;\n        // hidden config\n        public bool generateLegacyUrl = false;
        //public NLogConfig.LogLevel logLevel;\n        public LogViewerConfig logViewer;\n        public ProxyConfig proxy;\n        public HotkeyConfig hotkey;\n        [JsonIgnore]\n        NLogConfig nLogConfig;\n        private static readonly string CONFIG_FILE = "gui-config.json";\n        private static readonly NLogConfig.LogLevel verboseLogLevel =\n#if DEBUG\n        NLogConfig.LogLevel.Trace;\n#else\n        NLogConfig.LogLevel.Debug;\n#endif
#if DEBUG\n        NLogConfig.LogLevel.Trace;\n#else\n        NLogConfig.LogLevel.Debug;\n#endif\n        [JsonIgnore]\n        public bool updated = false;\n        [JsonIgnore]\n        public string localHost => GetLocalHost();\n        private string GetLocalHost()\n        {\n            return isIPv6Enabled ? "[::1]" : "127.0.0.1";
#else\n        NLogConfig.LogLevel.Debug;\n#endif\n        [JsonIgnore]\n        public bool updated = false;\n        [JsonIgnore]\n        public string localHost => GetLocalHost();\n        private string GetLocalHost()\n        {\n            return isIPv6Enabled ? "[::1]" : "127.0.0.1";\n        }
#endif\n        [JsonIgnore]\n        public bool updated = false;\n        [JsonIgnore]\n        public string localHost => GetLocalHost();\n        private string GetLocalHost()\n        {\n            return isIPv6Enabled ? "[::1]" : "127.0.0.1";\n        }\n        public Server GetCurrentServer()
using System.Text;\nusing System.Windows.Forms;\nusing Shadowsocks.Controller;\nusing Shadowsocks.Controller.Hotkeys;\nusing Shadowsocks.Model;\nusing Shadowsocks.Properties;\nusing Shadowsocks.Util;\nnamespace Shadowsocks.View\n{\n    public partial class HotkeySettingsForm : Form
using Shadowsocks.Model;\nusing Shadowsocks.Properties;\nusing Shadowsocks.Util;\nnamespace Shadowsocks.View\n{\n    public partial class HotkeySettingsForm : Form\n    {\n        private readonly ShadowsocksController _controller;\n        // this is a copy of hotkey configuration that we are working on\n        private HotkeyConfig _modifiedHotkeyConfig;
namespace Shadowsocks.View\n{\n    public partial class HotkeySettingsForm : Form\n    {\n        private readonly ShadowsocksController _controller;\n        // this is a copy of hotkey configuration that we are working on\n        private HotkeyConfig _modifiedHotkeyConfig;\n        public HotkeySettingsForm(ShadowsocksController controller)\n        {\n            InitializeComponent();
        }\n        private bool RegHotkeyFromString(string hotkeyStr, string callbackName, Label indicator = null)\n        {\n            var _callback = HotkeyCallbacks.GetCallback(callbackName);\n            if (_callback == null)\n            {\n                throw new Exception($"{callbackName} not found");\n            }\n            var callback = _callback as HotKeys.HotKeyCallBackHandler;
        {\n            var _callback = HotkeyCallbacks.GetCallback(callbackName);\n            if (_callback == null)\n            {\n                throw new Exception($"{callbackName} not found");\n            }\n            var callback = _callback as HotKeys.HotKeyCallBackHandler;\n            if (hotkeyStr.IsNullOrEmpty())\n            {
            {\n                throw new Exception($"{callbackName} not found");\n            }\n            var callback = _callback as HotKeys.HotKeyCallBackHandler;\n            if (hotkeyStr.IsNullOrEmpty())\n            {\n                HotKeys.UnregExistingHotkey(callback);\n                if (indicator != null)\n                {\n                    indicator.ResetBackColor();
                    MessageBox.Show(string.Format(I18N.GetString("Cannot parse hotkey: {0}"), hotkeyStr));\n                    return false;\n                }\n                else\n                {\n                    bool regResult = (HotKeys.RegHotkey(hotkey, callback));\n                    if (indicator != null)\n                    {\n                        indicator.BackColor = regResult ? Color.Green : Color.Yellow;\n                    }
            }\n        }\n    }\n}
            {\n                _isStartupChecking = true;\n                updateChecker.CheckUpdate(config, 3000);\n            }\n            if (config.isDefault)\n            {\n                _isFirstRun = true;\n                ShowConfigForm();

            }\n            else if (!_isStartupChecking)\n            {\n                ShowBalloonTip(I18N.GetString("Shadowsocks"), I18N.GetString("No update is available"), ToolTipIcon.Info, 5000);\n                _isFirstRun = false;\n            }\n            _isStartupChecking = false;\n        }\n        void notifyIcon1_BalloonTipClicked(object sender, EventArgs e)\n        {
            }\n            _isStartupChecking = false;\n        }\n        void notifyIcon1_BalloonTipClicked(object sender, EventArgs e)\n        {\n            if (updateChecker.NewVersionFound)\n            {\n                updateChecker.NewVersionFound = false; /* Reset the flag */\n                if (System.IO.File.Exists(updateChecker.LatestVersionLocalName))\n                {

            UpdateMoveUpAndDownButton();\n            LoadSelectedServer();\n        }\n        private void ConfigForm_Load(object sender, EventArgs e)\n        {\n        }\n        private void ServersListBox_SelectedIndexChanged(object sender, EventArgs e)\n        {\n            if (_oldSelectedIndex == ServersListBox.SelectedIndex)\n            {
            {\n                // can be -1\n                _oldSelectedIndex = _modifiedConfiguration.configs.Count - 1;\n            }\n            ServersListBox.SelectedIndex = _oldSelectedIndex;\n            LoadConfiguration(_modifiedConfiguration);\n            ServersListBox.SelectedIndex = _oldSelectedIndex;\n            LoadSelectedServer();\n        }\n        private void OKButton_Click(object sender, EventArgs e)\n        {
            controller.SaveServers(_modifiedConfiguration.configs, _modifiedConfiguration.localPort);\n            controller.SelectServerIndex(index);\n            this.Close();\n        }\n        private void CancelButton_Click(object sender, EventArgs e)\n        {\n            this.Close();\n        }\n        private void ConfigForm_Shown(object sender, EventArgs e)\n        {
            this.Close();\n        }\n        private void CancelButton_Click(object sender, EventArgs e)\n        {\n            this.Close();\n        }\n        private void ConfigForm_Shown(object sender, EventArgs e)\n        {\n            IPTextBox.Focus();\n        }
        protected int _encryptBytesRemaining;\n        protected int _decryptBytesRemaining;\n        protected ulong _encryptIC;\n        protected ulong _decryptIC;\n        public SodiumEncryptor(string method, string password, bool onetimeauth, bool isudp)\n            : base(method, password, onetimeauth, isudp)\n        {
            {\n                if (isCipher)\n                {\n                    bytesRemaining = _encryptBytesRemaining;\n                    ic = _encryptIC;\n                    iv = _encryptIV;\n                }\n                else\n                {\n                    bytesRemaining = _decryptBytesRemaining;
            }\n        }\n        public override void Dispose()\n        {\n        }\n    }\n}
using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.IO.Compression;\nusing System.Text;\nnamespace shadowsocks_csharp.Controller\n{\n    class PolipoRunner\n    {
{\n    class PolipoRunner\n    {\n        private Process process;\n        public void Start(Server config)\n        {\n            if (process == null)\n            {\n                Process[] existingPolipo = Process.GetProcessesByName("ss_polipo");\n                foreach (Process p in existingPolipo)
using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.IO.Compression;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Text;\nnamespace shadowsocks_csharp.Controller\n{
{\n    class PACServer\n    {\n        private static string PAC_FILE = "pac.txt";\n        Socket listener;\n        FileSystemWatcher watcher;\n        public event EventHandler PACFileChanged;\n        public void Start()\n        {\n            // Create a TCP/IP socket.
using System;\nusing System.Collections.Generic;\nusing System.Text;\nnamespace shadowsocks_csharp.Controller\n{\n    public class ShadowsocksController\n    {\n        // controller:\n        // handle user actions\n        // manipulates UI
{\n    public class ShadowsocksController\n    {\n        // controller:\n        // handle user actions\n        // manipulates UI\n        // interacts with low level logic\n        private Local local;\n        private PACServer pacServer;\n        private Configuration config;
using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Runtime.InteropServices;\nusing System.Windows.Forms;\nnamespace shadowsocks_csharp\n{\n    static class Program\n    {\n        [DllImport("Kernel32.dll")]
{\n    static class Program\n    {\n        [DllImport("Kernel32.dll")]\n        private static extern IntPtr LoadLibrary(string path);\n        /// <summary>\n        /// 应用程序的主入口点。\n        /// </summary>\n        [STAThread]\n        static void Main()
            }\n        }\n        private void loadCurrentConfiguration()\n        {\n            modifiedConfiguration = controller.GetConfiguration();\n            loadConfiguration(modifiedConfiguration);\n            oldSelectedIndex = modifiedConfiguration.index;\n            ServersListBox.SelectedIndex = modifiedConfiguration.index;\n            loadSelectedServer();
            this.editPACFileItem,\n            this.aboutItem,\n            this.menuItem3,\n            this.quitItem});\n            // \n            // enableItem\n            // \n            this.enableItem.Index = 0;\n            // configItem\n            // \n            this.configItem.Index = 1;
            // \n            // editPACFileItem\n            // \n            this.editPACFileItem.Index = 2;\n            this.editPACFileItem.Text = "Edit PAC File...";\n            this.editPACFileItem.Click += new System.EventHandler(this.EditPACFileItem_Click);\n            // \n            // aboutItem\n            // 
            this.editPACFileItem.Click += new System.EventHandler(this.EditPACFileItem_Click);\n            // \n            // aboutItem\n            // 
                _listener = new Listener(services);\n                _listener.Start(_config);\n            }\n            catch (Exception e)\n            {\n                // translate Microsoft language into human language\n                // i.e. An attempt was made to access a socket in a way forbidden by its access permissions => Port already in use\n                if (e is SocketException)\n                {\n                    SocketException se = (SocketException)e;
    {\n        private static int Uid;\n        private static string UniqueConfigFile;\n        private static Job PolipoJob;\n        private Process _process;\n        private int _runningPort;\n        static PolipoRunner()\n        {\n            try\n            {
        {\n            try\n            {\n                PolipoJob = new Job();\n                FileManager.UncompressFile(Utils.GetTempPath("ss_privoxy.exe"), Resources.privoxy_exe);\n                FileManager.UncompressFile(Utils.GetTempPath("mgwz.dll"), Resources.mgwz_dll);\n            }\n            catch (IOException e)
                {\n                    KillProcess(p);\n                }\n                string polipoConfig = Resources.privoxy_conf;\n                _runningPort = this.GetFreePort();\n                polipoConfig = polipoConfig.Replace("__SOCKS_PORT__", configuration.localPort.ToString());\n                polipoConfig = polipoConfig.Replace("__POLIPO_BIND_PORT__", _runningPort.ToString());\n                polipoConfig = polipoConfig.Replace("__POLIPO_BIND_IP__", configuration.shareOverLan ? "0.0.0.0" : "127.0.0.1");\n                FileManager.ByteArrayToFile(Utils.GetTempPath(UniqueConfigFile), Encoding.UTF8.GetBytes(polipoConfig));\n                _process = new Process();
                _runningPort = this.GetFreePort();\n                polipoConfig = polipoConfig.Replace("__SOCKS_PORT__", configuration.localPort.ToString());\n                polipoConfig = polipoConfig.Replace("__POLIPO_BIND_PORT__", _runningPort.ToString());\n                polipoConfig = polipoConfig.Replace("__POLIPO_BIND_IP__", configuration.shareOverLan ? "0.0.0.0" : "127.0.0.1");\n                FileManager.ByteArrayToFile(Utils.GetTempPath(UniqueConfigFile), Encoding.UTF8.GetBytes(polipoConfig));\n                _process = new Process();\n                // Configure the process using the StartInfo properties.\n                _process.StartInfo.FileName = "ss_privoxy.exe";\n                _process.StartInfo.Arguments = UniqueConfigFile;\n                _process.StartInfo.WorkingDirectory = Utils.GetTempPath();
                _process = new Process();\n                // Configure the process using the StartInfo properties.\n                _process.StartInfo.FileName = "ss_privoxy.exe";\n                _process.StartInfo.Arguments = UniqueConfigFile;\n                _process.StartInfo.WorkingDirectory = Utils.GetTempPath();\n                _process.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;\n                _process.StartInfo.UseShellExecute = true;\n                _process.StartInfo.CreateNoWindow = true;\n                _process.Start();\n                /*
                    {\n                        throw new FileNotFoundException(I18N.GetString("Cannot find the plugin program file"), _pluginProcess.StartInfo.FileName, ex);\n                    }\n                }\n                _pluginJob.AddProcess(_pluginProcess.Handle);\n                _started = true;\n            }\n            return true;\n        }
using Shadowsocks.Controller;\nusing Shadowsocks.Model;\nusing SimpleJson;\nusing System.Net.NetworkInformation;\nnamespace Shadowsocks.View\n{
namespace Shadowsocks.View\n{
                List<Asset> asserts = new List<Asset>();\n                foreach (JsonObject release in result)\n                {\n                    if ((bool)release["prerelease"])\n                    {\n                        continue;\n                    }\n                    foreach (JsonObject asset in (JsonArray)release["assets"])\n                    {\n                        Asset ass = new Asset();
                        {\n                            asserts.Add(ass);
                        }\n                    }\n                }\n                if (asserts.Count != 0)\n                {\n                    SortByVersions(asserts);\n                    Asset asset = asserts[asserts.Count - 1];\n                    NewVersionFound = true;\n                    LatestVersionURL = asset.browser_download_url;\n                    LatestVersionNumber = asset.version;
using System.Text;\nusing System.IO;\nusing System.Diagnostics;\nusing SimpleJson;\nusing Shadowsocks.Controller;\nusing System.Text.RegularExpressions;\nnamespace Shadowsocks.Model\n{\n    [Serializable]
using Shadowsocks.Controller;\nusing System.Text.RegularExpressions;\nnamespace Shadowsocks.Model\n{\n    [Serializable]\n    public class Server\n    {\n        public string server;\n        public int server_port;\n        public string password;
namespace Shadowsocks.Model\n{\n    [Serializable]\n    public class Server\n    {\n        public string server;\n        public int server_port;\n        public string password;\n        public string method;\n        public string remarks;
using System.Collections.Generic;\nusing System.IO;\nusing System.Text;\nusing System.Windows.Forms;\nusing SimpleJson;\nnamespace Shadowsocks.Model\n{\n    [Serializable]
namespace Shadowsocks.Model\n{\n    [Serializable]\n    public class Configuration\n    {\n        public List<Server> configs;\n        // when strategy is set, index is ignored\n        public string strategy;\n        public int index;\n        public bool global;
    {\n        public const int TYPE_TABLE = 1;\n        public const int TYPE_RC4 = 2;
        public byte[] encryptTable = new byte[256];\n        public byte[] decryptTable = new byte[256];\n        public int method = TYPE_TABLE;\n        public RC4 rc4 = null;
        private long compare(byte x, byte y, ulong a, int i)\n        {\n            return (long)(a % (ulong)(x + i)) - (long)(a % (ulong)(y + i));\n        }\n        private byte[] mergeSort(byte[] array, ulong a, int j)\n        {\n            if (array.Length == 1)\n                return array;\n            int middle = array.Length / 2;\n            byte[] left = new byte[middle];
                rc4 = new RC4();\n                encryptTable = rc4.EncryptInitalize(hash);\n                decryptTable = rc4.EncryptInitalize(hash);\n            } else {\n                Console.WriteLine("init table");\n                this.method = TYPE_TABLE;\n                // TODO endian
                Console.WriteLine("init table");\n                this.method = TYPE_TABLE;\n                // TODO endian\n                var a = BitConverter.ToUInt64(hash, 0);\n                for (int i = 0; i < 256; i++)\n                {\n                    encryptTable[i] = (byte)i;\n                }\n                for (int i = 1; i < 1024; i++)\n                {
                // TODO endian\n                var a = BitConverter.ToUInt64(hash, 0);\n                for (int i = 0; i < 256; i++)\n                {\n                    encryptTable[i] = (byte)i;\n                }\n                for (int i = 1; i < 1024; i++)\n                {\n                    encryptTable = mergeSort(encryptTable, a, i);\n                }
        {\n            switch (method)\n            {\n                case TYPE_TABLE:\n                    for (int i = 0; i < length; i++)\n                        buf[i] = encryptTable[buf[i]];\n                    break;\n                case TYPE_RC4:\n                    rc4.Encrypt(encryptTable, buf, length);
                    for (int i = 0; i < length; i++)\n                        buf[i] = encryptTable[buf[i]];\n                    break;\n                case TYPE_RC4:\n                    rc4.Encrypt(encryptTable, buf, length);\n                    break;\n            }\n        }\n        public void Decrypt(byte[] buf, int length)
                    rc4.Encrypt(encryptTable, buf, length);\n                    break;\n            }\n        }\n        public void Decrypt(byte[] buf, int length)\n        {\n            switch (method)
        {\n            switch (method)\n            {\n                case TYPE_TABLE:\n                    for (int i = 0; i < length; i++)\n                        buf[i] = decryptTable[buf[i]];\n                    break;\n                case TYPE_RC4:\n                    rc4.Decrypt(decryptTable, buf, length);
                    for (int i = 0; i < length; i++)\n                        buf[i] = decryptTable[buf[i]];\n                    break;\n                case TYPE_RC4:\n                    rc4.Decrypt(decryptTable, buf, length);\n                    break;
                    rc4.Decrypt(decryptTable, buf, length);\n                    break;\n            }\n        }\n    }\n}
            }\n        }\n    }\n}
            {\n                MessageBox.Show("there is some problem with parameters");\n            }\n        }\n        private void cancelButton_Click(object sender, EventArgs e)\n        {\n            this.Hide();\n            configToTextBox();\n        }\n        private void Form1_FormClosed(object sender, FormClosedEventArgs e)
            }\n        }\n        private void cancelButton_Click(object sender, EventArgs e)\n        {\n            this.Hide();\n            configToTextBox();\n        }\n        private void Form1_FormClosed(object sender, FormClosedEventArgs e)\n        {\n            if (local != null) local.Stop();
            if (remote != null)\n            {\n                remote.Close();\n            }\n        }\n        private void connectCallback(IAsyncResult ar)\n        {\n            try\n            {
        }\n        private void connectCallback(IAsyncResult ar)\n        {\n            try\n            {\n                // Complete the connection.\n                remote.EndConnect(ar);\n                Console.WriteLine("Socket connected to {0}",\n                    remote.RemoteEndPoint.ToString());\n                handshakeReceive();
        {\n            if (server == null)\n            {\n                throw new ArgumentNullException(nameof(server));\n            }\n            if (string.IsNullOrWhiteSpace(server.plugin))\n            {\n                return null;\n            }\n            return new Sip003Plugin(server.plugin, server.plugin_opts, server.plugin_args, server.server, server.server_port);
        }\n        private Sip003Plugin(string plugin, string pluginOpts, string pluginArgs, string serverAddress, int serverPort)\n        {\n            if (plugin == null) throw new ArgumentNullException(nameof(plugin));\n            if (string.IsNullOrWhiteSpace(serverAddress))\n            {\n                throw new ArgumentException("Value cannot be null or whitespace.", nameof(serverAddress));\n            }\n            if (serverPort <= 0 || serverPort > 65535)\n            {
        {\n            if (plugin == null) throw new ArgumentNullException(nameof(plugin));\n            if (string.IsNullOrWhiteSpace(serverAddress))\n            {\n                throw new ArgumentException("Value cannot be null or whitespace.", nameof(serverAddress));\n            }\n            if (serverPort <= 0 || serverPort > 65535)\n            {\n                throw new ArgumentOutOfRangeException("serverPort");\n            }
            Application.EnableVisualStyles();\n            Application.SetCompatibleTextRenderingDefault(false);\n            Application.Run(new Form1());\n            local.Stop();\n        }\n    }\n}
        }\n    }\n}
            this.contextMenuStrip1.Name = "contextMenuStrip1";\n            this.contextMenuStrip1.RenderMode = System.Windows.Forms.ToolStripRenderMode.System;\n            this.contextMenuStrip1.ShowImageMargin = false;\n            this.contextMenuStrip1.Size = new System.Drawing.Size(86, 48);\n            // \n            // Config\n            // \n            this.Config.Name = "Config";\n            this.Config.Size = new System.Drawing.Size(127, 22);\n            this.Config.Text = "Config";\n            this.Config.Click += new System.EventHandler(this.Config_Click);

            var ret = new DataList\n            {\n                new DataUnit(State.Geolocation, State.Unknown),\n                new DataUnit(State.ISP, State.Unknown),\n            };
                {\n                    Append(dataList, geolocationAndIsp.Result);\n                }\n            }\n        }\n        private static void Append(DataList dataList, IEnumerable<DataUnit> extra)\n        {\n            var data = dataList.Concat(extra);\n            var dataLine = string.Join(Delimiter, data.Select(kv => kv.Value).ToArray());
            }\n            // don't put polipoRunner.Start() before pacServer.Stop()\n            // or bind will fail when switching bind address from 0.0.0.0 to 127.0.0.1\n            // though UseShellExecute is set to true now\n            // http://stackoverflow.com/questions/10235093/socket-doesnt-close-after-application-exits-if-a-launched-process-is-open\n            polipoRunner.Stop();\n            try\n            {\n                var strategy = GetCurrentStrategy();\n                if (strategy != null)
    {\n        Local local;\n        PACServer pacServer;\n        Config config;\n        PolipoRunner polipoRunner;\n        public Form1()\n        {\n            config = Config.Load();\n            InitializeComponent();\n            notifyIcon1.ContextMenu = contextMenu1;
        {\n            config = Config.Load();\n            InitializeComponent();\n            notifyIcon1.ContextMenu = contextMenu1;\n            enableItem.Checked = config.enabled;\n            configToTextBox();\n        }\n        private void showWindow()\n        {\n            this.Opacity = 1;
                }\n                else\n                {\n                    Console.WriteLine("failed to recv data in handshakeReceive2Callback");\n                    this.Close();
        {\n            List<INTERNET_PER_CONN_OPTION> _optionlist = new List<INTERNET_PER_CONN_OPTION>();\n            if (enable)\n            {\n                if (global)\n                {\n                    // global proxy\n                    _optionlist.Add(new INTERNET_PER_CONN_OPTION\n                    {\n                        dwOption = (int)INTERNET_PER_CONN_OptionEnum.INTERNET_PER_CONN_FLAGS_UI,\n                        Value = { dwValue = (int)INTERNET_OPTION_PER_CONN_FLAGS_UI.PROXY_TYPE_PROXY }
                    });\n                    _optionlist.Add(new INTERNET_PER_CONN_OPTION\n                    {\n                        dwOption = (int)INTERNET_PER_CONN_OptionEnum.INTERNET_PER_CONN_PROXY_SERVER,\n                        Value = { pszValue = Marshal.StringToHGlobalAnsi(proxyServer) }\n                    });\n                    _optionlist.Add(new INTERNET_PER_CONN_OPTION\n                    {\n                        dwOption = (int)INTERNET_PER_CONN_OptionEnum.INTERNET_PER_CONN_PROXY_BYPASS,\n                        Value = { pszValue = Marshal.StringToHGlobalAnsi("<local>") }
                    });\n                    _optionlist.Add(new INTERNET_PER_CONN_OPTION\n                    {\n                        dwOption = (int)INTERNET_PER_CONN_OptionEnum.INTERNET_PER_CONN_PROXY_BYPASS,\n                        Value = { pszValue = Marshal.StringToHGlobalAnsi("<local>") }\n                    });\n                }\n                else\n                {\n                    // pac
                    });\n                }\n                else\n                {\n                    // pac\n                    _optionlist.Add(new INTERNET_PER_CONN_OPTION\n                    {\n                        dwOption = (int)INTERNET_PER_CONN_OptionEnum.INTERNET_PER_CONN_FLAGS_UI,\n                        Value = { dwValue = (int)INTERNET_OPTION_PER_CONN_FLAGS_UI.PROXY_TYPE_AUTO_PROXY_URL }\n                    });
                IntPtr.Zero,\n                INTERNET_OPTION.INTERNET_OPTION_SETTINGS_CHANGED,\n                IntPtr.Zero, 0);\n            NativeMethods.InternetSetOption(\n                IntPtr.Zero,
                IntPtr.Zero, 0);\n            NativeMethods.InternetSetOption(\n                IntPtr.Zero,\n                INTERNET_OPTION.INTERNET_OPTION_REFRESH,\n                IntPtr.Zero, 0);
                IntPtr.Zero,\n                INTERNET_OPTION.INTERNET_OPTION_REFRESH,\n                IntPtr.Zero, 0);
using System.Globalization;\nusing System.IO;\nusing Shadowsocks.Properties;\nusing Shadowsocks.Util;\nusing System.Windows.Forms;\nusing Microsoft.VisualBasic.FileIO;\nusing System.Text;\nnamespace Shadowsocks.Controller\n{
using System.Windows.Forms;\nusing Microsoft.VisualBasic.FileIO;\nusing System.Text;\nnamespace Shadowsocks.Controller\n{\n    public static class I18N\n    {\n        private static readonly string I18N_FILE = "i18n.csv";\n        private static Dictionary<string, string> _strings = new Dictionary<string, string>();\n        private static void Init(string res, string locale)
namespace Shadowsocks.Controller\n{\n    public static class I18N\n    {\n        private static readonly string I18N_FILE = "i18n.csv";\n        private static Dictionary<string, string> _strings = new Dictionary<string, string>();\n        private static void Init(string res, string locale)\n        {\n            using (TextFieldParser csvParser = new TextFieldParser(new StringReader(res)))\n            {
        static Sodium()\n        {\n            LoadSSCryptoLibrary();\n            LoadSSCrypto2Library();\n        }\n        static void LoadSSCryptoLibrary()\n        {\n            string tempPath = Utils.GetTempPath();\n            string dllPath = tempPath + "/libsscrypto.dll";\n            try
        {\n            string tempPath = Utils.GetTempPath();\n            string dllPath = tempPath + "/libsscrypto.dll";\n            try\n            {\n                FileManager.UncompressFile(dllPath, Resources.libsscrypto_dll);\n                LoadLibrary(dllPath);\n            }\n            catch (IOException)\n            {
            }\n            catch (IOException)\n            {\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine(e.ToString());\n            }\n        }\n        static void LoadSSCrypto2Library()
        }\n        [DllImport("Kernel32.dll")]\n        private static extern IntPtr LoadLibrary(string path);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void crypto_stream_salsa20_xor_ic(byte[] c, byte[] m, ulong mlen, byte[] n, ulong ic, byte[] k);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void crypto_stream_chacha20_xor_ic(byte[] c, byte[] m, ulong mlen, byte[] n, ulong ic, byte[] k);\n        [DllImport(DLLNAME2, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int ss_gen_crc(byte[] buf, ref int buf_offset, ref int data_len,\n            byte[] crc_buf, ref int crc_idx, int buf_size);
        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void crypto_stream_chacha20_xor_ic(byte[] c, byte[] m, ulong mlen, byte[] n, ulong ic, byte[] k);\n        [DllImport(DLLNAME2, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int ss_gen_crc(byte[] buf, ref int buf_offset, ref int data_len,\n            byte[] crc_buf, ref int crc_idx, int buf_size);
        public extern static int ss_gen_crc(byte[] buf, ref int buf_offset, ref int data_len,\n            byte[] crc_buf, ref int crc_idx, int buf_size);
        }\n        public int EndSend(IAsyncResult asyncResult)\n        {\n            return _remote.EndSend(asyncResult);\n        }\n        public void BeginReceive(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state)\n        {\n            _remote?.BeginReceive(buffer, offset, size, socketFlags, callback, state);\n        }
        }\n        public int EndReceive(IAsyncResult asyncResult)\n        {\n            return _remote.EndReceive(asyncResult);\n        }\n        public void Shutdown(SocketShutdown how)\n        {\n            _remote?.Shutdown(how);\n        }\n        public void Close()
        }\n        public void Close()\n        {\n            _remote?.Dispose();\n        }\n    }\n}
        }\n    }\n}
            this.QRCodeWebBrowser.Location = new System.Drawing.Point(0, 0);\n            this.QRCodeWebBrowser.MinimumSize = new System.Drawing.Size(20, 20);\n            this.QRCodeWebBrowser.Name = "QRCodeWebBrowser";\n            this.QRCodeWebBrowser.ScriptErrorsSuppressed = true;\n            this.QRCodeWebBrowser.ScrollBarsEnabled = false;\n            this.ClientSize = new System.Drawing.Size(184, 182);
            this.Controls.Add(this.QRCodeWebBrowser);\n            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedSingle;\n            this.MaximizeBox = false;\n            this.Name = "QRCodeForm";\n            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;\n            this.Load += new System.EventHandler(this.QRCodeForm_Load);\n            this.ResumeLayout(false);\n        }\n        #endregion\n        private System.Windows.Forms.WebBrowser QRCodeWebBrowser;
        private byte[] _encryptIV;\n        private byte[] _decryptIV;\n        private int _encryptIVOffset;\n        private int _decryptIVOffset;\n        private string _method;\n        private int keyLen;\n        private int ivLen;\n        public PolarSSLEncryptor(string method, string password)\n            : base(method, password)\n        {
        private string _method;\n        private int keyLen;\n        private int ivLen;\n        public PolarSSLEncryptor(string method, string password)\n            : base(method, password)\n        {\n            InitKey(method, password);\n        }\n        private static void randBytes(byte[] buf, int length)\n        {
                }\n                else\n                {\n                    realkey = _key;\n                }\n                if (_cipher == CIPHER_AES)\n                {\n                    PolarSSL.aes_init(ctx);\n                    // PolarSSL takes key length by bit\n                    // since we'll use CFB mode, here we both do enc, not dec
            }\n        }\n        static byte[] tempbuf = new byte[32768];\n        public override void Encrypt(byte[] buf, int length, byte[] outbuf, out int outlength)\n        {\n            if (_encryptCtx == null)\n            {\n                randBytes(outbuf, ivLen);\n                InitCipher(ref _encryptCtx, outbuf, true);\n                outlength = length + ivLen;
            {\n                randBytes(outbuf, ivLen);\n                InitCipher(ref _encryptCtx, outbuf, true);\n                outlength = length + ivLen;\n                lock (tempbuf)\n                {\n                    // C# could be multi-threaded\n                    lock (_encryptCtx)\n                    {\n                        if (_disposed)\n                        {
                }\n            }\n            else\n            {\n                outlength = length;\n                lock (_encryptCtx)\n                {\n                    if (_disposed)\n                    {\n                        throw new ObjectDisposedException(this.ToString());
                }\n            }\n        }\n        public override void Decrypt(byte[] buf, int length, byte[] outbuf, out int outlength)\n        {\n            if (_decryptCtx == null)\n            {\n                InitCipher(ref _decryptCtx, buf, false);\n                outlength = length - ivLen;\n                lock (tempbuf)
            {\n                InitCipher(ref _decryptCtx, buf, false);\n                outlength = length - ivLen;\n                lock (tempbuf)\n                {\n                    // C# could be multi-threaded\n                    Buffer.BlockCopy(buf, ivLen, tempbuf, 0, length - ivLen);\n                    lock (_decryptCtx)\n                    {\n                        if (_disposed)\n                        {
                    }\n                }\n            }\n            else\n            {\n                outlength = length;\n                lock (_decryptCtx)\n                {\n                    if (_disposed)\n                    {
                }\n            }\n        }\n        #region IDisposable\n        private bool _disposed;\n        public override void Dispose()\n        {\n            Dispose(true);\n            GC.SuppressFinalize(this);\n        }
        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void aes_free(byte[] ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int aes_setkey_enc(byte[] ctx, byte[] key, int keysize);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int aes_crypt_cfb128(byte[] ctx, int mode, int length, ref int iv_off, byte[] iv, byte[] input, byte[] output);\n        public const int ARC4_CTX_SIZE = 264;\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void arc4_init(byte[] ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int aes_setkey_enc(byte[] ctx, byte[] key, int keysize);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int aes_crypt_cfb128(byte[] ctx, int mode, int length, ref int iv_off, byte[] iv, byte[] input, byte[] output);\n        public const int ARC4_CTX_SIZE = 264;\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void arc4_init(byte[] ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void arc4_free(byte[] ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int aes_crypt_cfb128(byte[] ctx, int mode, int length, ref int iv_off, byte[] iv, byte[] input, byte[] output);\n        public const int ARC4_CTX_SIZE = 264;\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void arc4_init(byte[] ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void arc4_free(byte[] ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void arc4_setup(byte[] ctx, byte[] key, int keysize);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
        public const int ARC4_CTX_SIZE = 264;\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void arc4_init(byte[] ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void arc4_free(byte[] ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void arc4_setup(byte[] ctx, byte[] key, int keysize);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int arc4_crypt(byte[] ctx, int length, byte[] input, byte[] output);\n        public const int BLOWFISH_CTX_SIZE = 4168;
        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void arc4_free(byte[] ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void arc4_setup(byte[] ctx, byte[] key, int keysize);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int arc4_crypt(byte[] ctx, int length, byte[] input, byte[] output);\n        public const int BLOWFISH_CTX_SIZE = 4168;\n        public const int BLOWFISH_ENCRYPT = 1;\n        public const int BLOWFISH_DECRYPT = 0;\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void arc4_setup(byte[] ctx, byte[] key, int keysize);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int arc4_crypt(byte[] ctx, int length, byte[] input, byte[] output);\n        public const int BLOWFISH_CTX_SIZE = 4168;\n        public const int BLOWFISH_ENCRYPT = 1;\n        public const int BLOWFISH_DECRYPT = 0;\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void blowfish_init(byte[] ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int arc4_crypt(byte[] ctx, int length, byte[] input, byte[] output);\n        public const int BLOWFISH_CTX_SIZE = 4168;\n        public const int BLOWFISH_ENCRYPT = 1;\n        public const int BLOWFISH_DECRYPT = 0;\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void blowfish_init(byte[] ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void blowfish_free(byte[] ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
        public const int BLOWFISH_CTX_SIZE = 4168;\n        public const int BLOWFISH_ENCRYPT = 1;\n        public const int BLOWFISH_DECRYPT = 0;\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void blowfish_init(byte[] ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void blowfish_free(byte[] ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int blowfish_setkey(byte[] ctx, byte[] key, int keysize);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void blowfish_free(byte[] ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int blowfish_setkey(byte[] ctx, byte[] key, int keysize);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int blowfish_crypt_cfb64(byte[] ctx, int mode, int length, ref int iv_off, byte[] iv, byte[] input, byte[] output);\n    }\n}
        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int blowfish_setkey(byte[] ctx, byte[] key, int keysize);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int blowfish_crypt_cfb64(byte[] ctx, int mode, int length, ref int iv_off, byte[] iv, byte[] input, byte[] output);\n    }\n}
        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int blowfish_crypt_cfb64(byte[] ctx, int mode, int length, ref int iv_off, byte[] iv, byte[] input, byte[] output);\n    }\n}
    }\n}
                        byte[] plain = new byte[16384];\n                        byte[] cipher = new byte[plain.Length + 16];\n                        byte[] plain2 = new byte[plain.Length + 16];\n                        int outLen = 0;\n                        int outLen2 = 0;\n                        random.NextBytes(plain);\n                        //lock (locker)\n                        //{\n                            encryptor.Encrypt(plain, plain.Length, cipher, out outLen);\n                            decryptor.Decrypt(cipher, outLen, plain2, out outLen2);
                    }\n            }\n            catch\n            {\n                encryptionFailed = true;\n            }\n        }\n    }\n}
using Shadowsocks.Util.Sockets;\nnamespace Shadowsocks.Controller.Service\n{\n    class Http2Socks5 : Listener.Service\n    {\n        private readonly ByteSearch.SearchTarget _connectSearch =\n            new ByteSearch.SearchTarget(Encoding.UTF8.GetBytes("HTTP"));\n        private readonly int _socks5Port;\n        public Http2Socks5(int socks5Port)\n        {
        public override bool Handle(byte[] firstPacket, int length, Socket socket, object state)\n        {\n            if (socket.ProtocolType != ProtocolType.Tcp)\n            {\n                return false;\n            }
        {\n            return value.ToString("yyyyMMddHHmmssfff");

                    {\n                        //set all the connections's proxy as the lan\n                        registry.SetValue(each, defaultValue);\n                    }\n                }
                    }\n                }\n                NotifyIE();\n            }\n            catch (IOException e)\n            {\n                Logging.LogUsefulException(e);\n            }\n        }\n        /// <summary>
        public bool Ping { get; set; }\n        public int ChoiceKeptMinutes { get; } = 10;\n        public int DataCollectionMinutes { get; } = 10;\n        public int RepeatTimesNum { get; } = 4;\n        private const string ConfigFile = "statistics-config.json";\n        public static StatisticsStrategyConfiguration Load()\n        {\n            try\n            {\n                var content = File.ReadAllText(ConfigFile);
        private const string ConfigFile = "statistics-config.json";\n        public static StatisticsStrategyConfiguration Load()\n        {\n            try\n            {\n                var content = File.ReadAllText(ConfigFile);\n                var configuration = JsonConvert.DeserializeObject<StatisticsStrategyConfiguration>(content);\n                return configuration;\n            }\n            catch (FileNotFoundException)
using System.Linq;\nusing System.Windows.Forms;\nusing System.Windows.Forms.DataVisualization.Charting;\nusing Shadowsocks.Controller;\nusing Shadowsocks.Model;\nnamespace Shadowsocks.View\n{\n    using Statistics = Dictionary<string, List<StatisticsRecord>>;\n    public partial class StatisticsStrategyConfigurationForm : Form\n    {
using Shadowsocks.Controller;\nusing Shadowsocks.Model;\nnamespace Shadowsocks.View\n{\n    using Statistics = Dictionary<string, List<StatisticsRecord>>;\n    public partial class StatisticsStrategyConfigurationForm : Form\n    {\n        private readonly ShadowsocksController _controller;\n        private StatisticsStrategyConfiguration _configuration;\n        private readonly DataTable _dataTable = new DataTable();
    public partial class StatisticsStrategyConfigurationForm : Form\n    {\n        private readonly ShadowsocksController _controller;\n        private StatisticsStrategyConfiguration _configuration;\n        private readonly DataTable _dataTable = new DataTable();\n        private List<string> _servers;\n        public StatisticsStrategyConfigurationForm(ShadowsocksController controller)\n        {\n            if (controller == null) return;\n            InitializeComponent();
            this.tableLayoutPanel1.Controls.Add(this.TimeoutLabel, 0, 6);\n            this.tableLayoutPanel1.Controls.Add(this.TimeoutTextBox, 1, 6);\n            this.tableLayoutPanel1.Location = new System.Drawing.Point(8, 21);\n            this.tableLayoutPanel1.Margin = new System.Windows.Forms.Padding(0);\n            this.tableLayoutPanel1.Name = "tableLayoutPanel1";\n            this.tableLayoutPanel1.Padding = new System.Windows.Forms.Padding(3);\n            this.tableLayoutPanel1.RowCount = 8;\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel1.TabIndex = 0;\n            // \n            // RemarksTextBox\n            // \n            this.RemarksTextBox.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));\n            this.RemarksTextBox.Location = new System.Drawing.Point(89, 113);\n            this.RemarksTextBox.MaxLength = 32;\n            this.RemarksTextBox.Name = "RemarksTextBox";\n            this.RemarksTextBox.Size = new System.Drawing.Size(160, 21);\n            this.RemarksTextBox.TabIndex = 4;
            this.EncryptionSelect.Location = new System.Drawing.Point(89, 87);\n            this.EncryptionSelect.Name = "EncryptionSelect";\n            this.EncryptionSelect.Size = new System.Drawing.Size(160, 20);\n            this.EncryptionSelect.TabIndex = 3;\n            // \n            // OneTimeAuth\n            // \n            this.OneTimeAuth.AutoSize = true;\n            this.OneTimeAuth.Location = new System.Drawing.Point(89, 167);\n            this.OneTimeAuth.Name = "OneTimeAuth";\n            this.OneTimeAuth.Size = new System.Drawing.Size(156, 16);
            // \n            // panel2\n            // \n            this.panel2.Anchor = System.Windows.Forms.AnchorStyles.Top;\n            this.panel2.AutoSize = true;\n            this.panel2.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;\n            this.panel2.Location = new System.Drawing.Point(207, 187);\n            this.panel2.Name = "panel2";\n            this.panel2.Size = new System.Drawing.Size(0, 0);\n            this.panel2.TabIndex = 1;
            try\n            {\n                local.Start();\n                pacServer = new PACServer();\n                pacServer.PACFileChanged += pacServer_PACFileChanged;\n                pacServer.Start();\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine(e.Message);
            }\n            catch (Exception e)\n            {\n                Console.WriteLine(e.Message);\n            }\n            UpdateSystemProxy();\n        }\n        public void SaveConfig(Configuration newConfig)\n        {\n            Configuration.Save(newConfig);
        //private Encryptor encryptor;\n        Socket _listener;\n        public Local(Server config)\n        {\n            this.config = config;\n            //this.encryptor = new Encryptor(config.method, config.password);\n        }\n        public void Start()\n        {\n            try
            //this.encryptor = new Encryptor(config.method, config.password);\n        }\n        public void Start()\n        {\n            try\n            {\n                // Create a TCP/IP socket.\n                _listener = new Socket(AddressFamily.InterNetwork,\n                    SocketType.Stream, ProtocolType.Tcp);\n                IPEndPoint localEndPoint = new IPEndPoint(0, config.local_port);
                // Bind the socket to the local endpoint and listen for incoming connections.\n                _listener.Bind(localEndPoint);\n                _listener.Listen(100);\n                // Start an asynchronous socket to listen for connections.\n                Console.WriteLine("Shadowsocks started");\n                _listener.BeginAccept(\n                    new AsyncCallback(AcceptCallback),\n                    _listener);\n            }\n            catch(SocketException)
        {\n            // Create a TCP/IP socket.\n            listener = new Socket(AddressFamily.InterNetwork,\n                SocketType.Stream, ProtocolType.Tcp);\n            IPEndPoint localEndPoint = new IPEndPoint(0, 8090);\n            // Bind the socket to the local endpoint and listen for incoming connections.\n            listener.Bind(localEndPoint);\n            listener.Listen(100);\n            listener.BeginAccept(\n                new AsyncCallback(AcceptCallback),
        }\n        public string TouchPACFile()\n        {\n            if (File.Exists(PAC_FILE))\n            {\n                return PAC_FILE;\n            }\n            else\n            {\n                FileManager.UncompressFile(PAC_FILE, Resources.proxy_pac_txt);
                conn.BeginReceive(new byte[1024], 0, 1024, 0,\n                    new AsyncCallback(ReceiveCallback), conn);\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine(e.Message);\n            }\n        }\n        private string GetPACContent()\n        {
        }\n        private void ReceiveCallback(IAsyncResult ar)\n        {\n            Socket conn = (Socket)ar.AsyncState;\n            try\n            {\n                int bytesRead = conn.EndReceive(ar);\n                string pac = GetPACContent();\n                string proxy = "PROXY 127.0.0.1:8123;";
                pac = pac.Replace("__PROXY__", proxy);\n                if (bytesRead > 0)\n                {\n                    string text = String.Format(@"HTTP/1.1 200 OK\nServer: Shadowsocks\nContent-Type: application/x-ns-proxy-autoconfig\nContent-Length: {0}\nConnection: Close\n", System.Text.Encoding.UTF8.GetBytes(pac).Length) + pac;\n                    byte[] response = System.Text.Encoding.UTF8.GetBytes(text);
            this.tableLayoutPanel1.SuspendLayout();\n            this.panel1.SuspendLayout();\n            this.panel3.SuspendLayout();\n            this.ServerGroupBox.SuspendLayout();\n            this.SuspendLayout();\n            // \n            // tableLayoutPanel1\n            // \n            this.tableLayoutPanel1.AutoSize = true;\n            this.tableLayoutPanel1.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;
            this.ServersItem.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {\n            this.SeperatorItem,\n            this.ConfigItem});\n            this.ServersItem.Text = "&Servers";\n            // \n            // SeperatorItem\n            // \n            this.SeperatorItem.Index = 0;\n            this.SeperatorItem.Text = "-";\n            // \n            this.menuItem4.Index = 2;
            this.menuItem4.Text = "-";\n            // \n            // editPACFileItem\n            // 
        {\n            if (_process == null)\n            {\n                Process[] existingPolipo = Process.GetProcessesByName("ss_polipo");\n                foreach (Process p in existingPolipo)\n                {\n                    try\n                    {\n                        p.Kill();
        {\n            this.tcprelay = tcprelay;\n        }\n        public void CreateRemote()\n        {\n            Server server = controller.GetAServer(IStrategyCallerType.TCP, (IPEndPoint)connection.RemoteEndPoint);\n            if (server == null || server.server == "")\n            {\n                throw new ArgumentException("No server configured");
                ProxyTimer proxyTimer = new ProxyTimer(3000);\n                proxyTimer.AutoReset = false;\n                proxyTimer.Elapsed += proxyConnectTimer_Elapsed;\n                proxyTimer.Enabled = true;\n                proxyTimer.DestEndPoint = remoteEP;\n                proxyTimer.Server = server;\n                proxyConnected = false;\n                // Connect to the proxy server.\n                remote.BeginConnectProxy(remoteEP, new AsyncCallback(ProxyConnectCallback), proxyTimer);\n            }\n            catch (Exception e)
                proxyTimer.Server = server;\n                proxyConnected = false;\n                // Connect to the proxy server.\n                remote.BeginConnectProxy(remoteEP, new AsyncCallback(ProxyConnectCallback), proxyTimer);\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }
            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void proxyConnectTimer_Elapsed(object sender, ElapsedEventArgs e)\n        {\n            if (proxyConnected || destConnected)
                            {\n                                if (!int.TryParse(locs[1], out _targetPort))\n                                {\n                                    throw new Exception("Bad http header: " + line);\n                                }\n                            }\n                            else\n                            {\n                                _targetPort = 80;\n                            }
                            }\n                        }\n                    }\n                }\n                else\n                {\n                    if (line.IsNullOrEmpty())\n                    {\n                        return true;\n                    }
                            {\n                                if (!int.TryParse(locs[1], out _targetPort))\n                                {\n                                    throw new Exception("Bad http header: " + line);\n                                }\n                            }\n                            else\n                            {\n                                _targetPort = 80;\n                            }
                            }\n                        }\n                    }\n                }\n                _requestLineCount++;\n                return false;\n            }\n            private void OnFinish(byte[] lastBytes, int index, int length, object state)\n            {\n                if (_closed)
        public void Encrypt(byte[] table, byte[] data, int length)\n        {\n            EncryptOutput(enc_index1, enc_index2, table, data, length);\n        }\n        public void Decrypt(byte[] table, byte[] data, int length)\n        {\n            EncryptOutput(dec_index1, dec_index2, table, data, length);\n        }\n        public byte[] EncryptInitalize(byte[] key)\n        {
        }\n        public void Decrypt(byte[] table, byte[] data, int length)\n        {\n            EncryptOutput(dec_index1, dec_index2, table, data, length);\n        }\n        public byte[] EncryptInitalize(byte[] key)\n        {\n            byte[] s = new byte[256];\n            for (int i = 0; i < 256; i++)\n            {
        }\n        public byte[] EncryptInitalize(byte[] key)\n        {\n            byte[] s = new byte[256];\n            for (int i = 0; i < 256; i++)\n            {\n                s[i] = (byte)i;\n            }\n            for (int i = 0, j = 0; i < 256; i++)\n            {
        {\n            for (int n = 0; n < length; n++)\n            {\n                byte b = data[n];\n                index1 = (index1 + 1) & 255;\n                index2 = (index2 + s[index1]) & 255;\n                Swap(s, index1, index2);\n                data[n] = (byte)(b ^ s[(s[index1] + s[index2]) & 255]);\n            }\n        }
            }\n        }\n        private static void Swap(byte[] s, int i, int j)\n        {\n            byte c = s[i];\n            s[i] = s[j];\n            s[j] = c;\n        }\n    }\n}
        // return path to store temporary files\n        public static string GetTempPath()\n        {\n            if (TempPath == null)\n            {\n                if (IsPortableMode())\n                    try\n                    {\n                        Directory.CreateDirectory(Path.Combine(Application.StartupPath, "temp"));\n                    }\n                    catch (Exception e)
