                if (enabled)\n                {\n                    runKey.SetValue(Key, path);\n                }\n                else\n                {\n                    runKey.DeleteValue(Key);\n                }\n                return true;
                }\n                else\n                {\n                    runKey.DeleteValue(Key);\n                }\n                return true;\n            }\n            catch (Exception e)\n            {
                }\n                return true;\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                return false;\n            }\n            finally
                return true;\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                return false;\n            }\n            finally\n            {\n                if (runKey != null)
                string[] runList = runKey.GetValueNames();\n                foreach (string item in runList)\n                {\n                    if (item.Equals(Key))\n                        return true;\n                    else if (item.Equals("Shadowsocks")) // Compatibility with older versions\n                    {\n                        string value = Convert.ToString(runKey.GetValue(item));\n                        if (path.Equals(value, StringComparison.InvariantCultureIgnoreCase))
                foreach (string item in runList)\n                {\n                    if (item.Equals(Key))\n                        return true;\n                    else if (item.Equals("Shadowsocks")) // Compatibility with older versions\n                    {\n                        string value = Convert.ToString(runKey.GetValue(item));\n                        if (path.Equals(value, StringComparison.InvariantCultureIgnoreCase))\n                        {\n                            runKey.DeleteValue(item);
                        return true;\n                    else if (item.Equals("Shadowsocks")) // Compatibility with older versions\n                    {\n                        string value = Convert.ToString(runKey.GetValue(item));\n                        if (path.Equals(value, StringComparison.InvariantCultureIgnoreCase))\n                        {\n                            runKey.DeleteValue(item);\n                            runKey.SetValue(Key, path);\n                            return true;\n                        }
                var localPort = GetNextFreeTcpPort();\n                LocalEndPoint = new IPEndPoint(IPAddress.Loopback, localPort);\n                _pluginProcess.StartInfo.Environment["SS_LOCAL_HOST"] = LocalEndPoint.Address.ToString();\n                _pluginProcess.StartInfo.Environment["SS_LOCAL_PORT"] = LocalEndPoint.Port.ToString();\n                _pluginProcess.StartInfo.Arguments = ExpandEnvironmentVariables(_pluginProcess.StartInfo.Arguments, _pluginProcess.StartInfo.EnvironmentVariables);\n                try\n                {\n                    _pluginProcess.Start();\n                }\n                catch (System.ComponentModel.Win32Exception ex)
                _pluginJob.AddProcess(_pluginProcess.Handle);\n                _started = true;\n            }\n            return true;\n        }\n        public string ExpandEnvironmentVariables(string name, StringDictionary environmentVariables = null)\n        {\n            // Expand the environment variables from the new process itself\n            if (environmentVariables != null)\n            {
using System.Diagnostics;\nusing System.IO;\nusing System.Text;\nusing System.Threading;\nnamespace Shadowsocks.Util.SystemProxy\n{
namespace Shadowsocks.Util.SystemProxy\n{\n    public static class Sysproxy\n    {\n        private const string _userWininetConfigFile = "user-wininet.json";\n        private static string _queryStr;\n        // In general, this won't change\n        // format:\n        //  <flags><CR-LF>\n        //  <proxy-server><CR-LF>
                    var stderr = error.ToString();\n                    var stdout = output.ToString();\n                    var exitCode = process.ExitCode;\n                    if (exitCode != (int)RET_ERRORS.RET_NO_ERROR)\n                    {\n                        throw new ProxyException(ProxyExceptionType.SysproxyExitError, stderr);\n                    }\n                    if (arguments == "query")\n                    {\n                        if (stdout.IsNullOrWhiteSpace() || stdout.IsNullOrEmpty())
                    }\n                    if (arguments == "query")\n                    {\n                        if (stdout.IsNullOrWhiteSpace() || stdout.IsNullOrEmpty())\n                        {\n                            // we cannot get user settings\n                            throw new ProxyException(ProxyExceptionType.QueryReturnEmpty);\n                        }\n                        _queryStr = stdout;\n                    }\n                }
                        }\n                        _queryStr = stdout;\n                    }\n                }\n            }\n        }\n        private static void Save()\n        {\n            try\n            {
                            // Multiply with flyBlue\n                            Color flyBlue;\n                            if (currentWindowsThemeMode == Utils.WindowsThemeMode.Light)\n                                flyBlue = Color.FromArgb(128, 192, 192, 192); // Dark icon more transparent\n                            else\n                                flyBlue = Color.FromArgb(192, 192, 192, 192); // Light icon less transparent\n                            int red = color.R * flyBlue.R / 255;\n                            int green = color.G * flyBlue.G / 255;\n                            int blue = color.B * flyBlue.B / 255;\n                            int alpha = color.A * flyBlue.A / 255;\n                            iconCopy.SetPixel(x, y, Color.FromArgb(alpha, red, green, blue));
            this.tableLayoutPanel1.Location = new System.Drawing.Point(8, 21);\n            this.tableLayoutPanel1.Margin = new System.Windows.Forms.Padding(0);\n            this.tableLayoutPanel1.Name = "tableLayoutPanel1";\n            this.tableLayoutPanel1.Padding = new System.Windows.Forms.Padding(3);\n            this.tableLayoutPanel1.RowCount = 12;\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel1.TabIndex = 0;\n            // \n            // PluginOptionsLabel\n            // \n            this.PluginOptionsLabel.Anchor = System.Windows.Forms.AnchorStyles.Right;\n            this.PluginOptionsLabel.AutoSize = true;\n            this.PluginOptionsLabel.Location = new System.Drawing.Point(18, 166);\n            this.PluginOptionsLabel.Name = "PluginOptionsLabel";\n            this.PluginOptionsLabel.Size = new System.Drawing.Size(89, 12);\n            this.PluginOptionsLabel.TabIndex = 6;
            this.ServersListBox = new System.Windows.Forms.ListBox();\n            this.tableLayoutPanel1.SuspendLayout();\n            this.panel1.SuspendLayout();\n            this.panel3.SuspendLayout();\n            this.ServerGroupBox.SuspendLayout();\n            this.SuspendLayout();\n            // \n            // tableLayoutPanel1\n            // \n            this.tableLayoutPanel1.AutoSize = true;
                using (StreamWriter sw = new StreamWriter(File.Open(CONFIG_FILE, FileMode.Create)))\n                {\n                    string jsonString = SimpleJson.SimpleJson.SerializeObject(config);\n                    sw.Write(jsonString);\n                    sw.Flush();\n                }\n            }\n            catch (IOException e)\n            {\n                Console.Error.WriteLine(e);
        {\n            Reload();\n            if (regHotkeys)\n            {\n                HotkeyReg.RegAllHotkeys();\n            }\n        }\n        protected void ReportError(Exception e)\n        {\n            if (Errored != null)
        }\n        protected void ReportError(Exception e)\n        {\n            if (Errored != null)\n            {\n                Errored(this, new ErrorEventArgs(e));\n            }\n        }\n        public Server GetCurrentServer()\n        {
            byte[] output = new byte[16];\n            MbedTLS.md5(input, (uint)input.Length, output);\n            return output;\n        }
            return output;\n        }\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void md5(byte[] input, uint ilen, byte[] output);
    }\n}
using System.Net;\nusing System.Net.Sockets;\nusing System.Text;\nusing System.Web;\nnamespace Shadowsocks.Controller
using System.Web;\nnamespace Shadowsocks.Controller\n{\n    public class PACServer : Listener.Service\n    {\n        public const string RESOURCE_NAME = "pac";\n        private string PacSecret\n        {\n            get\n            {
using System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Data;\nusing System.Drawing;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Windows.Forms;\nusing Shadowsocks.Controller;\nusing Shadowsocks.Properties;
            this.filename = filename;\n            InitializeComponent();\n            this.Icon = Icon.FromHandle(Resources.ssw128.GetHicon());\n            LogViewerConfig config = controller.GetConfigurationCopy().logViewer;\n            if (config == null)\n                config = new LogViewerConfig();\n            topMostTrigger = config.topMost;\n            wrapTextTrigger = config.wrapText;\n            toolbarTrigger = config.toolbarShown;\n            LogMessageTextBox.BackColor = config.GetBackgroundColor();
            UpdateTexts();\n        }\n        private void UpdateTexts()\n        {\n            FileMenuItem.Text = I18N.GetString("&File");\n            OpenLocationMenuItem.Text = I18N.GetString("&Open Location");\n            ExitMenuItem.Text = I18N.GetString("E&xit");\n            CleanLogsButton.Text = I18N.GetString("&Clean logs");\n            ChangeFontButton.Text = I18N.GetString("Change &font");\n            WrapTextCheckBox.Text = I18N.GetString("&Wrap text");
                }\n                else\n                {\n                    int bytesRead = connection.EndReceive(ar);\n                    if (bytesRead > 0)\n                    {\n                        Logging.Debug(remote, RecvSize, "TCP Relay");\n                        connection.BeginReceive(_connetionRecvBuffer, 0, RecvSize, SocketFlags.None, new AsyncCallback(ReadAll), null);\n                    }\n                    else
                    }\n                    else\n                        Close();\n                }\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }
            // \n            // ServersItem\n            // \n            this.ServersItem.Index = 2;\n            this.ServersItem.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {\n            this.SeperatorItem,\n            this.ConfigItem});\n            this.ServersItem.Text = "&Servers";\n            // \n            // SeperatorItem\n            // \n            this.SeperatorItem.Index = 0;\n            this.SeperatorItem.Text = "-";
            // \n            // editPACFileItem\n            // \n            // menuItem4\n            // \n            this.menuItem4.Index = 7;\n            this.menuItem4.Text = "-";\n            // \n            // QRCodeItem\n            // 
        {\n            try\n            {\n                RegistryKey registry =\n                    Registry.CurrentUser.OpenSubKey("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings",\n                        true);\n                if (global)\n                {\n                    registry.SetValue("ProxyEnable", 1);\n                    registry.SetValue("ProxyServer", "127.0.0.1:8123");
                SystemProxy.NotifyIE();\n                //Must Notify IE first, or the connections do not chanage\n                CopyProxySettingFromLan();\n            }\n            catch (Exception)\n            {\n                MessageBox.Show("can not change registry!");\n                throw;\n            }\n        }
        {\n            // These lines implement the Interface in the beginning of program \n            // They cause the OS to refresh the settings, causing IP to realy update\n            settingsReturn = InternetSetOption(IntPtr.Zero, INTERNET_OPTION_SETTINGS_CHANGED, IntPtr.Zero, 0);\n            refreshReturn = InternetSetOption(IntPtr.Zero, INTERNET_OPTION_REFRESH, IntPtr.Zero, 0);\n        }\n        public static void Enable()\n        {\n            RegistryKey registry = Registry.CurrentUser.OpenSubKey("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings", true);\n            registry.SetValue("ProxyEnable", 0);\n            registry.SetValue("ProxyServer", "");\n            registry.SetValue("AutoConfigURL", "http://127.0.0.1:8090/pac");
        }\n        public static void Disable()\n        {\n            RegistryKey registry = Registry.CurrentUser.OpenSubKey("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings", true);\n            registry.SetValue("ProxyEnable", 0);\n            registry.SetValue("ProxyServer", "");\n            registry.SetValue("AutoConfigURL", "");\n            SystemProxy.NotifyIE();\n        }
        }\n    }\n}
using System.Web;\nusing Shadowsocks.Controller;\nnamespace Shadowsocks.Model\n{\n    [Serializable]\n    public class Server\n    {
        private const int DefaultServerTimeoutSec = 5;\n        public const int MaxServerTimeoutSec = 20;\n        public string server;\n        public int server_port;\n        public string password;\n        public string method;\n        public string plugin;\n        public string plugin_opts;\n        public string remarks;\n        public int timeout;
            List<Server> servers = new List<Server>();\n            foreach (string serverUrl in serverUrls)\n            {\n                if (string.IsNullOrWhiteSpace(serverUrl))\n                {\n                    continue;
            {\n                if (string.IsNullOrWhiteSpace(serverUrl))\n                {\n                    continue;\n                }\n                Uri parsedUrl;
                {\n                    continue;\n                }\n                Uri parsedUrl;\n                try\n                {\n                    parsedUrl = new Uri(serverUrl);\n                }\n                catch (UriFormatException)\n                {
                }\n                Uri parsedUrl;\n                try\n                {\n                    parsedUrl = new Uri(serverUrl);\n                }\n                catch (UriFormatException)\n                {
                    continue;\n                }\n                Server tmp = new Server\n                {\n                    remarks = parsedUrl.GetComponents(UriComponents.Fragment, UriFormat.Unescaped)\n                };\n                string possiblyUnpaddedBase64 = parsedUrl.GetComponents(UriComponents.UserInfo, UriFormat.Unescaped);\n                bool isOldFormatUrl = possiblyUnpaddedBase64.Length == 0;\n                if (isOldFormatUrl)\n                {
                servers.Add(tmp);\n            }\n            return servers;\n        }\n        public string Identifier()\n        {\n            return server + ':' + server_port;\n        }\n    }\n}
            this.tableLayoutPanel1.Controls.Add(this.IPLabel, 0, 0);\n            this.tableLayoutPanel1.Controls.Add(this.ServerPortLabel, 0, 1);\n            this.tableLayoutPanel1.Controls.Add(this.PasswordLabel, 0, 2);\n            this.tableLayoutPanel1.Controls.Add(this.IPTextBox, 1, 0);\n            this.tableLayoutPanel1.Controls.Add(this.ServerPortTextBox, 1, 1);\n            this.tableLayoutPanel1.Controls.Add(this.PasswordTextBox, 1, 2);\n            this.tableLayoutPanel1.Controls.Add(this.EncryptionLabel, 0, 3);\n            this.tableLayoutPanel1.Controls.Add(this.EncryptionSelect, 1, 3);\n            this.tableLayoutPanel1.Controls.Add(this.TimeoutLabel, 0, 8);\n            this.tableLayoutPanel1.Controls.Add(this.TimeoutTextBox, 1, 8);
            this.tableLayoutPanel1.Location = new System.Drawing.Point(8, 21);\n            this.tableLayoutPanel1.Margin = new System.Windows.Forms.Padding(0);\n            this.tableLayoutPanel1.Name = "tableLayoutPanel1";\n            this.tableLayoutPanel1.Padding = new System.Windows.Forms.Padding(3);\n            this.tableLayoutPanel1.RowCount = 9;\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel1.TabIndex = 0;\n            // \n            // PluginOptionsLabel\n            // \n            this.PluginOptionsLabel.Anchor = System.Windows.Forms.AnchorStyles.Right;\n            this.PluginOptionsLabel.AutoSize = true;\n            this.PluginOptionsLabel.Location = new System.Drawing.Point(6, 140);\n            this.PluginOptionsLabel.Name = "PluginOptionsLabel";\n            this.PluginOptionsLabel.Size = new System.Drawing.Size(75, 13);\n            this.PluginOptionsLabel.TabIndex = 15;\n            this.PluginOptionsLabel.Text = "Plugin Options";
                File.WriteAllBytes(DATABASE_PATH, Resources.dlc_dat);\n            }\n            LoadGeositeList();\n        }\n        /// <summary>\n        /// load new GeoSite data from geositeDB\n        /// </summary>\n        static void LoadGeositeList()\n        {\n            var list = GeositeList.Parser.ParseFrom(geositeDB);\n            foreach (var item in list.Entries)\n            {
            foreach (var item in list.Entries)\n            {\n                Geosites[item.GroupName.ToLower()] = item.Domains;\n            }\n        }\n        public static void ResetEvent()\n        {\n            UpdateCompleted = null;\n            Error = null;\n        }
        {\n            string geositeUrl = GEOSITE_URL;\n            string geositeSha256sumUrl = GEOSITE_SHA256SUM_URL;\n            SHA256 mySHA256 = SHA256.Create();\n            var config = Program.MainController.GetCurrentConfiguration();\n            string group = config.geositeGroup;\n            bool blacklist = config.geositeBlacklistMode;\n            if (!string.IsNullOrWhiteSpace(config.geositeUrl))\n            {\n                logger.Info("Found custom Geosite URL in config file");
            if (config.enabled)\n            {\n                httpClientHandler.Proxy = new WebProxy(\n                    config.isIPv6Enabled\n                    ? $"[{IPAddress.IPv6Loopback}]"\n                    : IPAddress.Loopback.ToString(),\n                    config.localPort);\n            }\n            try\n            {
                    config.isIPv6Enabled\n                    ? $"[{IPAddress.IPv6Loopback}]"\n                    : IPAddress.Loopback.ToString(),\n                    config.localPort);\n            }\n            try\n            {\n                // download checksum first\n                var geositeSha256sum = await httpClient.GetStringAsync(geositeSha256sumUrl);\n                geositeSha256sum = geositeSha256sum.Substring(0, 64).ToUpper();
        }\n        public static bool MergeAndWritePACFile(string group, bool blacklist)\n        {\n            IList<DomainObject> domains = Geosites[group];\n            string abpContent = MergePACFile(domains, blacklist);\n            if (File.Exists(PACDaemon.PAC_FILE))\n            {\n                string original = FileManager.NonExclusiveReadAllText(PACDaemon.PAC_FILE, Encoding.UTF8);\n                if (original == abpContent)\n                {
        public ConfigForm(ShadowsocksController controller)\n        {\n            InitializeComponent();\n            notifyIcon1.ContextMenu = contextMenu1;\n            this.controller = controller;\n            controller.EnableStatusChanged += controller_EnableStatusChanged;\n            controller.ConfigChanged += controller_ConfigChanged;\n            controller.PACFileReadyToOpen += controller_PACFileReadyToOpen;\n            loadCurrentConfiguration();\n        }
        }\n        private void controller_ConfigChanged(object sender, EventArgs e)\n        {\n            loadCurrentConfiguration();\n        }\n        private void controller_EnableStatusChanged(object sender, EventArgs e)\n        {\n            enableItem.Checked = controller.GetConfiguration().enabled;\n        }\n        void controller_PACFileReadyToOpen(object sender, ShadowsocksController.PathEventArgs e)
        }\n        private void controller_EnableStatusChanged(object sender, EventArgs e)\n        {\n            enableItem.Checked = controller.GetConfiguration().enabled;\n        }\n        void controller_PACFileReadyToOpen(object sender, ShadowsocksController.PathEventArgs e)\n        {\n            string argument = @"/select, " + e.Path;\n            System.Diagnostics.Process.Start("explorer.exe", argument);\n        }
        }\n        void controller_PACFileReadyToOpen(object sender, ShadowsocksController.PathEventArgs e)\n        {\n            string argument = @"/select, " + e.Path;\n            System.Diagnostics.Process.Start("explorer.exe", argument);\n        }\n        private void showWindow()\n        {\n            this.Opacity = 1;\n            this.Show();
        {\n            try\n            {\n                if (oldSelectedIndex == -1 || oldSelectedIndex >= modifiedConfiguration.configs.Count)\n                {\n                    return true;\n                }\n                Server server = new Server\n                {\n                    server = IPTextBox.Text,
            IPTextBox.Text = server.server;\n            ServerPortTextBox.Text = server.server_port.ToString();\n            PasswordTextBox.Text = server.password;\n            ProxyPortTextBox.Text = server.local_port.ToString();\n            EncryptionSelect.Text = server.method == null ? "aes-256-cfb" : server.method;\n        }\n        private void loadCurrentConfiguration()\n        {\n            modifiedConfiguration = controller.GetConfiguration();
        }\n        private void loadCurrentConfiguration()\n        {\n            modifiedConfiguration = controller.GetConfiguration();\n            ServersListBox.Items.Clear();\n            foreach (Server server in modifiedConfiguration.configs)\n            {\n                ServersListBox.Items.Add(server.server);\n            }\n            ServersListBox.SelectedIndex = modifiedConfiguration.index;
        {\n            if (!controller.GetConfiguration().isDefault)\n            {\n                this.Opacity = 0;\n                BeginInvoke(new MethodInvoker(delegate\n                {\n                    this.Hide();\n                }));\n            }\n        }
        }\n        private void CancelButton_Click(object sender, EventArgs e)\n        {\n            this.Hide();\n            loadCurrentConfiguration();\n        }\n        private void ConfigForm_FormClosed(object sender, FormClosedEventArgs e)\n        {\n            controller.Stop();\n        }
        }\n        private void ConfigForm_FormClosed(object sender, FormClosedEventArgs e)\n        {\n            controller.Stop();\n        }\n        private void AboutItem_Click(object sender, EventArgs e)\n        {\n            Process.Start("https://github.com/clowwindy/shadowsocks-csharp");\n        }\n        private void notifyIcon1_DoubleClick(object sender, EventArgs e)
            this.label1 = new System.Windows.Forms.Label();\n            this.label2 = new System.Windows.Forms.Label();\n            this.ProxyPortTextBox = new System.Windows.Forms.TextBox();\n            this.label4 = new System.Windows.Forms.Label();\n            this.label3 = new System.Windows.Forms.Label();\n            this.IPTextBox = new System.Windows.Forms.TextBox();\n            this.ServerPortTextBox = new System.Windows.Forms.TextBox();\n            this.PasswordTextBox = new System.Windows.Forms.TextBox();
            this.label3 = new System.Windows.Forms.Label();\n            this.IPTextBox = new System.Windows.Forms.TextBox();\n            this.ServerPortTextBox = new System.Windows.Forms.TextBox();\n            this.PasswordTextBox = new System.Windows.Forms.TextBox();\n            this.label5 = new System.Windows.Forms.Label();\n            this.EncryptionSelect = new System.Windows.Forms.ComboBox();\n            this.notifyIcon1 = new System.Windows.Forms.NotifyIcon(this.components);\n            this.panel2 = new System.Windows.Forms.Panel();
            this.IPTextBox = new System.Windows.Forms.TextBox();\n            this.ServerPortTextBox = new System.Windows.Forms.TextBox();\n            this.PasswordTextBox = new System.Windows.Forms.TextBox();\n            this.label5 = new System.Windows.Forms.Label();\n            this.EncryptionSelect = new System.Windows.Forms.ComboBox();\n            this.notifyIcon1 = new System.Windows.Forms.NotifyIcon(this.components);\n            this.panel2 = new System.Windows.Forms.Panel();\n            this.OKButton = new System.Windows.Forms.Button();\n            this.MyCancelButton = new System.Windows.Forms.Button();
            this.notifyIcon1 = new System.Windows.Forms.NotifyIcon(this.components);\n            this.panel2 = new System.Windows.Forms.Panel();\n            this.OKButton = new System.Windows.Forms.Button();\n            this.MyCancelButton = new System.Windows.Forms.Button();\n            this.panel1 = new System.Windows.Forms.Panel();\n            this.contextMenu1 = new System.Windows.Forms.ContextMenu();\n            this.enableItem = new System.Windows.Forms.MenuItem();\n            this.configItem = new System.Windows.Forms.MenuItem();\n            this.editPACFileItem = new System.Windows.Forms.MenuItem();\n            this.aboutItem = new System.Windows.Forms.MenuItem();
            this.groupBox1 = new System.Windows.Forms.GroupBox();\n            this.ServersListBox = new System.Windows.Forms.ListBox();\n            this.tableLayoutPanel1.SuspendLayout();\n            this.panel1.SuspendLayout();\n            this.panel3.SuspendLayout();\n            this.groupBox1.SuspendLayout();\n            this.SuspendLayout();\n            // \n            // tableLayoutPanel1\n            // 
            // \n            // EncryptionSelect\n            // \n            this.EncryptionSelect.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) \n            | System.Windows.Forms.AnchorStyles.Right)));\n            this.EncryptionSelect.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;\n            this.EncryptionSelect.FormattingEnabled = true;\n            this.EncryptionSelect.ImeMode = System.Windows.Forms.ImeMode.NoControl;\n            this.EncryptionSelect.ItemHeight = 13;\n            this.EncryptionSelect.Items.AddRange(new object[] {
            // \n            // groupBox1\n            // \n            this.groupBox1.Controls.Add(this.tableLayoutPanel1);\n            this.groupBox1.Location = new System.Drawing.Point(182, 12);\n            this.groupBox1.Name = "groupBox1";\n            this.groupBox1.Size = new System.Drawing.Size(257, 186);\n            this.groupBox1.TabIndex = 6;\n            this.groupBox1.TabStop = false;\n            this.groupBox1.Text = "Server";
                    {\n                        //do nothing\n                    }
                    }
                }\n                RawStatistics = JsonConvert.DeserializeObject<Statistics>(File.ReadAllText(path)) ?? RawStatistics;\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Console.WriteLine($"failed to load statistics; try to reload {_retryInterval.TotalMinutes} minutes later");\n                _recorder.Change(_retryInterval, RecordingInterval);\n            }\n        }
            Func<string, object, bool> onLineRead, Action<Exception, object> onException,\n            Action<byte[], int, int, object> onFinish,\n            Encoding encoding, string delimiter,\n            object state)\n        {\n            if (buffer == null)\n            {\n                throw new ArgumentNullException(nameof(buffer));\n            }\n            if (socket == null)
            object state)\n        {\n            if (buffer == null)\n            {\n                throw new ArgumentNullException(nameof(buffer));\n            }\n            if (socket == null)\n            {\n                throw new ArgumentNullException(nameof(socket));\n            }
            {\n                throw new ArgumentException("Line buffer length can't less than first package length!", nameof(buffer));\n            }\n            if (length > 0)\n            {\n                if (firstPackge == null)\n                {\n                    throw new ArgumentNullException(nameof(firstPackge));\n                }\n            }
            }\n            if (length > 0)\n            {\n                if (firstPackge == null)\n                {\n                    throw new ArgumentNullException(nameof(firstPackge));\n                }\n            }\n            _socket = socket;\n            _onLineRead = onLineRead;
            {\n                throw new ArgumentException("Too small!", nameof(buffer));\n            }\n            _delimiterSearch = new ByteSearch.SearchTarget(_delimiterBytes);\n            _lineBuffer = buffer;\n            if (length > 0)\n            {\n                // process first package\n                if (buffer == firstPackge)\n                {\n                    _bufferDataIndex = index;
            }\n            _delimiterSearch = new ByteSearch.SearchTarget(_delimiterBytes);\n            _lineBuffer = buffer;\n            if (length > 0)\n            {\n                // process first package\n                if (buffer == firstPackge)\n                {\n                    _bufferDataIndex = index;\n                }\n                else
            if (length > 0)\n            {\n                // process first package\n                if (buffer == firstPackge)\n                {\n                    _bufferDataIndex = index;\n                }\n                else\n                {\n                    Array.Copy(firstPackge, index, _lineBuffer, 0, length);\n                }
                _bufferDataLength = length;\n                try\n                {\n                    NewPackageRecv();\n                }\n                catch (Exception ex)\n                {\n                    OnException(ex);\n                    OnFinish();\n                }
            }\n        }\n        public LineReader(int maxLineBytes, WrappedSocket socket, Func<string, object, bool> onLineRead,\n            Action<Exception, object> onException, Action<byte[], int, int, object> onFinish, Encoding encoding,\n            string delimiter, object state)\n            : this(\n                new byte[maxLineBytes], socket, null, 0, 0, onLineRead, onException, onFinish, encoding, delimiter,\n                state)
        {\n        }\n        private void ReceiveCallback(IAsyncResult ar)\n        {\n            try\n            {\n                var bytesRead = _socket.EndReceive(ar);\n                if (bytesRead == 0)\n                {\n                    OnFinish();
            // 构造request包剩余部分\n            request[0] = 5;\n            request[1] = 1;\n            request[2] = 0;\n            request[3] = atyp;\n            request[request.Length - 2] = (byte) ((port >> 8) & 0xff);\n            request[request.Length - 1] = (byte) (port & 0xff);\n            var st = new Socks5State();\n            st.Callback = callback;\n            st.AsyncState = state;\n            _remote.BeginSend(request, 0, request.Length, 0, Socks5RequestSendCallback, st);
{\n    class TCPRelay : Listener.Service\n    {\n        private ShadowsocksController _controller;\n        private DateTime _lastSweepTime;\n        private Configuration _config;\n        public ISet<TCPHandler> Handlers { get; set; }\n        public TCPRelay(ShadowsocksController controller, Configuration conf)
        public TCPRelay(ShadowsocksController controller, Configuration conf)\n        {\n            _controller = controller;\n            _config = conf;\n            Handlers = new HashSet<TCPHandler>();\n            _lastSweepTime = DateTime.Now;\n        }\n        public override bool Handle(byte[] firstPacket, int length, Socket socket, object state)
        }\n        public override bool Handle(byte[] firstPacket, int length, Socket socket, object state)\n        {\n            if (socket.ProtocolType != ProtocolType.Tcp\n                || (length < 2 || firstPacket[0] != 5))
                return false;\n            socket.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n            TCPHandler handler = new TCPHandler(_controller, _config, this, socket);\n            IList<TCPHandler> handlersToClose = new List<TCPHandler>();\n            lock (Handlers)\n            {\n                Handlers.Add(handler);\n                DateTime now = DateTime.Now;\n                if (now - _lastSweepTime > TimeSpan.FromSeconds(1))
            socket.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n            TCPHandler handler = new TCPHandler(_controller, _config, this, socket);\n            IList<TCPHandler> handlersToClose = new List<TCPHandler>();\n            lock (Handlers)\n            {\n                Handlers.Add(handler);\n                DateTime now = DateTime.Now;\n                if (now - _lastSweepTime > TimeSpan.FromSeconds(1))\n                {\n                    _lastSweepTime = now;
    {\n        class AsyncSession
        {\n            public IForwardProxy Remote { get; }\n            public AsyncSession(IForwardProxy remote)\n            {\n                Remote = remote;\n            }\n        }\n        class AsyncSession<T> : AsyncSession\n        {\n            public T State { get; set; }
        {\n            public T State { get; set; }\n            public AsyncSession(IForwardProxy remote, T state) : base(remote)\n            {\n                State = state;\n            }
        private AsyncSession _currentRemoteSession;\n        private bool        _proxyConnected;\n        private bool        _destConnected;\n        private byte    _command;\n        private byte[]  _firstPacket;\n        private int     _firstPacketLength;\n        private int     _totalRead = 0;\n        private int     _totalWrite = 0;\n        private byte[]  _remoteRecvBuffer = new byte[BufferSize];\n        private byte[]  _remoteSendBuffer = new byte[BufferSize];
        private DateTime _startConnectTime;\n        private DateTime _startReceivingTime;\n        private DateTime _startSendingTime;\n        private EndPoint _destEndPoint = null;\n        public TCPHandler(ShadowsocksController controller, Configuration config, TCPRelay tcprelay, Socket socket)\n        {\n            _controller = controller;
        {\n            _controller = controller;\n        }\n        public void CreateRemote()
            if (server == null || server.server == "")\n                throw new ArgumentException("No server configured");\n            lock (_encryptionLock)\n            {\n                lock (_decryptionLock)\n                {\n                    _encryptor = EncryptorFactory.GetEncryptor(server.method, server.password, server.auth, false);\n                }\n            }\n            this._server = server;
            try\n            {\n                _startReceivingTime = DateTime.Now;\n                session.Remote.BeginReceive(_remoteRecvBuffer, 0, RecvSize, SocketFlags.None, new AsyncCallback(PipeRemoteReceiveCallback), session);\n                SendToServer(_firstPacketLength, session);\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();
            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void PipeRemoteReceiveCallback(IAsyncResult ar)\n        {
            _totalWrite += length;\n            int bytesToSend;\n            lock (_encryptionLock)\n            {\n            session.Remote.BeginSend(_connetionSendBuffer, 0, bytesToSend, SocketFlags.None, new AsyncCallback(PipeRemoteSendCallback), session);\n            IStrategy strategy = _controller.GetCurrentStrategy();
            IStrategy strategy = _controller.GetCurrentStrategy();\n            strategy?.UpdateLastWrite(_server);\n        }\n        private void PipeRemoteSendCallback(IAsyncResult ar)
        private void PipeRemoteSendCallback(IAsyncResult ar)\n        {\n            if (_closed) return;\n            try\n            {\n                var session = (AsyncSession)ar.AsyncState;\n                session.Remote.EndSend(ar);\n                _connection.BeginReceive(_connetionRecvBuffer, 0, RecvSize, SocketFlags.None, new AsyncCallback(PipeConnectionReceiveCallback), session);\n            }\n            catch (Exception e)
            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void PipeConnectionSendCallback(IAsyncResult ar)\n        {\n            try
                services.Add(tcpRelay);\n                services.Add(udpRelay);\n                services.Add(_pacServer);\n                services.Add(new Http2Socks5(_config.localPort));\n                _listener = new Listener(services);\n                _listener.Start(_config);\n            }\n            catch (Exception e)\n            {\n                // translate Microsoft language into human language
                    _encryptIV = new byte[ivLen];\n                    Array.Copy(iv, _encryptIV, ivLen);\n                }\n                else\n                {\n                    _decryptIV = new byte[ivLen];\n                    Array.Copy(iv, _decryptIV, ivLen);\n                }\n            }\n            else if (_cipher == CIPHER_BF)
                    _decryptIV = new byte[ivLen];\n                    Array.Copy(iv, _decryptIV, ivLen);\n                }\n            }\n            else if (_cipher == CIPHER_RC4)\n            {\n                PolarSSL.arc4_init(ctx);\n                PolarSSL.arc4_setup(ctx, realkey, keyLen);\n            }\n        }
        public event EventHandler PACFileChanged;\n        public event EventHandler UpdatePACFromGFWListCompleted;\n        public event ErrorEventHandler UpdatePACFromGFWListError;\n        public void Start(Configuration configuration)\n        {\n            try\n            {\n                config = configuration;\n                // Create a TCP/IP socket.\n                _listener = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
            }\n            catch (SocketException)\n            {\n                _listener.Close();\n                throw;\n            }\n        }\n        public void Stop()\n        {
            if (_listener != null)\n            {\n                _listener.Close();\n                _listener = null;\n            }\n        }\n        public string TouchPACFile()\n        {\n            if (File.Exists(PAC_FILE))\n            {
        public IWebProxy proxy = null;\n        public class GfwListDownloadCompletedArgs : EventArgs\n        {\n            public string Content;\n        }\n        public event EventHandler<GfwListDownloadCompletedArgs> DownloadCompleted;\n        public event ErrorEventHandler Error;\n        public void Download()\n        {\n            WebClient http = new WebClient();
        {\n            try\n            {\n                string response = e.Result;\n                if (DownloadCompleted != null)\n                {\n                    DownloadCompleted(this, new GfwListDownloadCompletedArgs\n                    {\n                        Content = response\n                    });
            }\n            catch (Exception ex)\n            {\n                ReportError(ex);\n            }\n        }\n        public class Parser\n        {\n            private string _Content;\n            public string Content
            public Parser(string response)\n            {\n                byte[] bytes = Convert.FromBase64String(response);\n                this._Content = Encoding.ASCII.GetString(bytes);\n            }\n            public string[] GetValidLines()\n            {\n                string[] lines = Content.Split(new char[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);\n                List<string> valid_lines = new List<string>(lines.Length);\n                foreach (string line in lines)
            }\n            /* refer https://github.com/clowwindy/gfwlist2pac/blob/master/gfwlist2pac/main.py */\n            public string[] GetDomains()\n            {\n                List<string> lines = new List<string>(GetValidLines());\n                lines.AddRange(GetBuildIn());\n                List<string> domains = new List<string>(lines.Count);\n                for (int i = 0; i < lines.Count; i++)\n                {\n                    string line = lines[i];\n                    if (line.IndexOf(".*") >= 0)
                lines.AddRange(GetBuildIn());\n                List<string> domains = new List<string>(lines.Count);\n                for (int i = 0; i < lines.Count; i++)\n                {\n                    string line = lines[i];\n                    if (line.IndexOf(".*") >= 0)\n                        continue;\n                    if (line.StartsWith("http://"))\n                        line = line.Substring(7);\n                    else if (line.StartsWith("https://"))

            this.tableLayoutPanel1.SuspendLayout();\n            this.panel1.SuspendLayout();\n            this.panel3.SuspendLayout();\n            this.ServerGroupBox.SuspendLayout();\n            this.panel4.SuspendLayout();\n            this.SuspendLayout();\n            // \n            // tableLayoutPanel1\n            // \n            this.tableLayoutPanel1.AutoSize = true;
            {\n                this.Opacity = 0;\n                BeginInvoke(new MethodInvoker(delegate { this.Hide(); }));
            }\n        }\n        private void ServersListBox_SelectedIndexChanged(object sender, EventArgs e)\n        {
            }\n        }\n        private void UserRuleFileWatcher_Changed(object sender, FileSystemEventArgs e)\n        {\n            string path = e.FullPath.ToString();\n            string currentLastWriteTime = File.GetLastWriteTime(e.FullPath).ToString();\n            // if there is no path info stored yet or stored path has different time of write then the one now is inspected\n            if (!fileChangedTime.ContainsKey(path) || fileChangedTime[path].ToString() != currentLastWriteTime)\n            {\n                if (UserRuleFileChanged != null)
        private string GetPACAddress(byte[] requestBuf, int length, IPEndPoint localEndPoint, bool useSocks)\n        {\n            //try\n            //{\n            //    string requestString = Encoding.UTF8.GetString(requestBuf);\n            //    if (requestString.IndexOf("AppleWebKit") >= 0)\n            //    {\n            //        string address = "" + localEndPoint.Address + ":" + config.GetCurrentServer().local_port;\n            //        proxy = "SOCKS5 " + address + "; SOCKS " + address + ";";\n            //    }
                _process.StartInfo.CreateNoWindow = true;\n                //_process.StartInfo.RedirectStandardOutput = true;\n                //_process.StartInfo.RedirectStandardError = true;\n                _process.Start();\n            }\n        }\n        public void Stop()\n        {\n            if (_process != null)\n            {
                _process.Start();\n            }\n        }\n        public void Stop()\n        {\n            if (_process != null)\n            {\n                try\n                {\n                    _process.Kill();
            onlinePACItem.Checked = onlinePACItem.Enabled && config.useOnlinePac;\n            localPACItem.Checked = !onlinePACItem.Checked;\n            UpdatePACItemsEnabledStatus();
            }\n        }\n        private void UpdateOnlinePACURLItem_Click(object sender, EventArgs e)\n        {\n            string origPacUrl = controller.GetConfiguration().pacUrl;\n            string pacUrl = Microsoft.VisualBasic.Interaction.InputBox(\n                I18N.GetString("Please input PAC Url"),
using System.IO;\nusing System.IO.Compression;\nnamespace Shadowsocks.Controller\n{\n    public class FileManager\n    {\n        public static bool ByteArrayToFile(string fileName, byte[] content)\n        {\n            try
namespace Shadowsocks.Controller\n{\n    public class FileManager\n    {\n        public static bool ByteArrayToFile(string fileName, byte[] content)\n        {\n            try\n            {\n                FileStream _FileStream = new FileStream(fileName, FileMode.Create, FileAccess.Write);
                _FileStream.Write(content, 0, content.Length);\n                _FileStream.Close();\n                return true;\n            }\n            catch (Exception _Exception)\n            {\n                Console.WriteLine("Exception caught in process: {0}",\n                                  _Exception.ToString());\n            }\n            return false;
                {\n                    destinationFile.Write(buffer, 0, n);\n                }\n            }\n            destinationFile.Close();
                    destinationFile.Write(buffer, 0, n);\n                }\n            }\n            destinationFile.Close();\n        }\n        public static void CompressFile(string fileName, byte[] content)\n        {\n            FileStream destinationFile = File.Create(fileName);\n            MemoryStream ms = new MemoryStream(content);\n            // Because the compressed size of the file is unknown,
                return true;\n            }\n            catch (IOException e)\n            {\n                Console.WriteLine(e.ToString());\n                return false;\n            }\n        }\n        private static void RollLogFile()\n        {
        }\n        public static void Info(object o)\n        {\n            WriteToLogFile(o);\n        }\n        public static void Debug(object o)\n        {\n#if DEBUG\n            WriteToLogFile("[D] " + o);\n#endif\n        }
        }\n        public static void Debug(object o)\n        {\n#if DEBUG\n            WriteToLogFile("[D] " + o);\n#endif\n        }\n        public static void Debug(EndPoint local, EndPoint remote, int len, string header = null, string tailer = null)\n        {\n#if DEBUG\n            if (header == null && tailer == null)
#endif\n        }\n        public static void Debug(EndPoint local, EndPoint remote, int len, string header = null, string tailer = null)\n        {\n#if DEBUG\n            if (header == null && tailer == null)\n                Debug($"{local} => {remote} (size={len})");\n            else if (header == null && tailer != null)\n                Debug($"{local} => {remote} (size={len}), {tailer}");\n            else if (header != null && tailer == null)
        {\n            WebClient http = new WebClient();\n            http.Proxy = new WebProxy(IPAddress.Loopback.ToString(), config.localPort);\n            http.DownloadStringCompleted += http_DownloadStringCompleted;\n            http.DownloadStringAsync(new Uri(GFWLIST_URL));\n        }\n        public List<string> ParseResult(string response)\n        {\n            byte[] bytes = Convert.FromBase64String(response);\n            string content = Encoding.ASCII.GetString(bytes);
            http.DownloadStringCompleted += http_DownloadStringCompleted;\n            http.DownloadStringAsync(new Uri(GFWLIST_URL));\n        }\n        public List<string> ParseResult(string response)\n        {\n            byte[] bytes = Convert.FromBase64String(response);\n            string content = Encoding.ASCII.GetString(bytes);\n            string[] lines = content.Split(new char[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);\n            List<string> valid_lines = new List<string>(lines.Length);\n            foreach (string line in lines)
            ChangeFontButton.Text = I18N.GetString("Change &Font");\n            WrapTextCheckBox.Text = I18N.GetString("&Wrap Text");\n            TopMostCheckBox.Text = I18N.GetString("&Top Most");\n            ViewMenuItem.Text = I18N.GetString("&View");\n            ClearLogsMenuItem.Text = I18N.GetString("&Clear Logs");\n            ChangeFontMenuItem.Text = I18N.GetString("Change &Font");\n            WrapTextMenuItem.Text = I18N.GetString("&Wrap Text");\n            TopMostMenuItem.Text = I18N.GetString("&Top Most");\n            ShowToolbarMenuItem.Text = I18N.GetString("&Show Toolbar");\n            Text = I18N.GetString("Log Viewer");
            ChangeFontMenuItem.Text = I18N.GetString("Change &Font");\n            WrapTextMenuItem.Text = I18N.GetString("&Wrap Text");\n            TopMostMenuItem.Text = I18N.GetString("&Top Most");\n            ShowToolbarMenuItem.Text = I18N.GetString("&Show Toolbar");\n            Text = I18N.GetString("Log Viewer");\n            // traffic chart\n            trafficChart.Series["Inbound"].LegendText = I18N.GetString("Inbound");\n            trafficChart.Series["Outbound"].LegendText = I18N.GetString("Outbound");\n        }\n        private void Timer_Tick(object sender, EventArgs e)
        {\n            Logging.Clear();\n            lastOffset = 0;\n            LogMessageTextBox.Clear();\n        }\n        private void ClearLogsMenuItem_Click(object sender, EventArgs e)\n        {\n            DoClearLogs();\n        }\n        private void ClearLogsButton_Click(object sender, EventArgs e)
        }\n        #endregion\n        #region Change the font settings applied in LogMessageTextBox.\n        private void DoChangeFont()\n        {\n            try\n            {\n                FontDialog fd = new FontDialog();\n                fd.Font = LogMessageTextBox.Font;\n                if (fd.ShowDialog() == DialogResult.OK)
            this.ChangeFontMenuItem = new System.Windows.Forms.MenuItem();\n            this.WrapTextMenuItem = new System.Windows.Forms.MenuItem();\n            this.TopMostMenuItem = new System.Windows.Forms.MenuItem();\n            this.MenuItemSeparater = new System.Windows.Forms.MenuItem();\n            this.ShowToolbarMenuItem = new System.Windows.Forms.MenuItem();\n            this.TopMostCheckBox = new System.Windows.Forms.CheckBox();\n            this.ChangeFontButton = new System.Windows.Forms.Button();\n            this.ClearLogsButton = new System.Windows.Forms.Button();

            // \n            // ChangeFontMenuItem\n            // \n            this.ChangeFontMenuItem.Index = 1;\n            this.ChangeFontMenuItem.Text = "Change &Font";\n            this.ChangeFontMenuItem.Click += new System.EventHandler(this.ChangeFontMenuItem_Click);\n            // \n            // WrapTextMenuItem\n            // \n            this.WrapTextMenuItem.Index = 2;
        private System.Windows.Forms.Button ChangeFontButton;\n        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel1;\n        private System.Windows.Forms.CheckBox TopMostCheckBox;\n        private System.Windows.Forms.MenuItem ViewMenuItem;\n        private System.Windows.Forms.MenuItem ClearLogsMenuItem;\n        private System.Windows.Forms.MenuItem ChangeFontMenuItem;\n        private System.Windows.Forms.MenuItem WrapTextMenuItem;\n        private System.Windows.Forms.MenuItem TopMostMenuItem;\n        private System.Windows.Forms.FlowLayoutPanel ToolbarFlowLayoutPanel;\n        private System.Windows.Forms.MenuItem MenuItemSeparater;
        private System.Windows.Forms.MenuItem ChangeFontMenuItem;\n        private System.Windows.Forms.MenuItem WrapTextMenuItem;\n        private System.Windows.Forms.MenuItem TopMostMenuItem;\n        private System.Windows.Forms.FlowLayoutPanel ToolbarFlowLayoutPanel;\n        private System.Windows.Forms.MenuItem MenuItemSeparater;\n        private System.Windows.Forms.MenuItem ShowToolbarMenuItem;\n        private System.Windows.Forms.SplitContainer splitContainer1;\n        private System.Windows.Forms.DataVisualization.Charting.Chart trafficChart;\n    }\n}
                            targetIndex = i;\n                    }\n                    Logging.Info($"Using {localeNames[targetIndex]} translation for {locale}");\n                }\n                // Still not found, exit\n                if (targetIndex == -1 || enIndex == targetIndex)\n                {\n                    Logging.Info($"Translation for {locale} not found");\n                    return;\n                }
                    }\n                    Logging.Info($"Using {localeNames[targetIndex]} translation for {locale}");\n                }\n                // Still not found, exit\n                if (targetIndex == -1 || enIndex == targetIndex)\n                {\n                    Logging.Info($"Translation for {locale} not found");\n                    return;\n                }\n                // read translation lines\n                while (!csvParser.EndOfData)
                {\n                    Logging.Info($"Translation for {locale} not found");\n                    return;\n                }\n                // read translation lines\n                while (!csvParser.EndOfData)\n                {\n                    string[] translations = csvParser.ReadFields();\n                    string source = translations[enIndex];\n                    string translation = translations[targetIndex];
                    connection.BeginReceive(_connetionRecvBuffer, 0, RecvSize, SocketFlags.None, new AsyncCallback(ReadAll), null);\n                }\n                else\n                {\n                    int bytesRead = connection.EndReceive(ar);\n                    if (bytesRead > 0)\n                    {\n                        // TODO: need fix\n                        //Logging.Debug(remote.LocalEndPoint, remote.DestEndPoint, RecvSize, "TCP Relay");\n                        connection.BeginReceive(_connetionRecvBuffer, 0, RecvSize, SocketFlags.None, new AsyncCallback(ReadAll), null);\n                    }
                        connection.BeginReceive(_connetionRecvBuffer, 0, RecvSize, SocketFlags.None, new AsyncCallback(ReadAll), null);\n                    }\n                    else\n                        Close();\n                }\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();
                // Setting up proxy\n                IPEndPoint proxyEP;\n                if (_config.useProxy)\n                {\n                    IPAddress ipAddress;\n                    bool parsed = IPAddress.TryParse(_config.proxyServer, out ipAddress);\n                    if (!parsed)\n                    {
                    if (!parsed)\n                    {
                }\n                ProxyTimer proxyTimer = new ProxyTimer(3000);\n                proxyTimer.AutoReset = false;\n                proxyTimer.Elapsed += proxyConnectTimer_Elapsed;\n                proxyTimer.Enabled = true;\n                proxyTimer.Proxy = remote;\n                proxyTimer.DestHost = server.server;\n                proxyTimer.DestPort = server.server_port;\n                proxyTimer.Server = server;
                proxyTimer.Server = server;\n                _proxyConnected = false;\n                // Connect to the proxy server.\n                remote.BeginConnectProxy(proxyEP, new AsyncCallback(ProxyConnectCallback), proxyTimer);\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }
        public void BeginConnectProxy(EndPoint remoteEP, AsyncCallback callback, object state)\n        {\n            // do nothing\n            var r = new FakeAsyncResult(state);\n            callback?.Invoke(r);\n        }\n        public void EndConnectProxy(IAsyncResult asyncResult)\n        {\n            // do nothing\n        }\n        public void BeginConnectDest(string host, int port, AsyncCallback callback, object state)
            var r = new FakeAsyncResult(state);\n            callback?.Invoke(r);\n        }\n        public void EndConnectProxy(IAsyncResult asyncResult)\n        {\n            // do nothing\n        }\n        public void BeginConnectDest(string host, int port, AsyncCallback callback, object state)\n        {\n            // TODO async resolving\n            IPAddress ipAddress;
        {\n            // TODO async resolving\n            IPAddress ipAddress;\n            bool parsed = IPAddress.TryParse(host, out ipAddress);\n            if (!parsed)\n            {\n                IPHostEntry ipHostInfo = Dns.GetHostEntry(host);\n                ipAddress = ipHostInfo.AddressList[0];\n            }\n            IPEndPoint remoteEP = new IPEndPoint(ipAddress, port);
            _remote.BeginConnect(remoteEP, callback, state);\n        }\n        public void EndConnectDest(IAsyncResult asyncResult)\n        {\n            _remote?.EndConnect(asyncResult);\n        }\n        public void BeginSend(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state)\n        {\n            _remote?.BeginSend(buffer, offset, size, socketFlags, callback, state);
        void BeginConnectProxy(EndPoint remoteEP, AsyncCallback callback, object state);\n        void EndConnectProxy(IAsyncResult asyncResult);\n        void BeginConnectDest(string host, int port, AsyncCallback callback, object state);\n        void EndConnectDest(IAsyncResult asyncResult);\n        void BeginSend(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state);\n        int EndSend(IAsyncResult asyncResult);\n        void BeginReceive(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state);\n        int EndReceive(IAsyncResult asyncResult);
        void EndConnectDest(IAsyncResult asyncResult);\n        void BeginSend(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state);\n        int EndSend(IAsyncResult asyncResult);\n        void BeginReceive(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state);\n        int EndReceive(IAsyncResult asyncResult);\n        void Shutdown(SocketShutdown how);\n        void Close();\n    }
            Bitmap drawArea = new Bitmap((qrCoded.GetModuleCount() * blockSize), (qrCoded.GetModuleCount() * blockSize));\n            using (Graphics g = Graphics.FromImage(drawArea))\n            {\n                g.Clear(Color.White);\n                using (Brush b = new SolidBrush(Color.Black))\n                {\n                    for (int row = 0; row < qrCoded.GetModuleCount(); row++)
            {\n                g.Clear(Color.White);\n                using (Brush b = new SolidBrush(Color.Black))\n                {\n                    for (int row = 0; row < qrCoded.GetModuleCount(); row++)\n                    {\n                        for (int col = 0; col < qrCoded.GetModuleCount(); col++)
                {\n                    for (int row = 0; row < qrCoded.GetModuleCount(); row++)\n                    {\n                        for (int col = 0; col < qrCoded.GetModuleCount(); col++)\n                        {\n                            bool isDark = qrCoded.IsDark(row, col);\n                            if (isDark)\n                            {
                    {\n                        for (int col = 0; col < qrCoded.GetModuleCount(); col++)\n                        {\n                            bool isDark = qrCoded.IsDark(row, col);\n                            if (isDark)\n                            {\n                                g.FillRectangle(b, blockSize * row, blockSize * col, blockSize, blockSize);
                        {\n                            bool isDark = qrCoded.IsDark(row, col);\n                            if (isDark)\n                            {\n                                g.FillRectangle(b, blockSize * row, blockSize * col, blockSize, blockSize);
                            {\n                                g.FillRectangle(b, blockSize * row, blockSize * col, blockSize, blockSize);
                            }\n                        }\n                    }\n                }\n            }\n            pictureBox1.Image = drawArea;\n        }\n        private void QRCodeForm_Load(object sender, EventArgs e)\n        {\n            GenQR(code);
                config.isDefault = false;\n                if (UpdateChecker.Asset.CompareVersion(UpdateChecker.Version, config.version ?? "0") > 0)\n                {\n                    config.updated = true;\n                }\n                if (config.configs == null)\n                    config.configs = new List<Server>();\n                if (config.configs.Count == 0)\n                    config.configs.Add(GetDefaultServer());\n                if (config.localPort == 0)
            }\n            catch (Exception e)\n            {\n                if (!(e is FileNotFoundException))\n                    logger.LogUsefulException(e);\n                config = new Configuration\n                {\n                    index = 0,\n                    isDefault = true,\n                    localPort = 1080,
                {\n                    index = 0,\n                    isDefault = true,\n                    localPort = 1080,\n                    autoCheckUpdate = true,\n                    configs = new List<Server>()\n                    {\n                        GetDefaultServer()\n                    },\n                    logViewer = new LogViewerConfig(),
            {\n                FontDialog fd = new FontDialog();\n                fd.Font = LogMessageTextBox.Font;\n                if (fd.ShowDialog() == DialogResult.OK)\n                {\n                    LogMessageTextBox.Font = new Font(fd.Font.FontFamily, fd.Font.Size, fd.Font.Style);\n                }\n            }\n            catch (Exception ex)\n            {
            }\n        }\n        private void TopMostCheckBox_CheckedChanged(object sender, EventArgs e)\n        {\n            this.TopMost = TopMostCheckBox.Checked;\n        }\n    }\n}
        ///   Looks up a localized string similar to # Sample configuration file for Polipo. -*-sh-*-\n        ///\n        ///# You should not need to use a configuration file; all configuration\n        ///# variables have reasonable defaults.  If you want to use one, you\n        ///# can copy this to /etc/polipo/config or to ~/.polipo and modify.\n        ///\n        ///# This file only contains some of the configuration variables; see the\n        ///# list given by ``polipo -v&apos;&apos; and the manual for more.\n        ///\n        ///\n            }\n        }\n        /// <summary>\n        ///   Looks up a localized resource of type System.Byte[].\n        /// </summary>\n        internal static byte[] polipo_exe {\n            get {\n            }
                {\n                    continue;\n                }\n                // Decode the Base64 part of Uri\n                int indexOfHashOrSlash = _serverUrl.IndexOfAny(new[] { '@', '/', '#' }, \n                                                               prefixLength, _serverUrl.Length - prefixLength);\n                string webSafeBase64Str = indexOfHashOrSlash == -1 ?\n                    _serverUrl.Substring(prefixLength) :\n                    _serverUrl.Substring(prefixLength, indexOfHashOrSlash - prefixLength);\n                string base64Str = webSafeBase64Str.Replace('-', '+').Replace('_', '/');
                }\n                catch (UriFormatException)\n                {\n                    continue;\n                }\n                Server tmp = new Server\n                {\n                    remarks = parsedUrl.GetComponents(UriComponents.Fragment, UriFormat.Unescaped)\n                };\n                string userInfo = parsedUrl.GetComponents(UriComponents.UserInfo, UriFormat.Unescaped);
                string[] userInfoParts = userInfo.Split(new[] { ':' }, 2);\n                if (userInfoParts.Length != 2)\n                {\n                    continue;\n                }\n                tmp.method = userInfoParts[0];\n                tmp.password = userInfoParts[1];\n                NameValueCollection queryParameters = HttpUtility.ParseQueryString(parsedUrl.Query);\n                string[] pluginParts = HttpUtility.UrlDecode(queryParameters["plugin"] ?? "").Split(new[] { ';' }, 2);\n                if (pluginParts.Length > 0)
            this.tableLayoutPanel1.Location = new System.Drawing.Point(8, 21);\n            this.tableLayoutPanel1.Margin = new System.Windows.Forms.Padding(0);\n            this.tableLayoutPanel1.Name = "tableLayoutPanel1";\n            this.tableLayoutPanel1.Padding = new System.Windows.Forms.Padding(3);\n            this.tableLayoutPanel1.RowCount = 8;\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel1.TabIndex = 0;\n            // \n            // RemarksTextBox\n            // \n            this.RemarksTextBox.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));
            this.ProxyPortTextBox = new System.Windows.Forms.TextBox();\n            this.tableLayoutPanel4 = new System.Windows.Forms.TableLayoutPanel();\n            this.ProxyTypeLabel = new System.Windows.Forms.Label();\n            this.ProxyTypeComboBox = new System.Windows.Forms.ComboBox();\n            this.ProxyTimeoutTextBox = new System.Windows.Forms.TextBox();\n            this.ProxyTimeoutLabel = new System.Windows.Forms.Label();
            this.ProxyAddrLabel.AutoSize = true;\n            this.ProxyAddrLabel.Location = new System.Drawing.Point(3, 7);\n            this.ProxyAddrLabel.Name = "ProxyAddrLabel";\n            this.ProxyAddrLabel.Size = new System.Drawing.Size(65, 12);\n            this.ProxyAddrLabel.TabIndex = 0;\n            this.ProxyAddrLabel.Text = "Proxy Addr";\n            // \n            // ProxyServerTextBox\n            // \n            this.ProxyServerTextBox.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));\n            this.ProxyServerTextBox.Location = new System.Drawing.Point(74, 3);\n            this.ProxyServerTextBox.MaxLength = 512;\n            this.ProxyServerTextBox.Name = "ProxyServerTextBox";
            // \n            // ProxyPortTextBox\n            // \n            this.ProxyPortTextBox.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));\n            this.ProxyPortTextBox.Location = new System.Drawing.Point(286, 3);\n            this.ProxyPortTextBox.MaxLength = 10;\n            this.ProxyPortTextBox.Name = "ProxyPortTextBox";\n            this.ProxyPortTextBox.Size = new System.Drawing.Size(100, 21);\n            this.ProxyPortTextBox.TabIndex = 3;\n            this.ProxyPortTextBox.WordWrap = false;\n            // \n            // tableLayoutPanel4\n            // \n            this.tableLayoutPanel4.ColumnCount = 4;\n            this.tableLayoutPanel4.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());
            this.tableLayoutPanel4.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());\n            this.tableLayoutPanel4.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());\n            this.tableLayoutPanel4.Controls.Add(this.ProxyTypeLabel, 0, 0);\n            this.tableLayoutPanel4.Controls.Add(this.ProxyTypeComboBox, 1, 0);\n            this.tableLayoutPanel4.Controls.Add(this.ProxyTimeoutTextBox, 3, 0);\n            this.tableLayoutPanel4.Controls.Add(this.ProxyTimeoutLabel, 2, 0);\n            this.tableLayoutPanel4.Location = new System.Drawing.Point(3, 25);\n            this.tableLayoutPanel4.Name = "tableLayoutPanel4";\n            this.tableLayoutPanel4.RowCount = 1;\n            this.tableLayoutPanel4.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.ProxyTypeLabel.AutoSize = true;\n            this.ProxyTypeLabel.Location = new System.Drawing.Point(3, 9);\n            this.ProxyTypeLabel.Name = "ProxyTypeLabel";\n            this.ProxyTypeLabel.Size = new System.Drawing.Size(65, 12);\n            this.ProxyTypeLabel.TabIndex = 1;\n            this.ProxyTypeLabel.Text = "Proxy Type";\n            // \n            // ProxyTypeComboBox\n            // \n            this.ProxyTypeComboBox.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));\n            this.ProxyTypeComboBox.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;\n            this.ProxyTypeComboBox.FormattingEnabled = true;\n            this.ProxyTypeComboBox.Items.AddRange(new object[] {
            this.ProxyTypeComboBox.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;\n            this.ProxyTypeComboBox.FormattingEnabled = true;\n            this.ProxyTypeComboBox.Items.AddRange(new object[] {\n            "SOCKS5",\n            "HTTP"});\n            this.ProxyTypeComboBox.Location = new System.Drawing.Point(74, 5);\n            this.ProxyTypeComboBox.Margin = new System.Windows.Forms.Padding(3, 5, 3, 5);\n            this.ProxyTypeComboBox.Name = "ProxyTypeComboBox";\n            this.ProxyTypeComboBox.Size = new System.Drawing.Size(121, 20);\n            this.ProxyTypeComboBox.TabIndex = 2;
        private System.Windows.Forms.TextBox ProxyPortTextBox;\n        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel3;\n        private System.Windows.Forms.Button MyCancelButton;\n        private System.Windows.Forms.Button OKButton;\n        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel4;\n        private System.Windows.Forms.Label ProxyTypeLabel;\n        private System.Windows.Forms.ComboBox ProxyTypeComboBox;\n        private System.Windows.Forms.TextBox ProxyTimeoutTextBox;\n        private System.Windows.Forms.Label ProxyTimeoutLabel;\n    }
            if (_config.availabilityStatistics)\n            {\n                availabilityStatistics.UpdateLatency(args.server, (int)args.latency.TotalMilliseconds);\n            }\n        }\n        public void UpdateInboundCounter(object sender, SSTransmitEventArgs args)\n        {\n            GetCurrentStrategy()?.UpdateLastRead(args.server);\n            Interlocked.Add(ref _inboundCounter, args.length);\n            if (_config.availabilityStatistics)
            if (_config.availabilityStatistics)\n            {\n                availabilityStatistics.UpdateInboundCounter(args.server, args.length);\n            }\n        }\n        public void UpdateOutboundCounter(object sender, SSTransmitEventArgs args)\n        {\n            GetCurrentStrategy()?.UpdateLastWrite(args.server);\n            Interlocked.Add(ref _outboundCounter, args.length);\n            if (_config.availabilityStatistics)
            if (_config.availabilityStatistics)\n            {\n                availabilityStatistics.UpdateOutboundCounter(args.server, args.length);\n            }\n        }\n        protected void Reload()\n        {\n            Encryption.RNG.Reload();\n            // some logic in configuration updated the config when saving, we need to read it again\n            _config = Configuration.Load();
            }\n        }\n        protected void Reload()\n        {\n            Encryption.RNG.Reload();\n            // some logic in configuration updated the config when saving, we need to read it again\n            _config = Configuration.Load();\n            NLogConfig.LoadConfiguration();\n            StatisticsConfiguration = StatisticsStrategyConfiguration.Load();\n            privoxyRunner = privoxyRunner ?? new PrivoxyRunner();
using System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Timers;\nusing NLog;\nusing Shadowsocks.Controller.Strategy;\nusing Shadowsocks.Encryption;\nusing Shadowsocks.Encryption.AEAD;\nusing Shadowsocks.Encryption.Exception;
    {\n        public event EventHandler<SSTCPConnectedEventArgs> OnConnected;\n        public event EventHandler<SSTransmitEventArgs> OnInbound;\n        public event EventHandler<SSTransmitEventArgs> OnOutbound;\n        public event EventHandler<SSRelayEventArgs> OnFailed;\n        private static readonly Logger logger = LogManager.GetCurrentClassLogger();\n        private readonly ShadowsocksController _controller;\n        private DateTime _lastSweepTime;
        private DateTime _lastSweepTime;\n        private readonly Configuration _config;\n        public ISet<TCPHandler> Handlers { get; set; }\n        public TCPRelay(ShadowsocksController controller, Configuration conf)\n        {\n            _controller = controller;\n            _config = conf;\n            Handlers = new HashSet<TCPHandler>();\n            _lastSweepTime = DateTime.Now;\n        }
        public ISet<TCPHandler> Handlers { get; set; }\n        public TCPRelay(ShadowsocksController controller, Configuration conf)\n        {\n            _controller = controller;\n            _config = conf;\n            Handlers = new HashSet<TCPHandler>();\n            _lastSweepTime = DateTime.Now;\n        }\n        public override bool Handle(byte[] firstPacket, int length, Socket socket, object state)\n        {
            IList<TCPHandler> handlersToClose = new List<TCPHandler>();\n            lock (Handlers)\n            {\n                Handlers.Add(handler);\n                DateTime now = DateTime.Now;\n                if (now - _lastSweepTime > TimeSpan.FromSeconds(1))\n                {\n                    _lastSweepTime = now;\n                    foreach (TCPHandler handler1 in Handlers)\n                    {
        }\n    }\n    internal class TCPHandler\n    {\n        public event EventHandler<SSTCPConnectedEventArgs> OnConnected;\n        public event EventHandler<SSTransmitEventArgs> OnInbound;\n        public event EventHandler<SSTransmitEventArgs> OnOutbound;\n        public event EventHandler<SSRelayEventArgs> OnClosed;\n        public event EventHandler<SSRelayEventArgs> OnFailed;\n        private class AsyncSession
        {\n            public IProxy Remote { get; }\n            public AsyncSession(IProxy remote)\n            {\n                Remote = remote;\n            }\n        }\n        private class AsyncSession<T> : AsyncSession\n        {\n            public T State { get; set; }
        {\n            public T State { get; set; }\n            public AsyncSession(IProxy remote, T state) : base(remote)\n            {\n                State = state;\n            }\n            public AsyncSession(AsyncSession session, T state) : base(session.Remote)\n            {\n                State = state;\n            }
        private readonly int _serverTimeout;\n        private readonly int _proxyTimeout;\n        // each recv size.\n        public const int RecvSize = 2048;\n        // overhead of one chunk, reserved for AEAD ciphers\n        public const int ChunkOverheadSize = 16 * 2 /* two tags */ + AEADEncryptor.CHUNK_LEN_BYTES;\n        // max chunk size\n        public const uint MaxChunkSize = AEADEncryptor.CHUNK_LEN_MASK + AEADEncryptor.CHUNK_LEN_BYTES + 16 * 2;\n        // In general, the ciphertext length, we should take overhead into account\n        public const int BufferSize = RecvSize + (int)MaxChunkSize + 32 /* max salt len */;\n        private readonly ShadowsocksController _controller;\n        private readonly ProxyConfig _config;\n        private readonly Socket _connection;
        private IEncryptor _encryptor;\n        private Server _server;\n        private AsyncSession _currentRemoteSession;\n        private bool _proxyConnected;\n        private bool _destConnected;\n        private byte _command;\n        private byte[] _firstPacket;\n        private int _firstPacketLength;\n        private const int CMD_CONNECT = 0x01;\n        private const int CMD_BIND = 0x02;
        // client -> local proxy (plaintext, before encrypt)\n        private readonly byte[] _connetionRecvBuffer = new byte[BufferSize];\n        // local proxy -> remote (plaintext, after decrypt)\n        private readonly byte[] _remoteSendBuffer = new byte[BufferSize];\n        // local proxy -> client (ciphertext, before decrypt)\n        private readonly byte[] _connetionSendBuffer = new byte[BufferSize];\n        private bool _connectionShutdown = false;\n        private bool _remoteShutdown = false;\n        private bool _closed = false;\n        // instance-based lock without static\n        private readonly object _encryptionLock = new object();\n        private readonly object _decryptionLock = new object();\n        private readonly object _closeConnLock = new object();
        // local proxy -> remote (plaintext, after decrypt)\n        private readonly byte[] _remoteSendBuffer = new byte[BufferSize];\n        // local proxy -> client (ciphertext, before decrypt)\n        private readonly byte[] _connetionSendBuffer = new byte[BufferSize];\n        private bool _connectionShutdown = false;\n        private bool _remoteShutdown = false;\n        private bool _closed = false;\n        // instance-based lock without static\n        private readonly object _encryptionLock = new object();\n        private readonly object _decryptionLock = new object();\n        private readonly object _closeConnLock = new object();\n        private DateTime _startConnectTime;
        // local proxy -> client (ciphertext, before decrypt)\n        private readonly byte[] _connetionSendBuffer = new byte[BufferSize];\n        private bool _connectionShutdown = false;\n        private bool _remoteShutdown = false;\n        private bool _closed = false;\n        // instance-based lock without static\n        private readonly object _encryptionLock = new object();\n        private readonly object _decryptionLock = new object();\n        private readonly object _closeConnLock = new object();\n        private DateTime _startConnectTime;\n        private DateTime _startReceivingTime;
        private bool _connectionShutdown = false;\n        private bool _remoteShutdown = false;\n        private bool _closed = false;\n        // instance-based lock without static\n        private readonly object _encryptionLock = new object();\n        private readonly object _decryptionLock = new object();\n        private readonly object _closeConnLock = new object();\n        private DateTime _startConnectTime;\n        private DateTime _startReceivingTime;\n        private DateTime _startSendingTime;
        {\n            _controller = controller;\n            _config = config.proxy;\n            _connection = socket;\n            _proxyTimeout = config.proxy.proxyTimeout * 1000;\n            _serverTimeout = config.GetCurrentServer().timeout * 1000;\n            lastActivity = DateTime.Now;\n        }
            _connection = socket;\n            _proxyTimeout = config.proxy.proxyTimeout * 1000;\n            _serverTimeout = config.GetCurrentServer().timeout * 1000;\n            lastActivity = DateTime.Now;\n        }\n        public void CreateRemote()\n        {\n            Server server = _controller.GetAServer(IStrategyCallerType.TCP, (IPEndPoint)_connection.RemoteEndPoint,\n                _destEndPoint);\n            if (server == null || server.server == "")
            /* prepare address buffer length for AEAD */\n            Logger.Trace($"_addrBufLength={_addrBufLength}");\n            _encryptor.AddrBufLength = _addrBufLength;\n        }\n        public void Start(byte[] firstPacket, int length)\n        {\n            _firstPacket = firstPacket;\n            _firstPacketLength = length;\n            HandshakeReceive();\n        }
                _closed = true;\n            }\n            OnClosed?.Invoke(this, new SSRelayEventArgs(_server));\n            try\n            {\n                _connection.Shutdown(SocketShutdown.Both);
            try\n            {\n                _connection.Shutdown(SocketShutdown.Both);\n                _connection.Close();\n            }\n            catch (Exception e)\n            {\n                Logger.LogUsefulException(e);\n            }\n            if (_currentRemoteSession != null)
            }\n        }\n        private void HandshakeSendCallback(IAsyncResult ar)\n        {\n            if (_closed)\n            {\n                return;\n            }\n            try
            try\n            {\n                _connection.EndSend(ar);\n                // +-----+-----+-------+------+----------+----------+\n                // | VER | CMD |  RSV  | ATYP | DST.ADDR | DST.PORT |\n                // +-----+-----+-------+------+----------+----------+\n                // |  1  |  1  | X'00' |  1   | Variable |    2     |\n                // +-----+-----+-------+------+----------+----------+\n                // Skip first 3 bytes, and read 2 more bytes to analysis the address.\n                // 2 more bytes is designed if address is domain then we don't need to read once more to get the addr length.\n                    AddressReceiveCallback, null);\n            }\n            catch (Exception e)\n            {\n                ErrorClose(e);\n            }
            try\n            {\n                int bytesRead = _connection.EndReceive(ar);\n                if (bytesRead >= 5)\n                {\n                    _command = _connetionRecvBuffer[1];
        {\n            try\n            {\n                _connection.EndSend(ar);\n                ReadAddress(StartConnect);\n            }\n            catch (Exception e)\n            {\n                ErrorClose(e);
            }\n        }\n        private void ReadAddress(Action onSuccess)\n        {\n            int atyp = _connetionRecvBuffer[3];\n            switch (atyp)\n            {\n                case ATYP_IPv4: // IPv4 address, 4 bytes\n                    ReadAddress(4 + ADDR_PORT_LEN - 1, onSuccess);\n                    break;
            try\n            {\n                int bytesRead = _connection.EndReceive(ar);\n                object[] states = (object[])ar.AsyncState;\n                int bytesRemain = (int)states[0];\n                Action onSuccess = (Action)states[1];\n                if (bytesRead >= bytesRemain)\n                {\n                    _firstPacketLength = bytesRead + 2;\n                    int atyp = _connetionRecvBuffer[0];
                int bytesRemain = (int)states[0];\n                Action onSuccess = (Action)states[1];\n                if (bytesRead >= bytesRemain)\n                {\n                    _firstPacketLength = bytesRead + 2;\n                    int atyp = _connetionRecvBuffer[0];\n                    string dstAddr = "Unknown";\n                    int dstPort = -1;\n                    switch (atyp)\n                    {
                if (bytesRead >= bytesRemain)\n                {\n                    _firstPacketLength = bytesRead + 2;\n                    int atyp = _connetionRecvBuffer[0];\n                    string dstAddr = "Unknown";\n                    int dstPort = -1;\n                    switch (atyp)\n                    {\n                        case ATYP_IPv4: // IPv4 address, 4 bytes\n                            dstAddr = new IPAddress(_connetionRecvBuffer.Skip(1).Take(4).ToArray()).ToString();
            }\n        }\n        // inner class\n        private class ProxyTimer : Timer\n        {\n            public AsyncSession Session;\n            public EndPoint DestEndPoint;\n            public Server Server;\n            public ProxyTimer(int p) : base(p)\n            {
                }\n                else\n                {\n                    remote = new DirectConnect();\n                }\n                AsyncSession session = new AsyncSession(remote);\n                lock (_closeConnLock)\n                {\n                    if (_closed)\n                    {
                lock (_closeConnLock)\n                {\n                    if (_closed)\n                    {\n                        remote.Close();\n                        return;\n                    }\n                    _currentRemoteSession = session;\n                }\n                ProxyTimer proxyTimer = new ProxyTimer(_proxyTimeout) { AutoReset = false };
            }\n        }\n        private void ProxyConnectTimer_Elapsed(object sender, ElapsedEventArgs e)\n        {\n            ProxyTimer timer = (ProxyTimer)sender;\n            timer.Elapsed -= ProxyConnectTimer_Elapsed;\n            timer.Enabled = false;\n            timer.Dispose();\n            if (_proxyConnected || _destConnected || _closed)\n            {
            timer.Elapsed -= ProxyConnectTimer_Elapsed;\n            timer.Enabled = false;\n            timer.Dispose();\n            if (_proxyConnected || _destConnected || _closed)\n            {\n                return;\n            }\n            IProxy proxy = timer.Session.Remote;\n            Logger.Info($"Proxy {proxy.ProxyEndPoint} timed out");\n            proxy.Close();
            Logger.Info($"Proxy {proxy.ProxyEndPoint} timed out");\n            proxy.Close();\n            Close();\n        }\n        private void ProxyConnectCallback(IAsyncResult ar)\n        {\n            if (_closed)\n            {\n                return;\n            }
                ProxyTimer timer = session.State;\n                EndPoint destEndPoint = timer.DestEndPoint;\n                Server server = timer.Server;\n                timer.Elapsed -= ProxyConnectTimer_Elapsed;\n                timer.Enabled = false;\n                timer.Dispose();\n                IProxy remote = session.Remote;\n                // Complete the connection.\n                remote.EndConnectProxy(ar);\n                _proxyConnected = true;
                timer.Elapsed -= ProxyConnectTimer_Elapsed;\n                timer.Enabled = false;\n                timer.Dispose();\n                IProxy remote = session.Remote;\n                // Complete the connection.\n                remote.EndConnectProxy(ar);\n                _proxyConnected = true;\n                if (!(remote is DirectConnect))\n                {\n                    Logger.Debug($"Socket connected to proxy {remote.ProxyEndPoint}");
                // Complete the connection.\n                remote.EndConnectProxy(ar);\n                _proxyConnected = true;\n                if (!(remote is DirectConnect))\n                {\n                    Logger.Debug($"Socket connected to proxy {remote.ProxyEndPoint}");\n                }\n                _startConnectTime = DateTime.Now;\n                ServerTimer connectTimer = new ServerTimer(_serverTimeout) { AutoReset = false };\n                connectTimer.Elapsed += DestConnectTimer_Elapsed;
                }\n                // Connect to the remote endpoint.\n                remote.BeginConnectDest(destEndPoint, ConnectCallback,\n                    new AsyncSession<ServerTimer>(session, connectTimer), auth);\n            }\n            catch (ArgumentException)\n            {\n            }\n            catch (Exception e)\n            {\n                ErrorClose(e);
            }\n        }\n        private void DestConnectTimer_Elapsed(object sender, ElapsedEventArgs e)\n        {\n            ServerTimer timer = (ServerTimer)sender;\n            timer.Elapsed -= DestConnectTimer_Elapsed;\n            timer.Enabled = false;\n            timer.Dispose();\n            if (_destConnected || _closed)\n            {
            timer.Elapsed -= DestConnectTimer_Elapsed;\n            timer.Enabled = false;\n            timer.Dispose();\n            if (_destConnected || _closed)\n            {\n                return;\n            }\n            AsyncSession session = timer.Session;\n            Server server = timer.Server;\n            OnFailed?.Invoke(this, new SSRelayEventArgs(_server));
            Server server = timer.Server;\n            OnFailed?.Invoke(this, new SSRelayEventArgs(_server));\n            Logger.Info($"{server.FriendlyName()} timed out");\n            session.Remote.Close();\n            Close();\n        }\n        private void ConnectCallback(IAsyncResult ar)\n        {
            Logger.Info($"{server.FriendlyName()} timed out");\n            session.Remote.Close();\n            Close();\n        }\n        private void ConnectCallback(IAsyncResult ar)\n        {\n            if (_closed)\n            {\n                return;\n            }
                ServerTimer timer = session.State;\n                _server = timer.Server;\n                timer.Elapsed -= DestConnectTimer_Elapsed;\n                timer.Enabled = false;\n                timer.Dispose();\n                IProxy remote = session.Remote;\n                // Complete the connection.\n                remote.EndConnectDest(ar);\n                _destConnected = true;\n                Logger.Debug($"Socket connected to ss server: {_server.FriendlyName()}");\n                TimeSpan latency = DateTime.Now - _startConnectTime;
                // Complete the connection.\n                remote.EndConnectDest(ar);\n                _destConnected = true;\n                Logger.Debug($"Socket connected to ss server: {_server.FriendlyName()}");\n                TimeSpan latency = DateTime.Now - _startConnectTime;\n                OnConnected?.Invoke(this, new SSTCPConnectedEventArgs(_server, latency));\n                StartPipe(session);
                StartPipe(session);\n            }\n            catch (ArgumentException)\n            {\n            }\n            catch (Exception e)\n            {\n                if (_server != null)\n                {\n                    OnFailed?.Invoke(this, new SSRelayEventArgs(_server));
            }\n        }\n        private void TryReadAvailableData()\n        {\n            int available = Math.Min(_connection.Available, RecvSize - _firstPacketLength);\n            if (available > 0)\n            {\n                int size = _connection.Receive(_connetionRecvBuffer, _firstPacketLength, available,\n                    SocketFlags.None);\n                _firstPacketLength += size;
                    SocketFlags.None);\n                _firstPacketLength += size;\n            }\n        }\n        private void StartPipe(AsyncSession session)\n        {\n            if (_closed)\n            {\n                return;\n            }
            try\n            {\n                _startReceivingTime = DateTime.Now;\n                session.Remote.BeginReceive(_remoteRecvBuffer, 0, RecvSize, SocketFlags.None,\n                    PipeRemoteReceiveCallback, session);\n                TryReadAvailableData();\n                Logger.Trace($"_firstPacketLength = {_firstPacketLength}");\n                SendToServer(_firstPacketLength, session);\n            }\n            catch (Exception e)
            }\n        }\n        private void PipeRemoteReceiveCallback(IAsyncResult ar)\n        {\n            if (_closed)\n            {\n                return;\n            }\n            try\n            {
                int bytesRead = session.Remote.EndReceive(ar);\n                _totalRead += bytesRead;\n                OnInbound?.Invoke(this, new SSTransmitEventArgs(_server, bytesRead));\n                if (bytesRead > 0)\n                {\n                    lastActivity = DateTime.Now;\n                    int bytesToSend = -1;\n                    lock (_decryptionLock)\n                    {\n                        try
                if (bytesRead > 0)\n                {\n                    lastActivity = DateTime.Now;\n                    int bytesToSend = -1;\n                    lock (_decryptionLock)\n                    {\n                        try\n                        {\n                            _encryptor.Decrypt(_remoteRecvBuffer, bytesRead, _remoteSendBuffer, out bytesToSend);\n                        }
            }\n        }\n        private void PipeConnectionReceiveCallback(IAsyncResult ar)\n        {\n            if (_closed)\n            {\n                return;\n            }\n            try
            try\n            {\n                int bytesRead = _connection.EndReceive(ar);\n                AsyncSession session = (AsyncSession)ar.AsyncState;\n                IProxy remote = session.Remote;\n                if (bytesRead > 0)\n                {\n                    SendToServer(bytesRead, session);\n                }\n                else
                if (bytesRead > 0)\n                {\n                    SendToServer(bytesRead, session);\n                }\n                else\n                {\n                    remote.Shutdown(SocketShutdown.Send);\n                    _remoteShutdown = true;\n                    CheckClose();\n                }
            _startSendingTime = DateTime.Now;\n            session.Remote.BeginSend(_connetionSendBuffer, 0, bytesToSend, SocketFlags.None,\n                PipeRemoteSendCallback, new object[] { session, bytesToSend });\n        }\n        private void PipeRemoteSendCallback(IAsyncResult ar)\n        {\n            if (_closed)\n            {
        }\n        private void PipeRemoteSendCallback(IAsyncResult ar)\n        {\n            if (_closed)\n            {\n                return;\n            }\n            try\n            {\n                object[] container = (object[])ar.AsyncState;
                int bytesSent = session.Remote.EndSend(ar);\n                if (bytesSent > 0)\n                {\n                    lastActivity = DateTime.Now;\n                }\n                int bytesRemaining = bytesShouldSend - bytesSent;\n                if (bytesRemaining > 0)\n                {\n                    Logger.Info("reconstruct _connetionSendBuffer to re-send");\n                    Buffer.BlockCopy(_connetionSendBuffer, bytesSent, _connetionSendBuffer, 0, bytesRemaining);
            }\n        }\n        // In general, we assume there is no delay between local proxy and client, add this for sanity\n        private void PipeConnectionSendCallback(IAsyncResult ar)\n        {\n            try\n            {\n                object[] container = (object[])ar.AsyncState;\n                AsyncSession session = (AsyncSession)container[0];\n                int bytesShouldSend = (int)container[1];\n                int bytesSent = _connection.EndSend(ar);
                if (bytesRemaining > 0)\n                {\n                    Logger.Info("reconstruct _remoteSendBuffer to re-send");\n                    Buffer.BlockCopy(_remoteSendBuffer, bytesSent, _remoteSendBuffer, 0, bytesRemaining);\n                    _connection.BeginSend(_remoteSendBuffer, 0, bytesRemaining, SocketFlags.None,\n                        PipeConnectionSendCallback, new object[] { session, bytesRemaining });\n                    return;\n                }\n                session.Remote.BeginReceive(_remoteRecvBuffer, 0, RecvSize, SocketFlags.None,\n                    PipeRemoteReceiveCallback, session);
            "rc4-md5",\n            "salsa20",\n            "chacha20",\n            "aes-256-cfb",\n            "aes-192-cfb",\n            "aes-128-cfb"});

        private void RunSinglePolarSSLEncryptionThread()\n        {\n            try\n            {\n                for (int i = 0; i < 100; i++)\n                {\n                    IEncryptor encryptor;\n                    IEncryptor decryptor;\n                    encryptor = new PolarSSLEncryptor("aes-256-cfb", "barfoo!");\n                    decryptor = new PolarSSLEncryptor("aes-256-cfb", "barfoo!");
            }\n            catch\n            {\n                encryptionFailed = true;\n                throw;\n            }\n        }\n        [TestMethod]\n        public void TestSodiumEncryption()\n        {
            this.MyCancelButton = new System.Windows.Forms.Button();\n            this.OKButton = new System.Windows.Forms.Button();\n            this.UseProxyCheckBox = new System.Windows.Forms.CheckBox();\n            this.ProxyAddrLabel = new System.Windows.Forms.Label();\n            this.ProxyServerTextBox = new System.Windows.Forms.TextBox();\n            this.ProxyPortLabel = new System.Windows.Forms.Label();\n            this.ProxyPortTextBox = new System.Windows.Forms.TextBox();\n            this.ProxyTypeLabel = new System.Windows.Forms.Label();
            this.ProxyAddrLabel = new System.Windows.Forms.Label();\n            this.ProxyServerTextBox = new System.Windows.Forms.TextBox();\n            this.ProxyPortLabel = new System.Windows.Forms.Label();\n            this.ProxyPortTextBox = new System.Windows.Forms.TextBox();\n            this.ProxyTypeLabel = new System.Windows.Forms.Label();\n            this.ProxyTypeComboBox = new System.Windows.Forms.ComboBox();\n            this.ProxyTimeoutTextBox = new System.Windows.Forms.TextBox();\n            this.ProxyTimeoutLabel = new System.Windows.Forms.Label();\n            this.tableLayoutPanel1 = new System.Windows.Forms.TableLayoutPanel();
            this.ProxyTypeLabel = new System.Windows.Forms.Label();\n            this.ProxyTypeComboBox = new System.Windows.Forms.ComboBox();\n            this.ProxyTimeoutTextBox = new System.Windows.Forms.TextBox();\n            this.ProxyTimeoutLabel = new System.Windows.Forms.Label();\n            this.tableLayoutPanel1 = new System.Windows.Forms.TableLayoutPanel();\n            this.ProxyNotificationLabel = new System.Windows.Forms.Label();\n            this.flowLayoutPanel1 = new System.Windows.Forms.FlowLayoutPanel();\n            this.tableLayoutPanel1.SuspendLayout();\n            this.flowLayoutPanel1.SuspendLayout();
            this.SuspendLayout();\n            // 
            this.MyCancelButton.Location = new System.Drawing.Point(84, 3);\n            this.MyCancelButton.Margin = new System.Windows.Forms.Padding(3, 3, 0, 0);\n            this.MyCancelButton.Name = "MyCancelButton";\n            this.MyCancelButton.Size = new System.Drawing.Size(75, 23);\n            this.MyCancelButton.TabIndex = 13;\n            this.MyCancelButton.Text = "Cancel";\n            this.MyCancelButton.UseVisualStyleBackColor = true;\n            this.MyCancelButton.Click += new System.EventHandler(this.CancelButton_Click);\n            // \n            // OKButton
            this.OKButton.Location = new System.Drawing.Point(3, 3);\n            this.OKButton.Margin = new System.Windows.Forms.Padding(3, 3, 3, 0);\n            this.OKButton.Name = "OKButton";\n            this.OKButton.Size = new System.Drawing.Size(75, 23);\n            this.OKButton.TabIndex = 12;\n            this.OKButton.Text = "OK";\n            this.OKButton.UseVisualStyleBackColor = true;\n            this.OKButton.Click += new System.EventHandler(this.OKButton_Click);\n            // \n            // UseProxyCheckBox\n            this.tableLayoutPanel1.SetColumnSpan(this.UseProxyCheckBox, 2);
            this.ResumeLayout(false);\n        }\n        #endregion\n        private System.Windows.Forms.CheckBox UseProxyCheckBox;\n        private System.Windows.Forms.Label ProxyAddrLabel;\n        private System.Windows.Forms.TextBox ProxyServerTextBox;\n        private System.Windows.Forms.Label ProxyPortLabel;\n        private System.Windows.Forms.TextBox ProxyPortTextBox;
        }\n        #endregion\n        private System.Windows.Forms.CheckBox UseProxyCheckBox;\n        private System.Windows.Forms.Label ProxyAddrLabel;\n        private System.Windows.Forms.TextBox ProxyServerTextBox;\n        private System.Windows.Forms.Label ProxyPortLabel;\n        private System.Windows.Forms.TextBox ProxyPortTextBox;\n        private System.Windows.Forms.Button MyCancelButton;
        private System.Windows.Forms.CheckBox UseProxyCheckBox;\n        private System.Windows.Forms.Label ProxyAddrLabel;\n        private System.Windows.Forms.TextBox ProxyServerTextBox;\n        private System.Windows.Forms.Label ProxyPortLabel;\n        private System.Windows.Forms.TextBox ProxyPortTextBox;\n        private System.Windows.Forms.Button MyCancelButton;\n        private System.Windows.Forms.Button OKButton;
        private System.Windows.Forms.Label ProxyAddrLabel;\n        private System.Windows.Forms.TextBox ProxyServerTextBox;\n        private System.Windows.Forms.Label ProxyPortLabel;\n        private System.Windows.Forms.TextBox ProxyPortTextBox;\n        private System.Windows.Forms.Button MyCancelButton;\n        private System.Windows.Forms.Button OKButton;\n        private System.Windows.Forms.Label ProxyTypeLabel;\n        private System.Windows.Forms.ComboBox ProxyTypeComboBox;
        private System.Windows.Forms.Button MyCancelButton;\n        private System.Windows.Forms.Button OKButton;\n        private System.Windows.Forms.Label ProxyTypeLabel;\n        private System.Windows.Forms.ComboBox ProxyTypeComboBox;\n        private System.Windows.Forms.TextBox ProxyTimeoutTextBox;\n        private System.Windows.Forms.Label ProxyTimeoutLabel;\n        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel1;\n        private System.Windows.Forms.Label ProxyNotificationLabel;\n        private System.Windows.Forms.FlowLayoutPanel flowLayoutPanel1;
        private System.Windows.Forms.Label ProxyTypeLabel;\n        private System.Windows.Forms.ComboBox ProxyTypeComboBox;\n        private System.Windows.Forms.TextBox ProxyTimeoutTextBox;\n        private System.Windows.Forms.Label ProxyTimeoutLabel;\n        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel1;\n        private System.Windows.Forms.Label ProxyNotificationLabel;\n        private System.Windows.Forms.FlowLayoutPanel flowLayoutPanel1;\n    }\n}
            this.aboutItem = new System.Windows.Forms.MenuItem();\n            this.menuItem3 = new System.Windows.Forms.MenuItem();\n            this.quitItem = new System.Windows.Forms.MenuItem();\n            this.panel3 = new System.Windows.Forms.Panel();\n            this.DeleteButton = new System.Windows.Forms.Button();\n            this.AddButton = new System.Windows.Forms.Button();\n            this.ServerGroupBox = new System.Windows.Forms.GroupBox();\n            this.ServersListBox = new System.Windows.Forms.ListBox();\n            this.QRCodeItem = new System.Windows.Forms.MenuItem();
            this.tableLayoutPanel1.SuspendLayout();\n            this.panel1.SuspendLayout();\n            this.panel3.SuspendLayout();\n            this.ServerGroupBox.SuspendLayout();\n            this.SuspendLayout();\n            // \n            // tableLayoutPanel1\n            // \n            this.tableLayoutPanel1.AutoSize = true;
            this.SuspendLayout();\n            // \n            // tableLayoutPanel1\n            // \n            this.tableLayoutPanel1.AutoSize = true;\n            this.tableLayoutPanel1.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;\n            this.tableLayoutPanel1.ColumnCount = 2;\n            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());\n            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());\n            this.tableLayoutPanel1.Controls.Add(this.RemarksTextBox, 1, 5);
            this.ClientSize = new System.Drawing.Size(489, 286);\n            this.Controls.Add(this.ServersListBox);\n            this.Controls.Add(this.ServerGroupBox);\n            this.Controls.Add(this.panel1);\n            this.Controls.Add(this.panel3);\n            this.Controls.Add(this.panel2);\n            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedSingle;\n            this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));\n            this.MaximizeBox = false;
            this.Controls.Add(this.ServersListBox);\n            this.Controls.Add(this.ServerGroupBox);\n            this.Controls.Add(this.panel1);\n            this.Controls.Add(this.panel3);\n            this.Controls.Add(this.panel2);\n            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedSingle;\n            this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));\n            this.MaximizeBox = false;\n            this.Name = "ConfigForm";\n            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
            this.FormClosed += new System.Windows.Forms.FormClosedEventHandler(this.ConfigForm_FormClosed);\n            this.Load += new System.EventHandler(this.ConfigForm_Load);\n            this.Shown += new System.EventHandler(this.ConfigForm_Shown);\n            this.tableLayoutPanel1.ResumeLayout(false);\n            this.tableLayoutPanel1.PerformLayout();\n            this.panel1.ResumeLayout(false);\n            this.panel3.ResumeLayout(false);\n            this.ServerGroupBox.ResumeLayout(false);\n            this.ServerGroupBox.PerformLayout();
            this.ResumeLayout(false);\n            this.PerformLayout();\n        }\n        #endregion\n        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel1;\n        private System.Windows.Forms.Label label1;\n        private System.Windows.Forms.Label label2;\n        private System.Windows.Forms.Label label3;\n        private System.Windows.Forms.Label label4;\n        private System.Windows.Forms.TextBox IPTextBox;
            }\n            else\n            {\n                isFirstRun = true;\n            }\n        }\n        private void ServersListBox_SelectedIndexChanged(object sender, EventArgs e)\n        {
            }\n        }\n        private void ServersListBox_SelectedIndexChanged(object sender, EventArgs e)\n        {
            }\n            switch ( hostType ) {\n                case UriHostNameType.IPv6:\n                    serverStr = $"[{server}]:{server_port}";\n                    break;\n                default:\n                    // IPv4 and domain name\n                    serverStr = $"{server}:{server_port}";\n                    break;
            }\n            return remarks.IsNullOrEmpty()\n                ? serverStr\n                : $"{remarks} ({serverStr})";\n        }\n        public Server()\n        {\n            server = "";\n            server_port = 8388;
        }\n        public Server()\n        {\n            server = "";\n            server_port = 8388;\n            method = "aes-256-cfb";\n            password = "";\n            remarks = "";\n            auth = false;\n        }
            this.Controls.Add(this.QRCodeWebBrowser);\n            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedSingle;\n            this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));\n            this.MaximizeBox = false;\n            this.Name = "QRCodeForm";\n            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;\n            this.Text = "QRCode";\n            this.Load += new System.EventHandler(this.QRCodeForm_Load);\n            ((System.ComponentModel.ISupportInitialize)(this.pictureBox1)).EndInit();\n            this.ResumeLayout(false);
            long maxSpeed = 0;\n            long lastInbound, lastOutbound;\n            lock (this)\n            {\n                if (traffic.Count == 0)\n                    return;\n                foreach (var trafficPerSecond in traffic)\n                {\n                    inboundPoints.Add(trafficPerSecond.Item1);\n                    outboundPoints.Add(trafficPerSecond.Item2);
            }\n            bandwidthScale = Utils.GetBandwidthScale(maxSpeed);\n            //rescale the original data points, since it is List<float>, .ForEach does not work\n            inboundPoints = inboundPoints.Select(p => p / bandwidthScale.Item3).ToList();\n            outboundPoints = outboundPoints.Select(p => p / bandwidthScale.Item3).ToList();\n            if (trafficChart.IsHandleCreated)\n            {\n                trafficChart.Series["Inbound"].Points.DataBindY(inboundPoints);\n                trafficChart.Series["Outbound"].Points.DataBindY(outboundPoints);\n                trafficChart.ChartAreas[0].AxisY.LabelStyle.Format = "{0:0.##} " + bandwidthScale.Item2;\n                trafficChart.ChartAreas[0].AxisY.Maximum = bandwidthScale.Item1;
            }\n        }\n        private void UpdateTexts()\n        {\n            FileMenuItem.Text = I18N.GetString("&File");\n            OpenLocationMenuItem.Text = I18N.GetString("&Open Location");\n            ExitMenuItem.Text = I18N.GetString("E&xit");\n            CleanLogsButton.Text = I18N.GetString("&Clean Logs");\n            ChangeFontButton.Text = I18N.GetString("Change &Font");\n            WrapTextCheckBox.Text = I18N.GetString("&Wrap Text");
            this.PluginTextBox.MaxLength = 256;\n            this.PluginTextBox.Name = "PluginTextBox";\n            this.PluginTextBox.Size = new System.Drawing.Size(235, 25);\n            this.PluginTextBox.TabIndex = 5;\n            this.PluginTextBox.WordWrap = false;\n            // \n            // RemarksTextBox\n            // \n            this.RemarksTextBox.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));\n            this.RemarksTextBox.Location = new System.Drawing.Point(151, 291);\n            this.RemarksTextBox.Margin = new System.Windows.Forms.Padding(4);\n            this.RemarksTextBox.MaxLength = 32;\n            this.RemarksTextBox.Name = "RemarksTextBox";
            this.RemarksTextBox.MaxLength = 32;\n            this.RemarksTextBox.Name = "RemarksTextBox";\n            this.RemarksTextBox.Size = new System.Drawing.Size(235, 25);\n            this.RemarksTextBox.TabIndex = 8;\n            this.RemarksTextBox.WordWrap = false;\n            // \n            // IPLabel\n            // \n            this.IPLabel.Anchor = System.Windows.Forms.AnchorStyles.Right;\n            this.IPLabel.AutoSize = true;
            this.IPTextBox.MaxLength = 512;\n            this.IPTextBox.Name = "IPTextBox";\n            this.IPTextBox.Size = new System.Drawing.Size(235, 25);\n            this.IPTextBox.TabIndex = 0;\n            this.IPTextBox.WordWrap = false;\n            // \n            // ServerPortTextBox\n            // \n            this.ServerPortTextBox.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));\n            this.ServerPortTextBox.Location = new System.Drawing.Point(151, 41);\n            this.ServerPortTextBox.Margin = new System.Windows.Forms.Padding(4);\n            this.ServerPortTextBox.MaxLength = 10;\n            this.ServerPortTextBox.Name = "ServerPortTextBox";
            this.ServerPortTextBox.MaxLength = 10;\n            this.ServerPortTextBox.Name = "ServerPortTextBox";\n            this.ServerPortTextBox.Size = new System.Drawing.Size(235, 25);\n            this.ServerPortTextBox.TabIndex = 1;\n            this.ServerPortTextBox.WordWrap = false;\n            // \n            // PasswordTextBox\n            // \n            this.PasswordTextBox.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));\n            this.PasswordTextBox.Margin = new System.Windows.Forms.Padding(4);\n            this.PasswordTextBox.MaxLength = 256;\n            this.PasswordTextBox.Name = "PasswordTextBox";
            this.PasswordTextBox.MaxLength = 256;\n            this.PasswordTextBox.Name = "PasswordTextBox";\n            this.PasswordTextBox.Size = new System.Drawing.Size(235, 25);\n            this.PasswordTextBox.TabIndex = 2;\n            this.PasswordTextBox.UseSystemPasswordChar = true;\n            this.PasswordTextBox.WordWrap = false;\n            // \n            // EncryptionLabel\n            // \n            this.EncryptionLabel.Anchor = System.Windows.Forms.AnchorStyles.Right;
            this.PluginOptionsTextBox.MaxLength = 256;\n            this.PluginOptionsTextBox.Name = "PluginOptionsTextBox";\n            this.PluginOptionsTextBox.Size = new System.Drawing.Size(235, 25);\n            this.PluginOptionsTextBox.TabIndex = 6;\n            this.PluginOptionsTextBox.WordWrap = false;\n            // \n            // ShowPasswdCheckBox\n            // \n            this.ShowPasswdCheckBox.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) \n            | System.Windows.Forms.AnchorStyles.Left)));\n            this.ShowPasswdCheckBox.Margin = new System.Windows.Forms.Padding(4);
            this.ShowPasswdCheckBox.Name = "ShowPasswdCheckBox";\n            this.ShowPasswdCheckBox.Size = new System.Drawing.Size(133, 19);\n            this.ShowPasswdCheckBox.TabIndex = 3;\n            this.ShowPasswdCheckBox.Text = "Show Password";\n            this.ShowPasswdCheckBox.TextAlign = System.Drawing.ContentAlignment.MiddleCenter;\n            this.ShowPasswdCheckBox.UseVisualStyleBackColor = true;\n            this.ShowPasswdCheckBox.CheckedChanged += new System.EventHandler(this.ShowPasswdCheckBox_CheckedChanged);\n            // \n            // PluginArgumentsTextBox\n            // \n            this.PluginArgumentsTextBox.Margin = new System.Windows.Forms.Padding(4);
            this.PluginArgumentsTextBox.MaxLength = 512;\n            this.PluginArgumentsTextBox.Name = "PluginArgumentsTextBox";\n            this.PluginArgumentsTextBox.Size = new System.Drawing.Size(235, 25);\n            this.PluginArgumentsTextBox.TabIndex = 7;\n            this.PluginArgumentsTextBox.WordWrap = false;\n            // \n            // PluginArgumentsLabel\n            // \n            this.PluginArgumentsLabel.Anchor = System.Windows.Forms.AnchorStyles.Right;\n            this.PluginArgumentsLabel.AutoSize = true;
            this.tableLayoutPanel5.RowCount = 2;\n            this.tableLayoutPanel5.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel5.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel5.Size = new System.Drawing.Size(251, 82);\n            this.tableLayoutPanel5.TabIndex = 9;\n            // \n            // ProxyPortTextBox\n            // \n            this.ProxyPortTextBox.Anchor = System.Windows.Forms.AnchorStyles.Left;\n            this.ProxyPortTextBox.Location = new System.Drawing.Point(103, 8);\n            this.ProxyPortTextBox.Margin = new System.Windows.Forms.Padding(4);\n            this.ProxyPortTextBox.MaxLength = 10;\n            this.ProxyPortTextBox.Name = "ProxyPortTextBox";
            this.ProxyPortTextBox.MaxLength = 10;\n            this.ProxyPortTextBox.Name = "ProxyPortTextBox";\n            this.ProxyPortTextBox.Size = new System.Drawing.Size(140, 25);\n            this.ProxyPortTextBox.TabIndex = 10;\n            this.ProxyPortTextBox.WordWrap = false;\n            // \n            // ProxyPortLabel\n            // \n            this.ProxyPortLabel.Anchor = System.Windows.Forms.AnchorStyles.Right;\n            this.ProxyPortLabel.AutoSize = true;
        private const string StatisticsFilesName = "shadowsocks.availability.json";\n        public static string AvailabilityStatisticsFile;\n        //static constructor to initialize every public static fields before refereced\n        static AvailabilityStatistics()\n        {\n            AvailabilityStatisticsFile = Utils.GetTempPath(StatisticsFilesName);\n        }\n        //arguments for ICMP tests\n        private int Repeat => Config.RepeatTimesNum;\n        public const int TimeoutMilliseconds = 500;
        }\n        //arguments for ICMP tests\n        private int Repeat => Config.RepeatTimesNum;\n        public const int TimeoutMilliseconds = 500;\n        //records cache for current server in {_monitorInterval} minutes\n        private List<int> _latencyRecords;\n        //speed in KiB/s\n        private long _lastInboundCounter;\n        private List<int> _inboundSpeedRecords;\n        private long _lastOutboundCounter;
            this.allMode.Location = new System.Drawing.Point(11, 61);\n            this.allMode.Margin = new System.Windows.Forms.Padding(5, 10, 5, 10);\n            this.allMode.Name = "allMode";\n            this.allMode.Size = new System.Drawing.Size(58, 31);\n            this.allMode.TabIndex = 1;\n            this.allMode.Text = "all";\n            this.allMode.UseVisualStyleBackColor = true;\n            this.allMode.CheckedChanged += new System.EventHandler(this.allMode_CheckedChanged);\n            // 
            this.allMode.Text = "all";\n            this.allMode.UseVisualStyleBackColor = true;\n            this.allMode.CheckedChanged += new System.EventHandler(this.allMode_CheckedChanged);\n            // \n            // dayMode\n            // \n            this.dayMode.AutoSize = true;\n            this.dayMode.Checked = true;\n            this.dayMode.Location = new System.Drawing.Point(11, 29);\n            this.dayMode.Margin = new System.Windows.Forms.Padding(5, 10, 5, 10);\n            this.dayMode.Name = "dayMode";\n            this.dayMode.Size = new System.Drawing.Size(73, 31);\n            this.dayMode.TabIndex = 0;
            this.splitContainer3.TabIndex = 6;\n            // \n            // label1\n            // \n            this.label1.AutoSize = true;\n            this.label1.Text = "Final Score =";\n            this.CalculatinTip.SetToolTip(this.label1, "(The server with the highest score would be choosen)");\n            // 
            // \n            // calculationContainer\n            // \n            this.calculationContainer.AutoScroll = true;\n            this.calculationContainer.Dock = System.Windows.Forms.DockStyle.Fill;\n            this.calculationContainer.Location = new System.Drawing.Point(0, 0);\n            this.calculationContainer.Margin = new System.Windows.Forms.Padding(5, 10, 5, 10);\n            this.calculationContainer.Name = "calculationContainer";
        {\n            _controller = controller;\n            _config = conf;\n            Handlers = new HashSet<TCPHandler>();\n            _lastSweepTime = DateTime.Now;\n        }\n        public bool Handle(byte[] firstPacket, int length, Socket socket, object state)\n        {\n            if (socket.ProtocolType != ProtocolType.Tcp\n                || (length < 2 || firstPacket[0] != 5))
            handler.connection = socket;\n            handler.controller = _controller;\n            handler.tcprelay = this;\n            handler.Start(firstPacket, length);\n            IList<TCPHandler> handlersToClose = new List<TCPHandler>();\n            lock (Handlers)\n            {\n                Handlers.Add(handler);\n                DateTime now = DateTime.Now;\n                if (now - _lastSweepTime > TimeSpan.FromSeconds(1))
        {\n            _tcprelay = tcprelay;\n            _config = config;\n        }\n        public void CreateRemote()\n        {\n            Server server = controller.GetAServer(IStrategyCallerType.TCP, (IPEndPoint)connection.RemoteEndPoint);\n            if (server == null || server.server == "")\n                throw new ArgumentException("No server configured");\n            encryptor = EncryptorFactory.GetEncryptor(server.method, server.password, server.auth, false);
                                Logging.Info( $"connect to {dst_addr}:{dst_port}" );\n                            }\n                            break;\n                        case 3:  // domain name, length + str\n                            int len = _connetionRecvBuffer[1];\n                            dst_addr = System.Text.Encoding.UTF8.GetString(_connetionRecvBuffer, 2, len);\n                            dst_port = (_connetionRecvBuffer[len + 2] << 8) + _connetionRecvBuffer[len + 3];\n                            if ( _config.isVerboseLogging ) {\n                                Logging.Info( $"connect to {dst_addr}:{dst_port}" );\n                            }
                                Logging.Info( $"connect to {dst_addr}:{dst_port}" );\n                            }\n                            break;\n                        case 4:  // IPv6 address, 16 bytes\n                            dst_addr = new IPAddress(_connetionRecvBuffer.Skip(1).Take(16).ToArray()).ToString();\n                            dst_port = (_connetionRecvBuffer[17] << 8) + _connetionRecvBuffer[18];\n                            if ( _config.isVerboseLogging ) {\n                                Logging.Info( $"connect to [{dst_addr}]:{dst_port}" );\n                            }\n                            break;
                                Logging.Info( $"connect to [{dst_addr}]:{dst_port}" );\n                            }\n                            break;\n                    }\n                    int bytesToSend;\n                    lock (_encryptionLock)\n                    {\n                        if (_closed) return;\n                        encryptor.Encrypt(_connetionRecvBuffer, bytesRead, _connetionSendBuffer, out bytesToSend);\n                    }
            Logging.LogUsefulException(e.GetException());\n        }\n        void controller_UpdatePACFromGFWListCompleted(object sender, EventArgs e)\n        {\n            ShowBalloonTip(I18N.GetString("Shadowsocks"), I18N.GetString("PAC updated"), ToolTipIcon.Info, 1000);
        }\n        void updateChecker_NewVersionFound(object sender, EventArgs e)\n        {\n            ShowBalloonTip(String.Format(I18N.GetString("Shadowsocks {0} Update Found"), updateChecker.LatestVersionNumber), I18N.GetString("Click here to download"), ToolTipIcon.Info, 5000);\n            _notifyIcon.BalloonTipClicked += notifyIcon1_BalloonTipClicked;\n            _isFirstRun = false;
            _notifyIcon.BalloonTipClicked += notifyIcon1_BalloonTipClicked;\n            _isFirstRun = false;\n        }\n        void notifyIcon1_BalloonTipClicked(object sender, EventArgs e)\n        {\n            System.Diagnostics.Process.Start(updateChecker.LatestVersionURL);\n            _notifyIcon.BalloonTipClicked -= notifyIcon1_BalloonTipClicked;\n        }\n        private void LoadCurrentConfiguration()
            _isFirstRun = false;\n        }\n        void notifyIcon1_BalloonTipClicked(object sender, EventArgs e)\n        {\n            System.Diagnostics.Process.Start(updateChecker.LatestVersionURL);\n            _notifyIcon.BalloonTipClicked -= notifyIcon1_BalloonTipClicked;\n        }\n        private void LoadCurrentConfiguration()\n        {\n            Configuration config = controller.GetConfiguration();
                {\n                    remote = new Socks5Proxy();\n                    proxyEP = SocketUtil.GetEndPoint(_config.proxy.proxyServer, _config.proxy.proxyPort);\n                }\n                else\n                {\n                    remote = new DirectConnect();\n                    proxyEP = null;\n                }\n                var session = new AsyncSession(remote);
                }\n                else\n                {\n                    remote = new DirectConnect();\n                    proxyEP = null;\n                }\n                var session = new AsyncSession(remote);\n                _currentRemoteSession = session;\n                ProxyTimer proxyTimer = new ProxyTimer(3000);\n                proxyTimer.AutoReset = false;
            SaveConfig(_config);\n        }\n        public void EnableProxy(string proxy, int port)\n        {\n            _config.proxy.useProxy = true;\n            _config.proxy.proxyServer = proxy;\n            _config.proxy.proxyPort = port;\n            SaveConfig(_config);\n        }\n        public void ToggleVerboseLogging(bool enabled)
            SaveConfig(_config);\n        }\n        public void ToggleVerboseLogging(bool enabled)\n        {\n            _config.isVerboseLogging = enabled;\n            SaveConfig(_config);\n            if ( VerboseLoggingStatusChanged != null ) {\n                VerboseLoggingStatusChanged(this, new EventArgs());\n            }\n        }
            DetailsParser = new Regex("^((?<method>.+?)(?<auth>-auth)??:(?<password>.*)@(?<hostname>.+?)" +\n                                      ":(?<port>\\d+?))$", RegexOptions.IgnoreCase);\n        private const int DefaultServerTimeoutSec = 5;\n        public const int MaxServerTimeoutSec = 20;\n        public string server;\n        public int server_port;\n        public string password;\n        public string method;\n        public string remarks;\n        public bool auth;
        private const int DefaultServerTimeoutSec = 5;\n        public const int MaxServerTimeoutSec = 20;\n        public string server;\n        public int server_port;\n        public string password;\n        public string method;\n        public string remarks;\n        public bool auth;\n        public int timeout;\n        public override int GetHashCode()
                }\n                catch (FormatException)\n                {\n                    MessageBox.Show(I18N.GetString("Illegal port number format"));\n                    ProxyPortTextBox.Clear();\n                    return;\n                }\n                try\n                {\n                    timeout = int.Parse(ProxyTimeoutTextBox.Text);
            controller.SaveProxyConfig(_modifiedConfiguration);\n            this.Close();\n        }\n        private void CancelButton_Click(object sender, EventArgs e)\n        {\n            this.Close();\n        }\n        private void ProxyForm_FormClosed(object sender, FormClosedEventArgs e)\n        {\n            controller.ConfigChanged -= controller_ConfigChanged;
                int localPort = int.Parse(ProxyPortTextBox.Text);\n                Configuration.CheckServer(server);\n                Configuration.CheckLocalPort(localPort);\n                _modifiedConfiguration.configs[_lastSelectedIndex] = server;\n                _modifiedConfiguration.localPort = localPort;\n                return true;
            }\n            catch (Exception ex)\n            {\n                MessageBox.Show(ex.Message);\n            }\n            return false;\n        }\n        private void LoadSelectedServer()\n        {\n            if (ServersListBox.SelectedIndex >= 0 && ServersListBox.SelectedIndex < _modifiedConfiguration.configs.Count)
            this.pictureBox1 = new System.Windows.Forms.PictureBox();\n            this.panel1 = new System.Windows.Forms.Panel();\n            ((System.ComponentModel.ISupportInitialize)(this.pictureBox1)).BeginInit();\n            this.panel1.SuspendLayout();\n            this.SuspendLayout();
            // \n            // pictureBox1\n            // \n            this.pictureBox1.Dock = System.Windows.Forms.DockStyle.Fill;\n            this.pictureBox1.Location = new System.Drawing.Point(10, 10);\n            this.pictureBox1.Margin = new System.Windows.Forms.Padding(0);\n            this.pictureBox1.Name = "pictureBox1";\n            this.pictureBox1.Size = new System.Drawing.Size(204, 202);\n            this.pictureBox1.SizeMode = System.Windows.Forms.PictureBoxSizeMode.StretchImage;\n            this.pictureBox1.TabIndex = 1;\n            this.pictureBox1.TabStop = false;\n            // 
            this.pictureBox1.Name = "pictureBox1";\n            this.pictureBox1.Size = new System.Drawing.Size(204, 202);\n            this.pictureBox1.SizeMode = System.Windows.Forms.PictureBoxSizeMode.StretchImage;\n            this.pictureBox1.TabIndex = 1;\n            this.pictureBox1.TabStop = false;\n            // \n            // panel1\n            // \n            this.panel1.Controls.Add(this.pictureBox1);\n            this.panel1.Dock = System.Windows.Forms.DockStyle.Fill;
            this.pictureBox1.TabIndex = 1;\n            this.pictureBox1.TabStop = false;\n            // \n            // panel1\n            // \n            this.panel1.Controls.Add(this.pictureBox1);\n            this.panel1.Dock = System.Windows.Forms.DockStyle.Fill;\n            this.panel1.Location = new System.Drawing.Point(0, 0);\n            this.panel1.Margin = new System.Windows.Forms.Padding(0);\n            this.panel1.Name = "panel1";
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedSingle;\n            this.MaximizeBox = false;\n            this.MinimizeBox = false;\n            this.Name = "QRCodeForm";\n            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;\n            this.Text = "QRCode";\n            this.Load += new System.EventHandler(this.QRCodeForm_Load);\n            ((System.ComponentModel.ISupportInitialize)(this.pictureBox1)).EndInit();\n            this.panel1.ResumeLayout(false);\n            this.ResumeLayout(false);
        private System.Windows.Forms.PictureBox pictureBox1;\n        private System.Windows.Forms.Panel panel1;\n    }\n}
        {\n            _controller = controller;\n            _config = config;\n            _connection = socket;\n            _proxyTimeout = config.proxy.proxyTimeout * 1000;\n            _serverTimeout = config.GetCurrentServer().timeout * 1000;\n            lastActivity = DateTime.Now;\n        }\n        public void CreateRemote()
            _connection = socket;\n            _proxyTimeout = config.proxy.proxyTimeout * 1000;\n            _serverTimeout = config.GetCurrentServer().timeout * 1000;\n            lastActivity = DateTime.Now;\n        }\n        public void CreateRemote()\n        {\n            Server server = _controller.GetAServer(IStrategyCallerType.TCP, (IPEndPoint)_connection.RemoteEndPoint,\n                _destEndPoint);\n            if (server == null || server.server == "")
        {\n            var dr = MessageBox.Show(I18N.GetString("Import from URL: {0} ?", ssURL), I18N.GetString("Shadowsocks"), MessageBoxButtons.YesNo);\n            if (dr == DialogResult.Yes)\n            {\n                if (AddServerBySSURL(ssURL))\n                {\n                    MessageBox.Show(I18N.GetString("Successfully imported from {0}", ssURL));\n                    return true;\n                }\n                else
        }\n        public bool AddServerBySSURL(string ssURL)\n        {\n            try\n            {\n                if (ssURL.IsNullOrEmpty() || ssURL.IsWhiteSpace())\n                    return false;\n                var servers = Server.GetServers(ssURL);\n                if (servers == null || servers.Count == 0)\n                    return false;
            }\n            else\n            {\n                GFWListUpdater.MergeAndWritePACFile(FileManager.NonExclusiveReadAllText(Utils.GetTempPath("gfwlist.txt")));\n            }
        }\n        public void CopyPacUrl()\n        {\n            Clipboard.SetDataObject(_pacServer.PacUrl);\n        }\n        #region Memory Management\n        private void StartReleasingMemory()\n        {\n            _ramThread = new Thread(new ThreadStart(ReleaseMemory));\n            _ramThread.IsBackground = true;
            }\n            catch (Exception ex)\n            {\n                Error?.Invoke(this, new ErrorEventArgs(ex));\n            }\n        }\n        public static bool MergeAndWritePACFile(string gfwListResult)\n        {\n            List<string> lines = new List<string>();\n            if (File.Exists(PACServer.USER_RULE_FILE))
        private int totalRead = 0;\n        private int totalWrite = 0;\n        // remote receive buffer\n        private byte[] remoteRecvBuffer = new byte[BufferSize];\n        // remote send buffer\n        private byte[] remoteSendBuffer = new byte[BufferSize];\n        // connection receive buffer\n        private byte[] connetionRecvBuffer = new byte[BufferSize];\n        // connection send buffer\n        private byte[] connetionSendBuffer = new byte[BufferSize];\n        // Received data string.\n        private bool connectionShutdown = false;\n        private bool remoteShutdown = false;
        // remote send buffer\n        private byte[] remoteSendBuffer = new byte[BufferSize];\n        // connection receive buffer\n        private byte[] connetionRecvBuffer = new byte[BufferSize];\n        // connection send buffer\n        private byte[] connetionSendBuffer = new byte[BufferSize];\n        // Received data string.\n        private bool connectionShutdown = false;\n        private bool remoteShutdown = false;\n        private bool closed = false;\n        private object encryptionLock = new object();\n        private object decryptionLock = new object();
        // connection send buffer\n        private byte[] connetionSendBuffer = new byte[BufferSize];\n        // Received data string.\n        private bool connectionShutdown = false;\n        private bool remoteShutdown = false;\n        private bool closed = false;\n        private object encryptionLock = new object();\n        private object decryptionLock = new object();\n        private DateTime _startConnectTime;\n        public void CreateRemote()
                {\n                    MessageBox.Show(I18N.GetString("Illegal port number format"));\n                    ServerPortTextBox.Focus();\n                    return false;\n                }\n                server.password = PasswordTextBox.Text;\n                server.method = EncryptionSelect.Text;\n                server.remarks = RemarksTextBox.Text;\n                if (!int.TryParse(TimeoutTextBox.Text, out server.timeout))
                    return false;\n                }\n                server.password = PasswordTextBox.Text;\n                server.method = EncryptionSelect.Text;\n                server.remarks = RemarksTextBox.Text;\n                if (!int.TryParse(TimeoutTextBox.Text, out server.timeout))
                {\n                    MessageBox.Show(I18N.GetString("Illegal timeout format"));\n                    TimeoutTextBox.Focus();\n                    return false;\n                }\n                server.auth = OneTimeAuth.Checked;\n                int localPort = int.Parse(ProxyPortTextBox.Text);\n                Configuration.CheckServer(server);\n                Configuration.CheckLocalPort(localPort);\n                _modifiedConfiguration.configs[_lastSelectedIndex] = server;
                    return false;\n                }\n                server.auth = OneTimeAuth.Checked;\n                int localPort = int.Parse(ProxyPortTextBox.Text);\n                Configuration.CheckServer(server);\n                Configuration.CheckLocalPort(localPort);\n                _modifiedConfiguration.configs[_lastSelectedIndex] = server;\n                _modifiedConfiguration.localPort = localPort;\n                return true;\n            }
                return false;\n            else\n            {\n                socket.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n                TCPHandler handler = new TCPHandler(this);\n                handler.connection = socket;\n                handler.controller = _controller;\n                handler.tcprelay = this;\n                handler.Start(firstPacket, length);\n                IList<TCPHandler> handlersToClose = new List<TCPHandler>();
        }\n        public void UpdateInboundCounter(Server server, long n)\n        {\n            _controller.UpdateInboundCounter(server, n);\n        }\n        public void UpdateOutboundCounter(Server server, long n)\n        {\n            _controller.UpdateOutboundCounter(server, n);\n        }\n        public void UpdateLatency(Server server, TimeSpan latency)
        }\n        public void CreateRemote()\n        {\n            Server server = controller.GetAServer(IStrategyCallerType.TCP, (IPEndPoint)connection.RemoteEndPoint);\n            if (server == null || server.server == "")\n                throw new ArgumentException("No server configured");\n            encryptor = EncryptorFactory.GetEncryptor(server.method, server.password, server.auth, false);\n            this.server = server;
                throw new ArgumentException("No server configured");\n            encryptor = EncryptorFactory.GetEncryptor(server.method, server.password, server.auth, false);\n            this.server = server;\n        }\n        public void Start(byte[] firstPacket, int length)\n        {\n            _firstPacket = firstPacket;\n            _firstPacketLength = length;\n            HandshakeReceive();
            encryptor = EncryptorFactory.GetEncryptor(server.method, server.password, server.auth, false);\n            this.server = server;\n        }\n        public void Start(byte[] firstPacket, int length)\n        {\n            _firstPacket = firstPacket;\n            _firstPacketLength = length;\n            HandshakeReceive();\n            lastActivity = DateTime.Now;\n        }
                    return;\n                else\n                    _closed = true;\n            }\n            try\n            {\n                connection?.Shutdown(SocketShutdown.Both);\n                connection?.Close();\n            }\n            catch (Exception e)
            }\n            lock (_encryptionLock)\n            {\n                lock (_decryptionLock)\n                {\n                    encryptor?.Dispose();
                }\n            }\n        }\n        private void HandshakeReceive()\n        {\n            if (_closed) return;
            try\n            {\n                int bytesRead = _firstPacketLength;\n                if (bytesRead > 1)\n                {\n                    byte[] response = { 5, 0 };\n                    if (_firstPacket[0] != 5)\n                    {\n                        // reject socks 4\n                        response = new byte[] { 0, 91 };
                    Close();\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void HandshakeSendCallback(IAsyncResult ar)
            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void HandshakeSendCallback(IAsyncResult ar)\n        {\n            if (_closed) return;
            try\n            {\n                connection.EndSend(ar);\n                // +-----+-----+-------+------+----------+----------+\n                // | VER | CMD |  RSV  | ATYP | DST.ADDR | DST.PORT |\n                // +-----+-----+-------+------+----------+----------+\n                // |  1  |  1  | X'00' |  1   | Variable |    2     |\n                // +-----+-----+-------+------+----------+----------+\n                // Skip first 3 bytes\n                // TODO validate
                        HandleUDPAssociate();\n                }\n                else\n                {\n                    Logging.Debug("failed to recv data in Shadowsocks.Controller.TCPHandler.handshakeReceive2Callback()");\n                    Close();\n                }\n            }\n            catch (Exception e)
                }\n                else\n                {\n                    Logging.Debug("failed to recv data in Shadowsocks.Controller.TCPHandler.handshakeReceive2Callback()");\n                    Close();\n                }\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);
            }\n            address.CopyTo(response, 4);\n            response[response.Length - 1] = (byte)(port & 0xFF);\n            response[response.Length - 2] = (byte)((port >> 8) & 0xFF);\n            connection.BeginSend(response, 0, response.Length, 0, new AsyncCallback(ReadAll), true);\n        }\n        private void ReadAll(IAsyncResult ar)\n        {\n            if (_closed) return;
            try\n            {\n                if (ar.AsyncState != null)\n                {\n                    connection.EndSend(ar);\n                    Logging.Debug(remote, RecvSize, "TCP Relay");\n                    connection.BeginReceive(_connetionRecvBuffer, 0, RecvSize, 0, new AsyncCallback(ReadAll), null);\n                }\n                else\n                {
                        Close();\n                }\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }
                }\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void ResponseCallback(IAsyncResult ar)\n        {
            Server server = ((ServerTimer)sender).Server;\n            IStrategy strategy = controller.GetCurrentStrategy();\n            strategy?.SetFailure(server);\n            Logging.Info($"{server.FriendlyName()} timed out");\n            remote.Close();\n            RetryConnect();
            Logging.Info($"{server.FriendlyName()} timed out");\n            remote.Close();\n            RetryConnect();\n        }\n        private void RetryConnect()\n        {\n            if (_retryCount < _maxRetry)\n            {\n                Logging.Debug($"Connection failed, retry ({_retryCount})");\n                StartConnect();
        }\n        private void ConnectCallback(IAsyncResult ar)\n        {\n            if (_closed) return;\n            try
            try\n            {\n                ServerTimer timer = (ServerTimer)ar.AsyncState;\n                Server server = timer.Server;\n                timer.Elapsed -= connectTimer_Elapsed;\n                timer.Enabled = false;\n                timer.Dispose();\n                // Complete the connection.\n                remote.EndConnect(ar);\n                _connected = true;
                timer.Elapsed -= connectTimer_Elapsed;\n                timer.Enabled = false;\n                timer.Dispose();\n                // Complete the connection.\n                remote.EndConnect(ar);\n                _connected = true;\n                var latency = DateTime.Now - _startConnectTime;\n                IStrategy strategy = controller.GetCurrentStrategy();\n                strategy?.UpdateLatency(server, latency);\n                _tcprelay.UpdateLatency(server, latency);
                }\n                Logging.LogUsefulException(e);\n                RetryConnect();\n            }\n        }\n        private void StartPipe()\n        {\n            if (_closed) return;
            try\n            {\n                _startReceivingTime = DateTime.Now;\n                remote.BeginReceive(_remoteRecvBuffer, 0, RecvSize, 0, new AsyncCallback(PipeRemoteReceiveCallback), null);\n                connection.BeginReceive(_connetionRecvBuffer, 0, RecvSize, 0, new AsyncCallback(PipeConnectionReceiveCallback), null);\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();
                        encryptor.Decrypt(_remoteRecvBuffer, bytesRead, _remoteSendBuffer, out bytesToSend);\n                    }\n                    connection.BeginSend(_remoteSendBuffer, 0, bytesToSend, 0, new AsyncCallback(PipeConnectionSendCallback), null);\n                    IStrategy strategy = controller.GetCurrentStrategy();\n                    strategy?.UpdateLastRead(server);\n                }
                }\n                else\n                {\n                    connection.Shutdown(SocketShutdown.Send);\n                    _connectionShutdown = true;\n                    CheckClose();

        }\n        public string Identifier()\n        {\n            return server + ':' + server_port;\n        }\n    }\n}
                }\n            } catch(FileNotFoundException) {\n            }\n            this.Text = I18N.GetString("Log Viewer") +\n                $" [in: {Utils.FormatBandwidth(controller.inboundCounter)}, out: {Utils.FormatBandwidth(controller.outboundCounter)}]";
            }\n            this.Text = I18N.GetString("Log Viewer") +\n                $" [in: {Utils.FormatBandwidth(controller.inboundCounter)}, out: {Utils.FormatBandwidth(controller.outboundCounter)}]";\n        }\n        private void LogForm_Load(object sender, EventArgs e)\n        {\n            InitContent();\n            timer = new Timer();\n            timer.Interval = 300;\n            timer.Tick += Timer_Tick;
                sw.AutoFlush = true;\n                Console.SetOut(sw);\n                Console.SetError(sw);\n                return true;\n            }\n            catch (IOException e)\n            {\n                Console.WriteLine(e.ToString());\n                return false;\n            }
        }\n        public static void Error(object o)\n        {\n            WriteToLogFile("[E] " + o);\n        }\n        public static void Info(object o)\n        {\n            WriteToLogFile(o);\n        }\n        public static void clear() {
            SaveConfig(_config);\n            if (EnableStatusChanged != null)\n            {\n                EnableStatusChanged(this, new EventArgs());\n            }\n        }\n        public void ToggleGlobal(bool global)\n        {\n            _config.global = global;
            SaveConfig(_config);\n            if (EnableGlobalChanged != null)\n            {\n                EnableGlobalChanged(this, new EventArgs());\n            }\n        }\n        public void ToggleShareOverLAN(bool enabled)\n        {\n            _config.shareOverLan = enabled;\n            SaveConfig(_config);
            SaveConfig(_config);\n            if (ConfigChanged != null)\n            {\n                ConfigChanged(this, new EventArgs());\n            }\n        }\n        public void UseOnlinePAC(bool useOnlinePac)\n        {\n            _config.useOnlinePac = useOnlinePac;
            SaveConfig(_config);\n            if (ConfigChanged != null)\n            {\n                ConfigChanged(this, new EventArgs());\n            }\n        }\n        public void ToggleCheckingUpdate(bool enabled)\n        {\n            _config.autoCheckUpdate = enabled;\n            Configuration.Save(_config);
using System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Text;\nusing System.Windows.Forms;\nusing Shadowsocks.Model;
using System.Net.Sockets;\nusing System.Text;\nusing System.Windows.Forms;\nusing Shadowsocks.Model;\nusing Shadowsocks.Properties;\nusing Shadowsocks.Util;\nusing Shadowsocks.Util.ProcessManagement;\nnamespace Shadowsocks.Controller\n{
using System.Text;\nusing System.Windows.Forms;\nusing Shadowsocks.Model;\nusing Shadowsocks.Properties;\nusing Shadowsocks.Util;\nusing Shadowsocks.Util.ProcessManagement;\nnamespace Shadowsocks.Controller\n{\n    class PrivoxyRunner\n    {
                privoxyConfig = privoxyConfig.Replace("__SOCKS_PORT__", configuration.localPort.ToString());\n                privoxyConfig = privoxyConfig.Replace("__PRIVOXY_BIND_PORT__", _runningPort.ToString());\n                privoxyConfig = privoxyConfig.Replace("__PRIVOXY_BIND_IP__", configuration.shareOverLan ? "0.0.0.0" : "127.0.0.1");\n                FileManager.ByteArrayToFile(Utils.GetTempPath(_uniqueConfigFile), Encoding.UTF8.GetBytes(privoxyConfig));\n                _process = new Process\n                {\n                    // Configure the process using the StartInfo properties.\n                    StartInfo =\n                    {\n                        FileName = "ss_privoxy.exe",
                _process.Start();\n                /*\n                 * Add this process to job obj associated with this ss process, so that\n                 * when ss exit unexpectedly, this process will be forced killed by system.\n                 */\n        }\n        public void Stop()\n        {
        }\n        public void Stop()\n        {\n            if (_process != null)\n            {\n                KillProcess(_process);\n                _process.Dispose();\n                _process = null;\n            }
        }\n        private static void KillProcess(Process p)\n        {\n            try\n            {\n                p.CloseMainWindow();\n                p.WaitForExit(100);\n                if (!p.HasExited)\n                {\n                    p.Kill();
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox1)).BeginInit();\n            this.SuspendLayout();\n            // \n            // pictureBox1\n            // \n            this.pictureBox1.Location = new System.Drawing.Point(9, 9);\n            this.pictureBox1.Margin = new System.Windows.Forms.Padding(0);\n            this.pictureBox1.Name = "pictureBox1";\n            this.pictureBox1.Size = new System.Drawing.Size(210, 210);\n            this.pictureBox1.SizeMode = System.Windows.Forms.PictureBoxSizeMode.Zoom;\n            this.pictureBox1.TabIndex = 1;
            this.SuspendLayout();\n            // \n            // pictureBox1\n            // \n            this.pictureBox1.Location = new System.Drawing.Point(9, 9);\n            this.pictureBox1.Margin = new System.Windows.Forms.Padding(0);\n            this.pictureBox1.Name = "pictureBox1";\n            this.pictureBox1.Size = new System.Drawing.Size(210, 210);\n            this.pictureBox1.SizeMode = System.Windows.Forms.PictureBoxSizeMode.Zoom;\n            this.pictureBox1.TabIndex = 1;\n            this.pictureBox1.TabStop = false;\n            // 
            this.pictureBox1.Margin = new System.Windows.Forms.Padding(0);\n            this.pictureBox1.Name = "pictureBox1";\n            this.pictureBox1.Size = new System.Drawing.Size(210, 210);\n            this.pictureBox1.SizeMode = System.Windows.Forms.PictureBoxSizeMode.Zoom;\n            this.pictureBox1.TabIndex = 1;\n            this.pictureBox1.TabStop = false;\n            // 
            this.pictureBox1.TabIndex = 1;\n            this.pictureBox1.TabStop = false;\n            // 
            // QRCodeForm\n            // \n            this.ClientSize = new System.Drawing.Size(338, 274);\n            this.Controls.Add(this.pictureBox1);\n            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedSingle;\n            this.MaximizeBox = false;\n            this.MinimizeBox = false;\n            this.Name = "QRCodeForm";\n            this.Padding = new System.Windows.Forms.Padding(9);\n            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;\n            this.Text = "QRCode";
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedSingle;\n            this.MaximizeBox = false;\n            this.MinimizeBox = false;\n            this.Name = "QRCodeForm";\n            this.Padding = new System.Windows.Forms.Padding(9);\n            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;\n            this.Text = "QRCode";\n            this.Load += new System.EventHandler(this.QRCodeForm_Load);\n            ((System.ComponentModel.ISupportInitialize)(this.pictureBox1)).EndInit();
            this.ResumeLayout(false);\n        }\n        #endregion\n        private System.Windows.Forms.PictureBox pictureBox1;\n    }\n}
    }\n}
        private readonly ConcurrentDictionary<string, List<int>> _inboundSpeedRecords = new ConcurrentDictionary<string, List<int>>();\n        private readonly ConcurrentDictionary<string, List<int>> _outboundSpeedRecords = new ConcurrentDictionary<string, List<int>>();\n        private readonly ConcurrentDictionary<string, InOutBoundRecord> _inOutBoundRecords = new ConcurrentDictionary<string, InOutBoundRecord>();\n        private class InOutBoundRecord\n        {\n            private long _inbound;\n            private long _lastInbound;\n            private long _outbound;
        private readonly ConcurrentDictionary<string, List<int>> _outboundSpeedRecords = new ConcurrentDictionary<string, List<int>>();\n        private readonly ConcurrentDictionary<string, InOutBoundRecord> _inOutBoundRecords = new ConcurrentDictionary<string, InOutBoundRecord>();\n        private class InOutBoundRecord\n        {\n            private long _inbound;\n            private long _lastInbound;\n            private long _outbound;\n            private long _lastOutbound;\n            private SpinLock _lock = new SpinLock();\n            public void UpdateInbound(long delta)
            {\n                var id = kv.Key;\n                var record = kv.Value;\n                long inboundDelta, outboundDelta;\n                record.GetDelta(out inboundDelta, out outboundDelta);\n                var inboundSpeed = GetSpeedInKiBPerSecond(inboundDelta, _monitorInterval.TotalSeconds);\n                var outboundSpeed = GetSpeedInKiBPerSecond(outboundDelta, _monitorInterval.TotalSeconds);\n                var inR = _inboundSpeedRecords.GetOrAdd(id, (k) => new List<int>());\n                var outR = _outboundSpeedRecords.GetOrAdd(id, (k) => new List<int>());\n                inR.Add(inboundSpeed);
                Logging.Debug(
        }\n        public void UpdateOutboundCounter(Server server, long n)\n        {\n            _inOutBoundRecords.AddOrUpdate(server.Identifier(), (k) =>\n            {\n                var r = new InOutBoundRecord();\n                r.UpdateOutbound(n);\n                return r;\n            }, (k, v) =>\n            {
        }\n        class UpdateRecordsState\n        {\n            public int counter;\n        }\n        class PingState\n        {\n            public UpdateRecordsState state;\n            public StatisticsRecord record;\n        }
                throw new ArgumentException(I18N.GetString("Password can not be blank"));\n        }\n        private static void CheckServer(string server)\n        {\n            if (server.IsNullOrEmpty())\n                throw new ArgumentException(I18N.GetString("Server IP can not be blank"));\n        }\n    }\n}
                throw new ArgumentException(I18N.GetString("Server IP can not be blank"));\n        }\n    }\n}
            {\n                return I18N.GetString("New server");\n            }\n            if (remarks.IsNullOrEmpty())\n            {\n                return server + ":" + server_port;\n            }\n            else\n            {\n                return remarks + " (" + server + ":" + server_port + ")";
            {\n                return server + ":" + server_port;\n            }\n            else\n            {\n                return remarks + " (" + server + ":" + server_port + ")";\n            }\n        }\n        public Server()\n        {
                {\n                    UpdateOnlinePACURLItem_Click(sender, e);\n                }\n                if (!controller.GetConfigurationCopy().pacUrl.IsNullOrEmpty())\n                {\n                    localPACItem.Checked = false;\n                    onlinePACItem.Checked = true;\n                    controller.UseOnlinePAC(true);\n                }\n                UpdatePACItemsEnabledStatus();
                {\n                    localPACItem.Checked = false;\n                    onlinePACItem.Checked = true;\n                    controller.UseOnlinePAC(true);\n                }\n                UpdatePACItemsEnabledStatus();\n            }\n        }\n        private void UpdateOnlinePACURLItem_Click(object sender, EventArgs e)\n        {
                if (i == 0)\n                {\n                    md5sum = MbedTLS.MD5(password);\n                }\n                else\n                {\n                    md5sum.CopyTo(result, 0);\n                    password.CopyTo(result, md5sum.Length);\n                    md5sum = MbedTLS.MD5(result);\n                }
                }\n                else\n                {\n                    md5sum.CopyTo(result, 0);\n                    password.CopyTo(result, md5sum.Length);\n                    md5sum = MbedTLS.MD5(result);\n                }\n                md5sum.CopyTo(key, i);\n                i += md5sum.Length;\n            }
                }\n                md5sum.CopyTo(key, i);\n                i += md5sum.Length;\n            }\n        }\n        protected static void randBytes(byte[] buf, int length)\n        {\n            byte[] temp = new byte[length];\n            RNGCryptoServiceProvider rngServiceProvider = new RNGCryptoServiceProvider();\n            rngServiceProvider.GetBytes(temp);
            this.ShareOverLANItem.Text = "Share over LAN";\n            this.ShareOverLANItem.Click += new System.EventHandler(this.ShareOverLANItem_Click);\n            // \n            // ServersItem\n            // \nthis.ServersItem.Index = 3;\n            this.ServersItem.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {\n            this.SeperatorItem,\n            this.ConfigItem});\n            this.ServersItem.Text = "&Servers";\n            // \n            // SeperatorItem\n            // 
            this.ServersItem.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {\n            this.SeperatorItem,\n            this.ConfigItem});\n            this.ServersItem.Text = "&Servers";\n            // \n            // SeperatorItem\n            // \n            this.SeperatorItem.Index = 0;\n            this.SeperatorItem.Text = "-";\n            // 
                            foreach (ResultPoint point in result.ResultPoints)\n                            {\n                                minX = Math.Min(minX, point.X);\n                                minY = Math.Min(minY, point.Y);\n                                maxX = Math.Max(maxX, point.X);\n                                maxY = Math.Max(maxY, point.Y);\n                            }\n                            minX /= imageScale;\n                            minY /= imageScale;\n                            maxX /= imageScale;
        private Configuration _config;\n        public event EventHandler PACFileChanged;\n        public event EventHandler UserRuleFileChanged;\n        public PACServer()\n        {\n            this.WatchPacFile();\n            this.WatchUserRuleFile();\n        }\n        public void UpdateConfiguration(Configuration config)\n        {
        {\n            if (PACFileChanged != null)\n            {\n                Console.WriteLine("Detected: PAC file '{0}' was {1}.", e.Name, e.ChangeType.ToString().ToLower());\n                PACFileChanged(this, new EventArgs());\n            }\n        }\n        private void UserRuleFileWatcher_Changed(object sender, FileSystemEventArgs e)\n        {\n            if (UserRuleFileChanged != null)
                {\n                    if (localeNames[i] == "en")\n                        enIndex = i;\n                    if (localeNames[i] == locale)\n                        targetIndex = i;\n                }\n                // Fallback to same language with different region\n                if (targetIndex == -1)\n                {\n                    string localeNoRegion = locale.Split('-')[0];
                    }\n                }\n                // Still not found, exit\n                if (targetIndex == -1)\n                {\n                    Logging.Info($"Translation for {locale} not found");\n                    return;\n                }\n                // read translation lines\n                while (!csvParser.EndOfData)\n                {\n                    string[] translations = csvParser.ReadFields();
                    if (translations[0].TrimStart(' ')[0] == '#') continue;\n                    _strings[source] = translation;\n                }\n            }\n        }\n        static I18N()\n        {\n            string i18n;\n            if (!File.Exists(I18N_FILE))\n            {
                }\n            }\n        }\n        static I18N()\n        {\n            string i18n;\n            if (!File.Exists(I18N_FILE))\n            {\n                i18n = Resources.i18n_csv;\n                File.WriteAllText(I18N_FILE, i18n, Encoding.UTF8);
        }\n        public static string GetString(string key, params object[] args)\n        {\n            return string.Format(_strings.TryGetValue(key, out var value) ? value : key, args);\n        }\n        public static void TranslateForm(Form c)\n        {\n            c.Text = GetString(c.Text);\n            foreach (var item in ViewUtils.GetChildControls<Control>(c))\n            {
            this.groupBox1.SuspendLayout();\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer1)).BeginInit();\n            this.splitContainer1.Panel1.SuspendLayout();\n            this.splitContainer1.Panel2.SuspendLayout();\n            this.splitContainer1.SuspendLayout();\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer2)).BeginInit();\n            this.splitContainer2.Panel1.SuspendLayout();\n            this.splitContainer2.Panel2.SuspendLayout();\n            this.splitContainer2.SuspendLayout();\n            ((System.ComponentModel.ISupportInitialize)(this.dataCollectionMinutesNum)).BeginInit();
            public string ServerName;\n            public string ICMPStatus;\n            public int RoundtripTime;\n            public string Geolocation;\n            public string ISP ;\n        }\n        public class StatisticsData\n        {\n            public float PackageLoss;\n            public int AverageResponse;
            var serverUrls = ssURL.Split('\r', '\n');\n            List<Server> servers = new List<Server>();\n            foreach (string serverUrl in serverUrls)\n            {\n                string _serverUrl = serverUrl.Trim();\n                if (!_serverUrl.BeginWith("ss://", StringComparison.InvariantCultureIgnoreCase))\n                {\n                    continue;\n                }\n                Server legacyServer = ParseLegacyURL(serverUrl);
                {\n                    servers.Add(legacyServer);\n                }\n                else   //SIP002\n                {\n                    Uri parsedUrl;\n                    try\n                    {\n                        parsedUrl = new Uri(serverUrl);\n                    }
                }\n                else   //SIP002\n                {\n                    Uri parsedUrl;\n                    try\n                    {\n                        parsedUrl = new Uri(serverUrl);\n                    }\n                    catch (UriFormatException)\n                    {
                {\n                    Uri parsedUrl;\n                    try\n                    {\n                        parsedUrl = new Uri(serverUrl);\n                    }\n                    catch (UriFormatException)\n                    {\n                        continue;\n                    }
                }
            }\n            return servers;\n        }\n        public string Identifier()\n        {\n            return server + ':' + server_port;\n        }\n    }\n}
        public SodiumEncryptor(string method, string password)\n            : base(method, password)\n        {\n            InitKey(method, password);\n        }\n        private static Dictionary<string, int[]> _ciphers = new Dictionary<string, int[]> {\n                {"salsa20", new int[]{32, 8, CIPHER_SALSA20, PolarSSL.AES_CTX_SIZE}},\n                {"chacha20", new int[]{32, 8, CIPHER_CHACHA20, PolarSSL.AES_CTX_SIZE}},
        }\n        private static Dictionary<string, int[]> _ciphers = new Dictionary<string, int[]> {\n                {"salsa20", new int[]{32, 8, CIPHER_SALSA20, PolarSSL.AES_CTX_SIZE}},\n                {"chacha20", new int[]{32, 8, CIPHER_CHACHA20, PolarSSL.AES_CTX_SIZE}},\n        };\n        protected override Dictionary<string, int[]> getCiphers()\n        {\n            return _ciphers;\n        }\n        public static List<string> SupportedCiphers()
            byte[] iv;\n            // I'm tired. just add a big lock\n            // let's optimize for RAM instead of CPU\n            lock(sodiumBuf)\n            {\n                if (isCipher)\n                {\n                    bytesRemaining = _encryptBytesRemaining;\n                    ic = _encryptIC;\n                    iv = _encryptIV;\n                }
            {\n                if (isCipher)\n                {\n                    bytesRemaining = _encryptBytesRemaining;\n                    ic = _encryptIC;\n                    iv = _encryptIV;\n                }\n                else\n                {\n                    bytesRemaining = _decryptBytesRemaining;
            }\n        }\n        public override void Dispose()\n        {\n        }\n    }\n}
                    stream.Close();\n                }\n            }\n        }\n    }\n}
        }\n        public Server GetCurrentServer()\n        {\n            return _config.GetCurrentServer();\n        }\n        // always return copy\n        public Configuration GetConfiguration()\n        {\n            return Configuration.Load();\n        }
            // some logic in configuration updated the config when saving, we need to read it again\n            _config = Configuration.Load();\n            if (polipoRunner == null)\n            {\n                polipoRunner = new PolipoRunner();\n            }\n            if (pacServer == null)\n            {\n                pacServer = new PACServer();\n                pacServer.PACFileChanged += pacServer_PACFileChanged;\n            }
            // don't put polipoRunner.Start() before pacServer.Stop()\n            // or bind will fail when switching bind address from 0.0.0.0 to 127.0.0.1\n            // though UseShellExecute is set to true now\n            // http://stackoverflow.com/questions/10235093/socket-doesnt-close-after-application-exits-if-a-launched-process-is-open\n            polipoRunner.Stop();\n            try\n            {\n                polipoRunner.Start(_config);\n                local = new Local(_config);\n                local.Start();\n                pacServer.Start(_config);\n            }\n            catch (Exception e)\n            {
            if (ConfigChanged != null)\n            {\n                ConfigChanged(this, new EventArgs());\n            }\n            UpdateSystemProxy();\n            Util.Util.ReleaseMemory();\n        }\n        protected void SaveConfig(Configuration newConfig)\n        {\n            Configuration.Save(newConfig);
                StartPipe();\n            }\n            catch (ArgumentException e)\n            {\n            }\n            catch (Exception e)\n            {\n                if (server != null)\n                {\n                    IStrategy strategy = controller.GetCurrentStrategy();
                }\n                Logging.LogUsefulException(e);\n                RetryConnect();\n            }\n        }\n        private void StartPipe()\n        {\n            if (closed)\n            {\n                return;
        private MenuItem ServersItem;

            this.ServersItem = CreateMenuGroup(2, "Servers", new System.Windows.Forms.MenuItem[] {\n                this.SeperatorItem,\n                this.ConfigItem\n            });\n            this.AutoStartupItem = CreateMenuItem(4, "Start on Boot", new System.EventHandler(this.AutoStartupItem_Click));\n            this.ShareOverLANItem = CreateMenuItem(5, "Share over LAN", new System.EventHandler(this.ShareOverLANItem_Click));
            this.AutoStartupItem = CreateMenuItem(4, "Start on Boot", new System.EventHandler(this.AutoStartupItem_Click));\n            this.ShareOverLANItem = CreateMenuItem(5, "Share over LAN", new System.EventHandler(this.ShareOverLANItem_Click));\n            this.contextMenu1.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
            this.contextMenu1.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {\n            this.enableItem,\n            CreateMenuGroup(1, "Mode", new System.Windows.Forms.MenuItem[] {\n                this.PACModeItem,\n                this.globalModeItem\n            }),\n            this.ServersItem,\n            CreateSeperatorItem(3),\n            this.AutoStartupItem,
            this.ServersItem,\n            CreateSeperatorItem(3),\n            this.AutoStartupItem,\n            this.ShareOverLANItem,\n            CreateMenuItem(6, "Edit PAC File...", new System.EventHandler(this.EditPACFileItem_Click)),\n            CreateSeperatorItem(7),\n            CreateMenuItem(8, "Show QRCode...", new System.EventHandler(this.QRCodeItem_Click)),\n            CreateMenuItem(9, "Show Logs...", new System.EventHandler(this.ShowLogItem_Click)),\n            CreateMenuItem(10, "About...", new System.EventHandler(this.Config_Click)),\n            CreateSeperatorItem(11),
            this.AutoStartupItem,\n            this.ShareOverLANItem,\n            CreateMenuItem(6, "Edit PAC File...", new System.EventHandler(this.EditPACFileItem_Click)),\n            CreateSeperatorItem(7),\n            CreateMenuItem(8, "Show QRCode...", new System.EventHandler(this.QRCodeItem_Click)),\n            CreateMenuItem(9, "Show Logs...", new System.EventHandler(this.ShowLogItem_Click)),\n            CreateMenuItem(10, "About...", new System.EventHandler(this.Config_Click)),\n            CreateSeperatorItem(11),\n            CreateMenuItem(12, "Quit", new System.EventHandler(this.Quit_Click))});\n        }
        }\n        private void controller_ConfigChanged(object sender, EventArgs e)\n        {\n            LoadCurrentConfiguration();\n            UpdateTrayIcon();\n        }\n        private void controller_EnableStatusChanged(object sender, EventArgs e)\n        {\n            enableItem.Checked = controller.GetConfiguration().enabled;\n        }
                List<string> versions = new List<string>();\n                foreach (JsonObject release in result)\n                {\n                    if ((bool)release["prerelease"])\n                    {\n                        continue;\n                    }\n                    foreach (JsonObject asset in (JsonArray)release["assets"])\n                    {\n                        string url = (string)asset["browser_download_url"];
                {\n                    if ((bool)release["prerelease"])\n                    {\n                        continue;\n                    }\n                    foreach (JsonObject asset in (JsonArray)release["assets"])\n                    {\n                        string url = (string)asset["browser_download_url"];\n                        if (IsNewVersion(url))
                    {\n                        continue;\n                    }\n                    foreach (JsonObject asset in (JsonArray)release["assets"])\n                    {\n                        string url = (string)asset["browser_download_url"];\n                        if (IsNewVersion(url))\n                        {\n                            versions.Add(url);
                        {\n                            versions.Add(url);\n                        }\n                    }\n                }\n                if (versions.Count == 0)
                        }\n                    }\n                }\n                if (versions.Count == 0)\n                {\n                    return;\n                }\n                // sort versions\n                SortVersions(versions);\n                LatestVersionURL = versions[versions.Count - 1];
using Shadowsocks.Controller;\nusing Shadowsocks.Properties;\nusing Shadowsocks.Model;\nusing System.Text;\nusing Newtonsoft.Json;\nnamespace Shadowsocks.Util.SystemProxy\n{\n    public static class Sysproxy\n    {\n        private const string _userWininetConfigFile = "user-wininet.json";
        // In general, this won't change\n        // format:\n        //  <flags><CR-LF>\n        //  <proxy-server><CR-LF>\n        //  <bypass-list><CR-LF>\n        //  <pac-url>\n        private static SysproxyConfig _userSettings = null;\n        enum RET_ERRORS : int\n        {\n            RET_NO_ERROR = 0,\n            INVALID_FORMAT = 1,\n            NO_PERMISSION = 2,\n            SYSCALL_FAILED = 3,\n            NO_MEMORY = 4,\n            INVAILD_OPTION_COUNT = 5,\n        };
        enum RET_ERRORS : int\n        {\n            RET_NO_ERROR = 0,\n            INVALID_FORMAT = 1,\n            NO_PERMISSION = 2,\n            SYSCALL_FAILED = 3,\n            NO_MEMORY = 4,\n            INVAILD_OPTION_COUNT = 5,\n        };\n        static Sysproxy()
            {\n                // record user settings\n                ExecSysproxy("query");\n                ParseQueryStr(_queryStr);\n            }\n            string arguments;\n            if (enable)\n            {
            }\n            string arguments;\n            if (enable)\n            {\n                arguments = global\n                    ? $"global {proxyServer} <local>;localhost;127.*;10.*;172.16.*;172.17.*;172.18.*;172.19.*;172.20.*;172.21.*;172.22.*;172.23.*;172.24.*;172.25.*;172.26.*;172.27.*;172.28.*;172.29.*;172.30.*;172.31.*;172.32.*;192.168.*"\n                    : $"pac {pacURL}";\n            }\n            else\n            {
                arguments = $"set {flags} {proxy_server} {bypass_list} {pac_url}";\n                // have to get new settings\n                _userSettings.UserSettingsRecorded = false;\n            }\n            Save();\n            ExecSysproxy(arguments);\n        }\n        private static void ExecSysproxy(string arguments)\n        {\n            using (var process = new Process())
            }\n            Save();\n            ExecSysproxy(arguments);\n        }\n        private static void ExecSysproxy(string arguments)\n        {\n            using (var process = new Process())\n            {\n                // Configure the process using the StartInfo properties.
        }\n        private static void ExecSysproxy(string arguments)\n        {\n            using (var process = new Process())\n            {\n                // Configure the process using the StartInfo properties.\n                process.StartInfo.FileName = Utils.GetTempPath("sysproxy.exe");\n                process.StartInfo.Arguments = arguments;\n                process.StartInfo.WorkingDirectory = Utils.GetTempPath();\n                process.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;
        {\n            using (var process = new Process())\n            {\n                // Configure the process using the StartInfo properties.\n                process.StartInfo.FileName = Utils.GetTempPath("sysproxy.exe");\n                process.StartInfo.Arguments = arguments;\n                process.StartInfo.WorkingDirectory = Utils.GetTempPath();\n                process.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;\n                process.StartInfo.UseShellExecute = false;\n                process.StartInfo.RedirectStandardError = true;
                }\n            }\n        }\n        private static void Save()\n        {\n            try {\n                using (StreamWriter sw = new StreamWriter(File.Open(_userWininetConfigFile, FileMode.Create))) {\n                    string jsonString = JsonConvert.SerializeObject(_userSettings, Formatting.Indented);\n                    sw.Write(jsonString);\n                    sw.Flush();
            }\n        }\n        private static void ParseQueryStr(string str)\n        {\n            string[] userSettingsArr = str.Split(new string[] { "\r\n" }, StringSplitOptions.RemoveEmptyEntries);\n            _userSettings.Flags = userSettingsArr[0];\n            // handle output from WinINET\n            if (userSettingsArr[1] == "(null)") _userSettings.ProxyServer = null;\n            else _userSettings.ProxyServer = userSettingsArr[1];\n            if (userSettingsArr[2] == "(null)") _userSettings.BypassList = null;
        }\n    }\n}
using System.Collections.Generic;\nusing System.IO;\nusing System.Runtime.InteropServices;\nusing System.Text;\nnamespace Shadowsocks.Encrypt\n{\n    public class PolarSSL\n    {\n        const string DLLNAME = "polarssl";\n        public const int AES_CTX_SIZE = 8 + 4 * 68;
using System.Threading;\nusing System.Windows.Forms;\nnamespace Shadowsocks\n{\n    static class Program\n    {\n        /// <summary>\n        /// 应用程序的主入口点。
        /// <summary>\n        /// 应用程序的主入口点。\n        /// </summary>\n        [STAThread]\n        static void Main()\n        {\n            using (Mutex mutex = new Mutex(false, "Global\\" + "71981632-A427-497F-AB91-241CD227EC1F"))\n            {\n                if (!mutex.WaitOne(0, false))\n                {
        {\n            byte[] hash = new byte[20];\n            OtaUpdateKeyBuffer();\n            Sodium.ss_sha1_hmac_ex(_otaChunkKeyBuffer, (uint)_otaChunkKeyBuffer.Length,\n                buf, offset, (uint)len, hash);\n            return hash;\n        }\n        private void OtaAuthBuffer4Tcp(byte[] buf, ref int length)\n        {\n            if (!_encryptIVSent)
                buf, offset, (uint)len, hash);\n            return hash;\n        }\n        private void OtaAuthBuffer4Tcp(byte[] buf, ref int length)\n        {\n            if (!_encryptIVSent)\n            {\n                int headLen = OtaGetHeadLen(buf, length);\n                int dataLen = length - headLen;\n                buf[0] |= ONETIMEAUTH_FLAG;
                int dataLen = length - headLen;\n                buf[0] |= ONETIMEAUTH_FLAG;\n                byte[] hash = OtaGenHash(buf, headLen);\n                Buffer.BlockCopy(buf, headLen, buf, headLen + ONETIMEAUTH_BYTES + AUTH_BYTES, dataLen);\n                Buffer.BlockCopy(hash, 0, buf, headLen, ONETIMEAUTH_BYTES);\n                hash = OtaGenChunkHash(buf, headLen + ONETIMEAUTH_BYTES + AUTH_BYTES, dataLen);\n                Buffer.BlockCopy(hash, 0, buf, headLen + ONETIMEAUTH_BYTES + CLEN_BYTES, ONETIMEAUTH_BYTES);\n                byte[] lenBytes = BitConverter.GetBytes((ushort)IPAddress.HostToNetworkOrder((short)dataLen));\n                Buffer.BlockCopy(lenBytes, 0, buf, headLen + ONETIMEAUTH_BYTES, CLEN_BYTES);\n                length = headLen + ONETIMEAUTH_BYTES + AUTH_BYTES + dataLen;
                Buffer.BlockCopy(buf, headLen, buf, headLen + ONETIMEAUTH_BYTES + AUTH_BYTES, dataLen);\n                Buffer.BlockCopy(hash, 0, buf, headLen, ONETIMEAUTH_BYTES);\n                hash = OtaGenChunkHash(buf, headLen + ONETIMEAUTH_BYTES + AUTH_BYTES, dataLen);\n                Buffer.BlockCopy(hash, 0, buf, headLen + ONETIMEAUTH_BYTES + CLEN_BYTES, ONETIMEAUTH_BYTES);\n                byte[] lenBytes = BitConverter.GetBytes((ushort)IPAddress.HostToNetworkOrder((short)dataLen));\n                Buffer.BlockCopy(lenBytes, 0, buf, headLen + ONETIMEAUTH_BYTES, CLEN_BYTES);\n                length = headLen + ONETIMEAUTH_BYTES + AUTH_BYTES + dataLen;\n            }\n            else\n            {
            Buffer.BlockCopy(hash, 0, buf, length, ONETIMEAUTH_BYTES);\n            length += ONETIMEAUTH_BYTES;\n        }\n        private void OtaAuthBuffer(byte[] buf, ref int length)\n        {\n            if (OnetimeAuth && ivLen > 0)\n            {\n                if (!IsUDP)\n                {\n                    OtaAuthBuffer4Tcp(buf, ref length);
                }\n                else\n                {\n                    OtaAuthBuffer4Udp(buf, ref length);\n                }\n            }\n        }\n        #endregion\n        protected static void randBytes(byte[] buf, int length)\n        {
        }\n        public override void Encrypt(byte[] buf, int length, byte[] outbuf, out int outlength)\n        {\n            if (!_encryptIVSent)\n            {\n                outlength = length + ivLen;\n                OtaAuthBuffer(buf, ref length);
                _encryptIVSent = true;\n                lock (tempbuf)\n                {\n                    cipherUpdate(true, length, buf, tempbuf);\n                    outlength = length + ivLen;\n                    Buffer.BlockCopy(tempbuf, 0, outbuf, ivLen, length);\n                }\n            }\n            else\n            {
    /// <summary>\n    internal class Resources {\n        private static global::System.Resources.ResourceManager resourceMan;\n        private static global::System.Globalization.CultureInfo resourceCulture;\n        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]\n        internal Resources() {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("shadowsocks_csharp.Properties.Resources", typeof(Resources).Assembly);\n                    resourceMan = temp;\n                }\n                return resourceMan;\n            }\n        }\n        /// <summary>\n        internal static global::System.Globalization.CultureInfo Culture {\n            get {
            }\n            if (_modifiedConfiguration.configs.Count == 0)\n            {\n                MessageBox.Show(I18N.GetString("Please add at least one server"));\n                return false;\n            }\n            int localPort = int.Parse(ProxyPortTextBox.Text);\n            Configuration.CheckLocalPort(localPort);\n            _modifiedConfiguration.localPort = localPort;\n            _modifiedConfiguration.portableMode = PortableModeCheckBox.Checked;
            }\n            int localPort = int.Parse(ProxyPortTextBox.Text);\n            Configuration.CheckLocalPort(localPort);\n            _modifiedConfiguration.localPort = localPort;\n            _modifiedConfiguration.portableMode = PortableModeCheckBox.Checked;\n            controller.SaveServers(_modifiedConfiguration.configs, _modifiedConfiguration.localPort, _modifiedConfiguration.portableMode);\n            // SelectedIndex remains valid\n            // We handled this in event handlers, e.g. Add/DeleteButton, SelectedIndexChanged\n            // and move operations\n            controller.SelectServerIndex(ServersListBox.SelectedIndex);\n            return true;\n        }\n        private void ConfigForm_KeyDown(object sender, KeyEventArgs e)
        }\n        private void CancelButton_Click(object sender, EventArgs e)\n        {\n            this.Close();\n        }\n        private void ConfigForm_Shown(object sender, EventArgs e)\n        {\n            IPTextBox.Focus();\n        }\n        private void ConfigForm_FormClosed(object sender, FormClosedEventArgs e)
            this.ApplyButton.Location = new System.Drawing.Point(165, 3);\n            this.ApplyButton.Margin = new System.Windows.Forms.Padding(3, 3, 0, 0);\n            this.ApplyButton.Name = "ApplyButton";\n            this.ApplyButton.Size = new System.Drawing.Size(75, 23);\n            this.ApplyButton.TabIndex = 19;\n            this.ApplyButton.Text = "Apply";\n            this.ApplyButton.UseVisualStyleBackColor = true;\n            this.ApplyButton.Click += new System.EventHandler(this.ApplyButton_Click);\n            // \n            // DeleteButton
        }\n        public void UpdateOutboundCounter(long n)\n        {\n            Interlocked.Add(ref outboundCounter, n);\n            _config.GetCurrentServer().bandwidthOut = outboundCounter;\n        }\n        protected void Reload()\n        {\n            // some logic in configuration updated the config when saving, we need to read it again\n            _config = Configuration.Load();\n            inboundCounter = _config.GetCurrentServer().bandwidthIn;
        }\n        protected void Reload()\n        {\n            // some logic in configuration updated the config when saving, we need to read it again\n            _config = Configuration.Load();\n            inboundCounter = _config.GetCurrentServer().bandwidthIn;\n            outboundCounter = _config.GetCurrentServer().bandwidthOut;\n            StatisticsConfiguration = StatisticsStrategyConfiguration.Load();\n            if (polipoRunner == null)\n            {\n                polipoRunner = new PolipoRunner();
            StatisticsConfiguration = StatisticsStrategyConfiguration.Load();\n            if (polipoRunner == null)\n            {\n                polipoRunner = new PolipoRunner();\n            }\n            if (_pacServer == null)\n            {\n                _pacServer = new PACServer();\n                _pacServer.PACFileChanged += pacServer_PACFileChanged;\n                _pacServer.UserRuleFileChanged += pacServer_UserRuleFileChanged;
            ((System.ComponentModel.ISupportInitialize)(this.StatisticsChart)).BeginInit();\n            this.groupBox1.SuspendLayout();\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer1)).BeginInit();\n            this.splitContainer1.Panel1.SuspendLayout();\n            this.splitContainer1.Panel2.SuspendLayout();\n            this.splitContainer1.SuspendLayout();\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer2)).BeginInit();\n            this.splitContainer2.Panel1.SuspendLayout();\n            this.splitContainer2.Panel2.SuspendLayout();
            this.groupBox1.SuspendLayout();\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer1)).BeginInit();\n            this.splitContainer1.Panel1.SuspendLayout();\n            this.splitContainer1.Panel2.SuspendLayout();\n            this.splitContainer1.SuspendLayout();\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer2)).BeginInit();\n            this.splitContainer2.Panel1.SuspendLayout();\n            this.splitContainer2.Panel2.SuspendLayout();\n            this.splitContainer2.SuspendLayout();\n            ((System.ComponentModel.ISupportInitialize)(this.dataCollectionMinutesNum)).BeginInit();

                             ?? new StatisticsStrategyConfiguration();\n            if (_configuration.Calculations == null)\n            {\n                _configuration = new StatisticsStrategyConfiguration();\n            }\n        }\n        private void InitData()\n        {\n            bindingConfiguration.Add(_configuration);\n            foreach (var kv in _configuration.Calculations)
namespace Shadowsocks.Controller\n{\n    class PACServer\n    {\n        private static int PORT = 8093;\n        public static string PAC_FILE = "pac.txt";\n        private static Configuration config;\n        Socket _listener;\n        FileSystemWatcher watcher;\n        public event EventHandler PACFileChanged;
        private static Configuration config;\n        Socket _listener;\n        FileSystemWatcher watcher;\n        public event EventHandler PACFileChanged;\n        public void Start(Configuration configuration)\n        {\n            try\n            {
        public void Start(Configuration configuration)\n        {\n            try\n            {\n                config = configuration;\n                // Create a TCP/IP socket.\n                _listener = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);\n                _listener.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, true);\n                IPEndPoint localEndPoint = null;\n                if (configuration.shareOverLan)
        public event ErrorEventHandler Error;
        private void http_DownloadStringCompleted(object sender, DownloadStringCompletedEventArgs e)\n        {\n            try\n            {\n                string[] lines = ParseResult(e.Result);\n                JsonArray rules = new JsonArray();\n                rules.AddRange(lines);\n                string abpContent = Utils.UnGzip(Resources.abp_js);\n                abpContent = abpContent.Replace("__RULES__", rules.ToString());\n                File.WriteAllText(PAC_FILE, abpContent, Encoding.UTF8);
                {\n                    UpdateCompleted(this, new EventArgs());\n                }\n            }\n            catch (Exception ex)\n            {
                }\n            }\n            catch (Exception ex)\n            {\n                if (Error != null)\n                {\n                    Error(this, new ErrorEventArgs(ex));\n                }\n            }
            }\n        }\n        public void UpdatePACFromGFWList()\n        {\n            WebClient http = new WebClient();\n            http.DownloadStringCompleted += http_DownloadStringCompleted;\n            http.DownloadStringAsync(new Uri(GFWLIST_URL));\n        }\n        public string[] ParseResult(string response)\n        {
        {\n            WebClient http = new WebClient();\n            http.DownloadStringCompleted += http_DownloadStringCompleted;\n            http.DownloadStringAsync(new Uri(GFWLIST_URL));\n        }\n        public string[] ParseResult(string response)\n        {\n            byte[] bytes = Convert.FromBase64String(response);\n            string content = Encoding.ASCII.GetString(bytes);\n            string[] lines = content.Split(new char[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
            {\n                if (line.StartsWith("!") || line.StartsWith("["))\n                    continue;\n                valid_lines.Add(line);\n            }\n            return valid_lines.ToArray();
            }\n            return valid_lines.ToArray();
        }\n    }\n}
        {\n            if (UpdatePACFromGFWListError != null)\n                UpdatePACFromGFWListError(this, e);\n        }\n        private void StartReleasingMemory()\n        {\n            _ramThread = new Thread(new ThreadStart(ReleaseMemory));\n            _ramThread.IsBackground = true;\n            _ramThread.Start();\n        }
    {\n        public static void ReleaseMemory()\n        {\n            // release any unused pages\n            // making the numbers look good in task manager\n            // this is totally nonsense in programming\n            // but good for those users who care\n            // making them happier with their everyday life\n            // which is part of user experience\n            GC.Collect(GC.MaxGeneration);\n        public static string UnGzip(byte[] buf)\n        {
            try\n            {\n                FileManager.UncompressFile(temppath + "/ss_privoxy.exe", Resources.privoxy_exe);\n                FileManager.UncompressFile(temppath + "/mgwz.dll", Resources.mgwz_dll);\n            }\n            catch (IOException e)\n            {\n                Logging.LogUsefulException(e);\n            }\n        }
        }\n    }\n    class Handler\n    {\n        //public Encryptor encryptor;\n        public IEncryptor encryptor;\n        public Server server;\n        // Client  socket.\n        public Socket remote;\n        public Socket connection;
         return Mode.BYTE;
      }\n      private static int chooseMaskPattern(BitArray bits,\n                                           ErrorCorrectionLevel ecLevel,\n                                           Version version,\n                                           ByteMatrix matrix)\n      {\n         int minPenalty = Int32.MaxValue;  // Lower penalty is better.\n         int bestMaskPattern = -1;\n         // We try all mask patterns to choose the best one.\n         for (int maskPattern = 0; maskPattern < QRCode.NUM_MASK_PATTERNS; maskPattern++)
            else\n                throw new WriterException("Invalid mode: " + mode);\n      }\n      internal static void appendNumericBytes(String content, BitArray bits)
      }\n      internal static void appendNumericBytes(String content, BitArray bits)\n      {\n         int length = content.Length;\n         int i = 0;\n         while (i < length)\n         {\n            int num1 = content[i] - '0';\n            if (i + 2 < length)\n            {
      /// <summary> Sets a block of 32 bits, starting at bit i.\n      /// \n      /// </summary>\n      /// <param name="i">first bit to set\n      /// </param>\n      /// <param name="newBits">the new value of the next 32 bits. Note again that the least-significant bit\n      /// corresponds to bit i, the next-least-significant to i+1, and so on.\n      /// </param>\n      public void setBulk(int i, int newBits)\n      {
      /// <summary> Clears all bits (sets to false).</summary>\n      public void clear()\n      {\n         int max = bits.Length;\n         for (int i = 0; i < max; i++)\n         {\n            bits[i] = 0;\n         }
      }\n      /// <summary>\n      /// Appends the bit.\n      /// </summary>\n      /// <param name="bit">The bit.</param>\n      public void appendBit(bool bit)\n      {\n         ensureCapacity(size + 1);\n         if (bit)\n         {
using Shadowsocks.Model;\nusing SimpleJson = SimpleJson.SimpleJson;\nusing Timer = System.Threading.Timer;\nnamespace Shadowsocks.Controller\n{\n    using DataUnit = KeyValuePair<string, string>;\n    using DataList = List<KeyValuePair<string, string>>;\n    class AvailabilityStatistics\n    {\n        private const string StatisticsFilesName = "shadowsocks.availability.csv";
        {\n            Logging.Debug("Retrive information of geolocation and isp");\n            const string api = "http://ip-api.com/json";\n            var jsonString = await new HttpClient().GetStringAsync(api);\n            var ret = new DataList\n            {\n                new DataUnit(State.Geolocation, State.Unknown),\n                new DataUnit(State.ISP, State.Unknown),\n            };\n            dynamic obj;
            {\n                //ICMP echo. we can also set options and special bytes\n                var reply = await ping.SendTaskAsync(server.server, Timeout);\n                ret.Add(new List<KeyValuePair<string, string>>\n                {\n                    new KeyValuePair<string, string>("Timestamp", timestamp),\n                    new KeyValuePair<string, string>("Server", server.FriendlyName()),\n                    new KeyValuePair<string, string>("Status", reply?.Status.ToString()),\n                    new KeyValuePair<string, string>("RoundtripTime", reply?.RoundtripTime.ToString())
                {\n                    new KeyValuePair<string, string>("Timestamp", timestamp),\n                    new KeyValuePair<string, string>("Server", server.FriendlyName()),\n                    new KeyValuePair<string, string>("Status", reply?.Status.ToString()),\n                    new KeyValuePair<string, string>("RoundtripTime", reply?.RoundtripTime.ToString())\n                    //new KeyValuePair<string, string>("data", reply.Buffer.ToString()); // The data of reply\n                });\n            }\n            return ret;\n        }
                }\n            }\n        }\n        private static void Append(DataList dataList, IEnumerable<DataUnit> extra)\n        {\n            var data = dataList.Concat(extra);\n            var dataLine = string.Join(Delimiter, data.Select(kv => kv.Value).ToArray());\n            string[] lines;\n            if (!File.Exists(AvailabilityStatisticsFile))\n            {
        {\n            var data = dataList.Concat(extra);\n            var dataLine = string.Join(Delimiter, data.Select(kv => kv.Value).ToArray());\n            string[] lines;\n            if (!File.Exists(AvailabilityStatisticsFile))\n            {\n                var headerLine = string.Join(Delimiter, data.Select(kv => kv.Key).ToArray());\n                lines = new[] { headerLine, dataLine };\n            }\n            else
                Match match = Regex.Match(name, @"^Shadowsocks-(?<version>\d+(?:\.\d+)*)(?:|-(?<suffix>.+))\.\w+$",\n                    RegexOptions.IgnoreCase);\n                if (match.Success)\n                {\n                    string version = match.Groups["version"].Value;\n                    var asset = new Asset\n                    {\n                        browser_download_url = (string) assertJObject["browser_download_url"],\n                        name = name,\n                        version = version
                        name = name,\n                        version = version\n                    };\n                    if (match.Groups["suffix"].Success)\n                    {\n                        asset.suffix = match.Groups["suffix"].Value;\n                    }\n                    return asset;\n                }\n                return null;
    public partial class LogForm : Form\n    {\n        long lastOffset;\n        string filename;\n        Timer timer;\n        const int BACK_OFFSET = 65536;\n        ShadowsocksController controller;\n        // global traffic update lock, make it static\n        private static readonly object _lock = new object();\n        #region Traffic Chart\n        Queue<TrafficInfo> trafficInfoQueue = new Queue<TrafficInfo>();
        #endregion\n        public LogForm(ShadowsocksController controller, string filename)\n        {\n            this.controller = controller;\n            this.filename = filename;\n            InitializeComponent();\n            Icon = Icon.FromHandle(Resources.ssw128.GetHicon());\n            LogViewerConfig config = controller.GetConfigurationCopy().logViewer;\n            topMostTrigger = config.topMost;\n            wrapTextTrigger = config.wrapText;
            lock (_lock)\n            {\n                if (trafficInfoQueue.Count == 0)\n                    return;\n                inboundPoints.Clear();\n                outboundPoints.Clear();\n                maxSpeed = 0;\n                foreach (var trafficInfo in trafficInfoQueue)\n                {\n                    inboundPoints.Add(trafficInfo.inbound);
                    return;\n                inboundPoints.Clear();\n                outboundPoints.Clear();\n                maxSpeed = 0;\n                foreach (var trafficInfo in trafficInfoQueue)\n                {\n                    inboundPoints.Add(trafficInfo.inbound);\n                    outboundPoints.Add(trafficInfo.outbound);\n                    maxSpeed = Math.Max(maxSpeed, Math.Max(trafficInfo.inbound, trafficInfo.outbound));\n                }
            }\n            if (maxSpeed > 0)\n            {\n                lastMaxSpeed -= lastMaxSpeed / 32;\n                maxSpeed = Math.Max(minScale, Math.Max(maxSpeed, lastMaxSpeed));\n                lastMaxSpeed = maxSpeed;\n            }\n            else\n            {\n                maxSpeed = lastMaxSpeed = minScale;
        private bool stopped = false;\n        private bool _systemProxyIsDirty = false;\n        public class PathEventArgs : EventArgs\n        {\n            public string Path;
        }\n        public class TrafficPerSecond\n        {\n            public long inboundCounter;\n            public long outboundCounter;\n            public long inboundIncreasement;\n            public long outboundIncreasement;\n        }\n        public event EventHandler ConfigChanged;\n        public event EventHandler EnableStatusChanged;
            for (int i = 0; i < queueMaxSize; i++)\n            {\n                trafficPerSecondQueue.Enqueue(new TrafficPerSecond());\n            }\n            _trafficThread = new Thread(new ThreadStart(() => TrafficStatistics(queueMaxSize)));\n            _trafficThread.IsBackground = true;\n            _trafficThread.Start();\n        }\n        private void TrafficStatistics(int queueMaxSize)\n        {
            }\n            _trafficThread = new Thread(new ThreadStart(() => TrafficStatistics(queueMaxSize)));\n            _trafficThread.IsBackground = true;\n            _trafficThread.Start();\n        }\n        private void TrafficStatistics(int queueMaxSize)\n        {\n            TrafficPerSecond previous, current;\n            while (true)\n            {
                TrafficChanged?.Invoke(this, new EventArgs());\n                Thread.Sleep(1000);\n            }\n        }\n        #endregion\n    }\n}
        public DateTime lastActivity;\n        private int _totalRead = 0;\n        private int _totalWrite = 0;\n        private byte[] _remoteRecvBuffer = new byte[BufferSize];
        private DateTime _startConnectTime;\n        private DateTime _startReceivingTime;\n        private DateTime _startSendingTime;\n        private int _bytesToSend;
        }\n    }\n}
        // remote receive buffer\n        public byte[] remoteRecvBuffer = new byte[RecvSize];\n        // remote send buffer\n        public byte[] remoteSendBuffer = new byte[BufferSize];\n        // connection receive buffer\n        public byte[] connetionRecvBuffer = new byte[RecvSize];\n        // connection send buffer\n        public byte[] connetionSendBuffer = new byte[BufferSize];\n        // Received data string.\n        public StringBuilder sb = new StringBuilder();\n        public void Start()\n        {
        // connection receive buffer\n        public byte[] connetionRecvBuffer = new byte[RecvSize];\n        // connection send buffer\n        public byte[] connetionSendBuffer = new byte[BufferSize];\n        // Received data string.\n        public StringBuilder sb = new StringBuilder();\n        public void Start()\n        {\n            try\n            {\n                // TODO async resolving
        // Received data string.\n        public StringBuilder sb = new StringBuilder();\n        public void Start()\n        {\n            try\n            {\n                // TODO async resolving\n                IPAddress ipAddress;\n                bool parsed = IPAddress.TryParse(config.server, out ipAddress);\n                if (!parsed)
                    new AsyncCallback(pipeRemoteReceiveCallback), null);\n                connection.BeginReceive(connetionRecvBuffer, 0, RecvSize, 0,\n                    new AsyncCallback(pipeConnectionReceiveCallback), null);\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine(e.ToString());\n                this.Close();\n            }\n        }
                    new AsyncCallback(pipeConnectionReceiveCallback), null);\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine(e.ToString());\n                this.Close();\n            }\n        }\n        private void pipeRemoteReceiveCallback(IAsyncResult ar)\n        {
        {\n            if (_encryptCtx == IntPtr.Zero)\n            {\n                OpenSSL.RAND_bytes(outbuf, ivLen);\n                InitCipher(ref _encryptCtx, outbuf, true);\n                outlength = length + ivLen;\n                OpenSSL.EVP_CipherUpdate(_encryptCtx, tempbuf, out outlength, buf, length);\n                outlength = length + ivLen;\n                Buffer.BlockCopy(tempbuf, 0, outbuf, ivLen, outlength);
            }\n            else\n            {\n                outlength = length;\n                OpenSSL.EVP_CipherUpdate(_encryptCtx, outbuf, out outlength, buf, length);
            }\n        }\n        public override void Decrypt(byte[] buf, int length, byte[] outbuf, out int outlength)\n        {\n            if (_decryptCtx == IntPtr.Zero)\n            {\n                InitCipher(ref _decryptCtx, buf, false);\n                outlength = length - ivLen;\n                Buffer.BlockCopy(buf, ivLen, tempbuf, 0, length - ivLen);\n                OpenSSL.EVP_CipherUpdate(_decryptCtx, outbuf, out outlength, tempbuf, length - ivLen);
        {\n            if (_decryptCtx == IntPtr.Zero)\n            {\n                InitCipher(ref _decryptCtx, buf, false);\n                outlength = length - ivLen;\n                Buffer.BlockCopy(buf, ivLen, tempbuf, 0, length - ivLen);\n                OpenSSL.EVP_CipherUpdate(_decryptCtx, outbuf, out outlength, tempbuf, length - ivLen);
            }\n            else\n            {\n                outlength = length;\n                OpenSSL.EVP_CipherUpdate(_decryptCtx, outbuf, out outlength, buf, length);
            }\n        }\n        private static readonly Dictionary<string, byte[]> CachedKeys = new Dictionary<string, byte[]>();\n        private byte[] _key;\n        private IntPtr _encryptCtx;\n        private IntPtr _decryptCtx;\n        private IntPtr _cipher;\n        private string _method;\n        private int keyLen;\n        private int ivLen;
    {\n        void Encrypt(byte[] buf, int length, byte[] outbuf, out int outlength);\n        void Decrypt(byte[] buf, int length, byte[] outbuf, out int outlength);\n    }\n}
    }\n}
        {\n            byte[] result = new byte[length];\n            for (int i = 0; i < length; i++)\n            {\n                outbuf[i] = _encryptTable[buf[i]];\n            }\n            outlength = length;\n        }\n        public override void Decrypt(byte[] buf, int length, byte[] outbuf, out int outlength)\n        {
            }\n            outlength = length;\n        }\n        public override void Decrypt(byte[] buf, int length, byte[] outbuf, out int outlength)\n        {\n            byte[] result = new byte[length];\n            for (int i = 0; i < length; i++)\n            {\n                outbuf[i] = _decryptTable[buf[i]];\n            }
        }\n        public override void Decrypt(byte[] buf, int length, byte[] outbuf, out int outlength)\n        {\n            byte[] result = new byte[length];\n            for (int i = 0; i < length; i++)\n            {\n                outbuf[i] = _decryptTable[buf[i]];\n            }\n            outlength = length;\n        }
        {\n            byte[] result = new byte[length];\n            for (int i = 0; i < length; i++)\n            {\n                outbuf[i] = _decryptTable[buf[i]];\n            }\n            outlength = length;\n        }\n        private readonly byte[] _encryptTable = new byte[256];\n        private readonly byte[] _decryptTable = new byte[256];
            }\n            outlength = length;\n        }\n        private readonly byte[] _encryptTable = new byte[256];\n        private readonly byte[] _decryptTable = new byte[256];\n        private static long Compare(byte x, byte y, ulong a, int i)\n        {\n            return (long)(a % (ulong)(x + i)) - (long)(a % (ulong)(y + i));\n        }\n        private byte[] MergeSort(byte[] array, ulong a, int j)
        }\n        private readonly byte[] _encryptTable = new byte[256];\n        private readonly byte[] _decryptTable = new byte[256];\n        private static long Compare(byte x, byte y, ulong a, int i)\n        {\n            return (long)(a % (ulong)(x + i)) - (long)(a % (ulong)(y + i));\n        }\n        private byte[] MergeSort(byte[] array, ulong a, int j)\n        {\n            if (array.Length == 1)
    {\n        // Don't use Application.ExecutablePath\n        // see https://stackoverflow.com/questions/12945805/odd-c-sharp-path-issue\n        private static readonly string ExecutablePath = Assembly.GetEntryAssembly().Location;\n        private static string Key = "Shadowsocks_" + Application.StartupPath.GetHashCode();\n        public static bool Set(bool enabled)\n        {\n            RegistryKey runKey = null;\n            try\n            {
        public static bool Set(bool enabled)\n        {\n            RegistryKey runKey = null;\n            try\n            {\n                runKey = Utils.OpenRegKey(@"Software\Microsoft\Windows\CurrentVersion\Run", true);\n                if ( runKey == null ) {\n                    Logging.Error( @"Cannot find HKCU\Software\Microsoft\Windows\CurrentVersion\Run" );\n                    return false;
                runKey = Utils.OpenRegKey(@"Software\Microsoft\Windows\CurrentVersion\Run", true);\n                if ( runKey == null ) {\n                    Logging.Error( @"Cannot find HKCU\Software\Microsoft\Windows\CurrentVersion\Run" );\n                    return false;\n                }\n                if (enabled)\n                {\n                    runKey.SetValue(Key, ExecutablePath);\n                }\n                else
                }\n                else\n                {\n                    runKey.DeleteValue(Key);\n                }\n                return true;\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);
                            return true;\n                        }\n                    }\n                }\n                return false;\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                return false;
        private AsyncSession _currentRemoteSession;\n        private const int   MaxRetry = 4;\n        private int         _retryCount = 0;\n        private bool        _proxyConnected;\n        private bool        _destConnected;\n        private byte    _command;\n        private byte[]  _firstPacket;\n        private int     _firstPacketLength;\n        private int     _totalRead = 0;\n        private int     _totalWrite = 0;
        private DateTime _startConnectTime;\n        private DateTime _startReceivingTime;\n        private DateTime _startSendingTime;\n        public TCPHandler(ShadowsocksController controller, Configuration config, TCPRelay tcprelay, Socket socket)\n        {\n            this._controller = controller;\n            this._config = config;
            this._tcprelay = tcprelay;\n            this._connection = socket;\n        }\n        public void CreateRemote()\n        {
        }\n        public void CreateRemote()\n        {
                if (_closed) return;\n                _closed = true;\n            }\n            lock (_tcprelay.Handlers)\n            {\n                _tcprelay.Handlers.Remove(this);\n            }\n            try\n            {\n                _connection?.Shutdown(SocketShutdown.Both);
            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n            }\n            try\n            {\n                var remote = _currentRemoteSession?.Remote;\n                remote?.Shutdown(SocketShutdown.Both);\n                remote?.Close();
            if (MbedTLS.cipher_set_iv(ctx, iv, ivLen) != 0)\n                throw new Exception("Cannot set mbed TLS cipher IV");\n            if (MbedTLS.cipher_reset(ctx) != 0)\n                throw new Exception("Cannot finalize mbed TLS cipher context");\n        }\n        protected override void cipherUpdate(bool isCipher, int length, byte[] buf, byte[] outbuf)\n        {\n            // C# could be multi-threaded\n            if (_disposed)\n            {
            if (MbedTLS.cipher_reset(ctx) != 0)\n                throw new Exception("Cannot finalize mbed TLS cipher context");\n        }\n        protected override void cipherUpdate(bool isCipher, int length, byte[] buf, byte[] outbuf)\n        {\n            // C# could be multi-threaded\n            if (_disposed)\n            {\n                throw new ObjectDisposedException(this.ToString());\n            }
        }\n        protected override void cipherUpdate(bool isCipher, int length, byte[] buf, byte[] outbuf)\n        {\n            // C# could be multi-threaded\n            if (_disposed)\n            {\n                throw new ObjectDisposedException(this.ToString());\n            }\n            IntPtr ctx;\n            if (isCipher)
            }\n            else if (name.StartsWith("Japan", StringComparison.OrdinalIgnoreCase))\n            {\n                Init(Resources.ja);\n            }\n        }\n        public static string GetString(string key)\n        {\n            return _strings.ContainsKey(key)\n                ? _strings[key]
            }\n        }\n        public static string GetString(string key)\n        {\n            return _strings.ContainsKey(key)\n                ? _strings[key]\n                : key;\n        }\n    }\n}
        private LRUCache<IPEndPoint, UDPHandler> _cache;\n        public UDPRelay(ShadowsocksController controller)\n        {\n            this._controller = controller;\n            this._cache = new LRUCache<IPEndPoint, UDPHandler>(512);  // todo: choose a smart number\n        }\n        public bool Handle(byte[] firstPacket, int length, Socket socket, object state)\n        {\n            if (socket.ProtocolType != ProtocolType.Udp)\n            {
        {\n            this._controller = controller;\n            this._cache = new LRUCache<IPEndPoint, UDPHandler>(512);  // todo: choose a smart number\n        }\n        public bool Handle(byte[] firstPacket, int length, Socket socket, object state)\n        {\n            if (socket.ProtocolType != ProtocolType.Udp)\n            {\n                return false;\n            }
            this._cache = new LRUCache<IPEndPoint, UDPHandler>(512);  // todo: choose a smart number\n        }\n        public bool Handle(byte[] firstPacket, int length, Socket socket, object state)\n        {\n            if (socket.ProtocolType != ProtocolType.Udp)\n            {\n                return false;\n            }\n            if (length < 4)\n            {
            _notifyIcon.Text = text.Substring(0, Math.Min(63, text.Length));\n        }\n        private MenuItem CreateMenuItem(string text, EventHandler click)\n        {\n            return new MenuItem(I18N.GetString(text), click);\n        }\n        private MenuItem CreateMenuGroup(string text, MenuItem[] items)\n        {\n            return new MenuItem(I18N.GetString(text), items);\n        }
            modeItem.Enabled = enableItem.Checked;\n        }\n        void controller_ShareOverLANStatusChanged(object sender, EventArgs e)\n        {\n            ShareOverLANItem.Checked = controller.GetConfigurationCopy().shareOverLan;\n        }\n        void controller_EnableGlobalChanged(object sender, EventArgs e)\n        {\n            globalModeItem.Checked = controller.GetConfigurationCopy().global;\n            PACModeItem.Checked = !globalModeItem.Checked;
        }\n        void controller_EnableGlobalChanged(object sender, EventArgs e)\n        {\n            globalModeItem.Checked = controller.GetConfigurationCopy().global;\n            PACModeItem.Checked = !globalModeItem.Checked;\n        }\n        void controller_FileReadyToOpen(object sender, ShadowsocksController.PathEventArgs e)\n        {\n            string argument = @"/select, " + e.Path;\n            System.Diagnostics.Process.Start("explorer.exe", argument);
            PACModeItem.Checked = !globalModeItem.Checked;\n        }\n        void controller_FileReadyToOpen(object sender, ShadowsocksController.PathEventArgs e)\n        {\n            string argument = @"/select, " + e.Path;\n            System.Diagnostics.Process.Start("explorer.exe", argument);\n        }\n        void ShowBalloonTip(string title, string content, ToolTipIcon icon, int timeout)\n        {\n            _notifyIcon.BalloonTipTitle = title;
                MenuItem item = new MenuItem(server.FriendlyName());\n                item.Tag = i;\n                item.Click += AServerItem_Click;\n                items.Add(i, item);\n                i++;\n            }\n            foreach (MenuItem item in items)\n            {\n                if (item.Tag != null && (item.Tag.ToString() == configuration.index.ToString() || item.Tag.ToString() == configuration.strategy))\n                {
            }\n        }\n        private void ShowConfigForm()\n        {\n            if (configForm != null)\n            {\n                configForm.Activate();\n            }\n            else\n            {
        }\n        public bool Handle(byte[] firstPacket, int length, Socket socket, object state)\n        {\n            if (socket.ProtocolType != ProtocolType.Tcp)\n            {\n                return false;\n            }\n            if (length < 2 || firstPacket[0] != 5)\n            {\n                return false;
        {\n            return Configuration.Load();\n        }\n        // always return current instance\n        public Configuration GetCurrentConfiguration()\n        {\n            return _config;\n        }\n        public IList<IStrategy> GetStrategies()\n        {
            {\n                config.index = -1;\n            }\n            config.isDefault = false;\n            try\n            {\n                using (StreamWriter sw = new StreamWriter(File.Open(CONFIG_FILE, FileMode.Create)))\n                {\n                    string jsonString = SimpleJson.SimpleJson.SerializeObject(config);\n                    sw.Write(jsonString);
            }\n            config.isDefault = false;\n            try\n            {\n                using (StreamWriter sw = new StreamWriter(File.Open(CONFIG_FILE, FileMode.Create)))\n                {\n                    string jsonString = SimpleJson.SimpleJson.SerializeObject(config);\n                    sw.Write(jsonString);\n                    sw.Flush();\n                }
        {\n            try\n            {\n                connection.EndSend(ar);\n                StartConnect();\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                this.Close();
                    Logging.Info("os suspend");\n                    break;\n            }\n        }\n        private static void Timer_Elapsed(object sender, System.Timers.ElapsedEventArgs e)\n        {\n            try\n            {\n                if (_controller != null)\n                {
            }\n            catch (Exception ex)\n            {\n                Logging.LogUsefulException(ex);\n            }\n            finally\n            {\n                try\n                {\n                    System.Timers.Timer timer = (System.Timers.Timer)sender;
            string base64 = Convert.ToBase64String(Encoding.UTF8.GetBytes(parts));\n            if(!server.remarks.IsNullOrEmpty())\n            {\n                tag = $"#{HttpUtility.UrlEncode(server.remarks, Encoding.UTF8)}";\n            }\n            return $"ss://{base64}{tag}";\n        }\n        public void UpdatePACFromGFWList()\n        {
        }\n        public void UpdatePACFromGFWList()\n        {\n            if (gfwListUpdater != null)\n            {\n                gfwListUpdater.UpdatePACFromGFWList(_config);\n            }\n        }\n        public void UpdateStatisticsConfiguration(bool enabled)\n        {
            if (!tag.IsNullOrEmpty())\n                remarks = HttpUtility.UrlDecode(tag, Encoding.UTF8);\n            match = DetailsParser.Match(Encoding.UTF8.GetString(Convert.FromBase64String(\n                base64.PadRight(base64.Length + (4 - base64.Length % 4) % 4, '='))));\n            method = match.Groups["method"].Value;\n            auth = match.Groups["auth"].Success;\n            password = match.Groups["password"].Value;\n            server = match.Groups["hostname"].Value;\n            server_port = int.Parse(match.Groups["port"].Value);\n        }
            match = DetailsParser.Match(Encoding.UTF8.GetString(Convert.FromBase64String(\n                base64.PadRight(base64.Length + (4 - base64.Length % 4) % 4, '='))));\n            method = match.Groups["method"].Value;\n            auth = match.Groups["auth"].Success;\n            password = match.Groups["password"].Value;\n            server = match.Groups["hostname"].Value;\n            server_port = int.Parse(match.Groups["port"].Value);\n        }\n        public string Identifier()\n        {
                    connection.BeginReceive(_connetionRecvBuffer, 0, RecvSize, SocketFlags.None, new AsyncCallback(ReadAll), null);\n                }\n                else\n                {\n                    int bytesRead = connection.EndReceive(ar);\n                    if (bytesRead > 0)\n                    {\n                        connection.BeginReceive(_connetionRecvBuffer, 0, RecvSize, SocketFlags.None, new AsyncCallback(ReadAll), null);\n                    }
                        connection.BeginReceive(_connetionRecvBuffer, 0, RecvSize, SocketFlags.None, new AsyncCallback(ReadAll), null);\n                    }\n                    else\n                        Close();\n                }\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();
                {\n                    byte[] response = { 5, 0 };\n                    if (connetionRecvBuffer[0] != 5)\n                    {\n                        // reject socks 4\n                        response = new byte[]{ 0, 91 };\n                    }\n                    connection.BeginSend(response, 0, response.Length, 0, new AsyncCallback(handshakeSendCallback), null);\n                }\n                else\n                {
                {\n                    OpenSSL.EVP_CIPHER_CTX_cleanup(_encryptCtx);\n                    OpenSSL.EVP_CIPHER_CTX_free(_encryptCtx);\n                    _encryptCtx = IntPtr.Zero;\n                }\n                if (_decryptCtx.ToInt64() != 0)\n                {\n                    OpenSSL.EVP_CIPHER_CTX_cleanup(_decryptCtx);\n                    OpenSSL.EVP_CIPHER_CTX_free(_decryptCtx);\n                    _decryptCtx = IntPtr.Zero;
                {\n                    OpenSSL.EVP_CIPHER_CTX_cleanup(_decryptCtx);\n                    OpenSSL.EVP_CIPHER_CTX_free(_decryptCtx);\n                    _decryptCtx = IntPtr.Zero;\n                }\n                _disposed = true;\n            }\n        }\n        #endregion\n    }
            }\n            else\n            {\n                defConnection[optionsOffset] = (byte)(defConnection[optionsOffset] & ~8);\n                savedLegacySetting[optionsOffset] = (byte)(savedLegacySetting[optionsOffset] & ~8);\n            }\n            BitConverter.GetBytes(\n                unchecked(BitConverter.ToUInt32(defConnection, versionOffset) + 1))\n                .CopyTo(defConnection, versionOffset);\n            BitConverter.GetBytes(
            }\n            BitConverter.GetBytes(\n                unchecked(BitConverter.ToUInt32(defConnection, versionOffset) + 1))\n                .CopyTo(defConnection, versionOffset);\n            BitConverter.GetBytes(\n                unchecked(BitConverter.ToUInt32(savedLegacySetting, versionOffset) + 1))\n                .CopyTo(savedLegacySetting, versionOffset);\n            registry.SetValue("DefaultConnectionSettings", defConnection);
            registry.SetValue("DefaultConnectionSettings", defConnection);\n            registry.SetValue("SavedLegacySettings", savedLegacySetting);\n        }\n    }\n}
    public sealed class AvailabilityStatistics\n    {\n        public const string DateTimePattern = "yyyy-MM-dd HH:mm:ss";\n        private const string StatisticsFilesName = "shadowsocks.availability.json";\n        private const int TimeoutMilliseconds = 500;\n        public static readonly DateTime UnknownDateTime = new DateTime(1970, 1, 1);\n        public static string AvailabilityStatisticsFile;\n        private readonly TimeSpan _delayBeforeStart = TimeSpan.FromSeconds(1);\n        private readonly TimeSpan _monitorInterval = TimeSpan.FromSeconds(1);\n        private readonly TimeSpan _retryInterval = TimeSpan.FromMinutes(2); //retry 2 minutes after failed
        public Statistics RawStatistics { get; private set; }\n        public Statistics FilteredStatistics { get; private set; }\n        private int Repeat => _config.RepeatTimesNum;\n        private TimeSpan RecordingInterval => TimeSpan.FromMinutes(_config.DataCollectionMinutes);
        private int Repeat => _config.RepeatTimesNum;\n        private TimeSpan RecordingInterval => TimeSpan.FromMinutes(_config.DataCollectionMinutes);
        public bool Set(StatisticsStrategyConfiguration config)\n        {\n            _config = config;\n            try\n            {\n                if (config.StatisticsEnabled)\n                {\n                    if (_recorder?.Change(_delayBeforeStart, RecordingInterval) == null)\n                    {\n                        _recorder = new Timer(Run, null, _delayBeforeStart, RecordingInterval);
                    }\n                }\n                else\n                {\n                    _recorder?.Dispose();\n                    _speedMonior?.Dispose();\n                }\n                return true;\n            }\n            catch (Exception e)
                    _speedMonior?.Dispose();\n                }\n                return true;\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                return false;\n            }\n        }
            bytes = _controller.outboundCounter - _lastOutboundCounter;\n            _lastOutboundCounter = _controller.outboundCounter;\n            var outboundSpeed = GetSpeedInKiBPerSecond(bytes, _monitorInterval.TotalSeconds);\n            _outboundSpeedRecords.Add(outboundSpeed);\n            Logging.Debug(\n                $"{_currentServer.FriendlyName()}: current/max inbound {inboundSpeed}/{_inboundSpeedRecords.Max()} KiB/s, current/max outbound {outboundSpeed}/{_outboundSpeedRecords.Max()} KiB/s");\n        }\n        private async Task<ICMPResult> ICMPTest(Server server)
        {\n            Logging.Debug("Ping " + server.FriendlyName());\n            if (server.server == "") return null;\n            var result = new ICMPResult(server);\n            try\n            {\n                var IP =\n                    Dns.GetHostAddresses(server.server)\n                        .First(\n                            ip =>
                var ping = new Ping();\n                foreach (var _ in Enumerable.Range(0, Repeat))\n                {\n                    try\n                    {\n                        var reply = await ping.SendTaskAsync(IP, TimeoutMilliseconds);\n                        if (!reply.Status.Equals(IPStatus.Success))\n                        {\n                            result.RoundtripTime.Add((int?) reply.RoundtripTime);\n                        }
                    try\n                    {\n                        var reply = await ping.SendTaskAsync(IP, TimeoutMilliseconds);\n                        if (!reply.Status.Equals(IPStatus.Success))\n                        {\n                            result.RoundtripTime.Add((int?) reply.RoundtripTime);\n                        }\n                        else\n                        {\n                            result.RoundtripTime.Add(null);
                        //Do ICMPTest in a random frequency\n                        Thread.Sleep(TimeoutMilliseconds + new Random().Next()%TimeoutMilliseconds);\n                    }\n                    catch (Exception e)\n                    {\n                        Logging.Error($"An exception occured while eveluating {server.FriendlyName()}");\n                        Logging.LogUsefulException(e);\n                    }\n                }\n            }\n            catch (Exception e)
            FilterRawStatistics();\n        }\n        private async void AppendRecord()\n        {\n            //todo: option for icmp test\n            var icmpResults = TaskEx.WhenAll(_servers.Select(ICMPTest));\n            var currentServerRecord = new StatisticsRecord(_currentServer.Identifier(),\n                _inboundSpeedRecords, _outboundSpeedRecords, _latencyRecords);\n            foreach (var result in (await icmpResults).Where(result => result != null))\n            {
        private static void Append(DataList dataList, IEnumerable<DataUnit> extra)\n        {\n            var data = dataList.Concat(extra);\n            var dataLine = string.Join(Delimiter, data.Select(kv => kv.Value).ToArray());\n            string[] lines;\n            if (!File.Exists(AvailabilityStatisticsFile))\n            {\n                var headerLine = string.Join(Delimiter, data.Select(kv => kv.Key).ToArray());\n                lines = new[] { headerLine, dataLine };\n            }
            Set(controller.StatisticsConfiguration);\n            _servers = _controller.GetCurrentConfiguration().configs;\n        }\n        private bool IsValidRecord(StatisticsRecord record)\n        {\n            if (_config.ByHourOfDay)\n            {\n                var currentHour = DateTime.Now.Hour;\n                if (record.Timestamp == UnknownDateTime) return false;\n                if (!record.Timestamp.Hour.Equals(DateTime.Now.Hour)) return false;
            }\n        }\n        private void LoadRawStatistics()\n        {\n            try\n            {\n                var path = AvailabilityStatisticsFile;\n                Logging.Debug($"loading statistics from {path}");\n                if (!File.Exists(path))\n                {
                        return;\n                    }\n                }\n                RawStatistics = JsonConvert.DeserializeObject<Statistics>(File.ReadAllText(path)) ?? RawStatistics;
            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n            }\n        }\n        private DateTime ParseExactOrUnknown(string str)\n        {\n            DateTime dateTime;\n            return !DateTime.TryParseExact(str, DateTimePattern, null, DateTimeStyles.None, out dateTime)
        }\n        public void UpdateLatency(int latency)\n        {\n            _latencyRecords.Add(latency);\n        }\n        private static int GetSpeedInKiBPerSecond(long bytes, double seconds)\n        {\n        }
        }\n        private static int GetSpeedInKiBPerSecond(long bytes, double seconds)\n        {\n        }\n        private class ICMPResult\n        {\n            internal readonly List<int?> RoundtripTime = new List<int?>();\n            internal readonly Server Server;
            if (!_controller.availabilityStatistics.FilteredStatistics.TryGetValue(serverName, out statistics)) return;\n            IEnumerable<IGrouping<int, StatisticsRecord>> dataGroups;\n            if (allMode.Checked)\n            {\n                dataGroups = statistics.GroupBy(data => data.Timestamp.DayOfYear);\n                StatisticsChart.ChartAreas["DataArea"].AxisX.LabelStyle.Format = "MM/dd/yyyy";\n                StatisticsChart.ChartAreas["DataArea"].AxisX2.LabelStyle.Format = "MM/dd/yyyy";\n            }\n            else\n            {
            if (allMode.Checked)\n            {\n                dataGroups = statistics.GroupBy(data => data.Timestamp.DayOfYear);\n                StatisticsChart.ChartAreas["DataArea"].AxisX.LabelStyle.Format = "MM/dd/yyyy";\n                StatisticsChart.ChartAreas["DataArea"].AxisX2.LabelStyle.Format = "MM/dd/yyyy";\n            }\n            else\n            {\n                dataGroups = statistics.GroupBy(data => data.Timestamp.Hour);\n                StatisticsChart.ChartAreas["DataArea"].AxisX.LabelStyle.Format = "HH:00";
        private int ChoiceKeptMilliseconds\n            => (int) TimeSpan.FromMinutes(_controller.StatisticsConfiguration.ChoiceKeptMinutes).TotalMilliseconds;\n        public StatisticsStrategy(ShadowsocksController controller)\n        {\n            _controller = controller;\n            var servers = controller.GetCurrentConfiguration().configs;\n            var randomIndex = new Random().Next() % servers.Count();\n            _currentServer = servers[randomIndex];  //choose a server randomly at first\n            _timer = new Timer(ReloadStatisticsAndChooseAServer);\n        }
        }\n        //return the score by data\n        //server with highest score will be choosen\n        private float GetScore(string serverName)\n        {\n            var config = _controller.StatisticsConfiguration;\n            List<StatisticsRecord> records;\n            if (_filteredStatistics == null || !_filteredStatistics.TryGetValue(serverName, out records)) return 0;
            float factor;\n            float score = 0;\n            var averageRecord = new StatisticsRecord(serverName,\n                records.FindAll(record => record.MaxInboundSpeed != null).Select(record => record.MaxInboundSpeed.Value),\n                records.FindAll(record => record.MaxOutboundSpeed != null).Select(record => record.MaxOutboundSpeed.Value),\n                records.FindAll(record => record.AverageLatency != null).Select(record => record.AverageLatency.Value));\n            averageRecord.setResponse(records.Select(record => record.AverageResponse));\n            if (!config.Calculations.TryGetValue("PackageLoss", out factor)) factor = 0;\n            score += averageRecord.PackageLoss*factor ?? 0;\n            if (!config.Calculations.TryGetValue("AverageResponse", out factor)) factor = 0;
            if (!config.Calculations.TryGetValue("AverageResponse", out factor)) factor = 0;\n            score += averageRecord.AverageResponse*factor ?? 0;\n            if (!config.Calculations.TryGetValue("MinResponse", out factor)) factor = 0;\n            score += averageRecord.MinResponse*factor ?? 0;\n            if (!config.Calculations.TryGetValue("MaxResponse", out factor)) factor = 0;\n            score += averageRecord.MaxResponse*factor ?? 0;\n            Logging.Debug($"{JsonConvert.SerializeObject(averageRecord, Formatting.Indented)}");\n            return score;\n        }\n        private void ChooseNewServer(List<Server> servers)
            if (!config.Calculations.TryGetValue("MinResponse", out factor)) factor = 0;\n            score += averageRecord.MinResponse*factor ?? 0;\n            if (!config.Calculations.TryGetValue("MaxResponse", out factor)) factor = 0;\n            score += averageRecord.MaxResponse*factor ?? 0;\n            Logging.Debug($"{JsonConvert.SerializeObject(averageRecord, Formatting.Indented)}");\n            return score;\n        }\n        private void ChooseNewServer(List<Server> servers)\n        {\n            if (_filteredStatistics == null || servers.Count == 0)
            if (!config.Calculations.TryGetValue("MaxResponse", out factor)) factor = 0;\n            score += averageRecord.MaxResponse*factor ?? 0;\n            Logging.Debug($"{JsonConvert.SerializeObject(averageRecord, Formatting.Indented)}");\n            return score;\n        }\n        private void ChooseNewServer(List<Server> servers)\n        {\n            if (_filteredStatistics == null || servers.Count == 0)\n            {\n                return;
            return score;\n        }\n        private void ChooseNewServer(List<Server> servers)\n        {\n            if (_filteredStatistics == null || servers.Count == 0)\n            {\n                return;\n            }\n            try\n            {
            this.tableLayoutPanel1.SuspendLayout();\n            this.panel1.SuspendLayout();\n            this.panel3.SuspendLayout();\n            this.ServerGroupBox.SuspendLayout();\n            this.SuspendLayout();\n            // \n            // tableLayoutPanel1\n            // \n            this.tableLayoutPanel1.AutoSize = true;\n            this.tableLayoutPanel1.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;
            this.tableLayoutPanel1.Name = "tableLayoutPanel1";\n            this.tableLayoutPanel1.Padding = new System.Windows.Forms.Padding(7, 7, 7, 7);\n            this.tableLayoutPanel1.RowCount = 6;\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel1.RowCount = 6;\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.RemarksTextBox.Name = "RemarksTextBox";\n            this.label6.Location = new System.Drawing.Point(27, 197);\n            this.label6.Margin = new System.Windows.Forms.Padding(5, 0, 5, 0);\n            this.label6.Name = "label6";
            this.label6.Name = "label6";\n            this.label1.Location = new System.Drawing.Point(26, 15);\n            this.label1.Margin = new System.Windows.Forms.Padding(5, 0, 5, 0);\n            this.label1.Name = "label1";
            this.label1.Name = "label1";\n            this.label2.Location = new System.Drawing.Point(12, 51);\n            this.label2.Margin = new System.Windows.Forms.Padding(5, 0, 5, 0);\n            this.label2.Name = "label2";
            this.label2.Name = "label2";\n            this.ProxyPortTextBox.Location = new System.Drawing.Point(110, 158);\n            this.ProxyPortTextBox.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);\n            this.ProxyPortTextBox.Name = "ProxyPortTextBox";
            this.ProxyPortTextBox.Name = "ProxyPortTextBox";\n            this.label4.Location = new System.Drawing.Point(20, 161);\n            this.label4.Margin = new System.Windows.Forms.Padding(5, 0, 5, 0);\n            this.label4.Name = "label4";
            this.label4.Name = "label4";\n            this.label3.Location = new System.Drawing.Point(22, 87);\n            this.label3.Margin = new System.Windows.Forms.Padding(5, 0, 5, 0);\n            this.label3.Name = "label3";
            this.label3.Name = "label3";\n            this.IPTextBox.Location = new System.Drawing.Point(110, 12);\n            this.IPTextBox.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);\n            this.IPTextBox.Name = "IPTextBox";
            this.IPTextBox.Name = "IPTextBox";\n            this.ServerPortTextBox.Location = new System.Drawing.Point(110, 48);\n            this.ServerPortTextBox.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);\n            this.ServerPortTextBox.Name = "ServerPortTextBox";
            this.ServerPortTextBox.Name = "ServerPortTextBox";\n            this.PasswordTextBox.Location = new System.Drawing.Point(110, 84);\n            this.PasswordTextBox.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);\n            this.PasswordTextBox.Name = "PasswordTextBox";\n            this.PasswordTextBox.PasswordChar = '*';
            this.PasswordTextBox.Name = "PasswordTextBox";\n            this.PasswordTextBox.PasswordChar = '*';\n            this.label5.Location = new System.Drawing.Point(16, 124);\n            this.label5.Margin = new System.Windows.Forms.Padding(5, 0, 5, 0);\n            this.label5.Name = "label5";
            this.label5.Name = "label5";
            this.EncryptionSelect.Name = "EncryptionSelect";\n            this.notifyIcon1.Text = "Shadowsocks";\n            this.notifyIcon1.DoubleClick += new System.EventHandler(this.notifyIcon1_DoubleClick);\n            // \n            // panel2\n            // 
            this.notifyIcon1.Text = "Shadowsocks";\n            this.notifyIcon1.DoubleClick += new System.EventHandler(this.notifyIcon1_DoubleClick);\n            // \n            // panel2\n            // \n            this.panel2.Anchor = System.Windows.Forms.AnchorStyles.Top;\n            this.panel2.AutoSize = true;\n            this.panel2.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;\n            this.panel2.Location = new System.Drawing.Point(246, 263);\n            this.panel2.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);\n            this.panel2.Name = "panel2";\n            this.panel2.Size = new System.Drawing.Size(0, 0);
            this.notifyIcon1.DoubleClick += new System.EventHandler(this.notifyIcon1_DoubleClick);\n            // \n            // panel2\n            // \n            this.panel2.Anchor = System.Windows.Forms.AnchorStyles.Top;\n            this.panel2.AutoSize = true;\n            this.panel2.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;\n            this.panel2.Location = new System.Drawing.Point(246, 263);\n            this.panel2.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);\n            this.panel2.Name = "panel2";\n            this.panel2.Size = new System.Drawing.Size(0, 0);\n            this.panel2.TabIndex = 1;\n            // 
            this.panel2.Name = "panel2";\n            this.panel2.Size = new System.Drawing.Size(0, 0);\n            this.panel2.TabIndex = 1;\n            // \n            // OKButton\n            // \n            this.OKButton.DialogResult = System.Windows.Forms.DialogResult.OK;\n            this.OKButton.Location = new System.Drawing.Point(6, 6);\n            this.OKButton.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);\n            this.OKButton.Name = "OKButton";
            this.OKButton.Name = "OKButton";\n            this.MyCancelButton.Location = new System.Drawing.Point(130, 6);\n            this.MyCancelButton.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);\n            this.MyCancelButton.Name = "MyCancelButton";
            this.MyCancelButton.Name = "MyCancelButton";
            this.DeleteButton.Name = "DeleteButton";\n            this.AddButton.Location = new System.Drawing.Point(6, 6);\n            this.AddButton.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);\n            this.AddButton.Name = "AddButton";
            this.AddButton.Name = "AddButton";\n            this.ServerGroupBox.Location = new System.Drawing.Point(334, 18);\n            this.ServerGroupBox.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);\n            this.ServerGroupBox.Name = "ServerGroupBox";
            this.ServerGroupBox.Name = "ServerGroupBox";\n            this.ServerGroupBox.Padding = new System.Windows.Forms.Padding(5, 5, 5, 5);\n            this.ServerGroupBox.Size = new System.Drawing.Size(383, 307);\n            this.ServerGroupBox.TabIndex = 6;\n            this.ServerGroupBox.TabStop = false;\n            this.ServerGroupBox.Text = "Server";\n            // \n            // ServersListBox\n            // \n            this.ServersListBox.FormattingEnabled = true;\n            this.ServersListBox.ItemHeight = 20;\n            this.ServersListBox.Location = new System.Drawing.Point(18, 18);\n            this.ServersListBox.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);
            this.ServerGroupBox.TabIndex = 6;\n            this.ServerGroupBox.TabStop = false;\n            this.ServerGroupBox.Text = "Server";\n            // \n            // ServersListBox\n            // \n            this.ServersListBox.FormattingEnabled = true;\n            this.ServersListBox.ItemHeight = 20;\n            this.ServersListBox.Location = new System.Drawing.Point(18, 18);\n            this.ServersListBox.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);\n            this.ServersListBox.Name = "ServersListBox";
            this.ServersListBox.Name = "ServersListBox";
            {\n                GeositeUpdater.MergeAndWritePACFile();\n            }\n            return File.ReadAllText(PAC_FILE, Encoding.UTF8);\n        }\n        private void WatchPacFile()
            }\n            return File.ReadAllText(PAC_FILE, Encoding.UTF8);\n        }\n        private void WatchPacFile()\n        {\n            PACFileWatcher?.Dispose();
        }\n        private void WatchPacFile()\n        {\n            PACFileWatcher?.Dispose();\n            PACFileWatcher = new FileSystemWatcher(Directory.GetCurrentDirectory());\n            PACFileWatcher.NotifyFilter = NotifyFilters.LastWrite | NotifyFilters.FileName | NotifyFilters.DirectoryName;\n            PACFileWatcher.Filter = PAC_FILE;\n            PACFileWatcher.Changed += PACFileWatcher_Changed;\n            PACFileWatcher.Created += PACFileWatcher_Changed;\n            PACFileWatcher.Deleted += PACFileWatcher_Changed;
            return true;\n        }\n        public class UDPHandler\n        {\n            private Socket _local;\n            private Socket _remote;\n            private Server _server;\n            private byte[] _buffer = new byte[65536];\n            private IPEndPoint _localEndPoint;\n            private IPEndPoint _remoteEndPoint;
                ServersListBox.SelectedIndexChanged += ServersListBox_SelectedIndexChanged;\n                return true;\n            }\n            else\n                return false;\n        }\n        #region GetServerDetailsFromUI Check\n        private bool? CheckIPTextBox(out string address, bool isSave, bool isCopy)\n        {\n            address = null;
            }\n        }\n        private void DuplicateButton_Click(object sender, EventArgs e)\n        {\n            if (ValidateAndSaveSelectedServerDetails(isCopy: true))\n            {\n                Server currServer = _modifiedConfiguration.configs[_lastSelectedIndex];\n                Configuration.AddDefaultServerOrServer(_modifiedConfiguration, currServer, _lastSelectedIndex + 1);\n                LoadServerNameListToUI(_modifiedConfiguration);\n                _lastSelectedIndex = (ServersListBox.SelectedIndex = (_lastSelectedIndex + 1));
                LoadServerNameListToUI(_modifiedConfiguration);\n                _lastSelectedIndex = (ServersListBox.SelectedIndex = (_lastSelectedIndex + 1));\n            }\n        }\n        private void DeleteButton_Click(object sender, EventArgs e)\n        {\n            _modifiedConfiguration.configs.RemoveAt(_lastSelectedIndex);\n            if (_modifiedConfiguration.configs.Count == 0)\n            {\n                Configuration.AddDefaultServerOrServer(_modifiedConfiguration);
            }\n        }\n        private void DeleteButton_Click(object sender, EventArgs e)\n        {\n            _modifiedConfiguration.configs.RemoveAt(_lastSelectedIndex);\n            if (_modifiedConfiguration.configs.Count == 0)\n            {\n                Configuration.AddDefaultServerOrServer(_modifiedConfiguration);\n            }\n            LoadServerNameListToUI(_modifiedConfiguration);
            ServersListBox.BeginUpdate();\n            LoadServerNameListToUI(_modifiedConfiguration);\n            _lastSelectedIndex = newIndex;\n            ServersListBox.SelectedIndex = newIndex;
            ServersListBox.EndUpdate();\n            UpdateButtons();\n        }\n        private void OKButton_Click(object sender, EventArgs e)\n        {\n            if (SaveValidConfiguration())\n            {\n                Close();\n            }\n        }
                }\n                else\n                {\n                    realkey = _key;\n                }\n                if (_cipher == CIPHER_AES)\n                {\n                    PolarSSL.aes_init(ctx);\n                    // PolarSSL takes key length by bit\n                    // since we'll use CFB mode, here we both do enc, not dec
            }\n        }\n        static byte[] tempbuf = new byte[32768];\n        public override void Encrypt(byte[] buf, int length, byte[] outbuf, out int outlength)\n        {\n            if (_encryptCtx == null)\n            {\n                randBytes(outbuf, ivLen);\n                InitCipher(ref _encryptCtx, outbuf, true);\n                outlength = length + ivLen;
                            break;\n                        case CIPHER_BF:\n                            PolarSSL.blowfish_crypt_cfb64(_encryptCtx, PolarSSL.BLOWFISH_ENCRYPT, length, ref _encryptIVOffset, _encryptIV, buf, outbuf);\n                            break;\n                        case CIPHER_RC4:\n                            PolarSSL.arc4_crypt(_encryptCtx, length, buf, outbuf);\n                            break;\n                    }
                            break;\n                        case CIPHER_RC4:\n                            PolarSSL.arc4_crypt(_encryptCtx, length, buf, outbuf);\n                            break;\n                    }
                }\n            }\n        }\n        public override void Decrypt(byte[] buf, int length, byte[] outbuf, out int outlength)\n        {\n            if (_decryptCtx == null)\n            {\n                InitCipher(ref _decryptCtx, buf, false);\n                outlength = length - ivLen;\n                lock (tempbuf)
                            break;\n                        case CIPHER_BF:\n                            PolarSSL.blowfish_crypt_cfb64(_decryptCtx, PolarSSL.BLOWFISH_DECRYPT, length, ref _decryptIVOffset, _decryptIV, buf, outbuf);\n                            break;\n                        case CIPHER_RC4:\n                            PolarSSL.arc4_crypt(_decryptCtx, length, buf, outbuf);\n                            break;\n                    }
                            break;\n                        case CIPHER_RC4:\n                            PolarSSL.arc4_crypt(_decryptCtx, length, buf, outbuf);\n                            break;\n                    }
                }\n            }\n        }\n        #region IDisposable\n        private bool _disposed;\n        public override void Dispose()\n        {\n            Dispose(true);\n            GC.SuppressFinalize(this);\n        }
                if (_encryptCtx != null)\n                {\n                    lock (_encryptCtx)\n                    {\n                        switch (_cipher)\n                        {\n                            case CIPHER_AES:\n                                PolarSSL.aes_free(_encryptCtx);\n                                break;\n                            case CIPHER_BF:
                    }\n                }\n                if (_decryptCtx != null)\n                {\n                    lock (_decryptCtx)\n                    {\n                        switch (_cipher)\n                        {\n                            case CIPHER_AES:\n                                PolarSSL.aes_free(_decryptCtx);
            }\n        }\n        #endregion\n    }\n}
Content-Type: application/x-ns-proxy-autoconfig\nContent-Length: { Encoding.UTF8.GetBytes(pacContent).Length}\nConnection: Close
Connection: Close
            {\n                using (var fs = new FileStream(path, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))\n                using (var sr = new StreamReader(fs, encoding))\n                {\n                    return sr.ReadToEnd();\n                }\n            }\n            catch (Exception ex)\n            {\n                Logging.Error(ex);
            }\n        }\n    }\n}
        protected ulong _encryptIC;\n        protected ulong _decryptIC;\n        protected byte[] _encryptBuf;\n        protected byte[] _decryptBuf;\n        public SodiumEncryptor(string method, string password)\n            : base(method, password)\n        {\n            InitKey(method, password);\n            _encryptBuf = new byte[MAX_INPUT_SIZE + SODIUM_BLOCK_SIZE];\n            _decryptBuf = new byte[MAX_INPUT_SIZE + SODIUM_BLOCK_SIZE];
            ulong ic;\n            byte[] sodiumBuf;\n            byte[] iv;\n            if (isCipher)\n            {\n                bytesRemaining = _encryptBytesRemaining;\n                ic = _encryptIC;\n                sodiumBuf = _encryptBuf;\n                iv = _encryptIV;\n            }
[assembly: AssemblyDescription("")]\n[assembly: AssemblyConfiguration("")]\n[assembly: AssemblyCompany("clowwindy")]\n[assembly: AssemblyProduct("Shadowsocks")]\n[assembly: AssemblyCopyright("Copyright © clowwindy 2014")]\n[assembly: AssemblyTrademark("")]\n[assembly: AssemblyCulture("")]\n// 将 ComVisible 设置为 false 使此程序集中的类型\n// 对 COM 组件不可见。如果需要从 COM 访问此程序集中的类型，\n// 则将该类型上的 ComVisible 属性设置为 true。
[assembly: AssemblyCopyright("Copyright © clowwindy 2014")]\n[assembly: AssemblyTrademark("")]\n[assembly: AssemblyCulture("")]\n// 将 ComVisible 设置为 false 使此程序集中的类型\n// 对 COM 组件不可见。如果需要从 COM 访问此程序集中的类型，\n// 则将该类型上的 ComVisible 属性设置为 true。\n[assembly: ComVisible(false)]\n// 如果此项目向 COM 公开，则下列 GUID 用于类型库的 ID\n[assembly: Guid("f8334709-4309-436a-8bbd-6165dcf4a660")]\n// 程序集的版本信息由下面四个值组成:
using System.Collections.Generic;\nusing System.IO;\nusing System.Runtime.InteropServices;\nusing System.Windows.Forms;\nnamespace shadowsocks_csharp\n{\n    static class Program\n    {\n        [DllImport("Kernel32.dll")]\n        private static extern IntPtr LoadLibrary(string path);
                FileStream fs = new FileStream("shadowsocks.log", FileMode.Append);\n                TextWriter tmp = Console.Out;\n                StreamWriter sw = new StreamWriter(fs);\n                sw.AutoFlush = true;\n                Console.SetOut(sw);\n                Console.SetError(sw);\n            }\n            catch (IOException e)\n            {\n                Console.WriteLine(e.ToString());
                foreach(string domain in domains)\n                {\n                    string last_root_domain = null;\n                    int pos;\n                    pos = domain.LastIndexOf('.');\n                    last_root_domain = domain.Substring(pos + 1);\n                    if (!tldIndex.Contains(last_root_domain))\n                        continue;\n                    while(pos > 0)\n                    {
                        continue;\n                    while(pos > 0)\n                    {\n                        pos = domain.LastIndexOf('.', pos - 1);\n                        last_root_domain = domain.Substring(pos + 1);\n                        if (tldIndex.Contains(last_root_domain))\n                            continue;\n                        else\n                            break;\n                    }
            {\n                string[] tlds = GetTlds();\n                TldIndex index = new TldIndex();\n                foreach (string tld in tlds)\n                {\n                    index.Add(tld);\n                }\n                return index;\n            }\n            private string[] GetBuildIn()
                foreach (string tld in tlds)\n                {\n                    index.Add(tld);\n                }\n                return index;\n            }\n            private string[] GetBuildIn()\n            {\n                string[] buildin = null;\n                byte[] builtinGZ = Resources.builtin_txt;
                        dic.Add(tld, tld);\n                    }\n                }\n                public bool Contains(string tld)\n                {\n                    if (dic.ContainsKey(tld))\n                        return true;\n                    foreach(string pattern in patterns)\n                    {\n                        if (Regex.IsMatch(tld, pattern))
            }\n        }\n    }\n}
                }\n            }\n        }\n        public void UpdateLatency(Model.Server server, TimeSpan latency)\n        {\n            Logging.Debug($"latency: {server.FriendlyName()} {latency}");\n            ServerStatus status;\n            if (_serverStatus.TryGetValue(server, out status))\n            {\n                status.latency = latency;
            ServerStatus status;\n            if (_serverStatus.TryGetValue(server, out status))\n            {\n                status.latency = latency;\n                status.lastTimeDetectLatency = DateTime.Now;\n            }\n        }\n        public void UpdateLastRead(Model.Server server)\n        {\n            Logging.Debug($"last read: {server.FriendlyName()}");
            ServerStatus status;\n            if (_serverStatus.TryGetValue(server, out status))\n            {\n                status.lastRead = DateTime.Now;\n            }\n        }\n        public void UpdateLastWrite(Model.Server server)\n        {\n            Logging.Debug($"last write: {server.FriendlyName()}");\n            ServerStatus status;
            ServerStatus status;\n            if (_serverStatus.TryGetValue(server, out status))\n            {\n                status.lastWrite = DateTime.Now;\n            }\n        }\n        public void SetFailure(Model.Server server)\n        {\n            Logging.Debug($"failure: {server.FriendlyName()}");\n            ServerStatus status;
            ServerStatus status;\n            if (_serverStatus.TryGetValue(server, out status))\n            {\n                status.lastFailure = DateTime.Now;\n            }\n        }\n    }\n}
            {\n                Logging.LogUsefulException(e);\n            }\n            return false;\n        }\n        public static void UncompressFile(string fileName, byte[] content)\n        {\n            FileStream destinationFile = File.Create(fileName);
            }\n            return false;\n        }\n        public static void UncompressFile(string fileName, byte[] content)\n        {\n            FileStream destinationFile = File.Create(fileName);\n            // Because the uncompressed size of the file is unknown, \n            // we are using an arbitrary buffer size.\n            byte[] buffer = new byte[4096];\n            int n;
#endif\n        }\n        public static void LogUsefulException(Exception e)\n        {\n            // just log useful exceptions, not all of them\n            if (e is SocketException)\n            {\n                SocketException se = (SocketException)e;\n                if (se.SocketErrorCode == SocketError.ConnectionAborted)\n                {
        #endregion\n        public LogForm(ShadowsocksController controller, string filename)\n        {\n            this.controller = controller;\n            this.filename = filename;\n            InitializeComponent();\n            Icon = Icon.FromHandle(Resources.ssw128.GetHicon());\n            LogViewerConfig config = controller.GetConfigurationCopy().logViewer;\n            topMostTrigger = config.topMost;\n            wrapTextTrigger = config.wrapText;
            const long minScale = 50;\n            long maxSpeed = 0;\n            long lastInbound, lastOutbound;\n            lock (this)\n            {\n                if (traffic.Count == 0)\n                    return;\n                foreach (var trafficPerSecond in traffic)\n                {\n                    inboundPoints.Add(trafficPerSecond.inbound);
            }\n            if (maxSpeed > 0)\n            {\n                lastMaxSpeed -= lastMaxSpeed / 32;\n                maxSpeed = Math.Max(minScale, Math.Max(maxSpeed, lastMaxSpeed));\n                lastMaxSpeed = maxSpeed;\n            }\n            else\n            {\n                maxSpeed = lastMaxSpeed = minScale;
            if (trafficChart.IsHandleCreated)\n            {\n                trafficChart.Series["Inbound"].Points.DataBindY(inboundPoints);\n                trafficChart.Series["Outbound"].Points.DataBindY(outboundPoints);\n                trafficChart.ChartAreas[0].AxisY.LabelStyle.Format = "{0:0.##} " + bandwidthScale.unit_name;\n                trafficChart.ChartAreas[0].AxisY.Maximum = bandwidthScale.value;\n                inboundAnnotation.AnchorDataPoint = trafficChart.Series["Inbound"].Points.Last();\n                inboundAnnotation.Text = Utils.FormatBandwidth(lastInbound);\n                outboundAnnotation.AnchorDataPoint = trafficChart.Series["Outbound"].Points.Last();\n                outboundAnnotation.Text = Utils.FormatBandwidth(lastOutbound);
                inboundAnnotation.AnchorDataPoint = trafficChart.Series["Inbound"].Points.Last();\n                inboundAnnotation.Text = Utils.FormatBandwidth(lastInbound);\n                outboundAnnotation.AnchorDataPoint = trafficChart.Series["Outbound"].Points.Last();\n                outboundAnnotation.Text = Utils.FormatBandwidth(lastOutbound);\n                trafficChart.Annotations.Clear();\n                trafficChart.Annotations.Add(inboundAnnotation);\n                trafficChart.Annotations.Add(outboundAnnotation);\n            }\n        }\n        private void controller_TrafficChanged(object sender, EventArgs e)
                foreach (var trafficPerSecond in controller.traffic)\n                {\n                    traffic.Enqueue(new TrafficInfo(trafficPerSecond.inboundIncreasement, trafficPerSecond.outboundIncreasement));\n                }\n            }\n        }\n        private void UpdateTexts()\n        {\n            FileMenuItem.Text = I18N.GetString("&File");\n            OpenLocationMenuItem.Text = I18N.GetString("&Open Location");
                }\n            }\n        }\n        private void UpdateTexts()\n        {\n            FileMenuItem.Text = I18N.GetString("&File");\n            OpenLocationMenuItem.Text = I18N.GetString("&Open Location");\n            ExitMenuItem.Text = I18N.GetString("E&xit");\n            CleanLogsButton.Text = I18N.GetString("&Clean Logs");\n            ChangeFontButton.Text = I18N.GetString("Change &Font");
        }\n        /// <summary>\n        /// Return scaled bandwidth\n        /// </summary>\n        /// <param name="n">Raw bandwidth</param>\n        /// <returns>\n        public static BandwidthScaleInfo GetBandwidthScale(long n)\n        {\n            long scale = 1;\n            float f = n;\n            string unit = "B";\n            if (f > 1024)\n            {\n                f = f / 1024;\n                scale <<= 10;
        {\n            long scale = 1;\n            float f = n;\n            string unit = "B";\n            if (f > 1024)\n            {\n                f = f / 1024;\n                scale <<= 10;\n                unit = "KiB";\n            }
using Shadowsocks.Model;\nusing Shadowsocks.Proxy;\nusing Shadowsocks.Util.Sockets;\nnamespace Shadowsocks.Controller\n{\n    class TCPRelay : Listener.Service\n    {\n        private ShadowsocksController _controller;\n        private DateTime _lastSweepTime;\n        private Configuration _config;
{\n    public class Socks5Proxy : IProxy\n    {\n        private class FakeAsyncResult : IAsyncResult\n        {\n            public readonly Socks5State innerState;\n            private readonly IAsyncResult r;\n            public FakeAsyncResult(IAsyncResult orig, Socks5State state)\n            {\n                r = orig;
    {\n        private class FakeAsyncResult : IAsyncResult\n        {\n            public readonly Socks5State innerState;\n            private readonly IAsyncResult r;\n            public FakeAsyncResult(IAsyncResult orig, Socks5State state)\n            {\n                r = orig;\n                innerState = state;\n            }
{\n    public class HttpProxy : IProxy\n    {\n        private class FakeAsyncResult : IAsyncResult\n        {\n            public readonly HttpState innerState;\n            private readonly IAsyncResult r;\n            public FakeAsyncResult(IAsyncResult orig, HttpState state)\n            {\n                r = orig;
    {\n        private class FakeAsyncResult : IAsyncResult\n        {\n            public readonly HttpState innerState;\n            private readonly IAsyncResult r;\n            public FakeAsyncResult(IAsyncResult orig, HttpState state)\n            {\n                r = orig;\n                innerState = state;\n            }
{\n    public interface IProxy\n    {\n        EndPoint LocalEndPoint { get; }\n        EndPoint ProxyEndPoint { get; }\n        EndPoint DestEndPoint { get; }\n        void BeginConnectProxy(EndPoint remoteEP, AsyncCallback callback, object state);\n        void EndConnectProxy(IAsyncResult asyncResult);\n        void BeginConnectDest(EndPoint destEndPoint, AsyncCallback callback, object state);\n        void EndConnectDest(IAsyncResult asyncResult);
    {\n        EndPoint LocalEndPoint { get; }\n        EndPoint ProxyEndPoint { get; }\n        EndPoint DestEndPoint { get; }\n        void BeginConnectProxy(EndPoint remoteEP, AsyncCallback callback, object state);\n        void EndConnectProxy(IAsyncResult asyncResult);\n        void BeginConnectDest(EndPoint destEndPoint, AsyncCallback callback, object state);\n        void EndConnectDest(IAsyncResult asyncResult);\n        void BeginSend(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state);
{\n    public class DirectConnect : IProxy\n    {\n        private class FakeAsyncResult : IAsyncResult\n        {\n            public FakeAsyncResult(object state)\n            {\n                AsyncState = state;\n            }\n            public bool IsCompleted { get; } = true;
    {\n        private class FakeAsyncResult : IAsyncResult\n        {\n            public FakeAsyncResult(object state)\n            {\n                AsyncState = state;\n            }\n            public bool IsCompleted { get; } = true;\n            public WaitHandle AsyncWaitHandle { get; } = null;\n            public object AsyncState { get; }
        public const string Version = "2.5.8";\n        public void CheckUpdate(Configuration config)\n        {\n            // TODO test failures\n            WebClient http = new WebClient();\n            http.Headers.Add("User-Agent", "Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.3319.102 Safari/537.36");\n            http.Proxy = new WebProxy(IPAddress.Loopback.ToString(), config.localPort);\n            http.DownloadStringCompleted += http_DownloadStringCompleted;\n            http.DownloadStringAsync(new Uri(UpdateURL));\n        }
                {\n                    // sort versions\n                    SortVersions(versions);\n                    NewVersionFound = true;\n                    LatestVersionURL = versions[versions.Count - 1];\n                    LatestVersionNumber = ParseVersionFromURL(LatestVersionURL);\n                }\n                if (CheckUpdateCompleted != null)
                }\n                if (CheckUpdateCompleted != null)\n                {\n                    CheckUpdateCompleted(this, new EventArgs());\n                }\n            }
                {\n                    CheckUpdateCompleted(this, new EventArgs());\n                }\n            }\n            catch (Exception ex)\n            {\n                Logging.Debug(ex.ToString());\n                return;\n            }\n        }
                }\n            }\n            catch (Exception ex)\n            {\n                Logging.Debug(ex.ToString());\n                return;\n            }\n        }\n    }\n}
            LoadCurrentConfiguration();\n            Configuration config = controller.GetConfigurationCopy();\n            if (config.autoCheckUpdate)\n            {\n                _isStartupChecking = true;\n                updateChecker.CheckUpdate(config);\n            }\n            if (config.isDefault)

using Shadowsocks.Controller;\nnamespace Shadowsocks.Encryption.Stream\n{\n    public abstract class StreamEncryptor\n        : EncryptorBase\n    {\n        // for UDP only\n        protected static byte[] _udpTmpBuf = new byte[65536];\n        // every connection should create its own buffer\n        private ByteCircularBuffer _encCircularBuffer = new ByteCircularBuffer(TCPHandler.BufferSize * 2);\n        private ByteCircularBuffer _decCircularBuffer = new ByteCircularBuffer(TCPHandler.BufferSize * 2);\n        protected Dictionary<string, EncryptorInfo> ciphers;
        protected Dictionary<string, EncryptorInfo> ciphers;\n        protected byte[] _encryptIV;\n        protected byte[] _decryptIV;\n        // Is first packet\n        protected bool _decryptIVReceived;\n        protected bool _encryptIVSent;\n        protected string _method;\n        protected int _cipher;\n        // internal name in the crypto library\n        protected string _innerLibName;
        }\n        private void OKButton_Click(object sender, EventArgs e)\n        {\n            // try to register, notify to change settings if failed\n            if (!RegisterAllHotkeys(out _)) // declare out as an inline discard variable\n            {\n                MessageBox.Show(I18N.GetString("Register hotkey failed"));
            }\n            // All check passed, saving\n            SaveConfig();\n            this.Close();\n        }\n        private void RegisterAllButton_Click(object sender, EventArgs e)\n        {\n            RegisterAllHotkeys(out _);  // declare out as an inline discard variable\n        }\n        private bool RegisterAllHotkeys(out string failureInfoStr)\n        {
        }\n        private void RegisterAllButton_Click(object sender, EventArgs e)\n        {\n            RegisterAllHotkeys(out _);  // declare out as an inline discard variable\n        }\n        private bool RegisterAllHotkeys(out string failureInfoStr)\n        {\n            bool isSuccess = true;\n            StringBuilder failureInfo = new StringBuilder();\n            foreach (var tb in _allTextBoxes)
        }\n        private bool TryRegHotkey(TextBox tb)\n        {\n            var hotkey = HotKeys.Str2HotKey(tb.Text);\n            if (hotkey == null)\n            {\n                MessageBox.Show(string.Format(I18N.GetString("Cannot parse hotkey: {0}"), tb.Text));\n                tb.Clear();\n                return false;\n            }
            lb.BackColor = regResult ? Color.Green : Color.Yellow;\n            return regResult;\n        }\n        private static void UnregPrevHotkey(HotKeys.HotKeyCallBackHandler cb)\n        {\n            GlobalHotKey.HotKey prevHotKey;\n            if (HotKeys.IsCallbackExists(cb, out prevHotKey))\n            {\n                // unregister previous one\n                HotKeys.Unregister(prevHotKey);\n            }
            }\n        }\n        private void SaveConfig()\n        {\n            _modifiedHotkeyConfig.SwitchSystemProxy = SwitchSystemProxyTextBox.Text;\n            _modifiedHotkeyConfig.SwitchSystemProxyMode = SwitchProxyModeTextBox.Text;\n            _modifiedHotkeyConfig.SwitchAllowLan = SwitchAllowLanTextBox.Text;\n            _modifiedHotkeyConfig.ShowLogs = ShowLogsTextBox.Text;\n            _modifiedHotkeyConfig.ServerMoveUp = ServerMoveUpTextBox.Text;\n            _modifiedHotkeyConfig.ServerMoveDown = ServerMoveDownTextBox.Text;
        }\n        #region Prepare hotkey\n        /// <summary>\n        /// Find correct callback and corresponding label\n        /// </summary>\n        /// <param name="tb"></param>\n        /// <param name="cb"></param>\n        /// <param name="lb"></param>\n        private void PrepareForHotkey(TextBox tb, out HotKeys.HotKeyCallBackHandler cb, out Label lb)\n        {
        }\n    }\n}
        public HighAvailabilityStrategy(ShadowsocksController controller)\n        {\n            _controller = controller;\n            _random = new Random();\n            _serverStatus = new Dictionary<Server, ServerStatus>();\n        }\n        public string Name\n        {\n            get { return I18N.GetString("High Availability"); }\n        }
        }\n        public Server GetAServer(IStrategyCallerType type, System.Net.IPEndPoint localIPEndPoint)\n        {\n            // TODO don't choose new server too frequently\n            ChooseNewServer();\n            return _currentServer;
namespace Shadowsocks.Model\n{\n    [Serializable]\n    public class StatisticsStrategyConfiguration\n    {
        {\n            var matches = UrlFinder.Matches(ssURL);\n            if (matches.Count <= 0) return null;\n            List<Server> servers = new List<Server>();\n            foreach (Match match in matches)\n            {\n                Server tmp = new Server();\n                var base64 = match.Groups["base64"].Value;\n                var tag = match.Groups["tag"].Value;\n                if (!tag.IsNullOrEmpty())
        }\n        public string Identifier()\n        {\n            return server + ':' + server_port;\n        }\n    }\n}
        {\n            for (int i = 0; i < length; i++)\n            {\n                buf[i] = encryptTable[buf[i]];\n            }\n        }\n        public void Decrypt(byte[] buf, int length)\n        {\n            for (int i = 0; i < length; i++)\n            {
            {\n                buf[i] = encryptTable[buf[i]];\n            }\n        }\n        public void Decrypt(byte[] buf, int length)\n        {\n            for (int i = 0; i < length; i++)\n            {\n                buf[i] = decryptTable[buf[i]];\n            }
        {\n            for (int i = 0; i < length; i++)\n            {\n                buf[i] = decryptTable[buf[i]];\n            }\n        }\n    }\n}
            {\n                buf[i] = decryptTable[buf[i]];\n            }\n        }\n    }\n}
using System.Net.NetworkInformation;\nusing System.Threading;\nusing Shadowsocks.Model;\nnamespace Shadowsocks.Controller.Strategy\n{\n    class SimplyChooseByStatisticsStrategy : IStrategy\n    {\n        private readonly ShadowsocksController _controller;\n        private Server _currentServer;\n        private readonly Timer _timer;
        private Server _currentServer;\n        private readonly Timer _timer;\n        private Dictionary<string, StatisticsData> _statistics;\n        private const int CachedInterval = 30*60*1000; //choose a new server every 30 minutes\n        private const int RetryInterval = 2*60*1000; //choose a new server every 30 minutes\n        public SimplyChooseByStatisticsStrategy(ShadowsocksController controller)\n        {\n            _controller = controller;\n            var servers = controller.GetCurrentConfiguration().configs;\n            var randomIndex = new Random().Next() % servers.Count();
        public SimplyChooseByStatisticsStrategy(ShadowsocksController controller)\n        {\n            _controller = controller;\n            var servers = controller.GetCurrentConfiguration().configs;\n            var randomIndex = new Random().Next() % servers.Count();\n            _currentServer = servers[randomIndex];  //choose a server randomly at first
            _currentServer = servers[randomIndex];  //choose a server randomly at first\n            var servers = _controller.GetCurrentConfiguration().configs;\n            LoadStatistics();\n            ChooseNewServer(servers);\n        }
            LoadStatistics();\n            ChooseNewServer(servers);\n        }\n        /*\n        return a dict:\n        {\n            'ServerFriendlyName1':StatisticsData,\n            'ServerFriendlyName2':...\n        }\n        */
                {  \n                   LogWhenEnabled($"Switch to server: {bestResult.server.FriendlyName()} by package loss:{1 - bestResult.score}");\n                }\n                _currentServer = bestResult.server;\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n            }\n        }
                }\n                _currentServer = bestResult.server;\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n            }\n        }\n        private void LogWhenEnabled(string log)\n        {
        {\n            if (_controller.GetCurrentStrategy()?.ID == ID) //output when enabled\n            {\n                Console.WriteLine(log);\n            }\n        }\n        public string ID => "com.shadowsocks.strategy.scbs";\n        public string Name => I18N.GetString("Choose By Total Package Loss");
        }\n        public string ID => "com.shadowsocks.strategy.scbs";\n        public string Name => I18N.GetString("Choose By Total Package Loss");\n        public Server GetAServer(IStrategyCallerType type, IPEndPoint localIPEndPoint)\n        {\n            var oldServer = _currentServer;
        public Server GetAServer(IStrategyCallerType type, IPEndPoint localIPEndPoint)\n        {\n            var oldServer = _currentServer;\n            if (oldServer == null)\n            {\n                ChooseNewServer(_controller.GetCurrentConfiguration().configs);\n            }
            return _currentServer;  //current server cached for CachedInterval\n        }\n        public void ReloadServers()\n        {\n            ChooseNewServer(_controller.GetCurrentConfiguration().configs);\n            Logging.Debug($"failure: {server.FriendlyName()}");
        }\n        public void UpdateLastRead(Server server)\n        {\n            //TODO: combine this part of data with ICMP statics\n        }\n        public void UpdateLastWrite(Server server)\n        {\n            //TODO: combine this part of data with ICMP statics\n        }\n        public void UpdateLatency(Server server, TimeSpan latency)
                _isFirstRun = false;\n            }\n            if (_updated)\n            {\n                ShowBalloonTip(\n                    I18N.GetString("Updated"),\n                    I18N.GetString("updated"),\n                    ToolTipIcon.Info,\n                    0\n                );
                MessageBox.Show(\n            if (Interlocked.Increment(ref exited) == 1)\n            {
        }\n        private static void SystemEvents_PowerModeChanged(object sender, PowerModeChangedEventArgs e)\n        {\n            switch (e.Mode)\n            {\n                case PowerModes.Resume:\n                    Logging.Info("os wake up");\n                    if (_controller != null)\n                    {\n                        System.Timers.Timer timer = new System.Timers.Timer(10 * 1000);
        }\n        public static bool IsWinVistaOrHigher() {\n            return Environment.OSVersion.Version.Major > 5;\n        }\n        [DllImport("kernel32.dll")]\n        [return: MarshalAs(UnmanagedType.Bool)]\n        private static extern bool SetProcessWorkingSetSize(IntPtr process,\n            UIntPtr minimumWorkingSetSize, UIntPtr maximumWorkingSetSize);\n    }\n}
using Shadowsocks.Model;\nusing Shadowsocks.Util.SystemProxy;\nnamespace Shadowsocks.Controller\n{\n    public static class SystemProxy\n    {
namespace Shadowsocks.Controller\n{\n    public static class SystemProxy\n    {
        private static string GetTimestamp(DateTime value)\n        {\n            return value.ToString("yyyyMMddHHmmssfff");\n        }\n        public static void Update(Configuration config, bool forceDisable)\n        {\n            bool global = config.global;\n            bool enabled = config.enabled;\n            if (forceDisable)\n            {
                }\n                else\n                {\n                    string pacUrl;\n                    if (config.useOnlinePac && !config.pacUrl.IsNullOrEmpty())\n                        pacUrl = config.pacUrl;\n                    else\n                        pacUrl = $"http://127.0.0.1:{config.localPort}/pac?t={GetTimestamp(DateTime.Now)}";\n                    WinINet.SetIEProxy(true, false, "", pacUrl);
                }\n            }\n            else\n            {\n                WinINet.SetIEProxy(false, false, "", "");
            }\n        }\n    }\n}
            var defaultValue = registry.GetValue("DefaultConnectionSettings");\n            try\n            {\n                var connections = registry.GetValueNames();\n                foreach (var each in connections)\n                {\n                    if (!(each.Equals("DefaultConnectionSettings")\n                        || each.Equals("LAN Connection")\n                        || each.Equals("SavedLegacySettings")))\n                    {
                {\n                    if (!(each.Equals("DefaultConnectionSettings")\n                        || each.Equals("LAN Connection")\n                        || each.Equals("SavedLegacySettings")))\n                    {\n                        //set all the connections's proxy as the lan\n                        registry.SetValue(each, defaultValue);\n                    }\n                }\n                NotifyIE();\n            }
                Logging.LogUsefulException(e);\n            }\n        }\n        /// <summary>\n        /// Checks or unchecks the IE Options Connection setting of "Automatically detect Proxy"\n        /// </summary>\n            var registry = Registry.CurrentUser
        }\n        /// <summary>\n        /// Checks or unchecks the IE Options Connection setting of "Automatically detect Proxy"\n        /// </summary>\n        /// <param name="set">Provide 'true' if you want to check the 'Automatically detect Proxy' check box. To uncheck, pass 'false'</param>\n        private static void IEAutoDetectProxy(bool set)\n        {\n            var registry = Registry.CurrentUser\n                .OpenSubKey(@"Software\Microsoft\Windows\CurrentVersion\Internet Settings\Connections", true);\n            var defConnection = (byte[])registry.GetValue("DefaultConnectionSettings");\n            var savedLegacySetting = (byte[])registry.GetValue("SavedLegacySettings");
            if (set)\n            {\n                defConnection[8] = (byte)(defConnection[8] | 8);\n                savedLegacySetting[8] = (byte)(savedLegacySetting[8] | 8);\n            }\n            else\n            {\n                defConnection[8] = (byte)(defConnection[8] & ~8);\n                savedLegacySetting[8] = (byte)(savedLegacySetting[8] & ~8);\n            }
            }\n            else\n            {\n                defConnection[8] = (byte)(defConnection[8] & ~8);\n                savedLegacySetting[8] = (byte)(savedLegacySetting[8] & ~8);\n            }\n            BitConverter.GetBytes(unchecked(BitConverter.ToUInt32(defConnection, 4) + 1)).CopyTo(defConnection, 4);\n            BitConverter.GetBytes(unchecked(BitConverter.ToUInt32(savedLegacySetting, 4) + 1)).CopyTo(savedLegacySetting, 4);\n            registry.SetValue("DefaultConnectionSettings", defConnection);\n            registry.SetValue("SavedLegacySettings", savedLegacySetting);
            }\n            BitConverter.GetBytes(unchecked(BitConverter.ToUInt32(defConnection, 4) + 1)).CopyTo(defConnection, 4);\n            BitConverter.GetBytes(unchecked(BitConverter.ToUInt32(savedLegacySetting, 4) + 1)).CopyTo(savedLegacySetting, 4);\n            registry.SetValue("DefaultConnectionSettings", defConnection);\n            registry.SetValue("SavedLegacySettings", savedLegacySetting);\n        }\n    }\n}
                return true;\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine("Exception caught in process: {0}",\n                                  ex.ToString());\n            }\n            return false;\n        }\n        public static void UncompressFile(string fileName, byte[] content)
            {\n                Console.WriteLine("Exception caught in process: {0}",\n                                  ex.ToString());\n            }\n            return false;\n        }\n        public static void UncompressFile(string fileName, byte[] content)\n        {\n            // Because the uncompressed size of the file is unknown,
            }\n            return false;\n        }\n        public static void UncompressFile(string fileName, byte[] content)\n        {\n            // Because the uncompressed size of the file is unknown,\n            // we are using an arbitrary buffer size.\n            byte[] buffer = new byte[4096];\n            int n;\n            using(var fs = File.Create(fileName))\n            using (var input = new GZipStream(
            // Because the uncompressed size of the file is unknown,\n            // we are using an arbitrary buffer size.\n            byte[] buffer = new byte[4096];\n            int n;\n            using(var fs = File.Create(fileName))\n            using (var input = new GZipStream(\n                new MemoryStream(content),\n                CompressionMode.Decompress, false))\n            {\n                while ((n = input.Read(buffer, 0, buffer.Length)) > 0)\n                {
                CompressionMode.Decompress, false))\n            {\n                while ((n = input.Read(buffer, 0, buffer.Length)) > 0)\n                {\n                    fs.Write(buffer, 0, n);\n                }\n            }\n        }\n    }
                }\n            }\n        }\n    }\n}
        }\n    }\n}
            this.tableLayoutPanel1.SuspendLayout();\n            this.panel1.SuspendLayout();\n            this.panel3.SuspendLayout();\n            this.groupBox1.SuspendLayout();\n            this.SuspendLayout();\n            // \n            // tableLayoutPanel1\n            // \n            this.tableLayoutPanel1.AutoSize = true;\n            this.tableLayoutPanel1.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;\n            this.tableLayoutPanel1.ColumnCount = 2;
            this.SuspendLayout();\n            // \n            // tableLayoutPanel1\n            // \n            this.tableLayoutPanel1.AutoSize = true;\n            this.tableLayoutPanel1.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;\n            this.tableLayoutPanel1.ColumnCount = 2;\n            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());\n            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());\n            this.tableLayoutPanel1.Controls.Add(this.label1, 0, 0);
            this.tableLayoutPanel1.AutoSize = true;\n            this.tableLayoutPanel1.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;\n            this.tableLayoutPanel1.ColumnCount = 2;\n            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());\n            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());\n            this.tableLayoutPanel1.Controls.Add(this.label1, 0, 0);\n            this.tableLayoutPanel1.Controls.Add(this.label2, 0, 1);\n            this.tableLayoutPanel1.Controls.Add(this.ProxyPortTextBox, 1, 4);\n            this.tableLayoutPanel1.Controls.Add(this.label4, 0, 4);
            this.tableLayoutPanel1.Controls.Add(this.label1, 0, 0);\n            this.tableLayoutPanel1.Controls.Add(this.label2, 0, 1);\n            this.tableLayoutPanel1.Controls.Add(this.ProxyPortTextBox, 1, 4);\n            this.tableLayoutPanel1.Controls.Add(this.label4, 0, 4);\n            this.tableLayoutPanel1.Controls.Add(this.label3, 0, 2);\n            this.tableLayoutPanel1.Controls.Add(this.IPTextBox, 1, 0);\n            this.tableLayoutPanel1.Controls.Add(this.ServerPortTextBox, 1, 1);\n            this.tableLayoutPanel1.Controls.Add(this.PasswordTextBox, 1, 2);
            this.tableLayoutPanel1.Controls.Add(this.label3, 0, 2);\n            this.tableLayoutPanel1.Controls.Add(this.IPTextBox, 1, 0);\n            this.tableLayoutPanel1.Controls.Add(this.ServerPortTextBox, 1, 1);\n            this.tableLayoutPanel1.Controls.Add(this.PasswordTextBox, 1, 2);\n            this.tableLayoutPanel1.Controls.Add(this.label5, 0, 3);\n            this.tableLayoutPanel1.Controls.Add(this.EncryptionSelect, 1, 3);\n            this.tableLayoutPanel1.Location = new System.Drawing.Point(8, 21);\n            this.tableLayoutPanel1.Margin = new System.Windows.Forms.Padding(5);\n            this.tableLayoutPanel1.Name = "tableLayoutPanel1";
            this.tableLayoutPanel1.Controls.Add(this.IPTextBox, 1, 0);\n            this.tableLayoutPanel1.Controls.Add(this.ServerPortTextBox, 1, 1);\n            this.tableLayoutPanel1.Controls.Add(this.PasswordTextBox, 1, 2);\n            this.tableLayoutPanel1.Controls.Add(this.label5, 0, 3);\n            this.tableLayoutPanel1.Controls.Add(this.EncryptionSelect, 1, 3);\n            this.tableLayoutPanel1.Location = new System.Drawing.Point(8, 21);\n            this.tableLayoutPanel1.Margin = new System.Windows.Forms.Padding(5);\n            this.tableLayoutPanel1.Name = "tableLayoutPanel1";\n            this.tableLayoutPanel1.Padding = new System.Windows.Forms.Padding(5);\n            this.tableLayoutPanel1.RowCount = 5;
            this.tableLayoutPanel1.Name = "tableLayoutPanel1";\n            this.tableLayoutPanel1.Padding = new System.Windows.Forms.Padding(5);\n            this.tableLayoutPanel1.RowCount = 5;\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.panel1.AutoSize = true;\n            this.panel1.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;\n            this.panel1.Controls.Add(this.MyCancelButton);\n            this.panel1.Controls.Add(this.OKButton);\n            this.panel1.Location = new System.Drawing.Point(275, 247);\n            this.panel1.Margin = new System.Windows.Forms.Padding(0);\n            this.panel1.Name = "panel1";
            this.panel1.Name = "panel1";
            this.SuspendLayout();\n            // \n            // StatisticsChart\n            // \n            this.StatisticsChart.BackColor = System.Drawing.Color.Transparent;
            this.splitContainer2.TabIndex = 7;\n            // \n            // numericUpDown2\n            // \n            this.numericUpDown2.Location = new System.Drawing.Point(16, 145);\n            this.numericUpDown2.Margin = new System.Windows.Forms.Padding(3, 4, 3, 4);\n            this.numericUpDown2.Maximum = new decimal(new int[] {\n            60,\n            0,\n            0,\n            0});
            this.numericUpDown1.Maximum = new decimal(new int[] {\n            10,\n            0,\n            0,\n            0});\n            this.numericUpDown1.Name = "numericUpDown1";
using System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Net;\nusing System.Net.NetworkInformation;\nusing System.Runtime.InteropServices;\nusing System.Text;\nusing Shadowsocks.Model;\nusing Shadowsocks.Properties;
using System.Text;\nusing Shadowsocks.Model;\nusing Shadowsocks.Properties;\nusing Shadowsocks.Util;\nnamespace Shadowsocks.Controller\n{\n    class PolipoRunner
using Shadowsocks.Util;\nnamespace Shadowsocks.Controller\n{\n    class PolipoRunner\n    {\n        private Process _process;\n        private int _runningPort;\n        static PolipoRunner()\n        {
        private int _runningPort;\n        static PolipoRunner()\n        {\n            try\n            {\n                FileManager.UncompressFile(Utils.GetTempPath("ss_privoxy.exe"), Resources.privoxy_exe);\n                FileManager.UncompressFile(Utils.GetTempPath("mgwz.dll"), Resources.mgwz_dll);\n            }\n            catch (IOException e)
            try\n            {\n                FileManager.UncompressFile(Utils.GetTempPath("ss_privoxy.exe"), Resources.privoxy_exe);\n                FileManager.UncompressFile(Utils.GetTempPath("mgwz.dll"), Resources.mgwz_dll);\n            }\n            catch (IOException e)\n            {\n                Logging.LogUsefulException(e);\n            }\n        }
            }\n            catch (IOException e)\n            {\n                Logging.LogUsefulException(e);\n            }\n        }\n        public int RunningPort\n        {\n            get\n            {
                _process = new Process();\n                // Configure the process using the StartInfo properties.\n                _process.StartInfo.FileName = "ss_privoxy.exe";\n                _process.StartInfo.Arguments = "privoxy.conf";\n                _process.StartInfo.WorkingDirectory = Utils.GetTempPath();\n                _process.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;\n                _process.StartInfo.UseShellExecute = true;\n                _process.StartInfo.CreateNoWindow = true;
                _process.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;\n                _process.StartInfo.UseShellExecute = true;\n                _process.StartInfo.CreateNoWindow = true;
using Shadowsocks.Properties;\nusing Shadowsocks.Util;\nnamespace Shadowsocks.Encryption\n{\n    public class PolarSSL
namespace Shadowsocks.Encryption\n{\n    public class PolarSSL\n    {\n        const string DLLNAME = "libsscrypto";\n        public const int AES_CTX_SIZE = 8 + 4 * 68;\n        public const int AES_ENCRYPT = 1;\n        public const int AES_DECRYPT = 0;\n        static PolarSSL()\n        {
using System.Diagnostics;\nusing System.IO;\nusing System.Threading;\nusing System.Windows.Forms;\nusing Shadowsocks.Controller;\nusing Shadowsocks.Util;\nusing Shadowsocks.View;\nnamespace Shadowsocks\n{\n    static class Program
            using (Mutex mutex = new Mutex(false, "Global\\Shadowsocks_" + Application.StartupPath.GetHashCode()))\n            {\n                Application.EnableVisualStyles();\n                Application.SetCompatibleTextRenderingDefault(false);\n                if (!mutex.WaitOne(0, false))\n                {\n                    Process[] oldProcesses = Process.GetProcessesByName("Shadowsocks");\n                    if (oldProcesses.Length > 0)\n                    {\n                        Process oldProcess = oldProcesses[0];
using Shadowsocks.Properties;\nusing Shadowsocks.Util;\nnamespace Shadowsocks.Encryption\n{\n    public class Sodium
namespace Shadowsocks.Encryption\n{\n    public class Sodium\n    {\n        const string DLLNAME = "libsscrypto";\n        static Sodium()\n        {\n            string dllPath = Utils.GetTempPath("libsscrypto.dll");
            try\n            {\n                FileManager.UncompressFile(dllPath, Resources.libsscrypto_dll);\n            }\n            catch (IOException)\n            {\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);
using Shadowsocks.Properties;\nusing Shadowsocks.Util;\nnamespace Shadowsocks.Encryption\n{\n    public class MbedTLS
namespace Shadowsocks.Encryption\n{\n    public class MbedTLS\n    {\n        const string DLLNAME = "libsscrypto";\n        static MbedTLS()\n        {\n            string dllPath = Utils.GetTempPath("libsscrypto.dll");
            try\n            {\n                FileManager.UncompressFile(dllPath, Resources.libsscrypto_dll);\n            }\n            catch (IOException ex)\n            {\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine(e.ToString());
using System.IO;\nusing System.Net.Sockets;\nusing System.Net;\nusing Shadowsocks.Util;\nnamespace Shadowsocks.Controller\n{\n    public class Logging\n    {\n        public static string LogFile;
namespace Shadowsocks.Controller\n{\n    public class Logging\n    {\n        public static string LogFile;\n        public static bool OpenLogFile()\n        {\n            try\n            {\n                LogFile = Utils.GetTempPath("shadowsocks.log");
                FileStream fs = new FileStream(LogFile, FileMode.Append);\n                StreamWriterWithTimestamp sw = new StreamWriterWithTimestamp(fs);\n                sw.AutoFlush = true;\n                Console.SetOut(sw);\n                Console.SetError(sw);\n                return true;\n            }\n            catch (IOException e)\n            {\n                Console.WriteLine(e.ToString());
            {\n                UpdatePACFromGFWList();\n                return;\n            }\n            List<string> lines = GFWListUpdater.ParseResult(File.ReadAllText(Utils.GetTempPath("gfwlist.txt")));\n            if (File.Exists(PACServer.USER_RULE_FILE))\n            {\n                string local = File.ReadAllText(PACServer.USER_RULE_FILE, Encoding.UTF8);\n                string[] rules = local.Split(new char[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);\n                foreach (string rule in rules)
            if (File.Exists(PACServer.USER_RULE_FILE))\n            {\n                string local = File.ReadAllText(PACServer.USER_RULE_FILE, Encoding.UTF8);\n                string[] rules = local.Split(new char[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);\n                foreach (string rule in rules)\n                {\n                    if (rule.StartsWith("!") || rule.StartsWith("["))\n                        continue;\n                    lines.Add(rule);\n                }
using Shadowsocks.Properties;\nusing Shadowsocks.Util;\nnamespace Shadowsocks.Controller\n{\n    public class GFWListUpdater\n    {\n        private const string GFWLIST_URL = "https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt";\n        private static string PAC_FILE = PACServer.PAC_FILE;
using Shadowsocks.Util;\nnamespace Shadowsocks.Controller\n{\n    public class GFWListUpdater\n    {\n        private const string GFWLIST_URL = "https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt";\n        private static string PAC_FILE = PACServer.PAC_FILE;\n        private static string USER_RULE_FILE = PACServer.USER_RULE_FILE;\n        private static string USER_ABP_FILE = PACServer.USER_ABP_FILE;
namespace Shadowsocks.Controller\n{\n    public class GFWListUpdater\n    {\n        private const string GFWLIST_URL = "https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt";\n        private static string PAC_FILE = PACServer.PAC_FILE;\n        private static string USER_RULE_FILE = PACServer.USER_RULE_FILE;\n        private static string USER_ABP_FILE = PACServer.USER_ABP_FILE;\n        public event EventHandler<ResultEventArgs> UpdateCompleted;\n        public event ErrorEventHandler Error;
using System.Collections.Generic;\nusing System.Net;\nusing System.Text.RegularExpressions;\nusing SimpleJson;\nusing Shadowsocks.Model;\nusing Shadowsocks.Util;\nnamespace Shadowsocks.Controller
using System.Text.RegularExpressions;\nusing SimpleJson;\nusing Shadowsocks.Model;\nusing Shadowsocks.Util;\nnamespace Shadowsocks.Controller\n{\n    public class UpdateChecker\n    {\n        private const string UpdateURL = "https://api.github.com/repos/shadowsocks/shadowsocks-windows/releases";
using SimpleJson;\nusing Shadowsocks.Model;\nusing Shadowsocks.Util;\nnamespace Shadowsocks.Controller\n{\n    public class UpdateChecker\n    {\n        private const string UpdateURL = "https://api.github.com/repos/shadowsocks/shadowsocks-windows/releases";\n        private const string UserAgent = "Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.3319.102 Safari/537.36";\n        private Configuration config;
            {\n                if (File.Exists(Path.Combine(Application.StartupPath, "shadowsocks_portable_mode.txt")))\n                    try\n                    {\n                        Directory.CreateDirectory(Path.Combine(Application.StartupPath, "temp"));\n                    }\n                    catch (Exception e)\n                    {\n                        TempPath = Path.GetTempPath();\n                        Logging.LogUsefulException(e);
            }\n            return TempPath;\n        }\n        // return a full path with filename combined which pointed to the temporary directory\n        public static string GetTempPath(string filename)\n        {\n            return Path.Combine(GetTempPath(), filename);\n        }\n        public static void ReleaseMemory(bool removePages)\n        {
        }\n        public static void ReleaseMemory(bool removePages)\n        {\n            // release any unused pages\n            // making the numbers look good in task manager\n            // this is totally nonsense in programming\n            // but good for those users who care\n            // making them happier with their everyday life\n            // which is part of user experience\n            GC.Collect(GC.MaxGeneration);
                traffic.Enqueue(current);\n                if (traffic.Count > queueMaxSize)\n                    traffic.Dequeue();\n                TrafficChanged?.Invoke(this, new EventArgs());\n                Thread.Sleep(1000);\n            }
                Thread.Sleep(1000);\n            }\n        }\n    }\n}
                var remote = session.Remote;\n                if (bytesRead > 0)\n                {\n                    SendToServer(bytesRead, session);
                }\n                else\n                {\n                    remote.Shutdown(SocketShutdown.Send);\n                    _remoteShutdown = true;\n                    CheckClose();\n                }\n            }\n            catch (Exception e)\n            {
        {\n            IStrategy strategy = GetCurrentStrategy();\n            if (strategy != null)\n            {\n                return strategy.GetAServer(type, localIPEndPoint, destEndPoint);\n            }\n            if (_config.index < 0)\n            {\n                _config.index = 0;\n            }
            }\n            if (_config.index < 0)\n            {\n                _config.index = 0;\n            }\n            return GetCurrentServer();\n        }\n        public void SaveServers(List<Server> servers, int localPort)\n        {\n            _config.configs = servers;
                {\n                    /*\n                     * Under PortableMode, we could identify it by the path of ss_privoxy.exe.\n                     */\n                    var path = process.MainModule.FileName;\n                    return Utils.GetTempPath("ss_privoxy.exe").Equals(path);\n                }\n                else
                     */\n                    var path = process.MainModule.FileName;\n                    return Utils.GetTempPath("ss_privoxy.exe").Equals(path);\n                }\n                else
                    return Utils.GetTempPath("ss_privoxy.exe").Equals(path);\n                }\n                else
                {\n                    var cmd = process.GetCommandLine();\n                    return cmd.Contains(UniqueConfigFile);\n                }\n            }\n            catch (Exception ex)\n            {\n                /*\n                 * Sometimes Process.GetProcessesByName will return some processes that\n                 * are already dead, and that will cause exceptions here.
                return false;\n            }\n        }\n        private int GetFreePort()\n        {\n            int defaultPort = 8123;\n            try\n            {\n                IPGlobalProperties properties = IPGlobalProperties.GetIPGlobalProperties();\n                IPEndPoint[] tcpEndPoints = properties.GetActiveTcpListeners();
                    if (isCipher)\n                    {\n                        _encryptIVOffset = ivOffset;\n                    }\n                    else\n                    {\n                        _decryptIVOffset = ivOffset;\n                    }\n                    break;\n                case CIPHER_RC4:
        {\n            // run it once before the multi-threading test to initialize global tables\n            RunSinglePolarSSLEncryptionThread();\n            List<Thread> threads = new List<Thread>();\n            for (int i = 0; i < 10; i++)\n            {\n                Thread t = new Thread(new ThreadStart(RunSinglePolarSSLEncryptionThread));\n                threads.Add(t);\n                t.Start();\n            }\n            foreach (Thread t in threads)
                threads.Add(t);\n                t.Start();\n            }\n            foreach (Thread t in threads)\n            {\n                t.Join();\n            }\n            Assert.IsFalse(encryptionFailed);\n        }\n        private static bool encryptionFailed = false;
        {\n            try\n            {\n                if (_lastSelectedIndex == -1 || _lastSelectedIndex >= _modifiedConfiguration.configs.Count)\n                {\n                    return true;\n                }\n                Server server = GetServerDetailsFromUI();
                Configuration.CheckServer(server);\n                _modifiedConfiguration.configs[_lastSelectedIndex] = server;\n                return true;\n            }\n            catch (Exception ex)\n            {\n                MessageBox.Show(ex.Message);
                _modifiedConfiguration.configs[_lastSelectedIndex] = server;\n                return true;\n            }\n            catch (Exception ex)\n            {\n                MessageBox.Show(ex.Message);\n            }\n            return false;
                return true;\n            }\n            catch (Exception ex)\n            {\n                MessageBox.Show(ex.Message);\n            }\n            return false;\n        }\n        private Server GetServerDetailsFromUI()\n        {
        {\n            if (ServersListBox.SelectedIndex >= 0 && ServersListBox.SelectedIndex < _modifiedConfiguration.configs.Count)\n            {\n                Server server = _modifiedConfiguration.configs[ServersListBox.SelectedIndex];\n                SetServerDetailsToUI(server);\n            }\n        }\n        private void SetServerDetailsToUI(Server server)\n        {\n            IPTextBox.Text = server.server;
        {\n            ServersListBox.Items.Clear();\n            foreach (Server server in configuration.configs)\n            {\n                ServersListBox.Items.Add(server.FriendlyName());\n            }\n        }\n        private void LoadCurrentConfiguration()\n        {\n            _modifiedConfiguration = controller.GetConfigurationCopy();
            {\n                ServersListBox.Items.Add(server.FriendlyName());\n            }\n        }\n        private void LoadCurrentConfiguration()\n        {\n            _modifiedConfiguration = controller.GetConfigurationCopy();\n            LoadServerNameListToUI(_modifiedConfiguration);\n            _lastSelectedIndex = _modifiedConfiguration.index;\n            if (_lastSelectedIndex < 0 || _lastSelectedIndex >= ServersListBox.Items.Count)
            _lastSelectedIndex = _modifiedConfiguration.index;\n            if (_lastSelectedIndex < 0 || _lastSelectedIndex >= ServersListBox.Items.Count)\n            {\n                _lastSelectedIndex = 0;\n            }\n            ServersListBox.SelectedIndex = _lastSelectedIndex;\n            UpdateButtons();\n            LoadSelectedServerDetails();\n            ProxyPortTextBox.Text = _modifiedConfiguration.localPort.ToString();
            PortableModeCheckBox.Checked = _modifiedConfiguration.portableMode;\n        }\n        private void ConfigForm_KeyDown(object sender, KeyEventArgs e)\n        {\n            // Sometimes the users may hit enter key by mistake, and the form will close without saving entries.\n            if (e.KeyCode == Keys.Enter)\n            {
        }\n        private void ConfigForm_KeyDown(object sender, KeyEventArgs e)\n        {\n            // Sometimes the users may hit enter key by mistake, and the form will close without saving entries.\n            if (e.KeyCode == Keys.Enter)\n            {\n                Server server = controller.GetCurrentServer();\n                if (!ValidateAndSaveSelectedServerDetails())\n                {\n                    return;\n                }
                {\n                    return;\n                }\n                if (_modifiedConfiguration.configs.Count == 0)\n                {\n                    MessageBox.Show(I18N.GetString("Please add at least one server"));\n                    return;\n                }\n                int localPort = int.Parse(ProxyPortTextBox.Text);\n                Configuration.CheckLocalPort(localPort);
            {\n                // why this won't cause stack overflow?\n                ServersListBox.SelectedIndex = _lastSelectedIndex;\n                return;\n            }\n            if (_lastSelectedIndex >= 0)\n            {\n                ServersListBox.Items[_lastSelectedIndex] = _modifiedConfiguration.configs[_lastSelectedIndex].FriendlyName();\n            }\n            UpdateButtons();\n            LoadSelectedServerDetails();
            _lastSelectedIndex = ServersListBox.SelectedIndex;\n        }\n        private void AddButton_Click(object sender, EventArgs e)\n        {\n            if (!ValidateAndSaveSelectedServerDetails())\n            {\n                return;\n            }\n            Server server = Configuration.GetDefaultServer();\n            _modifiedConfiguration.configs.Add(server);
            {\n                return;\n            }\n            Server server = Configuration.GetDefaultServer();\n            _modifiedConfiguration.configs.Add(server);\n            LoadServerNameListToUI(_modifiedConfiguration);\n            ServersListBox.SelectedIndex = _modifiedConfiguration.configs.Count - 1;\n            _lastSelectedIndex = ServersListBox.SelectedIndex;\n        }\n        private void DuplicateButton_Click(object sender, EventArgs e)
            ServersListBox.SelectedIndex = _modifiedConfiguration.configs.Count - 1;\n            _lastSelectedIndex = ServersListBox.SelectedIndex;\n        }\n        private void DuplicateButton_Click(object sender, EventArgs e)\n        {\n            if (!ValidateAndSaveSelectedServerDetails())\n            {\n                return;\n            }\n            Server currServer = _modifiedConfiguration.configs[_lastSelectedIndex];
            {\n                return;\n            }\n            Server currServer = _modifiedConfiguration.configs[_lastSelectedIndex];\n            var currIndex = _modifiedConfiguration.configs.IndexOf(currServer);\n            _modifiedConfiguration.configs.Insert(currIndex + 1, currServer);\n            LoadServerNameListToUI(_modifiedConfiguration);\n            ServersListBox.SelectedIndex = currIndex + 1;\n            _lastSelectedIndex = ServersListBox.SelectedIndex;\n        }
            ServersListBox.SelectedIndex = currIndex + 1;\n            _lastSelectedIndex = ServersListBox.SelectedIndex;\n        }\n        private void DeleteButton_Click(object sender, EventArgs e)\n        {\n            _lastSelectedIndex = ServersListBox.SelectedIndex;\n            if (_lastSelectedIndex >= 0 && _lastSelectedIndex < _modifiedConfiguration.configs.Count)\n            {\n                _modifiedConfiguration.configs.RemoveAt(_lastSelectedIndex);\n            }
            ServersListBox.SelectedIndex = _lastSelectedIndex;\n            LoadSelectedServerDetails();\n        }\n        private void OKButton_Click(object sender, EventArgs e)\n        {\n            if (!ValidateAndSaveSelectedServerDetails())\n            {\n                return;\n            }\n            if (_modifiedConfiguration.configs.Count == 0)
        }\n        private void OKButton_Click(object sender, EventArgs e)\n        {\n            if (!ValidateAndSaveSelectedServerDetails())\n            {\n                return;\n            }\n            if (_modifiedConfiguration.configs.Count == 0)\n            {\n                MessageBox.Show(I18N.GetString("Please add at least one server"));
            {\n                return;\n            }\n            if (_modifiedConfiguration.configs.Count == 0)\n            {\n                MessageBox.Show(I18N.GetString("Please add at least one server"));\n                return;\n            }\n            int localPort = int.Parse(ProxyPortTextBox.Text);\n            Configuration.CheckLocalPort(localPort);
        }\n        private void MoveUpButton_Click(object sender, EventArgs e)\n        {\n            if (!ValidateAndSaveSelectedServerDetails())\n            {\n                return;\n            }\n            if (ServersListBox.SelectedIndex > 0)\n            {\n                MoveConfigItem(-1);  // -1 means move backward
            {\n                return;\n            }\n            if (ServersListBox.SelectedIndex > 0)\n            {\n                MoveConfigItem(-1);  // -1 means move backward\n            }\n        }\n        private void MoveDownButton_Click(object sender, EventArgs e)\n        {
    {\n        const int CIPHER_AES = 1;\n        const int CIPHER_RC4 = 2;
        private IntPtr _encryptCtx = IntPtr.Zero;\n        private IntPtr _decryptCtx = IntPtr.Zero;\n        public PolarSSLEncryptor(string method, string password)
        public PolarSSLEncryptor(string method, string password)\n            : base(method, password)\n        {\n            InitKey(method, password);\n        }\n        protected override Dictionary<string, int[]> getCiphers()\n        {\n            return new Dictionary<string, int[]> {\n                {"aes-128-cfb", new int[]{16, 16, CIPHER_AES, PolarSSL.AES_CTX_SIZE}},\n                {"aes-192-cfb", new int[]{24, 16, CIPHER_AES, PolarSSL.AES_CTX_SIZE}},
        {\n            return new Dictionary<string, int[]> {\n                {"aes-128-cfb", new int[]{16, 16, CIPHER_AES, PolarSSL.AES_CTX_SIZE}},\n                {"aes-192-cfb", new int[]{24, 16, CIPHER_AES, PolarSSL.AES_CTX_SIZE}},\n                {"aes-256-cfb", new int[]{32, 16, CIPHER_AES, PolarSSL.AES_CTX_SIZE}},\n                {"rc4", new int[]{16, 0, CIPHER_RC4, PolarSSL.ARC4_CTX_SIZE}},\n                {"rc4-md5", new int[]{16, 16, CIPHER_RC4, PolarSSL.ARC4_CTX_SIZE}},\n            };
        }\n        protected override void initCipher(byte[] iv, bool isCipher)\n        {\n            base.initCipher(iv, isCipher);\n            IntPtr ctx;\n            ctx = Marshal.AllocHGlobal(_cipherInfo[3]);\n            if (isCipher)\n            {\n                _encryptCtx = ctx;
        {\n            base.initCipher(iv, isCipher);\n            IntPtr ctx;\n            ctx = Marshal.AllocHGlobal(_cipherInfo[3]);\n            if (isCipher)\n            {\n                _encryptCtx = ctx;
            {\n                _encryptCtx = ctx;
            }\n            else\n            {\n                _decryptCtx = ctx;\n            }
            }\n            byte[] realkey;\n            if (_method == "rc4-md5")\n            {\n                byte[] temp = new byte[keyLen + ivLen];\n                realkey = new byte[keyLen];
            byte[] realkey;\n            if (_method == "rc4-md5")\n            {\n                byte[] temp = new byte[keyLen + ivLen];\n                realkey = new byte[keyLen];\n                Array.Copy(_key, 0, temp, 0, keyLen);\n                Array.Copy(iv, 0, temp, keyLen, ivLen);\n                realkey = MD5.Create().ComputeHash(temp);\n            }\n            else
            }\n            else if (_cipher == CIPHER_RC4)\n            {\n                PolarSSL.arc4_init(ctx);\n                // PolarSSL RC4 takes key length by byte\n                PolarSSL.arc4_setup(ctx, realkey, keyLen);\n            }\n        }\n        protected override void cipherUpdate(bool isCipher, int length, byte[] buf, byte[] outbuf)
        {\n            // C# could be multi-threaded\n            if (_disposed)\n            {\n                throw new ObjectDisposedException(this.ToString());\n            }\n            byte[] iv;\n            int ivOffset;\n            if (isCipher)\n            {
            {\n                throw new ObjectDisposedException(this.ToString());\n            }\n            byte[] iv;\n            int ivOffset;\n            if (isCipher)\n            {\n                iv = _encryptIV;\n                ivOffset = _encryptIVOffset;
            }\n            else\n            {\n                iv = _decryptIV;\n                ivOffset = _decryptIVOffset;
            }\n            switch (_cipher)\n            {\n                case CIPHER_AES:\n                    PolarSSL.aes_crypt_cfb128(_encryptCtx, isCipher ? PolarSSL.AES_ENCRYPT : PolarSSL.AES_DECRYPT, length, ref ivOffset, iv, buf, outbuf);\n                    if (isCipher)
            {\n                case CIPHER_AES:\n                    PolarSSL.aes_crypt_cfb128(_encryptCtx, isCipher ? PolarSSL.AES_ENCRYPT : PolarSSL.AES_DECRYPT, length, ref ivOffset, iv, buf, outbuf);\n                    if (isCipher)
                    {\n                        _encryptIVOffset = ivOffset;\n                    }\n                    else\n                    {\n                        _decryptIVOffset = ivOffset;
                    }\n                    else\n                    {\n                        _decryptIVOffset = ivOffset;
                    {\n                        _decryptIVOffset = ivOffset;\n                    }\n                    break;
                    }\n                    break;\n                case CIPHER_RC4:\n                    PolarSSL.arc4_crypt(_encryptCtx, length, buf, outbuf);\n                    break;
            }\n        }\n        #region IDisposable\n        private bool _disposed;\n        public override void Dispose()\n        {\n            Dispose(true);\n            GC.SuppressFinalize(this);\n        }\n        ~PolarSSLEncryptor()
                FileManager.UncompressFile(dllPath, Resources.polarssl_dll);\n            }\n            catch (IOException e)\n            {\n                Console.WriteLine(e.ToString());\n            }\n            LoadLibrary(dllPath);\n            try\n            {\n                FileStream fs = new FileStream("shadowsocks.log", FileMode.Append);
                FileStream fs = new FileStream("shadowsocks.log", FileMode.Append);\n                TextWriter tmp = Console.Out;\n                StreamWriter sw = new StreamWriter(fs);\n                sw.AutoFlush = true;\n                Console.SetOut(sw);\n                Console.SetError(sw);\n            }\n            catch (IOException e)\n            {\n                Console.WriteLine(e.ToString());
            {\n                return File.ReadAllText(PAC_FILE, Encoding.UTF8);\n            }\n            else\n            {\n                byte[] pacGZ = Resources.proxy_pac_txt;\n                byte[] buffer = new byte[1024 * 1024];  // builtin pac gzip size: maximum 1M\n                int n;\n                using (GZipStream input = new GZipStream(new MemoryStream(pacGZ),\n                    CompressionMode.Decompress, false))
                {\n                    n = input.Read(buffer, 0, buffer.Length);\n                    if (n == 0)\n                    {\n                        throw new IOException("can not decompress pac");\n                    }\n                    return System.Text.Encoding.UTF8.GetString(buffer, 0, n);\n                }\n            }
                }\n            }\n        }\n        private void receiveCallback(IAsyncResult ar)\n        {\n            Socket conn = (Socket)ar.AsyncState;\n            try\n            {\n                int bytesRead = conn.EndReceive(ar);
            }\n        }\n        private void receiveCallback(IAsyncResult ar)\n        {\n            Socket conn = (Socket)ar.AsyncState;\n            try\n            {\n                int bytesRead = conn.EndReceive(ar);\n                string pac = getPACContent();\n                string proxy = "PROXY 127.0.0.1:8123; DIRECT;";
            updateSystemProxy();\n        }\n        public void SaveConfig(Config newConfig)\n        {\n            Config.Save(newConfig);\n            config = newConfig;\n            local.Stop();\n            polipoRunner.Stop();\n            polipoRunner.Start(config);\n            local = new Local(config);
            this.aboutItem.Text = "About";\n            this.aboutItem.Click += new System.EventHandler(this.aboutToolStripMenuItem_Click);\n            // \n            // menuItem3\n            // \n            // \n            // editPACFileItem\n            // 
                {"aes-128-cfb", new int[]{16, 16, CIPHER_AES, PolarSSL.AES_CTX_SIZE}},\n                {"aes-192-cfb", new int[]{24, 16, CIPHER_AES, PolarSSL.AES_CTX_SIZE}},\n                {"aes-256-cfb", new int[]{32, 16, CIPHER_AES, PolarSSL.AES_CTX_SIZE}},\n                {"rc4", new int[]{16, 0, CIPHER_RC4, PolarSSL.ARC4_CTX_SIZE}},\n                {"rc4-md5", new int[]{16, 16, CIPHER_RC4, PolarSSL.ARC4_CTX_SIZE}},\n        };\n        public static List<string> SupportedCiphers()\n        {\n            return new List<string>(_ciphers.Keys);\n        }
        }\n        protected override void initCipher(byte[] iv, bool isCipher)\n        {\n            base.initCipher(iv, isCipher);\n            IntPtr ctx;\n            ctx = Marshal.AllocHGlobal(_cipherInfo[3]);\n            if (isCipher)\n            {\n                _encryptCtx = ctx;\n            }
        }\n        protected override void cipherUpdate(bool isCipher, int length, byte[] buf, byte[] outbuf)\n        {\n            // TODO write a unidirection cipher so we don't have to if if if\n            int bytesRemaining;\n            ulong ic;\n            byte[] sodiumBuf;\n            byte[] iv;\n            if (isCipher)\n            {
            {\n                method = "table";\n            }\n            method = method.ToLowerInvariant();\n            Type t = _registeredEncryptors[method];\n            ConstructorInfo c = t.GetConstructor(_constructorTypes);\n            IEncryptor result = (IEncryptor)c.Invoke(new object[] { method, password });\n            return result;\n        }
            }\n            method = method.ToLowerInvariant();\n            Type t = _registeredEncryptors[method];\n            ConstructorInfo c = t.GetConstructor(_constructorTypes);\n            IEncryptor result = (IEncryptor)c.Invoke(new object[] { method, password });\n            return result;\n        }\n    }\n}
        }\n    }\n}
            this.btnOK.Name = "btnOK";\n            this.btnCancel.Location = new System.Drawing.Point(254, 9);\n            this.btnCancel.Margin = new System.Windows.Forms.Padding(4, 4, 4, 4);\n            this.btnCancel.Name = "btnCancel";
            this.btnCancel.Name = "btnCancel";\n            this.btnRegisterAll.Location = new System.Drawing.Point(92, 9);\n            this.btnRegisterAll.Margin = new System.Windows.Forms.Padding(4, 4, 4, 4);\n            this.btnRegisterAll.Name = "btnRegisterAll";
            this.btnRegisterAll.Name = "btnRegisterAll";
using System.Drawing;\nusing System.Text;\nusing System.Windows.Forms;\nusing static Shadowsocks.Controller.HotkeyReg;\nnamespace Shadowsocks.View\n{
using System.Text;\nusing System.Windows.Forms;\nusing static Shadowsocks.Controller.HotkeyReg;\nnamespace Shadowsocks.View\n{\n    public partial class HotkeySettingsForm : Form\n    {
using static Shadowsocks.Controller.HotkeyReg;\nnamespace Shadowsocks.View\n{\n    public partial class HotkeySettingsForm : Form\n    {\n        private readonly ShadowsocksController _controller;\n        // this is a copy of hotkey configuration that we are working on\n        private HotkeyConfig _modifiedHotkeyConfig;\n        public HotkeySettingsForm(ShadowsocksController controller)\n        {
using System.Globalization;\nusing System.IO;\nusing Shadowsocks.Properties;\nusing Shadowsocks.Util;\nusing System.Windows.Forms;\nusing Microsoft.VisualBasic.FileIO;\nnamespace Shadowsocks.Controller\n{\n    public static class I18N
    public static class I18N\n    {\n        private static Dictionary<string, string> _strings = new Dictionary<string, string>();\n        private static void Init(string res, string locale)\n        {\n            using (TextFieldParser csvParser = new TextFieldParser(new StringReader(res)))\n            {\n                csvParser.SetDelimiters(",");\n                string[] localeNames = csvParser.ReadFields();\n                int enIndex = 0;
        {\n            using (TextFieldParser csvParser = new TextFieldParser(new StringReader(res)))\n            {\n                csvParser.SetDelimiters(",");\n                string[] localeNames = csvParser.ReadFields();\n                int enIndex = 0;\n                int targetIndex = 0;\n                for (int i = 1; i < localeNames.Length; i++)\n                {
            {\n                csvParser.SetDelimiters(",");\n                string[] localeNames = csvParser.ReadFields();\n                int enIndex = 0;\n                int targetIndex = 0;\n                for (int i = 1; i < localeNames.Length; i++)\n                {\n                    if (localeNames[i] == "en")\n                    {
                {\n                    if (localeNames[i] == "en")\n                    {\n                    }\n                    if (localeNames[i] == locale)\n                    {\n                        targetIndex = i;\n                    }\n                }\n                while (!csvParser.EndOfData)
                }\n            }\n        }\n        static I18N()\n        {\n            Init(Resources.i18n_csv, CultureInfo.CurrentCulture.IetfLanguageTag);
        }\n        public static string GetString(string key, params object[] args)\n        {\n            return string.Format(_strings.TryGetValue(key, out var value) ? value : key, args);\n        }\n        public static void TranslateForm(Form c)\n        {\n            c.Text = GetString(c.Text);\n            foreach (var item in ViewUtils.GetChildControls<Control>(c))\n            {
namespace Shadowsocks.View\n{\n    public partial class ConfigForm : Form\n    {\n        private ShadowsocksController controller;\n        // this is a copy of configuration that we are working on\n        private Configuration _modifiedConfiguration;\n        private int _lastSelectedIndex = -1;\n        private bool isChange = false;\n        public ConfigForm(ShadowsocksController controller)
            toolTip1.SetToolTip(PortableModeCheckBox, I18N.GetString("Restart required"));
        }\n        private void SetupValueChangedListeners()\n        {\n            IPTextBox.TextChanged += ConfigValueChanged;\n            ProxyPortTextBox.TextChanged += ConfigValueChanged;\n            PasswordTextBox.TextChanged += ConfigValueChanged;\n            EncryptionSelect.SelectedIndexChanged += ConfigValueChanged;\n            PluginTextBox.TextChanged += ConfigValueChanged;\n            PluginArgumentsTextBox.TextChanged += ConfigValueChanged;\n            PluginOptionsTextBox.TextChanged += ConfigValueChanged;
using Shadowsocks.View;\nnamespace Shadowsocks.Controller.Hotkeys\n{\n    public class HotkeyCallbacks\n    {\n        public static void InitInstance(ShadowsocksController controller)\n        {\n            if (Instance != null)\n            {
        public static void InitInstance(ShadowsocksController controller)\n        {\n            if (Instance != null)\n            {\n                return;\n            }\n            Instance = new HotkeyCallbacks(controller);\n        }\n        /// <summary>\n        /// Create hotkey callback handler delegate based on callback name
using Shadowsocks.Model;\nusing Timer = System.Threading.Timer;\nnamespace Shadowsocks.Controller.Strategy\n{\n    using DataUnit = KeyValuePair<string, string>;\n    using DataList = List<KeyValuePair<string, string>>;\n    class StatisticsStrategy : IStrategy\n    {\n        private readonly ShadowsocksController _controller;\n        private Server _currentServer;
        public StatisticsStrategy(ShadowsocksController controller)\n        {\n            _controller = controller;\n            var servers = controller.GetCurrentConfiguration().configs;\n            var randomIndex = new Random().Next() % servers.Count();\n            _currentServer = servers[randomIndex];  //choose a server randomly at first\n            _timer = new Timer(ReloadStatisticsAndChooseAServer);\n        }\n        private void ReloadStatisticsAndChooseAServer(object obj)\n        {
        private void LoadStatistics()\n        {\n            try\n            {\n                var path = AvailabilityStatistics.AvailabilityStatisticsFile;\n                Logging.Debug($"loading statistics from {path}");\n                if (!File.Exists(path))\n                {\n                    LogWhenEnabled($"statistics file does not exist, try to reload {RetryInterval/60/1000} minutes later");\n                    _timer.Change(RetryInterval, ChoiceKeptMilliseconds);
                    return;\n                }\n                _rawStatistics = (from l in File.ReadAllLines(path)\n                    .Skip(1)\n                    let strings = l.Split(new[] {","}, StringSplitOptions.RemoveEmptyEntries)\n                    let rawData = new StatisticsRawData\n                    {\n                        Timestamp = strings[0],\n                        ServerName = strings[1],\n                        ICMPStatus = strings[2],
            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n            }\n        }\n        //return the score by data\n        //server with highest score will be choosen\n        private float GetScore(IEnumerable<StatisticsRawData> rawDataList)\n        {\n            var config = _controller.StatisticsConfiguration;\n            if (config.ByIsp)
        }\n        public class StatisticsData\n        {\n            public float PackageLoss;\n            public int AverageResponse;\n            public int MinResponse;\n            public int MaxResponse;\n        }
            public int AverageResponse;\n            public int MinResponse;\n            public int MaxResponse;\n        }\n        private void ChooseNewServer(List<Server> servers)\n        {\n            if (_rawStatistics == null || servers.Count == 0)\n            {\n                return;\n            }
            {\n                return;\n            }\n            try\n            {\n                var bestResult = (from server in servers\n                                  let name = server.FriendlyName()\n                                  where _rawStatistics.ContainsKey(name)\n                                  select new\n                                  {
                                  select new\n                                  {\n                                      server,\n                                      score = GetScore(_rawStatistics[name])\n                                  }\n                                  ).Aggregate((result1, result2) => result1.score > result2.score ? result1 : result2);\n                if (!_currentServer.Equals(bestResult.server)) //output when enabled\n                {
                                  }\n                                  ).Aggregate((result1, result2) => result1.score > result2.score ? result1 : result2);\n                if (!_currentServer.Equals(bestResult.server)) //output when enabled\n                {
        {\n            InitializeComponent();\n            valueLabel.Text = text;\n            factorNum.Value = (decimal) value;\n        }\n        public string Value => valueLabel.Text;\n        public float Factor => (float) factorNum.Value;\n    }\n}
        }\n        public string Value => valueLabel.Text;\n        public float Factor => (float) factorNum.Value;\n    }\n}
    }\n}
            this.StatisticsChart = new System.Windows.Forms.DataVisualization.Charting.Chart();\n            this.byISPCheckBox = new System.Windows.Forms.CheckBox();\n            this.bindingConfiguration = new System.Windows.Forms.BindingSource(this.components);\n            this.label2 = new System.Windows.Forms.Label();\n            this.label3 = new System.Windows.Forms.Label();\n            this.label4 = new System.Windows.Forms.Label();\n            this.groupBox1 = new System.Windows.Forms.GroupBox();\n            this.radioButton2 = new System.Windows.Forms.RadioButton();\n            this.radioButton1 = new System.Windows.Forms.RadioButton();\n            this.splitContainer1 = new System.Windows.Forms.SplitContainer();
            ((System.ComponentModel.ISupportInitialize)(this.StatisticsChart)).BeginInit();\n            ((System.ComponentModel.ISupportInitialize)(this.bindingConfiguration)).BeginInit();\n            this.groupBox1.SuspendLayout();\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer1)).BeginInit();\n            this.splitContainer1.Panel1.SuspendLayout();\n            this.splitContainer1.Panel2.SuspendLayout();\n            this.splitContainer1.SuspendLayout();\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer2)).BeginInit();\n            this.splitContainer2.Panel1.SuspendLayout();\n            this.splitContainer2.Panel2.SuspendLayout();
            series1.Legend = "ChartLegend";\n            series1.Name = "Package Loss";\n            series1.YValuesPerPoint = 4;\n            series2.BorderWidth = 4;\n            series2.ChartArea = "ChartArea";\n            series2.ChartType = System.Windows.Forms.DataVisualization.Charting.SeriesChartType.Line;\n            series2.Color = System.Drawing.Color.FromArgb(((int)(((byte)(155)))), ((int)(((byte)(77)))), ((int)(((byte)(150)))));\n            series2.Legend = "ChartLegend";\n            series2.Name = "Ping";
            series2.ChartArea = "ChartArea";\n            series2.ChartType = System.Windows.Forms.DataVisualization.Charting.SeriesChartType.Line;\n            series2.Color = System.Drawing.Color.FromArgb(((int)(((byte)(155)))), ((int)(((byte)(77)))), ((int)(((byte)(150)))));\n            series2.Legend = "ChartLegend";\n            series2.Name = "Ping";
            series2.Legend = "ChartLegend";\n            series2.Name = "Ping";\n            this.StatisticsChart.Series.Add(series1);
            this.StatisticsChart.Series.Add(series1);\n            this.StatisticsChart.Series.Add(series2);\n            this.StatisticsChart.Size = new System.Drawing.Size(1061, 314);\n            this.StatisticsChart.TabIndex = 2;\n            // \n            // byISPCheckBox\n            // \n            this.byISPCheckBox.AutoSize = true;\n            this.byISPCheckBox.DataBindings.Add(new System.Windows.Forms.Binding("Checked", this.bindingConfiguration, "ByIsp", true));
            this.StatisticsChart.TabIndex = 2;\n            // \n            // byISPCheckBox\n            // \n            this.byISPCheckBox.AutoSize = true;\n            this.byISPCheckBox.DataBindings.Add(new System.Windows.Forms.Binding("Checked", this.bindingConfiguration, "ByIsp", true));\n            this.byISPCheckBox.Location = new System.Drawing.Point(12, 56);\n            this.byISPCheckBox.Margin = new System.Windows.Forms.Padding(5, 10, 5, 10);\n            this.byISPCheckBox.Name = "byISPCheckBox";\n            this.byISPCheckBox.Size = new System.Drawing.Size(204, 32);
using Shadowsocks.Util;\nusing Timer = System.Threading.Timer;\nnamespace Shadowsocks.Controller\n{\n    using DataUnit = KeyValuePair<string, string>;\n    using DataList = List<KeyValuePair<string, string>>;\n    internal class AvailabilityStatistics\n    {\n        public static readonly string DateTimePattern = "yyyy-MM-dd HH:mm:ss";\n        private const string StatisticsFilesName = "shadowsocks.availability.csv";
        private Timer _timer;\n        private State _state;\n        private List<Server> _servers;\n        private StatisticsStrategyConfiguration _config;\n        public static string AvailabilityStatisticsFile;\n        //static constructor to initialize every public static fields before refereced\n        static AvailabilityStatistics()\n        {\n            var temppath = Utils.GetTempPath();\n            AvailabilityStatisticsFile = Path.Combine(temppath, StatisticsFilesName);\n        }
            AvailabilityStatisticsFile = Path.Combine(temppath, StatisticsFilesName);\n        }\n        public AvailabilityStatistics(Configuration config, StatisticsStrategyConfiguration statisticsConfig)\n        {\n            UpdateConfiguration(config, statisticsConfig);\n        }\n        public bool Set(StatisticsStrategyConfiguration config)\n        {\n            _config = config;\n            try
        {\n            UpdateConfiguration(config, statisticsConfig);\n        }\n        public bool Set(StatisticsStrategyConfiguration config)\n        {\n            _config = config;\n            try\n            {\n                if (config.StatisticsEnabled)\n                {
                {\n                    if (_timer?.Change(DelayBeforeStart, _interval) == null)\n                    {\n                        _state = new State();\n                        _timer = new Timer(Evaluate, _state, DelayBeforeStart, _interval);\n                    }\n                }\n                else\n                {\n                    _timer?.Dispose();
                    {\n                        _state = new State();\n                        _timer = new Timer(Evaluate, _state, DelayBeforeStart, _interval);\n                    }\n                }\n                else\n                {\n                    _timer?.Dispose();\n                }\n                return true;
                    }\n                }\n                else\n                {\n                    _timer?.Dispose();\n                }\n                return true;\n            }\n            catch (Exception e)\n            {
        {\n            var IP = Dns.GetHostAddresses(server.server).First(ip => ip.AddressFamily == AddressFamily.InterNetwork);\n            var ping = new Ping();\n            var ret = new List<DataList>();\n            foreach (\n                var timestamp in Enumerable.Range(0, _repeat).Select(_ => DateTime.Now.ToString(DateTimePattern)))\n            {\n                //ICMP echo. we can also set options and special bytes
            {\n                //ICMP echo. we can also set options and special bytes\n                try\n                {\n                    var reply = ping.Send(IP, Timeout);\n                    ret.Add(new List<KeyValuePair<string, string>>\n                    {\n                        new KeyValuePair<string, string>("Timestamp", timestamp),\n                        new KeyValuePair<string, string>("Server", server.FriendlyName()),\n                        new KeyValuePair<string, string>("Status", reply?.Status.ToString()),\n                        new KeyValuePair<string, string>("RoundtripTime", reply?.RoundtripTime.ToString())
                    ret.Add(new List<KeyValuePair<string, string>>\n                    {\n                        new KeyValuePair<string, string>("Timestamp", timestamp),\n                        new KeyValuePair<string, string>("Server", server.FriendlyName()),\n                        new KeyValuePair<string, string>("Status", reply?.Status.ToString()),\n                        new KeyValuePair<string, string>("RoundtripTime", reply?.RoundtripTime.ToString())\n                        //new KeyValuePair<string, string>("data", reply.Buffer.ToString()); // The data of reply\n                    });\n                    Thread.Sleep(new Random().Next() % Timeout);\n                    //Do ICMPTest in a random frequency\n                }\n                catch (Exception e)
        }\n        internal void UpdateConfiguration(Configuration config, StatisticsStrategyConfiguration statisticsConfig)\n        {\n            Set(statisticsConfig);\n            _servers = config.configs;\n        }\n        public class State\n        {\n            public DataList dataList = new DataList();\n            public const string Geolocation = "Geolocation";
        {\n            Set(statisticsConfig);\n            _servers = config.configs;\n        }\n        public class State\n        {\n            public DataList dataList = new DataList();\n            public const string Geolocation = "Geolocation";\n            public const string ISP = "ISP";\n            public const string Unknown = "Unknown";
            _servers = config.configs;\n        }\n        public class State\n        {\n            public DataList dataList = new DataList();\n            public const string Geolocation = "Geolocation";\n            public const string ISP = "ISP";\n            public const string Unknown = "Unknown";\n        }\n    }
        {\n            public DataList dataList = new DataList();\n            public const string Geolocation = "Geolocation";\n            public const string ISP = "ISP";\n            public const string Unknown = "Unknown";\n        }\n    }\n}
            try\n            {\n                ssURLAssociation = Registry.CurrentUser.CreateSubKey(@"SOFTWARE\Classes\ss", RegistryKeyPermissionCheck.ReadWriteSubTree);\n                if (ssURLAssociation == null)\n                {
                {\n                    ssURLAssociation.SetValue("", "URL:Shadowsocks");\n                    ssURLAssociation.SetValue("URL Protocol", "");\n                    var shellOpen = ssURLAssociation.CreateSubKey("shell").CreateSubKey("open").CreateSubKey("command");\n                    shellOpen.SetValue("", $"{ExecutablePath} --open-url %1");
                    shellOpen.SetValue("", $"{ExecutablePath} --open-url %1");\n                    logger.Info(@"Successfully added ss:// association.");\n                }\n                else\n                {\n                    Registry.CurrentUser.DeleteSubKeyTree(@"SOFTWARE\Classes\ss");\n                    logger.Info(@"Successfully removed ss:// association.");\n                }\n                return true;
                }\n                return true;\n            }\n            catch (Exception e)\n            {\n                logger.LogUsefulException(e);\n                return false;\n            }\n            finally\n            {
                    }\n                    catch (Exception e)\n                    { logger.LogUsefulException(e); }\n                }\n            }\n        }\n        public static bool Check()\n        {\n            RegistryKey ssURLAssociation = null;\n            try
            try\n            {\n                ssURLAssociation = Registry.CurrentUser.OpenSubKey(@"SOFTWARE\Classes\ss", true);\n                if (ssURLAssociation == null)\n                {\n                    //logger.Info(@"ss:// links not associated.");\n                    return false;\n                }\n                var shellOpen = ssURLAssociation.OpenSubKey("shell").OpenSubKey("open").OpenSubKey("command");\n                return (string)shellOpen.GetValue("") == $"{ExecutablePath} --open-url %1";
                {\n                    //logger.Info(@"ss:// links not associated.");\n                    return false;\n                }\n                var shellOpen = ssURLAssociation.OpenSubKey("shell").OpenSubKey("open").OpenSubKey("command");\n                return (string)shellOpen.GetValue("") == $"{ExecutablePath} --open-url %1";\n            }\n            catch (Exception e)\n            {\n                logger.LogUsefulException(e);
                    return false;\n                }\n                var shellOpen = ssURLAssociation.OpenSubKey("shell").OpenSubKey("open").OpenSubKey("command");\n                return (string)shellOpen.GetValue("") == $"{ExecutablePath} --open-url %1";\n            }\n            catch (Exception e)\n            {\n                logger.LogUsefulException(e);\n                return false;\n            }
                return (string)shellOpen.GetValue("") == $"{ExecutablePath} --open-url %1";\n            }\n            catch (Exception e)\n            {\n                logger.LogUsefulException(e);\n                return false;\n            }\n            finally\n            {\n                if (ssURLAssociation != null)
                    }\n                    catch (Exception e)\n                    { logger.LogUsefulException(e); }\n                }\n            }\n        }\n    }\n}
[assembly: AssemblyProduct("shadowsocks-csharp")]\n[assembly: AssemblyCopyright("Copyright © clowwindy 2014")]\n[assembly: AssemblyTrademark("")]\n[assembly: AssemblyCulture("")]\n// 将 ComVisible 设置为 false 使此程序集中的类型\n// 对 COM 组件不可见。如果需要从 COM 访问此程序集中的类型，\n// 则将该类型上的 ComVisible 属性设置为 true。\n[assembly: ComVisible(false)]\n// 如果此项目向 COM 公开，则下列 GUID 用于类型库的 ID\n[assembly: Guid("f8334709-4309-436a-8bbd-6165dcf4a660")]
[assembly: AssemblyTrademark("")]\n[assembly: AssemblyCulture("")]\n// 将 ComVisible 设置为 false 使此程序集中的类型\n// 对 COM 组件不可见。如果需要从 COM 访问此程序集中的类型，\n// 则将该类型上的 ComVisible 属性设置为 true。\n[assembly: ComVisible(false)]\n// 如果此项目向 COM 公开，则下列 GUID 用于类型库的 ID\n[assembly: Guid("f8334709-4309-436a-8bbd-6165dcf4a660")]\n// 程序集的版本信息由下面四个值组成:\n//
        {\n            // release any unused pages\n            // making the numbers look good in task manager\n            // this is totally nonsense in programming\n            // but good for those users who care\n            // making them happier with their everyday life\n            // which is part of user experience\n            GC.Collect(GC.MaxGeneration);\n            GC.WaitForPendingFinalizers();\n            if (removePages)\n            {\n                // as some users have pointed out\n                // removing pages from working set will cause some IO\n                // which lowered user experience for another group of users\n                //\n                // so we do 2 more things here to satisfy them:\n        }\n        public static string UnGzip(byte[] buf)
        }\n        public static string UnGzip(byte[] buf)\n        {\n            byte[] buffer = new byte[1024];\n            int n;\n            using (MemoryStream sb = new MemoryStream())\n            {\n                using (GZipStream input = new GZipStream(new MemoryStream(buf),\n                    CompressionMode.Decompress, false))\n                {
        }\n        private void ConnectCallback(IAsyncResult ar)\n        {\n            if (closed)\n            {\n                return;\n            }\n            try\n            {\n                // Complete the connection.
                    connection.BeginSend(remoteSendBuffer, 0, bytesToSend, 0, new AsyncCallback(PipeConnectionSendCallback), null);\n                }\n                else\n                {\n                    //Console.WriteLine("bytesRead: " + bytesRead.ToString());\n                    connection.Shutdown(SocketShutdown.Send);\n                    connectionShutdown = true;\n                    CheckClose();\n                }\n            }
                    remote.BeginSend(connetionSendBuffer, 0, bytesToSend, 0, new AsyncCallback(PipeRemoteSendCallback), null);\n                }\n                else\n                {\n                    remote.Shutdown(SocketShutdown.Send);\n                    remoteShutdown = true;\n                    CheckClose();\n                }\n            }\n            catch (Exception e)
            }\n        }\n        private string GetPACContent()\n        {\n            if (File.Exists(PAC_FILE))\n            {\n                return File.ReadAllText(PAC_FILE, Encoding.UTF8);\n            }\n            else\n            {
            {\n                Application.SetUnhandledExceptionMode(UnhandledExceptionMode.CatchException);\n                // handle UI exceptions\n                Application.ThreadException += Application_ThreadException;\n                // handle non-UI exceptions\n                AppDomain.CurrentDomain.UnhandledException += CurrentDomain_UnhandledException;\n                Application.ApplicationExit += Application_ApplicationExit;\n                SystemEvents.PowerModeChanged += SystemEvents_PowerModeChanged;\n                Application.EnableVisualStyles();\n                Application.SetCompatibleTextRenderingDefault(false);\n                Application.ApplicationExit += (sender, args) => HotKeys.Destroy();\n                if (!mutex.WaitOne(0, false))
                    "Shadowsocks Error", MessageBoxButtons.OK, MessageBoxIcon.Error);\n                Application.Exit();\n            }\n        }\n        private static void Application_ThreadException(object sender, ThreadExceptionEventArgs e)\n        {\n            string errorMsg = $"Exception Type: {e.GetType().Name}{Environment.NewLine}Stack Trace:{Environment.NewLine}{e.Exception.StackTrace}";\n            Logging.Error(errorMsg);\n            MessageBox.Show(\n                $"{I18N.GetString("Unexpected error, shadowsocks will exit. Please report to")} https://github.com/shadowsocks/shadowsocks-windows/issues {Environment.NewLine}{errorMsg}",
                    }\n                    _connection.BeginSend(response, 0, response.Length, SocketFlags.None,\n                        HandshakeSendCallback, null);\n                }\n                else\n                    Close();\n            }\n            catch (Exception e)\n            {\n                Logger.LogUsefulException(e);
                Close();\n            }\n        }\n        private void HandshakeSendCallback(IAsyncResult ar)\n        {\n            if (_closed) return;\n            try\n            {\n                _connection.EndSend(ar);\n                // +-----+-----+-------+------+----------+----------+
                            Close();\n                            break;\n                    }\n                }\n                else\n                {\n                    Logger.Debug(\n                        "failed to recv data in Shadowsocks.Controller.TCPHandler.handshakeReceive2Callback()");\n                    Close();\n                }
                Close();\n            }\n        }\n        private void ResponseCallback(IAsyncResult ar)\n        {\n            try\n            {\n                _connection.EndSend(ar);\n                ReadAddress(StartConnect);\n            }
                    }\n                    _destEndPoint = SocketUtil.GetEndPoint(dstAddr, dstPort);\n                    onSuccess.Invoke(); /* StartConnect() */\n                }\n                else\n                {\n                    Logger.Debug("failed to recv data in Shadowsocks.Controller.TCPHandler.OnAddressFullyRead()");\n                    Close();\n                }\n            }
                    Close();\n                }\n            }\n            catch (Exception e)\n            {\n                Logger.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void HandleUDPAssociate()
                Close();\n            }\n        }\n        private void HandleUDPAssociate()\n        {\n            IPEndPoint endPoint = (IPEndPoint)_connection.LocalEndPoint;\n            byte[] address = endPoint.Address.GetAddressBytes();\n            int port = endPoint.Port;\n            byte[] response = new byte[4 + address.Length + ADDR_PORT_LEN];\n            response[0] = 5;
                SendToServer(_firstPacketLength, session);\n            }\n            catch (Exception e)\n            {\n                Logger.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void PipeRemoteReceiveCallback(IAsyncResult ar)\n        {
                Close();\n            }\n        }\n        private void PipeRemoteReceiveCallback(IAsyncResult ar)\n        {\n            if (_closed) return;\n            try\n            {\n                var session = (AsyncSession)ar.AsyncState;\n                int bytesRead = session.Remote.EndReceive(ar);
                            Close();\n                            return;\n                        }\n                    }\n                    if (bytesToSend == 0)\n                    {\n                        // need more to decrypt\n                        Logger.Debug("Need more to decrypt");\n                        session.Remote.BeginReceive(_remoteRecvBuffer, 0, RecvSize, SocketFlags.None,\n                            PipeRemoteReceiveCallback, session);\n                        return;
                        $"Started SIP003 plugin for {server.Identifier()} on {plugin.LocalEndPoint} - PID: {plugin.ProcessId}");\n                }\n            }\n            catch (Exception ex)\n            {\n                logger.Error("Failed to start SIP003 plugin: " + ex.Message);\n                throw;\n            }\n            return plugin.LocalEndPoint;\n        }
                throw;\n            }\n            return plugin.LocalEndPoint;\n        }\n        public void SaveServers(List<Server> servers, int localPort, bool portableMode)\n        {\n            _config.configs = servers;\n            _config.localPort = localPort;\n            _config.portableMode = portableMode;\n            Configuration.Save(_config);
            }\n        }\n        private void Save()\n        {\n            logger.Debug($"save statistics to {AvailabilityStatisticsFile}");\n            if (RawStatistics.Count == 0)\n            {\n                return;\n            }\n            try
            if (RawStatistics.Count == 0)\n            {\n                return;\n            }\n            try\n            {\n                string content;\n#if DEBUG\n                content = JsonConvert.SerializeObject(RawStatistics, Formatting.Indented);\n#else
            }\n        }\n        private void LoadRawStatistics()\n        {\n            try\n            {\n                var path = AvailabilityStatisticsFile;\n                logger.Debug($"loading statistics from {path}");\n                if (!File.Exists(path))\n                {
                if (!File.Exists(path))\n                {\n                    using (File.Create(path))\n                    {\n                        //do nothing\n                    }\n                }\n                var content = File.ReadAllText(path);\n                RawStatistics = JsonConvert.DeserializeObject<Statistics>(content) ?? RawStatistics;\n            }
                    FireCompleted(e, userstate);\n                }\n            }\n            private void Ping_PingCompleted(object sender, PingCompletedEventArgs e)\n            {\n                try\n                {\n                    if (e.Reply.Status == IPStatus.Success)\n                    {\n                        logger.Debug($"Ping {server.FriendlyName()} {e.Reply.RoundtripTime} ms");
                    FireCompleted(ex, e.UserState);\n                }\n            }\n            private void TestNext(object userstate)\n            {\n                if (repeat > 0)\n                {\n                    //Do ICMPTest in a random frequency\n                    int delay = TimeoutMilliseconds + new Random().Next() % TimeoutMilliseconds;\n                    new Task(() => ICMPTest(delay, userstate)).Start();
        }\n        public static void randBytes(byte[] buf, int length) { RNG.GetBytes(buf, length); }\n        public abstract void cipherEncrypt(byte[] plaintext, uint plen, byte[] ciphertext, ref uint clen);\n        public abstract void cipherDecrypt(byte[] ciphertext, uint clen, byte[] plaintext, ref uint plen);\n        #region TCP\n        public override void Encrypt(byte[] buf, int length, byte[] outbuf, out int outlength)\n        {\n            Debug.Assert(_encCircularBuffer != null, "_encCircularBuffer != null");\n            _encCircularBuffer.Put(buf, 0, length);\n            outlength = 0;\n            logger.Debug("---Start Encryption");
                    throw new CryptoErrorException();\n                }\n                logger.Debug("Get the real chunk len:" + chunkLen);\n                bufSize = _decCircularBuffer.Size;\n                if (bufSize < CHUNK_LEN_BYTES + tagLen /* we haven't remove them */+ chunkLen + tagLen) {\n                    logger.Debug("No more data to decrypt one chunk");\n                    return;\n                }\n                IncrementNonce(false);\n                // we have enough data to decrypt one chunk
using System.IO;\nusing System.IO.Compression;\nusing System.Text;\nnamespace Shadowsocks.Controller\n{\n    public static class FileManager\n    {\n        private static Logger logger = LogManager.GetCurrentClassLogger();\n        public static bool ByteArrayToFile(string fileName, byte[] content)\n        {
using System;\nusing System.Collections.Generic;\nusing System.Net;\nusing System.Text;\nnamespace Shadowsocks.Controller.Strategy\n{\n    class HighAvailabilityStrategy : IStrategy\n    {\n        private static Logger logger = LogManager.GetCurrentClassLogger();
                }\n            }\n        }\n        public void UpdateLatency(Model.Server server, TimeSpan latency)\n        {\n            logger.Debug($"latency: {server.FriendlyName()} {latency}");\n            ServerStatus status;\n            if (_serverStatus.TryGetValue(server, out status))\n            {\n                status.latency = latency;
                }\n                _tcpSocket.BeginAccept(new AsyncCallback(AcceptCallback), _tcpSocket);\n                UDPState udpState = new UDPState(_udpSocket);\n                _udpSocket.BeginReceiveFrom(udpState.buffer, 0, udpState.buffer.Length, 0, ref udpState.remoteEndPoint, new AsyncCallback(RecvFromCallback), udpState);\n            }\n            catch (SocketException)\n            {\n                _tcpSocket.Close();\n                throw;\n            }
                WebClient http = CreateWebClient();\n                http.DownloadStringCompleted += http_DownloadStringCompleted;\n                http.DownloadStringAsync(new Uri(UpdateURL));\n            }\n            catch (Exception ex)\n            {\n                logger.LogUsefulException(ex);\n            }\n        }\n        private void http_DownloadStringCompleted(object sender, DownloadStringCompletedEventArgs e)
            }\n        }\n        private void http_DownloadStringCompleted(object sender, DownloadStringCompletedEventArgs e)\n        {\n            try\n            {\n                string response = e.Result;\n                JArray result = JArray.Parse(response);\n                List<Asset> asserts = new List<Asset>();\n                if (result != null)
                    if (CheckUpdateCompleted != null)\n                    {\n                        CheckUpdateCompleted(this, new EventArgs());\n                    }\n                }\n            }\n            catch (Exception ex)\n            {\n                logger.LogUsefulException(ex);\n            }
            }\n        }\n        private void startDownload()\n        {\n            try\n            {\n                LatestVersionLocalName = Utils.GetTempPath(LatestVersionName);\n                WebClient http = CreateWebClient();\n                http.DownloadFileCompleted += Http_DownloadFileCompleted;\n                http.DownloadFileAsync(new Uri(LatestVersionURL), LatestVersionLocalName);
                if (CheckUpdateCompleted != null)\n                {\n                    CheckUpdateCompleted(this, new EventArgs());\n                }\n            }\n            catch (Exception ex)\n            {\n                logger.LogUsefulException(ex);\n            }\n        }
            }\n        }\n        private WebClient CreateWebClient()\n        {\n            WebClient http = new WebClient();\n            http.Headers.Add("User-Agent", UserAgent);\n            http.Proxy = new WebProxy(config.localHost, config.localPort);\n            return http;\n        }\n        private void SortByVersions(List<Asset> asserts)
            switch (_cipher)\n            {\n                case CIPHER_CHACHA20IETFPOLY1305:\n                    ret = Sodium.crypto_aead_chacha20poly1305_ietf_decrypt(plaintext, ref decPlen,\n                        null,\n                        ciphertext, (ulong) clen,\n                        null, 0,\n                        _decNonce, _sodiumDecSubkey);\n                    break;\n                case CIPHER_XCHACHA20IETFPOLY1305:
                _remote?.SendTo(dataOut, outlen, SocketFlags.None, _remoteEndPoint);\n            }\n            public void Receive()\n            {\n                EndPoint remoteEndPoint = new IPEndPoint(GetIPAddress(), 0);\n                logger.Debug($"++++++Receive Server Port, size:" + _buffer.Length);\n                _remote?.BeginReceiveFrom(_buffer, 0, _buffer.Length, 0, ref remoteEndPoint, new AsyncCallback(RecvFromCallback), null);\n            }\n            public void RecvFromCallback(IAsyncResult ar)\n            {
                // truncate privoxy log file while debugging\n                string privoxyLogFilename = Utils.GetTempPath("privoxy.log");\n                if (File.Exists(privoxyLogFilename))\n                    using (new FileStream(privoxyLogFilename, FileMode.Truncate)) { }\n#endif\n                MainController = new ShadowsocksController();\n                MenuController = new MenuViewController(MainController);\n                HotKeys.Init(MainController);\n                MainController.Start();\n                Application.Run();
#endif\n                MainController = new ShadowsocksController();\n                MenuController = new MenuViewController(MainController);\n                HotKeys.Init(MainController);\n                MainController.Start();\n                Application.Run();\n            }\n        }\n        private static void TouchAndApplyNLogConfig()\n        {\n            string NLogConfigFileName = "NLog.config";
                MessageBox.Show(\n                    $"{I18N.GetString("Unexpected error, shadowsocks will exit. Please report to")} https://github.com/shadowsocks/shadowsocks-windows/issues {Environment.NewLine}{errMsg}",\n                    "Shadowsocks non-UI Error", MessageBoxButtons.OK, MessageBoxIcon.Error);\n                Application.Exit();\n            }\n        }\n        private static void Application_ThreadException(object sender, ThreadExceptionEventArgs e)\n        {\n            if (Interlocked.Increment(ref exited) == 1)\n            {
                            }\n                        });\n                    }\n                    break;\n                case PowerModes.Suspend:\n                    if (MainController != null)\n                    {\n                        MainController.Stop();\n                        logger.Info("controller stopped");\n                    }
                // Create the state object.\n                Handler handler = new Handler();\n                handler.connection = conn;\n                //if (encryptor.method == "table")\n                //{\n                //    handler.encryptor = encryptor;\n                //}\n                //else\n                //{\n                //    handler.encryptor = new Encryptor(config.method, config.password);\n            catch (Exception)\n            {\n                //Console.WriteLine(e.ToString());\n            }
            {\n                //Console.WriteLine(e.ToString());\n            }\n        }\n    }\n    class Handler\n    {\n        //public Encryptor encryptor;\n        public IEncryptor encryptor;\n        public Config config;
        {\n            return _strings.ContainsKey(key)\n                ? string.Format(_strings[key], args)\n                : string.Format(key, args);\n        }\n    }\n}
        }\n    }\n}
        }\n        public void Start(Configuration config)\n        {\n            this._config = config;\n            this._shareOverLAN = config.shareOverLan;\n            if (CheckIfPortInUse(_config.localPort))\n                throw new Exception(I18N.GetString("Port {0} already in use", _config.localPort));\n            try\n            {\n                // Create a TCP/IP socket.
            try\n            {\n                // Create a TCP/IP socket.\n                _tcpSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);\n                _udpSocket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);\n                _tcpSocket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, true);\n                _udpSocket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, true);\n                IPEndPoint localEndPoint = null;\n                localEndPoint = _shareOverLAN\n                    ? new IPEndPoint(IPAddress.Any, _config.localPort)
            DestHost = host;\n            DestPort = port;\n            byte[] request = null;\n            byte atyp = 0;\n            IPAddress ipAddress;\n            bool parsed = IPAddress.TryParse(host, out ipAddress);\n            if (parsed)\n            {\n                IPEndPoint ep = new IPEndPoint(ipAddress, port);\n                switch (ep.AddressFamily)
            request[0] = 5;\n            request[1] = 1;\n            request[2] = 0;\n            request[3] = atyp;\n            request[request.Length - 2] = (byte) ((port >> 8) & 0xff);\n            request[request.Length - 1] = (byte) (port & 0xff);\n            var st = new Socks5State();
            var st = new Socks5State();\n            st.Callback = callback;\n            st.AsyncState = state;\n            _remote?.BeginSend(request, 0, request.Length, 0, Socks5RequestSendCallback, st);\n        }\n        public void EndConnectDest(IAsyncResult asyncResult)\n        {\n            var state = ((FakeAsyncResult)asyncResult).innerState;\n            if (state.ex != null)\n            {
                            break;\n                        case 3:  // domain name, length + str\n                            int len = _connetionRecvBuffer[1];\n                            dst_addr = System.Text.Encoding.UTF8.GetString(_connetionRecvBuffer, 2, len);\n                            dst_port = (_connetionRecvBuffer[len + 2] << 8) + _connetionRecvBuffer[len + 3];\n                            if ( controller.GetCurrentConfiguration().isVerboseLogging ) {\n                                Logging.Info( $"connect to {dst_addr}:{dst_port}" );\n                            }\n                            break;
                            break;\n                        case 4:  // IPv6 address, 16 bytes\n                            dst_addr = new IPAddress(_connetionRecvBuffer.Skip(1).Take(16).ToArray()).ToString();\n                            dst_port = (_connetionRecvBuffer[17] << 8) + _connetionRecvBuffer[18];\n                            if ( controller.GetCurrentConfiguration().isVerboseLogging ) {\n                                Logging.Info( $"connect to [{dst_addr}]:{dst_port}" );\n                            }\n                            break;\n                    }
                            break;\n                    }\n                    int bytesToSend;\n                    lock (_encryptionLock)\n                    {\n                        if (_closed) return;\n                        encryptor.Encrypt(_connetionRecvBuffer, bytesRead, _connetionSendBuffer, out bytesToSend);\n                    }\n                    _tcprelay.UpdateOutboundCounter(server, bytesToSend);\n                    _startSendingTime = DateTime.Now;
            {\n                if (name == "zh" || name == "zh-CN")\n                {\n                    Init(Resources.cn);\n                }\n                else\n                {\n                    Init(Resources.zh_tw);
                {\n                    Init(Resources.cn);\n                }\n                else\n                {\n                    Init(Resources.zh_tw);
                }\n            }\n        }\n        public static string GetString(string key)\n        {\n            if (Strings.ContainsKey(key))\n            {\n                return Strings[key];\n            }\n            else
            {\n                byte[] strByte = Encoding.ASCII.GetBytes(str);\n                str = Encoding.Unicode.GetString(strByte);\n                userSettingsArr = str.Split(new string[] { "\r\n" }, StringSplitOptions.RemoveEmptyEntries);\n                // still fail, throw exception with string hexdump\n                if (userSettingsArr.Length != 4)\n                {\n                    throw new ProxyException("Unexpected sysproxy output:" + BitConverter.ToString(strByte));\n                }\n            }\n            _userSettings.Flags = userSettingsArr[0];
            {\n                var sb = new StringBuilder($"{Environment.NewLine}{tag}: ");\n                for (int i = 0; i < length - 1; i++)\n                {\n                    sb.Append($"0x{arr[i]:X2}, ");\n                }\n                sb.Append($"0x{arr[length - 1]:X2}");\n                sb.Append(Environment.NewLine);\n                logger.Trace(sb.ToString());\n            }
            }\n        }\n        public static void Debug(this Logger logger, EndPoint local, EndPoint remote, int len, string header = null, string tailer = null)\n        {\n            if (logger.IsDebugEnabled)\n            {\n                if (header == null && tailer == null)
        }\n        public static void Debug(this Logger logger, EndPoint local, EndPoint remote, int len, string header = null, string tailer = null)\n        {\n            if (logger.IsDebugEnabled)\n            {\n                if (header == null && tailer == null)\n                    logger.Debug($"{local} => {remote} (size={len})");\n                else if (header == null && tailer != null)\n                    logger.Debug($"{local} => {remote} (size={len}), {tailer}");\n                else if (header != null && tailer == null)
        }\n        public static void Debug(this Logger logger, Socket sock, int len, string header = null, string tailer = null)\n        {\n            if (logger.IsDebugEnabled)\n            {\n                logger.Debug(sock.LocalEndPoint, sock.RemoteEndPoint, len, header, tailer);\n            }\n        }\n        public static void LogUsefulException(this Logger logger, Exception e)\n        {
        }\n        public static void LogUsefulException(this Logger logger, Exception e)\n        {\n            // just log useful exceptions, not all of them\n            if (e is SocketException)\n            {\n                SocketException se = (SocketException)e;\n                if (se.SocketErrorCode == SocketError.ConnectionAborted)\n                {\n                    // closed by browser when sending
                return configuration;\n            }\n            catch (FileNotFoundException)\n            {\n                var configuration = new StatisticsStrategyConfiguration();\n                Save(configuration);\n                return configuration;\n            }\n            catch (Exception e)\n            {
            {\n                var configuration = new StatisticsStrategyConfiguration();\n                Save(configuration);\n                return configuration;\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                return new StatisticsStrategyConfiguration();\n            }
        {\n            bool success = true;\n            if (value is string)\n                success = SerializeString((string)value, builder);\n            else if (value is IDictionary<string, object>)\n            {\n                IDictionary<string, object> dict = (IDictionary<string, object>)value;\n                success = SerializeObject(jsonSerializerStrategy, dict.Keys, dict.Values, level, builder);\n            }\n            else if (value is IDictionary<string, string>)
            }\n            else if (value is IDictionary<string, string>)\n            {\n                IDictionary<string, string> dict = (IDictionary<string, string>)value;\n                success = SerializeObject(jsonSerializerStrategy, dict.Keys, dict.Values, level, builder);\n            }\n            else if (value is IEnumerable)\n                success = SerializeArray(jsonSerializerStrategy, (IEnumerable)value, level, builder);\n            else if (IsNumeric(value))\n                success = SerializeNumber(value, builder);
            }\n            else if (value is IEnumerable)\n                success = SerializeArray(jsonSerializerStrategy, (IEnumerable)value, level, builder);\n            else if (IsNumeric(value))\n                success = SerializeNumber(value, builder);\n            else if (value is Boolean)\n                builder.Append((bool)value ? "true" : "false");\n            else if (value == null)\n                builder.Append("null");\n            else
            else if (IsNumeric(value))\n                success = SerializeNumber(value, builder);\n            else if (value is Boolean)\n                builder.Append((bool)value ? "true" : "false");\n            else if (value == null)\n                builder.Append("null");\n            else\n            {\n                object serializedObject;\n                success = jsonSerializerStrategy.SerializeNonPrimitiveObject(value, out serializedObject);
            }\n            return success;\n        }\n        protected static bool SerializeObject(IJsonSerializerStrategy jsonSerializerStrategy, IEnumerable keys, IEnumerable values, int level, StringBuilder builder)\n        {\n            builder.Append("{\r\n");\n            level++;\n            IEnumerator ke = keys.GetEnumerator();\n            IEnumerator ve = values.GetEnumerator();\n            bool first = true;
        {\n            builder.Append("{\r\n");\n            level++;\n            IEnumerator ke = keys.GetEnumerator();\n            IEnumerator ve = values.GetEnumerator();\n            bool first = true;\n            while (ke.MoveNext() && ve.MoveNext())\n            {\n                object key = ke.Current;\n                object value = ve.Current;
                builder.Append(" : ");\n                if (!SerializeValue(jsonSerializerStrategy, value, level, builder))\n                    return false;\n                first = false;\n            }\n            builder.Append("\r\n");\n            FeedIndent(level - 1, builder);\n            builder.Append("}");\n            return true;\n        }
                    return false;\n                first = false;\n            }\n            builder.Append("\r\n");\n            FeedIndent(level - 1, builder);\n            builder.Append("}");\n            return true;\n        }\n        protected static bool SerializeArray(IJsonSerializerStrategy jsonSerializerStrategy, IEnumerable anArray, int level, StringBuilder builder)\n        {
            return true;\n        }\n        protected static bool SerializeArray(IJsonSerializerStrategy jsonSerializerStrategy, IEnumerable anArray, int level, StringBuilder builder)\n        {\n            builder.Append("[\r\n");\n            level++;\n            bool first = true;\n            foreach (object value in anArray)\n            {\n                if (!first)
            bool first = true;\n            foreach (object value in anArray)\n            {\n                if (!first)\n                    builder.Append(",\r\n");\n                FeedIndent(level, builder);\n                if (!SerializeValue(jsonSerializerStrategy, value, level, builder))\n                    return false;\n                first = false;\n            }
                    return false;\n                first = false;\n            }\n            builder.Append("\r\n");\n            FeedIndent(level - 1, builder);\n            builder.Append("]");\n            return true;\n        }\n        protected static bool SerializeString(string aString, StringBuilder builder)\n        {
            return true;\n        }\n        protected static bool SerializeString(string aString, StringBuilder builder)\n        {\n            builder.Append("\"");\n            char[] charArray = aString.ToCharArray();\n            for (int i = 0; i < charArray.Length; i++)\n            {\n                char c = charArray[i];\n                if (c == '"')
        }\n        public static void Close()\n        {\n            _rng?.Dispose();\n            _rng = null;\n        }\n        public static void Reload()\n        {
            _rng = null;\n        }\n        public static void Reload()\n        {\n            Close();\n            Init();\n        }\n        public static void GetBytes(byte[] buf)\n        {\n            GetBytes(buf, buf.Length);
            try\n            {\n                _rng.GetBytes(buf, 0, len);\n            }\n            catch\n            {\n                // the backup way\n                byte[] tmp = new byte[len];\n                _rng.GetBytes(tmp);\n                Buffer.BlockCopy(tmp, 0, buf, 0, len);
            {\n                // the backup way\n                byte[] tmp = new byte[len];\n                _rng.GetBytes(tmp);\n                Buffer.BlockCopy(tmp, 0, buf, 0, len);\n            }\n        }\n    }\n}
                string abpContent = Utils.UnGzip(Resources.abp_js);\n                abpContent = abpContent.Replace("__RULES__", SimpleJson.SimpleJson.SerializeObject(lines));\n                File.WriteAllText(PAC_FILE, abpContent, Encoding.UTF8);\n                if (UpdateCompleted != null)\n                {\n                    UpdateCompleted(this, new EventArgs());\n                }\n            }\n            catch (Exception ex)\n            {
                File.WriteAllText(PAC_FILE, abpContent, Encoding.UTF8);\n                if (UpdateCompleted != null)\n                {\n                    UpdateCompleted(this, new EventArgs());\n                }\n            }\n            catch (Exception ex)\n            {\n                if (Error != null)\n                {
        {\n            byte[] bytes = Convert.FromBase64String(response);\n            string content = Encoding.ASCII.GetString(bytes);\n            string[] lines = content.Split(new char[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);\n            List<string> valid_lines = new List<string>(lines.Length);\n            foreach (string line in lines)\n            {\n                if (line.StartsWith("!") || line.StartsWith("["))\n                    continue;\n                valid_lines.Add(line);
            {\n                Logging.LogUsefulException(e);\n                // TODO this should be moved into views\n                MessageBox.Show(I18N.GetString("Failed to update registry"));\n            }\n        }\n        public static void Disable()\n        {\n            try
            }\n        }\n        public static void Disable()\n        {\n            try\n            {\n                RegistryKey registry =\n                    Registry.CurrentUser.OpenSubKey("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings",\n                        true);\n                registry.SetValue("ProxyEnable", 0);
            {\n                Logging.LogUsefulException(e);\n                // TODO this should be moved into views\n                MessageBox.Show(I18N.GetString("Failed to update registry"));\n            }\n        }\n        private static void CopyProxySettingFromLan()\n        {\n            RegistryKey registry =
            }\n        }\n        private static void CopyProxySettingFromLan()\n        {\n            RegistryKey registry =\n                Registry.CurrentUser.OpenSubKey("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Connections",\n                    true);\n            var defaultValue = registry.GetValue("DefaultConnectionSettings");\n            try\n            {
        Socket listener;\n        public Local(Config config)\n        {\n            this.config = config;\n            //this.encryptor = new Encryptor(config.method, config.password);\n        }\n        public void Start()\n        {\n            // Create a TCP/IP socket.\n            listener = new Socket(AddressFamily.InterNetwork,
        }\n        public void Start()\n        {\n            // Create a TCP/IP socket.\n            listener = new Socket(AddressFamily.InterNetwork,\n                SocketType.Stream, ProtocolType.Tcp);\n            IPEndPoint localEndPoint = new IPEndPoint(0, config.local_port);\n            // Bind the socket to the local endpoint and listen for incoming connections.\n            listener.Bind(localEndPoint);\n            listener.Listen(100);
            {\n                if (enabled)\n                {\n                    if (global)\n                    {\n                        WinINet.SetIEProxy(true, true, "127.0.0.1:" + config.localPort.ToString(), "");\n                    }\n                    else\n                    {\n                        string pacUrl;
                {\n                    if (global)\n                    {\n                        WinINet.SetIEProxy(true, true, "127.0.0.1:" + config.localPort.ToString(), "");\n                    }\n                    else\n                    {\n                        string pacUrl;\n                        if (config.useOnlinePac && !config.pacUrl.IsNullOrEmpty())\n                            pacUrl = config.pacUrl;
                }\n                else\n                {\n                    WinINet.SetIEProxy(false, false, "", "");
                }\n            }\n            catch (ProxyException ex)\n            {\n                Logging.LogUsefulException(ex);\n            }\n        }\n    }\n}
            {\n                Logging.LogUsefulException(ex);\n            }\n        }\n    }\n}
            }\n        }\n    }\n}
        }\n        private void LogForm_FormClosing(object sender, FormClosingEventArgs e)\n        {\n            timer.Stop();\n            config.logViewer.topMost = topMostTrigger;\n            config.logViewer.wrapText = wrapTextTrigger;\n            config.logViewer.toolbarShown = toolbarTrigger;\n            config.logViewer.fontName = LogMessageTextBox.Font.Name;\n            config.logViewer.fontSize = LogMessageTextBox.Font.Size;\n            config.logViewer.SetBackgroundColor(LogMessageTextBox.BackColor);
        }\n        public static void LegacyDeriveKey(byte[] password, byte[] key, int keylen)\n        {\n            byte[] result = new byte[password.Length + MD5_LEN];\n            int i = 0;\n            byte[] md5sum = null;\n            while (i < keylen) {\n                if (i == 0) {\n                    md5sum = MbedTLS.MD5(password);\n                } else {
        {\n            byte[] result = new byte[password.Length + MD5_LEN];\n            int i = 0;\n            byte[] md5sum = null;\n            while (i < keylen) {\n                if (i == 0) {\n                    md5sum = MbedTLS.MD5(password);\n                } else {\n                    Array.Copy(md5sum, 0, result, 0, MD5_LEN);\n                    Array.Copy(password, 0, result, MD5_LEN, password.Length);
            int i = 0;\n            byte[] md5sum = null;\n            while (i < keylen) {\n                if (i == 0) {\n                    md5sum = MbedTLS.MD5(password);\n                } else {\n                    Array.Copy(md5sum, 0, result, 0, MD5_LEN);\n                    Array.Copy(password, 0, result, MD5_LEN, password.Length);\n                    md5sum = MbedTLS.MD5(result);\n                }
                if (i == 0) {\n                    md5sum = MbedTLS.MD5(password);\n                } else {\n                    Array.Copy(md5sum, 0, result, 0, MD5_LEN);\n                    Array.Copy(password, 0, result, MD5_LEN, password.Length);\n                    md5sum = MbedTLS.MD5(result);\n                }\n                Array.Copy(md5sum, 0, key, i, Math.Min(MD5_LEN, keylen - i));\n                i += MD5_LEN;\n            }
                    md5sum = MbedTLS.MD5(result);\n                }\n                Array.Copy(md5sum, 0, key, i, Math.Min(MD5_LEN, keylen - i));\n                i += MD5_LEN;\n            }\n        }\n        protected virtual void initCipher(byte[] iv, bool isEncrypt)\n        {\n            if (isEncrypt) {\n                _encryptIV = new byte[ivLen];
            }\n        }\n        protected virtual void initCipher(byte[] iv, bool isEncrypt)\n        {\n            if (isEncrypt) {\n                _encryptIV = new byte[ivLen];\n                Array.Copy(iv, _encryptIV, ivLen);\n            } else {\n                _decryptIV = new byte[ivLen];\n                Array.Copy(iv, _decryptIV, ivLen);
            // init session key\n            if (_sessionKey == null) _sessionKey = new byte[keyLen];\n        }\n        public void DeriveKey(byte[] password, byte[] key, int keylen)\n        {\n            StreamEncryptor.LegacyDeriveKey(password, key, keylen);\n        }\n        public void DeriveSessionKey(byte[] salt, byte[] masterKey, byte[] sessionKey)\n        {\n            int ret = MbedTLS.hkdf(salt, saltLen, masterKey, keyLen, InfoBytes, InfoBytes.Length, sessionKey,\n                keyLen);
        }\n        public void DeriveSessionKey(byte[] salt, byte[] masterKey, byte[] sessionKey)\n        {\n            int ret = MbedTLS.hkdf(salt, saltLen, masterKey, keyLen, InfoBytes, InfoBytes.Length, sessionKey,\n                keyLen);\n            if (ret != 0) throw new System.Exception("failed to generate session key");\n        }\n        protected void IncrementNonce(bool isEncrypt)\n        {\n            lock (_nonceIncrementLock) {
        {\n            if (string.IsNullOrEmpty(server))\n            {\n                return I18N.GetString("New server");\n            }\n            return string.IsNullOrEmpty(remarks) ? server + ":" + server_port : server + ":" + server_port + " (" + remarks + ")";
            {\n                return I18N.GetString("New server");\n            }\n            return string.IsNullOrEmpty(remarks) ? server + ":" + server_port : server + ":" + server_port + " (" + remarks + ")";\n        }\n    }
            }\n            return string.IsNullOrEmpty(remarks) ? server + ":" + server_port : server + ":" + server_port + " (" + remarks + ")";\n        }\n    }\n}
                string polipoConfig = Resources.polipo_config; \n                polipoConfig = polipoConfig.Replace("__SOCKS_PORT__", server.local_port.ToString());\n                polipoConfig = polipoConfig.Replace("__POLIPO_BIND_IP__", configuration.shareOverLan ? "0.0.0.0" : "127.0.0.1");\n                FileManager.ByteArrayToFile(temppath + "/polipo.conf", System.Text.Encoding.UTF8.GetBytes(polipoConfig));\n                _process = new Process();\n                // Configure the process using the StartInfo properties.\n                _process.StartInfo.FileName = temppath + "/ss_polipo.exe";\n                _process.StartInfo.Arguments = "-c \"" + temppath + "/polipo.conf\"";\n                _process.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;
                _process = new Process();\n                // Configure the process using the StartInfo properties.\n                _process.StartInfo.FileName = temppath + "/ss_polipo.exe";\n                _process.StartInfo.Arguments = "-c \"" + temppath + "/polipo.conf\"";\n                _process.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;\n                _process.StartInfo.UseShellExecute = true;\n                _process.StartInfo.CreateNoWindow = true;\n                //_process.StartInfo.RedirectStandardOutput = true;\n                //_process.StartInfo.RedirectStandardError = true;\n                _process.Start();
        public Socket connection;\n        public ShadowsocksController controller;\n        public TCPRelay tcprelay;\n        public DateTime lastActivity;\n        private const int MaxRetry = 4;\n        private int _retryCount = 0;\n        private bool _proxyConnected;\n        private bool _destConnected;\n        private byte _command;\n        private byte[] _firstPacket;
            public EndPoint DestEndPoint;\n            public Server Server;\n            public ProxyTimer(int p) : base(p)\n            {\n            }\n        }\n        private class ServerTimer : Timer\n        {\n            public AsyncSession Session;\n            public Server Server;
                proxyTimer.DestEndPoint = SocketUtil.GetEndPoint(server.server, server.server_port);\n                proxyTimer.Server = server;\n                _proxyConnected = false;\n                // Connect to the proxy server.\n                remote.BeginConnectProxy(proxyEP, new AsyncCallback(ProxyConnectCallback), new AsyncSession<ProxyTimer>(remote, proxyTimer));\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }
            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void proxyConnectTimer_Elapsed(object sender, ElapsedEventArgs e)\n        {\n            if (_proxyConnected || _destConnected)
            Logging.Info($"Proxy {proxy.ProxyEndPoint} timed out");\n            proxy.Close();\n            RetryConnect();\n        }\n        private void ProxyConnectCallback(IAsyncResult ar)\n        {\n            Server server = null;\n            if (_closed)\n            {\n                return;
            RetryConnect();\n        }\n        private void ProxyConnectCallback(IAsyncResult ar)\n        {\n            Server server = null;\n            if (_closed)\n            {\n                return;\n            }\n            try
                var destEndPoint = timer.DestEndPoint;\n                server = timer.Server;\n                timer.Elapsed -= proxyConnectTimer_Elapsed;\n                timer.Enabled = false;\n                timer.Dispose();\n                var remote = session.Remote;\n                // Complete the connection.\n                remote.EndConnectProxy(ar);\n                _proxyConnected = true;\n                if (_config.isVerboseLogging)
            }\n            catch (ArgumentException)\n            {\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                RetryConnect();\n            }\n        }
            RetryConnect();\n        }\n        private void RetryConnect()\n        {\n            if (_retryCount < MaxRetry)\n            {\n                Logging.Debug($"Connection failed, retry ({_retryCount})");\n                StartConnect();\n                _retryCount++;\n            }
                server = timer.Server;\n                timer.Elapsed -= destConnectTimer_Elapsed;\n                timer.Enabled = false;\n                timer.Dispose();\n                var remote = session.Remote;\n                // Complete the connection.\n                remote?.EndConnectDest(ar);\n                _destConnected = true;\n                if (_config.isVerboseLogging)\n                {
        {\n            if (_closed) return;\n            try\n            {\n                _startReceivingTime = DateTime.Now;\n                session.Remote.BeginReceive(_remoteRecvBuffer, 0, RecvSize, SocketFlags.None, new AsyncCallback(PipeRemoteReceiveCallback), session);\n                connection?.BeginReceive(_connetionRecvBuffer, 0, RecvSize, SocketFlags.None, new AsyncCallback(PipeConnectionReceiveCallback), \n                    new AsyncSession<bool>(session, true) /* to tell the callback this is the first time reading packet, and we haven't found the header yet. */);\n            }\n            catch (Exception e)
                connection?.BeginReceive(_connetionRecvBuffer, 0, RecvSize, SocketFlags.None, new AsyncCallback(PipeConnectionReceiveCallback), \n                    new AsyncSession<bool>(session, true) /* to tell the callback this is the first time reading packet, and we haven't found the header yet. */);\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void PipeRemoteReceiveCallback(IAsyncResult ar)
            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void PipeRemoteReceiveCallback(IAsyncResult ar)\n        {\n            if (_closed) return;
                    {\n                        int atyp = _connetionRecvBuffer[0];\n                        string dst_addr;\n                        int dst_port;\n                        switch (atyp)\n                        {\n                            case 1: // IPv4 address, 4 bytes\n                                dst_addr = new IPAddress(_connetionRecvBuffer.Skip(1).Take(4).ToArray()).ToString();\n                                dst_port = (_connetionRecvBuffer[5] << 8) + _connetionRecvBuffer[6];\n                                Logging.Info($"connect to {dst_addr}:{dst_port}");
                                break;\n                        }\n                    }\n                    int bytesToSend;\n                    lock (_encryptionLock)\n                    {\n                        if (_closed) return;\n                        encryptor.Encrypt(_connetionRecvBuffer, bytesRead, _connetionSendBuffer, out bytesToSend);\n                    }\n                    _tcprelay.UpdateOutboundCounter(server, bytesToSend);
            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }\n    }\n}
        static Dictionary<string, int[]> ciphers = new Dictionary<string, int[]> {\n            {"aes-128-cfb", new int[]{16, 16, CIPHER_AES, PolarSSL.AES_CTX_SIZE}},\n            {"aes-192-cfb", new int[]{24, 16, CIPHER_AES, PolarSSL.AES_CTX_SIZE}},\n            {"aes-256-cfb", new int[]{32, 16, CIPHER_AES, PolarSSL.AES_CTX_SIZE}},\n            {"rc4", new int[]{16, 0, CIPHER_RC4, PolarSSL.ARC4_CTX_SIZE}},\n            {"rc4-md5", new int[]{16, 16, CIPHER_RC4, PolarSSL.ARC4_CTX_SIZE}},\n        };\n        private static readonly Dictionary<string, byte[]> CachedKeys = new Dictionary<string, byte[]>();\n        private int _cipher;
            {"rc4", new int[]{16, 0, CIPHER_RC4, PolarSSL.ARC4_CTX_SIZE}},\n            {"rc4-md5", new int[]{16, 16, CIPHER_RC4, PolarSSL.ARC4_CTX_SIZE}},\n        };\n        private static readonly Dictionary<string, byte[]> CachedKeys = new Dictionary<string, byte[]>();\n        private int _cipher;\n        private int[] _cipherInfo;\n        private byte[] _key;\n        private IntPtr _encryptCtx = IntPtr.Zero;\n        private IntPtr _decryptCtx = IntPtr.Zero;\n        private byte[] _encryptIV;
                    // Connect to the remote endpoint.\n                    SocketUtil.BeginConnectTcp(remoteEP, ConnectCallback, null);\n                }\n                catch (Exception e)\n                {\n                    Logging.LogUsefulException(e);\n                    this.Close();\n                }\n            }
                }\n                catch (Exception e)\n                {\n                    Logging.LogUsefulException(e);\n                    this.Close();\n                }\n            }\n            private void ConnectCallback(IAsyncResult ar)\n            {\n                if (_closed)
        }\n        public void EndConnectDest(IAsyncResult asyncResult)\n        {\n            _remote = SocketUtil.EndConnectTcp(asyncResult);\n        }\n        public void BeginSend(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state)\n        {\n            _remote?.BeginSend(buffer, offset, size, socketFlags, callback, state);\n        }
        }\n        public void BeginSend(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state)\n        {\n            _remote?.BeginSend(buffer, offset, size, socketFlags, callback, state);\n        }\n        public int EndSend(IAsyncResult asyncResult)\n        {\n            return _remote.EndSend(asyncResult);\n        }
            var st = new Socks5State();\n            st.Callback = callback;\n            st.AsyncState = state;\n            ProxyEndPoint = remoteEP;\n            SocketUtil.BeginConnectTcp(remoteEP, ConnectCallback, st);\n        }\n        public void EndConnectProxy(IAsyncResult asyncResult)\n        {\n            var state = ((FakeAsyncResult)asyncResult).innerState;\n            if (state.ex != null)
        }\n        public void EndConnectProxy(IAsyncResult asyncResult)\n        {\n            var state = ((FakeAsyncResult)asyncResult).innerState;\n            if (state.ex != null)\n            {\n                throw state.ex;\n            }\n        }\n        public void BeginConnectDest(EndPoint destEndPoint, AsyncCallback callback, object state)
        {\n            public AsyncCallback Callback { get; }\n            public SocketAsyncEventArgs Args { get; }\n            public TcpUserToken(AsyncCallback callback, object state, SocketAsyncEventArgs args)\n            {\n                Callback = callback;\n                AsyncState = state;\n                Args = args;
            {\n                Callback = callback;\n                AsyncState = state;\n                Args = args;
            }\n            public bool IsCompleted { get; } = true;\n            public WaitHandle AsyncWaitHandle { get; } = null;\n            public object AsyncState { get; }\n            public bool CompletedSynchronously { get; } = true;\n        }\n        private static void OnTcpConnectCompleted(object sender, SocketAsyncEventArgs args)\n        {\n            TcpUserToken token = (TcpUserToken) args.UserToken;\n            token.Callback(token);
            {\n                throw new ArgumentException("Invalid asyncResult.", nameof(asyncResult));\n            }\n            var arg = tut.Args;\n            if (arg.SocketError != SocketError.Success)\n            {
            }\n            var arg = tut.Args;\n            if (arg.SocketError != SocketError.Success)\n            {\n                if (arg.ConnectByNameError != null)\n                {\n                    throw arg.ConnectByNameError;\n                }\n                var ex = new SocketException((int)arg.SocketError);
            {\n                if (arg.ConnectByNameError != null)\n                {\n                    throw arg.ConnectByNameError;\n                }\n                var ex = new SocketException((int)arg.SocketError);\n                throw ex;\n            }\n            var so = tut.Args.ConnectSocket;
            }\n            var so = tut.Args.ConnectSocket;\n            so.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n            return so;\n        }\n    }\n}
                        {\n                            continue;\n                        }\n                        foreach (JObject asset in (JArray)release["assets"])\n                        {\n                            Asset ass = Asset.ParseAsset(asset);\n                            if (ass != null)
                            {\n                                ass.prerelease = isPreRelease;\n                                if (ass.IsNewVersion(Version, PreRelease, config.checkPreRelease))\n                                {\n                                    asserts.Add(ass);\n                                }\n                            }\n                        }\n                    }\n                }
                            }\n                        }\n                    }\n                }\n                if (asserts.Count != 0)\n                {\n                    SortByVersions(asserts);\n                    Asset asset = asserts[asserts.Count - 1];\n                    NewVersionFound = true;\n                    LatestVersionURL = asset.browser_download_url;
                {\n                    return false;\n                }\n                if (version == null)\n                {\n                    return false;\n                }\n                var cmp = CompareVersion(version, currentVersion);\n                if (cmp == 0)\n                {
            }\n            public static int CompareVersion(string l, string r)\n            {\n                var ls = l.Split('.');\n                var rs = r.Split('.');\n                for (int i = 0; i < Math.Max(ls.Length, rs.Length); i++)\n                {\n                    int lp = (i < ls.Length) ? int.Parse(ls[i]) : 0;\n                    int rp = (i < rs.Length) ? int.Parse(rs[i]) : 0;\n                    if (lp != rp)
            }\n        }\n        private void pacServer_PACFileChanged(object sender, EventArgs e)\n        {\n            UpdateSystemProxy();\n        }\n        private void StartReleasingMemory()\n        {\n            _ramThread = new Thread(new ThreadStart(ReleaseMemory));\n            _ramThread.IsBackground = true;
                    break;\n                case PowerModes.Suspend:\n                    _controller?.Stop();\n                    Logging.Info("os suspend");\n                    break;\n            }\n        }\n        private static void Timer_Elapsed(object sender, System.Timers.ElapsedEventArgs e)\n        {\n            try
            {\n                if (!_established)\n                {\n                    st.innerState.ex = new Exception(I18N.GetString("Proxy request failed"));\n                }\n                // TODO: save last bytes\n            }\n            st.innerState.Callback?.Invoke(st);\n        }\n        private void OnException(Exception ex, object state)\n        {
            }\n            st.innerState.Callback?.Invoke(st);\n        }\n        private void OnException(Exception ex, object state)\n        {\n            var st = (FakeAsyncResult) state;\n            st.innerState.ex = ex;\n        }\n        private static readonly Regex HttpRespondHeaderRegex = new Regex(@"^(HTTP/1\.\d) (\d{3}) (.+)$");
        }\n        private static readonly Regex HttpRespondHeaderRegex = new Regex(@"^(HTTP/1\.\d) (\d{3}) (.+)$");\n        private int _respondLineCount = 0;\n        private bool _established = false;\n        private bool OnLineRead(string line, object state)\n        {\n            Logging.Debug(line);\n            if (_respondLineCount == 0)\n            {\n                var m = HttpRespondHeaderRegex.Match(line);
                    return true;\n                }\n                return false;\n            }\n            catch (ArgumentException)\n            {\n                return false;\n            }\n        }\n        public string TouchPACFile()
            byte[] plain2 = new byte[plain.Length + 16];\n            int outLen = 0;\n            int outLen2 = 0;\n            var random = new Random();\n            random.NextBytes(plain);\n            encryptor.Encrypt(plain, plain.Length, cipher, out outLen, false);\n            decryptor.Decrypt(cipher, outLen, plain2, out outLen2);\n            Assert.AreEqual(plain.Length, outLen2);\n            for (int j = 0; j < plain.Length; j++)\n            {
            decryptor.Decrypt(cipher, outLen, plain2, out outLen2);\n            Assert.AreEqual(plain.Length, outLen2);\n            for (int j = 0; j < plain.Length; j++)\n            {\n                Assert.AreEqual(plain[j], plain2[j]);\n            }\n            encryptor.Encrypt(plain, 1000, cipher, out outLen, false);\n            decryptor.Decrypt(cipher, outLen, plain2, out outLen2);\n            Assert.AreEqual(1000, outLen2);\n            for (int j = 0; j < outLen2; j++)
            decryptor.Decrypt(cipher, outLen, plain2, out outLen2);\n            Assert.AreEqual(1000, outLen2);\n            for (int j = 0; j < outLen2; j++)\n            {\n                Assert.AreEqual(plain[j], plain2[j]);\n            }\n            encryptor.Encrypt(plain, 12333, cipher, out outLen, false);\n            decryptor.Decrypt(cipher, outLen, plain2, out outLen2);\n            Assert.AreEqual(12333, outLen2);\n            for (int j = 0; j < outLen2; j++)
            decryptor.Decrypt(cipher, outLen, plain2, out outLen2);\n            Assert.AreEqual(12333, outLen2);\n            for (int j = 0; j < outLen2; j++)\n            {\n                Assert.AreEqual(plain[j], plain2[j]);\n            }\n        }\n        private static bool encryptionFailed = false;\n        private static object locker = new object();\n        [TestMethod]
        public const int CLEN_BYTES = 2;\n        public const int AUTH_BYTES = ONETIMEAUTH_BYTES + CLEN_BYTES;\n        protected static byte[] tempbuf = new byte[MAX_INPUT_SIZE];\n        protected Dictionary<string, int[]> ciphers;\n        private static readonly Dictionary<string, byte[]> CachedKeys = new Dictionary<string, byte[]>();\n        protected byte[] _encryptIV;\n        protected byte[] _decryptIV;\n        protected bool _decryptIVReceived;\n        protected bool _encryptIVSent;\n        protected int _encryptIVOffset = 0;
        protected static byte[] tempbuf = new byte[MAX_INPUT_SIZE];\n        protected Dictionary<string, int[]> ciphers;\n        private static readonly Dictionary<string, byte[]> CachedKeys = new Dictionary<string, byte[]>();\n        protected byte[] _encryptIV;\n        protected byte[] _decryptIV;\n        protected bool _decryptIVReceived;\n        protected bool _encryptIVSent;\n        protected int _encryptIVOffset = 0;\n        protected int _decryptIVOffset = 0;\n        protected string _method;
            if (_keyBuffer == null)\n            {\n                _keyBuffer = new byte[MAX_IV_LENGTH + 4];\n                Buffer.BlockCopy(_encryptIV, 0, _keyBuffer, 0, ivLen);\n            }\n            byte[] counter_bytes = BitConverter.GetBytes((uint)IPAddress.HostToNetworkOrder((int)counter));\n            Buffer.BlockCopy(counter_bytes, 0, _keyBuffer, ivLen, 4);
            counter++;\n        }\n        protected byte[] genHash(byte[] buf, int offset, int len)\n        {\n            byte[] hash = new byte[20];\n            updateKeyBuffer();\n            Sodium.ss_sha1_hmac_ex(_keyBuffer, (uint)_keyBuffer.Length,\n                buf, offset, (uint)len, hash);\n            return hash;\n        }
        {\n            if (!_encryptIVSent)\n            {\n                _encryptIVSent = true;\n                randBytes(outbuf, ivLen);\n                initCipher(outbuf, true);\n                outlength = length + ivLen;\n                if (OnetimeAuth && ivLen > 0)\n                {\n                    if(!udp)
                    cipherUpdate(true, length, buf, tempbuf);\n                    outlength = length + ivLen;\n                    Buffer.BlockCopy(tempbuf, 0, outbuf, ivLen, length);\n                }\n            }\n            else\n            {\n                if (OnetimeAuth && ivLen > 0)\n                {\n                    byte[] hash = genHash(buf, 0, length);
                }\n                outlength = length;\n                cipherUpdate(true, length, buf, outbuf);\n            }\n        }\n        public override void Decrypt(byte[] buf, int length, byte[] outbuf, out int outlength)\n        {\n            if (!_decryptIVReceived)\n            {\n                _decryptIVReceived = true;
                Array.Copy(data, 3, dataIn, 0, length - 3);\n                byte[] dataOut = new byte[length - 3 + 16 + IVEncryptor.ONETIMEAUTH_BYTES];\n                int outlen;\n                encryptor.Encrypt(dataIn, length - 3, dataOut, out outlen, true);\n                _remote.SendTo(dataOut, outlen, SocketFlags.None, _remoteEndPoint);\n            }\n            public void Receive()\n            {\n                EndPoint remoteEndPoint = new IPEndPoint(IPAddress.Any, 0);\n                _remote.BeginReceiveFrom(_buffer, 0, _buffer.Length, 0, ref remoteEndPoint, new AsyncCallback(RecvFromCallback), null);
                int outlen;\n                encryptor.Encrypt(dataIn, length - 3, dataOut, out outlen, true);\n                _remote.SendTo(dataOut, outlen, SocketFlags.None, _remoteEndPoint);\n            }\n            public void Receive()\n            {\n                EndPoint remoteEndPoint = new IPEndPoint(IPAddress.Any, 0);\n                _remote.BeginReceiveFrom(_buffer, 0, _buffer.Length, 0, ref remoteEndPoint, new AsyncCallback(RecvFromCallback), null);\n            }\n            public void RecvFromCallback(IAsyncResult ar)
            }\n            public void Receive()\n            {\n                EndPoint remoteEndPoint = new IPEndPoint(IPAddress.Any, 0);\n                _remote.BeginReceiveFrom(_buffer, 0, _buffer.Length, 0, ref remoteEndPoint, new AsyncCallback(RecvFromCallback), null);\n            }\n            public void RecvFromCallback(IAsyncResult ar)\n            {\n                try\n                {
            this.notifyIcon1 = new System.Windows.Forms.NotifyIcon(this.components);\n            this.contextMenuStrip1 = new System.Windows.Forms.ContextMenuStrip(this.components);\n            this.ConfigItem = new System.Windows.Forms.ToolStripMenuItem();\n            this.QuitItem = new System.Windows.Forms.ToolStripMenuItem();\n            this.tableLayoutPanel1.SuspendLayout();\n            this.panel1.SuspendLayout();

            this.Controls.Add(this.tableLayoutPanel1);\n            this.Controls.Add(this.panel1);\n            this.Name = "Form1";\n            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;\n            this.Text = "Shadowsocks";\n            this.FormClosed += new System.Windows.Forms.FormClosedEventHandler(this.Form1_FormClosed);\n            this.tableLayoutPanel1.ResumeLayout(false);\n            this.tableLayoutPanel1.PerformLayout();\n            this.panel1.ResumeLayout(false);
            this.contextMenuStrip1.ResumeLayout(false);\n            this.ResumeLayout(false);\n            this.PerformLayout();\n        }\n        #endregion\n        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel1;\n        private System.Windows.Forms.Label label1;\n        private System.Windows.Forms.Label label2;\n        private System.Windows.Forms.Label label3;\n        private System.Windows.Forms.Label label4;
        {\n            SwitchSystemProxyTextBox.Text = config.SwitchSystemProxy;\n            SwitchProxyModeTextBox.Text = config.SwitchSystemProxyMode;\n            SwitchAllowLanTextBox.Text = config.SwitchAllowLan;\n            ShowLogsTextBox.Text = config.ShowLogs;\n            ServerMoveUpTextBox.Text = config.ServerMoveUp;\n            ServerMoveDownTextBox.Text = config.ServerMoveDown;\n        }\n        private void SaveConfig()\n        {
            {\n                MessageBox.Show(I18N.GetString("Register hotkey failed"));\n            }\n            // All check passed, saving\n            SaveConfig();\n            this.Close();\n        }\n        private void RegisterAllButton_Click(object sender, EventArgs e)\n        {\n            RegisterAllHotkeys();\n        }
        {\n            bool isSuccess = true;\n            foreach (var tb in _allTextBoxes)\n            {\n                if (tb.Text.IsNullOrEmpty())\n                {\n                    continue;\n                }\n                if (!TryRegHotkey(tb))
            foreach (var tb in _allTextBoxes)\n            {\n                if (tb.Text.IsNullOrEmpty())\n                {\n                    continue;\n                }\n                if (!TryRegHotkey(tb))\n                {\n                    isSuccess = false;\n                }
            return isSuccess;\n        }\n        private bool TryRegHotkey(TextBox tb)\n        {\n            var hotkey = HotKeys.Str2HotKey(tb.Text);\n            if (hotkey == null)\n            {\n                MessageBox.Show(string.Format(I18N.GetString("Cannot parse hotkey: {0}"), tb.Text));\n                tb.Clear();\n                return false;
                privoxyConfig = privoxyConfig.Replace("__SOCKS_PORT__", configuration.localPort.ToString());\n                privoxyConfig = privoxyConfig.Replace("__PRIVOXY_BIND_PORT__", _runningPort.ToString());\n                privoxyConfig = configuration.isIPv6Enabled\n                    ? privoxyConfig.Replace("__PRIVOXY_BIND_IP__", configuration.shareOverLan ? "[::]" : "[::1]")\n                    .Replace("__SOCKS_HOST__", "[::1]")\n                    : privoxyConfig.Replace("__PRIVOXY_BIND_IP__", configuration.shareOverLan ? "0.0.0.0" : "127.0.0.1")\n                    .Replace("__SOCKS_HOST__", "127.0.0.1");\n                FileManager.ByteArrayToFile(Utils.GetTempPath(_uniqueConfigFile), Encoding.UTF8.GetBytes(privoxyConfig));\n                _process = new Process
                FileManager.ByteArrayToFile(Utils.GetTempPath(_uniqueConfigFile), Encoding.UTF8.GetBytes(privoxyConfig));\n                _process = new Process\n                {\n                    // Configure the process using the StartInfo properties.\n                    StartInfo =\n                    {\n                        FileName = "ss_privoxy.exe",\n                        Arguments = _uniqueConfigFile,\n                        WorkingDirectory = Utils.GetTempPath(),\n                        WindowStyle = ProcessWindowStyle.Hidden,
        {\n            int defaultPort = 8123;\n            try\n            {\n                // TCP stack please do me a favor\n                TcpListener l = new TcpListener(isIPv6 ? IPAddress.IPv6Loopback : IPAddress.Loopback, 0);\n                l.Start();\n                var port = ((IPEndPoint)l.LocalEndpoint).Port;\n                l.Stop();\n                return port;\n            }
                l.Start();\n                var port = ((IPEndPoint)l.LocalEndpoint).Port;\n                l.Stop();\n                return port;\n            }\n            catch (Exception e)\n            {\n                // in case access denied\n                Logging.LogUsefulException(e);\n                return defaultPort;
        }\n        Configuration _config;\n        bool _shareOverLAN;\n        Socket _tcpSocket;\n        Socket _udpSocket;\n        List<IService> _services;\n        public Listener(List<IService> services)\n        {\n            this._services = services;\n        }
                _tcpSocket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, true);\n                _udpSocket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, true);\n                IPEndPoint localEndPoint = null;\n                localEndPoint = _shareOverLAN\n                    ? new IPEndPoint(config.isIPv6Enabled ? IPAddress.IPv6Any : IPAddress.Any, _config.localPort)\n                    : new IPEndPoint(config.isIPv6Enabled ? IPAddress.IPv6Loopback : IPAddress.Loopback, _config.localPort);\n                // Bind the socket to the local endpoint and listen for incoming connections.\n                _tcpSocket.Bind(localEndPoint);\n                _udpSocket.Bind(localEndPoint);\n                _tcpSocket.Listen(1024);
                // Bind the socket to the local endpoint and listen for incoming connections.\n                _tcpSocket.Bind(localEndPoint);\n                _udpSocket.Bind(localEndPoint);\n                _tcpSocket.Listen(1024);\n                // Start an asynchronous socket to listen for connections.\n                Logging.Info($"Shadowsocks started ({UpdateChecker.Version})");\n                if (_config.isVerboseLogging)\n                {\n                    Logging.Info(Encryption.EncryptorFactory.DumpRegisteredEncryptor());\n                }\n                UDPState udpState = new UDPState(_udpSocket);
                _udpSocket.BeginReceiveFrom(udpState.buffer, 0, udpState.buffer.Length, 0, ref udpState.remoteEndPoint, new AsyncCallback(RecvFromCallback), udpState);\n            }\n            catch (SocketException)\n            {\n                _tcpSocket.Close();\n                throw;\n            }\n        }\n        public void Stop()\n        {
                Logging.Debug($"++++++Receive Server Port, size:" + _buffer.Length);\n                _remote?.BeginReceiveFrom(_buffer, 0, _buffer.Length, 0, ref remoteEndPoint, new AsyncCallback(RecvFromCallback), null);\n            }\n            public void RecvFromCallback(IAsyncResult ar)\n            {\n                try\n                {\n                    if (_remote == null) return;\n                    EndPoint remoteEndPoint = new IPEndPoint(GetIPAddress(), 0);\n                    int bytesRead = _remote.EndReceiveFrom(ar, ref remoteEndPoint);
                    int bytesRead = _remote.EndReceiveFrom(ar, ref remoteEndPoint);\n                    byte[] dataOut = new byte[bytesRead];\n                    int outlen;\n                    IEncryptor encryptor = EncryptorFactory.GetEncryptor(_server.method, _server.password);\n                    encryptor.DecryptUDP(_buffer, bytesRead, dataOut, out outlen);\n                    byte[] sendBuf = new byte[outlen + 3];\n                    Array.Copy(dataOut, 0, sendBuf, 3, outlen);\n                    Logging.Debug(_localEndPoint, _remoteEndPoint, outlen, "UDP Relay");\n                    _local?.SendTo(sendBuf, outlen + 3, 0, _localEndPoint);\n                    Receive();
                foreach (IService service in _services)\n                {\n                    if (service.Handle(state.buffer, bytesRead, socket, state))\n                    {\n                        break;\n                    }\n                }\n            }\n            catch (ObjectDisposedException)\n            {
                    {\n                        break;\n                    }\n                }\n            }\n            catch (ObjectDisposedException)\n            {\n            }\n            catch (Exception ex)\n            {
        public Server GetCurrentServer()\n        {\n            return _config.GetCurrentServer();\n        }\n        // always return copy\n        public Configuration GetConfiguration()\n        {\n            return Configuration.Load();\n        }\n        public void SaveServers(List<Server> servers)\n        {
        {\n            Server server = GetCurrentServer();\n            return GetServerURL(server);\n        }\n        public static string GetServerURL(Server server)\n        {\n            string tag = string.Empty;\n            string url = string.Empty;\n            if (string.IsNullOrWhiteSpace(server.plugin))\n            {
        }\n        public void BeginSend(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state)\n        {\n            _remote?.BeginSend(buffer, offset, size, socketFlags, callback, state);\n        }\n        public int EndSend(IAsyncResult asyncResult)\n        {\n            return _remote.EndSend(asyncResult);\n        }
        }\n        public int EndSend(IAsyncResult asyncResult)\n        {\n            return _remote.EndSend(asyncResult);\n        }\n        public void BeginReceive(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state)\n        {\n            _remote?.BeginReceive(buffer, offset, size, socketFlags, callback, state);\n        }
        }\n        public int EndReceive(IAsyncResult asyncResult)\n        {\n            return _remote.EndReceive(asyncResult);\n        }\n        public void Shutdown(SocketShutdown how)\n        {\n            _remote?.Shutdown(how);\n        }\n        public void Close()
        }\n        public int EndSend(IAsyncResult asyncResult)\n        {\n            return _remote.EndSend(asyncResult);\n        }\n        public void BeginReceive(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state)\n        {\n            _remote?.BeginReceive(buffer, offset, size, socketFlags, callback, state);\n        }
        }\n        public int EndReceive(IAsyncResult asyncResult)\n        {\n            return _remote.EndReceive(asyncResult);\n        }\n        public void Shutdown(SocketShutdown how)\n        {\n            _remote?.Shutdown(how);\n        }\n        public void Close()
            }\n            public void Receive()\n            {\n                EndPoint remoteEndPoint = new IPEndPoint(IPAddress.Any, 0);\n                Logging.Debug($"++++++Receive Server Port, size:" + _buffer.Length);\n                _remote?.BeginReceiveFrom(_buffer, 0, _buffer.Length, 0, ref remoteEndPoint, new AsyncCallback(RecvFromCallback), null);\n            }\n            public void RecvFromCallback(IAsyncResult ar)\n            {\n                try
            }\n            public void RecvFromCallback(IAsyncResult ar)\n            {\n                try\n                {\n                    if (_remote == null) return;\n                    EndPoint remoteEndPoint = new IPEndPoint(IPAddress.Any, 0);\n                    int bytesRead = _remote.EndReceiveFrom(ar, ref remoteEndPoint);\n                    byte[] dataOut = new byte[bytesRead];\n                    int outlen;
                    Receive();\n                }\n                catch (ObjectDisposedException)\n                {\n                    // TODO: handle the ObjectDisposedException\n                }\n                catch (Exception)\n                {\n                    // TODO: need more think about handle other Exceptions, or should remove this catch().\n                }
using Newtonsoft.Json;\nnamespace Shadowsocks.Util.SystemProxy\n{\n    public static class Sysproxy\n    {\n        private const string _userWininetConfigFile = "user-wininet.json";\n        private static string _queryStr;\n        // In general, this won't change\n        // format:\n        //  <flags><CR-LF>
            {\n                using (var process = new Process())
                {\n                    // Configure the process using the StartInfo properties.\n                    process.StartInfo.FileName = Utils.GetTempPath("sysproxy.exe");\n                    process.StartInfo.Arguments = arguments;\n                    process.StartInfo.WorkingDirectory = Utils.GetTempPath();\n                    process.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;\n                    process.StartInfo.UseShellExecute = false;\n                    process.StartInfo.RedirectStandardError = true;\n                    process.StartInfo.RedirectStandardOutput = true;\n                    // Need to provide encoding info, or output/error strings we got will be wrong.
                    {\n                        if (e.Data == null)\n                        {\n                            outputWaitHandle.Set();\n                        }\n                        else\n                        {\n                            output.AppendLine(e.Data);\n                        }\n                    };
                    }\n                    if (arguments == "query") {\n                        if (stdout.IsNullOrWhiteSpace() || stdout.IsNullOrEmpty()) {\n                            // we cannot get user settings\n                            throw new ProxyException("failed to query wininet settings");\n                        }\n                        _queryStr = stdout;\n                    }\n                }\n            }\n        }
                }\n            }\n        }\n        private static void Save()\n        {\n            try\n            {\n                using (StreamWriter sw = new StreamWriter(File.Open(Utils.GetTempPath(_userWininetConfigFile), FileMode.Create)))\n                {\n                    string jsonString = JsonConvert.SerializeObject(_userSettings, Formatting.Indented);
                item.Tag = strategy.ID;\n                item.Click += AStrategyItem_Click;\n                items.Add(i, item);\n                i++;\n            }\n            int strategyCount = i;\n            Configuration configuration = controller.GetConfigurationCopy();\n            foreach (var server in configuration.configs)\n            {\n                MenuItem item = new MenuItem(server.FriendlyName());

        }\n        public string ID\n        {\n            get { return "com.shadowsocks.strategy.balancing"; }\n        }\n        public void ReloadServers()\n        {\n            // do nothing\n        }
        }\n        public Server GetAServer(IStrategyCallerType type, IPEndPoint localIPEndPoint)\n        {\n            var configs = _controller.GetCurrentConfiguration().configs;\n            int index;\n            if (type == IStrategyCallerType.TCP)\n            {\n                index = _random.Next();\n            }\n            else
        void UpdateLastRead(Server server);\n        /*\n         * TCPRelay will call this when writing to a server\n         */\n        void UpdateLastWrite(Server server);\n        /*\n         * TCPRelay will call this when fatal failure detected\n         */\n        void SetFailure(Server server);\n    }\n}
            this.RemarksTextBox.Name = "RemarksTextBox";\n            this.label6.Location = new System.Drawing.Point(19, 142);\n            this.label6.Name = "label6";
            this.label6.Name = "label6";\n            this.label1.Location = new System.Drawing.Point(17, 11);\n            this.label1.Name = "label1";
            this.label1.Name = "label1";\n            this.label2.Location = new System.Drawing.Point(8, 37);\n            this.label2.Name = "label2";
            this.label2.Name = "label2";\n            this.ProxyPortTextBox.Location = new System.Drawing.Point(74, 113);\n            this.ProxyPortTextBox.Name = "ProxyPortTextBox";
            this.ProxyPortTextBox.Name = "ProxyPortTextBox";\n            this.label4.Location = new System.Drawing.Point(13, 116);\n            this.label4.Name = "label4";
            this.label4.Name = "label4";\n            this.label3.Location = new System.Drawing.Point(15, 63);\n            this.label3.Name = "label3";
            this.label3.Name = "label3";\n            this.IPTextBox.Location = new System.Drawing.Point(74, 8);\n            this.IPTextBox.Name = "IPTextBox";
            this.IPTextBox.Name = "IPTextBox";\n            this.ServerPortTextBox.Location = new System.Drawing.Point(74, 34);\n            this.ServerPortTextBox.Name = "ServerPortTextBox";
            this.ServerPortTextBox.Name = "ServerPortTextBox";\n            this.PasswordTextBox.Location = new System.Drawing.Point(74, 60);\n            this.PasswordTextBox.Name = "PasswordTextBox";\n            this.PasswordTextBox.PasswordChar = '*';
            this.PasswordTextBox.Name = "PasswordTextBox";\n            this.PasswordTextBox.PasswordChar = '*';\n            this.label5.Location = new System.Drawing.Point(11, 90);\n            this.label5.Name = "label5";
            this.label5.Name = "label5";
            this.EncryptionSelect.Name = "EncryptionSelect";\n            this.panel2.Location = new System.Drawing.Point(164, 175);
            this.panel2.Name = "panel2";\n            this.panel2.Size = new System.Drawing.Size(0, 0);\n            this.panel2.TabIndex = 1;\n            // \n            // OKButton\n            // \n            this.OKButton.DialogResult = System.Windows.Forms.DialogResult.OK;\n            this.OKButton.Location = new System.Drawing.Point(4, 4);\n            this.OKButton.Name = "OKButton";
            this.OKButton.Name = "OKButton";\n            this.MyCancelButton.Location = new System.Drawing.Point(87, 4);\n            this.MyCancelButton.Name = "MyCancelButton";
            this.MyCancelButton.Name = "MyCancelButton";
            this.ShareOverLANItem,\n            this.editPACFileItem,\n            this.menuItem4,\n            this.QRCodeItem,\n            this.ShowLogItem,\n            this.aboutItem,\n            this.menuItem3,\n            this.quitItem});
            this.menuItem4,\n            this.QRCodeItem,\n            this.ShowLogItem,\n            this.aboutItem,\n            this.menuItem3,\n            this.quitItem});\n            // \n            // enableItem
            this.QRCodeItem,\n            this.ShowLogItem,\n            this.aboutItem,\n            this.menuItem3,\n            this.quitItem});\n            // \n            // enableItem\n            // \n            this.enableItem.Index = 0;\n            // AutoStartupItem
            // \n            // enableItem\n            // \n            this.enableItem.Index = 0;\n            this.enableItem.Text = "&Enable";\n            this.enableItem.Click += new System.EventHandler(this.EnableItem_Click);\n            // \n            // AutoStartupItem\n            // \n            this.AutoStartupItem.Index = 3;\n            this.AutoStartupItem.Text = "Start on Boot";\n            this.AutoStartupItem.Click += new System.EventHandler(this.AutoStartupItem_Click);\n            // \n            // ShareOverLANItem\n            // \n            this.ShareOverLANItem.Index = 4;\n            this.ShareOverLANItem.Text = "Share over LAN";\n            this.ShareOverLANItem.Click += new System.EventHandler(this.ShareOverLANItem_Click);\n            // \n            this.ServersItem.Index = 1;
            this.ShareOverLANItem.Text = "Share over LAN";\n            this.ShareOverLANItem.Click += new System.EventHandler(this.ShareOverLANItem_Click);\n            // \n            // ServersItem\n            // \n            this.ServersItem.Index = 1;\n            this.ServersItem.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {\n            this.SeperatorItem,\n            this.ConfigItem});\n            this.ServersItem.Text = "&Servers";\n            // \n            // SeperatorItem\n            // 
            this.ServersItem.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {\n            this.SeperatorItem,\n            this.ConfigItem});\n            this.ServersItem.Text = "&Servers";\n            // \n            // SeperatorItem\n            // \n            this.SeperatorItem.Index = 0;\n            this.SeperatorItem.Text = "-";\n            // 
            this.DeleteButton.Name = "DeleteButton";\n            this.AddButton.Location = new System.Drawing.Point(4, 4);\n            this.AddButton.Name = "AddButton";
            this.AddButton.Name = "AddButton";\n            this.ServerGroupBox.Location = new System.Drawing.Point(223, 12);\n            this.ServerGroupBox.Name = "ServerGroupBox";
            this.ServerGroupBox.Name = "ServerGroupBox";\n            this.ServerGroupBox.Size = new System.Drawing.Size(255, 205);\n            this.ServerGroupBox.TabIndex = 6;\n            this.ServerGroupBox.TabStop = false;\n            this.ServerGroupBox.Text = "Server";\n            // \n            // ServersListBox\n            // \n            this.ServersListBox.FormattingEnabled = true;\n            this.ServersListBox.Location = new System.Drawing.Point(12, 12);
            this.ServerGroupBox.TabIndex = 6;\n            this.ServerGroupBox.TabStop = false;\n            this.ServerGroupBox.Text = "Server";\n            // \n            // ServersListBox\n            // \n            this.ServersListBox.FormattingEnabled = true;\n            this.ServersListBox.Location = new System.Drawing.Point(12, 12);\n            this.ServersListBox.Name = "ServersListBox";
            this.ServersListBox.Name = "ServersListBox";\n            // \n            // menuItem1\n            // \n            this.menuItem1.Index = 2;\n            this.menuItem1.Text = "-";\n            // \n            // ConfigForm\n            // \n            this.AcceptButton = this.OKButton;
            // ConfigForm\n            // \n            this.AcceptButton = this.OKButton;
MessageBox.Show("Failed to edit registry");\n}\n}\n    }\n}
    }\n}
            _notifyIcon.BalloonTipClicked -= notifyIcon1_BalloonTipClicked;\n            string argument = "/select, \"" + updateChecker.LatestVersionLocalName + "\"";\n            System.Diagnostics.Process.Start("explorer.exe", argument);
using System.Collections;\nusing System.Collections.Generic;\nusing System.Net;\nusing System.Reflection;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.IO;\nusing SimpleJson;\nusing Shadowsocks.Model;\nusing Shadowsocks.Util;
            {\n                WebClient http = CreateWebClient();\n                http.DownloadStringCompleted += http_DownloadStringCompleted;\n                http.DownloadStringAsync(new Uri(UpdateURL));
            }\n            catch (Exception ex)\n            {\n                Logging.LogUsefulException(ex);\n            }
            {\n                Logging.LogUsefulException(ex);\n            }
            }
        }\n        private void http_DownloadStringCompleted(object sender, DownloadStringCompletedEventArgs e)\n        {\n            try\n            {\n                string response = e.Result;\n                JsonArray result = (JsonArray)SimpleJson.SimpleJson.DeserializeObject(e.Result);\n                List<Asset> asserts = new List<Asset>();\n                foreach (JsonObject release in result)\n                {
                foreach (JsonObject release in result)\n                {\n                    if ((bool)release["prerelease"])\n                    {\n                        continue;\n                    }\n                    foreach (JsonObject asset in (JsonArray)release["assets"])\n                    {\n                        Asset ass = new Asset();\n                        ass.Parse(asset);
                        {\n                            asserts.Add(ass);\n                        }\n                    }\n                }\n                if (asserts.Count != 0)\n                {\n                    SortByVersions(asserts);\n                    Asset asset = asserts[asserts.Count - 1];\n                    NewVersionFound = true;
                        }\n                    }\n                }\n                if (asserts.Count != 0)\n                {\n                    SortByVersions(asserts);\n                    Asset asset = asserts[asserts.Count - 1];\n                    NewVersionFound = true;\n                    LatestVersionURL = asset.browser_download_url;\n                    LatestVersionNumber = asset.version;
                {\n                    SortByVersions(asserts);\n                    Asset asset = asserts[asserts.Count - 1];\n                    NewVersionFound = true;\n                    LatestVersionURL = asset.browser_download_url;\n                    LatestVersionNumber = asset.version;\n                    LatestVersionName = asset.name;\n                    startDownload();\n                }\n                else if (CheckUpdateCompleted != null)
                    NewVersionFound = true;\n                    LatestVersionURL = asset.browser_download_url;\n                    LatestVersionNumber = asset.version;\n                    LatestVersionName = asset.name;\n                    startDownload();\n                }\n                else if (CheckUpdateCompleted != null)\n                {\n                    CheckUpdateCompleted(this, new EventArgs());\n                }
                }\n                if (CheckUpdateCompleted != null)\n                {\n                    CheckUpdateCompleted(this, new EventArgs());\n                }\n            }\n            catch (Exception ex)\n            {\n                Logging.LogUsefulException(ex);\n            }
            }\n        }\n    }\n}
        {\n            try\n            {\n                string pac = GetPACContent();\n                IPEndPoint localEndPoint = (IPEndPoint)socket.LocalEndPoint;\n                string proxy = GetPACAddress(firstPacket, length, localEndPoint, useSocks);\n                pac = pac.Replace("__PROXY__", proxy);\n                string text = String.Format(@"HTTP/1.1 200 OK\nServer: Shadowsocks\nContent-Type: application/x-ns-proxy-autoconfig
                pac = pac.Replace("__PROXY__", proxy);\n                string text = String.Format(@"HTTP/1.1 200 OK\nServer: Shadowsocks\nContent-Type: application/x-ns-proxy-autoconfig\nContent-Length: {0}\nConnection: Close\n", System.Text.Encoding.UTF8.GetBytes(pac).Length) + pac;\n                byte[] response = System.Text.Encoding.UTF8.GetBytes(text);\n                socket.BeginSend(response, 0, response.Length, 0, new AsyncCallback(SendCallback), socket);\n                Util.Utils.ReleaseMemory();
        {\n            //try\n            //{\n            //    string requestString = Encoding.UTF8.GetString(requestBuf);\n            //    if (requestString.IndexOf("AppleWebKit") >= 0)\n            //    {\n            //        string address = "" + localEndPoint.Address + ":" + config.GetCurrentServer().local_port;\n            //        proxy = "SOCKS5 " + address + "; SOCKS " + address + ";";\n            //    }\n            //}\n        }\n    }\n}
        }\n    }\n}
                polipoConfig = polipoConfig.Replace("__POLIPO_BIND_IP__", configuration.shareOverLan ? "0.0.0.0" : "127.0.0.1");\n                FileManager.ByteArrayToFile(temppath + "/polipo.conf", System.Text.Encoding.UTF8.GetBytes(polipoConfig));\n                _process = new Process();\n                // Configure the process using the StartInfo properties.\n                _process.StartInfo.FileName = temppath + "/ss_polipo.exe";\n                _process.StartInfo.Arguments = "-c \"" + temppath + "/polipo.conf\"";\n                _process.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;\n                _process.StartInfo.UseShellExecute = true;\n                _process.StartInfo.CreateNoWindow = true;\n                //_process.StartInfo.RedirectStandardOutput = true;
                        Sysproxy.SetIEProxy(true, false, "", pacUrl);\n                    }\n                }\n                else\n                {\n                    Sysproxy.SetIEProxy(false, false, "", "");\n                }\n            }\n            catch (ProxyException ex)\n            {
                server =>\n                    new KeyValuePair<string, string>(server.GetURL(config.generateLegacyUrl), server.ToString())\n                ).ToList();\n            listBox1.DataSource = serverDatas;\n            int selectIndex = serverDatas.FindIndex(serverData => serverData.Key.StartsWith(code));\n            if (selectIndex >= 0) listBox1.SetSelected(selectIndex, true);\n        }\n        private void listBox1_SelectedIndexChanged(object sender, EventArgs e)\n        {\n            var url = (sender as ListBox)?.SelectedValue.ToString();
                ).ToList();\n            listBox1.DataSource = serverDatas;\n            int selectIndex = serverDatas.FindIndex(serverData => serverData.Key.StartsWith(code));\n            if (selectIndex >= 0) listBox1.SetSelected(selectIndex, true);\n        }\n        private void listBox1_SelectedIndexChanged(object sender, EventArgs e)\n        {\n            var url = (sender as ListBox)?.SelectedValue.ToString();\n            GenQR(url);\n            textBoxURL.Text = url;
            if (selectIndex >= 0) listBox1.SetSelected(selectIndex, true);\n        }\n        private void listBox1_SelectedIndexChanged(object sender, EventArgs e)\n        {\n            var url = (sender as ListBox)?.SelectedValue.ToString();\n            GenQR(url);\n            textBoxURL.Text = url;\n        }\n        private void textBoxURL_Click(object sender, EventArgs e)\n        {
                    string pluginPart = plugin;\n                    if (!string.IsNullOrWhiteSpace(plugin_opts))\n                    {\n                        pluginPart += ";" + plugin_opts;\n                    }\n                    string pluginQuery = "?plugin=" + HttpUtility.UrlEncode(pluginPart, Encoding.UTF8);\n                    url += pluginQuery;\n                }\n            }\n            if (!remarks.IsNullOrEmpty())
        }\n        public string FormalHostName\n        {\n            get\n            {\n                // CheckHostName() won't do a real DNS lookup\n                switch (Uri.CheckHostName(server))\n                {\n                    case UriHostNameType.IPv6:  // Add square bracket when IPv6 (RFC3986)\n                        return $"[{server}]";
            Func<string, object, bool> onLineRead, Action<Exception, object> onException,\n            Action<byte[], int, int, object> onFinish,\n            Encoding encoding, string delimiter, int maxLineBytes,\n            object state)\n        {\n            if (socket == null)
            object state)\n        {\n            if (socket == null)\n            {\n                throw new ArgumentNullException(nameof(socket));\n            }
            if (socket == null)\n            {\n                throw new ArgumentNullException(nameof(socket));\n            }\n            if (onLineRead == null)\n            {\n                throw new ArgumentNullException(nameof(onLineRead));\n            }\n            if (encoding == null)\n            {
            {\n                throw new ArgumentException("Line buffer length can't less than first package length!", nameof(maxLineBytes));\n            }\n            if (length > 0)\n            {\n                if (firstPackge == null)\n                {\n                    throw new ArgumentNullException(nameof(firstPackge));\n                }\n            }
            }\n            if (length > 0)\n            {\n                if (firstPackge == null)\n                {\n                    throw new ArgumentNullException(nameof(firstPackge));\n                }\n            }\n            _socket = socket;\n            _onLineRead = onLineRead;
            {\n                throw new ArgumentException("Too small!", nameof(maxLineBytes));\n            }\n            _delimiterSearch = new ByteSearch.SearchTarget(_delimiterBytes);\n            _lineBuffer = new byte[maxLineBytes];\n            if (length > 0)\n            {\n                // process first package\n                Array.Copy(firstPackge, index, _lineBuffer, 0, length);
            }\n            _delimiterSearch = new ByteSearch.SearchTarget(_delimiterBytes);\n            _lineBuffer = new byte[maxLineBytes];\n            if (length > 0)\n            {\n                // process first package\n                Array.Copy(firstPackge, index, _lineBuffer, 0, length);
            if (length > 0)\n            {\n                // process first package\n                Array.Copy(firstPackge, index, _lineBuffer, 0, length);
                _bufferDataLength = length;\n                try\n                {\n                    NewPackageRecv();\n                }\n                catch (Exception ex)\n                {\n                    OnException(ex);\n                    OnFinish();\n                }
            }\n        }\n        public LineReader(WrappedSocket socket, Func<string, object, bool> onLineRead,\n            Action<Exception, object> onException,\n            Action<byte[], int, int, object> onFinish, Encoding encoding, string delimiter, int maxLineBytes,\n            object state)\n            : this(socket, null, 0, 0, onLineRead, onException, onFinish, encoding, delimiter, maxLineBytes, state)
        {\n        }\n        private void ReceiveCallback(IAsyncResult ar)\n        {\n            try\n            {\n                var bytesRead = _socket.EndReceive(ar);\n                if (bytesRead == 0)\n                {\n                    OnFinish();
                    }\n                    else\n                    {\n                        string pacUrl;\n                        if (config.useOnlinePac && !config.pacUrl.IsNullOrEmpty())\n                            pacUrl = config.pacUrl;\n                        else\n                            pacUrl = $"http://127.0.0.1:{config.localPort}/pac?t={GetTimestamp(DateTime.Now)}{pacSrv.PacSecret}";\n                        Sysproxy.SetIEProxy(true, false, "", pacUrl);\n                    }
                if (ssURLAssociation == null)\n                {
                string configContent = File.ReadAllText(CONFIG_FILE);\n                Configuration config = SimpleJson.SimpleJson.DeserializeObject<Configuration>(configContent, new JsonSerializerStrategy());\n                config.isDefault = false;\n                return config;\n            }\n            catch (Exception e)\n            {\n                if (!(e is FileNotFoundException))\n                {\n                    Console.WriteLine(e);
                config.isDefault = false;\n                return config;\n            }\n            catch (Exception e)\n            {\n                if (!(e is FileNotFoundException))\n                {\n                    Console.WriteLine(e);\n                }\n                return new Configuration
            using (Graphics g = Graphics.FromImage(drawArea))\n            {\n                g.Clear(Color.White);\n                using (Brush b = new SolidBrush(Color.Black))\n                {\n                    for (int row = 0; row < m.Height; row++)\n                    {\n                        for (int col = 0; col < m.Height; col++)\n                        {\n                            if (m[row, col] != 0)
                    {\n                        for (int col = 0; col < m.Height; col++)\n                        {\n                            if (m[row, col] != 0)\n                            {\n                                g.FillRectangle(b, blockSize * row, blockSize * col, blockSize, blockSize);\n                            }\n                        }\n                    }\n                }
                        {\n                            if (m[row, col] != 0)\n                            {\n                                g.FillRectangle(b, blockSize * row, blockSize * col, blockSize, blockSize);\n                            }\n                        }\n                    }\n                }\n            }\n            pictureBox1.Image = drawArea;
                            {\n                                g.FillRectangle(b, blockSize * row, blockSize * col, blockSize, blockSize);\n                            }\n                        }\n                    }\n                }\n            }\n            pictureBox1.Image = drawArea;\n        }\n        private void QRCodeForm_Load(object sender, EventArgs e)
        }\n        private MenuItem CreateMenuGroup(string text, MenuItem[] items)\n        {\n            return new MenuItem(I18N.GetString(text), items);
        }\n        private void LoadMenu()\n        {\n            this.contextMenu1 = new System.Windows.Forms.ContextMenu();\n            this.contextMenu1.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {\n                this.enableItem = CreateMenuItem("Enable", new System.EventHandler(this.EnableItem_Click)),\n                CreateMenuGroup("Mode", new System.Windows.Forms.MenuItem[] {\n                    this.PACModeItem = CreateMenuItem("PAC", new System.EventHandler(this.PACModeItem_Click)),\n                    this.globalModeItem = CreateMenuItem("Global", new System.EventHandler(this.GlobalModeItem_Click))\n                }),
                    this.ConfigItem = CreateMenuItem("Edit Servers...", new System.EventHandler(this.Config_Click))\n                }),\n                new MenuItem("-"),\n                this.AutoStartupItem = CreateMenuItem("Start on Boot", new System.EventHandler(this.AutoStartupItem_Click)),\n                this.ShareOverLANItem = CreateMenuItem("Share over LAN", new System.EventHandler(this.ShareOverLANItem_Click)),\n                CreateMenuItem("Edit PAC File...", new System.EventHandler(this.EditPACFileItem_Click)),\n                new MenuItem("-"),\n                CreateMenuItem("Show QRCode...", new System.EventHandler(this.QRCodeItem_Click)),\n                CreateMenuItem("Show Logs...", new System.EventHandler(this.ShowLogItem_Click)),\n                CreateMenuItem("About...", new System.EventHandler(this.Config_Click)),
                this.AutoStartupItem = CreateMenuItem("Start on Boot", new System.EventHandler(this.AutoStartupItem_Click)),\n                this.ShareOverLANItem = CreateMenuItem("Share over LAN", new System.EventHandler(this.ShareOverLANItem_Click)),\n                CreateMenuItem("Edit PAC File...", new System.EventHandler(this.EditPACFileItem_Click)),\n                new MenuItem("-"),\n                CreateMenuItem("Show QRCode...", new System.EventHandler(this.QRCodeItem_Click)),\n                CreateMenuItem("Show Logs...", new System.EventHandler(this.ShowLogItem_Click)),\n                CreateMenuItem("About...", new System.EventHandler(this.Config_Click)),\n                new MenuItem("-"),\n                CreateMenuItem("Quit", new System.EventHandler(this.Quit_Click))\n            });
                CreateMenuItem("Show QRCode...", new System.EventHandler(this.QRCodeItem_Click)),\n                CreateMenuItem("Show Logs...", new System.EventHandler(this.ShowLogItem_Click)),\n                CreateMenuItem("About...", new System.EventHandler(this.Config_Click)),\n                new MenuItem("-"),\n                CreateMenuItem("Quit", new System.EventHandler(this.Quit_Click))\n            });\n        }\n        private void controller_ConfigChanged(object sender, EventArgs e)\n        {\n            LoadCurrentConfiguration();
                CreateMenuItem("Quit", new System.EventHandler(this.Quit_Click))\n            });\n        }\n        private void controller_ConfigChanged(object sender, EventArgs e)\n        {\n            LoadCurrentConfiguration();\n            UpdateTrayIcon();\n        }\n        private void controller_EnableStatusChanged(object sender, EventArgs e)\n        {
        {\n            byte[] bytes = Convert.FromBase64String(response);\n            string content = Encoding.ASCII.GetString(bytes);\n            return ParseToValidList(content);\n        }\n        private static List<string> ParseToValidList(string content)\n        {\n            List<string> valid_lines = new List<string>();\n            using (var sr = new StringReader(content))\n            {
                }\n                else\n                {\n                    arguments = $"pac {pacURL}";\n                }\n            }\n            else\n            {\n                arguments = "off";\n            }
                }\n            }\n            else\n            {\n                arguments = "off";\n            }\n            using (var process = new Process())\n            {\n                // Configure the process using the StartInfo properties.\n                process.StartInfo.FileName = Utils.GetTempPath("sysproxy.exe");
            controller.EnableStatusChanged += controller_EnableStatusChanged;\n            controller.ConfigChanged += controller_ConfigChanged;\n            controller.PACFileReadyToOpen += controller_PACFileReadyToOpen;\n            controller.ShareOverLANStatusChanged += controller_ShareOverLANStatusChanged;\n            controller.EnableGlobalChanged += controller_EnableGlobalChanged;\n            controller.Errored += controller_Errored;\n            _notifyIcon = new NotifyIcon();\n            LoadTrayIcon();\n            _notifyIcon.Visible = true;\n            _notifyIcon.Text = I18N.GetString("Shadowsocks");
            this.enableItem.Click += new System.EventHandler(this.EnableItem_Click);\n            //\n            // modeMenu\n            //\n            this.modeItem.Index = 1;\n            this.modeItem.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {\n            this.PACModeItem,\n            this.globalModeItem});\n            this.modeItem.Text = I18N.GetString("Mode");\n            //\n            // PACModeItem\n            //\n            this.PACModeItem.Index = 0;\n            this.PACModeItem.Text = I18N.GetString("PAC");\n            this.PACModeItem.Click += new System.EventHandler(this.PACModeItem_Click);\n            //
            //\n            // PACModeItem\n            //\n            this.PACModeItem.Index = 0;\n            this.PACModeItem.Text = I18N.GetString("PAC");\n            this.PACModeItem.Click += new System.EventHandler(this.PACModeItem_Click);\n            //\n            // globalModeItem\n            //\n            this.globalModeItem.Index = 1;\n            this.globalModeItem.Text = I18N.GetString("Global");\n            this.globalModeItem.Click += new System.EventHandler(this.GlobalModeItem_Click);\n            // \n            // ServersItem\n            // \n            this.ServersItem.Index = 2;
            this.PACModeItem.Click += new System.EventHandler(this.PACModeItem_Click);\n            //\n            // globalModeItem\n            //\n            this.globalModeItem.Index = 1;\n            this.globalModeItem.Text = I18N.GetString("Global");\n            this.globalModeItem.Click += new System.EventHandler(this.GlobalModeItem_Click);\n            // \n            // ServersItem\n            // \n            this.ServersItem.Index = 2;\n            this.ServersItem.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {\n            this.SeperatorItem,\n            this.ServersItem.Text = I18N.GetString("Servers");\n            // 
            this.globalModeItem.Click += new System.EventHandler(this.GlobalModeItem_Click);\n            // \n            // ServersItem\n            // \n            this.ServersItem.Index = 2;\n            this.ServersItem.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {\n            this.SeperatorItem,\n            this.ConfigItem});\n            this.ServersItem.Text = I18N.GetString("Servers");\n            // \n            // SeperatorItem\n            // \n            this.SeperatorItem.Index = 0;\n            this.ConfigItem.Text = I18N.GetString("Edit Servers...");
            // \n            // SeperatorItem\n            // \n            this.SeperatorItem.Index = 0;\n            this.SeperatorItem.Text = "-";\n            // \n            // ConfigItem\n            // \n            this.ConfigItem.Index = 1;\n            this.ConfigItem.Text = I18N.GetString("Edit Servers...");\n            this.ConfigItem.Click += new System.EventHandler(this.Config_Click);\n            // \n            // menuItem1\n            // \n            this.menuItem1.Index = 3;\n            this.menuItem1.Text = "-";\n            this.AutoStartupItem.Text = I18N.GetString("Start on Boot");\n            this.AutoStartupItem.Click += new System.EventHandler(this.AutoStartupItem_Click);
            this.ConfigItem.Click += new System.EventHandler(this.Config_Click);\n            // \n            // menuItem1\n            // \n            this.menuItem1.Index = 3;\n            this.menuItem1.Text = "-";\n            // \n            // AutoStartupItem\n            // \n            this.AutoStartupItem.Index = 4;\n            this.AutoStartupItem.Text = I18N.GetString("Start on Boot");\n            this.AutoStartupItem.Click += new System.EventHandler(this.AutoStartupItem_Click);\n            // \n            // ShareOverLANItem\n            // \n            this.ShareOverLANItem.Index = 5;\n            this.ShareOverLANItem.Text = I18N.GetString("Share over LAN");\n            this.ShareOverLANItem.Click += new System.EventHandler(this.ShareOverLANItem_Click);\n            // 
            this.AutoStartupItem.Click += new System.EventHandler(this.AutoStartupItem_Click);\n            // \n            // ShareOverLANItem\n            // \n            this.ShareOverLANItem.Index = 5;\n            this.ShareOverLANItem.Text = I18N.GetString("Share over LAN");\n            this.ShareOverLANItem.Click += new System.EventHandler(this.ShareOverLANItem_Click);\n            // \n            // editPACFileItem\n            // \n            this.editPACFileItem.Index = 6;\n            this.editPACFileItem.Text = I18N.GetString("Edit PAC File...");\n            this.editPACFileItem.Click += new System.EventHandler(this.EditPACFileItem_Click);\n            // \n            // menuItem4\n            // 
            this.ShareOverLANItem.Click += new System.EventHandler(this.ShareOverLANItem_Click);\n            // \n            // editPACFileItem\n            // \n            this.editPACFileItem.Index = 6;\n            this.editPACFileItem.Text = I18N.GetString("Edit PAC File...");\n            this.editPACFileItem.Click += new System.EventHandler(this.EditPACFileItem_Click);\n            // \n            // menuItem4\n            // \n            this.menuItem4.Index = 7;\n            this.menuItem4.Text = "-";\n            // \n            this.QRCodeItem.Text = I18N.GetString("Show QRCode...");\n            this.QRCodeItem.Click += new System.EventHandler(this.QRCodeItem_Click);\n            // 
            this.editPACFileItem.Click += new System.EventHandler(this.EditPACFileItem_Click);\n            // \n            // menuItem4\n            // \n            this.menuItem4.Index = 7;\n            this.menuItem4.Text = "-";\n            // \n            // QRCodeItem\n            // \n            this.QRCodeItem.Index = 8;\n            this.QRCodeItem.Text = I18N.GetString("Show QRCode...");\n            this.QRCodeItem.Click += new System.EventHandler(this.QRCodeItem_Click);\n            // \n            // ShowLogItem\n            // \n            this.ShowLogItem.Index = 9;\n            this.ShowLogItem.Text = I18N.GetString("Show Logs...");\n            this.ShowLogItem.Click += new System.EventHandler(this.ShowLogItem_Click);\n            // 
            this.QRCodeItem.Click += new System.EventHandler(this.QRCodeItem_Click);\n            // \n            // ShowLogItem\n            // \n            this.ShowLogItem.Index = 9;\n            this.ShowLogItem.Text = I18N.GetString("Show Logs...");\n            this.ShowLogItem.Click += new System.EventHandler(this.ShowLogItem_Click);\n            // \n            // aboutItem\n            // \n            this.aboutItem.Index = 10;\n            this.aboutItem.Text = I18N.GetString("About...");\n            this.aboutItem.Click += new System.EventHandler(this.AboutItem_Click);\n            // \n            // menuItem3\n            // 
            this.ShowLogItem.Click += new System.EventHandler(this.ShowLogItem_Click);\n            // \n            // aboutItem\n            // \n            this.aboutItem.Index = 10;\n            this.aboutItem.Text = I18N.GetString("About...");\n            this.aboutItem.Click += new System.EventHandler(this.AboutItem_Click);\n            // \n            // menuItem3\n            // \n            this.menuItem3.Index = 11;\n            this.menuItem3.Text = "-";\n            // \n            this.quitItem.Text = I18N.GetString("Quit");\n            this.quitItem.Click += new System.EventHandler(this.Quit_Click);\n        }
            this.aboutItem.Click += new System.EventHandler(this.AboutItem_Click);\n            // \n            // menuItem3\n            // \n            this.menuItem3.Index = 11;\n            this.menuItem3.Text = "-";\n            // \n            // quitItem\n            // \n            this.quitItem.Index = 12;\n            this.quitItem.Text = I18N.GetString("Quit");\n            this.quitItem.Click += new System.EventHandler(this.Quit_Click);\n        }\n        private void controller_ConfigChanged(object sender, EventArgs e)\n        {\n            LoadCurrentConfiguration();
            this.quitItem.Click += new System.EventHandler(this.Quit_Click);\n        }\n        private void controller_ConfigChanged(object sender, EventArgs e)\n        {\n            LoadCurrentConfiguration();\n        }\n        private void controller_EnableStatusChanged(object sender, EventArgs e)\n        {\n            enableItem.Checked = controller.GetConfiguration().enabled;\n            LoadTrayIcon();
            this.ProxyPortTextBox = new System.Windows.Forms.TextBox();\n            this.ProxyPortLabel = new System.Windows.Forms.Label();\n            this.PasswordLabel = new System.Windows.Forms.Label();\n            this.IPTextBox = new System.Windows.Forms.TextBox();\n            this.ServerPortTextBox = new System.Windows.Forms.TextBox();\n            this.PasswordTextBox = new System.Windows.Forms.TextBox();\n            this.EncryptionLabel = new System.Windows.Forms.Label();\n            this.EncryptionSelect = new System.Windows.Forms.ComboBox();\n            this.panel2 = new System.Windows.Forms.Panel();\n            this.OKButton = new System.Windows.Forms.Button();
            this.IPTextBox = new System.Windows.Forms.TextBox();\n            this.ServerPortTextBox = new System.Windows.Forms.TextBox();\n            this.PasswordTextBox = new System.Windows.Forms.TextBox();\n            this.EncryptionLabel = new System.Windows.Forms.Label();\n            this.EncryptionSelect = new System.Windows.Forms.ComboBox();\n            this.panel2 = new System.Windows.Forms.Panel();\n            this.OKButton = new System.Windows.Forms.Button();\n            this.MyCancelButton = new System.Windows.Forms.Button();\n            this.panel1 = new System.Windows.Forms.Panel();\n            this.panel3 = new System.Windows.Forms.Panel();
            this.EncryptionSelect = new System.Windows.Forms.ComboBox();\n            this.panel2 = new System.Windows.Forms.Panel();\n            this.OKButton = new System.Windows.Forms.Button();\n            this.MyCancelButton = new System.Windows.Forms.Button();\n            this.panel1 = new System.Windows.Forms.Panel();\n            this.panel3 = new System.Windows.Forms.Panel();\n            this.DeleteButton = new System.Windows.Forms.Button();\n            this.AddButton = new System.Windows.Forms.Button();\n            this.ServerGroupBox = new System.Windows.Forms.GroupBox();\n            this.ServersListBox = new System.Windows.Forms.ListBox();
            this.tableLayoutPanel1.Controls.Add(this.ProxyPortTextBox, 1, 4);\n            this.tableLayoutPanel1.Controls.Add(this.ProxyPortLabel, 0, 4);\n            this.tableLayoutPanel1.Controls.Add(this.PasswordLabel, 0, 2);\n            this.tableLayoutPanel1.Controls.Add(this.IPTextBox, 1, 0);\n            this.tableLayoutPanel1.Controls.Add(this.ServerPortTextBox, 1, 1);\n            this.tableLayoutPanel1.Controls.Add(this.PasswordTextBox, 1, 2);\n            this.tableLayoutPanel1.Controls.Add(this.EncryptionLabel, 0, 3);\n            this.tableLayoutPanel1.Controls.Add(this.EncryptionSelect, 1, 3);\n            this.tableLayoutPanel1.Location = new System.Drawing.Point(8, 21);\n            this.tableLayoutPanel1.Margin = new System.Windows.Forms.Padding(5);
            this.tableLayoutPanel1.Controls.Add(this.IPTextBox, 1, 0);\n            this.tableLayoutPanel1.Controls.Add(this.ServerPortTextBox, 1, 1);\n            this.tableLayoutPanel1.Controls.Add(this.PasswordTextBox, 1, 2);\n            this.tableLayoutPanel1.Controls.Add(this.EncryptionLabel, 0, 3);\n            this.tableLayoutPanel1.Controls.Add(this.EncryptionSelect, 1, 3);\n            this.tableLayoutPanel1.Location = new System.Drawing.Point(8, 21);\n            this.tableLayoutPanel1.Margin = new System.Windows.Forms.Padding(5);\n            this.tableLayoutPanel1.Name = "tableLayoutPanel1";\n            this.tableLayoutPanel1.Padding = new System.Windows.Forms.Padding(5);\n            this.tableLayoutPanel1.RowCount = 6;
            this.tableLayoutPanel1.Controls.Add(this.EncryptionSelect, 1, 3);\n            this.tableLayoutPanel1.Location = new System.Drawing.Point(8, 21);\n            this.tableLayoutPanel1.Margin = new System.Windows.Forms.Padding(5);\n            this.tableLayoutPanel1.Name = "tableLayoutPanel1";\n            this.tableLayoutPanel1.Padding = new System.Windows.Forms.Padding(5);\n            this.tableLayoutPanel1.RowCount = 6;\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());
            // \n            // ProxyPortTextBox\n            // \n            this.ProxyPortTextBox.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));\n            this.ProxyPortTextBox.Location = new System.Drawing.Point(74, 113);\n            this.ProxyPortTextBox.Name = "ProxyPortTextBox";\n            this.ProxyPortTextBox.Size = new System.Drawing.Size(160, 20);\n            this.ProxyPortTextBox.TabIndex = 4;\n            this.ProxyPortTextBox.WordWrap = false;\n            // \n            // ProxyPortLabel\n            // \n            this.ProxyPortLabel.Anchor = System.Windows.Forms.AnchorStyles.Right;\n            this.ProxyPortLabel.AutoSize = true;
            // \n            // IPTextBox\n            // \n            this.IPTextBox.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));\n            this.IPTextBox.Location = new System.Drawing.Point(74, 8);\n            this.IPTextBox.Name = "IPTextBox";\n            this.IPTextBox.Size = new System.Drawing.Size(160, 20);\n            this.IPTextBox.TabIndex = 0;\n            this.IPTextBox.WordWrap = false;\n            // 
        private System.Windows.Forms.TextBox IPTextBox;\n        private System.Windows.Forms.TextBox ServerPortTextBox;\n        private System.Windows.Forms.TextBox PasswordTextBox;\n        private System.Windows.Forms.TextBox ProxyPortTextBox;\n        private System.Windows.Forms.Label EncryptionLabel;\n        private System.Windows.Forms.ComboBox EncryptionSelect;\n        private System.Windows.Forms.Panel panel2;\n        private System.Windows.Forms.Button OKButton;\n        private System.Windows.Forms.Button MyCancelButton;\n        private System.Windows.Forms.Panel panel1;
        private System.Windows.Forms.ComboBox EncryptionSelect;\n        private System.Windows.Forms.Panel panel2;\n        private System.Windows.Forms.Button OKButton;\n        private System.Windows.Forms.Button MyCancelButton;\n        private System.Windows.Forms.Panel panel1;\n        private System.Windows.Forms.Panel panel3;\n        private System.Windows.Forms.Button DeleteButton;\n        private System.Windows.Forms.Button AddButton;\n        private System.Windows.Forms.GroupBox ServerGroupBox;\n        private System.Windows.Forms.ListBox ServersListBox;
            LoadConfiguration(_modifiedConfiguration);\n            ServersListBox.SelectedIndex = currIndex + 1;\n            _lastSelectedIndex = ServersListBox.SelectedIndex;\n        }\n        private void DeleteButton_Click(object sender, EventArgs e)\n        {\n            _lastSelectedIndex = ServersListBox.SelectedIndex;\n            if (_lastSelectedIndex >= 0 && _lastSelectedIndex < _modifiedConfiguration.configs.Count)\n            {\n                _modifiedConfiguration.configs.RemoveAt(_lastSelectedIndex);
            _lastSelectedIndex = ServersListBox.SelectedIndex;\n        }\n        private void DeleteButton_Click(object sender, EventArgs e)\n        {\n            _lastSelectedIndex = ServersListBox.SelectedIndex;\n            if (_lastSelectedIndex >= 0 && _lastSelectedIndex < _modifiedConfiguration.configs.Count)\n            {\n                _modifiedConfiguration.configs.RemoveAt(_lastSelectedIndex);\n            }\n            if (_lastSelectedIndex >= _modifiedConfiguration.configs.Count)
            }\n            catch (IOException)\n            {\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine(e.ToString());\n            }
            {\n                Console.WriteLine(e.ToString());\n            }\n        }\n        [DllImport("Kernel32.dll")]\n        private static extern IntPtr LoadLibrary(string path);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void aes_init(IntPtr ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
        }\n        [DllImport("Kernel32.dll")]\n        private static extern IntPtr LoadLibrary(string path);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void aes_init(IntPtr ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void aes_free(IntPtr ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int aes_setkey_enc(IntPtr ctx, byte[] key, int keysize);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
            get {\n                object obj = ResourceManager.GetObject("libsscrypto_dll", resourceCulture);\n                return ((byte[])(obj));\n            }
                return ((byte[])(obj));\n            }\n        }\n        /// <summary>\n        ///   Looks up a localized string similar to proxyAddress = &quot;__POLIPO_BIND_IP__&quot;\n        ///\n        ///socksParentProxy = &quot;127.0.0.1:__SOCKS_PORT__&quot;\n        ///socksProxyType = socks5\n        ///diskCacheRoot = &quot;&quot;\n        ///localDocumentRoot = &quot;&quot;
            }\n            catch (IOException)\n            {\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine(e.ToString());\n            }
            {\n                Console.WriteLine(e.ToString());\n            }\n        }\n        [DllImport("Kernel32.dll")]\n        private static extern IntPtr LoadLibrary(string path);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void crypto_stream_salsa20_xor_ic(byte[] c, byte[] m, ulong mlen, byte[] n, ulong ic, byte[] k);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
        }\n        [DllImport("Kernel32.dll")]\n        private static extern IntPtr LoadLibrary(string path);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void crypto_stream_salsa20_xor_ic(byte[] c, byte[] m, ulong mlen, byte[] n, ulong ic, byte[] k);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void crypto_stream_chacha20_xor_ic(byte[] c, byte[] m, ulong mlen, byte[] n, ulong ic, byte[] k);\n    }\n}
        }\n        private void LogForm_FormClosing(object sender, FormClosingEventArgs e)\n        {\n            timer.Stop();\n            config.logViewer.topMost = topMostTrigger;\n            config.logViewer.wrapText = wrapTextTrigger;\n            config.logViewer.toolbarShown = toolbarTrigger;\n            config.logViewer.fontName = LogMessageTextBox.Font.Name;\n            config.logViewer.fontSize = LogMessageTextBox.Font.Size;\n            config.logViewer.SetBackgroundColor(LogMessageTextBox.BackColor);
                    }\n                }\n                else\n                {\n                    if (line.IsNullOrEmpty())\n                    {\n                        return true;
                        return true;\n                    }\n                    if (!_isConnect)\n                    {\n                        if (line.StartsWith("Host: "))\n                        {
                    }\n                    if (!_isConnect)\n                    {\n                        if (line.StartsWith("Host: "))\n                        {\n                            var location = line.Substring(6).Trim();\n                            var locs = location.Split(':');\n                            _targetHost = locs[0];\n                            if (locs.Length > 1)\n                            {
            {\n                hotkey = _keymap.First(v => v.Value == cb).Key;\n                return true;\n            }\n            else\n            {
                return true;\n            }\n            else\n            {
            {
        private void CancelButton_Click(object sender, EventArgs e)\n        {\n            this.Close();\n        }\n        private void OKButton_Click(object sender, EventArgs e)\n        {\n            _modifiedHotkeyConfig = GetConfigFromUI();\n            // try to register, notify to change settings if failed\n            if (!RegisterAllHotkeys(_modifiedHotkeyConfig))\n            {\n                MessageBox.Show(I18N.GetString("Register hotkey failed"));
            {\n                MessageBox.Show(I18N.GetString("Register hotkey failed"));\n            }\n            // All check passed, saving\n            SaveConfig();\n            this.Close();\n        }\n        private void RegisterAllButton_Click(object sender, EventArgs e)\n        {\n            _modifiedHotkeyConfig = GetConfigFromUI();\n            RegisterAllHotkeys(_modifiedHotkeyConfig);
        }\n        private static void UnregPrevHotkey(HotKeys.HotKeyCallBackHandler cb)\n        {\n            GlobalHotKey.HotKey prevHotKey;\n            if (HotKeys.IsCallbackExists(cb, out prevHotKey))\n            {\n                // unregister previous one\n                HotKeys.Unregister(prevHotKey);\n            }\n        }
    }\n}
            this.SwitchSystemProxyTextBox.KeyDown += new System.Windows.Forms.KeyEventHandler(this.HotkeyDown);\n            this.SwitchSystemProxyTextBox.KeyUp += new System.Windows.Forms.KeyEventHandler(this.HotkeyUp);\n            // \n            // SwitchProxyModeTextBox\n            // \n            this.SwitchProxyModeTextBox.Dock = System.Windows.Forms.DockStyle.Fill;\n            this.SwitchProxyModeTextBox.Location = new System.Drawing.Point(208, 37);\n            this.SwitchProxyModeTextBox.Margin = new System.Windows.Forms.Padding(3, 3, 16, 3);\n            this.SwitchProxyModeTextBox.Name = "SwitchProxyModeTextBox";\n            this.SwitchProxyModeTextBox.ReadOnly = true;
            this.SwitchProxyModeTextBox.KeyDown += new System.Windows.Forms.KeyEventHandler(this.HotkeyDown);\n            this.SwitchProxyModeTextBox.KeyUp += new System.Windows.Forms.KeyEventHandler(this.HotkeyUp);\n            // \n            // SwitchAllowLanTextBox\n            // \n            this.SwitchAllowLanTextBox.Dock = System.Windows.Forms.DockStyle.Fill;\n            this.SwitchAllowLanTextBox.Location = new System.Drawing.Point(208, 71);\n            this.SwitchAllowLanTextBox.Margin = new System.Windows.Forms.Padding(3, 3, 16, 3);\n            this.SwitchAllowLanTextBox.Name = "SwitchAllowLanTextBox";\n            this.SwitchAllowLanTextBox.ReadOnly = true;
            this.SwitchAllowLanTextBox.KeyDown += new System.Windows.Forms.KeyEventHandler(this.HotkeyDown);\n            this.SwitchAllowLanTextBox.KeyUp += new System.Windows.Forms.KeyEventHandler(this.HotkeyUp);\n            // \n            // ShowLogsTextBox\n            // \n            this.ShowLogsTextBox.Dock = System.Windows.Forms.DockStyle.Fill;\n            this.ShowLogsTextBox.Location = new System.Drawing.Point(208, 105);\n            this.ShowLogsTextBox.Margin = new System.Windows.Forms.Padding(3, 3, 16, 3);\n            this.ShowLogsTextBox.Name = "ShowLogsTextBox";\n            this.ShowLogsTextBox.ReadOnly = true;
            this.ShowLogsTextBox.KeyDown += new System.Windows.Forms.KeyEventHandler(this.HotkeyDown);\n            this.ShowLogsTextBox.KeyUp += new System.Windows.Forms.KeyEventHandler(this.HotkeyUp);\n            // \n            // ServerMoveUpTextBox\n            // \n            this.ServerMoveUpTextBox.Dock = System.Windows.Forms.DockStyle.Fill;\n            this.ServerMoveUpTextBox.Location = new System.Drawing.Point(208, 139);\n            this.ServerMoveUpTextBox.Margin = new System.Windows.Forms.Padding(3, 3, 16, 3);\n            this.ServerMoveUpTextBox.Name = "ServerMoveUpTextBox";\n            this.ServerMoveUpTextBox.ReadOnly = true;
            this.ServerMoveUpTextBox.KeyDown += new System.Windows.Forms.KeyEventHandler(this.HotkeyDown);\n            this.ServerMoveUpTextBox.KeyUp += new System.Windows.Forms.KeyEventHandler(this.HotkeyUp);\n            // \n            // ServerMoveDownTextBox\n            // \n            this.ServerMoveDownTextBox.Dock = System.Windows.Forms.DockStyle.Fill;\n            this.ServerMoveDownTextBox.Location = new System.Drawing.Point(208, 174);\n            this.ServerMoveDownTextBox.Margin = new System.Windows.Forms.Padding(3, 3, 16, 3);\n            this.ServerMoveDownTextBox.Name = "ServerMoveDownTextBox";\n            this.ServerMoveDownTextBox.ReadOnly = true;

        {\n            _controller = controller;\n            _config = conf;\n            Handlers = new HashSet<TCPHandler>();\n            _lastSweepTime = DateTime.Now;\n        }\n        public bool Handle(byte[] firstPacket, int length, Socket socket, object state)\n        {\n            if (socket.ProtocolType != ProtocolType.Tcp)\n            {
        public Socket connection;\n        public ShadowsocksController controller;\n        public TCPRelay relay;\n        public DateTime lastActivity;\n        private const int maxRetry = 4;\n        private int retryCount = 0;\n        private bool proxyConnected;\n        private bool destConnected;\n        private byte command;
        private byte command;\n        private byte[] _firstPacket;\n        private int _firstPacketLength;\n        // Size of receive buffer.\n        public const int RecvSize = 8192;\n        public const int RecvReserveSize = IVEncryptor.ONETIMEAUTH_BYTES + IVEncryptor.AUTH_BYTES; // reserve for one-time auth\n        public const int BufferSize = RecvSize + RecvReserveSize + 32;\n        private int totalRead = 0;\n        private int totalWrite = 0;\n        // remote receive buffer
                    connection.BeginReceive(connetionRecvBuffer, 0, RecvSize, 0, new AsyncCallback(ReadAll), null);\n                }\n                else\n                {\n                    int bytesRead = connection.EndReceive(ar);\n                    if (bytesRead > 0)\n                    {\n                        Logging.Debug(remote.LocalEndPoint, remote.DestEndPoint, RecvSize, "TCP Relay");\n                        connection.BeginReceive(connetionRecvBuffer, 0, RecvSize, 0, new AsyncCallback(ReadAll), null);\n                    }
                        connection.BeginReceive(connetionRecvBuffer, 0, RecvSize, 0, new AsyncCallback(ReadAll), null);\n                    }\n                    else\n                    {\n                        Close();\n                    }\n                }\n            }\n            catch (Exception e)\n            {
                _startConnectTime = DateTime.Now;\n                ServerTimer connectTimer = new ServerTimer(3000);\n                connectTimer.AutoReset = false;\n                connectTimer.Elapsed += destConnectTimer_Elapsed;\n                connectTimer.Enabled = true;\n                connectTimer.Server = server;\n                destConnected = false;\n                // Connect to the remote endpoint.\n                remote.BeginConnectDest(destEP, new AsyncCallback(ConnectCallback), connectTimer);\n            }\n            catch (ArgumentException)
                connectTimer.Enabled = true;\n                connectTimer.Server = server;\n                destConnected = false;\n                // Connect to the remote endpoint.\n                remote.BeginConnectDest(destEP, new AsyncCallback(ConnectCallback), connectTimer);\n            }\n            catch (ArgumentException)\n            {\n            }\n            catch (Exception e)\n            {
                // Connect to the remote endpoint.\n                remote.BeginConnectDest(destEP, new AsyncCallback(ConnectCallback), connectTimer);\n            }\n            catch (ArgumentException)\n            {\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                RetryConnect();\n            }
            {\n                return;\n            }\n            Server server = ((ServerTimer)sender).Server;\n            IStrategy strategy = controller.GetCurrentStrategy();\n            if (strategy != null)\n            {\n                strategy.SetFailure(server);\n            }\n            Logging.Info($"{server.FriendlyName()} timed out");
                timer.Enabled = false;\n                timer.Dispose();\n                // Complete the connection.\n                remote.EndConnectDest(ar);\n                destConnected = true;\n                Logging.Debug($"Socket connected to {remote.DestEndPoint}");\n                var latency = DateTime.Now - _startConnectTime;\n                IStrategy strategy = controller.GetCurrentStrategy();\n                strategy?.UpdateLatency(server, latency);\n                tcprelay.UpdateLatency(server, latency);\n                StartPipe();
                var latency = DateTime.Now - _startConnectTime;\n                IStrategy strategy = controller.GetCurrentStrategy();\n                strategy?.UpdateLatency(server, latency);\n                tcprelay.UpdateLatency(server, latency);\n                StartPipe();\n            }\n            catch (ArgumentException)\n            {\n            }\n            catch (Exception e)
        {\n            this.KeySize = keySize;\n            this.IvSize = ivSize;\n            this.Type = type;\n            this.InnerLibName = innerLibName;\n        }\n        public EncryptorInfo(int keySize, int ivSize, int type)\n        {\n            this.KeySize = keySize;\n            this.IvSize = ivSize;
        }\n    }\n    public abstract class EncryptorBase\n        : IEncryptor\n    {\n        public const int MAX_INPUT_SIZE = 32768;\n        protected EncryptorBase(string method, string password, bool onetimeauth, bool isudp)\n        {\n            Method = method;\n            Password = password;
            {\n                if (!mutex.WaitOne(0, false))\n                {\n                    Process[] oldProcesses = Process.GetProcessesByName("Shadowsocks");\n                    if (oldProcesses.Length > 0)\n                    {\n                        Process oldProcess = oldProcesses[0];\n                    }\n                    MessageBox.Show("Shadowsocks is already running.\n\nFind Shadowsocks icon in your notify tray.");\n                    return;
            }
        }\n    }\n}
            series1.IsXValueIndexed = true;\n            series1.Legend = "Legend1";\n            series1.Name = "Inbound";\n            series2.ChartArea = "ChartArea1";\n            series2.ChartType = System.Windows.Forms.DataVisualization.Charting.SeriesChartType.Line;\n            series2.Color = System.Drawing.Color.FromArgb(128, 128, 255);

        public const int HASH_BYTES = 4;\n        public const int CLEN_BYTES = 2;\n        public const int AUTH_BYTES = HASH_BYTES + CLEN_BYTES;\n        protected static byte[] tempbuf = new byte[MAX_INPUT_SIZE];\n        protected Dictionary<string, int[]> ciphers;\n        private static readonly Dictionary<string, byte[]> CachedKeys = new Dictionary<string, byte[]>();\n        protected byte[] _encryptIV;\n        protected byte[] _decryptIV;\n        protected bool _decryptIVReceived;\n        protected bool _encryptIVSent;
        public IVEncryptor(string method, string password, bool onetimeauth)\n            : base(method, password, onetimeauth)\n        {\n            InitKey(method, password);\n        }\n        protected abstract Dictionary<string, int[]> getCiphers();
        }\n        protected abstract Dictionary<string, int[]> getCiphers();\n        protected void InitKey(string method, string password)\n        {\n            method = method.ToLower();\n            _method = method;\n            string k = method + ":" + password;\n            ciphers = getCiphers();\n            _cipherInfo = ciphers[_method];\n            _cipher = _cipherInfo[2];
        {\n            byte[] auth_key = new byte[ONETIMEAUTH_KEYBYTES];\n            byte[] auth_bytes = new byte[MAX_IV_LENGTH + MAX_KEY_LENGTH];\n            Buffer.BlockCopy(_encryptIV, 0, auth_bytes, 0, ivLen);\n            Buffer.BlockCopy(_key, 0, auth_bytes, ivLen, keyLen);\n            Sodium.crypto_generichash(auth_key, ONETIMEAUTH_KEYBYTES, auth_bytes, (ulong)(ivLen + keyLen), null, 0);\n            return Sodium.crypto_onetimeauth(auth, msg, (ulong)msg_len, auth_key);\n        }\n        protected void ss_gen_hash(byte[] buf, ref int offset, ref int len, int buf_size)\n        {
            return Sodium.crypto_onetimeauth(auth, msg, (ulong)msg_len, auth_key);\n        }\n        protected void ss_gen_hash(byte[] buf, ref int offset, ref int len, int buf_size)\n        {\n            int size = len + AUTH_BYTES;
            if (buf_size < (size + offset))\n                throw new Exception("failed to generate hash:  buffer size insufficient");\n            if (_keyBuffer == null)\n            {\n                _keyBuffer = new byte[MAX_IV_LENGTH + 4];\n                Buffer.BlockCopy(_encryptIV, 0, _keyBuffer, 0, ivLen);\n            }\n            byte[] counter_bytes = BitConverter.GetBytes((uint)IPAddress.HostToNetworkOrder((int)counter));\n            Buffer.BlockCopy(counter_bytes, 0, _keyBuffer, ivLen, 4);\n            byte[] hash = new byte[HASH_BYTES];
        }\n        public override void Encrypt(byte[] buf, int length, byte[] outbuf, out int outlength)\n        {\n            if (!_encryptIVSent)\n            {\n                _encryptIVSent = true;\n                randBytes(outbuf, ivLen);\n                initCipher(outbuf, true);\n                outlength = length + ivLen;\n                lock (tempbuf)
                        // we need a panel because a window has a minimal size\n                        splash.TargetRect = new Rectangle((int)minX, (int)minY, (int)maxX - (int)minX, (int)maxY - (int)minY);\n                        splash.Size = new Size(fullImage.Width, fullImage.Height);\n                        splash.Show();\n                        return;\n                    }\n                }\n            }\n            MessageBox.Show(I18N.GetString("Failed to find QRCode"));\n        }\n        void splash_FormClosed(object sender, FormClosedEventArgs e)
                        splash.Show();\n                        return;\n                    }\n                }\n            }\n            MessageBox.Show(I18N.GetString("Failed to find QRCode"));\n        }\n        void splash_FormClosed(object sender, FormClosedEventArgs e)\n        {\n            ShowConfigForm();
    {\n        public class QRRectView : Control\n        {\n            private Pen pen;\n            private Brush brush;\n            public QRRectView()\n            {\n                pen = new Pen(Color.Red, 3);\n                brush = new SolidBrush(Color.FromArgb(100, Color.Red));\n                SetStyle(ControlStyles.ResizeRedraw, true);
        }\n        private Timer timer;\n            SetStyle(ControlStyles.SupportsTransparentBackColor, true);\n            this.BackColor = Color.Transparent;\n            animationStep = 0;\n            flashStep = 0;\n            //codeRectView = new QRRectView();
            timer = new Timer();\n            timer.Interval = (int)(ANIMATION_TIME * 1000 / ANIMATION_STEPS);\n            timer.Tick += timer_Tick;\n            timer.Start();\n            bitmap = new Bitmap(Width, Height, PixelFormat.Format32bppArgb);\n            g = Graphics.FromImage(bitmap);\n            pen = new Pen(Color.Red, 3);\n            brush = new SolidBrush(Color.FromArgb(30, Color.Red));\n        }\n        protected override CreateParams CreateParams
            timer.Tick += timer_Tick;\n            timer.Start();\n            bitmap = new Bitmap(Width, Height, PixelFormat.Format32bppArgb);\n            g = Graphics.FromImage(bitmap);\n            pen = new Pen(Color.Red, 3);\n            brush = new SolidBrush(Color.FromArgb(30, Color.Red));\n        }\n        protected override CreateParams CreateParams\n        {\n            get
            {\n                File.WriteAllText(PAC_FILE, Resources.proxy_pac_txt);\n            }\n            return PAC_FILE;\n        }\n        internal string TouchUserRuleFile()
            }\n            return PAC_FILE;\n        }\n        internal string TouchUserRuleFile()\n        {\n            if (!File.Exists(USER_RULE_FILE))
        }\n        internal string TouchUserRuleFile()\n        {\n            if (!File.Exists(USER_RULE_FILE))\n            {
            {\n                File.WriteAllText(USER_RULE_FILE, Resources.user_rule);\n            }\n            return USER_RULE_FILE;\n        }\n        internal string GetPACContent()\n        {\n            if (File.Exists(PAC_FILE))\n            {
            }\n            return USER_RULE_FILE;\n        }\n        internal string GetPACContent()\n        {\n            if (File.Exists(PAC_FILE))\n            {\n                return File.ReadAllText(PAC_FILE, Encoding.UTF8);\n            }\n            else
            }\n        }\n        private void WatchPacFile()\n        {\n            PACFileWatcher?.Dispose();\n            PACFileWatcher = new FileSystemWatcher(Directory.GetCurrentDirectory());\n            PACFileWatcher.NotifyFilter = NotifyFilters.LastWrite | NotifyFilters.FileName | NotifyFilters.DirectoryName;\n            PACFileWatcher.Filter = PAC_FILE;\n            PACFileWatcher.Changed += PACFileWatcher_Changed;\n            PACFileWatcher.Created += PACFileWatcher_Changed;
            {\n                group = config.geositeGroup;\n                blacklist = config.geositeBlacklistMode;\n            }\n            if (!string.IsNullOrWhiteSpace(config.geositeUrl))\n            {\n                logger.Info("Found custom Geosite URL in config file");\n                geositeUrl = config.geositeUrl;\n            }\n            logger.Info($"Checking Geosite from {geositeUrl}");
            }\n            if (!string.IsNullOrWhiteSpace(config.geositeUrl))\n            {\n                logger.Info("Found custom Geosite URL in config file");\n                geositeUrl = config.geositeUrl;\n            }\n            logger.Info($"Checking Geosite from {geositeUrl}");\n            WebClient http = new WebClient();\n            if (config.enabled)\n            {
            WebClient http = new WebClient();\n            if (config.enabled)\n            {\n                http.Proxy = new WebProxy(\n                    config.isIPv6Enabled\n                    ? $"[{IPAddress.IPv6Loopback}]"\n                    : IPAddress.Loopback.ToString(),\n                    config.localPort);\n            }\n            http.DownloadDataCompleted += (o, e) =>
                    UpdateCompleted?.Invoke(null, new GeositeResultEventArgs(pacFileChanged));\n                }\n                catch (Exception ex)\n                {\n                    Error?.Invoke(null, new ErrorEventArgs(ex));\n                }\n            };\n            http.DownloadDataAsync(new Uri(geositeUrl));\n        }\n        public static bool MergeAndWritePACFile(string group, bool blacklist)
        }\n        public static bool MergeAndWritePACFile(string group, bool blacklist)\n        {\n            IList<DomainObject> domains = Geosites[group];\n            string abpContent = MergePACFile(domains, blacklist);
        {\n            IList<DomainObject> domains = Geosites[group];\n            string abpContent = MergePACFile(domains, blacklist);\n            if (File.Exists(PACDaemon.PAC_FILE))\n            {
            if (File.Exists(PACDaemon.PAC_FILE))\n            {\n                string original = FileManager.NonExclusiveReadAllText(PACDaemon.PAC_FILE, Encoding.UTF8);\n                if (original == abpContent)\n                {\n                    return false;\n                }\n            }\n            File.WriteAllText(PACDaemon.PAC_FILE, abpContent, Encoding.UTF8);\n            return true;
            }\n            List<string> gfwLines = GeositeToGFWList(domains, blacklist);\n            abpContent =\n$@"var __USERRULES__ = {JsonConvert.SerializeObject(userruleLines, Formatting.Indented)};\nvar __RULES__ = {JsonConvert.SerializeObject(gfwLines, Formatting.Indented)};\n{abpContent}";\n            return abpContent;\n        }\n        private static readonly IEnumerable<char> IgnoredLineBegins = new[] { '!', '[' };\n        private static List<string> PreProcessGFWList(string content)
            abpContent =\n$@"var __USERRULES__ = {JsonConvert.SerializeObject(userruleLines, Formatting.Indented)};\nvar __RULES__ = {JsonConvert.SerializeObject(gfwLines, Formatting.Indented)};\n{abpContent}";\n            return abpContent;\n        }\n        private static readonly IEnumerable<char> IgnoredLineBegins = new[] { '!', '[' };\n        private static List<string> PreProcessGFWList(string content)\n        {\n            List<string> valid_lines = new List<string>();
        {\n            List<string> valid_lines = new List<string>();\n            using (var sr = new StringReader(content))\n            {\n                foreach (var line in sr.NonWhiteSpaceLines())\n                {\n                    if (line.BeginWithAny(IgnoredLineBegins))\n                        continue;\n                    valid_lines.Add(line);\n                }
        {\n            return blacklist ? GeositeToGFWListBlack(domains) : GeositeToGFWListWhite(domains);\n        }\n        private static List<string> GeositeToGFWListBlack(IList<DomainObject> domains)\n        {\n            List<string> ret = new List<string>(domains.Count + 100);// 100 overhead\n            foreach (var d in domains)\n            {\n                string domain = d.Value;
            foreach (var d in domains)\n            {\n                string domain = d.Value;\n                switch (d.Type)\n                {\n                    case DomainObject.Types.Type.Plain:\n                        ret.Add(domain);\n                        break;\n                    case DomainObject.Types.Type.Regex:
                        break;\n                    case DomainObject.Types.Type.Regex:
        {\n            this.config = config;\n            TouchPACFile();\n            TouchUserRuleFile();\n            this.WatchPacFile();\n            this.WatchUserRuleFile();\n        }\n        public string TouchPACFile()\n        {\n            if (!File.Exists(PAC_FILE))
            }\n            return PAC_FILE;\n        }\n        internal string TouchUserRuleFile()\n        {\n            if (!File.Exists(USER_RULE_FILE))\n            {\n                File.WriteAllText(USER_RULE_FILE, Resources.user_rule);\n            }\n            return USER_RULE_FILE;
        {\n            // we are building x86 binary for both x86 and x64, which will\n            // cause problem when opening registry key\n            // detect operating system instead of CPU\n            if (name.IsNullOrEmpty()) throw new ArgumentException(nameof(name));\n            try\n            {\n                RegistryKey userKey = RegistryKey.OpenBaseKey(hive,\n                        Environment.Is64BitOperatingSystem ? RegistryView.Registry64 : RegistryView.Registry32)\n                    .OpenSubKey(name, writable);\n                return userKey;\n            }\n            catch (UnauthorizedAccessException uae)
                        Environment.Is64BitOperatingSystem ? RegistryView.Registry64 : RegistryView.Registry32)\n                    .OpenSubKey(name, writable);\n                return userKey;\n            }\n            catch (UnauthorizedAccessException uae)\n            {\n                Logging.LogUsefulException(uae);\n                return null;\n            }\n            catch (SecurityException se)
        }\n        public void UpdateOutboundCounter(long n)\n        {\n            Interlocked.Add(ref outboundCounter, n);\n        }\n        protected void Reload()\n        {\n            // some logic in configuration updated the config when saving, we need to read it again\n            _config = Configuration.Load();\n            StatisticsConfiguration = StatisticsStrategyConfiguration.Load();
        }\n        protected void Reload()\n        {\n            // some logic in configuration updated the config when saving, we need to read it again\n            _config = Configuration.Load();\n            StatisticsConfiguration = StatisticsStrategyConfiguration.Load();\n            if (polipoRunner == null)\n            {\n                polipoRunner = new PolipoRunner();\n            }
            polipoRunner = new PolipoRunner();\n            polipoRunner.Start(config.GetCurrentServer());\n            local = new Local(config.GetCurrentServer());\n            try\n            {\n                local.Start();\n                pacServer = new PACServer();\n                pacServer.PACFileChanged += pacServer_PACFileChanged;\n                pacServer.Start();\n            }
            try\n            {\n                local.Start();\n                pacServer = new PACServer();\n                pacServer.PACFileChanged += pacServer_PACFileChanged;\n                pacServer.Start();\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine(e.Message);
        {\n            Configuration.Save(newConfig);\n            config = newConfig;\n            local.Stop();\n            polipoRunner.Stop();\n            polipoRunner.Start(config.GetCurrentServer());\n            local = new Local(config.GetCurrentServer());\n            local.Start();\n            if (ConfigChanged != null)\n            {
            config = newConfig;\n            local.Stop();\n            polipoRunner.Stop();\n            polipoRunner.Start(config.GetCurrentServer());\n            local = new Local(config.GetCurrentServer());\n            local.Start();\n            if (ConfigChanged != null)\n            {\n                ConfigChanged(this, new EventArgs());\n            }
            local.Start();\n            if (ConfigChanged != null)\n            {\n                ConfigChanged(this, new EventArgs());\n            }\n        }\n        public Server GetCurrentServer()\n        {\n            return config.GetCurrentServer();\n        }
        {\n            return config;\n        }\n        public void ToggleEnable(bool enabled)\n        {\n            config.enabled = enabled;\n            updateSystemProxy();\n            SaveConfig(config);\n            if (EnableStatusChanged != null)\n            {
        }\n        private void Form1_Load(object sender, EventArgs e)\n        {\n            if (!controller.GetConfiguration().isDefault)\n            {\n                this.Opacity = 0;\n                BeginInvoke(new MethodInvoker(delegate\n                {\n                    this.Hide();\n                }));
            {\n                this.Opacity = 0;\n                BeginInvoke(new MethodInvoker(delegate\n                {\n                    this.Hide();\n                }));\n            }\n        }\n        private void Config_Click(object sender, EventArgs e)\n        {
                {\n                    server = textBox1.Text,\n                    server_port = int.Parse(textBox2.Text),\n                    password = textBox3.Text,\n                    local_port = int.Parse(textBox4.Text),\n                    method = comboBox1.Text\n                };\n                Configuration config = controller.GetConfiguration();
                };\n                Configuration config = controller.GetConfiguration();\n                config.configs.Clear();\n                config.configs.Add(server);\n                config.index = 0;\n                controller.SaveConfig(config);\n                this.Hide();\n            }\n            catch (FormatException)\n            {
                            {\n                                if (!int.TryParse(locs[1], out _targetPort))\n                                {\n                                    throw new Exception("Bad http header: " + line);\n                                }\n                            }\n                            else\n                            {\n                                _targetPort = 80;\n                            }
                            }\n                        }\n                    }\n                }\n                else\n                {\n                    if (line.IsNullOrEmpty())\n                    {\n                        return true;\n                    }
                            {\n                                if (!int.TryParse(locs[1], out _targetPort))\n                                {\n                                    throw new Exception("Bad http header: " + line);\n                                }\n                            }\n                            else\n                            {\n                                _targetPort = 80;\n                            }
                            }\n                        }\n                    }\n                }\n                _requestLineCount++;\n                return false;\n            }\n            private void OnFinish(byte[] lastBytes, int index, int length, object state)\n            {\n                if (_closed)
                            byte[] response = { 5, 0, 0, 1, 0, 0, 0, 0, 0, 0 };\n                            _connection.BeginSend(response, 0, response.Length, SocketFlags.None,\n                                ResponseCallback, null);\n                            break;\n                        case CMD_UDP_ASSOC:\n                            ReadAddress(HandleUDPAssociate);\n                            break;
                            ReadAddress(HandleUDPAssociate);\n                            break;\n                        case CMD_BIND:  // not implemented\n                        default:\n                            Logging.Debug("Unsupported CMD=" + _command);\n                            Close();\n                            break;\n                    }\n                }
                    }\n                }\n                else\n                {\n                    Logging.Debug(\n                        "failed to recv data in Shadowsocks.Controller.TCPHandler.handshakeReceive2Callback()");\n                    Close();\n                }\n            }\n            catch (Exception e)
using System.Diagnostics;\nusing System.IO;\nusing System.IO.Compression;\nusing System.Runtime.InteropServices;
using System.Runtime.InteropServices;

                return null;\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);
                return null;\n            }\n        }\n        public static bool IsWinVistaOrHigher() {\n            return Environment.OSVersion.Version.Major > 5;\n        }\n        [DllImport("kernel32.dll")]\n        [return: MarshalAs(UnmanagedType.Bool)]\n        private static extern bool SetProcessWorkingSetSize(IntPtr process,\n            UIntPtr minimumWorkingSetSize, UIntPtr maximumWorkingSetSize);
namespace Shadowsocks.Util.SystemProxy\n{\n    internal static class RemoteAccessService\n    {\n        private enum RasFieldSizeConstants\n        {\n            #region original header\n            //#if (WINVER >= 0x400)\n            //#define RAS_MaxEntryName      256\n            //#define RAS_MaxDeviceName     128
    {\n        private enum RasFieldSizeConstants\n        {\n            #region original header\n            //#if (WINVER >= 0x400)\n            //#define RAS_MaxEntryName      256\n            //#define RAS_MaxDeviceName     128\n            //#define RAS_MaxCallbackNumber RAS_MaxPhoneNumber\n            //#else\n            //#define RAS_MaxEntryName      20
using System.Collections;\nusing System.IO;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Text;\nusing Shadowsocks.Model;\nusing Shadowsocks.Properties;
using System.IO;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Text;\nusing Shadowsocks.Model;\nusing Shadowsocks.Properties;\nusing Shadowsocks.Util;\nnamespace Shadowsocks.Controller\n{
using System.Net;\nusing System.Net.Sockets;\nusing System.Text;\nusing Shadowsocks.Model;\nusing Shadowsocks.Properties;\nusing Shadowsocks.Util;\nnamespace Shadowsocks.Controller\n{\n    class PACServer : Listener.Service\n    {
        FileSystemWatcher PACFileWatcher;\n        FileSystemWatcher UserRuleFileWatcher;\n        private Configuration _config;\n        public event EventHandler PACFileChanged;\n        public event EventHandler UserRuleFileChanged;\n        public PACServer()\n        {\n            this.WatchPacFile();\n            this.WatchUserRuleFile();\n        }
                {\n                    string local = File.ReadAllText(PACServer.USER_RULE_FILE, Encoding.UTF8);\n                    string[] rules = local.Split(new char[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);\n                    foreach (string rule in rules)\n                    {\n                        if (rule.StartsWith("!") || rule.StartsWith("["))\n                            continue;\n                        lines.Add(rule);\n                    }\n                }
                    string[] rules = local.Split(new char[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);\n                    foreach (string rule in rules)\n                    {\n                        if (rule.StartsWith("!") || rule.StartsWith("["))\n                            continue;\n                        lines.Add(rule);\n                    }\n                }\n                string abpContent;\n                if (File.Exists(PACServer.USER_ABP_FILE))
                {\n                    abpContent = File.ReadAllText(PACServer.USER_ABP_FILE, Encoding.UTF8);\n                }\n                else\n                {\n                    abpContent = Utils.UnGzip(Resources.abp_js);\n                }\n                abpContent = abpContent.Replace("__RULES__", JsonConvert.SerializeObject(lines, Formatting.Indented));\n                if (File.Exists(PACServer.PAC_FILE))\n                {
                }\n                else\n                {\n                    abpContent = Utils.UnGzip(Resources.abp_js);\n                }\n                abpContent = abpContent.Replace("__RULES__", JsonConvert.SerializeObject(lines, Formatting.Indented));\n                if (File.Exists(PACServer.PAC_FILE))\n                {\n                    string original = File.ReadAllText(PACServer.PAC_FILE, Encoding.UTF8);\n                    if (original == abpContent)
                    if (original == abpContent)\n                    {\n                        UpdateCompleted(this, new ResultEventArgs(false));\n                        return;\n                    }\n                }\n                File.WriteAllText(PACServer.PAC_FILE, abpContent, Encoding.UTF8);\n                if (UpdateCompleted != null)\n                {\n                    UpdateCompleted(this, new ResultEventArgs(true));
                if (UpdateCompleted != null)\n                {\n                    UpdateCompleted(this, new ResultEventArgs(true));\n                }\n            }\n            catch (Exception ex)\n            {\n                if (Error != null)\n                {\n                    Error(this, new ErrorEventArgs(ex));
                {\n                    var reply = await ping.SendTaskAsync(server.server, Timeout);\n                    ret.Add(new List<KeyValuePair<string, string>>\n                    {\n                        new KeyValuePair<string, string>("Timestamp", timestamp),\n                        new KeyValuePair<string, string>("Server", server.FriendlyName()),\n                        new KeyValuePair<string, string>("Status", reply?.Status.ToString()),\n                        new KeyValuePair<string, string>("RoundtripTime", reply?.RoundtripTime.ToString())\n                        //new KeyValuePair<string, string>("data", reply.Buffer.ToString()); // The data of reply\n                    });
            }\n            return ret;\n        }\n        private async void Evaluate(object obj)\n        {\n            var geolocationAndIsp = getGeolocationAndISP();\n            foreach (var dataLists in await TaskEx.WhenAll(_servers.Select(ICMPTest)))\n            {\n                if (dataLists == null) continue;\n                foreach (var dataList in dataLists.Where(dataList => dataList != null))
            return output;\n        }\n        [DllImport("Kernel32.dll")]\n        private static extern IntPtr LoadLibrary(string path);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public static extern int md5_ret(byte[] input, uint ilen, byte[] output);\n        /// <summary>\n        /// Get cipher ctx size for unmanaged memory allocation\n        /// </summary>\n        /// <returns></returns>
        /// <summary>\n        /// Get cipher ctx size for unmanaged memory allocation\n        /// </summary>\n        /// <returns></returns>\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public static extern int cipher_get_size_ex();\n        #region Cipher layer wrappers\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public static extern IntPtr cipher_info_from_string(string cipher_name);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
    {\n        private Configuration _config;\n        public Local(Configuration config)\n        {\n            this._config = config;\n        }\n        public bool GoodForMe(byte[] firstPacket, int length)\n        {
        public Local(Configuration config)\n        {\n            this._config = config;\n        }\n        public bool GoodForMe(byte[] firstPacket, int length)\n        {\n            return true;\n        }\n        public void Handle(byte[] firstPacket, int length, Socket socket)\n        {
        }\n    }\n    class Handler\n    {\n        //public Encryptor encryptor;\n        public IEncryptor encryptor;\n        public Server server;\n        // Client  socket.\n        public Socket remote;\n        public Socket connection;\n        private byte[] _firstPacket;\n        private int _firstPacketLength;
                if (bytesRead > 1)\n                {\n                    byte[] response = { 5, 0 };\n                    if (_firstPacket[0] != 5)\n                    {\n                        // reject socks 4
                    {\n                        // reject socks 4
            }\n            // don't put polipoRunner.Start() before pacServer.Stop()\n            // or bind will fail when switching bind address from 0.0.0.0 to 127.0.0.1\n            // though UseShellExecute is set to true now\n            // http://stackoverflow.com/questions/10235093/socket-doesnt-close-after-application-exits-if-a-launched-process-is-open\n            polipoRunner.Stop();\n            try\n            {\n                polipoRunner.Start(_config);\n                Local local = new Local(_config);\n                List<Listener.Service> services = new List<Listener.Service>();\n                services.Add(local);\n                _listener = new Listener(services);\n                _listener.Start(_config);
                pacServer.Start(_config);\n            }\n            catch (Exception e)\n            {\n                // translate Microsoft language into human language\n                // i.e. An attempt was made to access a socket in a way forbidden by its access permissions => Port already in use\n                if (e is SocketException)\n                {\n                    SocketException se = (SocketException)e;\n                    if (se.SocketErrorCode == SocketError.AccessDenied)
            this.valueLabel.TabIndex = 7;\n            this.valueLabel.Text = "PackageLoss";
            {\n                new DataUnit(State.Geolocation, State.Unknown),\n                new DataUnit(State.ISP, State.Unknown)\n            };\n        }\n        private static async Task<DataList> GetInfoFromAPI(string API)\n        {\n            string jsonString;\n            try\n            {
            }\n            dynamic obj;\n            if (!SimpleJson.SimpleJson.TryDeserializeObject(jsonString, out obj)) return null;\n            string country = obj["country"];\n            string city = obj["city"];\n            string isp = obj["isp"];\n            if (country == null || city == null || isp == null) return null;\n            return new DataList {\n                new DataUnit(State.Geolocation, $"{country} {city}"),\n                new DataUnit(State.ISP, isp)
            string country = obj["country"];\n            string city = obj["city"];\n            string isp = obj["isp"];\n            if (country == null || city == null || isp == null) return null;\n            return new DataList {\n                new DataUnit(State.Geolocation, $"{country} {city}"),\n                new DataUnit(State.ISP, isp)\n            };\n        }\n        private async Task<List<DataList>> ICMPTest(Server server)
        }\n        private async Task<List<DataList>> ICMPTest(Server server)\n        {\n            Logging.Debug("Ping " + server.FriendlyName());\n            if (server.server == "") return null;\n            var IP = Dns.GetHostAddresses(server.server).First(ip => ip.AddressFamily == AddressFamily.InterNetwork);\n            var ping = new Ping();\n            var ret = new List<DataList>();\n            foreach (\n                var timestamp in Enumerable.Range(0, Repeat).Select(_ => DateTime.Now.ToString(DateTimePattern)))
        {\n            string serverName = _servers[serverSelector.SelectedIndex];\n            _dataTable.Rows.Clear();\n            List<AvailabilityStatistics.RawStatisticsData> statistics;\n            if (!_controller.availabilityStatistics.FilteredStatistics.TryGetValue(serverName, out statistics)) return;\n            IEnumerable<IGrouping<int, AvailabilityStatistics.RawStatisticsData>> dataGroups;\n            if (allMode.Checked)\n            {\n                dataGroups = statistics.GroupBy(data => data.Timestamp.DayOfYear);
            {\n                dataGroups = statistics.GroupBy(data => data.Timestamp.DayOfYear);\n                StatisticsChart.ChartAreas["DataArea"].AxisX.LabelStyle.Format = "MM/dd/yyyy";\n                StatisticsChart.ChartAreas["DataArea"].AxisX2.LabelStyle.Format = "MM/dd/yyyy";\n            }\n            else\n            {\n                dataGroups = statistics.GroupBy(data => data.Timestamp.Hour);\n                StatisticsChart.ChartAreas["DataArea"].AxisX.LabelStyle.Format = "HH:00";
            }\n            else\n            {\n                dataGroups = statistics.GroupBy(data => data.Timestamp.Hour);\n                StatisticsChart.ChartAreas["DataArea"].AxisX.LabelStyle.Format = "HH:00";\n                StatisticsChart.ChartAreas["DataArea"].AxisX2.LabelStyle.Format = "HH:00";\n            }\n            var finalData = from dataGroup in dataGroups\n                            orderby dataGroup.Key\n                            select new
        }\n    }\n}
            ((System.ComponentModel.ISupportInitialize)(this.StatisticsChart)).BeginInit();\n            this.chartModeSelector.SuspendLayout();\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer1)).BeginInit();\n            this.splitContainer1.Panel1.SuspendLayout();\n            this.splitContainer1.Panel2.SuspendLayout();\n            this.splitContainer1.SuspendLayout();\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer2)).BeginInit();\n            this.splitContainer2.Panel1.SuspendLayout();\n            this.splitContainer2.Panel2.SuspendLayout();\n            this.splitContainer2.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.splitContainer1)).BeginInit();\n            this.splitContainer1.Panel1.SuspendLayout();\n            this.splitContainer1.Panel2.SuspendLayout();\n            this.splitContainer1.SuspendLayout();\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer2)).BeginInit();\n            this.splitContainer2.Panel1.SuspendLayout();\n            this.splitContainer2.Panel2.SuspendLayout();\n            this.splitContainer2.SuspendLayout();\n            ((System.ComponentModel.ISupportInitialize)(this.dataCollectionMinutesNum)).BeginInit();\n            ((System.ComponentModel.ISupportInitialize)(this.choiceKeptMinutesNum)).BeginInit();
            // StatisticsStrategyConfigurationForm\n            // \n            this.chartModeSelector.ResumeLayout(false);
            this.splitContainer1.Panel1.ResumeLayout(false);\n            this.splitContainer1.Panel2.ResumeLayout(false);\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer1)).EndInit();\n            this.splitContainer1.ResumeLayout(false);\n            this.splitContainer2.Panel1.ResumeLayout(false);\n            this.splitContainer2.Panel1.PerformLayout();\n            this.splitContainer2.Panel2.ResumeLayout(false);\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer2)).EndInit();\n            this.splitContainer2.ResumeLayout(false);\n            ((System.ComponentModel.ISupportInitialize)(this.dataCollectionMinutesNum)).EndInit();

                    }\n                }\n                else\n                {\n                    registry.SetValue("ProxyEnable", 0);\n                    registry.SetValue("ProxyServer", "");\n                    registry.SetValue("AutoConfigURL", "");\n                }\n                SystemProxy.NotifyIE();\n                //Must Notify IE first, or the connections do not chanage
                {\n                    string argument = "/select, \"" + updateChecker.LatestVersionLocalName + "\"";\n                    Process.Start("explorer.exe", argument);\n                }\n            }\n        }\n        private void _notifyIcon_BalloonTipClosed(object sender, EventArgs e)\n        {\n            if (updateChecker.NewVersionFound)\n            {
                }\n            }\n        }\n        private void _notifyIcon_BalloonTipClosed(object sender, EventArgs e)\n        {\n            if (updateChecker.NewVersionFound)\n            {\n                updateChecker.NewVersionFound = false; /* Reset the flag */\n            }\n        }
namespace Shadowsocks.Controller\n{\n    class AvailabilityStatistics\n    {\n        private const string StatisticsFilesName = "shadowsocks.availability.csv";\n        private const string Delimiter = ",";\n        private const int Timeout = 500;\n        private const int Repeat = 4; //repeat times every evaluation\n        private const int Interval = 10*60*1000; //evaluate proxies every 15 minutes\n        private Timer _timer;
        public static string AvailabilityStatisticsFile;\n        //static constructor to initialize every public static fields before refereced\n        static AvailabilityStatistics()\n        {\n            var temppath = Path.GetTempPath();\n            AvailabilityStatisticsFile = Path.Combine(temppath, StatisticsFilesName);\n        }\n        public bool Set(bool enabled)\n        {\n            try\n            {
            AvailabilityStatisticsFile = Path.Combine(temppath, StatisticsFilesName);\n        }\n        public bool Set(bool enabled)\n        {\n            try\n            {\n                if (enabled)\n                {\n                    if (_timer?.Change(0, Interval) != null) return true;\n                    _state = new State();
                }\n                else\n                {
            {\n                Logging.Debug("eveluating " + server.FriendlyName());\n                foreach (var _ in Enumerable.Range(0, Repeat))\n                {\n                    //TODO: do simple analyze of data to provide friendly message, like package loss.\n                    var timestamp = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss");\n                    //ICMP echo. we can also set options and special bytes\n                    //seems no need to use SendPingAsync：\n                    var reply = ping.Send(server.server, Timeout);\n                    state.Data = new List<KeyValuePair<string, string>>\n                    {\n                        new KeyValuePair<string, string>("Timestamp", timestamp),
                    //ICMP echo. we can also set options and special bytes\n                    //seems no need to use SendPingAsync：\n                    var reply = ping.Send(server.server, Timeout);\n                    state.Data = new List<KeyValuePair<string, string>>\n                    {\n                        new KeyValuePair<string, string>("Timestamp", timestamp),\n                        new KeyValuePair<string, string>("Server", server.FriendlyName()),\n                        new KeyValuePair<string, string>("Status", reply?.Status.ToString()),\n                        new KeyValuePair<string, string>("RoundtripTime", reply?.RoundtripTime.ToString())\n                    };\n                    //state.data.Add(new KeyValuePair<string, string>("data", reply.Buffer.ToString())); // The data of reply
                    //state.data.Add(new KeyValuePair<string, string>("data", reply.Buffer.ToString())); // The data of reply\n            var dataLine = string.Join(Delimiter, data.Select(kv => kv.Value).ToArray());\n            string[] lines;\n            if (!File.Exists(AvailabilityStatisticsFile))\n            {
            string[] lines;\n            if (!File.Exists(AvailabilityStatisticsFile))\n            {\n                var headerLine = string.Join(Delimiter, data.Select(kv => kv.Key).ToArray());\n                lines = new[] { headerLine, dataLine };\n            }\n            else\n            {\n                lines = new[] { dataLine };\n            }
            }\n            else\n            {\n                lines = new[] { dataLine };\n            }\n            File.AppendAllLines(AvailabilityStatisticsFile, lines);\n        }
            }\n            File.AppendAllLines(AvailabilityStatisticsFile, lines);\n        }
using System.Collections.Generic;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Timers;\nusing NLog;\nusing Shadowsocks.Controller.Strategy;\nusing Shadowsocks.Encryption;\nusing Shadowsocks.Encryption.AEAD;\nusing Shadowsocks.Encryption.Exception;
    {\n        public event EventHandler<SSTCPConnectedEventArgs> OnConnected;\n        public event EventHandler<SSTransmitEventArgs> OnInbound;\n        public event EventHandler<SSTransmitEventArgs> OnOutbound;\n        public event EventHandler<SSRelayEventArgs> OnFailed;\n        private static readonly Logger logger = LogManager.GetCurrentClassLogger();\n        private readonly ShadowsocksController _controller;\n        private DateTime _lastSweepTime;\n        private readonly Configuration _config;\n        public ISet<TCPHandler> Handlers { get; set; }
        private DateTime _lastSweepTime;\n        private readonly Configuration _config;\n        public ISet<TCPHandler> Handlers { get; set; }\n        public TCPRelay(ShadowsocksController controller, Configuration conf)\n        {\n            _controller = controller;\n            _config = conf;\n            Handlers = new HashSet<TCPHandler>();\n            _lastSweepTime = DateTime.Now;\n        }
        public ISet<TCPHandler> Handlers { get; set; }\n        public TCPRelay(ShadowsocksController controller, Configuration conf)\n        {\n            _controller = controller;\n            _config = conf;\n            Handlers = new HashSet<TCPHandler>();\n            _lastSweepTime = DateTime.Now;\n        }\n        public override bool Handle(byte[] firstPacket, int length, Socket socket, object state)\n        {
        {\n            public IProxy Remote { get; }\n            public AsyncSession(IProxy remote)\n            {\n                Remote = remote;\n            }\n        }\n        private class AsyncSession<T> : AsyncSession\n        {\n            public T State { get; set; }
        {\n            public T State { get; set; }\n            public AsyncSession(IProxy remote, T state) : base(remote)\n            {\n                State = state;\n            }\n            public AsyncSession(AsyncSession session, T state) : base(session.Remote)\n            {\n                State = state;\n            }
        private readonly int _serverTimeout;\n        private readonly int _proxyTimeout;\n        // each recv size.\n        public const int RecvSize = 2048;\n        // overhead of one chunk, reserved for AEAD ciphers\n        public const int ChunkOverheadSize = 16 * 2 /* two tags */ + AEADEncryptor.CHUNK_LEN_BYTES;\n        // max chunk size\n        public const uint MaxChunkSize = AEADEncryptor.CHUNK_LEN_MASK + AEADEncryptor.CHUNK_LEN_BYTES + 16 * 2;\n        // In general, the ciphertext length, we should take overhead into account\n        public const int BufferSize = RecvSize + (int)MaxChunkSize + 32 /* max salt len */;\n        private readonly ShadowsocksController _controller;\n        private readonly ProxyConfig _config;\n        private readonly Socket _connection;
        private IEncryptor _encryptor;\n        private Server _server;\n        private AsyncSession _currentRemoteSession;\n        private bool _proxyConnected;\n        private bool _destConnected;\n        private byte _command;\n        private byte[] _firstPacket;\n        private int _firstPacketLength;\n        private const int CMD_CONNECT = 0x01;\n        private const int CMD_BIND = 0x02;
        // client -> local proxy (plaintext, before encrypt)\n        private readonly byte[] _connetionRecvBuffer = new byte[BufferSize];\n        // local proxy -> remote (plaintext, after decrypt)\n        private readonly byte[] _remoteSendBuffer = new byte[BufferSize];\n        // local proxy -> client (ciphertext, before decrypt)\n        private readonly byte[] _connetionSendBuffer = new byte[BufferSize];\n        private bool _connectionShutdown = false;\n        private bool _remoteShutdown = false;\n        private bool _closed = false;\n        // instance-based lock without static\n        private readonly object _encryptionLock = new object();\n        private readonly object _decryptionLock = new object();\n        private readonly object _closeConnLock = new object();
        // local proxy -> remote (plaintext, after decrypt)\n        private readonly byte[] _remoteSendBuffer = new byte[BufferSize];\n        // local proxy -> client (ciphertext, before decrypt)\n        private readonly byte[] _connetionSendBuffer = new byte[BufferSize];\n        private bool _connectionShutdown = false;\n        private bool _remoteShutdown = false;\n        private bool _closed = false;\n        // instance-based lock without static\n        private readonly object _encryptionLock = new object();\n        private readonly object _decryptionLock = new object();\n        private readonly object _closeConnLock = new object();\n        private DateTime _startConnectTime;
        // local proxy -> client (ciphertext, before decrypt)\n        private readonly byte[] _connetionSendBuffer = new byte[BufferSize];\n        private bool _connectionShutdown = false;\n        private bool _remoteShutdown = false;\n        private bool _closed = false;\n        // instance-based lock without static\n        private readonly object _encryptionLock = new object();\n        private readonly object _decryptionLock = new object();\n        private readonly object _closeConnLock = new object();\n        private DateTime _startConnectTime;\n        private DateTime _startReceivingTime;
        private bool _connectionShutdown = false;\n        private bool _remoteShutdown = false;\n        private bool _closed = false;\n        // instance-based lock without static\n        private readonly object _encryptionLock = new object();\n        private readonly object _decryptionLock = new object();\n        private readonly object _closeConnLock = new object();\n        private DateTime _startConnectTime;\n        private DateTime _startReceivingTime;\n        private DateTime _startSendingTime;
            /* prepare address buffer length for AEAD */\n            Logger.Trace($"_addrBufLength={_addrBufLength}");\n            _encryptor.AddrBufLength = _addrBufLength;\n        }\n        public void Start(byte[] firstPacket, int length)\n        {\n            _firstPacket = firstPacket;\n            _firstPacketLength = length;\n            HandshakeReceive();\n        }
                _closed = true;\n            }\n            OnClosed?.Invoke(this, new SSRelayEventArgs(_server));\n            try\n            {\n                _connection.Shutdown(SocketShutdown.Both);\n                _connection.Close();\n            }\n            catch (Exception e)\n            {
            }\n        }\n        private void HandshakeSendCallback(IAsyncResult ar)\n        {\n            if (_closed)\n            {\n                return;\n            }\n            try
            try\n            {\n                _connection.EndSend(ar);\n                // +-----+-----+-------+------+----------+----------+\n                // | VER | CMD |  RSV  | ATYP | DST.ADDR | DST.PORT |\n                // +-----+-----+-------+------+----------+----------+\n                // |  1  |  1  | X'00' |  1   | Variable |    2     |\n                // +-----+-----+-------+------+----------+----------+\n                // Skip first 3 bytes, and read 2 more bytes to analysis the address.\n                // 2 more bytes is designed if address is domain then we don't need to read once more to get the addr length.\n                    AddressReceiveCallback, null);\n            }\n            catch (Exception e)\n            {\n                ErrorClose(e);\n            }
            try\n            {\n                int bytesRead = _connection.EndReceive(ar);\n                if (bytesRead >= 5)\n                {\n                    _command = _connetionRecvBuffer[1];\n                    switch (_command)\n                    {\n                        case CMD_CONNECT:\n                            // +----+-----+-------+------+----------+----------+
        {\n            try\n            {\n                _connection.EndSend(ar);\n                ReadAddress(StartConnect);\n            }\n            catch (Exception e)\n            {\n                ErrorClose(e);
            }\n        }\n        private void ReadAddress(Action onSuccess)\n        {\n            int atyp = _connetionRecvBuffer[3];\n            switch (atyp)\n            {\n                case ATYP_IPv4: // IPv4 address, 4 bytes\n                    ReadAddress(4 + ADDR_PORT_LEN - 1, onSuccess);\n                    break;
            try\n            {\n                int bytesRead = _connection.EndReceive(ar);\n                object[] states = (object[])ar.AsyncState;\n                int bytesRemain = (int)states[0];\n                Action onSuccess = (Action)states[1];\n                if (bytesRead >= bytesRemain)\n                {\n                    _firstPacketLength = bytesRead + 2;\n                    int atyp = _connetionRecvBuffer[0];
                int bytesRemain = (int)states[0];\n                Action onSuccess = (Action)states[1];\n                if (bytesRead >= bytesRemain)\n                {\n                    _firstPacketLength = bytesRead + 2;\n                    int atyp = _connetionRecvBuffer[0];\n                    string dstAddr = "Unknown";\n                    int dstPort = -1;\n                    switch (atyp)\n                    {
                if (bytesRead >= bytesRemain)\n                {\n                    _firstPacketLength = bytesRead + 2;\n                    int atyp = _connetionRecvBuffer[0];\n                    string dstAddr = "Unknown";\n                    int dstPort = -1;\n                    switch (atyp)\n                    {\n                        case ATYP_IPv4: // IPv4 address, 4 bytes\n                            dstAddr = new IPAddress(_connetionRecvBuffer.Skip(1).Take(4).ToArray()).ToString();
            }\n        }\n        // inner class\n        private class ProxyTimer : Timer\n        {\n            public AsyncSession Session;\n            public EndPoint DestEndPoint;\n            public Server Server;\n            public ProxyTimer(int p) : base(p)\n            {
            }\n        }\n        private void ProxyConnectTimer_Elapsed(object sender, ElapsedEventArgs e)\n        {\n            ProxyTimer timer = (ProxyTimer)sender;\n            timer.Elapsed -= ProxyConnectTimer_Elapsed;\n            timer.Enabled = false;\n            timer.Dispose();\n            if (_proxyConnected || _destConnected || _closed)\n            {
            timer.Elapsed -= ProxyConnectTimer_Elapsed;\n            timer.Enabled = false;\n            timer.Dispose();\n            if (_proxyConnected || _destConnected || _closed)\n            {\n                return;\n            }\n            IProxy proxy = timer.Session.Remote;\n            Logger.Info($"Proxy {proxy.ProxyEndPoint} timed out");\n            proxy.Close();
            Logger.Info($"Proxy {proxy.ProxyEndPoint} timed out");\n            proxy.Close();\n            Close();\n        }\n        private void ProxyConnectCallback(IAsyncResult ar)\n        {\n            if (_closed)\n            {\n                return;\n            }
                ProxyTimer timer = session.State;\n                EndPoint destEndPoint = timer.DestEndPoint;\n                Server server = timer.Server;\n                timer.Elapsed -= ProxyConnectTimer_Elapsed;\n                timer.Enabled = false;\n                timer.Dispose();\n                IProxy remote = session.Remote;\n                // Complete the connection.\n                remote.EndConnectProxy(ar);\n                _proxyConnected = true;
                timer.Elapsed -= ProxyConnectTimer_Elapsed;\n                timer.Enabled = false;\n                timer.Dispose();\n                IProxy remote = session.Remote;\n                // Complete the connection.\n                remote.EndConnectProxy(ar);\n                _proxyConnected = true;\n                if (!(remote is DirectConnect))\n                {\n                    Logger.Debug($"Socket connected to proxy {remote.ProxyEndPoint}");
                // Complete the connection.\n                remote.EndConnectProxy(ar);\n                _proxyConnected = true;\n                if (!(remote is DirectConnect))\n                {\n                    Logger.Debug($"Socket connected to proxy {remote.ProxyEndPoint}");\n                }\n                _startConnectTime = DateTime.Now;\n                ServerTimer connectTimer = new ServerTimer(_serverTimeout) { AutoReset = false };\n                connectTimer.Elapsed += DestConnectTimer_Elapsed;
            }\n        }\n        private void DestConnectTimer_Elapsed(object sender, ElapsedEventArgs e)\n        {\n            ServerTimer timer = (ServerTimer)sender;\n            timer.Elapsed -= DestConnectTimer_Elapsed;\n            timer.Enabled = false;\n            timer.Dispose();\n            if (_destConnected || _closed)\n            {
            timer.Elapsed -= DestConnectTimer_Elapsed;\n            timer.Enabled = false;\n            timer.Dispose();\n            if (_destConnected || _closed)\n            {\n                return;\n            }\n            AsyncSession session = timer.Session;\n            Server server = timer.Server;\n            OnFailed?.Invoke(this, new SSRelayEventArgs(_server));
            Server server = timer.Server;\n            OnFailed?.Invoke(this, new SSRelayEventArgs(_server));\n            Logger.Info($"{server.FriendlyName()} timed out");\n            session.Remote.Close();\n            Close();\n        }\n        private void ConnectCallback(IAsyncResult ar)\n        {\n            if (_closed)\n            {
                ServerTimer timer = session.State;\n                _server = timer.Server;\n                timer.Elapsed -= DestConnectTimer_Elapsed;\n                timer.Enabled = false;\n                timer.Dispose();\n                IProxy remote = session.Remote;\n                // Complete the connection.\n                remote.EndConnectDest(ar);\n                _destConnected = true;\n                Logger.Debug($"Socket connected to ss server: {_server.FriendlyName()}");\n                TimeSpan latency = DateTime.Now - _startConnectTime;
                // Complete the connection.\n                remote.EndConnectDest(ar);\n                _destConnected = true;\n                Logger.Debug($"Socket connected to ss server: {_server.FriendlyName()}");\n                TimeSpan latency = DateTime.Now - _startConnectTime;\n                OnConnected?.Invoke(this, new SSTCPConnectedEventArgs(_server, latency));\n                StartPipe(session);\n            }\n            catch (ArgumentException)\n            {\n            }
                OnConnected?.Invoke(this, new SSTCPConnectedEventArgs(_server, latency));\n                StartPipe(session);\n            }\n            catch (ArgumentException)\n            {\n            }\n            catch (Exception e)\n            {\n                if (_server != null)\n                {
            }\n        }\n        private void TryReadAvailableData()\n        {\n            int available = Math.Min(_connection.Available, RecvSize - _firstPacketLength);\n            if (available > 0)\n            {\n                int size = _connection.Receive(_connetionRecvBuffer, _firstPacketLength, available,\n                    SocketFlags.None);\n                _firstPacketLength += size;
                    SocketFlags.None);\n                _firstPacketLength += size;\n            }\n        }\n        private void StartPipe(AsyncSession session)\n        {\n            if (_closed)\n            {\n                return;\n            }
            try\n            {\n                _startReceivingTime = DateTime.Now;\n                session.Remote.BeginReceive(_remoteRecvBuffer, 0, RecvSize, SocketFlags.None,\n                    PipeRemoteReceiveCallback, session);\n                TryReadAvailableData();\n                Logger.Trace($"_firstPacketLength = {_firstPacketLength}");\n                SendToServer(_firstPacketLength, session);\n            }\n            catch (Exception e)
            }\n        }\n        private void PipeRemoteReceiveCallback(IAsyncResult ar)\n        {\n            if (_closed)\n            {\n                return;\n            }\n            try\n            {
                int bytesRead = session.Remote.EndReceive(ar);\n                _totalRead += bytesRead;\n                OnInbound?.Invoke(this, new SSTransmitEventArgs(_server, bytesRead));\n                if (bytesRead > 0)\n                {\n                    lastActivity = DateTime.Now;\n                    int bytesToSend = -1;\n                    lock (_decryptionLock)\n                    {\n                        try
            }\n        }\n        private void PipeConnectionReceiveCallback(IAsyncResult ar)\n        {\n            if (_closed)\n            {\n                return;\n            }\n            try
            try\n            {\n                int bytesRead = _connection.EndReceive(ar);\n                AsyncSession session = (AsyncSession)ar.AsyncState;\n                IProxy remote = session.Remote;\n                if (bytesRead > 0)\n                {\n                    SendToServer(bytesRead, session);\n                }\n                else
                if (bytesRead > 0)\n                {\n                    SendToServer(bytesRead, session);\n                }\n                else\n                {\n                    remote.Shutdown(SocketShutdown.Send);\n                    _remoteShutdown = true;\n                    CheckClose();\n                }
            }\n        }\n        // In general, we assume there is no delay between local proxy and client, add this for sanity\n        private void PipeConnectionSendCallback(IAsyncResult ar)\n        {\n            try\n            {\n                object[] container = (object[])ar.AsyncState;\n                AsyncSession session = (AsyncSession)container[0];\n                int bytesShouldSend = (int)container[1];\n                int bytesSent = _connection.EndSend(ar);
                if (bytesRemaining > 0)\n                {\n                    Logger.Info("reconstruct _remoteSendBuffer to re-send");\n                    Buffer.BlockCopy(_remoteSendBuffer, bytesSent, _remoteSendBuffer, 0, bytesRemaining);\n                    _connection.BeginSend(_remoteSendBuffer, 0, bytesRemaining, SocketFlags.None,\n                        PipeConnectionSendCallback, new object[] { session, bytesRemaining });\n                    return;\n                }\n                session.Remote.BeginReceive(_remoteRecvBuffer, 0, RecvSize, SocketFlags.None,\n                    PipeRemoteReceiveCallback, session);
        private MenuItem editPACFileItem;\n        private MenuItem QRCodeItem;\n        private MenuItem ShowLogItem;\n        private MenuItem aboutItem;\n        private MenuItem ServersItem;\n        private MenuItem SeperatorItem4;\n        private MenuItem quitItem;\n        private MenuItem SeperatorItem2;
        private MenuItem quitItem;\n        private MenuItem SeperatorItem2;

            // \n            // contextMenu1\n            // \n            this.contextMenu1.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {\n            this.enableItem,\n            this.modeItem,\n            this.ServersItem,\n            this.SeperatorItem2,\n            this.AutoStartupItem,\n            this.ShareOverLANItem,\n            this.editPACFileItem,\n            this.SeperatorItem3,\n            this.QRCodeItem,
            this.AutoStartupItem,\n            this.ShareOverLANItem,\n            this.editPACFileItem,\n            this.SeperatorItem3,\n            this.QRCodeItem,\n            this.ShowLogItem,\n            this.aboutItem,\n            this.SeperatorItem4,\n            this.quitItem});
            this.QRCodeItem,\n            this.ShowLogItem,\n            this.aboutItem,\n            this.SeperatorItem4,\n            this.quitItem});
            this.quitItem});
        }\n        private void controller_ConfigChanged(object sender, EventArgs e)\n        {\n            LoadCurrentConfiguration();\n            UpdateTrayIcon();\n        }\n        private void controller_EnableStatusChanged(object sender, EventArgs e)\n        {\n            enableItem.Checked = controller.GetConfiguration().enabled;\n        }
            handler.Send(firstPacket, length);\n            handler.Receive();\n            return true;\n        }\n        public class UDPHandler\n        {\n            private Socket _local;\n            private Socket _remote;\n            private Server _server;\n            private byte[] _buffer = new byte[1500];
        {\n            private Socket _local;\n            private Socket _remote;\n            private Server _server;\n            private byte[] _buffer = new byte[1500];\n            private IPEndPoint _localEndPoint;\n            private IPEndPoint _remoteEndPoint;\n            public UDPHandler(Socket local, Server server, IPEndPoint localEndPoint)\n            {
        }\n        private void OKButton_Click(object sender, EventArgs e)\n        {\n            if (_modifiedProxyConfig.useProxy=UseProxyCheckBox.Checked)\n            {\n                if (!int.TryParse(ProxyPortTextBox.Text, out _modifiedProxyConfig.proxyPort))\n                {
            {\n                if (!int.TryParse(ProxyPortTextBox.Text, out _modifiedProxyConfig.proxyPort))\n                {\n                    MessageBox.Show(I18N.GetString("Illegal port number format"));\n                    return;\n                }\n                if (!int.TryParse(ProxyTimeoutTextBox.Text, out _modifiedProxyConfig.proxyTimeout))
                {\n                    MessageBox.Show(I18N.GetString("Illegal port number format"));\n                    return;\n                }\n                if (!int.TryParse(ProxyTimeoutTextBox.Text, out _modifiedProxyConfig.proxyTimeout))\n                {\n                    MessageBox.Show(I18N.GetString("Illegal timeout format"));\n                    return;\n                }\n                _modifiedProxyConfig.proxyType = ProxyTypeComboBox.SelectedIndex;
                {\n                    MessageBox.Show(I18N.GetString("Illegal timeout format"));\n                    return;\n                }\n                _modifiedProxyConfig.proxyType = ProxyTypeComboBox.SelectedIndex;\n                try\n                {\n                    Configuration.CheckServer(_modifiedProxyConfig.proxyServer = ProxyServerTextBox.Text);
                try\n                {\n                    Configuration.CheckServer(_modifiedProxyConfig.proxyServer = ProxyServerTextBox.Text);\n                    Configuration.CheckPort(_modifiedProxyConfig.proxyPort);\n                    Configuration.CheckTimeout(_modifiedProxyConfig.proxyTimeout, ProxyConfig.MaxProxyTimeoutSec);\n                }\n                catch (Exception ex)\n                {\n                    MessageBox.Show(ex.Message);\n                    return;
                }\n                catch (Exception ex)\n                {\n                    MessageBox.Show(ex.Message);\n                    return;\n                }\n            }\n            controller.SaveProxy(_modifiedProxyConfig);
            }\n            controller.SaveProxy(_modifiedProxyConfig);\n            this.Close();\n        }\n        private void CancelButton_Click(object sender, EventArgs e)\n        {
            this.Close();\n        }\n        private void CancelButton_Click(object sender, EventArgs e)\n        {\n            this.Close();\n        }\n        private void ProxyForm_FormClosed(object sender, FormClosedEventArgs e)\n        {\n            controller.ConfigChanged -= controller_ConfigChanged;\n        }
                ProxyTypeComboBox.Enabled = true;\n            }\n            else\n            {\n                ProxyServerTextBox.Enabled =\n                ProxyPortTextBox.Enabled =\n                ProxyTimeoutTextBox.Enabled =\n                ProxyTypeComboBox.Enabled = false; \n            }\n        }
            }\n        }\n    }\n}
        public void Start(Configuration configuration)\n        {\n            if (_process == null)\n            {\n                Process[] existingPrivoxy = Process.GetProcessesByName("ss_privoxy");\n                foreach (Process p in existingPrivoxy.Where(IsChildProcess))\n                {\n                    KillProcess(p);\n                }
            if (_process == null)\n            {\n                Process[] existingPrivoxy = Process.GetProcessesByName("ss_privoxy");\n                foreach (Process p in existingPrivoxy.Where(IsChildProcess))\n                {\n                    KillProcess(p);\n                }\n                string privoxyConfig = Resources.privoxy_conf;\n                _runningPort = this.GetFreePort();\n                privoxyConfig = privoxyConfig.Replace("__SOCKS_PORT__", configuration.localPort.ToString());
            }\n            catch (Exception e)\n            {\n                // in case access denied\n                Logging.LogUsefulException(e);\n                return defaultPort;\n            }\n        }\n        [StructLayout(LayoutKind.Sequential)]\n        public struct RECT
        }\n        [StructLayout(LayoutKind.Sequential)]\n        public struct RECT\n        {\n            public int left;\n            public int top;\n            public int right;\n            public int bottom;\n        }\n        [DllImport("user32.dll")]
                    {\n                        string rule;\n                        while ((rule = sr.ReadLine()) != null)\n                        {\n                            if (rule == "" || rule[0] == '!' || rule[0] == '[')\n                                continue;\n                            lines.Add(rule);\n                        }\n                    }\n                }
                    }\n                }\n                string abpContent;\n                if (File.Exists(PACServer.USER_ABP_FILE))\n                {\n                    abpContent = File.ReadAllText(PACServer.USER_ABP_FILE, Encoding.UTF8);\n                }\n                else\n                {\n                    abpContent = Utils.UnGzip(Resources.abp_js);
            {\n                string line;\n                while ((line = sr.ReadLine()) != null)\n                {\n                    if (line == "" || line[0] == '!' || line[0] == '[')\n                        continue;\n                    valid_lines.Add(line);\n                }\n            }\n            return valid_lines;
            }\n            return valid_lines;\n        }\n    }\n}
using System.Drawing;\nusing System.Windows.Forms;\nusing Newtonsoft.Json;\nnamespace Shadowsocks.Model\n{\n    [Serializable]\n    public class LogViewerConfig\n    {
        public bool topMost;\n        public bool wrapText;\n        public bool toolbarShown;
            topMost = false;\n            wrapText = false;\n            toolbarShown = false;\n        }\n        #region Size
        }\n        #region Size\n        public void SaveSize()\n        {\n            Properties.Settings.Default.Save();\n        }\n        [JsonIgnore]\n        public int Width\n        {\n            get { return Properties.Settings.Default.LogViewerWidth; }
        {\n            get
            {\n        [JsonIgnore]\n        public int BestTop
        {\n            get\n            {\n                int height = Height;
            {\n                int height = Height;\n                height = (height >= 200) ? height : 200; // set up the minimum size\n                return Screen.PrimaryScreen.WorkingArea.Height - height;\n            }
            }\n        }\n        #endregion
    }\n}
                }\n                catch (FormatException)\n                {\n                    MessageBox.Show(I18N.GetString("Illegal port number format"));\n                    return;\n                }\n                catch (Exception ex)\n                {\n                    MessageBox.Show(ex.Message);\n                    return;
namespace Shadowsocks.Model\n{\n    [Serializable]\n    public class ProxyConfig\n    {\n        public const int PROXY_SOCKS5 = 0;\n        public const int PROXY_HTTP = 1;\n        public bool useProxy;\n        public int proxyType;\n        public string proxyServer;
            this.tableLayoutPanel1.Controls.Add(this.UseProxyCheckBox, 0, 0);\n            this.tableLayoutPanel1.Controls.Add(this.tableLayoutPanel2, 0, 2);\n            this.tableLayoutPanel1.Controls.Add(this.tableLayoutPanel4, 0, 1);\n            this.tableLayoutPanel1.Location = new System.Drawing.Point(15, 15);\n            this.tableLayoutPanel1.Name = "tableLayoutPanel1";\n            this.tableLayoutPanel1.RowCount = 4;\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel1.Location = new System.Drawing.Point(15, 15);\n            this.tableLayoutPanel1.Name = "tableLayoutPanel1";\n            this.tableLayoutPanel1.RowCount = 4;\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.Size = new System.Drawing.Size(395, 123);

        }\n        public int EndSend(IAsyncResult asyncResult)\n        {\n            return _remote.EndSend(asyncResult);\n        }\n        public void BeginReceive(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state)\n        {\n            _remote.BeginReceive(buffer, offset, size, socketFlags, callback, state);\n        }
        }\n        public int EndReceive(IAsyncResult asyncResult)\n        {\n            return _remote.EndReceive(asyncResult);\n        }\n        public void Shutdown(SocketShutdown how)\n        {\n            _remote.Shutdown(how);\n        }\n        public void Close()
        }\n        public void Close()\n        {\n            _remote.Dispose();\n        }\n        private void ConnectCallback(IAsyncResult ar)\n        {\n            var state = (Socks5State) ar.AsyncState;\n            try\n            {
        }\n        private void ConnectCallback(IAsyncResult ar)\n        {\n            var state = (Socks5State) ar.AsyncState;\n            try\n            {\n                _remote.EndConnect(ar);\n                _remote.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n                byte[] handshake = {5, 1, 0};\n                _remote.BeginSend(handshake, 0, handshake.Length, 0, Socks5HandshakeSendCallback, state);
        {\n            _config.proxy.useProxy = true;\n            _config.proxy.proxyType = type;\n            _config.proxy.proxyServer = proxy;\n            _config.proxy.proxyPort = port;\n            SaveConfig(_config);\n        }\n        public void ToggleVerboseLogging(bool enabled)\n        {\n            _config.isVerboseLogging = enabled;
        XmlDocument doc = new XmlDocument();\n        XmlElement logFileNameElement;\n        XmlElement logLevelElement;\n        /// <summary>\n        /// Load the NLog config xml file content\n        /// </summary>\n        public static NLogConfig LoadXML()\n        {\n            NLogConfig config = new NLogConfig();
        /// <summary>\n        /// Load the NLog config xml file content\n        /// </summary>\n        public static NLogConfig LoadXML()\n        {\n            NLogConfig config = new NLogConfig();\n            config.doc.Load(NLOG_CONFIG_FILE_NAME);\n            config.logLevelElement = (XmlElement)SelectSingleNode(config.doc, "//nlog:logger[@name='*']");\n            config.logFileNameElement = (XmlElement)SelectSingleNode(config.doc, "//nlog:target[@name='file']");\n            return config;
        }\n        /// <summary>\n        /// Set the target fileName to xml file\n        /// </summary>\n        /// <param name="fileName"></param>\n        public void SetLogFileName(string fileName)\n        {\n            logFileNameElement.SetAttribute(LOGGER_FILE_NAME_ATTRIBUTE, fileName);\n        }
using System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Drawing;\nusing System.Windows.Forms;\nusing ZXing;\nusing ZXing.Common;\nusing ZXing.QrCode;\nusing Shadowsocks.Controller;\nusing Shadowsocks.Model;
using System.Windows.Forms;\nusing ZXing;\nusing ZXing.Common;\nusing ZXing.QrCode;\nusing Shadowsocks.Controller;\nusing Shadowsocks.Model;\nusing Shadowsocks.Properties;\nnamespace Shadowsocks.View\n{\n    public class MenuViewController
            this.notifyIcon1 = new System.Windows.Forms.NotifyIcon(this.components);\n            this.contextMenuStrip1 = new System.Windows.Forms.ContextMenuStrip(this.components);\n            this.ConfigItem = new System.Windows.Forms.ToolStripMenuItem();\n            this.aboutToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();\n            this.toolStripSeparator2 = new System.Windows.Forms.ToolStripSeparator();\n            this.QuitItem = new System.Windows.Forms.ToolStripMenuItem();\n            this.panel2 = new System.Windows.Forms.Panel();\n            this.button1 = new System.Windows.Forms.Button();\n            this.button2 = new System.Windows.Forms.Button();\n            this.panel1 = new System.Windows.Forms.Panel();
            this.SuspendLayout();\n            // \n            // tableLayoutPanel1\n            // \n            this.tableLayoutPanel1.AutoSize = true;\n            this.tableLayoutPanel1.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;\n            this.tableLayoutPanel1.ColumnCount = 2;\n            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());\n            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());\n            this.tableLayoutPanel1.Controls.Add(this.label5, 0, 4);\n            this.tableLayoutPanel1.Controls.Add(this.label1, 0, 0);\n            this.tableLayoutPanel1.Controls.Add(this.label2, 0, 1);\n            this.tableLayoutPanel1.Controls.Add(this.comboBox1, 1, 4);
            this.ResumeLayout(false);\n            this.PerformLayout();\n        }\n        #endregion\n        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel1;\n        private System.Windows.Forms.Label label1;\n        private System.Windows.Forms.Label label2;\n        private System.Windows.Forms.Label label3;\n        private System.Windows.Forms.Label label4;\n        private System.Windows.Forms.TextBox textBox1;
        private System.Windows.Forms.NotifyIcon notifyIcon1;\n        private System.Windows.Forms.ContextMenuStrip contextMenuStrip1;\n        private System.Windows.Forms.ToolStripMenuItem ConfigItem;\n        private System.Windows.Forms.ToolStripMenuItem QuitItem;\n        private System.Windows.Forms.ToolStripMenuItem aboutToolStripMenuItem;\n        private System.Windows.Forms.ToolStripSeparator toolStripSeparator2;\n        private System.Windows.Forms.Label label5;\n        private System.Windows.Forms.ComboBox comboBox1;\n        private System.Windows.Forms.Panel panel2;\n        private System.Windows.Forms.Button button1;
        {\n            MD5 md5 = System.Security.Cryptography.MD5.Create();\n            byte[] inputBytes = System.Text.Encoding.UTF8.GetBytes(password);\n            byte[] hash = md5.ComputeHash(inputBytes);\n            if (method != null && method.ToLowerInvariant().Equals("rc4")) {\n                Console.WriteLine("init rc4");\n                this.method = TYPE_RC4;\n                rc4 = new RC4();\n                encryptTable = rc4.EncryptInitalize(hash);\n                decryptTable = rc4.EncryptInitalize(hash);
            }\n        }\n        public void Encrypt(byte[] buf, int length)\n        {\n            switch (method)\n            {\n                case TYPE_TABLE:\n                    for (int i = 0; i < length; i++)\n                        buf[i] = encryptTable[buf[i]];\n                    break;
            {\n                case TYPE_TABLE:\n                    for (int i = 0; i < length; i++)\n                        buf[i] = encryptTable[buf[i]];\n                    break;\n                case TYPE_RC4:\n                    rc4.Encrypt(encryptTable, buf, length);\n                    break;\n            }\n        }
            }\n        }\n        public void Decrypt(byte[] buf, int length)\n        {\n            switch (method)\n            {\n                case TYPE_TABLE:\n                    for (int i = 0; i < length; i++)\n                        buf[i] = decryptTable[buf[i]];\n                    break;
            {\n                case TYPE_TABLE:\n                    for (int i = 0; i < length; i++)\n                        buf[i] = decryptTable[buf[i]];\n                    break;\n                case TYPE_RC4:\n                    rc4.Decrypt(decryptTable, buf, length);\n                    break;\n            }\n        }
            }\n        }\n    }\n}
using System.Net.Sockets;\nusing System.Timers;\nusing Shadowsocks.Controller.Strategy;\nusing Shadowsocks.Encryption;\nusing Shadowsocks.Model;\nnamespace Shadowsocks.Controller\n{
using Shadowsocks.Encryption;\nusing Shadowsocks.Model;\nnamespace Shadowsocks.Controller\n{\n    class TCPRelay : Listener.Service\n    {\n        private ShadowsocksController _controller;\n        private DateTime _lastSweepTime;
namespace Shadowsocks.Controller\n{\n    class TCPRelay : Listener.Service\n    {\n        private ShadowsocksController _controller;\n        private DateTime _lastSweepTime;\n        public ISet<TCPHandler> Handlers\n        {\n            get; set;\n        }
        {\n            get; set;\n        }\n        public TCPRelay(ShadowsocksController controller)\n        {\n            _controller = controller;\n            Handlers = new HashSet<TCPHandler>();\n            _lastSweepTime = DateTime.Now;\n        }\n        public bool Handle(byte[] firstPacket, int length, Socket socket, object state)
        }\n        public bool Handle(byte[] firstPacket, int length, Socket socket, object state)\n        {\n            if (socket.ProtocolType != ProtocolType.Tcp)\n            {\n                return false;\n            }\n            if (length < 2 || firstPacket[0] != 5)\n            {\n                return false;
            handler.connection = socket;\n            handler.controller = _controller;\n            handler.relay = this;\n            handler.Start(firstPacket, length);\n            IList<TCPHandler> handlersToClose = new List<TCPHandler>();\n            lock (Handlers)\n            {\n                Handlers.Add(handler);\n                DateTime now = DateTime.Now;
                DateTime now = DateTime.Now;\n                if (now - _lastSweepTime > TimeSpan.FromSeconds(1))\n                {\n                    _lastSweepTime = now;\n                    foreach (TCPHandler handler1 in Handlers)\n                    {\n                        if (now - handler1.lastActivity > TimeSpan.FromSeconds(900))\n                        {\n                            handlersToClose.Add(handler1);\n                        }
                    {\n                        if (now - handler1.lastActivity > TimeSpan.FromSeconds(900))\n                        {\n                            handlersToClose.Add(handler1);\n                        }\n                    }\n                }\n            }\n            foreach (TCPHandler handler1 in handlersToClose)\n            {
            {\n                Logging.Debug("Closing timed out TCP connection.");\n                handler1.Close();\n            }\n            return true;\n        }\n        public void UpdateInboundCounter(long n)\n        {\n            _controller.UpdateInboundCounter(n);\n        }
    {\n        private const int maxRetry = 4;\n        private int retryCount = 0;
            this.server = server;\n        }\n        public void Start(byte[] firstPacket, int length)\n        {\n            _firstPacket = firstPacket;\n            _firstPacketLength = length;\n            HandshakeReceive();\n            lastActivity = DateTime.Now;\n        }\n        private void CheckClose()
        }\n        private void CheckClose()\n        {\n            if (connectionShutdown && remoteShutdown)\n            {\n                Close();\n            }\n        }\n        public void Close()\n        {
            }\n        }\n        public void Close()\n        {\n            lock (relay.Handlers)\n            {\n                relay.Handlers.Remove(this);\n            }\n            lock (this)
                relay.Handlers.Remove(this);\n            }\n            lock (this)\n            {\n                if (closed)\n                {\n                    return;\n                }\n                closed = true;\n            }
                    connection.BeginSend(response, 0, response.Length, 0, new AsyncCallback(HandshakeSendCallback), null);\n                }\n                else\n                {\n                    Close();\n                }\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);
            }\n        }\n        private void HandshakeSendCallback(IAsyncResult ar)\n        {\n            if (closed)\n            {\n                return;\n            }\n            try\n            {
                        connection.BeginSend(response, 0, response.Length, 0, new AsyncCallback(ResponseCallback), null);\n                    }\n                    else if (command == 3)\n                    {\n                        HandleUDPAssociate();\n                    }\n                }\n                else\n                {\n                    Logging.Debug("failed to recv data in Shadowsocks.Controller.TCPHandler.handshakeReceive2Callback()");
            }\n        }\n        private void HandleUDPAssociate()\n        {\n            IPEndPoint endPoint = (IPEndPoint)connection.LocalEndPoint;\n            byte[] address = endPoint.Address.GetAddressBytes();\n            int port = endPoint.Port;\n            byte[] response = new byte[4 + address.Length + 2];\n            response[0] = 5;\n            if (endPoint.AddressFamily == AddressFamily.InterNetwork)
                }\n                else\n                {\n                    int bytesRead = connection.EndReceive(ar);\n                    if (bytesRead > 0)\n                    {\n                        Logging.Debug(remote, RecvSize, "TCP Relay");\n                        connection.BeginReceive(connetionRecvBuffer, 0, RecvSize, 0, new AsyncCallback(ReadAll), null);
                    }\n                    else\n                    {\n                        Close();\n                    }\n                }\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);
            }\n        }\n        private void ResponseCallback(IAsyncResult ar)\n        {\n            try\n            {\n                connection.EndSend(ar);\n                StartConnect();\n            }\n            catch (Exception e)
                StartConnect();\n                retryCount++;\n            }\n            else\n            {\n                Close();\n            }\n        }\n        private void ConnectCallback(IAsyncResult ar)\n        {
            }\n        }\n        private void ConnectCallback(IAsyncResult ar)\n        {\n            Server server = null;\n            if (closed)\n            {\n                return;\n            }\n            try
                    int bytesToSend;\n                    lock (decryptionLock)\n                    {\n                        if (closed)\n                        {\n                            return;\n                        }\n                        encryptor.Decrypt(remoteRecvBuffer, bytesRead, remoteSendBuffer, out bytesToSend);\n                    }\n                    Logging.Debug(remote, bytesToSend, "TCP Relay", "@PipeRemoteReceiveCallback() (download)");
                    connection.BeginSend(remoteSendBuffer, 0, bytesToSend, 0, new AsyncCallback(PipeConnectionSendCallback), null);\n                    IStrategy strategy = controller.GetCurrentStrategy();\n                    if (strategy != null)\n                    {\n                        strategy.UpdateLastRead(server);\n                    }\n                }\n                else\n                {\n                    connection.Shutdown(SocketShutdown.Send);
                    }\n                }\n                else\n                {\n                    connection.Shutdown(SocketShutdown.Send);\n                    connectionShutdown = true;\n                    CheckClose();\n                    //if (totalRead == 0)\n                    //{\n                    //    // closed before anything received, reports as failure
            }\n        }\n        private void PipeConnectionReceiveCallback(IAsyncResult ar)\n        {\n            if (closed)\n            {\n                return;\n            }\n            try\n            {
                    remote.BeginSend(connetionSendBuffer, 0, bytesToSend, 0, new AsyncCallback(PipeRemoteSendCallback), null);\n                    IStrategy strategy = controller.GetCurrentStrategy();\n                    if (strategy != null)\n                    {\n                        strategy.UpdateLastWrite(server);\n                    }\n                }\n                else\n                {\n                    remote.Shutdown(SocketShutdown.Send);
                    }\n                }\n                else\n                {\n                    remote.Shutdown(SocketShutdown.Send);\n                    remoteShutdown = true;\n                    CheckClose();\n                }\n            }\n            catch (Exception e)
using System.Collections.Generic;\nusing System.Net;\nusing System.Net.NetworkInformation;\nusing System.Net.Sockets;\nusing Shadowsocks.Model;\nnamespace Shadowsocks.Controller\n{\n    public class Listener\n    {\n        public interface Service
namespace Shadowsocks.Controller\n{\n    public class Listener\n    {\n        public interface Service\n        {\n            bool Handle(byte[] firstPacket, int length, Socket socket, object state);\n        }\n        public class UDPState\n        {
using System.Collections.Generic;\nusing System.IO;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Text;\nusing System.Threading;\nusing Shadowsocks.Controller.Strategy;\nusing Shadowsocks.Model;\nusing Shadowsocks.Properties;
using Shadowsocks.Controller.Strategy;\nusing Shadowsocks.Model;\nusing Shadowsocks.Properties;\nusing Shadowsocks.Util;\nnamespace Shadowsocks.Controller\n{\n    public class ShadowsocksController\n    {
using Shadowsocks.Util;\nnamespace Shadowsocks.Controller\n{\n    public class ShadowsocksController\n    {\n        // controller:\n        // handle user actions\n        // manipulates UI\n        // interacts with low level logic
namespace Shadowsocks.Controller\n{\n    public class ShadowsocksController\n    {\n        // controller:\n        // handle user actions\n        // manipulates UI\n        // interacts with low level logic\n        private Thread _ramThread;\n        private Listener _listener;
using Shadowsocks.Encryption;\nusing Shadowsocks.Model;\nnamespace Shadowsocks.Controller\n{\n    class UDPRelay : Listener.Service\n    {
namespace Shadowsocks.Controller\n{\n    class UDPRelay : Listener.Service\n    {\n        private ShadowsocksController _controller;\n        private LRUCache<IPEndPoint, UDPHandler> _cache;\n        public long outbound = 0;\n        public long inbound = 0;\n        public UDPRelay(ShadowsocksController controller)\n        {
using System.Diagnostics;\nusing System.IO;\nusing System.IO.Compression;\nusing System.Runtime.InteropServices;\nusing System.Windows.Forms;\nusing Shadowsocks.Controller;\nnamespace Shadowsocks.Util\n{\n    public class Utils
using System.Windows.Forms;\nusing Shadowsocks.Controller;\nnamespace Shadowsocks.Util\n{\n    public class Utils\n    {\n        // return path to store temporary files\n        public static string GetTempPath()\n        {\n            if (File.Exists(Application.StartupPath + "\\shadowsocks_portable_mode.txt"))
using System.Drawing;\nusing System.IO;\nusing System.Windows.Forms;\nusing Shadowsocks.Controller;\nusing Shadowsocks.Properties;\nusing Shadowsocks.Model;\nusing Shadowsocks.Util;\nnamespace Shadowsocks.View
using System.Windows.Forms;\nusing Shadowsocks.Controller;\nusing Shadowsocks.Properties;\nusing Shadowsocks.Model;\nusing Shadowsocks.Util;\nnamespace Shadowsocks.View\n{\n    public partial class LogForm : Form\n    {\n        long lastOffset;
using System.Net;\nusing System.Net.Sockets;\nnamespace Shadowsocks.Controller\n{\n    class PortForwarder : Listener.Service\n    {\n        int _targetPort;\n        public PortForwarder(int targetPort)\n        {
namespace Shadowsocks.Controller\n{\n    class PortForwarder : Listener.Service\n    {\n        int _targetPort;\n        public PortForwarder(int targetPort)\n        {\n            this._targetPort = targetPort;\n        }\n        public bool Handle(byte[] firstPacket, int length, Socket socket, object state)
            public void UpdateInbound(long delta)\n            {\n                Interlocked.Add(ref _inbound, delta);
            }\n            public void UpdateOutbound(long delta)\n            {\n                Interlocked.Add(ref _outbound, delta);
            }\n            public void GetDelta(out long inboundDelta, out long outboundDelta)\n            {\n                var i = Interlocked.Read(ref _inbound);\n                var il = Interlocked.Exchange(ref _lastInbound, i);\n                inboundDelta = i - il;\n                var o = Interlocked.Read(ref _outbound);\n                var ol = Interlocked.Exchange(ref _lastOutbound, o);\n                outboundDelta = o - ol;
            }\n        }\n        //tasks\n        private readonly TimeSpan _delayBeforeStart = TimeSpan.FromSeconds(1);\n        private readonly TimeSpan _retryInterval = TimeSpan.FromMinutes(2);\n        private Timer _recorder; //analyze and save cached records to RawStatistics and filter records\n        private TimeSpan RecordingInterval => TimeSpan.FromMinutes(Config.DataCollectionMinutes);\n        private Timer _speedMonior;\n        private readonly TimeSpan _monitorInterval = TimeSpan.FromSeconds(1);\n        //private Timer _writer; //write RawStatistics to file
        void BeginConnectProxy(EndPoint remoteEP, AsyncCallback callback, object state);\n        void EndConnectProxy(IAsyncResult asyncResult);\n        void BeginConnectDest(EndPoint destEndPoint, AsyncCallback callback, object state);\n        void EndConnectDest(IAsyncResult asyncResult);\n        void BeginSend(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state);\n        int EndSend(IAsyncResult asyncResult);\n        void BeginReceive(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state);\n        int EndReceive(IAsyncResult asyncResult);
        void EndConnectDest(IAsyncResult asyncResult);\n        void BeginSend(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state);\n        int EndSend(IAsyncResult asyncResult);\n        void BeginReceive(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state);\n        int EndReceive(IAsyncResult asyncResult);\n        void Shutdown(SocketShutdown how);\n        void Close();\n    }
            byte[] request = null;\n            byte atyp = 0;\n            int port;\n            var dep = destEndPoint as DnsEndPoint;\n            if (dep != null)\n            {\n                // is a domain name, we will leave it to server\n                atyp = 3; // DOMAINNAME\n                var enc = Encoding.UTF8;\n                var hostByteCount = enc.GetByteCount(dep.Host);
                {\n                    case AddressFamily.InterNetwork:\n                        request = new byte[4 + 4 + 2];\n                        atyp = 1; // IP V4 address\n                        break;\n                    case AddressFamily.InterNetworkV6:\n                        request = new byte[4 + 16 + 2];\n                        atyp = 4; // IP V6 address\n                        break;\n                    default:
                Array.Copy(addr, 0, request, 4, request.Length - 4 - 2);
            }\n            // 构造request包剩余部分\n            request[0] = 5;\n            request[1] = 1;\n            request[2] = 0;\n            request[3] = atyp;\n            request[request.Length - 2] = (byte) ((port >> 8) & 0xff);\n            request[request.Length - 1] = (byte) (port & 0xff);\n            var st = new Socks5State();\n            st.Callback = callback;
        public void BeginConnectProxy(EndPoint remoteEP, AsyncCallback callback, object state)\n        {\n            // do nothing\n            var r = new FakeAsyncResult(state);\n            callback?.Invoke(r);\n        }\n        public void EndConnectProxy(IAsyncResult asyncResult)\n        {\n            // do nothing\n        }\n        public void BeginConnectDest(EndPoint destEndPoint, AsyncCallback callback, object state)\n        {
        {\n            EndPoint realEndPoint = DestEndPoint = destEndPoint;\n            /*\n             * On windows vista or later, dual-mode socket is supported, so that\n             * we don't need to resolve a DnsEndPoint manually.\n             * We could just create a dual-mode socket and pass the DnsEndPoint\n             * directly to it's BeginConnect and the system will handle it correctlly\n             * so that we won't worry about async resolving any more.\n             * \n             * see: https://blogs.msdn.microsoft.com/webdev/2013/01/08/dual-mode-sockets-never-create-an-ipv4-socket-again/
            {\n                // need to resolve manually\n                // TODO async resolving\n                IPHostEntry ipHostInfo = Dns.GetHostEntry(dep.Host);\n                IPAddress ipAddress = ipHostInfo.AddressList[0];\n                realEndPoint = new IPEndPoint(ipAddress, dep.Port);\n            }
            }\n            if (_remote == null)\n            {\n                _remote = new Socket(realEndPoint.AddressFamily, SocketType.Stream, ProtocolType.Tcp);\n                _remote.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n            }\n            _remote.BeginConnect(realEndPoint, callback, state);
            if (_remote == null)\n            {\n                _remote = new Socket(realEndPoint.AddressFamily, SocketType.Stream, ProtocolType.Tcp);\n                _remote.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n            }\n            _remote.BeginConnect(realEndPoint, callback, state);\n        }\n        public void EndConnectDest(IAsyncResult asyncResult)\n        {\n            _remote?.EndConnect(asyncResult);
                _remote.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n            }\n            _remote.BeginConnect(realEndPoint, callback, state);\n        }\n        public void EndConnectDest(IAsyncResult asyncResult)\n        {\n            _remote?.EndConnect(asyncResult);\n        }\n        public void BeginSend(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state)
        }\n        public void EndConnectDest(IAsyncResult asyncResult)\n        {\n            _remote?.EndConnect(asyncResult);\n        }\n        public void BeginSend(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state)\n        {\n            _remote?.BeginSend(buffer, offset, size, socketFlags, callback, state);\n        }
        {\n            this.controller = controller;\n            InitializeComponent();\n            Icon = Icon.FromHandle(Resources.ssw128.GetHicon());\n            var nLogConfig = NLogConfig.LoadXML();\n            this.filename = nLogConfig.GetLogFileName();\n            LogViewerConfig config = controller.GetConfigurationCopy().logViewer;\n            topMostTrigger = config.topMost;\n            wrapTextTrigger = config.wrapText;
            InitializeComponent();\n            Icon = Icon.FromHandle(Resources.ssw128.GetHicon());\n            var nLogConfig = NLogConfig.LoadXML();\n            this.filename = nLogConfig.GetLogFileName();\n            LogViewerConfig config = controller.GetConfigurationCopy().logViewer;\n            topMostTrigger = config.topMost;\n            wrapTextTrigger = config.wrapText;\n            toolbarTrigger = config.toolbarShown;\n            LogMessageTextBox.BackColor = config.BackgroundColor;\n            LogMessageTextBox.ForeColor = config.TextColor;
{\n    public class StreamSodiumEncryptor\n        : StreamEncryptor, IDisposable\n    {\n        const int CIPHER_SALSA20 = 1;\n        const int CIPHER_CHACHA20 = 2;\n        const int CIPHER_CHACHA20_IETF = 3;\n        const int SODIUM_BLOCK_SIZE = 64;\n        protected int _encryptBytesRemaining;\n        protected int _decryptBytesRemaining;
    {\n        const int CIPHER_SALSA20 = 1;\n        const int CIPHER_CHACHA20 = 2;\n        const int CIPHER_CHACHA20_IETF = 3;\n        const int SODIUM_BLOCK_SIZE = 64;\n        protected int _encryptBytesRemaining;\n        protected int _decryptBytesRemaining;\n        protected ulong _encryptIC;\n        protected ulong _decryptIC;\n        protected byte[] _encryptBuf;
        {\n            // TODO write a unidirection cipher so we don't have to if if if\n            int bytesRemaining;\n            ulong ic;\n            byte[] sodiumBuf;\n            byte[] iv;\n            int ret = -1;\n            if (isEncrypt)\n            {\n                bytesRemaining = _encryptBytesRemaining;
            {\n                bytesRemaining = _encryptBytesRemaining;\n                ic = _encryptIC;\n                sodiumBuf = _encryptBuf;\n                iv = _encryptIV;\n            }\n            else\n            {\n                bytesRemaining = _decryptBytesRemaining;\n                ic = _decryptIC;
                    break;\n                case CIPHER_CHACHA20:\n                    ret = Sodium.crypto_stream_chacha20_xor_ic(sodiumBuf, sodiumBuf, (ulong)(padding + length), iv, ic, _key);\n                    break;\n                case CIPHER_CHACHA20_IETF:\n                    ret = Sodium.crypto_stream_chacha20_ietf_xor_ic(sodiumBuf, sodiumBuf, (ulong)(padding + length), iv, (uint)ic, _key);\n                    break;\n            }\n            if (ret != 0) throw new CryptoErrorException();\n            Buffer.BlockCopy(sodiumBuf, padding, outbuf, 0, length);
                    break;\n                case CIPHER_CHACHA20_IETF:\n                    ret = Sodium.crypto_stream_chacha20_ietf_xor_ic(sodiumBuf, sodiumBuf, (ulong)(padding + length), iv, (uint)ic, _key);\n                    break;\n            }\n            if (ret != 0) throw new CryptoErrorException();\n            Buffer.BlockCopy(sodiumBuf, padding, outbuf, 0, length);\n            padding += length;\n            ic += (ulong)padding / SODIUM_BLOCK_SIZE;\n            bytesRemaining = padding % SODIUM_BLOCK_SIZE;
                    break;\n            }\n            if (ret != 0) throw new CryptoErrorException();\n            Buffer.BlockCopy(sodiumBuf, padding, outbuf, 0, length);\n            padding += length;\n            ic += (ulong)padding / SODIUM_BLOCK_SIZE;\n            bytesRemaining = padding % SODIUM_BLOCK_SIZE;\n            if (isEncrypt)\n            {\n                _encryptBytesRemaining = bytesRemaining;
            {\n                _encryptBytesRemaining = bytesRemaining;\n                _encryptIC = ic;\n            }\n            else\n            {\n                _decryptBytesRemaining = bytesRemaining;\n                _decryptIC = ic;\n            }\n        }
{\n    public class EncryptorInfo\n    {\n        public int KeySize;\n        public int IvSize;\n        public int SaltSize;\n        public int TagSize;\n        public int NonceSize;\n        public int Type;\n        public string InnerLibName;
    {\n        public int KeySize;\n        public int IvSize;\n        public int SaltSize;\n        public int TagSize;\n        public int NonceSize;\n        public int Type;\n        public string InnerLibName;\n        // For those who make use of internal crypto method name\n        // e.g. mbed TLS
        {\n            Method = method;\n            Password = password;\n        }\n        protected string Method;\n        protected string Password;
        }\n        protected string Method;\n        protected string Password;
        public abstract void Encrypt(byte[] buf, int length, byte[] outbuf, out int outlength);\n        public abstract void Decrypt(byte[] buf, int length, byte[] outbuf, out int outlength);\n        public abstract void EncryptUDP(byte[] buf, int length, byte[] outbuf, out int outlength);\n        public abstract void DecryptUDP(byte[] buf, int length, byte[] outbuf, out int outlength);\n        public abstract void Dispose();\n        public int AddrBufLength { get; set; } = - 1;\n    }\n}
    {\n        private const string DLLNAME = "libsscrypto.dll";\n        private static bool _initialized = false;\n        private static readonly object _initLock = new object();\n        static Sodium()\n        {\n            string dllPath = Utils.GetTempPath(DLLNAME);\n            try\n            {
        static Sodium()\n        {\n            string dllPath = Utils.GetTempPath(DLLNAME);\n            try\n            {\n                FileManager.UncompressFile(dllPath, Resources.libsscrypto_dll);\n            }\n            catch (IOException)\n            {\n            }
            try\n            {\n                FileManager.UncompressFile(dllPath, Resources.libsscrypto_dll);\n            }\n            catch (IOException)\n            {\n            }\n            catch (System.Exception e)\n            {\n                Logging.LogUsefulException(e);
            {\n                Logging.LogUsefulException(e);\n            }\n            LoadLibrary(dllPath);\n            lock (_initLock)\n            {\n                if (!_initialized)\n                {\n                    if (sodium_init() == -1)\n                    {
        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public static extern int sodium_increment(byte[] n, int nlen);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public static extern int crypto_aead_chacha20poly1305_ietf_encrypt(byte[] c, ref ulong clen_p, byte[] m,\n            ulong mlen, byte[] ad, ulong adlen, byte[] nsec, byte[] npub, byte[] k);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public static extern int crypto_aead_chacha20poly1305_ietf_decrypt(byte[] m, ref ulong mlen_p,\n            byte[] nsec, byte[] c, ulong clen, byte[] ad, ulong adlen, byte[] npub, byte[] k);\n        #endregion
        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public static extern int crypto_aead_chacha20poly1305_ietf_encrypt(byte[] c, ref ulong clen_p, byte[] m,\n            ulong mlen, byte[] ad, ulong adlen, byte[] nsec, byte[] npub, byte[] k);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public static extern int crypto_aead_chacha20poly1305_ietf_decrypt(byte[] m, ref ulong mlen_p,\n            byte[] nsec, byte[] c, ulong clen, byte[] ad, ulong adlen, byte[] npub, byte[] k);\n        #endregion\n        #region Stream\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public static extern int crypto_aead_chacha20poly1305_ietf_decrypt(byte[] m, ref ulong mlen_p,\n            byte[] nsec, byte[] c, ulong clen, byte[] ad, ulong adlen, byte[] npub, byte[] k);\n        #endregion\n        #region Stream\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public static extern int crypto_stream_salsa20_xor_ic(byte[] c, byte[] m, ulong mlen, byte[] n, ulong ic,\n            byte[] k);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public static extern int crypto_stream_chacha20_xor_ic(byte[] c, byte[] m, ulong mlen, byte[] n, ulong ic,
    }\n}
        }\n        public static void GetBytes(byte[] buf, int len)\n        {\n            if (_rng == null) Reload();\n            try\n            {\n                _rng.GetBytes(buf, 0, len);\n            }\n            catch (System.Exception)\n            {
            {\n                // the backup way\n                byte[] tmp = new byte[len];\n                _rng.GetBytes(tmp);\n                Buffer.BlockCopy(tmp, 0, buf, 0, len);\n            }\n        }\n    }\n}
        public long outbound = 0;\n        public long inbound = 0;\n        public UDPRelay(ShadowsocksController controller)\n        {\n            this._controller = controller;\n        }\n        public override bool Handle(byte[] firstPacket, int length, Socket socket, object state)\n        {\n            if (socket.ProtocolType != ProtocolType.Udp)
        }\n        public override bool Handle(byte[] firstPacket, int length, Socket socket, object state)\n        {\n            if (socket.ProtocolType != ProtocolType.Udp)\n            {\n                return false;\n            }\n            if (length < 4)\n            {\n                return false;
                Array.Copy(data, 3, dataIn, 0, length - 3);\n                byte[] dataOut = new byte[length - 3 + 16];\n                int outlen;\n                encryptor.EncryptUDP(dataIn, length - 3, dataOut, out outlen);\n                Logging.Debug(_localEndPoint, _remoteEndPoint, outlen, "UDP Relay");\n                _remote?.SendTo(dataOut, outlen, SocketFlags.None, _remoteEndPoint);\n            }\n            public void Receive()\n            {\n                EndPoint remoteEndPoint = new IPEndPoint(IPAddress.Any, 0);
                int outlen;\n                encryptor.EncryptUDP(dataIn, length - 3, dataOut, out outlen);\n                Logging.Debug(_localEndPoint, _remoteEndPoint, outlen, "UDP Relay");\n                _remote?.SendTo(dataOut, outlen, SocketFlags.None, _remoteEndPoint);\n            }\n            public void Receive()\n            {\n                EndPoint remoteEndPoint = new IPEndPoint(IPAddress.Any, 0);\n                Logging.Debug($"++++++Receive Server Port, size:" + _buffer.Length);\n                _remote?.BeginReceiveFrom(_buffer, 0, _buffer.Length, 0, ref remoteEndPoint, new AsyncCallback(RecvFromCallback), null);
                Logging.Debug(_localEndPoint, _remoteEndPoint, outlen, "UDP Relay");\n                _remote?.SendTo(dataOut, outlen, SocketFlags.None, _remoteEndPoint);\n            }\n            public void Receive()\n            {\n                EndPoint remoteEndPoint = new IPEndPoint(IPAddress.Any, 0);\n                Logging.Debug($"++++++Receive Server Port, size:" + _buffer.Length);\n                _remote?.BeginReceiveFrom(_buffer, 0, _buffer.Length, 0, ref remoteEndPoint, new AsyncCallback(RecvFromCallback), null);\n            }\n            public void RecvFromCallback(IAsyncResult ar)
        public DateTime lastActivity;\n        private bool _proxyConnected;\n        private bool _destConnected;
        // instance-based lock without static
            this._server = server;\n            /* prepare address buffer length for AEAD */\n            Logging.Debug($"_addrBufLength={_addrBufLength}");\n            _encryptor.AddrBufLength = _addrBufLength;\n        }\n        public void Start(byte[] firstPacket, int length)\n        {\n            _firstPacket = firstPacket;\n            _firstPacketLength = length;\n            HandshakeReceive();\n        }
        {\n            if (_closed) return;\n            try\n            {\n                int bytesRead = _connection.EndReceive(ar);\n                if (bytesRead >= 5)\n                {\n                    _command = _connetionRecvBuffer[1];\n                    if (_command != CMD_CONNECT && _command != CMD_UDP_ASSOC)\n                    {
                    {\n                        Logging.Debug("Unsupported CMD=" + _command);\n                        Close();\n                    }\n                    else\n                    {\n                        if (_command == CMD_CONNECT)\n                        {\n                            byte[] response = { 5, 0, 0, 1, 0, 0, 0, 0, 0, 0 };\n                            _connection.BeginSend(response, 0, response.Length, SocketFlags.None,
                        {\n                            byte[] response = { 5, 0, 0, 1, 0, 0, 0, 0, 0, 0 };\n                            _connection.BeginSend(response, 0, response.Length, SocketFlags.None,\n                                ResponseCallback, null);\n                        }\n                        else if (_command == CMD_UDP_ASSOC)\n                        {\n                            ReadAddress(HandleUDPAssociate);\n                        }\n                    }
                        }\n                        else if (_command == CMD_UDP_ASSOC)\n                        {\n                            ReadAddress(HandleUDPAssociate);\n                        }\n                    }\n                }\n                else\n                {\n                    Logging.Debug(
                        {\n                            ReadAddress(HandleUDPAssociate);\n                        }\n                    }\n                }\n                else\n                {\n                    Logging.Debug(\n                        "failed to recv data in Shadowsocks.Controller.TCPHandler.handshakeReceive2Callback()");
                    break;\n                case ATYP_DOMAIN: // domain name, length + str\n                    int len = _connetionRecvBuffer[4];\n                    ReadAddress(len + ADDR_PORT_LEN, onSuccess);\n                    break;\n                case ATYP_IPv6: // IPv6 address, 16 bytes\n                    ReadAddress(16 + ADDR_PORT_LEN - 1, onSuccess);\n                    break;\n                default:\n                    Logging.Debug("Unsupported ATYP=" + atyp);
                    int len = _connetionRecvBuffer[4];\n                    ReadAddress(len + ADDR_PORT_LEN, onSuccess);\n                    break;\n                case ATYP_IPv6: // IPv6 address, 16 bytes\n                    ReadAddress(16 + ADDR_PORT_LEN - 1, onSuccess);\n                    break;\n                default:\n                    Logging.Debug("Unsupported ATYP=" + atyp);\n                    Close();\n                    break;
                    break;\n                case ATYP_IPv6: // IPv6 address, 16 bytes\n                    ReadAddress(16 + ADDR_PORT_LEN - 1, onSuccess);\n                    break;\n                default:\n                    Logging.Debug("Unsupported ATYP=" + atyp);\n                    Close();\n                    break;\n            }\n        }
                    break;\n                default:\n                    Logging.Debug("Unsupported ATYP=" + atyp);\n                    Close();\n                    break;\n            }\n        }\n        private void ReadAddress(int bytesRemain, Action onSuccess)\n        {\n            // drop [ VER | CMD |  RSV  ]
            // Read the remain address bytes\n            _connection.BeginReceive(_connetionRecvBuffer, 2, RecvSize - 2, SocketFlags.None, OnAddressFullyRead,\n                new object[] { bytesRemain, onSuccess });\n        }\n        private void OnAddressFullyRead(IAsyncResult ar)\n        {\n            if (_closed) return;\n            try\n            {\n                int bytesRead = _connection.EndReceive(ar);
                            break;\n                        case ATYP_DOMAIN: // domain name, length + str\n                            int len = _connetionRecvBuffer[1];\n                            dstAddr = System.Text.Encoding.UTF8.GetString(_connetionRecvBuffer, 2, len);\n                            dstPort = (_connetionRecvBuffer[len + 2] << 8) + _connetionRecvBuffer[len + 3];\n                            _addrBufLength = ADDR_ATYP_LEN + 1 + len + ADDR_PORT_LEN;\n                            break;\n                        case ATYP_IPv6: // IPv6 address, 16 bytes\n                            dstAddr = $"[{new IPAddress(_connetionRecvBuffer.Skip(1).Take(16).ToArray())}]";\n                            dstPort = (_connetionRecvBuffer[17] << 8) + _connetionRecvBuffer[18];
                            int len = _connetionRecvBuffer[1];\n                            dstAddr = System.Text.Encoding.UTF8.GetString(_connetionRecvBuffer, 2, len);\n                            dstPort = (_connetionRecvBuffer[len + 2] << 8) + _connetionRecvBuffer[len + 3];\n                            _addrBufLength = ADDR_ATYP_LEN + 1 + len + ADDR_PORT_LEN;\n                            break;\n                        case ATYP_IPv6: // IPv6 address, 16 bytes\n                            dstAddr = $"[{new IPAddress(_connetionRecvBuffer.Skip(1).Take(16).ToArray())}]";\n                            dstPort = (_connetionRecvBuffer[17] << 8) + _connetionRecvBuffer[18];\n                            _addrBufLength = ADDR_ATYP_LEN + 16 + ADDR_PORT_LEN;\n                            break;
                            break;\n                        case ATYP_IPv6: // IPv6 address, 16 bytes\n                            dstAddr = $"[{new IPAddress(_connetionRecvBuffer.Skip(1).Take(16).ToArray())}]";\n                            dstPort = (_connetionRecvBuffer[17] << 8) + _connetionRecvBuffer[18];\n                            _addrBufLength = ADDR_ATYP_LEN + 16 + ADDR_PORT_LEN;\n                            break;\n                    }\n                    if (_config.isVerboseLogging)\n                    {
                            break;\n                    }\n                    if (_config.isVerboseLogging)\n                    {
            response[0] = 5;\n            switch (endPoint.AddressFamily)\n            {\n                case AddressFamily.InterNetwork:\n                    response[3] = ATYP_IPv4;\n                    break;\n                case AddressFamily.InterNetworkV6:\n                    response[3] = ATYP_IPv6;\n                    break;\n            }
                    break;\n                case AddressFamily.InterNetworkV6:\n                    response[3] = ATYP_IPv6;\n                    break;\n            }\n            address.CopyTo(response, 4);\n            response[response.Length - 1] = (byte)(port & 0xFF);\n            response[response.Length - 2] = (byte)((port >> 8) & 0xFF);\n            _connection.BeginSend(response, 0, response.Length, SocketFlags.None, ReadAll, true);\n        }
                    break;\n            }\n            address.CopyTo(response, 4);\n            response[response.Length - 1] = (byte)(port & 0xFF);\n            response[response.Length - 2] = (byte)((port >> 8) & 0xFF);\n            _connection.BeginSend(response, 0, response.Length, SocketFlags.None, ReadAll, true);\n        }\n        private void ReadAll(IAsyncResult ar)\n        {\n            if (_closed) return;
        }\n        private void ReadAll(IAsyncResult ar)\n        {\n            if (_closed) return;\n            try\n            {\n                if (ar.AsyncState != null)\n                {\n                    _connection.EndSend(ar);\n                    _connection.BeginReceive(_connetionRecvBuffer, 0, RecvSize, SocketFlags.None,
                }\n                else\n                {\n                    int bytesRead = _connection.EndReceive(ar);\n                    if (bytesRead > 0)\n                    {\n                        _connection.BeginReceive(_connetionRecvBuffer, 0, RecvSize, SocketFlags.None,\n                            ReadAll, null);\n                    }
                    }\n                    else\n                        Close();\n                }\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }
                if (_config.proxy.useProxy)\n                {\n                    switch (_config.proxy.proxyType)\n                    {\n                        case ProxyConfig.PROXY_SOCKS5:\n                            remote = new Socks5Proxy();\n                            break;\n                        case ProxyConfig.PROXY_HTTP:\n                            remote = new HttpProxy();\n                            break;
                proxyTimer.Enabled = true;\n                proxyTimer.Session = session;\n                proxyTimer.DestEndPoint = SocketUtil.GetEndPoint(_server.server, _server.server_port);\n                proxyTimer.Server = _server;\n                _proxyConnected = false;\n                // Connect to the proxy server.\n                remote.BeginConnectProxy(proxyEP, ProxyConnectCallback,\n                    new AsyncSession<ProxyTimer>(remote, proxyTimer));\n            }\n            catch (Exception e)\n            {
            timer.Enabled = false;\n            timer.Dispose();\n            if (_proxyConnected || _destConnected || _closed)\n            {\n                return;\n            }\n            var proxy = timer.Session.Remote;\n            Logging.Info($"Proxy {proxy.ProxyEndPoint} timed out");\n            proxy.Close();\n            Close();
            if (_closed)\n            {\n                return;\n            }\n            try\n            {\n                var server = timer.Server;
                timer.Enabled = false;\n                timer.Dispose();\n                var remote = session.Remote;\n                // Complete the connection.\n                remote.EndConnectProxy(ar);\n                _proxyConnected = true;\n                if (_config.isVerboseLogging)\n                {\n                    if (!(remote is DirectConnect))\n                    {
                connectTimer.Enabled = true;\n                connectTimer.Session = session;\n                connectTimer.Server = server;\n                _destConnected = false;\n                // Connect to the remote endpoint.\n                remote.BeginConnectDest(destEndPoint, ConnectCallback,\n                    new AsyncSession<ServerTimer>(session, connectTimer));\n            }\n            catch (ArgumentException)\n            {
            }\n            catch (ArgumentException)\n            {\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }
                    lock (_decryptionLock)\n                    {\n                        try\n                        {\n                            _encryptor.Decrypt(_remoteRecvBuffer, bytesRead, _remoteSendBuffer, out bytesToSend);\n                        }\n                        catch (CryptoErrorException)\n                        {\n                            Logging.Error("decryption error");\n                            Close();
                    IStrategy strategy = _controller.GetCurrentStrategy();\n                    strategy?.UpdateLastRead(_server);\n                }\n                else\n                {\n                    _connection.Shutdown(SocketShutdown.Send);\n                    _connectionShutdown = true;\n                    CheckClose();\n                }\n            }
            }\n            _tcprelay.UpdateOutboundCounter(_server, bytesToSend);\n            _startSendingTime = DateTime.Now;\n            session.Remote.BeginSend(_connetionSendBuffer, 0, bytesToSend, SocketFlags.None,\n                PipeRemoteSendCallback, new object[] { session, bytesToSend });\n            IStrategy strategy = _controller.GetCurrentStrategy();\n            strategy?.UpdateLastWrite(_server);\n        }\n        private void PipeRemoteSendCallback(IAsyncResult ar)
            IStrategy strategy = _controller.GetCurrentStrategy();\n            strategy?.UpdateLastWrite(_server);\n        }\n        private void PipeRemoteSendCallback(IAsyncResult ar)\n        {\n            if (_closed) return;\n            try\n            {\n                var container = (object[])ar.AsyncState;\n                var session = (AsyncSession)container[0];
        private void PipeConnectionSendCallback(IAsyncResult ar)\n        {\n            try\n            {\n                var container = (object[])ar.AsyncState;\n                var session = (AsyncSession)container[0];\n                var bytesShouldSend = (int)container[1];\n                var bytesSent = _connection.EndSend(ar);\n                var bytesRemaining = bytesShouldSend - bytesSent;\n                if (bytesRemaining > 0)
            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }\n    }\n}
{\n    public class StreamMbedTLSEncryptor\n        : StreamEncryptor, IDisposable\n    {\n        const int CIPHER_RC4 = 1;\n        const int CIPHER_AES = 2;\n        const int CIPHER_BLOWFISH = 3;\n        const int CIPHER_CAMELLIA = 4;\n        private IntPtr _encryptCtx = IntPtr.Zero;\n        private IntPtr _decryptCtx = IntPtr.Zero;
    {\n        const int CIPHER_RC4 = 1;\n        const int CIPHER_AES = 2;\n        const int CIPHER_BLOWFISH = 3;\n        const int CIPHER_CAMELLIA = 4;\n        private IntPtr _encryptCtx = IntPtr.Zero;\n        private IntPtr _decryptCtx = IntPtr.Zero;\n        public StreamMbedTLSEncryptor(string method, string password)\n            : base(method, password)\n        {
        {\n        }\n        private static Dictionary<string, EncryptorInfo> _ciphers = new Dictionary<string, EncryptorInfo> {\n            { "aes-128-cfb", new EncryptorInfo("AES-128-CFB128", 16, 16, CIPHER_AES) },\n            { "aes-192-cfb", new EncryptorInfo("AES-192-CFB128", 24, 16, CIPHER_AES) },\n            { "aes-256-cfb", new EncryptorInfo("AES-256-CFB128", 32, 16, CIPHER_AES) },\n            { "aes-128-ctr", new EncryptorInfo("AES-128-CTR", 16, 16, CIPHER_AES) },\n            { "aes-192-ctr", new EncryptorInfo("AES-192-CTR", 24, 16, CIPHER_AES) },\n            { "aes-256-ctr", new EncryptorInfo("AES-256-CTR", 32, 16, CIPHER_AES) },\n            { "bf-cfb", new EncryptorInfo("BLOWFISH-CFB64", 16, 8, CIPHER_BLOWFISH) },
            IntPtr ctx = Marshal.AllocHGlobal(MbedTLS.cipher_get_size_ex());\n            if (isEncrypt)\n            {\n                _encryptCtx = ctx;\n            }\n            else\n            {\n                _decryptCtx = ctx;\n            }\n            byte[] realkey;
            if (MbedTLS.cipher_set_iv(ctx, iv, ivLen) != 0)\n                throw new System.Exception("Cannot set mbed TLS cipher IV");\n            if (MbedTLS.cipher_reset(ctx) != 0)\n                throw new System.Exception("Cannot finalize mbed TLS cipher context");\n        }\n        protected override void cipherUpdate(bool isEncrypt, int length, byte[] buf, byte[] outbuf)\n        {\n            // C# could be multi-threaded\n            if (_disposed)\n            {
            if (MbedTLS.cipher_reset(ctx) != 0)\n                throw new System.Exception("Cannot finalize mbed TLS cipher context");\n        }\n        protected override void cipherUpdate(bool isEncrypt, int length, byte[] buf, byte[] outbuf)\n        {\n            // C# could be multi-threaded\n            if (_disposed)\n            {\n                throw new ObjectDisposedException(this.ToString());\n            }\n            if (MbedTLS.cipher_update(isEncrypt ? _encryptCtx : _decryptCtx,
        }\n        protected override void cipherUpdate(bool isEncrypt, int length, byte[] buf, byte[] outbuf)\n        {\n            // C# could be multi-threaded\n            if (_disposed)\n            {\n                throw new ObjectDisposedException(this.ToString());\n            }\n            if (MbedTLS.cipher_update(isEncrypt ? _encryptCtx : _decryptCtx,\n                buf, length, outbuf, ref length) != 0 )\n                throw new CryptoErrorException();
        {\n            // C# could be multi-threaded\n            if (_disposed)\n            {\n                throw new ObjectDisposedException(this.ToString());\n            }\n            if (MbedTLS.cipher_update(isEncrypt ? _encryptCtx : _decryptCtx,\n                buf, length, outbuf, ref length) != 0 )\n                throw new CryptoErrorException();\n        }\n        #region IDisposable
                buf, length, outbuf, ref length) != 0 )\n                throw new CryptoErrorException();\n        }\n        #region IDisposable\n        private bool _disposed;\n        // instance based lock\n        private readonly object _lock = new object();\n        public override void Dispose()\n        {\n            Dispose(true);
        }\n        #region IDisposable\n        private bool _disposed;\n        // instance based lock\n        private readonly object _lock = new object();\n        public override void Dispose()\n        {\n            Dispose(true);\n            GC.SuppressFinalize(this);\n        }\n        ~StreamMbedTLSEncryptor()\n        {
        {\n            Dispose(false);\n        }\n        protected virtual void Dispose(bool disposing)\n        {\n            lock (_lock)\n            {\n                if (_disposed) return;\n                _disposed = true;\n            }
        static EncryptorFactory()\n        {\n            foreach (string method in StreamMbedTLSEncryptor.SupportedCiphers())\n            {\n                _registeredEncryptors.Add(method, typeof(StreamMbedTLSEncryptor));\n            }\n            foreach (string method in StreamSodiumEncryptor.SupportedCiphers())\n            {
            {\n                _registeredEncryptors.Add(method, typeof(StreamMbedTLSEncryptor));\n            }\n            foreach (string method in StreamSodiumEncryptor.SupportedCiphers())\n            {\n                _registeredEncryptors.Add(method, typeof(StreamSodiumEncryptor));\n            }\n            foreach (string method in AEADMbedTLSEncryptor.SupportedCiphers())\n            {\n                _registeredEncryptors.Add(method, typeof(AEADMbedTLSEncryptor));
            }\n            foreach (string method in StreamSodiumEncryptor.SupportedCiphers())\n            {\n                _registeredEncryptors.Add(method, typeof(StreamSodiumEncryptor));\n            }\n            foreach (string method in AEADMbedTLSEncryptor.SupportedCiphers())\n            {\n                _registeredEncryptors.Add(method, typeof(AEADMbedTLSEncryptor));\n            }\n            foreach (string method in AEADSodiumEncryptor.SupportedCiphers())
            {\n                _registeredEncryptors.Add(method, typeof(StreamSodiumEncryptor));\n            }\n            foreach (string method in AEADMbedTLSEncryptor.SupportedCiphers())\n            {\n                _registeredEncryptors.Add(method, typeof(AEADMbedTLSEncryptor));\n            }\n            foreach (string method in AEADSodiumEncryptor.SupportedCiphers())\n            {\n                _registeredEncryptors.Add(method, typeof(AEADSodiumEncryptor));
            }\n        }\n        public static IEncryptor GetEncryptor(string method, string password)\n        {\n            if (method.IsNullOrEmpty())\n            {\n                method = "aes-256-cfb";\n            }\n            method = method.ToLowerInvariant();\n            Type t = _registeredEncryptors[method];
        {\n            if (method.IsNullOrEmpty())\n            {\n                method = "aes-256-cfb";\n            }\n            method = method.ToLowerInvariant();\n            Type t = _registeredEncryptors[method];\n            ConstructorInfo c = t.GetConstructor(ConstructorTypes);\n            if (c == null) throw new System.Exception("Invalid ctor");\n            IEncryptor result = (IEncryptor) c.Invoke(new object[] {method, password});
            return result;\n        }\n    }\n}
    {\n        private const string DLLNAME = "libsscrypto.dll";\n        public const int MBEDTLS_ENCRYPT = 1;\n        public const int MBEDTLS_DECRYPT = 0;\n        static MbedTLS()\n        {\n            string dllPath = Utils.GetTempPath(DLLNAME);\n            try\n            {\n                FileManager.UncompressFile(dllPath, Resources.libsscrypto_dll);
        public const int MBEDTLS_ENCRYPT = 1;\n        public const int MBEDTLS_DECRYPT = 0;\n        static MbedTLS()\n        {\n            string dllPath = Utils.GetTempPath(DLLNAME);\n            try\n            {\n                FileManager.UncompressFile(dllPath, Resources.libsscrypto_dll);\n            }\n            catch (IOException)
            try\n            {\n                FileManager.UncompressFile(dllPath, Resources.libsscrypto_dll);\n            }\n            catch (IOException)\n            {\n            }\n            catch (System.Exception e)\n            {\n                Logging.LogUsefulException(e);
            {\n                Logging.LogUsefulException(e);\n            }\n            LoadLibrary(dllPath);\n        }\n        public static byte[] MD5(byte[] input)\n        {\n            byte[] output = new byte[16];
        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public static extern int cipher_auth_decrypt(IntPtr ctx,\n            byte[] iv, uint iv_len,\n            IntPtr ad, uint ad_len,\n            byte[] input, uint ilen,\n            byte[] output, ref uint olen,\n            byte[] tag, uint tag_len);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public static extern int hkdf(byte[] salt,\n            int salt_len, byte[] ikm, int ikm_len,
    }\n}
        }\n        /**\n         * once failed, try after 5 min\n         * and (last write - last read) < 5s\n         * and (now - last read) <  5s  // means not stuck\n         * and latency < 200ms, try after 30s\n         */\n        public void ChooseNewServer()\n        {\n            ServerStatus oldServer = _currentServer;

                {\n                    _currentServer = max;\n                    Console.WriteLine("HA switching to server: {0}", _currentServer.server.FriendlyName());\n                }\n            }\n        }\n        public void UpdateLatency(Model.Server server, TimeSpan latency)\n        {
                }\n            }\n        }\n        public void UpdateLatency(Model.Server server, TimeSpan latency)\n        {\n            Logging.Debug(String.Format("latency: {0} {1}", server.FriendlyName(), latency));\n            ServerStatus status;\n            if (_serverStatus.TryGetValue(server, out status))\n            {
            }\n        }\n        public void UpdateLatency(Model.Server server, TimeSpan latency)\n        {\n            Logging.Debug(String.Format("latency: {0} {1}", server.FriendlyName(), latency));\n            ServerStatus status;\n            if (_serverStatus.TryGetValue(server, out status))\n            {\n                status.latency = latency;\n                status.lastTimeDetectLatency = DateTime.Now;
            this.PasswordTextBox.Size = new System.Drawing.Size(160, 21);\n            this.PasswordTextBox.TabIndex = 2;\n            this.PasswordTextBox.WordWrap = false;\n    this.PasswordTextBox.UseSystemPasswordChar = true;
                        //new KeyValuePair<string, string>("data", reply.Buffer.ToString()); // The data of reply\n                    });\n                    Thread.Sleep(Timeout + new Random().Next() % Timeout);\n                    //Do ICMPTest in a random frequency\n                }\n                catch (Exception e)\n                {\n                    Logging.Error($"An exception occured while eveluating {server.FriendlyName()}");\n                    Logging.LogUsefulException(e);\n                }
            foreach (var dataLists in await TaskEx.WhenAll(_servers.Select(ICMPTest)))\n            {\n                if (dataLists == null) continue;\n                foreach (var dataList in dataLists.Where(dataList => dataList != null))\n                {\n                    Append(dataList, Enumerable.Empty<DataUnit>());\n                }\n            }\n        }\n        private static void Append(DataList dataList, IEnumerable<DataUnit> extra)
                }\n            }\n        }\n        private static void Append(DataList dataList, IEnumerable<DataUnit> extra)\n        {\n            var data = dataList.Concat(extra);\n            var dataLine = string.Join(Delimiter, data.Select(kv => kv.Value).ToArray());\n            string[] lines;\n            if (!File.Exists(AvailabilityStatisticsFile))\n            {
            public const string Unknown = "Unknown";\n        }\n        //TODO: redesign model\n        public class RawStatisticsData\n        {\n            public DateTime Timestamp;\n            public string ServerName;\n            public string ICMPStatus;\n            public int RoundtripTime;
        }\n        public class StatisticsData\n        {\n            public float PackageLoss;\n            public int AverageResponse;\n            public int MinResponse;\n            public int MaxResponse;\n        }\n        public void UpdateLatency(int latency)\n        {
                    Array.Copy(iv, _encryptIV, ivLen);\n                }\n                else\n                {\n                    _decryptIV = new byte[ivLen];\n                    Array.Copy(iv, _decryptIV, ivLen);\n                }\n            }\n            else if (_cipher == CIPHER_BF)
                    Array.Copy(iv, _decryptIV, ivLen);\n                }\n            }\n            else if (_cipher == CIPHER_BF)\n            {\n                PolarSSL.blowfish_init(ctx);\n                // PolarSSL takes key length by bit\n                PolarSSL.blowfish_setkey(ctx, realkey, keyLen * 8);\n                if (isCipher)\n                {
                    Array.Copy(iv, _encryptIV, ivLen);\n                }\n                else\n                {\n                    _decryptIV = new byte[ivLen];\n                    Array.Copy(iv, _decryptIV, ivLen);\n                }\n            }\n            else if (_cipher == CIPHER_RC4)
                    Array.Copy(iv, _decryptIV, ivLen);\n                }\n            }\n            else if (_cipher == CIPHER_RC4)\n            {\n                PolarSSL.arc4_init(ctx);\n                // PolarSSL RC4 takes key length by byte\n                PolarSSL.arc4_setup(ctx, realkey, keyLen);\n            }\n        }
                            break;\n                        case CIPHER_BF:\n                            PolarSSL.blowfish_crypt_cfb64(_encryptCtx, PolarSSL.BLOWFISH_ENCRYPT, length, ref _encryptIVOffset, _encryptIV, buf, tempbuf);\n                            break;\n                        case CIPHER_RC4:\n                            PolarSSL.arc4_crypt(_encryptCtx, length, buf, tempbuf);\n                            break;\n                    }\n                    outlength = length + ivLen;\n                    Buffer.BlockCopy(tempbuf, 0, outbuf, ivLen, length);
                            break;\n                        case CIPHER_RC4:\n                            PolarSSL.arc4_crypt(_encryptCtx, length, buf, tempbuf);\n                            break;\n                    }\n                    outlength = length + ivLen;\n                    Buffer.BlockCopy(tempbuf, 0, outbuf, ivLen, length);\n                }\n            }\n            else
                        break;\n                    case CIPHER_BF:\n                        PolarSSL.blowfish_crypt_cfb64(_encryptCtx, PolarSSL.BLOWFISH_ENCRYPT, length, ref _encryptIVOffset, _encryptIV, buf, outbuf);\n                        break;\n                    case CIPHER_RC4:\n                        PolarSSL.arc4_crypt(_encryptCtx, length, buf, outbuf);\n                        break;\n                }\n            }\n        }
                        break;\n                    case CIPHER_RC4:\n                        PolarSSL.arc4_crypt(_encryptCtx, length, buf, outbuf);\n                        break;\n                }\n            }\n        }\n        public override void Decrypt(byte[] buf, int length, byte[] outbuf, out int outlength)\n        {\n            if (_decryptCtx == IntPtr.Zero)
                            break;\n                        case CIPHER_BF:\n                            PolarSSL.blowfish_crypt_cfb64(_decryptCtx, PolarSSL.BLOWFISH_DECRYPT, length - ivLen, ref _decryptIVOffset, _decryptIV, tempbuf, outbuf);\n                            break;\n                        case CIPHER_RC4:\n                            PolarSSL.arc4_crypt(_decryptCtx, length - ivLen, tempbuf, outbuf);\n                            break;\n                    }\n                }\n            }
                            break;\n                        case CIPHER_RC4:\n                            PolarSSL.arc4_crypt(_decryptCtx, length - ivLen, tempbuf, outbuf);\n                            break;\n                    }\n                }\n            }\n            else\n            {\n                outlength = length;
                        break;\n                    case CIPHER_BF:\n                        PolarSSL.blowfish_crypt_cfb64(_decryptCtx, PolarSSL.BLOWFISH_DECRYPT, length, ref _decryptIVOffset, _decryptIV, buf, outbuf);\n                        break;\n                    case CIPHER_RC4:\n                        PolarSSL.arc4_crypt(_decryptCtx, length, buf, outbuf);\n                        break;\n                }\n            }\n        }
                        break;\n                    case CIPHER_RC4:\n                        PolarSSL.arc4_crypt(_decryptCtx, length, buf, outbuf);\n                        break;\n                }\n            }\n        }\n        #region IDisposable\n        private bool _disposed;\n        public override void Dispose()
            this.MyCancelButton.Name = "MyCancelButton";\n            this.MyCancelButton.Size = new System.Drawing.Size(75, 23);\n            this.MyCancelButton.TabIndex = 18;\n            this.MyCancelButton.Text = "Cancel";\n            this.MyCancelButton.UseVisualStyleBackColor = true;\n            this.MyCancelButton.Click += new System.EventHandler(this.CancelButton_Click);\n            // \n            // ApplyButton\n            // \n            this.ApplyButton.Enabled = false;
using System.Drawing;\nusing System.Windows.Forms;\nusing Shadowsocks.Controller;\nusing Shadowsocks.Model;\nusing Shadowsocks.Properties;\nnamespace Shadowsocks.View
using System.Windows.Forms;\nusing Shadowsocks.Controller;\nusing Shadowsocks.Model;\nusing Shadowsocks.Properties;\nnamespace Shadowsocks.View\n{\n    public partial class ConfigForm : Form
using Shadowsocks.Controller;\nusing Shadowsocks.Model;\nusing Shadowsocks.Properties;\nnamespace Shadowsocks.View\n{\n    public partial class ConfigForm : Form\n    {\n        private ShadowsocksController controller;\n        // this is a copy of configuration that we are working on
namespace Shadowsocks.View\n{\n    public partial class ConfigForm : Form\n    {\n        private ShadowsocksController controller;\n        // this is a copy of configuration that we are working on\n        private Configuration _modifiedConfiguration;\n        private int _lastSelectedIndex = -1;\n        public ConfigForm(ShadowsocksController controller)\n        {
                byte[] dataIn = new byte[length - 3 + IVEncryptor.ONETIMEAUTH_BYTES];\n                Array.Copy(data, 3, dataIn, 0, length - 3);\n                byte[] dataOut = new byte[length - 3 + 16 + IVEncryptor.ONETIMEAUTH_BYTES];\n                int outlen;\n                encryptor.Encrypt(dataIn, length - 3, dataOut, out outlen);\n                _remote.SendTo(dataOut, outlen, SocketFlags.None, _remoteEndPoint);\n            }\n            public void Receive()\n            {\n                EndPoint remoteEndPoint = new IPEndPoint(IPAddress.Any, 0);
                _remote.SendTo(dataOut, outlen, SocketFlags.None, _remoteEndPoint);\n            }\n            public void Receive()\n            {\n                EndPoint remoteEndPoint = new IPEndPoint(IPAddress.Any, 0);\n                _remote.BeginReceiveFrom(_buffer, 0, _buffer.Length, 0, ref remoteEndPoint, new AsyncCallback(RecvFromCallback), null);\n            }\n            public void RecvFromCallback(IAsyncResult ar)\n            {\n                try
        {\n            if (!_encryptIVSent)\n            {\n                int headLen = getHeadLen(buf, length);\n                int dataLen = length - headLen;\n                buf[0] |= ONETIMEAUTH_FLAG;\n                byte[] hash = genOnetimeAuthHash(buf, headLen);\n                Buffer.BlockCopy(buf, headLen, buf, headLen + ONETIMEAUTH_BYTES + AUTH_BYTES, dataLen);\n                Buffer.BlockCopy(hash, 0, buf, headLen, ONETIMEAUTH_BYTES);\n                hash = genHash(buf, headLen + ONETIMEAUTH_BYTES + AUTH_BYTES, dataLen);
                randBytes(outbuf, ivLen);\n                initCipher(outbuf, true);\n                outlength = length + ivLen;\n                reactBuffer(buf, ref length);\n                _encryptIVSent = true;
                lock (tempbuf)\n                {\n                    cipherUpdate(true, length, buf, tempbuf);\n                    outlength = length + ivLen;\n                    Buffer.BlockCopy(tempbuf, 0, outbuf, ivLen, length);\n                }\n            }\n            else\n            {\n                reactBuffer(buf, ref length);
                outlength = length;\n                cipherUpdate(true, length, buf, outbuf);\n            }\n        }\n        public override void Decrypt(byte[] buf, int length, byte[] outbuf, out int outlength)\n        {\n            if (!_decryptIVReceived)\n            {\n                _decryptIVReceived = true;\n                initCipher(buf, false);
        {\n            Method = method;\n            Password = password;\n            OnetimeAuth = onetimeauth;\n            IsUDP = isudp;\n        }\n        protected string Method;\n        protected string Password;\n        protected bool OnetimeAuth;\n        protected bool IsUDP;
        public abstract void Decrypt(byte[] buf, int length, byte[] outbuf, out int outlength);\n        public abstract void Dispose();\n    }\n}
        {\n            if (string.IsNullOrEmpty(method))\n            {\n                method = "table";\n            }\n            method = method.ToLowerInvariant();\n            Type t = _registeredEncryptors[method];\n            ConstructorInfo c = t.GetConstructor(_constructorTypes);\n            IEncryptor result = (IEncryptor)c.Invoke(new object[] { method, password, onetimeauth, isudp });\n            return result;
            return result;\n        }\n    }\n}
            decryptor.Decrypt(cipher, outLen, plain2, out outLen2);\n            Assert.AreEqual(plain.Length, outLen2);\n            for (int j = 0; j < plain.Length; j++)\n            {\n                Assert.AreEqual(plain[j], plain2[j]);\n            }\n            encryptor.Encrypt(plain, 1000, cipher, out outLen);\n            decryptor.Decrypt(cipher, outLen, plain2, out outLen2);\n            Assert.AreEqual(1000, outLen2);\n            for (int j = 0; j < outLen2; j++)
            decryptor.Decrypt(cipher, outLen, plain2, out outLen2);\n            Assert.AreEqual(1000, outLen2);\n            for (int j = 0; j < outLen2; j++)\n            {\n                Assert.AreEqual(plain[j], plain2[j]);\n            }\n            encryptor.Encrypt(plain, 12333, cipher, out outLen);\n            decryptor.Decrypt(cipher, outLen, plain2, out outLen2);\n            Assert.AreEqual(12333, outLen2);\n            for (int j = 0; j < outLen2; j++)
            decryptor.Decrypt(cipher, outLen, plain2, out outLen2);\n            Assert.AreEqual(12333, outLen2);\n            for (int j = 0; j < outLen2; j++)\n            {\n                Assert.AreEqual(plain[j], plain2[j]);\n            }\n        }\n        private static bool encryptionFailed = false;\n        private static object locker = new object();\n        [TestMethod]
            this.tableLayoutPanel2 = new System.Windows.Forms.TableLayoutPanel();\n            this.notifyIcon1 = new System.Windows.Forms.NotifyIcon(this.components);\n            this.contextMenuStrip1 = new System.Windows.Forms.ContextMenuStrip(this.components);\n            this.Config = new System.Windows.Forms.ToolStripMenuItem();\n            this.Quit = new System.Windows.Forms.ToolStripMenuItem();\n            this.tableLayoutPanel1.SuspendLayout();\n            this.panel1.SuspendLayout();\n            this.tableLayoutPanel2.SuspendLayout();\n            this.contextMenuStrip1.SuspendLayout();

        //speed in KiB/s\n        private readonly ConcurrentDictionary<string, long> _inboundCounter = new ConcurrentDictionary<string, long>();\n        private readonly ConcurrentDictionary<string, long> _lastInboundCounter = new ConcurrentDictionary<string, long>();\n        private readonly ConcurrentDictionary<string, List<int>> _inboundSpeedRecords = new ConcurrentDictionary<string, List<int>>();\n        private readonly ConcurrentDictionary<string, long> _outboundCounter = new ConcurrentDictionary<string, long>();\n        private readonly ConcurrentDictionary<string, long> _lastOutboundCounter = new ConcurrentDictionary<string, long>();\n        private readonly ConcurrentDictionary<string, List<int>> _outboundSpeedRecords = new ConcurrentDictionary<string, List<int>>();
        //tasks\n        private readonly TimeSpan _delayBeforeStart = TimeSpan.FromSeconds(1);\n        private readonly TimeSpan _retryInterval = TimeSpan.FromMinutes(2);\n        private Timer _recorder; //analyze and save cached records to RawStatistics and filter records\n        private TimeSpan RecordingInterval => TimeSpan.FromMinutes(Config.DataCollectionMinutes);\n        private Timer _speedMonior;\n        private readonly TimeSpan _monitorInterval = TimeSpan.FromSeconds(1);\n        //private Timer _writer; //write RawStatistics to file\n        //private readonly TimeSpan _writingInterval = TimeSpan.FromMinutes(1);\n        private ShadowsocksController _controller;\n        private StatisticsStrategyConfiguration Config => _controller.StatisticsConfiguration;
        private ShadowsocksController _controller;\n        private StatisticsStrategyConfiguration Config => _controller.StatisticsConfiguration;\n        // Static Singleton Initialization\n        public static AvailabilityStatistics Instance { get; } = new AvailabilityStatistics();\n        public Statistics RawStatistics { get; private set; }\n        public Statistics FilteredStatistics { get; private set; }\n        private AvailabilityStatistics()\n        {\n            RawStatistics = new Statistics();
        // Static Singleton Initialization\n        public static AvailabilityStatistics Instance { get; } = new AvailabilityStatistics();\n        public Statistics RawStatistics { get; private set; }\n        public Statistics FilteredStatistics { get; private set; }\n        private AvailabilityStatistics()\n        {\n            RawStatistics = new Statistics();\n        }\n        internal void UpdateConfiguration(ShadowsocksController controller)\n        {
                }\n                else\n                {\n                    _recorder?.Dispose();\n                    _speedMonior?.Dispose();\n                }\n            }\n            catch (Exception e)\n            {
                }\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n            }\n        }\n        private void StartTimerWithoutState(ref Timer timer, TimerCallback callback, TimeSpan interval)\n        {\n            if (timer?.Change(_delayBeforeStart, interval) == null)
        }\n        private void Run(object _)\n        {\n            UpdateRecords();\n            Save();\n            Reset();\n            FilterRawStatistics();\n        }\n        private async void UpdateRecords()\n        {
                return;\n            }
            try\n            {\n                var content = JsonConvert.SerializeObject(RawStatistics, Formatting.None);\n                File.WriteAllText(AvailabilityStatisticsFile, content);\n            }\n            catch (IOException e)\n            {\n                Logging.LogUsefulException(e);\n            }
            }\n            catch (IOException e)\n            {\n                Logging.LogUsefulException(e);\n            }\n        }\n        private bool IsValidRecord(StatisticsRecord record)\n        {\n            if (Config.ByHourOfDay)
            }\n        }\n        private bool IsValidRecord(StatisticsRecord record)\n        {\n            if (Config.ByHourOfDay)\n            {\n                if (!record.Timestamp.Hour.Equals(DateTime.Now.Hour)) return false;\n            }\n            return true;\n        }
            _speedMonior.Dispose();\n        }\n        public void UpdateLatency(Server server, int latency)\n        {\n            List<int> records;\n            _latencyRecords.TryGetValue(server.Identifier(), out records);\n            if (records == null)\n            {\n                records = new List<int>();\n            }
        {\n            Interlocked.Add(ref inboundCounter, n);\n            if (_config.availabilityStatistics)\n            {\n                new Task(() => availabilityStatistics.UpdateInboundCounter(server, n)).Start();\n            }\n        }\n        public void UpdateOutboundCounter(Server server, long n)\n        {\n            Interlocked.Add(ref outboundCounter, n);
        {\n            Interlocked.Add(ref outboundCounter, n);\n            if (_config.availabilityStatistics)\n            {\n                new Task(() => availabilityStatistics.UpdateOutboundCounter(server, n)).Start();\n            }\n        }\n        protected void Reload()\n        {\n            // some logic in configuration updated the config when saving, we need to read it again
        // in ping-only records, these fields would be null\n        public int? AverageLatency;\n        public int? MinLatency;\n        public int? MaxLatency;\n        private bool EmptyLatencyData => (AverageLatency == null) && (MinLatency == null) && (MaxLatency == null);\n        public int? AverageInboundSpeed;\n        public int? MinInboundSpeed;\n        public int? MaxInboundSpeed;\n        private bool EmptyInboundSpeedData\n            => (AverageInboundSpeed == null) && (MinInboundSpeed == null) && (MaxInboundSpeed == null);\n        public int? AverageOutboundSpeed;
        {\n            ServerIdentifier = identifier;\n            if (inboundSpeedRecords != null && inboundSpeedRecords.Any())\n            {\n                AverageInboundSpeed = (int) inboundSpeedRecords.Average();\n                MinInboundSpeed = inboundSpeedRecords.Min();\n                MaxInboundSpeed = inboundSpeedRecords.Max();\n            }\n            if (outboundSpeedRecords != null && outboundSpeedRecords.Any())\n            {
            if (inboundSpeedRecords != null && inboundSpeedRecords.Any())\n            {\n                AverageInboundSpeed = (int) inboundSpeedRecords.Average();\n                MinInboundSpeed = inboundSpeedRecords.Min();\n                MaxInboundSpeed = inboundSpeedRecords.Max();\n            }\n            if (outboundSpeedRecords != null && outboundSpeedRecords.Any())\n            {\n                AverageOutboundSpeed = (int) outboundSpeedRecords.Average();\n                MinOutboundSpeed = outboundSpeedRecords.Min();
        }\n        public void SetResponse(ICollection<int?> responseRecords)\n        {\n            if (responseRecords == null) return;\n            var records = responseRecords.Where(response => response != null).Select(response => response.Value).ToList();\n            if (!records.Any()) return;\n            AverageResponse = (int?) records.Average();\n            MinResponse = records.Min();\n            MaxResponse = records.Max();\n            PackageLoss = responseRecords.Count(response => response != null)/(float) responseRecords.Count;
        {\n            if (responseRecords == null) return;\n            var records = responseRecords.Where(response => response != null).Select(response => response.Value).ToList();\n            if (!records.Any()) return;\n            AverageResponse = (int?) records.Average();\n            MinResponse = records.Min();\n            MaxResponse = records.Max();\n            PackageLoss = responseRecords.Count(response => response != null)/(float) responseRecords.Count;\n        }\n    }
        }\n    }\n}
        {\n            var config = _controller.StatisticsConfiguration;\n            float? score = null;\n            var averageRecord = new StatisticsRecord(identifier,\n                records.Where(record => record.MaxInboundSpeed != null).Select(record => record.MaxInboundSpeed.Value).ToList(),\n                records.Where(record => record.MaxOutboundSpeed != null).Select(record => record.MaxOutboundSpeed.Value).ToList(),\n                records.Where(record => record.AverageLatency != null).Select(record => record.AverageLatency.Value).ToList());\n            averageRecord.SetResponse(records.Select(record => record.AverageResponse).ToList());\n            foreach (var calculation in config.Calculations)\n            {
            return score;\n        }\n        private void ChooseNewServer(List<Server> servers)\n        {\n            if (_filteredStatistics == null || servers.Count == 0)\n            {\n                return;\n            }\n            try\n            {
            ((System.ComponentModel.ISupportInitialize)(this.StatisticsChart)).BeginInit();\n            ((System.ComponentModel.ISupportInitialize)(this.bindingConfiguration)).BeginInit();\n            this.chartModeSelector.SuspendLayout();\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer1)).BeginInit();\n            this.splitContainer1.Panel1.SuspendLayout();\n            this.splitContainer1.Panel2.SuspendLayout();\n            this.splitContainer1.SuspendLayout();\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer2)).BeginInit();\n            this.splitContainer2.Panel1.SuspendLayout();\n            this.splitContainer2.Panel2.SuspendLayout();
            this.ServersListBox.Location = new System.Drawing.Point(12, 12);\n            this.ServersListBox.Name = "ServersListBox";

                    {\n                        if (line[0] == '#')\n                            continue;\n                        var pos = line.IndexOf('=');\n                        if (pos < 1)\n                            continue;\n                        Strings[line.Substring(0, pos)] = line.Substring(pos + 1);\n                    }\n                }\n            }
                            continue;\n                        var pos = line.IndexOf('=');\n                        if (pos < 1)\n                            continue;\n                        Strings[line.Substring(0, pos)] = line.Substring(pos + 1);\n                    }\n                }\n            }\n        }\n        public static string GetString(string key)
        private Encryptor encryptor;\n        Socket listener;\n        public Local(Config config)\n        {\n            this.config = config;\n            this.encryptor = new Encryptor(config.password);\n        }\n        public void Start()\n        {\n            // Create a TCP/IP socket.
        }\n        public void Start()\n        {\n            // Create a TCP/IP socket.\n            listener = new Socket(AddressFamily.InterNetwork,\n                SocketType.Stream, ProtocolType.Tcp);\n            IPEndPoint localEndPoint = new IPEndPoint(0, config.local_port);\n            // Bind the socket to the local endpoint and listen for incoming connections.\n                listener.Bind(localEndPoint);\n                listener.Listen(100);\n            // Start an asynchronous socket to listen for connections.
            // Bind the socket to the local endpoint and listen for incoming connections.\n                listener.Bind(localEndPoint);\n                listener.Listen(100);\n            // Start an asynchronous socket to listen for connections.\n            Console.WriteLine("Waiting for a connection...");\n            listener.BeginAccept(\n                new AsyncCallback(AcceptCallback),\n                listener);\n        }\n        public void Stop()
            IPAddress ipAddress = ipHostInfo.AddressList[0];\n            IPEndPoint remoteEP = new IPEndPoint(ipAddress, config.server_port);\n            remote = new Socket(AddressFamily.InterNetwork,\n                SocketType.Stream, ProtocolType.Tcp);\n            // Connect to the remote endpoint.\n            remote.BeginConnect(remoteEP,\n                new AsyncCallback(connectCallback), null);\n        }\n        public void Close()\n        {\n            connection.Close();
            remote = new Socket(AddressFamily.InterNetwork,\n                SocketType.Stream, ProtocolType.Tcp);\n            // Connect to the remote endpoint.\n            remote.BeginConnect(remoteEP,\n                new AsyncCallback(connectCallback), null);\n        }\n        public void Close()\n        {\n            connection.Close();\n            remote.Close();\n        }
        {\n            ShowBalloonTip(I18N.GetString("Failed to update PAC file"), e.GetException().Message, ToolTipIcon.Error, 5000);\n            logger.LogUsefulException(e.GetException());\n        }\n        void controller_UpdatePACFromGeositeCompleted(object sender, GeositeResultEventArgs e)\n        {\n            string result = e.Success\n                ? I18N.GetString("PAC updated")
        {\n            string result = e.Success\n                ? I18N.GetString("PAC updated")
        }\n        private void PacServer_PACUpdateError(object sender, ErrorEventArgs e)\n        {\n            UpdatePACFromGeositeError?.Invoke(this, e);\n        }\n        private static readonly IEnumerable<char> IgnoredLineBegins = new[] { '!', '[' };\n        private void PacDaemon_UserRuleFileChanged(object sender, EventArgs e)\n        {\n            GeositeUpdater.MergeAndWritePACFile();\n            UpdateSystemProxy();
        }\n        private static readonly IEnumerable<char> IgnoredLineBegins = new[] { '!', '[' };\n        private void PacDaemon_UserRuleFileChanged(object sender, EventArgs e)\n        {\n            GeositeUpdater.MergeAndWritePACFile();\n            UpdateSystemProxy();\n        }\n        public void CopyPacUrl()\n        {\n            Clipboard.SetDataObject(_pacServer.PacUrl);
        }\n        public static void Disable()\n        {\n            try\n            {\n                RegistryKey registry =\n                    Registry.CurrentUser.OpenSubKey("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings",\n                        true);\n                registry.SetValue("ProxyEnable", 0);\n                registry.SetValue("ProxyServer", "");
        }\n        private static String GetTimestamp(DateTime value)\n        {\n            return value.ToString("yyyyMMddHHmmssffff");\n        }\n    }\n}
            {\n                string original = FileManager.NonExclusiveReadAllText(PACDaemon.PAC_FILE, Encoding.UTF8);\n                if (original == abpContent)\n                {\n                    return false;\n                }\n            }\n            File.WriteAllText(PACDaemon.PAC_FILE, abpContent, Encoding.UTF8);\n            return true;\n        }
                if (original == abpContent)\n                {\n                    return false;\n                }\n            }\n            File.WriteAllText(PACDaemon.PAC_FILE, abpContent, Encoding.UTF8);\n            return true;\n        }\n        private static string MergePACFile(string gfwListResult)\n        {
            return true;\n        }\n        private static string MergePACFile(string gfwListResult)\n        {\n            string abpContent;\n            if (File.Exists(PACDaemon.USER_ABP_FILE))\n            {\n                abpContent = FileManager.NonExclusiveReadAllText(PACDaemon.USER_ABP_FILE, Encoding.UTF8);\n            }\n            else
            PACFileReadyToOpen?.Invoke(this, new PathEventArgs() { Path = pacFilename });\n        }\n        public void TouchUserRuleFile()\n        {\n            string userRuleFilename = _pacDaemon.TouchUserRuleFile();\n            UserRuleFileReadyToOpen?.Invoke(this, new PathEventArgs() { Path = userRuleFilename });\n        }\n        public string GetServerURLForCurrentServer()\n        {\n            Server server = GetCurrentServer();
            UserRuleFileReadyToOpen?.Invoke(this, new PathEventArgs() { Path = userRuleFilename });\n        }\n        public string GetServerURLForCurrentServer()\n        {\n            Server server = GetCurrentServer();\n            return GetServerURL(server);\n        }\n        public static string GetServerURL(Server server)\n        {\n            string tag = string.Empty;
            if (gfwListUpdater == null)\n            {\n                gfwListUpdater = new GFWListUpdater();\n                gfwListUpdater.UpdateCompleted += PacServer_PACUpdateCompleted;\n                gfwListUpdater.Error += PacServer_PACUpdateError;\n            }\n            availabilityStatistics.UpdateConfiguration(this);\n            if (_listener != null)\n            {\n                _listener.Stop();
        private string PacSecret { get; set; } = "";\n        public string PacUrl { get; private set; } = "";\n        private Configuration _config;\n        private PACDaemon _pacDaemon;\n        public PACServer(PACDaemon pacDaemon)
        private Configuration _config;\n        private PACDaemon _pacDaemon;\n        public PACServer(PACDaemon pacDaemon)\n        {\n            _pacDaemon = pacDaemon;
        {\n            _pacDaemon = pacDaemon;\n        }\n        public void UpdatePACURL(Configuration config)\n        {\n            this._config = config;\n            if (config.secureLocalPac)\n            {
        }\n        public void UpdatePACURL(Configuration config)\n        {\n            this._config = config;\n            if (config.secureLocalPac)\n            {\n                var rd = new byte[32];\n                RNG.GetBytes(rd);\n                PacSecret = $"&secret={Convert.ToBase64String(rd)}";\n            }
        {\n            this._config = config;\n            if (config.secureLocalPac)\n            {\n                var rd = new byte[32];\n                RNG.GetBytes(rd);\n                PacSecret = $"&secret={Convert.ToBase64String(rd)}";\n            }\n            else\n            {
                {\n                    return false;\n                }\n                // parse request line\n                string requestLine = lines[0];\n                // GET /pac?t=yyyyMMddHHmmssfff&secret=foobar HTTP/1.1\n                string[] requestItems = requestLine.Split(' ');\n                if (requestItems.Length == 3 && requestItems[0] == "GET")\n                {\n                    int index = requestItems[1].IndexOf('?');
                    if (kv.Length == 2)\n                    {\n                        if (kv[0] == "Host")\n                        {\n                            if (kv[1].Trim() == ((IPEndPoint)socket.LocalEndPoint).ToString())\n                            {\n                                hostMatch = true;\n                            }\n                        }\n                        //else if (kv[0] == "User-Agent")
                    }\n                }\n                if (hostMatch && pathMatch)\n                {\n                    if (!secretMatch)\n                    {\n                        socket.Close(); // Close immediately\n                    }\n                    else\n                    {
        public void SendResponse(Socket socket, bool useSocks)\n        {\n            try\n            {\n                IPEndPoint localEndPoint = (IPEndPoint)socket.LocalEndPoint;\n                string proxy = GetPACAddress(localEndPoint, useSocks);\n                string pacContent = _pacDaemon.GetPACContent().Replace("__PROXY__", proxy);\n                string responseHead = String.Format(@"HTTP/1.1 200 OK\nServer: Shadowsocks\nContent-Type: application/x-ns-proxy-autoconfig
                string responseHead = String.Format(@"HTTP/1.1 200 OK\nServer: Shadowsocks\nContent-Type: application/x-ns-proxy-autoconfig\nContent-Length: {0}\nConnection: Close\n", Encoding.UTF8.GetBytes(pacContent).Length);\n                byte[] response = Encoding.UTF8.GetBytes(responseHead + pacContent);\n                socket.BeginSend(response, 0, response.Length, 0, new AsyncCallback(SendCallback), socket);\n                Utils.ReleaseMemory(true);\n            }
        private TimeSpan RecordingInterval => TimeSpan.FromMinutes(Config.DataCollectionMinutes);\n        private Timer _perSecondTimer; //analyze and save cached records to RawStatistics and filter records\n        private readonly TimeSpan _monitorInterval = TimeSpan.FromSeconds(1);\n        //private Timer _writer; //write RawStatistics to file\n        //private readonly TimeSpan _writingInterval = TimeSpan.FromMinutes(1);\n        private ShadowsocksController _controller;\n        private StatisticsStrategyConfiguration Config => _controller.StatisticsConfiguration;\n        // Static Singleton Initialization\n        public static AvailabilityStatistics Instance { get; } = new AvailabilityStatistics();\n        public Statistics RawStatistics { get; private set; }
        private readonly TimeSpan _monitorInterval = TimeSpan.FromSeconds(1);\n        //private Timer _writer; //write RawStatistics to file\n        //private readonly TimeSpan _writingInterval = TimeSpan.FromMinutes(1);\n        private ShadowsocksController _controller;\n        private StatisticsStrategyConfiguration Config => _controller.StatisticsConfiguration;\n        // Static Singleton Initialization\n        public static AvailabilityStatistics Instance { get; } = new AvailabilityStatistics();\n        public Statistics RawStatistics { get; private set; }\n        public Statistics FilteredStatistics { get; private set; }\n        private AvailabilityStatistics()
                    LoadRawStatistics();\n                    if (_perSecondTimer == null)\n                    {\n                        _perSecondTimer = new Timer(OperationsPerSecond, new Counter(), _delayBeforeStart, TimeSpan.FromSeconds(1));\n                    }\n                }\n                else\n                {\n                    _perSecondTimer?.Dispose();
                }\n                else\n                {\n                    _perSecondTimer?.Dispose();\n                }\n            }\n            catch (Exception e)\n            {
                }\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n            }\n        }\n        private void OperationsPerSecond(object state)\n        {\n            lock(state)
        {\n            foreach (var kv in _inOutBoundRecords)\n            {\n                var id = kv.Key;\n                var record = kv.Value;\n                long inboundDelta, outboundDelta;\n                record.GetDelta(out inboundDelta, out outboundDelta);\n                var inboundSpeed = GetSpeedInKiBPerSecond(inboundDelta, _monitorInterval.TotalSeconds);\n                var outboundSpeed = GetSpeedInKiBPerSecond(outboundDelta, _monitorInterval.TotalSeconds);
        {\n            UpdateRecords();\n            Reset();\n        }\n        private void UpdateRecords()\n        {\n            var records = new Dictionary<string, StatisticsRecord>();\n            UpdateRecordsState state = new UpdateRecordsState();\n            int serverCount = _controller.GetCurrentConfiguration().configs.Count;\n            state.counter = serverCount;
            {\n                Save();\n                FilterRawStatistics();\n            }\n        }\n        private void ping_Completed(object sender, MyPing.CompletedEventArgs e)\n        {\n            PingState pingState = (PingState)e.UserState;\n            UpdateRecordsState state = pingState.state;\n            Server server = e.Server;
                foreach (var serverAndRecords in RawStatistics)\n                {\n                    var server = serverAndRecords.Key;\n                    var filteredRecords = serverAndRecords.Value.FindAll(IsValidRecord);\n                    filteredStatistics[server] = filteredRecords;\n                }\n                FilteredStatistics = filteredStatistics;\n            }\n            catch (Exception e)\n            {
            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n            }\n        }\n        private void LoadRawStatistics()\n        {\n            try\n            {
            }\n        }\n        private static int GetSpeedInKiBPerSecond(long bytes, double seconds)\n        {\n            var result = (int)(bytes / seconds) / 1024;\n            return result;\n        }\n        public void Dispose()\n        {\n            _perSecondTimer.Dispose();
        }\n        public void UpdateLatency(Server server, int latency)\n        {\n            _latencyRecords.GetOrAdd(server.Identifier(), (k) =>\n            {\n                List<int> records = new List<int>();\n                records.Add(latency);\n                return records;\n            });\n        }
        public string PacUrl { get; private set; } = "";\n        private Configuration _config;\n        private PACDaemon _pacDaemon;\n        public PACServer(PACDaemon pacDaemon)\n        {\n            _pacDaemon = pacDaemon;\n        }\n        public void UpdatePACURL(Configuration config)\n        {\n            _config = config;
        }\n        private static string GetHash(string content)\n        {\n            var contentBytes = Encoding.ASCII.GetBytes(content);\n            using (var md5 = System.Security.Cryptography.MD5.Create())\n            {\n                var md5Bytes = md5.ComputeHash(contentBytes);\n                return HttpServerUtility.UrlTokenEncode(md5Bytes);

    {\n        private static Dictionary<string, string> _strings = new Dictionary<string, string>();\n        private static void Init(string res)\n        {\n            using (var sr = new StringReader(res))\n            {\n                foreach (var line in sr.NonWhiteSpaceLines())\n                {\n                    if (line[0] == '#')\n                        continue;
        {\n            using (var sr = new StringReader(res))\n            {\n                foreach (var line in sr.NonWhiteSpaceLines())\n                {\n                    if (line[0] == '#')\n                        continue;\n                    var pos = line.IndexOf('=');\n                    if (pos < 1)\n                        continue;
            {\n                // choose Traditional Chinese only if we get explicit indication\n                Init(name.Contains("Traditional")\n                    ? Resources.zh_tw\n                    : Resources.cn);
            }\n        }\n        public static string GetString(string key)\n        {\n            return _strings.ContainsKey(key)\n                ? _strings[key]\n                : key;
        }\n    }\n}
            }\n            else\n            {\n                Logging.Info("Using external translation");\n                i18n = File.ReadAllText(I18N_FILE, Encoding.UTF8);\n            }\n            Logging.Info("Current language is: " + locale);\n            Init(i18n, locale);\n        }\n        public static string GetString(string key, params object[] args)
using System.Diagnostics;\nusing System.Drawing;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Windows.Forms;\nusing ZXing;\nusing ZXing.Common;\nusing ZXing.QrCode;
using System.Windows.Forms;\nusing ZXing;\nusing ZXing.Common;\nusing ZXing.QrCode;
namespace Shadowsocks.View\n{\n    public class MenuViewController\n    {\n        // yes this is just a menu view controller\n        // when config form is closed, it moves away from RAM\n        // and it should just do anything related to the config form\n        private ShadowsocksController controller;\n        private UpdateChecker updateChecker;\n        private NotifyIcon _notifyIcon;
                List<Listener.Service> services = new List<Listener.Service>();\n                services.Add(tcpRelay);\n                services.Add(udpRelay);\n                services.Add(_pacServer);\n                services.Add(new PortForwarder(polipoRunner.RunningPort));\n                _listener = new Listener(services);\n                _listener.Start(_config);\n            }\n            catch (Exception e)
                services.Add(_pacServer);\n                services.Add(new PortForwarder(polipoRunner.RunningPort));\n                _listener = new Listener(services);\n                _listener.Start(_config);\n            }\n            catch (Exception e)\n            {\n                // translate Microsoft language into human language\n                // i.e. An attempt was made to access a socket in a way forbidden by its access permissions => Port already in use\n                if (e is SocketException)
        }\n        Configuration _config;\n        bool _shareOverLAN;\n        Socket _tcpSocket;\n        Socket _udpSocket;\n        IList<Service> _services;\n        public Listener(IList<Service> services)\n        {\n            this._services = services;
        IList<Service> _services;\n        public Listener(IList<Service> services)\n        {\n            this._services = services;\n        }\n        private bool CheckIfPortInUse(int port)\n        {\n            IPGlobalProperties ipProperties = IPGlobalProperties.GetIPGlobalProperties();\n            IPEndPoint[] ipEndPoints = ipProperties.GetActiveTcpListeners();\n            foreach (IPEndPoint endPoint in ipEndPoints)
                IPEndPoint localEndPoint = null;\n                if (_shareOverLAN)\n                {\n                    localEndPoint = new IPEndPoint(IPAddress.Any, _config.localPort);\n                }\n                else\n                {\n                    localEndPoint = new IPEndPoint(IPAddress.Loopback, _config.localPort);\n                }\n                // Bind the socket to the local endpoint and listen for incoming connections.\n                _tcpSocket.Bind(localEndPoint);
                // Start an asynchronous socket to listen for connections.\n                Console.WriteLine("Shadowsocks started");\n                _tcpSocket.BeginAccept(\n                    new AsyncCallback(AcceptCallback),\n                    _tcpSocket);\n                UDPState udpState = new UDPState();\n                _udpSocket.BeginReceiveFrom(udpState.buffer, 0, udpState.buffer.Length, 0, ref udpState.remoteEndPoint, new AsyncCallback(RecvFromCallback), udpState);\n            }\n            catch (SocketException)\n            {
                    new AsyncCallback(AcceptCallback),\n                    _tcpSocket);\n                UDPState udpState = new UDPState();\n                _udpSocket.BeginReceiveFrom(udpState.buffer, 0, udpState.buffer.Length, 0, ref udpState.remoteEndPoint, new AsyncCallback(RecvFromCallback), udpState);\n            }\n            catch (SocketException)\n            {\n                _tcpSocket.Close();\n                throw;
            }\n            catch (SocketException)\n            {\n                _tcpSocket.Close();\n                throw;\n            }\n        }\n        public void Stop()\n        {\n            if (_tcpSocket != null)
                throw;\n            }\n        }\n        public void Stop()\n        {\n            if (_tcpSocket != null)\n            {\n                _tcpSocket.Close();\n                _tcpSocket = null;\n            }
            {\n                _tcpSocket.Close();\n                _tcpSocket = null;\n            }\n            if (_udpSocket != null)\n            {\n                _udpSocket.Close();\n                _udpSocket = null;\n            }\n        }
            }\n        }\n        public void AcceptCallback(IAsyncResult ar)\n        {\n            Socket listener = (Socket)ar.AsyncState;\n            try\n            {\n                Socket conn = listener.EndAccept(ar);\n                byte[] buf = new byte[4096];\n                object[] state = new object[] {
                    {\n                        return;\n                    }\n                }\n                // no service found for this\n                if (conn.ProtocolType == ProtocolType.Tcp)\n                {\n                    conn.Close();\n                }\n            }\n            catch (Exception e)
            }\n            catch (Exception e)\n            {\n                Console.WriteLine(e);\n                conn.Close();\n            }\n        }\n    }\n}
    {\n        private Configuration _config;\n        public TCPRelay(Configuration config)\n        {\n            this._config = config;\n        }\n        public bool Handle(byte[] firstPacket, int length, Socket socket, object state)\n        {\n            if (socket.ProtocolType != ProtocolType.Tcp)\n            {
        {\n            this._config = config;\n        }\n        public bool Handle(byte[] firstPacket, int length, Socket socket, object state)\n        {\n            if (socket.ProtocolType != ProtocolType.Tcp)\n            {\n                return false;\n            }\n            if (length < 2 || firstPacket[0] != 5)
            if (length < 2 || firstPacket[0] != 5)\n            {\n                return false;\n            }\n            socket.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n            Handler handler = new Handler();\n            handler.connection = socket;\n            Server server = _config.GetCurrentServer();\n            handler.encryptor = EncryptorFactory.GetEncryptor(server.method, server.password);\n            handler.server = server;
        {\n            if (socket.ProtocolType != ProtocolType.Tcp)\n            {\n                return false;\n            }\n            try\n            {\n                string request = Encoding.UTF8.GetString(firstPacket, 0, length);\n                string[] lines = request.Split('\r', '\n');\n                bool hostMatch = false, pathMatch = false, useSocks = false;
        {\n            if (socket.ProtocolType != ProtocolType.Tcp)\n            {\n                return false;\n            }\n            new Handler().Start(firstPacket, length, socket, this._targetPort);\n            return true;\n        }\n        class Handler\n        {
        void EndConnectProxy(IAsyncResult asyncResult);\n        void BeginConnectDest(EndPoint remoteEP, AsyncCallback callback, object state);\n        void EndConnectDest(IAsyncResult asyncResult);\n        void BeginSend(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state);\n        int EndSend(IAsyncResult asyncResult);\n        void BeginReceive(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state);\n        int EndReceive(IAsyncResult asyncResult);\n        void Shutdown(SocketShutdown how);
        void EndConnectDest(IAsyncResult asyncResult);\n        void BeginSend(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state);\n        int EndSend(IAsyncResult asyncResult);\n        void BeginReceive(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state);\n        int EndReceive(IAsyncResult asyncResult);\n        void Shutdown(SocketShutdown how);\n        void Close();\n    }
            object state);\n        int EndSend(IAsyncResult asyncResult);\n        void BeginReceive(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state);\n        int EndReceive(IAsyncResult asyncResult);\n        void Shutdown(SocketShutdown how);\n        void Close();\n    }\n}
            object state);\n        int EndReceive(IAsyncResult asyncResult);\n        void Shutdown(SocketShutdown how);\n        void Close();\n    }\n}
        {\n            // do nothing\n            ProxyEndPoint = remoteEP;\n            var r = new FakeAsyncResult(state);\n            callback?.Invoke(r);\n        }\n        public void EndConnectProxy(IAsyncResult asyncResult)\n        {\n            // do nothing\n        }\n        public void BeginConnectDest(EndPoint remoteEP, AsyncCallback callback, object state)
        }\n        public void EndConnectProxy(IAsyncResult asyncResult)\n        {\n            // do nothing\n        }\n        public void BeginConnectDest(EndPoint remoteEP, AsyncCallback callback, object state)\n        {\n            if (_remote == null)\n            {\n                _remote = new Socket(remoteEP.AddressFamily, SocketType.Stream, ProtocolType.Tcp);\n                _remote.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);
        {\n            if (_remote == null)\n            {\n                _remote = new Socket(remoteEP.AddressFamily, SocketType.Stream, ProtocolType.Tcp);\n                _remote.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n            }\n            DestEndPoint = remoteEP;\n            _remote.BeginConnect(remoteEP, callback, state);\n        }\n        public void EndConnectDest(IAsyncResult asyncResult)
        }\n        public void EndConnectDest(IAsyncResult asyncResult)\n        {\n            _remote.EndConnect(asyncResult);\n        }\n        public void BeginSend(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state)\n        {\n            _remote.BeginSend(buffer, offset, size, socketFlags, callback, state);\n        }
            object state)\n        {\n            _remote.BeginSend(buffer, offset, size, socketFlags, callback, state);\n        }\n        public int EndSend(IAsyncResult asyncResult)\n        {\n            return _remote.EndSend(asyncResult);\n        }\n        public void BeginReceive(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state)
        }\n        public int EndSend(IAsyncResult asyncResult)\n        {\n            return _remote.EndSend(asyncResult);\n        }\n        public void BeginReceive(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state)\n        {\n            _remote.BeginReceive(buffer, offset, size, socketFlags, callback, state);\n        }
            object state)\n        {\n            _remote.BeginReceive(buffer, offset, size, socketFlags, callback, state);\n        }\n        public int EndReceive(IAsyncResult asyncResult)\n        {\n            return _remote.EndReceive(asyncResult);\n        }\n        public void Shutdown(SocketShutdown how)\n        {
        }\n        public int EndReceive(IAsyncResult asyncResult)\n        {\n            return _remote.EndReceive(asyncResult);\n        }\n        public void Shutdown(SocketShutdown how)\n        {\n            _remote?.Shutdown(how);\n        }\n        public void Close()
                {\n                    KillProcess(p);\n                }\n                string polipoConfig = Resources.privoxy_conf;\n                _runningPort = this.GetFreePort();\n                polipoConfig = polipoConfig.Replace("__SOCKS_PORT__", configuration.localPort.ToString());\n                polipoConfig = polipoConfig.Replace("__POLIPO_BIND_PORT__", _runningPort.ToString());\n                polipoConfig = polipoConfig.Replace("__POLIPO_BIND_IP__", configuration.shareOverLan ? "0.0.0.0" : "127.0.0.1");\n                FileManager.ByteArrayToFile(Utils.GetTempPath(UniqueConfigFile), Encoding.UTF8.GetBytes(polipoConfig));\n                _process = new Process();
                _process = new Process();\n                // Configure the process using the StartInfo properties.\n                _process.StartInfo.FileName = "ss_privoxy.exe";\n                _process.StartInfo.Arguments = UniqueConfigFile;\n                _process.StartInfo.WorkingDirectory = Utils.GetTempPath();\n                _process.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;\n                _process.StartInfo.UseShellExecute = true;\n                _process.StartInfo.CreateNoWindow = true;\n                _process.Start();\n                /*\n                 * Add this process to job obj associated with this ss process, so that
                _process.StartInfo.WorkingDirectory = Utils.GetTempPath();\n                _process.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;\n                _process.StartInfo.UseShellExecute = true;\n                _process.StartInfo.CreateNoWindow = true;\n                _process.Start();\n                /*\n                 * Add this process to job obj associated with this ss process, so that\n                 * when ss exit unexpectedly, this process will be forced killed by system.\n                 */\n                PolipoJob.AddProcess(_process.Handle);\n            }
                    try\n                    {\n                        Directory.CreateDirectory(Path.Combine(Application.StartupPath, "temp"));\n                    }\n                    catch (Exception e)\n                    {\n                        TempPath = Path.GetTempPath();\n                        Logging.LogUsefulException(e);\n                    }\n                    finally
                LogMessageTextBox.ScrollToCaret();\n                lastOffset = reader.BaseStream.Position;\n            }\n        }\n        private void UpdateContent()\n        {\n            try\n            {\n                using (StreamReader reader = new StreamReader(new FileStream(filename,\n                         FileMode.Open, FileAccess.Read, FileShare.ReadWrite)))
                    }\n                    if (changed)\n                    {\n                        LogMessageTextBox.AppendText(appendText.ToString());\n                        LogMessageTextBox.ScrollToCaret();\n                    }\n                    lastOffset = reader.BaseStream.Position;\n                }\n            }\n            catch (FileNotFoundException)
        // return path to store temporary files\n        public static string GetTempPath()\n        {\n            if (_tempPath == null)\n            {\n                bool isPortableMode = Configuration.Load().portableMode;\n                try\n                {\n                    if (isPortableMode)\n                    {\n                        _tempPath = Directory.CreateDirectory(Path.Combine(Application.StartupPath, "ss_win_temp")).FullName;
                        // don't use "/", it will fail when we call explorer /select xxx/ss_win_temp\xxx.log\n                    }\n                    else\n                    {\n                        _tempPath = Directory.CreateDirectory(Path.Combine(Path.GetTempPath(), @"Shadowsocks\ss_win_temp_" + Application.ExecutablePath.GetHashCode())).FullName;\n                    }

                Configuration.CheckServer(server);\n                Configuration.CheckLocalPort(localPort);\n                _modifiedConfiguration.configs[_lastSelectedIndex] = server;\n                _modifiedConfiguration.localPort = localPort;\n                _modifiedConfiguration.portableMode = PortableModeCheckBox.Checked;\n                return true;\n            }\n            catch (Exception ex)\n            {\n                MessageBox.Show(ex.Message);
        {\n            _config.configs = servers;\n            _config.localPort = localPort;\n            _config.portableMode = portableMode;\n            Configuration.Save(_config);
            Configuration.Save(_config);\n        }\n        public void SaveStrategyConfigurations(StatisticsStrategyConfiguration configuration)\n        {\n            StatisticsConfiguration = configuration;\n            StatisticsStrategyConfiguration.Save(configuration);\n        }\n        public bool AddServerBySSURL(string ssURL)\n        {\n            try
        private System.Windows.Forms.TextBox PluginArgumentsTextBox;\n        private System.Windows.Forms.Label PluginArgumentsLabel;\n        private System.Windows.Forms.ToolTip toolTip1;\n        private System.Windows.Forms.CheckBox PortableModeCheckBox;\n    }\n}
    }\n}
            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void PipeConnectionSendCallback(IAsyncResult ar)\n        {
            try\n            {\n                var session = (AsyncSession)ar.AsyncState;\n                _connection.EndSend(ar);\n                session.Remote.BeginReceive(_remoteRecvBuffer, 0, RecvSize, SocketFlags.None, new AsyncCallback(PipeRemoteReceiveCallback), session);\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();
                session.Remote.BeginReceive(_remoteRecvBuffer, 0, RecvSize, SocketFlags.None, new AsyncCallback(PipeRemoteReceiveCallback), session);\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }\n    }\n}
            this.ClientSize = new System.Drawing.Size(284, 262);\n            this.ControlBox = false;\n            this.Controls.Add(this.Panel);
                                            Screen.PrimaryScreen.Bounds.Height))\n            {\n                using (Graphics g = Graphics.FromImage(fullImage))\n                {\n                    g.CopyFromScreen(Screen.PrimaryScreen.Bounds.X,\n                                     Screen.PrimaryScreen.Bounds.Y,\n                                     0, 0,\n                                     fullImage.Size,\n                                     CopyPixelOperation.SourceCopy);\n                }
                {\n                    g.CopyFromScreen(Screen.PrimaryScreen.Bounds.X,\n                                     Screen.PrimaryScreen.Bounds.Y,\n                                     0, 0,\n                                     fullImage.Size,\n                                     CopyPixelOperation.SourceCopy);\n                }\n                for (int i = 0; i < 5; i++)\n                {\n                    int marginLeft = fullImage.Width * i / 3 / 5;
                                     CopyPixelOperation.SourceCopy);\n                }\n                for (int i = 0; i < 5; i++)\n                {\n                    int marginLeft = fullImage.Width * i / 3 / 5;\n                    int marginTop = fullImage.Height * i / 3 / 5;\n                    Rectangle cropRect = new Rectangle(marginLeft, marginTop, fullImage.Width - marginLeft * 2, fullImage.Height - marginTop * 2);\n                    Bitmap target = new Bitmap(cropRect.Width, cropRect.Height);\n                    using (Graphics g = Graphics.FromImage(target))
                {\n                    int marginLeft = fullImage.Width * i / 3 / 5;\n                    int marginTop = fullImage.Height * i / 3 / 5;\n                    Rectangle cropRect = new Rectangle(marginLeft, marginTop, fullImage.Width - marginLeft * 2, fullImage.Height - marginTop * 2);\n                    Bitmap target = new Bitmap(cropRect.Width, cropRect.Height);\n                    using (Graphics g = Graphics.FromImage(target))\n                    {\n                        g.DrawImage(fullImage, new Rectangle(0, 0, target.Width, target.Height),
                    {\n                        g.DrawImage(fullImage, new Rectangle(0, 0, target.Width, target.Height),\n                                        cropRect,\n                                        GraphicsUnit.Pixel);\n                    }\n                    var reader = new BarcodeReader
                    }\n                    var reader = new BarcodeReader\n                    {\n                        TryHarder = true,
                    {\n                        TryHarder = true,\n                        PossibleFormats = new List<BarcodeFormat>\n                        {\n                            BarcodeFormat.QR_CODE\n                        }\n                    };\n                    var result = reader.Decode(target);\n                    if (result != null)\n                    {
                        splash.Location = new Point((int)minX, (int)minY);\n                        // we need a panel because a window has a minimal size\n                        splash.Panel.Size = new Size((int)maxX - (int)minX, (int)maxY - (int)minY);\n                        splash.Size = splash.Panel.Size;\n                        splash.Show();\n                        return;\n                    }\n                }\n            }\n            MessageBox.Show(I18N.GetString("Failed to find QRCode"));
                        splash.Show();\n                        return;\n                    }\n                }\n            }\n            MessageBox.Show(I18N.GetString("Failed to find QRCode"));\n        }\n        void splash_FormClosed(object sender, FormClosedEventArgs e)\n        {\n            ShowConfigForm();
        }\n        void splash_FormClosed(object sender, FormClosedEventArgs e)\n        {\n            ShowConfigForm();\n        }\n        void openURLFromQRCode(object sender, FormClosedEventArgs e)\n        {\n            Process.Start(_urlToOpen);\n        }\nprivate void AutoStartupItem_Click(object sender, EventArgs e) {
        // this is a copy of configuration that we are working on\n        private HotkeyConfig _modifiedConfig;\n        private readonly IEnumerable<TextBox> _allTextBoxes;\n        public HotkeySettingsForm(ShadowsocksController controller)\n        {\n            InitializeComponent();\n            UpdateTexts();
        public HotkeySettingsForm(ShadowsocksController controller)\n        {\n            InitializeComponent();\n            UpdateTexts();\n            Icon = Icon.FromHandle(Resources.ssw128.GetHicon());\n            _controller = controller;\n            _controller.ConfigChanged += controller_ConfigChanged;\n            LoadCurrentConfiguration();\n            // get all textboxes belong to this form\n            _allTextBoxes = tableLayoutPanel1.GetChildControls<TextBox>();\n            if (!_allTextBoxes.Any()) throw new Exception("Cannot get all textboxes");
            _controller = controller;\n            _controller.ConfigChanged += controller_ConfigChanged;\n            LoadCurrentConfiguration();\n            // get all textboxes belong to this form\n            _allTextBoxes = tableLayoutPanel1.GetChildControls<TextBox>();\n            if (!_allTextBoxes.Any()) throw new Exception("Cannot get all textboxes");\n        }\n        private void controller_ConfigChanged(object sender, EventArgs e)\n        {\n            LoadCurrentConfiguration();\n        }
            if (!_allTextBoxes.Any()) throw new Exception("Cannot get all textboxes");\n        }\n        private void controller_ConfigChanged(object sender, EventArgs e)\n        {\n            LoadCurrentConfiguration();\n        }\n        private void LoadCurrentConfiguration()\n        {\n            _modifiedConfig = _controller.GetConfigurationCopy().hotkey;\n            LoadConfiguration(_modifiedConfig);
        }\n        /// <summary>\n        /// Capture hotkey - Press key\n        /// </summary>\n        private void HotkeyDown(object sender, KeyEventArgs e)\n        {\n            StringBuilder sb = new StringBuilder();\n            //Combination key only\n            if (e.Modifiers != 0)\n            {\n                // XXX: Hotkey parsing depends on the sequence, more specifically, ModifierKeysConverter.\n                // Windows key is reserved by operating system, we deny this key.\n                if (e.Control)
            //Combination key only\n            if (e.Modifiers != 0)\n            {\n                // XXX: Hotkey parsing depends on the sequence, more specifically, ModifierKeysConverter.\n                // Windows key is reserved by operating system, we deny this key.\n                if (e.Control)\n                {
            if (content.Length >= 1 && content[content.Length - 1] == '+')\n            {\n                tb.Text = "";\n            }\n        }\n        private void TextBox_TextChanged(object sender, EventArgs e)\n        {\n            var tb = (TextBox) sender;\n            if (tb.Text == "")\n            {
            if (tb.Text == "")\n            {\n                // unreg\n                UnregHotkey(tb);\n            }\n        }\n        private void UnregHotkey(TextBox tb)\n        {\n            HotKeys.HotKeyCallBackHandler callBack;\n            Label lb;\n            PrepareForHotkey(tb, out callBack, out lb);
        }\n        private void CancelButton_Click(object sender, EventArgs e)\n        {\n            Close();\n        }\n        private void OKButton_Click(object sender, EventArgs e)\n        {\n            // try to register, notify to change settings if failed\n            foreach (var tb in _allTextBoxes)\n            {
        }\n        private void OKButton_Click(object sender, EventArgs e)\n        {\n            // try to register, notify to change settings if failed\n            foreach (var tb in _allTextBoxes)\n            {\n                if (tb.Text.IsNullOrEmpty())\n                {\n                    continue;\n                }
                        Logging.Info("controller stopped");\n                    }\n                    Logging.Info("os suspend");\n                    break;\n            }\n        }\n        private static void Timer_Elapsed(object sender, System.Timers.ElapsedEventArgs e)\n        {\n            try\n            {
                    Logging.Info("controller started");\n                }\n            }\n            catch (Exception ex)\n            {\n                Logging.LogUsefulException(ex);\n            }\n            finally\n            {\n                try
            }\n        }\n    }\n}
            }\n            catch (IOException)\n            {\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine(e.ToString());\n            }\n            LoadLibrary(dllPath);\n        }
            Logging.Info($"Proxy {proxy.ProxyEndPoint} timed out");\n            proxy.Close();\n            RetryConnect();\n        }\n        private void ProxyConnectCallback(IAsyncResult ar)\n        {\n            Server server = null;\n            if (_closed)\n            {\n                return;
            IStrategy strategy = controller.GetCurrentStrategy();\n            strategy?.SetFailure(server);\n            Logging.Info($"{server.FriendlyName()} timed out");\n            session.Remote.Close();\n            RetryConnect();\n        }\n        private void RetryConnect()\n        {\n            if (_retryCount < MaxRetry)\n            {
        {\n            public bool IsCompleted { get; } = true;\n            public WaitHandle AsyncWaitHandle { get; } = null;\n            public object AsyncState { get; set; }\n            public bool CompletedSynchronously { get; } = true;\n            public TcpUserToken UserToken { get; set; }\n            ~AutoReleaseAsyncResult()\n            {\n                UserToken.Dispose();\n            }
            public TcpUserToken(AsyncCallback callback, object state, SocketAsyncEventArgs args)\n            {\n                Callback = callback;\n                AsyncState = state;\n                Args = args;\n            }\n            public void Dispose()\n            {\n                Args?.Dispose();\n                Callback = null;
        }\n        private static void OnTcpConnectCompleted(object sender, SocketAsyncEventArgs args)\n        {\n            args.Completed -= OnTcpConnectCompleted;\n            TcpUserToken token = (TcpUserToken) args.UserToken;\n            AutoReleaseAsyncResult r = new AutoReleaseAsyncResult\n            {\n                AsyncState = token.AsyncState,\n                UserToken = token\n            };
        }\n        public static void BeginConnectTcp(EndPoint endPoint, AsyncCallback callback, object state)\n        {\n            var arg = new SocketAsyncEventArgs();\n            arg.RemoteEndPoint = endPoint;\n            arg.Completed += OnTcpConnectCompleted;\n            arg.UserToken = new TcpUserToken(callback, state, arg);\n            Socket.ConnectAsync(SocketType.Stream, ProtocolType.Tcp, arg);\n        }\n        public static Socket EndConnectTcp(IAsyncResult asyncResult)
            {\n                throw new ArgumentException("Invalid asyncResult.", nameof(asyncResult));\n            }\n            var tut = r.UserToken;\n            var arg = tut.Args;\n            if (arg.SocketError != SocketError.Success)\n            {\n                if (arg.ConnectByNameError != null)\n                {\n                    throw arg.ConnectByNameError;
            this.panel2 = new System.Windows.Forms.Panel();\n            this.OKButton = new System.Windows.Forms.Button();\n            this.MyCancelButton = new System.Windows.Forms.Button();\n            this.panel1 = new System.Windows.Forms.Panel();
            this.panel3 = new System.Windows.Forms.Panel();\n            this.DeleteButton = new System.Windows.Forms.Button();\n            this.AddButton = new System.Windows.Forms.Button();\n            this.ServerGroupBox = new System.Windows.Forms.GroupBox();\n            this.ServersListBox = new System.Windows.Forms.ListBox();\n            this.tableLayoutPanel1.SuspendLayout();\n            this.panel1.SuspendLayout();\n            this.panel3.SuspendLayout();\n            this.ServerGroupBox.SuspendLayout();
            this.tableLayoutPanel1.SuspendLayout();\n            this.panel1.SuspendLayout();\n            this.panel3.SuspendLayout();\n            this.ServerGroupBox.SuspendLayout();\n            this.SuspendLayout();\n            // \n            // tableLayoutPanel1\n            // \n            this.tableLayoutPanel1.AutoSize = true;\n            this.tableLayoutPanel1.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;
            this.tableLayoutPanel1.Name = "tableLayoutPanel1";\n            this.tableLayoutPanel1.Padding = new System.Windows.Forms.Padding(5);\n            this.tableLayoutPanel1.RowCount = 6;\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.Size = new System.Drawing.Size(242, 167);
            this.tableLayoutPanel1.RowCount = 6;\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.Size = new System.Drawing.Size(242, 167);\n            this.tableLayoutPanel1.TabIndex = 0;\n            // 
        private System.Windows.Forms.Label label5;\n        private System.Windows.Forms.ComboBox EncryptionSelect;\n        private System.Windows.Forms.Panel panel2;\n        private System.Windows.Forms.Button OKButton;\n        private System.Windows.Forms.Button MyCancelButton;\n        private System.Windows.Forms.Panel panel1;
        private System.Windows.Forms.Panel panel3;\n        private System.Windows.Forms.Button DeleteButton;\n        private System.Windows.Forms.Button AddButton;\n        private System.Windows.Forms.GroupBox ServerGroupBox;\n        private System.Windows.Forms.ListBox ServersListBox;\n        private System.Windows.Forms.TextBox RemarksTextBox;\n        private System.Windows.Forms.Label label6;
        private System.Windows.Forms.TextBox RemarksTextBox;\n        private System.Windows.Forms.Label label6;\n    }\n}
    }\n}
            this.controller = controller;\n            controller.ConfigChanged += controller_ConfigChanged;\n            LoadCurrentConfiguration();
            controller.ConfigChanged += controller_ConfigChanged;\n            LoadCurrentConfiguration();
            LoadCurrentConfiguration();
        }\n        private void controller_ConfigChanged(object sender, EventArgs e)\n        {\n            LoadCurrentConfiguration();
        }\n        void notifyIcon1_BalloonTipClicked(object sender, EventArgs e)\n        {\n            Process.Start(updateChecker.LatestVersionURL);\n        }\n        private void ShowWindow()\n        {\n            this.Opacity = 1;\n            this.Show();\n            IPTextBox.Focus();
        }\n        private void ConfigForm_Load(object sender, EventArgs e)\n        {
        }\n        private void ServersListBox_SelectedIndexChanged(object sender, EventArgs e)\n        {\n            if (_oldSelectedIndex == ServersListBox.SelectedIndex)\n            {\n                // we are moving back to oldSelectedIndex or doing a force move\n                return;\n            }\n            if (!SaveOldSelectedServer())\n            {
        }\n        private void CancelButton_Click(object sender, EventArgs e)\n        {\n            this.Close();
        }\n        private void ConfigForm_Shown(object sender, EventArgs e)\n        {\n            IPTextBox.Focus();\n        }\n        private void ConfigForm_FormClosed(object sender, FormClosedEventArgs e)\n        {\n            controller.ConfigChanged -= controller_ConfigChanged;
        {\n            controller.ConfigChanged -= controller_ConfigChanged;\n        }
        }\n    }\n}
    }\n}
                Socket conn = listener.EndAccept(ar);\n                conn.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n                Handler handler = new Handler();\n                handler.connection = conn;\n                handler.encryptor = EncryptorFactory.GetEncryptor(_server.method, _server.password);\n                handler.config = _server;\n                handler.Start();
                Handler handler = new Handler();\n                handler.connection = conn;\n                handler.encryptor = EncryptorFactory.GetEncryptor(_server.method, _server.password);\n                handler.config = _server;\n                handler.Start();\n            }\n            catch\n            {\n                //Console.WriteLine(e.Message);\n            }\n            finally
                Socket conn = listener.EndAccept(ar);\n                byte[] buf = new byte[2048];\n                object[] state = new object[] {\n                    conn,\n                    buf\n                };\n                conn.BeginReceive(buf, 0, 1024, 0,
                byte[] buf = new byte[2048];\n                object[] state = new object[] {\n                    conn,\n                    buf\n                };\n                conn.BeginReceive(buf, 0, 1024, 0,\n                    new AsyncCallback(ReceiveCallback), state);\n            }\n            catch (ObjectDisposedException)\n            {
            this.DeleteButton = new System.Windows.Forms.Button();\n            this.AddButton = new System.Windows.Forms.Button();\n            this.ServerGroupBox = new System.Windows.Forms.GroupBox();\n            this.ServersListBox = new System.Windows.Forms.ListBox();\n            this.tableLayoutPanel2 = new System.Windows.Forms.TableLayoutPanel();\n            this.tableLayoutPanel3 = new System.Windows.Forms.TableLayoutPanel();\n            this.tableLayoutPanel4 = new System.Windows.Forms.TableLayoutPanel();\n            this.tableLayoutPanel1.SuspendLayout();
            this.ServerGroupBox.SuspendLayout();\n            this.tableLayoutPanel2.SuspendLayout();\n            this.tableLayoutPanel3.SuspendLayout();\n            this.tableLayoutPanel4.SuspendLayout();\n            this.SuspendLayout();\n            // \n            // tableLayoutPanel1\n            // \n            this.tableLayoutPanel1.AutoSize = true;\n            this.tableLayoutPanel1.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;
            this.OKButton.Name = "OKButton";\n            this.OKButton.Size = new System.Drawing.Size(75, 23);\n            this.OKButton.TabIndex = 8;\n            this.OKButton.Text = "OK";\n            this.OKButton.UseVisualStyleBackColor = true;\n            this.OKButton.Click += new System.EventHandler(this.OKButton_Click);\n            // \n            // MyCancelButton\n            // \n            this.MyCancelButton.DialogResult = System.Windows.Forms.DialogResult.Cancel;\n            this.MyCancelButton.Dock = System.Windows.Forms.DockStyle.Right;\n            this.MyCancelButton.Location = new System.Drawing.Point(84, 3);\n            this.MyCancelButton.Margin = new System.Windows.Forms.Padding(3, 3, 0, 0);
            this.MyCancelButton.Name = "MyCancelButton";\n            this.MyCancelButton.Size = new System.Drawing.Size(75, 23);\n            this.MyCancelButton.TabIndex = 9;\n            this.MyCancelButton.Text = "Cancel";\n            this.MyCancelButton.UseVisualStyleBackColor = true;\n            this.MyCancelButton.Click += new System.EventHandler(this.CancelButton_Click);\n            // 
            // DeleteButton\n            // \n            this.DeleteButton.Dock = System.Windows.Forms.DockStyle.Right;\n            this.DeleteButton.Location = new System.Drawing.Point(86, 6);\n            this.DeleteButton.Margin = new System.Windows.Forms.Padding(3, 6, 0, 3);\n            this.DeleteButton.Name = "DeleteButton";\n            this.AddButton.Dock = System.Windows.Forms.DockStyle.Left;
            this.DeleteButton.Name = "DeleteButton";\n            this.AddButton.Dock = System.Windows.Forms.DockStyle.Left;\n            this.AddButton.Location = new System.Drawing.Point(0, 6);\n            this.AddButton.Margin = new System.Windows.Forms.Padding(0, 6, 3, 3);
            this.AddButton.Name = "AddButton";\n            this.ServerGroupBox.AutoSize = true;\n            this.ServerGroupBox.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;\n            this.ServerGroupBox.Controls.Add(this.tableLayoutPanel1);\n            this.ServerGroupBox.Location = new System.Drawing.Point(178, 0);
            this.ServerGroupBox.Name = "ServerGroupBox";\n            this.ServersListBox.IntegralHeight = false;\n            this.ServersListBox.Location = new System.Drawing.Point(0, 0);\n            this.ServersListBox.Margin = new System.Windows.Forms.Padding(0);
            this.ServersListBox.Name = "ServersListBox";\n            this.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;\n            this.CancelButton = this.MyCancelButton;\n            this.ClientSize = new System.Drawing.Size(574, 367);\n            this.Controls.Add(this.tableLayoutPanel2);
            this.Controls.Add(this.panel2);\n            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedSingle;\n            this.MaximizeBox = false;\n            this.MinimizeBox = false;\n            this.Name = "ConfigForm";\n            this.Padding = new System.Windows.Forms.Padding(12, 12, 12, 9);\n            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;\n            this.Text = "Edit Servers";\n            this.FormClosed += new System.Windows.Forms.FormClosedEventHandler(this.ConfigForm_FormClosed);\n            this.Load += new System.EventHandler(this.ConfigForm_Load);
            this.ServerGroupBox.ResumeLayout(false);\n            this.ServerGroupBox.PerformLayout();\n            this.tableLayoutPanel2.ResumeLayout(false);\n            this.tableLayoutPanel2.PerformLayout();\n            this.tableLayoutPanel3.ResumeLayout(false);\n            this.tableLayoutPanel4.ResumeLayout(false);\n            this.ResumeLayout(false);\n            this.PerformLayout();\n        }\n        #endregion
        private System.Windows.Forms.Button DeleteButton;\n        private System.Windows.Forms.Button AddButton;\n        private System.Windows.Forms.GroupBox ServerGroupBox;\n        private System.Windows.Forms.ListBox ServersListBox;\n        private System.Windows.Forms.TextBox RemarksTextBox;\n        private System.Windows.Forms.Label RemarksLabel;\n        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel2;\n        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel3;\n        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel4;\n    }
using System.Net.Sockets;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing Shadowsocks.ForwardProxy;\nusing Shadowsocks.Util.Sockets;\nnamespace Shadowsocks.Controller.Service\n{\n    class Http2Socks5 : Listener.Service\n    {
using Shadowsocks.Util.Sockets;\nnamespace Shadowsocks.Controller.Service\n{\n    class Http2Socks5 : Listener.Service\n    {\n        private readonly ByteSearch.SearchTarget _connectSearch =\n            new ByteSearch.SearchTarget(Encoding.UTF8.GetBytes("HTTP"));\n        private readonly int _socks5Port;\n        public Http2Socks5(int socks5Port)\n        {
                        registry.SetValue("AutoConfigURL", pacUrl);\n                    }\n                }\n                else\n                {\n                    registry.SetValue("ProxyEnable", 0);\n                    if (global)\n                    {\n                        registry.SetValue("ProxyServer", "");\n                    }
                    registry.SetValue("AutoConfigURL", "");\n                }\n                //Set AutoDetectProxy Off\n                IEAutoDetectProxy(false);\n                SystemProxy.NotifyIE();\n                //Must Notify IE first, or the connections do not chanage\n                CopyProxySettingFromLan();\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);
using System.Collections.Generic;\nusing System.Text;\nnamespace shadowsocks_csharp.Controller\n{\n    public class ShadowsocksController\n    {\n        // controller:\n        // handle user actions\n        // manipulates UI\n        // interacts with low level logic
{\n    public class ShadowsocksController\n    {\n        // controller:\n        // handle user actions\n        // manipulates UI\n        // interacts with low level logic\n        private Local local;\n        private PACServer pacServer;\n        private Config config;\n        public class PathEventArgs : EventArgs\n        {
using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.IO.Compression;\nusing System.Text;\nnamespace shadowsocks_csharp.Controller\n{\n    class PolipoRunner\n    {
{\n    class PolipoRunner\n    {\n        private Process process;
        public void Start(Config config)\n        {\n            if (process == null)\n            {\n                Process[] existingPolipo = Process.GetProcessesByName("ss_polipo");\n                foreach (Process p in existingPolipo)\n                {\n                    p.Kill();\n                    p.WaitForExit();\n                }
{\n    public class SystemProxy\n    {\n        [DllImport("wininet.dll")]\n        public static extern bool InternetSetOption(IntPtr hInternet, int dwOption, IntPtr lpBuffer, int dwBufferLength);\n        public const int INTERNET_OPTION_SETTINGS_CHANGED = 39;\n        public const int INTERNET_OPTION_REFRESH = 37;\n        static bool settingsReturn, refreshReturn;\n        public static void NotifyIE()\n        {
    {\n        [DllImport("wininet.dll")]\n        public static extern bool InternetSetOption(IntPtr hInternet, int dwOption, IntPtr lpBuffer, int dwBufferLength);\n        public const int INTERNET_OPTION_SETTINGS_CHANGED = 39;\n        public const int INTERNET_OPTION_REFRESH = 37;\n        static bool settingsReturn, refreshReturn;\n        public static void NotifyIE()\n        {\n            // These lines implement the Interface in the beginning of program \n            // They cause the OS to refresh the settings, causing IP to realy update
                }\n            }\n            else if (e is ObjectDisposedException)\n            {\n            }\n            else\n            {\n                Info(e);\n            }\n        }
            }\n        }\n    }\n    // Simply extended System.IO.StreamWriter for adding timestamp workaround\n    public class StreamWriterWithTimestamp : StreamWriter\n    {\n        public StreamWriterWithTimestamp(Stream stream) : base(stream)\n        {\n        }\n        private string GetTimestamp()
        {\n            bool Handle(byte[] firstPacket, int length, Socket socket, object state);\n            void Stop();\n        }\n        public abstract class Service : IService\n        {\n            public abstract bool Handle(byte[] firstPacket, int length, Socket socket, object state);\n            public virtual void Stop() { }\n        }\n        public class UDPState
                {\n                    if (service.Handle(state.buffer, bytesRead, _udpSocket, state))\n                    {\n                        break;\n                    }\n                }\n            }\n            catch (ObjectDisposedException)\n            {\n            }
            {\n            // requested unregister, which has no side effect\n            else if (!register)\n            {\n                UnregisterApplicationRestart();\n                Logging.Debug("Unregister restart after system reboot");\n            }\n        }
        {\n            // TODO test failures\n            WebClient http = new WebClient();\n            http.Proxy = new WebProxy(IPAddress.Loopback.ToString(), config.localPort);\n            http.DownloadStringCompleted += http_DownloadStringCompleted;\n            http.DownloadStringAsync(new Uri(UpdateURL));\n        }\n        public static int CompareVersion(string l, string r)\n        {\n            var ls = l.Split('.');\n            var rs = r.Split('.');
            http.DownloadStringCompleted += http_DownloadStringCompleted;\n            http.DownloadStringAsync(new Uri(UpdateURL));\n        }\n        public static int CompareVersion(string l, string r)\n        {\n            var ls = l.Split('.');\n            var rs = r.Split('.');\n            for (int i = 0; i < Math.Max(ls.Length, rs.Length); i++)\n            {\n                int lp = (i < ls.Length) ? int.Parse(ls[i]) : 0;
            this.tableLayoutPanel1.Controls.Add(this.ToolbarFlowLayoutPanel, 0, 0);\n            this.tableLayoutPanel1.Controls.Add(this.splitContainer1, 0, 1);\n            this.tableLayoutPanel1.Dock = System.Windows.Forms.DockStyle.Fill;\n            this.tableLayoutPanel1.Location = new System.Drawing.Point(0, 0);\n            this.tableLayoutPanel1.Name = "tableLayoutPanel1";\n            this.tableLayoutPanel1.RowCount = 2;\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());
        }\n        [DllImport("kernel32.dll")]\n        [return: MarshalAs(UnmanagedType.Bool)]\n        private static extern bool SetProcessWorkingSetSize(IntPtr process,\n            UIntPtr minimumWorkingSetSize, UIntPtr maximumWorkingSetSize);\n    }\n}
            if (dpi < 97)\n            {\n                // dpi = 96;\n                icon_baseBitmap = Resources.ss16;\n            }\n            else if (dpi < 121)\n            {\n                // dpi = 120;\n                icon_baseBitmap = Resources.ss20;\n            }\n            else\n            {
            }\n            else if (dpi < 121)\n            {\n                // dpi = 120;\n                icon_baseBitmap = Resources.ss20;\n            }\n            else\n            {\n                icon_baseBitmap = Resources.ss24;\n            }\n            Configuration config = controller.GetConfigurationCopy();
            }\n            else\n            {\n                icon_baseBitmap = Resources.ss24;\n            }\n            Configuration config = controller.GetConfigurationCopy();\n            bool enabled = config.enabled;\n            bool global = config.global;\n            icon_baseBitmap = getTrayIconByState(icon_baseBitmap, enabled, global);\n            icon_base = Icon.FromHandle(icon_baseBitmap.GetHicon());
            }\n            Configuration config = controller.GetConfigurationCopy();\n            bool enabled = config.enabled;\n            bool global = config.global;\n            icon_baseBitmap = getTrayIconByState(icon_baseBitmap, enabled, global);\n            icon_base = Icon.FromHandle(icon_baseBitmap.GetHicon());\n            targetIcon = icon_base;\n            icon_in = Icon.FromHandle(AddBitmapOverlay(icon_baseBitmap, Resources.ssIn24).GetHicon());\n            icon_out = Icon.FromHandle(AddBitmapOverlay(icon_baseBitmap, Resources.ssOut24).GetHicon());\n            icon_both = Icon.FromHandle(AddBitmapOverlay(icon_baseBitmap, Resources.ssIn24, Resources.ssOut24).GetHicon());

                {\n                    using (Graphics g = Graphics.FromImage(fullImage))
                    {\n                        g.CopyFromScreen(screen.Bounds.X,\n                                         screen.Bounds.Y,\n                                         0, 0,\n                                         fullImage.Size,\n                                         CopyPixelOperation.SourceCopy);\n                    }
                    }\n                    int maxTry = 10;\n                    for (int i = 0; i < maxTry; i++)\n                    {\n                        int marginLeft = fullImage.Width * i / 3 / maxTry;
                    {\n                        int marginLeft = fullImage.Width * i / 3 / maxTry;\n                        int marginTop = fullImage.Height * i / 3 / maxTry;\n                        Rectangle cropRect = new Rectangle(marginLeft, marginTop, fullImage.Width - marginLeft * 2, fullImage.Height - marginTop * 2);\n                        Bitmap target = new Bitmap(cropRect.Width, cropRect.Height);\n                        using (Graphics g = Graphics.FromImage(target))\n                        {
                        {\n                            g.DrawImage(fullImage, new Rectangle(0, 0, target.Width, target.Height),\n                                            cropRect,\n                                            GraphicsUnit.Pixel);\n                        }\n                        var source = new BitmapLuminanceSource(target);\n                        var bitmap = new BinaryBitmap(new HybridBinarizer(source));\n                        QRCodeReader reader = new QRCodeReader();\n                        var result = reader.decode(bitmap);
                        }\n                        var source = new BitmapLuminanceSource(target);\n                        var bitmap = new BinaryBitmap(new HybridBinarizer(source));\n                        QRCodeReader reader = new QRCodeReader();\n                        var result = reader.decode(bitmap);\n                        if (result != null)\n                        {
                        {
                    break;\n                case "rc4":\n                    rc4.Encrypt(encryptTable, buf, length);\n                    return byteArrayWith(buf, length);\n                    break;\n                default:\n                    return sslEncrypt(buf, length);\n            }\n        }\n        public byte[] Decrypt(byte[] buf, int length)
                    break;\n                default:\n                    return sslEncrypt(buf, length);\n            }\n        }\n        public byte[] Decrypt(byte[] buf, int length)\n        {\n            switch (method)\n            {\n                case "table":
                    break;\n                case "rc4":\n                    rc4.Decrypt(decryptTable, buf, length);\n                    return byteArrayWith(buf, length);\n                    break;\n                default:\n                    return sslDecrypt(buf, length);\n            }\n        }\n    }
                    break;\n                default:\n                    return sslDecrypt(buf, length);\n            }\n        }\n    }\n}
        {\n            InitializeComponent();\n            notifyIcon1.ContextMenu = contextMenu1;\n            this.controller = controller;\n            controller.EnableStatusChanged += controller_EnableStatusChanged;\n            controller.ConfigChanged += controller_ConfigChanged;\n            updateUI();\n        }\n        private void controller_ConfigChanged(object sender, EventArgs e)
            InitializeComponent();\n            notifyIcon1.ContextMenu = contextMenu1;\n            this.controller = controller;\n            controller.EnableStatusChanged += controller_EnableStatusChanged;\n            controller.ConfigChanged += controller_ConfigChanged;\n            updateUI();\n        }\n        private void controller_ConfigChanged(object sender, EventArgs e)\n        {\n            updateUI();
        }\n        private void showWindow()\n        {\n            this.Opacity = 1;\n            this.Show();\n        }\n        private void updateUI()\n        {\n            Config config = controller.GetConfig();\n            textBox1.Text = config.server;
        {\n            Config config = controller.GetConfig();\n            textBox1.Text = config.server;\n            textBox2.Text = config.server_port.ToString();\n            textBox3.Text = config.password;\n            textBox4.Text = config.local_port.ToString();\n            comboBox1.Text = config.method == null ? "aes-256-cfb" : config.method;\n            enableItem.Checked = config.enabled;\n        }\n        private void Form1_Load(object sender, EventArgs e)
        }\n        private void Form1_Load(object sender, EventArgs e)\n        {\n            if (!controller.GetConfig().isDefault)\n            {\n                this.Opacity = 0;\n                BeginInvoke(new MethodInvoker(delegate\n                {\n                    this.Hide();\n                }));
            {\n                this.Opacity = 0;\n                BeginInvoke(new MethodInvoker(delegate\n                {\n                    this.Hide();\n                }));\n            }
                {\n                    this.Hide();\n                }));\n            }
        }\n        private void Config_Click(object sender, EventArgs e)\n        {\n            showWindow();\n        }\n        private void Quit_Click(object sender, EventArgs e)\n        {\n            this.Close();\n        }\n        private void OKButton_Click(object sender, EventArgs e)
        }\n        private void Form1_FormClosed(object sender, FormClosedEventArgs e)\n        {\n            controller.Stop();
        }\n        private void aboutToolStripMenuItem_Click(object sender, EventArgs e)\n        {\n            Process.Start("https://github.com/clowwindy/shadowsocks-csharp");\n        }\n        private void notifyIcon1_DoubleClick(object sender, EventArgs e)\n        {\n            showWindow();\n        }
        private void EnableItem_Click(object sender, EventArgs e)\n        {\n            enableItem.Checked = !enableItem.Checked;\n            controller.ToggleEnable(enableItem.Checked);\n        }\n    }\n}
        }\n    }\n}
        {\n            _config.proxy.useProxy = true;\n            _config.proxy.proxyType = type;\n            _config.proxy.proxyServer = proxy;\n            _config.proxy.proxyPort = port;\n            _config.proxy.proxyTimeout = timeout;\n            SaveConfig(_config);\n        }\n        public void ToggleVerboseLogging(bool enabled)\n        {
            if (UseProxyCheckBox.Checked)\n            {\n                int port;\n                int timeout;\n                if (!int.TryParse(ProxyPortTextBox.Text, out port))
                {\n                    MessageBox.Show(I18N.GetString("Illegal port number format"));\n                    return;\n                }\n                if (!int.TryParse(ProxyTimeoutTextBox.Text, out timeout))
                    return;\n                }\n                if (!int.TryParse(ProxyTimeoutTextBox.Text, out timeout))\n                {\n                    MessageBox.Show(I18N.GetString("Illegal timeout format"));
                {\n                    MessageBox.Show(I18N.GetString("Illegal timeout format"));\n                    return;\n                }\n                var type = ProxyTypeComboBox.SelectedIndex;\n                var proxy = ProxyServerTextBox.Text;\n                try\n                {\n                    Configuration.CheckServer(proxy);
                    return;\n                }\n                var type = ProxyTypeComboBox.SelectedIndex;\n                var proxy = ProxyServerTextBox.Text;\n                try\n                {\n                    Configuration.CheckServer(proxy);\n                    Configuration.CheckPort(port);\n                    Configuration.CheckTimeout(timeout, ProxyConfig.MaxProxyTimeoutSec);\n                }
            }\n            else\n            {\n                controller.DisableProxy();\n            }
            this.Close();\n        }\n        private void CancelButton_Click(object sender, EventArgs e)\n        {\n            this.Close();\n        }\n        private void ProxyForm_FormClosed(object sender, FormClosedEventArgs e)\n        {\n            controller.ConfigChanged -= controller_ConfigChanged;\n        }
                    if (method == "CONNECT")\n                    {\n                        _isConnect = true;\n                        if (!ParseHost(m.Groups[2].Value))\n                        {\n                            throw new Exception("Bad http header: " + line);\n                        }\n                    }\n                }\n            }
                        {\n                            throw new Exception("Bad http header: " + line);\n                        }\n                    }\n                }\n            }\n            else\n            {
                if (line.IsNullOrEmpty())\n                {\n                    return true;\n                }\n                if (!_isConnect)\n                {\n                    if (line.StartsWith("Host: "))\n                    {\n                        if (!ParseHost(line.Substring(6).Trim()))\n                        {
            if (_config.availabilityStatistics)\n            {\n                availabilityStatistics.UpdateLatency(args.server, (int)args.latency.TotalMilliseconds);\n            }\n        }\n        public void UpdateInboundCounter(object sender, SSTransmitEventArgs args)\n        {\n            GetCurrentStrategy()?.UpdateLastRead(args.server);\n            Interlocked.Add(ref _inboundCounter, args.length);\n            if (_config.availabilityStatistics)
            if (_config.availabilityStatistics)\n            {\n                availabilityStatistics.UpdateInboundCounter(args.server, args.length);\n            }\n        }\n        public void UpdateOutboundCounter(object sender, SSTransmitEventArgs args)\n        {\n            GetCurrentStrategy()?.UpdateLastWrite(args.server);\n            Interlocked.Add(ref _outboundCounter, args.length);\n            if (_config.availabilityStatistics)
            if (_config.availabilityStatistics)\n            {\n                availabilityStatistics.UpdateOutboundCounter(args.server, args.length);\n            }\n        }\n        protected void Reload()\n        {\n            Encryption.RNG.Reload();\n            // some logic in configuration updated the config when saving, we need to read it again\n            _config = Configuration.Load();
            }\n        }\n        protected void Reload()\n        {\n            Encryption.RNG.Reload();\n            // some logic in configuration updated the config when saving, we need to read it again\n            _config = Configuration.Load();\n            NLogConfig.LoadConfiguration();\n            StatisticsConfiguration = StatisticsStrategyConfiguration.Load();\n            privoxyRunner = privoxyRunner ?? new PrivoxyRunner();
    }\n    public class SSRelayEventArgs : EventArgs\n    {\n        public readonly Server server;\n        public SSRelayEventArgs(Server server)\n        {\n            this.server = server;\n        }\n    }\n    public class SSTransmitEventArgs : SSRelayEventArgs
    {\n        public readonly Server server;\n        public SSRelayEventArgs(Server server)\n        {\n            this.server = server;\n        }\n    }\n    public class SSTransmitEventArgs : SSRelayEventArgs\n    {\n        public readonly long length;
    {\n        public readonly long length;\n        public SSTransmitEventArgs(Server server, long length) : base(server)\n        {\n            this.length = length;\n        }\n    }\n    public class SSTCPConnectedEventArgs : SSRelayEventArgs
        {\n            this.length = length;\n        }\n    }\n    public class SSTCPConnectedEventArgs : SSRelayEventArgs
    {\n        public readonly TimeSpan latency;\n        public SSTCPConnectedEventArgs(Server server, TimeSpan latency) : base(server)\n        {\n            this.latency = latency;
        }\n    }\n    internal class TCPHandler\n    {\n        public event EventHandler<SSTCPConnectedEventArgs> OnConnected;\n        public event EventHandler<SSTransmitEventArgs> OnInbound;\n        public event EventHandler<SSTransmitEventArgs> OnOutbound;\n        public event EventHandler<SSRelayEventArgs> OnClosed;\n        public event EventHandler<SSRelayEventArgs> OnFailed;
        class AsyncSession\n        {\n            public IProxy Remote { get; }\n            public AsyncSession(IProxy remote)\n            {\n                Remote = remote;\n            }\n        }\n        class AsyncSession<T> : AsyncSession\n        {
            _startSendingTime = DateTime.Now;\n            session.Remote.BeginSend(_connetionSendBuffer, 0, bytesToSend, SocketFlags.None,\n                PipeRemoteSendCallback, new object[] { session, bytesToSend });\n        }\n        private void PipeRemoteSendCallback(IAsyncResult ar)\n        {\n            if (_closed) return;\n            try
        }\n        private void PipeRemoteSendCallback(IAsyncResult ar)\n        {\n            if (_closed) return;\n            try\n            {\n                var container = (object[])ar.AsyncState;\n                var session = (AsyncSession)container[0];\n                var bytesShouldSend = (int)container[1];\n                int bytesSent = session.Remote.EndSend(ar);
        {\n            InitKey(method, password);\n            if (OnetimeAuth)\n            {\n                crc_buf = new byte[CRC_BUF_LEN];\n            }\n        }\n        protected abstract Dictionary<string, int[]> getCiphers();\n        protected void InitKey(string method, string password)\n        {
        }\n        [DllImport("Kernel32.dll")]\n        private static extern IntPtr LoadLibrary(string path);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void crypto_stream_salsa20_xor_ic(byte[] c, byte[] m, ulong mlen, byte[] n, ulong ic, byte[] k);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void crypto_stream_chacha20_xor_ic(byte[] c, byte[] m, ulong mlen, byte[] n, ulong ic, byte[] k);\n        [DllImport(DLLNAME2, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int ss_gen_crc(byte[] buf, ref int buf_offset, ref int data_len,\n            byte[] crc_buf, ref int crc_idx, int buf_size);
        {\n            Method = method;\n            Password = password;\n            OnetimeAuth = onetimeauth;\n        }\n        protected string Method;\n        protected string Password;\n        protected bool OnetimeAuth;\n        protected byte[] GetPasswordHash()\n        {
            this.tableLayoutPanel1.TabIndex = 0;\n            // \n            // RemarksTextBox\n            // \n            this.RemarksTextBox.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));\n            this.RemarksTextBox.Location = new System.Drawing.Point(72, 111);\n            this.RemarksTextBox.MaxLength = 32;\n            this.RemarksTextBox.Name = "RemarksTextBox";\n            this.RemarksTextBox.Size = new System.Drawing.Size(160, 20);
            this.ServerGroupBox.TabStop = false;\n            this.ServerGroupBox.Text = "Server";\n            // \n            // ServersListBox\n            // \n            this.ServersListBox.FormattingEnabled = true;\n            this.ServersListBox.IntegralHeight = false;\n            this.ServersListBox.Location = new System.Drawing.Point(0, 0);\n            this.ServersListBox.Margin = new System.Windows.Forms.Padding(0);\n            this.ServersListBox.Name = "ServersListBox";\n            this.ServersListBox.Size = new System.Drawing.Size(166, 148);
            this.ServersListBox.Location = new System.Drawing.Point(0, 0);\n            this.ServersListBox.Margin = new System.Windows.Forms.Padding(0);\n            this.ServersListBox.Name = "ServersListBox";\n            this.ServersListBox.Size = new System.Drawing.Size(166, 148);
        {\n            if (string.IsNullOrEmpty(method))\n            {\n                method = "table";\n            }\n            method = method.ToLowerInvariant();\n            Type t = _registeredEncryptors[method];\n            ConstructorInfo c = t.GetConstructor(_constructorTypes);\n            IEncryptor result = (IEncryptor)c.Invoke(new object[] { method, password, onetimeauth });\n            return result;
            return result;\n        }\n    }\n}
            this.PluginOptionsLabel.Name = "PluginOptionsLabel";\n            this.PluginTextBox.Location = new System.Drawing.Point(151, 165);\n            this.PluginTextBox.Margin = new System.Windows.Forms.Padding(4, 4, 4, 4);\n            this.PluginTextBox.MaxLength = 256;\n            this.PluginTextBox.Name = "PluginTextBox";
            this.PluginTextBox.MaxLength = 256;\n            this.PluginTextBox.Name = "PluginTextBox";\n            this.RemarksTextBox.Location = new System.Drawing.Point(151, 291);\n            this.RemarksTextBox.Margin = new System.Windows.Forms.Padding(4, 4, 4, 4);\n            this.RemarksTextBox.MaxLength = 32;\n            this.RemarksTextBox.Name = "RemarksTextBox";
            this.RemarksTextBox.MaxLength = 32;\n            this.RemarksTextBox.Name = "RemarksTextBox";\n            this.IPLabel.Location = new System.Drawing.Point(64, 13);\n            this.IPLabel.Margin = new System.Windows.Forms.Padding(4, 0, 4, 0);\n            this.IPLabel.Name = "IPLabel";
            this.IPLabel.Name = "IPLabel";\n            this.ServerPortLabel.Location = new System.Drawing.Point(48, 46);\n            this.ServerPortLabel.Margin = new System.Windows.Forms.Padding(4, 0, 4, 0);\n            this.ServerPortLabel.Name = "ServerPortLabel";
            this.ServerPortLabel.Name = "ServerPortLabel";\n            this.PasswordLabel.Location = new System.Drawing.Point(72, 79);\n            this.PasswordLabel.Margin = new System.Windows.Forms.Padding(4, 0, 4, 0);\n            this.PasswordLabel.Name = "PasswordLabel";
            this.PasswordLabel.Name = "PasswordLabel";\n            this.IPTextBox.Location = new System.Drawing.Point(151, 8);\n            this.IPTextBox.Margin = new System.Windows.Forms.Padding(4, 4, 4, 4);\n            this.IPTextBox.MaxLength = 512;\n            this.IPTextBox.Name = "IPTextBox";
            this.IPTextBox.MaxLength = 512;\n            this.IPTextBox.Name = "IPTextBox";\n            this.ServerPortTextBox.Location = new System.Drawing.Point(151, 41);\n            this.ServerPortTextBox.Margin = new System.Windows.Forms.Padding(4, 4, 4, 4);\n            this.ServerPortTextBox.MaxLength = 10;\n            this.ServerPortTextBox.Name = "ServerPortTextBox";
            this.ServerPortTextBox.MaxLength = 10;\n            this.ServerPortTextBox.Name = "ServerPortTextBox";\n            this.PasswordTextBox.Location = new System.Drawing.Point(151, 74);\n            this.PasswordTextBox.Margin = new System.Windows.Forms.Padding(4, 4, 4, 4);\n            this.PasswordTextBox.MaxLength = 256;\n            this.PasswordTextBox.Name = "PasswordTextBox";
            this.PasswordTextBox.MaxLength = 256;\n            this.PasswordTextBox.Name = "PasswordTextBox";\n            this.EncryptionLabel.Location = new System.Drawing.Point(56, 138);\n            this.EncryptionLabel.Margin = new System.Windows.Forms.Padding(4, 0, 4, 0);
            this.EncryptionLabel.Name = "EncryptionLabel";\n            this.EncryptionSelect.ItemHeight = 15;
            this.EncryptionSelect.Name = "EncryptionSelect";\n            this.TimeoutLabel.Location = new System.Drawing.Point(40, 329);\n            this.TimeoutLabel.Margin = new System.Windows.Forms.Padding(4, 0, 4, 0);\n            this.TimeoutLabel.Name = "TimeoutLabel";\n            this.TimeoutLabel.RightToLeft = System.Windows.Forms.RightToLeft.No;
            this.TimeoutLabel.Name = "TimeoutLabel";\n            this.TimeoutLabel.RightToLeft = System.Windows.Forms.RightToLeft.No;\n            this.TimeoutTextBox.Location = new System.Drawing.Point(151, 324);\n            this.TimeoutTextBox.Margin = new System.Windows.Forms.Padding(4, 4, 4, 4);\n            this.TimeoutTextBox.MaxLength = 5;\n            this.TimeoutTextBox.Name = "TimeoutTextBox";
            this.TimeoutTextBox.MaxLength = 5;\n            this.TimeoutTextBox.Name = "TimeoutTextBox";\n            this.PluginLabel.Location = new System.Drawing.Point(24, 170);\n            this.PluginLabel.Margin = new System.Windows.Forms.Padding(4, 0, 4, 0);\n            this.PluginLabel.Name = "PluginLabel";
            this.PluginLabel.Name = "PluginLabel";\n            this.PluginOptionsTextBox.Location = new System.Drawing.Point(151, 198);\n            this.PluginOptionsTextBox.Margin = new System.Windows.Forms.Padding(4, 4, 4, 4);\n            this.PluginOptionsTextBox.MaxLength = 256;\n            this.PluginOptionsTextBox.Name = "PluginOptionsTextBox";
            this.PluginOptionsTextBox.MaxLength = 256;\n            this.PluginOptionsTextBox.Name = "PluginOptionsTextBox";\n            this.ShowPasswdCheckBox.Location = new System.Drawing.Point(151, 107);\n            this.ShowPasswdCheckBox.Margin = new System.Windows.Forms.Padding(4, 4, 4, 4);
            this.ShowPasswdCheckBox.Name = "ShowPasswdCheckBox";\n            this.PluginArgumentsTextBox.Location = new System.Drawing.Point(151, 258);\n            this.PluginArgumentsTextBox.Margin = new System.Windows.Forms.Padding(4, 4, 4, 4);
            this.PluginArgumentsTextBox.MaxLength = 512;\n            this.PluginArgumentsTextBox.Name = "PluginArgumentsTextBox";\n            this.PluginArgumentsLabel.Location = new System.Drawing.Point(8, 263);\n            this.PluginArgumentsLabel.Margin = new System.Windows.Forms.Padding(4, 0, 4, 0);\n            this.PluginArgumentsLabel.Name = "PluginArgumentsLabel";
            this.PluginArgumentsLabel.Name = "PluginArgumentsLabel";\n            this.RemarksLabel.Location = new System.Drawing.Point(80, 296);\n            this.RemarksLabel.Margin = new System.Windows.Forms.Padding(4, 0, 4, 0);
            this.RemarksLabel.Name = "RemarksLabel";\n            this.NeedPluginArgCheckBox.Location = new System.Drawing.Point(151, 231);\n            this.NeedPluginArgCheckBox.Margin = new System.Windows.Forms.Padding(4, 4, 4, 4);\n            this.NeedPluginArgCheckBox.Name = "NeedPluginArgCheckBox";
            this.NeedPluginArgCheckBox.Name = "NeedPluginArgCheckBox";\n            this.panel2.Location = new System.Drawing.Point(206, 234);
            this.panel2.Name = "panel2";\n            this.panel2.Size = new System.Drawing.Size(0, 0);\n            this.panel2.TabIndex = 1;\n            // \n            // OKButton\n            // \n            this.OKButton.DialogResult = System.Windows.Forms.DialogResult.OK;\n            this.OKButton.Dock = System.Windows.Forms.DockStyle.Right;
            this.tableLayoutPanel5.RowCount = 2;\n            this.tableLayoutPanel5.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel5.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.ProxyPortTextBox.Location = new System.Drawing.Point(103, 8);\n            this.ProxyPortTextBox.Margin = new System.Windows.Forms.Padding(4, 4, 4, 4);\n            this.ProxyPortTextBox.MaxLength = 10;\n            this.ProxyPortTextBox.Name = "ProxyPortTextBox";
            this.ProxyPortTextBox.MaxLength = 10;\n            this.ProxyPortTextBox.Name = "ProxyPortTextBox";\n            this.ProxyPortLabel.Location = new System.Drawing.Point(8, 13);\n            this.ProxyPortLabel.Margin = new System.Windows.Forms.Padding(4, 0, 4, 0);\n            this.ProxyPortLabel.Name = "ProxyPortLabel";
            this.ProxyPortLabel.Name = "ProxyPortLabel";\n            this.PortableModeCheckBox.Location = new System.Drawing.Point(8, 48);\n            this.PortableModeCheckBox.Margin = new System.Windows.Forms.Padding(4, 4, 4, 4);\n            this.PortableModeCheckBox.Name = "PortableModeCheckBox";
            this.PortableModeCheckBox.Name = "PortableModeCheckBox";
using GlobalHotKey;\nusing System.Windows.Input;\nusing System.Threading;\nusing System.Collections.Generic;\nusing Shadowsocks.Controller.Hotkeys;\nusing System.Diagnostics;\nnamespace Shadowsocks.Test
using System.Diagnostics;\nnamespace Shadowsocks.Test\n{\n    [TestClass]\n    public class UnitTest\n    {\n        [TestMethod]\n        public void TestCompareVersion()
{\n    [TestClass]\n    public class UnitTest\n    {\n        [TestMethod]\n        public void TestCompareVersion()\n        {\n            Assert.IsTrue(UpdateChecker.Asset.CompareVersion("2.3.1.0", "2.3.1") == 0);\n            Assert.IsTrue(UpdateChecker.Asset.CompareVersion("1.2", "1.3") < 0);\n            Assert.IsTrue(UpdateChecker.Asset.CompareVersion("1.3", "1.2") > 0);
        {\n            try\n            {\n                IPEndPoint localEndPoint = (IPEndPoint)socket.LocalEndPoint;\n                string proxy = GetPACAddress(localEndPoint, useSocks);\n                string pacContent = GetPACContent().Replace("__PROXY__", proxy);\n                string responseHead = String.Format(@"HTTP/1.1 200 OK\nServer: Shadowsocks\nContent-Type: application/x-ns-proxy-autoconfig
                IPEndPoint localEndPoint = (IPEndPoint)socket.LocalEndPoint;\n                string proxy = GetPACAddress(localEndPoint, useSocks);\n                string pacContent = GetPACContent().Replace("__PROXY__", proxy);\n                string responseHead = String.Format(@"HTTP/1.1 200 OK\nServer: Shadowsocks\nContent-Type: application/x-ns-proxy-autoconfig\nContent-Length: {0}\nConnection: Close\n", Encoding.UTF8.GetBytes(pacContent).Length);\n                byte[] response = Encoding.UTF8.GetBytes(responseHead + pacContent);
Server: Shadowsocks\nContent-Type: application/x-ns-proxy-autoconfig\nContent-Length: {0}\nConnection: Close\n", Encoding.UTF8.GetBytes(pacContent).Length);\n                byte[] response = Encoding.UTF8.GetBytes(responseHead + pacContent);\n                socket.BeginSend(response, 0, response.Length, 0, new AsyncCallback(SendCallback), socket);\n                Utils.ReleaseMemory(true);\n            }\n            catch (Exception e)
                socket.BeginSend(response, 0, response.Length, 0, new AsyncCallback(SendCallback), socket);\n                Utils.ReleaseMemory(true);\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                socket.Close();\n            }\n        }\n        private void SendCallback(IAsyncResult ar)
                }\n                catch (IOException e)\n                {\n                    Console.WriteLine(e.ToString());\n                }\n                LoadLibrary(dllPath);\n#if !DEBUG\n                Logging.OpenLogFile();\n#endif\n                Application.EnableVisualStyles();
    {\n        // A value in INTERNET_OPTION_PER_CONN_FLAGS.\n        [FieldOffset(0)]\n        public int dwValue;\n        [FieldOffset(0)]\n        public System.IntPtr pszValue;\n        [FieldOffset(0)]\n        public System.Runtime.InteropServices.ComTypes.FILETIME ftValue;\n        public void Dispose()\n        {\n            Dispose(true);
    {\n        public int Size;\n        // The connection to be set. NULL means LAN.\n        public System.IntPtr Connection;\n        public int OptionCount;\n        public int OptionError;\n        // List of INTERNET_PER_CONN_OPTIONs.\n        public System.IntPtr pOptions;\n        public void Dispose()\n        {\n            Dispose( true );\n            GC.SuppressFinalize( this );
                return true;\n            }\n            catch (IOException e)\n            {\n                Console.WriteLine(e.ToString());\n                return false;\n            }\n        }
        private static void WriteToLogFile(object o)\n        {\n            Console.WriteLine(o);\n        }\n        public static void Error(object o)\n        {\n            WriteToLogFile("[E] " + o);\n        }
            Console.WriteLine(o);\n        }\n        public static void Error(object o)\n        {\n            WriteToLogFile("[E] " + o);\n        }\n        public static void Info(object o)\n        {\n            WriteToLogFile(o);\n        }
        // this is a copy of configuration that we are working on\n        private Configuration _modifiedConfiguration;\n        private int _oldSelectedIndex = -1;\n        public ConfigForm(ShadowsocksController controller)\n        {\n            InitializeComponent();\n            this.Icon = Icon.FromHandle(Resources.ssw128.GetHicon());\n            this.controller = controller;\n            controller.ConfigChanged += controller_ConfigChanged;\n            LoadCurrentConfiguration();
        public ConfigForm(ShadowsocksController controller)\n        {\n            InitializeComponent();\n            this.Icon = Icon.FromHandle(Resources.ssw128.GetHicon());\n            this.controller = controller;\n            controller.ConfigChanged += controller_ConfigChanged;\n            LoadCurrentConfiguration();\n        }\n        private void controller_ConfigChanged(object sender, EventArgs e)\n        {
        private static readonly ConcurrentDictionary<string, byte[]> CachedKeys = new ConcurrentDictionary<string, byte[]>();\n        protected byte[] _encryptIV;\n        protected byte[] _decryptIV;\n        protected bool _decryptIVReceived;\n        protected bool _encryptIVSent;\n        protected string _method;\n        protected int _cipher;\n        // cipher name in MbedTLS, useless when using LibSodium\n        protected string _cipherMbedName;\n        protected EncryptorInfo _cipherInfo;\n        protected byte[] _key;
        protected byte[] _key;\n        protected int keyLen;\n        protected int ivLen;\n        public IVEncryptor(string method, string password, bool onetimeauth, bool isudp)\n            : base(method, password, onetimeauth, isudp)\n        {\n            InitKey(method, password);\n        }\n        protected abstract Dictionary<string, EncryptorInfo> getCiphers();\n        private void InitKey(string method, string password)
        private void InitKey(string method, string password)\n        {\n            method = method.ToLower();\n            _method = method;\n            string k = method + ":" + password;\n            ciphers = getCiphers();\n            _cipherInfo = ciphers[_method];\n            _cipherMbedName = _cipherInfo.name;\n            _cipher = _cipherInfo.type;
            if (_cipher == 0)\n            {\n                throw new Exception("method not found");\n            }\n            keyLen = _cipherInfo.key_size;\n            ivLen = _cipherInfo.iv_size;\n            _key = CachedKeys.GetOrAdd(k, (nk) =>\n            {\n                byte[] passbuf = Encoding.UTF8.GetBytes(password);\n                byte[] key = new byte[32];
            _key = CachedKeys.GetOrAdd(k, (nk) =>\n            {\n                byte[] passbuf = Encoding.UTF8.GetBytes(password);\n                byte[] key = new byte[32];\n                bytesToKey(passbuf, key);\n                return key;\n            });\n        }\n        protected void bytesToKey(byte[] password, byte[] key)\n        {
        };\n        public static List<string> SupportedCiphers()\n        {\n            return new List<string>(_ciphers.Keys);\n        }\n        protected override Dictionary<string, EncryptorInfo> getCiphers()\n        {\n            return _ciphers;\n        }\n        protected override void initCipher(byte[] iv, bool isCipher)
        {\n            return _ciphers;\n        }\n        protected override void initCipher(byte[] iv, bool isCipher)\n        {\n            base.initCipher(iv, isCipher);\n            IntPtr ctx = Marshal.AllocHGlobal(MbedTLS.cipher_get_size_ex());\n            if (isCipher)\n            {\n                _encryptCtx = ctx;
        };\n        protected override Dictionary<string, EncryptorInfo> getCiphers()\n        {\n            return _ciphers;\n        }\n        public static List<string> SupportedCiphers()\n        {\n            return new List<string>(_ciphers.Keys);\n        }\n        protected override void cipherUpdate(bool isCipher, int length, byte[] buf, byte[] outbuf)
        {\n            return _ciphers;\n        }\n        public static List<string> SupportedCiphers()\n        {\n            return new List<string>(_ciphers.Keys);\n        }\n        protected override void cipherUpdate(bool isCipher, int length, byte[] buf, byte[] outbuf)\n        {\n            // TODO write a unidirection cipher so we don't have to if if if
        }\n        #endregion\n        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel1;\n        private System.Windows.Forms.Label label1;\n        private System.Windows.Forms.Label label2;\n        private System.Windows.Forms.Label label3;\n        private System.Windows.Forms.Label label4;\n        private System.Windows.Forms.TextBox textBox1;\n        private System.Windows.Forms.TextBox textBox2;\n        private System.Windows.Forms.TextBox textBox3;\n        private System.Windows.Forms.TextBox textBox4;
        protected static byte[] tempbuf = new byte[MAX_INPUT_SIZE];\n        protected Dictionary<string, int[]> ciphers;\n        private static readonly Dictionary<string, byte[]> CachedKeys = new Dictionary<string, byte[]>();\n        protected byte[] _encryptIV;\n        protected byte[] _decryptIV;\n        protected bool _decryptIVReceived;\n        protected bool _encryptIVSent;\n        protected int _encryptIVOffset = 0;\n        protected int _decryptIVOffset = 0;\n        protected string _method;
        public IVEncryptor(string method, string password, bool onetimeauth)\n            : base(method, password, onetimeauth)\n        {\n            InitKey(method, password);\n            if (OnetimeAuth)\n            {\n                hash_buf = new byte[HASH_BUF_LEN];\n            }\n        }\n        protected abstract Dictionary<string, int[]> getCiphers();
            }\n        }\n        protected abstract Dictionary<string, int[]> getCiphers();\n        protected void InitKey(string method, string password)\n        {\n            method = method.ToLower();\n            _method = method;\n            string k = method + ":" + password;\n            ciphers = getCiphers();\n            _cipherInfo = ciphers[_method];
                        {\n                            int headLen = ss_headlen(buf, length);\n                            int data_len = length - headLen;\n                            Buffer.BlockCopy(buf, headLen, buf, headLen + ONETIMEAUTH_BYTES, data_len);\n                            buf[0] |= ONETIMEAUTH_FLAG;\n                            byte[] auth = new byte[ONETIMEAUTH_BYTES];\n                            ss_onetimeauth(auth, buf, headLen, _encryptIV, ivLen, _key, keyLen);\n                            Buffer.BlockCopy(auth, 0, buf, headLen, ONETIMEAUTH_BYTES);\n                            int buf_offset = headLen + ONETIMEAUTH_BYTES;\n                            ss_gen_hash(buf, ref buf_offset, ref data_len, hash_buf, ref hash_idx, buf.Length);
                            int data_len = length - headLen;\n                            Buffer.BlockCopy(buf, headLen, buf, headLen + ONETIMEAUTH_BYTES, data_len);\n                            buf[0] |= ONETIMEAUTH_FLAG;\n                            byte[] auth = new byte[ONETIMEAUTH_BYTES];\n                            ss_onetimeauth(auth, buf, headLen, _encryptIV, ivLen, _key, keyLen);\n                            Buffer.BlockCopy(auth, 0, buf, headLen, ONETIMEAUTH_BYTES);\n                            int buf_offset = headLen + ONETIMEAUTH_BYTES;\n                            ss_gen_hash(buf, ref buf_offset, ref data_len, hash_buf, ref hash_idx, buf.Length);
                            Buffer.BlockCopy(auth, 0, buf, headLen, ONETIMEAUTH_BYTES);\n                            int buf_offset = headLen + ONETIMEAUTH_BYTES;\n                            ss_gen_hash(buf, ref buf_offset, ref data_len, hash_buf, ref hash_idx, buf.Length);\n                            length = headLen + ONETIMEAUTH_BYTES + data_len;\n                        }\n                    }\n                    cipherUpdate(true, length, buf, tempbuf);
                            length = headLen + ONETIMEAUTH_BYTES + data_len;\n                        }\n                    }\n                    cipherUpdate(true, length, buf, tempbuf);\n                    outlength = length + ivLen;\n                    Buffer.BlockCopy(tempbuf, 0, outbuf, ivLen, length);\n                }\n            }\n            else\n            {
                    {\n                        int buf_offset = 0;\n                        ss_gen_hash(buf, ref buf_offset, ref length, hash_buf, ref hash_idx, buf.Length);\n                    }\n                }\n                outlength = length;\n                cipherUpdate(true, length, buf, outbuf);
                    }\n                }\n                outlength = length;\n                cipherUpdate(true, length, buf, outbuf);\n            }\n        }\n        public override void Decrypt(byte[] buf, int length, byte[] outbuf, out int outlength)\n        {\n            if (!_decryptIVReceived)\n            {
        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int crypto_onetimeauth(byte[] outbuf, byte[] inbuf, ulong inlen, byte[] k);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int crypto_onetimeauth_verify(byte[] h, byte[] inbuf, ulong inlen, byte[] k);\n    }\n}
    }\n}
private void autoStartup_Click(object sender, EventArgs e) {\nautoStartup.Checked = !autoStartup.Checked;\nif (!AutoStartup.Set(autoStartup.Checked)) {\nMessageBox.Show("Failed to edit registry");\n}\n}\nprivate void contextMenu1_Popup(object sender, EventArgs e) {\nautoStartup.Checked = AutoStartup.Check();\n}\n    }
}\n}\nprivate void contextMenu1_Popup(object sender, EventArgs e) {\nautoStartup.Checked = AutoStartup.Check();\n}\n    }\n}
}\n    }\n}
            using (Graphics g = Graphics.FromImage(drawArea))\n            {\n                g.Clear(Color.White);\n                using (Brush b = new SolidBrush(Color.Black))\n                {\n                    for (int row = 0; row < m.Width; row++)\n                    {\n                        for (int col = 0; col < m.Height; col++)\n                        {\n                            if (m[row, col] != 0)
         // Determine what character encoding has been specified by the caller, if any\n#if !SILVERLIGHT || WINDOWS_PHONE\n         String encoding = DEFAULT_BYTE_MODE_ENCODING;\n         //bool generateECI = !DEFAULT_BYTE_MODE_ENCODING.Equals(encoding);\n#else\n         // Silverlight supports only UTF-8 and UTF-16 out-of-the-box\n         const string encoding = "UTF-8";\n         Mode mode = Mode.BYTE;
#else\n         // Silverlight supports only UTF-8 and UTF-16 out-of-the-box\n         const string encoding = "UTF-8";\n         // caller of the method can only control if the ECI segment should be written\n         // character set is fixed to UTF-8; but some scanners doesn't like the ECI segment\n         bool generateECI = (hints != null && hints.ContainsKey(EncodeHintType.CHARACTER_SET));\n#endif\n         // Pick an encoding mode appropriate for the content. Note that this will not attempt to use\n         // multiple modes / segments even if that were more efficient. Twould be nice.\n         Mode mode = Mode.BYTE;\n         // This will store the header information, like mode and\n         // length, as well as "header" segments like an ECI segment.\n         BitArray headerBits = new BitArray();\n         /*\n          // Append ECI segment if applicable\n         if (mode == Mode.BYTE && generateECI)\n         {
         // This will store the header information, like mode and\n         // length, as well as "header" segments like an ECI segment.\n         BitArray headerBits = new BitArray();\n         /*\n          // Append ECI segment if applicable\n         if (mode == Mode.BYTE && generateECI)\n         {\n            CharacterSetECI eci = CharacterSetECI.getCharacterSetECIByName(encoding);\n            if (eci != null)\n            {
               if (mode.Equals(Mode.BYTE))\n                  append8BitBytes(content, bits, encoding);\n                  else\n                      throw new Exception("Invalid mode: " + mode);
                  else\n                      throw new Exception("Invalid mode: " + mode);
      }\n      internal static void append8BitBytes(String content, BitArray bits, String encoding)\n      {\n         byte[] bytes;\n         try\n         {\n            bytes = Encoding.GetEncoding(encoding).GetBytes(content);\n         }\n#if WindowsCE\n         catch (PlatformNotSupportedException)
      /// <summary>\n      /// Gets the version for number.\n      /// </summary>\n      /// <param name="versionNumber">The version number.</param>\n      /// <returns></returns>\n      public static Version getVersionForNumber(int versionNumber)\n      {\n         if (versionNumber < 1 || versionNumber > 40)\n         {\n            throw new ArgumentException();
      }\n      /// <summary> <p>Encapsulates a set of error-correction blocks in one symbol version. Most versions will\n      /// use blocks of differing sizes within one version, so, this encapsulates the parameters for\n      /// each set of blocks. It also holds the number of error-correction codewords per block since it\n      /// will be the same across all blocks within one version.</p>\n      /// </summary>\n      public sealed class ECBlocks\n      {\n         private readonly int ecCodewordsPerBlock;\n         private readonly ECB[] ecBlocks;
      /// Gets the generator base.\n      /// </summary>\n      public int GeneratorBase\n      {\n         get { return generatorBase; }\n      }\n   }\n}
   }\n}
      }\n      public BitArray()\n      {\n         this.size = 0;\n         this.bits = new int[1];
      }\n      private void ensureCapacity(int size)\n      {\n         if (size > bits.Length << 5)\n         {\n            int[] newBits = makeArray(size);\n            System.Array.Copy(bits, 0, newBits, 0, bits.Length);\n            bits = newBits;\n         }
      private static int[] makeArray(int size)\n      {\n         return new int[(size + 31) >> 5];\n      }
   }\n}
            }\n            else\n            {\n                logForm = new LogForm(controller, Logging.LogFilePath);\n                logForm.Show();\n                logForm.Activate();\n                logForm.FormClosed += logForm_FormClosed;
            }\n        }\n        void logForm_FormClosed(object sender, FormClosedEventArgs e)\n        {\n            logForm = null;\n            Utils.ReleaseMemory(true);\n        }\n        void configForm_FormClosed(object sender, FormClosedEventArgs e)\n        {
        }\n        void configForm_FormClosed(object sender, FormClosedEventArgs e)\n        {\n            configForm = null;\n            Utils.ReleaseMemory(true);\n            if (_isFirstRun)\n            {\n                CheckUpdateForFirstRun();\n                ShowFirstTimeBalloon();\n                _isFirstRun = false;
                bytesToKey(passbuf, key);\n                return key;\n            });\n        }\n        protected static void bytesToKey(byte[] password, byte[] key)\n        {\n            byte[] result = new byte[password.Length + 16];\n            int i = 0;\n            byte[] md5sum = null;\n            while (i < key.Length)
        {\n            byte[] result = new byte[password.Length + 16];\n            int i = 0;\n            byte[] md5sum = null;\n            while (i < key.Length)\n            {\n                if (i == 0)\n                {\n                    md5sum = MbedTLS.MD5(password);\n                }
            {\n                if (File.Exists(NLOG_CONFIG_FILE_NAME))\n                    return; // NLog.config exists, and has already been loaded\n                File.WriteAllText(NLOG_CONFIG_FILE_NAME, Properties.Resources.NLog_config);\n            }\n            catch (Exception ex)\n            {\n                NLog.Common.InternalLogger.Error(ex, "[shadowsocks] Failed to setup default NLog.config: {0}", NLOG_CONFIG_FILE_NAME);\n                return;
            }\n            catch (Exception ex)\n            {\n                NLog.Common.InternalLogger.Error(ex, "[shadowsocks] Failed to setup default NLog.config: {0}", NLOG_CONFIG_FILE_NAME);\n                return;\n            }\n            LoadConfiguration();    // Load the new config-file\n        }\n        /// <summary>\n        /// NLog reload the config file and apply to current LogManager
        }\n        private Sip003Plugin(string plugin, string pluginOpts, string pluginArgs, string serverAddress, int serverPort)\n        {\n            if (plugin == null) throw new ArgumentNullException(nameof(plugin));\n            if (string.IsNullOrWhiteSpace(serverAddress))\n            {\n                throw new ArgumentException("Value cannot be null or whitespace.", nameof(serverAddress));\n            }\n            if (serverPort <= 0 || serverPort > 65535)\n            {
        {\n            if (plugin == null) throw new ArgumentNullException(nameof(plugin));\n            if (string.IsNullOrWhiteSpace(serverAddress))\n            {\n                throw new ArgumentException("Value cannot be null or whitespace.", nameof(serverAddress));\n            }\n            if (serverPort <= 0 || serverPort > 65535)\n            {\n                throw new ArgumentOutOfRangeException("serverPort");\n            }
            this.tableLayoutPanel1.TabIndex = 0;\n            // \n            // PluginOptionsLabel\n            // \n            this.PluginOptionsLabel.Anchor = System.Windows.Forms.AnchorStyles.Right;\n            this.PluginOptionsLabel.AutoSize = true;
        private System.Windows.Forms.TextBox IPTextBox;\n        private System.Windows.Forms.TextBox ServerPortTextBox;\n        private System.Windows.Forms.TextBox PasswordTextBox;\n        private System.Windows.Forms.Label EncryptionLabel;\n        private System.Windows.Forms.ComboBox EncryptionSelect;\n        private System.Windows.Forms.Panel panel2;\n        private System.Windows.Forms.Button OKButton;\n        private System.Windows.Forms.Button MyCancelButton;\n        private System.Windows.Forms.Button DeleteButton;
        private System.Windows.Forms.Label EncryptionLabel;\n        private System.Windows.Forms.ComboBox EncryptionSelect;\n        private System.Windows.Forms.Panel panel2;\n        private System.Windows.Forms.Button OKButton;\n        private System.Windows.Forms.Button MyCancelButton;\n        private System.Windows.Forms.Button DeleteButton;\n        private System.Windows.Forms.Button AddButton;\n        private System.Windows.Forms.GroupBox ServerGroupBox;\n        private System.Windows.Forms.ListBox ServersListBox;\n        private System.Windows.Forms.TextBox RemarksTextBox;
            this.panel3 = new System.Windows.Forms.Panel();\n            this.AddButton = new System.Windows.Forms.Button();\n            this.DeleteButton = new System.Windows.Forms.Button();\n            this.groupBox1 = new System.Windows.Forms.GroupBox();\n            this.ServersListBox = new System.Windows.Forms.ListBox();\n            this.tableLayoutPanel1.SuspendLayout();\n            this.panel1.SuspendLayout();\n            this.panel3.SuspendLayout();\n            this.groupBox1.SuspendLayout();\n            this.SuspendLayout();
            this.Controls.Add(this.panel1);\n            this.Controls.Add(this.panel3);\n            this.Controls.Add(this.panel2);\n            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedSingle;\n            this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));\n            this.MaximizeBox = false;\n            this.Name = "ConfigForm";\n            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;\n            this.Text = "Shadowsocks";\n            this.FormClosed += new System.Windows.Forms.FormClosedEventHandler(this.ConfigForm_FormClosed);
        private System.Windows.Forms.Panel panel3;\n        private System.Windows.Forms.Button DeleteButton;\n        private System.Windows.Forms.Button AddButton;\n        private System.Windows.Forms.GroupBox groupBox1;\n        private System.Windows.Forms.ListBox ServersListBox;\n    }\n}
[assembly: AssemblyProduct("Shadowsocks")]\n[assembly: AssemblyCopyright("Copyright © clowwindy 2014")]\n[assembly: AssemblyTrademark("")]\n[assembly: AssemblyCulture("")]\n// 将 ComVisible 设置为 false 使此程序集中的类型\n// 对 COM 组件不可见。如果需要从 COM 访问此程序集中的类型，\n// 则将该类型上的 ComVisible 属性设置为 true。\n[assembly: ComVisible(false)]\n// 如果此项目向 COM 公开，则下列 GUID 用于类型库的 ID\n[assembly: Guid("f8334709-4309-436a-8bbd-6165dcf4a660")]\n// [assembly: AssemblyFileVersion("2.0.0")]

    _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);\n  }\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n  public Geosite Clone() {\n    return new Geosite(this);\n  }\n  /// <summary>Field number for the "group_name" field.</summary>\n  public const int GroupNameFieldNumber = 1;\n  private string groupName_ = "";\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    set {\n      groupName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");\n    }\n  }\n  /// <summary>Field number for the "domains" field.</summary>\n  public const int DomainsFieldNumber = 2;\n  private static readonly pb::FieldCodec<global::DomainObject> _repeated_domains_codec\n      = pb::FieldCodec.ForMessage(18, global::DomainObject.Parser);\n  private readonly pbc::RepeatedField<global::DomainObject> domains_ = new pbc::RepeatedField<global::DomainObject>();\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n  public pbc::RepeatedField<global::DomainObject> Domains {
      = pb::FieldCodec.ForMessage(18, global::DomainObject.Parser);\n  private readonly pbc::RepeatedField<global::DomainObject> domains_ = new pbc::RepeatedField<global::DomainObject>();\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n  public pbc::RepeatedField<global::DomainObject> Domains {\n    get { return domains_; }\n  }\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n  public override bool Equals(object other) {\n    return Equals(other as Geosite);\n  }
  }\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n  public override bool Equals(object other) {\n    return Equals(other as Geosite);\n  }\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n  public bool Equals(Geosite other) {\n    if (ReferenceEquals(other, null)) {\n      return false;\n    }
    return Equals(_unknownFields, other._unknownFields);\n  }\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n  public override int GetHashCode() {\n    int hash = 1;\n    if (GroupName.Length != 0) hash ^= GroupName.GetHashCode();\n    hash ^= domains_.GetHashCode();\n    if (_unknownFields != null) {\n      hash ^= _unknownFields.GetHashCode();\n    }
    if (_unknownFields != null) {\n      hash ^= _unknownFields.GetHashCode();\n    }\n    return hash;\n  }\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n  public override string ToString() {\n    return pb::JsonFormatter.ToDiagnosticString(this);\n  }\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      output.WriteRawTag(10);\n      output.WriteString(GroupName);\n    }\n    domains_.WriteTo(output, _repeated_domains_codec);\n    if (_unknownFields != null) {\n      _unknownFields.WriteTo(output);\n    }\n  }\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n  public int CalculateSize() {
    if (_unknownFields != null) {\n      _unknownFields.WriteTo(output);\n    }\n  }\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n  public int CalculateSize() {\n    int size = 0;\n    if (GroupName.Length != 0) {\n      size += 1 + pb::CodedOutputStream.ComputeStringSize(GroupName);\n    }
    if (_unknownFields != null) {\n      size += _unknownFields.CalculateSize();\n    }\n    return size;\n  }\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n  public void MergeFrom(Geosite other) {\n    if (other == null) {\n      return;\n    }
          break;\n        }\n        case 18: {\n          domains_.AddEntriesFrom(input, _repeated_domains_codec);\n          break;\n        }\n      }\n    }\n  }\n}
          break;\n        }\n      }\n    }\n  }\n}\npublic sealed partial class GeositeList : pb::IMessage<GeositeList> {\n  private static readonly pb::MessageParser<GeositeList> _parser = new pb::MessageParser<GeositeList>(() => new GeositeList());\n  private pb::UnknownFieldSet _unknownFields;\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
      = pb::FieldCodec.ForMessage(10, global::Geosite.Parser);\n  private readonly pbc::RepeatedField<global::Geosite> entries_ = new pbc::RepeatedField<global::Geosite>();\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n  public pbc::RepeatedField<global::Geosite> Entries {\n    get { return entries_; }\n  }\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n  public override bool Equals(object other) {\n    return Equals(other as GeositeList);\n  }
  }\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n  public override bool Equals(object other) {\n    return Equals(other as GeositeList);\n  }\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n  public bool Equals(GeositeList other) {\n    if (ReferenceEquals(other, null)) {\n      return false;\n    }
    return Equals(_unknownFields, other._unknownFields);\n  }\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n  public override int GetHashCode() {\n    int hash = 1;\n    hash ^= entries_.GetHashCode();\n    if (_unknownFields != null) {\n      hash ^= _unknownFields.GetHashCode();\n    }\n    return hash;
        static GeositeUpdater()\n        {\n            LoadGeositeList();\n        }\n        static void LoadGeositeList(byte[] data = null)\n        {
            {\n                Geosites[item.GroupName.ToLower()] = item.Domains;\n            }\n        }\n        public static void UpdatePACFromGeosite(Configuration config)\n        {\n            string gfwListUrl = GEOSITE_URL;\n            if (!string.IsNullOrWhiteSpace(config.gfwListUrl))\n            {\n                logger.Info("Found custom GFWListURL in config file");
            }\n        }\n        public static void UpdatePACFromGeosite(Configuration config)\n        {\n            string gfwListUrl = GEOSITE_URL;\n            if (!string.IsNullOrWhiteSpace(config.gfwListUrl))\n            {\n                logger.Info("Found custom GFWListURL in config file");\n                gfwListUrl = config.gfwListUrl;\n            }
                        line = line.Replace("*", "/");\n                    if (line.StartsWith("||"))\n                        while (line.StartsWith("||"))\n                            line = line.Substring(2);\n                    else if (line.StartsWith("|"))\n                        line = line.TrimStart('|');\n                    else if (line.StartsWith("."))\n                        line = line.TrimStart('.');\n                    if (line.StartsWith("!"))\n                        continue;
                    else if (line.StartsWith("|"))\n                        line = line.TrimStart('|');\n                    else if (line.StartsWith("."))\n                        line = line.TrimStart('.');\n                    if (line.StartsWith("!"))\n                        continue;\n                    else if (line.StartsWith("["))\n                        continue;\n                    else if (line.StartsWith("@"))\n                        continue; /*ignore white list*/
                    else if (line.StartsWith("."))\n                        line = line.TrimStart('.');\n                    if (line.StartsWith("!"))\n                        continue;\n                    else if (line.StartsWith("["))\n                        continue;\n                    else if (line.StartsWith("@"))\n                        continue; /*ignore white list*/\n                    int pos = line.IndexOfAny(new char[] { '/'});\n                    if (pos >= 0)
                    if (line.StartsWith("!"))\n                        continue;\n                    else if (line.StartsWith("["))\n                        continue;\n                    else if (line.StartsWith("@"))\n                        continue; /*ignore white list*/\n                    int pos = line.IndexOfAny(new char[] { '/'});\n                    if (pos >= 0)\n                        line = line.Substring(0, pos);\n                    if (line.Length > 0)
            }\n            /* refer https://github.com/clowwindy/gfwlist2pac/blob/master/gfwlist2pac/main.py */\n            public string[] GetReducedDomains()\n            {\n                string[] domains = GetDomains();\n                List<string> new_domains = new List<string>(domains.Length);\n                TldIndex tldIndex = GetTldIndex();\n                foreach(string domain in domains)\n                {\n                    string last_root_domain = null;
                    {\n                        e = new Exception(I18N.GetString("Port {0} already in use", _config.localPort), e);\n                    }\n                    else if (se.SocketErrorCode == SocketError.AccessDenied)\n                    {\n                        e = new Exception(I18N.GetString("Port {0} is reserved by system", _config.localPort), e);\n                    }\n                }\n                Logging.LogUsefulException(e);\n                ReportError(e);
    }\n}
            InitializeComponent();\n            // a dirty hack\n            ServersListBox.Dock = DockStyle.Fill;\n            tableLayoutPanel5.Dock = DockStyle.Fill;\n            PerformLayout();\n            UpdateTexts();\n            SetupValueChangedListeners();\n            Icon = Icon.FromHandle(Resources.ssw128.GetHicon());\n            this.controller = controller;
            UpdateTexts();\n            SetupValueChangedListeners();\n            Icon = Icon.FromHandle(Resources.ssw128.GetHicon());\n            this.controller = controller;
            this.controller = controller;
            RemarksLabel.Text = I18N.GetString("Remarks");\n            TimeoutLabel.Text = I18N.GetString("Timeout(Sec)");\n            ServerGroupBox.Text = I18N.GetString("Server");\n            OKButton.Text = I18N.GetString("OK");\n            MyCancelButton.Text = I18N.GetString("Cancel");\n            ApplyButton.Text = I18N.GetString("Apply");\n            MoveUpButton.Text = I18N.GetString("Move &Up");\n            MoveDownButton.Text = I18N.GetString("Move D&own");\n            Text = I18N.GetString("Edit Servers");\n        }
        }\n        private void SetupValueChangedListeners()\n        {\n            IPTextBox.TextChanged += ConfigValueChanged;\n            ProxyPortTextBox.TextChanged += ConfigValueChanged;\n            PasswordTextBox.TextChanged += ConfigValueChanged;\n            EncryptionSelect.SelectedIndexChanged += ConfigValueChanged;\n            PluginTextBox.TextChanged += ConfigValueChanged;\n            PluginArgumentsTextBox.TextChanged += ConfigValueChanged;\n            PluginOptionsTextBox.TextChanged += ConfigValueChanged;
        {\n            try\n            {\n                if (_lastSelectedIndex == -1 || _lastSelectedIndex >= _modifiedConfiguration.configs.Count)\n                {\n                    return true;\n                }\n                bool verify = GetServerDetailsFromUI(out Server server, isSave, isCopy);\n                if (server != null)\n                {
                return true;\n            }
            LoadServerNameListToUI(_modifiedConfiguration);\n            UpdateIndexToEnd();
            LoadSelectedServerDetails();\n            UpdateButtons();\n        }\n        private void UpdateButtons()\n        {\n            DeleteButton.Enabled = (ServersListBox.Items.Count > 0);\n            MoveUpButton.Enabled = (ServersListBox.SelectedIndex > 0);\n            MoveDownButton.Enabled = (ServersListBox.SelectedIndex < ServersListBox.Items.Count - 1);\n        }\n        private void MoveUpButton_Click(object sender, EventArgs e)
        }\n        private void MoveConfigItem(int step)\n        {\n            int index = ServersListBox.SelectedIndex;\n            Server server = _modifiedConfiguration.configs[index];\n            object item = ServersListBox.Items[index];\n            _modifiedConfiguration.configs.Remove(server);\n            _modifiedConfiguration.configs.Insert(index + step, server);\n            _modifiedConfiguration.index += step;\n            ServersListBox.BeginUpdate();
        }\n        private void ShowPasswdCheckBox_CheckedChanged(object sender, EventArgs e)\n        {\n            PasswordTextBox.UseSystemPasswordChar = !ShowPasswdCheckBox.Checked;\n        }\n        private void UsePluginArgCheckBox_CheckedChanged(object sender, EventArgs e)\n        {\n            ShowHidePluginArgInput(NeedPluginArgCheckBox.Checked);\n        }\n    }
        }\n        private void UsePluginArgCheckBox_CheckedChanged(object sender, EventArgs e)\n        {\n            ShowHidePluginArgInput(NeedPluginArgCheckBox.Checked);\n        }\n    }\n}
        }\n    }\n}
namespace Shadowsocks.Model\n{\n    [Serializable]\n    public class Configuration\n    {\n        public string version;\n        public List<Server> configs;\n        // when strategy is set, index is ignored\n        public string strategy;\n        public int index;
        public Server GetCurrentServer()\n        {\n            if (index >= 0 && index < configs.Count)\n                return configs[index];\n            else\n                return GetDefaultServer();\n        }\n        public static void CheckServer(Server server)\n        {\n            CheckServer(server.server);
            CheckTimeout(server.timeout, Server.MaxServerTimeoutSec);\n        }\n        public static bool ChecksServer(Server server)\n        {\n            try\n            {\n                CheckServer(server);\n                return true;\n            }\n            catch (Exception)
        {\n            if (config != null && config.configs != null)\n            {\n                server = (server ?? GetDefaultServer());\n                config.configs.Insert(index.GetValueOrDefault(config.configs.Count), server);\n                //if (index.HasValue)\n                //    config.configs.Insert(index.Value, server);\n                //else\n                //    config.configs.Add(server);\n            }\n            return server;\n        }\n        public static Server GetDefaultServer()
            }\n            return server;\n        }\n        public static Server GetDefaultServer()\n        {\n            return new Server();\n        }\n        private static void Assert(bool condition)\n        {\n            if (!condition)
        private void PACFileWatcher_Changed(object sender, FileSystemEventArgs e)\n        {\n            if (PACFileChanged != null)\n            {\n                Logging.Info($"Detected: PAC file '{e.Name}' was {e.ChangeType.ToString().ToLower()}.");\n                Task.Factory.StartNew(() =>\n                {\n                    ((FileSystemWatcher)sender).EnableRaisingEvents = false;\n                    System.Threading.Thread.Sleep(10);
                    PACFileChanged(this, new EventArgs());\n                    ((FileSystemWatcher)sender).EnableRaisingEvents = true;\n                });\n            }\n        }\n        private void UserRuleFileWatcher_Changed(object sender, FileSystemEventArgs e)\n        {\n            if (UserRuleFileChanged != null)
            }\n        }\n        private void UserRuleFileWatcher_Changed(object sender, FileSystemEventArgs e)\n        {\n            if (UserRuleFileChanged != null)\n            {\n                Logging.Info($"Detected: User Rule file '{e.Name}' was {e.ChangeType.ToString().ToLower()}.");\n                Task.Factory.StartNew(()=>\n                {\n                    ((FileSystemWatcher)sender).EnableRaisingEvents = false;
                    UserRuleFileChanged(this, new EventArgs());\n                    ((FileSystemWatcher)sender).EnableRaisingEvents = true;\n                });\n            }\n        }\n        #endregion\n        private string GetPACAddress(byte[] requestBuf, int length, IPEndPoint localEndPoint, bool useSocks)\n        {
            }\n        }\n        #endregion\n        private string GetPACAddress(byte[] requestBuf, int length, IPEndPoint localEndPoint, bool useSocks)\n        {\n            //try\n            //{\n            //    string requestString = Encoding.UTF8.GetString(requestBuf);\n            //    if (requestString.IndexOf("AppleWebKit") >= 0)\n            //    {
using NLog;\nusing Shadowsocks.Controller;\nusing Shadowsocks.Controller.Hotkeys;\nusing Shadowsocks.Util;\nusing Shadowsocks.View;\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;
using Shadowsocks.Controller;\nusing Shadowsocks.Controller.Hotkeys;\nusing Shadowsocks.Util;\nusing Shadowsocks.View;\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.IO.Pipes;\nusing System.Linq;
using System.Text;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing System.Windows.Forms;\nnamespace Shadowsocks\n{\n    internal static class Program\n    {\n        private static readonly Logger logger = LogManager.GetCurrentClassLogger();\n        public static ShadowsocksController MainController { get; private set; }
using System.Threading.Tasks;\nusing System.Windows.Forms;\nnamespace Shadowsocks\n{\n    internal static class Program\n    {\n        private static readonly Logger logger = LogManager.GetCurrentClassLogger();\n        public static ShadowsocksController MainController { get; private set; }\n        public static MenuViewController MenuController { get; private set; }\n        public static string[] Args { get; private set; }
namespace Shadowsocks\n{\n    internal static class Program\n    {\n        private static readonly Logger logger = LogManager.GetCurrentClassLogger();\n        public static ShadowsocksController MainController { get; private set; }\n        public static MenuViewController MenuController { get; private set; }\n        public static string[] Args { get; private set; }\n        /// <summary>\n        /// 应用程序的主入口点。\n        private static void Main(string[] args)
    {\n        private static readonly Logger logger = LogManager.GetCurrentClassLogger();\n        public static ShadowsocksController MainController { get; private set; }\n        public static MenuViewController MenuController { get; private set; }\n        public static string[] Args { get; private set; }\n        /// <summary>\n        /// 应用程序的主入口点。\n        /// </summary>\n        /// </summary>\n        [STAThread]\n        private static void Main(string[] args)\n        {\n            Directory.SetCurrentDirectory(Application.StartupPath);\n            // todo: initialize the NLog configuartion
        public static ShadowsocksController MainController { get; private set; }\n        public static MenuViewController MenuController { get; private set; }\n        public static string[] Args { get; private set; }\n        /// <summary>\n        /// 应用程序的主入口点。\n        /// </summary>\n        /// </summary>\n        [STAThread]\n        private static void Main(string[] args)\n        {\n            Directory.SetCurrentDirectory(Application.StartupPath);\n            // todo: initialize the NLog configuartion\n            Model.NLogConfig.TouchAndApplyNLogConfig();\n            // .NET Framework 4.7.2 on Win7 compatibility\n            ServicePointManager.SecurityProtocol |=\n                SecurityProtocolType.Tls | SecurityProtocolType.Tls11 | SecurityProtocolType.Tls12;
        {\n            Directory.SetCurrentDirectory(Application.StartupPath);\n            // todo: initialize the NLog configuartion\n            Model.NLogConfig.TouchAndApplyNLogConfig();\n            // .NET Framework 4.7.2 on Win7 compatibility\n            ServicePointManager.SecurityProtocol |=\n                SecurityProtocolType.Tls | SecurityProtocolType.Tls11 | SecurityProtocolType.Tls12;\n            // store args for further use\n            Args = args;\n            // Check OS since we are using dual-mode socket\n            if (!Utils.IsWinVistaOrHigher())\n            {
            // store args for further use\n            Args = args;\n            // Check OS since we are using dual-mode socket\n            if (!Utils.IsWinVistaOrHigher())\n            {\n                MessageBox.Show(I18N.GetString("Unsupported operating system, use Windows Vista at least."),\n                "Shadowsocks Error", MessageBoxButtons.OK, MessageBoxIcon.Error);\n                return;\n            }\n            // Check .NET Framework version
                int urlidx = alist.IndexOf("--open-url") + 1;\n                if (urlidx > 0)\n                {\n                    if (Args.Length <= urlidx)\n                    {\n                        return;\n                    }\n                    // --open-url exist, and no other instance, add it later\n                    if (!pipeExist)\n                    {
                else if (pipeExist)\n                {\n                    Process[] oldProcesses = Process.GetProcessesByName("Shadowsocks");\n                    if (oldProcesses.Length > 0)\n                    {\n                        Process oldProcess = oldProcesses[0];\n                    }\n                    MessageBox.Show(I18N.GetString("Find Shadowsocks icon in your notify tray.")\n                        + Environment.NewLine\n                        + I18N.GetString("If you want to start multiple Shadowsocks, make a copy in another directory."),
    {\n        public Rectangle TargetRect;\n        public QRCodeSplashForm()\n        {\n            FormBorderStyle = FormBorderStyle.None;
        public event EventHandler ConfigChanged;\n        public event EventHandler EnableStatusChanged;\n        // when user clicked Edit PAC, and PAC file has already created\n        public event EventHandler<PathEventArgs> PACFileReadyToOpen;\n        public ShadowsocksController()\n        {\n            config = Configuration.Load();\n            polipoRunner = new PolipoRunner();\n            polipoRunner.Start(config.GetCurrentServer());
        // when user clicked Edit PAC, and PAC file has already created\n        public event EventHandler<PathEventArgs> PACFileReadyToOpen;\n        public ShadowsocksController()\n        {\n            config = Configuration.Load();\n            polipoRunner = new PolipoRunner();\n            polipoRunner.Start(config.GetCurrentServer());\n            local = new Local(config.GetCurrentServer());\n            try\n            {
            enableItem.Checked = controller.GetConfiguration().enabled;\n        }\n        private void CinfigForm_Load(object sender, EventArgs e)\n        {\n            if (!controller.GetConfiguration().isDefault)\n            {\n                this.Opacity = 0;\n                BeginInvoke(new MethodInvoker(delegate\n                {\n                    this.Hide();
        {\n            if (!controller.GetConfiguration().isDefault)\n            {\n                this.Opacity = 0;\n                BeginInvoke(new MethodInvoker(delegate\n                {\n                    this.Hide();\n                }));\n            }\n        }
        {\n            controller.Stop();\n        }\n        private void AboutItem_Click(object sender, EventArgs e)\n        {\n            Process.Start("https://github.com/clowwindy/shadowsocks-csharp");\n        }\n        private void notifyIcon1_DoubleClick(object sender, EventArgs e)\n        {\n            showWindow();
            this.label3 = new System.Windows.Forms.Label();\n            this.label4 = new System.Windows.Forms.Label();\n            this.IPTextBox = new System.Windows.Forms.TextBox();\n            this.ServerPortTextBox = new System.Windows.Forms.TextBox();\n            this.PasswordTextBox = new System.Windows.Forms.TextBox();\n            this.ProxyPortTextBox = new System.Windows.Forms.TextBox();\n            this.notifyIcon1 = new System.Windows.Forms.NotifyIcon(this.components);\n            this.panel2 = new System.Windows.Forms.Panel();\n            this.OKButton = new System.Windows.Forms.Button();\n            this.MyCancelButton = new System.Windows.Forms.Button();
            this.notifyIcon1 = new System.Windows.Forms.NotifyIcon(this.components);\n            this.panel2 = new System.Windows.Forms.Panel();\n            this.OKButton = new System.Windows.Forms.Button();\n            this.MyCancelButton = new System.Windows.Forms.Button();\n            this.panel1 = new System.Windows.Forms.Panel();\n            this.contextMenu1 = new System.Windows.Forms.ContextMenu();\n            this.enableItem = new System.Windows.Forms.MenuItem();\n            this.configItem = new System.Windows.Forms.MenuItem();\n            this.editPACFileItem = new System.Windows.Forms.MenuItem();\n            this.aboutItem = new System.Windows.Forms.MenuItem();
            this.panel1 = new System.Windows.Forms.Panel();\n            this.contextMenu1 = new System.Windows.Forms.ContextMenu();\n            this.enableItem = new System.Windows.Forms.MenuItem();\n            this.configItem = new System.Windows.Forms.MenuItem();\n            this.editPACFileItem = new System.Windows.Forms.MenuItem();\n            this.aboutItem = new System.Windows.Forms.MenuItem();\n            this.menuItem3 = new System.Windows.Forms.MenuItem();\n            this.quitItem = new System.Windows.Forms.MenuItem();\n            this.tableLayoutPanel2 = new System.Windows.Forms.TableLayoutPanel();\n            this.listView1 = new System.Windows.Forms.ListView();
            this.tableLayoutPanel1.SuspendLayout();\n            this.panel1.SuspendLayout();\n            this.tableLayoutPanel2.SuspendLayout();\n            this.tableLayoutPanel3.SuspendLayout();\n            this.SuspendLayout();\n            // \n            // tableLayoutPanel1\n            // \n            this.tableLayoutPanel1.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) \n            | System.Windows.Forms.AnchorStyles.Right)));
            this.tableLayoutPanel1.Controls.Add(this.label3, 0, 2);\n            this.tableLayoutPanel1.Controls.Add(this.label4, 0, 3);\n            this.tableLayoutPanel1.Controls.Add(this.IPTextBox, 1, 0);\n            this.tableLayoutPanel1.Controls.Add(this.ServerPortTextBox, 1, 1);\n            this.tableLayoutPanel1.Controls.Add(this.PasswordTextBox, 1, 2);\n            this.tableLayoutPanel1.Controls.Add(this.ProxyPortTextBox, 1, 3);\n            this.tableLayoutPanel1.Location = new System.Drawing.Point(246, 10);\n            this.tableLayoutPanel1.Margin = new System.Windows.Forms.Padding(10);\n            this.tableLayoutPanel1.Name = "tableLayoutPanel1";\n            this.tableLayoutPanel1.Padding = new System.Windows.Forms.Padding(5);
            this.tableLayoutPanel1.Margin = new System.Windows.Forms.Padding(10);\n            this.tableLayoutPanel1.Name = "tableLayoutPanel1";\n            this.tableLayoutPanel1.Padding = new System.Windows.Forms.Padding(5);\n            this.tableLayoutPanel1.RowCount = 5;\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());
            "table",\n            "rc4-md5",\n            "aes-256-cfb",\n            "aes-192-cfb",\n            "aes-128-cfb",\n            "bf-cfb",\n            "rc4"});\n            this.EncryptionSelect.Location = new System.Drawing.Point(74, 112);\n            this.EncryptionSelect.Name = "EncryptionSelect";\n            this.EncryptionSelect.Size = new System.Drawing.Size(134, 21);
            // \n            // panel1\n            // \n            this.panel1.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) \n            | System.Windows.Forms.AnchorStyles.Right)));\n            this.panel1.AutoSize = true;\n            this.panel1.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;\n            this.panel1.Controls.Add(this.MyCancelButton);\n            this.panel1.Controls.Add(this.OKButton);\n            this.panel1.Location = new System.Drawing.Point(311, 205);\n            this.panel1.Name = "panel1";
            this.panel1.AutoSize = true;\n            this.panel1.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;\n            this.panel1.Controls.Add(this.MyCancelButton);\n            this.panel1.Controls.Add(this.OKButton);\n            this.panel1.Location = new System.Drawing.Point(311, 205);\n            this.panel1.Name = "panel1";
            this.panel1.Name = "panel1";
            // \n            // menuItem3\n            // \n            this.menuItem3.Index = 4;\n            this.menuItem3.Text = "-";\n            // \n            // quitItem\n            // \n            this.quitItem.Index = 5;\n            this.quitItem.Text = "Quit";
            this.Controls.Add(this.panel2);\n            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedSingle;\n            this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));\n            this.MaximizeBox = false;\n            this.Name = "ConfigForm";\n            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;\n            this.Text = "Shadowsocks";\n            this.FormClosed += new System.Windows.Forms.FormClosedEventHandler(this.ConfigForm_FormClosed);
            this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));\n            this.MaximizeBox = false;\n            this.Name = "ConfigForm";\n            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;\n            this.Text = "Shadowsocks";\n            this.FormClosed += new System.Windows.Forms.FormClosedEventHandler(this.ConfigForm_FormClosed);\n            this.Load += new System.EventHandler(this.CinfigForm_Load);\n            this.tableLayoutPanel1.ResumeLayout(false);\n            this.tableLayoutPanel1.PerformLayout();\n            this.panel1.ResumeLayout(false);
            this.tableLayoutPanel1.ResumeLayout(false);\n            this.tableLayoutPanel1.PerformLayout();\n            this.panel1.ResumeLayout(false);\n            this.tableLayoutPanel2.ResumeLayout(false);\n            this.tableLayoutPanel2.PerformLayout();\n            this.tableLayoutPanel3.ResumeLayout(false);\n            this.tableLayoutPanel3.PerformLayout();\n            this.ResumeLayout(false);\n            this.PerformLayout();\n        }
        private System.Windows.Forms.NotifyIcon notifyIcon1;\n        private System.Windows.Forms.Label label5;\n        private System.Windows.Forms.ComboBox EncryptionSelect;\n        private System.Windows.Forms.Panel panel2;\n        private System.Windows.Forms.Button OKButton;\n        private System.Windows.Forms.Button MyCancelButton;\n        private System.Windows.Forms.Panel panel1;\n        private System.Windows.Forms.ContextMenu contextMenu1;\n        private System.Windows.Forms.MenuItem enableItem;\n        private System.Windows.Forms.MenuItem aboutItem;
        private System.Windows.Forms.Panel panel2;\n        private System.Windows.Forms.Button OKButton;\n        private System.Windows.Forms.Button MyCancelButton;\n        private System.Windows.Forms.Panel panel1;\n        private System.Windows.Forms.ContextMenu contextMenu1;\n        private System.Windows.Forms.MenuItem enableItem;\n        private System.Windows.Forms.MenuItem aboutItem;\n        private System.Windows.Forms.MenuItem menuItem3;\n        private System.Windows.Forms.MenuItem quitItem;\n        private System.Windows.Forms.MenuItem configItem;
        private System.Windows.Forms.Panel panel1;\n        private System.Windows.Forms.ContextMenu contextMenu1;\n        private System.Windows.Forms.MenuItem enableItem;\n        private System.Windows.Forms.MenuItem aboutItem;\n        private System.Windows.Forms.MenuItem menuItem3;\n        private System.Windows.Forms.MenuItem quitItem;\n        private System.Windows.Forms.MenuItem configItem;\n        private System.Windows.Forms.MenuItem editPACFileItem;\n        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel2;\n        private System.Windows.Forms.ListView listView1;
using System.Net;\nusing System.IO;\nnamespace Shadowsocks.Controller\n{\n    public class GfwListUpdater
namespace Shadowsocks.Controller\n{\n    public class GfwListUpdater\n    {\n        private const string GFWLIST_URL = "https://autoproxy-gfwlist.googlecode.com/svn/trunk/gfwlist.txt";\n        public IWebProxy proxy = null;\n        public class GfwListDownloadCompletedArgs : EventArgs\n        {\n            public string Content;\n        }
using System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.IO.Compression;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Text;\nnamespace Shadowsocks.Controller\n{
namespace Shadowsocks.Controller\n{\n    class PACServer\n    {\n        private static int PORT = 8093;\n        private static string PAC_FILE = "pac.txt";\n        private static Configuration config;\n        Socket _listener;\n        FileSystemWatcher watcher;\n        public event EventHandler PACFileChanged;
            flashStep = 0;\n            x = 0;\n            y = 0;\n            w = Width;\n            h = Height;\n            sw = Stopwatch.StartNew();\n            timer = new Timer();\n            timer.Interval = (int)(ANIMATION_TIME * 1000 / ANIMATION_STEPS);\n            timer.Tick += timer_Tick;\n            timer.Start();
                if (flashStep == 0)\n                {\n                    timer.Interval = 100;\n                    g.Clear(Color.Transparent);\n                    SetBitmap(bitmap);\n                }\n                else if (flashStep == 1)\n                {\n                    timer.Interval = 50;\n                    g.FillRectangle(brush, x, y, w, h);
                        registry.SetValue("AutoConfigURL", pacUrl);\n                    }\n                }\n                else\n                {\n                    registry.SetValue("ProxyEnable", 0);\n                    registry.SetValue("ProxyServer", "");
                    registry.SetValue("AutoConfigURL", "");\n                }\n                //Set AutoDetectProxy Off\n                IEAutoDetectProxy(false);\n                SystemProxy.NotifyIE();\n                //Must Notify IE first, or the connections do not chanage\n                CopyProxySettingFromLan();\n            }\n            catch (Exception e)\n            {
                string beforeAt = data.Substring(0, indexLastAt);\n                string[] parts = beforeAt.Split(new[] { ':' });\n                method = parts[0];\n                password = parts[1];\n                //TODO: read one_time_auth\n            }\n            catch (IndexOutOfRangeException)\n            {\n                throw new FormatException();\n            }
                //TODO: read one_time_auth\n            }\n            catch (IndexOutOfRangeException)\n            {\n                throw new FormatException();\n            }\n        }\n    }\n}
                return configs[index];\n            else\n                return GetDefaultServer();\n        }\n        public static void CheckServer(Server server)\n        {\n            CheckPort(server.server_port);
            else\n                return GetDefaultServer();\n        }\n        public static void CheckServer(Server server)\n        {\n            CheckPort(server.server_port);\n            CheckPassword(server.password);\n            CheckServer(server.server);
                return GetDefaultServer();\n        }\n        public static void CheckServer(Server server)\n        {\n            CheckPort(server.server_port);\n            CheckPassword(server.password);\n            CheckServer(server.server);\n        }\n        public static Configuration Load()
        }\n        public static void CheckServer(Server server)\n        {\n            CheckPort(server.server_port);\n            CheckPassword(server.password);\n            CheckServer(server.server);\n        }\n        public static Configuration Load()\n        {\n            try
                    config.localPort = 1080;\n                if (config.index == -1 && config.strategy == null)\n                    config.index = 0;\n                return config;
                return config;\n            }\n            catch (Exception e)\n            {\n                if (!(e is FileNotFoundException))\n                    Logging.LogUsefulException(e);\n                return new Configuration\n                {
                    Logging.LogUsefulException(e);\n                return new Configuration\n                {\n                    index = 0,\n                    isDefault = true,\n                    localPort = 1080,\n                    autoCheckUpdate = true,\n                    configs = new List<Server>()\n                    {
                return new Configuration\n                {\n                    index = 0,\n                    isDefault = true,\n                    localPort = 1080,\n                    autoCheckUpdate = true,\n                    configs = new List<Server>()\n                    {\n                        GetDefaultServer()\n                    }
                config.index = config.configs.Count - 1;\n            if (config.index < -1)\n                config.index = -1;\n            if (config.index == -1 && config.strategy == null)\n                config.index = 0;
            if (config.index < -1)\n                config.index = -1;\n            if (config.index == -1 && config.strategy == null)\n                config.index = 0;
                config.index = -1;\n            if (config.index == -1 && config.strategy == null)\n                config.index = 0;\n            config.isDefault = false;
            config.isDefault = false;\n            try\n            {\n                using (StreamWriter sw = new StreamWriter(File.Open(CONFIG_FILE, FileMode.Create)))\n                {\n                    string jsonString = JsonConvert.SerializeObject(config, Formatting.Indented);\n                    sw.Write(jsonString);\n                    sw.Flush();\n                }\n            }
                throw new Exception(I18N.GetString("assertion failure"));\n        }\n        public static void CheckPort(int port)\n        {\n            if (port <= 0 || port > 65535)\n                throw new ArgumentException(I18N.GetString("Port out of range"));\n        }
        }\n        public static void CheckPort(int port)\n        {\n            if (port <= 0 || port > 65535)\n                throw new ArgumentException(I18N.GetString("Port out of range"));\n        }\n        public static void CheckLocalPort(int port)\n        {
                throw new ArgumentException(I18N.GetString("Port out of range"));\n        }\n        public static void CheckLocalPort(int port)\n        {\n            CheckPort(port);\n            if (port == 8123)\n                throw new ArgumentException(I18N.GetString("Port can't be 8123"));
        }\n        public static void CheckLocalPort(int port)\n        {\n            CheckPort(port);\n            if (port == 8123)\n                throw new ArgumentException(I18N.GetString("Port can't be 8123"));\n        }\n        private static void CheckPassword(string password)
                throw new ArgumentException(I18N.GetString("Port can't be 8123"));\n        }\n        private static void CheckPassword(string password)\n        {\n            if (string.IsNullOrEmpty(password))\n                throw new ArgumentException(I18N.GetString("Password can not be blank"));\n        }
        }\n        private static void CheckPassword(string password)\n        {\n            if (string.IsNullOrEmpty(password))\n                throw new ArgumentException(I18N.GetString("Password can not be blank"));\n        }\n        private static void CheckServer(string server)\n        {
                throw new ArgumentException(I18N.GetString("Password can not be blank"));\n        }\n        private static void CheckServer(string server)\n        {\n            if (string.IsNullOrEmpty(server))\n                throw new ArgumentException(I18N.GetString("Server IP can not be blank"));\n        }
        }\n        private static void CheckServer(string server)\n        {\n            if (string.IsNullOrEmpty(server))\n                throw new ArgumentException(I18N.GetString("Server IP can not be blank"));\n        }\n    }\n}
                throw new ArgumentException(I18N.GetString("Server IP can not be blank"));\n        }\n    }\n}
        }\n    }\n}
using System.Diagnostics;\nusing System.IO;\nusing System.Text;\nusing Shadowsocks.Controller;\nusing Shadowsocks.Properties;\nnamespace Shadowsocks.Util.SystemProxy\n{\n    public static class Sysproxy
using System.Text;\nusing Shadowsocks.Controller;\nusing Shadowsocks.Properties;\nnamespace Shadowsocks.Util.SystemProxy\n{\n    public static class Sysproxy\n    {\n        private static bool _userSettingsRecorded = false;\n        // In general, this won't change
using Shadowsocks.Controller;\nusing Shadowsocks.Properties;\nnamespace Shadowsocks.Util.SystemProxy\n{\n    public static class Sysproxy\n    {\n        private static bool _userSettingsRecorded = false;\n        // In general, this won't change\n        // format:\n        //  <flags><CR-LF>\n        enum RET_ERRORS : int\n        {
            }\n            else\n            {\n                // restore user settings\n                var flags = _userSettings[0];\n                var proxy_server = _userSettings[1] ?? "-";\n                var bypass_list = _userSettings[2] ?? "-";\n                var pac_url = _userSettings[3] ?? "-";\n                arguments = $"set {flags} {proxy_server} {bypass_list} {pac_url}";\n                // have to get new settings
            }\n            ExecSysproxy(arguments, out str);\n        }\n        private static void ExecSysproxy(string arguments, out string queryStr)\n        {\n            using (var process = new Process())\n            {\n                // Configure the process using the StartInfo properties.\n                process.StartInfo.FileName = Utils.GetTempPath("sysproxy.exe");\n                process.StartInfo.Arguments = arguments;
                process.WaitForExit();\n                var exitCode = process.ExitCode;\n                    throw new ProxyException(stderr);\n                }\n                if (arguments == "query" && stdout.IsNullOrWhiteSpace())\n                {\n                    // we cannot get user settings\n                    throw new ProxyException("failed to query wininet settings");
                }\n                if (arguments == "query" && stdout.IsNullOrWhiteSpace())\n                {\n                    // we cannot get user settings\n                    throw new ProxyException("failed to query wininet settings");\n                }\n                queryStr = stdout;\n            }\n        }\n        private static void ParseQueryStr(string str)
                    }\n                }\n                else\n                {\n                    Sysproxy.SetIEProxy(false, false, null, null);\n                }\n            }\n            catch (ProxyException ex)\n            {\n                Logging.LogUsefulException(ex);
                }\n            }\n            catch (ProxyException ex)\n            {\n                Logging.LogUsefulException(ex);\n            }\n        }\n    }\n}
                            {\n                                useSocks = true;\n                            } */\n                        }\n                    }\n                    else if (kv.Length == 1)\n                    {\n                        if (line.IndexOf("pac") >= 0)\n                        {\n                            pathMatch = true;
                        }\n                    }\n                    else if (kv.Length == 1)\n                    {\n                        if (line.IndexOf("pac") >= 0)\n                        {\n                            pathMatch = true;\n                        }\n                    }\n                }
                _systemProxyIsDirty = true;\n            }\n            else\n            {\n                // only switch it off if we have switched it on\n                if (_systemProxyIsDirty)\n                {\n                    SystemProxy.Update(_config, false);\n                    _systemProxyIsDirty = false;\n                }\n            }
                    _systemProxyIsDirty = false;\n                }\n            }\n        }\n        private void pacServer_PACFileChanged(object sender, EventArgs e)\n        {\n            UpdateSystemProxy();\n        }\n        private void pacServer_PACUpdateCompleted(object sender, EventArgs e)\n        {
        {\n            bool global = config.global;\n            bool enabled = config.enabled;\n            if (forceDisable)\n            {\n                enabled = false;\n            }\n            try\n            {\n                RegistryKey registry =
                {\n                    if (global)\n                    {\n                        registry.SetValue("ProxyEnable", 1);\n                        registry.SetValue("ProxyServer", "127.0.0.1:" + config.localPort.ToString());\n                        registry.SetValue("AutoConfigURL", "");\n                    }\n                    else\n                    {\n                        registry.SetValue("ProxyEnable", 0);
                }\n                else\n                {\n                    registry.SetValue("ProxyEnable", 0);\n                    registry.SetValue("ProxyServer", "");\n                    registry.SetValue("AutoConfigURL", "");\n                }\n                SystemProxy.NotifyIE();\n                //Must Notify IE first, or the connections do not chanage
                }\n                SystemProxy.NotifyIE();\n                //Must Notify IE first, or the connections do not chanage
                CopyProxySettingFromLan();\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                // TODO this should be moved into views\n                MessageBox.Show(I18N.GetString("Failed to update registry"));\n            }\n        }\n        private static void CopyProxySettingFromLan()
                }\n                if (changed)\n                {\n                    LogMessageTextBox.ScrollToCaret();\n                }\n                lastOffset = reader.BaseStream.Position;\n            }\n        }\n        private void LogForm_Load(object sender, EventArgs e)\n        {
                }\n                lastOffset = reader.BaseStream.Position;\n            }\n        }\n        private void LogForm_Load(object sender, EventArgs e)\n        {\n            InitContent();\n            timer = new Timer();\n            timer.Interval = 300;\n            timer.Tick += Timer_Tick;
        {\n            string argument = @"/select, " + filename;\n            System.Diagnostics.Process.Start("explorer.exe", argument);\n        }\n        private void ExitMenuItem_Click(object sender, EventArgs e)\n        {
        {\n            this.Close();\n        }\n        private void LogForm_Shown(object sender, EventArgs e)\n        {\n            LogMessageTextBox.ScrollToCaret();\n        }\n        private void WrapTextCheckBox_CheckedChanged(object sender, EventArgs e)\n        {\n            LogMessageTextBox.WordWrap = WrapTextCheckBox.Checked;
        }\n    }\n}
            this.contextMenuStrip1 = new System.Windows.Forms.ContextMenuStrip(this.components);\n            this.mainMenu1 = new System.Windows.Forms.MainMenu(this.components);\n            this.FileMenuItem = new System.Windows.Forms.MenuItem();\n            this.OpenLocationMenuItem = new System.Windows.Forms.MenuItem();\n            this.ExitMenuItem = new System.Windows.Forms.MenuItem();\n            this.panel1 = new System.Windows.Forms.Panel();\n            this.ChangeFontButton = new System.Windows.Forms.Button();\n            this.CleanLogsButton = new System.Windows.Forms.Button();\n            this.WrapTextCheckBox = new System.Windows.Forms.CheckBox();\n            this.tableLayoutPanel1 = new System.Windows.Forms.TableLayoutPanel();
            this.SuspendLayout();\n            // \n            this.FileMenuItem});\n            // \n            this.FileMenuItem.Index = 0;\n            this.FileMenuItem.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {\n            this.OpenLocationMenuItem,
            // \n            this.FileMenuItem.Index = 0;\n            this.FileMenuItem.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {\n            this.OpenLocationMenuItem,\n            this.ExitMenuItem});\n            this.FileMenuItem.Text = "&File";\n            // \n            this.OpenLocationMenuItem.Index = 0;\n            this.OpenLocationMenuItem.Text = "&Open Location";\n            this.OpenLocationMenuItem.Click += new System.EventHandler(this.OpenLocationMenuItem_Click);\n            // 
            // \n            this.OpenLocationMenuItem.Index = 0;\n            this.OpenLocationMenuItem.Text = "&Open Location";\n            this.OpenLocationMenuItem.Click += new System.EventHandler(this.OpenLocationMenuItem_Click);\n            // \n            this.ClientSize = new System.Drawing.Size(547, 353);\n            this.Controls.Add(this.tableLayoutPanel1);\n            this.Menu = this.mainMenu1;
            // \n            this.ClientSize = new System.Drawing.Size(547, 353);\n            this.Controls.Add(this.tableLayoutPanel1);\n            this.Menu = this.mainMenu1;\n            this.Name = "LogForm";\n            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;\n            this.Text = "Log Viewer";
            this.Menu = this.mainMenu1;\n            this.Name = "LogForm";\n            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;\n            this.Text = "Log Viewer";\n            this.FormClosing += new System.Windows.Forms.FormClosingEventHandler(this.LogForm_FormClosing);\n            this.Load += new System.EventHandler(this.LogForm_Load);\n            this.Shown += new System.EventHandler(this.LogForm_Shown);\n            this.panel1.ResumeLayout(false);\n            this.panel1.PerformLayout();\n            this.tableLayoutPanel1.ResumeLayout(false);
        }\n        #endregion\n        private System.Windows.Forms.TextBox LogMessageTextBox;\n        private System.Windows.Forms.ContextMenuStrip contextMenuStrip1;\n        private System.Windows.Forms.MainMenu mainMenu1;\n        private System.Windows.Forms.MenuItem FileMenuItem;\n        private System.Windows.Forms.MenuItem OpenLocationMenuItem;\n        private System.Windows.Forms.MenuItem ExitMenuItem;\n        private System.Windows.Forms.Panel panel1;\n        private System.Windows.Forms.CheckBox WrapTextCheckBox;\n        private System.Windows.Forms.Button CleanLogsButton;
        private System.Windows.Forms.ContextMenuStrip contextMenuStrip1;\n        private System.Windows.Forms.MainMenu mainMenu1;\n        private System.Windows.Forms.MenuItem FileMenuItem;\n        private System.Windows.Forms.MenuItem OpenLocationMenuItem;\n        private System.Windows.Forms.MenuItem ExitMenuItem;\n        private System.Windows.Forms.Panel panel1;\n        private System.Windows.Forms.CheckBox WrapTextCheckBox;\n        private System.Windows.Forms.Button CleanLogsButton;\n        private System.Windows.Forms.Button ChangeFontButton;\n        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel1;
    }\n}
            }\n        }\n        private static void CheckPort(int port)\n        {\n            if (port <= 0 || port > 65535)\n            {\n                throw new ArgumentException(I18N.GetString("Port out of range"));\n            }\n        }\n        private static void CheckPassword(string password)
            }\n        }\n        private static void CheckPassword(string password)\n        {\n            if (string.IsNullOrEmpty(password))\n            {\n                throw new ArgumentException(I18N.GetString("Password can not be blank"));\n            }\n        }\n        private static void CheckServer(string server)
            }\n        }\n        private static void CheckServer(string server)\n        {\n            if (string.IsNullOrEmpty(server))\n            {\n                throw new ArgumentException(I18N.GetString("Server IP can not be blank"));\n            }\n        }\n        private static void CheckRemark(string remark)
            }\n        }\n        private static void CheckRemark(string remark)\n        {\n            //remark is optional\n        }\n        private class JsonSerializerStrategy : SimpleJson.PocoJsonSerializerStrategy\n        {\n            // convert string to int\n            public override object DeserializeObject(object value, Type type)
        public event ErrorEventHandler Error;\n        public class ResultEventArgs : EventArgs\n        {\n            public bool Success;\n            public ResultEventArgs(bool success)\n            {\n                this.Success = success;\n            }\n        }\n        private void http_DownloadStringCompleted(object sender, DownloadStringCompletedEventArgs e)
                }\n            }\n            catch (Exception ex)\n            {\n                if (Error != null)\n                {\n                    Error(this, new ErrorEventArgs(ex));\n                }\n            }\n        }
                StreamWriterWithTimestamp sw = new StreamWriterWithTimestamp(fs);\n                sw.AutoFlush = true;\n                Console.SetOut(sw);\n                Console.SetError(sw);\n                return true;\n            }\n            catch (IOException e)\n            {\n                Console.WriteLine(e.ToString());\n                return false;
        }\n        private void ReceiveCallback(IAsyncResult ar)\n        {\n            try\n            {\n                var bytesRead = _socket.EndReceive(ar);\n                if (bytesRead == 0)\n                {\n                    OnFinish();
            try\n            {\n                var bytesRead = _socket.EndReceive(ar);\n                if (bytesRead == 0)\n                {\n                    OnFinish();\n                    return;\n                }\n                _bufferDataLength += bytesRead;\n                NewPackageRecv();
                    return;\n                }\n                _bufferDataLength += bytesRead;\n                NewPackageRecv();\n            }\n            catch (Exception ex)\n            {\n                OnException(ex);\n                OnFinish();\n            }
                    return;\n                }\n            }\n            if (_bufferDataLength == _lineBuffer.Length)\n            {\n                OnException(new IndexOutOfRangeException("LineBuffer full! Try increace maxLineBytes!"));\n                OnFinish();\n                return;\n            }\n            if (_bufferDataIndex > 0)
        }\n        private void OnException(Exception ex)\n        {\n            _onException?.Invoke(ex, _state);\n        }\n        private void OnFinish()\n        {\n            _onFinish?.Invoke(_lineBuffer, _bufferDataIndex, _bufferDataLength, _state);\n        }\n        #region Boyer-Moore string search\n        private static int IndexOf(byte[] haystack, int index, int length, byte[] needle, int[] offsetTable, int[] charTable)
        }\n        #region Boyer-Moore string search\n        private static int IndexOf(byte[] haystack, int index, int length, byte[] needle, int[] offsetTable, int[] charTable)\n        {\n            var end = index + length;\n            for (int i = needle.Length - 1 + index, j; i < end;)\n            {\n                for (j = needle.Length - 1; needle[j] == haystack[i]; --i, --j)\n                {\n                    if (j == 0)\n                    {
        {\n            var end = index + length;\n            for (int i = needle.Length - 1 + index, j; i < end;)\n            {\n                for (j = needle.Length - 1; needle[j] == haystack[i]; --i, --j)\n                {\n                    if (j == 0)\n                    {\n                        return i;\n                    }
using System.Runtime.InteropServices;\nusing System.IO;\nusing Shadowsocks.Model;\nusing Shadowsocks.Util;\nnamespace Shadowsocks.Controller\n{\n    public static class SystemProxy\n    {\n        [DllImport("wininet.dll")]
using System.IO;\nusing Shadowsocks.Model;\nusing Shadowsocks.Util;\nnamespace Shadowsocks.Controller\n{\n    public static class SystemProxy\n    {\n        [DllImport("wininet.dll")]\n        public static extern bool InternetSetOption(IntPtr hInternet, int dwOption, IntPtr lpBuffer, int dwBufferLength);\n        public const int INTERNET_OPTION_SETTINGS_CHANGED = 39;
            }\n        }\n        private static void CopyProxySettingFromLan()\n        {\n            RegistryKey registry = null;\n            try {\n                registry = Utils.OpenUserRegKey( @"Software\Microsoft\Windows\CurrentVersion\Internet Settings\Connections", true );\n                if ( registry == null ) {\n                    Logging.Error( @"Cannot find HKCU\Software\Microsoft\Windows\CurrentVersion\Internet Settings" );\n                    return;
                var connections = registry.GetValueNames();\n                foreach ( var each in connections ) {\n                    switch ( each.ToUpperInvariant() ) {\n                        case "DEFAULTCONNECTIONSETTINGS":\n                        case "LAN CONNECTION":\n                        case "SAVEDLEGACYSETTINGS":
            }\n        }\n        /// <summary>\n        /// Checks or unchecks the IE Options Connection setting of "Automatically detect Proxy"\n        /// </summary>\n        /// <param name="set">Provide 'true' if you want to check the 'Automatically detect Proxy' check box. To uncheck, pass 'false'</param>\n        private static void IEAutoDetectProxy(bool set)\n        {\n            RegistryKey registry = null;\n            try {\n                registry = Utils.OpenUserRegKey( @"Software\Microsoft\Windows\CurrentVersion\Internet Settings\Connections", true );\n                if ( registry == null ) {\n                    Logging.Error( @"Cannot find HKCU\Software\Microsoft\Windows\CurrentVersion\Internet Settings" );\n                    return;
            }
        }\n    }\n}
            {\n                bool pipeExist = false;\n                try\n                {\n                    pipe.Connect(10);\n                    pipeExist = true;\n                }\n                catch (TimeoutException)\n                {\n                    pipeExist = false;
                {\n                    Process[] oldProcesses = Process.GetProcessesByName("Shadowsocks");\n                    if (oldProcesses.Length > 0)\n                    {\n                        Process oldProcess = oldProcesses[0];\n                    }\n                    MessageBox.Show(I18N.GetString("Find Shadowsocks icon in your notify tray.")\n                        + Environment.NewLine\n                        + I18N.GetString("If you want to start multiple Shadowsocks, make a copy in another directory."),\n                        I18N.GetString("Shadowsocks is already running."));
#if DEBUG\n            MainController = new ShadowsocksController();\n            MenuController = new MenuViewController(MainController);\n            HotKeys.Init(MainController);\n            MainController.Start();\n            Application.Run();\n        }
        }\n        private static int exited = 0;\n        private static void CurrentDomain_UnhandledException(object sender, UnhandledExceptionEventArgs e)\n        {\n            if (Interlocked.Increment(ref exited) == 1)\n            {\n                string errMsg = e.ExceptionObject.ToString();\n                logger.Error(errMsg);\n                MessageBox.Show(\n                    $"{I18N.GetString("Unexpected error, shadowsocks will exit. Please report to")} https://github.com/shadowsocks/shadowsocks-windows/issues {Environment.NewLine}{errMsg}",
            StatisticsChart.DataSource = _dataTable;\n            LoadChartData();\n            StatisticsChart.DataBind();\n        }\n        private void CancelButton_Click(object sender, EventArgs e)\n        {\n            Close();\n        }\n        private void OKButton_Click(object sender, EventArgs e)\n        {
            foreach (var data in finalData)\n            {\n                _dataTable.Rows.Add(data.Timestamp, data.Speed, data.PackageLossPercentage, data.Ping);\n            }\n            StatisticsChart.DataBind();\n        }\n        private void serverSelector_SelectionChangeCommitted(object sender, EventArgs e)\n        {\n            LoadChartData();
            }\n            StatisticsChart.DataBind();\n        }\n        private void serverSelector_SelectionChangeCommitted(object sender, EventArgs e)\n        {\n            LoadChartData();\n        }
        {\n            LoadChartData();\n        }\n        private void dayMode_CheckedChanged(object sender, EventArgs e)\n        {\n            LoadChartData();\n        }
        }\n        private void dayMode_CheckedChanged(object sender, EventArgs e)\n        {\n            LoadChartData();\n        }\n        private void allMode_CheckedChanged(object sender, EventArgs e)\n        {\n            LoadChartData();\n        }\n        private void PingCheckBox_CheckedChanged(object sender, EventArgs e)
            this.chartModeSelector.SuspendLayout();\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer1)).BeginInit();\n            this.splitContainer1.Panel1.SuspendLayout();\n            this.splitContainer1.Panel2.SuspendLayout();\n            this.splitContainer1.SuspendLayout();\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer2)).BeginInit();\n            this.splitContainer2.Panel1.SuspendLayout();\n            this.splitContainer2.Panel2.SuspendLayout();\n            this.splitContainer2.SuspendLayout();\n            ((System.ComponentModel.ISupportInitialize)(this.dataCollectionMinutesNum)).BeginInit();
            series1.Legend = "ChartLegend";\n            series1.Name = "Speed";\n            series1.ToolTip = "Max inbound speed\\n#VAL KiB/s";\n            series2.ChartArea = "DataArea";\n            series2.ChartType = System.Windows.Forms.DataVisualization.Charting.SeriesChartType.Bubble;\n            series2.Color = System.Drawing.Color.Crimson;\n            series2.CustomProperties = "EmptyPointValue=Zero";
            series2.ChartArea = "DataArea";\n            series2.ChartType = System.Windows.Forms.DataVisualization.Charting.SeriesChartType.Bubble;\n            series2.Color = System.Drawing.Color.Crimson;\n            series2.CustomProperties = "EmptyPointValue=Zero";\n            series2.Legend = "ChartLegend";\n            series2.Name = "Package Loss";\n            series2.ToolTip = "#VAL%";\n            series2.YAxisType = System.Windows.Forms.DataVisualization.Charting.AxisType.Secondary;
            series2.Legend = "ChartLegend";\n            series2.Name = "Package Loss";\n            series2.ToolTip = "#VAL%";\n            series2.YAxisType = System.Windows.Forms.DataVisualization.Charting.AxisType.Secondary;\n            series2.YValuesPerPoint = 2;\n            series3.BorderWidth = 5;\n            series3.ChartArea = "DataArea";\n            series3.ChartType = System.Windows.Forms.DataVisualization.Charting.SeriesChartType.Line;\n            series3.Color = System.Drawing.Color.DodgerBlue;
            series3.ChartArea = "DataArea";\n            series3.ChartType = System.Windows.Forms.DataVisualization.Charting.SeriesChartType.Line;\n            series3.Color = System.Drawing.Color.DodgerBlue;\n            series3.Legend = "ChartLegend";\n            series3.MarkerSize = 10;\n            series3.MarkerStyle = System.Windows.Forms.DataVisualization.Charting.MarkerStyle.Circle;\n            series3.Name = "Ping";\n            series3.ToolTip = "#VAL ms";\n            this.StatisticsChart.Series.Add(series1);
            series3.Legend = "ChartLegend";\n            series3.MarkerSize = 10;\n            series3.MarkerStyle = System.Windows.Forms.DataVisualization.Charting.MarkerStyle.Circle;\n            series3.Name = "Ping";\n            series3.ToolTip = "#VAL ms";\n            this.StatisticsChart.Series.Add(series1);\n            this.StatisticsChart.Series.Add(series2);\n            this.StatisticsChart.Series.Add(series3);
            this.StatisticsChart.Series.Add(series1);\n            this.StatisticsChart.Series.Add(series2);\n            this.StatisticsChart.Series.Add(series3);\n            // \n            // PingCheckBox\n            // \n            this.PingCheckBox.AutoSize = true;
            // \n            // PingCheckBox\n            // \n            this.PingCheckBox.AutoSize = true;\n            this.PingCheckBox.DataBindings.Add(new System.Windows.Forms.Binding("Checked", this.bindingConfiguration, "Ping", true));\n            this.PingCheckBox.Location = new System.Drawing.Point(13, 54);\n            this.PingCheckBox.Margin = new System.Windows.Forms.Padding(5, 10, 5, 10);\n            this.PingCheckBox.Name = "PingCheckBox";
            this.chartModeSelector.ResumeLayout(false);\n            this.chartModeSelector.PerformLayout();\n            this.splitContainer1.Panel1.ResumeLayout(false);\n            this.splitContainer1.Panel2.ResumeLayout(false);\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer1)).EndInit();\n            this.splitContainer1.ResumeLayout(false);\n            this.splitContainer2.Panel1.ResumeLayout(false);\n            this.splitContainer2.Panel1.PerformLayout();\n            this.splitContainer2.Panel2.ResumeLayout(false);\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer2)).EndInit();
      public static readonly Mode BYTE = new Mode(new int[] { 8, 16, 16 }, 0x04, "BYTE");\n      private readonly int[] characterCountBitsForVersions;\n      private readonly int bits;\n      private readonly String name;\n      private Mode(int[] characterCountBitsForVersions, int bits, System.String name)
      private readonly int[] characterCountBitsForVersions;\n      private readonly int bits;\n      private readonly String name;\n      private Mode(int[] characterCountBitsForVersions, int bits, System.String name)\n      {\n         this.characterCountBitsForVersions = characterCountBitsForVersions;\n         this.bits = bits;\n         this.name = name;\n      }\n      /// <summary>
            case 0x4:\n               return BYTE;
            default:\n               throw new ArgumentException();\n         }\n      }\n      /// <param name="version">version in question\n      /// </param>\n      /// <returns> number of bits used, in this QR Code symbol {@link Version}, to encode the\n      /// count of characters that will follow encoded in this {@link Mode}\n      /// </returns>\n      public int getCharacterCountBits(Version version)
      public static GenericGF QR_CODE_FIELD_256 = new GenericGF(0x011D, 256, 0); // x^8 + x^4 + x^3 + x^2 + 1\n      private int[] expTable;\n      private int[] logTable;\n      private GenericGFPoly zero;\n      private GenericGFPoly one;\n      private readonly int size;\n      private readonly int primitive;
      private int[] expTable;\n      private int[] logTable;\n      private GenericGFPoly zero;\n      private GenericGFPoly one;\n      private readonly int size;\n      private readonly int primitive;\n      private readonly int generatorBase;\n      /// <summary>\n      /// Create a representation of GF(size) using the given primitive polynomial.\n      /// </summary>
    {\n        private static Logger logger = LogManager.GetCurrentClassLogger();\n        public static event EventHandler<GeositeResultEventArgs> UpdateCompleted;
        public static event ErrorEventHandler Error;\n        private static readonly string DATABASE_PATH = Utils.GetTempPath("dlc.dat");\n        // temporary workaround\n        private static readonly string GEOSITE_URL = "https://github.com/v2ray/domain-list-community/releases/download/202005010407/dlc.dat";\n        public static readonly Dictionary<string, IList<DomainObject>> Geosites = new Dictionary<string, IList<DomainObject>>();\n        static GeositeUpdater()\n        {\n            if (!File.Exists(DATABASE_PATH))\n            {\n                File.WriteAllBytes(DATABASE_PATH, Resources.dlc_dat);
            }\n            UpdateSystemProxy();\n        }\n        public Server GetCurrentServer()\n        {\n            return _config.GetCurrentServer();\n        }\n        // always return copy\n        public Configuration GetConfiguration()\n        {
            if (methodname.IsNullOrEmpty()) throw new ArgumentException(nameof(methodname));\n            MethodInfo dynMethod = typeof(HotkeyCallbacks).GetMethod(methodname,\n                BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.IgnoreCase);\n            return dynMethod == null ? null : Delegate.CreateDelegate(typeof(HotKeys.HotKeyCallBackHandler), HotkeyCallbacks.Instance, dynMethod);\n        }\n        #endregion\n    }\n}
                BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.IgnoreCase);\n            return dynMethod == null ? null : Delegate.CreateDelegate(typeof(HotKeys.HotKeyCallBackHandler), HotkeyCallbacks.Instance, dynMethod);\n        }\n        #endregion\n    }\n}
        }\n        #endregion\n    }\n}
using GlobalHotKey;\nusing System.Windows.Input;\nusing System.Threading;\nusing System.Collections.Generic;\nusing Shadowsocks.Controller.Hotkeys;\nnamespace test\n{\n    [TestClass]\n    public class UnitTest\n    {
{\n    public static class HotKeys\n    {\n        private static HotKeyManager _hotKeyManager;\n        public delegate void HotKeyCallBackHandler();\n        // map key and corresponding handler function\n        private static Dictionary<HotKey, HotKeyCallBackHandler> _keymap = new Dictionary<HotKey, HotKeyCallBackHandler>();\n        public static void Init(ShadowsocksController controller)\n        {\n            _hotKeyManager = new HotKeyManager();\n            _hotKeyManager.KeyPressed += HotKeyManagerPressed;
        {\n            _hotKeyManager = new HotKeyManager();\n            _hotKeyManager.KeyPressed += HotKeyManagerPressed;\n            HotkeyCallbacks.InitInstance(controller);\n        }\n        public static void Destroy()\n        {\n            _hotKeyManager.KeyPressed -= HotKeyManagerPressed;\n            _hotKeyManager.Dispose();\n        }
                            // Multiply with flyBlue\n                            int red = color.R * flyBlue.R / 255;\n                            int green = color.G * flyBlue.G / 255;\n                            int blue = color.B * flyBlue.B / 255;\n                            int alpha = color.A * flyBlue.A / 255;\n                            iconCopy.SetPixel(x, y, Color.FromArgb(alpha, red, green, blue));\n                        }\n                        else if (global)\n                        {\n                            Color flyBlue = Color.FromArgb(25, 125, 191);
                        }\n                        else if (global)\n                        {\n                            Color flyBlue = Color.FromArgb(25, 125, 191);\n                            // Multiply with flyBlue\n                            int red = color.R * flyBlue.R / 255;\n                            int green = color.G * flyBlue.G / 255;\n                            int blue = color.B * flyBlue.B / 255;\n                            iconCopy.SetPixel(x, y, Color.FromArgb(color.A, red, green, blue));\n                        }
            try\n            {\n                var strategy = GetCurrentStrategy();\n                if (strategy != null)\n                {\n                    strategy.ReloadServers();\n                }\n                TCPRelay tcpRelay = new TCPRelay(this, _config);\n                UDPRelay udpRelay = new UDPRelay(this);
                TCPRelay tcpRelay = new TCPRelay(this, _config);\n                UDPRelay udpRelay = new UDPRelay(this);\n                List<Listener.IService> services = new List<Listener.IService>();\n                services.Add(tcpRelay);\n                services.Add(udpRelay);\n                services.Add(_pacServer);\n                _listener = new Listener(services);\n                _listener.Start(_config);\n            }
                _listener = new Listener(services);\n                _listener.Start(_config);\n            }\n            catch (Exception e)\n            {\n                // translate Microsoft language into human language\n                // i.e. An attempt was made to access a socket in a way forbidden by its access permissions => Port already in use\n                if (e is SocketException)\n                {\n                    SocketException se = (SocketException)e;
        [DllImport("kernel32.dll")]\n        private static extern bool SetInformationJobObject(IntPtr hJob, JobObjectInfoType infoType, IntPtr lpJobObjectInfo, UInt32 cbJobObjectInfoLength);\n        [DllImport("kernel32.dll", SetLastError = true)]\n        private static extern bool AssignProcessToJobObject(IntPtr job, IntPtr process);\n        [DllImport("kernel32.dll", SetLastError = true)]\n        [return: MarshalAs(UnmanagedType.Bool)]\n        private static extern bool CloseHandle(IntPtr hObject);\n        private IntPtr handle;\n        private bool disposed;\n        public Job()
        [DllImport("kernel32.dll", SetLastError = true)]\n        private static extern bool AssignProcessToJobObject(IntPtr job, IntPtr process);\n        [DllImport("kernel32.dll", SetLastError = true)]\n        [return: MarshalAs(UnmanagedType.Bool)]\n        private static extern bool CloseHandle(IntPtr hObject);\n        private IntPtr handle;\n        private bool disposed;\n        public Job()\n        {\n            handle = CreateJobObject(IntPtr.Zero, null);
        [DllImport("kernel32.dll", SetLastError = true)]\n        [return: MarshalAs(UnmanagedType.Bool)]\n        private static extern bool CloseHandle(IntPtr hObject);\n        private IntPtr handle;\n        private bool disposed;\n        public Job()\n        {\n            handle = CreateJobObject(IntPtr.Zero, null);\n            var extendedInfoPtr = IntPtr.Zero;\n            var info = new JOBOBJECT_BASIC_LIMIT_INFORMATION
        private IntPtr handle;\n        private bool disposed;\n        public Job()\n        {\n            handle = CreateJobObject(IntPtr.Zero, null);\n            var extendedInfoPtr = IntPtr.Zero;\n            var info = new JOBOBJECT_BASIC_LIMIT_INFORMATION\n            {\n                LimitFlags = 0x2000\n            };
        }\n        public void Dispose()\n        {\n            Dispose(true);\n            GC.SuppressFinalize(this);\n        }\n        private void Dispose(bool disposing)\n        {\n            if (disposed)\n                return;
            ServersListBox.SelectedIndex = modifiedConfiguration.index;\n            loadSelectedServer();\n            enableItem.Checked = modifiedConfiguration.enabled;\n        }\n        private void ConfigForm_Load(object sender, EventArgs e)\n        {\n            if (!controller.GetConfiguration().isDefault)\n            {\n                this.Opacity = 0;\n                BeginInvoke(new MethodInvoker(delegate
            enableItem.Checked = modifiedConfiguration.enabled;\n        }\n        private void ConfigForm_Load(object sender, EventArgs e)\n        {\n            if (!controller.GetConfiguration().isDefault)\n            {\n                this.Opacity = 0;\n                BeginInvoke(new MethodInvoker(delegate\n                {\n                    this.Hide();

using System.Collections.Generic;\nusing System.Runtime.InteropServices;\nusing System.Text;\nnamespace shadowsocks_csharp.Encrypt\n{\n    public class OpensslEncryptor\n        : EncryptorBase, IDisposable\n    {\n        static Dictionary<string, int[]> ciphers = new Dictionary<string, int[]> {\n            {"aes-128-cfb", new int[]{16, 16}},
                byte[] iv = new byte[ivLen];\n                OpenSSL.RAND_bytes(iv, iv.Length);\n                InitCipher(ref _encryptCtx, iv, true);\n                int outLen = length + ivLen;\n                byte[] cipherText = new byte[outLen];\n                OpenSSL.EVP_CipherUpdate(_encryptCtx, cipherText, out outLen, buf, length);\n                byte[] result = new byte[outLen + ivLen];\n                Buffer.BlockCopy(iv, 0, result, 0, ivLen);\n                Buffer.BlockCopy(cipherText, 0, result, ivLen, outLen);\n                return result;
                InitCipher(ref _encryptCtx, iv, true);\n                int outLen = length + ivLen;\n                byte[] cipherText = new byte[outLen];\n                OpenSSL.EVP_CipherUpdate(_encryptCtx, cipherText, out outLen, buf, length);\n                byte[] result = new byte[outLen + ivLen];\n                Buffer.BlockCopy(iv, 0, result, 0, ivLen);\n                Buffer.BlockCopy(cipherText, 0, result, ivLen, outLen);\n                return result;\n            }\n            else
                byte[] cipherText = new byte[outLen];\n                OpenSSL.EVP_CipherUpdate(_encryptCtx, cipherText, out outLen, buf, length);\n                byte[] result = new byte[outLen + ivLen];\n                Buffer.BlockCopy(iv, 0, result, 0, ivLen);\n                Buffer.BlockCopy(cipherText, 0, result, ivLen, outLen);\n                return result;\n            }\n            else\n            {\n                int outLen = length + ivLen;
                byte[] result = new byte[outLen + ivLen];\n                Buffer.BlockCopy(iv, 0, result, 0, ivLen);\n                Buffer.BlockCopy(cipherText, 0, result, ivLen, outLen);\n                return result;\n            }\n            else\n            {\n                int outLen = length + ivLen;\n                byte[] cipherText = new byte[outLen];\n                OpenSSL.EVP_CipherUpdate(_encryptCtx, cipherText, out outLen, buf, length);
                byte[] cipherText = new byte[outLen];\n                OpenSSL.EVP_CipherUpdate(_encryptCtx, cipherText, out outLen, buf, length);\n                byte[] result = new byte[outLen];\n                Buffer.BlockCopy(cipherText, 0, result, 0, outLen);\n                return result;\n            }\n        }\n        public override byte[] Decrypt(byte[] buf, int length)\n        {\n            if (_decryptCtx == IntPtr.Zero)
                byte[] result = new byte[outLen];\n                Buffer.BlockCopy(cipherText, 0, result, 0, outLen);\n                return result;\n            }\n        }\n        public override byte[] Decrypt(byte[] buf, int length)\n        {\n            if (_decryptCtx == IntPtr.Zero)\n            {
                byte[] iv = new byte[ivLen];\n                Buffer.BlockCopy(buf, 0, iv, 0, ivLen);\n                InitCipher(ref _decryptCtx, iv, false);\n                int outLen = length + ivLen;\n                outLen -= ivLen;\n                byte[] cipherText = new byte[outLen];\n                byte[] subset = new byte[length - ivLen];\n                Buffer.BlockCopy(buf, ivLen, subset, 0, length - ivLen);\n                OpenSSL.EVP_CipherUpdate(_decryptCtx, cipherText, out outLen, subset, length - ivLen);\n                byte[] result = new byte[outLen];
                outLen -= ivLen;\n                byte[] cipherText = new byte[outLen];\n                byte[] subset = new byte[length - ivLen];\n                Buffer.BlockCopy(buf, ivLen, subset, 0, length - ivLen);\n                OpenSSL.EVP_CipherUpdate(_decryptCtx, cipherText, out outLen, subset, length - ivLen);\n                byte[] result = new byte[outLen];\n                Buffer.BlockCopy(cipherText, 0, result, 0, outLen);\n                return result;\n            }\n            else
                byte[] result = new byte[outLen];\n                Buffer.BlockCopy(cipherText, 0, result, 0, outLen);\n                return result;\n            }\n            else\n            {\n                int outLen = length + ivLen;\n                byte[] cipherText = new byte[outLen];\n                OpenSSL.EVP_CipherUpdate(_decryptCtx, cipherText, out outLen, buf, length);\n                byte[] result = new byte[outLen];
                byte[] cipherText = new byte[outLen];\n                OpenSSL.EVP_CipherUpdate(_decryptCtx, cipherText, out outLen, buf, length);\n                byte[] result = new byte[outLen];\n                Buffer.BlockCopy(cipherText, 0, result, 0, outLen);\n                return result;\n            }\n        }\n        private static readonly Dictionary<string, byte[]> CachedKeys = new Dictionary<string, byte[]>();\n        private byte[] _key;
                byte[] result = new byte[outLen];\n                Buffer.BlockCopy(cipherText, 0, result, 0, outLen);\n                return result;\n            }\n        }\n        private static readonly Dictionary<string, byte[]> CachedKeys = new Dictionary<string, byte[]>();\n        private byte[] _key;\n        private IntPtr _encryptCtx;
        private byte[] _key;\n        private IntPtr _encryptCtx;\n        private IntPtr _decryptCtx;\n        private IntPtr _cipher;\n        private int keyLen;\n        private int ivLen;\n        private void InitKey(string method, string password)\n        {\n            OpenSSL.OpenSSL_add_all_ciphers();
        private IntPtr _encryptCtx;\n        private IntPtr _decryptCtx;\n        private IntPtr _cipher;\n        private int keyLen;\n        private int ivLen;\n        private void InitKey(string method, string password)\n        {\n            OpenSSL.OpenSSL_add_all_ciphers();\n            method = method.ToLower();\n            string k = method + ":" + password;
            }\n            else\n            {\n                byte[] passbuf = Encoding.UTF8.GetBytes(password);\n                _key = new byte[32];\n                byte[] iv = new byte[16];\n                OpenSSL.EVP_BytesToKey(_cipher, OpenSSL.EVP_md5(), IntPtr.Zero, passbuf, passbuf.Length, 1, _key, iv);\n                CachedKeys[k] = _key;
            {\n                byte[] passbuf = Encoding.UTF8.GetBytes(password);\n                _key = new byte[32];\n                byte[] iv = new byte[16];\n                OpenSSL.EVP_BytesToKey(_cipher, OpenSSL.EVP_md5(), IntPtr.Zero, passbuf, passbuf.Length, 1, _key, iv);\n                CachedKeys[k] = _key;\n            }
            }\n        }\n        private void InitCipher(ref IntPtr ctx, byte[] iv, bool isCipher)\n        {
        }\n        private void InitCipher(ref IntPtr ctx, byte[] iv, bool isCipher)\n        {\n            ctx = OpenSSL.EVP_CIPHER_CTX_new();\n            int enc = isCipher ? 1 : 0;\n            OpenSSL.EVP_CipherInit_ex(ctx, _cipher, IntPtr.Zero, _key, iv, enc);
            int enc = isCipher ? 1 : 0;\n            OpenSSL.EVP_CipherInit_ex(ctx, _cipher, IntPtr.Zero, _key, iv, enc);\n        }\n        #region IDisposable\n        private bool _disposed;
        }\n        #region IDisposable\n        private bool _disposed;\n        public void Dispose()\n        {\n            Dispose(true);\n            GC.SuppressFinalize(this);\n        }\n        ~OpensslEncryptor()\n        {
            availabilityStatistics.UpdateConfiguration(this);\n            _listener?.Stop();\n            StopPlugins();\n            // don't put PrivoxyRunner.Start() before pacServer.Stop()\n            // or bind will fail when switching bind address from 0.0.0.0 to 127.0.0.1\n            // though UseShellExecute is set to true now
            StopPlugins();\n            // don't put PrivoxyRunner.Start() before pacServer.Stop()\n            // or bind will fail when switching bind address from 0.0.0.0 to 127.0.0.1\n            // though UseShellExecute is set to true now\n            // http://stackoverflow.com/questions/10235093/socket-doesnt-close-after-application-exits-if-a-launched-process-is-open\n            privoxyRunner.Stop();\n            try\n            {\n                var strategy = GetCurrentStrategy();\n                strategy?.ReloadServers();
                StartPlugin();\n                privoxyRunner.Start(_config);\n                TCPRelay tcpRelay = new TCPRelay(this, _config);\n                UDPRelay udpRelay = new UDPRelay(this);\n                List<Listener.IService> services = new List<Listener.IService>\n                {\n                    tcpRelay,\n                    udpRelay,\n                    _pacServer,\n                    new PortForwarder(privoxyRunner.RunningPort)
            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                return false;\n            }\n        }\n        public static bool Check()\n        {\n            try
}

                new MenuItem("-"),\n                CreateMenuItem("Show Logs...", new EventHandler(this.ShowLogItem_Click)),\n                CreateMenuItem("About...", new EventHandler(this.AboutItem_Click)),\n                new MenuItem("-"),\n                CreateMenuItem("Quit", new EventHandler(this.Quit_Click))\n            });\n        }\n        private void controller_ConfigChanged(object sender, EventArgs e)\n        {\n            LoadCurrentConfiguration();
                {\n                    Console.WriteLine(e.ToString());\n                }\n                _process = null;\n            }\n        }\n    }\n}
            return remarks.IsNullOrEmpty()\n                ? serverStr\n                : $"{remarks} ({serverStr})";\n        }\n        public string FormatHostName(string hostName)\n        {\n            // CheckHostName() won't do a real DNS lookup\n            switch (Uri.CheckHostName(hostName))\n            {\n                case UriHostNameType.IPv6:  // Add square bracket when IPv6 (RFC3986)
        private static string GetTimestamp(DateTime value)\n        {\n            return value.ToString("yyyyMMddHHmmssfff");\n        }\n        public static void Update(Configuration config, bool forceDisable, PACServer pacSrv, bool noRetry = false)\n        {\n            bool global = config.global;\n            bool enabled = config.enabled;\n            if (forceDisable)
        {\n            bool global = config.global;\n            bool enabled = config.enabled;\n            if (forceDisable)\n            {\n                enabled = false;\n            }\n            try\n            {
            bool global = config.global;\n            bool enabled = config.enabled;\n            if (forceDisable)\n            {\n                enabled = false;\n            }\n            try\n            {\n                if (enabled)\n                {
                {\n                    var ret = MessageBox.Show(I18N.GetString("Error occured when process proxy setting, do you want reset current setting and retry?"), I18N.GetString("Shadowsocks"), MessageBoxButtons.YesNo, MessageBoxIcon.Warning);\n                    if (ret == DialogResult.Yes)\n                    {\n                        Sysproxy.ResetIEProxy();\n                        Update(config, forceDisable, pacSrv, true);\n                    }\n                }\n                else\n                {
                }\n            }\n        }\n    }\n}
        {\n            // These lines implement the Interface in the beginning of program \n            // They cause the OS to refresh the settings, causing IP to realy update\n            settingsReturn = InternetSetOption(IntPtr.Zero, INTERNET_OPTION_SETTINGS_CHANGED, IntPtr.Zero, 0);\n            refreshReturn = InternetSetOption(IntPtr.Zero, INTERNET_OPTION_REFRESH, IntPtr.Zero, 0);\n        }\n        public static void Enable()\n        {\n            RegistryKey registry = Registry.CurrentUser.OpenSubKey("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings", true);
            // These lines implement the Interface in the beginning of program \n            // They cause the OS to refresh the settings, causing IP to realy update\n            settingsReturn = InternetSetOption(IntPtr.Zero, INTERNET_OPTION_SETTINGS_CHANGED, IntPtr.Zero, 0);\n            refreshReturn = InternetSetOption(IntPtr.Zero, INTERNET_OPTION_REFRESH, IntPtr.Zero, 0);\n        }\n        public static void Enable()\n        {\n            RegistryKey registry = Registry.CurrentUser.OpenSubKey("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings", true);\n            registry.SetValue("ProxyEnable", 1);\n            registry.SetValue("ProxyServer", "127.0.0.1:8123");\n            SystemProxy.UpdateIE();\n        }
        {\n            RegistryKey registry = Registry.CurrentUser.OpenSubKey("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings", true);\n            registry.SetValue("ProxyEnable", 0);\n            registry.SetValue("ProxyServer", "");\n            SystemProxy.UpdateIE();\n        }\n    }\n}
        }\n    }\n}
    public class AvailabilityStatistics\n    {\n        public static readonly string DateTimePattern = "yyyy-MM-dd HH:mm:ss";\n        private const string StatisticsFilesName = "shadowsocks.availability.csv";\n        private const string Delimiter = ",";\n        private const int Timeout = 500;\n        private const int DelayBeforeStart = 1000;\n        public Statistics RawStatistics { get; private set; }\n        public Statistics FilteredStatistics { get; private set; }\n        private int Repeat => _config.RepeatTimesNum;
        private const int RetryInterval = 2*60*1000; //retry 2 minutes after failed
                    ret.Add(new List<KeyValuePair<string, string>>\n                    {\n                        new KeyValuePair<string, string>("Timestamp", timestamp),\n                        new KeyValuePair<string, string>("Server", server.FriendlyName()),\n                        new KeyValuePair<string, string>("Status", reply?.Status.ToString()),\n                        new KeyValuePair<string, string>("RoundtripTime", reply?.RoundtripTime.ToString())\n                        //new KeyValuePair<string, string>("data", reply.Buffer.ToString()); // The data of reply\n                    });\n                    Thread.Sleep(Timeout + new Random().Next() % Timeout);\n                    //Do ICMPTest in a random frequency\n                }
                    //Do ICMPTest in a random frequency\n                }\n                catch (Exception e)\n                {\n                    Console.WriteLine($"An exception occured when eveluating {server.FriendlyName()}");\n                    Logging.LogUsefulException(e);\n                }\n            }\n            return ret;\n        }
                    tcprelay.UpdateOutboundCounter(server, bytesToSend);\n                    _startSendingTime = DateTime.Now;\n                    _bytesToSend = bytesToSend;\n                    remote.BeginSend(connetionSendBuffer, 0, bytesToSend, 0, new AsyncCallback(PipeRemoteSendCallback), null);\n                    IStrategy strategy = controller.GetCurrentStrategy();\n                    strategy?.UpdateLastWrite(server);\n                }\n                else\n                {\n                    remote.Shutdown(SocketShutdown.Send);
            this.label2 = new System.Windows.Forms.Label();\n            this.label3 = new System.Windows.Forms.Label();\n            this.chartModeSelector = new System.Windows.Forms.GroupBox();\n            this.allMode = new System.Windows.Forms.RadioButton();\n            this.dayMode = new System.Windows.Forms.RadioButton();\n            this.splitContainer1 = new System.Windows.Forms.SplitContainer();\n            this.splitContainer2 = new System.Windows.Forms.SplitContainer();\n            this.label9 = new System.Windows.Forms.Label();\n            this.label8 = new System.Windows.Forms.Label();
            this.chartModeSelector = new System.Windows.Forms.GroupBox();\n            this.allMode = new System.Windows.Forms.RadioButton();\n            this.dayMode = new System.Windows.Forms.RadioButton();\n            this.splitContainer1 = new System.Windows.Forms.SplitContainer();\n            this.splitContainer2 = new System.Windows.Forms.SplitContainer();\n            this.label9 = new System.Windows.Forms.Label();\n            this.label8 = new System.Windows.Forms.Label();\n            this.dataCollectionMinutesNum = new System.Windows.Forms.NumericUpDown();\n            this.StatisticsEnabledCheckBox = new System.Windows.Forms.CheckBox();\n            this.choiceKeptMinutesNum = new System.Windows.Forms.NumericUpDown();
        private System.Windows.Forms.Label label2;\n        private System.Windows.Forms.Label label3;\n        private System.Windows.Forms.GroupBox chartModeSelector;\n        private System.Windows.Forms.RadioButton allMode;\n        private System.Windows.Forms.RadioButton dayMode;\n        private System.Windows.Forms.SplitContainer splitContainer1;\n        private System.Windows.Forms.Label label1;\n        private System.Windows.Forms.SplitContainer splitContainer2;\n        private System.Windows.Forms.FlowLayoutPanel calculationContainer;
        private System.Windows.Forms.GroupBox chartModeSelector;\n        private System.Windows.Forms.RadioButton allMode;\n        private System.Windows.Forms.RadioButton dayMode;\n        private System.Windows.Forms.SplitContainer splitContainer1;\n        private System.Windows.Forms.Label label1;\n        private System.Windows.Forms.SplitContainer splitContainer2;\n        private System.Windows.Forms.FlowLayoutPanel calculationContainer;\n        private System.Windows.Forms.SplitContainer splitContainer3;\n        private System.Windows.Forms.NumericUpDown repeatTimesNum;\n        private System.Windows.Forms.Label label6;
        public static string AvailabilityStatisticsFile;
        //static constructor to initialize every public static fields before refereced\n        static AvailabilityStatistics()\n        {\n            AvailabilityStatisticsFile = Utils.GetTempPath(StatisticsFilesName);\n            UnknownDateTime = new DateTime(1970, 1, 1);\n        }\n        //arguments for ICMP tests\n        private int Repeat => Config.RepeatTimesNum;\n        private const int TimeoutMilliseconds = 500;\n        //records cache for current server in {_monitorInterval} minutes\n        private List<int> _latencyRecords;
        // Static Singleton Initialization\n        public static AvailabilityStatistics Instance { get; } = new AvailabilityStatistics();\n        public Statistics RawStatistics { get; private set; }\n        public Statistics FilteredStatistics { get; private set; }\n        private AvailabilityStatistics()\n        {\n            RawStatistics = new Statistics();\n        }\n        internal void UpdateConfiguration(ShadowsocksController controller)\n        {\n            _controller = controller;
                    LoadRawStatistics();\n                    StartTimerWithoutState(ref _speedMonior, UpdateSpeed, _monitorInterval);\n                    StartTimerWithoutState(ref _writer, Save, _writingInterval);
                }\n                else\n                {\n                    _recorder?.Dispose();\n                    _speedMonior?.Dispose();\n                    _writer?.Dispose();\n                }\n            }\n            catch (Exception e)\n            {
            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n            }\n        }\n        private void StartTimerWithoutState(ref Timer timer, TimerCallback callback, TimeSpan interval)\n        {\n            if (timer?.Change(_delayBeforeStart, interval) == null)\n            {
        {\n            var bytes = _controller.inboundCounter - _lastInboundCounter;\n            _lastInboundCounter = _controller.inboundCounter;\n            var inboundSpeed = GetSpeedInKiBPerSecond(bytes, _monitorInterval.TotalSeconds);\n            _inboundSpeedRecords.Add(inboundSpeed);\n            bytes = _controller.outboundCounter - _lastOutboundCounter;\n            _lastOutboundCounter = _controller.outboundCounter;\n            var outboundSpeed = GetSpeedInKiBPerSecond(bytes, _monitorInterval.TotalSeconds);\n            _outboundSpeedRecords.Add(outboundSpeed);\n            Logging.Debug(
            Reset();\n            FilterRawStatistics();\n        }\n        private async void UpdateRecords()\n        {\n            var currentServerRecord = new StatisticsRecord(CurrentServer.Identifier(), _inboundSpeedRecords, _outboundSpeedRecords, _latencyRecords);\n            if (!Config.Ping)\n            {\n                AppendRecord(CurrentServer, currentServerRecord);\n                return;
            foreach (var result in (await icmpResults).Where(result => result != null))\n            {\n                if (result.Server.Equals(CurrentServer))\n                {\n                    currentServerRecord.setResponse(result.RoundtripTime);
                {\n                    currentServerRecord.setResponse(result.RoundtripTime);\n                    AppendRecord(CurrentServer, currentServerRecord);\n                }\n                else\n                {\n                    AppendRecord(result.Server, new StatisticsRecord(result.Server.Identifier(), result.RoundtripTime));\n                }\n            }\n        }
                }\n                else\n                {\n                    AppendRecord(result.Server, new StatisticsRecord(result.Server.Identifier(), result.RoundtripTime));\n                }\n            }\n        }\n        private void AppendRecord(Server server, StatisticsRecord record)\n        {\n            List<StatisticsRecord> records;
        }\n        private void Save(object _)\n        {\n            try\n            {\n                File.WriteAllText(AvailabilityStatisticsFile,\n                    JsonConvert.SerializeObject(RawStatistics, Formatting.None));\n            }\n            catch (IOException e)\n            {
        private bool IsValidRecord(StatisticsRecord record)\n        {\n            if (Config.ByHourOfDay)\n            {\n                if (record.Timestamp == UnknownDateTime) return false;\n                if (!record.Timestamp.Hour.Equals(DateTime.Now.Hour)) return false;\n            }\n            return true;\n        }
                if (record.Timestamp == UnknownDateTime) return false;\n                if (!record.Timestamp.Hour.Equals(DateTime.Now.Hour)) return false;\n            }\n            return true;\n        }\n        private void FilterRawStatistics()\n        {\n            if (RawStatistics == null) return;\n            if (FilteredStatistics == null)\n            {
            {\n                ChooseNewServer(_controller.GetCurrentConfiguration().configs);\n            }\n            return _currentServer;  //current server cached for CachedInterval\n        }\n        public void ReloadServers()\n        {
            }\n            return _currentServer;  //current server cached for CachedInterval\n        }\n        public void ReloadServers()\n        {\n            ChooseNewServer(_controller.GetCurrentConfiguration().configs);\n            _timer?.Change(0, ChoiceKeptMilliseconds);\n        }\n        public void SetFailure(Server server)\n        {
        }\n        private void CleanLogsButton_Click(object sender, EventArgs e)\n        {\n            DoCleanLogs();\n        }\n        #endregion\n        #region Change the font settings applied in LogMessageTextBox.\n        private void DoChangeFont()\n        {\n            try\n            {
        {\n            try\n            {\n                FontDialog fd = new FontDialog();\n                fd.Font = LogMessageTextBox.Font;\n                if (fd.ShowDialog() == DialogResult.OK)\n                {\n                    LogMessageTextBox.Font = new Font(fd.Font.FontFamily, fd.Font.Size, fd.Font.Style);\n                }\n            }
        }\n    }\n}
            this.FileMenuItem = new System.Windows.Forms.MenuItem();\n            this.OpenLocationMenuItem = new System.Windows.Forms.MenuItem();\n            this.ExitMenuItem = new System.Windows.Forms.MenuItem();\n            this.ViewMenuItem = new System.Windows.Forms.MenuItem();\n            this.CleanLogsMenuItem = new System.Windows.Forms.MenuItem();\n            this.ChangeFontMenuItem = new System.Windows.Forms.MenuItem();\n            this.WrapTextMenuItem = new System.Windows.Forms.MenuItem();\n            this.TopMostMenuItem = new System.Windows.Forms.MenuItem();\n            this.MenuItemSeparater = new System.Windows.Forms.MenuItem();\n            this.ShowToolbarMenuItem = new System.Windows.Forms.MenuItem();
            this.ChangeFontButton = new System.Windows.Forms.Button();\n            this.CleanLogsButton = new System.Windows.Forms.Button();\n            this.WrapTextCheckBox = new System.Windows.Forms.CheckBox();\n            this.tableLayoutPanel1 = new System.Windows.Forms.TableLayoutPanel();\n            this.ToolbarFlowLayoutPanel = new System.Windows.Forms.FlowLayoutPanel();\n            this.tableLayoutPanel1.SuspendLayout();\n            this.ToolbarFlowLayoutPanel.SuspendLayout();
            this.tableLayoutPanel1.SuspendLayout();\n            this.ToolbarFlowLayoutPanel.SuspendLayout();
            // \n            // ChangeFontButton\n            // \n            this.ChangeFontButton.AutoSize = true;\n            this.ChangeFontButton.Location = new System.Drawing.Point(84, 3);\n            this.ChangeFontButton.Name = "ChangeFontButton";\n            this.ChangeFontButton.Size = new System.Drawing.Size(75, 23);\n            this.ChangeFontButton.TabIndex = 2;\n            this.ChangeFontButton.Text = "&Font";\n            this.ChangeFontButton.UseVisualStyleBackColor = true;\n            this.ChangeFontButton.Click += new System.EventHandler(this.ChangeFontButton_Click);\n            // \n            // CleanLogsButton\n            this.CleanLogsButton.AutoSize = true;\n            this.CleanLogsButton.Location = new System.Drawing.Point(3, 3);
            this.ChangeFontButton.Name = "ChangeFontButton";\n            this.ChangeFontButton.Size = new System.Drawing.Size(75, 23);\n            this.ChangeFontButton.TabIndex = 2;\n            this.ChangeFontButton.Text = "&Font";\n            this.ChangeFontButton.UseVisualStyleBackColor = true;\n            this.ChangeFontButton.Click += new System.EventHandler(this.ChangeFontButton_Click);\n            // \n            // CleanLogsButton\n            // \n            this.CleanLogsButton.AutoSize = true;\n            this.CleanLogsButton.Location = new System.Drawing.Point(3, 3);\n            this.CleanLogsButton.Name = "CleanLogsButton";\n            this.CleanLogsButton.Size = new System.Drawing.Size(75, 23);
            this.CleanLogsButton.Name = "CleanLogsButton";\n            this.CleanLogsButton.Size = new System.Drawing.Size(75, 23);\n            this.CleanLogsButton.TabIndex = 1;\n            this.CleanLogsButton.Text = "&Clean logs";\n            this.CleanLogsButton.UseVisualStyleBackColor = true;\n            this.CleanLogsButton.Click += new System.EventHandler(this.CleanLogsButton_Click);\n            // \n            // WrapTextCheckBox\n            // \n            this.WrapTextCheckBox.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) \n            | System.Windows.Forms.AnchorStyles.Left)));\n            this.WrapTextCheckBox.AutoSize = true;
            this.tableLayoutPanel1.Controls.Add(this.LogMessageTextBox, 0, 1);\n            this.tableLayoutPanel1.Controls.Add(this.ToolbarFlowLayoutPanel, 0, 0);\n            this.tableLayoutPanel1.Dock = System.Windows.Forms.DockStyle.Fill;\n            this.tableLayoutPanel1.Location = new System.Drawing.Point(0, 0);\n            this.tableLayoutPanel1.Name = "tableLayoutPanel1";\n            this.tableLayoutPanel1.RowCount = 2;\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.Size = new System.Drawing.Size(590, 418);\n            this.tableLayoutPanel1.TabIndex = 2;
            this.tableLayoutPanel1.TabIndex = 2;\n            // \n            // ToolbarFlowLayoutPanel\n            // \n            this.ToolbarFlowLayoutPanel.AutoSize = true;\n            this.ToolbarFlowLayoutPanel.Controls.Add(this.CleanLogsButton);\n            this.ToolbarFlowLayoutPanel.Controls.Add(this.ChangeFontButton);\n            this.ToolbarFlowLayoutPanel.Controls.Add(this.WrapTextCheckBox);\n            this.ToolbarFlowLayoutPanel.Controls.Add(this.TopMostCheckBox);\n            this.ToolbarFlowLayoutPanel.Dock = System.Windows.Forms.DockStyle.Fill;\n            this.ToolbarFlowLayoutPanel.Location = new System.Drawing.Point(3, 3);

            this.tableLayoutPanel1.ResumeLayout(false);\n            this.tableLayoutPanel1.PerformLayout();\n            this.ToolbarFlowLayoutPanel.ResumeLayout(false);\n            this.ToolbarFlowLayoutPanel.PerformLayout();\n            this.ResumeLayout(false);\n        }\n        #endregion\n        private System.Windows.Forms.TextBox LogMessageTextBox;\n        private System.Windows.Forms.MainMenu MainMenu;\n        private System.Windows.Forms.MenuItem FileMenuItem;
        private System.Windows.Forms.MenuItem FileMenuItem;\n        private System.Windows.Forms.MenuItem OpenLocationMenuItem;\n        private System.Windows.Forms.MenuItem ExitMenuItem;\n        private System.Windows.Forms.CheckBox WrapTextCheckBox;\n        private System.Windows.Forms.Button CleanLogsButton;\n        private System.Windows.Forms.Button ChangeFontButton;\n        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel1;\n        private System.Windows.Forms.CheckBox TopMostCheckBox;\n        private System.Windows.Forms.MenuItem ViewMenuItem;
        private System.Windows.Forms.CheckBox WrapTextCheckBox;\n        private System.Windows.Forms.Button CleanLogsButton;\n        private System.Windows.Forms.Button ChangeFontButton;\n        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel1;\n        private System.Windows.Forms.CheckBox TopMostCheckBox;\n        private System.Windows.Forms.MenuItem ViewMenuItem;\n        private System.Windows.Forms.MenuItem CleanLogsMenuItem;\n        private System.Windows.Forms.MenuItem ChangeFontMenuItem;\n        private System.Windows.Forms.MenuItem WrapTextMenuItem;\n        private System.Windows.Forms.MenuItem TopMostMenuItem;
        public PortForwarder(int targetPort)\n        {\n            _targetPort = targetPort;\n        }\n        public override bool Handle(byte[] firstPacket, int length, Socket socket, object state)\n        {\n            if (socket.ProtocolType != ProtocolType.Tcp)\n            {\n                return false;\n            }
        }\n        public override bool Handle(byte[] firstPacket, int length, Socket socket, object state)\n        {\n            if (socket.ProtocolType != ProtocolType.Tcp)\n            {\n                return false;\n            }\n            new Handler().Start(firstPacket, length, socket, _targetPort);\n            return true;\n        }
            return true;\n        }\n        private class Handler\n        {\n            private byte[] _firstPacket;\n            private int _firstPacketLength;\n            private Socket _local;\n            private WrappedSocket _remote;\n            private bool _closed = false;\n            private bool _localShutdown = false;
        {\n            private byte[] _firstPacket;\n            private int _firstPacketLength;\n            private Socket _local;\n            private WrappedSocket _remote;\n            private bool _closed = false;\n            private bool _localShutdown = false;\n            private bool _remoteShutdown = false;\n            private const int RecvSize = 2048;\n            // remote receive buffer
            // remote receive buffer\n            private byte[] remoteRecvBuffer = new byte[RecvSize];\n            // connection receive buffer\n            private byte[] connetionRecvBuffer = new byte[RecvSize];\n            // instance-based lock\n            private readonly object _Lock = new object();\n            public void Start(byte[] firstPacket, int length, Socket socket, int targetPort)\n            {\n                _firstPacket = firstPacket;\n                _firstPacketLength = length;\n                _local = socket;\n                try\n                {
                try\n                {\n                    EndPoint remoteEP = SocketUtil.GetEndPoint("127.0.0.1", targetPort);\n                    // Connect to the remote endpoint.\n                    _remote = new WrappedSocket();\n                    _remote.BeginConnect(remoteEP, ConnectCallback, null);\n                }\n                catch (Exception e)\n                {\n                    Logging.LogUsefulException(e);\n                    Close();
                }\n            }\n            private void ConnectCallback(IAsyncResult ar)\n            {\n                if (_closed)\n                {\n                    return;\n                }\n                try\n                {
                    _local.BeginReceive(connetionRecvBuffer, 0, RecvSize, 0,\n                        PipeConnectionReceiveCallback, null);\n                }\n                catch (Exception e)\n                {\n                    Logging.LogUsefulException(e);\n                    Close();\n                }\n            }\n            private void PipeRemoteReceiveCallback(IAsyncResult ar)
                }\n            }\n            private void PipeRemoteReceiveCallback(IAsyncResult ar)\n            {\n                if (_closed)\n                {\n                    return;\n                }\n                try\n                {
                }\n            }\n            private void CheckClose()\n            {\n                if (_localShutdown && _remoteShutdown)\n                {\n                    Close();\n                }\n            }\n            public void Close()
                }\n            }\n            public void Close()\n            {\n                lock (_Lock)\n                {\n                    if (_closed)\n                    {\n                        return;\n                    }
                _key = CachedKeys[k];
        }\n        protected void bytesToKey(byte[] password, byte[] key)\n        {\n            byte[] result = new byte[password.Length + 16];\n            int i = 0;\n            byte[] md5sum = null;\n            while (i < key.Length)\n            {\n                if (i == 0)\n                {
{\n    public class DirectConnect : IForwardProxy\n    {\n        private class FakeAsyncResult : IAsyncResult\n        {\n            public FakeAsyncResult(object state)\n            {\n                AsyncState = state;\n            }\n            public bool IsCompleted { get; } = true;
    {\n        private class FakeAsyncResult : IAsyncResult\n        {\n            public FakeAsyncResult(object state)\n            {\n                AsyncState = state;\n            }\n            public bool IsCompleted { get; } = true;\n            public WaitHandle AsyncWaitHandle { get; } = null;\n            public object AsyncState { get; }
{\n    public class HttpProxy : IForwardProxy\n    {\n        private class FakeAsyncResult : IAsyncResult\n        {\n            public readonly HttpState innerState;\n            private readonly IAsyncResult r;\n            public FakeAsyncResult(IAsyncResult orig, HttpState state)\n            {\n                r = orig;
    {\n        private class FakeAsyncResult : IAsyncResult\n        {\n            public readonly HttpState innerState;\n            private readonly IAsyncResult r;\n            public FakeAsyncResult(IAsyncResult orig, HttpState state)\n            {\n                r = orig;\n                innerState = state;\n            }
using Shadowsocks.Util.Sockets;\nnamespace Shadowsocks.Controller\n{\n    class TCPRelay : Listener.Service\n    {\n        private ShadowsocksController _controller;\n        private DateTime _lastSweepTime;\n        private Configuration _config;\n        public ISet<TCPHandler> Handlers { get; set; }\n        public TCPRelay(ShadowsocksController controller, Configuration conf)
{\n    public interface IForwardProxy\n    {\n        EndPoint LocalEndPoint { get; }\n        EndPoint ProxyEndPoint { get; }\n        EndPoint DestEndPoint { get; }\n        void BeginConnectProxy(EndPoint remoteEP, AsyncCallback callback, object state);\n        void EndConnectProxy(IAsyncResult asyncResult);\n        void BeginConnectDest(EndPoint destEndPoint, AsyncCallback callback, object state);\n        void EndConnectDest(IAsyncResult asyncResult);
    {\n        EndPoint LocalEndPoint { get; }\n        EndPoint ProxyEndPoint { get; }\n        EndPoint DestEndPoint { get; }\n        void BeginConnectProxy(EndPoint remoteEP, AsyncCallback callback, object state);\n        void EndConnectProxy(IAsyncResult asyncResult);\n        void BeginConnectDest(EndPoint destEndPoint, AsyncCallback callback, object state);\n        void EndConnectDest(IAsyncResult asyncResult);\n        void BeginSend(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state);
{\n    public class Socks5Proxy : IForwardProxy\n    {\n        private class FakeAsyncResult : IAsyncResult\n        {\n            public readonly Socks5State innerState;\n            private readonly IAsyncResult r;\n            public FakeAsyncResult(IAsyncResult orig, Socks5State state)\n            {\n                r = orig;
    {\n        private class FakeAsyncResult : IAsyncResult\n        {\n            public readonly Socks5State innerState;\n            private readonly IAsyncResult r;\n            public FakeAsyncResult(IAsyncResult orig, Socks5State state)\n            {\n                r = orig;\n                innerState = state;\n            }
            this.StatisticsChart = new System.Windows.Forms.DataVisualization.Charting.Chart();\n            this.byISPCheckBox = new System.Windows.Forms.CheckBox();\n            this.bindingConfiguration = new System.Windows.Forms.BindingSource(this.components);\n            this.label2 = new System.Windows.Forms.Label();\n            this.label3 = new System.Windows.Forms.Label();\n            this.label4 = new System.Windows.Forms.Label();\n            this.groupBox1 = new System.Windows.Forms.GroupBox();\n            this.radioButton2 = new System.Windows.Forms.RadioButton();\n            this.radioButton1 = new System.Windows.Forms.RadioButton();
            this.label2 = new System.Windows.Forms.Label();\n            this.label3 = new System.Windows.Forms.Label();\n            this.label4 = new System.Windows.Forms.Label();\n            this.groupBox1 = new System.Windows.Forms.GroupBox();\n            this.radioButton2 = new System.Windows.Forms.RadioButton();\n            this.radioButton1 = new System.Windows.Forms.RadioButton();\n            this.splitContainer1 = new System.Windows.Forms.SplitContainer();\n            this.splitContainer2 = new System.Windows.Forms.SplitContainer();\n            this.label9 = new System.Windows.Forms.Label();\n            this.label8 = new System.Windows.Forms.Label();
            this.label6 = new System.Windows.Forms.Label();\n            this.splitContainer3 = new System.Windows.Forms.SplitContainer();\n            this.label1 = new System.Windows.Forms.Label();\n            this.calculationContainer = new System.Windows.Forms.FlowLayoutPanel();\n            this.OKButton = new System.Windows.Forms.Button();\n            this.CancelButton = new System.Windows.Forms.Button();
            ((System.ComponentModel.ISupportInitialize)(this.StatisticsChart)).BeginInit();\n            ((System.ComponentModel.ISupportInitialize)(this.bindingConfiguration)).BeginInit();\n            this.groupBox1.SuspendLayout();\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer1)).BeginInit();\n            this.splitContainer1.Panel1.SuspendLayout();\n            this.splitContainer1.Panel2.SuspendLayout();\n            this.splitContainer1.SuspendLayout();\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer2)).BeginInit();\n            this.splitContainer2.Panel1.SuspendLayout();\n            this.splitContainer2.Panel2.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.splitContainer3)).BeginInit();\n            this.splitContainer3.Panel1.SuspendLayout();\n            this.splitContainer3.Panel2.SuspendLayout();\n            this.splitContainer3.SuspendLayout();\n            this.SuspendLayout();\n            // \n            // StatisticsChart\n            // 
            this.SuspendLayout();\n            // \n            // StatisticsChart\n            // \n            this.StatisticsChart.BackColor = System.Drawing.Color.Transparent;
            // \n            // splitContainer1.Panel2\n            // \n            this.splitContainer1.Panel2.Controls.Add(this.CancelButton);\n            this.splitContainer1.Panel2.Controls.Add(this.OKButton);\n            this.splitContainer1.Panel2.Controls.Add(this.groupBox1);\n            this.splitContainer1.Panel2.Controls.Add(this.StatisticsChart);
            this.splitContainer2.Panel1.Controls.Add(this.label6);\n            this.splitContainer2.Panel1.Controls.Add(this.label2);\n            this.splitContainer2.Panel1.Controls.Add(this.label4);\n            this.splitContainer2.Panel1.Controls.Add(this.byISPCheckBox);\n            this.splitContainer2.Panel1.Controls.Add(this.label3);\n            // \n            // splitContainer2.Panel2\n            // \n            this.splitContainer2.Panel2.Controls.Add(this.splitContainer3);
            this.splitContainer2.Panel1.Controls.Add(this.label3);\n            // \n            // splitContainer2.Panel2\n            // \n            this.splitContainer2.Panel2.Controls.Add(this.splitContainer3);\n            // label9\n            // \n            this.label9.AutoSize = true;\n            this.label9.Location = new System.Drawing.Point(7, 181);
            10,\n            0,\n            0,\n            0});\n            this.dataCollectionMinutesNum.Location = new System.Drawing.Point(161, 188);\n            this.dataCollectionMinutesNum.Margin = new System.Windows.Forms.Padding(3, 4, 3, 4);\n            this.dataCollectionMinutesNum.Maximum = new decimal(new int[] {\n            120,\n            0,\n            0,
            4,\n            0,\n            0,\n            0});\n            // \n            // label6\n            // \n            this.label6.AutoSize = true;
            ((System.ComponentModel.ISupportInitialize)(this.StatisticsChart)).EndInit();\n            ((System.ComponentModel.ISupportInitialize)(this.bindingConfiguration)).EndInit();\n            this.groupBox1.ResumeLayout(false);\n            this.groupBox1.PerformLayout();\n            this.splitContainer1.Panel1.ResumeLayout(false);\n            this.splitContainer1.Panel2.ResumeLayout(false);\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer1)).EndInit();\n            this.splitContainer1.ResumeLayout(false);\n            this.splitContainer2.Panel1.ResumeLayout(false);\n            this.splitContainer2.Panel1.PerformLayout();
            this.splitContainer3.Panel1.ResumeLayout(false);\n            this.splitContainer3.Panel1.PerformLayout();\n            this.splitContainer3.Panel2.ResumeLayout(false);\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer3)).EndInit();\n            this.splitContainer3.ResumeLayout(false);\n            this.ResumeLayout(false);
            this.ResumeLayout(false);\n        }\n        #endregion\n        private System.Windows.Forms.DataVisualization.Charting.Chart StatisticsChart;\n        private System.Windows.Forms.CheckBox byISPCheckBox;\n        private System.Windows.Forms.Label label2;\n        private System.Windows.Forms.Label label3;\n        private System.Windows.Forms.Label label4;\n        private System.Windows.Forms.GroupBox groupBox1;\n        private System.Windows.Forms.RadioButton radioButton2;\n        private System.Windows.Forms.RadioButton radioButton1;
        private System.Windows.Forms.Label label2;\n        private System.Windows.Forms.Label label3;\n        private System.Windows.Forms.Label label4;\n        private System.Windows.Forms.GroupBox groupBox1;\n        private System.Windows.Forms.RadioButton radioButton2;\n        private System.Windows.Forms.RadioButton radioButton1;\n        private System.Windows.Forms.SplitContainer splitContainer1;\n        private System.Windows.Forms.Label label1;\n        private System.Windows.Forms.SplitContainer splitContainer2;\n        private System.Windows.Forms.FlowLayoutPanel calculationContainer;
        private System.Windows.Forms.SplitContainer splitContainer3;\n        private System.Windows.Forms.NumericUpDown repeatTimesNum;\n        private System.Windows.Forms.Label label6;\n        private System.Windows.Forms.CheckBox byHourOfDayCheckBox;
        private System.Windows.Forms.Label label6;\n        private System.Windows.Forms.CheckBox byHourOfDayCheckBox;\n        private System.Windows.Forms.NumericUpDown choiceKeptMinutesNum;\n        private System.Windows.Forms.CheckBox StatisticsEnabledCheckBox;\n        private System.Windows.Forms.Label label9;\n        private System.Windows.Forms.Label label8;\n        private System.Windows.Forms.NumericUpDown dataCollectionMinutesNum;\n        private System.Windows.Forms.BindingSource bindingConfiguration;\n        private System.Windows.Forms.Button CancelButton;\n        private System.Windows.Forms.Button OKButton;
    }\n}
    {\n        private readonly ShadowsocksController _controller;\n        private Server _currentServer;\n        private readonly Timer _timer;\n        private Dictionary<string, StatisticsData> _statistics;\n        private const int CachedInterval = 30*60*1000; //choose a new server every 30 minutes\n        private const int RetryInterval = 2*60*1000; //choose a new server every 30 minutes\n        public class StatisticsData\n        {\n            public int SuccessTimes;
        {\n            _controller = controller;\n            var servers = controller.GetCurrentConfiguration().configs;\n            var randomIndex = new Random().Next() % servers.Count();\n            _currentServer = servers[randomIndex];  //choose a server randomly at first\n            _timer = new Timer(ReloadStatisticsAndChooseAServer);\n        }\n        private void ReloadStatisticsAndChooseAServer(object obj)\n        {\n            Logging.Debug("Reloading statistics and choose a new server....");
        {\n            //TODO: Load options\n            var statisticsStrategyOptionsForm = new StatisticsStrategyConfigurationForm(controller);

                _currentServer = bestResult.server;\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n            }\n        }\n        public string ID\n        {\n            get { return "com.shadowsocks.strategy.scbs"; }
        {\n            get { return "com.shadowsocks.strategy.scbs"; }\n        }\n        public string Name\n        {\n            get { return I18N.GetString("Choose By Total Package Loss"); }\n        }\n        public Server GetAServer(IStrategyCallerType type, IPEndPoint localIPEndPoint)\n        {\n            var oldServer = _currentServer;
        {\n            get { return I18N.GetString("Choose By Total Package Loss"); }\n        }\n        public Server GetAServer(IStrategyCallerType type, IPEndPoint localIPEndPoint)\n        {\n            var oldServer = _currentServer;\n            if (oldServer == null)\n            {\n                ChooseNewServer(_controller.GetCurrentConfiguration().configs);\n            }
        {\n            var oldServer = _currentServer;\n            if (oldServer == null)\n            {\n                ChooseNewServer(_controller.GetCurrentConfiguration().configs);\n            }\n            if (oldServer != _currentServer)\n            {\n            }
            return _currentServer;  //current server cached for CachedInterval\n        }\n        public void ReloadServers()\n        {\n            ChooseNewServer(_controller.GetCurrentConfiguration().configs);\n            timer?.Change(0, CachedInterval);\n        }\n        public void SetFailure(Server server)\n        {\n            Logging.Debug(String.Format("failure: {0}", server.FriendlyName()));
        {\n            ChooseNewServer(_controller.GetCurrentConfiguration().configs);\n            timer?.Change(0, CachedInterval);\n        }\n        public void SetFailure(Server server)\n        {\n            Logging.Debug(String.Format("failure: {0}", server.FriendlyName()));\n        }\n        public void UpdateLastRead(Server server)\n        {
        {\n            Logging.Debug(String.Format("failure: {0}", server.FriendlyName()));\n        }\n        public void UpdateLastRead(Server server)\n        {\n            //TODO: combine this part of data with ICMP statics\n        }\n        public void UpdateLastWrite(Server server)\n        {\n            //TODO: combine this part of data with ICMP statics\n        }\n        public void UpdateLatency(Server server, TimeSpan latency)
        {\n            //TODO: combine this part of data with ICMP statics\n        }\n        public void UpdateLastWrite(Server server)\n        {\n            //TODO: combine this part of data with ICMP statics\n        }\n        public void UpdateLatency(Server server, TimeSpan latency)\n        {\n            //TODO: combine this part of data with ICMP statics\n        }\n    }
        {\n            //TODO: combine this part of data with ICMP statics\n        }\n        public void UpdateLatency(Server server, TimeSpan latency)\n        {\n            //TODO: combine this part of data with ICMP statics\n        }\n    }\n}
        {\n            //TODO: combine this part of data with ICMP statics\n        }\n    }\n}
            LoadServerNameListToUI(_modifiedConfiguration);\n            ServersListBox.SelectedIndex = _modifiedConfiguration.configs.Count - 1;\n            _lastSelectedIndex = ServersListBox.SelectedIndex;\n        }\n        private void DuplicateButton_Click(object sender, EventArgs e)\n        {\n            if (_lastSelectedIndex == -1 || _lastSelectedIndex > _modifiedConfiguration.configs.Count\n                || !ValidateAndSaveSelectedServerDetails())\n            {
            {\n                return;\n            }\n            Server currServer = _modifiedConfiguration.configs[_lastSelectedIndex];\n            var currIndex = _modifiedConfiguration.configs.IndexOf(currServer);\n            _modifiedConfiguration.configs.Insert(currIndex + 1, currServer);\n            LoadServerNameListToUI(_modifiedConfiguration);\n            ServersListBox.SelectedIndex = currIndex + 1;\n            _lastSelectedIndex = ServersListBox.SelectedIndex;\n        }
            }\n            // requested unregister, which has no side effect\n            else if (!register)\n            {\n                UnregisterApplicationRestart();\n                Logging.Debug("Unregister restart after system reboot");\n            }\n        }\n    }\n}
        {\n            // store args for further use\n            Args = args;\n            // Check OS since we are using dual-mode socket\n            if (!Utils.IsWinVistaOrHigher())\n            {\n                MessageBox.Show(I18N.GetString("Unsupported operating system, use Windows Vista at least."),\n                "Shadowsocks Error", MessageBoxButtons.OK, MessageBoxIcon.Error);\n                return;\n            }\n            // Check .NET Framework version
        }\n        private byte[] mergeSort(byte[] array, ulong a, int j)\n        {\n            if (array.Length == 1)\n                return array;\n            int middle = array.Length / 2;\n            byte[] left = new byte[middle];\n            for (int i = 0; i < middle; i++)\n            {\n                left[i] = array[i];
        {\n            if (array.Length == 1)\n                return array;\n            int middle = array.Length / 2;\n            byte[] left = new byte[middle];\n            for (int i = 0; i < middle; i++)\n            {\n                left[i] = array[i];\n            }\n            byte[] right = new byte[array.Length - middle];
                SocketType.Stream, ProtocolType.Tcp);\n            IPEndPoint localEndPoint = new IPEndPoint(0, port);\n            // Bind the socket to the local endpoint and listen for incoming connections.\n                listener.Bind(localEndPoint);\n                listener.Listen(100);\n            // Start an asynchronous socket to listen for connections.\n            Console.WriteLine("Waiting for a connection...");\n            listener.BeginAccept(\n                new AsyncCallback(AcceptCallback),\n                listener);\n        }\n        public void Stop()
            Application.EnableVisualStyles();\n            Application.SetCompatibleTextRenderingDefault(false);\n            Application.Run(new Form1());\n            local.Stop();\n        }\n    }\n}
                }\n                else\n                {\n                    remote.Shutdown(SocketShutdown.Send);\n                    remoteShutdown = true;\n                    CheckClose();\n                }\n            }\n            catch (Exception e)\n            {
        private const string StatisticsFilesName = "shadowsocks.availability.csv";\n        private const string Delimiter = ",";\n        private const int Timeout = 500;\n        private readonly TimeSpan DelayBeforeStart = TimeSpan.FromSeconds(1);\n        public Statistics RawStatistics { get; private set; }\n        public Statistics FilteredStatistics { get; private set; }\n        public static readonly DateTime UnknownDateTime = new DateTime(1970, 1, 1);\n        private int Repeat => _config.RepeatTimesNum;\n        private readonly TimeSpan RetryInterval = TimeSpan.FromMinutes(2); //retry 2 minutes after failed\n        private TimeSpan Interval => TimeSpan.FromMinutes(_config.DataCollectionMinutes);
        public Statistics RawStatistics { get; private set; }\n        public Statistics FilteredStatistics { get; private set; }\n        public static readonly DateTime UnknownDateTime = new DateTime(1970, 1, 1);\n        private int Repeat => _config.RepeatTimesNum;\n        private readonly TimeSpan RetryInterval = TimeSpan.FromMinutes(2); //retry 2 minutes after failed\n        private TimeSpan Interval => TimeSpan.FromMinutes(_config.DataCollectionMinutes);\n        private Timer _timer;\n        private Timer _speedMonior;\n        private State _state;\n        private List<Server> _servers;
        private Timer _timer;\n        private Timer _speedMonior;\n        private State _state;\n        private List<Server> _servers;\n        private StatisticsStrategyConfiguration _config;\n        private const string Empty = "";\n        public static string AvailabilityStatisticsFile;\n        //speed in KiB/s\n        private int _inboundSpeed = 0;\n        private int _outboundSpeed = 0;
        }\n        public bool Set(StatisticsStrategyConfiguration config)\n        {\n            _config = config;\n            try\n            {\n                if (config.StatisticsEnabled)\n                {\n                    if (_timer?.Change(DelayBeforeStart, Interval) == null)\n                    {
                    Append(dataList, geolocationAndIsp.Result);\n                }\n            }\n        }\n        private static void Append(DataList dataList, IEnumerable<DataUnit> extra)\n        {\n            var data = dataList.Concat(extra);\n            var dataLine = string.Join(Delimiter, data.Select(kv => kv.Value).ToArray());\n            string[] lines;\n            if (!File.Exists(AvailabilityStatisticsFile))
                try\n                {\n                    process.Kill();\n                    process.WaitForExit();\n                }\n                catch (InvalidOperationException)\n                {\n                    // do nothing\n                }\n                process = null;
            {\n                IPGlobalProperties properties = IPGlobalProperties.GetIPGlobalProperties();\n                IPEndPoint[] tcpEndPoints = properties.GetActiveTcpListeners();\n                List<int> usedPorts = new List<int>();\n                foreach (IPEndPoint endPoint in IPGlobalProperties.GetIPGlobalProperties().GetActiveTcpListeners())\n                {\n                    usedPorts.Add(endPoint.Port);\n                }\n                for (int port = defaultPort; port < 65535; port++)\n                {
            }\n            catch (Exception e)\n            {\n                // in case access denied\n                Logging.LogUsefulException(e);\n                return defaultPort;\n            }
            {\n                // in case access denied\n                Logging.LogUsefulException(e);\n                return defaultPort;\n            }\n            throw new Exception("No free port found.");\n        }
            }\n            throw new Exception("No free port found.");\n        }\n    }\n}
            SwitchAllowLanTextBox.Text = config.SwitchAllowLan;\n            ShowLogsTextBox.Text = config.ShowLogs;\n            ServerMoveUpTextBox.Text = config.ServerMoveUp;\n            ServerMoveDownTextBox.Text = config.ServerMoveDown;\n        }\n        private void UpdateTexts()\n        {\n            // I18N stuff\n            SwitchSystemProxyLabel.Text = I18N.GetString("Switch system proxy");\n            SwitchProxyModeLabel.Text = I18N.GetString("Switch system proxy mode");
            SwitchAllowLanLabel.Text = I18N.GetString("Switch share over LAN");\n            ShowLogsLabel.Text = I18N.GetString("Show Logs");\n            ServerMoveUpLabel.Text = I18N.GetString("Switch to prev server");\n            ServerMoveDownLabel.Text = I18N.GetString("Switch to next server");\n            btnOK.Text = I18N.GetString("OK");\n            btnCancel.Text = I18N.GetString("Cancel");\n            btnRegisterAll.Text = I18N.GetString("Reg All");\n            this.Text = I18N.GetString("Edit Hotkeys...");\n        }\n        /// <summary>
        public string SwitchAllowLan;\n        public string ShowLogs;\n        public string ServerMoveUp;\n        public string ServerMoveDown;\n        public HotkeyConfig()\n        {\n            SwitchSystemProxy = "";\n            SwitchSystemProxyMode = "";
            SwitchAllowLan = "";\n            ShowLogs = "";\n            ServerMoveUp = "";\n            ServerMoveDown = "";\n        }\n    }\n}
            this.SwitchAllowLanLabel = new System.Windows.Forms.Label();\n            this.ShowLogsLabel = new System.Windows.Forms.Label();\n            this.ServerMoveUpLabel = new System.Windows.Forms.Label();\n            this.ServerMoveDownLabel = new System.Windows.Forms.Label();\n            this.SwitchSystemProxyTextBox = new System.Windows.Forms.TextBox();\n            this.SwitchProxyModeTextBox = new System.Windows.Forms.TextBox();\n            this.SwitchAllowLanTextBox = new System.Windows.Forms.TextBox();\n            this.ShowLogsTextBox = new System.Windows.Forms.TextBox();
            this.SwitchAllowLanTextBox = new System.Windows.Forms.TextBox();\n            this.ShowLogsTextBox = new System.Windows.Forms.TextBox();\n            this.ServerMoveUpTextBox = new System.Windows.Forms.TextBox();\n            this.ServerMoveDownTextBox = new System.Windows.Forms.TextBox();\n            flowLayoutPanel1 = new System.Windows.Forms.FlowLayoutPanel();\n            flowLayoutPanel1.SuspendLayout();\n            this.tableLayoutPanel1.SuspendLayout();\n            this.SuspendLayout();\n            // \n            // flowLayoutPanel1
            this.tableLayoutPanel1.Controls.Add(this.SwitchSystemProxyTextBox, 1, 0);\n            this.tableLayoutPanel1.Controls.Add(this.SwitchProxyModeTextBox, 1, 1);\n            this.tableLayoutPanel1.Controls.Add(this.SwitchAllowLanTextBox, 1, 2);\n            this.tableLayoutPanel1.Controls.Add(this.ShowLogsTextBox, 1, 3);\n            this.tableLayoutPanel1.Controls.Add(this.ServerMoveUpTextBox, 1, 4);\n            this.tableLayoutPanel1.Controls.Add(this.ServerMoveDownTextBox, 1, 5);\n            this.tableLayoutPanel1.Dock = System.Windows.Forms.DockStyle.Fill;\n            this.tableLayoutPanel1.Location = new System.Drawing.Point(0, 0);\n            this.tableLayoutPanel1.Name = "tableLayoutPanel1";
            this.tableLayoutPanel1.Dock = System.Windows.Forms.DockStyle.Fill;\n            this.tableLayoutPanel1.Location = new System.Drawing.Point(0, 0);\n            this.tableLayoutPanel1.Name = "tableLayoutPanel1";
        private System.Windows.Forms.Label SwitchAllowLanLabel;\n        private System.Windows.Forms.Label ShowLogsLabel;\n        private System.Windows.Forms.Label ServerMoveUpLabel;\n        private System.Windows.Forms.Label ServerMoveDownLabel;\n        private System.Windows.Forms.Button btnOK;\n        private System.Windows.Forms.Button btnCancel;\n        private System.Windows.Forms.TextBox ShowLogsTextBox;\n        private System.Windows.Forms.TextBox SwitchAllowLanTextBox;\n        private System.Windows.Forms.TextBox SwitchProxyModeTextBox;
        private System.Windows.Forms.TextBox SwitchSystemProxyTextBox;\n        private System.Windows.Forms.TextBox ServerMoveUpTextBox;\n        private System.Windows.Forms.TextBox ServerMoveDownTextBox;\n        private System.Windows.Forms.Button btnRegisterAll;\n        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel1;\n    }\n}
                string[] runList = runKey.GetValueNames();\n                foreach (string item in runList)\n                {\n                    if (item == Key)\n                        return true;\n                    else if (item == "Shadowsocks") // Compatibility with older versions\n                    {\n                        string value = Convert.ToString(runKey.GetValue(item));\n                        if (path.Equals(value, StringComparison.InvariantCultureIgnoreCase))\n                        {
                        return true;\n                    else if (item == "Shadowsocks") // Compatibility with older versions\n                    {\n                        string value = Convert.ToString(runKey.GetValue(item));\n                        if (path.Equals(value, StringComparison.InvariantCultureIgnoreCase))\n                        {\n                            runKey.DeleteValue(item);\n                            runKey.SetValue(Key, path);\n                            return true;\n                        }
                    {\n                        string value = Convert.ToString(runKey.GetValue(item));\n                        if (path.Equals(value, StringComparison.InvariantCultureIgnoreCase))\n                        {\n                            runKey.DeleteValue(item);\n                            runKey.SetValue(Key, path);\n                            return true;\n                        }\n                    }\n                }
        private IntPtr handle = IntPtr.Zero;\n        public Job()\n        {\n            handle = CreateJobObject(IntPtr.Zero, null);\n            var extendedInfoPtr = IntPtr.Zero;\n            var info = new JOBOBJECT_BASIC_LIMIT_INFORMATION\n            {\n                LimitFlags = 0x2000\n            };
        public Job()\n        {\n            handle = CreateJobObject(IntPtr.Zero, null);\n            var extendedInfoPtr = IntPtr.Zero;\n            var info = new JOBOBJECT_BASIC_LIMIT_INFORMATION\n            {\n                LimitFlags = 0x2000\n            };\n            var extendedInfo = new JOBOBJECT_EXTENDED_LIMIT_INFORMATION\n            {


            this.tableLayoutPanel1.ResumeLayout(false);\n            this.tableLayoutPanel1.PerformLayout();\n            this.panel1.ResumeLayout(false);\n            this.contextMenuStrip1.ResumeLayout(false);\n            this.ResumeLayout(false);\n            this.PerformLayout();\n        }\n        #endregion\n        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel1;\n        private System.Windows.Forms.Label label1;
        }\n        public void Close()\n        {\n            connection.Close();\n            if (remote != null)\n            {\n                remote.Close();\n            }\n        }\n        private void connectCallback(IAsyncResult ar)
        }\n        private void connectCallback(IAsyncResult ar)\n        {\n            try\n            {\n                // Complete the connection.\n                remote.EndConnect(ar);\n                Console.WriteLine("Socket connected to {0}",\n                    remote.RemoteEndPoint.ToString());\n                handshakeReceive();
using System.Text;\nusing System.IO;\nusing System.Diagnostics;\nusing SimpleJson;\nnamespace shadowsocks_csharp\n{\n    [Serializable]\n    public class Config\n    {\n        public string server;
        public bool isDefault;\n        private static void assert(bool condition)\n        {\n            if(!condition) \n            {\n                throw new Exception("assertion failure");\n            }\n        }\n        public static Config Load()\n        {
            try\n            {\n                using (StreamReader sr = new StreamReader(File.OpenRead(@"config.json")))\n                {\n                    Config config = SimpleJson.SimpleJson.DeserializeObject<Config>(sr.ReadToEnd());\n                    assert(!string.IsNullOrEmpty(config.server));\n                    assert(!string.IsNullOrEmpty(config.password));\n                    assert(config.local_port > 0);\n                    assert(config.server_port > 0);\n                    config.isDefault = false;
                {\n                    Config config = SimpleJson.SimpleJson.DeserializeObject<Config>(sr.ReadToEnd());\n                    assert(!string.IsNullOrEmpty(config.server));\n                    assert(!string.IsNullOrEmpty(config.password));\n                    assert(config.local_port > 0);\n                    assert(config.server_port > 0);\n                    config.isDefault = false;\n                    return config;\n                }\n            }
                    assert(!string.IsNullOrEmpty(config.server));\n                    assert(!string.IsNullOrEmpty(config.password));\n                    assert(config.local_port > 0);\n                    assert(config.server_port > 0);\n                    config.isDefault = false;\n                    return config;\n                }\n            }\n            catch (Exception e)\n            {
            try\n            {\n                using (StreamWriter sw = new StreamWriter(File.Open(@"config.json", FileMode.Create)))\n                {\n                    string jsonString = SimpleJson.SimpleJson.SerializeObject(new\n                    {\n                        server = config.server,\n                        server_port = config.server_port,\n                        local_port = config.local_port,\n                        password = config.password
                {\n                    string jsonString = SimpleJson.SimpleJson.SerializeObject(new\n                    {\n                        server = config.server,\n                        server_port = config.server_port,\n                        local_port = config.local_port,\n                        password = config.password\n                    });\n                    sw.Write(jsonString);\n                    sw.Flush();
                }\n            }\n            catch (IOException e)\n            {\n                Console.Error.WriteLine(e);\n            }\n        }\n    }\n}
                }),\n                this.ServersItem = CreateMenuGroup("Servers", new MenuItem[] {\n                    this.SeperatorItem = new MenuItem("-"),\n                    this.ConfigItem = CreateMenuItem("Edit Servers...", new EventHandler(this.Config_Click))\n                }),\n                new MenuItem("-"),\n                this.AutoStartupItem = CreateMenuItem("Start on Boot", new EventHandler(this.AutoStartupItem_Click)),\n                this.ShareOverLANItem = CreateMenuItem("Share over LAN", new EventHandler(this.ShareOverLANItem_Click)),\n                CreateMenuItem("Edit PAC File...", new EventHandler(this.EditPACFileItem_Click)),\n                new MenuItem("-"),
                    this.SeperatorItem = new MenuItem("-"),\n                    this.ConfigItem = CreateMenuItem("Edit Servers...", new EventHandler(this.Config_Click))\n                }),\n                new MenuItem("-"),\n                this.AutoStartupItem = CreateMenuItem("Start on Boot", new EventHandler(this.AutoStartupItem_Click)),\n                this.ShareOverLANItem = CreateMenuItem("Share over LAN", new EventHandler(this.ShareOverLANItem_Click)),\n                CreateMenuItem("Edit PAC File...", new EventHandler(this.EditPACFileItem_Click)),\n                new MenuItem("-"),\n                CreateMenuItem("Show QRCode...", new EventHandler(this.QRCodeItem_Click)),\n                CreateMenuItem("Show Logs...", new EventHandler(this.ShowLogItem_Click)),
                }),\n                new MenuItem("-"),\n                this.AutoStartupItem = CreateMenuItem("Start on Boot", new EventHandler(this.AutoStartupItem_Click)),\n                this.ShareOverLANItem = CreateMenuItem("Share over LAN", new EventHandler(this.ShareOverLANItem_Click)),\n                CreateMenuItem("Edit PAC File...", new EventHandler(this.EditPACFileItem_Click)),\n                new MenuItem("-"),\n                CreateMenuItem("Show QRCode...", new EventHandler(this.QRCodeItem_Click)),\n                CreateMenuItem("Show Logs...", new EventHandler(this.ShowLogItem_Click)),\n                CreateMenuItem("About...", new EventHandler(this.Config_Click)),\n                new MenuItem("-"),
                new MenuItem("-"),\n                CreateMenuItem("Show QRCode...", new EventHandler(this.QRCodeItem_Click)),\n                CreateMenuItem("Show Logs...", new EventHandler(this.ShowLogItem_Click)),\n                CreateMenuItem("About...", new EventHandler(this.Config_Click)),\n                new MenuItem("-"),\n                CreateMenuItem("Quit", new EventHandler(this.Quit_Click))\n            });\n        }\n        private void controller_ConfigChanged(object sender, EventArgs e)\n        {
                new MenuItem("-"),\n                CreateMenuItem("Quit", new EventHandler(this.Quit_Click))\n            });\n        }\n        private void controller_ConfigChanged(object sender, EventArgs e)\n        {\n            LoadCurrentConfiguration();\n            UpdateTrayIcon();\n        }\n        private void controller_EnableStatusChanged(object sender, EventArgs e)
            });\n        }\n        private void controller_ConfigChanged(object sender, EventArgs e)\n        {\n            LoadCurrentConfiguration();\n            UpdateTrayIcon();\n        }\n        private void controller_EnableStatusChanged(object sender, EventArgs e)\n        {\n            enableItem.Checked = controller.GetConfiguration().enabled;
            }\n            LoadLibrary(dllPath);\n        }\n        public static byte[] MD5(byte[] input)\n        {\n            byte[] output = new byte[16];\n            md5(input, (uint)input.Length, output);
        public static byte[] MD5(byte[] input)\n        {\n            byte[] output = new byte[16];\n            md5(input, (uint)input.Length, output);\n            return output;\n        }\n        [DllImport("Kernel32.dll")]\n        private static extern IntPtr LoadLibrary(string path);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public static extern IntPtr cipher_info_from_string(string cipher_name);
            return output;\n        }\n        [DllImport("Kernel32.dll")]\n        private static extern IntPtr LoadLibrary(string path);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public static extern IntPtr cipher_info_from_string(string cipher_name);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public static extern void cipher_init(IntPtr ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public static extern int cipher_setup(IntPtr ctx, IntPtr cipher_info);
    }\n}
        private static readonly ConcurrentDictionary<string, byte[]> CachedKeys = new ConcurrentDictionary<string, byte[]>();\n        protected byte[] _encryptIV;\n        protected byte[] _decryptIV;\n        protected bool _decryptIVReceived;\n        protected bool _encryptIVSent;\n        protected string _method;\n        protected int _cipher;\n        // cipher name in MbedTLS, useless when using LibSodium
        protected string _method;\n        protected int _cipher;\n        // cipher name in MbedTLS, useless when using LibSodium\n        protected string _cipherMbedName;\n        protected int[] _cipherInfo;\n        protected byte[] _key;\n        protected int keyLen;\n        protected int ivLen;\n        protected uint counter = 0;\n        protected byte[] _keyBuffer = null;\n        public IVEncryptor(string method, string password, bool onetimeauth, bool isudp)
        protected void InitKey(string method, string password)\n        {\n            method = method.ToLower();\n            _method = method;\n            string k = method + ":" + password;\n            ciphers = getCiphers();\n            ciphersDetail = ciphers[_method];\n            _cipherMbedName = ciphersDetail.Keys.FirstOrDefault();\n            _cipherInfo = ciphers[_method][_cipherMbedName];
            _cipher = _cipherInfo[2];\n            if (_cipher == 0)\n            {\n                throw new Exception("method not found");\n            }\n            keyLen = _cipherInfo[0];\n            ivLen = _cipherInfo[1];\n            _key = CachedKeys.GetOrAdd(k, (nk) =>\n            {\n                byte[] passbuf = Encoding.UTF8.GetBytes(password);
            _key = CachedKeys.GetOrAdd(k, (nk) =>\n            {\n                byte[] passbuf = Encoding.UTF8.GetBytes(password);\n                byte[] key = new byte[32];\n                byte[] iv = new byte[16];\n                bytesToKey(passbuf, key);\n                return key;\n            });\n        }\n        protected void bytesToKey(byte[] password, byte[] key)
        };\n        protected override Dictionary<string, Dictionary<string, int[]>> getCiphers()\n        {\n            return _ciphers;\n        }\n        public static List<string> SupportedCiphers()\n        {\n            return new List<string>(_ciphers.Keys);\n        }\n        protected override void cipherUpdate(bool isCipher, int length, byte[] buf, byte[] outbuf)
        {\n            return _ciphers;\n        }\n        public static List<string> SupportedCiphers()\n        {\n            return new List<string>(_ciphers.Keys);\n        }\n        protected override void cipherUpdate(bool isCipher, int length, byte[] buf, byte[] outbuf)\n        {\n            // TODO write a unidirection cipher so we don't have to if if if
        {\n            // run it once before the multi-threading test to initialize global tables\n            RunSingleMbedTLSEncryptionThread();\n            List<Thread> threads = new List<Thread>();\n            for (int i = 0; i < 10; i++)\n            {\n                Thread t = new Thread(new ThreadStart(RunSingleMbedTLSEncryptionThread));\n                threads.Add(t);\n                t.Start();\n            }\n            foreach (Thread t in threads)
                threads.Add(t);\n                t.Start();\n            }\n            foreach (Thread t in threads)\n            {\n                t.Join();\n            }\n            Assert.IsFalse(encryptionFailed);\n        }\n        private void RunSingleMbedTLSEncryptionThread()
        {\n            try\n            {\n                for (int i = 0; i < 100; i++)\n                {\n                    IEncryptor encryptor;\n                    IEncryptor decryptor;\n                    encryptor = new MbedTLSEncryptor("aes-256-cfb", "barfoo!", false, false);\n                    decryptor = new MbedTLSEncryptor("aes-256-cfb", "barfoo!", false, false);\n                    RunEncryptionRound(encryptor, decryptor);
                    RunEncryptionRound(encryptor, decryptor);\n                }\n            }\n            catch\n            {\n                encryptionFailed = true;\n                throw;\n            }\n        }\n        [TestMethod]
            Logging.Dump("after cipherEncrypt: cipher", ciphertext, (int) encClen);\n            clen = (uint) encClen;\n        }\n        public override void cipherDecrypt(byte[] ciphertext, uint clen, byte[] plaintext, ref uint plen)\n        {\n            Debug.Assert(_sodiumDecSubkey != null);\n            // buf: ciphertext + tag\n            // outbuf: plaintext\n            int ret;
        }\n        public override void cipherDecrypt(byte[] ciphertext, uint clen, byte[] plaintext, ref uint plen)\n        {\n            Debug.Assert(_sodiumDecSubkey != null);\n            // buf: ciphertext + tag\n            // outbuf: plaintext\n            int ret;\n            ulong decPlen = 0;\n            Logging.Dump("_decNonce before dec", _decNonce, nonceLen);\n            Logging.Dump("_sodiumDecSubkey", _sodiumDecSubkey, keyLen);
        {\n            Debug.Assert(_sodiumDecSubkey != null);\n            // buf: ciphertext + tag\n            // outbuf: plaintext\n            int ret;\n            ulong decPlen = 0;\n            Logging.Dump("_decNonce before dec", _decNonce, nonceLen);\n            Logging.Dump("_sodiumDecSubkey", _sodiumDecSubkey, keyLen);\n            Logging.Dump("before cipherDecrypt: cipher", ciphertext, (int) clen);\n            switch (_cipher)
            Logging.Dump("after cipherDecrypt: plain", plaintext, (int) decPlen);\n            plen = (uint) decPlen;\n        }\n        public override void Dispose()\n        {\n        }\n    }\n}
        }\n        public override void Dispose()\n        {\n        }\n    }\n}
            {\n                if (!_registeredEncryptors.ContainsKey(method))\n                    _registeredEncryptors.Add(method, typeof(StreamOpenSSLEncryptor));\n            }\n            foreach (string method in StreamSodiumEncryptor.SupportedCiphers())\n            {\n                if (!_registeredEncryptors.ContainsKey(method))\n                    _registeredEncryptors.Add(method, typeof(StreamSodiumEncryptor));\n            }
            }\n            foreach (string method in StreamSodiumEncryptor.SupportedCiphers())\n            {\n                if (!_registeredEncryptors.ContainsKey(method))\n                    _registeredEncryptors.Add(method, typeof(StreamSodiumEncryptor));\n            }\n            foreach (string method in StreamMbedTLSEncryptor.SupportedCiphers())\n            {\n                if (!_registeredEncryptors.ContainsKey(method))\n                    _registeredEncryptors.Add(method, typeof(StreamMbedTLSEncryptor));
            }\n            foreach (string method in AEADMbedTLSEncryptorSupportedCiphers)\n            {\n                if (!_registeredEncryptors.ContainsKey(method))\n                    _registeredEncryptors.Add(method, typeof(AEADMbedTLSEncryptor));\n            }
            }\n        }\n        public static IEncryptor GetEncryptor(string method, string password)\n        {\n            if (method.IsNullOrEmpty())\n            {\n                method = "aes-256-cfb";\n            }\n            method = method.ToLowerInvariant();\n            Type t = _registeredEncryptors[method];
                    Debug.Assert(olen == plen);\n                    // attach tag to ciphertext\n                    Array.Copy(tagbuf, 0, ciphertext, (int) plen, tagLen);\n                    clen = olen + (uint) tagLen;\n                    break;\n                default:\n                    throw new System.Exception("not implemented");\n            }\n        }\n        public override void cipherDecrypt(byte[] ciphertext, uint clen, byte[] plaintext, ref uint plen)\n        {
                default:\n                    throw new System.Exception("not implemented");\n            }\n        }\n        public override void cipherDecrypt(byte[] ciphertext, uint clen, byte[] plaintext, ref uint plen)\n        {\n            // buf: ciphertext + tag\n            // outbuf: plaintext\n            int ret;\n            uint olen = 0;
        {\n            // buf: ciphertext + tag\n            // outbuf: plaintext\n            int ret;\n            uint olen = 0;\n            // split tag\n            byte[] tagbuf = new byte[tagLen];\n            Array.Copy(ciphertext, (int) (clen - tagLen), tagbuf, 0, tagLen);\n            switch (_cipher)\n            {
                    Debug.Assert(olen == clen - tagLen);\n                    plen = olen;\n                    break;\n                default:\n                    throw new System.Exception("not implemented");\n            }\n        }\n        #region IDisposable\n        private bool _disposed;\n        // instance based lock
                default:\n                    throw new System.Exception("not implemented");\n            }\n        }\n        #region IDisposable\n        private bool _disposed;\n        // instance based lock\n        private readonly object _lock = new object();\n        public override void Dispose()\n        {
            this.FileMenuItem = new System.Windows.Forms.MenuItem();\n            this.OpenLocationMenuItem = new System.Windows.Forms.MenuItem();\n            this.ExitMenuItem = new System.Windows.Forms.MenuItem();\n            this.ViewMenuItem = new System.Windows.Forms.MenuItem();\n            this.CleanLogsMenuItem = new System.Windows.Forms.MenuItem();\n            this.ChangeFontMenuItem = new System.Windows.Forms.MenuItem();\n            this.WrapTextMenuItem = new System.Windows.Forms.MenuItem();\n            this.TopMostMenuItem = new System.Windows.Forms.MenuItem();\n            this.MenuItemSeparater = new System.Windows.Forms.MenuItem();\n            this.ShowToolbarMenuItem = new System.Windows.Forms.MenuItem();
            this.ChangeFontButton = new System.Windows.Forms.Button();\n            this.CleanLogsButton = new System.Windows.Forms.Button();\n            this.WrapTextCheckBox = new System.Windows.Forms.CheckBox();\n            this.tableLayoutPanel1 = new System.Windows.Forms.TableLayoutPanel();\n            this.ToolbarFlowLayoutPanel = new System.Windows.Forms.FlowLayoutPanel();\n            this.tableLayoutPanel1.SuspendLayout();\n            this.ToolbarFlowLayoutPanel.SuspendLayout();
            this.tableLayoutPanel1.SuspendLayout();\n            this.ToolbarFlowLayoutPanel.SuspendLayout();
            // \n            // ChangeFontButton\n            // \n            this.ChangeFontButton.AutoSize = true;\n            this.ChangeFontButton.Location = new System.Drawing.Point(84, 3);\n            this.ChangeFontButton.Name = "ChangeFontButton";\n            this.ChangeFontButton.Size = new System.Drawing.Size(75, 23);\n            this.ChangeFontButton.TabIndex = 2;\n            this.ChangeFontButton.Text = "&Font";\n            this.ChangeFontButton.UseVisualStyleBackColor = true;\n            this.ChangeFontButton.Click += new System.EventHandler(this.ChangeFontButton_Click);\n            // \n            // CleanLogsButton\n            this.CleanLogsButton.AutoSize = true;\n            this.CleanLogsButton.Location = new System.Drawing.Point(3, 3);
            this.ChangeFontButton.Name = "ChangeFontButton";\n            this.ChangeFontButton.Size = new System.Drawing.Size(75, 23);\n            this.ChangeFontButton.TabIndex = 2;\n            this.ChangeFontButton.Text = "&Font";\n            this.ChangeFontButton.UseVisualStyleBackColor = true;\n            this.ChangeFontButton.Click += new System.EventHandler(this.ChangeFontButton_Click);\n            // \n            // CleanLogsButton\n            // \n            this.CleanLogsButton.AutoSize = true;\n            this.CleanLogsButton.Location = new System.Drawing.Point(3, 3);\n            this.CleanLogsButton.Name = "CleanLogsButton";\n            this.CleanLogsButton.Size = new System.Drawing.Size(75, 23);
            this.CleanLogsButton.Name = "CleanLogsButton";\n            this.CleanLogsButton.Size = new System.Drawing.Size(75, 23);\n            this.CleanLogsButton.TabIndex = 1;\n            this.CleanLogsButton.Text = "&Clean logs";\n            this.CleanLogsButton.UseVisualStyleBackColor = true;\n            this.CleanLogsButton.Click += new System.EventHandler(this.CleanLogsButton_Click);\n            // \n            // WrapTextCheckBox\n            // \n            this.WrapTextCheckBox.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) \n            | System.Windows.Forms.AnchorStyles.Left)));\n            this.WrapTextCheckBox.AutoSize = true;
            this.tableLayoutPanel1.Controls.Add(this.LogMessageTextBox, 0, 1);\n            this.tableLayoutPanel1.Controls.Add(this.ToolbarFlowLayoutPanel, 0, 0);\n            this.tableLayoutPanel1.Dock = System.Windows.Forms.DockStyle.Fill;\n            this.tableLayoutPanel1.Location = new System.Drawing.Point(0, 0);\n            this.tableLayoutPanel1.Name = "tableLayoutPanel1";\n            this.tableLayoutPanel1.RowCount = 2;\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.Size = new System.Drawing.Size(590, 418);\n            this.tableLayoutPanel1.TabIndex = 2;
            this.tableLayoutPanel1.TabIndex = 2;\n            // \n            // ToolbarFlowLayoutPanel\n            // \n            this.ToolbarFlowLayoutPanel.AutoSize = true;\n            this.ToolbarFlowLayoutPanel.Controls.Add(this.CleanLogsButton);\n            this.ToolbarFlowLayoutPanel.Controls.Add(this.ChangeFontButton);\n            this.ToolbarFlowLayoutPanel.Controls.Add(this.WrapTextCheckBox);\n            this.ToolbarFlowLayoutPanel.Controls.Add(this.TopMostCheckBox);\n            this.ToolbarFlowLayoutPanel.Dock = System.Windows.Forms.DockStyle.Fill;\n            this.ToolbarFlowLayoutPanel.Location = new System.Drawing.Point(3, 3);

            this.tableLayoutPanel1.ResumeLayout(false);\n            this.tableLayoutPanel1.PerformLayout();\n            this.ToolbarFlowLayoutPanel.ResumeLayout(false);\n            this.ToolbarFlowLayoutPanel.PerformLayout();\n            this.ResumeLayout(false);\n        }\n        #endregion\n        private System.Windows.Forms.TextBox LogMessageTextBox;\n        private System.Windows.Forms.MainMenu MainMenu;\n        private System.Windows.Forms.MenuItem FileMenuItem;
        private System.Windows.Forms.MenuItem FileMenuItem;\n        private System.Windows.Forms.MenuItem OpenLocationMenuItem;\n        private System.Windows.Forms.MenuItem ExitMenuItem;\n        private System.Windows.Forms.CheckBox WrapTextCheckBox;\n        private System.Windows.Forms.Button CleanLogsButton;\n        private System.Windows.Forms.Button ChangeFontButton;\n        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel1;\n        private System.Windows.Forms.CheckBox TopMostCheckBox;\n        private System.Windows.Forms.MenuItem ViewMenuItem;
        private System.Windows.Forms.CheckBox WrapTextCheckBox;\n        private System.Windows.Forms.Button CleanLogsButton;\n        private System.Windows.Forms.Button ChangeFontButton;\n        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel1;\n        private System.Windows.Forms.CheckBox TopMostCheckBox;\n        private System.Windows.Forms.MenuItem ViewMenuItem;\n        private System.Windows.Forms.MenuItem CleanLogsMenuItem;\n        private System.Windows.Forms.MenuItem ChangeFontMenuItem;\n        private System.Windows.Forms.MenuItem WrapTextMenuItem;\n        private System.Windows.Forms.MenuItem TopMostMenuItem;
        }\n        private void CleanLogsButton_Click(object sender, EventArgs e)\n        {\n            DoCleanLogs();\n        }\n        #endregion\n        #region Change the font settings applied in LogMessageTextBox.\n        private void DoChangeFont()\n        {\n            FontDialog fd = new FontDialog();\n            fd.Font = LogMessageTextBox.Font;
        {\n            FontDialog fd = new FontDialog();\n            fd.Font = LogMessageTextBox.Font;\n            if (fd.ShowDialog() == DialogResult.OK)\n            {\n                LogMessageTextBox.Font = fd.Font;\n            }\n        }\n        private void ChangeFontMenuItem_Click(object sender, EventArgs e)\n        {
        }\n    }\n}
                        {\n                            byte[] response = { 5, 0, 0, 1, 0, 0, 0, 0, 0, 0 };\n                            _connection.BeginSend(response, 0, response.Length, SocketFlags.None,\n                                new AsyncCallback(ResponseCallback), null);\n                        }\n                        else if (_command == 3)\n                        {\n                            ReadAddress(HandleUDPAssociate);
                        }\n                    }\n                }\n                else\n                {\n                    Logging.Debug("failed to recv data in Shadowsocks.Controller.TCPHandler.handshakeReceive2Callback()");\n                    Close();\n                }\n            }\n            catch (Exception e)
        {\n            Array.Copy(_connetionRecvBuffer, 3, _connetionRecvBuffer, 0, 2);\n            // Read the remain address bytes\n            _connection.BeginReceive(_connetionRecvBuffer, 2, RecvSize - 2, SocketFlags.None, OnAddressFullyRead, new object[] {bytesRemain, onSuccess});\n        }\n        private void OnAddressFullyRead(IAsyncResult ar)\n        {\n            if (_closed) return;\n            try\n            {\n                int bytesRead = _connection.EndReceive(ar);
        }\n        private void OnAddressFullyRead(IAsyncResult ar)\n        {\n            if (_closed) return;\n            try\n            {\n                int bytesRead = _connection.EndReceive(ar);\n                var states = (object[]) ar.AsyncState;\n                int bytesRemain = (int)states[0];\n                var onSuccess = (Action) states[1];
                if (bytesRead >= bytesRemain)\n                {\n                    _firstPacketLength = bytesRead + 2;\n                    int atyp = _connetionRecvBuffer[0];\n                    string dst_addr = "Unknown";\n                    int dst_port = -1;\n                    switch (atyp)\n                    {\n                        case 1: // IPv4 address, 4 bytes\n                            dst_addr = new IPAddress(_connetionRecvBuffer.Skip(1).Take(4).ToArray()).ToString();
            }\n            // This should not happen, user should check the input instead of blaming\n            return null;\n        }\n        public Server()\n        {\n            server = "";
        }\n        public Server()\n        {\n            server = "";\n            server_port = 8388;\n            method = "aes-256-cfb";\n            password = "";\n            remarks = "";\n            auth = false;\n        }
            if (_requestLineCount == 0)\n            {\n                var m = HttpRequestHeaderRegex.Match(line);\n                if (m.Success)\n                {\n                    var method = m.Groups["method"].Value;\n                    var path = m.Groups["path"].Value;\n                    if (method == "CONNECT")\n                    {
                    if (method == "CONNECT")\n                    {\n                        _isConnect = true;\n                        if (!ParseHost(path))\n                        {\n                            throw new Exception("Bad http header: " + line);\n                        }\n                    }\n                    else\n                    {
                        {\n                            throw new Exception("Bad http header: " + line);\n                        }\n                    }\n                    else\n                    {\n                        var targetUrl = new Uri(path);\n                        if (!ParseHost(targetUrl.Authority))\n                        {\n                            throw new Exception("Bad http header: " + line);
                if (line.IsNullOrEmpty())\n                {\n                    return true;\n                }\n                if (!_isConnect)\n                {\n                    if (line.StartsWith("Host: "))\n                    {\n                        if (!ParseHost(line.Substring(6).Trim()))\n                        {
                    byte[] response = { 5, 0, 0, 1, 0, 0, 0, 0, 0, 0 };\n                    connection.BeginSend(response, 0, response.Length, 0, new AsyncCallback(StartConnect), null);\n                }\n                else\n                {\n                    Console.WriteLine("failed to recv data in handshakeReceive2Callback");\n                    this.Close();\n                }\n            }\n            catch (Exception e)
                }\n                else\n                {\n                    Console.WriteLine("failed to recv data in handshakeReceive2Callback");\n                    this.Close();\n                }\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);
            this.PACUrlTextBox.MaxLength = 256;\n            this.PACUrlTextBox.Name = "PACUrlTextBox";\n            this.PACUrlTextBox.Size = new System.Drawing.Size(245, 20);\n            this.PACUrlTextBox.TabIndex = 4;\n            this.PACUrlTextBox.WordWrap = false;\n            // \n            // PACUrlLabel\n            // \n            this.PACUrlLabel.Anchor = System.Windows.Forms.AnchorStyles.Left;\n            this.PACUrlLabel.AutoSize = true;\n            this.PACUrlLabel.Location = new System.Drawing.Point(3, 6);\n            this.PACUrlLabel.Margin = new System.Windows.Forms.Padding(3);\n            this.PACUrlLabel.Name = "PACUrlLabel";
            this.PACUrlLabel.Name = "PACUrlLabel";\n            this.PACUrlLabel.Size = new System.Drawing.Size(44, 13);\n            this.PACUrlLabel.TabIndex = 3;\n            this.PACUrlLabel.Text = "PAC Url";\n            this.PACUrlLabel.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;\n            // \n            // OkButton\n            // 
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedSingle;\n            this.MaximizeBox = false;\n            this.MinimizeBox = false;\n            this.Name = "PACUrlForm";\n            this.Padding = new System.Windows.Forms.Padding(3);\n            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;\n            this.Text = "Update Online PAC URL";\n            this.Load += new System.EventHandler(this.PACUrlForm_Load);\n            this.tableLayoutPanel1.ResumeLayout(false);\n            this.tableLayoutPanel1.PerformLayout();
#else\n         // Silverlight supports only UTF-8 and UTF-16 out-of-the-box\n         const string encoding = "UTF-8";\n         // caller of the method can only control if the ECI segment should be written\n         // character set is fixed to UTF-8; but some scanners doesn't like the ECI segment\n         bool generateECI = (hints != null && hints.ContainsKey(EncodeHintType.CHARACTER_SET));\n#endif\n         // Pick an encoding mode appropriate for the content. Note that this will not attempt to use\n         // multiple modes / segments even if that were more efficient. Twould be nice.\n         Mode mode = chooseMode(content, encoding);\n         // This will store the header information, like mode and\n         // length, as well as "header" segments like an ECI segment.\n         BitArray headerBits = new BitArray();
         // This will store the header information, like mode and\n         // length, as well as "header" segments like an ECI segment.\n         BitArray headerBits = new BitArray();
         // (With ECI in place,) Write the mode marker\n         appendModeInfo(mode, headerBits);\n         // Collect data within the main segment, separately, to count its size if needed. Don't add it to\n         // main payload yet.\n         BitArray dataBits = new BitArray();\n         appendBytes(content, mode, dataBits, encoding);\n         // Hard part: need to know version to know how many bits length takes. But need to know how many\n         // bits it takes to know version. First we take a guess at version by assuming version will be\n         // the minimum, 1:\n         int provisionalBitsNeeded = headerBits.Size
      }\n      /// <summary>\n      /// Terminate bits as described in 8.4.8 and 8.4.9 of JISX0510:2004 (p.24).\n      /// </summary>\n      /// <param name="numDataBytes">The num data bytes.</param>\n      /// <param name="bits">The bits.</param>\n      internal static void terminateBits(int numDataBytes, BitArray bits)\n      {\n         int capacity = numDataBytes << 3;\n         if (bits.Size > capacity)\n            throw new WriterException("data bits cannot fit in the QR Code" + bits.Size + " > " +\n                capacity);\n         }\n         for (int i = 0; i < 4 && bits.Size < capacity; ++i)
         }\n         // 5 = 4 + 1.\n         if (numRSBlocks != numRsBlocksInGroup1 + numRsBlocksInGroup2)\n         {\n            throw new WriterException("RS blocks mismatch");\n         }\n         // 196 = (13 + 26) * 4 + (14 + 26) * 1\n         if (numTotalBytes !=\n             ((numDataBytesInGroup1 + numEcBytesInGroup1) *\n                 numRsBlocksInGroup1) +\n                 ((numDataBytesInGroup2 + numEcBytesInGroup2) *
         }\n         // 196 = (13 + 26) * 4 + (14 + 26) * 1\n         if (numTotalBytes !=\n             ((numDataBytesInGroup1 + numEcBytesInGroup1) *\n                 numRsBlocksInGroup1) +\n                 ((numDataBytesInGroup2 + numEcBytesInGroup2) *\n                     numRsBlocksInGroup2))\n         {\n            throw new WriterException("Total bytes mismatch");\n         }\n         if (blockID < numRsBlocksInGroup1)
         }\n         if (blockID < numRsBlocksInGroup1)\n         {\n            numDataBytesInBlock[0] = numDataBytesInGroup1;\n            numECBytesInBlock[0] = numEcBytesInGroup1;\n         }\n         else\n         {\n            numDataBytesInBlock[0] = numDataBytesInGroup2;\n            numECBytesInBlock[0] = numEcBytesInGroup2;
         }\n         bits.appendBits(numLetters, numBits);\n      }\n      /// <summary>\n      /// Append "bytes" in "mode" mode (encoding) into "bits". On success, store the result in "bits".\n      /// </summary>\n      /// <param name="content">The content.</param>\n      /// <param name="mode">The mode.</param>\n      /// <param name="bits">The bits.</param>\n      /// <param name="encoding">The encoding.</param>\n         if (mode.Equals(Mode.NUMERIC))\n            appendNumericBytes(content, bits);
      }\n      internal static void append8BitBytes(String content, BitArray bits, String encoding)\n      {\n         byte[] bytes;\n         try\n         {\n            bytes = Encoding.GetEncoding(encoding).GetBytes(content);\n         }\n#if WindowsCE\n         catch (PlatformNotSupportedException)
         }\n         foreach (byte b in bytes)\n         {\n            bits.appendBits(b, 8);\n         }\n      }\n      internal static void appendKanjiBytes(String content, BitArray bits)\n      {\n         byte[] bytes;\n         try
         }\n         matrix[8, matrix.Height - 8] = 1;\n      }\n      private static void embedHorizontalSeparationPattern(int xStart, int yStart, ByteMatrix matrix)\n      {\n         for (int x = 0; x < 8; ++x)\n         {\n            if (!isEmpty(matrix[xStart + x, yStart]))\n            {\n               throw new WriterException();
            }\n            matrix[xStart + x, yStart] = 0;\n         }\n      }\n      private static void embedVerticalSeparationPattern(int xStart, int yStart, ByteMatrix matrix)\n      {\n         for (int y = 0; y < 7; ++y)\n         {\n            if (!isEmpty(matrix[xStart, yStart + y]))\n            {
            }\n            catch (Exception e)\n            {\n                // translate Microsoft language into human language\n                // i.e. An attempt was made to access a socket in a way forbidden by its access permissions => Port already in use\n                if (e is SocketException)\n                {\n                    SocketException se = (SocketException)e;\n                    if (se.SocketErrorCode == SocketError.AccessDenied)\n                    {
    {\n        private static int PORT = 8093;\n        public static string PAC_FILE = "pac.txt";\n        FileSystemWatcher watcher;\n        public event EventHandler PACFileChanged;\n        public PACServer()\n        {\n            this.WatchPacFile();
        FileSystemWatcher watcher;\n        public event EventHandler PACFileChanged;\n        public PACServer()\n        {\n            this.WatchPacFile();\n        }\n        public bool Handle(byte[] firstPacket, int length, Socket socket)\n        {\n            try
        {\n            try\n            {\n                string request = Encoding.UTF8.GetString(firstPacket, 0, length);\n                string[] lines = request.Split('\r', '\n');\n                bool hostMatch = false, pathMatch = false;\n                foreach (string line in lines)
                {\n                    string[] kv = line.Split(new char[]{':'}, 2);\n                    if (kv.Length == 2)\n                    {\n                        if (kv[0] == "Host")\n                        {\n                            if (kv[1].Trim() == ((IPEndPoint)socket.LocalEndPoint).ToString())\n                            {\n                                hostMatch = true;\n                            }
                }\n                if (hostMatch && pathMatch)\n                {\n                    SendResponse(firstPacket, length, socket);\n                    return true;\n                }\n                return false;
                {\n                    SendResponse(firstPacket, length, socket);\n                    return true;\n                }\n                return false;
                }\n                return false;\n            }\n            catch (ArgumentException)
            }\n            catch (ArgumentException)\n            {\n                return false;
            {\n                return false;
            }\n        }\n        public string TouchPACFile()\n        {\n            if (File.Exists(PAC_FILE))\n            {\n                return PAC_FILE;\n            }\n            else\n            {
        {\n            try\n            {\n                string pac = GetPACContent();\n                IPEndPoint localEndPoint = (IPEndPoint)socket.LocalEndPoint;\n                string proxy = GetPACAddress(firstPacket, length, localEndPoint);
            try\n            {\n                string pac = GetPACContent();\n                IPEndPoint localEndPoint = (IPEndPoint)socket.LocalEndPoint;\n                string proxy = GetPACAddress(firstPacket, length, localEndPoint);\n                pac = pac.Replace("__PROXY__", proxy);\n                string text = String.Format(@"HTTP/1.1 200 OK
                string pac = GetPACContent();\n                IPEndPoint localEndPoint = (IPEndPoint)socket.LocalEndPoint;\n                string proxy = GetPACAddress(firstPacket, length, localEndPoint);\n                pac = pac.Replace("__PROXY__", proxy);\n                string text = String.Format(@"HTTP/1.1 200 OK\nServer: Shadowsocks\nContent-Type: application/x-ns-proxy-autoconfig\nContent-Length: {0}
                pac = pac.Replace("__PROXY__", proxy);\n                string text = String.Format(@"HTTP/1.1 200 OK\nServer: Shadowsocks\nContent-Type: application/x-ns-proxy-autoconfig\nContent-Length: {0}\nConnection: Close\n", System.Text.Encoding.UTF8.GetBytes(pac).Length) + pac;\n                byte[] response = System.Text.Encoding.UTF8.GetBytes(text);
Server: Shadowsocks\nContent-Type: application/x-ns-proxy-autoconfig\nContent-Length: {0}\nConnection: Close\n", System.Text.Encoding.UTF8.GetBytes(pac).Length) + pac;\n                byte[] response = System.Text.Encoding.UTF8.GetBytes(text);\n                socket.BeginSend(response, 0, response.Length, 0, new AsyncCallback(SendCallback), socket);\n                Util.Utils.ReleaseMemory();
            }\n            catch (Exception e)\n            {\n                Console.WriteLine(e);\n                socket.Close();\n            }\n        }\n        private void SendCallback(IAsyncResult ar)\n        {\n            Socket conn = (Socket)ar.AsyncState;
            }\n        }\n        private void SendCallback(IAsyncResult ar)\n        {\n            Socket conn = (Socket)ar.AsyncState;\n            try\n            {\n                conn.Shutdown(SocketShutdown.Send);\n            }\n            catch
        {\n            return "PROXY " + localEndPoint.Address + ":8123;";\n        }\n    }\n}
        }\n    }\n}
            socket.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n            Handler handler = new Handler();\n            handler.connection = socket;\n            Server server = _config.GetCurrentServer();\n            handler.encryptor = EncryptorFactory.GetEncryptor(server.method, server.password);\n            handler.server = server;\n            handler.Start(firstPacket, length);\n            return true;\n        }\n    }
            {\n                server = "192.168.100.1",\n                server_port = 8888,\n                password = "test",\n                method = "bf-cfb"\n            };\n            server1CanonUrl = "ss://YmYtY2ZiOnRlc3RAMTkyLjE2OC4xMDAuMTo4ODg4";\n            // server2 has base64 padding\n            server2 = new Server
            {\n                server = "192.168.1.1",\n                server_port = 8388,\n                password = "test",\n                method = "bf-cfb"\n            };\n            server2CanonUrl = "ss://YmYtY2ZiOnRlc3RAMTkyLjE2OC4xLjE6ODM4OA==";\n            server1WithRemark = new Server\n            {\n                server = server1.server,
                remarks = "example-server"\n            };\n            server1WithRemarkCanonUrl = "ss://YmYtY2ZiOnRlc3RAMTkyLjE2OC4xMDAuMTo4ODg4#example-server";\n            server2WithRemark = new Server\n            {\n                server = server2.server,\n                server_port = server2.server_port,\n                password = server2.password,\n                method = server2.method,\n                remarks = "example-server"
            {\n                server = server2.server,\n                server_port = server2.server_port,\n                password = server2.password,\n                method = server2.method,\n                remarks = "example-server"\n            };\n            server2WithRemarkCanonUrl = "ss://YmYtY2ZiOnRlc3RAMTkyLjE2OC4xLjE6ODM4OA==#example-server";\n            server1WithPlugin = new Server\n            {
                plugin = "obfs-local",\n                plugin_opts = "obfs=http;obfs-host=google.com"\n            };\n            server1WithPluginCanonUrl =\n                "ss://YmYtY2ZiOnRlc3Q@192.168.100.1:8888/?plugin=obfs-local%3bobfs%3dhttp%3bobfs-host%3dgoogle.com";\n            server2WithPlugin = new Server\n            {\n                server = server2.server,\n                server_port = server2.server_port,\n                password = server2.password,
                "ss://YmYtY2ZiOnRlc3Q@192.168.100.1:8888/?plugin=obfs-local%3bobfs%3dhttp%3bobfs-host%3dgoogle.com";\n            server2WithPlugin = new Server\n            {\n                server = server2.server,\n                server_port = server2.server_port,\n                password = server2.password,\n                method = server2.method,\n                plugin = "obfs-local",\n                plugin_opts = "obfs=http;obfs-host=google.com"\n            };
            {\n                server = server2.server,\n                server_port = server2.server_port,\n                password = server2.password,\n                method = server2.method,\n                plugin = "obfs-local",\n                plugin_opts = "obfs=http;obfs-host=google.com"\n            };\n            server2WithPluginCanonUrl =\n                "ss://YmYtY2ZiOnRlc3Q@192.168.1.1:8388/?plugin=obfs-local%3bobfs%3dhttp%3bobfs-host%3dgoogle.com";
                "ss://YmYtY2ZiOnRlc3Q@192.168.1.1:8388/?plugin=obfs-local%3bobfs%3dhttp%3bobfs-host%3dgoogle.com";\n            server1WithPluginAndRemark = new Server\n            {\n                server = server1.server,\n                server_port = server1.server_port,\n                password = server1.password,\n                method = server1.method,\n                plugin = server1WithPlugin.plugin,\n                plugin_opts = server1WithPlugin.plugin_opts,\n                remarks = server1WithRemark.remarks
                "ss://YmYtY2ZiOnRlc3Q@192.168.100.1:8888/?plugin=obfs-local%3bobfs%3dhttp%3bobfs-host%3dgoogle.com#example-server";\n            server2WithPluginAndRemark = new Server\n            {\n                server = server2.server,\n                server_port = server2.server_port,\n                password = server2.password,\n                method = server2.method,\n                plugin = server2WithPlugin.plugin,\n                plugin_opts = server2WithPlugin.plugin_opts,\n                remarks = server2WithRemark.remarks
            {\n                server = server2.server,\n                server_port = server2.server_port,\n                password = server2.password,\n                method = server2.method,\n                plugin = server2WithPlugin.plugin,\n                plugin_opts = server2WithPlugin.plugin_opts,\n                remarks = server2WithRemark.remarks\n            };\n            server2WithPluginAndRemarkCanonUrl =
                "ss://YmYtY2ZiOnRlc3Q@192.168.1.1:8388/?plugin=obfs-local%3bobfs%3dhttp%3bobfs-host%3dgoogle.com#example-server";\n        }\n        [TestMethod]\n        public void TestParseUrl_Server1()\n        {\n            RunParseShadowsocksUrlTest(\n                string.Join(\n                    "\r\n",\n                    server1CanonUrl,\n                    "\r\n",
                    "\r\n",\n                    "ss://YmYtY2ZiOnRlc3RAMTkyLjE2OC4xMDAuMTo4ODg4/",\n                    server1,\n                    server1,\n                    server1WithRemark,\n                    server1WithRemark
            RunParseShadowsocksUrlTest(\n                string.Join(\n                    "\r\n",\n                    server2CanonUrl,\n                    "\r\n",\n                    "ss://YmYtY2ZiOnRlc3RAMTkyLjE2OC4xLjE6ODM4OA==/",\n                    server2WithRemarkCanonUrl,\n                    "ss://YmYtY2ZiOnRlc3RAMTkyLjE2OC4xLjE6ODM4OA==/#example-server"),\n                new[]\n                {
        {\n            var NoPlugin = Sip003Plugin.CreateIfConfigured(new Server\n            {\n                server = "192.168.100.1",\n                server_port = 8888,\n                password = "test",\n                method = "bf-cfb"\n            });\n            RunPluginSupportTest(
            var NoPlugin = Sip003Plugin.CreateIfConfigured(new Server\n            {\n                server = "192.168.100.1",\n                server_port = 8888,\n                password = "test",\n                method = "bf-cfb"\n            });\n            RunPluginSupportTest(\n                NoPlugin,\n                "",
        public HotkeySettingsForm(ShadowsocksController controller)\n        {\n            InitializeComponent();\n            UpdateTexts();\n            Icon = Icon.FromHandle(Resources.ssw128.GetHicon());\n            _controller = controller;\n            _controller.ConfigChanged += controller_ConfigChanged;\n            LoadCurrentConfiguration();
        }\n        private void UpdateTexts()\n        {\n            // I18N stuff\n            SwitchSystemProxyLabel.Text = I18N.GetString("Switch system proxy");\n            SwitchProxyModeLabel.Text = I18N.GetString("Switch system proxy mode");\n            SwitchAllowLanLabel.Text = I18N.GetString("Switch share over LAN");\n            ShowLogsLabel.Text = I18N.GetString("Show Logs");\n            ServerMoveUpLabel.Text = I18N.GetString("Switch to prev server");\n            ServerMoveDownLabel.Text = I18N.GetString("Switch to next server");
        }\n        private bool RegHotkeyFromString(string hotkeyStr, string callbackName, Label indicator = null)\n        {\n            var _callback = HotkeyCallbacks.GetCallback(callbackName);\n            if (_callback == null)\n            {\n                throw new Exception($"{callbackName} not found");\n            }\n            var callback = _callback as HotKeys.HotKeyCallBackHandler;\n            if (hotkeyStr.IsNullOrEmpty())
        {\n            var _callback = HotkeyCallbacks.GetCallback(callbackName);\n            if (_callback == null)\n            {\n                throw new Exception($"{callbackName} not found");\n            }\n            var callback = _callback as HotKeys.HotKeyCallBackHandler;\n            if (hotkeyStr.IsNullOrEmpty())\n            {\n                HotKeys.UnregExistingHotkey(callback);
                return true;\n            }\n            else\n            {\n                var hotkey = HotKeys.Str2HotKey(hotkeyStr);\n                if (hotkey == null)\n                {\n                    MessageBox.Show(string.Format(I18N.GetString("Cannot parse hotkey: {0}"), hotkeyStr));\n                    return false;\n                }
                    if (indicator != null)\n                    {\n                        indicator.BackColor = regResult ? Color.Green : Color.Yellow;\n                    }\n                    return regResult;\n                }\n            }\n        }
    }\n}
            foreach (var d in domains)\n            {\n                string domain = d.Value;\n                switch (d.Type)\n                {\n                    case DomainObject.Types.Type.Plain:\n                        ret.Add($"@@{domain}");\n                        break;\n                    case DomainObject.Types.Type.Regex:
                        break;\n                    case DomainObject.Types.Type.Regex:

            this.tableLayoutPanel1.Location = new System.Drawing.Point(8, 21);\n            this.tableLayoutPanel1.Margin = new System.Windows.Forms.Padding(0);\n            this.tableLayoutPanel1.Name = "tableLayoutPanel1";\n            this.tableLayoutPanel1.Padding = new System.Windows.Forms.Padding(3);\n            this.tableLayoutPanel1.RowCount = 10;\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel1.TabIndex = 0;\n            // \n            // PluginOptionsLabel\n            // \n            this.PluginOptionsLabel.Anchor = System.Windows.Forms.AnchorStyles.Right;\n            this.PluginOptionsLabel.AutoSize = true;
                return configuration;\n            }\n            catch (FileNotFoundException e)\n            {\n                var configuration = new StatisticsStrategyConfiguration();\n                Save(configuration);\n                return configuration;\n            }\n            catch (Exception e)\n            {
            {\n                var configuration = new StatisticsStrategyConfiguration();\n                Save(configuration);\n                return configuration;\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                return new StatisticsStrategyConfiguration();\n            }
            this.chartModeSelector = new System.Windows.Forms.GroupBox();\n            this.allMode = new System.Windows.Forms.RadioButton();\n            this.dayMode = new System.Windows.Forms.RadioButton();\n            this.splitContainer1 = new System.Windows.Forms.SplitContainer();\n            this.splitContainer2 = new System.Windows.Forms.SplitContainer();\n            this.CollectDataPerLabel = new System.Windows.Forms.Label();\n            this.MinutesLabel1 = new System.Windows.Forms.Label();\n            this.dataCollectionMinutesNum = new System.Windows.Forms.NumericUpDown();\n            this.StatisticsEnabledCheckBox = new System.Windows.Forms.CheckBox();\n            this.choiceKeptMinutesNum = new System.Windows.Forms.NumericUpDown();
            this.dataCollectionMinutesNum = new System.Windows.Forms.NumericUpDown();\n            this.StatisticsEnabledCheckBox = new System.Windows.Forms.CheckBox();\n            this.choiceKeptMinutesNum = new System.Windows.Forms.NumericUpDown();\n            this.byHourOfDayCheckBox = new System.Windows.Forms.CheckBox();\n            this.repeatTimesNum = new System.Windows.Forms.NumericUpDown();\n            this.PackagePerPingLabel = new System.Windows.Forms.Label();\n            this.splitContainer3 = new System.Windows.Forms.SplitContainer();\n            this.FinalScoreLabel = new System.Windows.Forms.Label();\n            this.calculationContainer = new System.Windows.Forms.FlowLayoutPanel();\n            this.serverSelector = new System.Windows.Forms.ComboBox();
            this.splitContainer3 = new System.Windows.Forms.SplitContainer();\n            this.FinalScoreLabel = new System.Windows.Forms.Label();\n            this.calculationContainer = new System.Windows.Forms.FlowLayoutPanel();\n            this.serverSelector = new System.Windows.Forms.ComboBox();\n            this.CancelButton = new System.Windows.Forms.Button();\n            this.OKButton = new System.Windows.Forms.Button();\n            this.CalculatinTip = new System.Windows.Forms.ToolTip(this.components);\n            this.bindingConfiguration = new System.Windows.Forms.BindingSource(this.components);\n            ((System.ComponentModel.ISupportInitialize)(this.StatisticsChart)).BeginInit();
            this.calculationContainer = new System.Windows.Forms.FlowLayoutPanel();\n            this.serverSelector = new System.Windows.Forms.ComboBox();\n            this.CancelButton = new System.Windows.Forms.Button();\n            this.OKButton = new System.Windows.Forms.Button();\n            this.CalculatinTip = new System.Windows.Forms.ToolTip(this.components);\n            this.bindingConfiguration = new System.Windows.Forms.BindingSource(this.components);\n            ((System.ComponentModel.ISupportInitialize)(this.StatisticsChart)).BeginInit();\n            this.chartModeSelector.SuspendLayout();\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer1)).BeginInit();
            this.chartModeSelector.SuspendLayout();\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer1)).BeginInit();\n            this.splitContainer1.Panel1.SuspendLayout();\n            this.splitContainer1.Panel2.SuspendLayout();\n            this.splitContainer1.SuspendLayout();\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer2)).BeginInit();\n            this.splitContainer2.Panel1.SuspendLayout();\n            this.splitContainer2.Panel2.SuspendLayout();\n            this.splitContainer2.SuspendLayout();\n            ((System.ComponentModel.ISupportInitialize)(this.dataCollectionMinutesNum)).BeginInit();
            this.splitContainer2.Panel1.Controls.Add(this.dataCollectionMinutesNum);\n            this.splitContainer2.Panel1.Controls.Add(this.StatisticsEnabledCheckBox);\n            this.splitContainer2.Panel1.Controls.Add(this.choiceKeptMinutesNum);\n            this.splitContainer2.Panel1.Controls.Add(this.byHourOfDayCheckBox);\n            this.splitContainer2.Panel1.Controls.Add(this.repeatTimesNum);\n            this.splitContainer2.Panel1.Controls.Add(this.PackagePerPingLabel);\n            this.splitContainer2.Panel1.Controls.Add(this.KeepChoiceForLabel);\n            this.splitContainer2.Panel1.Controls.Add(this.PingCheckBox);\n            this.splitContainer2.Panel1.Controls.Add(this.MinutesLabel2);\n            // 
            this.splitContainer2.Panel1.Controls.Add(this.PingCheckBox);\n            this.splitContainer2.Panel1.Controls.Add(this.MinutesLabel2);\n            // \n            // splitContainer2.Panel2\n            // \n            this.splitContainer2.Panel2.Controls.Add(this.splitContainer3);
            // \n            // splitContainer2.Panel2\n            // \n            this.splitContainer2.Panel2.Controls.Add(this.splitContainer3);
            // \n            // splitContainer3.Panel2\n            // \n            this.splitContainer3.Panel2.Controls.Add(this.calculationContainer);\n            // FinalScoreLabel\n            // \n            this.FinalScoreLabel.AutoSize = true;\n            this.FinalScoreLabel.Location = new System.Drawing.Point(5, 9);\n            this.FinalScoreLabel.Margin = new System.Windows.Forms.Padding(5, 0, 5, 0);
            // \n            // calculationContainer\n            // \n            this.calculationContainer.AutoScroll = true;\n            this.calculationContainer.Dock = System.Windows.Forms.DockStyle.Fill;\n            this.calculationContainer.Location = new System.Drawing.Point(0, 0);\n            this.calculationContainer.Margin = new System.Windows.Forms.Padding(5, 10, 5, 10);\n            this.calculationContainer.Name = "calculationContainer";
            this.chartModeSelector.ResumeLayout(false);\n            this.chartModeSelector.PerformLayout();\n            this.splitContainer1.Panel1.ResumeLayout(false);\n            this.splitContainer1.Panel2.ResumeLayout(false);\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer1)).EndInit();\n            this.splitContainer1.ResumeLayout(false);\n            this.splitContainer2.Panel1.ResumeLayout(false);\n            this.splitContainer2.Panel1.PerformLayout();\n            this.splitContainer2.Panel2.ResumeLayout(false);\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer2)).EndInit();
        private System.Windows.Forms.GroupBox chartModeSelector;\n        private System.Windows.Forms.RadioButton allMode;\n        private System.Windows.Forms.RadioButton dayMode;\n        private System.Windows.Forms.SplitContainer splitContainer1;\n        private System.Windows.Forms.Label FinalScoreLabel;\n        private System.Windows.Forms.SplitContainer splitContainer2;\n        private System.Windows.Forms.FlowLayoutPanel calculationContainer;\n        private System.Windows.Forms.SplitContainer splitContainer3;\n        private System.Windows.Forms.NumericUpDown repeatTimesNum;\n        private System.Windows.Forms.Label PackagePerPingLabel;
        private System.Windows.Forms.SplitContainer splitContainer2;\n        private System.Windows.Forms.FlowLayoutPanel calculationContainer;\n        private System.Windows.Forms.SplitContainer splitContainer3;\n        private System.Windows.Forms.NumericUpDown repeatTimesNum;\n        private System.Windows.Forms.Label PackagePerPingLabel;\n        private System.Windows.Forms.CheckBox byHourOfDayCheckBox;\n        private System.Windows.Forms.NumericUpDown choiceKeptMinutesNum;\n        private System.Windows.Forms.CheckBox StatisticsEnabledCheckBox;\n        private System.Windows.Forms.Label CollectDataPerLabel;\n        private System.Windows.Forms.Label MinutesLabel1;
        private System.Windows.Forms.CheckBox byHourOfDayCheckBox;\n        private System.Windows.Forms.NumericUpDown choiceKeptMinutesNum;\n        private System.Windows.Forms.CheckBox StatisticsEnabledCheckBox;\n        private System.Windows.Forms.Label CollectDataPerLabel;\n        private System.Windows.Forms.Label MinutesLabel1;\n        private System.Windows.Forms.NumericUpDown dataCollectionMinutesNum;\n        private System.Windows.Forms.BindingSource bindingConfiguration;\n        private new System.Windows.Forms.Button CancelButton;\n        private System.Windows.Forms.Button OKButton;\n        private System.Windows.Forms.ComboBox serverSelector;
        private System.Windows.Forms.NumericUpDown dataCollectionMinutesNum;\n        private System.Windows.Forms.BindingSource bindingConfiguration;\n        private new System.Windows.Forms.Button CancelButton;\n        private System.Windows.Forms.Button OKButton;\n        private System.Windows.Forms.ComboBox serverSelector;\n        private System.Windows.Forms.ToolTip CalculatinTip;\n    }\n}
                this.hotKeyItem = CreateMenuItem("Edit Hotkeys...", new EventHandler(this.hotKeyItem_Click)),\n                CreateMenuGroup("Help", new MenuItem[] {\n                    CreateMenuItem("Show Logs...", new EventHandler(this.ShowLogItem_Click)),\n                    this.VerboseLoggingToggleItem = CreateMenuItem( "Verbose Logging", new EventHandler(this.VerboseLoggingToggleItem_Click) ),\n                    CreateMenuGroup("Updates...", new MenuItem[] {\n                        CreateMenuItem("Check for Updates...", new EventHandler(this.checkUpdatesItem_Click)),\n                        new MenuItem("-"),\n                        this.autoCheckUpdatesToggleItem = CreateMenuItem("Check for Updates at Startup", new EventHandler(this.autoCheckUpdatesToggleItem_Click)),\n                        this.checkPreReleaseToggleItem = CreateMenuItem("Check Pre-release Version", new EventHandler(this.checkPreReleaseToggleItem_Click)),\n                    }),
                }),

using Shadowsocks.Controller.Strategy;\nusing Shadowsocks.Model;\nusing Shadowsocks.Util;\nnamespace Shadowsocks.Controller\n{\n    public class ShadowsocksController
using Shadowsocks.Util;\nnamespace Shadowsocks.Controller\n{\n    public class ShadowsocksController\n    {\n        // controller:\n        // handle user actions
namespace Shadowsocks.Controller\n{\n    public class ShadowsocksController\n    {\n        // controller:\n        // handle user actions\n        // manipulates UI\n        // interacts with low level logic\n        private Thread _ramThread;\n        private Thread _trafficThread;
        }\n        public void ToggleGlobal(bool global)\n        {\n            _config.global = global;\n            SaveConfig(_config);\n            EnableGlobalChanged?.Invoke(this, new EventArgs());
        }\n        public void ToggleShareOverLAN(bool enabled)\n        {\n            _config.shareOverLan = enabled;\n            SaveConfig(_config);\n            ShareOverLANStatusChanged?.Invoke(this, new EventArgs());
        }\n        public void SaveProxy(ProxyConfig proxyConfig)\n        {\n            _config.proxy = proxyConfig;\n            SaveConfig(_config);\n        }\n        public void ToggleVerboseLogging(bool enabled)\n        {\n            _config.isVerboseLogging = enabled;\n            SaveConfig(_config);
        }\n        public void TouchUserRuleFile()\n        {\n            string userRuleFilename = _pacServer.TouchUserRuleFile();\n            UserRuleFileReadyToOpen?.Invoke(this, new PathEventArgs() { Path = userRuleFilename });\n        }
        }\n        public string GetServerURLForCurrentServer()\n        {\n            Server server = GetCurrentServer();\n            return GetServerURL(server);\n        }\n        public static string GetServerURL(Server server)\n        {\n            string tag = string.Empty;\n            string url = string.Empty;
        }\n        public void SavePACUrl(string pacUrl)\n        {\n            _config.pacUrl = pacUrl;\n            SaveConfig(_config);\n            ConfigChanged?.Invoke(this, new EventArgs());
        }\n        public void UseOnlinePAC(bool useOnlinePac)\n        {\n            _config.useOnlinePac = useOnlinePac;\n            SaveConfig(_config);\n            ConfigChanged?.Invoke(this, new EventArgs());
        }\n        public void ToggleSecureLocalPac(bool enabled)\n        {\n            _config.secureLocalPac = enabled;\n            SaveConfig(_config);\n            ConfigChanged?.Invoke(this, new EventArgs());
        }\n        public void ToggleCheckingUpdate(bool enabled)\n        {\n            _config.autoCheckUpdate = enabled;\n            Configuration.Save(_config);\n            ConfigChanged?.Invoke(this, new EventArgs());
        }\n        public void ToggleCheckingPreRelease(bool enabled)\n        {\n            _config.checkPreRelease = enabled;\n            Configuration.Save(_config);\n            ConfigChanged?.Invoke(this, new EventArgs());
        }\n        public void SaveLogViewerConfig(LogViewerConfig newConfig)\n        {\n            _config.logViewer = newConfig;\n            newConfig.SaveSize();\n            Configuration.Save(_config);\n            ConfigChanged?.Invoke(this, new EventArgs());
        }\n        public void SaveHotkeyConfig(HotkeyConfig newConfig)\n        {\n            _config.hotkey = newConfig;\n            SaveConfig(_config);\n            ConfigChanged?.Invoke(this, new EventArgs());
        }\n        public void UpdateLatency(Server server, TimeSpan latency)\n        {\n            if (_config.availabilityStatistics)\n            {\n                availabilityStatistics.UpdateLatency(server, (int)latency.TotalMilliseconds);\n            }\n        }\n        public void UpdateInboundCounter(Server server, long n)\n        {
                _listener = new Listener(services);\n                _listener.Start(_config);\n            }\n            catch (Exception e)\n            {\n                // translate Microsoft language into human language\n                // i.e. An attempt was made to access a socket in a way forbidden by its access permissions => Port already in use\n                if (e is SocketException se)\n                {\n                    if (se.SocketErrorCode == SocketError.AddressAlreadyInUse)\n                    {
                    if (se.SocketErrorCode == SocketError.AddressAlreadyInUse)\n                    {\n                        e = new Exception(I18N.GetString("Port {0} already in use", _config.localPort), e);\n                    }\n                    else if (se.SocketErrorCode == SocketError.AccessDenied)\n                    {\n                        e = new Exception(I18N.GetString("Port {0} is reserved by system", _config.localPort), e);\n                    }\n                }\n                Logging.LogUsefulException(e);
            _trafficThread.Start();\n        }\n        private void TrafficStatistics(int queueMaxSize)\n        {\n            TrafficPerSecond previous, current;\n            while (true)\n            {\n                previous = trafficPerSecondQueue.Last();\n                current = new TrafficPerSecond\n                {
                current.inboundIncreasement = current.inboundCounter - previous.inboundCounter;\n                current.outboundIncreasement = current.outboundCounter - previous.outboundCounter;\n                trafficPerSecondQueue.Enqueue(current);\n                if (trafficPerSecondQueue.Count > queueMaxSize)\n                    trafficPerSecondQueue.Dequeue();\n                TrafficChanged?.Invoke(this, new EventArgs());\n                Thread.Sleep(1000);\n            }\n        }\n        #endregion
        }\n        private void ReceiveCallback(IAsyncResult ar)\n        {\n            int length = (int)ar.AsyncState;\n            try\n            {\n                var bytesRead = _socket.EndReceive(ar);\n                if (bytesRead == 0)\n                {\n                    OnFinish(length);
                    return;\n                }\n                length += bytesRead;\n                int i;\n                while ((i = IndexOf(_lineBuffer, _bufferIndex, length, _delimiterBytes, _delimiterSearchOffsetTable,\n                           _delimiterSearchCharTable)) != -1)\n                {\n                    var decodeLen = i - _bufferIndex;\n                    string line = _encoding.GetString(_lineBuffer, _bufferIndex, decodeLen);\n                    _bufferIndex = i + _delimiterBytes.Length;
            }\n            catch (Exception ex)\n            {\n                OnException(ex);\n                OnFinish(length);\n            }
        }\n        private void OnException(Exception ex)\n        {\n            _onException?.Invoke(ex, _state);\n        }\n        private void OnFinish(int length)\n        {\n            _onFinish?.Invoke(_lineBuffer, _bufferIndex, length, _state);\n        }\n        #region Boyer-Moore string search\n        public static int IndexOf(byte[] haystack, int index, int length, byte[] needle, int[] offsetTable, int[] charTable)
        }\n        #region Boyer-Moore string search\n        public static int IndexOf(byte[] haystack, int index, int length, byte[] needle, int[] offsetTable, int[] charTable)\n        {\n            var end = index + length;\n            for (int i = needle.Length - 1 + index, j; i < end;)\n            {\n                for (j = needle.Length - 1; needle[j] == haystack[i]; --i, --j)\n                {\n                    if (j == 0)\n                    {
        {\n            var end = index + length;\n            for (int i = needle.Length - 1 + index, j; i < end;)\n            {\n                for (j = needle.Length - 1; needle[j] == haystack[i]; --i, --j)\n                {\n                    if (j == 0)\n                    {\n                        return i;\n                    }
            {\n                Logging.LogUsefulException(ex);\n            }\n            finally\n            {\n                try\n                {\n                    _udpSocket.BeginReceiveFrom(state.buffer, 0, state.buffer.Length, 0, ref state.remoteEndPoint, new AsyncCallback(RecvFromCallback), state);\n                }\n                catch (ObjectDisposedException)
            public UDPHandler(Socket local, Server server, IPEndPoint localEndPoint)\n            {\n                _local = local;\n                _server = server;\n                _localEndPoint = localEndPoint;\n                // TODO async resolving\n                IPAddress ipAddress;\n                bool parsed = IPAddress.TryParse(server.server, out ipAddress);\n                if (!parsed)\n                {
            }\n            public void Send(byte[] data, int length)\n            {\n                IEncryptor encryptor = EncryptorFactory.GetEncryptor(_server.method, _server.password, _server.auth, true);\n                byte[] dataIn = new byte[length - 3 + IVEncryptor.ONETIMEAUTH_BYTES];\n                Array.Copy(data, 3, dataIn, 0, length - 3);\n                byte[] dataOut = new byte[length - 3 + 16 + IVEncryptor.ONETIMEAUTH_BYTES];\n                int outlen;\n                encryptor.Encrypt(dataIn, length - 3, dataOut, out outlen);\n                Logging.Debug(_localEndPoint, _remoteEndPoint, outlen, "UDP Relay");
                        }\n                        else if (global)\n                        {\n                            iconCopy.SetPixel(x, y, Color.FromArgb(color.A, 0, color.G, 0));\n                        }\n                        else\n                        {\n                            iconCopy.SetPixel(x, y, Color.FromArgb(color.A, color.R, color.G, 0));
                        }\n                        else\n                        {\n                            iconCopy.SetPixel(x, y, Color.FromArgb(color.A, color.R, color.G, 0));

            var ret = new List<DataList>();\n            try {\n                var IP = Dns.GetHostAddresses(server.server).First(ip => (ip.AddressFamily == AddressFamily.InterNetwork || ip.AddressFamily == AddressFamily.InterNetworkV6));\n                var ping = new Ping();\n                foreach (var timestamp in Enumerable.Range(0, Repeat).Select(_ => DateTime.Now.ToString(DateTimePattern)))\n                {\n                    //ICMP echo. we can also set options and special bytes\n                    try\n                    {\n                        var reply = await ping.SendTaskAsync(IP, Timeout);
                    {\n                        new KeyValuePair<string, string>("Timestamp", timestamp),\n                        new KeyValuePair<string, string>("Server", server.FriendlyName()),\n                        new KeyValuePair<string, string>("Status", reply?.Status.ToString()),\n                        new KeyValuePair<string, string>("RoundtripTime", reply?.RoundtripTime.ToString())\n                        //new KeyValuePair<string, string>("data", reply.Buffer.ToString()); // The data of reply\n                    });\n                        Thread.Sleep(Timeout + new Random().Next() % Timeout);\n                        //Do ICMPTest in a random frequency\n                    }\n                    catch (Exception e)
            }\n            return ret;\n        }\n        private void Run(object obj)\n        {\n            LoadRawStatistics();\n            FilterRawStatistics();\n            evaluate();\n        }\n        private async void evaluate()
        }\n        public void EndConnectDest(IAsyncResult asyncResult)\n        {\n            _remote.EndConnect(asyncResult);\n            _remote.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n        }\n        public void BeginSend(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state)\n        {
        }\n        public void BeginSend(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state)\n        {\n            _remote?.BeginSend(buffer, offset, size, socketFlags, callback, state);\n        }\n        public int EndSend(IAsyncResult asyncResult)\n        {\n            return _remote.EndSend(asyncResult);\n        }
using System.Net;\nusing System.Net.Sockets;\nusing System.Text;\nusing System.Threading;\nusing Shadowsocks.Controller;\nusing Shadowsocks.Util.Sockets;\nnamespace Shadowsocks.Proxy\n{\n    public class Socks5Proxy : IProxy\n    {
namespace Shadowsocks.Proxy\n{\n    public class Socks5Proxy : IProxy\n    {\n        private class FakeAsyncResult : IAsyncResult\n        {\n            public readonly Socks5State innerState;\n            private readonly IAsyncResult r;\n            public FakeAsyncResult(IAsyncResult orig, Socks5State state)\n            {
        }\n        private void ConnectCallback(IAsyncResult ar)\n        {\n            var state = (Socks5State) ar.AsyncState;\n            try\n            {\n                _remote.EndConnect(ar);\n                _remote.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n                byte[] handshake = {5, 1, 0};
                byte[] handshake = {5, 1, 0};\n                _remote.BeginSend(handshake, 0, handshake.Length, 0, Socks5HandshakeSendCallback, state);\n            }\n            catch (Exception ex)\n            {\n                state.ex = ex;\n                state.Callback?.Invoke(new FakeAsyncResult(ar, state));\n            }\n        }\n        private void Socks5HandshakeSendCallback(IAsyncResult ar)
        {\n            if (config.enabled)\n            {\n                SystemProxy.Enable();\n            }\n            else\n            {\n                SystemProxy.Disable();
            {\n                SystemProxy.Enable();\n            }\n            else\n            {\n                SystemProxy.Disable();\n            }\n        }\n        private void EnableItem_Click(object sender, EventArgs e)\n        {
            get {\n                object obj = ResourceManager.GetObject("proxy_pac_txt", resourceCulture);\n                return ((byte[])(obj));\n            }\n        }\n    }\n}
            }\n        }\n    }\n}
                string proxy = "PROXY 127.0.0.1:8123; DIRECT;";\n                pac = pac.Replace("__PROXY__", proxy);\n                if (bytesRead > 0)\n                {\n                    string text = String.Format(@"HTTP/1.1 200 OK\nServer: Shadowsocks\nContent-Type: application/x-ns-proxy-autoconfig\nContent-Length: {0}\nConnection: Close\n", System.Text.Encoding.UTF8.GetBytes(pac).Length) + pac;
            this.panel2 = new System.Windows.Forms.Panel();\n            this.button1 = new System.Windows.Forms.Button();\n            this.button2 = new System.Windows.Forms.Button();\n            this.panel1 = new System.Windows.Forms.Panel();\n            this.contextMenu1 = new System.Windows.Forms.ContextMenu();\n            this.enableItem = new System.Windows.Forms.MenuItem();\n            this.aboutItem = new System.Windows.Forms.MenuItem();\n            this.menuItem3 = new System.Windows.Forms.MenuItem();\n            this.quitItem = new System.Windows.Forms.MenuItem();\n            this.configItem = new System.Windows.Forms.MenuItem();
            this.tableLayoutPanel1.SuspendLayout();\n            this.panel1.SuspendLayout();\n            this.SuspendLayout();\n            // \n            // tableLayoutPanel1\n            // \n            this.tableLayoutPanel1.AutoSize = true;\n            this.tableLayoutPanel1.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;\n            this.tableLayoutPanel1.ColumnCount = 2;
            this.panel1.SuspendLayout();\n            this.SuspendLayout();\n            // \n            // tableLayoutPanel1\n            // \n            this.tableLayoutPanel1.AutoSize = true;\n            this.tableLayoutPanel1.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;\n            this.tableLayoutPanel1.ColumnCount = 2;\n            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());\n            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());
            this.notifyIcon1.Icon = ((System.Drawing.Icon)(resources.GetObject("notifyIcon1.Icon")));\n            this.notifyIcon1.Text = "shadowsocks";\n            this.notifyIcon1.Visible = true;\n            this.notifyIcon1.DoubleClick += new System.EventHandler(this.notifyIcon1_DoubleClick);
            // \n            // panel2\n            // \n            this.panel2.Anchor = System.Windows.Forms.AnchorStyles.Top;\n            this.panel2.AutoSize = true;\n            this.panel2.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;\n            this.panel2.Location = new System.Drawing.Point(61, 175);\n            this.panel2.Name = "panel2";\n            this.panel2.Size = new System.Drawing.Size(0, 0);\n            this.panel2.TabIndex = 1;
        private System.Windows.Forms.Label label5;\n        private System.Windows.Forms.ComboBox comboBox1;\n        private System.Windows.Forms.Panel panel2;\n        private System.Windows.Forms.Button button1;\n        private System.Windows.Forms.Button button2;\n        private System.Windows.Forms.Panel panel1;\n        private System.Windows.Forms.ContextMenu contextMenu1;\n        private System.Windows.Forms.MenuItem enableItem;\n        private System.Windows.Forms.MenuItem aboutItem;\n        private System.Windows.Forms.MenuItem menuItem3;
    }\n}
            this.tableLayoutPanel1.SuspendLayout();\n            this.panel1.SuspendLayout();\n            this.SuspendLayout();\n            // \n            // tableLayoutPanel1\n            // \n            this.tableLayoutPanel1.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) \n            | System.Windows.Forms.AnchorStyles.Right)));\n            this.tableLayoutPanel1.AutoSize = true;\n            this.tableLayoutPanel1.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;\n            this.tableLayoutPanel1.ColumnCount = 2;\n            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());\n            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());
            this.tableLayoutPanel1.Name = "tableLayoutPanel1";\n            this.tableLayoutPanel1.Padding = new System.Windows.Forms.Padding(5);\n            this.tableLayoutPanel1.RowCount = 5;\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());

        private void UpdateOnlinePACURLItem_Click(object sender, EventArgs e)\n        {\n            string origPacUrl = controller.GetConfiguration().pacUrl;\n            string pacUrl = Microsoft.VisualBasic.Interaction.InputBox(\n                I18N.GetString("Please input PAC Url"),\n                I18N.GetString("Update Online PAC URL"),\n                origPacUrl, -1, -1);\n            if (!string.IsNullOrEmpty(pacUrl) && pacUrl != origPacUrl)\n            {\n                controller.SavePACUrl(pacUrl);
        }\n    }\n}
            }\n            catch (Exception ex)\n            {\n                Error?.Invoke(this, new ErrorEventArgs(ex));\n            }\n        }
            }\n        }\n        public void UpdatePACFromGFWList(Configuration config)\n        {\n            WebClient http = new WebClient();\n            http.Proxy = new WebProxy(IPAddress.Loopback.ToString(), config.localPort);\n            http.DownloadStringCompleted += http_DownloadStringCompleted;\n            http.DownloadStringAsync(new Uri(GFWLIST_URL));\n        }\n        public static List<string> ParseResult(string response)
using System.Collections.Generic;\nusing System.Globalization;\nusing System.IO;\nnamespace Shadowsocks.Controller\n{\n    using Shadowsocks.Properties;\n    public class I18N\n    {\n        protected static Dictionary<string, string> Strings;\n        static I18N()
namespace Shadowsocks.Controller\n{\n    using Shadowsocks.Properties;\n    public class I18N\n    {\n        protected static Dictionary<string, string> Strings;\n        static I18N()\n        {\n            Strings = new Dictionary<string, string>();\n            if (CultureInfo.CurrentCulture.IetfLanguageTag.StartsWith("zh", StringComparison.OrdinalIgnoreCase))
            {\n                using (var sr = new StringReader(Resources.cn))\n                {\n                    string line;\n                    while ((line = sr.ReadLine()) != null)\n                    {\n                        if (line[0] == '#')
                {\n                    string line;\n                    while ((line = sr.ReadLine()) != null)\n                    {\n                        if (line[0] == '#')\n                            continue;\n                        var pos = line.IndexOf('=');\n                        if (pos < 1)\n                            continue;
                    {\n                        if (line[0] == '#')\n                            continue;\n                        var pos = line.IndexOf('=');\n                        if (pos < 1)\n                            continue;\n                        Strings[line.Substring(0, pos)] = line.Substring(pos + 1);\n                    }\n                }\n            }
                    }\n                }\n            }\n        }\n        public static string GetString(string key)\n        {\n            if (Strings.ContainsKey(key))\n            {\n                return Strings[key];\n            }
                        return true;\n                    else if (item.Equals("Shadowsocks", StringComparison.OrdinalIgnoreCase)) // Compatibility with older versions\n                    {\n                        string value = Convert.ToString(runKey.GetValue(item));\n                        if (path.Equals(value, StringComparison.OrdinalIgnoreCase))\n                        {\n                            runKey.DeleteValue(item);\n                            runKey.SetValue(Key, path);\n                            return true;\n                        }
                    {\n                        string value = Convert.ToString(runKey.GetValue(item));\n                        if (path.Equals(value, StringComparison.OrdinalIgnoreCase))\n                        {\n                            runKey.DeleteValue(item);\n                            runKey.SetValue(Key, path);\n                            return true;\n                        }\n                    }\n                }
                        {\n                            runKey.DeleteValue(item);\n                            runKey.SetValue(Key, path);\n                            return true;\n                        }\n                    }\n                }\n                return false;\n            }\n            catch (Exception e)
            try\n            {\n                int bytesRead = conn.EndReceive(ar);\n                string pac = GetPACContent();\n                IPEndPoint localEndPoint = (IPEndPoint)conn.LocalEndPoint;\n                string proxy = GetPACAddress(requestBuf, localEndPoint);\n                pac = pac.Replace("__PROXY__", proxy);\n                if (bytesRead > 0)\n                {\n                    string text = String.Format(@"HTTP/1.1 200 OK
                pac = pac.Replace("__PROXY__", proxy);\n                if (bytesRead > 0)\n                {\n                    string text = String.Format(@"HTTP/1.1 200 OK\nServer: Shadowsocks\nContent-Type: application/x-ns-proxy-autoconfig\nContent-Length: {0}\nConnection: Close\n", System.Text.Encoding.UTF8.GetBytes(pac).Length) + pac;\n                    byte[] response = System.Text.Encoding.UTF8.GetBytes(text);
                    method = EncryptionSelect.Text,\n                    remarks = RemarksTextBox.Text\n                };\n                int localPort = int.Parse(ProxyPortTextBox.Text);\n                Configuration.CheckServer(server);\n                Configuration.CheckPort(localPort);\n                _modifiedConfiguration.configs[_oldSelectedIndex] = server;\n                _modifiedConfiguration.localPort = localPort;\n                return true;\n            }
        private bool _shareOverLAN;\n        //private Encryptor encryptor;\n        Socket _listener;\n        public Local(Configuration config)\n        {\n            this._config = config;\n            _shareOverLAN = config.shareOverLan;\n            //this.encryptor = new Encryptor(config.method, config.password);\n        }\n        public void Start()\n        {
            _shareOverLAN = config.shareOverLan;\n            //this.encryptor = new Encryptor(config.method, config.password);\n        }\n        public void Start()\n        {\n            try\n            {\n                // Create a TCP/IP socket.\n                _listener = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);\n                _listener.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, true);
                }\n                else\n                {\n                    localEndPoint = new IPEndPoint(IPAddress.Loopback, _config.localPort);\n                }\n                // Bind the socket to the local endpoint and listen for incoming connections.\n                _listener.Bind(localEndPoint);\n                _listener.Listen(100);\n                // Start an asynchronous socket to listen for connections.\n                Console.WriteLine("Shadowsocks started");
                }\n                // Bind the socket to the local endpoint and listen for incoming connections.\n                _listener.Bind(localEndPoint);\n                _listener.Listen(100);\n                // Start an asynchronous socket to listen for connections.\n                Console.WriteLine("Shadowsocks started");\n                _listener.BeginAccept(\n                    new AsyncCallback(AcceptCallback),\n                    _listener);\n            }
                if (!parsed)\n                {\n                    IPHostEntry ipHostInfo = Dns.GetHostEntry(server.server);\n                    ipAddress = ipHostInfo.AddressList[0];\n                }\n                IPEndPoint remoteEP = new IPEndPoint(ipAddress, server.server_port);\n                remote = new Socket(ipAddress.AddressFamily,\n                    SocketType.Stream, ProtocolType.Tcp);\n                remote.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n                // Connect to the remote endpoint.
                    ipAddress = ipHostInfo.AddressList[0];\n                }\n                IPEndPoint remoteEP = new IPEndPoint(ipAddress, server.server_port);\n                remote = new Socket(ipAddress.AddressFamily,\n                    SocketType.Stream, ProtocolType.Tcp);\n                remote.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n                // Connect to the remote endpoint.\n                remote.BeginConnect(remoteEP,\n                    new AsyncCallback(ConnectCallback), null);\n            }
                remote = new Socket(ipAddress.AddressFamily,\n                    SocketType.Stream, ProtocolType.Tcp);\n                remote.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n                // Connect to the remote endpoint.\n                remote.BeginConnect(remoteEP,\n                    new AsyncCallback(ConnectCallback), null);\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);
using System.Collections.Generic;\nusing System.Globalization;\nusing System.IO;\nusing System.Linq;\nusing System.Net;\nusing System.Net.NetworkInformation;\nusing System.Net.Sockets;\nusing System.Threading;\nusing System.Threading.Tasks;
using System.Net.NetworkInformation;\nusing System.Net.Sockets;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Shadowsocks.Model;\nusing Shadowsocks.Util;\nnamespace Shadowsocks.Controller\n{
using Shadowsocks.Model;\nusing Shadowsocks.Util;\nnamespace Shadowsocks.Controller\n{\n    using DataUnit = KeyValuePair<string, string>;\n    using DataList = List<KeyValuePair<string, string>>;\n    using Statistics = Dictionary<string, List<AvailabilityStatistics.RawStatisticsData>>;\n    public sealed class AvailabilityStatistics\n    {
    {\n        // Static Singleton Initialization\n        public static AvailabilityStatistics Instance { get; } = new AvailabilityStatistics();\n        private AvailabilityStatistics() { }\n        public const string DateTimePattern = "yyyy-MM-dd HH:mm:ss";\n        private const string StatisticsFilesName = "shadowsocks.availability.csv";\n        private const string Delimiter = ",";\n        private const int TimeoutMilliseconds = 500;\n        private readonly TimeSpan _delayBeforeStart = TimeSpan.FromSeconds(1);\n        public Statistics RawStatistics { get; private set; }\n        public Statistics FilteredStatistics { get; private set; }
        public Statistics RawStatistics { get; private set; }\n        public Statistics FilteredStatistics { get; private set; }\n        public static readonly DateTime UnknownDateTime = new DateTime(1970, 1, 1);\n        private int Repeat => _config.RepeatTimesNum;
        private long _lastInboundCounter = 0;\n        private long _lastOutboundCounter = 0;
        public bool Set(StatisticsStrategyConfiguration config)\n        {\n            _config = config;\n            try\n            {\n                if (config.StatisticsEnabled)\n                {
        }\n        private string GetRecentInboundSpeed(Server server)\n        {\n            return server != _currentServer ? Empty : _inboundSpeed.ToString();\n        }\n        private string GetRecentLatency(Server server)\n        {\n            if (server != _currentServer) return Empty;
        }\n        private string GetRecentLatency(Server server)\n        {\n            if (server != _currentServer) return Empty;\n            return _latency == null ? Empty : _latency.ToString();\n        }\n        private void ResetSpeed()\n        {\n            _currentServer = _controller.GetCurrentServer();\n            _latency = null;
            _latency = null;\n            _inboundSpeed = 0;\n            _outboundSpeed = 0;\n        }\n        private void Run(object obj)\n        {
            ResetSpeed();\n            Set(controller.StatisticsConfiguration);\n            _servers = _controller.GetCurrentConfiguration().configs;\n        }\n        private void FilterRawStatistics()\n        {\n            if (RawStatistics == null) return;\n            if (FilteredStatistics == null)\n            {\n                FilteredStatistics = new Statistics();
        {\n            if (RawStatistics == null) return;\n            if (FilteredStatistics == null)\n            {\n                FilteredStatistics = new Statistics();\n            }\n            foreach (IEnumerable<RawStatisticsData> rawData in RawStatistics.Values)\n            {\n                var filteredData = rawData;\n                if (_config.ByHourOfDay)
            }\n        }\n        public void UpdateInboundCounter(Server server, long n)\n        {\n            Interlocked.Add(ref inboundCounter, n);\n            if (_config.availabilityStatistics)\n            {\n                availabilityStatistics.UpdateInboundCounter(server, n);\n            }\n        }
            }\n        }\n        public void UpdateOutboundCounter(Server server, long n)\n        {\n            Interlocked.Add(ref outboundCounter, n);\n            if (_config.availabilityStatistics)\n            {\n                availabilityStatistics.UpdateOutboundCounter(server, n);\n            }\n        }
            }\n        }\n        protected void Reload()\n        {\n            // some logic in configuration updated the config when saving, we need to read it again\n            _config = Configuration.Load();\n            StatisticsConfiguration = StatisticsStrategyConfiguration.Load();\n            if (polipoRunner == null)\n            {\n                polipoRunner = new PolipoRunner();
                _process = null;\n            }\n            RefreshTrayArea();\n        }\n        private static void KillProcess(Process p)\n        {\n            try\n            {\n                p.CloseMainWindow();\n                p.WaitForExit(100);
                var lastOutbound = _lastOutboundCounter[id];\n                var outbound = _outboundCounter[id];\n                bytes = outbound - lastOutbound;\n                _lastOutboundCounter[id] = outbound;\n                var outboundSpeed = GetSpeedInKiBPerSecond(bytes, _monitorInterval.TotalSeconds);\n                _outboundSpeedRecords.GetOrAdd(id, (k) =>\n                {\n                    List<int> records = new List<int>();\n                    records.Add(outboundSpeed);\n                    return records;
                Logging.Debug(\n                    $"{id}: current/max inbound {inboundSpeed}/{_inboundSpeedRecords[id].Max()} KiB/s, current/max outbound {outboundSpeed}/{_outboundSpeedRecords[id].Max()} KiB/s");\n            }
        }\n        private void Reset()\n        {\n            _inboundSpeedRecords.Clear();\n            _outboundSpeedRecords.Clear();\n            _latencyRecords.Clear();\n        }\n        private void Run(object _)\n        {\n            UpdateRecords();
            Reset();\n        }\n        private void UpdateRecords()\n        {\n            var records = new Dictionary<string, StatisticsRecord>();\n            UpdateRecordsState state = new UpdateRecordsState();\n            state.counter = _controller.GetCurrentConfiguration().configs.Count;\n            foreach (var server in _controller.GetCurrentConfiguration().configs)\n            {
        {\n            var records = new Dictionary<string, StatisticsRecord>();\n            UpdateRecordsState state = new UpdateRecordsState();\n            state.counter = _controller.GetCurrentConfiguration().configs.Count;\n            foreach (var server in _controller.GetCurrentConfiguration().configs)\n            {\n                var id = server.Identifier();\n                List<int> inboundSpeedRecords = null;\n                List<int> outboundSpeedRecords = null;\n                List<int> latencyRecords = null;
            }\n        }\n        private void AppendRecord(string serverIdentifier, StatisticsRecord record)\n        {\n            try\n            {\n                List<StatisticsRecord> records;\n                lock (RawStatistics)\n                {\n                    if (!RawStatistics.TryGetValue(serverIdentifier, out records))
        }\n        private void Save()\n        {\n            Logging.Debug($"save statistics to {AvailabilityStatisticsFile}");\n            if (RawStatistics.Count == 0)\n            {\n                return;\n            }\n            try\n            {
                File.WriteAllText(AvailabilityStatisticsFile, content);\n            }\n            catch (IOException e)\n            {\n                Logging.LogUsefulException(e);\n            }\n        }\n        private bool IsValidRecord(StatisticsRecord record)\n        {\n            if (Config.ByHourOfDay)
        }\n        public void Dispose()\n        {\n            _recorder.Dispose();\n            _speedMonior.Dispose();\n        }\n        public void UpdateLatency(Server server, int latency)\n        {\n            _latencyRecords.GetOrAdd(server.Identifier(), (k) =>\n            {
        }\n        public void UpdateInboundCounter(Server server, long n)\n        {\n            _inboundCounter.AddOrUpdate(server.Identifier(), (k) =>\n            {\n                _lastInboundCounter.GetOrAdd(server.Identifier(), 0);\n                return n;\n            }, (k, v) => (v + n));
        }\n        public void UpdateOutboundCounter(Server server, long n)\n        {\n            _outboundCounter.AddOrUpdate(server.Identifier(), (k) =>\n            {\n                _lastOutboundCounter.GetOrAdd(server.Identifier(), 0);\n                return n;\n            }, (k, v) => (v + n));\n        }\n        class UpdateRecordsState
        }\n    }\n}
                // truncate privoxy log file while debugging\n                string privoxyLogFilename = Utils.GetTempPath("privoxy.log");\n                if (File.Exists(privoxyLogFilename))\n                    using (new FileStream(privoxyLogFilename, FileMode.Truncate)) { }\n#endif\n                MainController = new ShadowsocksController();\n                MenuController = new MenuViewController(MainController);\n                MainController.ProgramUpdated += (o, e) =>\n                {\n                    Logging.Info($"Updated from {e.OldVersion} to {e.NewVersion}");\n                };
#endif\n                MainController = new ShadowsocksController();\n                MenuController = new MenuViewController(MainController);\n                MainController.ProgramUpdated += (o, e) =>\n                {\n                    Logging.Info($"Updated from {e.OldVersion} to {e.NewVersion}");\n                };\n                HotKeys.Init(MainController);\n                MainController.Start();\n                Application.Run();\n            }
                _systemProxyIsDirty = true;\n            }\n            else\n            {\n                // only switch it off if we have switched it on\n                if (_systemProxyIsDirty)\n                {\n                    SystemProxy.Update(_config, false, _pacServer);\n                    _systemProxyIsDirty = false;\n                }\n            }
                    _systemProxyIsDirty = false;\n                }\n            }\n        }\n        private void pacServer_PACFileChanged(object sender, EventArgs e)\n        {\n            UpdateSystemProxy();\n        }\n        private void pacServer_PACUpdateCompleted(object sender, GFWListUpdater.ResultEventArgs e)\n        {
    {\n        public const string PAC_FILE = "pac.txt";\n        public const string USER_RULE_FILE = "user-rule.txt";\n        public const string USER_ABP_FILE = "abp.txt";\n        public string PacSecret { get; private set; } = "";\n        FileSystemWatcher PACFileWatcher;\n        FileSystemWatcher UserRuleFileWatcher;\n        private Configuration _config;\n        public event EventHandler PACFileChanged;\n        public event EventHandler UserRuleFileChanged;
                object[] state = new object[] {\n                    conn,\n                    requestBuf\n                };\n                conn.BeginReceive(requestBuf, 0, requestBuf.Length, 0,\n                    new AsyncCallback(ReceiveCallback), state);\n            }\n            catch (ObjectDisposedException)\n            {\n            }
                };\n                conn.BeginReceive(requestBuf, 0, requestBuf.Length, 0,\n                    new AsyncCallback(ReceiveCallback), state);\n            }\n            catch (ObjectDisposedException)\n            {\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine(e);
                    new AsyncCallback(ReceiveCallback), state);\n            }\n            catch (ObjectDisposedException)\n            {\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine(e);\n            }\n            finally
                int n;\n                using (GZipStream input = new GZipStream(new MemoryStream(pacGZ),\n                    CompressionMode.Decompress, false))\n                {\n                    while((n = input.Read(buffer, 0, buffer.Length)) > 0)\n                    {\n                        sb.Write(buffer, 0, n);\n                    }
                    {\n                        sb.Write(buffer, 0, n);\n                    }\n                    return System.Text.Encoding.UTF8.GetString(sb.ToArray());\n                }\n            }\n        }\n        private void ReceiveCallback(IAsyncResult ar)\n        {\n            object[] state = (object[])ar.AsyncState;
                    }\n                    return System.Text.Encoding.UTF8.GetString(sb.ToArray());\n                }\n            }\n        }\n        private void ReceiveCallback(IAsyncResult ar)\n        {\n            object[] state = (object[])ar.AsyncState;\n            Socket conn = (Socket)state[0];\n            byte[] requestBuf = (byte[])state[1];
                }\n            }\n        }\n        private void ReceiveCallback(IAsyncResult ar)\n        {\n            object[] state = (object[])ar.AsyncState;\n            Socket conn = (Socket)state[0];\n            byte[] requestBuf = (byte[])state[1];\n            try\n            {
        {\n            DestEndPoint = destEndPoint;\n            String authInfo = "";\n            if (auth != null)\n            {\n                string authKey = Convert.ToBase64String(Encoding.UTF8.GetBytes(auth.UserName + ":" + auth.Password));\n                authInfo = string.Format(PROXY_AUTH_TEMPLATE, authKey);\n            }\n            string request = string.Format(HTTP_CONNECT_TEMPLATE, destEndPoint, authInfo);
            var b = Encoding.UTF8.GetBytes(request);\n            var st = new HttpState();\n            st.Callback = callback;\n            st.AsyncState = state;\n            _remote.BeginSend(b, 0, b.Length, 0, HttpRequestSendCallback, st);\n        }\n        public void EndConnectDest(IAsyncResult asyncResult)\n        {\n            var state = ((FakeAsyncResult)asyncResult).innerState;\n            if (state.ex != null)
            }\n            catch (ArgumentException)\n            {\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }
            }\n        }\n        private void ProxyTypeComboBox_SelectedIndexChanged(object sender, EventArgs e)\n        {\n            // TODO support for SOCK5 auth\n            if (ProxyTypeComboBox.SelectedIndex != ProxyConfig.PROXY_HTTP)\n            {\n                UseAuthCheckBox.Checked = false;\n                AuthUserTextBox.Clear();\n                AuthPwdTextBox.Clear();
                _modifiedConfiguration = new ProxyConfig();\n                controller.SaveProxyConfig(_modifiedConfiguration);\n            }\n            UseProxyCheckBox.Checked = _modifiedConfiguration.useProxy;\n            ProxyServerTextBox.Text = _modifiedConfiguration.proxyServer;\n            ProxyPortTextBox.Text = _modifiedConfiguration.proxyPort.ToString();\n        }\n        private void OKButton_Click(object sender, EventArgs e)\n        {\n            if (UseProxyCheckBox.Checked)
        }\n        private void UseProxyCheckBox_CheckedChanged(object sender, EventArgs e)\n        {\n            UpdateEnabled();\n        }\n        private void UpdateEnabled()\n        {\n            if (UseProxyCheckBox.Checked)\n            {\n                ProxyServerTextBox.Enabled = true;
            byte[] input, int ioff, uint ilen,\n            byte[] output);\n    }\n}
                _disposed = true;\n            }\n            if (disposing)\n            {\n                // free managed objects\n            }\n            // free unmanaged objects\n            if (_encryptCtx != IntPtr.Zero)\n            {\n                MbedTLS.cipher_free(_encryptCtx);
            }\n        }\n        #endregion\n    }\n}
            if (disposing) { }\n            Close();\n        }\n        private void Close()\n        {\n            if (handle != IntPtr.Zero)\n            {\n                CloseHandle(handle);\n                handle = IntPtr.Zero;
        }\n        private void Close()\n        {\n            if (handle != IntPtr.Zero)\n            {\n                CloseHandle(handle);\n                handle = IntPtr.Zero;\n            }\n        }\n        ~Job()
        {\n            if (handle != IntPtr.Zero)\n            {\n                CloseHandle(handle);\n                handle = IntPtr.Zero;\n            }\n        }\n        ~Job()\n        {\n            Dispose(false);
        }\n        public bool AddProcess(IntPtr processHandle)\n        {\n            var succ = AssignProcessToJobObject(handle, processHandle);\n            if (!succ)\n            {\n                Logging.Error("Failed to call AssignProcessToJobObject! GetLastError=" + Marshal.GetLastWin32Error());\n            }\n            return succ;\n        }
            {\n                AverageInboundSpeed = (int) inbound.Average();\n                MinInboundSpeed = inbound.Min();\n                MaxInboundSpeed = inbound.Max();\n            }\n            var outbound = outboundSpeedRecords?.Where(s => s > 0).ToList();\n            if (outbound!= null && outbound.Any())\n            {\n                AverageOutboundSpeed = (int) outbound.Average();
            }\n            var outbound = outboundSpeedRecords?.Where(s => s > 0).ToList();\n            if (outbound!= null && outbound.Any())\n            {\n                AverageOutboundSpeed = (int) outbound.Average();\n                MinOutboundSpeed = outbound.Min();\n                MaxOutboundSpeed = outbound.Max();\n            }\n            var latency = latencyRecords?.Where(s => s > 0).ToList();
            {\n                AverageOutboundSpeed = (int) outbound.Average();\n                MinOutboundSpeed = outbound.Min();\n                MaxOutboundSpeed = outbound.Max();\n            }\n            var latency = latencyRecords?.Where(s => s > 0).ToList();\n            if (latency!= null && latency.Any())\n            {\n                AverageLatency = (int) latency.Average();
            }\n            var latency = latencyRecords?.Where(s => s > 0).ToList();\n            if (latency!= null && latency.Any())\n            {\n                AverageLatency = (int) latency.Average();\n                MinLatency = latency.Min();\n                MaxLatency = latency.Max();\n            }\n        }
            {\n                AverageLatency = (int) latency.Average();\n                MinLatency = latency.Min();\n                MaxLatency = latency.Max();\n            }\n        }\n        public StatisticsRecord(string identifier, ICollection<int?> responseRecords)\n        {\n            ServerIdentifier = identifier;\n            SetResponse(responseRecords);
            }\n        }\n        public StatisticsRecord(string identifier, ICollection<int?> responseRecords)\n        {\n            ServerIdentifier = identifier;\n            SetResponse(responseRecords);\n        }\n        public void SetResponse(ICollection<int?> responseRecords)\n        {\n            if (responseRecords == null) return;
                            };\n            foreach (var data in finalData.Where(data => data.Speed != 0 || data.PackageLossPercentage != 0 || data.Ping != 0))\n            {\n                _dataTable.Rows.Add(data.Timestamp, data.Speed, data.PackageLossPercentage, data.Ping);\n            }\n            StatisticsChart.DataBind();\n        }\n        private void serverSelector_SelectionChangeCommitted(object sender, EventArgs e)\n        {\n            LoadChartData();
            {\n                _dataTable.Rows.Add(data.Timestamp, data.Speed, data.PackageLossPercentage, data.Ping);\n            }\n            StatisticsChart.DataBind();\n        }\n        private void serverSelector_SelectionChangeCommitted(object sender, EventArgs e)\n        {\n            LoadChartData();\n        }\n        private void dayMode_CheckedChanged(object sender, EventArgs e)
using System.Net.NetworkInformation;\nusing System.Threading;\nusing Newtonsoft.Json;\nusing Shadowsocks.Model;\nnamespace Shadowsocks.Controller.Strategy\n{\n    class StatisticsStrategy : IStrategy
using Newtonsoft.Json;\nusing Shadowsocks.Model;\nnamespace Shadowsocks.Controller.Strategy\n{\n    class StatisticsStrategy : IStrategy\n    {\n        private readonly ShadowsocksController _controller;
namespace Shadowsocks.Controller.Strategy\n{\n    class StatisticsStrategy : IStrategy\n    {\n        private readonly ShadowsocksController _controller;\n        private Server _currentServer;\n        private readonly Timer _timer;\n        private Dictionary<string, List<AvailabilityStatistics.RawStatisticsData>> _filteredStatistics;
    class StatisticsStrategy : IStrategy\n    {\n        private readonly ShadowsocksController _controller;\n        private Server _currentServer;\n        private readonly Timer _timer;\n        private Dictionary<string, List<AvailabilityStatistics.RawStatisticsData>> _filteredStatistics;\n        private int ChoiceKeptMilliseconds\n            => (int) TimeSpan.FromMinutes(_controller.StatisticsConfiguration.ChoiceKeptMinutes).TotalMilliseconds;\n        public StatisticsStrategy(ShadowsocksController controller)
        private int ChoiceKeptMilliseconds\n            => (int) TimeSpan.FromMinutes(_controller.StatisticsConfiguration.ChoiceKeptMinutes).TotalMilliseconds;\n        public StatisticsStrategy(ShadowsocksController controller)\n        {\n            _controller = controller;\n            var servers = controller.GetCurrentConfiguration().configs;\n            var randomIndex = new Random().Next() % servers.Count();\n            _currentServer = servers[randomIndex];  //choose a server randomly at first\n            _timer = new Timer(ReloadStatisticsAndChooseAServer);
        public StatisticsStrategy(ShadowsocksController controller)\n        {\n            _controller = controller;\n            var servers = controller.GetCurrentConfiguration().configs;\n            var randomIndex = new Random().Next() % servers.Count();\n            _currentServer = servers[randomIndex];  //choose a server randomly at first\n            _timer = new Timer(ReloadStatisticsAndChooseAServer);\n        }\n        private void ReloadStatisticsAndChooseAServer(object obj)\n        {
        }\n        //return the score by data\n        //server with highest score will be choosen\n        private float GetScore(string serverName)\n        {\n            var config = _controller.StatisticsConfiguration;\n            List<AvailabilityStatistics.RawStatisticsData> dataList;\n            if (_filteredStatistics == null || !_filteredStatistics.TryGetValue(serverName, out dataList)) return 0;
        {\n            var config = _controller.StatisticsConfiguration;\n            List<AvailabilityStatistics.RawStatisticsData> dataList;\n            if (_filteredStatistics == null || !_filteredStatistics.TryGetValue(serverName, out dataList)) return 0;
            var SuccessTimes = (float) dataList.Count(data => data.ICMPStatus.Equals(IPStatus.Success.ToString()));\n            var TimedOutTimes = (float) dataList.Count(data => data.ICMPStatus.Equals(IPStatus.TimedOut.ToString()));\n            var statisticsData = new AvailabilityStatistics.StatisticsData()\n            {
            {
        private void ChooseNewServer(List<Server> servers)\n        {\n            if (_filteredStatistics == null || servers.Count == 0)\n            {\n                return;\n            }\n            try\n            {\n                var bestResult = (from server in servers\n                                  let name = server.FriendlyName()
            {\n                return;\n            }\n            try\n            {\n                var bestResult = (from server in servers\n                                  let name = server.FriendlyName()\n                                  where _filteredStatistics.ContainsKey(name)\n                                  select new\n                                  {
                                  select new\n                                  {\n                                      server,\n                                      score = GetScore(name)\n                                  }\n                                  ).Aggregate((result1, result2) => result1.score > result2.score ? result1 : result2);\n                if (!_currentServer.Equals(bestResult.server)) //output when enabled\n                {\n                   LogWhenEnabled($"Switch to server: {bestResult.server.FriendlyName()} by statistics: score {bestResult.score}");\n                }
                                  }\n                                  ).Aggregate((result1, result2) => result1.score > result2.score ? result1 : result2);\n                if (!_currentServer.Equals(bestResult.server)) //output when enabled\n                {\n                   LogWhenEnabled($"Switch to server: {bestResult.server.FriendlyName()} by statistics: score {bestResult.score}");\n                }\n                _currentServer = bestResult.server;\n            }\n            catch (Exception e)\n            {
using System.Net.Http;\nusing System.Net.NetworkInformation;\nusing System.Net.Sockets;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Shadowsocks.Model;\nusing Shadowsocks.Util;\nnamespace Shadowsocks.Controller
using Shadowsocks.Model;\nusing Shadowsocks.Util;\nnamespace Shadowsocks.Controller\n{\n    using DataUnit = KeyValuePair<string, string>;\n    using DataList = List<KeyValuePair<string, string>>;\n    using RawStatistics = Dictionary<string, List<AvailabilityStatistics.RawStatisticsData>>;\n    using Statistics = Dictionary<string, List<AvailabilityStatistics.StatisticsData>>;\n    public class AvailabilityStatistics
namespace Shadowsocks.Controller\n{\n    using DataUnit = KeyValuePair<string, string>;\n    using DataList = List<KeyValuePair<string, string>>;\n    using RawStatistics = Dictionary<string, List<AvailabilityStatistics.RawStatisticsData>>;\n    using Statistics = Dictionary<string, List<AvailabilityStatistics.StatisticsData>>;\n    public class AvailabilityStatistics\n    {\n        public static readonly string DateTimePattern = "yyyy-MM-dd HH:mm:ss";
    {\n        public static readonly string DateTimePattern = "yyyy-MM-dd HH:mm:ss";\n        private const string StatisticsFilesName = "shadowsocks.availability.csv";\n        private const string Delimiter = ",";\n        private const int Timeout = 500;\n        private const int DelayBeforeStart = 1000;\n        public RawStatistics rawStatistics { get; private set; }\n        public RawStatistics filteredStatistics { get; private set; }\n        private int _repeat => _config.RepeatTimesNum;\n        private const int RetryInterval = 2*60*1000; //retry 2 minutes after failed
            ((System.ComponentModel.ISupportInitialize)(this.StatisticsChart)).BeginInit();\n            ((System.ComponentModel.ISupportInitialize)(this.bindingConfiguration)).BeginInit();\n            this.chartModeSelector.SuspendLayout();\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer1)).BeginInit();\n            this.splitContainer1.Panel1.SuspendLayout();\n            this.splitContainer1.Panel2.SuspendLayout();\n            this.splitContainer1.SuspendLayout();\n            ((System.ComponentModel.ISupportInitialize)(this.splitContainer2)).BeginInit();\n            this.splitContainer2.Panel1.SuspendLayout();\n            this.splitContainer2.Panel2.SuspendLayout();
            {\n                _registeredEncryptors.Add(method, typeof(AEADMbedTLSEncryptor));\n            }\n            foreach (string method in AEADSodiumEncryptorSupportedCiphers)\n            {\n                _registeredEncryptors.Add(method, typeof(AEADSodiumEncryptor));\n            }\n        }\n        public static IEncryptor GetEncryptor(string method, string password)\n        {
            {\n                _registeredEncryptors.Add(method, typeof(AEADSodiumEncryptor));\n            }\n        }\n        public static IEncryptor GetEncryptor(string method, string password)\n        {\n            if (method.IsNullOrEmpty())\n            {\n                method = "aes-256-cfb";\n            }
                this.Close();\n            }\n        }\n        private void ConnectCallback(IAsyncResult ar)\n        {\n            Server server = null;\n            if (closed)\n            {\n                return;\n            }
                // Complete the connection.\n                remote.EndConnect(ar);\n                connected = true;\n                //Console.WriteLine("Socket connected to {0}",\n                //    remote.RemoteEndPoint.ToString());\n                var latency = DateTime.Now - _startConnectTime;\n                controller.GetCurrentStrategy().UpdateLatency(server, latency);\n                StartPipe();\n            }\n            catch (ArgumentException e)\n            {\n            }\n            catch (Exception e)
                StartPipe();\n            }\n            catch (ArgumentException e)\n            {\n            }\n            catch (Exception e)\n            {\n                if (server != null)\n                {\n                    controller.GetCurrentStrategy().SetFailure(server);
            }\n        }\n        private void StartPipe()\n        {\n            if (closed)\n            {\n                return;\n            }\n            try\n            {
                {\n                    if (!(each.Equals("DefaultConnectionSettings")\n                        || each.Equals("LAN Connection")\n                        || each.Equals("SavedLegacySettings")))\n                    {\n                        //set all the connections's proxy as the lan\n                        registry.SetValue(each, defaultValue);\n                    }\n                }\n                SystemProxy.NotifyIE();\n            } catch (IOException e) {
                }\n                SystemProxy.NotifyIE();\n            } catch (IOException e) {\n                Logging.LogUsefulException(e);\n            }\n        }\n        private static String GetTimestamp(DateTime value)\n        {\n            return value.ToString("yyyyMMddHHmmssffff");
        }\n        private static String GetTimestamp(DateTime value)\n        {\n            return value.ToString("yyyyMMddHHmmssffff");\n        }\n    }\n}
                {\n                    g.CopyFromScreen(Screen.PrimaryScreen.Bounds.X,\n                                     Screen.PrimaryScreen.Bounds.Y,\n                                     0, 0,\n                                     image.Size,\n                                     CopyPixelOperation.SourceCopy);\n                }\n                var reader = new BarcodeReader\n                {
                                     CopyPixelOperation.SourceCopy);\n                }\n                var reader = new BarcodeReader\n                {\n                    TryHarder = true,\n                    PossibleFormats = new List<BarcodeFormat>
                {\n                    TryHarder = true,\n                    PossibleFormats = new List<BarcodeFormat>\n                if (result != null)
                {\n                    Console.WriteLine(result.Text);\n                }\n            }\n        }\nprivate void AutoStartupItem_Click(object sender, EventArgs e) {\nAutoStartupItem.Checked = !AutoStartupItem.Checked;
                }\n            }\n        }\nprivate void AutoStartupItem_Click(object sender, EventArgs e) {\nAutoStartupItem.Checked = !AutoStartupItem.Checked;\nif (!AutoStartup.Set(AutoStartupItem.Checked)) {\nMessageBox.Show("Failed to edit registry");
        }\nprivate void AutoStartupItem_Click(object sender, EventArgs e) {\nAutoStartupItem.Checked = !AutoStartupItem.Checked;\nif (!AutoStartup.Set(AutoStartupItem.Checked)) {\nMessageBox.Show("Failed to edit registry");\n}\n}\n    }\n}
            {\n                Console.WriteLine(e);\n                return new Config\n                {\n                    server = "127.0.0.1",\n                    server_port = 8388,\n                    local_port = 1081,\n                    password = "barfoo!",\n                    isDefault = true
                };\n            }\n        }\n        public static void Save(Config config)\n        {\n            DataContractJsonSerializer ser = new DataContractJsonSerializer(typeof(Config));\n            try\n            {\n                using (FileStream fs = File.Open(@"config.json", FileMode.Create))\n                {
            InitializeComponent();\n            configToTextBox();\n        }\n        private void showWindow()\n        {\n            this.Opacity = 1;\n            this.Show();\n        }\n        private void configToTextBox()\n        {
        {\n            try\n            {\n                Config config = new Config\n                {\n                    server = textBox1.Text,\n                    server_port = int.Parse(textBox2.Text),\n                    password = textBox3.Text,\n                    local_port = int.Parse(textBox4.Text),\n                    isDefault = false
        }\n        private void cancelButton_Click(object sender, EventArgs e)\n        {\n            this.Hide();\n            configToTextBox();\n        }\n        private void Form1_FormClosed(object sender, FormClosedEventArgs e)\n        {\n            local.Stop();\n        }
        {\n            this.Hide();\n            configToTextBox();\n        }\n        private void Form1_FormClosed(object sender, FormClosedEventArgs e)\n        {\n            local.Stop();\n        }\n        private void aboutToolStripMenuItem_Click(object sender, EventArgs e)\n        {
            // \n            // button1\n            // \n            this.button1.DialogResult = System.Windows.Forms.DialogResult.OK;\n            this.button1.Location = new System.Drawing.Point(4, 4);\n            this.button1.Name = "button1";\n            this.button1.Size = new System.Drawing.Size(75, 23);\n            this.button1.TabIndex = 0;\n            this.button1.Text = "OK";\n            this.button1.UseVisualStyleBackColor = true;\n            this.button1.Click += new System.EventHandler(this.OKButton_Click);\n            // \n            // notifyIcon1
            // \n            // notifyIcon1\n            // \n            this.notifyIcon1.ContextMenuStrip = this.contextMenuStrip1;\n            this.notifyIcon1.Icon = ((System.Drawing.Icon)(resources.GetObject("notifyIcon1.Icon")));\n            this.notifyIcon1.DoubleClick += new System.EventHandler(this.notifyIcon1_DoubleClick);\n            // \n            // contextMenuStrip1\n            // \n            this.contextMenuStrip1.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {\n            this.ConfigItem,\n            this.aboutToolStripMenuItem,\n            this.toolStripSeparator2,\n            this.QuitItem});
            // \n            // ConfigItem\n            // \n            // aboutToolStripMenuItem\n            // \n            this.aboutToolStripMenuItem.Name = "aboutToolStripMenuItem";\n            this.aboutToolStripMenuItem.Size = new System.Drawing.Size(110, 22);\n            this.aboutToolStripMenuItem.Text = "About";\n            this.aboutToolStripMenuItem.Click += new System.EventHandler(this.aboutToolStripMenuItem_Click);\n            // QuitItem\n            // 
        }\n        public static string GetString(string key, params object[] args)\n        {\n            return string.Format(_strings.TryGetValue(key.Trim(), out var value) ? value : key, args);\n        }\n        public static void TranslateForm(Form c)\n        {\n            if (c == null) return;\n            c.Text = GetString(c.Text);\n            foreach (var item in ViewUtils.GetChildControls<Control>(c))
        // remote send buffer\n        private byte[] remoteSendBuffer = new byte[BufferSize];\n        // connection receive buffer\n        private byte[] connetionRecvBuffer = new byte[RecvSize];\n        // connection send buffer\n        private byte[] connetionSendBuffer = new byte[BufferSize];\n        // Received data string.\n        private bool connectionShutdown = false;\n        private bool remoteShutdown = false;\n        private bool closed = false;\n        public void Start()\n        {\n            try
        // connection receive buffer\n        private byte[] connetionRecvBuffer = new byte[RecvSize];\n        // connection send buffer\n        private byte[] connetionSendBuffer = new byte[BufferSize];\n        // Received data string.\n        private bool connectionShutdown = false;\n        private bool remoteShutdown = false;\n        private bool closed = false;\n        public void Start()\n        {\n            try\n            {
        // connection send buffer\n        private byte[] connetionSendBuffer = new byte[BufferSize];\n        // Received data string.\n        private bool connectionShutdown = false;\n        private bool remoteShutdown = false;\n        private bool closed = false;\n        public void Start()\n        {\n            try\n            {\n                // TODO async resolving
        // Received data string.\n        private bool connectionShutdown = false;\n        private bool remoteShutdown = false;\n        private bool closed = false;\n        public void Start()\n        {\n            try\n            {\n                // TODO async resolving\n                IPAddress ipAddress;
        private bool connectionShutdown = false;\n        private bool remoteShutdown = false;\n        private bool closed = false;\n        public void Start()\n        {\n            try\n            {\n                // TODO async resolving\n                IPAddress ipAddress;\n                bool parsed = IPAddress.TryParse(config.server, out ipAddress);
            this.tableLayoutPanel4.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel4.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel4.Size = new System.Drawing.Size(166, 64);\n            this.tableLayoutPanel4.TabIndex = 8;\n            // \n            // DuplicateButton\n            // \n            this.DuplicateButton.Dock = System.Windows.Forms.DockStyle.Left;\n            this.DuplicateButton.Location = new System.Drawing.Point(0, 38);\n            this.DuplicateButton.Margin = new System.Windows.Forms.Padding(0, 6, 3, 3);
            this.tableLayoutPanel4.TabIndex = 8;\n            // \n            // DuplicateButton\n            // \n            this.DuplicateButton.Dock = System.Windows.Forms.DockStyle.Left;\n            this.DuplicateButton.Location = new System.Drawing.Point(0, 38);\n            this.DuplicateButton.Margin = new System.Windows.Forms.Padding(0, 6, 3, 3);\n            this.DuplicateButton.Name = "DuplicateButton";\n            this.DuplicateButton.Size = new System.Drawing.Size(80, 23);\n            this.DuplicateButton.TabIndex = 10;
        }\n        public void UpdateOutboundCounter(long n)\n        {\n            Interlocked.Add(ref outboundCounter, n);\n        }\n        protected void Reload()\n        {\n            // some logic in configuration updated the config when saving, we need to read it again\n            _config = Configuration.Load();
        }\n        protected void Reload()\n        {\n            // some logic in configuration updated the config when saving, we need to read it again\n            _config = Configuration.Load();\n            StatisticsConfiguration = StatisticsStrategyConfiguration.Load();\n            if (polipoRunner == null)\n            {\n                polipoRunner = new PolipoRunner();
            StatisticsConfiguration = StatisticsStrategyConfiguration.Load();\n            if (polipoRunner == null)\n            {\n                polipoRunner = new PolipoRunner();\n            }\n            if (_pacServer == null)\n            {\n                _pacServer = new PACServer();\n                _pacServer.PACFileChanged += pacServer_PACFileChanged;\n                _pacServer.UserRuleFileChanged += pacServer_UserRuleFileChanged;
            public UDPHandler(Socket local, Server server, IPEndPoint localEndPoint)\n            {\n                _local = local;\n                _server = server;\n                _localEndPoint = localEndPoint;\n                _remoteEndPoint = SocketUtil.GetEndPoint(server.server, server.server_port);\n                _remote = SocketUtil.CreateSocket(_remoteEndPoint, ProtocolType.Udp);
            }\n            public void Send(byte[] data, int length)\n            {\n                IEncryptor encryptor = EncryptorFactory.GetEncryptor(_server.method, _server.password, _server.auth, true);\n                byte[] dataIn = new byte[length - 3 + IVEncryptor.ONETIMEAUTH_BYTES];\n                Array.Copy(data, 3, dataIn, 0, length - 3);\n                byte[] dataOut = new byte[length - 3 + 16 + IVEncryptor.ONETIMEAUTH_BYTES];\n                int outlen;\n                encryptor.Encrypt(dataIn, length - 3, dataOut, out outlen);\n                Logging.Debug(_localEndPoint, _remoteEndPoint, outlen, "UDP Relay");
            if (_remote == null)\n            {\n                _remote = SocketUtil.CreateSocket(destEndPoint);\n                _remote.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n            }\n            _remote.BeginConnect(destEndPoint, callback, state);\n        }\n        public void EndConnectDest(IAsyncResult asyncResult)\n        {\n            _remote?.EndConnect(asyncResult);
                _remote.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n            }\n            _remote.BeginConnect(destEndPoint, callback, state);\n        }\n        public void EndConnectDest(IAsyncResult asyncResult)\n        {\n            _remote?.EndConnect(asyncResult);\n        }\n        public void BeginSend(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state)
        }\n        public void EndConnectDest(IAsyncResult asyncResult)\n        {\n            _remote?.EndConnect(asyncResult);\n        }\n        public void BeginSend(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state)\n        {\n            _remote?.BeginSend(buffer, offset, size, socketFlags, callback, state);\n        }
                if (_config.useProxy)\n                {
                    remote = new Socks5Proxy();\n                    proxyEP = SocketUtil.GetEndPoint(_config.proxyServer, _config.proxyPort);\n                }\n                else\n                {\n                    remote = new DirectConnect();\n                    proxyEP = null;\n                }\n                ProxyTimer proxyTimer = new ProxyTimer(3000);\n                proxyTimer.AutoReset = false;
                }\n                else\n                {\n                    remote = new DirectConnect();\n                    proxyEP = null;\n                }\n                ProxyTimer proxyTimer = new ProxyTimer(3000);\n                proxyTimer.AutoReset = false;\n                proxyTimer.Elapsed += proxyConnectTimer_Elapsed;\n                proxyTimer.Enabled = true;
            _notifyIcon.Visible = true;\n            _notifyIcon.ContextMenu = contextMenu1;\n            _notifyIcon.DoubleClick += notifyIcon1_DoubleClick;\n            this.updateChecker = new UpdateChecker();\n            updateChecker.NewVersionFound += updateChecker_NewVersionFound;\n            LoadCurrentConfiguration();\n            updateChecker.CheckUpdate();\n            if (controller.GetConfiguration().isDefault)\n            {
            _notifyIcon.ContextMenu = contextMenu1;\n            _notifyIcon.DoubleClick += notifyIcon1_DoubleClick;\n            this.updateChecker = new UpdateChecker();\n            updateChecker.NewVersionFound += updateChecker_NewVersionFound;\n            LoadCurrentConfiguration();\n            updateChecker.CheckUpdate();\n            if (controller.GetConfiguration().isDefault)\n            {\n                _isFirstRun = true;\n                ShowConfigForm();
        }\n        void controller_ShareOverLANStatusChanged(object sender, EventArgs e)\n        {\n            ShareOverLANItem.Checked = controller.GetConfiguration().shareOverLan;\n        }\n        void controller_EnableGlobalChanged(object sender, EventArgs e)\n        {\n            globalModeItem.Checked = controller.GetConfiguration().global;\n            PACModeItem.Checked = !globalModeItem.Checked;\n        }
            // \n            // EncryptionLabel\n            // \n            this.EncryptionLabel.Anchor = System.Windows.Forms.AnchorStyles.Right;\n            this.EncryptionLabel.AutoSize = true;\n            this.EncryptionLabel.Location = new System.Drawing.Point(12, 91);\n            this.EncryptionLabel.Name = "EncryptionLabel";\n            this.EncryptionLabel.Size = new System.Drawing.Size(65, 12);\n            this.EncryptionLabel.TabIndex = 8;\n            this.EncryptionLabel.Text = "Encryption";
        private bool _isFirstRun;\n        private bool _isStartupChecking;\n        private string _urlToOpen;\n        private ContextMenu contextMenu1;\n        private MenuItem disableItem;\n        private MenuItem AutoStartupItem;\n        private MenuItem ShareOverLANItem;\n        private MenuItem SeperatorItem;\n        private MenuItem ConfigItem;\n        private MenuItem ServersItem;
                _notifyIcon.Icon = newIcon;\n            }\n        }\n        void controller_Errored(object sender, System.IO.ErrorEventArgs e)\n        {\n            MessageBox.Show(e.GetException().ToString(), I18N.GetString("Shadowsocks Error: {0}", e.GetException().Message));\n        }\n        #region Tray Icon\n        private void UpdateTrayIconAndNotifyText()\n        {
            Configuration config = controller.GetConfigurationCopy();\n            bool enabled = config.enabled;\n            bool global = config.global;\n            Color colorMask = SelectColorMask(enabled, global);\n            Size iconSize = SelectIconSize();\n            UpdateIconSet(colorMask, iconSize, out icon, out icon_in, out icon_out, out icon_both);\n            previousIcon = icon;\n            _notifyIcon.Icon = previousIcon;
            string serverInfo = null;\n            if (controller.GetCurrentStrategy() != null)\n            {\n                serverInfo = controller.GetCurrentStrategy().Name;\n            }\n            else\n            {\n                serverInfo = config.GetCurrentServer().FriendlyName();\n            }\n            // show more info by hacking the P/Invoke declaration for NOTIFYICONDATA inside Windows Forms
                    {\n                        colorMask = colorMaskEclipse;\n                    }\n                }
                    }\n                }\n            }\n            else  // disabled\n            {\n                if (currentWindowsThemeMode == Utils.WindowsThemeMode.Light)\n                {\n                    colorMask = colorMaskDarkSilver;\n                }\n                else
        }\n        #endregion\n        #region MenuItems and MenuGroups\n        private MenuItem CreateMenuItem(string text, EventHandler click)\n        {\n            return new MenuItem(I18N.GetString(text), click);\n        }\n        private MenuItem CreateMenuGroup(string text, MenuItem[] items)\n        {\n            return new MenuItem(I18N.GetString(text), items);
            try\n            {\n                RegistryKey reg_ThemesPersonalize = Registry.CurrentUser.OpenSubKey(@"Software\Microsoft\Windows\CurrentVersion\Themes\Personalize", false);\n                if (reg_ThemesPersonalize.GetValue("SystemUsesLightTheme") != null)\n                {\n                    if ((int)(reg_ThemesPersonalize.GetValue("SystemUsesLightTheme")) == 0) // 0:dark mode, 1:light mode\n                        themeMode = WindowsThemeMode.Dark;\n                    else
                if (reg_ThemesPersonalize.GetValue("SystemUsesLightTheme") != null)\n                {\n                    if ((int)(reg_ThemesPersonalize.GetValue("SystemUsesLightTheme")) == 0) // 0:dark mode, 1:light mode\n                        themeMode = WindowsThemeMode.Dark;\n                    else\n                        themeMode = WindowsThemeMode.Light;\n                }\n                else\n                {
                    else\n                        themeMode = WindowsThemeMode.Light;\n                }\n                else\n                {\n                    throw new Exception("Reg-Value SystemUsesLightTheme not found.");\n                }\n            }\n            catch
                }\n                else\n                {\n                    throw new Exception("Reg-Value SystemUsesLightTheme not found.");\n                }\n            }\n            catch\n            {\n                Logging.Info(\n                        $"Cannot get Windows 10 system theme mode, return default value 0 (dark mode).");

            InitializeComponent();\n            // a dirty hack\n            this.ServersListBox.Dock = DockStyle.Fill;\n            this.tableLayoutPanel5.Dock = DockStyle.Fill;\n            this.PerformLayout();\n            UpdateTexts();\n            this.Icon = Icon.FromHandle(Resources.ssw128.GetHicon());\n            this.controller = controller;\n            controller.ConfigChanged += controller_ConfigChanged;\n            LoadCurrentConfiguration();
            this.PerformLayout();\n            UpdateTexts();\n            this.Icon = Icon.FromHandle(Resources.ssw128.GetHicon());\n            this.controller = controller;\n            controller.ConfigChanged += controller_ConfigChanged;\n            LoadCurrentConfiguration();\n        }\n        private void UpdateTexts()\n        {\n            AddButton.Text = I18N.GetString("&Add");
            this.PluginArgumentsTextBox = new System.Windows.Forms.TextBox();\n            this.PluginArgumentsLabel = new System.Windows.Forms.Label();\n            this.RemarksLabel = new System.Windows.Forms.Label();\n            this.panel2 = new System.Windows.Forms.Panel();\n            this.OKButton = new System.Windows.Forms.Button();\n            this.MyCancelButton = new System.Windows.Forms.Button();\n            this.DeleteButton = new System.Windows.Forms.Button();\n            this.AddButton = new System.Windows.Forms.Button();\n            this.ServerGroupBox = new System.Windows.Forms.GroupBox();\n            this.ServersListBox = new System.Windows.Forms.ListBox();
            this.tableLayoutPanel5.AutoSize = true;\n            this.tableLayoutPanel5.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;\n            this.tableLayoutPanel5.ColumnCount = 2;\n            this.tableLayoutPanel5.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());\n            this.tableLayoutPanel5.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());\n            this.tableLayoutPanel5.Controls.Add(this.ProxyPortTextBox, 1, 0);\n            this.tableLayoutPanel5.Controls.Add(this.ProxyPortLabel, 0, 0);\n            this.tableLayoutPanel5.Controls.Add(this.TempFolderLabel, 0, 1);\n            this.tableLayoutPanel5.Controls.Add(this.TempFolderTextBox, 1, 1);\n            this.tableLayoutPanel5.Location = new System.Drawing.Point(166, 308);
            this.tableLayoutPanel5.Margin = new System.Windows.Forms.Padding(0);\n            this.tableLayoutPanel5.Name = "tableLayoutPanel5";\n            this.tableLayoutPanel5.Padding = new System.Windows.Forms.Padding(3);\n            this.tableLayoutPanel5.RowCount = 2;\n            this.tableLayoutPanel5.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel5.RowStyles.Add(new System.Windows.Forms.RowStyle());
                    string jsonString = JsonConvert.SerializeObject(_userSettings, Formatting.Indented);\n                    sw.Write(jsonString);\n                    sw.Flush();\n                }\n            }\n            catch (IOException e)\n            {\n                Logging.LogUsefulException(e);\n            }
                _userSettings = JsonConvert.DeserializeObject<SysproxyConfig>(configContent);\n            }\n            catch (Exception)\n            {\n                // Suppress all exceptions. finally block will initialize new user config settings.\n            }\n            finally\n            {\n                if (_userSettings == null) _userSettings = new SysproxyConfig();\n            }\n        }
using System.Net;\nusing System.Net.Sockets;\nusing System.Timers;\nusing Shadowsocks.Controller.Strategy;\nusing Shadowsocks.Encryption;\nusing Shadowsocks.ForwardProxy;\nusing Shadowsocks.Model;\nusing Shadowsocks.Util.Sockets;\nnamespace Shadowsocks.Controller.Service\n{
{\n    class TCPRelay : Listener.Service\n    {\n        private ShadowsocksController _controller;\n        private DateTime _lastSweepTime;\n        private Configuration _config;\n        private readonly List<ITCPHandlerFactory> _factories = new List<ITCPHandlerFactory>();\n        public ISet<TCPHandler> Handlers { get; } = new HashSet<TCPHandler>();\n        public TCPRelay(ShadowsocksController controller, Configuration conf)
        public TCPRelay(ShadowsocksController controller, Configuration conf)\n        {\n            _controller = controller;\n            _config = conf;\n            _lastSweepTime = DateTime.Now;\n            _factories.Add(new Socks5HandlerFactory());\n            _factories.Add(new HttpHandlerHandlerFactory());\n        }\n        public override bool Handle(byte[] firstPacket, int length, Socket socket, object state)
            _lastSweepTime = DateTime.Now;\n            _factories.Add(new Socks5HandlerFactory());\n            _factories.Add(new HttpHandlerHandlerFactory());\n        }\n        public override bool Handle(byte[] firstPacket, int length, Socket socket, object state)\n        {\n            TCPHandler handler = null;\n            foreach (var factory in _factories)\n            {\n                if (factory.CanHandle(firstPacket, length))
                return false;\n            }\n            socket.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n            IList<TCPHandler> handlersToClose = new List<TCPHandler>();\n            lock (Handlers)\n            {\n                Handlers.Add(handler);\n                DateTime now = DateTime.Now;\n                if (now - _lastSweepTime > TimeSpan.FromSeconds(1))
            IList<TCPHandler> handlersToClose = new List<TCPHandler>();\n            lock (Handlers)\n            {\n                Handlers.Add(handler);\n                DateTime now = DateTime.Now;\n                if (now - _lastSweepTime > TimeSpan.FromSeconds(1))\n                {\n                    _lastSweepTime = now;\n                    foreach (TCPHandler handler1 in Handlers)\n                        if (now - handler1.lastActivity > TimeSpan.FromSeconds(900))
    {\n        bool CanHandle(byte[] firstPacket, int length);\n        TCPHandler NewHandler(ShadowsocksController controller, Configuration config, TCPRelay tcprelay, Socket socket);\n    }\n    abstract class TCPHandler\n    {\n        public abstract void StartHandshake(byte[] firstPacket, int length);\n        protected abstract void OnServerConnected(AsyncSession session);\n        protected class AsyncSession
        {\n            public IForwardProxy Remote { get; }\n            public AsyncSession(IForwardProxy remote)\n            {\n                Remote = remote;\n            }\n        }\n        protected class AsyncSession<T> : AsyncSession\n        {\n            public T State { get; set; }
        {\n            public T State { get; set; }\n            public AsyncSession(IForwardProxy remote, T state) : base(remote)\n            {\n                State = state;\n            }
        private AsyncSession _currentRemoteSession;\n        private bool _proxyConnected;\n        private bool _destConnected;\n        private int _totalRead = 0;\n        private int _totalWrite = 0;\n        protected byte[] RemoteRecvBuffer { get; } = new byte[BufferSize];\n        private readonly byte[] _remoteSendBuffer = new byte[BufferSize];\n        protected byte[] ConnetionRecvBuffer { get; } = new byte[BufferSize];\n        private readonly byte[] _connetionSendBuffer = new byte[BufferSize];\n        private IEncryptor _encryptor;
        private DateTime _startConnectTime;\n        private DateTime _startReceivingTime;\n        private DateTime _startSendingTime;\n        private EndPoint _destEndPoint = null;\n        public TCPHandler(ShadowsocksController controller, Configuration config, TCPRelay tcprelay, Socket socket, bool autoAppendHeader = true)\n        {\n            _controller = controller;
        {\n            _controller = controller;\n            _serverHeaderSent = !autoAppendHeader;\n        }
            if (server == null || server.server == "")\n                throw new ArgumentException("No server configured");\n            lock (_encryptionLock)\n            {\n                lock (_decryptionLock)\n                {\n                    _encryptor = EncryptorFactory.GetEncryptor(server.method, server.password, server.auth, false);\n                }\n            }\n            this._server = server;
            try\n            {\n                _startReceivingTime = DateTime.Now;\n                session.Remote.BeginReceive(RemoteRecvBuffer, 0, RecvSize, SocketFlags.None, PipeRemoteReceiveCallback, session);\n                Connection.BeginReceive(ConnetionRecvBuffer, 0, RecvSize, SocketFlags.None, PipeConnectionReceiveCallback, session);\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();
            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void PipeRemoteReceiveCallback(IAsyncResult ar)\n        {
            IStrategy strategy = _controller.GetCurrentStrategy();\n            strategy?.UpdateLastWrite(_server);\n        }\n        protected AsyncSession EndSendToServer(IAsyncResult ar)\n        {\n            var session = (AsyncSession)ar.AsyncState;\n            session.Remote.EndSend(ar);\n            return session;\n        }\n        private void PipeRemoteSendCallback(IAsyncResult ar)
            try\n            {\n                var session = (AsyncSession)ar.AsyncState;\n                Connection.EndSend(ar);\n                session.Remote.BeginReceive(RemoteRecvBuffer, 0, RecvSize, SocketFlags.None, PipeRemoteReceiveCallback, session);
            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }\n    }\n}
                _listener = new Listener(services);\n                _listener.Start(_config);\n            }\n            catch (Exception e)\n            {\n                // translate Microsoft language into human language\n                // i.e. An attempt was made to access a socket in a way forbidden by its access permissions => Port already in use\n                if (e is SocketException)\n                {\n                    SocketException se = (SocketException)e;
            // 构造request包剩余部分\n            request[0] = 5;\n            request[1] = 1;\n            request[2] = 0;\n            var st = new Socks5State();\n            st.Callback = callback;\n            st.AsyncState = state;\n            _remote.BeginSend(request, 0, request.Length, 0, Socks5RequestSendCallback, st);
            var st = new Socks5State();\n            st.Callback = callback;\n            st.AsyncState = state;\n            _remote.BeginSend(request, 0, request.Length, 0, Socks5RequestSendCallback, st);\n        }\n        public void EndConnectDest(IAsyncResult asyncResult)\n        {\n            var state = ((FakeAsyncResult)asyncResult).innerState;\n            if (state.ex != null)\n            {
            int entryNameSize = 0;\n            int lpSize = 0;\n            uint retval = ERROR_SUCCESS;\n            RasEntryName[] names = null;\n            entryNameSize = Marshal.SizeOf(typeof(RasEntryName));\n            // Windows Vista or later:  To determine the required buffer size, call RasEnumEntries\n            // with lprasentryname set to NULL. The variable pointed to by lpcb should be set to zero.\n            // The function will return the required buffer size in lpcb and an error code of ERROR_BUFFER_TOO_SMALL.\n            retval = RasEnumEntries(null, null, null, ref lpSize, out lpNames);
            if (retval == ERROR_BUFFER_TOO_SMALL)\n            {\n                names = new RasEntryName[lpNames];\n                for (int i = 0; i < names.Length; i++)\n                {\n                    names[i].dwSize = entryNameSize;\n                }\n                retval = RasEnumEntries(null, null, names, ref lpSize, out lpNames);\n            }\n            if (retval == ERROR_SUCCESS)
            }\n            if (retval == ERROR_SUCCESS)\n            {\n                if (lpNames == 0)\n                {\n                    // no entries found.\n                    return 1;\n                }\n                allConns = new string[names.Length];\n                for (int i = 0; i < names.Length; i++)
            foreach (var strategy in controller.GetStrategies())\n            {\n                MenuItem item = new MenuItem(strategy.Name);\n                item.Tag = strategy.ID;\n                item.Click += AStrategyItem_Click;\n                items.Add(strategyCount, item);\n                strategyCount++;\n            }\n            // user wants a seperator item between strategy and servers menugroup\n            items.Add(strategyCount++, new MenuItem("-"));\n            int serverCount = 0;
            }\n            // user wants a seperator item between strategy and servers menugroup\n            items.Add(strategyCount++, new MenuItem("-"));\n            int serverCount = 0;\n            Configuration configuration = controller.GetConfigurationCopy();\n            foreach (var server in configuration.configs)\n            {\n                if (Configuration.ChecksServer(server))\n                {\n                    MenuItem item = new MenuItem(server.FriendlyName());\n                    item.Tag = configuration.configs.FindIndex(s => s == server);
            Configuration configuration = controller.GetConfigurationCopy();\n            foreach (var server in configuration.configs)\n            {\n                if (Configuration.ChecksServer(server))\n                {\n                    MenuItem item = new MenuItem(server.FriendlyName());\n                    item.Tag = configuration.configs.FindIndex(s => s == server);\n                    item.Click += AServerItem_Click;\n                    items.Add(strategyCount + serverCount, item);\n                    serverCount++;
                    item.Click += AServerItem_Click;\n                    items.Add(strategyCount + serverCount, item);\n                    serverCount++;

                }),\n                new MenuItem("-"),\n                this.AutoStartupItem = CreateMenuItem("Start on Boot", new EventHandler(this.AutoStartupItem_Click)),\n                this.ShareOverLANItem = CreateMenuItem("Share over LAN", new EventHandler(this.ShareOverLANItem_Click)),\n                CreateMenuItem("Edit PAC File...", new EventHandler(this.EditPACFileItem_Click)),\n                CreateMenuItem("Update PAC from GFWList", new EventHandler(this.UpdatePACFromGFWListItem_Click)),\n                new MenuItem("-"),\n                CreateMenuItem("Show Logs...", new EventHandler(this.ShowLogItem_Click)),
                CreateMenuItem("Show Logs...", new EventHandler(this.ShowLogItem_Click)),\n                CreateMenuItem("About...", new EventHandler(this.AboutItem_Click)),\n                new MenuItem("-"),\n                CreateMenuItem("Quit", new EventHandler(this.Quit_Click))\n            });\n        }\n        private void controller_ConfigChanged(object sender, EventArgs e)\n        {\n            LoadCurrentConfiguration();\n            UpdateTrayIcon();
            Configuration configuration = controller.GetConfiguration();\n            for (int i = 0; i < configuration.configs.Count; i++)\n            {\n                Server server = configuration.configs[i];\n                MenuItem item = new MenuItem(server.FriendlyName());\n                item.Tag = i;\n                item.Click += AServerItem_Click;\n                items.Add(i, item);\n            }
            if (configuration.index >= 0 && configuration.index < configuration.configs.Count)\n            {\n                items[configuration.index].Checked = true;\n            }\n        }\n        private void ShowConfigForm()\n        {\n            if (configForm != null)\n            {\n                configForm.Activate();
                }\n                MessageBox.Show(I18N.GetString("Failed to scan QRCode"));\n            }\n        }\nprivate void AutoStartupItem_Click(object sender, EventArgs e) {\nAutoStartupItem.Checked = !AutoStartupItem.Checked;\nif (!AutoStartup.Set(AutoStartupItem.Checked)) {\nMessageBox.Show("Failed to edit registry");\n}\n}
            if (File.Exists(PACServer.USER_RULE_FILE))\n            {\n                string local = FileManager.NonExclusiveReadAllText(PACServer.USER_RULE_FILE, Encoding.UTF8);\n                using (var sr = new StringReader(local))\n                {\n                    foreach (var rule in sr.NonWhiteSpaceLines())\n                    {\n                        if (rule.BeginWithAny(IgnoredLineBegins))\n                            continue;\n                        lines.Add(rule);
                using (var sr = new StringReader(local))\n                {\n                    foreach (var rule in sr.NonWhiteSpaceLines())\n                    {\n                        if (rule.BeginWithAny(IgnoredLineBegins))\n                            continue;\n                        lines.Add(rule);\n                    }\n                }\n            }
        }\n        void controller_ShareOverLANStatusChanged(object sender, EventArgs e)\n        {\n            ShareOverLANItem.Checked = controller.GetConfigurationCopy().shareOverLan;\n        }\n        void controller_VerboseLoggingStatusChanged(object sender, EventArgs e)\n        {\n            VerboseLoggingToggleItem.Checked = controller.GetConfigurationCopy().isVerboseLogging;\n        }
        }\n        private void GlobalModeItem_Click(object sender, EventArgs e)\n        {\n            controller.ToggleEnable(true);\n            controller.ToggleGlobal(true);\n            Configuration config = controller.GetConfigurationCopy();\n            UpdateSystemProxyItemsEnabledStatus(config);\n        }\n        private void PACModeItem_Click(object sender, EventArgs e)\n        {
                StreamWriterWithTimestamp sw = new StreamWriterWithTimestamp(fs);\n                sw.AutoFlush = true;\n                Console.SetOut(sw);\n                Console.SetError(sw);\n                return true;\n            }\n            catch (IOException e)\n            {\n                Console.WriteLine(e.ToString());\n                return false;
            if (polipoRunner == null)\n            {\n                polipoRunner = new PolipoRunner();\n            }\n            polipoRunner.Start(config);\n            local = new Local(config);\n            local.Start();\n        }\n        private void Config_Click(object sender, EventArgs e)\n        {
        {\n            MenuItem result = new MenuItem(I18N.GetString(text), click);\n            return result;\n        }\n        private MenuItem CreateSeperatorItem()\n        {\n            MenuItem result = new MenuItem("-");\n            return result;
            return result;\n        }\n        private MenuItem CreateSeperatorItem()\n        {\n            MenuItem result = new MenuItem("-");\n            return result;\n        }\n        private MenuItem CreateMenuGroup(string text, MenuItem[] items)\n        {
        {\n            MenuItem result = new MenuItem("-");\n            return result;\n        }\n        private MenuItem CreateMenuGroup(string text, MenuItem[] items)\n        {\n            for (int i = 0; i < items.Length; i++)\n            {\n                items[i].Index = i;
            return result;\n        }\n        private MenuItem CreateMenuGroup(string text, MenuItem[] items)\n        {\n            for (int i = 0; i < items.Length; i++)\n            {\n                items[i].Index = i;\n            }\n            MenuItem result = new MenuItem(I18N.GetString(text), items);
            MenuItem result = new MenuItem(I18N.GetString(text), items);\n            return result;\n        }\n        private void LoadMenu()\n        {\n            this.contextMenu1 = new System.Windows.Forms.ContextMenu();\n            this.contextMenu1.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {\n                this.enableItem = CreateMenuItem("Enable", new System.EventHandler(this.EnableItem_Click)),\n                CreateMenuGroup("Mode", new System.Windows.Forms.MenuItem[] {
            return result;\n        }\n        private void LoadMenu()\n        {\n            this.contextMenu1 = new System.Windows.Forms.ContextMenu();\n            this.contextMenu1.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {\n                this.enableItem = CreateMenuItem("Enable", new System.EventHandler(this.EnableItem_Click)),\n                CreateMenuGroup("Mode", new System.Windows.Forms.MenuItem[] {\n                    this.PACModeItem = CreateMenuItem("PAC", new System.EventHandler(this.PACModeItem_Click)),\n                    this.globalModeItem = CreateMenuItem("Global", new System.EventHandler(this.GlobalModeItem_Click))
            });
        }\n        private void controller_ConfigChanged(object sender, EventArgs e)\n        {\n            LoadCurrentConfiguration();\n            UpdateTrayIcon();\n        }\n        private void controller_EnableStatusChanged(object sender, EventArgs e)\n        {\n            enableItem.Checked = controller.GetConfiguration().enabled;\n        }
                    {\n                        int atyp = _connetionRecvBuffer[0];\n                        string dst_addr;\n                        int dst_port;\n                        switch (atyp)\n                        {\n                            case 1: // IPv4 address, 4 bytes\n                                dst_addr = new IPAddress(_connetionRecvBuffer.Skip(1).Take(4).ToArray()).ToString();\n                                dst_port = (_connetionRecvBuffer[5] << 8) + _connetionRecvBuffer[6];\n                                Logging.Info($"connect to {dst_addr}:{dst_port}");
                    }\n                    int bytesToSend;\n                    lock (_encryptionLock)\n                    {\n                        if (_closed) return;\n                        encryptor.Encrypt(_connetionRecvBuffer, bytesRead, _connetionSendBuffer, out bytesToSend);\n                    }\n                    _tcprelay.UpdateOutboundCounter(server, bytesToSend);\n                    _startSendingTime = DateTime.Now;\n                    _bytesToSend = bytesToSend;
        public string version;\n        public List<Server> configs;\n        // when strategy is set, index is ignored\n        public string strategy;\n        public int index;\n        public bool global;\n        public bool enabled;\n        public bool shareOverLan;\n        public bool isDefault;\n        public int localPort;
        public int localPort;\n        public bool portableMode = true;\n        public bool showPluginOutput;\n        public string pacUrl;\n        public bool useOnlinePac;\n        public bool secureLocalPac = true;\n        public bool availabilityStatistics;
        public bool useOnlinePac;\n        public bool secureLocalPac = true;\n        public bool availabilityStatistics;\n        public bool autoCheckUpdate;\n        public bool checkPreRelease;\n        public bool isVerboseLogging;\n        // hidden options\n        public bool isIPv6Enabled = false; // for experimental ipv6 support\n        public bool generateLegacyUrl = false; // for pre-sip002 url compatibility\n        public string geositeUrl; // for custom geosite source (and rule group)
        //public NLogConfig.LogLevel logLevel;\n        public LogViewerConfig logViewer;\n        public ProxyConfig proxy;\n        public HotkeyConfig hotkey;\n        [JsonIgnore]\n        NLogConfig nLogConfig;\n        private static readonly string CONFIG_FILE = "gui-config.json";\n#if DEBUG\n        private static readonly NLogConfig.LogLevel verboseLogLevel = NLogConfig.LogLevel.Trace;\n#else\n        private static readonly NLogConfig.LogLevel verboseLogLevel =  NLogConfig.LogLevel.Debug;\n#endif
#if DEBUG\n        private static readonly NLogConfig.LogLevel verboseLogLevel = NLogConfig.LogLevel.Trace;\n#else\n        private static readonly NLogConfig.LogLevel verboseLogLevel =  NLogConfig.LogLevel.Debug;\n#endif\n        [JsonIgnore]\n        public bool updated = false;\n        [JsonIgnore]\n        public string localHost => GetLocalHost();\n        private string GetLocalHost()\n        {\n            return isIPv6Enabled ? "[::1]" : "127.0.0.1";
#else\n        private static readonly NLogConfig.LogLevel verboseLogLevel =  NLogConfig.LogLevel.Debug;\n#endif\n        [JsonIgnore]\n        public bool updated = false;\n        [JsonIgnore]\n        public string localHost => GetLocalHost();\n        private string GetLocalHost()\n        {\n            return isIPv6Enabled ? "[::1]" : "127.0.0.1";\n        }
#endif\n        [JsonIgnore]\n        public bool updated = false;\n        [JsonIgnore]\n        public string localHost => GetLocalHost();\n        private string GetLocalHost()\n        {\n            return isIPv6Enabled ? "[::1]" : "127.0.0.1";\n        }\n        public Server GetCurrentServer()
using System.Text;\nusing System.Windows.Forms;\nusing Shadowsocks.Controller;\nusing Shadowsocks.Model;\nusing Shadowsocks.Properties;\nusing static Shadowsocks.Controller.HotkeyReg;\nnamespace Shadowsocks.View\n{\n    public partial class HotkeySettingsForm : Form
using Shadowsocks.Model;\nusing Shadowsocks.Properties;\nusing static Shadowsocks.Controller.HotkeyReg;\nnamespace Shadowsocks.View\n{\n    public partial class HotkeySettingsForm : Form\n    {\n        private readonly ShadowsocksController _controller;\n        // this is a copy of hotkey configuration that we are working on\n        private HotkeyConfig _modifiedHotkeyConfig;
namespace Shadowsocks.View\n{\n    public partial class HotkeySettingsForm : Form\n    {\n        private readonly ShadowsocksController _controller;\n        // this is a copy of hotkey configuration that we are working on\n        private HotkeyConfig _modifiedHotkeyConfig;\n        public HotkeySettingsForm(ShadowsocksController controller)\n        {\n            InitializeComponent();
        }\n        private void HandleRegResult(string hotkeyStr, Label label, RegResult result)\n        {\n            switch (result)\n            {\n                case RegResult.ParseError:
        {\n            switch (result)\n            {\n                case RegResult.ParseError:
            {\n                case RegResult.ParseError:
                    MessageBox.Show(string.Format(I18N.GetString("Cannot parse hotkey: {0}"), hotkeyStr));\n                    break;\n                case RegResult.UnregSuccess:\n                    label.ResetBackColor();\n                    break;\n                case RegResult.RegSuccess:\n                    label.BackColor = Color.Green;\n                    break;\n                case RegResult.RegFailure:\n                    label.BackColor = Color.Red;
            }\n        }\n    }\n}
            {\n                _isStartupChecking = true;\n                updateChecker.CheckUpdate(config, 3000);

            }\n            else if (!_isStartupChecking)\n            {\n                ShowBalloonTip(I18N.GetString("Shadowsocks"), I18N.GetString("No update is available"), ToolTipIcon.Info, 5000);\n            }\n            _isStartupChecking = false;\n        }\n        void notifyIcon1_BalloonTipClicked(object sender, EventArgs e)\n        {
            }\n            _isStartupChecking = false;\n        }\n        void notifyIcon1_BalloonTipClicked(object sender, EventArgs e)\n        {\n            if (updateChecker.NewVersionFound)\n            {\n                updateChecker.NewVersionFound = false; /* Reset the flag */\n                if (System.IO.File.Exists(updateChecker.LatestVersionLocalName))\n                {

            UpdateMoveUpAndDownButton();\n            LoadSelectedServer();\n        }\n        private void ConfigForm_Load(object sender, EventArgs e)\n        {\n        }\n        private void ServersListBox_SelectedIndexChanged(object sender, EventArgs e)\n        {\n            if (_lastSelectedIndex == ServersListBox.SelectedIndex)\n            {
            {\n                // can be -1\n                _lastSelectedIndex = _modifiedConfiguration.configs.Count - 1;\n            }\n            ServersListBox.SelectedIndex = _lastSelectedIndex;\n            LoadConfiguration(_modifiedConfiguration);\n            ServersListBox.SelectedIndex = _lastSelectedIndex;\n            LoadSelectedServer();\n        }\n        private void OKButton_Click(object sender, EventArgs e)\n        {
            controller.SaveServers(_modifiedConfiguration.configs, _modifiedConfiguration.localPort);\n            controller.SelectServerIndex(_modifiedConfiguration.configs.IndexOf(server));\n            this.Close();\n        }\n        private void CancelButton_Click(object sender, EventArgs e)\n        {\n            this.Close();\n        }\n        private void ConfigForm_Shown(object sender, EventArgs e)\n        {
            this.Close();\n        }\n        private void CancelButton_Click(object sender, EventArgs e)\n        {\n            this.Close();\n        }\n        private void ConfigForm_Shown(object sender, EventArgs e)\n        {\n            IPTextBox.Focus();\n        }
        protected int _encryptBytesRemaining;\n        protected int _decryptBytesRemaining;\n        protected ulong _encryptIC;\n        protected ulong _decryptIC;\n        protected byte[] _encryptBuf;\n        protected byte[] _decryptBuf;\n        public SodiumEncryptor(string method, string password, bool onetimeauth, bool isudp)\n            : base(method, password, onetimeauth, isudp)\n        {\n            _encryptBuf = new byte[MAX_INPUT_SIZE + SODIUM_BLOCK_SIZE];
            {\n                bytesRemaining = _encryptBytesRemaining;\n                ic = _encryptIC;\n                sodiumBuf = _encryptBuf;\n                iv = _encryptIV;\n            }\n            else\n            {\n                bytesRemaining = _decryptBytesRemaining;\n                ic = _decryptIC;
            }\n        }\n        public override void Dispose()\n        {\n        }\n    }\n}
using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.IO.Compression;\nusing System.Text;\nnamespace shadowsocks.Controller\n{\n    class PolipoRunner\n    {
{\n    class PolipoRunner\n    {\n        private Process process;\n        public void Start(Server config)\n        {\n            if (process == null)\n            {\n                Process[] existingPolipo = Process.GetProcessesByName("ss_polipo");\n                foreach (Process p in existingPolipo)
using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.IO.Compression;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Text;\nnamespace shadowsocks.Controller\n{
{\n    class PACServer\n    {\n        private static string PAC_FILE = "pac.txt";\n        Socket listener;\n        FileSystemWatcher watcher;\n        public event EventHandler PACFileChanged;\n        public void Start()\n        {\n            // Create a TCP/IP socket.
using System;\nusing System.Collections.Generic;\nusing System.Text;\nnamespace shadowsocks.Controller\n{\n    public class ShadowsocksController\n    {\n        // controller:\n        // handle user actions\n        // manipulates UI
{\n    public class ShadowsocksController\n    {\n        // controller:\n        // handle user actions\n        // manipulates UI\n        // interacts with low level logic\n        private Local local;\n        private PACServer pacServer;\n        private Configuration config;
using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Runtime.InteropServices;\nusing System.Windows.Forms;\nnamespace shadowsocks\n{\n    static class Program\n    {\n        [DllImport("Kernel32.dll")]
{\n    static class Program\n    {\n        [DllImport("Kernel32.dll")]\n        private static extern IntPtr LoadLibrary(string path);\n        /// <summary>\n        /// 应用程序的主入口点。\n        /// </summary>\n        [STAThread]\n        static void Main()
            }\n        }\n        private void loadCurrentConfiguration()\n        {\n            modifiedConfiguration = controller.GetConfiguration();\n            loadConfiguration(modifiedConfiguration);\n            oldSelectedIndex = modifiedConfiguration.index;\n            ServersListBox.SelectedIndex = modifiedConfiguration.index;\n            loadSelectedServer();\n            updateServersMenu();
            this.editPACFileItem,\n            this.aboutItem,\n            this.menuItem3,\n            this.quitItem});\n            // \n            // enableItem\n            // \n            this.enableItem.Index = 0;\n            // ServersItem\n            // \n            this.ServersItem.Index = 1;
            // \n            // editPACFileItem\n            // \n            this.editPACFileItem.Index = 3;\n            this.editPACFileItem.Text = "Edit &PAC File...";\n            this.editPACFileItem.Click += new System.EventHandler(this.EditPACFileItem_Click);\n            // \n            // aboutItem\n            // 
            this.editPACFileItem.Click += new System.EventHandler(this.EditPACFileItem_Click);\n            // \n            // aboutItem\n            // 
                _listener = new Listener(services);\n                _listener.Start(_config);\n            }\n            catch (Exception e)\n            {\n                // translate Microsoft language into human language\n                // i.e. An attempt was made to access a socket in a way forbidden by its access permissions => Port already in use\n                if (e is SocketException)\n                {\n                    SocketException se = (SocketException)e;
    {\n        private static int Uid;\n        private static string UniqueConfigFile;\n        private static Job PrivoxyJob;\n        private Process _process;\n        private int _runningPort;\n        static PrivoxyRunner()\n        {\n            try\n            {
        {\n            try\n            {\n                PrivoxyJob = new Job();\n                FileManager.UncompressFile(Utils.GetTempPath("ss_privoxy.exe"), Resources.privoxy_exe);\n                FileManager.UncompressFile(Utils.GetTempPath("mgwz.dll"), Resources.mgwz_dll);\n            }\n            catch (IOException e)
                {\n                    KillProcess(p);\n                }\n                string privoxyConfig = Resources.privoxy_conf;\n                _runningPort = this.GetFreePort();\n                privoxyConfig = privoxyConfig.Replace("__SOCKS_PORT__", configuration.localPort.ToString());\n                privoxyConfig = privoxyConfig.Replace("__PRIVOXY_BIND_PORT__", _runningPort.ToString());\n                privoxyConfig = privoxyConfig.Replace("__PRIVOXY_BIND_IP__", configuration.shareOverLan ? "0.0.0.0" : "127.0.0.1");\n                FileManager.ByteArrayToFile(Utils.GetTempPath(UniqueConfigFile), Encoding.UTF8.GetBytes(privoxyConfig));\n                _process = new Process();
                _runningPort = this.GetFreePort();\n                privoxyConfig = privoxyConfig.Replace("__SOCKS_PORT__", configuration.localPort.ToString());\n                privoxyConfig = privoxyConfig.Replace("__PRIVOXY_BIND_PORT__", _runningPort.ToString());\n                privoxyConfig = privoxyConfig.Replace("__PRIVOXY_BIND_IP__", configuration.shareOverLan ? "0.0.0.0" : "127.0.0.1");\n                FileManager.ByteArrayToFile(Utils.GetTempPath(UniqueConfigFile), Encoding.UTF8.GetBytes(privoxyConfig));\n                _process = new Process();\n                // Configure the process using the StartInfo properties.\n                _process.StartInfo.FileName = "ss_privoxy.exe";\n                _process.StartInfo.Arguments = UniqueConfigFile;\n                _process.StartInfo.WorkingDirectory = Utils.GetTempPath();
                _process = new Process();\n                // Configure the process using the StartInfo properties.\n                _process.StartInfo.FileName = "ss_privoxy.exe";\n                _process.StartInfo.Arguments = UniqueConfigFile;\n                _process.StartInfo.WorkingDirectory = Utils.GetTempPath();\n                _process.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;\n                _process.StartInfo.UseShellExecute = true;\n                _process.StartInfo.CreateNoWindow = true;\n                _process.Start();\n                /*
                    {\n                        throw new FileNotFoundException(I18N.GetString("Cannot find the plugin program file"), _pluginProcess.StartInfo.FileName, ex);\n                    }\n                    throw new ApplicationException(I18N.GetString("Plugin Program"), ex);\n                }\n                _pluginJob.AddProcess(_pluginProcess.Handle);\n                _started = true;\n            }\n            return true;\n        }
using Shadowsocks.Controller;\nusing Shadowsocks.Model;\nnamespace Shadowsocks.View\n{
namespace Shadowsocks.View\n{
                List<Asset> asserts = new List<Asset>();\n                if (result != null)\n                {\n                    foreach (JObject release in result)\n                    {\n                        if ((bool)release["prerelease"])
                        {\n                            continue;\n                        }\n                        foreach (JObject asset in (JArray)release["assets"])\n                        {\n                            Asset ass = new Asset();\n                            ass.Parse(asset);\n                            if (ass.IsNewVersion(Version))\n                            {\n                                asserts.Add(ass);
                        }\n                    }\n                }\n                if (asserts.Count != 0)\n                {\n                    SortByVersions(asserts);\n                    Asset asset = asserts[asserts.Count - 1];\n                    NewVersionFound = true;\n                    LatestVersionURL = asset.browser_download_url;\n                    LatestVersionNumber = asset.version;
using System.Text;\nusing System.Text.RegularExpressions;\nusing Shadowsocks.Controller;\nnamespace Shadowsocks.Model\n{\n    [Serializable]
using Shadowsocks.Controller;\nnamespace Shadowsocks.Model\n{\n    [Serializable]\n    public class Server\n    {\n        public string server;\n        public int server_port;\n        public string password;
namespace Shadowsocks.Model\n{\n    [Serializable]\n    public class Server\n    {\n        public string server;\n        public int server_port;\n        public string password;\n        public string method;\n        public string remarks;
using System.Collections.Generic;\nusing System.IO;\nusing Shadowsocks.Controller;\nusing Newtonsoft.Json;\nnamespace Shadowsocks.Model\n{\n    [Serializable]
namespace Shadowsocks.Model\n{\n    [Serializable]\n    public class Configuration\n    {\n        public List<Server> configs;\n        // when strategy is set, index is ignored\n        public string strategy;\n        public int index;\n        public bool global;
    {\n        public static string[] encryption_names = new string[] {\n            "table",\n            "rc4",\n            "aes-256-cfb",\n            "aes-192-cfb",\n            "aes-128-cfb",\n            "bf-cfb"\n        };
        public byte[] encryptTable = new byte[256];\n        public byte[] decryptTable = new byte[256];\n        public string method = "table";\n        public string password;\n        public byte[] key;\n        private RC4 rc4 = null;\n        private Cipher cipher = null;\n        private IntPtr encryptCTX;\n        private IntPtr decryptCTX;\n        private static Dictionary<string, byte[]> cachedKeys = new Dictionary<string, byte[]>();
        private long compare(byte x, byte y, ulong a, int i)\n        {\n            return (long)(a % (ulong)(x + i)) - (long)(a % (ulong)(y + i));\n        }\n        private byte[] mergeSort(byte[] array, ulong a, int j)\n        {\n            if (array.Length == 1)\n                return array;\n            int middle = array.Length / 2;\n            byte[] left = new byte[middle];
                rc4 = new RC4();\n                encryptTable = rc4.EncryptInitalize(hash);\n                decryptTable = rc4.EncryptInitalize(hash);\n            }\n            else if (method == "table" || method == "" || method == null)\n            {\n                Console.WriteLine("init table");\n                // TODO endian
                Console.WriteLine("init table");\n                // TODO endian\n                var a = BitConverter.ToUInt64(hash, 0);\n                for (int i = 0; i < 256; i++)\n                {\n                    encryptTable[i] = (byte)i;\n                }\n                for (int i = 1; i < 1024; i++)\n                {
                // TODO endian\n                var a = BitConverter.ToUInt64(hash, 0);\n                for (int i = 0; i < 256; i++)\n                {\n                    encryptTable[i] = (byte)i;\n                }\n                for (int i = 1; i < 1024; i++)\n                {\n                    encryptTable = mergeSort(encryptTable, a, i);\n                }
        {\n            switch (method)\n            {\n                case "table":\n                    for (int i = 0; i < length; i++)\n                        buf[i] = encryptTable[buf[i]];\n                    return buf;\n                    break;\n                case "rc4":\n                    rc4.Encrypt(encryptTable, buf, length);
                    for (int i = 0; i < length; i++)\n                        buf[i] = encryptTable[buf[i]];\n                    return buf;\n                    break;\n                case "rc4":\n                    rc4.Encrypt(encryptTable, buf, length);\n                    return buf;\n                    break;\n                default:\n                    return sslEncrypt(buf, length);
                    rc4.Encrypt(encryptTable, buf, length);\n                    return buf;\n                    break;\n                default:\n                    return sslEncrypt(buf, length);\n            }\n        }\n        public byte[] Decrypt(byte[] buf, int length)\n        {\n            switch (method)
        {\n            switch (method)\n            {\n                case "table":\n                    for (int i = 0; i < length; i++)\n                        buf[i] = decryptTable[buf[i]];\n                    return buf;\n                    break;\n                case "rc4":\n                    rc4.Decrypt(decryptTable, buf, length);
                    for (int i = 0; i < length; i++)\n                        buf[i] = decryptTable[buf[i]];\n                    return buf;\n                    break;\n                case "rc4":\n                    rc4.Decrypt(decryptTable, buf, length);\n                    return buf;\n                    break;\n                default:\n                    return sslDecrypt(buf, length);
                    rc4.Decrypt(decryptTable, buf, length);\n                    return buf;\n                    break;\n                default:\n                    return sslDecrypt(buf, length);\n            }\n        }\n    }\n}
            }\n        }\n    }\n}
            {\n                MessageBox.Show(ex.ToString());\n            }\n        }\n        private void cancelButton_Click(object sender, EventArgs e)\n        {\n            this.Hide();\n            configToTextBox();\n        }\n        private void Form1_FormClosed(object sender, FormClosedEventArgs e)
            }\n        }\n        private void cancelButton_Click(object sender, EventArgs e)\n        {\n            this.Hide();\n            configToTextBox();\n        }\n        private void Form1_FormClosed(object sender, FormClosedEventArgs e)\n        {\n            if (local != null) local.Stop();
            if (remote != null)\n            {\n                remote.Shutdown(SocketShutdown.Send);\n            }\n            encryptor.Dispose();\n        }\n        private void connectCallback(IAsyncResult ar)\n        {\n            try\n            {
        }\n        private void connectCallback(IAsyncResult ar)\n        {\n            try\n            {\n                // Complete the connection.\n                remote.EndConnect(ar);\n                Console.WriteLine("Socket connected to {0}",\n                    remote.RemoteEndPoint.ToString());\n                handshakeReceive();
        {\n            if (server == null)\n            {\n                throw new ArgumentNullException(nameof(server));\n            }\n            if (string.IsNullOrWhiteSpace(server.plugin))\n            {\n                return null;\n            }\n            return new Sip003Plugin(
        }\n        private Sip003Plugin(string plugin, string pluginOpts, string pluginArgs, string serverAddress, int serverPort, bool showPluginOutput)\n        {\n            if (plugin == null) throw new ArgumentNullException(nameof(plugin));\n            if (string.IsNullOrWhiteSpace(serverAddress))\n            {\n                throw new ArgumentException("Value cannot be null or whitespace.", nameof(serverAddress));\n            }\n            if (serverPort <= 0 || serverPort > 65535)\n            {
        {\n            if (plugin == null) throw new ArgumentNullException(nameof(plugin));\n            if (string.IsNullOrWhiteSpace(serverAddress))\n            {\n                throw new ArgumentException("Value cannot be null or whitespace.", nameof(serverAddress));\n            }\n            if (serverPort <= 0 || serverPort > 65535)\n            {\n                throw new ArgumentOutOfRangeException("serverPort");\n            }
            Application.EnableVisualStyles();\n            Application.SetCompatibleTextRenderingDefault(false);\n            Application.Run(new Form1());\n        }\n    }\n}
        }\n    }\n}
            this.contextMenuStrip1.Name = "contextMenuStrip1";\n            this.contextMenuStrip1.RenderMode = System.Windows.Forms.ToolStripRenderMode.System;\n            this.contextMenuStrip1.ShowImageMargin = false;\n            this.contextMenuStrip1.Size = new System.Drawing.Size(86, 48);\n            // \n            // ConfigItem\n            // \n            this.ConfigItem.Name = "ConfigItem";\n            this.ConfigItem.Size = new System.Drawing.Size(127, 22);\n            this.ConfigItem.Text = "Config";\n            this.ConfigItem.Click += new System.EventHandler(this.Config_Click);

            var ret = new DataList\n            {\n                new DataUnit(State.Geolocation, State.Unknown),\n                new DataUnit(State.ISP, State.Unknown),\n            };\n            string jsonString;\n            try\n            {\n                jsonString = await new HttpClient().GetStringAsync(api);\n            }
                {\n                    await geolocationAndIsp;\n                    Append(dataList, geolocationAndIsp.Result);\n                }\n            }\n        }\n        private static void Append(DataList dataList, IEnumerable<DataUnit> extra)\n        {\n            var data = dataList.Concat(extra);\n            var dataLine = string.Join(Delimiter, data.Select(kv => kv.Value).ToArray());
            }\n            // don't put polipoRunner.Start() before pacServer.Stop()\n            // or bind will fail when switching bind address from 0.0.0.0 to 127.0.0.1\n            // though UseShellExecute is set to true now\n            // http://stackoverflow.com/questions/10235093/socket-doesnt-close-after-application-exits-if-a-launched-process-is-open\n            polipoRunner.Stop();\n            try\n            {\n                var strategy = GetCurrentStrategy();\n                if (strategy != null)
    {\n        Local local;\n        PACServer pacServer;\n        Config config;\n        PolipoRunner polipoRunner;\n        public ConfigForm()\n        {\n            config = Config.Load();\n            InitializeComponent();\n            notifyIcon1.ContextMenu = contextMenu1;
        {\n            config = Config.Load();\n            InitializeComponent();\n            notifyIcon1.ContextMenu = contextMenu1;\n            enableItem.Checked = config.enabled;\n            configToTextBox();\n        }\n        private void showWindow()\n        {\n            this.Opacity = 1;
                }\n                else\n                {\n                    Console.WriteLine("failed to recv data in handshakeReceive2Callback");\n                    this.Close();\n                }\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);
        {\n            List<INTERNET_PER_CONN_OPTION> _optionlist = new List<INTERNET_PER_CONN_OPTION>();\n            if (enable)\n            {\n                if (global)\n                {\n                    // global proxy\n                    _optionlist.Add(new INTERNET_PER_CONN_OPTION\n                    {\n                        dwOption = (int)INTERNET_PER_CONN_OptionEnum.INTERNET_PER_CONN_FLAGS_UI,\n                        Value = { dwValue = (int)(INTERNET_OPTION_PER_CONN_FLAGS_UI.PROXY_TYPE_PROXY
                    });\n                    _optionlist.Add(new INTERNET_PER_CONN_OPTION\n                    {\n                        dwOption = (int)INTERNET_PER_CONN_OptionEnum.INTERNET_PER_CONN_PROXY_SERVER,\n                        Value = { pszValue = Marshal.StringToHGlobalAuto(proxyServer) }\n                    });\n                    _optionlist.Add(new INTERNET_PER_CONN_OPTION\n                    {\n                        dwOption = (int)INTERNET_PER_CONN_OptionEnum.INTERNET_PER_CONN_PROXY_BYPASS,\n                        Value = { pszValue = Marshal.StringToHGlobalAuto("<local>") }
                    });\n                    _optionlist.Add(new INTERNET_PER_CONN_OPTION\n                    {\n                        dwOption = (int)INTERNET_PER_CONN_OptionEnum.INTERNET_PER_CONN_PROXY_BYPASS,\n                        Value = { pszValue = Marshal.StringToHGlobalAuto("<local>") }\n                    });\n                }\n                else\n                {\n                    // pac
                    });\n                }\n                else\n                {\n                    // pac\n                    _optionlist.Add(new INTERNET_PER_CONN_OPTION\n                    {\n                        dwOption = (int)INTERNET_PER_CONN_OptionEnum.INTERNET_PER_CONN_FLAGS_UI,\n                        Value = { dwValue = (int)INTERNET_OPTION_PER_CONN_FLAGS_UI.PROXY_TYPE_AUTO_PROXY_URL }\n                    });
                IntPtr.Zero,\n                INTERNET_OPTION.INTERNET_OPTION_PROXY_SETTINGS_CHANGED,\n                IntPtr.Zero, 0);\n            if (!bReturn)\n            {\n                Logging.Error("InternetSetOption:INTERNET_OPTION_PROXY_SETTINGS_CHANGED");\n            }\n            bReturn = NativeMethods.InternetSetOption(\n                IntPtr.Zero,
                IntPtr.Zero, 0);\n            if (!bReturn)\n            {\n                Logging.Error("InternetSetOption:INTERNET_OPTION_PROXY_SETTINGS_CHANGED");\n            }\n            bReturn = NativeMethods.InternetSetOption(\n                IntPtr.Zero,\n                INTERNET_OPTION.INTERNET_OPTION_REFRESH,\n                IntPtr.Zero, 0);
                IntPtr.Zero,\n                INTERNET_OPTION.INTERNET_OPTION_REFRESH,\n                IntPtr.Zero, 0);\n            if (!bReturn)\n            {\n                Logging.Error("InternetSetOption:INTERNET_OPTION_REFRESH");\n            }\n        }\n        public static void SetIEProxy(bool enable, bool global, string proxyServer, string pacURL)\n        {
using System.Globalization;\nusing System.IO;\nusing System.Text;\nusing System.Windows.Forms;\nnamespace Shadowsocks.Controller\n{
using System.Windows.Forms;\nnamespace Shadowsocks.Controller\n{\n    public static class I18N\n    {\n        private static readonly string I18N_FILE = "i18n.csv";\n        private static Dictionary<string, string> _strings = new Dictionary<string, string>();\n        private static void Init(string res, string locale)
namespace Shadowsocks.Controller\n{\n    public static class I18N\n    {\n        private static readonly string I18N_FILE = "i18n.csv";\n        private static Dictionary<string, string> _strings = new Dictionary<string, string>();\n        private static void Init(string res, string locale)\n        {\n            using (TextFieldParser csvParser = new TextFieldParser(new StringReader(res)))\n            {
        static Sodium()\n        {\n            string tempPath = Utils.GetTempPath();\n            string dllPath = tempPath + "/libsscrypto.dll";\n            try
        {\n            string tempPath = Utils.GetTempPath();\n            string dllPath = tempPath + "/libsscrypto.dll";\n            try\n            {\n                FileManager.UncompressFile(dllPath, Resources.libsscrypto_dll);\n            }\n            catch (IOException)\n            {
            }\n            catch (IOException)\n            {\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine(e.ToString());\n            }\n            LoadLibrary(dllPath);
        }\n        [DllImport("Kernel32.dll")]\n        private static extern IntPtr LoadLibrary(string path);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int crypto_stream_salsa20_xor_ic(byte[] c, byte[] m, ulong mlen, byte[] n, ulong ic, byte[] k);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int crypto_stream_chacha20_xor_ic(byte[] c, byte[] m, ulong mlen, byte[] n, ulong ic, byte[] k);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int ss_gen_crc(byte[] buf, ref int buf_offset, ref int data_len,\n            byte[] crc_buf, ref int crc_idx, int buf_size);
        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int crypto_stream_chacha20_xor_ic(byte[] c, byte[] m, ulong mlen, byte[] n, ulong ic, byte[] k);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int ss_gen_crc(byte[] buf, ref int buf_offset, ref int data_len,\n            byte[] crc_buf, ref int crc_idx, int buf_size);
        public extern static int ss_gen_crc(byte[] buf, ref int buf_offset, ref int data_len,\n            byte[] crc_buf, ref int crc_idx, int buf_size);
        }\n        public int EndSend(IAsyncResult asyncResult)\n        {\n            return _remote.EndSend(asyncResult);\n        }\n        public void BeginReceive(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,\n            object state)\n        {\n            _remote.BeginReceive(buffer, offset, size, socketFlags, callback, state);\n        }
        }\n        public int EndReceive(IAsyncResult asyncResult)\n        {\n            return _remote.EndReceive(asyncResult);\n        }\n        public void Shutdown(SocketShutdown how)\n        {\n            _remote.Shutdown(how);\n        }\n        public void Close()
        }\n        public void Close()\n        {\n            _remote.Dispose();\n        }\n    }\n}
        }\n    }\n}
            this.QRCodeWebBrowser.Location = new System.Drawing.Point(0, 0);\n            this.QRCodeWebBrowser.Margin = new System.Windows.Forms.Padding(0);\n            this.QRCodeWebBrowser.MinimumSize = new System.Drawing.Size(20, 20);\n            this.QRCodeWebBrowser.Name = "QRCodeWebBrowser";\n            this.QRCodeWebBrowser.ScriptErrorsSuppressed = true;\n            this.QRCodeWebBrowser.ScrollBarsEnabled = false;\n            this.AutoSize = true;\n            this.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;
            this.Controls.Add(this.QRCodeWebBrowser);\n            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedSingle;\n            this.MaximizeBox = false;\n            this.Name = "QRCodeForm";\n            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;\n            this.Load += new System.EventHandler(this.QRCodeForm_Load);\n            this.ResumeLayout(false);\n        }\n        #endregion\n        private System.Windows.Forms.WebBrowser QRCodeWebBrowser;
        private byte[] _encryptIV;\n        private byte[] _decryptIV;\n        private byte[] _encryptIVOffset;\n        private byte[] _decryptIVOffset;\n        private string _method;\n        private int keyLen;\n        private int ivLen;\n        public PolarSSLEncryptor(string method, string password)\n            : base(method, password)\n        {
        private string _method;\n        private int keyLen;\n        private int ivLen;\n        public PolarSSLEncryptor(string method, string password)\n            : base(method, password)\n        {\n            InitKey(method, password);\n        }\n        private static void randBytes(byte[] buf, int length)\n        {
                }\n                else\n                {\n                    _decryptIV = new byte[ivLen];\n                    _decryptIVOffset = new byte[8];\n                    Array.Copy(iv, _decryptIV, ivLen);\n                }\n            }\n            else if (_cipher == CIPHER_BF)\n            {
            }\n        }\n        static byte[] tempbuf = new byte[32768];\n        public override void Encrypt(byte[] buf, int length, byte[] outbuf, out int outlength)\n        {\n            if (_encryptCtx == IntPtr.Zero)\n            {\n                randBytes(outbuf, ivLen);\n                InitCipher(ref _encryptCtx, outbuf, true);\n                outlength = length + ivLen;
            {\n                randBytes(outbuf, ivLen);\n                InitCipher(ref _encryptCtx, outbuf, true);\n                outlength = length + ivLen;\n                lock (tempbuf)\n                {\n                    // C# could be multi-threaded\n                    if (_disposed)\n                    {\n                        throw new ObjectDisposedException(this.ToString());\n                    }
                }\n            }\n            else\n            {\n                outlength = length;\n                if (_disposed)\n                {\n                    throw new ObjectDisposedException(this.ToString());\n                }\n                switch (_cipher)
                }\n            }\n        }\n        public override void Decrypt(byte[] buf, int length, byte[] outbuf, out int outlength)\n        {\n            if (_decryptCtx == IntPtr.Zero)\n            {\n                InitCipher(ref _decryptCtx, buf, false);\n                outlength = length - ivLen;\n                lock (tempbuf)
            {\n                InitCipher(ref _decryptCtx, buf, false);\n                outlength = length - ivLen;\n                lock (tempbuf)\n                {\n                    // C# could be multi-threaded\n                    Buffer.BlockCopy(buf, ivLen, tempbuf, 0, length - ivLen);\n                    if (_disposed)\n                    {\n                        throw new ObjectDisposedException(this.ToString());\n                    }
                    }\n                }\n            }\n            else\n            {\n                outlength = length;\n                if (_disposed)\n                {\n                    throw new ObjectDisposedException(this.ToString());\n                }
                }\n            }\n        }\n        #region IDisposable\n        private bool _disposed;\n        public override void Dispose()\n        {\n            Dispose(true);\n            GC.SuppressFinalize(this);\n        }
        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void aes_free(IntPtr ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int aes_setkey_enc(IntPtr ctx, byte[] key, int keysize);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int aes_crypt_cfb128(IntPtr ctx, int mode, int length, byte[] iv_off, byte[] iv, byte[] input, byte[] output);\n        public const int ARC4_CTX_SIZE = 264;\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void arc4_init(IntPtr ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int aes_setkey_enc(IntPtr ctx, byte[] key, int keysize);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int aes_crypt_cfb128(IntPtr ctx, int mode, int length, byte[] iv_off, byte[] iv, byte[] input, byte[] output);\n        public const int ARC4_CTX_SIZE = 264;\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void arc4_init(IntPtr ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void arc4_free(IntPtr ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int aes_crypt_cfb128(IntPtr ctx, int mode, int length, byte[] iv_off, byte[] iv, byte[] input, byte[] output);\n        public const int ARC4_CTX_SIZE = 264;\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void arc4_init(IntPtr ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void arc4_free(IntPtr ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void arc4_setup(IntPtr ctx, byte[] key, int keysize);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
        public const int ARC4_CTX_SIZE = 264;\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void arc4_init(IntPtr ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void arc4_free(IntPtr ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void arc4_setup(IntPtr ctx, byte[] key, int keysize);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int arc4_crypt(IntPtr ctx, int length, byte[] input, byte[] output);\n        public const int BLOWFISH_CTX_SIZE = 4168;
        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void arc4_free(IntPtr ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void arc4_setup(IntPtr ctx, byte[] key, int keysize);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int arc4_crypt(IntPtr ctx, int length, byte[] input, byte[] output);\n        public const int BLOWFISH_CTX_SIZE = 4168;\n        public const int BLOWFISH_ENCRYPT = 1;\n        public const int BLOWFISH_DECRYPT = 0;\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void arc4_setup(IntPtr ctx, byte[] key, int keysize);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int arc4_crypt(IntPtr ctx, int length, byte[] input, byte[] output);\n        public const int BLOWFISH_CTX_SIZE = 4168;\n        public const int BLOWFISH_ENCRYPT = 1;\n        public const int BLOWFISH_DECRYPT = 0;\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void blowfish_init(IntPtr ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int arc4_crypt(IntPtr ctx, int length, byte[] input, byte[] output);\n        public const int BLOWFISH_CTX_SIZE = 4168;\n        public const int BLOWFISH_ENCRYPT = 1;\n        public const int BLOWFISH_DECRYPT = 0;\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void blowfish_init(IntPtr ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void blowfish_free(IntPtr ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
        public const int BLOWFISH_CTX_SIZE = 4168;\n        public const int BLOWFISH_ENCRYPT = 1;\n        public const int BLOWFISH_DECRYPT = 0;\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void blowfish_init(IntPtr ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void blowfish_free(IntPtr ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int blowfish_setkey(IntPtr ctx, byte[] key, int keysize);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void blowfish_free(IntPtr ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int blowfish_setkey(IntPtr ctx, byte[] key, int keysize);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int blowfish_crypt_cfb64(IntPtr ctx, int mode, int length, byte[] iv_off, byte[] iv, byte[] input, byte[] output);\n    }\n}
        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int blowfish_setkey(IntPtr ctx, byte[] key, int keysize);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int blowfish_crypt_cfb64(IntPtr ctx, int mode, int length, byte[] iv_off, byte[] iv, byte[] input, byte[] output);\n    }\n}
        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int blowfish_crypt_cfb64(IntPtr ctx, int mode, int length, byte[] iv_off, byte[] iv, byte[] input, byte[] output);\n    }\n}
    }\n}
                        byte[] plain = new byte[16384];\n                        byte[] cipher = new byte[plain.Length + 16];\n                        byte[] plain2 = new byte[plain.Length + 16];\n                        int outLen = 0;\n                        int outLen2 = 0;\n                        random.NextBytes(plain);\n                        //lock (locker)\n                        //{\n                            encryptor.Encrypt(plain, plain.Length, cipher, out outLen);\n                            decryptor.Decrypt(cipher, outLen, plain2, out outLen2);\n                            for (int j = 0; j < plain.Length; j++)
                    }\n            }\n            catch\n            {\n                encryptionFailed = true;\n                throw;\n            }\n        }\n    }\n}
using Shadowsocks.Util.Sockets;\nnamespace Shadowsocks.Controller.Service\n{\n    class Http2Socks5 : Listener.Service\n    {
        public override bool Handle(byte[] firstPacket, int length, Socket socket, object state)\n        {\n            if (socket.ProtocolType != ProtocolType.Tcp)\n            {\n                return false;\n            }
        {\n            var contentBytes = Encoding.ASCII.GetBytes(content);\n            using (var md5 = System.Security.Cryptography.MD5.Create())\n            {\n                var md5Bytes = md5.ComputeHash(contentBytes);\n                return BitConverter.ToString(md5Bytes).Replace("-", "");\n            };

                    {\n                        case "DefaultConnectionSettings":\n                        case "LAN Connection":\n                        case "SavedLegacySettings":\n                            continue;\n                        default:\n                            //set all the connections's proxy as the lan\n                            registry.SetValue(each, defaultValue);\n                            continue;\n                    }\n                }
                    }\n                }\n                NotifyIE();\n            }\n            catch (IOException e)\n            {\n                Logging.LogUsefulException(e);\n            }\n        }\n        /// <summary>
        public bool Ping { get; set; }\n        public int ChoiceKeptMinutes { get; set; } = 10;\n        public int DataCollectionMinutes { get; set; } = 10;\n        public int RepeatTimesNum { get; set; } = 4;\n        private const string ConfigFile = "statistics-config.json";\n        public static StatisticsStrategyConfiguration Load()\n        {\n            try\n            {\n                var content = File.ReadAllText(ConfigFile);
        private const string ConfigFile = "statistics-config.json";\n        public static StatisticsStrategyConfiguration Load()\n        {\n            try\n            {\n                var content = File.ReadAllText(ConfigFile);\n                var configuration = JsonConvert.DeserializeObject<StatisticsStrategyConfiguration>(content);\n                return configuration;\n            }\n            catch (FileNotFoundException)
using System.Linq;\nusing System.Windows.Forms;\nusing Shadowsocks.Controller;\nusing Shadowsocks.Model;\nnamespace Shadowsocks.View\n{\n    public partial class StatisticsStrategyConfigurationForm : Form\n    {
using Shadowsocks.Controller;\nusing Shadowsocks.Model;\nnamespace Shadowsocks.View\n{\n    public partial class StatisticsStrategyConfigurationForm : Form\n    {\n        private readonly ShadowsocksController _controller;\n        private StatisticsStrategyConfiguration _configuration;\n        private readonly DataTable _dataTable = new DataTable();
    public partial class StatisticsStrategyConfigurationForm : Form\n    {\n        private readonly ShadowsocksController _controller;\n        private StatisticsStrategyConfiguration _configuration;\n        private readonly DataTable _dataTable = new DataTable();\n        private List<string> _servers;\n        public StatisticsStrategyConfigurationForm(ShadowsocksController controller)\n        {\n            if (controller == null) return;\n            InitializeComponent();
            this.tableLayoutPanel1.Controls.Add(this.TimeoutLabel, 0, 6);\n            this.tableLayoutPanel1.Controls.Add(this.TimeoutTextBox, 1, 6);\n            this.tableLayoutPanel1.Location = new System.Drawing.Point(8, 21);\n            this.tableLayoutPanel1.Margin = new System.Windows.Forms.Padding(0);\n            this.tableLayoutPanel1.Name = "tableLayoutPanel1";\n            this.tableLayoutPanel1.Padding = new System.Windows.Forms.Padding(3);\n            this.tableLayoutPanel1.RowCount = 7;\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());
            this.tableLayoutPanel1.TabIndex = 0;\n            // \n            // RemarksTextBox\n            // \n            this.RemarksTextBox.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));\n            this.RemarksTextBox.Location = new System.Drawing.Point(89, 113);\n            this.RemarksTextBox.MaxLength = 32;\n            this.RemarksTextBox.Name = "RemarksTextBox";\n            this.RemarksTextBox.Size = new System.Drawing.Size(160, 21);\n            this.RemarksTextBox.TabIndex = 4;
            this.EncryptionSelect.Location = new System.Drawing.Point(89, 87);\n            this.EncryptionSelect.Name = "EncryptionSelect";\n            this.EncryptionSelect.Size = new System.Drawing.Size(160, 20);\n            this.EncryptionSelect.TabIndex = 3;\n            // \n            // TimeoutLabel\n            // \n            this.TimeoutLabel.Anchor = System.Windows.Forms.AnchorStyles.Right;\n            this.TimeoutLabel.AutoSize = true;\n            this.TimeoutLabel.Location = new System.Drawing.Point(6, 144);\n            this.TimeoutLabel.Name = "TimeoutLabel";
            // \n            // panel2\n            // \n            this.panel2.Anchor = System.Windows.Forms.AnchorStyles.Top;\n            this.panel2.AutoSize = true;\n            this.panel2.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;\n            this.panel2.Location = new System.Drawing.Point(207, 187);\n            this.panel2.Name = "panel2";\n            this.panel2.Size = new System.Drawing.Size(0, 0);\n            this.panel2.TabIndex = 1;
            try\n            {\n                local.Start();\n                pacServer = new PACServer();\n                pacServer.PACFileChanged += pacServer_PACFileChanged;\n                pacServer.Start(_config);\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine(e.Message);
            }\n            catch (Exception e)\n            {\n                Console.WriteLine(e.Message);\n            }\n            UpdateSystemProxy();\n        }\n        public void SaveConfig(Configuration newConfig)\n        {\n            Configuration.Save(newConfig);
        //private Encryptor encryptor;\n        Socket _listener;\n        public Local(Configuration config)\n        {\n            this._server = config.GetCurrentServer();\n            _shareOverLAN = config.shareOverLan;\n            //this.encryptor = new Encryptor(config.method, config.password);\n        }\n        public void Start()\n        {\n            try
            //this.encryptor = new Encryptor(config.method, config.password);\n        }\n        public void Start()\n        {\n            try\n            {\n                // Create a TCP/IP socket.\n                _listener = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);\n                _listener.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, true);\n                IPEndPoint localEndPoint = null;\n                if (_shareOverLAN)\n                {
                // Bind the socket to the local endpoint and listen for incoming connections.\n                _listener.Bind(localEndPoint);\n                _listener.Listen(100);\n                // Start an asynchronous socket to listen for connections.\n                Console.WriteLine("Shadowsocks started");\n                _listener.BeginAccept(\n                    new AsyncCallback(AcceptCallback),\n                    _listener);\n            }\n            catch(SocketException)
        {\n            try\n            {\n                // Create a TCP/IP socket.\n                _listener = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);\n                _listener.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, true);\n                IPEndPoint localEndPoint = null;\n                if (configuration.shareOverLan)\n                {\n                    localEndPoint = new IPEndPoint(IPAddress.Any, PORT);
        }\n        public string TouchPACFile()\n        {\n            if (File.Exists(PAC_FILE))\n            {\n                return PAC_FILE;\n            }\n            else\n            {\n                FileManager.UncompressFile(PAC_FILE, Resources.proxy_pac_txt);
                conn.BeginReceive(new byte[1024], 0, 1024, 0,\n                    new AsyncCallback(ReceiveCallback), conn);\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine(e.Message);\n            }\n        }\n        private string GetPACContent()\n        {
        }\n        private void ReceiveCallback(IAsyncResult ar)\n        {\n            Socket conn = (Socket)ar.AsyncState;\n            try\n            {\n                int bytesRead = conn.EndReceive(ar);\n                string pac = GetPACContent();\n                IPEndPoint localEndPoint = (IPEndPoint)conn.LocalEndPoint;\n                string proxy = "PROXY " + localEndPoint.Address + ":8123;";
                pac = pac.Replace("__PROXY__", proxy);\n                if (bytesRead > 0)\n                {\n                    string text = String.Format(@"HTTP/1.1 200 OK\nServer: Shadowsocks\nContent-Type: application/x-ns-proxy-autoconfig\nContent-Length: {0}\nConnection: Close\n", System.Text.Encoding.UTF8.GetBytes(pac).Length) + pac;\n                    byte[] response = System.Text.Encoding.UTF8.GetBytes(text);
            this.tableLayoutPanel1.SuspendLayout();\n            this.panel1.SuspendLayout();\n            this.panel3.SuspendLayout();\n            this.ServerGroupBox.SuspendLayout();\n            this.SuspendLayout();\n            // \n            // tableLayoutPanel1\n            // \n            this.tableLayoutPanel1.AutoSize = true;\n            this.tableLayoutPanel1.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;
            this.ServersItem.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {\n            this.SeperatorItem,\n            this.ConfigItem});\n            this.ServersItem.Text = "&Servers";\n            // \n            // SeperatorItem\n            // \n            this.SeperatorItem.Index = 0;\n            this.SeperatorItem.Text = "-";\n            // \n            this.menuItem4.Index = 3;
            this.menuItem4.Text = "-";\n            // \n            // editPACFileItem\n            // \n            // ShowLogItem\n            // \n            this.ShowLogItem.Index = 6;
        {\n            Server server = configuration.GetCurrentServer();\n            if (_process == null)\n            {\n                Process[] existingPolipo = Process.GetProcessesByName("ss_polipo");\n                foreach (Process p in existingPolipo)\n                {\n                    try\n                    {\n                        p.Kill();
        {\n            this.tcprelay = tcprelay;\n            this.config = config;\n        }\n        public void CreateRemote()\n        {\n            Server server = controller.GetAServer(IStrategyCallerType.TCP, (IPEndPoint)connection.RemoteEndPoint);\n            if (server == null || server.server == "")\n            {\n                throw new ArgumentException("No server configured");
                ProxyTimer proxyTimer = new ProxyTimer(3000);\n                proxyTimer.AutoReset = false;\n                proxyTimer.Elapsed += proxyConnectTimer_Elapsed;\n                proxyTimer.Enabled = true;\n                proxyTimer.DestEndPoint = destEP;\n                proxyTimer.Server = server;\n                proxyConnected = false;\n                // Connect to the proxy server.\n                remote.BeginConnectProxy(proxyEP, new AsyncCallback(ProxyConnectCallback), proxyTimer);\n            }\n            catch (Exception e)
                proxyTimer.Server = server;\n                proxyConnected = false;\n                // Connect to the proxy server.\n                remote.BeginConnectProxy(proxyEP, new AsyncCallback(ProxyConnectCallback), proxyTimer);\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }
            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void proxyConnectTimer_Elapsed(object sender, ElapsedEventArgs e)\n        {\n            if (proxyConnected || destConnected)
                            {\n                                throw new Exception("Bad http header: " + line);\n                            }
                            }\n                        }\n                    }\n                }\n                else\n                {\n                    if (line.IsNullOrEmpty())\n                    {\n                        return true;\n                    }
                            {\n                                throw new Exception("Bad http header: " + line);\n                            }
                            }\n                        }\n                    }\n                }\n                _requestLineCount++;\n                return false;\n            }\n            private void OnFinish(byte[] lastBytes, int index, int length, object state)\n            {\n                if (_closed)
        public void Encrypt(byte[] table, byte[] data, int length)\n        {\n            EncryptOutput(enc_ctx, table, data, length);\n        }\n        public void Decrypt(byte[] table, byte[] data, int length)\n        {\n            EncryptOutput(dec_ctx, table, data, length);\n        }\n        public byte[] EncryptInitalize(byte[] key)\n        {
        }\n        public void Decrypt(byte[] table, byte[] data, int length)\n        {\n            EncryptOutput(dec_ctx, table, data, length);\n        }\n        public byte[] EncryptInitalize(byte[] key)\n        {\n            byte[] s = new byte[256];\n            for (int i = 0; i < 256; i++)\n            {
        }\n        public byte[] EncryptInitalize(byte[] key)\n        {\n            byte[] s = new byte[256];\n            for (int i = 0; i < 256; i++)\n            {\n                s[i] = (byte)i;\n            }\n            for (int i = 0, j = 0; i < 256; i++)\n            {
        {\n            for (int n = 0; n < length; n++)\n            {\n                byte b = data[n];\n                ctx.index1 = (ctx.index1 + 1) & 255;\n                ctx.index2 = (ctx.index2 + s[ctx.index1]) & 255;\n                Swap(s, ctx.index1, ctx.index2);\n                data[n] = (byte)(b ^ s[(s[ctx.index1] + s[ctx.index2]) & 255]);\n            }\n        }
            }\n        }\n        private static void Swap(byte[] s, int i, int j)\n        {\n            byte c = s[i];\n            s[i] = s[j];\n            s[j] = c;\n        }\n    }\n}
        // return path to store temporary files\n        public static string GetTempPath()\n        {\n            if (_tempPath == null)\n            {\n                try\n                {\n                    Directory.CreateDirectory(Path.Combine(Application.StartupPath, "ss_win_temp"));\n                    // don't use "/", it will fail when we call explorer /select xxx/ss_win_temp\xxx.log\n                    _tempPath = Path.Combine(Application.StartupPath, "ss_win_temp");\n                }
