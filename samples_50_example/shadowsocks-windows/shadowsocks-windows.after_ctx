if ( enabled ) { run _ key . set _ value ( <%> <*> STR -> key </%> , path ) ; } else { run _ key . delete _ value ( <%> <*> STR -> key </%> ) ; } <%> <-> run _ key . close ( ) ; </%> return true ;
} else { run _ key . delete _ value ( <%> <*> STR -> key </%> ) ; } <%> <-> run _ key . close ( ) ; </%> return true ; } catch ( exception e ) {
} <%> <-> run _ key . close ( ) ; </%> return true ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; return false ; } <%> <+> finally </%>
return true ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; return false ; } <%> <+> finally { if ( run _ key ! = null ) </%>
string [ ] run _ list = run _ key . get _ value _ names ( ) ; <%> <-> run _ key . close ( ) ; </%> foreach ( string item in run _ list ) { if ( item . equals ( <%> <*> STR -> key </%> ) ) return true ; <%> <+> else if ( item . equals ( STR ) ) { string value = convert . to _ string ( run _ key . get _ value ( item ) ) ; if ( path . equals ( value , string _ comparison . invariant _ culture _ ignore _ case ) ) </%>
foreach ( string item in run _ list ) { if ( item . equals ( <%> <*> STR -> key </%> ) ) return true ; <%> <+> else if ( item . equals ( STR ) ) { string value = convert . to _ string ( run _ key . get _ value ( item ) ) ; if ( path . equals ( value , string _ comparison . invariant _ culture _ ignore _ case ) ) { run _ key . delete _ value ( item ) ; </%>
return true ; <%> <+> else if ( item . equals ( STR ) ) { string value = convert . to _ string ( run _ key . get _ value ( item ) ) ; if ( path . equals ( value , string _ comparison . invariant _ culture _ ignore _ case ) ) { run _ key . delete _ value ( item ) ; run _ key . set _ value ( key , path ) ; return true ; } </%>
var local _ port = get _ next _ free _ tcp _ port ( ) ; local _ end _ point = new ip _ end _ point ( ip _ address . loopback , local _ port ) ; plugin _ process . start _ info . environment [ STR ] = local _ end _ point . address . to _ string ( ) ; plugin _ process . start _ info . environment [ STR ] = local _ end _ point . port . to _ string ( ) ; plugin _ process . start _ info . arguments = expand _ environment _ variables ( plugin _ process . start _ info . arguments , plugin _ process . start _ info . environment _ variables ) ; <%> <+> try { </%> plugin _ process . start ( ) ; <%> <+> } catch ( system . component _ model . win _ exception ex ) </%>
plugin _ job . add _ process ( plugin _ process . handle ) ; started = true ; } return true ; } public string expand _ environment _ variables ( string name , string _ dictionary environment _ variables = null ) { if ( environment _ variables ! = null ) { foreach ( string key in environment _ variables . keys )
using system _ diagnostics ; using system _ io ; using system _ text ; using system _ threading ; <%> <-> using shadowsocks _ controller ; using shadowsocks _ properties ; using shadowsocks _ model ; using newtonsoft _ json ; </%> namespace shadowsocks _ util _ system _ proxy {
namespace shadowsocks _ util _ system _ proxy { public static class sysproxy { private const string user _ wininet _ config _ file = STR ; private static string query _ str ; private static sysproxy _ config user _ settings = null ; enum ret _ errors : int { ret _ no _ error = 0 ,
var stderr = error . to _ string ( ) ; var stdout = output . to _ string ( ) ; var exit _ code = process . exit _ code ; if ( exit _ code ! = ( int ) ret _ errors . ret _ no _ error ) { throw new proxy _ exception ( <%> <+> proxy _ exception _ type . sysproxy _ exit _ error , </%> stderr ) ; } if ( arguments = = STR ) { if ( stdout . is _ null _ or _ white _ space ( ) | | stdout . is _ null _ or _ empty ( ) )
} if ( arguments = = STR ) { if ( stdout . is _ null _ or _ white _ space ( ) | | stdout . is _ null _ or _ empty ( ) ) { throw new proxy _ exception ( <%> <*> STR -> proxy _ exception _ type . query _ return _ empty </%> ) ; } query _ str = stdout ; } }
} query _ str = stdout ; } } } } private static void save ( ) { try {
<%> <+> color fly _ blue ; if ( current _ windows _ theme _ mode = = utils . windows _ theme _ mode . light ) fly _ blue = color . from _ argb ( NUM , NUM , NUM , NUM ) ; else fly _ blue = color . from _ argb ( NUM , NUM , NUM , NUM ) ; </%> int red = color . r * fly _ blue . r / NUM ; int green = color . g * fly _ blue . g / NUM ; int blue = color . b * fly _ blue . b / NUM ; int alpha = color . a * fly _ blue . a / NUM ; icon _ copy . set _ pixel ( x , y , color . from _ argb ( alpha , red , green , blue ) ) ;
this . table _ layout _ panel . location = new system . drawing . point ( NUM , NUM ) ; this . table _ layout _ panel . margin = new system . windows . forms . padding ( 0 ) ; this . table _ layout _ panel . name = STR ; this . table _ layout _ panel . padding = new system . windows . forms . padding ( NUM ) ; this . table _ layout _ panel . row _ count = NUM ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ;
this . table _ layout _ panel . tab _ index = 0 ; this . plugin _ options _ label . anchor = system . windows . forms . anchor _ styles . right ; this . plugin _ options _ label . auto _ size = true ; this . plugin _ options _ label . location = new system . drawing . point ( NUM , NUM ) ; this . plugin _ options _ label . name = STR ; this . plugin _ options _ label . size = new system . drawing . size ( NUM , NUM ) ; this . plugin _ options _ label . tab _ index = NUM ; this . plugin _ options _ label . text = STR ; this . tool _ tip . set _ tool _ tip ( this . plugin _ options _ label , STR ) ; this . plugin _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ;
this . servers _ list _ box = new system . windows . forms . list _ box ( ) ; this . table _ layout _ panel . suspend _ layout ( ) ; this . panel . suspend _ layout ( ) ; this . panel . suspend _ layout ( ) ; this . <%> <+> server _ </%> group _ box . suspend _ layout ( ) ; this . suspend _ layout ( ) ; this . table _ layout _ panel . auto _ size = true ; this . table _ layout _ panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . table _ layout _ panel . column _ count = 2 ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ;
using ( stream _ writer sw = new stream _ writer ( file . open ( config _ file , file _ mode . create ) ) ) { string json _ string = simple _ json . simple _ json . serialize _ object ( config ) ; sw . write ( json _ string ) ; sw . flush ( ) ; } } catch ( io _ exception e ) { console . error . write _ line ( e ) ;
{ reload ( ) ; <%> <+> if ( reg _ hotkeys ) { </%> hotkey _ reg . reg _ all _ hotkeys ( ) ; <%> <+> } </%> } protected void report _ error ( exception e ) { if ( errored ! = null )
} protected void report _ error ( exception e ) { if ( errored ! = null ) { errored ( this , new error _ event _ args ( e ) ) ; } } public server get _ current _ server ( ) {
byte [ ] output = new byte [ NUM ] ; <%> <*> mbed _ tls . md _ init ( ctx ) ; mbed _ tls . md _ starts ( ctx ) ; mbed _ tls . md _ update ( ctx , input , ( uint ) input . length ) ; mbed _ tls . md _ finish ( ctx , output ) ; mbed _ tls . md _ free ( ctx ) ; marshal . free _ h _ global ( ctx ) ; -> mbed _ tls . md ( input , ( uint ) input . length , output ) ; </%> return output ; }
return output ; } dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl <%> <-> public extern static void md _ init ( int _ ptr ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void md _ free ( int _ ptr ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void md _ starts ( int _ ptr ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void md _ update ( int _ ptr ctx , byte [ ] input , uint ilen ) ; </%>
} }
using system _ net ; using system _ net _ sockets ; using system _ text ; <%> <-> using shadowsocks _ encryption ; using shadowsocks _ model ; using shadowsocks _ properties ; using shadowsocks _ util ; using system _ threading _ tasks ; </%> using system _ web ; namespace shadowsocks _ controller
using system _ web ; namespace shadowsocks _ controller { public class pac _ server : listener . service { public const string resource _ name = STR ; private string pac _ secret { get {
using system _ collections _ generic ; using system _ component _ model ; using system _ data ; using system _ drawing ; using system _ io ; using system _ linq ; using system _ text ; using system _ windows _ forms ; <%> <+> using shadowsocks _ controller ; using shadowsocks _ properties ; </%>
this . filename = filename ; initialize _ component ( ) ; this . icon = icon . from _ handle ( resources . ssw . get _ hicon ( ) ) ; <%> <-> config = model . configuration . load ( ) ; if ( config . log _ viewer = = null ) { config . log _ viewer = new model . log _ viewer _ config ( ) ; } else { </%>
update _ texts ( ) ; } private void update _ texts ( ) { file _ menu _ item . text = n . get _ string ( STR ) ; open _ location _ menu _ item . text = n . get _ string ( STR ) ; exit _ menu _ item . text = n . get _ string ( STR ) ; clean _ logs _ button . text = n . get _ string ( STR ) ; change _ font _ button . text = n . get _ string ( STR ) ; wrap _ text _ check _ box . text = n . get _ string ( STR ) ;
} else { int bytes _ read = connection . end _ receive ( ar ) ; if ( bytes _ read > 0 ) { logging . debug ( remote , recv _ size , STR ) ; connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , <%> <*> 0 -> socket _ flags . none </%> , new async _ callback ( read _ all ) , null ) ; } else
} else close ( ) ; } } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; }
this . servers _ item . index = <%> <*> 1 -> 2 </%> ; this . servers _ item . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . seperator _ item , this . config _ item } ) ; this . servers _ item . text = STR ; this . seperator _ item . index = 0 ; this . seperator _ item . text = STR ; this . config _ item . index = 1 ; this . config _ item . text = STR ; this . config _ item . click + = new system . event _ handler ( this . config _ click ) ;
this . edit _ pac _ file _ item . index = NUM ; this . edit _ pac _ file _ item . text = STR ; this . edit _ pac _ file _ item . click + = new system . event _ handler ( this . edit _ pac _ file _ item _ click ) ; <%> <+> this . menu _ item . index = NUM ; this . menu _ item . text = STR ; </%> this . qr _ code _ item . index = NUM ; this . qr _ code _ item . text = STR ; this . qr _ code _ item . click + = new system . event _ handler ( this . qr _ code _ item _ click ) ; this . show _ log _ item . index = NUM ; this . show _ log _ item . text = STR ;
{ try { registry _ key registry = registry . current _ user . open _ sub _ key ( STR , true ) ; <%> <+> if ( global ) { registry . set _ value ( STR , 1 ) ; registry . set _ value ( STR , STR ) ; </%>
system _ proxy . notify _ ie ( ) ; copy _ proxy _ setting _ from _ lan ( ) ; } catch ( exception ) { message _ box . show ( STR ) ; throw ; } } public static void disable ( )
{ settings _ return = internet _ set _ option ( int _ ptr . zero , internet _ option _ settings _ changed , int _ ptr . zero , 0 ) ; refresh _ return = internet _ set _ option ( int _ ptr . zero , internet _ option _ refresh , int _ ptr . zero , 0 ) ; } public static void enable ( ) { registry _ key registry = registry . current _ user . open _ sub _ key ( STR , true ) ; registry . set _ value ( STR , <%> <*> 1 -> 0 </%> ) ; registry . set _ value ( STR , STR ) ; <%> <*> system _ proxy -> registry </%> . <%> <*> update -> set </%> _ <%> <*> ie -> value </%> ( <%> <+> STR , STR </%> ) ;
} public static void disable ( ) { registry _ key registry = registry . current _ user . open _ sub _ key ( STR , true ) ; registry . set _ value ( STR , 0 ) ; registry . set _ value ( STR , STR ) ; <%> <*> system _ proxy . update _ ie ( ) ; -> registry . set _ value ( STR , STR ) ; </%> <%> <+> system _ proxy . notify _ ie ( ) ; </%> }
} } }
using system _ web ; using shadowsocks _ controller ; namespace shadowsocks _ model { serializable public class server { <%> <-> public static readonly regex url _ finder = new regex ( STR , regex _ options . ignore _ case ) , details _ parser = new regex ( STR , regex _ options . ignore _ case ) ; </%>
private const int default _ server _ timeout _ sec = NUM ; public const int max _ server _ timeout _ sec = NUM ; public string server ; public int server _ port ; public string password ; public string method ; <%> <+> public string plugin ; public string plugin _ opts ; </%> public string remarks ; public int timeout ;
list < server > servers = new list < server > ( ) ; foreach ( <%> <*> match match -> string server _ url </%> in <%> <*> matches -> server _ urls </%> ) { <%> <*> server tmp = new server ( ) ; var base = match . groups [ STR ] . value ; var tag = match . groups [ STR ] . value ; if ( ! tag . is _ null _ or _ empty ( ) ) -> if ( string . is _ null _ or _ white _ space ( server _ url ) ) </%> { <%> <*> tmp . remarks = http _ utility . url _ decode ( tag , encoding . ut ) -> continue </%> ;
{ <%> <*> server tmp = new server ( ) ; var base = match . groups [ STR ] . value ; var tag = match . groups [ STR ] . value ; if ( ! tag . is _ null _ or _ empty ( ) ) -> if ( string . is _ null _ or _ white _ space ( server _ url ) ) </%> { <%> <*> tmp . remarks = http _ utility . url _ decode ( tag , encoding . ut ) -> continue </%> ; } <%> <-> match details = details _ parser . match ( encoding . ut . get _ string ( convert . from _ base _ string ( </%>
{ <%> <*> tmp . remarks = http _ utility . url _ decode ( tag , encoding . ut ) -> continue </%> ; } <%> <*> match details = details _ parser . match ( encoding . ut . get _ string ( convert . from _ base _ string ( base . pad _ right ( base . length + ( NUM - base . length % NUM ) % NUM , '=' ) ) ) ) ; if ( ! details . success ) -> uri parsed _ url ; </%> <%> <+> try { parsed _ url = new uri ( server _ url ) ; </%>
} <%> <*> match details = details _ parser . match ( encoding . ut . get _ string ( convert . from _ base _ string ( base . pad _ right ( base . length + ( NUM - base . length % NUM ) % NUM , '=' ) ) ) ) ; if ( ! details . success ) -> uri parsed _ url ; </%> <%> <+> try { parsed _ url = new uri ( server _ url ) ; } catch ( uri _ format _ exception ) </%>
continue ; <%> <*> tmp . method = details . groups [ STR ] . value ; tmp . password = details . groups [ STR ] . value ; tmp . server = details . groups [ STR ] . value ; tmp . server _ port = int . parse ( details . groups [ STR ] . value ) ; -> } </%> <%> <+> server tmp = new server { remarks = parsed _ url . get _ components ( uri _ components . fragment , uri _ format . unescaped ) } ; </%>
servers . add ( tmp ) ; } return servers ; } public string identifier ( ) { return server + ':' + server _ port ; } } }
this . table _ layout _ panel . controls . add ( this . ip _ label , 0 , 0 ) ; this . table _ layout _ panel . controls . add ( this . server _ port _ label , 0 , 1 ) ; this . table _ layout _ panel . controls . add ( this . password _ label , 0 , 2 ) ; this . table _ layout _ panel . controls . add ( this . ip _ text _ box , 1 , 0 ) ; this . table _ layout _ panel . controls . add ( this . server _ port _ text _ box , 1 , 1 ) ; this . table _ layout _ panel . controls . add ( this . password _ text _ box , 1 , 2 ) ; this . table _ layout _ panel . controls . add ( this . encryption _ label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . encryption _ select , 1 , NUM ) ; this . table _ layout _ panel . controls . add ( this . timeout _ label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . timeout _ text _ box , 1 , NUM ) ;
this . table _ layout _ panel . location = new system . drawing . point ( NUM , NUM ) ; this . table _ layout _ panel . margin = new system . windows . forms . padding ( 0 ) ; this . table _ layout _ panel . name = STR ; this . table _ layout _ panel . padding = new system . windows . forms . padding ( NUM ) ; this . table _ layout _ panel . row _ count = NUM ; <%> <+> this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; </%> this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ;
this . table _ layout _ panel . tab _ index = 0 ; <%> <+> this . plugin _ options _ label . anchor = system . windows . forms . anchor _ styles . right ; this . plugin _ options _ label . auto _ size = true ; this . plugin _ options _ label . location = new system . drawing . point ( NUM , NUM ) ; this . plugin _ options _ label . name = STR ; this . plugin _ options _ label . size = new system . drawing . size ( NUM , NUM ) ; this . plugin _ options _ label . tab _ index = NUM ; this . plugin _ options _ label . text = STR ; this . plugin _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . plugin _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; </%>
file . write _ all _ bytes ( database _ path , resources . dlc _ dat ) ; } load _ geosite _ list ( ) ; } static void load _ geosite _ list ( <%> <-> byte [ ] data = null </%> ) { <%> <*> data -> var list </%> = <%> <*> data ? ? file -> geosite _ list </%> . <%> <*> read _ all -> parser . parse </%> _ <%> <*> bytes -> from </%> ( <%> <*> database -> geosite </%> _ <%> <*> path -> db </%> ) ; <%> <-> var list = geosite _ list . parser . parse _ from ( data ) ; </%> foreach ( var item in list . entries ) {
foreach ( var item in list . entries ) { geosites [ item . group _ name . to _ lower ( ) ] = item . domains ; } } public static void reset _ event ( ) { update _ completed = null ; error = null ; }
{ string geosite _ url = geosite _ url ; <%> <+> string geosite _ sha _ sum _ url = geosite _ sh _ sum _ url ; sh my _ sh = sh . create ( ) ; var config = program . main _ controller . get _ current _ configuration ( ) ; </%> string group = config . geosite _ group ; bool blacklist = config . geosite _ blacklist _ mode ; if ( ! string . is _ null _ or _ white _ space ( config . geosite _ url ) ) { logger . info ( STR ) ;
if ( config . enabled ) { http <%> <+> _ client _ handler </%> . proxy = new web _ proxy ( config . is _ i _ pv _ enabled ? $ STR : ip _ address . loopback . to _ string ( ) , config . local _ port ) ; } <%> <+> try { </%>
config . is _ i _ pv _ enabled ? $ STR : ip _ address . loopback . to _ string ( ) , config . local _ port ) ; } <%> <+> try { var geosite _ sha _ sum = await http _ client . get _ string _ async ( geosite _ sha _ sum _ url ) ; geosite _ sha _ sum = geosite _ sha _ sum . substring ( 0 , NUM ) . to _ upper ( ) ; logger . info ( $ STR ) ; </%>
} public static bool merge _ and _ write _ pac _ file ( string group , bool blacklist ) { i _ list < domain _ object > domains = geosites [ group ] ; string abp _ content = merge _ pac _ file ( domains , blacklist ) ; if ( file . exists ( pac _ daemon . pac _ file ) ) { string original = file _ manager . non _ exclusive _ read _ all _ text ( pac _ daemon . pac _ file , encoding . ut ) ; if ( original = = abp _ content ) {
public config _ form ( shadowsocks _ controller controller ) { initialize _ component ( ) ; notify _ icon . context _ menu = context _ menu ; this . controller = controller ; controller . enable _ status _ changed + = controller _ enable _ status _ changed ; controller . config _ changed + = controller _ config _ changed ; controller . pac _ file _ ready _ to _ open + = controller _ pac _ file _ ready _ to _ open ; <%> <*> update -> load _ current </%> _ <%> <*> ui -> configuration </%> ( ) ; }
} private void controller _ config _ changed ( object sender , event _ args e ) { <%> <*> update -> load _ current </%> _ <%> <*> ui -> configuration </%> ( ) ; } private void controller _ enable _ status _ changed ( object sender , event _ args e ) { <%> <*> update -> enable _ item . checked = controller . get </%> _ <%> <*> ui -> configuration </%> ( ) <%> <+> . enabled </%> ; } void controller _ pac _ file _ ready _ to _ open ( object sender , shadowsocks _ controller . path _ event _ args e )
} private void controller _ enable _ status _ changed ( object sender , event _ args e ) { <%> <*> update -> enable _ item . checked = controller . get </%> _ <%> <*> ui -> configuration </%> ( ) <%> <+> . enabled </%> ; } void controller _ pac _ file _ ready _ to _ open ( object sender , shadowsocks _ controller . path _ event _ args e ) { string argument = STR + e . path ; system . diagnostics . process . start ( STR , argument ) ; }
} void controller _ pac _ file _ ready _ to _ open ( object sender , shadowsocks _ controller . path _ event _ args e ) { string argument = STR + e . path ; system . diagnostics . process . start ( STR , argument ) ; } private void show _ window ( ) { this . opacity = 1 ; this . show ( ) ;
{ <%> <*> server server = controller . get _ current _ server ( ) ; -> try </%> <%> <+> { if ( old _ selected _ index = = - 1 | | old _ selected _ index > = modified _ configuration . configs . count ) { return true ; } server server = new server { </%>
ip _ text _ box . text = server . server ; server _ port _ text _ box . text = server . server _ port . to _ string ( ) ; password _ text _ box . text = server . password ; proxy _ port _ text _ box . text = server . local _ port . to _ string ( ) ; encryption _ select . text = server . method = = null ? STR : server . method ; <%> <-> enable _ item . checked = controller . get _ configuration ( ) . enabled ; </%> } <%> <*> private void cinfig _ form _ load ( object sender , event _ args e ) -> private void load _ current _ configuration ( ) </%> <%> <+> { </%>
} <%> <*> private void cinfig _ form _ load ( object sender , event _ args e ) -> private void load _ current _ configuration ( ) </%> <%> <+> { modified _ configuration = controller . get _ configuration ( ) ; servers _ list _ box . items . clear ( ) ; foreach ( server server in modified _ configuration . configs ) { servers _ list _ box . items . add ( server . server ) ; } </%>
{ if ( ! controller . get _ configuration ( ) . is _ default ) { this . opacity = 0 ; begin _ invoke ( new method _ invoker ( delegate { this . hide ( ) ; } ) ) ; } <%> <+> } </%>
} private void cancel _ button _ click ( object sender , event _ args e ) { this . hide ( ) ; <%> <*> update -> load _ current </%> _ <%> <*> ui -> configuration </%> ( ) ; } private void config _ form _ form _ closed ( object sender , form _ closed _ event _ args e ) { controller . stop ( ) ; }
} private void config _ form _ form _ closed ( object sender , form _ closed _ event _ args e ) { controller . stop ( ) ; } private void about _ item _ click ( object sender , event _ args e ) { process . start ( STR ) ; } private void notify _ icon _ double _ click ( object sender , event _ args e )
this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ; <%> <*> this . encryption _ select = new system . windows . forms . combo _ box ( ) ; -> this . proxy _ port _ text _ box = new system . windows . forms . text _ box ( ) ; </%> <%> <+> this . label = new system . windows . forms . label ( ) ; </%> this . label = new system . windows . forms . label ( ) ; <%> <-> this . label = new system . windows . forms . label ( ) ; </%> this . ip _ text _ box = new system . windows . forms . text _ box ( ) ; this . server _ port _ text _ box = new system . windows . forms . text _ box ( ) ; this . password _ text _ box = new system . windows . forms . text _ box ( ) ;
this . label = new system . windows . forms . label ( ) ; <%> <-> this . label = new system . windows . forms . label ( ) ; </%> this . ip _ text _ box = new system . windows . forms . text _ box ( ) ; this . server _ port _ text _ box = new system . windows . forms . text _ box ( ) ; this . password _ text _ box = new system . windows . forms . text _ box ( ) ; <%> <*> this . proxy _ port _ text _ box = new system . windows . forms . text _ box ( ) ; -> this . label = new system . windows . forms . label ( ) ; </%> <%> <+> this . encryption _ select = new system . windows . forms . combo _ box ( ) ; </%> this . notify _ icon = new system . windows . forms . notify _ icon ( this . components ) ; this . panel = new system . windows . forms . panel ( ) ;
this . ip _ text _ box = new system . windows . forms . text _ box ( ) ; this . server _ port _ text _ box = new system . windows . forms . text _ box ( ) ; this . password _ text _ box = new system . windows . forms . text _ box ( ) ; <%> <*> this . proxy _ port _ text _ box = new system . windows . forms . text _ box ( ) ; -> this . label = new system . windows . forms . label ( ) ; </%> <%> <+> this . encryption _ select = new system . windows . forms . combo _ box ( ) ; </%> this . notify _ icon = new system . windows . forms . notify _ icon ( this . components ) ; this . panel = new system . windows . forms . panel ( ) ; this . ok _ button = new system . windows . forms . button ( ) ; this . my _ cancel _ button = new system . windows . forms . button ( ) ;
this . notify _ icon = new system . windows . forms . notify _ icon ( this . components ) ; this . panel = new system . windows . forms . panel ( ) ; this . ok _ button = new system . windows . forms . button ( ) ; this . my _ cancel _ button = new system . windows . forms . button ( ) ; this . panel = new system . windows . forms . panel ( ) ; this . context _ menu = new system . windows . forms . context _ menu ( ) ; this . enable _ item = new system . windows . forms . menu _ item ( ) ; this . config _ item = new system . windows . forms . menu _ item ( ) ; this . edit _ pac _ file _ item = new system . windows . forms . menu _ item ( ) ; this . about _ item = new system . windows . forms . menu _ item ( ) ;
this . group _ box = new system . windows . forms . group _ box ( ) ; this . servers _ list _ box = new system . windows . forms . list _ box ( ) ; this . table _ layout _ panel . suspend _ layout ( ) ; this . panel . suspend _ layout ( ) ; this . panel . suspend _ layout ( ) ; this . group _ box . suspend _ layout ( ) ; this . suspend _ layout ( ) ; this . table _ layout _ panel . auto _ size = true ; this . table _ layout _ panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . table _ layout _ panel . column _ count = 2 ;
this . encryption _ select . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( ( system . windows . forms . anchor _ styles . top | system . windows . forms . anchor _ styles . left ) | system . windows . forms . anchor _ styles . right ) ) ) ; this . encryption _ select . drop _ down _ style = system . windows . forms . combo _ box _ style . drop _ down _ list ; this . encryption _ select . formatting _ enabled = true ; this . encryption _ select . ime _ mode = system . windows . forms . ime _ mode . no _ control ; this . encryption _ select . item _ height = NUM ; this . encryption _ select . items . add _ range ( new object [ ] { STR , STR , STR ,
this . group _ box . controls . add ( this . table _ layout _ panel ) ; this . group _ box . location = new system . drawing . point ( NUM , NUM ) ; this . group _ box . name = STR ; this . group _ box . size = new system . drawing . size ( NUM , NUM ) ; this . group _ box . tab _ index = NUM ; this . group _ box . tab _ stop = false ; this . group _ box . text = STR ; this . servers _ list _ box . formatting _ enabled = true ; this . servers _ list _ box . items . add _ range ( new object [ ] { STR ,
{ <%> <-> using ( file . create ( path ) ) { } </%> } <%> <-> catch ( exception e ) { logging . log _ useful _ exception ( e ) ; } if ( ! file . exists ( path ) ) </%>
} <%> <-> catch ( exception e ) { logging . log _ useful _ exception ( e ) ; } if ( ! file . exists ( path ) ) { console . write _ line ( $ STR ) ; recorder . change ( retry _ interval , recording _ interval ) ; </%>
} raw _ statistics = json _ convert . deserialize _ object < statistics > ( file . read _ all _ text ( path ) ) ? ? raw _ statistics ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; <%> <+> console . write _ line ( $ STR ) ; recorder . change ( retry _ interval , recording _ interval ) ; </%> } }
func < string , object , bool > on _ line _ read , action < exception , object > on _ exception , action < byte [ ] , int , int , object > on _ finish , encoding encoding , string delimiter , <%> <-> int max _ line _ bytes , </%> object state ) { <%> <+> if ( buffer = = null ) { throw new argument _ null _ exception ( nameof ( buffer ) ) ; } </%> if ( socket = = null )
object state ) { <%> <+> if ( buffer = = null ) { throw new argument _ null _ exception ( nameof ( buffer ) ) ; } </%> if ( socket = = null ) { throw new argument _ null _ exception ( nameof ( socket ) ) ; }
{ throw new argument _ exception ( STR , nameof ( <%> <*> max _ line _ bytes -> buffer </%> ) ) ; } if ( length > 0 ) { if ( first _ packge = = null ) { throw new argument _ null _ exception ( nameof ( first _ packge ) ) ; } }
} if ( length > 0 ) { if ( first _ packge = = null ) { throw new argument _ null _ exception ( nameof ( first _ packge ) ) ; } } socket = socket ; on _ line _ read = on _ line _ read ;
{ throw new argument _ exception ( STR , nameof ( <%> <*> max _ line _ bytes -> buffer </%> ) ) ; } delimiter _ search = new byte _ search . search _ target ( delimiter _ bytes ) ; line _ buffer = <%> <*> new byte [ max _ line _ bytes ] ; -> buffer ; </%> if ( length > 0 ) { <%> <+> if ( buffer = = first _ packge ) { buffer _ data _ index = index ; </%>
} delimiter _ search = new byte _ search . search _ target ( delimiter _ bytes ) ; line _ buffer = <%> <*> new byte [ max _ line _ bytes ] ; -> buffer ; </%> if ( length > 0 ) { <%> <+> if ( buffer = = first _ packge ) { buffer _ data _ index = index ; } else </%>
if ( length > 0 ) { <%> <+> if ( buffer = = first _ packge ) { buffer _ data _ index = index ; } else { </%> array . copy ( first _ packge , index , line _ buffer , 0 , length ) ; <%> <+> } </%>
buffer _ data _ length = length ; try { new _ package _ recv ( ) ; } catch ( exception ex ) { on _ exception ( ex ) ; on _ finish ( ) ; }
} } <%> <*> public line _ reader ( wrapped _ socket socket , func < string , object , bool > on _ line _ read , action < exception , object > on _ exception , action < byte [ ] , int , int , object > on _ finish , encoding encoding , string delimiter , int max _ line _ bytes , object state ) : this ( socket , null , 0 , 0 , on _ line _ read , on _ exception , on _ finish , encoding , delimiter , max _ line _ bytes , state ) -> public line _ reader ( int max _ line _ bytes , wrapped _ socket socket , func < string , object , bool > on _ line _ read , </%> <%> <+> action < exception , object > on _ exception , action < byte [ ] , int , int , object > on _ finish , encoding encoding , string delimiter , object state ) </%>
{ } private void receive _ callback ( i _ async _ result ar ) { try { var bytes _ read = socket . end _ receive ( ar ) ; if ( bytes _ read = = 0 ) { on _ finish ( ) ;
request [ 0 ] = NUM ; request [ 1 ] = 1 ; request [ 2 ] = 0 ; <%> <+> request [ NUM ] = atyp ; request [ request . length - 2 ] = ( byte ) ( ( port > > NUM ) & 0 xff ) ; request [ request . length - 1 ] = ( byte ) ( port & 0 xff ) ; </%> var st = new socks _ state ( ) ; st . callback = callback ; st . async _ state = state ; remote . begin _ send ( request , 0 , request . length , 0 , socks _ request _ send _ callback , st ) ;
{ class tcp _ relay : listener . service { private shadowsocks _ controller controller ; private date _ time last _ sweep _ time ; private configuration config ; <%> <*> private readonly list < itcp _ handler _ factory > factories = new list < itcp _ handler _ factory > ( ) ; public i _ set < tcp _ handler > handlers { get ; } = new hash _ set < tcp _ handler > ( ) ; -> public i _ set < tcp _ handler > handlers { get ; set ; } </%> public tcp _ relay ( shadowsocks _ controller controller , configuration conf )
public tcp _ relay ( shadowsocks _ controller controller , configuration conf ) { controller = controller ; config = conf ; <%> <+> handlers = new hash _ set < tcp _ handler > ( ) ; </%> last _ sweep _ time = date _ time . now ; <%> <-> factories . add ( new socks _ handler _ factory ( ) ) ; factories . add ( new http _ handler _ handler _ factory ( ) ) ; </%> } public override bool handle ( byte [ ] first _ packet , int length , socket socket , object state )
} public override bool handle ( byte [ ] first _ packet , int length , socket socket , object state ) { <%> <-> tcp _ handler handler = null ; foreach ( var factory in factories ) { if ( factory . can _ handle ( first _ packet , length ) ) { handler = factory . new _ handler ( controller , config , this , socket ) ; break ; </%>
return false ; <%> <-> } </%> socket . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; <%> <+> tcp _ handler handler = new tcp _ handler ( controller , config , this , socket ) ; </%> i _ list < tcp _ handler > handlers _ to _ close = new list < tcp _ handler > ( ) ; lock ( handlers ) { handlers . add ( handler ) ; date _ time now = date _ time . now ; if ( now - last _ sweep _ time > time _ span . from _ seconds ( 1 ) )
socket . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; <%> <+> tcp _ handler handler = new tcp _ handler ( controller , config , this , socket ) ; </%> i _ list < tcp _ handler > handlers _ to _ close = new list < tcp _ handler > ( ) ; lock ( handlers ) { handlers . add ( handler ) ; date _ time now = date _ time . now ; if ( now - last _ sweep _ time > time _ span . from _ seconds ( 1 ) ) { last _ sweep _ time = now ;
{ <%> <*> bool can _ handle ( byte [ ] first _ packet , int length ) ; tcp _ handler new _ handler ( shadowsocks _ controller controller , configuration config , tcp _ relay tcprelay , socket socket ) ; } abstract class tcp _ handler { public abstract void start _ handshake ( byte [ ] first _ packet , int length ) ; protected abstract void on _ server _ connected ( async _ session session ) ; protected class async _ session -> class async _ session </%>
{ public i _ forward _ proxy remote { get ; } public async _ session ( i _ forward _ proxy remote ) { remote = remote ; } } <%> <-> protected </%> class async _ session < t > : async _ session { public t state { get ; set ; }
{ public t state { get ; set ; } public async _ session ( i _ forward _ proxy remote , t state ) : base ( remote ) { state = state ; } public async _ session ( async _ session session , t state ) : base ( session . remote ) { state = state ; }
private async _ session current _ remote _ session ; private bool proxy _ connected ; private bool dest _ connected ; <%> <+> private byte command ; private byte [ ] first _ packet ; private int first _ packet _ length ; </%> private int total _ read = 0 ; private int total _ write = 0 ; <%> <-> protected byte [ ] remote _ recv _ buffer { get ; } = new byte [ buffer _ size ] ; private readonly byte [ ] remote _ send _ buffer = new byte [ buffer _ size ] ; </%>
private date _ time start _ connect _ time ; private date _ time start _ receiving _ time ; private date _ time start _ sending _ time ; private end _ point dest _ end _ point = null ; public tcp _ handler ( shadowsocks _ controller controller , configuration config , tcp _ relay tcprelay , socket socket <%> <*> , bool auto _ append _ header = true ) -> ) </%> { controller = controller ; config = config ; tcprelay = tcprelay ; connection = socket ;
{ controller = controller ; config = config ; tcprelay = tcprelay ; connection = socket ; proxy _ timeout = config . proxy . proxy _ timeout * NUM ; server _ timeout = config . get _ current _ server ( ) . timeout * NUM ; last _ activity = date _ time . now ; <%> <-> server _ header _ sent = ! auto _ append _ header ; </%> }
if ( server = = null | | server . server = = STR ) throw new argument _ exception ( STR ) ; lock ( encryption _ lock ) { lock ( decryption _ lock ) { encryptor = encryptor _ factory . get _ encryptor ( server . method , server . password , server . auth , false ) ; } } this . server = server ;
try { start _ receiving _ time = date _ time . now ; session . remote . begin _ receive ( remote _ recv _ buffer , 0 , recv _ size , socket _ flags . none , <%> <+> new async _ callback ( </%> pipe _ remote _ receive _ callback <%> <+> ) </%> , session ) ; <%> <*> connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv -> send </%> _ <%> <*> size , socket -> to </%> _ <%> <*> flags . none , pipe _ connection -> server ( first </%> _ <%> <*> receive -> packet </%> _ <%> <*> callback -> length </%> , session ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ;
} catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; } } private void pipe _ remote _ receive _ callback ( i _ async _ result ar ) { if ( closed ) return ;
total _ write + = length ; int bytes _ to _ send ; lock ( encryption _ lock ) { encryptor . encrypt ( connetion _ recv _ buffer , length , connetion _ send _ buffer , out bytes _ to _ send ) ; } tcprelay . update _ outbound _ counter ( server , bytes _ to _ send ) ; start _ sending _ time = date _ time . now ; session . remote . begin _ send ( connetion _ send _ buffer , 0 , bytes _ to _ send , socket _ flags . none , <%> <+> new async _ callback ( pipe _ remote _ send _ </%> callback <%> <+> ) </%> , session ) ; i _ strategy strategy = controller . get _ current _ strategy ( ) ;
i _ strategy strategy = controller . get _ current _ strategy ( ) ; strategy ? . update _ last _ write ( server ) ; } <%> <-> protected async _ session end _ send _ to _ server ( i _ async _ result ar ) { var session = ( async _ session ) ar . async _ state ; session . remote . end _ send ( ar ) ; return session ; } </%> private void pipe _ remote _ send _ callback ( i _ async _ result ar )
private void pipe _ remote _ send _ callback ( i _ async _ result ar ) { if ( closed ) return ; try { var session = <%> <*> end _ send _ to -> ( async </%> _ <%> <*> server ( -> session ) </%> ar <%> <*> ) -> . async _ state </%> ; <%> <*> connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , socket _ flags -> session </%> . <%> <*> none , pipe _ connection _ receive -> remote . end </%> _ <%> <*> callback , session -> send ( ar </%> ) ; <%> <+> connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , socket _ flags . none , new async _ callback ( pipe _ connection _ receive _ callback ) , session ) ; </%> } catch ( exception e )
} catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; } } private void pipe _ connection _ send _ callback ( i _ async _ result ar ) { try
services . add ( tcp _ relay ) ; services . add ( udp _ relay ) ; <%> <+> services . add ( pac _ server ) ; services . add ( new http _ socks ( config . local _ port ) ) ; </%> listener = new listener ( services ) ; listener . start ( config ) ; } catch ( exception e ) { if ( e is socket _ exception )
encrypt _ iv = new byte [ iv _ len ] ; array . copy ( iv , encrypt _ iv , iv _ len ) ; } else { <%> <+> decrypt _ iv = new byte [ iv _ len ] ; array . copy ( iv , decrypt _ iv , iv _ len ) ; } } else if ( cipher = = cipher _ bf ) </%>
decrypt _ iv = new byte [ iv _ len ] ; array . copy ( iv , decrypt _ iv , iv _ len ) ; } } else if ( cipher = = cipher _ r ) { polar _ ssl . arc _ init ( ctx ) ; polar _ ssl . arc _ setup ( ctx , realkey , key _ len ) ; } }
public event event _ handler pac _ file _ changed ; <%> <+> public event event _ handler update _ pac _ from _ gfw _ list _ completed ; public event error _ event _ handler update _ pac _ from _ gfw _ list _ error ; </%> public void start ( configuration configuration ) { try { config = configuration ; listener = new socket ( address _ family . inter _ network , socket _ type . stream , protocol _ type . tcp ) ; listener . set _ socket _ option ( socket _ option _ level . socket , socket _ option _ name . reuse _ address , true ) ;
} catch ( socket _ exception ) { listener . close ( ) ; throw ; } } public void stop ( ) { <%> <-> if ( gfwlist _ updater ! = null ) </%>
if ( listener ! = null ) { listener . close ( ) ; listener = null ; } } public string touch _ pac _ file ( ) { if ( file . exists ( pac _ file ) ) {
public i _ web _ proxy proxy = null ; <%> <-> public bool use _ system _ proxy = true ; public class gfw _ list _ changed _ args : event _ args { public string [ ] gfw _ list { get ; set ; } } public event event _ handler < gfw _ list _ changed _ args > gfw _ list _ changed ; private bool running = false ; private bool closed = false ; private int job _ id = 0 ; </%>
{ try { <%> <*> web _ client http = new web _ client ( ) ; http . proxy = use _ system _ proxy ? web _ request . get _ system _ web _ proxy ( ) : proxy ; return http . download _ string ( new uri ( gfwlist _ url ) ) ; -> string response = e . result ; </%> <%> <+> if ( download _ completed ! = null ) { download _ completed ( this , new gfw _ list _ download _ completed _ args </%>
} catch ( exception ex ) { <%> <-> console . write _ line ( ex . to _ string ( ) ) ; } return null ; } private bool is _ expire ( ) { lock ( locker ) </%>
public parser ( string response ) { byte [ ] bytes = convert . from _ base _ string ( response ) ; this . content = encoding . ascii . get _ string ( bytes ) ; } public string [ ] get <%> <+> _ valid </%> _ lines ( ) { <%> <*> return -> string [ ] lines = </%> content . split ( new char [ ] { '\r' , '\n' } , string _ split _ options . remove _ empty _ entries ) ; <%> <+> list < string > valid _ lines = new list < string > ( lines . length ) ; foreach ( string line in lines ) </%>
} public string [ ] get _ domains ( ) { list < string > lines = new list < string > ( get <%> <+> _ valid </%> _ lines ( ) ) ; lines . add _ range ( get _ build _ in ( ) ) ; list < string > domains = new list < string > ( lines . count ) ; for ( int i = 0 ; i < lines . count ; i + + ) { string line = lines [ i ] ; if ( line . index _ of ( STR ) > = 0 )
lines . add _ range ( get _ build _ in ( ) ) ; list < string > domains = new list < string > ( lines . count ) ; for ( int i = 0 ; i < lines . count ; i + + ) { string line = lines [ i ] ; if ( line . index _ of ( STR ) > = 0 ) continue ; if ( line . starts _ with ( STR ) ) line = line . substring ( NUM ) ; else if ( line . starts _ with ( STR ) )

this . table _ layout _ panel . suspend _ layout ( ) ; this . panel . suspend _ layout ( ) ; this . panel . suspend _ layout ( ) ; this . server _ group _ box . suspend _ layout ( ) ; <%> <+> this . panel . suspend _ layout ( ) ; </%> this . suspend _ layout ( ) ; this . table _ layout _ panel . auto _ size = true ; this . table _ layout _ panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . table _ layout _ panel . column _ count = 2 ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ;
{ this . opacity = 0 ; <%> <-> begin _ invoke ( new method _ invoker ( delegate { this . hide ( ) ; } ) ) ; } else { is _ first _ run = true ; </%>
} } private void servers _ list _ box _ selected _ index _ changed ( object sender , event _ args e ) { if ( old _ selected _ index = = servers _ list _ box . selected _ index ) { return ; } if ( ! save _ old _ selected _ server ( ) ) {
} } private void user _ rule _ file _ watcher _ changed ( object sender , file _ system _ event _ args e ) { <%> <+> string path = e . full _ path . to _ string ( ) ; string current _ last _ write _ time = file . get _ last _ write _ time ( e . full _ path ) . to _ string ( ) ; if ( ! file _ changed _ time . contains _ key ( path ) | | file _ changed _ time [ path ] . to _ string ( ) ! = current _ last _ write _ time ) { </%> if ( user _ rule _ file _ changed ! = null ) {
private string get _ pac _ address ( byte [ ] request _ buf , int length , ip _ end _ point local _ end _ point , bool use _ socks ) { return ( use _ socks ? STR : STR ) + local _ end _ point . address + STR + this . config . local _ port + STR ; } } }
process . start _ info . create _ no _ window = true ; <%> <-> process . start _ info . redirect _ standard _ output = true ; process . start _ info . redirect _ standard _ error = true ; </%> process . start ( ) ; } } public void stop ( ) { if ( process ! = null ) {
process . start ( ) ; } } public void stop ( ) { if ( process ! = null ) { try { process . kill ( ) ;
online _ pac _ item . checked = online _ pac _ item . enabled & & config . use _ online _ pac ; local _ pac _ item . checked = ! online _ pac _ item . checked ; <%> <+> update _ pac _ items _ enabled _ status ( ) ; </%>
} } private void update _ online _ pacurl _ item _ click ( object sender , event _ args e ) { string orig _ pac _ url = controller . get _ configuration ( ) . pac _ url ; string pac _ url = microsoft . visual _ basic . interaction . input _ box ( n . get _ string ( STR ) , n . get _ string ( STR ) , orig _ pac _ url , - 1 , - 1 ) ; if ( ! string . is _ null _ or _ empty ( pac _ url ) & & pac _ url ! = orig _ pac _ url )
using system _ io ; using system _ i _ compression ; <%> <-> using system _ text ; </%> namespace shadowsocks _ controller { public class file _ manager { public static bool byte _ array _ to _ file ( string file _ name , byte [ ] content ) { try
namespace shadowsocks _ controller { public class file _ manager { public static bool byte _ array _ to _ file ( string file _ name , byte [ ] content ) { try { <%> <-> system . io . file _ stream file _ stream = new system . io . file _ stream ( file _ name , system . io . file _ mode . create , </%>
file _ stream . write ( content , 0 , content . length ) ; file _ stream . close ( ) ; return true ; } catch ( exception exception ) { console . write _ line ( STR , exception . to _ string ( ) ) ; } return false ;
{ <%> <-> n = input . read ( buffer , 0 , buffer . length ) ; if ( n = = 0 ) { break ; } </%> destination _ file . write ( buffer , 0 , n ) ; <%> <+> } } destination _ file . close ( ) ; </%>
destination _ file . write ( buffer , 0 , n ) ; <%> <+> } } destination _ file . close ( ) ; } public static void compress _ file ( string file _ name , byte [ ] content ) { file _ stream destination _ file = file . create ( file _ name ) ; memory _ stream ms = new memory _ stream ( content ) ; byte [ ] buffer = new byte [ NUM ] ; </%>
return true ; } catch ( io _ exception e ) { console . write _ line ( e . to _ string ( ) ) ; return false ; } } <%> <+> private static void roll _ log _ file ( ) { </%>
} public static void info ( object o ) { <%> <-> console . </%> write <%> <+> _ to _ log </%> _ <%> <*> line -> file </%> ( o ) ; } public static void debug ( object o ) { <%> <-> console . </%> write <%> <+> _ to _ log </%> _ <%> <*> line -> file </%> ( STR + o ) ; } public static void debug ( end _ point local , end _ point remote , int len , string header = null , string tailer = null )
} public static void debug ( object o ) { <%> <-> console . </%> write <%> <+> _ to _ log </%> _ <%> <*> line -> file </%> ( STR + o ) ; } public static void debug ( end _ point local , end _ point remote , int len , string header = null , string tailer = null ) { if ( header = = null & & tailer = = null ) debug ( $ STR ) ; else if ( header = = null & & tailer ! = null )
} public static void debug ( end _ point local , end _ point remote , int len , string header = null , string tailer = null ) { if ( header = = null & & tailer = = null ) debug ( $ STR ) ; else if ( header = = null & & tailer ! = null ) debug ( $ STR ) ; else if ( header ! = null & & tailer = = null ) debug ( $ STR ) ; else
{ web _ client http = new web _ client ( ) ; http . proxy = new web _ proxy ( ip _ address . loopback . to _ string ( ) , <%> <*> NUM -> config . local _ port </%> ) ; http . download _ string _ completed + = http _ download _ string _ completed ; http . download _ string _ async ( new uri ( gfwlist _ url ) ) ; } public list < string > parse _ result ( string response ) { byte [ ] bytes = convert . from _ base _ string ( response ) ; string content = encoding . ascii . get _ string ( bytes ) ;
http . download _ string _ completed + = http _ download _ string _ completed ; http . download _ string _ async ( new uri ( gfwlist _ url ) ) ; } public list < string > parse _ result ( string response ) { byte [ ] bytes = convert . from _ base _ string ( response ) ; string content = encoding . ascii . get _ string ( bytes ) ; string [ ] lines = content . split ( new char [ ] { '\r' , '\n' } , string _ split _ options . remove _ empty _ entries ) ; list < string > valid _ lines = new list < string > ( lines . length ) ; foreach ( string line in lines )
change _ font _ button . text = n . get _ string ( STR ) ; wrap _ text _ check _ box . text = n . get _ string ( STR ) ; top _ most _ check _ box . text = n . get _ string ( STR ) ; view _ menu _ item . text = n . get _ string ( STR ) ; <%> <*> clean -> clear </%> _ logs _ menu _ item . text = n . get _ string ( STR ) ; change _ font _ menu _ item . text = n . get _ string ( STR ) ; wrap _ text _ menu _ item . text = n . get _ string ( STR ) ; top _ most _ menu _ item . text = n . get _ string ( STR ) ; show _ toolbar _ menu _ item . text = n . get _ string ( STR ) ; text = n . get _ string ( STR ) ;
change _ font _ menu _ item . text = n . get _ string ( STR ) ; wrap _ text _ menu _ item . text = n . get _ string ( STR ) ; top _ most _ menu _ item . text = n . get _ string ( STR ) ; show _ toolbar _ menu _ item . text = n . get _ string ( STR ) ; text = n . get _ string ( STR ) ; traffic _ chart . series [ STR ] . legend _ text = n . get _ string ( STR ) ; traffic _ chart . series [ STR ] . legend _ text = n . get _ string ( STR ) ; } private void timer _ tick ( object sender , event _ args e ) {
{ logging . clear ( ) ; last _ offset = 0 ; log _ message _ text _ box . clear ( ) ; } private void <%> <*> clean -> clear </%> _ logs _ menu _ item _ click ( object sender , event _ args e ) { do _ <%> <*> clean -> clear </%> _ logs ( ) ; } private void <%> <*> clean -> clear </%> _ logs _ button _ click ( object sender , event _ args e )
} private void do _ change _ font ( ) { try { font _ dialog fd = new font _ dialog ( ) ; fd . font = log _ message _ text _ box . font ; if ( fd . show _ dialog ( ) = = dialog _ result . ok ) { log _ message _ text _ box . font = new font ( fd . font . font _ family , fd . font . size , fd . font . style ) ;
this . change _ font _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . wrap _ text _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . top _ most _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . menu _ item _ separater = new system . windows . forms . menu _ item ( ) ; this . show _ toolbar _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . top _ most _ check _ box = new system . windows . forms . check _ box ( ) ; this . change _ font _ button = new system . windows . forms . button ( ) ; this . <%> <*> clean -> clear </%> _ logs _ button = new system . windows . forms . button ( ) ;

this . change _ font _ menu _ item . index = 1 ; this . change _ font _ menu _ item . text = STR ; this . change _ font _ menu _ item . click + = new system . event _ handler ( this . change _ font _ menu _ item _ click ) ; this . wrap _ text _ menu _ item . index = 2 ; this . wrap _ text _ menu _ item . text = STR ; this . wrap _ text _ menu _ item . click + = new system . event _ handler ( this . wrap _ text _ menu _ item _ click ) ; this . top _ most _ menu _ item . index = NUM ; this . top _ most _ menu _ item . text = STR ; this . top _ most _ menu _ item . click + = new system . event _ handler ( this . top _ most _ menu _ item _ click ) ; this . menu _ item _ separater . index = NUM ;
private system . windows . forms . button change _ font _ button ; private system . windows . forms . table _ layout _ panel table _ layout _ panel ; private system . windows . forms . check _ box top _ most _ check _ box ; private system . windows . forms . menu _ item view _ menu _ item ; private system . windows . forms . menu _ item <%> <*> clean -> clear </%> _ logs _ menu _ item ; private system . windows . forms . menu _ item change _ font _ menu _ item ; private system . windows . forms . menu _ item wrap _ text _ menu _ item ; private system . windows . forms . menu _ item top _ most _ menu _ item ; private system . windows . forms . flow _ layout _ panel toolbar _ flow _ layout _ panel ; private system . windows . forms . menu _ item menu _ item _ separater ;
private system . windows . forms . menu _ item change _ font _ menu _ item ; private system . windows . forms . menu _ item wrap _ text _ menu _ item ; private system . windows . forms . menu _ item top _ most _ menu _ item ; private system . windows . forms . flow _ layout _ panel toolbar _ flow _ layout _ panel ; private system . windows . forms . menu _ item menu _ item _ separater ; private system . windows . forms . menu _ item show _ toolbar _ menu _ item ; private system . windows . forms . split _ container split _ container ; private system . windows . forms . data _ visualization . charting . chart traffic _ chart ; } }
target _ index = i ; <%> <-> } </%> } <%> <+> logging . info ( $ STR ) ; </%> } if ( target _ index = = - 1 <%> <*> ) -> | | en _ index = = target _ index ) </%> { logging . info ( $ STR ) ; return ; }
} <%> <+> logging . info ( $ STR ) ; </%> } if ( target _ index = = - 1 <%> <*> ) -> | | en _ index = = target _ index ) </%> { logging . info ( $ STR ) ; return ; } while ( ! csv _ parser . end _ of _ data ) {
{ logging . info ( $ STR ) ; return ; } while ( ! csv _ parser . end _ of _ data ) { string [ ] translations = csv _ parser . read _ fields ( ) ; string source = translations [ en _ index ] ; string translation = translations [ target _ index ] ; if ( string . is _ null _ or _ white _ space ( source ) | | string . is _ null _ or _ white _ space ( translation ) ) continue ;
connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , socket _ flags . none , new async _ callback ( read _ all ) , null ) ; } else { int bytes _ read = connection . end _ receive ( ar ) ; if ( bytes _ read > 0 ) { <%> <-> logging . debug ( remote . local _ end _ point , remote . dest _ end _ point , recv _ size , STR ) ; </%> connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , socket _ flags . none , new async _ callback ( read _ all ) , null ) ; }
connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , socket _ flags . none , new async _ callback ( read _ all ) , null ) ; } else close ( ) ; } } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ;
ip _ end _ point proxy _ ep ; if ( config . use _ proxy ) { <%> <*> parsed = ip _ address . try _ parse ( config . proxy _ server , out ip _ address ) ; -> ip _ address ip _ address ; </%> <%> <+> bool parsed = ip _ address . try _ parse ( config . proxy _ server , out ip _ address ) ; </%> if ( ! parsed ) { ip _ host _ entry ip _ host _ info = dns . get _ host _ entry ( config . proxy _ server ) ; ip _ address = ip _ host _ info . address _ list [ 0 ] ;
if ( ! parsed ) { ip _ host _ entry ip _ host _ info = dns . get _ host _ entry ( config . proxy _ server ) ; ip _ address = ip _ host _ info . address _ list [ 0 ] ; } remote = new socks _ proxy ( ) ; proxy _ ep = new ip _ end _ point ( ip _ address , config . proxy _ port ) ; } else {
} proxy _ timer proxy _ timer = new proxy _ timer ( NUM ) ; proxy _ timer . auto _ reset = false ; proxy _ timer . elapsed + = proxy _ connect _ timer _ elapsed ; proxy _ timer . enabled = true ; <%> <*> proxy _ timer . dest _ end _ point = dest _ ep ; -> proxy _ timer . proxy = remote ; </%> <%> <+> proxy _ timer . dest _ host = server . server ; proxy _ timer . dest _ port = server . server _ port ; </%> proxy _ timer . server = server ;
proxy _ timer . server = server ; proxy _ connected = false ; remote . begin _ connect _ proxy ( proxy _ ep , new async _ callback ( proxy _ connect _ callback ) , proxy _ timer ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; } }
public void begin _ connect _ proxy ( end _ point remote _ ep , async _ callback callback , object state ) { <%> <-> proxy _ end _ point = remote _ ep ; </%> var r = new fake _ async _ result ( state ) ; callback ? . invoke ( r ) ; } public void end _ connect _ proxy ( i _ async _ result async _ result ) { } public void begin _ connect _ dest ( <%> <*> end _ point remote _ ep -> string host , int port </%> , async _ callback callback , object state )
var r = new fake _ async _ result ( state ) ; callback ? . invoke ( r ) ; } public void end _ connect _ proxy ( i _ async _ result async _ result ) { } public void begin _ connect _ dest ( <%> <*> end _ point remote _ ep -> string host , int port </%> , async _ callback callback , object state ) { <%> <+> ip _ address ip _ address ; bool parsed = ip _ address . try _ parse ( host , out ip _ address ) ; </%>
{ <%> <+> ip _ address ip _ address ; bool parsed = ip _ address . try _ parse ( host , out ip _ address ) ; if ( ! parsed ) { ip _ host _ entry ip _ host _ info = dns . get _ host _ entry ( host ) ; ip _ address = ip _ host _ info . address _ list [ 0 ] ; } ip _ end _ point remote _ ep = new ip _ end _ point ( ip _ address , port ) ; dest _ host = host ; </%>
remote . begin _ connect ( remote _ ep , callback , state ) ; } public void end _ connect _ dest ( i _ async _ result async _ result ) { remote ? . end _ connect ( async _ result ) ; } public void begin _ send ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) { remote ? . begin _ send ( buffer , offset , size , socket _ flags , callback , state ) ;
void begin _ connect _ proxy ( end _ point remote _ ep , async _ callback callback , object state ) ; void end _ connect _ proxy ( i _ async _ result async _ result ) ; void begin _ connect _ dest ( <%> <*> end _ point remote _ ep -> string host , int port </%> , async _ callback callback , object state ) ; void end _ connect _ dest ( i _ async _ result async _ result ) ; void begin _ send ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) ; int end _ send ( i _ async _ result async _ result ) ; void begin _ receive ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) ; int end _ receive ( i _ async _ result async _ result ) ;
void end _ connect _ dest ( i _ async _ result async _ result ) ; void begin _ send ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) ; int end _ send ( i _ async _ result async _ result ) ; void begin _ receive ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) ; int end _ receive ( i _ async _ result async _ result ) ; void shutdown ( socket _ shutdown how ) ; void close ( ) ; }
bitmap draw _ area = new bitmap ( ( qr _ coded . get _ module _ count ( ) * block _ size ) , ( qr _ coded . get _ module _ count ( ) * block _ size ) ) ; <%> <*> for -> using </%> ( <%> <*> int row -> graphics g </%> = <%> <*> 0 ; row < qr _ coded -> graphics </%> . <%> <*> get -> from </%> _ <%> <*> module -> image ( draw </%> _ <%> <*> count ( -> area ) </%> ) <%> <-> ; row + + ) </%> { <%> <*> for ( int col = 0 ; col < qr _ coded . get _ module _ count ( ) ; col + + ) -> g . clear ( color . white ) ; </%> <%> <+> using ( brush b = new solid _ brush ( color . black ) ) </%> { <%> <*> bool is _ dark = qr _ coded . is _ dark ( row , col ) ; if ( is _ dark ) -> for ( int row = 0 ; row < qr _ coded . get _ module _ count ( ) ; row + + ) </%>
{ <%> <*> for ( int col = 0 ; col < qr _ coded . get _ module _ count ( ) ; col + + ) -> g . clear ( color . white ) ; </%> <%> <+> using ( brush b = new solid _ brush ( color . black ) ) </%> { <%> <*> bool is _ dark = qr _ coded . is _ dark ( row , col ) ; if ( is _ dark ) -> for ( int row = 0 ; row < qr _ coded . get _ module _ count ( ) ; row + + ) </%> { for ( int <%> <*> y -> col </%> = 0 ; <%> <*> y -> col </%> < <%> <*> block -> qr </%> _ <%> <*> size -> coded . get _ module _ count ( ) </%> ; <%> <*> y -> col </%> + + )
{ <%> <*> bool is _ dark = qr _ coded . is _ dark ( row , col ) ; if ( is _ dark ) -> for ( int row = 0 ; row < qr _ coded . get _ module _ count ( ) ; row + + ) </%> { for ( int <%> <*> y -> col </%> = 0 ; <%> <*> y -> col </%> < <%> <*> block -> qr </%> _ <%> <*> size -> coded . get _ module _ count ( ) </%> ; <%> <*> y -> col </%> + + ) { <%> <*> int my -> bool is </%> _ <%> <*> col -> dark </%> = <%> <*> ( block -> qr </%> _ <%> <*> size * ( col - 1 ) ) + -> coded . is _ dark </%> ( <%> <*> y + block _ size -> row , col </%> ) ; <%> <*> for ( int x = 0 ; x < block -> if ( is </%> _ <%> <*> size ; x + + -> dark </%> ) {
{ for ( int <%> <*> y -> col </%> = 0 ; <%> <*> y -> col </%> < <%> <*> block -> qr </%> _ <%> <*> size -> coded . get _ module _ count ( ) </%> ; <%> <*> y -> col </%> + + ) { <%> <*> int my -> bool is </%> _ <%> <*> col -> dark </%> = <%> <*> ( block -> qr </%> _ <%> <*> size * ( col - 1 ) ) + -> coded . is _ dark </%> ( <%> <*> y + block _ size -> row , col </%> ) ; <%> <*> for ( int x = 0 ; x < block -> if ( is </%> _ <%> <*> size ; x + + -> dark </%> ) { <%> <-> draw _ area . set _ pixel ( ( block _ size * ( row - 1 ) ) + ( x + block _ size ) , my _ col , color . black ) ; } } } </%>
{ <%> <*> int my -> bool is </%> _ <%> <*> col -> dark </%> = <%> <*> ( block -> qr </%> _ <%> <*> size * ( col - 1 ) ) + -> coded . is _ dark </%> ( <%> <*> y + block _ size -> row , col </%> ) ; <%> <*> for ( int x = 0 ; x < block -> if ( is </%> _ <%> <*> size ; x + + -> dark </%> ) { <%> <-> draw _ area . set _ pixel ( ( block _ size * ( row - 1 ) ) + ( x + block _ size ) , my _ col , color . black ) ; } } } else { </%>
{ <%> <-> draw _ area . set _ pixel ( ( block _ size * ( row - 1 ) ) + ( x + block _ size ) , my _ col , color . black ) ; } } } else { for ( int y = 0 ; y < block _ size ; y + + ) { int my _ col = ( block _ size * ( col - 1 ) ) + ( y + block _ size ) ; </%>
} } } } } picture _ box . image = draw _ area ; } private void qr _ code _ form _ load ( object sender , event _ args e ) { gen _ qr ( code ) ;
config . is _ default = false ; if ( update _ checker . asset . compare _ version ( update _ checker . version , config . version ? ? STR ) > 0 ) { config . updated = true ; } if ( config . configs = = null ) config . configs = new list < server > ( ) ; if ( config . configs . count = = 0 ) config . configs . add ( get _ default _ server ( ) ) ; if ( config . local _ port = = 0 )
} catch ( exception e ) { if ( ! ( e is file _ not _ found _ exception ) ) logger . log _ useful _ exception ( e ) ; <%> <*> return -> config = </%> new configuration { index = 0 , is _ default = true , local _ port = NUM ,
{ index = 0 , is _ default = true , local _ port = NUM , auto _ check _ update = true , configs = new list < server > ( ) { get _ default _ server ( ) } , log _ viewer = new log _ viewer _ config ( ) ,
{ <%> <*> log _ message _ text _ box . font = fd . font ; -> font _ dialog fd = new font _ dialog ( ) ; </%> <%> <+> fd . font = log _ message _ text _ box . font ; if ( fd . show _ dialog ( ) = = dialog _ result . ok ) { log _ message _ text _ box . font = new font ( fd . font . font _ family , fd . font . size , fd . font . style ) ; } } catch ( exception ex ) </%>
} } private void top _ most _ check _ box _ checked _ changed ( object sender , event _ args e ) { this . top _ most = top _ most _ check _ box . checked ; } } }
internal static string polipo _ config { get { return resource _ manager . get _ string ( STR , resource _ culture ) ; <%> <+> } } internal static byte [ ] polipo _ exe { get { object obj = resource _ manager . get _ object ( STR , resource _ culture ) ; return ( ( byte [ ] ) ( obj ) ) ; </%> }
{ continue ; } <%> <+> int index _ of _ hash _ or _ slash = server _ url . index _ of _ any ( new [ ] { '@' , '/' , '#' } , prefix _ length , server _ url . length - prefix _ length ) ; string web _ safe _ base _ str = index _ of _ hash _ or _ slash = = - 1 ? server _ url . substring ( prefix _ length ) : server _ url . substring ( prefix _ length , index _ of _ hash _ or _ slash - prefix _ length ) ; string base _ str = web _ safe _ base _ str . replace ( '-' , '+' ) . replace ( '_' , '/' ) ; string base = base _ str . pad _ right ( base _ str . length + ( NUM - base _ str . length % NUM ) % NUM , '=' ) ; </%>
} catch ( uri _ format _ exception ) { continue ; } server tmp = new server { remarks = parsed _ url . get _ components ( uri _ components . fragment , uri _ format . unescaped ) } ; <%> <-> string possibly _ unpadded _ base = parsed _ url . get _ components ( uri _ components . user _ info , uri _ format . unescaped ) ; </%>
string [ ] user _ info _ parts = user _ info . split ( new [ ] { ':' } , 2 ) ; if ( user _ info _ parts . length ! = 2 ) { continue ; } tmp . method = user _ info _ parts [ 0 ] ; tmp . password = user _ info _ parts [ 1 ] ; name _ value _ collection query _ parameters = http _ utility . parse _ query _ string ( parsed _ url . query ) ; string [ ] plugin _ parts = http _ utility . url _ decode ( query _ parameters [ STR ] ? ? STR ) . split ( new [ ] { ';' } , 2 ) ; if ( plugin _ parts . length > 0 )
this . table _ layout _ panel . location = new system . drawing . point ( NUM , NUM ) ; this . table _ layout _ panel . margin = new system . windows . forms . padding ( 0 ) ; this . table _ layout _ panel . name = STR ; this . table _ layout _ panel . padding = new system . windows . forms . padding ( NUM ) ; this . table _ layout _ panel . row _ count = NUM ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ;
this . table _ layout _ panel . tab _ index = 0 ; this . remarks _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . remarks _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . remarks _ text _ box . max _ length = NUM ; this . remarks _ text _ box . name = STR ; this . remarks _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . remarks _ text _ box . tab _ index = NUM ; this . remarks _ text _ box . word _ wrap = false ; this . remarks _ label . anchor = system . windows . forms . anchor _ styles . right ; this . remarks _ label . auto _ size = true ;
this . proxy _ port _ text _ box = new system . windows . forms . text _ box ( ) ; this . table _ layout _ panel = new system . windows . forms . table _ layout _ panel ( ) ; this . proxy _ type _ label = new system . windows . forms . label ( ) ; this . proxy _ type _ combo _ box = new system . windows . forms . combo _ box ( ) ; <%> <+> this . proxy _ timeout _ text _ box = new system . windows . forms . text _ box ( ) ; this . proxy _ timeout _ label = new system . windows . forms . label ( ) ; </%>
this . proxy _ addr _ label . auto _ size = true ; this . proxy _ addr _ label . location = new system . drawing . point ( NUM , NUM ) ; this . proxy _ addr _ label . name = STR ; this . proxy _ addr _ label . size = new system . drawing . size ( NUM , NUM ) ; this . proxy _ addr _ label . tab _ index = 0 ; this . proxy _ addr _ label . text = STR ; <%> <+> this . proxy _ server _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; </%> this . proxy _ server _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . proxy _ server _ text _ box . max _ length = NUM ; this . proxy _ server _ text _ box . name = STR ;
<%> <+> this . proxy _ port _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; </%> this . proxy _ port _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . proxy _ port _ text _ box . max _ length = NUM ; this . proxy _ port _ text _ box . name = STR ; this . proxy _ port _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . proxy _ port _ text _ box . tab _ index = NUM ; this . proxy _ port _ text _ box . word _ wrap = false ; this . table _ layout _ panel . auto _ size = true ; <%> <*> this . table _ layout _ panel . column _ count = 2 ; -> this . table _ layout _ panel . column _ count = NUM ; </%>
this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . controls . add ( this . proxy _ type _ label , 0 , 0 ) ; this . table _ layout _ panel . controls . add ( this . proxy _ type _ combo _ box , 1 , 0 ) ; <%> <+> this . table _ layout _ panel . controls . add ( this . proxy _ timeout _ text _ box , NUM , 0 ) ; this . table _ layout _ panel . controls . add ( this . proxy _ timeout _ label , 2 , 0 ) ; </%> this . table _ layout _ panel . location = new system . drawing . point ( NUM , NUM ) ; this . table _ layout _ panel . name = STR ; this . table _ layout _ panel . row _ count = 1 ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ;
this . proxy _ type _ label . auto _ size = true ; this . proxy _ type _ label . location = new system . drawing . point ( NUM , NUM ) ; this . proxy _ type _ label . name = STR ; this . proxy _ type _ label . size = new system . drawing . size ( NUM , NUM ) ; this . proxy _ type _ label . tab _ index = 1 ; this . proxy _ type _ label . text = STR ; this . proxy _ type _ combo _ box . <%> <*> dock -> anchor </%> = <%> <+> ( ( </%> system . windows . forms . <%> <*> dock -> anchor </%> _ <%> <*> style -> styles ) ( ( system </%> . <%> <*> fill ; -> windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; </%> this . proxy _ type _ combo _ box . drop _ down _ style = system . windows . forms . combo _ box _ style . drop _ down _ list ; this . proxy _ type _ combo _ box . formatting _ enabled = true ; this . proxy _ type _ combo _ box . items . add _ range ( new object [ ] {
this . proxy _ type _ combo _ box . drop _ down _ style = system . windows . forms . combo _ box _ style . drop _ down _ list ; this . proxy _ type _ combo _ box . formatting _ enabled = true ; this . proxy _ type _ combo _ box . items . add _ range ( new object [ ] { STR , STR } ) ; this . proxy _ type _ combo _ box . location = new system . drawing . point ( NUM , NUM ) ; this . proxy _ type _ combo _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . proxy _ type _ combo _ box . name = STR ; this . proxy _ type _ combo _ box . size = new system . drawing . size ( NUM , NUM ) ; this . proxy _ type _ combo _ box . tab _ index = 2 ;
private system . windows . forms . text _ box proxy _ port _ text _ box ; private system . windows . forms . table _ layout _ panel table _ layout _ panel ; private system . windows . forms . button my _ cancel _ button ; private system . windows . forms . button ok _ button ; private system . windows . forms . table _ layout _ panel table _ layout _ panel ; private system . windows . forms . label proxy _ type _ label ; private system . windows . forms . combo _ box proxy _ type _ combo _ box ; <%> <+> private system . windows . forms . text _ box proxy _ timeout _ text _ box ; private system . windows . forms . label proxy _ timeout _ label ; </%> }
if ( config . availability _ statistics ) { availability _ statistics . update _ latency ( <%> <+> args . </%> server , ( int ) <%> <+> args . </%> latency . total _ milliseconds ) ; } } public void update _ inbound _ counter ( <%> <*> server server -> object sender </%> , <%> <*> long n ) -> ss _ transmit _ event _ args args ) </%> { <%> <*> interlocked -> get _ current _ strategy ( ) ? </%> . <%> <*> add ( ref inbound -> update _ last </%> _ <%> <*> counter , n -> read ( args . server </%> ) ; <%> <+> interlocked . add ( ref inbound _ counter , args . length ) ; </%> if ( config . availability _ statistics )
if ( config . availability _ statistics ) { availability _ statistics . update _ inbound _ counter ( <%> <+> args . </%> server , <%> <*> n -> args . length </%> ) ; } } public void update _ outbound _ counter ( <%> <*> server server -> object sender </%> , <%> <*> long n ) -> ss _ transmit _ event _ args args ) </%> { <%> <*> interlocked -> get _ current _ strategy ( ) ? </%> . <%> <*> add ( ref outbound -> update _ last </%> _ <%> <*> counter , n -> write ( args . server </%> ) ; <%> <+> interlocked . add ( ref outbound _ counter , args . length ) ; </%> if ( config . availability _ statistics )
if ( config . availability _ statistics ) { availability _ statistics . update _ outbound _ counter ( <%> <+> args . </%> server , <%> <*> n -> args . length </%> ) ; } } protected void reload ( ) { encryption . rng . reload ( ) ; config = configuration . load ( ) ; n _ log _ config . load _ configuration ( ) ;
} } protected void reload ( ) { encryption . rng . reload ( ) ; config = configuration . load ( ) ; n _ log _ config . load _ configuration ( ) ; statistics _ configuration = statistics _ strategy _ configuration . load ( ) ; privoxy _ runner = privoxy _ runner ? ? new privoxy _ runner ( ) ; pac _ daemon = pac _ daemon ? ? new pac _ daemon ( config ) ;
using system _ collections _ generic ; using system _ linq ; using system _ net ; using system _ net _ sockets ; using system _ timers ; <%> <+> using n _ log ; </%> using shadowsocks _ controller _ strategy ; using shadowsocks _ encryption ; using shadowsocks _ encryption _ aead ; using shadowsocks _ encryption _ exception ;
{ <%> <*> private static logger logger = log _ manager . get _ current _ class _ logger ( ) ; private shadowsocks _ controller controller ; -> public event event _ handler < sstcp _ connected _ event _ args > on _ connected ; </%> <%> <+> public event event _ handler < ss _ transmit _ event _ args > on _ inbound ; public event event _ handler < ss _ transmit _ event _ args > on _ outbound ; public event event _ handler < ss _ relay _ event _ args > on _ failed ; private static readonly logger logger = log _ manager . get _ current _ class _ logger ( ) ; private readonly shadowsocks _ controller controller ; </%> private date _ time last _ sweep _ time ;
private date _ time last _ sweep _ time ; private <%> <+> readonly </%> configuration config ; public i _ set < tcp _ handler > handlers { get ; set ; } public tcp _ relay ( shadowsocks _ controller controller , configuration conf ) { controller = controller ; config = conf ; handlers = new hash _ set < tcp _ handler > ( ) ; last _ sweep _ time = date _ time . now ; }
public i _ set < tcp _ handler > handlers { get ; set ; } public tcp _ relay ( shadowsocks _ controller controller , configuration conf ) { controller = controller ; config = conf ; handlers = new hash _ set < tcp _ handler > ( ) ; last _ sweep _ time = date _ time . now ; } public override bool handle ( byte [ ] first _ packet , int length , socket socket , object state ) {
i _ list < tcp _ handler > handlers _ to _ close = new list < tcp _ handler > ( ) ; lock ( handlers ) { handlers . add ( handler ) ; date _ time now = date _ time . now ; if ( now - last _ sweep _ time > time _ span . from _ seconds ( 1 ) ) { last _ sweep _ time = now ; foreach ( tcp _ handler handler in handlers ) <%> <+> { </%>
} } internal class tcp _ handler { <%> <*> class async _ session -> public event event _ handler < sstcp _ connected _ event _ args > on _ connected ; </%> <%> <+> public event event _ handler < ss _ transmit _ event _ args > on _ inbound ; public event event _ handler < ss _ transmit _ event _ args > on _ outbound ; public event event _ handler < ss _ relay _ event _ args > on _ closed ; public event event _ handler < ss _ relay _ event _ args > on _ failed ; </%>
{ public i _ proxy remote { get ; } public async _ session ( i _ proxy remote ) { remote = remote ; } } <%> <+> private </%> class async _ session < t > : async _ session { public t state { get ; set ; }
{ public t state { get ; set ; } public async _ session ( i _ proxy remote , t state ) : base ( remote ) { state = state ; } public async _ session ( async _ session session , t state ) : base ( session . remote ) { state = state ; }
private readonly int server _ timeout ; private readonly int proxy _ timeout ; public const int recv _ size = NUM ; public const int chunk _ overhead _ size = NUM * 2 public const uint max _ chunk _ size = aead _ encryptor . chunk _ len _ mask + aead _ encryptor . chunk _ len _ bytes + NUM * 2 ; public const int buffer _ size = recv _ size + ( int ) max _ chunk _ size + NUM public date _ time last _ activity ; <%> <-> private shadowsocks _ controller controller ; private configuration config ; private tcp _ relay tcprelay ; </%>
private i _ encryptor encryptor ; private server server ; private async _ session current _ remote _ session ; private bool proxy _ connected ; private bool dest _ connected ; private byte command ; private byte [ ] first _ packet ; private int first _ packet _ length ; private const int cmd _ connect = 0 ; private const int cmd _ bind = 0 ;
private <%> <+> readonly </%> byte [ ] connetion _ recv _ buffer = new byte [ buffer _ size ] ; private <%> <+> readonly </%> byte [ ] remote _ send _ buffer = new byte [ buffer _ size ] ; private <%> <+> readonly </%> byte [ ] connetion _ send _ buffer = new byte [ buffer _ size ] ; private bool connection _ shutdown = false ; private bool remote _ shutdown = false ; private bool closed = false ; private readonly object encryption _ lock = new object ( ) ; private readonly object decryption _ lock = new object ( ) ; private readonly object close _ conn _ lock = new object ( ) ; private date _ time start _ connect _ time ;
private <%> <+> readonly </%> byte [ ] remote _ send _ buffer = new byte [ buffer _ size ] ; private <%> <+> readonly </%> byte [ ] connetion _ send _ buffer = new byte [ buffer _ size ] ; private bool connection _ shutdown = false ; private bool remote _ shutdown = false ; private bool closed = false ; private readonly object encryption _ lock = new object ( ) ; private readonly object decryption _ lock = new object ( ) ; private readonly object close _ conn _ lock = new object ( ) ; private date _ time start _ connect _ time ; private date _ time start _ receiving _ time ;
private <%> <+> readonly </%> byte [ ] connetion _ send _ buffer = new byte [ buffer _ size ] ; private bool connection _ shutdown = false ; private bool remote _ shutdown = false ; private bool closed = false ; private readonly object encryption _ lock = new object ( ) ; private readonly object decryption _ lock = new object ( ) ; private readonly object close _ conn _ lock = new object ( ) ; private date _ time start _ connect _ time ; private date _ time start _ receiving _ time ; private date _ time start _ sending _ time ;
private bool connection _ shutdown = false ; private bool remote _ shutdown = false ; private bool closed = false ; private readonly object encryption _ lock = new object ( ) ; private readonly object decryption _ lock = new object ( ) ; private readonly object close _ conn _ lock = new object ( ) ; private date _ time start _ connect _ time ; private date _ time start _ receiving _ time ; private date _ time start _ sending _ time ; private end _ point dest _ end _ point = null ;
{ controller = controller ; <%> <*> config = config ; tcprelay = tcprelay ; -> config = config . proxy ; </%> connection = socket ; proxy _ timeout = config . proxy . proxy _ timeout * NUM ; server _ timeout = config . get _ current _ server ( ) . timeout * NUM ; last _ activity = date _ time . now ; }
connection = socket ; proxy _ timeout = config . proxy . proxy _ timeout * NUM ; server _ timeout = config . get _ current _ server ( ) . timeout * NUM ; last _ activity = date _ time . now ; } public void create _ remote ( ) { server server = controller . get _ a _ server ( i _ strategy _ caller _ type . tcp , ( ip _ end _ point ) connection . remote _ end _ point , dest _ end _ point ) ; if ( server = = null | | server . server = = STR )
logger . trace ( $ STR ) ; encryptor . addr _ buf _ length = addr _ buf _ length ; } public void start ( byte [ ] first _ packet , int length ) { first _ packet = first _ packet ; first _ packet _ length = length ; handshake _ receive ( ) ; } private void check _ close ( )
closed = true ; } <%> <*> lock ( tcprelay . handlers ) { tcprelay . handlers . remove ( this ) ; } -> on _ closed ? . invoke ( this , new ss _ relay _ event _ args ( server ) ) ; </%> try { connection . shutdown ( socket _ shutdown . both ) ;
try { connection . shutdown ( socket _ shutdown . both ) ; connection . close ( ) ; } catch ( exception e ) { logger . log _ useful _ exception ( e ) ; } if ( current _ remote _ session ! = null )
} } private void handshake _ send _ callback ( i _ async _ result ar ) { <%> <*> if ( closed ) return ; -> if ( closed ) </%> <%> <+> { return ; } </%> try
try { connection . end _ send ( ar ) ; connection . begin _ receive ( connetion _ recv _ buffer , 0 , NUM + addr _ atyp _ len + 1 , socket _ flags . none , <%> <*> handshake -> address </%> _ receive _ callback , null ) ; } catch ( exception e ) { <%> <*> logger . log _ useful _ exception ( e ) ; -> error _ </%> close ( <%> <+> e </%> ) ;
try { int bytes _ read = connection . end _ receive ( ar ) ; if ( bytes _ read > = NUM ) { command = connetion _ recv _ buffer [ 1 ] ; switch ( command ) { case cmd _ connect : byte [ ] response = { NUM , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 } ;
{ try { connection . end _ send ( ar ) ; read _ address ( start _ connect ) ; } catch ( exception e ) { <%> <-> logger . log _ useful _ exception ( e ) ; close ( ) ; </%>
} } private void read _ address ( action on _ success ) { int atyp = connetion _ recv _ buffer [ NUM ] ; switch ( atyp ) { case atyp _ i _ pv : read _ address ( NUM + addr _ port _ len - 1 , on _ success ) ; break ;
try { int bytes _ read = connection . end _ receive ( ar ) ; <%> <*> var -> object [ ] </%> states = ( object [ ] ) ar . async _ state ; int bytes _ remain = ( int ) states [ 0 ] ; <%> <*> var -> action </%> on _ success = ( action ) states [ 1 ] ; if ( bytes _ read > = bytes _ remain ) { first _ packet _ length = bytes _ read + 2 ; int atyp = connetion _ recv _ buffer [ 0 ] ;
int bytes _ remain = ( int ) states [ 0 ] ; <%> <*> var -> action </%> on _ success = ( action ) states [ 1 ] ; if ( bytes _ read > = bytes _ remain ) { first _ packet _ length = bytes _ read + 2 ; int atyp = connetion _ recv _ buffer [ 0 ] ; string dst _ addr = STR ; int dst _ port = - 1 ; switch ( atyp ) {
if ( bytes _ read > = bytes _ remain ) { first _ packet _ length = bytes _ read + 2 ; int atyp = connetion _ recv _ buffer [ 0 ] ; string dst _ addr = STR ; int dst _ port = - 1 ; switch ( atyp ) { case atyp _ i _ pv : dst _ addr = new ip _ address ( connetion _ recv _ buffer . skip ( 1 ) . take ( NUM ) . to _ array ( ) ) . to _ string ( ) ;
} } private class proxy _ timer : timer { public async _ session session ; public end _ point dest _ end _ point ; public server server ; public proxy _ timer ( int p ) : base ( p ) { }
} else { remote = new direct _ connect ( ) ; } <%> <*> var -> async _ session </%> session = new async _ session ( remote ) ; lock ( close _ conn _ lock ) { if ( closed ) {
lock ( close _ conn _ lock ) { if ( closed ) { remote . close ( ) ; return ; } current _ remote _ session = session ; } proxy _ timer proxy _ timer = new proxy _ timer ( proxy _ timeout ) { auto _ reset = false } ;
} } private void proxy _ connect _ timer _ elapsed ( object sender , elapsed _ event _ args e ) { <%> <*> var -> proxy _ timer </%> timer = ( proxy _ timer ) sender ; timer . elapsed - = proxy _ connect _ timer _ elapsed ; timer . enabled = false ; timer . dispose ( ) ; if ( proxy _ connected | | dest _ connected | | closed ) {
timer . elapsed - = proxy _ connect _ timer _ elapsed ; timer . enabled = false ; timer . dispose ( ) ; if ( proxy _ connected | | dest _ connected | | closed ) { return ; } <%> <*> var -> i _ proxy </%> proxy = timer . session . remote ; logger . info ( $ STR ) ; proxy . close ( ) ;
logger . info ( $ STR ) ; proxy . close ( ) ; close ( ) ; } private void proxy _ connect _ callback ( i _ async _ result ar ) { if ( closed ) { return ; }
proxy _ timer timer = session . state ; <%> <*> var -> end _ point </%> dest _ end _ point = timer . dest _ end _ point ; <%> <*> var -> server </%> server = timer . server ; timer . elapsed - = proxy _ connect _ timer _ elapsed ; timer . enabled = false ; timer . dispose ( ) ; <%> <*> var -> i _ proxy </%> remote = session . remote ; remote . end _ connect _ proxy ( ar ) ; proxy _ connected = true ; if ( ! ( remote is direct _ connect ) )
timer . elapsed - = proxy _ connect _ timer _ elapsed ; timer . enabled = false ; timer . dispose ( ) ; <%> <*> var -> i _ proxy </%> remote = session . remote ; remote . end _ connect _ proxy ( ar ) ; proxy _ connected = true ; if ( ! ( remote is direct _ connect ) ) { logger . debug ( $ STR ) ; }
remote . end _ connect _ proxy ( ar ) ; proxy _ connected = true ; if ( ! ( remote is direct _ connect ) ) { logger . debug ( $ STR ) ; } start _ connect _ time = date _ time . now ; server _ timer connect _ timer = new server _ timer ( server _ timeout ) { auto _ reset = false } ; connect _ timer . elapsed + = dest _ connect _ timer _ elapsed ; connect _ timer . enabled = true ;
} remote . begin _ connect _ dest ( dest _ end _ point , connect _ callback , new async _ session < server _ timer > ( session , connect _ timer ) , auth ) ; } catch ( argument _ exception ) { } catch ( exception e ) { <%> <-> logger . log _ useful _ exception ( e ) ; </%>
} } private void dest _ connect _ timer _ elapsed ( object sender , elapsed _ event _ args e ) { <%> <*> var -> server _ timer </%> timer = ( server _ timer ) sender ; timer . elapsed - = dest _ connect _ timer _ elapsed ; timer . enabled = false ; timer . dispose ( ) ; if ( dest _ connected | | closed ) {
timer . elapsed - = dest _ connect _ timer _ elapsed ; timer . enabled = false ; timer . dispose ( ) ; if ( dest _ connected | | closed ) { return ; } <%> <*> var -> async _ session </%> session = timer . session ; server server = timer . server ; <%> <-> i _ strategy strategy = controller . get _ current _ strategy ( ) ; </%>
server server = timer . server ; <%> <*> i _ strategy strategy = controller . get _ current _ strategy ( ) ; strategy ? . set _ failure ( server ) ; -> on _ failed ? . invoke ( this , new ss _ relay _ event _ args ( server ) ) ; </%> logger . info ( $ STR ) ; session . remote . close ( ) ; close ( ) ; } private void connect _ callback ( i _ async _ result ar ) {
logger . info ( $ STR ) ; session . remote . close ( ) ; close ( ) ; } private void connect _ callback ( i _ async _ result ar ) { <%> <*> if ( closed ) return ; -> if ( closed ) { return ; </%> <%> <+> } </%>
server _ timer timer = session . state ; server = timer . server ; timer . elapsed - = dest _ connect _ timer _ elapsed ; timer . enabled = false ; timer . dispose ( ) ; <%> <*> var -> i _ proxy </%> remote = session . remote ; remote . end _ connect _ dest ( ar ) ; dest _ connected = true ; logger . debug ( $ STR ) ; <%> <-> var latency = date _ time . now - start _ connect _ time ; </%>
remote . end _ connect _ dest ( ar ) ; dest _ connected = true ; logger . debug ( $ STR ) ; <%> <*> var latency = date _ time . now - start _ connect _ time ; i _ strategy strategy = controller . get _ current _ strategy ( ) ; strategy ? . update _ latency ( server , latency ) ; tcprelay . update _ latency ( server , latency ) ; -> time _ span latency = date _ time . now - start _ connect _ time ; </%> <%> <+> on _ connected ? . invoke ( this , new sstcp _ connected _ event _ args ( server , latency ) ) ; </%> start _ pipe ( session ) ;
start _ pipe ( session ) ; } catch ( argument _ exception ) { } catch ( exception e ) { if ( server ! = null ) { <%> <-> i _ strategy strategy = controller . get _ current _ strategy ( ) ; </%>
} } private void try _ read _ available _ data ( ) { int available = math . min ( connection . available , recv _ size - first _ packet _ length ) ; if ( available > 0 ) { <%> <*> var -> int </%> size = connection . receive ( connetion _ recv _ buffer , first _ packet _ length , available , socket _ flags . none ) ; first _ packet _ length + = size ;
socket _ flags . none ) ; first _ packet _ length + = size ; } } private void start _ pipe ( async _ session session ) { <%> <*> if ( closed ) return ; -> if ( closed ) </%> <%> <+> { return ; </%>
try { start _ receiving _ time = date _ time . now ; session . remote . begin _ receive ( remote _ recv _ buffer , 0 , recv _ size , socket _ flags . none , pipe _ remote _ receive _ callback , session ) ; try _ read _ available _ data ( ) ; logger . trace ( $ STR ) ; send _ to _ server ( first _ packet _ length , session ) ; } catch ( exception e )
} } private void pipe _ remote _ receive _ callback ( i _ async _ result ar ) { <%> <*> if ( closed ) return ; -> if ( closed ) { return ; </%> <%> <+> } </%> try {
int bytes _ read = session . remote . end _ receive ( ar ) ; total _ read + = bytes _ read ; <%> <*> tcprelay . update -> on _ inbound ? . invoke ( this , new ss _ transmit </%> _ <%> <*> inbound -> event </%> _ <%> <*> counter -> args </%> ( server , bytes _ read ) <%> <+> ) </%> ; if ( bytes _ read > 0 ) { last _ activity = date _ time . now ; int bytes _ to _ send = - 1 ; lock ( decryption _ lock ) { try
if ( bytes _ read > 0 ) { last _ activity = date _ time . now ; int bytes _ to _ send = - 1 ; lock ( decryption _ lock ) { try { encryptor . decrypt ( remote _ recv _ buffer , bytes _ read , remote _ send _ buffer , out bytes _ to _ send ) ; }
} } private void pipe _ connection _ receive _ callback ( i _ async _ result ar ) { <%> <*> if ( closed ) return ; -> if ( closed ) </%> <%> <+> { return ; } </%> try
try { int bytes _ read = connection . end _ receive ( ar ) ; <%> <*> var -> async _ session </%> session = ( async _ session ) ar . async _ state ; <%> <*> var -> i _ proxy </%> remote = session . remote ; if ( bytes _ read > 0 ) { send _ to _ server ( bytes _ read , session ) ; } else
if ( bytes _ read > 0 ) { send _ to _ server ( bytes _ read , session ) ; } else { remote . shutdown ( socket _ shutdown . send ) ; remote _ shutdown = true ; check _ close ( ) ; }
start _ sending _ time = date _ time . now ; session . remote . begin _ send ( connetion _ send _ buffer , 0 , bytes _ to _ send , socket _ flags . none , pipe _ remote _ send _ callback , new object [ ] { session , bytes _ to _ send } ) ; <%> <-> i _ strategy strategy = controller . get _ current _ strategy ( ) ; strategy ? . update _ last _ write ( server ) ; </%> } private void pipe _ remote _ send _ callback ( i _ async _ result ar ) { <%> <+> if ( closed ) { </%>
} private void pipe _ remote _ send _ callback ( i _ async _ result ar ) { <%> <*> if ( closed ) return ; -> if ( closed ) { return ; </%> <%> <+> } </%> try { <%> <*> var -> object [ ] </%> container = ( object [ ] ) ar . async _ state ;
int bytes _ sent = session . remote . end _ send ( ar ) ; if ( bytes _ sent > 0 ) { last _ activity = date _ time . now ; } int bytes _ remaining = bytes _ should _ send - bytes _ sent ; if ( bytes _ remaining > 0 ) { logger . info ( STR ) ; buffer . block _ copy ( connetion _ send _ buffer , bytes _ sent , connetion _ send _ buffer , 0 , bytes _ remaining ) ;
} } private void pipe _ connection _ send _ callback ( i _ async _ result ar ) { try { <%> <*> var -> object [ ] </%> container = ( object [ ] ) ar . async _ state ; <%> <*> var -> async _ session </%> session = ( async _ session ) container [ 0 ] ; <%> <*> var -> int </%> bytes _ should _ send = ( int ) container [ 1 ] ; <%> <*> var -> int </%> bytes _ sent = connection . end _ send ( ar ) ;
if ( bytes _ remaining > 0 ) { logger . info ( STR ) ; buffer . block _ copy ( remote _ send _ buffer , bytes _ sent , remote _ send _ buffer , 0 , bytes _ remaining ) ; connection . begin _ send ( remote _ send _ buffer , 0 , bytes _ remaining , socket _ flags . none , pipe _ connection _ send _ callback , new object [ ] { session , bytes _ remaining } ) ; return ; } session . remote . begin _ receive ( remote _ recv _ buffer , 0 , recv _ size , socket _ flags . none , pipe _ remote _ receive _ callback , session ) ;
STR , STR , STR , STR , STR , <%> <-> STR , </%> STR } ) ;

private void run _ single _ polar _ ssl _ encryption _ thread ( ) { try { for ( int i = 0 ; i < NUM ; i + + ) { <%> <-> var random = new random ( ) ; </%> i _ encryptor encryptor ; i _ encryptor decryptor ; encryptor = new polar _ ssl _ encryptor ( STR , STR ) ;
} catch { encryption _ failed = true ; throw ; } } test _ method public void test _ sodium _ encryption ( ) {
this . my _ cancel _ button = new system . windows . forms . button ( ) ; this . ok _ button = new system . windows . forms . button ( ) ; this . use _ proxy _ check _ box = new system . windows . forms . check _ box ( ) ; <%> <-> this . table _ layout _ panel = new system . windows . forms . table _ layout _ panel ( ) ; </%> this . proxy _ addr _ label = new system . windows . forms . label ( ) ; this . proxy _ server _ text _ box = new system . windows . forms . text _ box ( ) ; this . proxy _ port _ label = new system . windows . forms . label ( ) ; this . proxy _ port _ text _ box = new system . windows . forms . text _ box ( ) ; <%> <-> this . table _ layout _ panel = new system . windows . forms . table _ layout _ panel ( ) ; </%> this . proxy _ type _ label = new system . windows . forms . label ( ) ;
this . proxy _ addr _ label = new system . windows . forms . label ( ) ; this . proxy _ server _ text _ box = new system . windows . forms . text _ box ( ) ; this . proxy _ port _ label = new system . windows . forms . label ( ) ; this . proxy _ port _ text _ box = new system . windows . forms . text _ box ( ) ; <%> <-> this . table _ layout _ panel = new system . windows . forms . table _ layout _ panel ( ) ; </%> this . proxy _ type _ label = new system . windows . forms . label ( ) ; this . proxy _ type _ combo _ box = new system . windows . forms . combo _ box ( ) ; this . proxy _ timeout _ text _ box = new system . windows . forms . text _ box ( ) ; this . proxy _ timeout _ label = new system . windows . forms . label ( ) ; <%> <+> this . table _ layout _ panel = new system . windows . forms . table _ layout _ panel ( ) ; </%>
this . proxy _ type _ label = new system . windows . forms . label ( ) ; this . proxy _ type _ combo _ box = new system . windows . forms . combo _ box ( ) ; this . proxy _ timeout _ text _ box = new system . windows . forms . text _ box ( ) ; this . proxy _ timeout _ label = new system . windows . forms . label ( ) ; <%> <+> this . table _ layout _ panel = new system . windows . forms . table _ layout _ panel ( ) ; this . proxy _ notification _ label = new system . windows . forms . label ( ) ; this . flow _ layout _ panel = new system . windows . forms . flow _ layout _ panel ( ) ; </%> this . table _ layout _ panel . suspend _ layout ( ) ; <%> <-> this . table _ layout _ panel . suspend _ layout ( ) ; this . table _ layout _ panel . suspend _ layout ( ) ; </%>
this . suspend _ layout ( ) ; this . table _ layout _ panel . auto _ size = true ; this . table _ layout _ panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . table _ layout _ panel . column _ count = 1 ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . controls . add ( this . table _ layout _ panel , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . use _ proxy _ check _ box , 0 , 0 ) ; this . table _ layout _ panel . controls . add ( this . table _ layout _ panel , 0 , 2 ) ; this . table _ layout _ panel . controls . add ( this . table _ layout _ panel , 0 , 1 ) ; this . table _ layout _ panel . location = new system . drawing . point ( NUM , NUM ) ;
this . my _ cancel _ button . location = new system . drawing . point ( NUM , NUM ) ; this . my _ cancel _ button . margin = new system . windows . forms . padding ( NUM , NUM , 0 , 0 ) ; this . my _ cancel _ button . name = STR ; this . my _ cancel _ button . size = new system . drawing . size ( NUM , NUM ) ; this . my _ cancel _ button . tab _ index = NUM ; this . my _ cancel _ button . text = STR ; this . my _ cancel _ button . use _ visual _ style _ back _ color = true ; this . my _ cancel _ button . click + = new system . event _ handler ( this . cancel _ button _ click ) ; this . ok _ button . dialog _ result = system . windows . forms . dialog _ result . ok ; <%> <-> this . ok _ button . dock = system . windows . forms . dock _ style . right ; </%>
this . ok _ button . location = new system . drawing . point ( NUM , NUM ) ; this . ok _ button . margin = new system . windows . forms . padding ( NUM , NUM , NUM , 0 ) ; this . ok _ button . name = STR ; this . ok _ button . size = new system . drawing . size ( NUM , NUM ) ; this . ok _ button . tab _ index = NUM ; this . ok _ button . text = STR ; this . ok _ button . use _ visual _ style _ back _ color = true ; this . ok _ button . click + = new system . event _ handler ( this . ok _ button _ click ) ; this . use _ proxy _ check _ box . auto _ size = true ; <%> <+> this . table _ layout _ panel . set _ column _ span ( this . use _ proxy _ check _ box , 2 ) ; </%>
this . resume _ layout ( false ) ; <%> <-> this . perform _ layout ( ) ; </%> } <%> <-> private system . windows . forms . table _ layout _ panel table _ layout _ panel ; </%> private system . windows . forms . check _ box use _ proxy _ check _ box ; <%> <-> private system . windows . forms . table _ layout _ panel table _ layout _ panel ; </%> private system . windows . forms . label proxy _ addr _ label ; private system . windows . forms . text _ box proxy _ server _ text _ box ; private system . windows . forms . label proxy _ port _ label ; private system . windows . forms . text _ box proxy _ port _ text _ box ;
} <%> <-> private system . windows . forms . table _ layout _ panel table _ layout _ panel ; </%> private system . windows . forms . check _ box use _ proxy _ check _ box ; <%> <-> private system . windows . forms . table _ layout _ panel table _ layout _ panel ; </%> private system . windows . forms . label proxy _ addr _ label ; private system . windows . forms . text _ box proxy _ server _ text _ box ; private system . windows . forms . label proxy _ port _ label ; private system . windows . forms . text _ box proxy _ port _ text _ box ; <%> <-> private system . windows . forms . table _ layout _ panel table _ layout _ panel ; </%> private system . windows . forms . button my _ cancel _ button ;
private system . windows . forms . check _ box use _ proxy _ check _ box ; <%> <-> private system . windows . forms . table _ layout _ panel table _ layout _ panel ; </%> private system . windows . forms . label proxy _ addr _ label ; private system . windows . forms . text _ box proxy _ server _ text _ box ; private system . windows . forms . label proxy _ port _ label ; private system . windows . forms . text _ box proxy _ port _ text _ box ; <%> <-> private system . windows . forms . table _ layout _ panel table _ layout _ panel ; </%> private system . windows . forms . button my _ cancel _ button ; private system . windows . forms . button ok _ button ; <%> <-> private system . windows . forms . table _ layout _ panel table _ layout _ panel ; </%>
private system . windows . forms . label proxy _ addr _ label ; private system . windows . forms . text _ box proxy _ server _ text _ box ; private system . windows . forms . label proxy _ port _ label ; private system . windows . forms . text _ box proxy _ port _ text _ box ; <%> <-> private system . windows . forms . table _ layout _ panel table _ layout _ panel ; </%> private system . windows . forms . button my _ cancel _ button ; private system . windows . forms . button ok _ button ; <%> <-> private system . windows . forms . table _ layout _ panel table _ layout _ panel ; </%> private system . windows . forms . label proxy _ type _ label ; private system . windows . forms . combo _ box proxy _ type _ combo _ box ;
private system . windows . forms . button my _ cancel _ button ; private system . windows . forms . button ok _ button ; <%> <-> private system . windows . forms . table _ layout _ panel table _ layout _ panel ; </%> private system . windows . forms . label proxy _ type _ label ; private system . windows . forms . combo _ box proxy _ type _ combo _ box ; private system . windows . forms . text _ box proxy _ timeout _ text _ box ; private system . windows . forms . label proxy _ timeout _ label ; <%> <+> private system . windows . forms . table _ layout _ panel table _ layout _ panel ; private system . windows . forms . label proxy _ notification _ label ; private system . windows . forms . flow _ layout _ panel flow _ layout _ panel ; </%>
private system . windows . forms . label proxy _ type _ label ; private system . windows . forms . combo _ box proxy _ type _ combo _ box ; private system . windows . forms . text _ box proxy _ timeout _ text _ box ; private system . windows . forms . label proxy _ timeout _ label ; <%> <+> private system . windows . forms . table _ layout _ panel table _ layout _ panel ; private system . windows . forms . label proxy _ notification _ label ; private system . windows . forms . flow _ layout _ panel flow _ layout _ panel ; </%> } }
this . about _ item = new system . windows . forms . menu _ item ( ) ; this . menu _ item = new system . windows . forms . menu _ item ( ) ; this . quit _ item = new system . windows . forms . menu _ item ( ) ; this . panel = new system . windows . forms . panel ( ) ; this . delete _ button = new system . windows . forms . button ( ) ; this . add _ button = new system . windows . forms . button ( ) ; this . server _ group _ box = new system . windows . forms . group _ box ( ) ; this . servers _ list _ box = new system . windows . forms . list _ box ( ) ; <%> <-> this . lock _ button = new system . windows . forms . button ( ) ; this . panel = new system . windows . forms . panel ( ) ; </%>
this . table _ layout _ panel . suspend _ layout ( ) ; this . panel . suspend _ layout ( ) ; this . panel . suspend _ layout ( ) ; this . server _ group _ box . suspend _ layout ( ) ; <%> <-> this . panel . suspend _ layout ( ) ; </%> this . suspend _ layout ( ) ; this . table _ layout _ panel . auto _ size = true ; this . table _ layout _ panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . table _ layout _ panel . column _ count = 2 ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ;
this . suspend _ layout ( ) ; this . table _ layout _ panel . auto _ size = true ; this . table _ layout _ panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . table _ layout _ panel . column _ count = 2 ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . controls . add ( this . remarks _ text _ box , 1 , NUM ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , 0 ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , 1 ) ;
this . client _ size = new system . drawing . size ( NUM , NUM ) ; <%> <-> this . controls . add ( this . panel ) ; </%> this . controls . add ( this . servers _ list _ box ) ; this . controls . add ( this . server _ group _ box ) ; this . controls . add ( this . panel ) ; this . controls . add ( this . panel ) ; this . controls . add ( this . panel ) ; this . form _ border _ style = system . windows . forms . form _ border _ style . fixed _ single ; this . icon = ( ( system . drawing . icon ) ( resources . get _ object ( STR ) ) ) ; this . maximize _ box = false ;
this . controls . add ( this . servers _ list _ box ) ; this . controls . add ( this . server _ group _ box ) ; this . controls . add ( this . panel ) ; this . controls . add ( this . panel ) ; this . controls . add ( this . panel ) ; this . form _ border _ style = system . windows . forms . form _ border _ style . fixed _ single ; this . icon = ( ( system . drawing . icon ) ( resources . get _ object ( STR ) ) ) ; this . maximize _ box = false ; this . name = STR ; this . start _ position = system . windows . forms . form _ start _ position . center _ screen ;
this . form _ closed + = new system . windows . forms . form _ closed _ event _ handler ( this . config _ form _ form _ closed ) ; this . load + = new system . event _ handler ( this . config _ form _ load ) ; this . shown + = new system . event _ handler ( this . config _ form _ shown ) ; this . table _ layout _ panel . resume _ layout ( false ) ; this . table _ layout _ panel . perform _ layout ( ) ; this . panel . resume _ layout ( false ) ; this . panel . resume _ layout ( false ) ; this . server _ group _ box . resume _ layout ( false ) ; this . server _ group _ box . perform _ layout ( ) ; <%> <-> this . panel . resume _ layout ( false ) ; </%>
this . resume _ layout ( false ) ; this . perform _ layout ( ) ; } private system . windows . forms . table _ layout _ panel table _ layout _ panel ; private system . windows . forms . label label ; private system . windows . forms . label label ; private system . windows . forms . label label ; private system . windows . forms . label label ; private system . windows . forms . text _ box ip _ text _ box ; private system . windows . forms . text _ box server _ port _ text _ box ;
} else { <%> <*> this . opacity = 0 ; begin _ invoke ( new method _ invoker ( delegate { this . hide ( ) ; } ) ) ; -> is _ first _ run = true ; </%> } } private void servers _ list _ box _ selected _ index _ changed ( object sender , event _ args e ) {
} } private void servers _ list _ box _ selected _ index _ changed ( object sender , event _ args e ) { if ( old _ selected _ index = = servers _ list _ box . selected _ index ) { return ; } if ( ! save _ old _ selected _ server ( ) ) {
} <%> <-> if ( remarks . is _ null _ or _ empty ( ) ) { switch ( addr . address _ family ) { case address _ family . inter _ network : return $ STR ; case address _ family . inter _ network : return $ STR ; } } else { switch ( addr . address _ family ) { </%>
} <%> <*> return null ; -> return remarks . is _ null _ or _ empty ( ) </%> <%> <+> ? server _ str : $ STR ; </%> } public server ( ) { server = STR ; server _ port = NUM ;
} public server ( ) { server = STR ; server _ port = NUM ; method = STR ; password = STR ; remarks = STR ; auth = false ; }
this . controls . add ( this . qr _ code _ web _ browser ) ; this . form _ border _ style = system . windows . forms . form _ border _ style . fixed _ single ; <%> <+> this . icon = ( ( system . drawing . icon ) ( resources . get _ object ( STR ) ) ) ; </%> this . maximize _ box = false ; this . name = STR ; this . start _ position = system . windows . forms . form _ start _ position . center _ screen ; <%> <+> this . text = STR ; </%> this . load + = new system . event _ handler ( this . qr _ code _ form _ load ) ; <%> <+> ( ( system . component _ model . i _ support _ initialize ) ( this . picture _ box ) ) . end _ init ( ) ; </%> this . resume _ layout ( false ) ;
long max _ speed = 0 ; <%> <-> inbound _ points . clear ( ) ; </%> <%> <*> outbound -> long last </%> _ <%> <*> points . clear ( ) -> inbound , last _ outbound </%> ; <%> <*> foreach ( var traffic _ per _ second in controller . traffic -> lock ( this </%> ) { <%> <*> inbound _ points . add -> if </%> ( traffic <%> <-> _ per _ second </%> . <%> <*> inbound _ increasement -> count = = 0 </%> ) <%> <-> ; </%> <%> <*> outbound _ points . add ( traffic _ per _ second . outbound _ increasement ) -> return </%> ; <%> <*> max _ speed = math . max ( max _ speed , math . max -> foreach </%> ( <%> <+> var </%> traffic _ per _ second <%> <*> . inbound _ increasement , -> in </%> traffic <%> <*> _ per _ second . outbound _ increasement ) ) ; -> ) </%> <%> <+> { inbound _ points . add ( traffic _ per _ second . item ) ; </%>
} bandwidth _ scale = utils . get _ bandwidth _ scale ( max _ speed ) ; inbound _ points = inbound _ points . select ( p = > p / bandwidth _ scale . item ) . to _ list ( ) ; outbound _ points = outbound _ points . select ( p = > p / bandwidth _ scale . item ) . to _ list ( ) ; <%> <*> try { if ( traffic _ chart . invoke _ required & & traffic _ chart . is _ handle _ created ) { -> if ( </%> traffic _ chart . <%> <*> invoke ( new action ( ( -> is _ handle _ created </%> ) <%> <-> = > </%> {
} } private void update _ texts ( ) { file _ menu _ item . text = n . get _ string ( STR ) ; open _ location _ menu _ item . text = n . get _ string ( STR ) ; exit _ menu _ item . text = n . get _ string ( STR ) ; clean _ logs _ button . text = n . get _ string ( STR ) ; change _ font _ button . text = n . get _ string ( STR ) ; wrap _ text _ check _ box . text = n . get _ string ( STR ) ;
this . plugin _ text _ box . max _ length = NUM ; this . plugin _ text _ box . name = STR ; this . plugin _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . plugin _ text _ box . tab _ index = NUM ; this . plugin _ text _ box . word _ wrap = false ; this . remarks _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . remarks _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . remarks _ text _ box . margin = new system . windows . forms . padding ( <%> <-> NUM , NUM , NUM , </%> NUM ) ; this . remarks _ text _ box . max _ length = NUM ; this . remarks _ text _ box . name = STR ;
this . remarks _ text _ box . max _ length = NUM ; this . remarks _ text _ box . name = STR ; this . remarks _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . remarks _ text _ box . tab _ index = NUM ; this . remarks _ text _ box . word _ wrap = false ; this . ip _ label . anchor = system . windows . forms . anchor _ styles . right ; this . ip _ label . auto _ size = true ; this . ip _ label . location = new system . drawing . point ( NUM , NUM ) ; this . ip _ label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ; this . ip _ label . name = STR ;
this . ip _ text _ box . max _ length = NUM ; this . ip _ text _ box . name = STR ; this . ip _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . ip _ text _ box . tab _ index = 0 ; this . ip _ text _ box . word _ wrap = false ; this . server _ port _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . server _ port _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . server _ port _ text _ box . margin = new system . windows . forms . padding ( <%> <-> NUM , NUM , NUM , </%> NUM ) ; this . server _ port _ text _ box . max _ length = NUM ; this . server _ port _ text _ box . name = STR ;
this . server _ port _ text _ box . max _ length = NUM ; this . server _ port _ text _ box . name = STR ; this . server _ port _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . server _ port _ text _ box . tab _ index = 1 ; this . server _ port _ text _ box . word _ wrap = false ; this . password _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . password _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . password _ text _ box . margin = new system . windows . forms . padding ( <%> <-> NUM , NUM , NUM , </%> NUM ) ; this . password _ text _ box . max _ length = NUM ; this . password _ text _ box . name = STR ;
this . password _ text _ box . max _ length = NUM ; this . password _ text _ box . name = STR ; this . password _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . password _ text _ box . tab _ index = 2 ; this . password _ text _ box . use _ system _ password _ char = true ; this . password _ text _ box . word _ wrap = false ; this . encryption _ label . anchor = system . windows . forms . anchor _ styles . right ; this . encryption _ label . auto _ size = true ; this . encryption _ label . location = new system . drawing . point ( NUM , NUM ) ; this . encryption _ label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ;
this . plugin _ options _ text _ box . max _ length = NUM ; this . plugin _ options _ text _ box . name = STR ; this . plugin _ options _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . plugin _ options _ text _ box . tab _ index = NUM ; this . plugin _ options _ text _ box . word _ wrap = false ; this . show _ passwd _ check _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( ( system . windows . forms . anchor _ styles . top | system . windows . forms . anchor _ styles . bottom ) | system . windows . forms . anchor _ styles . left ) ) ) ; this . show _ passwd _ check _ box . auto _ size = true ; this . show _ passwd _ check _ box . location = new system . drawing . point ( NUM , NUM ) ; this . show _ passwd _ check _ box . margin = new system . windows . forms . padding ( <%> <-> NUM , NUM , NUM , </%> NUM ) ;
this . show _ passwd _ check _ box . name = STR ; this . show _ passwd _ check _ box . size = new system . drawing . size ( NUM , NUM ) ; this . show _ passwd _ check _ box . tab _ index = NUM ; this . show _ passwd _ check _ box . text = STR ; this . show _ passwd _ check _ box . text _ align = system . drawing . content _ alignment . middle _ center ; this . show _ passwd _ check _ box . use _ visual _ style _ back _ color = true ; this . show _ passwd _ check _ box . checked _ changed + = new system . event _ handler ( this . show _ passwd _ check _ box _ checked _ changed ) ; this . plugin _ arguments _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . plugin _ arguments _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . plugin _ arguments _ text _ box . margin = new system . windows . forms . padding ( <%> <-> NUM , NUM , NUM , </%> NUM ) ;
this . plugin _ arguments _ text _ box . max _ length = NUM ; this . plugin _ arguments _ text _ box . name = STR ; this . plugin _ arguments _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . plugin _ arguments _ text _ box . tab _ index = NUM ; this . plugin _ arguments _ text _ box . word _ wrap = false ; this . plugin _ arguments _ label . anchor = system . windows . forms . anchor _ styles . right ; this . plugin _ arguments _ label . auto _ size = true ; this . plugin _ arguments _ label . location = new system . drawing . point ( NUM , NUM ) ; this . plugin _ arguments _ label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ; this . plugin _ arguments _ label . name = STR ;
this . table _ layout _ panel . row _ count = 2 ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ; this . table _ layout _ panel . tab _ index = NUM ; this . proxy _ port _ text _ box . anchor = system . windows . forms . anchor _ styles . left ; this . proxy _ port _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . proxy _ port _ text _ box . margin = new system . windows . forms . padding ( <%> <-> NUM , NUM , NUM , </%> NUM ) ; this . proxy _ port _ text _ box . max _ length = NUM ; this . proxy _ port _ text _ box . name = STR ;
this . proxy _ port _ text _ box . max _ length = NUM ; this . proxy _ port _ text _ box . name = STR ; this . proxy _ port _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . proxy _ port _ text _ box . tab _ index = NUM ; this . proxy _ port _ text _ box . word _ wrap = false ; this . proxy _ port _ label . anchor = system . windows . forms . anchor _ styles . right ; this . proxy _ port _ label . auto _ size = true ; this . proxy _ port _ label . location = new system . drawing . point ( NUM , NUM ) ; this . proxy _ port _ label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ; this . proxy _ port _ label . name = STR ;
private const string statistics _ files _ name = STR ; public static string availability _ statistics _ file ; static availability _ statistics ( ) { availability _ statistics _ file = utils . get _ temp _ path ( statistics _ files _ name ) ; <%> <-> unknown _ date _ time = new date _ time ( NUM , 1 , 1 ) ; </%> } private int repeat = > config . repeat _ times _ num ; public const int timeout _ milliseconds = NUM ; private list < int > latency _ records ;
} private int repeat = > config . repeat _ times _ num ; public const int timeout _ milliseconds = NUM ; private list < int > latency _ records ; private long last _ inbound _ counter ; private list < int > inbound _ speed _ records ; private long last _ outbound _ counter ; private list < int > outbound _ speed _ records ; private readonly time _ span delay _ before _ start = time _ span . from _ seconds ( 1 ) ; private readonly time _ span retry _ interval = time _ span . from _ minutes ( 2 ) ;
this . all _ mode . location = new system . drawing . point ( NUM , NUM ) ; this . all _ mode . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . all _ mode . name = STR ; this . all _ mode . size = new system . drawing . size ( NUM , NUM ) ; this . all _ mode . tab _ index = 1 ; <%> <-> this . all _ mode . tab _ stop = true ; </%> this . all _ mode . text = STR ; this . all _ mode . use _ visual _ style _ back _ color = true ; this . all _ mode . checked _ changed + = new system . event _ handler ( this . all _ mode _ checked _ changed ) ; this . day _ mode . auto _ size = true ;
this . all _ mode . text = STR ; this . all _ mode . use _ visual _ style _ back _ color = true ; this . all _ mode . checked _ changed + = new system . event _ handler ( this . all _ mode _ checked _ changed ) ; this . day _ mode . auto _ size = true ; <%> <+> this . day _ mode . checked = true ; </%> this . day _ mode . location = new system . drawing . point ( NUM , NUM ) ; this . day _ mode . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . day _ mode . name = STR ; this . day _ mode . size = new system . drawing . size ( NUM , NUM ) ; this . day _ mode . tab _ index = 0 ;
this . split _ container . tab _ index = NUM ; this . label . auto _ size = true ; this . label . location = new system . drawing . point ( NUM , NUM ) ; this . label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ; this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ; this . label . tab _ index = 0 ; this . label . text = STR ; <%> <+> this . calculatin _ tip . set _ tool _ tip ( this . label , STR ) ; </%> this . calculation _ container . auto _ scroll = true ;
this . calculation _ container . auto _ scroll = true ; this . calculation _ container . dock = system . windows . forms . dock _ style . fill ; this . calculation _ container . location = new system . drawing . point ( 0 , 0 ) ; this . calculation _ container . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . calculation _ container . name = STR ; this . calculation _ container . size = new system . drawing . size ( NUM , NUM ) ; this . calculation _ container . tab _ index = 1 ; this . server _ selector . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . bottom | system . windows . forms . anchor _ styles . right ) ) ) ; this . server _ selector . formatting _ enabled = true ; this . server _ selector . location = new system . drawing . point ( NUM , NUM ) ;
{ controller = controller ; <%> <+> config = conf ; </%> handlers = new hash _ set < tcp _ handler > ( ) ; last _ sweep _ time = date _ time . now ; } public bool handle ( byte [ ] first _ packet , int length , socket socket , object state ) { if ( socket . protocol _ type ! = protocol _ type . tcp | | ( length < 2 | | first _ packet [ 0 ] ! = NUM ) )
handler . connection = socket ; handler . controller = controller ; handler . tcprelay = this ; handler . start ( first _ packet , length ) ; i _ list < tcp _ handler > handlers _ to _ close = new list < tcp _ handler > ( ) ; lock ( handlers ) { handlers . add ( handler ) ; date _ time now = date _ time . now ; if ( now - last _ sweep _ time > time _ span . from _ seconds ( 1 ) )
{ tcprelay = tcprelay ; <%> <+> config = config ; </%> } public void create _ remote ( ) { server server = controller . get _ a _ server ( i _ strategy _ caller _ type . tcp , ( ip _ end _ point ) connection . remote _ end _ point ) ; if ( server = = null | | server . server = = STR ) throw new argument _ exception ( STR ) ; encryptor = encryptor _ factory . get _ encryptor ( server . method , server . password , server . auth , false ) ;
logging . info ( $ STR ) ; } break ; case NUM : int len = connetion _ recv _ buffer [ 1 ] ; dst _ addr = system . text . encoding . ut . get _ string ( connetion _ recv _ buffer , 2 , len ) ; dst _ port = ( connetion _ recv _ buffer [ len + 2 ] < < NUM ) + connetion _ recv _ buffer [ len + NUM ] ; <%> <*> if ( controller . get _ current _ configuration -> if </%> ( <%> <*> ) -> config </%> . is _ verbose _ logging ) { logging . info ( $ STR ) ; }
logging . info ( $ STR ) ; } break ; case NUM : dst _ addr = new ip _ address ( connetion _ recv _ buffer . skip ( 1 ) . take ( NUM ) . to _ array ( ) ) . to _ string ( ) ; dst _ port = ( connetion _ recv _ buffer [ NUM ] < < NUM ) + connetion _ recv _ buffer [ NUM ] ; <%> <*> if ( controller . get _ current _ configuration -> if </%> ( <%> <*> ) -> config </%> . is _ verbose _ logging ) { logging . info ( $ STR ) ; } break ;
logging . info ( $ STR ) ; } break ; } int bytes _ to _ send ; lock ( encryption _ lock ) { if ( closed ) return ; encryptor . encrypt ( connetion _ recv _ buffer , bytes _ read , connetion _ send _ buffer , out bytes _ to _ send ) ; }
logging . log _ useful _ exception ( e . get _ exception ( ) ) ; } void controller _ update _ pac _ from _ gfw _ list _ completed ( object sender , event _ args e ) { <%> <*> is _ update _ pac _ from _ gfw _ list _ running = false ; notify _ icon . balloon _ tip _ title = n . get _ string ( STR ) ; notify _ icon . balloon _ tip _ text = n . get _ string ( STR ) ; notify _ icon . balloon _ tip _ icon = tool _ tip _ icon . info ; notify _ icon . show _ balloon _ tip ( NUM ) ; -> show _ balloon _ tip ( n . get _ string ( STR ) , n . get _ string ( STR ) , tool _ tip _ icon . info , NUM ) ; </%>
} void update _ checker _ new _ version _ found ( object sender , event _ args e ) { <%> <*> notify _ icon . balloon _ tip _ title = string . format ( n . get _ string ( STR ) , update _ checker . latest _ version _ number ) ; notify _ icon . balloon _ tip _ text = n . get _ string ( STR ) ; notify _ icon . balloon _ tip _ icon = tool _ tip _ icon . info ; -> show _ balloon _ tip ( string . format ( n . get _ string ( STR ) , update _ checker . latest _ version _ number ) , n . get _ string ( STR ) , tool _ tip _ icon . info , NUM ) ; </%> notify _ icon . balloon _ tip _ clicked + = notify _ icon _ balloon _ tip _ clicked ; <%> <-> notify _ icon . show _ balloon _ tip ( NUM ) ; </%> is _ first _ run = false ;
notify _ icon . balloon _ tip _ clicked + = notify _ icon _ balloon _ tip _ clicked ; <%> <-> notify _ icon . show _ balloon _ tip ( NUM ) ; </%> is _ first _ run = false ; } void notify _ icon _ balloon _ tip _ clicked ( object sender , event _ args e ) { system . diagnostics . process . start ( update _ checker . latest _ version _ url ) ; <%> <+> notify _ icon . balloon _ tip _ clicked - = notify _ icon _ balloon _ tip _ clicked ; </%> } private void load _ current _ configuration ( )
is _ first _ run = false ; } void notify _ icon _ balloon _ tip _ clicked ( object sender , event _ args e ) { system . diagnostics . process . start ( update _ checker . latest _ version _ url ) ; <%> <+> notify _ icon . balloon _ tip _ clicked - = notify _ icon _ balloon _ tip _ clicked ; </%> } private void load _ current _ configuration ( ) { configuration config = controller . get _ configuration ( ) ;
{ remote = new socks _ proxy ( ) ; proxy _ ep = socket _ util . get _ end _ point ( config <%> <+> . proxy </%> . proxy _ server , config <%> <+> . proxy </%> . proxy _ port ) ; } else { remote = new direct _ connect ( ) ; proxy _ ep = null ; } var session = new async _ session ( remote ) ;
} else { remote = new direct _ connect ( ) ; proxy _ ep = null ; } var session = new async _ session ( remote ) ; current _ remote _ session = session ; proxy _ timer proxy _ timer = new proxy _ timer ( NUM ) ; proxy _ timer . auto _ reset = false ;
save _ config ( config ) ; } public void enable _ proxy ( string proxy , int port ) { config <%> <+> . proxy </%> . use _ proxy = true ; config <%> <+> . proxy </%> . proxy _ server = proxy ; config <%> <+> . proxy </%> . proxy _ port = port ; save _ config ( config ) ; } public void toggle _ verbose _ logging ( bool enabled )
save _ config ( config ) ; } public void toggle _ verbose _ logging ( bool enabled ) { config . is _ verbose _ logging = enabled ; save _ config ( config ) ; if ( verbose _ logging _ status _ changed ! = null ) { verbose _ logging _ status _ changed ( this , new event _ args ( ) ) ; } }
details _ parser = new regex ( STR + STR , <%> <-> regex _ options . compiled | </%> regex _ options . ignore _ case ) ; private const int default _ server _ timeout _ sec = NUM ; public const int max _ server _ timeout _ sec = NUM ; public string server ; public int server _ port ; public string password ; public string method ; public string remarks ; public bool auth ;
private const int default _ server _ timeout _ sec = NUM ; public const int max _ server _ timeout _ sec = NUM ; public string server ; public int server _ port ; public string password ; public string method ; public string remarks ; public bool auth ; public int timeout ; public override int get _ hash _ code ( )
} catch ( format _ exception ) { message _ box . show ( n . get _ string ( STR ) ) ; <%> <+> proxy _ port _ text _ box . clear ( ) ; </%> return ; <%> <+> } try { timeout = int . parse ( proxy _ timeout _ text _ box . text ) ; </%>
controller . save _ proxy _ config ( modified _ configuration ) ; this . close ( ) ; } private void cancel _ button _ click ( object sender , event _ args e ) { this . close ( ) ; } private void proxy _ form _ form _ closed ( object sender , form _ closed _ event _ args e ) { controller . config _ changed - = controller _ config _ changed ;
int local _ port = int . parse ( proxy _ port _ text _ box . text ) ; configuration . check _ server ( server ) ; configuration . check _ local _ port ( local _ port ) ; modified _ configuration . configs [ last _ selected _ index ] = server ; modified _ configuration . local _ port = local _ port ; return true ; <%> <-> } catch ( format _ exception ) { message _ box . show ( n . get _ string ( STR ) ) ; </%>
} catch ( exception ex ) { message _ box . show ( ex . message ) ; } return false ; } private void load _ selected _ server ( ) { if ( servers _ list _ box . selected _ index > = 0 & & servers _ list _ box . selected _ index < modified _ configuration . configs . count )
this . picture _ box = new system . windows . forms . picture _ box ( ) ; <%> <+> this . panel = new system . windows . forms . panel ( ) ; </%> ( ( system . component _ model . i _ support _ initialize ) ( this . picture _ box ) ) . begin _ init ( ) ; <%> <+> this . panel . suspend _ layout ( ) ; </%> this . suspend _ layout ( ) ; <%> <-> this . qr _ code _ web _ browser . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( ( ( system . windows . forms . anchor _ styles . top | system . windows . forms . anchor _ styles . bottom ) | system . windows . forms . anchor _ styles . left ) | system . windows . forms . anchor _ styles . right ) ) ) ; this . qr _ code _ web _ browser . location = new system . drawing . point ( 0 , 0 ) ; this . qr _ code _ web _ browser . margin = new system . windows . forms . padding ( 0 ) ; </%>
<%> <*> this . picture _ box . location = new system . drawing . point ( 0 , 0 ) ; -> this . picture _ box . dock = system . windows . forms . dock _ style . fill ; </%> <%> <+> this . picture _ box . location = new system . drawing . point ( NUM , NUM ) ; this . picture _ box . margin = new system . windows . forms . padding ( 0 ) ; </%> this . picture _ box . name = STR ; this . picture _ box . size = new system . drawing . size ( NUM , NUM ) ; <%> <+> this . picture _ box . size _ mode = system . windows . forms . picture _ box _ size _ mode . stretch _ image ; </%> this . picture _ box . tab _ index = 1 ; this . picture _ box . tab _ stop = false ; <%> <+> this . panel . controls . add ( this . picture _ box ) ; </%>
this . picture _ box . name = STR ; this . picture _ box . size = new system . drawing . size ( NUM , NUM ) ; <%> <+> this . picture _ box . size _ mode = system . windows . forms . picture _ box _ size _ mode . stretch _ image ; </%> this . picture _ box . tab _ index = 1 ; this . picture _ box . tab _ stop = false ; <%> <+> this . panel . controls . add ( this . picture _ box ) ; this . panel . dock = system . windows . forms . dock _ style . fill ; this . panel . location = new system . drawing . point ( 0 , 0 ) ; this . panel . margin = new system . windows . forms . padding ( 0 ) ; this . panel . name = STR ; </%>
this . picture _ box . tab _ index = 1 ; this . picture _ box . tab _ stop = false ; <%> <+> this . panel . controls . add ( this . picture _ box ) ; this . panel . dock = system . windows . forms . dock _ style . fill ; this . panel . location = new system . drawing . point ( 0 , 0 ) ; this . panel . margin = new system . windows . forms . padding ( 0 ) ; this . panel . name = STR ; this . panel . padding = new system . windows . forms . padding ( NUM ) ; this . panel . size = new system . drawing . size ( NUM , NUM ) ; this . panel . tab _ index = 2 ; </%>
this . form _ border _ style = system . windows . forms . form _ border _ style . fixed _ single ; this . maximize _ box = false ; this . minimize _ box = false ; this . name = STR ; this . start _ position = system . windows . forms . form _ start _ position . center _ screen ; this . text = STR ; this . load + = new system . event _ handler ( this . qr _ code _ form _ load ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . picture _ box ) ) . end _ init ( ) ; <%> <+> this . panel . resume _ layout ( false ) ; </%> this . resume _ layout ( false ) ;
private system . windows . forms . picture _ box picture _ box ; <%> <+> private system . windows . forms . panel panel ; </%> } }
{ controller = controller ; config = config ; <%> <-> tcprelay = tcprelay ; </%> connection = socket ; proxy _ timeout = config . proxy . proxy _ timeout * NUM ; server _ timeout = config . get _ current _ server ( ) . timeout * NUM ; last _ activity = date _ time . now ; } public void create _ remote ( )
connection = socket ; proxy _ timeout = config . proxy . proxy _ timeout * NUM ; server _ timeout = config . get _ current _ server ( ) . timeout * NUM ; last _ activity = date _ time . now ; } public void create _ remote ( ) { server server = controller . get _ a _ server ( i _ strategy _ caller _ type . tcp , ( ip _ end _ point ) connection . remote _ end _ point , dest _ end _ point ) ; if ( server = = null | | server . server = = STR )
{ var dr = message _ box . show ( n . get _ string ( STR , ss _ url ) , n . get _ string ( STR ) , message _ box _ buttons . yes _ no ) ; if ( dr = = dialog _ result . yes ) { <%> <+> if ( add _ server _ by _ ssurl ( ss _ url ) ) { message _ box . show ( n . get _ string ( STR , ss _ url ) ) ; </%> <%> <*> add _ server _ by _ ssurl ( ss _ url ) -> return true </%> ; } <%> <+> else </%>
} public bool add _ server _ by _ ssurl ( string ss _ url ) { try { if ( ss _ url . is _ null _ or _ empty ( ) | | ss _ url . is _ white _ space ( ) ) return false ; var servers = server . get _ servers ( ss _ url ) ; if ( servers = = null | | servers . count = = 0 ) return false ;
} else { <%> <-> abp _ content = utils . un _ gzip ( resources . abp _ js ) ; } abp _ content = abp _ content . replace ( STR , json _ convert . serialize _ object ( lines , formatting . indented ) ) ; if ( file . exists ( pac _ server . pac _ file ) ) { string original = file _ manager . non _ exclusive _ read _ all _ text ( pac _ server . pac _ file , encoding . ut ) ; if ( original = = abp _ content ) </%>
} public void copy _ pac _ url ( ) { clipboard . set _ data _ object ( pac _ server . pac _ url ) ; } private void start _ releasing _ memory ( ) { ram _ thread = new thread ( new thread _ start ( release _ memory ) ) ; ram _ thread . is _ background = true ; ram _ thread . start ( ) ;
} catch ( exception ex ) { error ? . invoke ( this , new error _ event _ args ( ex ) ) ; } <%> <+> } public static bool merge _ and _ write _ pac _ file ( string gfw _ list _ result ) { list < string > lines = new list < string > ( ) ; if ( file . exists ( pac _ server . user _ rule _ file ) ) </%>
private int total _ read = 0 ; private int total _ write = 0 ; private byte [ ] remote _ recv _ buffer = new byte [ <%> <*> recv -> buffer </%> _ size ] ; private byte [ ] remote _ send _ buffer = new byte [ buffer _ size ] ; private byte [ ] connetion _ recv _ buffer = new byte [ <%> <*> recv -> buffer </%> _ size ] ; private byte [ ] connetion _ send _ buffer = new byte [ buffer _ size ] ; private bool connection _ shutdown = false ; private bool remote _ shutdown = false ; private bool closed = false ; private object encryption _ lock = new object ( ) ;
private byte [ ] remote _ send _ buffer = new byte [ buffer _ size ] ; private byte [ ] connetion _ recv _ buffer = new byte [ <%> <*> recv -> buffer </%> _ size ] ; private byte [ ] connetion _ send _ buffer = new byte [ buffer _ size ] ; private bool connection _ shutdown = false ; private bool remote _ shutdown = false ; private bool closed = false ; private object encryption _ lock = new object ( ) ; private object decryption _ lock = new object ( ) ; private date _ time start _ connect _ time ; public void create _ remote ( )
private byte [ ] connetion _ send _ buffer = new byte [ buffer _ size ] ; private bool connection _ shutdown = false ; private bool remote _ shutdown = false ; private bool closed = false ; private object encryption _ lock = new object ( ) ; private object decryption _ lock = new object ( ) ; private date _ time start _ connect _ time ; public void create _ remote ( ) { server server = controller . get _ a _ server ( i _ strategy _ caller _ type . tcp , ( ip _ end _ point ) connection . remote _ end _ point ) ;
{ message _ box . show ( n . get _ string ( STR ) ) ; server _ port _ text _ box . <%> <*> clear -> focus </%> ( ) ; return false ; } server . password = password _ text _ box . text ; server . method = encryption _ select . text ; server . remarks = remarks _ text _ box . text ; <%> <-> try { </%>
return false ; } server . password = password _ text _ box . text ; server . method = encryption _ select . text ; server . remarks = remarks _ text _ box . text ; <%> <-> try { server . timeout = int . parse ( timeout _ text _ box . text ) ; } catch ( format _ exception ) </%>
{ message _ box . show ( n . get _ string ( STR ) ) ; timeout _ text _ box . <%> <*> clear -> focus </%> ( ) ; return false ; } server . auth = one _ time _ auth . checked ; int local _ port = int . parse ( proxy _ port _ text _ box . text ) ; configuration . check _ server ( server ) ; configuration . check _ local _ port ( local _ port ) ; modified _ configuration . configs [ last _ selected _ index ] = server ;
return false ; } server . auth = one _ time _ auth . checked ; int local _ port = int . parse ( proxy _ port _ text _ box . text ) ; configuration . check _ server ( server ) ; configuration . check _ local _ port ( local _ port ) ; modified _ configuration . configs [ last _ selected _ index ] = server ; modified _ configuration . local _ port = local _ port ; return true ; }
return false ; <%> <*> } if ( length < 2 | | first _ packet [ 0 ] ! = NUM ) -> else </%> { <%> <-> return false ; } </%> socket . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; tcp _ handler handler = new tcp _ handler ( this ) ; handler . connection = socket ; handler . controller = controller ;
} public void update _ inbound _ counter ( server server , long n ) { controller . update _ inbound _ counter ( server , n ) ; } public void update _ outbound _ counter ( server server , long n ) { controller . update _ outbound _ counter ( server , n ) ; } public void update _ latency ( server server , time _ span latency )
} public void create _ remote ( ) { server server = controller . get _ a _ server ( i _ strategy _ caller _ type . tcp , ( ip _ end _ point ) connection . remote _ end _ point ) ; if ( server = = null | | server . server = = STR ) <%> <-> { </%> throw new argument _ exception ( STR ) ; <%> <-> } </%> encryptor = encryptor _ factory . get _ encryptor ( server . method , server . password , server . auth , false ) ; this . server = server ;
throw new argument _ exception ( STR ) ; <%> <-> } </%> encryptor = encryptor _ factory . get _ encryptor ( server . method , server . password , server . auth , false ) ; this . server = server ; } public void start ( byte [ ] first _ packet , int length ) { first _ packet = first _ packet ; first _ packet _ length = length ; handshake _ receive ( ) ;
encryptor = encryptor _ factory . get _ encryptor ( server . method , server . password , server . auth , false ) ; this . server = server ; } public void start ( byte [ ] first _ packet , int length ) { first _ packet = first _ packet ; first _ packet _ length = length ; handshake _ receive ( ) ; last _ activity = date _ time . now ; }
return ; <%> <-> } </%> <%> <+> else </%> closed = true ; } <%> <-> if ( connection ! = null ) { </%> try { connection <%> <+> ? </%> . shutdown ( socket _ shutdown . both ) ; connection <%> <+> ? </%> . close ( ) ;
} lock ( encryption _ lock ) { lock ( decryption _ lock ) { <%> <*> if ( encryptor ! = null ) { ( ( i _ disposable ) encryptor ) . dispose ( ) ; } -> encryptor ? . dispose ( ) ; </%>
} } } private void handshake _ receive ( ) { <%> <*> if ( closed ) { return ; } -> if ( closed ) return ; </%>
try { int bytes _ read = first _ packet _ length ; if ( bytes _ read > 1 ) { byte [ ] response = { NUM , 0 } ; if ( first _ packet [ 0 ] ! = NUM ) { response = new byte [ ] { 0 , NUM } ; logging . error ( STR ) ;
close ( ) ; <%> <-> } </%> } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; } } private void handshake _ send _ callback ( i _ async _ result ar )
} catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; } } private void handshake _ send _ callback ( i _ async _ result ar ) { <%> <-> if ( closed ) </%>
try { connection . end _ send ( ar ) ; connection . begin _ receive ( connetion _ recv _ buffer , 0 , NUM , 0 , new async _ callback ( handshake _ receive _ callback ) , null ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; }
handle _ udp _ associate ( ) ; <%> <-> } </%> } else { logging . debug ( STR ) ; close ( ) ; } } catch ( exception e )
} else { logging . debug ( STR ) ; close ( ) ; } } catch ( exception e ) { logging . log _ useful _ exception ( e ) ;
} address . copy _ to ( response , NUM ) ; response [ response . length - 1 ] = ( byte ) ( port & 0 xff ) ; response [ response . length - 2 ] = ( byte ) ( ( port > > NUM ) & 0 xff ) ; connection . begin _ send ( response , 0 , response . length , 0 , new async _ callback ( read _ all ) , true ) ; } private void read _ all ( i _ async _ result ar ) { <%> <-> if ( closed ) { </%>
try { if ( ar . async _ state ! = null ) { connection . end _ send ( ar ) ; logging . debug ( remote , recv _ size , STR ) ; connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , 0 , new async _ callback ( read _ all ) , null ) ; } else {
close ( ) ; <%> <-> } </%> } } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; } }
} } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; } } private void response _ callback ( i _ async _ result ar ) {
server server = ( ( server _ timer ) sender ) . server ; i _ strategy strategy = controller . get _ current _ strategy ( ) ; <%> <*> if ( strategy ! = null ) { strategy . set _ failure ( server ) ; } -> strategy ? . set _ failure ( server ) ; </%> logging . info ( $ STR ) ; remote . close ( ) ; retry _ connect ( ) ;
logging . info ( $ STR ) ; remote . close ( ) ; retry _ connect ( ) ; } private void retry _ connect ( ) { if ( retry _ count < max _ retry ) { logging . debug ( $ STR ) ; start _ connect ( ) ;
} private void connect _ callback ( i _ async _ result ar ) { <%> <*> server server = null ; if ( closed ) { return ; } -> if ( closed ) return ; </%> try
try { server _ timer timer = ( server _ timer ) ar . async _ state ; <%> <+> server </%> server = timer . server ; timer . elapsed - = connect _ timer _ elapsed ; timer . enabled = false ; timer . dispose ( ) ; remote . end _ connect ( ar ) ; connected = true ; var latency = date _ time . now - start _ connect _ time ;
timer . elapsed - = connect _ timer _ elapsed ; timer . enabled = false ; timer . dispose ( ) ; remote . end _ connect ( ar ) ; connected = true ; var latency = date _ time . now - start _ connect _ time ; i _ strategy strategy = controller . get _ current _ strategy ( ) ; strategy ? . update _ latency ( server , latency ) ; tcprelay . update _ latency ( server , latency ) ; start _ pipe ( ) ;
} logging . log _ useful _ exception ( e ) ; retry _ connect ( ) ; } } private void start _ pipe ( ) { <%> <-> if ( closed ) { return ; </%>
try { start _ receiving _ time = date _ time . now ; remote . begin _ receive ( remote _ recv _ buffer , 0 , recv _ size , 0 , new async _ callback ( pipe _ remote _ receive _ callback ) , null ) ; connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , 0 , new async _ callback ( pipe _ connection _ receive _ callback ) , null ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ;
encryptor . decrypt ( remote _ recv _ buffer , bytes _ read , remote _ send _ buffer , out bytes _ to _ send ) ; } connection . begin _ send ( remote _ send _ buffer , 0 , bytes _ to _ send , 0 , new async _ callback ( pipe _ connection _ send _ callback ) , null ) ; i _ strategy strategy = controller . get _ current _ strategy ( ) ; <%> <*> if ( strategy ! = null ) { strategy . update _ last _ read ( server ) ; } -> strategy ? . update _ last _ read ( server ) ; </%> }
} else { connection . shutdown ( socket _ shutdown . send ) ; connection _ shutdown = true ; check _ close ( ) ; } } catch ( exception e ) {

} public string identifier ( ) { return server + ':' + server _ port ; } } }
} <%> <*> if ( changed ) { log _ message _ text _ box . scroll _ to _ caret ( ) ; } last _ offset = reader . base _ stream . position ; -> } catch ( file _ not _ found _ exception ) { </%> } this . text = n . get _ string ( STR ) + $ STR ;
} this . text = n . get _ string ( STR ) + $ STR ; } private void log _ form _ load ( object sender , event _ args e ) { init _ content ( ) ; timer = new timer ( ) ; timer . interval = NUM ; timer . tick + = timer _ tick ;
sw . auto _ flush = true ; console . set _ out ( sw ) ; console . set _ error ( sw ) ; return true ; } catch ( io _ exception e ) { console . write _ line ( e . to _ string ( ) ) ; return false ; }
} public static void error ( object o ) { write _ to _ log _ file ( STR + o ) ; } public static void info ( object o ) { write _ to _ log _ file ( o ) ; <%> <+> } public static void clear ( ) { </%>
save _ config ( config ) ; if ( enable _ status _ changed ! = null ) { enable _ status _ changed ( this , new event _ args ( ) ) ; } } public void toggle _ global ( bool global ) { config . global = global ; <%> <-> update _ system _ proxy ( ) ; </%>
save _ config ( config ) ; if ( enable _ global _ changed ! = null ) { enable _ global _ changed ( this , new event _ args ( ) ) ; } } public void toggle _ share _ over _ lan ( bool enabled ) { config . share _ over _ lan = enabled ; save _ config ( config ) ;
save _ config ( config ) ; if ( config _ changed ! = null ) { config _ changed ( this , new event _ args ( ) ) ; } } public void use _ online _ pac ( bool use _ online _ pac ) { config . use _ online _ pac = use _ online _ pac ; <%> <-> update _ system _ proxy ( ) ; </%>
save _ config ( config ) ; if ( config _ changed ! = null ) { config _ changed ( this , new event _ args ( ) ) ; } } public void toggle _ checking _ update ( bool enabled ) { config . auto _ check _ update = enabled ; configuration . save ( config ) ;
using system _ diagnostics ; using system _ io ; using system _ linq ; using system _ net ; <%> <-> using system _ net _ network _ information ; </%> using system _ net _ sockets ; <%> <-> using system _ runtime _ interop _ services ; </%> using system _ text ; using system _ windows _ forms ; using shadowsocks _ model ;
using system _ net _ sockets ; <%> <-> using system _ runtime _ interop _ services ; </%> using system _ text ; using system _ windows _ forms ; using shadowsocks _ model ; using shadowsocks _ properties ; using shadowsocks _ util ; using shadowsocks _ util _ process _ management ; namespace shadowsocks _ controller {
using system _ text ; using system _ windows _ forms ; using shadowsocks _ model ; using shadowsocks _ properties ; using shadowsocks _ util ; using shadowsocks _ util _ process _ management ; namespace shadowsocks _ controller { class privoxy _ runner {
privoxy _ config = privoxy _ config . replace ( STR , configuration . local _ port . to _ string ( ) ) ; privoxy _ config = privoxy _ config . replace ( STR , running _ port . to _ string ( ) ) ; privoxy _ config = privoxy _ config . replace ( STR , configuration . share _ over _ lan ? STR : STR ) ; file _ manager . byte _ array _ to _ file ( utils . get _ temp _ path ( unique _ config _ file ) , encoding . ut . get _ bytes ( privoxy _ config ) ) ; process = new process <%> <*> ( ) ; -> { </%> <%> <-> process . </%> start _ info <%> <-> . file _ name </%> = <%> <*> STR ; process . start _ info . arguments = unique _ config _ file ; process . start _ info . working -> { file </%> _ <%> <*> directory -> name </%> = <%> <*> utils . get _ temp _ path ( ) ; process . start _ info . window _ style -> STR , arguments </%> = <%> <*> process -> unique </%> _ <%> <*> window -> config </%> _ <%> <*> style . hidden ; -> file , </%>
process . start ( ) ; * add this process to job obj associated with this ss process , so that * when ss exit unexpectedly , this process will be forced killed by system . * / privoxy _ job . add _ process ( process . handle ) ; } <%> <-> refresh _ tray _ area ( ) ; </%> } public void stop ( ) {
} public void stop ( ) { if ( process ! = null ) { kill _ process ( process ) ; process . dispose ( ) ; process = null ; } <%> <-> refresh _ tray _ area ( ) ; </%>
} private static void kill _ process ( process p ) { try { p . close _ main _ window ( ) ; p . wait _ for _ exit ( NUM ) ; if ( ! p . has _ exited ) { p . kill ( ) ;
( ( system . component _ model . i _ support _ initialize ) ( this . picture _ box ) ) . begin _ init ( ) ; <%> <-> this . panel . suspend _ layout ( ) ; </%> this . suspend _ layout ( ) ; <%> <-> this . picture _ box . dock = system . windows . forms . dock _ style . fill ; </%> this . picture _ box . location = new system . drawing . point ( NUM , NUM ) ; this . picture _ box . margin = new system . windows . forms . padding ( 0 ) ; this . picture _ box . name = STR ; this . picture _ box . size = new system . drawing . size ( NUM , NUM ) ; this . picture _ box . size _ mode = system . windows . forms . picture _ box _ size _ mode . <%> <*> stretch _ image -> zoom </%> ; this . picture _ box . tab _ index = 1 ;
this . suspend _ layout ( ) ; <%> <-> this . picture _ box . dock = system . windows . forms . dock _ style . fill ; </%> this . picture _ box . location = new system . drawing . point ( NUM , NUM ) ; this . picture _ box . margin = new system . windows . forms . padding ( 0 ) ; this . picture _ box . name = STR ; this . picture _ box . size = new system . drawing . size ( NUM , NUM ) ; this . picture _ box . size _ mode = system . windows . forms . picture _ box _ size _ mode . <%> <*> stretch _ image -> zoom </%> ; this . picture _ box . tab _ index = 1 ; this . picture _ box . tab _ stop = false ; <%> <-> this . panel . controls . add ( this . picture _ box ) ; </%>
this . picture _ box . margin = new system . windows . forms . padding ( 0 ) ; this . picture _ box . name = STR ; this . picture _ box . size = new system . drawing . size ( NUM , NUM ) ; this . picture _ box . size _ mode = system . windows . forms . picture _ box _ size _ mode . <%> <*> stretch _ image -> zoom </%> ; this . picture _ box . tab _ index = 1 ; this . picture _ box . tab _ stop = false ; <%> <-> this . panel . controls . add ( this . picture _ box ) ; this . panel . dock = system . windows . forms . dock _ style . fill ; this . panel . location = new system . drawing . point ( 0 , 0 ) ; this . panel . margin = new system . windows . forms . padding ( 0 ) ; </%>
this . picture _ box . tab _ index = 1 ; this . picture _ box . tab _ stop = false ; <%> <-> this . panel . controls . add ( this . picture _ box ) ; this . panel . dock = system . windows . forms . dock _ style . fill ; this . panel . location = new system . drawing . point ( 0 , 0 ) ; this . panel . margin = new system . windows . forms . padding ( 0 ) ; this . panel . name = STR ; this . panel . padding = new system . windows . forms . padding ( NUM ) ; this . panel . size = new system . drawing . size ( NUM , NUM ) ; this . panel . tab _ index = 2 ; </%>
this . back _ color = system . drawing . color . white ; this . client _ size = new system . drawing . size ( NUM , NUM ) ; this . controls . add ( this . <%> <*> panel -> picture _ box </%> ) ; this . form _ border _ style = system . windows . forms . form _ border _ style . fixed _ single ; this . maximize _ box = false ; this . minimize _ box = false ; this . name = STR ; <%> <+> this . padding = new system . windows . forms . padding ( NUM ) ; </%> this . start _ position = system . windows . forms . form _ start _ position . center _ screen ; this . text = STR ;
this . form _ border _ style = system . windows . forms . form _ border _ style . fixed _ single ; this . maximize _ box = false ; this . minimize _ box = false ; this . name = STR ; <%> <+> this . padding = new system . windows . forms . padding ( NUM ) ; </%> this . start _ position = system . windows . forms . form _ start _ position . center _ screen ; this . text = STR ; this . load + = new system . event _ handler ( this . qr _ code _ form _ load ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . picture _ box ) ) . end _ init ( ) ; <%> <-> this . panel . resume _ layout ( false ) ; </%>
this . resume _ layout ( false ) ; } private system . windows . forms . picture _ box picture _ box ; <%> <-> private system . windows . forms . panel panel ; </%> } }
} }
private readonly concurrent _ dictionary < string , list < int > > inbound _ speed _ records = new concurrent _ dictionary < string , list < int > > ( ) ; <%> <-> private readonly concurrent _ dictionary < string , long > outbound _ counter = new concurrent _ dictionary < string , long > ( ) ; private readonly concurrent _ dictionary < string , long > last _ outbound _ counter = new concurrent _ dictionary < string , long > ( ) ; </%> private readonly concurrent _ dictionary < string , list < int > > outbound _ speed _ records = new concurrent _ dictionary < string , list < int > > ( ) ; <%> <+> private readonly concurrent _ dictionary < string , in _ out _ bound _ record > in _ out _ bound _ records = new concurrent _ dictionary < string , in _ out _ bound _ record > ( ) ; private class in _ out _ bound _ record { private long inbound ; private long last _ inbound ; private long outbound ; </%>
private readonly concurrent _ dictionary < string , list < int > > outbound _ speed _ records = new concurrent _ dictionary < string , list < int > > ( ) ; <%> <+> private readonly concurrent _ dictionary < string , in _ out _ bound _ record > in _ out _ bound _ records = new concurrent _ dictionary < string , in _ out _ bound _ record > ( ) ; private class in _ out _ bound _ record { private long inbound ; private long last _ inbound ; private long outbound ; private long last _ outbound ; private spin _ lock lock = new spin _ lock ( ) ; public void update _ inbound ( long delta ) </%>
{ var id = kv . key ; <%> <-> var last _ inbound = kv . value ; var inbound = inbound _ counter [ id ] ; var bytes = inbound - last _ inbound ; last _ inbound _ counter [ id ] = inbound ; var inbound _ speed = get _ speed _ in _ ki _ b _ per _ second ( bytes , monitor _ interval . total _ seconds ) ; inbound _ speed _ records . get _ or _ add ( id , ( k ) = > { list < int > records = new list < int > ( ) ; </%>
logging . debug ( $ STR ) ; } } private void reset ( ) { inbound _ speed _ records . clear ( ) ; outbound _ speed _ records . clear ( ) ; latency _ records . clear ( ) ; }
} public void update _ outbound _ counter ( server server , long n ) { <%> <*> outbound -> in _ out _ bound </%> _ <%> <*> counter -> records </%> . add _ or _ update ( server . identifier ( ) , ( k ) = > { <%> <*> last _ outbound -> var r = new in </%> _ <%> <*> counter . get -> out </%> _ <%> <*> or -> bound </%> _ <%> <*> add -> record </%> ( <%> <-> server . identifier ( ) , 0 </%> ) ; <%> <*> return -> r . update _ outbound ( </%> n <%> <+> ) </%> ; <%> <*> } , ( k , v ) = > ( v + n ) ) -> return r </%> ; <%> <+> } , ( k , v ) = > { </%>
} class update _ records _ state { public int counter ; } class ping _ state { public update _ records _ state state ; public statistics _ record record ; }
throw new argument _ exception ( n . get _ string ( STR ) ) ; } private static void check _ server ( string server ) { if ( <%> <*> string -> server </%> . is _ null _ or _ empty ( <%> <-> server </%> ) ) throw new argument _ exception ( n . get _ string ( STR ) ) ; } } }
throw new argument _ exception ( n . get _ string ( STR ) ) ; } } }
{ return n . get _ string ( STR ) ; } if ( <%> <*> string -> remarks </%> . is _ null _ or _ empty ( <%> <-> remarks </%> ) ) { return server + STR + server _ port ; } else { return remarks + STR + server + STR + server _ port + STR ;
{ return server + STR + server _ port ; } else { return remarks + STR + server + STR + server _ port + STR ; } } public server ( ) {
{ update _ online _ pacurl _ item _ click ( sender , e ) ; } if ( ! <%> <-> string . is _ null _ or _ empty ( </%> controller . get _ configuration _ copy ( ) . pac _ url <%> <+> . is _ null _ or _ empty ( </%> ) ) { local _ pac _ item . checked = false ; online _ pac _ item . checked = true ; controller . use _ online _ pac ( true ) ; } update _ pac _ items _ enabled _ status ( ) ;
{ local _ pac _ item . checked = false ; online _ pac _ item . checked = true ; controller . use _ online _ pac ( true ) ; } update _ pac _ items _ enabled _ status ( ) ; } } private void update _ online _ pacurl _ item _ click ( object sender , event _ args e ) {
if ( i = = 0 ) { md _ sum = <%> <*> md . compute _ hash -> mbed _ tls . m </%> ( password ) ; } else { md _ sum . copy _ to ( result , 0 ) ; password . copy _ to ( result , md _ sum . length ) ; md _ sum = <%> <*> md . compute _ hash -> mbed _ tls . m </%> ( result ) ; }
} else { md _ sum . copy _ to ( result , 0 ) ; password . copy _ to ( result , md _ sum . length ) ; md _ sum = <%> <*> md . compute _ hash -> mbed _ tls . m </%> ( result ) ; } md _ sum . copy _ to ( key , i ) ; i + = md _ sum . length ; }
} md _ sum . copy _ to ( key , i ) ; i + = md _ sum . length ; } } protected static void rand _ bytes ( byte [ ] buf , int length ) { byte [ ] temp = new byte [ length ] ; rng _ crypto _ service _ provider rng _ service _ provider = new rng _ crypto _ service _ provider ( ) ; rng _ service _ provider . get _ bytes ( temp ) ;
this . share _ over _ lan _ item . text = STR ; this . share _ over _ lan _ item . click + = new system . event _ handler ( this . share _ over _ lan _ item _ click ) ; this . servers _ item . index = <%> <*> 2 -> NUM </%> ; this . servers _ item . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . seperator _ item , this . config _ item } ) ; this . servers _ item . text = STR ; this . seperator _ item . index = 0 ; this . seperator _ item . text = STR ; this . config _ item . index = 1 ;
this . servers _ item . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . seperator _ item , this . config _ item } ) ; this . servers _ item . text = STR ; this . seperator _ item . index = 0 ; this . seperator _ item . text = STR ; this . config _ item . index = 1 ; this . config _ item . text = STR ; this . config _ item . click + = new system . event _ handler ( this . config _ click ) ; this . menu _ item . index = NUM ;
foreach ( result _ point point in result . result _ points ) { min _ x = math . min ( min _ x , point . x ) ; min _ y = math . min ( min _ y , point . y ) ; max _ x = math . max ( max _ x , point . x ) ; max _ y = math . max ( max _ y , point . y ) ; } <%> <+> min _ x / = image _ scale ; min _ y / = image _ scale ; max _ x / = image _ scale ; </%>
private configuration config ; public event event _ handler pac _ file _ changed ; <%> <+> public event event _ handler user _ rule _ file _ changed ; </%> public pac _ server ( ) { this . watch _ pac _ file ( ) ; <%> <+> this . watch _ user _ rule _ file ( ) ; </%> } public void update _ configuration ( configuration config ) {
{ if ( pac _ file _ changed ! = null ) { <%> <+> console . write _ line ( STR , e . name , e . change _ type . to _ string ( ) . to _ lower ( ) ) ; </%> pac _ file _ changed ( this , new event _ args ( ) ) ; <%> <+> } } private void user _ rule _ file _ watcher _ changed ( object sender , file _ system _ event _ args e ) { if ( user _ rule _ file _ changed ! = null ) </%>
{ if ( locale _ names [ i ] = = STR ) <%> <+> en _ index = i ; if ( locale _ names [ i ] = = locale ) target _ index = i ; } if ( target _ index = = - 1 ) { string locale _ no _ region = locale . split ( '-' ) [ 0 ] ; for ( int i = 0 ; i < locale _ names . length ; i + + ) </%>
} } <%> <+> if ( target _ index = = - 1 ) { logging . info ( $ STR ) ; return ; } </%> while ( ! csv _ parser . end _ of _ data ) { string [ ] translations = csv _ parser . read _ fields ( ) ;
if ( translations [ 0 ] . trim _ start ( ' ' ) [ 0 ] = = '#' ) continue ; strings [ <%> <*> translations [ en _ index ] -> source </%> ] = <%> <*> translations [ target _ index ] -> translation </%> ; } } } static n ( ) { <%> <*> init ( resources . n _ csv , culture _ info . current _ culture . ietf _ language _ tag ) ; -> string n ; </%> <%> <+> if ( ! file . exists ( n _ file ) ) </%>
} } } static n ( ) { <%> <*> init ( resources . n _ csv , culture _ info . current _ culture . ietf _ language _ tag ) ; -> string n ; </%> <%> <+> if ( ! file . exists ( n _ file ) ) { n = resources . n _ csv ; </%>
} public static string get _ string ( string key , params object [ ] args ) { return string . format ( strings . try _ get _ value ( key , out var value ) ? value : key , args ) ; } public static void translate _ form ( form c ) { c . text = get _ string ( c . text ) ; foreach ( var item in view _ utils . get _ child _ controls < control > ( c ) ) {
this . group _ box . suspend _ layout ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . begin _ init ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . suspend _ layout ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . begin _ init ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . suspend _ layout ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . data _ collection _ minutes _ num ) ) . begin _ init ( ) ;
public string server _ name ; public string icmp _ status ; public int roundtrip _ time ; public string geolocation ; public string isp ; } public class statistics _ data { public float package _ loss ; public int average _ response ;
var server _ urls = ss _ url . split ( '\r' , '\n' ) ; list < server > servers = new list < server > ( ) ; foreach ( string server _ url in server _ urls ) { string server _ url = server _ url . trim ( ) ; if ( ! server _ url . begin _ with ( STR , string _ comparison . invariant _ culture _ ignore _ case ) ) { continue ; } <%> <-> int index _ of _ hash _ or _ slash = server _ url . index _ of _ any ( new [ ] { '@' , '/' , '#' } , </%>
{ <%> <*> parsed _ url = new uri -> servers . add </%> ( <%> <*> decoded -> legacy </%> _ server <%> <-> _ url </%> ) ; } <%> <-> catch ( uri _ format _ exception ) </%> <%> <+> else </%> { <%> <+> uri parsed _ url ; try { parsed _ url = new uri ( server _ url ) ; } </%>
} <%> <-> catch ( uri _ format _ exception ) </%> <%> <+> else </%> { <%> <+> uri parsed _ url ; try { parsed _ url = new uri ( server _ url ) ; } catch ( uri _ format _ exception ) { </%>
{ <%> <+> uri parsed _ url ; try { parsed _ url = new uri ( server _ url ) ; } catch ( uri _ format _ exception ) { </%> continue ; <%> <+> } </%>
} <%> <-> server tmp = new server { remarks = parsed _ url . get _ components ( uri _ components . fragment , uri _ format . unescaped ) } ; string user _ info = parsed _ url . get _ components ( uri _ components . user _ info , uri _ format . unescaped ) ; tmp . server = parsed _ url . get _ components ( uri _ components . host , uri _ format . unescaped ) ; tmp . server _ port = parsed _ url . port ; string [ ] user _ info _ parts = user _ info . split ( new [ ] { ':' } , 2 ) ; if ( user _ info _ parts . length ! = 2 ) </%>
} return servers ; } public string identifier ( ) { return server + ':' + server _ port ; } } }
public sodium _ encryptor ( string method , string password ) : base ( method , password ) { init _ key ( method , password ) ; <%> <-> encrypt _ buf = new byte [ max _ input _ size + sodium _ block _ size ] ; decrypt _ buf = new byte [ max _ input _ size + sodium _ block _ size ] ; </%> } private static dictionary < string , int [ ] > ciphers = new dictionary < string , int [ ] > { { STR , new int [ ] { NUM , NUM , cipher _ sals , polar _ ssl . aes _ ctx _ size } } , { STR , new int [ ] { NUM , NUM , cipher _ chach , polar _ ssl . aes _ ctx _ size } } ,
} private static dictionary < string , int [ ] > ciphers = new dictionary < string , int [ ] > { { STR , new int [ ] { NUM , NUM , cipher _ sals , polar _ ssl . aes _ ctx _ size } } , { STR , new int [ ] { NUM , NUM , cipher _ chach , polar _ ssl . aes _ ctx _ size } } , } ; protected override dictionary < string , int [ ] > get _ ciphers ( ) { return ciphers ; } public static list < string > supported _ ciphers ( )
byte [ ] iv ; <%> <*> if ( is _ cipher ) -> lock ( sodium _ buf ) </%> { <%> <+> if ( is _ cipher ) { </%> bytes _ remaining = encrypt _ bytes _ remaining ; ic = encrypt _ ic ; <%> <-> sodium _ buf = encrypt _ buf ; </%> iv = encrypt _ iv ;
{ <%> <+> if ( is _ cipher ) { </%> bytes _ remaining = encrypt _ bytes _ remaining ; ic = encrypt _ ic ; <%> <-> sodium _ buf = encrypt _ buf ; </%> iv = encrypt _ iv ; } else {
} } public override void dispose ( ) { } } }
stream . close ( ) ; } } } } }
} public server get _ current _ server ( ) { return config . get _ current _ server ( ) ; } public configuration get _ configuration ( ) { return configuration . load ( ) ; } public void save _ servers ( list < server > servers )
config = configuration . load ( ) ; <%> <+> if ( polipo _ runner = = null ) { polipo _ runner = new polipo _ runner ( ) ; } if ( pac _ server = = null ) { pac _ server = new pac _ server ( ) ; pac _ server . pac _ file _ changed + = pac _ server _ pac _ file _ changed ; } </%>
polipo _ runner . stop ( ) ; <%> <+> try { </%> polipo _ runner . start ( config ) ; local = new local ( config ) ; local . start ( ) ; pac _ server . start ( config ) ; <%> <+> } catch ( exception e ) { </%>
if ( config _ changed ! = null ) { config _ changed ( this , new event _ args ( ) ) ; } <%> <+> update _ system _ proxy ( ) ; </%> util . util . release _ memory ( ) ; <%> <+> } protected void save _ config ( configuration new _ config ) { configuration . save ( new _ config ) ; </%>
start _ pipe ( ) ; } catch ( argument _ exception e ) { } catch ( exception e ) { if ( server ! = null ) { <%> <-> controller . get _ current _ strategy ( ) . set _ failure ( server ) ; </%>
} logging . log _ useful _ exception ( e ) ; retry _ connect ( ) ; } } private void start _ pipe ( ) { if ( closed ) { return ;
private menu _ item servers _ item ; <%> <-> private menu _ item seperator _ item ; private menu _ item quit _ item ; private menu _ item seperator _ item ; private menu _ item mode _ item ; </%>

this . servers _ item = create _ menu _ group ( 2 , STR , new system . windows . forms . menu _ item [ ] { this . seperator _ item , this . config _ item <%> <-> } ) ; </%> <%> <*> this . seperator _ item = create _ seperator _ item ( NUM -> } </%> ) ; this . auto _ startup _ item = create _ menu _ item ( NUM , STR , new system . event _ handler ( this . auto _ startup _ item _ click ) ) ; this . share _ over _ lan _ item = create _ menu _ item ( NUM , STR , new system . event _ handler ( this . share _ over _ lan _ item _ click ) ) ; <%> <-> this . edit _ pac _ file _ item = create _ menu _ item ( NUM , STR , new system . event _ handler ( this . edit _ pac _ file _ item _ click ) ) ; this . seperator _ item = create _ seperator _ item ( NUM ) ; this . qr _ code _ item = create _ menu _ item ( NUM , STR , new system . event _ handler ( this . qr _ code _ item _ click ) ) ; this . show _ log _ item = create _ menu _ item ( NUM , STR , new system . event _ handler ( this . show _ log _ item _ click ) ) ; </%>
this . auto _ startup _ item = create _ menu _ item ( NUM , STR , new system . event _ handler ( this . auto _ startup _ item _ click ) ) ; this . share _ over _ lan _ item = create _ menu _ item ( NUM , STR , new system . event _ handler ( this . share _ over _ lan _ item _ click ) ) ; <%> <-> this . edit _ pac _ file _ item = create _ menu _ item ( NUM , STR , new system . event _ handler ( this . edit _ pac _ file _ item _ click ) ) ; this . seperator _ item = create _ seperator _ item ( NUM ) ; this . qr _ code _ item = create _ menu _ item ( NUM , STR , new system . event _ handler ( this . qr _ code _ item _ click ) ) ; this . show _ log _ item = create _ menu _ item ( NUM , STR , new system . event _ handler ( this . show _ log _ item _ click ) ) ; this . about _ item = create _ menu _ item ( NUM , STR , new system . event _ handler ( this . config _ click ) ) ; this . seperator _ item = create _ seperator _ item ( NUM ) ; this . quit _ item = create _ menu _ item ( NUM , STR , new system . event _ handler ( this . quit _ click ) ) ; </%> this . context _ menu . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] {
this . context _ menu . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . enable _ item , <%> <*> this . mode _ item , -> create _ menu _ group ( 1 , STR , new system . windows . forms . menu _ item [ ] { </%> <%> <+> this . pac _ mode _ item , this . global _ mode _ item } ) , </%> this . servers _ item , <%> <*> this . -> create _ </%> seperator _ item <%> <+> ( NUM ) </%> , this . auto _ startup _ item ,
this . servers _ item , <%> <*> this . -> create _ </%> seperator _ item <%> <+> ( NUM ) </%> , this . auto _ startup _ item , this . share _ over _ lan _ item , <%> <+> create _ menu _ item ( NUM , STR , new system . event _ handler ( </%> this . edit _ pac _ file _ item <%> <+> _ click ) ) </%> , <%> <*> this . -> create _ </%> seperator _ item <%> <+> ( NUM ) </%> , <%> <+> create _ menu _ item ( NUM , STR , new system . event _ handler ( </%> this . qr _ code _ item <%> <+> _ click ) ) </%> , <%> <+> create _ menu _ item ( NUM , STR , new system . event _ handler ( </%> this . show _ log _ item <%> <+> _ click ) ) </%> , <%> <+> create _ menu _ item ( NUM , STR , new system . event _ handler ( </%> this . <%> <*> about -> config </%> _ <%> <*> item -> click ) ) </%> , <%> <*> this . -> create _ </%> seperator _ item <%> <+> ( NUM ) </%> ,
this . auto _ startup _ item , this . share _ over _ lan _ item , <%> <+> create _ menu _ item ( NUM , STR , new system . event _ handler ( </%> this . edit _ pac _ file _ item <%> <+> _ click ) ) </%> , <%> <*> this . -> create _ </%> seperator _ item <%> <+> ( NUM ) </%> , <%> <+> create _ menu _ item ( NUM , STR , new system . event _ handler ( </%> this . qr _ code _ item <%> <+> _ click ) ) </%> , <%> <+> create _ menu _ item ( NUM , STR , new system . event _ handler ( </%> this . show _ log _ item <%> <+> _ click ) ) </%> , <%> <+> create _ menu _ item ( NUM , STR , new system . event _ handler ( </%> this . <%> <*> about -> config </%> _ <%> <*> item -> click ) ) </%> , <%> <*> this . -> create _ </%> seperator _ item <%> <+> ( NUM ) </%> , <%> <+> create _ menu _ item ( NUM , STR , new system . event _ handler ( </%> this . quit _ <%> <*> item -> click ) ) </%> } ) ; }
} private void controller _ config _ changed ( object sender , event _ args e ) { load _ current _ configuration ( ) ; update _ tray _ icon ( ) ; } private void controller _ enable _ status _ changed ( object sender , event _ args e ) { enable _ item . checked = controller . get _ configuration ( ) . enabled ; }
list < string > versions = new list < string > ( ) ; foreach ( <%> <*> xml -> json </%> _ <%> <*> node el -> object release </%> in <%> <*> elements -> result </%> ) { <%> <*> foreach -> if </%> ( <%> <*> xml _ attribute attr in el . attributes -> ( bool ) release [ STR ] </%> ) { <%> <*> if ( attr . name = = STR ) -> continue ; </%> <%> <+> } foreach ( json _ object asset in ( json _ array ) release [ STR ] ) { </%>
{ <%> <*> foreach -> if </%> ( <%> <*> xml _ attribute attr in el . attributes -> ( bool ) release [ STR ] </%> ) { <%> <*> if ( attr . name = = STR ) -> continue ; </%> <%> <+> } foreach ( json _ object asset in ( json _ array ) release [ STR ] ) { string url = ( string ) asset [ STR ] ; if ( is _ new _ version ( url ) ) </%>
{ <%> <*> if ( attr . name = = STR ) -> continue ; </%> <%> <+> } foreach ( json _ object asset in ( json _ array ) release [ STR ] ) { string url = ( string ) asset [ STR ] ; if ( is _ new _ version ( url ) ) </%> { <%> <-> if ( is _ new _ version ( attr . value ) ) </%>
{ <%> <*> if ( is _ new _ version ( attr . value ) ) { versions . add ( attr . value ) ; } -> versions . add ( url ) ; </%> } } } if ( versions . count = = 0 )
} } } if ( versions . count = = 0 ) { return ; } sort _ versions ( versions ) ; latest _ version _ url = versions [ versions . count - 1 ] ; latest _ version _ number = parse _ version _ from _ url ( latest _ version _ url ) ;
using shadowsocks _ controller ; using shadowsocks _ properties ; <%> <+> using shadowsocks _ model ; using system _ text ; using newtonsoft _ json ; </%> namespace shadowsocks _ util _ system _ proxy { public static class sysproxy { <%> <-> private static bool user _ settings _ recorded = false ; </%>
private static <%> <*> string [ ] -> sysproxy _ config </%> user _ settings = <%> <*> new string [ NUM ] -> null </%> ; enum ret _ errors : int { ret _ no _ error = 0 , invalid _ format = 1 , no _ permission = 2 , syscall _ failed = NUM , no _ memory = NUM , invaild _ option _ count = NUM , } ;
enum ret _ errors : int { ret _ no _ error = 0 , invalid _ format = 1 , no _ permission = 2 , syscall _ failed = NUM , no _ memory = NUM , invaild _ option _ count = NUM , } ; static sysproxy ( )
{ <%> <*> exec _ sysproxy ( STR , out str ) ; parse _ query _ str ( str ) ; user _ settings _ recorded = true ; -> exec _ sysproxy ( STR ) ; </%> <%> <+> parse _ query _ str ( query _ str ) ; </%> } string arguments ; if ( enable ) {
} string arguments ; if ( enable ) { arguments = global ? $ STR : $ STR ; } else {
arguments = $ STR ; <%> <+> user _ settings . </%> user _ settings _ recorded = false ; } <%> <*> exec _ sysproxy ( arguments , out str ) ; -> save ( ) ; </%> <%> <+> exec _ sysproxy ( arguments ) ; </%> } private static void exec _ sysproxy ( string arguments <%> <-> , out string query _ str </%> ) { using ( var process = new process ( ) )
} <%> <*> exec _ sysproxy ( arguments , out str ) ; -> save ( ) ; </%> <%> <+> exec _ sysproxy ( arguments ) ; </%> } private static void exec _ sysproxy ( string arguments <%> <-> , out string query _ str </%> ) { using ( var process = new process ( ) ) { process . start _ info . file _ name = utils . get _ temp _ path ( STR ) ;
} private static void exec _ sysproxy ( string arguments <%> <-> , out string query _ str </%> ) { using ( var process = new process ( ) ) { process . start _ info . file _ name = utils . get _ temp _ path ( STR ) ; process . start _ info . arguments = arguments ; process . start _ info . working _ directory = utils . get _ temp _ path ( ) ; process . start _ info . window _ style = process _ window _ style . hidden ; process . start _ info . use _ shell _ execute = false ;
{ using ( var process = new process ( ) ) { process . start _ info . file _ name = utils . get _ temp _ path ( STR ) ; process . start _ info . arguments = arguments ; process . start _ info . working _ directory = utils . get _ temp _ path ( ) ; process . start _ info . window _ style = process _ window _ style . hidden ; process . start _ info . use _ shell _ execute = false ; process . start _ info . redirect _ standard _ error = true ; process . start _ info . redirect _ standard _ output = true ;
} <%> <*> query _ str = stdout ; -> } </%> <%> <+> } private static void save ( ) { try { using ( stream _ writer sw = new stream _ writer ( file . open ( user _ wininet _ config _ file , file _ mode . create ) ) ) { string json _ string = json _ convert . serialize _ object ( user _ settings , formatting . indented ) ; sw . write ( json _ string ) ; </%>
} } private static void parse _ query _ str ( string str ) { <%> <-> user _ settings = str . split ( new string [ ] { STR } , string _ split _ options . remove _ empty _ entries ) ; </%> <%> <*> for ( var i -> string [ ] user _ settings _ arr </%> = <%> <*> 0 ; i < NUM ; i + + ) -> str . split ( new string [ ] { STR } , string _ split _ options . remove _ empty _ entries ) ; </%> <%> <-> { </%> <%> <+> user _ settings . flags = user _ settings _ arr [ 0 ] ; </%> if ( user _ settings <%> <+> _ arr </%> [ <%> <*> i -> 1 </%> ] = = STR ) <%> <+> user _ settings . proxy _ server = null ; else user _ settings . proxy _ server = </%> user _ settings <%> <+> _ arr </%> [ <%> <*> i -> 1 </%> ] <%> <-> = null </%> ; <%> <-> } </%> <%> <+> if ( user _ settings _ arr [ 2 ] = = STR ) user _ settings . bypass _ list = null ; </%>
} } }
using system _ collections _ generic ; <%> <+> using system _ io ; </%> using system _ runtime _ interop _ services ; using system _ text ; namespace shadowsocks _ encrypt { public class polar _ ssl { const string dllname = STR ; public const int aes _ ctx _ size = NUM + NUM * NUM ;
using system _ threading ; using system _ windows _ forms ; namespace shadowsocks { static class program { <%> <-> dll _ import _ kernel _ dll private static extern int _ ptr load _ library ( string path ) ; </%> sta _ thread static void main ( )
sta _ thread static void main ( ) { using ( mutex mutex = new mutex ( false , STR + STR ) ) { if ( ! mutex . wait _ one ( 0 , false ) ) { process [ ] old _ processes = process . get _ processes _ by _ name ( STR ) ; if ( old _ processes . length > 0 ) {
{ byte [ ] hash = new byte [ NUM ] ; <%> <+> ota _ </%> update _ key _ buffer ( ) ; sodium . ss _ sha _ hmac _ ex ( <%> <+> ota _ chunk _ </%> key _ buffer , ( uint ) <%> <+> ota _ chunk _ </%> key _ buffer . length , buf , offset , ( uint ) len , hash ) ; return hash ; } <%> <*> protected -> private </%> void <%> <*> react -> ota _ auth </%> _ buffer _ tcp ( byte [ ] buf , ref int length ) { if ( ! encrypt _ iv _ sent )
buf , offset , ( uint ) len , hash ) ; return hash ; } <%> <*> protected -> private </%> void <%> <*> react -> ota _ auth </%> _ buffer _ tcp ( byte [ ] buf , ref int length ) { if ( ! encrypt _ iv _ sent ) { int head _ len = <%> <+> ota _ </%> get _ head _ len ( buf , length ) ; int data _ len = length - head _ len ; buf [ 0 ] | = onetimeauth _ flag ;
int data _ len = length - head _ len ; buf [ 0 ] | = onetimeauth _ flag ; byte [ ] hash = <%> <*> gen _ onetime -> ota </%> _ <%> <*> auth -> gen </%> _ hash ( buf , head _ len ) ; buffer . block _ copy ( buf , head _ len , buf , head _ len + onetimeauth _ bytes + auth _ bytes , data _ len ) ; buffer . block _ copy ( hash , 0 , buf , head _ len , onetimeauth _ bytes ) ; hash = <%> <+> ota _ </%> gen <%> <+> _ chunk </%> _ hash ( buf , head _ len + onetimeauth _ bytes + auth _ bytes , data _ len ) ; buffer . block _ copy ( hash , 0 , buf , head _ len + onetimeauth _ bytes + clen _ bytes , onetimeauth _ bytes ) ; byte [ ] len _ bytes = bit _ converter . get _ bytes ( ( ushort ) ip _ address . host _ to _ network _ order ( ( short ) data _ len ) ) ; buffer . block _ copy ( len _ bytes , 0 , buf , head _ len + onetimeauth _ bytes , clen _ bytes ) ; length = head _ len + onetimeauth _ bytes + auth _ bytes + data _ len ;
buffer . block _ copy ( buf , head _ len , buf , head _ len + onetimeauth _ bytes + auth _ bytes , data _ len ) ; buffer . block _ copy ( hash , 0 , buf , head _ len , onetimeauth _ bytes ) ; hash = <%> <+> ota _ </%> gen <%> <+> _ chunk </%> _ hash ( buf , head _ len + onetimeauth _ bytes + auth _ bytes , data _ len ) ; buffer . block _ copy ( hash , 0 , buf , head _ len + onetimeauth _ bytes + clen _ bytes , onetimeauth _ bytes ) ; byte [ ] len _ bytes = bit _ converter . get _ bytes ( ( ushort ) ip _ address . host _ to _ network _ order ( ( short ) data _ len ) ) ; buffer . block _ copy ( len _ bytes , 0 , buf , head _ len + onetimeauth _ bytes , clen _ bytes ) ; length = head _ len + onetimeauth _ bytes + auth _ bytes + data _ len ; } else {
buffer . block _ copy ( hash , 0 , buf , length , onetimeauth _ bytes ) ; length + = onetimeauth _ bytes ; } <%> <*> protected -> private </%> void <%> <*> react -> ota _ auth </%> _ buffer ( byte [ ] buf , ref int length ) { if ( onetime _ auth & & iv _ len > 0 ) { if ( ! is _ udp ) { <%> <*> react -> ota _ auth </%> _ buffer _ tcp ( buf , ref length ) ;
} else { <%> <*> react -> ota _ auth </%> _ buffer _ udp ( buf , ref length ) ; } } <%> <+> } protected static void rand _ bytes ( byte [ ] buf , int length ) { byte [ ] temp = new byte [ length ] ; </%>
} public override void encrypt ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength ) { if ( ! encrypt _ iv _ sent ) { rand _ bytes ( outbuf , iv _ len ) ; init _ cipher ( outbuf , true ) ; <%> <*> react _ buffer ( buf , ref length ) ; -> outlength = length + iv _ len ; </%> <%> <+> ota _ auth _ buffer ( buf , ref length ) ; </%>
encrypt _ iv _ sent = true ; lock ( tempbuf ) { cipher _ update ( true , length , buf , tempbuf ) ; outlength = length + iv _ len ; buffer . block _ copy ( tempbuf , 0 , outbuf , iv _ len , length ) ; } } else {
global _ system _ code _ dom _ compiler _ generated _ code _ attribute _ system _ resources _ tools _ strongly _ typed _ resource _ builder global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute global _ system _ runtime _ compiler _ services _ compiler _ generated _ attribute <%> <*> internal class resources { -> internal class resources { </%> private static global :: system . resources . resource _ manager resource _ man ; private static global :: system . globalization . culture _ info resource _ culture ; global _ system _ diagnostics _ code _ analysis _ suppress _ message _ attribute _ microsoft _ performance _ c _ avoid _ uncalled _ private _ code <%> <-> internal resources ( ) </%>
global :: system . resources . resource _ manager temp = new global :: system . resources . resource _ manager ( STR , typeof ( resources ) . assembly ) ; resource _ man = temp ; } return resource _ man ; } } global _ system _ component _ model _ editor _ browsable _ attribute _ global _ system _ component _ model _ editor _ browsable _ state _ advanced <%> <-> internal static global :: system . globalization . culture _ info culture { get </%>
} if ( modified _ configuration . configs . count = = 0 ) { message _ box . show ( n . get _ string ( STR ) ) ; return <%> <+> false </%> ; } int local _ port = int . parse ( proxy _ port _ text _ box . text ) ; configuration . check _ local _ port ( local _ port ) ; modified _ configuration . local _ port = local _ port ; modified _ configuration . portable _ mode = portable _ mode _ check _ box . checked ;
} int local _ port = int . parse ( proxy _ port _ text _ box . text ) ; configuration . check _ local _ port ( local _ port ) ; modified _ configuration . local _ port = local _ port ; modified _ configuration . portable _ mode = portable _ mode _ check _ box . checked ; controller . save _ servers ( modified _ configuration . configs , modified _ configuration . local _ port , modified _ configuration . portable _ mode ) ; controller . select _ server _ index ( servers _ list _ box . selected _ index ) ; <%> <+> return true ; } private void config _ form _ key _ down ( object sender , key _ event _ args e ) </%>
} private void cancel _ button _ click ( object sender , event _ args e ) { this . close ( ) ; } private void config _ form _ shown ( object sender , event _ args e ) { ip _ text _ box . focus ( ) ; } private void config _ form _ form _ closed ( object sender , form _ closed _ event _ args e )
this . apply _ button . location = new system . drawing . point ( NUM , NUM ) ; this . apply _ button . margin = new system . windows . forms . padding ( NUM , NUM , 0 , 0 ) ; this . apply _ button . name = STR ; this . apply _ button . size = new system . drawing . size ( NUM , NUM ) ; this . apply _ button . tab _ index = NUM ; this . apply _ button . text = STR ; this . apply _ button . use _ visual _ style _ back _ color = true ; this . apply _ button . click + = new system . event _ handler ( this . apply _ button _ click ) ; this . delete _ button . dock = system . windows . forms . dock _ style . right ; this . delete _ button . location = new system . drawing . point ( NUM , NUM ) ;
} public void update _ outbound _ counter ( long n ) { interlocked . add ( ref outbound _ counter , n ) ; <%> <*> config -> config . get _ current _ server ( ) </%> . bandwidth _ out = outbound _ counter ; } protected void reload ( ) { config = configuration . load ( ) ; inbound _ counter = config <%> <+> . get _ current _ server ( ) </%> . bandwidth _ in ;
} protected void reload ( ) { config = configuration . load ( ) ; inbound _ counter = config <%> <+> . get _ current _ server ( ) </%> . bandwidth _ in ; outbound _ counter = config <%> <+> . get _ current _ server ( ) </%> . bandwidth _ out ; statistics _ configuration = statistics _ strategy _ configuration . load ( ) ; if ( polipo _ runner = = null ) { polipo _ runner = new polipo _ runner ( ) ;
statistics _ configuration = statistics _ strategy _ configuration . load ( ) ; if ( polipo _ runner = = null ) { polipo _ runner = new polipo _ runner ( ) ; } if ( pac _ server = = null ) { pac _ server = new pac _ server ( ) ; pac _ server . pac _ file _ changed + = pac _ server _ pac _ file _ changed ; pac _ server . user _ rule _ file _ changed + = pac _ server _ user _ rule _ file _ changed ;
( ( system . component _ model . i _ support _ initialize ) ( this . statistics _ chart ) ) . begin _ init ( ) ; <%> <-> ( ( system . component _ model . i _ support _ initialize ) ( this . binding _ configuration ) ) . begin _ init ( ) ; </%> this . group _ box . suspend _ layout ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . begin _ init ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . suspend _ layout ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . begin _ init ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . panel . suspend _ layout ( ) ;
this . group _ box . suspend _ layout ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . begin _ init ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . suspend _ layout ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . begin _ init ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . suspend _ layout ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . data _ collection _ minutes _ num ) ) . begin _ init ( ) ;

? ? new statistics _ strategy _ configuration ( ) ; <%> <+> if ( configuration . calculations = = null ) { configuration = new statistics _ strategy _ configuration ( ) ; } </%> } private void init _ data ( ) { binding _ configuration . add ( configuration ) ; foreach ( var kv in configuration . calculations )
namespace shadowsocks _ controller { class pac _ server { private static int port = NUM ; <%> <*> private -> public </%> static string pac _ file = STR ; private static configuration config ; socket listener ; file _ system _ watcher watcher ; public event event _ handler pac _ file _ changed ;
private static configuration config ; socket listener ; file _ system _ watcher watcher ; public event event _ handler pac _ file _ changed ; <%> <-> public event event _ handler update _ pac _ from _ gfw _ list _ completed ; public event error _ event _ handler update _ pac _ from _ gfw _ list _ error ; </%> public void start ( configuration configuration ) { try {
public void start ( configuration configuration ) { try { config = configuration ; listener = new socket ( address _ family . inter _ network , socket _ type . stream , protocol _ type . tcp ) ; listener . set _ socket _ option ( socket _ option _ level . socket , socket _ option _ name . reuse _ address , true ) ; ip _ end _ point local _ end _ point = null ; if ( configuration . share _ over _ lan ) {
public event error _ event _ handler error ; <%> <-> public void download ( ) { web _ client http = new web _ client ( ) ; http . proxy = proxy ; http . download _ string _ completed + = http _ download _ string _ completed ; http . download _ string _ async ( new uri ( gfwlist _ url ) ) ; } protected void report _ error ( exception e ) { </%>
private void http _ download _ string _ completed ( object sender , download _ string _ completed _ event _ args e ) { try { <%> <*> string response = e . result ; if ( download _ completed ! = null ) -> string [ ] lines = parse _ result ( e . result ) ; </%> <%> <+> json _ array rules = new json _ array ( ) ; rules . add _ range ( lines ) ; string abp _ content = utils . un _ gzip ( resources . abp _ js ) ; </%>
{ <%> <*> download _ completed ( this , new gfw _ list _ download _ completed _ args { content = response } ) ; -> update _ completed ( this , new event _ args ( ) ) ; </%> } } catch ( exception ex ) {
} } catch ( exception ex ) { <%> <*> report _ error ( ex ) ; -> if ( error ! = null ) </%> <%> <+> { error ( this , new error _ event _ args ( ex ) ) ; } </%> }
} } public <%> <*> class parser -> void update _ pac _ from _ gfw _ list ( ) </%> { <%> <*> private string content ; public string content -> web _ client http = new web _ client ( ) ; </%> <%> <+> http . download _ string _ completed + = http _ download _ string _ completed ; http . download _ string _ async ( new uri ( gfwlist _ url ) ) ; } </%>
{ <%> <*> private string content ; public string content -> web _ client http = new web _ client ( ) ; </%> <%> <+> http . download _ string _ completed + = http _ download _ string _ completed ; http . download _ string _ async ( new uri ( gfwlist _ url ) ) ; } public string [ ] parse _ result ( string response ) { byte [ ] bytes = convert . from _ base _ string ( response ) ; </%>
{ <%> <*> get { return content ; } -> if ( line . starts _ with ( STR ) | | line . starts _ with ( STR ) ) </%> <%> <+> continue ; valid _ lines . add ( line ) ; </%> } <%> <-> public parser ( string response ) { byte [ ] bytes = convert . from _ base _ string ( response ) ; this . content = encoding . ascii . get _ string ( bytes ) ; </%>
} <%> <-> public parser ( string response ) { byte [ ] bytes = convert . from _ base _ string ( response ) ; this . content = encoding . ascii . get _ string ( bytes ) ; } public string [ ] get _ valid _ lines ( ) { string [ ] lines = content . split ( new char [ ] { '\r' , '\n' } , string _ split _ options . remove _ empty _ entries ) ; list < string > valid _ lines = new list < string > ( lines . length ) ; </%>
} } }
{ if ( update _ pac _ from _ gfw _ list _ error ! = null ) update _ pac _ from _ gfw _ list _ error ( this , e ) ; } private void start _ releasing _ memory ( ) { ram _ thread = new thread ( new thread _ start ( release _ memory ) ) ; ram _ thread . is _ background = true ; ram _ thread . start ( ) ; }
{ public static void release _ memory ( ) { gc . collect ( gc . max _ generation ) ; gc . wait _ for _ pending _ finalizers ( ) ; set _ process _ working _ set _ size ( process . get _ current _ process ( ) . handle , ( u _ int _ ptr ) 0 xffffffff , ( u _ int _ ptr ) 0 xffffffff ) ; } <%> <+> public static string un _ gzip ( byte [ ] buf ) { </%>
try { file _ manager . uncompress _ file ( temppath + STR , resources . privoxy _ exe ) ; file _ manager . uncompress _ file ( temppath + STR , resources . mgwz _ dll ) ; } catch ( io _ exception e ) { logging . log _ useful _ exception ( e ) ; } }
} } class handler { public i _ encryptor encryptor ; public server server ; public socket remote ; public socket connection ; public shadowsocks _ controller controller ; public tcp _ relay relay ;
return mode . byte ; <%> <-> } private static bool is _ only _ double _ byte _ kanji ( string content ) { byte [ ] bytes ; try { bytes = encoding . get _ encoding ( STR ) . get _ bytes ( content ) ; } catch ( exception ) </%>
} private static int choose _ mask _ pattern ( bit _ array bits , error _ correction _ level ec _ level , version version , byte _ matrix matrix ) { int min _ penalty = int . max _ value ; int best _ mask _ pattern = - 1 ; for ( int mask _ pattern = 0 ; mask _ pattern < qr _ code . num _ mask _ patterns ; mask _ pattern + + ) {
else <%> <-> if ( mode . equals ( mode . byte ) ) append _ bit _ bytes ( content , bits , encoding ) ; else if ( mode . equals ( mode . kanji ) ) append _ kanji _ bytes ( content , bits ) ; else </%> throw new writer _ exception ( STR + mode ) ; } internal static void append _ numeric _ bytes ( string content , bit _ array bits )
} internal static void append _ numeric _ bytes ( string content , bit _ array bits ) { int length = content . length ; int i = 0 ; while ( i < length ) { int num = content [ i ] - '0' ; if ( i + 2 < length ) {
public void set _ bulk ( int i , int new _ bits ) { bits [ i > > NUM ] = new _ bits ; } <%> <-> public void set _ range ( int start , int end ) { if ( end < start ) { throw new argument _ exception ( ) ; } </%>
public void clear ( ) { int max = bits . length ; for ( int i = 0 ; i < max ; i + + ) { bits [ i ] = 0 ; } <%> <-> } public bool is _ range ( int start , int end , bool value ) { </%>
} public void append _ bit ( bool bit ) { ensure _ capacity ( size + 1 ) ; if ( bit ) { bits [ size > > NUM ] | = 1 < < ( size & 0 f ) ; } size + + ; }
using shadowsocks _ model ; <%> <+> using simple _ json = simple _ json . simple _ json ; using timer = system . threading . timer ; </%> namespace shadowsocks _ controller { <%> <+> using data _ unit = key _ value _ pair < string , string > ; using data _ list = list < key _ value _ pair < string , string > > ; </%> class availability _ statistics { private const string statistics _ files _ name = STR ;
{ <%> <+> logging . debug ( STR ) ; const string api = STR ; var json _ string = await new http _ client ( ) . get _ string _ async ( api ) ; var ret = new data _ list { new data _ unit ( state . geolocation , state . unknown ) , new data _ unit ( state . isp , state . unknown ) , } ; dynamic obj ; </%>
{ <%> <*> logging . debug ( STR + server . friendly _ name ( ) ) ; foreach ( var in enumerable . range ( 0 , repeat ) ) -> var reply = await ping . send _ task _ async ( server . server , timeout ) ; </%> <%> <+> ret . add ( new list < key _ value _ pair < string , string > > </%> { <%> <-> var timestamp = date _ time . now . to _ string ( STR ) ; var reply = ping . send ( server . server , timeout ) ; state . data = new list < key _ value _ pair < string , string > > { </%>
{ <%> <-> var timestamp = date _ time . now . to _ string ( STR ) ; var reply = ping . send ( server . server , timeout ) ; state . data = new list < key _ value _ pair < string , string > > { </%> new key _ value _ pair < string , string > ( STR , timestamp ) , new key _ value _ pair < string , string > ( STR , server . friendly _ name ( ) ) , new key _ value _ pair < string , string > ( STR , reply ? . status . to _ string ( ) ) , new key _ value _ pair < string , string > ( STR , reply ? . roundtrip _ time . to _ string ( ) ) <%> <-> } ; </%>
} } } private static void append ( <%> <+> data _ </%> list <%> <*> < key -> data </%> _ <%> <*> value -> list , i </%> _ <%> <*> pair -> enumerable </%> < <%> <*> string , string > -> data _ unit </%> > <%> <*> data -> extra </%> ) { <%> <+> var data = data _ list . concat ( extra ) ; </%> var data _ line = string . join ( delimiter , data . select ( kv = > kv . value ) . to _ array ( ) ) ; string [ ] lines ; if ( ! file . exists ( availability _ statistics _ file ) ) {
{ <%> <+> var data = data _ list . concat ( extra ) ; </%> var data _ line = string . join ( delimiter , data . select ( kv = > kv . value ) . to _ array ( ) ) ; string [ ] lines ; if ( ! file . exists ( availability _ statistics _ file ) ) { var header _ line = string . join ( delimiter , data . select ( kv = > kv . key ) . to _ array ( ) ) ; lines = new [ ] { header _ line , data _ line } ; } else
match match = regex . match ( name , STR , regex _ options . ignore _ case ) ; if ( match . success ) { string version = match . groups [ STR ] . value ; var asset = new asset { browser _ download _ url = ( string ) <%> <*> aj -> assert _ j </%> _ object [ STR ] , name = name , version = version
name = name , version = version } ; if ( match . groups [ STR ] . success ) { asset . suffix = match . groups [ STR ] . value ; } return asset ; } return null ;
public partial class log _ form : form { long last _ offset ; string filename ; timer timer ; const int back _ offset = NUM ; shadowsocks _ controller controller ; private static readonly object lock = new object ( ) ; <%> <*> long last -> queue < traffic _ info > traffic </%> _ <%> <*> max -> info </%> _ <%> <*> speed ; shadowsocks _ controller . queue _ last < traffic _ info > traffic = new shadowsocks _ controller . -> queue = new queue < traffic _ info > ( ) ; const int </%> queue _ <%> <*> last < traffic -> max </%> _ <%> <*> info > ( ) -> length = NUM </%> ;
public log _ form ( shadowsocks _ controller controller , string filename ) { this . controller = controller ; this . filename = filename ; initialize _ component ( ) ; icon = icon . from _ handle ( resources . ssw . get _ hicon ( ) ) ; log _ viewer _ config config = controller . get _ configuration _ copy ( ) . log _ viewer ; top _ most _ trigger = config . top _ most ; wrap _ text _ trigger = config . wrap _ text ; toolbar _ trigger = config . toolbar _ shown ;
lock ( lock ) { if ( traffic <%> <+> _ info _ queue </%> . count = = 0 ) return ; <%> <+> inbound _ points . clear ( ) ; outbound _ points . clear ( ) ; max _ speed = 0 ; </%> foreach ( var traffic <%> <-> _ per </%> _ <%> <*> second -> info </%> in traffic <%> <+> _ info _ queue </%> ) { inbound _ points . add ( traffic <%> <-> _ per </%> _ <%> <*> second -> info </%> . inbound ) ;
return ; <%> <+> inbound _ points . clear ( ) ; outbound _ points . clear ( ) ; max _ speed = 0 ; </%> foreach ( var traffic <%> <-> _ per </%> _ <%> <*> second -> info </%> in traffic <%> <+> _ info _ queue </%> ) { inbound _ points . add ( traffic <%> <-> _ per </%> _ <%> <*> second -> info </%> . inbound ) ; outbound _ points . add ( traffic <%> <-> _ per </%> _ <%> <*> second -> info </%> . outbound ) ; max _ speed = math . max ( max _ speed , math . max ( traffic <%> <-> _ per </%> _ <%> <*> second -> info </%> . inbound , traffic <%> <-> _ per </%> _ <%> <*> second -> info </%> . outbound ) ) ; }
} if ( max _ speed > 0 ) { last _ max _ speed - = last _ max _ speed / NUM ; max _ speed = math . max ( min _ scale , math . max ( max _ speed , last _ max _ speed ) ) ; last _ max _ speed = max _ speed ; } else { max _ speed = last _ max _ speed = min _ scale ;
private bool stopped = false ; private bool system _ proxy _ is _ dirty = false ; public class path _ event _ args : event _ args { public string path ; <%> <-> } public class queue _ last < t > : queue < t > { public t last { get ; private set ; } public new void enqueue ( t item ) </%>
} public class traffic _ per _ second { public long inbound _ counter ; public long outbound _ counter ; public long inbound _ increasement ; public long outbound _ increasement ; } public event event _ handler config _ changed ; public event event _ handler enable _ status _ changed ;
for ( int i = 0 ; i < queue _ max _ size ; i + + ) { <%> <*> traffic -> traffic _ per _ second _ queue </%> . enqueue ( new traffic _ per _ second ( ) ) ; } traffic _ thread = new thread ( new thread _ start ( ( ) = > traffic _ statistics ( queue _ max _ size ) ) ) ; traffic _ thread . is _ background = true ; traffic _ thread . start ( ) ; } private void traffic _ statistics ( int queue _ max _ size ) {
} traffic _ thread = new thread ( new thread _ start ( ( ) = > traffic _ statistics ( queue _ max _ size ) ) ) ; traffic _ thread . is _ background = true ; traffic _ thread . start ( ) ; } private void traffic _ statistics ( int queue _ max _ size ) { <%> <+> traffic _ per _ second previous , current ; </%> while ( true ) {
traffic _ changed ? . invoke ( this , new event _ args ( ) ) ; thread . sleep ( NUM ) ; } } } }
public date _ time last _ activity ; private const int max _ retry = NUM ; private int retry _ count = 0 ; private bool connected ; private byte command ; private byte [ ] first _ packet ; private int first _ packet _ length ; <%> <-> public const int recv _ size = NUM ; public const int recv _ reserve _ size = iv _ encryptor . onetimeauth _ bytes + iv _ encryptor . auth _ bytes ; public const int buffer _ size = recv _ size + recv _ reserve _ size + NUM ; </%>
private date _ time start _ connect _ time ; private date _ time start _ receiving _ time ; private date _ time start _ sending _ time ; private int bytes _ to _ send ; private tcp _ relay tcprelay ; public tcp _ handler ( tcp _ relay tcprelay ) { this . tcprelay = tcprelay ; } public void create _ remote ( )
} } }
<%> <*> public byte [ ] remote _ buffer = new byte [ buffer _ size ] ; -> public byte [ ] remote _ recv _ buffer = new byte [ recv _ size ] ; </%> <%> <*> public byte [ ] connetion _ buffer = new byte [ buffer _ size ] ; -> public byte [ ] remote _ send _ buffer = new byte [ buffer _ size ] ; </%> <%> <+> public byte [ ] connetion _ recv _ buffer = new byte [ recv _ size ] ; public byte [ ] connetion _ send _ buffer = new byte [ buffer _ size ] ; </%> public string _ builder sb = new string _ builder ( ) ; public void start ( ) { try
<%> <*> public byte [ ] connetion _ buffer = new byte [ buffer _ size ] ; -> public byte [ ] connetion _ recv _ buffer = new byte [ recv _ size ] ; </%> <%> <+> public byte [ ] connetion _ send _ buffer = new byte [ buffer _ size ] ; </%> public string _ builder sb = new string _ builder ( ) ; public void start ( ) { try { ip _ address ip _ address ; bool parsed = ip _ address . try _ parse ( config . server , out ip _ address ) ;
public string _ builder sb = new string _ builder ( ) ; public void start ( ) { try { ip _ address ip _ address ; bool parsed = ip _ address . try _ parse ( config . server , out ip _ address ) ; if ( ! parsed ) { ip _ host _ entry ip _ host _ info = dns . get _ host _ entry ( config . server ) ;
new async _ callback ( pipe _ remote _ receive _ callback ) , null ) ; connection . begin _ receive ( connetion <%> <+> _ recv </%> _ buffer , 0 , <%> <*> buffer -> recv </%> _ size , 0 , new async _ callback ( pipe _ connection _ receive _ callback ) , null ) ; } catch ( exception e ) { console . write _ line ( e . to _ string ( ) ) ; this . close ( ) ; } }
new async _ callback ( pipe _ connection _ receive _ callback ) , null ) ; } catch ( exception e ) { console . write _ line ( e . to _ string ( ) ) ; this . close ( ) ; } } private void pipe _ remote _ receive _ callback ( i _ async _ result ar ) {
{ if ( encrypt _ ctx = = int _ ptr . zero ) { <%> <-> byte [ ] iv = new byte [ iv _ len ] ; open _ ssl . rand _ bytes ( iv , iv . length ) ; init _ cipher ( ref encrypt _ ctx , iv , true ) ; int out _ len = length + iv _ len ; byte [ ] cipher _ text = new byte [ out _ len ] ; open _ ssl . evp _ cipher _ update ( encrypt _ ctx , cipher _ text , out out _ len , buf , length ) ; byte [ ] result = new byte [ out _ len + iv _ len ] ; </%>
} else { <%> <*> int out _ len = length + iv _ len ; byte [ ] cipher _ text = new byte [ out _ len ] ; open _ ssl . evp _ cipher _ update ( encrypt _ ctx , cipher _ text , out out _ len , buf , length ) ; byte [ ] result = new byte [ out _ len ] ; buffer . block _ copy ( cipher _ text , 0 , result , 0 , out _ len ) ; return result ; -> outlength = length ; </%>
} } public override <%> <*> byte [ ] -> void </%> decrypt ( byte [ ] buf , int length <%> <*> ) -> , byte [ ] outbuf , out int outlength ) </%> { if ( decrypt _ ctx = = int _ ptr . zero ) { <%> <-> byte [ ] iv = new byte [ iv _ len ] ; buffer . block _ copy ( buf , 0 , iv , 0 , iv _ len ) ; init _ cipher ( ref decrypt _ ctx , iv , false ) ; int out _ len = length + iv _ len ; </%>
{ if ( decrypt _ ctx = = int _ ptr . zero ) { <%> <-> byte [ ] iv = new byte [ iv _ len ] ; buffer . block _ copy ( buf , 0 , iv , 0 , iv _ len ) ; init _ cipher ( ref decrypt _ ctx , iv , false ) ; int out _ len = length + iv _ len ; out _ len - = iv _ len ; byte [ ] cipher _ text = new byte [ out _ len ] ; byte [ ] subset = new byte [ length - iv _ len ] ; </%>
} else { <%> <*> int out _ len = length + iv _ len ; byte [ ] cipher _ text = new byte [ out _ len ] ; open _ ssl . evp _ cipher _ update ( decrypt _ ctx , cipher _ text , out out _ len , buf , length ) ; byte [ ] result = new byte [ out _ len ] ; buffer . block _ copy ( cipher _ text , 0 , result , 0 , out _ len ) ; return result ; -> outlength = length ; </%>
} } private static readonly dictionary < string , byte [ ] > cached _ keys = new dictionary < string , byte [ ] > ( ) ; private byte [ ] key ; private int _ ptr encrypt _ ctx ; private int _ ptr decrypt _ ctx ; private int _ ptr cipher ; private string method ; private int key _ len ; private int iv _ len ;
{ <%> <*> byte [ ] -> void </%> encrypt ( byte [ ] buf , int length <%> <+> , byte [ ] outbuf , out int outlength </%> ) ; <%> <*> byte [ ] -> void </%> decrypt ( byte [ ] buf , int length <%> <+> , byte [ ] outbuf , out int outlength </%> ) ; } }
} }
{ byte [ ] result = new byte [ length ] ; for ( int i = 0 ; i < length ; i + + ) { <%> <*> result -> outbuf </%> [ i ] = encrypt _ table [ buf [ i ] ] ; } <%> <*> return result -> outlength = length </%> ; } public override <%> <*> byte [ ] -> void </%> decrypt ( byte [ ] buf , int length <%> <*> ) -> , byte [ ] outbuf , out int outlength ) </%> {
} <%> <*> return result -> outlength = length </%> ; } public override <%> <*> byte [ ] -> void </%> decrypt ( byte [ ] buf , int length <%> <*> ) -> , byte [ ] outbuf , out int outlength ) </%> { byte [ ] result = new byte [ length ] ; for ( int i = 0 ; i < length ; i + + ) { <%> <*> result -> outbuf </%> [ i ] = decrypt _ table [ buf [ i ] ] ; }
} public override <%> <*> byte [ ] -> void </%> decrypt ( byte [ ] buf , int length <%> <*> ) -> , byte [ ] outbuf , out int outlength ) </%> { byte [ ] result = new byte [ length ] ; for ( int i = 0 ; i < length ; i + + ) { <%> <*> result -> outbuf </%> [ i ] = decrypt _ table [ buf [ i ] ] ; } <%> <*> return result -> outlength = length </%> ; }
{ byte [ ] result = new byte [ length ] ; for ( int i = 0 ; i < length ; i + + ) { <%> <*> result -> outbuf </%> [ i ] = decrypt _ table [ buf [ i ] ] ; } <%> <*> return result -> outlength = length </%> ; } private readonly byte [ ] encrypt _ table = new byte [ NUM ] ; private readonly byte [ ] decrypt _ table = new byte [ NUM ] ;
} <%> <*> return result -> outlength = length </%> ; } private readonly byte [ ] encrypt _ table = new byte [ NUM ] ; private readonly byte [ ] decrypt _ table = new byte [ NUM ] ; private static long compare ( byte x , byte y , ulong a , int i ) { return ( long ) ( a % ( ulong ) ( x + i ) ) - ( long ) ( a % ( ulong ) ( y + i ) ) ; } private byte [ ] merge _ sort ( byte [ ] array , ulong a , int j )
} private readonly byte [ ] encrypt _ table = new byte [ NUM ] ; private readonly byte [ ] decrypt _ table = new byte [ NUM ] ; private static long compare ( byte x , byte y , ulong a , int i ) { return ( long ) ( a % ( ulong ) ( x + i ) ) - ( long ) ( a % ( ulong ) ( y + i ) ) ; } private byte [ ] merge _ sort ( byte [ ] array , ulong a , int j ) { if ( array . length = = 1 )
{ <%> <*> static string key = STR + application . startup _ path . get _ hash _ code ( ) ; -> private static readonly string executable _ path = assembly . get _ entry _ assembly ( ) . location ; </%> <%> <+> private static string key = STR + application . startup _ path . get _ hash _ code ( ) ; </%> public static bool set ( bool enabled ) { registry _ key run _ key = null ; try { <%> <-> string path = application . executable _ path ; </%>
public static bool set ( bool enabled ) { registry _ key run _ key = null ; try { <%> <-> string path = application . executable _ path ; </%> run _ key = utils . open _ reg _ key ( STR , true ) ; if ( run _ key = = null ) { logging . error ( STR ) ; return false ;
run _ key = utils . open _ reg _ key ( STR , true ) ; if ( run _ key = = null ) { logging . error ( STR ) ; return false ; } if ( enabled ) { run _ key . set _ value ( key , <%> <+> executable _ </%> path ) ; } else
} else { run _ key . delete _ value ( key ) ; } return true ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ;
return true ; } } } return false ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; return false ;
private async _ session current _ remote _ session ; <%> <-> public socket connection ; public shadowsocks _ controller controller ; public tcp _ relay tcprelay ; public date _ time last _ activity ; </%> private const int max _ retry = NUM ; private int retry _ count = 0 ; private bool proxy _ connected ; private bool dest _ connected ; private byte command ;
private date _ time start _ connect _ time ; private date _ time start _ receiving _ time ; private date _ time start _ sending _ time ; <%> <-> private int bytes _ to _ send ; private tcp _ relay tcprelay ; private configuration config ; </%> public tcp _ handler ( <%> <+> shadowsocks _ controller controller , configuration config , </%> tcp _ relay tcprelay , <%> <*> configuration config -> socket socket </%> ) { <%> <+> this . controller = controller ; this . config = config ; </%>
this . tcprelay = tcprelay ; this . <%> <*> config -> connection </%> = <%> <*> config -> socket </%> ; } public void create _ remote ( ) { server server = controller . get _ a _ server ( i _ strategy _ caller _ type . tcp , ( ip _ end _ point ) connection . remote _ end _ point ) ; if ( server = = null | | server . server = = STR ) throw new argument _ exception ( STR ) ; lock ( encryption _ lock ) {
} public void create _ remote ( ) { server server = controller . get _ a _ server ( i _ strategy _ caller _ type . tcp , ( ip _ end _ point ) connection . remote _ end _ point ) ; if ( server = = null | | server . server = = STR ) throw new argument _ exception ( STR ) ; lock ( encryption _ lock ) { lock ( decryption _ lock ) {
if ( closed ) return ; closed = true ; } <%> <+> lock ( tcprelay . handlers ) { tcprelay . handlers . remove ( this ) ; } </%> try { connection ? . shutdown ( socket _ shutdown . both ) ;
} catch ( exception e ) { logging . log _ useful _ exception ( e ) ; } try { var remote = current _ remote _ session ? . remote ; remote ? . shutdown ( socket _ shutdown . both ) ; remote ? . close ( ) ;
if ( mbed _ tls . cipher _ set _ iv ( ctx , iv , iv _ len ) ! = 0 ) throw new exception ( <%> <+> STR </%> ) ; if ( mbed _ tls . cipher _ reset ( ctx ) ! = 0 ) throw new exception ( <%> <+> STR </%> ) ; } protected override void cipher _ update ( bool is _ cipher , int length , byte [ ] buf , byte [ ] outbuf ) { if ( disposed ) { throw new object _ disposed _ exception ( this . to _ string ( ) ) ;
if ( mbed _ tls . cipher _ reset ( ctx ) ! = 0 ) throw new exception ( <%> <+> STR </%> ) ; } protected override void cipher _ update ( bool is _ cipher , int length , byte [ ] buf , byte [ ] outbuf ) { if ( disposed ) { throw new object _ disposed _ exception ( this . to _ string ( ) ) ; } int _ ptr ctx ;
} protected override void cipher _ update ( bool is _ cipher , int length , byte [ ] buf , byte [ ] outbuf ) { if ( disposed ) { throw new object _ disposed _ exception ( this . to _ string ( ) ) ; } int _ ptr ctx ; if ( is _ cipher ) {
} else if ( name . starts _ with ( STR , string _ comparison . ordinal _ ignore _ case ) ) { init ( resources . <%> <*> jp -> ja </%> ) ; } } public static string get _ string ( string key ) { return strings . contains _ key ( key ) ? strings [ key ]
} } public static string get _ string ( string key ) { return strings . contains _ key ( key ) ? strings [ key ] : key ; } } }
private lru _ cache < ip _ end _ point , udp _ handler > cache ; public udp _ relay ( <%> <*> configuration config -> shadowsocks _ controller controller </%> ) { this . <%> <*> config -> controller </%> = <%> <*> config -> controller </%> ; this . cache = new lru _ cache < ip _ end _ point , udp _ handler > ( NUM ) ; } public bool handle ( byte [ ] first _ packet , int length , socket socket , object state ) { if ( socket . protocol _ type ! = protocol _ type . udp ) {
{ this . <%> <*> config -> controller </%> = <%> <*> config -> controller </%> ; this . cache = new lru _ cache < ip _ end _ point , udp _ handler > ( NUM ) ; } public bool handle ( byte [ ] first _ packet , int length , socket socket , object state ) { if ( socket . protocol _ type ! = protocol _ type . udp ) { return false ; }
this . cache = new lru _ cache < ip _ end _ point , udp _ handler > ( NUM ) ; } public bool handle ( byte [ ] first _ packet , int length , socket socket , object state ) { if ( socket . protocol _ type ! = protocol _ type . udp ) { return false ; } if ( length < NUM ) {
notify _ icon . text = text . substring ( 0 , math . min ( NUM , text . length ) ) ; } private menu _ item create _ menu _ item ( string text , event _ handler click ) { return new menu _ item ( n . get _ string ( text ) , click ) ; } private menu _ item create _ menu _ group ( string text , menu _ item [ ] items ) { return new menu _ item ( n . get _ string ( text ) , items ) ; }
mode _ item . enabled = enable _ item . checked ; } void controller _ share _ over _ lan _ status _ changed ( object sender , event _ args e ) { share _ over _ lan _ item . checked = controller . get _ configuration <%> <+> _ copy </%> ( ) . share _ over _ lan ; } void controller _ enable _ global _ changed ( object sender , event _ args e ) { global _ mode _ item . checked = controller . get _ configuration <%> <+> _ copy </%> ( ) . global ; pac _ mode _ item . checked = ! global _ mode _ item . checked ;
} void controller _ enable _ global _ changed ( object sender , event _ args e ) { global _ mode _ item . checked = controller . get _ configuration <%> <+> _ copy </%> ( ) . global ; pac _ mode _ item . checked = ! global _ mode _ item . checked ; } void controller _ file _ ready _ to _ open ( object sender , shadowsocks _ controller . path _ event _ args e ) { string argument = STR + e . path ; system . diagnostics . process . start ( STR , argument ) ;
pac _ mode _ item . checked = ! global _ mode _ item . checked ; } void controller _ file _ ready _ to _ open ( object sender , shadowsocks _ controller . path _ event _ args e ) { string argument = STR + e . path ; system . diagnostics . process . start ( STR , argument ) ; } void show _ balloon _ tip ( string title , string content , tool _ tip _ icon icon , int timeout ) { notify _ icon . balloon _ tip _ title = title ;
menu _ item item = new menu _ item ( server . friendly _ name ( ) ) ; item . tag = i ; item . click + = a _ server _ item _ click ; items . add ( i , item ) ; <%> <+> i + + ; </%> } <%> <*> if ( configuration . index > = 0 & & configuration . index < configuration . configs . count -> foreach ( menu _ item item in items </%> ) { <%> <*> items [ -> if ( item . tag ! = null & & ( item . tag . to _ string ( ) = = </%> configuration . index <%> <-> ] </%> . <%> <*> checked = true ; -> to _ string ( ) | | item . tag . to _ string ( ) = = configuration . strategy ) ) </%> <%> <+> { </%>
} } private void show _ config _ form ( ) { if ( config _ form ! = null ) { config _ form . activate ( ) ; } else {
} public bool handle ( byte [ ] first _ packet , int length , socket socket , object state ) { if ( socket . protocol _ type ! = protocol _ type . tcp ) { return false ; } if ( length < 2 | | first _ packet [ 0 ] ! = NUM ) { return false ;
{ return configuration . load ( ) ; <%> <+> } public configuration get _ current _ configuration ( ) { return config ; } public i _ list < i _ strategy > get _ strategies ( ) { return strategy _ manager . get _ strategies ( ) ; </%>
{ config . index = <%> <*> 0 -> - 1 </%> ; } config . is _ default = false ; try { using ( stream _ writer sw = new stream _ writer ( file . open ( config _ file , file _ mode . create ) ) ) { string json _ string = simple _ json . simple _ json . serialize _ object ( config ) ; sw . write ( json _ string ) ;
} config . is _ default = false ; try { using ( stream _ writer sw = new stream _ writer ( file . open ( config _ file , file _ mode . create ) ) ) { string json _ string = simple _ json . simple _ json . serialize _ object ( config ) ; sw . write ( json _ string ) ; sw . flush ( ) ; }
{ try { connection . end _ send ( ar ) ; <%> <+> start _ connect ( ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; this . close ( ) ; </%>
logging . info ( STR ) ; break ; } } private static void timer _ elapsed ( object sender , system . timers . elapsed _ event _ args e ) { try { <%> <*> controller ? . start ( ) ; -> if ( controller ! = null ) </%>
} catch ( exception ex ) { logging . log _ useful _ exception ( ex ) ; } finally { try { system . timers . timer timer = ( system . timers . timer ) sender ;
string base = convert . to _ base _ string ( encoding . ut . get _ bytes ( parts ) ) ; <%> <*> return STR + base ; -> if ( ! server . remarks . is _ null _ or _ empty ( ) ) </%> <%> <+> { tag = $ STR ; } return $ STR ; </%> } public void update _ pac _ from _ gfw _ list ( ) {
} public void update _ pac _ from _ gfw _ list ( ) { if ( gfw _ list _ updater ! = null ) { gfw _ list _ updater . update _ pac _ from _ gfw _ list ( config ) ; } } public void update _ statistics _ configuration ( bool enabled ) {
if ( ! tag . is _ null _ or _ empty ( ) ) remarks = <%> <*> tag -> http _ utility </%> . <%> <*> substring -> url _ decode </%> ( <%> <*> 1 ) . trim ( -> tag , encoding . ut </%> ) ; match = details _ parser . match ( encoding . ut . get _ string ( convert . from _ base _ string ( base . pad _ right ( base . length + ( NUM - base . length % NUM ) % NUM , '=' ) ) ) ) ; method = match . groups [ STR ] . value ; auth = match . groups [ STR ] . success ; password = match . groups [ STR ] . value ; server = match . groups [ STR ] . value ; server _ port = int . parse ( match . groups [ STR ] . value ) ; }
match = details _ parser . match ( encoding . ut . get _ string ( convert . from _ base _ string ( base . pad _ right ( base . length + ( NUM - base . length % NUM ) % NUM , '=' ) ) ) ) ; method = match . groups [ STR ] . value ; auth = match . groups [ STR ] . success ; password = match . groups [ STR ] . value ; server = match . groups [ STR ] . value ; server _ port = int . parse ( match . groups [ STR ] . value ) ; } public string identifier ( ) {
connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , socket _ flags . none , new async _ callback ( read _ all ) , null ) ; } else { int bytes _ read = connection . end _ receive ( ar ) ; if ( bytes _ read > 0 ) { <%> <-> logging . debug ( remote . local _ end _ point , remote . dest _ end _ point , recv _ size , STR ) ; </%> connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , socket _ flags . none , new async _ callback ( read _ all ) , null ) ; }
connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , socket _ flags . none , new async _ callback ( read _ all ) , null ) ; } else close ( ) ; } } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ;
{ byte [ ] response = { NUM , 0 } ; <%> <+> if ( connetion _ recv _ buffer [ 0 ] ! = NUM ) { response = new byte [ ] { 0 , NUM } ; } </%> connection . begin _ send ( response , 0 , response . length , 0 , new async _ callback ( handshake _ send _ callback ) , null ) ; } else {
{ open _ ssl . evp _ cipher _ ctx _ cleanup ( encrypt _ ctx ) ; open _ ssl . evp _ cipher _ ctx _ free ( encrypt _ ctx ) ; encrypt _ ctx = int _ ptr . zero ; } if ( decrypt _ ctx <%> <+> . to _ int ( ) </%> ! = <%> <*> int _ ptr . zero -> 0 </%> ) { open _ ssl . evp _ cipher _ ctx _ cleanup ( decrypt _ ctx ) ; open _ ssl . evp _ cipher _ ctx _ free ( decrypt _ ctx ) ; decrypt _ ctx = int _ ptr . zero ;
{ open _ ssl . evp _ cipher _ ctx _ cleanup ( decrypt _ ctx ) ; open _ ssl . evp _ cipher _ ctx _ free ( decrypt _ ctx ) ; decrypt _ ctx = int _ ptr . zero ; } disposed = true ; } } } }
} else { def _ connection [ <%> <*> NUM -> options _ offset </%> ] = ( byte ) ( def _ connection [ <%> <*> NUM -> options _ offset </%> ] & ~ NUM ) ; saved _ legacy _ setting [ <%> <*> NUM -> options _ offset </%> ] = ( byte ) ( saved _ legacy _ setting [ <%> <*> NUM -> options _ offset </%> ] & ~ NUM ) ; } <%> <*> bit _ converter . get _ bytes ( unchecked ( bit _ converter . to _ u _ int ( def _ connection , NUM ) + 1 ) ) . copy _ to ( def _ connection , NUM ) ; bit _ converter . get _ bytes ( unchecked ( bit _ converter . to _ u _ int ( saved _ legacy _ setting , NUM ) + 1 ) ) . copy _ to ( saved _ legacy _ setting , NUM ) ; -> bit _ converter . get _ bytes ( </%> <%> <+> unchecked ( bit _ converter . to _ u _ int ( def _ connection , version _ offset ) + 1 ) ) </%>
} <%> <*> bit _ converter . get _ bytes ( unchecked ( bit _ converter . to _ u _ int ( def _ connection , NUM ) + 1 ) ) . copy _ to ( def _ connection , NUM ) ; bit _ converter . get _ bytes ( unchecked ( bit _ converter . to _ u _ int ( saved _ legacy _ setting , NUM ) + 1 ) ) . copy _ to ( saved _ legacy _ setting , NUM ) ; -> bit _ converter . get _ bytes ( </%> <%> <+> unchecked ( bit _ converter . to _ u _ int ( def _ connection , version _ offset ) + 1 ) ) . copy _ to ( def _ connection , version _ offset ) ; bit _ converter . get _ bytes ( unchecked ( bit _ converter . to _ u _ int ( saved _ legacy _ setting , version _ offset ) + 1 ) ) . copy _ to ( saved _ legacy _ setting , version _ offset ) ; </%> registry . set _ value ( STR , def _ connection ) ;
registry . set _ value ( STR , def _ connection ) ; registry . set _ value ( STR , saved _ legacy _ setting ) ; } } }
public sealed class availability _ statistics { <%> <+> public const string date _ time _ pattern = STR ; private const string statistics _ files _ name = STR ; private const int timeout _ milliseconds = NUM ; public static readonly date _ time unknown _ date _ time = new date _ time ( NUM , 1 , 1 ) ; public static string availability _ statistics _ file ; private readonly time _ span delay _ before _ start = time _ span . from _ seconds ( 1 ) ; private readonly time _ span monitor _ interval = time _ span . from _ seconds ( 1 ) ; private readonly time _ span retry _ interval = time _ span . from _ minutes ( 2 ) ; </%>
public statistics raw _ statistics { get ; private set ; } public statistics filtered _ statistics { get ; private set ; } <%> <-> public static readonly date _ time unknown _ date _ time = new date _ time ( NUM , 1 , 1 ) ; </%> private int repeat = > config . repeat _ times _ num ; <%> <-> private readonly time _ span retry _ interval = time _ span . from _ minutes ( 2 ) ; private time _ span interval = > time _ span . from _ minutes ( config . data _ collection _ minutes ) ; private timer timer ; private timer speed _ monior ; private state state ; private list < server > servers ; </%>
private int repeat = > config . repeat _ times _ num ; <%> <-> private readonly time _ span retry _ interval = time _ span . from _ minutes ( 2 ) ; private time _ span interval = > time _ span . from _ minutes ( config . data _ collection _ minutes ) ; private timer timer ; private timer speed _ monior ; private state state ; private list < server > servers ; private statistics _ strategy _ configuration config ; private const string empty = STR ; public static string availability _ statistics _ file ; </%>
public bool set ( statistics _ strategy _ configuration config ) { config = config ; try { if ( config . statistics _ enabled ) { if ( <%> <*> timer -> recorder </%> ? . change ( delay _ before _ start , <%> <+> recording _ </%> interval ) = = null ) { <%> <*> state -> recorder </%> = new <%> <*> state -> timer </%> ( <%> <+> run , null , delay _ before _ start , recording _ interval </%> ) ;
} } else { <%> <*> timer -> recorder </%> ? . dispose ( ) ; speed _ monior ? . dispose ( ) ; } return true ; } catch ( exception e )
speed _ monior ? . dispose ( ) ; } return true ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; return false ; } }
bytes = controller . outbound _ counter - last _ outbound _ counter ; last _ outbound _ counter = controller . outbound _ counter ; var outbound _ speed = get _ speed _ in _ ki _ b _ per _ second ( bytes , monitor _ interval . total _ seconds ) ; <%> <-> if ( inbound _ speed > inbound _ speed ) { inbound _ speed = inbound _ speed ; } if ( outbound _ speed > outbound _ speed ) { </%> outbound _ speed <%> <*> = -> _ records . add ( </%> outbound _ speed <%> <+> ) </%> ;
{ logging . debug ( STR + server . friendly _ name ( ) ) ; if ( server . server = = STR ) return null ; <%> <*> var ret = new list < data _ list > ( ) ; try { var ip = dns . get _ host _ addresses ( server . server ) . first ( ip = > ( ip . address _ family = = address _ family . inter _ network | | ip . address _ family = = address _ family . inter _ network ) ) ; -> var result = new icmp _ result ( server ) ; </%> <%> <+> try { var ip = </%>
var ping = new ping ( ) ; foreach ( var <%> <-> timestamp </%> in enumerable . range ( 0 , repeat ) <%> <*> . select ( = > date _ time . now . to _ string ( date _ time _ pattern ) ) ) -> ) </%> { try { var reply = await ping . send _ task _ async ( ip , timeout _ milliseconds ) ; <%> <*> ret -> if ( ! reply . status </%> . <%> <*> add -> equals </%> ( <%> <*> new list < key -> ip </%> _ <%> <*> value _ pair < string , string > > -> status . success ) ) </%> { <%> <*> new key -> result . roundtrip </%> _ <%> <*> value _ pair < string , string > ( STR , timestamp -> time . add ( ( int? ) reply . roundtrip _ time </%> ) <%> <*> , -> ; </%> <%> <-> new key _ value _ pair < string , string > ( STR , server . friendly _ name ( ) ) , </%> <%> <+> } </%>
try { var reply = await ping . send _ task _ async ( ip , timeout _ milliseconds ) ; <%> <*> ret -> if ( ! reply . status </%> . <%> <*> add -> equals </%> ( <%> <*> new list < key -> ip </%> _ <%> <*> value _ pair < string , string > > -> status . success ) ) </%> { <%> <*> new key -> result . roundtrip </%> _ <%> <*> value _ pair < string , string > ( STR , timestamp -> time . add ( ( int? ) reply . roundtrip _ time </%> ) <%> <*> , -> ; </%> <%> <-> new key _ value _ pair < string , string > ( STR , server . friendly _ name ( ) ) , </%> <%> <*> new key _ value _ pair < string , string > ( STR , reply ? . status . to _ string ( ) ) , -> } </%> <%> <*> new key _ value _ pair < string , string > ( STR , reply ? . roundtrip _ time . to _ string ( ) ) , -> else </%> <%> <+> { </%> <%> <*> new key _ value _ pair < string , string > ( STR , get -> result . roundtrip </%> _ <%> <*> recent _ latency -> time . add </%> ( <%> <*> server -> null </%> ) <%> <*> ) , -> ; </%>
<%> <+> thread . sleep ( timeout _ milliseconds + new random ( ) . next ( ) % timeout _ milliseconds ) ; </%> } catch ( exception e ) { logging . error ( $ STR ) ; logging . log _ useful _ exception ( e ) ; } } <%> <*> } catch ( exception e ) -> } </%>
filter _ raw _ statistics ( ) ; <%> <+> } private async void append _ record ( ) { var icmp _ results = task _ ex . when _ all ( servers . select ( icmp _ test ) ) ; var current _ server _ record = new statistics _ record ( current _ server . identifier ( ) , inbound _ speed _ records , outbound _ speed _ records , latency _ records ) ; foreach ( var result in ( await icmp _ results ) . where ( result = > result ! = null ) ) { list < statistics _ record > records ; </%>
private static void append ( data _ list data _ list , i _ enumerable < data _ unit > extra ) { var data = data _ list . concat ( extra ) ; var data _ line = string . join ( delimiter , data . select ( kv = > kv . value ) . to _ array ( ) ) ; string [ ] lines ; if ( ! file . exists ( availability _ statistics _ file ) ) { var header _ line = string . join ( delimiter , data . select ( kv = > kv . key ) . to _ array ( ) ) ; lines = new [ ] { header _ line , data _ line } ; }
set ( controller . statistics _ configuration ) ; servers = controller . get _ current _ configuration ( ) . configs ; } <%> <+> private bool is _ valid _ record ( statistics _ record record ) { if ( config . by _ hour _ of _ day ) { var current _ hour = date _ time . now . hour ; if ( record . timestamp = = unknown _ date _ time ) return false ; if ( ! record . timestamp . hour . equals ( date _ time . now . hour ) ) return false ; </%>
} } private void load _ raw _ statistics ( ) { try { var path = availability _ statistics _ file ; logging . debug ( $ STR ) ; if ( ! file . exists ( path ) ) {
return ; } } <%> <-> raw _ statistics = ( from l in file . read _ all _ lines ( path ) . skip ( 1 ) let strings = l . split ( new [ ] { STR } , string _ split _ options . remove _ empty _ entries ) let raw _ data = new raw _ statistics _ data { timestamp = parse _ exact _ or _ unknown ( strings [ 0 ] ) , server _ name = strings [ 1 ] , icmp _ status = strings [ 2 ] , </%>
} catch ( exception e ) { logging . log _ useful _ exception ( e ) ; } } private date _ time parse _ exact _ or _ unknown ( string str ) { date _ time date _ time ; <%> <-> return ! date _ time . try _ parse _ exact ( str , date _ time _ pattern , null , date _ time _ styles . none , out date _ time ) ? unknown _ date _ time : date _ time ; </%>
} public void update _ latency ( int latency ) { latency <%> <*> = -> _ records . add ( </%> latency <%> <+> ) </%> ; } private static int get _ speed _ in _ ki _ b _ per _ second ( long bytes , double seconds ) { var result = ( int ) ( bytes / seconds ) / NUM ; return result ; <%> <+> } </%>
} private static int get _ speed _ in _ ki _ b _ per _ second ( long bytes , double seconds ) { var result = ( int ) ( bytes / seconds ) / NUM ; return result ; <%> <+> } private class icmp _ result { internal readonly list < int? > roundtrip _ time = new list < int? > ( ) ; internal readonly server server ; </%>
if ( ! controller . availability _ statistics . filtered _ statistics . try _ get _ value ( server _ name , out statistics ) ) return ; i _ enumerable < i _ grouping < int , <%> <-> availability _ statistics . raw _ </%> statistics _ <%> <*> data -> record </%> > > data _ groups ; if ( all _ mode . checked ) { data _ groups = statistics . group _ by ( data = > data . timestamp . day _ of _ year ) ; statistics _ chart . chart _ areas [ STR ] . axis _ x . label _ style . format = STR ; statistics _ chart . chart _ areas [ STR ] . axis . label _ style . format = STR ; } else {
if ( all _ mode . checked ) { data _ groups = statistics . group _ by ( data = > data . timestamp . day _ of _ year ) ; statistics _ chart . chart _ areas [ STR ] . axis _ x . label _ style . format = STR ; statistics _ chart . chart _ areas [ STR ] . axis . label _ style . format = STR ; } else { data _ groups = statistics . group _ by ( data = > data . timestamp . hour ) ; statistics _ chart . chart _ areas [ STR ] . axis _ x . label _ style . format = STR ;
private int choice _ kept _ milliseconds = > ( int ) time _ span . from _ minutes ( controller . statistics _ configuration . choice _ kept _ minutes ) . total _ milliseconds ; public statistics _ strategy ( shadowsocks _ controller controller ) { controller = controller ; var servers = controller . get _ current _ configuration ( ) . configs ; var random _ index = new random ( ) . next ( ) % servers . count ( ) ; current _ server = servers [ random _ index ] ; timer = new timer ( reload _ statistics _ and _ choose _ a _ server ) ; }
} private float get _ score ( string server _ name ) { var config = controller . statistics _ configuration ; <%> <-> list < availability _ statistics . raw _ statistics _ data > data _ list ; if ( filtered _ statistics = = null | | ! filtered _ statistics . try _ get _ value ( server _ name , out data _ list ) ) return 0 ; var success _ times = ( float ) data _ list . count ( data = > data . icmp _ status . equals ( ip _ status . success . to _ string ( ) ) ) ; var timed _ out _ times = ( float ) data _ list . count ( data = > data . icmp _ status . equals ( ip _ status . timed _ out . to _ string ( ) ) ) ; var statistics _ data = new availability _ statistics . statistics _ data { </%>
float factor ; float score = 0 ; <%> <+> var average _ record = new statistics _ record ( server _ name , records . find _ all ( record = > record . max _ inbound _ speed ! = null ) . select ( record = > record . max _ inbound _ speed . value ) , records . find _ all ( record = > record . max _ outbound _ speed ! = null ) . select ( record = > record . max _ outbound _ speed . value ) , records . find _ all ( record = > record . average _ latency ! = null ) . select ( record = > record . average _ latency . value ) ) ; average _ record . set _ response ( records . select ( record = > record . average _ response ) ) ; </%> if ( ! config . calculations . try _ get _ value ( STR , out factor ) ) factor = 0 ; score + = <%> <*> statistics -> average </%> _ <%> <*> data -> record </%> . package _ loss * factor <%> <+> ? ? 0 </%> ; if ( ! config . calculations . try _ get _ value ( STR , out factor ) ) factor = 0 ;
if ( ! config . calculations . try _ get _ value ( STR , out factor ) ) factor = 0 ; score + = <%> <*> statistics -> average </%> _ <%> <*> data -> record </%> . average _ response * factor <%> <+> ? ? 0 </%> ; if ( ! config . calculations . try _ get _ value ( STR , out factor ) ) factor = 0 ; score + = <%> <*> statistics -> average </%> _ <%> <*> data -> record </%> . min _ response * factor <%> <+> ? ? 0 </%> ; if ( ! config . calculations . try _ get _ value ( STR , out factor ) ) factor = 0 ; score + = <%> <*> statistics -> average </%> _ <%> <*> data -> record </%> . max _ response * factor <%> <+> ? ? 0 </%> ; logging . debug ( $ STR ) ; return score ; } private void choose _ new _ server ( list < server > servers )
if ( ! config . calculations . try _ get _ value ( STR , out factor ) ) factor = 0 ; score + = <%> <*> statistics -> average </%> _ <%> <*> data -> record </%> . min _ response * factor <%> <+> ? ? 0 </%> ; if ( ! config . calculations . try _ get _ value ( STR , out factor ) ) factor = 0 ; score + = <%> <*> statistics -> average </%> _ <%> <*> data -> record </%> . max _ response * factor <%> <+> ? ? 0 </%> ; logging . debug ( $ STR ) ; return score ; } private void choose _ new _ server ( list < server > servers ) { if ( filtered _ statistics = = null | | servers . count = = 0 )
if ( ! config . calculations . try _ get _ value ( STR , out factor ) ) factor = 0 ; score + = <%> <*> statistics -> average </%> _ <%> <*> data -> record </%> . max _ response * factor <%> <+> ? ? 0 </%> ; logging . debug ( $ STR ) ; return score ; } private void choose _ new _ server ( list < server > servers ) { if ( filtered _ statistics = = null | | servers . count = = 0 ) { return ;
return score ; } private void choose _ new _ server ( list < server > servers ) { if ( filtered _ statistics = = null | | servers . count = = 0 ) { return ; } try {
this . table _ layout _ panel . suspend _ layout ( ) ; this . panel . suspend _ layout ( ) ; this . panel . suspend _ layout ( ) ; this . server _ group _ box . suspend _ layout ( ) ; this . suspend _ layout ( ) ; this . table _ layout _ panel . auto _ size = true ; this . table _ layout _ panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . table _ layout _ panel . column _ count = 2 ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ;
this . table _ layout _ panel . name = STR ; this . table _ layout _ panel . padding = new system . windows . forms . padding ( <%> <+> NUM , NUM , NUM , </%> NUM ) ; this . table _ layout _ panel . row _ count = NUM ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ;
this . table _ layout _ panel . row _ count = NUM ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ; this . table _ layout _ panel . tab _ index = 0 ; this . remarks _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ;
this . remarks _ text _ box . name = STR ; this . remarks _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . remarks _ text _ box . tab _ index = NUM ; this . remarks _ text _ box . word _ wrap = false ; this . label . anchor = system . windows . forms . anchor _ styles . right ; this . label . auto _ size = true ; this . label . location = new system . drawing . point ( NUM , NUM ) ; <%> <+> this . label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ; </%> this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ;
this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ; this . label . tab _ index = NUM ; this . label . text = STR ; this . label . anchor = system . windows . forms . anchor _ styles . right ; this . label . auto _ size = true ; this . label . location = new system . drawing . point ( NUM , NUM ) ; <%> <+> this . label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ; </%> this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ;
this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ; this . label . tab _ index = 0 ; this . label . text = STR ; this . label . anchor = system . windows . forms . anchor _ styles . right ; this . label . auto _ size = true ; this . label . location = new system . drawing . point ( NUM , NUM ) ; <%> <+> this . label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ; </%> this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ;
this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ; this . label . tab _ index = 1 ; this . label . text = STR ; this . proxy _ port _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . proxy _ port _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; <%> <+> this . proxy _ port _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; </%> this . proxy _ port _ text _ box . name = STR ; this . proxy _ port _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . proxy _ port _ text _ box . tab _ index = NUM ;
this . proxy _ port _ text _ box . name = STR ; this . proxy _ port _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . proxy _ port _ text _ box . tab _ index = NUM ; this . proxy _ port _ text _ box . word _ wrap = false ; this . label . anchor = system . windows . forms . anchor _ styles . right ; this . label . auto _ size = true ; this . label . location = new system . drawing . point ( NUM , NUM ) ; <%> <+> this . label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ; </%> this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ;
this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ; this . label . tab _ index = NUM ; this . label . text = STR ; this . label . anchor = system . windows . forms . anchor _ styles . right ; this . label . auto _ size = true ; this . label . location = new system . drawing . point ( NUM , NUM ) ; <%> <+> this . label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ; </%> this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ;
this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ; this . label . tab _ index = 2 ; this . label . text = STR ; this . ip _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . ip _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; <%> <+> this . ip _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; </%> this . ip _ text _ box . name = STR ; this . ip _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . ip _ text _ box . tab _ index = 0 ;
this . ip _ text _ box . name = STR ; this . ip _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . ip _ text _ box . tab _ index = 0 ; this . ip _ text _ box . word _ wrap = false ; this . server _ port _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . server _ port _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; <%> <+> this . server _ port _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; </%> this . server _ port _ text _ box . name = STR ; this . server _ port _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . server _ port _ text _ box . tab _ index = 1 ;
this . server _ port _ text _ box . name = STR ; this . server _ port _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . server _ port _ text _ box . tab _ index = 1 ; this . server _ port _ text _ box . word _ wrap = false ; this . password _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . password _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; <%> <+> this . password _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; </%> this . password _ text _ box . name = STR ; this . password _ text _ box . password _ char = '*' ; this . password _ text _ box . size = new system . drawing . size ( NUM , NUM ) ;
this . password _ text _ box . name = STR ; this . password _ text _ box . password _ char = '*' ; this . password _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . password _ text _ box . tab _ index = 2 ; this . password _ text _ box . word _ wrap = false ; this . label . anchor = system . windows . forms . anchor _ styles . right ; this . label . auto _ size = true ; this . label . location = new system . drawing . point ( NUM , NUM ) ; <%> <+> this . label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ; </%> this . label . name = STR ;
this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ; this . label . tab _ index = NUM ; this . label . text = STR ; this . encryption _ select . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( ( system . windows . forms . anchor _ styles . top | system . windows . forms . anchor _ styles . left ) | system . windows . forms . anchor _ styles . right ) ) ) ; this . encryption _ select . drop _ down _ style = system . windows . forms . combo _ box _ style . drop _ down _ list ; this . encryption _ select . formatting _ enabled = true ; this . encryption _ select . ime _ mode = system . windows . forms . ime _ mode . no _ control ; this . encryption _ select . item _ height = NUM ;
this . encryption _ select . name = STR ; this . encryption _ select . size = new system . drawing . size ( NUM , NUM ) ; this . encryption _ select . tab _ index = NUM ; <%> <-> this . notify _ icon . icon = ( ( system . drawing . icon ) ( resources . get _ object ( STR ) ) ) ; </%> this . notify _ icon . text = STR ; <%> <-> this . notify _ icon . visible = true ; </%> this . notify _ icon . double _ click + = new system . event _ handler ( this . notify _ icon _ double _ click ) ; this . panel . anchor = system . windows . forms . anchor _ styles . top ; this . panel . auto _ size = true ; this . panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ;
this . notify _ icon . text = STR ; <%> <-> this . notify _ icon . visible = true ; </%> this . notify _ icon . double _ click + = new system . event _ handler ( this . notify _ icon _ double _ click ) ; this . panel . anchor = system . windows . forms . anchor _ styles . top ; this . panel . auto _ size = true ; this . panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . panel . location = new system . drawing . point ( NUM , NUM ) ; <%> <+> this . panel . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; </%> this . panel . name = STR ; this . panel . size = new system . drawing . size ( 0 , 0 ) ;
this . notify _ icon . double _ click + = new system . event _ handler ( this . notify _ icon _ double _ click ) ; this . panel . anchor = system . windows . forms . anchor _ styles . top ; this . panel . auto _ size = true ; this . panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . panel . location = new system . drawing . point ( NUM , NUM ) ; <%> <+> this . panel . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; </%> this . panel . name = STR ; this . panel . size = new system . drawing . size ( 0 , 0 ) ; this . panel . tab _ index = 1 ; this . ok _ button . dialog _ result = system . windows . forms . dialog _ result . ok ;
this . panel . name = STR ; this . panel . size = new system . drawing . size ( 0 , 0 ) ; this . panel . tab _ index = 1 ; this . ok _ button . dialog _ result = system . windows . forms . dialog _ result . ok ; this . ok _ button . location = new system . drawing . point ( NUM , NUM ) ; <%> <+> this . ok _ button . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; </%> this . ok _ button . name = STR ; this . ok _ button . size = new system . drawing . size ( NUM , NUM ) ; this . ok _ button . tab _ index = NUM ; this . ok _ button . text = STR ;
this . ok _ button . name = STR ; this . ok _ button . size = new system . drawing . size ( NUM , NUM ) ; this . ok _ button . tab _ index = NUM ; this . ok _ button . text = STR ; this . ok _ button . use _ visual _ style _ back _ color = true ; this . ok _ button . click + = new system . event _ handler ( this . ok _ button _ click ) ; this . my _ cancel _ button . dialog _ result = system . windows . forms . dialog _ result . cancel ; this . my _ cancel _ button . location = new system . drawing . point ( NUM , NUM ) ; <%> <+> this . my _ cancel _ button . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; </%> this . my _ cancel _ button . name = STR ;
this . my _ cancel _ button . name = STR ; this . my _ cancel _ button . size = new system . drawing . size ( NUM , NUM ) ; this . my _ cancel _ button . tab _ index = NUM ; this . my _ cancel _ button . text = STR ; this . my _ cancel _ button . use _ visual _ style _ back _ color = true ; this . my _ cancel _ button . click + = new system . event _ handler ( this . cancel _ button _ click ) ; this . panel . auto _ size = true ; this . panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . panel . controls . add ( this . my _ cancel _ button ) ; this . panel . controls . add ( this . ok _ button ) ;
this . delete _ button . name = STR ; this . delete _ button . size = new system . drawing . size ( NUM , NUM ) ; this . delete _ button . tab _ index = NUM ; this . delete _ button . text = STR ; this . delete _ button . use _ visual _ style _ back _ color = true ; this . delete _ button . click + = new system . event _ handler ( this . delete _ button _ click ) ; this . add _ button . location = new system . drawing . point ( NUM , NUM ) ; <%> <+> this . add _ button . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; </%> this . add _ button . name = STR ; this . add _ button . size = new system . drawing . size ( NUM , NUM ) ;
this . add _ button . name = STR ; this . add _ button . size = new system . drawing . size ( NUM , NUM ) ; this . add _ button . tab _ index = NUM ; this . add _ button . text = STR ; this . add _ button . use _ visual _ style _ back _ color = true ; this . add _ button . click + = new system . event _ handler ( this . add _ button _ click ) ; this . server _ group _ box . controls . add ( this . table _ layout _ panel ) ; this . server _ group _ box . location = new system . drawing . point ( NUM , NUM ) ; <%> <+> this . server _ group _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; </%> this . server _ group _ box . name = STR ;
this . server _ group _ box . name = STR ; <%> <+> this . server _ group _ box . padding = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; </%> this . server _ group _ box . size = new system . drawing . size ( NUM , NUM ) ; this . server _ group _ box . tab _ index = NUM ; this . server _ group _ box . tab _ stop = false ; this . server _ group _ box . text = STR ; this . servers _ list _ box . formatting _ enabled = true ; <%> <+> this . servers _ list _ box . item _ height = NUM ; </%> this . servers _ list _ box . location = new system . drawing . point ( NUM , NUM ) ; <%> <+> this . servers _ list _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; </%>
this . server _ group _ box . tab _ index = NUM ; this . server _ group _ box . tab _ stop = false ; this . server _ group _ box . text = STR ; this . servers _ list _ box . formatting _ enabled = true ; <%> <+> this . servers _ list _ box . item _ height = NUM ; </%> this . servers _ list _ box . location = new system . drawing . point ( NUM , NUM ) ; <%> <+> this . servers _ list _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; </%> this . servers _ list _ box . name = STR ; this . servers _ list _ box . size = new system . drawing . size ( NUM , NUM ) ; this . servers _ list _ box . tab _ index = NUM ;
this . servers _ list _ box . name = STR ; this . servers _ list _ box . size = new system . drawing . size ( NUM , NUM ) ; this . servers _ list _ box . tab _ index = NUM ; this . servers _ list _ box . selected _ index _ changed + = new system . event _ handler ( this . servers _ list _ box _ selected _ index _ changed ) ; this . accept _ button = this . ok _ button ; this . auto _ scale _ mode = system . windows . forms . auto _ scale _ mode . dpi ; this . auto _ size = true ; this . cancel _ button = this . my _ cancel _ button ; this . client _ size = new system . drawing . size ( NUM , NUM ) ; this . controls . add ( this . servers _ list _ box ) ;
{ <%> <*> return file -> geosite _ updater </%> . <%> <*> read -> merge </%> _ <%> <*> all -> and </%> _ <%> <*> text ( -> write _ </%> pac _ file <%> <*> , encoding . ut -> ( </%> ) ; } <%> <*> else { return resources . default _ abp _ rule + resources . abp _ js ; } -> return file . read _ all _ text ( pac _ file , encoding . ut ) ; </%> } private void watch _ pac _ file ( )
} <%> <*> else { return resources . default _ abp _ rule + resources . abp _ js ; } -> return file . read _ all _ text ( pac _ file , encoding . ut ) ; </%> } private void watch _ pac _ file ( ) { pac _ file _ watcher ? . dispose ( ) ;
} private void watch _ pac _ file ( ) { pac _ file _ watcher ? . dispose ( ) ; pac _ file _ watcher = new file _ system _ watcher ( directory . get _ current _ directory ( ) ) ; pac _ file _ watcher . notify _ filter = notify _ filters . last _ write | notify _ filters . file _ name | notify _ filters . directory _ name ; pac _ file _ watcher . filter = pac _ file ; pac _ file _ watcher . changed + = pac _ file _ watcher _ changed ; pac _ file _ watcher . created + = pac _ file _ watcher _ changed ; pac _ file _ watcher . deleted + = pac _ file _ watcher _ changed ;
return true ; } public class udp _ handler { private socket local ; private socket remote ; private server server ; private byte [ ] buffer = new byte [ NUM ] ; private ip _ end _ point local _ end _ point ; private ip _ end _ point remote _ end _ point ;
servers _ list _ box . selected _ index _ changed + = servers _ list _ box _ selected _ index _ changed ; return true ; } else return false ; } private bool? check _ ip _ text _ box ( out string address , bool is _ save , bool is _ copy ) { address = null ; string out _ address ;
} } private void duplicate _ button _ click ( object sender , event _ args e ) { if ( validate _ and _ save _ selected _ server _ details ( is _ copy : true ) ) { server curr _ server = modified _ configuration . configs [ last _ selected _ index ] ; configuration . add _ default _ server _ or _ server ( modified _ configuration , curr _ server <%> <+> , last _ selected _ index + 1 </%> ) ; load _ server _ name _ list _ to _ ui ( modified _ configuration ) ; <%> <*> update -> last _ selected _ index = ( servers _ list _ box . selected </%> _ index <%> <+> = ( last </%> _ <%> <*> to -> selected </%> _ <%> <*> end ( -> index + 1 ) </%> ) ;
load _ server _ name _ list _ to _ ui ( modified _ configuration ) ; <%> <*> update -> last _ selected _ index = ( servers _ list _ box . selected </%> _ index <%> <+> = ( last </%> _ <%> <*> to -> selected </%> _ <%> <*> end ( -> index + 1 ) </%> ) ; } } private void delete _ button _ click ( object sender , event _ args e ) { modified _ configuration . configs . remove _ at ( last _ selected _ index ) ; if ( modified _ configuration . configs . count = = 0 ) { configuration . add _ default _ server _ or _ server ( modified _ configuration ) ;
} } private void delete _ button _ click ( object sender , event _ args e ) { modified _ configuration . configs . remove _ at ( last _ selected _ index ) ; if ( modified _ configuration . configs . count = = 0 ) { configuration . add _ default _ server _ or _ server ( modified _ configuration ) ; } load _ server _ name _ list _ to _ ui ( modified _ configuration ) ;
servers _ list _ box . begin _ update ( ) ; <%> <*> servers _ list _ box . enabled = false ; last _ selected _ index = index + step ; servers _ list _ box . items . remove ( item ) ; servers _ list _ box . items . insert ( index + step , item ) ; servers _ list _ box . enabled = true ; servers _ list _ box . selected _ index = index + step ; -> load _ server _ name _ list _ to _ ui ( modified _ configuration ) ; </%> <%> <+> last _ selected _ index = new _ index ; servers _ list _ box . selected _ index = new _ index ; </%>
servers _ list _ box . end _ update ( ) ; update _ buttons ( ) ; } private void ok _ button _ click ( object sender , event _ args e ) { if ( save _ valid _ configuration ( ) ) { close ( ) ; } }
} else { <%> <+> realkey = key ; } if ( cipher = = cipher _ aes ) { polar _ ssl . aes _ init ( ctx ) ; polar _ ssl . aes _ setkey _ enc ( ctx , realkey , key _ len * NUM ) ; if ( is _ cipher ) </%>
} } static byte [ ] tempbuf = new byte [ NUM ] ; public override void encrypt ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength ) { if ( encrypt _ ctx = = null ) { rand _ bytes ( outbuf , iv _ len ) ; init _ cipher ( ref encrypt _ ctx , outbuf , true ) ; outlength = length + iv _ len ;
break ; case cipher _ bf : polar _ ssl . blowfish _ crypt _ cfb ( encrypt _ ctx , polar _ ssl . blowfish _ encrypt , length , ref encrypt _ iv _ offset , encrypt _ iv , buf , <%> <*> tempbuf -> outbuf </%> ) ; break ; case cipher _ r : <%> <-> polar _ ssl . arc _ crypt ( encrypt _ ctx , length , buf , tempbuf ) ; break ; } outlength = length + iv _ len ; buffer . block _ copy ( tempbuf , 0 , outbuf , iv _ len , outlength ) ; </%>
break ; case cipher _ r : <%> <-> polar _ ssl . arc _ crypt ( encrypt _ ctx , length , buf , tempbuf ) ; break ; } outlength = length + iv _ len ; buffer . block _ copy ( tempbuf , 0 , outbuf , iv _ len , outlength ) ; } } else </%>
} } } public override void decrypt ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength ) { if ( decrypt _ ctx = = null ) { init _ cipher ( ref decrypt _ ctx , buf , false ) ; outlength = length - iv _ len ; lock ( tempbuf )
break ; case cipher _ bf : polar _ ssl . blowfish _ crypt _ cfb ( decrypt _ ctx , polar _ ssl . blowfish _ decrypt , length <%> <-> - iv _ len </%> , ref decrypt _ iv _ offset , decrypt _ iv , <%> <*> tempbuf -> buf </%> , outbuf ) ; break ; case cipher _ r : <%> <-> polar _ ssl . arc _ crypt ( decrypt _ ctx , length - iv _ len , tempbuf , outbuf ) ; break ; } } } </%>
break ; case cipher _ r : <%> <-> polar _ ssl . arc _ crypt ( decrypt _ ctx , length - iv _ len , tempbuf , outbuf ) ; break ; } } } else { outlength = length ; </%>
} } } private bool disposed ; public override void dispose ( ) { dispose ( true ) ; gc . suppress _ finalize ( this ) ; } ~ polar _ ssl _ encryptor ( )
if ( encrypt _ ctx ! = null ) { <%> <+> lock ( encrypt _ ctx ) { </%> switch ( cipher ) { case cipher _ aes : polar _ ssl . aes _ free ( encrypt _ ctx ) ; break ; case cipher _ bf :
} } if ( decrypt _ ctx ! = null ) { <%> <+> lock ( decrypt _ ctx ) { </%> switch ( cipher ) { case cipher _ aes : polar _ ssl . aes _ free ( decrypt _ ctx ) ;
} } } }
content - type : application / x - ns - proxy - autoconfig content - length : { <%> <*> 0 } -> encoding . ut . get _ bytes ( pac _ content ) . length } </%> connection : close STR byte [ ] response = encoding . ut . get _ bytes ( response _ head + pac _ content ) ; socket . begin _ send ( response , 0 , response . length , 0 , new async _ callback ( send _ callback ) , socket ) ; utils . release _ memory ( true ) ; } catch ( exception e ) {
connection : close STR byte [ ] response = encoding . ut . get _ bytes ( response _ head + pac _ content ) ; socket . begin _ send ( response , 0 , response . length , 0 , new async _ callback ( send _ callback ) , socket ) ; utils . release _ memory ( true ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; socket . close ( ) ;
{ <%> <+> using ( var fs = new file _ stream ( path , file _ mode . open , file _ access . read , file _ share . read _ write ) ) using ( var sr = new stream _ reader ( fs , encoding ) ) { </%> return sr . read _ to _ end ( ) ; <%> <+> } } catch ( exception ex ) { logging . error ( ex ) ; </%>
} } } }
protected ulong encrypt _ ic ; protected ulong decrypt _ ic ; <%> <+> protected byte [ ] encrypt _ buf ; protected byte [ ] decrypt _ buf ; </%> public sodium _ encryptor ( string method , string password ) : base ( method , password ) { init _ key ( method , password ) ; <%> <+> encrypt _ buf = new byte [ max _ input _ size + sodium _ block _ size ] ; decrypt _ buf = new byte [ max _ input _ size + sodium _ block _ size ] ; </%>
ulong ic ; <%> <+> byte [ ] sodium _ buf ; byte [ ] iv ; </%> if ( is _ cipher ) { bytes _ remaining = encrypt _ bytes _ remaining ; ic = encrypt _ ic ; <%> <+> sodium _ buf = encrypt _ buf ; iv = encrypt _ iv ; </%> }
assembly _ assembly _ description assembly _ assembly _ configuration assembly _ assembly _ company _ clowwindy assembly _ assembly _ product _ shadowsocks <%> <-> _ csharp </%> assembly _ assembly _ copyright _ copyright _ clowwindy assembly _ assembly _ trademark assembly _ assembly _ culture assembly _ com _ visible _ false assembly _ guid _ bbd _ dcf assembly _ assembly _ version
assembly _ assembly _ copyright _ copyright _ clowwindy assembly _ assembly _ trademark assembly _ assembly _ culture assembly _ com _ visible _ false assembly _ guid _ bbd _ dcf assembly _ assembly _ version assembly _ assembly _ file _ version
using system _ collections _ generic ; using system _ io ; <%> <+> using system _ runtime _ interop _ services ; </%> using system _ windows _ forms ; namespace shadowsocks _ csharp { static class program { <%> <+> dll _ import _ kernel _ dll private static extern int _ ptr load _ library ( string path ) ; </%>
file _ stream fs = new file _ stream ( STR , file _ mode . append ) ; text _ writer tmp = console . out ; stream _ writer sw = new stream _ writer ( fs ) ; sw . auto _ flush = true ; console . set _ out ( sw ) ; console . set _ error ( sw ) ; } catch ( io _ exception e ) { console . write _ line ( e . to _ string ( ) ) ;
foreach ( string domain in domains ) { string last _ root _ domain = null ; int pos ; pos = domain . last _ index _ of ( '.' ) ; last _ root _ domain = domain . substring ( pos + 1 ) ; if ( ! tld _ <%> <*> dic -> index </%> . contains <%> <-> _ key </%> ( last _ root _ domain ) ) continue ; while ( pos > 0 ) {
continue ; while ( pos > 0 ) { pos = domain . last _ index _ of ( '.' , pos - 1 ) ; last _ root _ domain = domain . substring ( pos + 1 ) ; if ( tld _ <%> <*> dic -> index </%> . contains <%> <-> _ key </%> ( last _ root _ domain ) ) continue ; else break ; }
{ string [ ] tlds = get _ tlds ( ) ; <%> <*> i -> tld </%> _ <%> <*> dictionary < string , string > dic -> index index </%> = new <%> <*> dictionary < string , string > -> tld _ index </%> ( <%> <-> tlds . length </%> ) ; foreach ( string tld in tlds ) { <%> <*> if ( ! dic . contains _ key ( tld ) ) -> index . add ( tld ) ; </%> <%> <+> } return index ; } </%>
foreach ( string tld in tlds ) { <%> <*> if ( ! dic . contains _ key ( tld ) ) -> index . add ( tld ) ; </%> <%> <+> } return index ; } private string [ ] get _ build _ in ( ) { string [ ] buildin = null ; </%>
dic . add ( tld , tld ) ; } <%> <-> return dic ; </%> <%> <+> } public bool contains ( string tld ) { if ( dic . contains _ key ( tld ) ) return true ; foreach ( string pattern in patterns ) { if ( regex . is _ match ( tld , pattern ) ) </%>
} } } }
} } } public void update _ latency ( model . server server , time _ span latency ) { logging . debug ( <%> <*> string . format ( -> $ </%> STR <%> <-> , server . friendly _ name ( ) , latency ) </%> ) ; server _ status status ; if ( server _ status . try _ get _ value ( server , out status ) ) { status . latency = latency ;
server _ status status ; if ( server _ status . try _ get _ value ( server , out status ) ) { status . latency = latency ; status . last _ time _ detect _ latency = date _ time . now ; } } public void update _ last _ read ( model . server server ) { logging . debug ( <%> <*> string . format ( -> $ </%> STR <%> <-> , server . friendly _ name ( ) ) </%> ) ;
server _ status status ; if ( server _ status . try _ get _ value ( server , out status ) ) { status . last _ read = date _ time . now ; } } public void update _ last _ write ( model . server server ) { logging . debug ( <%> <*> string . format ( -> $ </%> STR <%> <-> , server . friendly _ name ( ) ) </%> ) ; server _ status status ;
server _ status status ; if ( server _ status . try _ get _ value ( server , out status ) ) { status . last _ write = date _ time . now ; } } public void set _ failure ( model . server server ) { logging . debug ( <%> <*> string . format ( -> $ </%> STR <%> <-> , server . friendly _ name ( ) ) </%> ) ; server _ status status ;
server _ status status ; if ( server _ status . try _ get _ value ( server , out status ) ) { status . last _ failure = date _ time . now ; } } } }
{ <%> <*> console . write _ line ( STR , exception . to _ string ( ) ) ; -> logging . log _ useful _ exception ( e ) ; </%> } return false ; } public static void uncompress _ file ( string file _ name , byte [ ] content ) { file _ stream destination _ file = file . create ( file _ name ) ;
} return false ; } public static void uncompress _ file ( string file _ name , byte [ ] content ) { file _ stream destination _ file = file . create ( file _ name ) ; byte [ ] buffer = new byte [ NUM ] ; int n ; using ( g _ zip _ stream input = new g _ zip _ stream ( new memory _ stream ( content ) , compression _ mode . decompress , false ) )
} public static void log _ useful _ exception ( exception e ) { if ( e is socket _ exception ) { socket _ exception se = ( socket _ exception ) e ; if ( se . socket _ error _ code = = socket _ error . connection _ aborted ) { } else if ( se . socket _ error _ code = = socket _ error . connection _ reset )
public log _ form ( shadowsocks _ controller controller , string filename ) { this . controller = controller ; this . filename = filename ; initialize _ component ( ) ; icon = icon . from _ handle ( resources . ssw . get _ hicon ( ) ) ; log _ viewer _ config config = controller . get _ configuration _ copy ( ) . log _ viewer ; top _ most _ trigger = config . top _ most ; wrap _ text _ trigger = config . wrap _ text ; toolbar _ trigger = config . toolbar _ shown ;
const long min _ scale = NUM ; long max _ speed = 0 ; long last _ inbound , last _ outbound ; lock ( this ) { if ( traffic . count = = 0 ) return ; foreach ( var traffic _ per _ second in traffic ) { inbound _ points . add ( traffic _ per _ second . <%> <*> item -> inbound </%> ) ;
} if ( max _ speed > 0 ) { last _ max _ speed - = last _ max _ speed / NUM ; max _ speed = math . max ( min _ scale , math . max ( max _ speed , last _ max _ speed ) ) ; last _ max _ speed = max _ speed ; } else { max _ speed = last _ max _ speed = min _ scale ;
if ( traffic _ chart . is _ handle _ created ) { traffic _ chart . series [ STR ] . points . data _ bind _ y ( inbound _ points ) ; traffic _ chart . series [ STR ] . points . data _ bind _ y ( outbound _ points ) ; traffic _ chart . chart _ areas [ 0 ] . axis _ y . label _ style . format = STR + bandwidth _ scale . <%> <*> item -> unit _ name </%> ; traffic _ chart . chart _ areas [ 0 ] . axis _ y . maximum = bandwidth _ scale . <%> <*> item -> value </%> ; inbound _ annotation . anchor _ data _ point = traffic _ chart . series [ STR ] . points . last ( ) ; inbound _ annotation . text = utils . format _ bandwidth ( last _ inbound ) ; outbound _ annotation . anchor _ data _ point = traffic _ chart . series [ STR ] . points . last ( ) ; outbound _ annotation . text = utils . format _ bandwidth ( last _ outbound ) ;
inbound _ annotation . anchor _ data _ point = traffic _ chart . series [ STR ] . points . last ( ) ; inbound _ annotation . text = utils . format _ bandwidth ( last _ inbound ) ; outbound _ annotation . anchor _ data _ point = traffic _ chart . series [ STR ] . points . last ( ) ; outbound _ annotation . text = utils . format _ bandwidth ( last _ outbound ) ; traffic _ chart . annotations . clear ( ) ; traffic _ chart . annotations . add ( inbound _ annotation ) ; traffic _ chart . annotations . add ( outbound _ annotation ) ; } } private void controller _ traffic _ changed ( object sender , event _ args e )
foreach ( var traffic _ per _ second in controller . traffic ) { traffic . enqueue ( new <%> <*> tuple < long , long > -> traffic _ info </%> ( traffic _ per _ second . inbound _ increasement , traffic _ per _ second . outbound _ increasement ) ) ; } } } private void update _ texts ( ) { file _ menu _ item . text = n . get _ string ( STR ) ; open _ location _ menu _ item . text = n . get _ string ( STR ) ;
} } } private void update _ texts ( ) { file _ menu _ item . text = n . get _ string ( STR ) ; open _ location _ menu _ item . text = n . get _ string ( STR ) ; exit _ menu _ item . text = n . get _ string ( STR ) ; clean _ logs _ button . text = n . get _ string ( STR ) ; change _ font _ button . text = n . get _ string ( STR ) ;
} public static <%> <*> tuple < float , string , long > -> bandwidth _ scale _ info </%> get _ bandwidth _ scale ( long n ) { long scale = 1 ; float f = n ; string unit = STR ; if ( f > NUM ) { f = f / NUM ; scale < < = NUM ;
{ long scale = 1 ; float f = n ; string unit = STR ; if ( f > NUM ) { f = f / NUM ; scale < < = NUM ; unit = STR ; }
using shadowsocks _ model ; <%> <+> using shadowsocks _ proxy ; </%> using shadowsocks _ util _ sockets ; namespace shadowsocks _ controller { class tcp _ relay : listener . service { private shadowsocks _ controller controller ; private date _ time last _ sweep _ time ; private configuration config ;
{ public class socks _ proxy : i <%> <-> _ forward </%> _ proxy { private class fake _ async _ result : i _ async _ result { public readonly socks _ state inner _ state ; private readonly i _ async _ result r ; public fake _ async _ result ( i _ async _ result orig , socks _ state state ) { r = orig ;
{ private class fake _ async _ result : i _ async _ result { public readonly socks _ state inner _ state ; private readonly i _ async _ result r ; public fake _ async _ result ( i _ async _ result orig , socks _ state state ) { r = orig ; inner _ state = state ; }
{ public class http _ proxy : i <%> <-> _ forward </%> _ proxy { private class fake _ async _ result : i _ async _ result { public readonly http _ state inner _ state ; private readonly i _ async _ result r ; public fake _ async _ result ( i _ async _ result orig , http _ state state ) { r = orig ;
{ private class fake _ async _ result : i _ async _ result { public readonly http _ state inner _ state ; private readonly i _ async _ result r ; public fake _ async _ result ( i _ async _ result orig , http _ state state ) { r = orig ; inner _ state = state ; }
{ public interface i <%> <-> _ forward </%> _ proxy { end _ point local _ end _ point { get ; } end _ point proxy _ end _ point { get ; } end _ point dest _ end _ point { get ; } void begin _ connect _ proxy ( end _ point remote _ ep , async _ callback callback , object state ) ; void end _ connect _ proxy ( i _ async _ result async _ result ) ; void begin _ connect _ dest ( end _ point dest _ end _ point , async _ callback callback , object state ) ; void end _ connect _ dest ( i _ async _ result async _ result ) ;
{ end _ point local _ end _ point { get ; } end _ point proxy _ end _ point { get ; } end _ point dest _ end _ point { get ; } void begin _ connect _ proxy ( end _ point remote _ ep , async _ callback callback , object state ) ; void end _ connect _ proxy ( i _ async _ result async _ result ) ; void begin _ connect _ dest ( end _ point dest _ end _ point , async _ callback callback , object state ) ; void end _ connect _ dest ( i _ async _ result async _ result ) ; void begin _ send ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) ;
{ public class direct _ connect : i <%> <-> _ forward </%> _ proxy { private class fake _ async _ result : i _ async _ result { public fake _ async _ result ( object state ) { async _ state = state ; } public bool is _ completed { get ; } = true ;
{ private class fake _ async _ result : i _ async _ result { public fake _ async _ result ( object state ) { async _ state = state ; } public bool is _ completed { get ; } = true ; public wait _ handle async _ wait _ handle { get ; } = null ; public object async _ state { get ; }
public const string version = STR ; public void check _ update ( configuration config ) { web _ client http = new web _ client ( ) ; http . headers . add ( STR , STR ) ; http . proxy = new web _ proxy ( ip _ address . loopback . to _ string ( ) , config . local _ port ) ; http . download _ string _ completed + = http _ download _ string _ completed ; http . download _ string _ async ( new uri ( update _ url ) ) ; } public static int compare _ version ( string l , string r )
{ <%> <*> return ; -> sort _ versions ( versions ) ; </%> <%> <+> new _ version _ found = true ; latest _ version _ url = versions [ versions . count - 1 ] ; latest _ version _ number = parse _ version _ from _ url ( latest _ version _ url ) ; </%> } <%> <-> sort _ versions ( versions ) ; latest _ version _ url = versions [ versions . count - 1 ] ; latest _ version _ number = parse _ version _ from _ url ( latest _ version _ url ) ; </%>
} <%> <*> sort _ versions ( versions ) ; latest _ version _ url = versions [ versions . count - 1 ] ; latest _ version _ number = parse _ version _ from _ url ( latest _ version _ url ) ; if ( new _ version _ found ! = null ) -> if ( check _ update _ completed ! = null ) </%> { <%> <*> new -> check </%> _ <%> <*> version -> update </%> _ <%> <*> found -> completed </%> ( this , new event _ args ( ) ) ; } }
{ <%> <*> new -> check </%> _ <%> <*> version -> update </%> _ <%> <*> found -> completed </%> ( this , new event _ args ( ) ) ; } } catch ( exception ex ) { logging . debug ( ex . to _ string ( ) ) ; return ; } }
} } catch ( exception ex ) { logging . debug ( ex . to _ string ( ) ) ; return ; } } } }
load _ current _ configuration ( ) ; <%> <*> update _ checker . check _ update ( controller . get _ configuration _ copy ( ) ) ; if ( controller . get _ configuration _ copy ( ) . is _ default ) -> configuration config = controller . get _ configuration _ copy ( ) ; </%> <%> <+> if ( config . auto _ check _ update ) { is _ startup _ checking = true ; update _ checker . check _ update ( config ) ; } if ( config . is _ default ) </%>

using shadowsocks _ controller ; namespace shadowsocks _ encryption _ stream { public abstract class stream _ encryptor : encryptor _ base { protected static byte [ ] udp _ tmp _ buf = new byte [ NUM ] ; private <%> <+> byte _ </%> circular _ buffer <%> <-> < byte > </%> enc _ circular _ buffer = new <%> <+> byte _ </%> circular _ buffer <%> <-> < byte > </%> ( tcp _ handler . buffer _ size * 2 <%> <-> , false </%> ) ; private <%> <+> byte _ </%> circular _ buffer <%> <-> < byte > </%> dec _ circular _ buffer = new <%> <+> byte _ </%> circular _ buffer <%> <-> < byte > </%> ( tcp _ handler . buffer _ size * 2 <%> <-> , false </%> ) ; protected dictionary < string , encryptor _ info > ciphers ;
protected dictionary < string , encryptor _ info > ciphers ; protected byte [ ] encrypt _ iv ; protected byte [ ] decrypt _ iv ; protected bool decrypt _ iv _ received ; protected bool encrypt _ iv _ sent ; protected string method ; protected int cipher ; protected string inner _ lib _ name ; protected encryptor _ info cipher _ info ; protected static byte [ ] key = null ;
} private void ok _ button _ click ( object sender , event _ args e ) { <%> <-> foreach ( var tb in all _ text _ boxes ) { if ( tb . text . is _ null _ or _ empty ( ) ) { continue ; } </%> if ( ! <%> <*> try -> register </%> _ <%> <*> reg -> all </%> _ <%> <*> hotkey -> hotkeys </%> ( <%> <*> tb -> out </%> ) )
} save _ config ( ) ; <%> <+> this . </%> close ( ) ; } private void register _ all _ button _ click ( object sender , event _ args e ) { <%> <+> register _ all _ hotkeys ( out ) ; } private bool register _ all _ hotkeys ( out string failure _ info _ str ) { </%>
} private void register _ all _ button _ click ( object sender , event _ args e ) { <%> <+> register _ all _ hotkeys ( out ) ; } private bool register _ all _ hotkeys ( out string failure _ info _ str ) { bool is _ success = true ; string _ builder failure _ info = new string _ builder ( ) ; </%> foreach ( var tb in all _ text _ boxes )
} private bool try _ reg _ hotkey ( text _ box tb ) { var hotkey = hot _ keys . str _ hot _ key ( tb . text ) ; if ( hotkey = = null ) { message _ box . show ( string . format ( n . get _ string ( STR ) , tb . text ) ) ; tb . clear ( ) ; return false ; }
lb . back _ color = reg _ result ? color . green : color . yellow ; return reg _ result ; } private static void unreg _ prev _ hotkey ( hot _ keys . hot _ key _ call _ back _ handler cb ) { global _ hot _ key . hot _ key prev _ hot _ key ; if ( hot _ keys . is _ callback _ exists ( cb , out prev _ hot _ key ) ) { hot _ keys . <%> <*> un _ regist -> unregister </%> ( prev _ hot _ key ) ; }
} } private void save _ config ( ) { modified <%> <+> _ hotkey </%> _ config . switch _ system _ proxy = switch _ system _ proxy _ text _ box . text ; modified <%> <+> _ hotkey </%> _ config . switch _ system _ proxy _ mode = switch _ proxy _ mode _ text _ box . text ; modified <%> <+> _ hotkey </%> _ config . switch _ allow _ lan = switch _ allow _ lan _ text _ box . text ; modified <%> <+> _ hotkey </%> _ config . show _ logs = show _ logs _ text _ box . text ; modified <%> <+> _ hotkey </%> _ config . server _ move _ up = server _ move _ up _ text _ box . text ; modified <%> <+> _ hotkey </%> _ config . server _ move _ down = server _ move _ down _ text _ box . text ;
} private void prepare _ for _ hotkey ( text _ box tb , out hot _ keys . hot _ key _ call _ back _ handler cb , out label lb ) { * xxx : the label _ name , text _ box _ name and callback _ name * must follow this rule to make use of reflection * * < base _ name > < control - type - name > * / if ( tb = = null ) throw new argument _ null _ exception ( nameof ( tb ) ) ;
} } }
public high _ availability _ strategy ( shadowsocks _ controller controller ) { controller = controller ; random = new random ( ) ; server _ status = new dictionary < server , server _ status > ( ) ; } public string name { get { return n . get _ string ( STR ) ; } }
} public server get _ a _ server ( i _ strategy _ caller _ type type , system . net . ip _ end _ point local _ ip _ end _ point ) { <%> <+> choose _ new _ server ( ) ; </%> return current _ server ; } public void update _ latency ( model . server server , time _ span latency ) { logging . debug ( string . format ( STR , server . friendly _ name ( ) , latency ) ) ; server _ status status ;
namespace shadowsocks _ model { serializable public class statistics _ strategy _ configuration { public static readonly string id = STR ; private bool statistics _ enabled = true ; private bool by _ isp = false ; private bool by _ hour _ of _ day = false ; private int choice _ kept _ minutes = NUM ;
{ <%> <*> var match = url _ finder . match ( ss _ url ) ; -> var matches = url _ finder . matches ( ss _ url ) ; if ( matches . count < = 0 ) return null ; list < server > servers = new list < server > ( ) ; foreach ( match match in matches ) </%> <%> <+> { </%> <%> <*> if ( ! match . success ) throw -> server tmp = </%> new <%> <*> format _ exception -> server </%> ( ) ; var base = match . groups [ <%> <*> 1 -> STR </%> ] . value ; var tag = match . groups [ <%> <*> NUM -> STR </%> ] . value ; if ( ! tag . is _ null _ or _ empty ( ) )
} public string identifier ( ) { return server + ':' + server _ port ; } } }
{ for ( int i = 0 ; i < <%> <-> buf . </%> length ; i + + ) { buf [ i ] = encrypt _ table [ buf [ i ] ] ; } } public void decrypt ( byte [ ] buf <%> <+> , int length </%> ) { for ( int i = 0 ; i < <%> <-> buf . </%> length ; i + + ) {
{ buf [ i ] = encrypt _ table [ buf [ i ] ] ; } } public void decrypt ( byte [ ] buf <%> <+> , int length </%> ) { for ( int i = 0 ; i < <%> <-> buf . </%> length ; i + + ) { buf [ i ] = decrypt _ table [ buf [ i ] ] ; }
{ for ( int i = 0 ; i < <%> <-> buf . </%> length ; i + + ) { buf [ i ] = decrypt _ table [ buf [ i ] ] ; } } } }
{ buf [ i ] = decrypt _ table [ buf [ i ] ] ; } } } }
using system _ net _ network _ information ; using system _ threading ; <%> <+> using shadowsocks _ model ; </%> namespace shadowsocks _ controller _ strategy { class simply _ choose _ by _ statistics _ strategy : i _ strategy { private <%> <+> readonly </%> shadowsocks _ controller controller ; private server current _ server ; private <%> <+> readonly </%> timer timer ;
private server current _ server ; private <%> <+> readonly </%> timer timer ; private dictionary < string , statistics _ data > statistics ; private <%> <*> static readonly -> const </%> int cached _ interval = NUM * NUM * NUM ; <%> <+> private const int retry _ interval = 2 * NUM * NUM ; </%> public simply _ choose _ by _ statistics _ strategy ( shadowsocks _ controller controller ) { controller = controller ; var servers = controller . get _ current _ configuration ( ) . configs ; <%> <*> int -> var </%> random _ index = new random ( ) . next ( ) % servers . count ( ) ;
public simply _ choose _ by _ statistics _ strategy ( shadowsocks _ controller controller ) { controller = controller ; var servers = controller . get _ current _ configuration ( ) . configs ; <%> <*> int -> var </%> random _ index = new random ( ) . next ( ) % servers . count ( ) ; current _ server = servers [ random _ index ] ; timer = new timer ( reload _ statistics _ and _ choose _ a _ server ) ; } private void reload _ statistics _ and _ choose _ a _ server ( object obj ) {
current _ server = servers [ random _ index ] ; timer = new timer ( reload _ statistics _ and _ choose _ a _ server ) ; } private void reload _ statistics _ and _ choose _ a _ server ( object obj ) { logging . debug ( STR ) ; <%> <*> list < server > -> var </%> servers = controller . get _ current _ configuration ( ) . configs ; load _ statistics ( ) ; choose _ new _ server ( servers ) ; }
load _ statistics ( ) ; choose _ new _ server ( servers ) ; } return a dict : { ' server _ friendly _ name ' : statistics _ data , ' server _ friendly _ name ' : . . . } * / private void load _ statistics ( )
{ <%> <*> console . write _ line ( STR , best -> log </%> _ <%> <*> result . server . friendly -> when </%> _ <%> <*> name -> enabled </%> ( <%> <*> ) , 1 - best _ result . score -> $ STR </%> ) ; } current _ server = best _ result . server ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; } }
} current _ server = best _ result . server ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; } } <%> <*> public -> private void log _ when _ enabled ( </%> string <%> <*> id -> log ) </%> {
{ <%> <*> get { return STR ; } -> if ( controller . get _ current _ strategy ( ) ? . id = = id ) </%> <%> <+> { console . write _ line ( log ) ; } </%> } <%> <-> public string name { get { return n . get _ string ( STR ) ; } </%>
} <%> <*> public string name { get { return n . get _ string ( STR ) ; } } -> public string id = > STR ; </%> <%> <+> public string name = > n . get _ string ( STR ) ; </%> public server get _ a _ server ( i _ strategy _ caller _ type type , ip _ end _ point local _ ip _ end _ point ) { var old _ server = current _ server ;
public server get _ a _ server ( i _ strategy _ caller _ type type , ip _ end _ point local _ ip _ end _ point ) { var old _ server = current _ server ; if ( old _ server = = null ) { choose _ new _ server ( controller . get _ current _ configuration ( ) . configs ) ; } <%> <-> if ( old _ server ! = current _ server ) { } </%>
return current _ server ; } public void reload _ servers ( ) { choose _ new _ server ( controller . get _ current _ configuration ( ) . configs ) ; timer ? . change ( 0 , cached _ interval ) ; } public void set _ failure ( server server ) { logging . debug ( <%> <*> string . format ( -> $ </%> STR <%> <-> , server . friendly _ name ( ) ) </%> ) ;
} public void update _ last _ read ( server server ) { } public void update _ last _ write ( server server ) { } public void update _ latency ( server server , time _ span latency ) { }
is _ first _ run = false ; <%> <+> } if ( updated ) { show _ balloon _ tip ( n . get _ string ( STR ) , n . get _ string ( STR ) , tool _ tip _ icon . info , 0 ) ; </%>
message _ box . show ( $ STR unexpected error , shadowsocks will exit . please report to STR , STR , message _ box _ buttons . ok , message _ box _ icon . error ) ; application . exit ( ) ; } } private static void application _ thread _ exception ( object sender , thread _ exception _ event _ args e ) { <%> <+> if ( interlocked . increment ( ref exited ) = = 1 ) { </%>
} private static void system _ events _ power _ mode _ changed ( object sender , power _ mode _ changed _ event _ args e ) { switch ( e . mode ) { case power _ modes . resume : logging . info ( STR ) ; if ( controller ! = null ) { system . timers . timer timer = new system . timers . timer ( NUM * NUM ) ;
} public static bool is _ win _ vista _ or _ higher ( ) { return environment . os _ version . version . major > NUM ; } dll _ import _ kernel _ dll return _ marshal _ as _ unmanaged _ type _ bool private static extern bool set _ process _ working _ set _ size ( int _ ptr process , u _ int _ ptr minimum _ working _ set _ size , u _ int _ ptr maximum _ working _ set _ size ) ; } }
using shadowsocks _ model ; using shadowsocks _ util <%> <+> _ system _ proxy </%> ; namespace shadowsocks _ controller { public static class system _ proxy { <%> <-> dll _ import _ wininet _ dll public static extern bool internet _ set _ option ( int _ ptr h _ internet , int dw _ option , int _ ptr lp _ buffer , int dw _ buffer _ length ) ; public const int internet _ option _ settings _ changed = NUM ; public const int internet _ option _ refresh = NUM ; </%>
namespace shadowsocks _ controller { public static class system _ proxy { <%> <-> dll _ import _ wininet _ dll public static extern bool internet _ set _ option ( int _ ptr h _ internet , int dw _ option , int _ ptr lp _ buffer , int dw _ buffer _ length ) ; public const int internet _ option _ settings _ changed = NUM ; public const int internet _ option _ refresh = NUM ; static bool settings _ return , refresh _ return ; public static void notify _ ie ( ) </%>
private static string get _ timestamp ( date _ time value ) { return value . to _ string ( STR ) ; } public static void update ( configuration config , bool force _ disable ) { bool global = config . global ; bool enabled = config . enabled ; if ( force _ disable ) {
} <%> <*> if ( enabled ) { if ( global ) { registry . set _ value ( STR , 1 ) ; registry . set _ value ( STR , STR + config . local _ port . to _ string ( ) ) ; registry . set _ value ( STR , STR ) ; -> else </%> <%> <-> } else </%> { string pac _ url ; if ( config . use _ online _ pac & & ! config . pac _ url . is _ null _ or _ empty ( ) ) pac _ url = config . pac _ url ;
} } <%> <-> } private static void copy _ proxy _ setting _ from _ lan ( ) { registry _ key registry = null ; try { registry = utils . open _ user _ reg _ key ( STR , true ) ; if ( registry = = null ) { logging . error ( STR ) ; </%>
} } } }
var default _ value = registry . get _ value ( STR ) ; try { var connections = registry . get _ value _ names ( ) ; foreach ( <%> <*> string -> var </%> each in connections ) { if ( ! ( each . equals ( STR ) | | each . equals ( STR ) | | each . equals ( STR ) ) ) {
{ if ( ! ( each . equals ( STR ) | | each . equals ( STR ) | | each . equals ( STR ) ) ) { registry . set _ value ( each , default _ value ) ; } } <%> <-> system _ proxy . notify _ ie ( ) ; } catch ( io _ exception e ) { </%>
logging . log _ useful _ exception ( e ) ; } <%> <-> } private static string get _ timestamp ( date _ time value ) { return value . to _ string ( STR ) ; </%> } private static void ie _ auto _ detect _ proxy ( bool set ) { <%> <-> registry _ key registry = </%>
} private static void ie _ auto _ detect _ proxy ( bool set ) { <%> <*> registry _ key registry = registry . current _ user . open _ sub _ key ( STR , true ) ; byte [ ] def _ connection = ( byte [ ] ) registry . get _ value ( STR ) ; byte [ ] saved _ legacy _ setting = ( byte [ ] ) registry . get _ value ( STR ) ; -> var registry = registry . current _ user </%> <%> <+> . open _ sub _ key ( STR , true ) ; </%>
if ( set ) { def _ connection [ NUM ] = <%> <*> convert . to _ -> ( </%> byte <%> <+> ) </%> ( def _ connection [ NUM ] <%> <*> & -> | </%> NUM ) ; saved _ legacy _ setting [ NUM ] = <%> <*> convert . to _ -> ( </%> byte <%> <+> ) </%> ( saved _ legacy _ setting [ NUM ] <%> <*> & -> | </%> NUM ) ; } else { def _ connection [ NUM ] = <%> <*> convert . to _ -> ( </%> byte <%> <+> ) </%> ( def _ connection [ NUM ] & ~ NUM ) ; saved _ legacy _ setting [ NUM ] = <%> <*> convert . to _ -> ( </%> byte <%> <+> ) </%> ( saved _ legacy _ setting [ NUM ] & ~ NUM ) ; }
} else { def _ connection [ NUM ] = <%> <*> convert . to _ -> ( </%> byte <%> <+> ) </%> ( def _ connection [ NUM ] & ~ NUM ) ; saved _ legacy _ setting [ NUM ] = <%> <*> convert . to _ -> ( </%> byte <%> <+> ) </%> ( saved _ legacy _ setting [ NUM ] & ~ NUM ) ; } <%> <+> bit _ converter . get _ bytes ( unchecked ( bit _ converter . to _ u _ int ( def _ connection , NUM ) + 1 ) ) . copy _ to ( def _ connection , NUM ) ; bit _ converter . get _ bytes ( unchecked ( bit _ converter . to _ u _ int ( saved _ legacy _ setting , NUM ) + 1 ) ) . copy _ to ( saved _ legacy _ setting , NUM ) ; </%> registry . set _ value ( STR , def _ connection ) ; registry . set _ value ( STR , saved _ legacy _ setting ) ;
} <%> <+> bit _ converter . get _ bytes ( unchecked ( bit _ converter . to _ u _ int ( def _ connection , NUM ) + 1 ) ) . copy _ to ( def _ connection , NUM ) ; bit _ converter . get _ bytes ( unchecked ( bit _ converter . to _ u _ int ( saved _ legacy _ setting , NUM ) + 1 ) ) . copy _ to ( saved _ legacy _ setting , NUM ) ; </%> registry . set _ value ( STR , def _ connection ) ; registry . set _ value ( STR , saved _ legacy _ setting ) ; } } }
return true ; } catch ( exception <%> <*> exception -> ex </%> ) { console . write _ line ( STR , <%> <*> exception -> ex </%> . to _ string ( ) ) ; } return false ; } public static void uncompress _ file ( string file _ name , byte [ ] content )
{ console . write _ line ( STR , <%> <*> exception -> ex </%> . to _ string ( ) ) ; } return false ; } public static void uncompress _ file ( string file _ name , byte [ ] content ) { <%> <-> file _ stream destination _ file = file . create ( file _ name ) ; </%> byte [ ] buffer = new byte [ NUM ] ;
} return false ; } public static void uncompress _ file ( string file _ name , byte [ ] content ) { <%> <-> file _ stream destination _ file = file . create ( file _ name ) ; </%> byte [ ] buffer = new byte [ NUM ] ; int n ; <%> <*> using ( g _ zip _ stream input = new g _ zip _ stream ( new memory _ stream ( content ) , -> using ( var fs = file . create ( file _ name ) ) </%>
byte [ ] buffer = new byte [ NUM ] ; int n ; <%> <*> using ( g _ zip _ stream input = new g _ zip _ stream ( new memory _ stream ( content ) , -> using ( var fs = file . create ( file _ name ) ) </%> <%> <+> using ( var input = new g _ zip _ stream ( new memory _ stream ( content ) , </%> compression _ mode . decompress , false ) ) { while ( ( n = input . read ( buffer , 0 , buffer . length ) ) > 0 ) {
compression _ mode . decompress , false ) ) { while ( ( n = input . read ( buffer , 0 , buffer . length ) ) > 0 ) { <%> <*> destination _ file -> fs </%> . write ( buffer , 0 , n ) ; } } <%> <-> destination _ file . close ( ) ; </%> } }
} } <%> <-> destination _ file . close ( ) ; </%> } } }
} } }
this . table _ layout _ panel . suspend _ layout ( ) ; this . panel . suspend _ layout ( ) ; this . <%> <-> table _ layout _ </%> panel . suspend _ layout ( ) ; this . <%> <*> table _ layout -> group </%> _ <%> <*> panel -> box </%> . suspend _ layout ( ) ; this . suspend _ layout ( ) ; <%> <-> this . table _ layout _ panel . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( ( system . windows . forms . anchor _ styles . top | system . windows . forms . anchor _ styles . left ) | system . windows . forms . anchor _ styles . right ) ) ) ; </%> this . table _ layout _ panel . auto _ size = true ; this . table _ layout _ panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . table _ layout _ panel . column _ count = 2 ;
this . suspend _ layout ( ) ; <%> <-> this . table _ layout _ panel . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( ( system . windows . forms . anchor _ styles . top | system . windows . forms . anchor _ styles . left ) | system . windows . forms . anchor _ styles . right ) ) ) ; </%> this . table _ layout _ panel . auto _ size = true ; this . table _ layout _ panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . table _ layout _ panel . column _ count = 2 ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; <%> <-> this . table _ layout _ panel . controls . add ( this . label , 0 , NUM ) ; </%> this . table _ layout _ panel . controls . add ( this . label , 0 , 0 ) ;
this . table _ layout _ panel . auto _ size = true ; this . table _ layout _ panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . table _ layout _ panel . column _ count = 2 ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; <%> <-> this . table _ layout _ panel . controls . add ( this . label , 0 , NUM ) ; </%> this . table _ layout _ panel . controls . add ( this . label , 0 , 0 ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , 1 ) ; <%> <*> this . table _ layout _ panel . controls . add ( this . encryption _ select , 1 , NUM ) ; -> this . table _ layout _ panel . controls . add ( this . proxy _ port _ text _ box , 1 , NUM ) ; </%>
this . table _ layout _ panel . controls . add ( this . label , 0 , 0 ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , 1 ) ; <%> <*> this . table _ layout _ panel . controls . add ( this . encryption _ select , 1 , NUM ) ; -> this . table _ layout _ panel . controls . add ( this . proxy _ port _ text _ box , 1 , NUM ) ; </%> <%> <+> this . table _ layout _ panel . controls . add ( this . label , 0 , NUM ) ; </%> this . table _ layout _ panel . controls . add ( this . label , 0 , 2 ) ; <%> <-> this . table _ layout _ panel . controls . add ( this . label , 0 , NUM ) ; </%> this . table _ layout _ panel . controls . add ( this . ip _ text _ box , 1 , 0 ) ; this . table _ layout _ panel . controls . add ( this . server _ port _ text _ box , 1 , 1 ) ; this . table _ layout _ panel . controls . add ( this . password _ text _ box , 1 , 2 ) ;
this . table _ layout _ panel . controls . add ( this . label , 0 , 2 ) ; <%> <-> this . table _ layout _ panel . controls . add ( this . label , 0 , NUM ) ; </%> this . table _ layout _ panel . controls . add ( this . ip _ text _ box , 1 , 0 ) ; this . table _ layout _ panel . controls . add ( this . server _ port _ text _ box , 1 , 1 ) ; this . table _ layout _ panel . controls . add ( this . password _ text _ box , 1 , 2 ) ; <%> <+> this . table _ layout _ panel . controls . add ( this . label , 0 , NUM ) ; </%> this . table _ layout _ panel . controls . add ( this . <%> <*> proxy _ port _ text -> encryption </%> _ <%> <*> box -> select </%> , 1 , NUM ) ; this . table _ layout _ panel . location = new system . drawing . point ( NUM , NUM ) ; this . table _ layout _ panel . margin = new system . windows . forms . padding ( NUM ) ; this . table _ layout _ panel . name = STR ;
this . table _ layout _ panel . controls . add ( this . ip _ text _ box , 1 , 0 ) ; this . table _ layout _ panel . controls . add ( this . server _ port _ text _ box , 1 , 1 ) ; this . table _ layout _ panel . controls . add ( this . password _ text _ box , 1 , 2 ) ; <%> <+> this . table _ layout _ panel . controls . add ( this . label , 0 , NUM ) ; </%> this . table _ layout _ panel . controls . add ( this . <%> <*> proxy _ port _ text -> encryption </%> _ <%> <*> box -> select </%> , 1 , NUM ) ; this . table _ layout _ panel . location = new system . drawing . point ( NUM , NUM ) ; this . table _ layout _ panel . margin = new system . windows . forms . padding ( NUM ) ; this . table _ layout _ panel . name = STR ; this . table _ layout _ panel . padding = new system . windows . forms . padding ( NUM ) ; this . table _ layout _ panel . row _ count = NUM ;
this . table _ layout _ panel . name = STR ; this . table _ layout _ panel . padding = new system . windows . forms . padding ( NUM ) ; this . table _ layout _ panel . row _ count = NUM ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ; this . table _ layout _ panel . tab _ index = 0 ;
this . panel . auto _ size = true ; this . panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . panel . controls . add ( this . my _ cancel _ button ) ; this . panel . controls . add ( this . ok _ button ) ; this . panel . location = new system . drawing . point ( NUM , NUM ) ; <%> <+> this . panel . margin = new system . windows . forms . padding ( 0 ) ; </%> this . panel . name = STR ; this . panel . size = new system . drawing . size ( NUM , NUM ) ; this . panel . tab _ index = 1 ; this . context _ menu . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] {
this . panel . name = STR ; this . panel . size = new system . drawing . size ( NUM , NUM ) ; this . panel . tab _ index = 1 ; this . context _ menu . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . enable _ item , this . config _ item , this . edit _ pac _ file _ item , this . about _ item , this . menu _ item , this . quit _ item } ) ;
this . suspend _ layout ( ) ; this . statistics _ chart . back _ color = system . drawing . color . transparent ; chart _ area . axis _ x . major _ grid . enabled = false ; chart _ area . axis _ y . major _ grid . enabled = false ; chart _ area . axis . major _ grid . enabled = false ; chart _ area . back _ color = system . drawing . color . transparent ; chart _ area . name = STR ; this . statistics _ chart . chart _ areas . add ( chart _ area ) ; this . statistics _ chart . dock = system . windows . forms . dock _ style . fill ; legend . back _ color = system . drawing . color . transparent ;
this . split _ container . tab _ index = NUM ; <%> <+> this . numeric _ up _ down . location = new system . drawing . point ( NUM , NUM ) ; this . numeric _ up _ down . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . numeric _ up _ down . maximum = new decimal ( new int [ ] { NUM , 0 , 0 , 0 } ) ; this . numeric _ up _ down . name = STR ; this . numeric _ up _ down . size = new system . drawing . size ( NUM , NUM ) ; </%>
this . numeric _ up _ down . maximum = new decimal ( new int [ ] { NUM , 0 , 0 , 0 } ) ; this . numeric _ up _ down . name = STR ; this . numeric _ up _ down . size = new system . drawing . size ( NUM , NUM ) ; this . numeric _ up _ down . tab _ index = NUM ; this . numeric _ up _ down . value = new decimal ( new int [ ] { NUM ,
using system _ collections _ generic ; using system _ diagnostics ; using system _ io ; <%> <*> using system _ i _ compression ; -> using system _ net ; </%> <%> <+> using system _ net _ network _ information ; using system _ runtime _ interop _ services ; </%> using system _ text ; <%> <-> using system _ net _ network _ information ; using system _ net ; </%>
using system _ text ; <%> <*> using system _ net _ network _ information ; using system _ net ; using system _ runtime _ interop _ services ; -> using shadowsocks _ model ; </%> <%> <+> using shadowsocks _ properties ; </%> using shadowsocks _ util ; namespace shadowsocks _ controller { class polipo _ runner
using shadowsocks _ util ; namespace shadowsocks _ controller { class polipo _ runner { private process process ; <%> <-> private static string temppath ; </%> private int running _ port ; static polipo _ runner ( ) {
private int running _ port ; static polipo _ runner ( ) { <%> <-> temppath = utils . get _ temp _ path ( ) ; </%> try { file _ manager . uncompress _ file ( <%> <*> temppath + -> utils . get _ temp _ path ( </%> STR <%> <+> ) </%> , resources . privoxy _ exe ) ; file _ manager . uncompress _ file ( <%> <*> temppath + -> utils . get _ temp _ path ( </%> STR <%> <+> ) </%> , resources . mgwz _ dll ) ; } catch ( io _ exception e )
try { file _ manager . uncompress _ file ( <%> <*> temppath + -> utils . get _ temp _ path ( </%> STR <%> <+> ) </%> , resources . privoxy _ exe ) ; file _ manager . uncompress _ file ( <%> <*> temppath + -> utils . get _ temp _ path ( </%> STR <%> <+> ) </%> , resources . mgwz _ dll ) ; } catch ( io _ exception e ) { logging . log _ useful _ exception ( e ) ; } }
} catch ( io _ exception e ) { logging . log _ useful _ exception ( e ) ; } } public int running _ port { get {
process = new process ( ) ; <%> <*> process . start _ info . file _ name = temppath + STR ; process . start _ info . arguments = STR + temppath + STR ; -> process . start _ info . file _ name = STR ; </%> <%> <+> process . start _ info . arguments = STR ; process . start _ info . working _ directory = utils . get _ temp _ path ( ) ; </%> process . start _ info . window _ style = process _ window _ style . hidden ; process . start _ info . use _ shell _ execute = true ; process . start _ info . create _ no _ window = true ; process . start ( ) ;
process . start _ info . window _ style = process _ window _ style . hidden ; process . start _ info . use _ shell _ execute = true ; process . start _ info . create _ no _ window = true ; process . start ( ) ; } refresh _ tray _ area ( ) ; } public void stop ( ) { if ( process ! = null )
using shadowsocks _ properties ; using shadowsocks _ util ; <%> <-> using system ; using system _ collections _ generic ; using system _ io ; using system _ runtime _ interop _ services ; using system _ text ; </%> namespace shadowsocks _ encryption { public class polar _ ssl
namespace shadowsocks _ encryption { public class polar _ ssl { const string dllname = STR ; public const int aes _ ctx _ size = NUM + NUM * NUM ; public const int aes _ encrypt = 1 ; public const int aes _ decrypt = 0 ; static polar _ ssl ( ) {
using system _ diagnostics ; using system _ io ; using system _ threading ; using system _ windows _ forms ; <%> <+> using shadowsocks _ controller ; using shadowsocks _ util ; using shadowsocks _ view ; </%> namespace shadowsocks { static class program
using ( mutex mutex = new mutex ( false , STR + application . startup _ path . get _ hash _ code ( ) ) ) { application . enable _ visual _ styles ( ) ; application . set _ compatible _ text _ rendering _ default ( false ) ; if ( ! mutex . wait _ one ( 0 , false ) ) { process [ ] old _ processes = process . get _ processes _ by _ name ( STR ) ; if ( old _ processes . length > 0 ) { process old _ process = old _ processes [ 0 ] ;
using shadowsocks _ properties ; using shadowsocks _ util ; <%> <-> using system ; using system _ collections _ generic ; using system _ io ; using system _ runtime _ interop _ services ; using system _ text ; </%> namespace shadowsocks _ encryption { public class sodium
namespace shadowsocks _ encryption { public class sodium { const string dllname = STR ; static sodium ( ) { <%> <*> string temp _ path = utils . get _ temp _ path ( ) ; string dll _ path = temp _ path + STR ; -> string dll _ path = utils . get _ temp _ path ( STR ) ; </%>
try { file _ manager . uncompress _ file ( dll _ path , resources . libsscrypto _ dll ) ; } catch ( io _ exception ) { } catch ( exception e ) { logging . log _ useful _ exception ( e ) ;
using shadowsocks _ properties ; using shadowsocks _ util ; <%> <-> using system ; using system _ collections _ generic ; using system _ io ; using system _ runtime _ interop _ services ; using system _ text ; </%> namespace shadowsocks _ encryption { public class mbed _ tls
namespace shadowsocks _ encryption { public class mbed _ tls { const string dllname = STR ; static mbed _ tls ( ) { <%> <*> string temp _ path = utils . get _ temp _ path ( ) ; string dll _ path = temp _ path + STR ; -> string dll _ path = utils . get _ temp _ path ( STR ) ; </%>
try { file _ manager . uncompress _ file ( dll _ path , resources . libsscrypto _ dll ) ; } catch ( io _ exception ex ) { } catch ( exception e ) { console . write _ line ( e . to _ string ( ) ) ;
using system _ io ; using system _ net _ sockets ; <%> <*> using system _ text ; -> using system _ net ; </%> <%> <+> using shadowsocks _ util ; </%> namespace shadowsocks _ controller { public class logging { public static string log _ file ;
namespace shadowsocks _ controller { public class logging { public static string log _ file ; public static bool open _ log _ file ( ) { try { <%> <-> string temppath = utils . get _ temp _ path ( ) ; </%>
file _ stream fs = new file _ stream ( log _ file , file _ mode . append ) ; stream _ writer _ with _ timestamp sw = new stream _ writer _ with _ timestamp ( fs ) ; sw . auto _ flush = true ; console . set _ out ( sw ) ; console . set _ error ( sw ) ; return true ; } catch ( io _ exception e ) { console . write _ line ( e . to _ string ( ) ) ;
{ update _ pac _ from _ gfw _ list ( ) ; return ; } list < string > lines = gfw _ list _ updater . parse _ result ( file . read _ all _ text ( utils . get _ temp _ path ( <%> <-> ) + </%> STR ) ) <%> <+> ) </%> ; if ( file . exists ( pac _ server . user _ rule _ file ) ) { string local = file . read _ all _ text ( pac _ server . user _ rule _ file , encoding . ut ) ; string [ ] rules = local . split ( new char [ ] { '\r' , '\n' } , string _ split _ options . remove _ empty _ entries ) ; foreach ( string rule in rules )
if ( file . exists ( pac _ server . user _ rule _ file ) ) { string local = file . read _ all _ text ( pac _ server . user _ rule _ file , encoding . ut ) ; string [ ] rules = local . split ( new char [ ] { '\r' , '\n' } , string _ split _ options . remove _ empty _ entries ) ; foreach ( string rule in rules ) { if ( rule . starts _ with ( STR ) | | rule . starts _ with ( STR ) ) continue ; lines . add ( rule ) ; }
using shadowsocks _ properties ; <%> <-> using simple _ json ; </%> using shadowsocks _ util ; <%> <-> using shadowsocks _ model ; </%> namespace shadowsocks _ controller { public class gfw _ list _ updater { private const string gfwlist _ url = STR ; private static string pac _ file = pac _ server . pac _ file ;
using shadowsocks _ util ; <%> <-> using shadowsocks _ model ; </%> namespace shadowsocks _ controller { public class gfw _ list _ updater { private const string gfwlist _ url = STR ; private static string pac _ file = pac _ server . pac _ file ; private static string user _ rule _ file = pac _ server . user _ rule _ file ; private static string user _ abp _ file = pac _ server . user _ abp _ file ;
namespace shadowsocks _ controller { public class gfw _ list _ updater { private const string gfwlist _ url = STR ; private static string pac _ file = pac _ server . pac _ file ; private static string user _ rule _ file = pac _ server . user _ rule _ file ; private static string user _ abp _ file = pac _ server . user _ abp _ file ; public event event _ handler < result _ event _ args > update _ completed ; public event error _ event _ handler error ;
using system _ collections _ generic ; using system _ net ; <%> <-> using system _ reflection ; using system _ text ; </%> using system _ text _ regular _ expressions ; <%> <-> using system _ io ; </%> using simple _ json ; using shadowsocks _ model ; using shadowsocks _ util ; namespace shadowsocks _ controller
using system _ text _ regular _ expressions ; <%> <-> using system _ io ; </%> using simple _ json ; using shadowsocks _ model ; using shadowsocks _ util ; namespace shadowsocks _ controller { public class update _ checker { private const string update _ url = STR ;
using simple _ json ; using shadowsocks _ model ; using shadowsocks _ util ; namespace shadowsocks _ controller { public class update _ checker { private const string update _ url = STR ; private const string user _ agent = STR ; private configuration config ;
{ <%> <+> if ( file . exists ( path . combine ( application . startup _ path , STR ) ) ) </%> try { directory . create _ directory <%> <+> ( path . combine </%> ( application . startup _ path <%> <*> + -> , </%> STR ) <%> <+> ) </%> ; } catch ( exception e ) { <%> <+> temp _ path = path . get _ temp _ path ( ) ; </%> logging . log _ useful _ exception ( e ) ;
} <%> <*> return path . get _ temp _ path ( ) ; -> return temp _ path ; </%> <%> <+> } public static string get _ temp _ path ( string filename ) { return path . combine ( get _ temp _ path ( ) , filename ) ; </%> } public static void release _ memory ( bool remove _ pages ) {
} public static void release _ memory ( bool remove _ pages ) { gc . collect ( gc . max _ generation ) ; gc . wait _ for _ pending _ finalizers ( ) ; if ( remove _ pages ) { set _ process _ working _ set _ size ( process . get _ current _ process ( ) . handle , ( u _ int _ ptr ) 0 xffffffff , ( u _ int _ ptr ) 0 xffffffff ) ; }
traffic . enqueue ( current ) ; if ( traffic . count > queue _ max _ size ) traffic . dequeue ( ) ; <%> <*> if ( traffic _ changed ! = null ) { traffic _ changed ( this , new event _ args ( ) ) ; } -> traffic _ changed ? . invoke ( this , new event _ args ( ) ) ; </%> thread . sleep ( NUM ) ; }
thread . sleep ( NUM ) ; } } } }
var remote = session . remote ; if ( bytes _ read > 0 ) { <%> <-> * only the first packet contains the socks header , it doesn ' t make sense to parse every packets . * also it ' s unnecessary to parse these data if we turn off the verbose _ logging . * / if ( session . state & & config . is _ verbose _ logging ) { int atyp = connetion _ recv _ buffer [ 0 ] ; string dst _ addr ; </%>
} else { remote . shutdown ( socket _ shutdown . send ) ; remote _ shutdown = true ; check _ close ( ) ; } } catch ( exception e ) {
{ i _ strategy strategy = get _ current _ strategy ( ) ; if ( strategy ! = null ) { return strategy . get _ a _ server ( type , local _ ip <%> <+> _ end _ point , dest </%> _ end _ point ) ; } if ( config . index < 0 ) { config . index = 0 ; }
} if ( config . index < 0 ) { config . index = 0 ; } return get _ current _ server ( ) ; } public void save _ servers ( list < server > servers , int local _ port ) { config . configs = servers ;
{ <%> <*> * sometimes process . get _ processes _ by _ name will return some processes that * are already dead , and that will cause exceptions here . * we could simply ignore those exceptions . -> * under portable _ mode , we could identify it by the path of ss _ privoxy . exe . </%> * / <%> <*> string -> var </%> path = process . main _ module . file _ name ; return utils . get _ temp _ path ( STR ) . equals ( path ) ; } <%> <-> catch ( exception ex ) </%>
* / <%> <*> string -> var </%> path = process . main _ module . file _ name ; return utils . get _ temp _ path ( STR ) . equals ( path ) ; } <%> <-> catch ( exception ex ) { logging . log _ useful _ exception ( ex ) ; return false ; } } </%>
return utils . get _ temp _ path ( STR ) . equals ( path ) ; } <%> <-> catch ( exception ex ) { logging . log _ useful _ exception ( ex ) ; return false ; } } </%> else <%> <-> { </%>
{ var cmd = process . get _ command _ line ( ) ; return cmd . contains ( unique _ config _ file ) ; } <%> <-> catch ( win _ exception ex ) { if ( ( uint ) ex . error _ code ! = 0 ) { throw ; } </%>
return false ; } } private int get _ free _ port ( ) { int default _ port = NUM ; try { ip _ global _ properties properties = ip _ global _ properties . get _ ip _ global _ properties ( ) ; ip _ end _ point [ ] tcp _ end _ points = properties . get _ active _ tcp _ listeners ( ) ;
if ( is _ cipher ) { encrypt _ iv _ offset = iv _ offset ; } else { decrypt _ iv _ offset = iv _ offset ; } break ; case cipher _ r :
{ run _ single <%> <+> _ polar _ ssl </%> _ encryption _ thread ( ) ; list < thread > threads = new list < thread > ( ) ; for ( int i = 0 ; i < NUM ; i + + ) { thread t = new thread ( new thread _ start ( run _ single <%> <+> _ polar _ ssl </%> _ encryption _ thread ) ) ; threads . add ( t ) ; t . start ( ) ; } foreach ( thread t in threads )
threads . add ( t ) ; t . start ( ) ; } foreach ( thread t in threads ) { t . join ( ) ; } assert . is _ false ( encryption _ failed ) ; } private static bool encryption _ failed = false ;
{ try { if ( last _ selected _ index = = - 1 | | last _ selected _ index > = modified _ configuration . configs . count ) { return true ; } <%> <-> server server = new server ( ) ; if ( uri . check _ host _ name ( server . server = ip _ text _ box . text . trim ( ) ) = = uri _ host _ name _ type . unknown ) { </%>
configuration . check _ server ( server ) ; <%> <-> configuration . check _ local _ port ( local _ port ) ; </%> modified _ configuration . configs [ last _ selected _ index ] = server ; <%> <-> modified _ configuration . local _ port = local _ port ; modified _ configuration . portable _ mode = portable _ mode _ check _ box . checked ; </%> return true ; } catch ( exception ex ) { message _ box . show ( ex . message ) ;
modified _ configuration . configs [ last _ selected _ index ] = server ; <%> <-> modified _ configuration . local _ port = local _ port ; modified _ configuration . portable _ mode = portable _ mode _ check _ box . checked ; </%> return true ; } catch ( exception ex ) { message _ box . show ( ex . message ) ; } return false ;
return true ; } catch ( exception ex ) { message _ box . show ( ex . message ) ; } return false ; } <%> <*> private void load _ selected _ server ( ) -> private server get _ server _ details _ from _ ui ( ) </%>
{ if ( servers _ list _ box . selected _ index > = 0 & & servers _ list _ box . selected _ index < modified _ configuration . configs . count ) { server server = modified _ configuration . configs [ servers _ list _ box . selected _ index ] ; <%> <+> set _ server _ details _ to _ ui ( server ) ; } } private void set _ server _ details _ to _ ui ( server server ) { </%> ip _ text _ box . text = server . server ;
{ servers _ list _ box . items . clear ( ) ; foreach ( server server in <%> <-> modified _ </%> configuration . configs ) { servers _ list _ box . items . add ( server . friendly _ name ( ) ) ; } } private void load _ current _ configuration ( ) { modified _ configuration = controller . get _ configuration _ copy ( ) ;
{ servers _ list _ box . items . add ( server . friendly _ name ( ) ) ; } } private void load _ current _ configuration ( ) { modified _ configuration = controller . get _ configuration _ copy ( ) ; <%> <*> load -> load _ server _ name _ list _ to </%> _ <%> <*> configuration -> ui </%> ( modified _ configuration ) ; last _ selected _ index = modified _ configuration . index ; if ( last _ selected _ index < 0 | | last _ selected _ index > = servers _ list _ box . items . count )
last _ selected _ index = modified _ configuration . index ; if ( last _ selected _ index < 0 | | last _ selected _ index > = servers _ list _ box . items . count ) { last _ selected _ index = 0 ; } servers _ list _ box . selected _ index = last _ selected _ index ; <%> <*> update _ move _ up _ and _ down _ button ( ) ; load _ selected _ server ( ) ; -> update _ buttons ( ) ; </%> <%> <+> load _ selected _ server _ details ( ) ; </%>
portable _ mode _ check _ box . checked = modified _ configuration . portable _ mode ; <%> <-> } private void config _ form _ load ( object sender , event _ args e ) { </%> } private void config _ form _ key _ down ( object sender , key _ event _ args e ) { if ( e . key _ code = = keys . enter ) { server server = controller . get _ current _ server ( ) ;
} private void config _ form _ key _ down ( object sender , key _ event _ args e ) { if ( e . key _ code = = keys . enter ) { server server = controller . get _ current _ server ( ) ; if ( ! <%> <*> save -> validate _ and </%> _ <%> <*> old -> save </%> _ selected _ server <%> <+> _ details </%> ( ) ) { return ; }
{ return ; } if ( modified _ configuration . configs . count = = 0 ) { message _ box . show ( n . get _ string ( STR ) ) ; return ; } <%> <+> int local _ port = int . parse ( proxy _ port _ text _ box . text ) ; configuration . check _ local _ port ( local _ port ) ; </%>
{ servers _ list _ box . selected _ index = last _ selected _ index ; return ; } if ( last _ selected _ index > = 0 ) { servers _ list _ box . items [ last _ selected _ index ] = modified _ configuration . configs [ last _ selected _ index ] . friendly _ name ( ) ; } <%> <*> update _ move _ up _ and _ down -> update </%> _ <%> <*> button -> buttons </%> ( ) ; load _ selected _ server <%> <+> _ details </%> ( ) ;
last _ selected _ index = servers _ list _ box . selected _ index ; } private void add _ button _ click ( object sender , event _ args e ) { if ( ! <%> <*> save -> validate _ and </%> _ <%> <*> old -> save </%> _ selected _ server <%> <+> _ details </%> ( ) ) { return ; } server server = configuration . get _ default _ server ( ) ; modified _ configuration . configs . add ( server ) ;
{ return ; } server server = configuration . get _ default _ server ( ) ; modified _ configuration . configs . add ( server ) ; <%> <*> load -> load _ server _ name _ list _ to </%> _ <%> <*> configuration -> ui </%> ( modified _ configuration ) ; servers _ list _ box . selected _ index = modified _ configuration . configs . count - 1 ; last _ selected _ index = servers _ list _ box . selected _ index ; } private void duplicate _ button _ click ( object sender , event _ args e )
servers _ list _ box . selected _ index = modified _ configuration . configs . count - 1 ; last _ selected _ index = servers _ list _ box . selected _ index ; } private void duplicate _ button _ click ( object sender , event _ args e ) { if ( ! <%> <*> save -> validate _ and </%> _ <%> <*> old -> save </%> _ selected _ server <%> <+> _ details </%> ( ) ) { return ; } server curr _ server = modified _ configuration . configs [ last _ selected _ index ] ;
{ return ; } server curr _ server = modified _ configuration . configs [ last _ selected _ index ] ; var curr _ index = modified _ configuration . configs . index _ of ( curr _ server ) ; modified _ configuration . configs . insert ( curr _ index + 1 , curr _ server ) ; <%> <*> load -> load _ server _ name _ list _ to </%> _ <%> <*> configuration -> ui </%> ( modified _ configuration ) ; servers _ list _ box . selected _ index = curr _ index + 1 ; last _ selected _ index = servers _ list _ box . selected _ index ; }
servers _ list _ box . selected _ index = curr _ index + 1 ; last _ selected _ index = servers _ list _ box . selected _ index ; } private void delete _ button _ click ( object sender , event _ args e ) { last _ selected _ index = servers _ list _ box . selected _ index ; if ( last _ selected _ index > = 0 & & last _ selected _ index < modified _ configuration . configs . count ) { modified _ configuration . configs . remove _ at ( last _ selected _ index ) ; }
servers _ list _ box . selected _ index = last _ selected _ index ; load _ selected _ server <%> <+> _ details </%> ( ) ; } private void ok _ button _ click ( object sender , event _ args e ) { if ( ! <%> <*> save -> validate _ and </%> _ <%> <*> old -> save </%> _ selected _ server <%> <+> _ details </%> ( ) ) { return ; } if ( modified _ configuration . configs . count = = 0 )
} private void ok _ button _ click ( object sender , event _ args e ) { if ( ! <%> <*> save -> validate _ and </%> _ <%> <*> old -> save </%> _ selected _ server <%> <+> _ details </%> ( ) ) { return ; } if ( modified _ configuration . configs . count = = 0 ) { message _ box . show ( n . get _ string ( STR ) ) ;
{ return ; } if ( modified _ configuration . configs . count = = 0 ) { message _ box . show ( n . get _ string ( STR ) ) ; return ; } <%> <+> int local _ port = int . parse ( proxy _ port _ text _ box . text ) ; configuration . check _ local _ port ( local _ port ) ; </%>
} private void move _ up _ button _ click ( object sender , event _ args e ) { if ( ! <%> <*> save -> validate _ and </%> _ <%> <*> old -> save </%> _ selected _ server <%> <+> _ details </%> ( ) ) { return ; } if ( servers _ list _ box . selected _ index > 0 ) { move _ config _ item ( - 1 ) ;
{ return ; } if ( servers _ list _ box . selected _ index > 0 ) { move _ config _ item ( - 1 ) ; } } private void move _ down _ button _ click ( object sender , event _ args e ) {
{ const int cipher _ aes = 1 ; const int cipher _ r = 2 ; <%> <-> static dictionary < string , int [ ] > ciphers = new dictionary < string , int [ ] > { { STR , new int [ ] { NUM , NUM , cipher _ aes , polar _ ssl . aes _ ctx _ size } } , { STR , new int [ ] { NUM , NUM , cipher _ aes , polar _ ssl . aes _ ctx _ size } } , { STR , new int [ ] { NUM , NUM , cipher _ aes , polar _ ssl . aes _ ctx _ size } } , { STR , new int [ ] { NUM , 0 , cipher _ r , polar _ ssl . ar _ ctx _ size } } , { STR , new int [ ] { NUM , NUM , cipher _ r , polar _ ssl . ar _ ctx _ size } } , } ; </%>
private int _ ptr encrypt _ ctx = int _ ptr . zero ; private int _ ptr decrypt _ ctx = int _ ptr . zero ; <%> <-> private byte [ ] encrypt _ iv ; private byte [ ] decrypt _ iv ; private int encrypt _ iv _ offset = 0 ; private int decrypt _ iv _ offset = 0 ; private string method ; private int key _ len ; private int iv _ len ; </%> public polar _ ssl _ encryptor ( string method , string password )
public polar _ ssl _ encryptor ( string method , string password ) : base ( method , password ) { init _ key ( method , password ) ; } <%> <*> private static void rand _ bytes ( byte -> protected override dictionary < string , int </%> [ ] <%> <*> buf , int length -> > get _ ciphers ( </%> ) { <%> <-> byte [ ] temp = new byte [ length ] ; new random ( ) . next _ bytes ( temp ) ; temp . copy _ to ( buf , 0 ) ; </%>
{ <%> <*> byte [ ] temp = new byte [ length ] ; new random ( ) . next _ bytes ( temp ) ; temp . copy _ to ( buf , 0 ) ; -> return new dictionary < string , int [ ] > { </%> <%> <+> { STR , new int [ ] { NUM , NUM , cipher _ aes , polar _ ssl . aes _ ctx _ size } } , { STR , new int [ ] { NUM , NUM , cipher _ aes , polar _ ssl . aes _ ctx _ size } } , { STR , new int [ ] { NUM , NUM , cipher _ aes , polar _ ssl . aes _ ctx _ size } } , { STR , new int [ ] { NUM , 0 , cipher _ r , polar _ ssl . ar _ ctx _ size } } , { STR , new int [ ] { NUM , NUM , cipher _ r , polar _ ssl . ar _ ctx _ size } } , </%>
} <%> <*> private -> protected override </%> void <%> <*> bytes _ to -> init </%> _ <%> <*> key -> cipher </%> ( byte [ ] <%> <*> password -> iv </%> , <%> <*> byte [ ] key -> bool is _ cipher </%> ) { <%> <*> byte [ ] result = new byte [ password -> base </%> . <%> <*> length + NUM ] ; -> init _ cipher ( iv , is _ cipher ) ; </%> int <%> <*> i = 0 -> _ ptr ctx </%> ; <%> <*> byte -> ctx = marshal . alloc _ h _ global ( cipher _ info </%> [ <%> <+> NUM </%> ] <%> <*> md _ sum = null -> ) </%> ; <%> <*> while -> if </%> ( <%> <*> i < key . length -> is _ cipher </%> ) { <%> <-> m md = m . create ( ) ; if ( i = = 0 ) </%>
{ <%> <*> byte [ ] result = new byte [ password -> base </%> . <%> <*> length + NUM ] ; -> init _ cipher ( iv , is _ cipher ) ; </%> int <%> <*> i = 0 -> _ ptr ctx </%> ; <%> <*> byte -> ctx = marshal . alloc _ h _ global ( cipher _ info </%> [ <%> <+> NUM </%> ] <%> <*> md _ sum = null -> ) </%> ; <%> <*> while -> if </%> ( <%> <*> i < key . length -> is _ cipher </%> ) { <%> <-> m md = m . create ( ) ; if ( i = = 0 ) { md _ sum = md . compute _ hash ( password ) ; </%>
{ <%> <-> m md = m . create ( ) ; if ( i = = 0 ) { md _ sum = md . compute _ hash ( password ) ; } else { md _ sum . copy _ to ( result , 0 ) ; password . copy _ to ( result , md _ sum . length ) ; </%>
} else { <%> <*> byte [ ] passbuf = encoding . ut . get _ bytes ( password ) ; key = new byte [ NUM ] ; byte [ ] iv = new byte [ NUM ] ; bytes _ to _ key ( passbuf , key ) ; cached _ keys [ k ] = key ; -> decrypt _ ctx = ctx ; </%> }
} <%> <-> } private void init _ cipher ( ref int _ ptr ctx , byte [ ] iv , bool is _ cipher ) { ctx = marshal . alloc _ h _ global ( cipher _ info [ NUM ] ) ; </%> byte [ ] realkey ; if ( method = = STR ) { byte [ ] temp = new byte [ key _ len + iv _ len ] ; realkey = new byte [ key _ len ] ;
byte [ ] realkey ; if ( method = = STR ) { byte [ ] temp = new byte [ key _ len + iv _ len ] ; realkey = new byte [ key _ len ] ; array . copy ( key , 0 , temp , 0 , key _ len ) ; array . copy ( iv , 0 , temp , key _ len , iv _ len ) ; realkey = m . create ( ) . compute _ hash ( temp ) ; } else
} else if ( cipher = = cipher _ r ) { polar _ ssl . arc _ init ( ctx ) ; polar _ ssl . arc _ setup ( ctx , realkey , key _ len ) ; } } <%> <*> static byte [ ] tempbuf = new byte [ NUM ] ; public override void encrypt ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength ) -> protected override void cipher _ update ( bool is _ cipher , int length , byte [ ] buf , byte [ ] outbuf ) </%>
{ <%> <*> if ( encrypt _ ctx = = int _ ptr . zero ) -> if ( disposed ) </%> { <%> <-> rand _ bytes ( outbuf , iv _ len ) ; init _ cipher ( ref encrypt _ ctx , outbuf , true ) ; outlength = length + iv _ len ; lock ( tempbuf ) { if ( disposed ) </%>
{ <%> <-> rand _ bytes ( outbuf , iv _ len ) ; init _ cipher ( ref encrypt _ ctx , outbuf , true ) ; outlength = length + iv _ len ; lock ( tempbuf ) { if ( disposed ) { </%> throw new object _ disposed _ exception ( this . to _ string ( ) ) ; }
} else { <%> <-> outlength = length ; if ( disposed ) { throw new object _ disposed _ exception ( this . to _ string ( ) ) ; } switch ( cipher ) { </%>
} <%> <*> } public override void decrypt ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength ) { if ( decrypt _ ctx = = int _ ptr . zero ) -> switch ( cipher ) </%> { <%> <-> init _ cipher ( ref decrypt _ ctx , buf , false ) ; outlength = length - iv _ len ; lock ( tempbuf ) </%>
{ <%> <*> init _ cipher ( ref decrypt _ ctx , buf , false ) ; outlength = length - iv _ len ; lock ( tempbuf ) { buffer . block _ copy ( buf , iv _ len , tempbuf , 0 , length - iv _ len ) ; if ( disposed ) -> case cipher _ aes : </%> <%> <+> polar _ ssl . aes _ crypt _ cfb ( encrypt _ ctx , is _ cipher ? polar _ ssl . aes _ encrypt : polar _ ssl . aes _ decrypt , length , ref iv _ offset , iv , buf , outbuf ) ; if ( is _ cipher ) </%>
{ <%> <*> throw new object -> encrypt </%> _ <%> <*> disposed -> iv </%> _ <%> <*> exception ( this . to -> offset = iv </%> _ <%> <*> string ( ) ) -> offset </%> ; } <%> <-> switch ( cipher ) </%> <%> <+> else </%> { <%> <-> case cipher _ aes : polar _ ssl . aes _ crypt _ cfb ( decrypt _ ctx , polar _ ssl . aes _ decrypt , length - iv _ len , ref decrypt _ iv _ offset , decrypt _ iv , tempbuf , outbuf ) ; break ; case cipher _ r : polar _ ssl . arc _ crypt ( decrypt _ ctx , length - iv _ len , tempbuf , outbuf ) ; </%>
} <%> <-> switch ( cipher ) </%> <%> <+> else </%> { <%> <*> case cipher _ aes : polar _ ssl . aes _ crypt _ cfb ( decrypt _ ctx , polar _ ssl . aes _ decrypt , length - iv _ len , ref decrypt _ iv _ offset , decrypt _ iv , tempbuf , outbuf ) ; break ; case cipher _ r : polar _ ssl . arc _ crypt ( decrypt _ ctx , length - iv _ len , tempbuf , outbuf ) ; break ; -> decrypt _ iv _ offset = iv _ offset ; </%>
{ <%> <*> case cipher _ aes : polar _ ssl . aes _ crypt _ cfb ( decrypt _ ctx , polar _ ssl . aes _ decrypt , length - iv _ len , ref decrypt _ iv _ offset , decrypt _ iv , tempbuf , outbuf ) ; break ; case cipher _ r : polar _ ssl . arc _ crypt ( decrypt _ ctx , length - iv _ len , tempbuf , outbuf ) ; break ; -> decrypt _ iv _ offset = iv _ offset ; </%> } <%> <-> } </%>
} <%> <-> } } else { outlength = length ; if ( disposed ) { throw new object _ disposed _ exception ( this . to _ string ( ) ) ; } </%>
} } private bool disposed ; public override void dispose ( ) { dispose ( true ) ; gc . suppress _ finalize ( this ) ; } ~ polar _ ssl _ encryptor ( ) {
file _ manager . uncompress _ file ( dll _ path , resources . polarssl _ dll ) ; <%> <+> } catch ( io _ exception e ) { console . write _ line ( e . to _ string ( ) ) ; } </%> load _ library ( dll _ path ) ; <%> <+> try { </%> file _ stream fs = new file _ stream ( STR , file _ mode . append ) ;
file _ stream fs = new file _ stream ( STR , file _ mode . append ) ; text _ writer tmp = console . out ; stream _ writer sw = new stream _ writer ( fs ) ; sw . auto _ flush = true ; console . set _ out ( sw ) ; console . set _ error ( sw ) ; } catch ( io _ exception e ) { console . write _ line ( e . to _ string ( ) ) ;
{ <%> <*> n = input . read ( buffer , 0 , buffer . length ) ; if ( n = = 0 ) -> return file . read _ all _ text ( pac _ file , encoding . ut ) ; </%> <%> <+> } else { byte [ ] pac _ gz = resources . proxy _ pac _ txt ; byte [ ] buffer = new byte [ NUM * NUM ] ; int n ; </%>
{ <%> <+> n = input . read ( buffer , 0 , buffer . length ) ; if ( n = = 0 ) { </%> throw new io _ exception ( STR ) ; <%> <+> } return system . text . encoding . ut . get _ string ( buffer , 0 , n ) ; </%> } <%> <-> return system . text . encoding . ut . get _ string ( buffer , 0 , n ) ; </%> }
} <%> <-> return system . text . encoding . ut . get _ string ( buffer , 0 , n ) ; </%> } } private void receive _ callback ( i _ async _ result ar ) { socket conn = ( socket ) ar . async _ state ; try { int bytes _ read = conn . end _ receive ( ar ) ;
} } private void receive _ callback ( i _ async _ result ar ) { socket conn = ( socket ) ar . async _ state ; try { int bytes _ read = conn . end _ receive ( ar ) ; string pac = get _ pac _ content ( ) ; string proxy = STR ;
update _ system _ proxy ( ) ; } public void save _ config ( config new _ config ) { config . save ( new _ config ) ; config = new _ config ; local . stop ( ) ; polipo _ runner . stop ( ) ; polipo _ runner . start ( config ) ; local = new local ( config ) ;
this . about _ item . text = STR ; this . about _ item . click + = new system . event _ handler ( this . about _ tool _ strip _ menu _ item _ click ) ; this . menu _ item . index = NUM ; this . menu _ item . text = STR ; this . quit _ item . index = NUM ; this . quit _ item . text = STR ; this . quit _ item . click + = new system . event _ handler ( this . quit _ click ) ; <%> <+> this . edit _ pac _ file _ item . index = 2 ; this . edit _ pac _ file _ item . text = STR ; this . edit _ pac _ file _ item . click + = new system . event _ handler ( this . edit _ pac _ file _ item _ click ) ; </%>
{ STR , new int [ ] { NUM , NUM , cipher _ aes , polar _ ssl . aes _ ctx _ size } } , { STR , new int [ ] { NUM , NUM , cipher _ aes , polar _ ssl . aes _ ctx _ size } } , { STR , new int [ ] { NUM , NUM , cipher _ aes , polar _ ssl . aes _ ctx _ size } } , { STR , new int [ ] { NUM , 0 , cipher _ r , polar _ ssl . ar _ ctx _ size } } , { STR , new int [ ] { NUM , NUM , cipher _ r , polar _ ssl . ar _ ctx _ size } } , } ; <%> <+> public static list < string > supported _ ciphers ( ) { return new list < string > ( ciphers . keys ) ; } </%>
} protected override void init _ cipher ( byte [ ] iv , bool is _ cipher ) { base . init _ cipher ( iv , is _ cipher ) ; int _ ptr ctx ; ctx = marshal . alloc _ h _ global ( cipher _ info [ NUM ] ) ; if ( is _ cipher ) { encrypt _ ctx = ctx ; }
} protected override void cipher _ update ( bool is _ cipher , int length , byte [ ] buf , byte [ ] outbuf ) { int bytes _ remaining ; ulong ic ; byte [ ] sodium _ buf ; byte [ ] iv ; if ( is _ cipher ) { bytes _ remaining = encrypt _ bytes _ remaining ;
{ <%> <-> return new table _ encryptor ( </%> method <%> <*> , password ) -> = STR </%> ; } <%> <*> return new sodium _ encryptor ( method , password ) ; -> method = method . to _ lower _ invariant ( ) ; </%> <%> <+> type t = registered _ encryptors [ method ] ; constructor _ info c = t . get _ constructor ( constructor _ types ) ; i _ encryptor result = ( i _ encryptor ) c . invoke ( new object [ ] { method , password } ) ; return result ; </%> }
} <%> <*> return new sodium _ encryptor ( method , password ) ; -> method = method . to _ lower _ invariant ( ) ; </%> <%> <+> type t = registered _ encryptors [ method ] ; constructor _ info c = t . get _ constructor ( constructor _ types ) ; i _ encryptor result = ( i _ encryptor ) c . invoke ( new object [ ] { method , password } ) ; return result ; </%> } } }
} } }
this . btn _ ok . name = STR ; this . btn _ ok . size = new system . drawing . size ( NUM , NUM ) ; this . btn _ ok . tab _ index = 0 ; this . btn _ ok . text = STR ; this . btn _ ok . use _ visual _ style _ back _ color = true ; this . btn _ ok . click + = new system . event _ handler ( this . ok _ button _ click ) ; this . btn _ cancel . dialog _ result = system . windows . forms . dialog _ result . cancel ; this . btn _ cancel . location = new system . drawing . point ( NUM , NUM ) ; <%> <+> this . btn _ cancel . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; </%> this . btn _ cancel . name = STR ;
this . btn _ cancel . name = STR ; this . btn _ cancel . size = new system . drawing . size ( NUM , NUM ) ; this . btn _ cancel . tab _ index = 1 ; this . btn _ cancel . text = STR ; this . btn _ cancel . use _ visual _ style _ back _ color = true ; this . btn _ cancel . click + = new system . event _ handler ( this . cancel _ button _ click ) ; this . btn _ register _ all . dialog _ result = system . windows . forms . dialog _ result . cancel ; this . btn _ register _ all . location = new system . drawing . point ( NUM , NUM ) ; <%> <+> this . btn _ register _ all . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; </%> this . btn _ register _ all . name = STR ;
this . btn _ register _ all . name = STR ; this . btn _ register _ all . size = new system . drawing . size ( NUM , NUM ) ; this . btn _ register _ all . tab _ index = 2 ; this . btn _ register _ all . text = STR ; this . btn _ register _ all . use _ visual _ style _ back _ color = true ; this . btn _ register _ all . click + = new system . event _ handler ( this . register _ all _ button _ click ) ; this . table _ layout _ panel . column _ count = 2 ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . controls . add ( this . reg _ hotkeys _ at _ startup _ label , 0 , NUM ) ;
using system _ drawing ; <%> <-> using system _ linq ; </%> using system _ text ; using system _ windows _ forms ; <%> <-> using shadowsocks _ controller ; using shadowsocks _ model ; using shadowsocks _ properties ; </%> using static shadowsocks . controller . hotkey _ reg ; namespace shadowsocks _ view {
using system _ text ; using system _ windows _ forms ; <%> <-> using shadowsocks _ controller ; using shadowsocks _ model ; using shadowsocks _ properties ; </%> using static shadowsocks . controller . hotkey _ reg ; namespace shadowsocks _ view { public partial class hotkey _ settings _ form : form {
using static shadowsocks . controller . hotkey _ reg ; namespace shadowsocks _ view { public partial class hotkey _ settings _ form : form { private readonly shadowsocks _ controller controller ; private hotkey _ config modified _ hotkey _ config ; public hotkey _ settings _ form ( shadowsocks _ controller controller ) { initialize _ component ( ) ;
using system _ globalization ; using system _ io ; <%> <+> using shadowsocks _ properties ; using shadowsocks _ util ; using system _ windows _ forms ; using microsoft _ visual _ basic _ file _ io ; </%> namespace shadowsocks _ controller { <%> <-> using shadowsocks _ properties ; </%> public static class n
public static class n { private static dictionary < string , string > strings = new dictionary < string , string > ( ) ; private static void init ( string res <%> <+> , string locale </%> ) { using ( <%> <*> var sr -> text _ field _ parser csv _ parser </%> = <%> <+> new text _ field _ parser ( </%> new string _ reader ( res ) ) <%> <+> ) </%> { <%> <*> foreach ( var line in sr . non _ white _ space _ lines ( ) ) -> csv _ parser . set _ delimiters ( STR ) ; </%> <%> <+> string [ ] locale _ names = csv _ parser . read _ fields ( ) ; </%>
{ using ( <%> <*> var sr -> text _ field _ parser csv _ parser </%> = <%> <+> new text _ field _ parser ( </%> new string _ reader ( res ) ) <%> <+> ) </%> { <%> <*> foreach ( var line in sr . non _ white _ space _ lines ( ) ) -> csv _ parser . set _ delimiters ( STR ) ; </%> <%> <+> string [ ] locale _ names = csv _ parser . read _ fields ( ) ; int en _ index = 0 ; int target _ index = 0 ; for ( int i = 1 ; i < locale _ names . length ; i + + ) </%> {
{ <%> <*> foreach ( var line in sr . non _ white _ space _ lines ( ) ) -> csv _ parser . set _ delimiters ( STR ) ; </%> <%> <+> string [ ] locale _ names = csv _ parser . read _ fields ( ) ; int en _ index = 0 ; int target _ index = 0 ; for ( int i = 1 ; i < locale _ names . length ; i + + ) </%> { <%> <-> if ( line [ 0 ] = = '#' ) continue ; </%>
{ <%> <*> if ( line [ 0 ] = = '#' ) continue ; var pos = line . index _ of ( '=' ) ; if ( pos < 1 ) continue ; strings [ line . substring ( 0 , pos ) ] = line . substring ( pos + 1 ) ; -> if ( locale _ names [ i ] = = STR ) </%> <%> <+> { } </%>
} } } static n ( ) { <%> <-> string name = culture _ info . current _ culture . english _ name ; if ( name . starts _ with ( STR , string _ comparison . ordinal _ ignore _ case ) ) { init ( name . contains ( STR ) ? resources . zh _ tw </%>
} public static string get _ string ( string key , params object [ ] args ) { return string . format ( strings . try _ get _ value ( key , out var value ) ? value : key , args ) ; } <%> <+> public static void translate _ form ( form c ) { c . text = get _ string ( c . text ) ; foreach ( var item in view _ utils . get _ child _ controls < control > ( c ) ) { </%>
namespace shadowsocks _ view { public partial class config _ form : form { private shadowsocks _ controller controller ; private configuration modified _ configuration ; private int last _ selected _ index = - 1 ; private bool is _ change = false ; public config _ form ( shadowsocks _ controller controller ) {
tool _ tip . set _ tool _ tip ( portable _ mode _ check _ box , n . get _ string ( STR ) ) ; <%> <-> remarks _ label . text = n . get _ string ( STR ) ; timeout _ label . text = n . get _ string ( STR ) ; server _ group _ box . text = n . get _ string ( STR ) ; ok _ button . text = n . get _ string ( STR ) ; my _ cancel _ button . text = n . get _ string ( STR ) ; apply _ button . text = n . get _ string ( STR ) ; move _ up _ button . text = n . get _ string ( STR ) ; move _ down _ button . text = n . get _ string ( STR ) ; text = n . get _ string ( STR ) ; </%>
} private void setup _ value _ changed _ listeners ( ) { ip _ text _ box . text _ changed + = config _ value _ changed ; proxy _ port _ text _ box . text _ changed + = config _ value _ changed ; password _ text _ box . text _ changed + = config _ value _ changed ; encryption _ select . selected _ index _ changed + = config _ value _ changed ; plugin _ text _ box . text _ changed + = config _ value _ changed ; plugin _ arguments _ text _ box . text _ changed + = config _ value _ changed ; plugin _ options _ text _ box . text _ changed + = config _ value _ changed ;
using shadowsocks _ view ; namespace shadowsocks _ controller _ hotkeys { public class hotkey _ callbacks { <%> <-> public static hotkey _ callbacks instance { get ; private set ; } </%> public static void init _ instance ( shadowsocks _ controller controller ) { if ( instance ! = null ) {
public static void init _ instance ( shadowsocks _ controller controller ) { if ( instance ! = null ) { return ; } instance = new hotkey _ callbacks ( controller ) ; } <%> <+> public static delegate get _ callback ( string methodname ) { </%>
using shadowsocks _ model ; <%> <+> using timer = system . threading . timer ; </%> namespace shadowsocks _ controller _ strategy { <%> <+> using data _ unit = key _ value _ pair < string , string > ; using data _ list = list < key _ value _ pair < string , string > > ; </%> class statistics _ strategy : i _ strategy { private readonly shadowsocks _ controller controller ; private server current _ server ;
public statistics _ strategy ( shadowsocks _ controller controller ) { controller = controller ; var servers = controller . get _ current _ configuration ( ) . configs ; var random _ index = new random ( ) . next ( ) % servers . count ( ) ; current _ server = servers [ random _ index ] ; timer = new timer ( reload _ statistics _ and _ choose _ a _ server ) ; } private void reload _ statistics _ and _ choose _ a _ server ( object obj ) {
private void load _ statistics ( ) { try { var path = availability _ statistics . availability _ statistics _ file ; logging . debug ( $ STR ) ; if ( ! file . exists ( path ) ) { log _ when _ enabled ( $ STR ) ; timer . change ( retry _ interval , <%> <*> cached -> choice _ kept </%> _ <%> <*> interval -> milliseconds </%> ) ;
return ; } <%> <+> raw _ </%> statistics = ( from l in file . read _ all _ lines ( path ) . skip ( 1 ) let strings = l . split ( new [ ] { STR } , string _ split _ options . remove _ empty _ entries ) let raw _ data = new <%> <+> statistics _ raw _ data </%> { <%> <+> timestamp = strings [ 0 ] , </%> server _ name = strings [ 1 ] , <%> <+> icmp _ status = strings [ 2 ] , </%>
} catch ( exception e ) { logging . log _ useful _ exception ( e ) ; } } private <%> <*> static double -> float </%> get _ score ( <%> <+> i _ enumerable < </%> statistics <%> <+> _ raw </%> _ data <%> <+> > raw _ </%> data <%> <+> _ list </%> ) { <%> <*> return ( double ) data . success _ times / ( data . success _ times + data -> var config = controller </%> . <%> <*> timed -> statistics </%> _ <%> <*> out _ times ) -> configuration </%> ; <%> <+> if ( config . by _ isp ) </%>
} public class statistics _ data { <%> <*> public int success _ times ; public int timed _ out _ times ; -> public float package _ loss ; </%> public int average _ response ; public int min _ response ; public int max _ response ; }
public int average _ response ; public int min _ response ; public int max _ response ; } private void choose _ new _ server ( list < server > servers ) { if ( <%> <+> raw _ </%> statistics = = null | | servers . count = = 0 ) { return ; }
{ return ; } try { var best _ result = ( from server in servers let name = server . friendly _ name ( ) where <%> <+> raw _ </%> statistics . contains _ key ( name ) select new {
select new { server , score = get _ score ( <%> <+> raw _ </%> statistics [ name ] ) } ) . aggregate ( ( result , result ) = > result . score > result . score ? result : result ) ; if ( ! current _ server . equals ( best _ result . server ) ) { log _ when _ enabled ( $ STR ) ; }
} ) . aggregate ( ( result , result ) = > result . score > result . score ? result : result ) ; if ( ! current _ server . equals ( best _ result . server ) ) { log _ when _ enabled ( $ STR ) ; } current _ server = best _ result . server ; } catch ( exception e ) {
{ initialize _ component ( ) ; <%> <*> value _ label . text = value ; -> value _ label . text = text ; </%> <%> <+> factor _ num . value = ( decimal ) value ; </%> } public string value = > value _ label . text ; public float factor = > <%> <+> ( </%> float <%> <*> . parse ( -> ) </%> factor _ num . <%> <*> text ) -> value </%> ; } }
} public string value = > value _ label . text ; public float factor = > <%> <+> ( </%> float <%> <*> . parse ( -> ) </%> factor _ num . <%> <*> text ) -> value </%> ; } }
} }
this . statistics _ chart = new system . windows . forms . data _ visualization . charting . chart ( ) ; this . by _ isp _ check _ box = new system . windows . forms . check _ box ( ) ; <%> <+> this . binding _ configuration = new system . windows . forms . binding _ source ( this . components ) ; </%> this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ; this . group _ box = new system . windows . forms . group _ box ( ) ; this . radio _ button = new system . windows . forms . radio _ button ( ) ; this . radio _ button = new system . windows . forms . radio _ button ( ) ; this . split _ container = new system . windows . forms . split _ container ( ) ;
( ( system . component _ model . i _ support _ initialize ) ( this . statistics _ chart ) ) . begin _ init ( ) ; <%> <+> ( ( system . component _ model . i _ support _ initialize ) ( this . binding _ configuration ) ) . begin _ init ( ) ; </%> this . group _ box . suspend _ layout ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . begin _ init ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . suspend _ layout ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . begin _ init ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . panel . suspend _ layout ( ) ;
series . legend = STR ; series . name = STR ; <%> <+> series . y _ values _ per _ point = NUM ; series . border _ width = NUM ; </%> series . chart _ area = STR ; series . chart _ type = system . windows . forms . data _ visualization . charting . series _ chart _ type . <%> <*> bubble -> line </%> ; series . color = system . drawing . color . from _ argb ( ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) , ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) , ( ( int ) ( ( ( byte ) ( <%> <*> 0 -> NUM </%> ) ) ) ) ) ; series . legend = STR ; <%> <-> series . name = STR ; series . y _ values _ per _ point = NUM ; </%>
series . chart _ area = STR ; series . chart _ type = system . windows . forms . data _ visualization . charting . series _ chart _ type . <%> <*> bubble -> line </%> ; series . color = system . drawing . color . from _ argb ( ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) , ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) , ( ( int ) ( ( ( byte ) ( <%> <*> 0 -> NUM </%> ) ) ) ) ) ; series . legend = STR ; <%> <-> series . name = STR ; series . y _ values _ per _ point = NUM ; series . border _ width = NUM ; series . chart _ area = STR ; series . chart _ type = system . windows . forms . data _ visualization . charting . series _ chart _ type . line ; series . color = system . drawing . color . from _ argb ( ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) , ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) , ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) ) ; </%>
series . legend = STR ; <%> <-> series . name = STR ; series . y _ values _ per _ point = NUM ; series . border _ width = NUM ; series . chart _ area = STR ; series . chart _ type = system . windows . forms . data _ visualization . charting . series _ chart _ type . line ; series . color = system . drawing . color . from _ argb ( ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) , ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) , ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) ) ; series . legend = STR ; </%> series . name = STR ; this . statistics _ chart . series . add ( series ) ;
this . statistics _ chart . series . add ( series ) ; this . statistics _ chart . series . add ( series ) ; <%> <-> this . statistics _ chart . series . add ( series ) ; </%> this . statistics _ chart . size = new system . drawing . size ( NUM , NUM ) ; this . statistics _ chart . tab _ index = 2 ; this . by _ isp _ check _ box . auto _ size = true ; this . by _ isp _ check _ box . data _ bindings . add ( new system . windows . forms . binding ( STR , this . binding _ configuration , STR , true ) ) ; this . by _ isp _ check _ box . location = new system . drawing . point ( NUM , NUM ) ; this . by _ isp _ check _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . by _ isp _ check _ box . name = STR ;
this . statistics _ chart . tab _ index = 2 ; this . by _ isp _ check _ box . auto _ size = true ; this . by _ isp _ check _ box . data _ bindings . add ( new system . windows . forms . binding ( STR , this . binding _ configuration , STR , true ) ) ; this . by _ isp _ check _ box . location = new system . drawing . point ( NUM , NUM ) ; this . by _ isp _ check _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . by _ isp _ check _ box . name = STR ; this . by _ isp _ check _ box . size = new system . drawing . size ( NUM , NUM ) ; this . by _ isp _ check _ box . tab _ index = NUM ; this . by _ isp _ check _ box . text = STR ; this . by _ isp _ check _ box . use _ visual _ style _ back _ color = true ;
using shadowsocks _ util ; using timer = system . threading . timer ; namespace shadowsocks _ controller { using data _ unit = key _ value _ pair < string , string > ; using data _ list = list < key _ value _ pair < string , string > > ; internal class availability _ statistics { <%> <+> public static readonly string date _ time _ pattern = STR ; </%> private const string statistics _ files _ name = STR ;
private timer timer ; private state state ; private list < server > servers ; <%> <+> private statistics _ strategy _ configuration config ; </%> public static string availability _ statistics _ file ; static availability _ statistics ( ) { <%> <*> string -> var </%> temppath = utils . get _ temp _ path ( ) ; availability _ statistics _ file = path . combine ( temppath , statistics _ files _ name ) ; }
availability _ statistics _ file = path . combine ( temppath , statistics _ files _ name ) ; } public <%> <*> bool set -> availability _ statistics </%> ( <%> <*> bool enabled ) -> configuration config , statistics _ strategy _ configuration statistics _ config ) </%> { <%> <+> update _ configuration ( config , statistics _ config ) ; } public bool set ( statistics _ strategy _ configuration config ) { config = config ; </%> try
{ <%> <+> update _ configuration ( config , statistics _ config ) ; } public bool set ( statistics _ strategy _ configuration config ) { config = config ; </%> try { if ( <%> <+> config . statistics _ </%> enabled ) {
{ if ( timer ? . change ( <%> <*> 0 -> delay _ before _ start </%> , interval ) = = null ) { state = new state ( ) ; timer = new timer ( evaluate , state , <%> <*> 0 -> delay _ before _ start </%> , interval ) ; } } else { timer ? . dispose ( ) ;
{ state = new state ( ) ; timer = new timer ( evaluate , state , <%> <*> 0 -> delay _ before _ start </%> , interval ) ; } } else { timer ? . dispose ( ) ; } return true ;
} } else { timer ? . dispose ( ) ; } return true ; } catch ( exception e ) {
{ logging . debug ( STR + server . friendly _ name ( ) ) ; if ( server . server = = STR ) return null ; <%> <+> var ip = dns . get _ host _ addresses ( server . server ) . first ( ip = > ip . address _ family = = address _ family . inter _ network ) ; </%> var ping = new ping ( ) ; var ret = new list < data _ list > ( ) ; foreach ( var timestamp in enumerable . range ( 0 , repeat ) . select ( = > date _ time . now . to _ string ( <%> <*> STR -> date _ time _ pattern </%> ) ) ) { try
{ try { var reply = <%> <-> await </%> ping . send <%> <-> _ task _ async </%> ( <%> <*> server . server -> ip </%> , timeout ) ; ret . add ( new list < key _ value _ pair < string , string > > { new key _ value _ pair < string , string > ( STR , timestamp ) , new key _ value _ pair < string , string > ( STR , server . friendly _ name ( ) ) , new key _ value _ pair < string , string > ( STR , reply ? . status . to _ string ( ) ) , new key _ value _ pair < string , string > ( STR , reply ? . roundtrip _ time . to _ string ( ) )
ret . add ( new list < key _ value _ pair < string , string > > { new key _ value _ pair < string , string > ( STR , timestamp ) , new key _ value _ pair < string , string > ( STR , server . friendly _ name ( ) ) , new key _ value _ pair < string , string > ( STR , reply ? . status . to _ string ( ) ) , new key _ value _ pair < string , string > ( STR , reply ? . roundtrip _ time . to _ string ( ) ) } ) ; <%> <+> thread . sleep ( new random ( ) . next ( ) % timeout ) ; </%> } catch ( exception e )
} internal void update _ configuration ( configuration config <%> <*> ) -> , statistics _ strategy _ configuration statistics _ config ) </%> { set ( <%> <*> config . availability -> statistics </%> _ <%> <*> statistics -> config </%> ) ; servers = config . configs ; } <%> <*> private -> public </%> class state { public data _ list data _ list = new data _ list ( ) ; public const string geolocation = STR ;
{ set ( <%> <*> config . availability -> statistics </%> _ <%> <*> statistics -> config </%> ) ; servers = config . configs ; } <%> <*> private -> public </%> class state { public data _ list data _ list = new data _ list ( ) ; public const string geolocation = STR ; public const string isp = STR ; public const string unknown = STR ;
servers = config . configs ; } <%> <*> private -> public </%> class state { public data _ list data _ list = new data _ list ( ) ; public const string geolocation = STR ; public const string isp = STR ; public const string unknown = STR ; } }
{ public data _ list data _ list = new data _ list ( ) ; public const string geolocation = STR ; public const string isp = STR ; public const string unknown = STR ; } } }
try { <%> <*> registry _ key hkcr = registry _ key . open _ base _ key ( registry _ hive . classes _ root , environment . is _ bit _ operating _ system ? registry _ view . registry : registry _ view . registry ) ; run _ key = hkcr . create _ sub _ key ( STR , registry _ key _ permission _ check . read _ write _ sub _ tree ) ; if ( run _ key = = null ) -> ss _ url _ association = registry . current _ user . create _ sub _ key ( STR , registry _ key _ permission _ check . read _ write _ sub _ tree ) ; </%> <%> <+> if ( ss _ url _ association = = null ) </%> { logger . error ( STR ) ;
{ logger . error ( STR ) ; return false ; } if ( enabled ) { <%> <*> run -> ss _ url </%> _ <%> <*> key -> association </%> . set _ value ( STR , STR ) ; <%> <*> run -> ss _ url </%> _ <%> <*> key -> association </%> . set _ value ( STR , STR ) ; var shell _ open = <%> <*> run -> ss _ url </%> _ <%> <*> key -> association </%> . create _ sub _ key ( STR ) . create _ sub _ key ( STR ) . create _ sub _ key ( STR ) ; shell _ open . set _ value ( STR , $ STR ) ;
shell _ open . set _ value ( STR , $ STR ) ; <%> <+> logger . info ( STR ) ; </%> } else { <%> <*> hkcr . delete _ sub _ key _ tree ( STR ) ; -> registry . current _ user . delete _ sub _ key _ tree ( STR ) ; </%> <%> <+> logger . info ( STR ) ; </%> } return true ;
} return true ; } catch ( exception e ) { logger . log _ useful _ exception ( e ) ; return false ; } finally {
} catch ( exception e ) { logger . log _ useful _ exception ( e ) ; } } } } public static bool check ( ) { registry _ key <%> <*> run -> ss _ url </%> _ <%> <*> key -> association </%> = null ; try
try { <%> <*> run -> ss _ url </%> _ <%> <*> key -> association </%> = <%> <*> utils -> registry . current _ user </%> . open _ <%> <*> reg -> sub </%> _ key ( STR , true <%> <-> , registry _ hive . classes _ root </%> ) ; if ( <%> <*> run -> ss _ url </%> _ <%> <*> key -> association </%> = = null ) { <%> <-> logger . error ( STR ) ; </%> return false ; } var shell _ open = <%> <*> run -> ss _ url </%> _ <%> <*> key -> association </%> . open _ sub _ key ( STR ) . open _ sub _ key ( STR ) . open _ sub _ key ( STR ) ; return ( string ) shell _ open . get _ value ( STR ) = = $ STR ;
{ <%> <-> logger . error ( STR ) ; </%> return false ; } var shell _ open = <%> <*> run -> ss _ url </%> _ <%> <*> key -> association </%> . open _ sub _ key ( STR ) . open _ sub _ key ( STR ) . open _ sub _ key ( STR ) ; return ( string ) shell _ open . get _ value ( STR ) = = $ STR ; } catch ( exception e ) { logger . log _ useful _ exception ( e ) ;
return false ; } var shell _ open = <%> <*> run -> ss _ url </%> _ <%> <*> key -> association </%> . open _ sub _ key ( STR ) . open _ sub _ key ( STR ) . open _ sub _ key ( STR ) ; return ( string ) shell _ open . get _ value ( STR ) = = $ STR ; } catch ( exception e ) { logger . log _ useful _ exception ( e ) ; return false ; }
return ( string ) shell _ open . get _ value ( STR ) = = $ STR ; } catch ( exception e ) { logger . log _ useful _ exception ( e ) ; return false ; } finally { if ( <%> <*> run -> ss _ url </%> _ <%> <*> key -> association </%> ! = null )
} catch ( exception e ) { logger . log _ useful _ exception ( e ) ; } } } } } }
assembly _ assembly _ product _ shadowsocks _ csharp assembly _ assembly _ copyright _ copyright <%> <+> _ clowwindy </%> assembly _ assembly _ trademark assembly _ assembly _ culture assembly _ com _ visible _ false assembly _ guid _ bbd _ dcf assembly _ assembly _ version assembly _ assembly _ file _ version
assembly _ assembly _ trademark assembly _ assembly _ culture assembly _ com _ visible _ false assembly _ guid _ bbd _ dcf assembly _ assembly _ version assembly _ assembly _ file _ version
{ gc . collect ( gc . max _ generation ) ; gc . wait _ for _ pending _ finalizers ( ) ; <%> <+> if ( remove _ pages ) { </%> set _ process _ working _ set _ size ( process . get _ current _ process ( ) . handle , ( u _ int _ ptr ) 0 xffffffff , ( u _ int _ ptr ) 0 xffffffff ) ; <%> <+> } </%> } public static string un _ gzip ( byte [ ] buf )
} public static string un _ gzip ( byte [ ] buf ) { byte [ ] buffer = new byte [ NUM ] ; int n ; using ( memory _ stream sb = new memory _ stream ( ) ) { using ( g _ zip _ stream input = new g _ zip _ stream ( new memory _ stream ( buf ) , compression _ mode . decompress , false ) ) {
} private void connect _ callback ( i _ async _ result ar ) { <%> <+> if ( closed ) { return ; } </%> try { remote . end _ connect ( ar ) ;
connection . begin _ send ( remote _ send _ buffer , 0 , bytes _ to _ send , 0 , new async _ callback ( pipe _ connection _ send _ callback ) , null ) ; } else { connection . shutdown ( socket _ shutdown . send ) ; connection _ shutdown = true ; check _ close ( ) ; } } catch ( exception e )
remote . begin _ send ( connetion _ send _ buffer , 0 , bytes _ to _ send , 0 , new async _ callback ( pipe _ remote _ send _ callback ) , null ) ; } else { remote . shutdown ( socket _ shutdown . send ) ; remote _ shutdown = true ; check _ close ( ) ; } } catch ( exception e )
} } private string get _ pac _ content ( ) { if ( file . exists ( pac _ file ) ) { return file . read _ all _ text ( pac _ file , encoding . ut ) ; } else {
{ <%> <+> application . set _ unhandled _ exception _ mode ( unhandled _ exception _ mode . catch _ exception ) ; application . thread _ exception + = application _ thread _ exception ; </%> app _ domain . current _ domain . unhandled _ exception + = current _ domain _ unhandled _ exception ; application . application _ exit + = application _ application _ exit ; system _ events . power _ mode _ changed + = system _ events _ power _ mode _ changed ; application . enable _ visual _ styles ( ) ; application . set _ compatible _ text _ rendering _ default ( false ) ; application . application _ exit + = ( sender , args ) = > hot _ keys . destroy ( ) ; if ( ! mutex . wait _ one ( 0 , false ) )
STR , message _ box _ buttons . ok , message _ box _ icon . error ) ; application . exit ( ) ; } <%> <+> } private static void application _ thread _ exception ( object sender , thread _ exception _ event _ args e ) { string error _ msg = $ STR ; logging . error ( error _ msg ) ; message _ box . show ( $ STR unexpected error , shadowsocks will exit . please report to STR , </%>
} connection . begin _ send ( response , 0 , response . length , socket _ flags . none , handshake _ send _ callback , null ) ; } else close ( ) ; } catch ( exception e ) { <%> <*> logging -> logger </%> . log _ useful _ exception ( e ) ;
close ( ) ; } } private void handshake _ send _ callback ( i _ async _ result ar ) { if ( closed ) return ; try { connection . end _ send ( ar ) ; connection . begin _ receive ( connetion _ recv _ buffer , 0 , NUM + addr _ atyp _ len + 1 , socket _ flags . none ,
close ( ) ; break ; } } else { <%> <*> logging -> logger </%> . debug ( STR ) ; close ( ) ; }
close ( ) ; } } private void response _ callback ( i _ async _ result ar ) { try { connection . end _ send ( ar ) ; read _ address ( start _ connect ) ; }
} dest _ end _ point = socket _ util . get _ end _ point ( dst _ addr , dst _ port ) ; on _ success . invoke ( ) ; } else { <%> <*> logging -> logger </%> . debug ( STR ) ; close ( ) ; } }
close ( ) ; } } catch ( exception e ) { <%> <*> logging -> logger </%> . log _ useful _ exception ( e ) ; close ( ) ; } } private void handle _ udp _ associate ( )
close ( ) ; } } private void handle _ udp _ associate ( ) { ip _ end _ point end _ point = ( ip _ end _ point ) connection . local _ end _ point ; byte [ ] address = end _ point . address . get _ address _ bytes ( ) ; int port = end _ point . port ; byte [ ] response = new byte [ NUM + address . length + addr _ port _ len ] ; response [ 0 ] = NUM ;
send _ to _ server ( first _ packet _ length , session ) ; } catch ( exception e ) { <%> <*> logging -> logger </%> . log _ useful _ exception ( e ) ; close ( ) ; } } private void pipe _ remote _ receive _ callback ( i _ async _ result ar ) {
close ( ) ; } } private void pipe _ remote _ receive _ callback ( i _ async _ result ar ) { if ( closed ) return ; try { var session = ( async _ session ) ar . async _ state ; int bytes _ read = session . remote . end _ receive ( ar ) ;
close ( ) ; return ; } } if ( bytes _ to _ send = = 0 ) { <%> <*> logging -> logger </%> . debug ( STR ) ; session . remote . begin _ receive ( remote _ recv _ buffer , 0 , recv _ size , socket _ flags . none , pipe _ remote _ receive _ callback , session ) ; return ;
$ STR ) ; } } catch ( exception ex ) { <%> <*> logging -> logger </%> . error ( STR + ex . message ) ; throw ; } return plugin . local _ end _ point ; }
throw ; } return plugin . local _ end _ point ; } public void save _ servers ( list < server > servers , int local _ port , bool portable _ mode ) { config . configs = servers ; config . local _ port = local _ port ; config . portable _ mode = portable _ mode ; configuration . save ( config ) ;
} } private void save ( ) { <%> <*> logging -> logger </%> . debug ( $ STR ) ; if ( raw _ statistics . count = = 0 ) { return ; } try
if ( raw _ statistics . count = = 0 ) { return ; } try { string content ; content = json _ convert . serialize _ object ( raw _ statistics , formatting . indented ) ; content = json _ convert . serialize _ object ( raw _ statistics , formatting . none ) ; file . write _ all _ text ( availability _ statistics _ file , content ) ;
} } private void load _ raw _ statistics ( ) { try { var path = availability _ statistics _ file ; <%> <*> logging -> logger </%> . debug ( $ STR ) ; if ( ! file . exists ( path ) ) {
if ( ! file . exists ( path ) ) { using ( file . create ( path ) ) { } } var content = file . read _ all _ text ( path ) ; raw _ statistics = json _ convert . deserialize _ object < statistics > ( content ) ? ? raw _ statistics ; } catch ( exception e )
fire _ completed ( e , userstate ) ; } } private void ping _ ping _ completed ( object sender , ping _ completed _ event _ args e ) { try { if ( e . reply . status = = ip _ status . success ) { <%> <*> logging -> logger </%> . debug ( $ STR ) ;
fire _ completed ( ex , e . user _ state ) ; } } private void test _ next ( object userstate ) { if ( repeat > 0 ) { int delay = timeout _ milliseconds + new random ( ) . next ( ) % timeout _ milliseconds ; new task ( ( ) = > icmp _ test ( delay , userstate ) ) . start ( ) ; }
} public static void rand _ bytes ( byte [ ] buf , int length ) { rng . get _ bytes ( buf , length ) ; } public abstract void cipher _ encrypt ( byte [ ] plaintext , uint plen , byte [ ] ciphertext , ref uint clen ) ; public abstract void cipher _ decrypt ( byte [ ] ciphertext , uint clen , byte [ ] plaintext , ref uint plen ) ; public override void encrypt ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength ) { debug . assert ( enc _ circular _ buffer ! = null , STR ) ; enc _ circular _ buffer . put ( buf , 0 , length ) ; outlength = 0 ; <%> <*> logging -> logger </%> . debug ( STR ) ;
throw new crypto _ error _ exception ( ) ; } <%> <*> logging -> logger </%> . debug ( STR + chunk _ len ) ; buf _ size = dec _ circular _ buffer . size ; if ( buf _ size < chunk _ len _ bytes + tag _ len <%> <*> logging -> logger </%> . debug ( STR ) ; return ; } increment _ nonce ( false ) ; dec _ circular _ buffer . skip ( chunk _ len _ bytes + tag _ len ) ;
using system _ io ; using system _ i _ compression ; using system _ text ; namespace shadowsocks _ controller { public static class file _ manager { <%> <+> private static logger logger = log _ manager . get _ current _ class _ logger ( ) ; </%> public static bool byte _ array _ to _ file ( string file _ name , byte [ ] content ) {
using system ; using system _ collections _ generic ; using system _ net ; using system _ text ; namespace shadowsocks _ controller _ strategy { class high _ availability _ strategy : i _ strategy { <%> <+> private static logger logger = log _ manager . get _ current _ class _ logger ( ) ; </%>
} } } public void update _ latency ( model . server server , time _ span latency ) { <%> <*> logging -> logger </%> . debug ( $ STR ) ; server _ status status ; if ( server _ status . try _ get _ value ( server , out status ) ) { status . latency = latency ;
} tcp _ socket . begin _ accept ( new async _ callback ( accept _ callback ) , tcp _ socket ) ; udp _ state udp _ state = new udp _ state ( udp _ socket ) ; udp _ socket . begin _ receive _ from ( udp _ state . buffer , 0 , udp _ state . buffer . length , 0 , ref udp _ state . remote _ end _ point , new async _ callback ( recv _ from _ callback ) , udp _ state ) ; } catch ( socket _ exception ) { tcp _ socket . close ( ) ; throw ; }
web _ client http = create _ web _ client ( ) ; http . download _ string _ completed + = http _ download _ string _ completed ; http . download _ string _ async ( new uri ( update _ url ) ) ; } catch ( exception ex ) { <%> <*> logging -> logger </%> . log _ useful _ exception ( ex ) ; } } private void http _ download _ string _ completed ( object sender , download _ string _ completed _ event _ args e )
} } private void http _ download _ string _ completed ( object sender , download _ string _ completed _ event _ args e ) { try { string response = e . result ; j _ array result = j _ array . parse ( response ) ; list < asset > asserts = new list < asset > ( ) ; if ( result ! = null )
if ( check _ update _ completed ! = null ) { check _ update _ completed ( this , new event _ args ( ) ) ; } } } catch ( exception ex ) { <%> <*> logging -> logger </%> . log _ useful _ exception ( ex ) ; }
} } private void start _ download ( ) { try { latest _ version _ local _ name = utils . get _ temp _ path ( latest _ version _ name ) ; web _ client http = create _ web _ client ( ) ; http . download _ file _ completed + = http _ download _ file _ completed ; http . download _ file _ async ( new uri ( latest _ version _ url ) , latest _ version _ local _ name ) ;
if ( check _ update _ completed ! = null ) { check _ update _ completed ( this , new event _ args ( ) ) ; } } catch ( exception ex ) { <%> <*> logging -> logger </%> . log _ useful _ exception ( ex ) ; } }
} } private web _ client create _ web _ client ( ) { web _ client http = new web _ client ( ) ; http . headers . add ( STR , user _ agent ) ; http . proxy = new web _ proxy ( config . local _ host , config . local _ port ) ; return http ; } private void sort _ by _ versions ( list < asset > asserts )
switch ( cipher ) { case cipher _ chach _ ietfpol : ret = sodium . crypto _ aead _ chacha _ poly _ ietf _ decrypt ( plaintext , ref dec _ plen , null , ciphertext , ( ulong ) clen , null , 0 , dec _ nonce , sodium _ dec _ subkey ) ; break ; case cipher _ xchach _ ietfpol :
remote ? . send _ to ( data _ out , outlen , socket _ flags . none , remote _ end _ point ) ; } public void receive ( ) { end _ point remote _ end _ point = new ip _ end _ point ( get _ ip _ address ( ) , 0 ) ; <%> <*> logging -> logger </%> . debug ( $ STR + buffer . length ) ; remote ? . begin _ receive _ from ( buffer , 0 , buffer . length , 0 , ref remote _ end _ point , new async _ callback ( recv _ from _ callback ) , null ) ; } public void recv _ from _ callback ( i _ async _ result ar ) {
string privoxy _ log _ filename = utils . get _ temp _ path ( STR ) ; if ( file . exists ( privoxy _ log _ filename ) ) using ( new file _ stream ( privoxy _ log _ filename , file _ mode . truncate ) ) { } <%> <-> logging . open _ log _ file ( ) ; </%> main _ controller = new shadowsocks _ controller ( ) ; menu _ controller = new menu _ view _ controller ( main _ controller ) ; hot _ keys . init ( main _ controller ) ; main _ controller . start ( ) ; application . run ( ) ; }
main _ controller = new shadowsocks _ controller ( ) ; menu _ controller = new menu _ view _ controller ( main _ controller ) ; hot _ keys . init ( main _ controller ) ; main _ controller . start ( ) ; application . run ( ) ; } } <%> <+> private static void touch _ and _ apply _ n _ log _ config ( ) { string n _ log _ config _ file _ name = STR ; </%>
message _ box . show ( $ STR unexpected error , shadowsocks will exit . please report to STR , STR , message _ box _ buttons . ok , message _ box _ icon . error ) ; application . exit ( ) ; } } private static void application _ thread _ exception ( object sender , thread _ exception _ event _ args e ) { if ( interlocked . increment ( ref exited ) = = 1 ) {
} } ) ; } break ; case power _ modes . suspend : if ( main _ controller ! = null ) { main _ controller . stop ( ) ; <%> <*> logging -> logger </%> . info ( STR ) ; }
handler handler = new handler ( ) ; handler . connection = conn ; handler . encryptor = encryptor _ factory . get _ encryptor ( config . method , config . password ) ; handler . config = config ; handler . start ( ) ; } catch ( exception <%> <-> e </%> ) { } }
{ } } } class handler { public i _ encryptor encryptor ; public config config ; public socket remote ; public socket connection ;
{ return strings . contains _ key ( key ) ? <%> <+> string . format ( </%> strings [ key ] <%> <+> , args ) </%> : <%> <+> string . format ( </%> key <%> <+> , args ) </%> ; } } }
} } }
} public void start ( configuration config ) { this . config = config ; this . share _ over _ lan = config . share _ over _ lan ; if ( check _ if _ port _ in _ use ( config . local _ port ) ) throw new exception ( n . get _ string ( STR <%> <+> , config . local _ port </%> ) ) ; try { tcp _ socket = new socket ( address _ family . inter _ network , socket _ type . stream , protocol _ type . tcp ) ;
try { tcp _ socket = new socket ( address _ family . inter _ network , socket _ type . stream , protocol _ type . tcp ) ; udp _ socket = new socket ( address _ family . inter _ network , socket _ type . dgram , protocol _ type . udp ) ; tcp _ socket . set _ socket _ option ( socket _ option _ level . socket , socket _ option _ name . reuse _ address , true ) ; udp _ socket . set _ socket _ option ( socket _ option _ level . socket , socket _ option _ name . reuse _ address , true ) ; ip _ end _ point local _ end _ point = null ; local _ end _ point = share _ over _ lan ? new ip _ end _ point ( ip _ address . any , config . local _ port ) : new ip _ end _ point ( ip _ address . loopback , config . local _ port ) ;
dest _ host = host ; dest _ port = port ; byte [ ] request = null ; byte atyp = 0 ; <%> <+> ip _ address ip _ address ; bool parsed = ip _ address . try _ parse ( host , out ip _ address ) ; if ( parsed ) { ip _ end _ point ep = new ip _ end _ point ( ip _ address , port ) ; </%> switch ( ep . address _ family )
request [ 0 ] = NUM ; request [ 1 ] = 1 ; request [ 2 ] = 0 ; request [ NUM ] = atyp ; <%> <*> array . copy ( addr , 0 , request , NUM , request . length - NUM - 2 ) ; request [ request . length - 2 ] = ( byte ) ( ( ep . port > > NUM ) & 0 xff ) ; request [ request . length - 1 ] = ( byte ) ( ep . port & 0 xff ) ; -> request [ request . length - 2 ] = ( byte ) ( ( port > > NUM ) & 0 xff ) ; </%> <%> <+> request [ request . length - 1 ] = ( byte ) ( port & 0 xff ) ; </%> var st = new socks _ state ( ) ;
var st = new socks _ state ( ) ; st . callback = callback ; st . async _ state = state ; remote ? . begin _ send ( request , 0 , request . length , 0 , socks _ request _ send _ callback , st ) ; } public void end _ connect _ dest ( i _ async _ result async _ result ) { var state = ( ( fake _ async _ result ) async _ result ) . inner _ state ; if ( state . ex ! = null ) {
break ; case NUM : int len = connetion _ recv _ buffer [ 1 ] ; dst _ addr = system . text . encoding . ut . get _ string ( connetion _ recv _ buffer , 2 , len ) ; dst _ port = ( connetion _ recv _ buffer [ len + 2 ] < < NUM ) + connetion _ recv _ buffer [ len + NUM ] ; <%> <*> logging . debug ( $ STR ) ; -> if ( controller . get _ current _ configuration ( ) . is _ verbose _ logging ) { </%> <%> <+> logging . info ( $ STR ) ; } </%> break ;
break ; case NUM : dst _ addr = new ip _ address ( connetion _ recv _ buffer . skip ( 1 ) . take ( NUM ) . to _ array ( ) ) . to _ string ( ) ; dst _ port = ( connetion _ recv _ buffer [ NUM ] < < NUM ) + connetion _ recv _ buffer [ NUM ] ; <%> <*> logging . debug ( $ STR ) ; -> if ( controller . get _ current _ configuration ( ) . is _ verbose _ logging ) { </%> <%> <+> logging . info ( $ STR ) ; } </%> break ; }
break ; } int bytes _ to _ send ; lock ( encryption _ lock ) { if ( closed ) return ; encryptor . encrypt ( connetion _ recv _ buffer , bytes _ read , connetion _ send _ buffer , out bytes _ to _ send ) ; } tcprelay . update _ outbound _ counter ( server , bytes _ to _ send ) ; start _ sending _ time = date _ time . now ;
{ <%> <*> using -> if </%> ( <%> <*> var sr -> name </%> = <%> <*> new string _ reader ( resources . cn -> = STR | | name = = STR </%> ) <%> <-> ) </%> { <%> <-> foreach ( var line in sr . non _ white _ space _ lines ( ) ) { if ( line [ 0 ] = = '#' ) continue ; var pos = line . index _ of ( '=' ) ; if ( pos < 1 ) continue ; </%>
{ <%> <-> foreach ( var line in sr . non _ white _ space _ lines ( ) ) { if ( line [ 0 ] = = '#' ) continue ; var pos = line . index _ of ( '=' ) ; if ( pos < 1 ) continue ; </%> <%> <*> strings [ line . substring ( 0 , pos ) ] = line . substring -> init </%> ( <%> <*> pos + 1 -> resources . cn </%> ) ; }
} } } public static string get _ string ( string key ) { if ( strings . contains _ key ( key ) ) { return strings [ key ] ; } else
{ byte [ ] str _ byte = encoding . ascii . get _ bytes ( str ) ; str = encoding . unicode . get _ string ( str _ byte ) ; user _ settings _ arr = str . split ( new string [ ] { STR } , string _ split _ options . remove _ empty _ entries ) ; <%> <+> if ( user _ settings _ arr . length ! = NUM ) { throw new proxy _ exception ( STR + bit _ converter . to _ string ( str _ byte ) ) ; } </%> } user _ settings . flags = user _ settings _ arr [ 0 ] ;
{ <%> <+> var sb = new string _ builder ( $ STR ) ; for ( int i = 0 ; i < length - 1 ; i + + ) { </%> sb . append ( $ STR ) ; <%> <+> } sb . append ( $ STR ) ; sb . append ( environment . new _ line ) ; logger . trace ( sb . to _ string ( ) ) ; </%> }
} <%> <-> sb . append ( $ STR ) ; sb . append ( environment . new _ line ) ; logger . debug ( sb . to _ string ( ) ) ; </%> } public static void debug ( this logger logger , end _ point local , end _ point remote , int len , string header = null , string tailer = null ) { <%> <+> if ( logger . is _ debug _ enabled ) { </%> if ( header = = null & & tailer = = null )
} public static void debug ( this logger logger , end _ point local , end _ point remote , int len , string header = null , string tailer = null ) { <%> <+> if ( logger . is _ debug _ enabled ) { </%> if ( header = = null & & tailer = = null ) logger . debug ( $ STR ) ; else if ( header = = null & & tailer ! = null ) logger . debug ( $ STR ) ; else if ( header ! = null & & tailer = = null )
} public static void debug ( this logger logger , socket sock , int len , string header = null , string tailer = null ) { <%> <+> if ( logger . is _ debug _ enabled ) { </%> logger . debug ( sock . local _ end _ point , sock . remote _ end _ point , len , header , tailer ) ; <%> <+> } </%> } public static void log _ useful _ exception ( this logger logger , exception e ) {
} public static void log _ useful _ exception ( this logger logger , exception e ) { if ( e is socket _ exception ) { socket _ exception se = ( socket _ exception ) e ; if ( se . socket _ error _ code = = socket _ error . connection _ aborted ) { } else if ( se . socket _ error _ code = = socket _ error . connection _ reset )
return configuration ; } catch ( file _ not _ found _ exception <%> <-> e </%> ) { var configuration = new statistics _ strategy _ configuration ( ) ; save ( configuration ) ; return configuration ; } catch ( exception e ) {
{ var configuration = new statistics _ strategy _ configuration ( ) ; save ( configuration ) ; return configuration ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; return new statistics _ strategy _ configuration ( ) ; }
{ bool success = true ; if ( value is string ) success = serialize _ string ( ( string ) value , builder ) ; else if ( value is i _ dictionary < string , object > ) { i _ dictionary < string , object > dict = ( i _ dictionary < string , object > ) value ; success = serialize _ object ( json _ serializer _ strategy , dict . keys , dict . values <%> <+> , level </%> , builder ) ; } else if ( value is i _ dictionary < string , string > )
} else if ( value is i _ dictionary < string , string > ) { i _ dictionary < string , string > dict = ( i _ dictionary < string , string > ) value ; success = serialize _ object ( json _ serializer _ strategy , dict . keys , dict . values <%> <+> , level </%> , builder ) ; } else if ( value is i _ enumerable ) success = serialize _ array ( json _ serializer _ strategy , ( i _ enumerable ) value <%> <+> , level </%> , builder ) ; else if ( is _ numeric ( value ) ) success = serialize _ number ( value , builder ) ;
} else if ( value is i _ enumerable ) success = serialize _ array ( json _ serializer _ strategy , ( i _ enumerable ) value <%> <+> , level </%> , builder ) ; else if ( is _ numeric ( value ) ) success = serialize _ number ( value , builder ) ; else if ( value is boolean ) builder . append ( ( bool ) value ? STR : STR ) ; else if ( value = = null ) builder . append ( STR ) ; else
else if ( is _ numeric ( value ) ) success = serialize _ number ( value , builder ) ; else if ( value is boolean ) builder . append ( ( bool ) value ? STR : STR ) ; else if ( value = = null ) builder . append ( STR ) ; else { object serialized _ object ; success = json _ serializer _ strategy . serialize _ non _ primitive _ object ( value , out serialized _ object ) ;
} return success ; } protected static bool serialize _ object ( i _ json _ serializer _ strategy json _ serializer _ strategy , i _ enumerable keys , i _ enumerable values <%> <+> , int level </%> , string _ builder builder ) { builder . append ( STR ) ; <%> <+> level + + ; </%> i _ enumerator ke = keys . get _ enumerator ( ) ; i _ enumerator ve = values . get _ enumerator ( ) ; bool first = true ;
{ builder . append ( STR ) ; <%> <+> level + + ; </%> i _ enumerator ke = keys . get _ enumerator ( ) ; i _ enumerator ve = values . get _ enumerator ( ) ; bool first = true ; while ( ke . move _ next ( ) & & ve . move _ next ( ) ) { object key = ke . current ; object value = ve . current ;
builder . append ( STR ) ; if ( ! serialize _ value ( json _ serializer _ strategy , value <%> <+> , level </%> , builder ) ) return false ; first = false ; } builder . append ( STR ) ; <%> <+> feed _ indent ( level - 1 , builder ) ; builder . append ( STR ) ; </%> return true ; }
return false ; first = false ; } builder . append ( STR ) ; <%> <+> feed _ indent ( level - 1 , builder ) ; builder . append ( STR ) ; </%> return true ; } protected static bool serialize _ array ( i _ json _ serializer _ strategy json _ serializer _ strategy , i _ enumerable an _ array <%> <+> , int level </%> , string _ builder builder ) {
return true ; } protected static bool serialize _ array ( i _ json _ serializer _ strategy json _ serializer _ strategy , i _ enumerable an _ array <%> <+> , int level </%> , string _ builder builder ) { builder . append ( STR ) ; <%> <+> level + + ; </%> bool first = true ; foreach ( object value in an _ array ) { if ( ! first )
bool first = true ; foreach ( object value in an _ array ) { if ( ! first ) builder . append ( STR ) ; <%> <*> if ( ! serialize _ value ( json _ serializer -> feed </%> _ <%> <*> strategy , value -> indent ( level </%> , builder ) <%> <*> ) -> ; </%> <%> <+> if ( ! serialize _ value ( json _ serializer _ strategy , value , level , builder ) ) </%> return false ; first = false ; }
return false ; first = false ; } builder . append ( STR ) ; <%> <+> feed _ indent ( level - 1 , builder ) ; builder . append ( STR ) ; </%> return true ; } protected static bool serialize _ string ( string a _ string , string _ builder builder ) {
return true ; } protected static bool serialize _ string ( string a _ string , string _ builder builder ) { builder . append ( STR ) ; char [ ] char _ array = a _ string . to _ char _ array ( ) ; for ( int i = 0 ; i < char _ array . length ; i + + ) { char c = char _ array [ i ] ; if ( c = = '"' )
} public static void close ( ) { <%> <*> if ( rng = = null ) return ; rng . dispose ( ) ; -> rng ? . dispose ( ) ; </%> rng = null ; } public static void reload ( ) {
rng = null ; } public static void reload ( ) { close ( ) ; init ( ) ; } public static void get _ bytes ( byte [ ] buf ) { get _ bytes ( buf , buf . length ) ;
try { rng . get _ bytes ( buf , 0 , len ) ; } catch <%> <-> ( system . exception ) </%> { byte [ ] tmp = new byte [ len ] ; rng . get _ bytes ( tmp ) ; buffer . block _ copy ( tmp , 0 , buf , 0 , len ) ; }
{ byte [ ] tmp = new byte [ len ] ; rng . get _ bytes ( tmp ) ; buffer . block _ copy ( tmp , 0 , buf , 0 , len ) ; } } } }
string abp _ content = utils . un _ gzip ( resources . abp _ js ) ; abp _ content = abp _ content . replace ( STR , <%> <*> rules -> simple _ json . simple _ json </%> . <%> <*> to -> serialize </%> _ <%> <*> string -> object </%> ( <%> <+> lines </%> ) ) ; file . write _ all _ text ( pac _ file , abp _ content , encoding . ut ) ; if ( update _ completed ! = null ) { update _ completed ( this , new event _ args ( ) ) ; } } catch ( exception ex ) {
file . write _ all _ text ( pac _ file , abp _ content , encoding . ut ) ; if ( update _ completed ! = null ) { update _ completed ( this , new event _ args ( ) ) ; } } catch ( exception ex ) { if ( error ! = null ) {
{ byte [ ] bytes = convert . from _ base _ string ( response ) ; string content = encoding . ascii . get _ string ( bytes ) ; string [ ] lines = content . split ( new char [ ] { '\r' , '\n' } , string _ split _ options . remove _ empty _ entries ) ; list < string > valid _ lines = new list < string > ( lines . length ) ; foreach ( string line in lines ) { if ( line . starts _ with ( STR ) | | line . starts _ with ( STR ) ) continue ; valid _ lines . add ( line ) ;
{ <%> <*> message _ box . show ( STR ) ; throw ; -> logging . log _ useful _ exception ( e ) ; </%> <%> <+> message _ box . show ( n . get _ string ( STR ) ) ; </%> } } public static void disable ( ) { try
} } public static void disable ( ) { try { registry _ key registry = registry . current _ user . open _ sub _ key ( STR , true ) ; registry . set _ value ( STR , 0 ) ;
{ <%> <*> message _ box . show ( STR ) ; throw ; -> logging . log _ useful _ exception ( e ) ; </%> <%> <+> message _ box . show ( n . get _ string ( STR ) ) ; </%> } } private static void copy _ proxy _ setting _ from _ lan ( ) { registry _ key registry =
} } private static void copy _ proxy _ setting _ from _ lan ( ) { registry _ key registry = registry . current _ user . open _ sub _ key ( STR , true ) ; var default _ value = registry . get _ value ( STR ) ; try {
socket listener ; public local ( config config ) { this . config = config ; <%> <-> this . encryptor = new encryptor ( config . method , config . password ) ; </%> } public void start ( ) { listener = new socket ( address _ family . inter _ network , socket _ type . stream , protocol _ type . tcp ) ;
} public void start ( ) { listener = new socket ( address _ family . inter _ network , socket _ type . stream , protocol _ type . tcp ) ; ip _ end _ point local _ end _ point = new ip _ end _ point ( 0 , config . local _ port ) ; listener . bind ( local _ end _ point ) ; listener . listen ( NUM ) ; console . write _ line ( STR ) ; listener . begin _ accept (
{ if ( <%> <*> global -> enabled </%> ) { <%> <+> if ( global ) { </%> win _ i _ net . set _ ie _ proxy ( true , true , STR + config . local _ port . to _ string ( ) , STR ) ; <%> <+> } else { string pac _ url ; </%>
{ <%> <+> if ( global ) { </%> win _ i _ net . set _ ie _ proxy ( true , true , STR + config . local _ port . to _ string ( ) , STR ) ; <%> <+> } else { string pac _ url ; if ( config . use _ online _ pac & & ! config . pac _ url . is _ null _ or _ empty ( ) ) pac _ url = config . pac _ url ; </%>
} else { <%> <*> string pac _ url ; if ( config . use _ online _ pac & & ! config . pac _ url . is _ null _ or _ empty ( ) ) pac _ url = config . pac _ url ; else pac _ url = $ STR ; win _ i _ net . set _ ie _ proxy ( true , false , STR , pac _ url ) ; -> win _ i _ net . set _ ie _ proxy ( false , false , STR , STR ) ; </%>
} } <%> <-> else </%> <%> <+> catch ( proxy _ exception ex ) </%> { <%> <*> win _ i _ net -> logging </%> . <%> <*> set -> log </%> _ <%> <*> ie -> useful </%> _ <%> <*> proxy -> exception </%> ( <%> <*> false , false , STR , STR -> ex </%> ) ; } } } }
{ <%> <*> win _ i _ net -> logging </%> . <%> <*> set -> log </%> _ <%> <*> ie -> useful </%> _ <%> <*> proxy -> exception </%> ( <%> <*> false , false , STR , STR -> ex </%> ) ; } } } }
} } } }
} private void log _ form _ form _ closing ( object sender , form _ closing _ event _ args e ) { timer . stop ( ) ; <%> <+> config . log _ viewer . top _ most = top _ most _ trigger ; config . log _ viewer . wrap _ text = wrap _ text _ trigger ; config . log _ viewer . toolbar _ shown = toolbar _ trigger ; config . log _ viewer . font _ name = log _ message _ text _ box . font . name ; config . log _ viewer . font _ size = log _ message _ text _ box . font . size ; config . log _ viewer . set _ background _ color ( log _ message _ text _ box . back _ color ) ; </%>
} public static void legacy _ derive _ key ( byte [ ] password , byte [ ] key <%> <+> , int keylen </%> ) { byte [ ] result = new byte [ password . length + <%> <*> NUM -> m _ len </%> ] ; int i = 0 ; byte [ ] md _ sum = null ; while ( i < <%> <*> key . length -> keylen </%> ) { if ( i = = 0 ) { md _ sum = mbed _ tls . m ( password ) ; } else {
{ byte [ ] result = new byte [ password . length + <%> <*> NUM -> m _ len </%> ] ; int i = 0 ; byte [ ] md _ sum = null ; while ( i < <%> <*> key . length -> keylen </%> ) { if ( i = = 0 ) { md _ sum = mbed _ tls . m ( password ) ; } else { <%> <+> array . copy ( </%> md _ sum <%> <*> . copy _ to ( -> , 0 , </%> result , 0 <%> <+> , m _ len </%> ) ; <%> <*> password -> array </%> . copy <%> <-> _ to </%> ( <%> <+> password , 0 , </%> result , <%> <*> md -> m </%> _ <%> <*> sum -> len , password </%> . length ) ;
int i = 0 ; byte [ ] md _ sum = null ; while ( i < <%> <*> key . length -> keylen </%> ) { if ( i = = 0 ) { md _ sum = mbed _ tls . m ( password ) ; } else { <%> <+> array . copy ( </%> md _ sum <%> <*> . copy _ to ( -> , 0 , </%> result , 0 <%> <+> , m _ len </%> ) ; <%> <*> password -> array </%> . copy <%> <-> _ to </%> ( <%> <+> password , 0 , </%> result , <%> <*> md -> m </%> _ <%> <*> sum -> len , password </%> . length ) ; md _ sum = mbed _ tls . m ( result ) ; }
if ( i = = 0 ) { md _ sum = mbed _ tls . m ( password ) ; } else { <%> <+> array . copy ( </%> md _ sum <%> <*> . copy _ to ( -> , 0 , </%> result , 0 <%> <+> , m _ len </%> ) ; <%> <*> password -> array </%> . copy <%> <-> _ to </%> ( <%> <+> password , 0 , </%> result , <%> <*> md -> m </%> _ <%> <*> sum -> len , password </%> . length ) ; md _ sum = mbed _ tls . m ( result ) ; } <%> <+> array . copy ( </%> md _ sum <%> <+> , 0 , key , i , math </%> . <%> <*> copy -> min ( m </%> _ <%> <*> to ( key , -> len , keylen - </%> i ) <%> <+> ) </%> ; i + = <%> <*> md -> m </%> _ <%> <*> sum . length -> len </%> ; }
md _ sum = mbed _ tls . m ( result ) ; } <%> <+> array . copy ( </%> md _ sum <%> <+> , 0 , key , i , math </%> . <%> <*> copy -> min ( m </%> _ <%> <*> to ( key , -> len , keylen - </%> i ) <%> <+> ) </%> ; i + = <%> <*> md -> m </%> _ <%> <*> sum . length -> len </%> ; } } protected virtual void init _ cipher ( byte [ ] iv , bool is _ encrypt ) { if ( is _ encrypt ) { encrypt _ iv = new byte [ iv _ len ] ;
} } protected virtual void init _ cipher ( byte [ ] iv , bool is _ encrypt ) { if ( is _ encrypt ) { encrypt _ iv = new byte [ iv _ len ] ; array . copy ( iv , encrypt _ iv , iv _ len ) ; } else { decrypt _ iv = new byte [ iv _ len ] ; array . copy ( iv , decrypt _ iv , iv _ len ) ;
if ( session _ key = = null ) session _ key = new byte [ key _ len ] ; } public void derive _ key ( byte [ ] password , byte [ ] key <%> <+> , int keylen </%> ) { stream _ encryptor . legacy _ derive _ key ( password , key <%> <+> , keylen </%> ) ; } public void derive _ session _ key ( byte [ ] salt , byte [ ] master _ key , byte [ ] session _ key ) { int ret = mbed _ tls . hkdf ( salt , salt _ len , master _ key , key _ len , info _ bytes , info _ bytes . length , session _ key , key _ len ) ;
} public void derive _ session _ key ( byte [ ] salt , byte [ ] master _ key , byte [ ] session _ key ) { int ret = mbed _ tls . hkdf ( salt , salt _ len , master _ key , key _ len , info _ bytes , info _ bytes . length , session _ key , key _ len ) ; if ( ret ! = 0 ) throw new system . exception ( STR ) ; } protected void increment _ nonce ( bool is _ encrypt ) { lock ( nonce _ increment _ lock ) {
{ <%> <-> get </%> <%> <+> if ( string . is _ null _ or _ empty ( server ) ) </%> { <%> <-> if ( string . is _ null _ or _ empty ( server ) ) { </%> return n . get _ string ( STR ) ; <%> <-> } return string . is _ null _ or _ empty ( remarks ) ? server + STR + server _ port : server + STR + server _ port + STR + remarks + STR ; </%> } <%> <+> return string . is _ null _ or _ empty ( remarks ) ? server + STR + server _ port : server + STR + server _ port + STR + remarks + STR ; </%>
{ <%> <-> if ( string . is _ null _ or _ empty ( server ) ) { </%> return n . get _ string ( STR ) ; <%> <-> } return string . is _ null _ or _ empty ( remarks ) ? server + STR + server _ port : server + STR + server _ port + STR + remarks + STR ; </%> } <%> <+> return string . is _ null _ or _ empty ( remarks ) ? server + STR + server _ port : server + STR + server _ port + STR + remarks + STR ; </%> } }
} <%> <+> return string . is _ null _ or _ empty ( remarks ) ? server + STR + server _ port : server + STR + server _ port + STR + remarks + STR ; </%> } } }
string polipo _ config = resources . polipo _ config ; polipo _ config = polipo _ config . replace ( STR , server . local _ port . to _ string ( ) ) ; polipo _ config = polipo _ config . replace ( STR , configuration . share _ over _ lan ? STR : STR ) ; file _ manager . byte _ array _ to _ file ( temppath + STR , system . text . encoding . ut . get _ bytes ( polipo _ config ) ) ; <%> <-> file _ manager . uncompress _ file ( temppath + STR , resources . polipo _ exe ) ; </%> process = new process ( ) ; process . start _ info . file _ name = temppath + STR ; process . start _ info . arguments = STR + temppath + STR ; process . start _ info . window _ style = process _ window _ style . hidden ; process . start _ info . use _ shell _ execute = true ;
process = new process ( ) ; process . start _ info . file _ name = temppath + STR ; process . start _ info . arguments = STR + temppath + STR ; process . start _ info . window _ style = process _ window _ style . hidden ; process . start _ info . use _ shell _ execute = true ; process . start _ info . create _ no _ window = true ; process . start ( ) ; } } public void stop ( )
public socket connection ; public shadowsocks _ controller controller ; public tcp _ relay tcprelay ; public date _ time last _ activity ; private const int max _ retry = NUM ; private int retry _ count = 0 ; private bool proxy _ connected ; private bool dest _ connected ; private byte command ; private byte [ ] first _ packet ;
public end _ point dest _ end _ point ; public server server ; public proxy _ timer ( int p ) : base ( p ) { } } private class server _ timer : timer { <%> <+> public async _ session session ; </%> public server server ;
proxy _ timer . dest _ end _ point = socket _ util . get _ end _ point ( server . server , server . server _ port ) ; proxy _ timer . server = server ; proxy _ connected = false ; remote . begin _ connect _ proxy ( proxy _ ep , new async _ callback ( proxy _ connect _ callback ) <%> <+> , new async _ session < proxy _ timer > ( remote </%> , proxy _ timer ) <%> <+> ) </%> ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; }
} catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; } } private void proxy _ connect _ timer _ elapsed ( object sender , elapsed _ event _ args e ) { if ( proxy _ connected | | dest _ connected )
logging . info ( $ STR ) ; <%> <*> remote ? -> proxy </%> . close ( ) ; retry _ connect ( ) ; } private void proxy _ connect _ callback ( i _ async _ result ar ) { server server = null ; if ( closed ) { return ;
retry _ connect ( ) ; } private void proxy _ connect _ callback ( i _ async _ result ar ) { server server = null ; if ( closed ) { return ; } try
var dest _ end _ point = timer . dest _ end _ point ; server = timer . server ; timer . elapsed - = proxy _ connect _ timer _ elapsed ; timer . enabled = false ; timer . dispose ( ) ; <%> <+> var remote = session . remote ; </%> remote . end _ connect _ proxy ( ar ) ; proxy _ connected = true ; if ( config . is _ verbose _ logging ) {
} catch ( argument _ exception ) { } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; retry _ connect ( ) ; } }
retry _ connect ( ) ; } private void retry _ connect ( ) { if ( retry _ count < max _ retry ) { logging . debug ( $ STR ) ; start _ connect ( ) ; retry _ count + + ; }
server = timer . server ; timer . elapsed - = dest _ connect _ timer _ elapsed ; timer . enabled = false ; timer . dispose ( ) ; <%> <+> var remote = session . remote ; </%> remote ? . end _ connect _ dest ( ar ) ; dest _ connected = true ; if ( config . is _ verbose _ logging ) { logging . info ( $ STR ) ;
{ if ( closed ) return ; try { start _ receiving _ time = date _ time . now ; <%> <+> session . </%> remote <%> <-> ? </%> . begin _ receive ( remote _ recv _ buffer , 0 , recv _ size , socket _ flags . none , new async _ callback ( pipe _ remote _ receive _ callback ) , <%> <*> null -> session </%> ) ; connection ? . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , socket _ flags . none , new async _ callback ( pipe _ connection _ receive _ callback ) , <%> <+> new async _ session < bool > ( session , </%> true <%> <+> ) </%> } catch ( exception e )
connection ? . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , socket _ flags . none , new async _ callback ( pipe _ connection _ receive _ callback ) , <%> <+> new async _ session < bool > ( session , </%> true <%> <+> ) </%> } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; } } private void pipe _ remote _ receive _ callback ( i _ async _ result ar )
} catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; } } private void pipe _ remote _ receive _ callback ( i _ async _ result ar ) { if ( closed ) return ;
{ int atyp = connetion _ recv _ buffer [ 0 ] ; string dst _ addr ; int dst _ port ; switch ( atyp ) { case 1 : dst _ addr = new ip _ address ( connetion _ recv _ buffer . skip ( 1 ) . take ( NUM ) . to _ array ( ) ) . to _ string ( ) ; dst _ port = ( connetion _ recv _ buffer [ NUM ] < < NUM ) + connetion _ recv _ buffer [ NUM ] ; logging . info ( $ STR ) ;
break ; } } int bytes _ to _ send ; lock ( encryption _ lock ) { if ( closed ) return ; encryptor . encrypt ( connetion _ recv _ buffer , bytes _ read , connetion _ send _ buffer , out bytes _ to _ send ) ; } tcprelay . update _ outbound _ counter ( server , bytes _ to _ send ) ;
} catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; } } } }
static dictionary < string , int [ ] > ciphers = new dictionary < string , int [ ] > { { STR , new int [ ] { NUM , NUM , cipher _ aes , polar _ ssl . aes _ ctx _ size } } , { STR , new int [ ] { NUM , NUM , cipher _ aes , polar _ ssl . aes _ ctx _ size } } , { STR , new int [ ] { NUM , NUM , cipher _ aes , polar _ ssl . aes _ ctx _ size } } , <%> <-> { STR , new int [ ] { NUM , NUM , cipher _ bf , polar _ ssl . blowfish _ ctx _ size } } , </%> { STR , new int [ ] { NUM , 0 , cipher _ r , polar _ ssl . ar _ ctx _ size } } , { STR , new int [ ] { NUM , NUM , cipher _ r , polar _ ssl . ar _ ctx _ size } } , } ; private static readonly dictionary < string , byte [ ] > cached _ keys = new dictionary < string , byte [ ] > ( ) ; private int cipher ;
{ STR , new int [ ] { NUM , 0 , cipher _ r , polar _ ssl . ar _ ctx _ size } } , { STR , new int [ ] { NUM , NUM , cipher _ r , polar _ ssl . ar _ ctx _ size } } , } ; private static readonly dictionary < string , byte [ ] > cached _ keys = new dictionary < string , byte [ ] > ( ) ; private int cipher ; private int [ ] cipher _ info ; private byte [ ] key ; private int _ ptr encrypt _ ctx = int _ ptr . zero ; private int _ ptr decrypt _ ctx = int _ ptr . zero ; private byte [ ] encrypt _ iv ;
<%> <*> remote . begin _ connect ( remote _ ep , new async _ callback ( connect _ callback ) , null ) ; -> socket _ util . begin _ connect _ tcp ( remote _ ep , connect _ callback , null ) ; </%> } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; this . close ( ) ; } }
} catch ( exception e ) { logging . log _ useful _ exception ( e ) ; this . close ( ) ; } } private void connect _ callback ( i _ async _ result ar ) { if ( closed )
} public void end _ connect _ dest ( i _ async _ result async _ result ) { remote <%> <*> ? -> = socket _ util </%> . end _ connect <%> <+> _ tcp </%> ( async _ result ) ; } public void begin _ send ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) { remote ? . begin _ send ( buffer , offset , size , socket _ flags , callback , state ) ; }
} public void begin _ send ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) { remote ? . begin _ send ( buffer , offset , size , socket _ flags , callback , state ) ; } public int end _ send ( i _ async _ result async _ result ) { return remote . end _ send ( async _ result ) ; }
var st = new socks _ state ( ) ; st . callback = callback ; st . async _ state = state ; proxy _ end _ point = remote _ ep ; <%> <*> remote -> socket _ util </%> . begin _ connect <%> <+> _ tcp </%> ( remote _ ep , connect _ callback , st ) ; } public void end _ connect _ proxy ( i _ async _ result async _ result ) { var state = ( ( fake _ async _ result ) async _ result ) . inner _ state ; if ( state . ex ! = null )
} public void end _ connect _ proxy ( i _ async _ result async _ result ) { var state = ( ( fake _ async _ result ) async _ result ) . inner _ state ; if ( state . ex ! = null ) { throw state . ex ; } } public void begin _ connect _ dest ( end _ point dest _ end _ point , async _ callback callback , object state )
{ <%> <*> socket _ type socket _ type ; switch ( protocol _ type ) -> public async _ callback callback { get ; } </%> <%> <+> public socket _ async _ event _ args args { get ; } public tcp _ user _ token ( async _ callback callback , object state , socket _ async _ event _ args args ) </%> { <%> <-> case protocol _ type . tcp : socket _ type = socket _ type . stream ; break ; </%>
{ <%> <*> case protocol _ type . tcp : socket _ type = socket _ type . stream ; break ; case protocol _ type . udp : socket _ type = socket _ type . dgram ; break ; default : throw new not _ supported _ exception ( STR + protocol _ type + STR ) ; -> callback = callback ; </%>
} <%> <*> if ( end _ point is dns _ end _ point ) -> public bool is _ completed { get ; } = true ; </%> <%> <+> public wait _ handle async _ wait _ handle { get ; } = null ; public object async _ state { get ; } public bool completed _ synchronously { get ; } = true ; } private static void on _ tcp _ connect _ completed ( object sender , socket _ async _ event _ args args ) { tcp _ user _ token token = ( tcp _ user _ token ) args . user _ token ; </%>
{ <%> <*> var socket = new socket ( address _ family . inter _ network , socket _ type , protocol _ type ) ; socket . set _ socket _ option ( socket _ option _ level . i _ pv , ( socket _ option _ name ) NUM , false ) ; return socket ; -> throw new argument _ exception ( STR , nameof ( async _ result ) ) ; </%> } <%> <*> else -> var arg = tut . args ; </%> <%> <+> if ( arg . socket _ error ! = socket _ error . success ) </%> {
} <%> <*> else -> var arg = tut . args ; </%> <%> <+> if ( arg . socket _ error ! = socket _ error . success ) </%> { <%> <*> return new socket ( end _ point . address _ family , socket _ type , protocol _ type ) ; -> if ( arg . connect _ by _ name _ error ! = null ) </%> <%> <+> { throw arg . connect _ by _ name _ error ; } </%>
{ <%> <*> return new socket ( end _ point . address _ family , socket _ type , protocol _ type ) ; -> if ( arg . connect _ by _ name _ error ! = null ) </%> <%> <+> { throw arg . connect _ by _ name _ error ; } var ex = new socket _ exception ( ( int ) arg . socket _ error ) ; throw ex ; </%> } <%> <+> var so = tut . args . connect _ socket ; </%>
} <%> <+> var so = tut . args . connect _ socket ; so . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; return so ; </%> } } }
{ continue ; } foreach ( j _ object asset in ( j _ array ) release [ STR ] ) { <%> <*> asset ass = new asset ( ) ; ass . parse ( asset ) ; if ( ass . is _ new _ version ( version ) ) -> asset ass = asset . parse _ asset ( asset ) ; </%> <%> <+> if ( ass ! = null ) </%>
{ <%> <+> ass . prerelease = is _ pre _ release ; if ( ass . is _ new _ version ( version , pre _ release , config . check _ pre _ release ) ) { </%> asserts . add ( ass ) ; <%> <+> } </%> } } } }
} } } } if ( asserts . count ! = 0 ) { sort _ by _ versions ( asserts ) ; asset asset = asserts [ asserts . count - 1 ] ; new _ version _ found = true ; latest _ version _ url = asset . browser _ download _ url ;
{ return false ; } if ( version = = null ) { return false ; } <%> <-> return compare _ version ( version , current _ version ) > 0 ; } public void parse ( j _ object asset ) </%>
} public static int compare _ version ( string l , string r ) { var ls = l . split ( '.' ) ; var rs = r . split ( '.' ) ; for ( int i = 0 ; i < math . max ( ls . length , rs . length ) ; i + + ) { int lp = ( i < ls . length ) ? int . parse ( ls [ i ] ) : 0 ; int rp = ( i < rs . length ) ? int . parse ( rs [ i ] ) : 0 ; if ( lp ! = rp )
} } private void pac _ server _ pac _ file _ changed ( object sender , event _ args e ) { update _ system _ proxy ( ) ; } private void start _ releasing _ memory ( ) { ram _ thread = new thread ( new thread _ start ( release _ memory ) ) ; ram _ thread . is _ background = true ;
break ; case power _ modes . suspend : controller ? . stop ( ) ; logging . info ( STR ) ; break ; <%> <+> } } private static void timer _ elapsed ( object sender , system . timers . elapsed _ event _ args e ) { try </%>
{ <%> <+> if ( ! established ) { </%> st . inner _ state . ex = new exception ( n . get _ string ( STR ) ) ; <%> <+> } </%> } st . inner _ state . callback ? . invoke ( st ) ; } private void on _ exception ( exception ex , object state ) {
} st . inner _ state . callback ? . invoke ( st ) ; } private void on _ exception ( exception ex , object state ) { var st = ( fake _ async _ result ) state ; st . inner _ state . ex = ex ; <%> <-> st . inner _ state . callback ? . invoke ( st ) ; </%> } private static readonly regex http _ respond _ header _ regex = new regex ( STR ) ;
} private static readonly regex http _ respond _ header _ regex = new regex ( STR ) ; private int respond _ line _ count = 0 ; private bool established = false ; private bool on _ line _ read ( string line , object state ) { logging . debug ( line ) ; if ( respond _ line _ count = = 0 ) { var m = http _ respond _ header _ regex . match ( line ) ;
return true ; } return false ; } catch ( argument _ exception ) { return false ; } } public string touch _ pac _ file ( )
byte [ ] plain = new byte [ plain . length + NUM ] ; int out _ len = 0 ; int out _ len = 0 ; var random = new random ( ) ; random . next _ bytes ( plain ) ; encryptor . encrypt ( plain , plain . length , cipher , out out _ len <%> <+> , false </%> ) ; decryptor . decrypt ( cipher , out _ len , plain , out out _ len ) ; assert . are _ equal ( plain . length , out _ len ) ; for ( int j = 0 ; j < plain . length ; j + + ) {
decryptor . decrypt ( cipher , out _ len , plain , out out _ len ) ; assert . are _ equal ( plain . length , out _ len ) ; for ( int j = 0 ; j < plain . length ; j + + ) { assert . are _ equal ( plain [ j ] , plain [ j ] ) ; } encryptor . encrypt ( plain , NUM , cipher , out out _ len <%> <+> , false </%> ) ; decryptor . decrypt ( cipher , out _ len , plain , out out _ len ) ; assert . are _ equal ( NUM , out _ len ) ; for ( int j = 0 ; j < out _ len ; j + + )
decryptor . decrypt ( cipher , out _ len , plain , out out _ len ) ; assert . are _ equal ( NUM , out _ len ) ; for ( int j = 0 ; j < out _ len ; j + + ) { assert . are _ equal ( plain [ j ] , plain [ j ] ) ; } encryptor . encrypt ( plain , NUM , cipher , out out _ len <%> <+> , false </%> ) ; decryptor . decrypt ( cipher , out _ len , plain , out out _ len ) ; assert . are _ equal ( NUM , out _ len ) ; for ( int j = 0 ; j < out _ len ; j + + )
decryptor . decrypt ( cipher , out _ len , plain , out out _ len ) ; assert . are _ equal ( NUM , out _ len ) ; for ( int j = 0 ; j < out _ len ; j + + ) { assert . are _ equal ( plain [ j ] , plain [ j ] ) ; } } private static bool encryption _ failed = false ; private static object locker = new object ( ) ; test _ method
public const int clen _ bytes = 2 ; public const int auth _ bytes = <%> <*> hash -> onetimeauth </%> _ bytes + clen _ bytes ; protected static byte [ ] tempbuf = new byte [ max _ input _ size ] ; protected dictionary < string , int [ ] > ciphers ; private static readonly dictionary < string , byte [ ] > cached _ keys = new dictionary < string , byte [ ] > ( ) ; protected byte [ ] encrypt _ iv ; protected byte [ ] decrypt _ iv ; protected bool decrypt _ iv _ received ; protected bool encrypt _ iv _ sent ; protected int encrypt _ iv _ offset = 0 ;
protected static byte [ ] tempbuf = new byte [ max _ input _ size ] ; protected dictionary < string , int [ ] > ciphers ; private static readonly dictionary < string , byte [ ] > cached _ keys = new dictionary < string , byte [ ] > ( ) ; protected byte [ ] encrypt _ iv ; protected byte [ ] decrypt _ iv ; protected bool decrypt _ iv _ received ; protected bool encrypt _ iv _ sent ; protected int encrypt _ iv _ offset = 0 ; protected int decrypt _ iv _ offset = 0 ; protected string method ;
if ( key _ buffer = = null ) { key _ buffer = new byte [ max _ iv _ length + NUM ] ; buffer . block _ copy ( encrypt _ iv , 0 , key _ buffer , 0 , iv _ len ) ; } byte [ ] counter _ bytes = bit _ converter . get _ bytes ( ( uint ) ip _ address . host _ to _ network _ order ( ( int ) counter ) ) ; buffer . block _ copy ( counter _ bytes , 0 , key _ buffer , iv _ len , NUM ) ; <%> <-> byte [ ] hash = new byte [ hash _ bytes ] ; byte [ ] tmp = new byte [ len ] ; buffer . block _ copy ( buf , offset , tmp , 0 , len ) ; </%>
counter + + ; <%> <-> len + = auth _ bytes ; offset + = len ; </%> } <%> <*> public override void encrypt -> protected byte [ ] gen _ hash </%> ( byte [ ] buf , int <%> <*> length -> offset </%> , <%> <-> byte [ ] outbuf , out </%> int <%> <*> outlength -> len </%> ) <%> <+> { byte [ ] hash = new byte [ NUM ] ; update _ key _ buffer ( ) ; sodium . ss _ sha _ hmac _ ex ( key _ buffer , ( uint ) key _ buffer . length , buf , offset , ( uint ) len , hash ) ; </%>
{ if ( ! encrypt _ iv _ sent ) { encrypt _ iv _ sent = true ; rand _ bytes ( outbuf , iv _ len ) ; init _ cipher ( outbuf , true ) ; outlength = length + iv _ len ; <%> <+> if ( onetime _ auth & & iv _ len > 0 ) { if ( ! udp ) </%>
cipher _ update ( true , length , buf , tempbuf ) ; outlength = length + iv _ len ; buffer . block _ copy ( tempbuf , 0 , outbuf , iv _ len , length ) ; } } else { if ( onetime _ auth <%> <*> ) -> & & iv _ len > 0 ) </%> { <%> <*> int offset = -> byte [ ] hash = gen _ hash ( buf , </%> 0 <%> <+> , length ) </%> ;
} outlength = length ; cipher _ update ( true , length , buf , outbuf ) ; } } public override void decrypt ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength ) { if ( ! decrypt _ iv _ received ) { decrypt _ iv _ received = true ;
array . copy ( data , NUM , data _ in , 0 , length - NUM ) ; byte [ ] data _ out = new byte [ length - NUM + NUM <%> <+> + iv _ encryptor . onetimeauth _ bytes </%> ] ; int outlen ; encryptor . encrypt ( data _ in , <%> <-> data _ in . </%> length <%> <+> - NUM </%> , data _ out , out outlen <%> <+> , true </%> ) ; remote . send _ to ( data _ out <%> <+> , outlen , socket _ flags . none </%> , remote _ end _ point ) ; } public void receive ( ) { end _ point remote _ end _ point = new ip _ end _ point ( ip _ address . any , 0 ) ; remote . begin _ receive _ from ( buffer , 0 , buffer . length , 0 , ref remote _ end _ point , new async _ callback ( recv _ from _ callback ) , null ) ;
int outlen ; encryptor . encrypt ( data _ in , <%> <-> data _ in . </%> length <%> <+> - NUM </%> , data _ out , out outlen <%> <+> , true </%> ) ; remote . send _ to ( data _ out <%> <+> , outlen , socket _ flags . none </%> , remote _ end _ point ) ; } public void receive ( ) { end _ point remote _ end _ point = new ip _ end _ point ( ip _ address . any , 0 ) ; remote . begin _ receive _ from ( buffer , 0 , buffer . length , 0 , ref remote _ end _ point , new async _ callback ( recv _ from _ callback ) , null ) ; } public void recv _ from _ callback ( i _ async _ result ar )
} public void receive ( ) { end _ point remote _ end _ point = new ip _ end _ point ( ip _ address . any , 0 ) ; remote . begin _ receive _ from ( buffer , 0 , buffer . length , 0 , ref remote _ end _ point , new async _ callback ( recv _ from _ callback ) , null ) ; } public void recv _ from _ callback ( i _ async _ result ar ) { try {
this . notify _ icon = new system . windows . forms . notify _ icon ( this . components ) ; this . context _ menu _ strip = new system . windows . forms . context _ menu _ strip ( this . components ) ; this . config _ item = new system . windows . forms . tool _ strip _ menu _ item ( ) ; this . quit _ item = new system . windows . forms . tool _ strip _ menu _ item ( ) ; this . table _ layout _ panel . suspend _ layout ( ) ; this . panel . suspend _ layout ( ) ; <%> <-> this . table _ layout _ panel . suspend _ layout ( ) ; </%>

this . controls . add ( this . table _ layout _ panel ) ; <%> <+> this . controls . add ( this . panel ) ; </%> this . name = STR ; <%> <+> this . start _ position = system . windows . forms . form _ start _ position . center _ screen ; </%> this . text = STR ; this . form _ closed + = new system . windows . forms . form _ closed _ event _ handler ( this . form _ form _ closed ) ; this . table _ layout _ panel . resume _ layout ( false ) ; this . table _ layout _ panel . perform _ layout ( ) ; this . panel . resume _ layout ( false ) ; <%> <-> this . table _ layout _ panel . resume _ layout ( false ) ; </%>
this . context _ menu _ strip . resume _ layout ( false ) ; this . resume _ layout ( false ) ; this . perform _ layout ( ) ; } private system . windows . forms . table _ layout _ panel table _ layout _ panel ; private system . windows . forms . label label ; private system . windows . forms . label label ; private system . windows . forms . label label ; private system . windows . forms . label label ; private system . windows . forms . text _ box text _ box ;
{ switch _ system _ proxy _ text _ box . text = config . switch _ system _ proxy ; switch _ proxy _ mode _ text _ box . text = config . switch _ system _ proxy _ mode ; switch _ allow _ lan _ text _ box . text = config . switch _ allow _ lan ; show _ logs _ text _ box . text = config . show _ logs ; server _ move _ up _ text _ box . text = config . server _ move _ up ; server _ move _ down _ text _ box . text = config . server _ move _ down ; } <%> <+> private void save _ config ( ) { </%>
{ message _ box . show ( n . get _ string ( STR ) ) ; } save _ config ( ) ; this . close ( ) ; } private void register _ all _ button _ click ( object sender , event _ args e ) { register _ all _ hotkeys ( <%> <-> out </%> ) ; }
{ bool is _ success = true ; <%> <-> string _ builder failure _ info = new string _ builder ( ) ; </%> foreach ( var tb in all _ text _ boxes ) { if ( tb . text . is _ null _ or _ empty ( ) ) { continue ; } if ( ! try _ reg _ hotkey ( tb ) )
foreach ( var tb in all _ text _ boxes ) { if ( tb . text . is _ null _ or _ empty ( ) ) { continue ; } if ( ! try _ reg _ hotkey ( tb ) ) { is _ success = false ; <%> <-> failure _ info . append _ line ( tb . text ) ; </%>
return is _ success ; } private bool try _ reg _ hotkey ( text _ box tb ) { var hotkey = hot _ keys . str _ hot _ key ( tb . text ) ; if ( hotkey = = null ) { message _ box . show ( string . format ( n . get _ string ( STR ) , tb . text ) ) ; tb . clear ( ) ; return false ;
privoxy _ config = privoxy _ config . replace ( STR , configuration . local _ port . to _ string ( ) ) ; privoxy _ config = privoxy _ config . replace ( STR , running _ port . to _ string ( ) ) ; <%> <*> privoxy _ config = privoxy _ config . replace ( STR , configuration . share _ over _ lan ? STR : STR ) ; -> privoxy _ config = configuration . is _ i _ pv _ enabled </%> <%> <+> ? privoxy _ config . replace ( STR , configuration . share _ over _ lan ? STR : STR ) . replace ( STR , STR ) : privoxy _ config . replace ( STR , configuration . share _ over _ lan ? STR : STR ) . replace ( STR , STR ) ; </%> file _ manager . byte _ array _ to _ file ( utils . get _ temp _ path ( unique _ config _ file ) , encoding . ut . get _ bytes ( privoxy _ config ) ) ; process = new process
file _ manager . byte _ array _ to _ file ( utils . get _ temp _ path ( unique _ config _ file ) , encoding . ut . get _ bytes ( privoxy _ config ) ) ; process = new process { start _ info = { file _ name = STR , arguments = unique _ config _ file , working _ directory = utils . get _ temp _ path ( ) , window _ style = process _ window _ style . hidden , use _ shell _ execute = true ,
{ int default _ port = NUM ; try { tcp _ listener l = new tcp _ listener ( <%> <+> is _ i _ pv ? ip _ address . i _ pv _ loopback : </%> ip _ address . loopback , 0 ) ; l . start ( ) ; var port = ( ( ip _ end _ point ) l . local _ endpoint ) . port ; l . stop ( ) ; return port ; }
l . start ( ) ; var port = ( ( ip _ end _ point ) l . local _ endpoint ) . port ; l . stop ( ) ; return port ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; return default _ port ; }
} configuration config ; bool share _ over _ lan ; socket tcp _ socket ; socket udp _ socket ; list < i _ service > services ; public listener ( list < i _ service > services ) { this . services = services ; }
tcp _ socket . set _ socket _ option ( socket _ option _ level . socket , socket _ option _ name . reuse _ address , true ) ; udp _ socket . set _ socket _ option ( socket _ option _ level . socket , socket _ option _ name . reuse _ address , true ) ; ip _ end _ point local _ end _ point = null ; local _ end _ point = share _ over _ lan ? new ip _ end _ point ( <%> <+> config . is _ i _ pv _ enabled ? ip _ address . i _ pv _ any : </%> ip _ address . any , config . local _ port ) : new ip _ end _ point ( <%> <+> config . is _ i _ pv _ enabled ? ip _ address . i _ pv _ loopback : </%> ip _ address . loopback , config . local _ port ) ; tcp _ socket . bind ( local _ end _ point ) ; udp _ socket . bind ( local _ end _ point ) ; tcp _ socket . listen ( NUM ) ; logging . info ( $ STR ) ;
tcp _ socket . bind ( local _ end _ point ) ; udp _ socket . bind ( local _ end _ point ) ; tcp _ socket . listen ( NUM ) ; logging . info ( $ STR ) ; if ( config . is _ verbose _ logging ) { logging . info ( encryption . encryptor _ factory . dump _ registered _ encryptor ( ) ) ; } tcp _ socket . begin _ accept ( new async _ callback ( accept _ callback ) , tcp _ socket ) ; <%> <-> udp _ state udp _ state = new udp _ state ( ) ; </%>
udp _ socket . begin _ receive _ from ( udp _ state . buffer , 0 , udp _ state . buffer . length , 0 , ref udp _ state . remote _ end _ point , new async _ callback ( recv _ from _ callback ) , udp _ state ) ; } catch ( socket _ exception ) { tcp _ socket . close ( ) ; throw ; } } public void stop ( ) {
logging . debug ( $ STR + buffer . length ) ; remote ? . begin _ receive _ from ( buffer , 0 , buffer . length , 0 , ref remote _ end _ point , new async _ callback ( recv _ from _ callback ) , null ) ; } public void recv _ from _ callback ( i _ async _ result ar ) { try { if ( remote = = null ) return ; end _ point remote _ end _ point = new ip _ end _ point ( <%> <+> get _ </%> ip _ address <%> <*> . any -> ( ) </%> , 0 ) ; int bytes _ read = remote . end _ receive _ from ( ar , ref remote _ end _ point ) ;
int bytes _ read = remote . end _ receive _ from ( ar , ref remote _ end _ point ) ; byte [ ] data _ out = new byte [ bytes _ read ] ; int outlen ; i _ encryptor encryptor = encryptor _ factory . get _ encryptor ( server . method , server . password ) ; encryptor . decrypt _ udp ( buffer , bytes _ read , data _ out , out outlen ) ; byte [ ] send _ buf = new byte [ outlen + NUM ] ; array . copy ( data _ out , 0 , send _ buf , NUM , outlen ) ; logging . debug ( local _ end _ point , remote _ end _ point , outlen , STR ) ; local ? . send _ to ( send _ buf , outlen + NUM , 0 , local _ end _ point ) ; receive ( ) ;
foreach ( i _ service service in services ) { if ( service . handle ( state . buffer , bytes _ read , <%> <-> udp _ </%> socket , state ) ) { break ; } } } catch ( object _ disposed _ exception ) {
{ break ; } } } catch ( object _ disposed _ exception ) { } catch ( exception ex ) {
public server get _ current _ server ( ) { return config . get _ current _ server ( ) ; } public configuration get _ configuration ( ) { return configuration . load ( ) ; <%> <+> } public void save _ servers ( list < server > servers ) { </%>
{ server server = get _ current _ server ( ) ; return get _ <%> <*> qr -> server </%> _ <%> <*> code -> url </%> ( server ) ; } public static string get _ <%> <*> qr -> server </%> _ <%> <*> code -> url </%> ( server server ) { string tag = string . empty ; string url = string . empty ; if ( string . is _ null _ or _ white _ space ( server . plugin ) ) {
} public void begin _ send ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) { remote <%> <+> ? </%> . begin _ send ( buffer , offset , size , socket _ flags , callback , state ) ; } public int end _ send ( i _ async _ result async _ result ) { return remote . end _ send ( async _ result ) ; }
} public int end _ send ( i _ async _ result async _ result ) { return remote . end _ send ( async _ result ) ; } public void begin _ receive ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) { remote <%> <+> ? </%> . begin _ receive ( buffer , offset , size , socket _ flags , callback , state ) ; }
} public int end _ receive ( i _ async _ result async _ result ) { return remote . end _ receive ( async _ result ) ; } public void shutdown ( socket _ shutdown how ) { remote ? . shutdown ( how ) ; } public void close ( )
} public int end _ send ( i _ async _ result async _ result ) { return remote . end _ send ( async _ result ) ; } public void begin _ receive ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) { remote <%> <+> ? </%> . begin _ receive ( buffer , offset , size , socket _ flags , callback , state ) ; }
} public int end _ receive ( i _ async _ result async _ result ) { return remote . end _ receive ( async _ result ) ; } public void shutdown ( socket _ shutdown how ) { remote ? . shutdown ( how ) ; } public void close ( )
} public void receive ( ) { end _ point remote _ end _ point = new ip _ end _ point ( ip _ address . any , 0 ) ; logging . debug ( $ STR + buffer . length ) ; remote <%> <+> ? </%> . begin _ receive _ from ( buffer , 0 , buffer . length , 0 , ref remote _ end _ point , new async _ callback ( recv _ from _ callback ) , null ) ; } public void recv _ from _ callback ( i _ async _ result ar ) { try
} public void recv _ from _ callback ( i _ async _ result ar ) { try { <%> <+> if ( remote = = null ) return ; </%> end _ point remote _ end _ point = new ip _ end _ point ( ip _ address . any , 0 ) ; int bytes _ read = remote . end _ receive _ from ( ar , ref remote _ end _ point ) ; byte [ ] data _ out = new byte [ bytes _ read ] ; int outlen ;
receive ( ) ; } catch ( object _ disposed _ exception ) { } catch ( exception ) { } finally {
using newtonsoft _ json ; namespace shadowsocks _ util _ system _ proxy { public static class sysproxy { private const string user _ wininet _ config _ file = STR ; private static string query _ str ; private static sysproxy _ config user _ settings = null ; enum ret _ errors : int {
{ <%> <-> process . start _ info . file _ name = utils . get _ temp _ path ( STR ) ; process . start _ info . arguments = arguments ; process . start _ info . working _ directory = utils . get _ temp _ path ( ) ; process . start _ info . window _ style = process _ window _ style . hidden ; process . start _ info . use _ shell _ execute = false ; process . start _ info . redirect _ standard _ error = true ; process . start _ info . redirect _ standard _ output = true ; process . start _ info . standard _ output _ encoding = encoding . unicode ; process . start _ info . standard _ error _ encoding = encoding . unicode ; </%>
{ <%> <*> throw new proxy _ exception ( stderr ) ; } if ( arguments = = STR ) { if ( stdout . is _ null _ or _ white _ space ( ) | | stdout . is _ null _ or _ empty ( ) ) -> process . start _ info . file _ name = utils . get _ temp _ path ( STR ) ; </%> <%> <+> process . start _ info . arguments = arguments ; process . start _ info . working _ directory = utils . get _ temp _ path ( ) ; process . start _ info . window _ style = process _ window _ style . hidden ; </%>
{ <%> <*> throw new proxy _ exception ( STR ) ; -> if ( e . data = = null ) </%> <%> <+> { output _ wait _ handle . set ( ) ; } else { output . append _ line ( e . data ) ; } </%>
} <%> <+> if ( arguments = = STR ) { if ( stdout . is _ null _ or _ white _ space ( ) | | stdout . is _ null _ or _ empty ( ) ) { throw new proxy _ exception ( STR ) ; } </%> query _ str = stdout ; <%> <+> } </%> } } }
} } } private static void save ( ) { try { using ( stream _ writer sw = new stream _ writer ( file . open ( utils . get _ temp _ path ( user _ wininet _ config _ file ) , file _ mode . create ) ) ) { string json _ string = json _ convert . serialize _ object ( user _ settings , formatting . indented ) ;
item . tag = strategy . id ; item . click + = a _ strategy _ item _ click ; items . add ( i , item ) ; i + + ; } <%> <+> int strategy _ count = i ; </%> configuration configuration = controller . get _ configuration _ copy ( ) ; foreach ( var server in configuration . configs ) { menu _ item item = new menu _ item ( server . friendly _ name ( ) ) ;

} public string id { <%> <*> get { -> get { </%> return STR ; <%> <+> } </%> } <%> <+> public void reload _ servers ( ) { </%> }
} public server get _ a _ server ( i _ strategy _ caller _ type type , ip _ end _ point local _ ip _ end _ point ) { var configs = controller . get _ current _ configuration ( ) . configs ; int index ; if ( type = = i _ strategy _ caller _ type . tcp ) { index = random . next ( ) ; } else
void update _ last _ read ( server server ) ; <%> <+> * tcp _ relay will call this when writing to a server * / </%> void update _ last _ write ( server server ) ; <%> <+> * tcp _ relay will call this when fatal failure detected * / </%> void set _ failure ( server server ) ; } }
this . remarks _ text _ box . name = STR ; this . remarks _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . remarks _ text _ box . tab _ index = NUM ; this . remarks _ text _ box . word _ wrap = false ; this . label . anchor = system . windows . forms . anchor _ styles . right ; this . label . auto _ size = true ; this . label . location = new system . drawing . point ( NUM , NUM ) ; <%> <-> this . label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ; </%> this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ;
this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ; this . label . tab _ index = NUM ; this . label . text = STR ; this . label . anchor = system . windows . forms . anchor _ styles . right ; this . label . auto _ size = true ; this . label . location = new system . drawing . point ( NUM , NUM ) ; <%> <-> this . label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ; </%> this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ;
this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ; this . label . tab _ index = 0 ; this . label . text = STR ; this . label . anchor = system . windows . forms . anchor _ styles . right ; this . label . auto _ size = true ; this . label . location = new system . drawing . point ( NUM , NUM ) ; <%> <-> this . label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ; </%> this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ;
this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ; this . label . tab _ index = 1 ; this . label . text = STR ; this . proxy _ port _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . proxy _ port _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; <%> <-> this . proxy _ port _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; </%> this . proxy _ port _ text _ box . name = STR ; this . proxy _ port _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . proxy _ port _ text _ box . tab _ index = NUM ;
this . proxy _ port _ text _ box . name = STR ; this . proxy _ port _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . proxy _ port _ text _ box . tab _ index = NUM ; this . proxy _ port _ text _ box . word _ wrap = false ; this . label . anchor = system . windows . forms . anchor _ styles . right ; this . label . auto _ size = true ; this . label . location = new system . drawing . point ( NUM , NUM ) ; <%> <-> this . label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ; </%> this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ;
this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ; this . label . tab _ index = NUM ; this . label . text = STR ; this . label . anchor = system . windows . forms . anchor _ styles . right ; this . label . auto _ size = true ; this . label . location = new system . drawing . point ( NUM , NUM ) ; <%> <-> this . label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ; </%> this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ;
this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ; this . label . tab _ index = 2 ; this . label . text = STR ; this . ip _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . ip _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; <%> <-> this . ip _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; </%> this . ip _ text _ box . name = STR ; this . ip _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . ip _ text _ box . tab _ index = 0 ;
this . ip _ text _ box . name = STR ; this . ip _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . ip _ text _ box . tab _ index = 0 ; this . ip _ text _ box . word _ wrap = false ; this . server _ port _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . server _ port _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; <%> <-> this . server _ port _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; </%> this . server _ port _ text _ box . name = STR ; this . server _ port _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . server _ port _ text _ box . tab _ index = 1 ;
this . server _ port _ text _ box . name = STR ; this . server _ port _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . server _ port _ text _ box . tab _ index = 1 ; this . server _ port _ text _ box . word _ wrap = false ; this . password _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . password _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; <%> <-> this . password _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; </%> this . password _ text _ box . name = STR ; this . password _ text _ box . password _ char = '*' ; this . password _ text _ box . size = new system . drawing . size ( NUM , NUM ) ;
this . password _ text _ box . name = STR ; this . password _ text _ box . password _ char = '*' ; this . password _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . password _ text _ box . tab _ index = 2 ; this . password _ text _ box . word _ wrap = false ; this . label . anchor = system . windows . forms . anchor _ styles . right ; this . label . auto _ size = true ; this . label . location = new system . drawing . point ( NUM , NUM ) ; <%> <-> this . label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ; </%> this . label . name = STR ;
this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ; this . label . tab _ index = NUM ; this . label . text = STR ; this . encryption _ select . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( ( system . windows . forms . anchor _ styles . top | system . windows . forms . anchor _ styles . left ) | system . windows . forms . anchor _ styles . right ) ) ) ; this . encryption _ select . drop _ down _ style = system . windows . forms . combo _ box _ style . drop _ down _ list ; this . encryption _ select . formatting _ enabled = true ; this . encryption _ select . ime _ mode = system . windows . forms . ime _ mode . no _ control ; this . encryption _ select . item _ height = NUM ;
this . encryption _ select . name = STR ; this . encryption _ select . size = new system . drawing . size ( NUM , NUM ) ; this . encryption _ select . tab _ index = NUM ; this . notify _ icon . text = STR ; this . notify _ icon . double _ click + = new system . event _ handler ( this . notify _ icon _ double _ click ) ; this . panel . anchor = system . windows . forms . anchor _ styles . top ; this . panel . auto _ size = true ; this . panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . panel . location = new system . drawing . point ( NUM , NUM ) ; <%> <-> this . panel . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; </%>
this . panel . name = STR ; this . panel . size = new system . drawing . size ( 0 , 0 ) ; this . panel . tab _ index = 1 ; this . ok _ button . dialog _ result = system . windows . forms . dialog _ result . ok ; this . ok _ button . location = new system . drawing . point ( NUM , NUM ) ; <%> <-> this . ok _ button . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; </%> this . ok _ button . name = STR ; this . ok _ button . size = new system . drawing . size ( NUM , NUM ) ; this . ok _ button . tab _ index = NUM ; this . ok _ button . text = STR ;
this . ok _ button . name = STR ; this . ok _ button . size = new system . drawing . size ( NUM , NUM ) ; this . ok _ button . tab _ index = NUM ; this . ok _ button . text = STR ; this . ok _ button . use _ visual _ style _ back _ color = true ; this . ok _ button . click + = new system . event _ handler ( this . ok _ button _ click ) ; this . my _ cancel _ button . dialog _ result = system . windows . forms . dialog _ result . cancel ; this . my _ cancel _ button . location = new system . drawing . point ( NUM , NUM ) ; <%> <-> this . my _ cancel _ button . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; </%> this . my _ cancel _ button . name = STR ;
this . my _ cancel _ button . name = STR ; this . my _ cancel _ button . size = new system . drawing . size ( NUM , NUM ) ; this . my _ cancel _ button . tab _ index = NUM ; this . my _ cancel _ button . text = STR ; this . my _ cancel _ button . use _ visual _ style _ back _ color = true ; this . my _ cancel _ button . click + = new system . event _ handler ( this . cancel _ button _ click ) ; this . panel . auto _ size = true ; this . panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . panel . controls . add ( this . my _ cancel _ button ) ; this . panel . controls . add ( this . ok _ button ) ;
this . share _ over _ lan _ item , this . <%> <*> servers -> edit _ pac _ file </%> _ item , this . menu _ item , <%> <-> this . edit _ pac _ file _ item , </%> this . qr _ code _ item , this . show _ log _ item , this . about _ item , this . menu _ item , this . quit _ item } ) ; <%> <-> this . context _ menu . popup + = new system . event _ handler ( this . context _ menu _ popup ) ; </%>
this . menu _ item , <%> <-> this . edit _ pac _ file _ item , </%> this . qr _ code _ item , this . show _ log _ item , this . about _ item , this . menu _ item , this . quit _ item } ) ; <%> <-> this . context _ menu . popup + = new system . event _ handler ( this . context _ menu _ popup ) ; </%> this . enable _ item . index = 0 ; this . enable _ item . text = STR ;
this . qr _ code _ item , this . show _ log _ item , this . about _ item , this . menu _ item , this . quit _ item } ) ; <%> <-> this . context _ menu . popup + = new system . event _ handler ( this . context _ menu _ popup ) ; </%> this . enable _ item . index = 0 ; this . enable _ item . text = STR ; this . enable _ item . click + = new system . event _ handler ( this . enable _ item _ click ) ; <%> <+> this . auto _ startup _ item . index = NUM ; </%>
this . enable _ item . index = 0 ; this . enable _ item . text = STR ; this . enable _ item . click + = new system . event _ handler ( this . enable _ item _ click ) ; <%> <+> this . auto _ startup _ item . index = NUM ; this . auto _ startup _ item . text = STR ; this . auto _ startup _ item . click + = new system . event _ handler ( this . auto _ startup _ item _ click ) ; </%> this . share _ over _ lan _ item . index = <%> <*> 2 -> NUM </%> ; this . share _ over _ lan _ item . text = STR ; this . share _ over _ lan _ item . click + = new system . event _ handler ( this . share _ over _ lan _ item _ click ) ; this . servers _ item . index = <%> <*> NUM -> 1 </%> ;
this . share _ over _ lan _ item . text = STR ; this . share _ over _ lan _ item . click + = new system . event _ handler ( this . share _ over _ lan _ item _ click ) ; this . servers _ item . index = <%> <*> NUM -> 1 </%> ; this . servers _ item . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . seperator _ item , this . config _ item } ) ; this . servers _ item . text = STR ; this . seperator _ item . index = 0 ; this . seperator _ item . text = STR ; this . config _ item . index = 1 ;
this . servers _ item . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . seperator _ item , this . config _ item } ) ; this . servers _ item . text = STR ; this . seperator _ item . index = 0 ; this . seperator _ item . text = STR ; this . config _ item . index = 1 ; this . config _ item . text = STR ; this . config _ item . click + = new system . event _ handler ( this . config _ click ) ; this . menu _ item . index = NUM ;
this . delete _ button . name = STR ; this . delete _ button . size = new system . drawing . size ( NUM , NUM ) ; this . delete _ button . tab _ index = NUM ; this . delete _ button . text = STR ; this . delete _ button . use _ visual _ style _ back _ color = true ; this . delete _ button . click + = new system . event _ handler ( this . delete _ button _ click ) ; this . add _ button . location = new system . drawing . point ( NUM , NUM ) ; <%> <-> this . add _ button . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; </%> this . add _ button . name = STR ; this . add _ button . size = new system . drawing . size ( NUM , NUM ) ;
this . add _ button . name = STR ; this . add _ button . size = new system . drawing . size ( NUM , NUM ) ; this . add _ button . tab _ index = NUM ; this . add _ button . text = STR ; this . add _ button . use _ visual _ style _ back _ color = true ; this . add _ button . click + = new system . event _ handler ( this . add _ button _ click ) ; this . server _ group _ box . controls . add ( this . table _ layout _ panel ) ; this . server _ group _ box . location = new system . drawing . point ( NUM , NUM ) ; <%> <-> this . server _ group _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; </%> this . server _ group _ box . name = STR ;
this . server _ group _ box . name = STR ; <%> <-> this . server _ group _ box . padding = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; </%> this . server _ group _ box . size = new system . drawing . size ( NUM , NUM ) ; this . server _ group _ box . tab _ index = NUM ; this . server _ group _ box . tab _ stop = false ; this . server _ group _ box . text = STR ; this . servers _ list _ box . formatting _ enabled = true ; <%> <-> this . servers _ list _ box . item _ height = NUM ; </%> this . servers _ list _ box . location = new system . drawing . point ( NUM , NUM ) ; <%> <-> this . servers _ list _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; </%>
this . server _ group _ box . tab _ index = NUM ; this . server _ group _ box . tab _ stop = false ; this . server _ group _ box . text = STR ; this . servers _ list _ box . formatting _ enabled = true ; <%> <-> this . servers _ list _ box . item _ height = NUM ; </%> this . servers _ list _ box . location = new system . drawing . point ( NUM , NUM ) ; <%> <-> this . servers _ list _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; </%> this . servers _ list _ box . name = STR ; this . servers _ list _ box . size = new system . drawing . size ( NUM , NUM ) ; this . servers _ list _ box . tab _ index = NUM ;
this . servers _ list _ box . name = STR ; this . servers _ list _ box . size = new system . drawing . size ( NUM , NUM ) ; this . servers _ list _ box . tab _ index = NUM ; this . servers _ list _ box . selected _ index _ changed + = new system . event _ handler ( this . servers _ list _ box _ selected _ index _ changed ) ; <%> <-> this . auto _ startup . index = 1 ; </%> this . <%> <*> auto -> menu </%> _ <%> <*> startup -> item </%> . <%> <*> text -> index </%> = <%> <*> STR -> 2 </%> ; this . <%> <*> auto -> menu </%> _ <%> <*> startup -> item </%> . <%> <*> click + -> text </%> = <%> <*> new system . event _ handler ( this . auto _ startup _ click ) ; -> STR ; </%> this . accept _ button = this . ok _ button ; this . auto _ scale _ mode = system . windows . forms . auto _ scale _ mode . dpi ; this . auto _ size = true ;
this . accept _ button = this . ok _ button ; this . auto _ scale _ mode = system . windows . forms . auto _ scale _ mode . dpi ; this . auto _ size = true ; this . cancel _ button = this . my _ cancel _ button ; this . client _ size = new system . drawing . size ( NUM , NUM ) ; this . controls . add ( this . servers _ list _ box ) ; this . controls . add ( this . server _ group _ box ) ; this . controls . add ( this . panel ) ; this . controls . add ( this . panel ) ; this . controls . add ( this . panel ) ;
message _ box . show ( STR ) ; } } <%> <-> private void context _ menu _ popup ( object sender , event _ args e ) { auto _ startup . checked = auto _ startup . check ( ) ; } </%> } }
} }
notify _ icon . balloon _ tip _ clicked - = notify _ icon _ balloon _ tip _ clicked ; <%> <+> string argument = STR + update _ checker . latest _ version _ local _ name + STR ; system . diagnostics . process . start ( STR , argument ) ; </%>
using system _ collections ; using system _ collections _ generic ; using system _ net ; using system _ reflection ; using system _ text ; using system _ text _ regular _ expressions ; <%> <+> using system _ io ; </%> using simple _ json ; <%> <+> using shadowsocks _ model ; using shadowsocks _ util ; </%>
{ <%> <*> int lp = ( i < ls . length ) ? int . parse ( ls [ i ] ) : 0 ; int rp = ( i < rs . length ) ? int . parse ( rs [ i ] ) : 0 ; if ( lp ! = rp ) { return lp - rp ; } -> web _ client http = create _ web _ client ( ) ; </%> <%> <+> http . download _ string _ completed + = http _ download _ string _ completed ; http . download _ string _ async ( new uri ( update _ url ) ) ; </%>
} <%> <*> return 0 ; } public class version _ comparer : i _ comparer < string > { public int compare ( string x , string y ) -> catch ( exception ex ) </%> { <%> <*> return compare _ version ( parse _ version _ from _ url ( x ) , parse _ version -> logging . log </%> _ <%> <*> from -> useful </%> _ <%> <*> url -> exception </%> ( <%> <*> y ) -> ex </%> ) ; }
{ <%> <*> return compare _ version ( parse _ version _ from _ url ( x ) , parse _ version -> logging . log </%> _ <%> <*> from -> useful </%> _ <%> <*> url -> exception </%> ( <%> <*> y ) -> ex </%> ) ; } <%> <-> } private static string parse _ version _ from _ url ( string url ) { match match = regex . match ( url , STR , regex _ options . ignore _ case ) ; if ( match . success ) { if ( match . groups . count = = 2 ) </%>
} <%> <-> } private static string parse _ version _ from _ url ( string url ) { match match = regex . match ( url , STR , regex _ options . ignore _ case ) ; if ( match . success ) { if ( match . groups . count = = 2 ) { return match . groups [ 1 ] . value ; </%>
} private void http _ download _ string _ completed ( object sender , download _ string _ completed _ event _ args e ) { try { string response = e . result ; json _ array result = ( json _ array ) simple _ json . simple _ json . deserialize _ object ( e . result ) ; list < <%> <*> string -> asset </%> > <%> <*> versions -> asserts </%> = new list < <%> <*> string -> asset </%> > ( ) ; foreach ( json _ object release in result ) {
foreach ( json _ object release in result ) { if ( ( bool ) release [ STR ] ) { continue ; } foreach ( json _ object asset in ( json _ array ) release [ STR ] ) { <%> <-> string url = ( string ) asset [ STR ] ; if ( is _ new _ version ( url ) ) </%>
{ <%> <*> versions -> asserts </%> . add ( <%> <*> url -> ass </%> ) ; } } } if ( <%> <*> versions -> asserts </%> . count ! = 0 ) { <%> <+> sort _ by _ versions ( asserts ) ; </%> <%> <*> sort _ versions ( versions ) -> asset asset = asserts [ asserts . count - 1 ] </%> ; new _ version _ found = true ;
} } } if ( <%> <*> versions -> asserts </%> . count ! = 0 ) { <%> <+> sort _ by _ versions ( asserts ) ; </%> <%> <*> sort _ versions ( versions ) -> asset asset = asserts [ asserts . count - 1 ] </%> ; new _ version _ found = true ; <%> <-> latest _ version _ url = versions [ versions . count - 1 ] ; latest _ version _ number = parse _ version _ from _ url ( latest _ version _ url ) ; </%>
{ <%> <+> sort _ by _ versions ( asserts ) ; </%> <%> <*> sort _ versions ( versions ) -> asset asset = asserts [ asserts . count - 1 ] </%> ; new _ version _ found = true ; <%> <*> latest _ version _ url = versions [ versions . count - 1 ] ; latest _ version _ number = parse _ version _ from _ url ( latest _ version _ url ) ; -> latest _ version _ url = asset . browser _ download _ url ; </%> <%> <+> latest _ version _ number = asset . version ; latest _ version _ name = asset . name ; start _ download ( ) ; </%>
new _ version _ found = true ; <%> <*> latest _ version _ url = versions [ versions . count - 1 ] ; latest _ version _ number = parse _ version _ from _ url ( latest _ version _ url ) ; -> latest _ version _ url = asset . browser _ download _ url ; </%> <%> <+> latest _ version _ number = asset . version ; latest _ version _ name = asset . name ; start _ download ( ) ; } else if ( check _ update _ completed ! = null ) { </%>
} if ( check _ update _ completed ! = null ) { check _ update _ completed ( this , new event _ args ( ) ) ; } } catch ( exception ex ) { <%> <-> logging . debug ( ex . to _ string ( ) ) ; return ; </%>
} } } }
{ try { string pac = get _ pac _ content ( ) ; ip _ end _ point local _ end _ point = ( ip _ end _ point ) socket . local _ end _ point ; string proxy = get _ pac _ address ( first _ packet , length , local _ end _ point <%> <+> , use _ socks </%> ) ; pac = pac . replace ( STR , proxy ) ; string text = string . format ( @ STR server : shadowsocks content - type : application / x - ns - proxy - autoconfig
pac = pac . replace ( STR , proxy ) ; string text = string . format ( @ STR server : shadowsocks content - type : application / x - ns - proxy - autoconfig content - length : { 0 } connection : close STR byte [ ] response = system . text . encoding . ut . get _ bytes ( text ) ; socket . begin _ send ( response , 0 , response . length , 0 , new async _ callback ( send _ callback ) , socket ) ; util . utils . release _ memory ( ) ;
{ <%> <*> return STR + local _ end _ point . address + STR + this . config . local _ port + STR ; -> return ( use _ socks ? STR : STR ) + local _ end _ point . address + STR + this . config . local _ port + STR ; </%> } } }
} } }
polipo _ config = polipo _ config . replace ( STR , configuration . share _ over _ lan ? STR : STR ) ; file _ manager . byte _ array _ to _ file ( temppath + STR , system . text . encoding . ut . get _ bytes ( polipo _ config ) ) ; process = new process ( ) ; process . start _ info . file _ name = temppath + STR ; process . start _ info . arguments = STR + temppath + STR ; process . start _ info . window _ style = process _ window _ style . hidden ; process . start _ info . use _ shell _ execute = true ; process . start _ info . create _ no _ window = true ; process . start ( ) ; }
sysproxy . set _ ie _ proxy ( true , false , STR , pac _ url ) ; } } else { sysproxy . set _ ie _ proxy ( false , false , STR , STR ) ; } } catch ( proxy _ exception ex ) {
server = > new key _ value _ pair < string , string > ( server . <%> <+> get _ url ( config . generate _ legacy _ </%> url <%> <+> ) </%> , server . to _ string ( ) ) ) . to _ list ( ) ; list _ box . data _ source = server _ datas ; <%> <*> var -> int </%> select _ index = server _ datas . find _ index ( server _ data = > server _ data . key . starts _ with ( code ) ) ; if ( select _ index > = 0 ) list _ box . set _ selected ( select _ index , true ) ; } private void list _ box _ selected _ index _ changed ( object sender , event _ args e ) { var url = ( sender as list _ box ) ? . selected _ value . to _ string ( ) ;
) . to _ list ( ) ; list _ box . data _ source = server _ datas ; <%> <*> var -> int </%> select _ index = server _ datas . find _ index ( server _ data = > server _ data . key . starts _ with ( code ) ) ; if ( select _ index > = 0 ) list _ box . set _ selected ( select _ index , true ) ; } private void list _ box _ selected _ index _ changed ( object sender , event _ args e ) { var url = ( sender as list _ box ) ? . selected _ value . to _ string ( ) ; gen _ qr ( url ) ; text _ box _ url . text = url ;
if ( select _ index > = 0 ) list _ box . set _ selected ( select _ index , true ) ; } private void list _ box _ selected _ index _ changed ( object sender , event _ args e ) { var url = ( sender as list _ box ) ? . selected _ value . to _ string ( ) ; gen _ qr ( url ) ; text _ box _ url . text = url ; } private void text _ box _ url _ click ( object sender , event _ args e ) {
string plugin _ part = plugin ; if ( ! string . is _ null _ or _ white _ space ( plugin _ opts ) ) { plugin _ part + = STR + plugin _ opts ; } <%> <-> url = string . format ( STR , websafe _ base , </%> <%> <*> formal -> string plugin _ query = STR + http _ utility . url </%> _ <%> <*> host -> encode ( plugin </%> _ <%> <*> name -> part </%> , <%> <+> encoding . ut ) ; </%> <%> <*> server -> url + = plugin </%> _ <%> <*> port , -> query ; </%>
} public string formal _ host _ name { get { switch ( uri . check _ host _ name ( server ) ) { case uri _ host _ name _ type . i _ pv : return $ STR ; default :
func < string , object , bool > on _ line _ read , action < exception , object > on _ exception , action < byte [ ] , int , int , object > on _ finish , encoding encoding , string delimiter , <%> <+> int max _ line _ bytes , </%> object state ) { <%> <-> if ( buffer = = null ) { throw new argument _ null _ exception ( nameof ( buffer ) ) ; } </%> if ( socket = = null )
object state ) { <%> <-> if ( buffer = = null ) { throw new argument _ null _ exception ( nameof ( buffer ) ) ; } </%> if ( socket = = null ) { throw new argument _ null _ exception ( nameof ( socket ) ) ; }
if ( socket = = null ) { throw new argument _ null _ exception ( nameof ( socket ) ) ; } if ( on _ line _ read = = null ) { throw new argument _ null _ exception ( nameof ( on _ line _ read ) ) ; } if ( encoding = = null ) {
{ throw new argument _ exception ( STR , nameof ( <%> <*> buffer -> max _ line _ bytes </%> ) ) ; } if ( length > 0 ) { if ( first _ packge = = null ) { throw new argument _ null _ exception ( nameof ( first _ packge ) ) ; } }
} if ( length > 0 ) { if ( first _ packge = = null ) { throw new argument _ null _ exception ( nameof ( first _ packge ) ) ; } } socket = socket ; on _ line _ read = on _ line _ read ;
{ throw new argument _ exception ( STR , nameof ( <%> <*> buffer -> max _ line _ bytes </%> ) ) ; } delimiter _ search = new byte _ search . search _ target ( delimiter _ bytes ) ; line _ buffer = <%> <*> buffer ; -> new byte [ max _ line _ bytes ] ; </%> if ( length > 0 ) { <%> <-> if ( buffer = = first _ packge ) { buffer _ data _ index = index ; </%>
} delimiter _ search = new byte _ search . search _ target ( delimiter _ bytes ) ; line _ buffer = <%> <*> buffer ; -> new byte [ max _ line _ bytes ] ; </%> if ( length > 0 ) { <%> <-> if ( buffer = = first _ packge ) { buffer _ data _ index = index ; } else </%>
if ( length > 0 ) { <%> <-> if ( buffer = = first _ packge ) { buffer _ data _ index = index ; } else { </%> array . copy ( first _ packge , index , line _ buffer , 0 , length ) ; <%> <-> } </%>
buffer _ data _ length = length ; try { new _ package _ recv ( ) ; } catch ( exception ex ) { on _ exception ( ex ) ; on _ finish ( ) ; }
} } <%> <*> public line _ reader ( int max _ line _ bytes , wrapped _ socket socket , func < string , object , bool > on _ line _ read , action < exception , object > on _ exception , action < byte [ ] , int , int , object > on _ finish , encoding encoding , string delimiter , object state ) : this ( new byte [ max _ line _ bytes ] , socket , null , 0 , 0 , on _ line _ read , on _ exception , on _ finish , encoding , delimiter , state ) -> public line _ reader ( wrapped _ socket socket , func < string , object , bool > on _ line _ read , </%> <%> <+> action < exception , object > on _ exception , </%>
{ } private void receive _ callback ( i _ async _ result ar ) { try { var bytes _ read = socket . end _ receive ( ar ) ; if ( bytes _ read = = 0 ) { on _ finish ( ) ;
} else { string pac _ url ; if ( config . use _ online _ pac & & ! config . pac _ url . is _ null _ or _ empty ( ) ) pac _ url = config . pac _ url ; else pac _ url = $ STR ; <%> <*> win _ i _ net -> sysproxy </%> . set _ ie _ proxy ( true , false , STR , pac _ url ) ; }
if ( ss _ url _ association = = null ) { logger . error ( STR ) ; return false ; } if ( enabled ) { ss _ url _ association . set _ value ( STR , STR ) ; ss _ url _ association . set _ value ( STR , STR ) ; var shell _ open = ss _ url _ association . create _ sub _ key ( STR ) . create _ sub _ key ( STR ) . create _ sub _ key ( STR ) ;
string config _ content = file . read _ all _ text ( config _ file ) ; configuration config = simple _ json . simple _ json . deserialize _ object < configuration > ( config _ content <%> <+> , new json _ serializer _ strategy ( ) </%> ) ; config . is _ default = false ; return config ; } catch ( exception e ) { if ( ! ( e is file _ not _ found _ exception ) ) { console . write _ line ( e ) ;
config . is _ default = false ; return config ; } catch ( exception e ) { if ( ! ( e is file _ not _ found _ exception ) ) { console . write _ line ( e ) ; } return new configuration
using ( graphics g = graphics . from _ image ( draw _ area ) ) { g . clear ( color . white ) ; using ( brush b = new solid _ brush ( color . black ) ) { for ( int row = 0 ; row < <%> <*> qr _ coded -> m </%> . <%> <*> get _ module _ count ( ) -> height </%> ; row + + ) { for ( int col = 0 ; col < <%> <*> qr _ coded -> m </%> . <%> <*> get _ module _ count ( ) -> height </%> ; col + + ) { if ( <%> <*> qr _ coded . is _ dark ( -> m [ </%> row , col <%> <*> ) -> ] ! = 0 </%> )
{ for ( int col = 0 ; col < <%> <*> qr _ coded -> m </%> . <%> <*> get _ module _ count ( ) -> height </%> ; col + + ) { if ( <%> <*> qr _ coded . is _ dark ( -> m [ </%> row , col <%> <*> ) -> ] ! = 0 </%> ) { g . fill _ rectangle ( b , block _ size * row , block _ size * col , block _ size , block _ size ) ; } } } }
{ if ( <%> <*> qr _ coded . is _ dark ( -> m [ </%> row , col <%> <*> ) -> ] ! = 0 </%> ) { g . fill _ rectangle ( b , block _ size * row , block _ size * col , block _ size , block _ size ) ; } } } } } picture _ box . image = draw _ area ;
{ g . fill _ rectangle ( b , block _ size * row , block _ size * col , block _ size , block _ size ) ; } } } } } picture _ box . image = draw _ area ; } private void qr _ code _ form _ load ( object sender , event _ args e )
} private menu _ item create _ menu _ group ( string text , menu _ item [ ] items ) { <%> <*> for ( int i = 0 ; i < items . length ; i + + ) { items [ i ] . index = i ; } menu _ item result = new menu _ item ( n . get _ string ( text ) , items ) ; return result ; -> return new menu _ item ( n . get _ string ( text ) , items ) ; </%>
} private void load _ menu ( ) { this . context _ menu = new system . windows . forms . context _ menu ( ) ; this . context _ menu . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . enable _ item = create _ menu _ item ( STR , new system . event _ handler ( this . enable _ item _ click ) ) , create _ menu _ group ( STR , new system . windows . forms . menu _ item [ ] { this . pac _ mode _ item = create _ menu _ item ( STR , new system . event _ handler ( this . pac _ mode _ item _ click ) ) , this . global _ mode _ item = create _ menu _ item ( STR , new system . event _ handler ( this . global _ mode _ item _ click ) ) } ) ,
this . config _ item = create _ menu _ item ( STR , new system . event _ handler ( this . config _ click ) ) } ) , <%> <*> create _ seperator -> new menu </%> _ item ( <%> <+> STR </%> ) , this . auto _ startup _ item = create _ menu _ item ( STR , new system . event _ handler ( this . auto _ startup _ item _ click ) ) , this . share _ over _ lan _ item = create _ menu _ item ( STR , new system . event _ handler ( this . share _ over _ lan _ item _ click ) ) , create _ menu _ item ( STR , new system . event _ handler ( this . edit _ pac _ file _ item _ click ) ) , <%> <*> create _ seperator -> new menu </%> _ item ( <%> <+> STR </%> ) , create _ menu _ item ( STR , new system . event _ handler ( this . qr _ code _ item _ click ) ) , create _ menu _ item ( STR , new system . event _ handler ( this . show _ log _ item _ click ) ) , create _ menu _ item ( STR , new system . event _ handler ( this . config _ click ) ) ,
this . auto _ startup _ item = create _ menu _ item ( STR , new system . event _ handler ( this . auto _ startup _ item _ click ) ) , this . share _ over _ lan _ item = create _ menu _ item ( STR , new system . event _ handler ( this . share _ over _ lan _ item _ click ) ) , create _ menu _ item ( STR , new system . event _ handler ( this . edit _ pac _ file _ item _ click ) ) , <%> <*> create _ seperator -> new menu </%> _ item ( <%> <+> STR </%> ) , create _ menu _ item ( STR , new system . event _ handler ( this . qr _ code _ item _ click ) ) , create _ menu _ item ( STR , new system . event _ handler ( this . show _ log _ item _ click ) ) , create _ menu _ item ( STR , new system . event _ handler ( this . config _ click ) ) , <%> <*> create _ seperator -> new menu </%> _ item ( <%> <+> STR </%> ) , create _ menu _ item ( STR , new system . event _ handler ( this . quit _ click ) ) } ) ;
create _ menu _ item ( STR , new system . event _ handler ( this . qr _ code _ item _ click ) ) , create _ menu _ item ( STR , new system . event _ handler ( this . show _ log _ item _ click ) ) , create _ menu _ item ( STR , new system . event _ handler ( this . config _ click ) ) , <%> <*> create _ seperator -> new menu </%> _ item ( <%> <+> STR </%> ) , create _ menu _ item ( STR , new system . event _ handler ( this . quit _ click ) ) } ) ; } private void controller _ config _ changed ( object sender , event _ args e ) { load _ current _ configuration ( ) ;
create _ menu _ item ( STR , new system . event _ handler ( this . quit _ click ) ) } ) ; } private void controller _ config _ changed ( object sender , event _ args e ) { load _ current _ configuration ( ) ; update _ tray _ icon ( ) ; } private void controller _ enable _ status _ changed ( object sender , event _ args e ) {
{ byte [ ] bytes = convert . from _ base _ string ( response ) ; string content = encoding . ascii . get _ string ( bytes ) ; <%> <+> return parse _ to _ valid _ list ( content ) ; } private static list < string > parse _ to _ valid _ list ( string content ) { </%> list < string > valid _ lines = new list < string > ( ) ; using ( var sr = new string _ reader ( content ) ) {
} else { arguments = <%> <+> $ </%> STR <%> <-> + pac _ url </%> ; } } else { arguments = STR ; }
} } else { arguments = STR ; } using ( var process = new process ( ) ) { process . start _ info . file _ name = utils . get _ temp _ path ( STR ) ; process . start _ info . arguments = arguments ;
controller . enable _ status _ changed + = controller _ enable _ status _ changed ; controller . config _ changed + = controller _ config _ changed ; controller . pac _ file _ ready _ to _ open + = controller _ pac _ file _ ready _ to _ open ; controller . share _ over _ lan _ status _ changed + = controller _ share _ over _ lan _ status _ changed ; controller . enable _ global _ changed + = controller _ enable _ global _ changed ; controller . errored + = controller _ errored ; <%> <+> notify _ icon = new notify _ icon ( ) ; load _ tray _ icon ( ) ; notify _ icon . visible = true ; notify _ icon . text = n . get _ string ( STR ) ; </%>
this . enable _ item . click + = new system . event _ handler ( this . enable _ item _ click ) ; this . mode _ item . index = 1 ; this . mode _ item . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . pac _ mode _ item , this . global _ mode _ item } ) ; this . mode _ item . text = <%> <+> n . get _ string ( </%> STR <%> <+> ) </%> ; this . pac _ mode _ item . index = 0 ; this . pac _ mode _ item . text = <%> <+> n . get _ string ( </%> STR <%> <+> ) </%> ; this . pac _ mode _ item . click + = new system . event _ handler ( this . pac _ mode _ item _ click ) ; this . global _ mode _ item . index = 1 ;
this . pac _ mode _ item . index = 0 ; this . pac _ mode _ item . text = <%> <+> n . get _ string ( </%> STR <%> <+> ) </%> ; this . pac _ mode _ item . click + = new system . event _ handler ( this . pac _ mode _ item _ click ) ; this . global _ mode _ item . index = 1 ; this . global _ mode _ item . text = <%> <+> n . get _ string ( </%> STR <%> <+> ) </%> ; this . global _ mode _ item . click + = new system . event _ handler ( this . global _ mode _ item _ click ) ; this . servers _ item . index = 2 ; this . servers _ item . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . seperator _ item , this . config _ item } ) ;
this . pac _ mode _ item . click + = new system . event _ handler ( this . pac _ mode _ item _ click ) ; this . global _ mode _ item . index = 1 ; this . global _ mode _ item . text = <%> <+> n . get _ string ( </%> STR <%> <+> ) </%> ; this . global _ mode _ item . click + = new system . event _ handler ( this . global _ mode _ item _ click ) ; this . servers _ item . index = 2 ; this . servers _ item . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . seperator _ item , this . config _ item } ) ; this . servers _ item . text = <%> <+> n . get _ string ( </%> STR <%> <+> ) </%> ; this . seperator _ item . index = 0 ;
this . global _ mode _ item . click + = new system . event _ handler ( this . global _ mode _ item _ click ) ; this . servers _ item . index = 2 ; this . servers _ item . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . seperator _ item , this . config _ item } ) ; this . servers _ item . text = <%> <+> n . get _ string ( </%> STR <%> <+> ) </%> ; this . seperator _ item . index = 0 ; this . seperator _ item . text = STR ; this . config _ item . index = 1 ; this . config _ item . text = <%> <+> n . get _ string ( </%> STR <%> <+> ) </%> ;
this . seperator _ item . index = 0 ; this . seperator _ item . text = STR ; this . config _ item . index = 1 ; this . config _ item . text = <%> <+> n . get _ string ( </%> STR <%> <+> ) </%> ; this . config _ item . click + = new system . event _ handler ( this . config _ click ) ; this . menu _ item . index = NUM ; this . menu _ item . text = STR ; this . auto _ startup _ item . index = NUM ; this . auto _ startup _ item . text = <%> <+> n . get _ string ( </%> STR <%> <+> ) </%> ; this . auto _ startup _ item . click + = new system . event _ handler ( this . auto _ startup _ item _ click ) ;
this . config _ item . click + = new system . event _ handler ( this . config _ click ) ; this . menu _ item . index = NUM ; this . menu _ item . text = STR ; this . auto _ startup _ item . index = NUM ; this . auto _ startup _ item . text = <%> <+> n . get _ string ( </%> STR <%> <+> ) </%> ; this . auto _ startup _ item . click + = new system . event _ handler ( this . auto _ startup _ item _ click ) ; this . share _ over _ lan _ item . index = NUM ; this . share _ over _ lan _ item . text = <%> <+> n . get _ string ( </%> STR <%> <+> ) </%> ; this . share _ over _ lan _ item . click + = new system . event _ handler ( this . share _ over _ lan _ item _ click ) ; this . edit _ pac _ file _ item . index = NUM ;
this . auto _ startup _ item . click + = new system . event _ handler ( this . auto _ startup _ item _ click ) ; this . share _ over _ lan _ item . index = NUM ; this . share _ over _ lan _ item . text = <%> <+> n . get _ string ( </%> STR <%> <+> ) </%> ; this . share _ over _ lan _ item . click + = new system . event _ handler ( this . share _ over _ lan _ item _ click ) ; this . edit _ pac _ file _ item . index = NUM ; this . edit _ pac _ file _ item . text = <%> <+> n . get _ string ( </%> STR <%> <+> ) </%> ; this . edit _ pac _ file _ item . click + = new system . event _ handler ( this . edit _ pac _ file _ item _ click ) ; this . menu _ item . index = NUM ; this . menu _ item . text = STR ; this . qr _ code _ item . index = NUM ;
this . share _ over _ lan _ item . click + = new system . event _ handler ( this . share _ over _ lan _ item _ click ) ; this . edit _ pac _ file _ item . index = NUM ; this . edit _ pac _ file _ item . text = <%> <+> n . get _ string ( </%> STR <%> <+> ) </%> ; this . edit _ pac _ file _ item . click + = new system . event _ handler ( this . edit _ pac _ file _ item _ click ) ; this . menu _ item . index = NUM ; this . menu _ item . text = STR ; this . qr _ code _ item . index = NUM ; this . qr _ code _ item . text = <%> <+> n . get _ string ( </%> STR <%> <+> ) </%> ; this . qr _ code _ item . click + = new system . event _ handler ( this . qr _ code _ item _ click ) ; this . show _ log _ item . index = NUM ;
this . edit _ pac _ file _ item . click + = new system . event _ handler ( this . edit _ pac _ file _ item _ click ) ; this . menu _ item . index = NUM ; this . menu _ item . text = STR ; this . qr _ code _ item . index = NUM ; this . qr _ code _ item . text = <%> <+> n . get _ string ( </%> STR <%> <+> ) </%> ; this . qr _ code _ item . click + = new system . event _ handler ( this . qr _ code _ item _ click ) ; this . show _ log _ item . index = NUM ; this . show _ log _ item . text = <%> <+> n . get _ string ( </%> STR <%> <+> ) </%> ; this . show _ log _ item . click + = new system . event _ handler ( this . show _ log _ item _ click ) ; this . about _ item . index = NUM ;
this . qr _ code _ item . click + = new system . event _ handler ( this . qr _ code _ item _ click ) ; this . show _ log _ item . index = NUM ; this . show _ log _ item . text = <%> <+> n . get _ string ( </%> STR <%> <+> ) </%> ; this . show _ log _ item . click + = new system . event _ handler ( this . show _ log _ item _ click ) ; this . about _ item . index = NUM ; this . about _ item . text = <%> <+> n . get _ string ( </%> STR <%> <+> ) </%> ; this . about _ item . click + = new system . event _ handler ( this . about _ item _ click ) ; this . menu _ item . index = NUM ; this . menu _ item . text = STR ; this . quit _ item . index = NUM ;
this . show _ log _ item . click + = new system . event _ handler ( this . show _ log _ item _ click ) ; this . about _ item . index = NUM ; this . about _ item . text = <%> <+> n . get _ string ( </%> STR <%> <+> ) </%> ; this . about _ item . click + = new system . event _ handler ( this . about _ item _ click ) ; this . menu _ item . index = NUM ; this . menu _ item . text = STR ; this . quit _ item . index = NUM ; this . quit _ item . text = <%> <+> n . get _ string ( </%> STR <%> <+> ) </%> ; this . quit _ item . click + = new system . event _ handler ( this . quit _ click ) ; }
this . about _ item . click + = new system . event _ handler ( this . about _ item _ click ) ; this . menu _ item . index = NUM ; this . menu _ item . text = STR ; this . quit _ item . index = NUM ; this . quit _ item . text = <%> <+> n . get _ string ( </%> STR <%> <+> ) </%> ; this . quit _ item . click + = new system . event _ handler ( this . quit _ click ) ; } private void controller _ config _ changed ( object sender , event _ args e ) { load _ current _ configuration ( ) ;
this . quit _ item . click + = new system . event _ handler ( this . quit _ click ) ; } private void controller _ config _ changed ( object sender , event _ args e ) { load _ current _ configuration ( ) ; } private void controller _ enable _ status _ changed ( object sender , event _ args e ) { enable _ item . checked = controller . get _ configuration ( ) . enabled ; <%> <+> load _ tray _ icon ( ) ; </%>
this . proxy _ port _ text _ box = new system . windows . forms . text _ box ( ) ; this . <%> <+> proxy _ port _ </%> label = new system . windows . forms . label ( ) ; this . <%> <+> password _ </%> label = new system . windows . forms . label ( ) ; this . ip _ text _ box = new system . windows . forms . text _ box ( ) ; this . server _ port _ text _ box = new system . windows . forms . text _ box ( ) ; this . password _ text _ box = new system . windows . forms . text _ box ( ) ; this . <%> <+> encryption _ </%> label = new system . windows . forms . label ( ) ; this . encryption _ select = new system . windows . forms . combo _ box ( ) ; this . panel = new system . windows . forms . panel ( ) ; this . ok _ button = new system . windows . forms . button ( ) ;
this . ip _ text _ box = new system . windows . forms . text _ box ( ) ; this . server _ port _ text _ box = new system . windows . forms . text _ box ( ) ; this . password _ text _ box = new system . windows . forms . text _ box ( ) ; this . <%> <+> encryption _ </%> label = new system . windows . forms . label ( ) ; this . encryption _ select = new system . windows . forms . combo _ box ( ) ; this . panel = new system . windows . forms . panel ( ) ; this . ok _ button = new system . windows . forms . button ( ) ; this . my _ cancel _ button = new system . windows . forms . button ( ) ; this . panel = new system . windows . forms . panel ( ) ; this . panel = new system . windows . forms . panel ( ) ;
this . encryption _ select = new system . windows . forms . combo _ box ( ) ; this . panel = new system . windows . forms . panel ( ) ; this . ok _ button = new system . windows . forms . button ( ) ; this . my _ cancel _ button = new system . windows . forms . button ( ) ; this . panel = new system . windows . forms . panel ( ) ; this . panel = new system . windows . forms . panel ( ) ; this . delete _ button = new system . windows . forms . button ( ) ; this . add _ button = new system . windows . forms . button ( ) ; this . server _ group _ box = new system . windows . forms . group _ box ( ) ; this . servers _ list _ box = new system . windows . forms . list _ box ( ) ;
this . table _ layout _ panel . controls . add ( this . proxy _ port _ text _ box , 1 , NUM ) ; this . table _ layout _ panel . controls . add ( this . <%> <+> proxy _ port _ </%> label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . <%> <+> password _ </%> label , 0 , 2 ) ; this . table _ layout _ panel . controls . add ( this . ip _ text _ box , 1 , 0 ) ; this . table _ layout _ panel . controls . add ( this . server _ port _ text _ box , 1 , 1 ) ; this . table _ layout _ panel . controls . add ( this . password _ text _ box , 1 , 2 ) ; this . table _ layout _ panel . controls . add ( this . <%> <+> encryption _ </%> label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . encryption _ select , 1 , NUM ) ; this . table _ layout _ panel . location = new system . drawing . point ( NUM , NUM ) ; this . table _ layout _ panel . margin = new system . windows . forms . padding ( NUM ) ;
this . table _ layout _ panel . controls . add ( this . ip _ text _ box , 1 , 0 ) ; this . table _ layout _ panel . controls . add ( this . server _ port _ text _ box , 1 , 1 ) ; this . table _ layout _ panel . controls . add ( this . password _ text _ box , 1 , 2 ) ; this . table _ layout _ panel . controls . add ( this . <%> <+> encryption _ </%> label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . encryption _ select , 1 , NUM ) ; this . table _ layout _ panel . location = new system . drawing . point ( NUM , NUM ) ; this . table _ layout _ panel . margin = new system . windows . forms . padding ( NUM ) ; this . table _ layout _ panel . name = STR ; this . table _ layout _ panel . padding = new system . windows . forms . padding ( NUM ) ; this . table _ layout _ panel . row _ count = NUM ;
this . table _ layout _ panel . controls . add ( this . encryption _ select , 1 , NUM ) ; this . table _ layout _ panel . location = new system . drawing . point ( NUM , NUM ) ; this . table _ layout _ panel . margin = new system . windows . forms . padding ( NUM ) ; this . table _ layout _ panel . name = STR ; this . table _ layout _ panel . padding = new system . windows . forms . padding ( NUM ) ; this . table _ layout _ panel . row _ count = NUM ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ;
this . proxy _ port _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . proxy _ port _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . proxy _ port _ text _ box . name = STR ; this . proxy _ port _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . proxy _ port _ text _ box . tab _ index = NUM ; this . proxy _ port _ text _ box . word _ wrap = false ; this . <%> <+> proxy _ port _ </%> label . anchor = system . windows . forms . anchor _ styles . right ; this . <%> <+> proxy _ port _ </%> label . auto _ size = true ; this . <%> <+> proxy _ port _ </%> label . location = new system . drawing . point ( NUM , NUM ) ; this . <%> <+> proxy _ port _ </%> label . name = STR ;
this . ip _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . ip _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . ip _ text _ box . name = STR ; this . ip _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . ip _ text _ box . tab _ index = 0 ; this . ip _ text _ box . word _ wrap = false ; this . server _ port _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . server _ port _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . server _ port _ text _ box . name = STR ; this . server _ port _ text _ box . size = new system . drawing . size ( NUM , NUM ) ;
private system . windows . forms . text _ box ip _ text _ box ; private system . windows . forms . text _ box server _ port _ text _ box ; private system . windows . forms . text _ box password _ text _ box ; private system . windows . forms . text _ box proxy _ port _ text _ box ; private system . windows . forms . label <%> <+> encryption _ </%> label ; private system . windows . forms . combo _ box encryption _ select ; private system . windows . forms . panel panel ; private system . windows . forms . button ok _ button ; private system . windows . forms . button my _ cancel _ button ; private system . windows . forms . panel panel ;
private system . windows . forms . combo _ box encryption _ select ; private system . windows . forms . panel panel ; private system . windows . forms . button ok _ button ; private system . windows . forms . button my _ cancel _ button ; private system . windows . forms . panel panel ; private system . windows . forms . panel panel ; private system . windows . forms . button delete _ button ; private system . windows . forms . button add _ button ; private system . windows . forms . group _ box server _ group _ box ; private system . windows . forms . list _ box servers _ list _ box ;
load _ configuration ( modified _ configuration ) ; servers _ list _ box . selected _ index = <%> <*> modified -> curr </%> _ <%> <*> configuration . configs . count - -> index + </%> 1 ; last _ selected _ index = servers _ list _ box . selected _ index ; } private void delete _ button _ click ( object sender , event _ args e ) { last _ selected _ index = servers _ list _ box . selected _ index ; if ( last _ selected _ index > = 0 & & last _ selected _ index < modified _ configuration . configs . count ) { modified _ configuration . configs . remove _ at ( last _ selected _ index ) ;
last _ selected _ index = servers _ list _ box . selected _ index ; } private void delete _ button _ click ( object sender , event _ args e ) { last _ selected _ index = servers _ list _ box . selected _ index ; if ( last _ selected _ index > = 0 & & last _ selected _ index < modified _ configuration . configs . count ) { modified _ configuration . configs . remove _ at ( last _ selected _ index ) ; } if ( last _ selected _ index > = modified _ configuration . configs . count )
} <%> <*> catch ( io _ exception e ) -> catch ( io _ exception ) </%> <%> <+> { } catch ( exception e ) </%> { console . write _ line ( e . to _ string ( ) ) ; } <%> <-> load _ library ( dll _ path ) ; </%>
{ console . write _ line ( e . to _ string ( ) ) ; } <%> <-> load _ library ( dll _ path ) ; </%> } dll _ import _ kernel _ dll private static extern int _ ptr load _ library ( string path ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void aes _ init ( int _ ptr ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl
} dll _ import _ kernel _ dll private static extern int _ ptr load _ library ( string path ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void aes _ init ( int _ ptr ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void aes _ free ( int _ ptr ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int aes _ setkey _ enc ( int _ ptr ctx , byte [ ] key , int keysize ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl
get { <%> <-> object obj = resource _ manager . get _ object ( STR , resource _ culture ) ; return ( ( byte [ ] ) ( obj ) ) ; } } internal static byte [ ] polarssl _ dll { get { </%> object obj = resource _ manager . get _ object ( STR , resource _ culture ) ; return ( ( byte [ ] ) ( obj ) ) ; }
return ( ( byte [ ] ) ( obj ) ) ; } } internal static string polipo _ config { get { return resource _ manager . get _ string ( STR , resource _ culture ) ; } } internal static byte [ ] polipo _ exe { get {
} <%> <*> catch ( io _ exception e ) -> catch ( io _ exception ) </%> <%> <+> { } catch ( exception e ) </%> { console . write _ line ( e . to _ string ( ) ) ; } <%> <-> load _ library ( dll _ path ) ; </%>
{ console . write _ line ( e . to _ string ( ) ) ; } <%> <-> load _ library ( dll _ path ) ; </%> } dll _ import _ kernel _ dll private static extern int _ ptr load _ library ( string path ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void crypto _ stream _ salsa _ xor _ ic ( byte [ ] c , byte [ ] m , ulong mlen , byte [ ] n , ulong ic , byte [ ] k ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl
} dll _ import _ kernel _ dll private static extern int _ ptr load _ library ( string path ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void crypto _ stream _ salsa _ xor _ ic ( byte [ ] c , byte [ ] m , ulong mlen , byte [ ] n , ulong ic , byte [ ] k ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void crypto _ stream _ chacha _ xor _ ic ( byte [ ] c , byte [ ] m , ulong mlen , byte [ ] n , ulong ic , byte [ ] k ) ; } }
} private void log _ form _ form _ closing ( object sender , form _ closing _ event _ args e ) { timer . stop ( ) ; <%> <+> config . log _ viewer . top _ most = top _ most _ trigger ; config . log _ viewer . wrap _ text = wrap _ text _ trigger ; config . log _ viewer . toolbar _ shown = toolbar _ trigger ; config . log _ viewer . font _ name = log _ message _ text _ box . font . name ; config . log _ viewer . font _ size = log _ message _ text _ box . font . size ; config . log _ viewer . set _ background _ color ( log _ message _ text _ box . back _ color ) ; </%>
} } else { if ( line . is _ null _ or _ empty ( ) ) { <%> <-> headers . enqueue ( STR ) ; </%> return true ; <%> <-> } if ( ! line . starts _ with ( STR ) ) </%>
return true ; <%> <-> } if ( ! line . starts _ with ( STR ) ) { headers . enqueue ( line ) ; </%> } if ( ! is _ connect ) { if ( line . starts _ with ( STR ) ) {
} if ( ! is _ connect ) { if ( line . starts _ with ( STR ) ) { var location = line . substring ( NUM ) . trim ( ) ; var locs = location . split ( ':' ) ; target _ host = locs [ 0 ] ; if ( locs . length > 1 ) {
{ <%> <*> var key = keymap . first ( x = > x . value = = cb ) . key ; hotkey = key ; -> hotkey = keymap . first ( v = > v . value = = cb ) . key ; </%> return true ; } <%> <-> catch ( invalid _ operation _ exception ) </%> <%> <+> else </%> { hotkey = null ; return false ;
return true ; } <%> <-> catch ( invalid _ operation _ exception ) </%> <%> <+> else </%> { hotkey = null ; return false ; } } public static string hot _ key _ str ( hot _ key key ) {
{ hotkey = null ; return false ; } } public static string hot _ key _ str ( hot _ key key ) { if ( key = = null ) throw new argument _ null _ exception ( nameof ( key ) ) ; return hot _ key _ str ( key . key , key . modifiers ) ; }
private void cancel _ button _ click ( object sender , event _ args e ) { this . close ( ) ; } private void ok _ button _ click ( object sender , event _ args e ) { <%> <+> modified _ hotkey _ config = get _ config _ from _ ui ( ) ; </%> if ( ! register _ all _ hotkeys ( <%> <+> modified _ hotkey _ config </%> ) ) { message _ box . show ( n . get _ string ( STR ) ) ;
{ message _ box . show ( n . get _ string ( STR ) ) ; } save _ config ( ) ; this . close ( ) ; } private void register _ all _ button _ click ( object sender , event _ args e ) { <%> <+> modified _ hotkey _ config = get _ config _ from _ ui ( ) ; </%> register _ all _ hotkeys ( <%> <+> modified _ hotkey _ config </%> ) ;
} private static void unreg _ prev _ hotkey ( hot _ keys . hot _ key _ call _ back _ handler cb ) { global _ hot _ key . hot _ key prev _ hot _ key ; if ( hot _ keys . is _ callback _ exists ( cb , out prev _ hot _ key ) ) { hot _ keys . unregister ( prev _ hot _ key ) ; } } <%> <-> private void prepare _ for _ hotkey ( text _ box tb , out hot _ keys . hot _ key _ call _ back _ handler cb , out label lb ) </%>
} }
this . switch _ system _ proxy _ text _ box . key _ down + = new system . windows . forms . key _ event _ handler ( this . hotkey _ down ) ; this . switch _ system _ proxy _ text _ box . key _ up + = new system . windows . forms . key _ event _ handler ( this . hotkey _ up ) ; this . switch _ proxy _ mode _ text _ box . dock = system . windows . forms . dock _ style . fill ; this . switch _ proxy _ mode _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . switch _ proxy _ mode _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . switch _ proxy _ mode _ text _ box . name = STR ; this . switch _ proxy _ mode _ text _ box . read _ only = true ; this . switch _ proxy _ mode _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . switch _ proxy _ mode _ text _ box . tab _ index = NUM ; <%> <-> this . switch _ proxy _ mode _ text _ box . text _ changed + = new system . event _ handler ( this . text _ box _ text _ changed ) ; </%>
this . switch _ proxy _ mode _ text _ box . key _ down + = new system . windows . forms . key _ event _ handler ( this . hotkey _ down ) ; this . switch _ proxy _ mode _ text _ box . key _ up + = new system . windows . forms . key _ event _ handler ( this . hotkey _ up ) ; this . switch _ allow _ lan _ text _ box . dock = system . windows . forms . dock _ style . fill ; this . switch _ allow _ lan _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . switch _ allow _ lan _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . switch _ allow _ lan _ text _ box . name = STR ; this . switch _ allow _ lan _ text _ box . read _ only = true ; this . switch _ allow _ lan _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . switch _ allow _ lan _ text _ box . tab _ index = NUM ; <%> <-> this . switch _ allow _ lan _ text _ box . text _ changed + = new system . event _ handler ( this . text _ box _ text _ changed ) ; </%>
this . switch _ allow _ lan _ text _ box . key _ down + = new system . windows . forms . key _ event _ handler ( this . hotkey _ down ) ; this . switch _ allow _ lan _ text _ box . key _ up + = new system . windows . forms . key _ event _ handler ( this . hotkey _ up ) ; this . show _ logs _ text _ box . dock = system . windows . forms . dock _ style . fill ; this . show _ logs _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . show _ logs _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . show _ logs _ text _ box . name = STR ; this . show _ logs _ text _ box . read _ only = true ; this . show _ logs _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . show _ logs _ text _ box . tab _ index = NUM ; <%> <-> this . show _ logs _ text _ box . text _ changed + = new system . event _ handler ( this . text _ box _ text _ changed ) ; </%>
this . show _ logs _ text _ box . key _ down + = new system . windows . forms . key _ event _ handler ( this . hotkey _ down ) ; this . show _ logs _ text _ box . key _ up + = new system . windows . forms . key _ event _ handler ( this . hotkey _ up ) ; this . server _ move _ up _ text _ box . dock = system . windows . forms . dock _ style . fill ; this . server _ move _ up _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . server _ move _ up _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . server _ move _ up _ text _ box . name = STR ; this . server _ move _ up _ text _ box . read _ only = true ; this . server _ move _ up _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . server _ move _ up _ text _ box . tab _ index = NUM ; <%> <-> this . server _ move _ up _ text _ box . text _ changed + = new system . event _ handler ( this . text _ box _ text _ changed ) ; </%>
this . server _ move _ up _ text _ box . key _ down + = new system . windows . forms . key _ event _ handler ( this . hotkey _ down ) ; this . server _ move _ up _ text _ box . key _ up + = new system . windows . forms . key _ event _ handler ( this . hotkey _ up ) ; this . server _ move _ down _ text _ box . dock = system . windows . forms . dock _ style . fill ; this . server _ move _ down _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . server _ move _ down _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . server _ move _ down _ text _ box . name = STR ; this . server _ move _ down _ text _ box . read _ only = true ; this . server _ move _ down _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . server _ move _ down _ text _ box . tab _ index = NUM ; <%> <-> this . server _ move _ down _ text _ box . text _ changed + = new system . event _ handler ( this . text _ box _ text _ changed ) ; </%>

{ controller = controller ; <%> <+> config = conf ; </%> handlers = new hash _ set < tcp _ handler > ( ) ; last _ sweep _ time = date _ time . now ; } public bool handle ( byte [ ] first _ packet , int length , socket socket , object state ) { if ( socket . protocol _ type ! = protocol _ type . tcp ) {
public socket connection ; public shadowsocks _ controller controller ; public tcp _ relay relay ; public date _ time last _ activity ; private const int max _ retry = NUM ; private int retry _ count = 0 ; <%> <*> private bool connected ; -> private bool proxy _ connected ; </%> <%> <+> private bool dest _ connected ; </%> private byte command ;
private byte command ; private byte [ ] first _ packet ; private int first _ packet _ length ; public const int recv _ size = NUM ; public const int recv _ reserve _ size = iv _ encryptor . onetimeauth _ bytes + iv _ encryptor . auth _ bytes ; public const int buffer _ size = recv _ size + recv _ reserve _ size + NUM ; private int total _ read = 0 ; private int total _ write = 0 ; private byte [ ] remote _ recv _ buffer = new byte [ buffer _ size ] ; private byte [ ] remote _ send _ buffer = new byte [ buffer _ size ] ;
connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , 0 , new async _ callback ( read _ all ) , null ) ; } else { int bytes _ read = connection . end _ receive ( ar ) ; if ( bytes _ read > 0 ) { logging . debug ( remote <%> <+> . local _ end _ point , remote . dest _ end _ point </%> , recv _ size , STR ) ; connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , 0 , new async _ callback ( read _ all ) , null ) ; }
connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , 0 , new async _ callback ( read _ all ) , null ) ; } else { close ( ) ; } } } catch ( exception e ) {
start _ connect _ time = date _ time . now ; server _ timer connect _ timer = new server _ timer ( NUM ) ; connect _ timer . auto _ reset = false ; connect _ timer . elapsed + = <%> <+> dest _ </%> connect _ timer _ elapsed ; connect _ timer . enabled = true ; connect _ timer . server = server ; <%> <+> dest _ </%> connected = false ; <%> <+> remote . begin _ connect _ dest ( dest _ ep , new async _ callback ( connect _ callback ) , connect _ timer ) ; } catch ( argument _ exception ) </%>
connect _ timer . enabled = true ; connect _ timer . server = server ; <%> <+> dest _ </%> connected = false ; <%> <*> remote . begin _ connect ( remote _ ep , new async _ callback ( connect _ callback ) , connect _ timer ) ; -> remote . begin _ connect _ dest ( dest _ ep , new async _ callback ( connect _ callback ) , connect _ timer ) ; } catch ( argument _ exception ) </%> <%> <+> { </%> } catch ( exception e ) {
<%> <*> remote . begin _ connect ( remote _ ep , new async _ callback ( connect _ callback ) , connect _ timer ) ; -> remote . begin _ connect _ dest ( dest _ ep , new async _ callback ( connect _ callback ) , connect _ timer ) ; } catch ( argument _ exception ) </%> <%> <+> { </%> } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; <%> <*> close -> retry _ connect </%> ( ) ; }
{ return ; } server server = ( ( server _ timer ) sender ) . server ; i _ strategy strategy = controller . get _ current _ strategy ( ) ; if ( strategy ! = null ) { strategy . set _ failure ( server ) ; } logging . info ( $ STR ) ;
timer . enabled = false ; timer . dispose ( ) ; remote . end _ connect <%> <+> _ dest </%> ( ar ) ; <%> <+> dest _ </%> connected = true ; logging . debug ( $ STR ) ; var latency = date _ time . now - start _ connect _ time ; i _ strategy strategy = controller . get _ current _ strategy ( ) ; strategy ? . update _ latency ( server , latency ) ; tcprelay . update _ latency ( server , latency ) ; start _ pipe ( ) ;
var latency = date _ time . now - start _ connect _ time ; i _ strategy strategy = controller . get _ current _ strategy ( ) ; strategy ? . update _ latency ( server , latency ) ; tcprelay . update _ latency ( server , latency ) ; start _ pipe ( ) ; } catch ( argument _ exception ) { } catch ( exception e )
{ <%> <-> this . name = name ; </%> this . key _ size = key _ size ; this . iv _ size = iv _ size ; this . type = type ; <%> <+> this . inner _ lib _ name = inner _ lib _ name ; } public encryptor _ info ( int key _ size , int iv _ size , int type ) { this . key _ size = key _ size ; </%>
} } public abstract class encryptor _ base : i _ encryptor { public const int max _ input _ size = NUM ; protected encryptor _ base ( string method , string password , bool onetimeauth , bool isudp ) { method = method ; password = password ;
{ <%> <+> if ( ! mutex . wait _ one ( 0 , false ) ) { process [ ] old _ processes = process . get _ processes _ by _ name ( STR ) ; if ( old _ processes . length > 0 ) { process old _ process = old _ processes [ 0 ] ; } message _ box . show ( STR ) ; return ; </%>
} <%> <-> catch ( io _ exception e ) { console . write _ line ( e . to _ string ( ) ) ; } load _ library ( dll _ path ) ; try { file _ stream fs = new file _ stream ( STR , file _ mode . append ) ; text _ writer tmp = console . out ; </%>
} } }
series . is _ x _ value _ indexed = true ; series . legend = STR ; series . name = STR ; series . chart _ area = STR ; series . chart _ type = system . windows . forms . data _ visualization . charting . series _ chart _ type . line ; series . color = system . drawing . color . from _ argb <%> <-> ( ( ( int ) ( </%> ( <%> <*> ( byte ) ( -> NUM , NUM , </%> NUM ) <%> <*> ) ) ) , ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) , ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) ) ; -> ; </%>

public const int hash _ bytes = NUM ; <%> <+> public const int clen _ bytes = 2 ; public const int auth _ bytes = hash _ bytes + clen _ bytes ; </%> protected static byte [ ] tempbuf = new byte [ max _ input _ size ] ; protected dictionary < string , int [ ] > ciphers ; private static readonly dictionary < string , byte [ ] > cached _ keys = new dictionary < string , byte [ ] > ( ) ; protected byte [ ] encrypt _ iv ; protected byte [ ] decrypt _ iv ; protected bool decrypt _ iv _ received ; protected bool encrypt _ iv _ sent ;
public iv _ encryptor ( string method , string password , bool onetimeauth ) : base ( method , password , onetimeauth ) { init _ key ( method , password ) ; <%> <-> if ( onetime _ auth ) { hash _ buf = new byte [ hash _ buf _ len ] ; } </%> } protected abstract dictionary < string , int [ ] > get _ ciphers ( ) ;
} protected abstract dictionary < string , int [ ] > get _ ciphers ( ) ; protected void init _ key ( string method , string password ) { method = method . to _ lower ( ) ; method = method ; string k = method + STR + password ; ciphers = get _ ciphers ( ) ; cipher _ info = ciphers [ method ] ; cipher = cipher _ info [ 2 ] ;
{ byte [ ] auth _ key = new byte [ onetimeauth _ keybytes ] ; byte [ ] auth _ bytes = new byte [ max _ iv _ length + max _ key _ length ] ; buffer . block _ copy ( <%> <+> encrypt _ </%> iv , 0 , auth _ bytes , 0 , iv _ len ) ; buffer . block _ copy ( key , 0 , auth _ bytes , iv _ len , key _ len ) ; sodium . crypto _ generichash ( auth _ key , onetimeauth _ keybytes , auth _ bytes , ( ulong ) ( iv _ len + key _ len ) , null , 0 ) ; return sodium . crypto _ onetimeauth ( auth , msg , ( ulong ) msg _ len , auth _ key ) ; } <%> <*> protected void ss _ gen _ hash ( byte [ ] in _ buf , ref int in _ offset , ref int in _ len , -> protected void ss _ gen _ hash ( </%> byte [ ] <%> <-> hash _ </%> buf , ref int <%> <*> hash _ idx -> offset , ref int len </%> , int buf _ size )
return sodium . crypto _ onetimeauth ( auth , msg , ( ulong ) msg _ len , auth _ key ) ; } <%> <*> protected void ss _ gen _ hash ( byte [ ] in _ buf , ref int in _ offset , ref int in _ len , -> protected void ss _ gen _ hash ( </%> byte [ ] <%> <-> hash _ </%> buf , ref int <%> <*> hash _ idx -> offset , ref int len </%> , int buf _ size ) { int <%> <*> i , j -> size = len + auth _ bytes </%> ; <%> <-> int offset = in _ offset ; int blen = in _ len ; int cidx = hash _ idx ; int size = ( blen / hash _ buf _ len + 1 ) * hash _ bytes + blen ; </%>
if ( buf _ size < ( size + offset ) ) throw new exception ( STR ) ; <%> <+> if ( key _ buffer = = null ) { key _ buffer = new byte [ max _ iv _ length + NUM ] ; buffer . block _ copy ( encrypt _ iv , 0 , key _ buffer , 0 , iv _ len ) ; } byte [ ] counter _ bytes = bit _ converter . get _ bytes ( ( uint ) ip _ address . host _ to _ network _ order ( ( int ) counter ) ) ; buffer . block _ copy ( counter _ bytes , 0 , key _ buffer , iv _ len , NUM ) ; </%> byte [ ] hash = new byte [ hash _ bytes ] ;
} public override void encrypt ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength ) { if ( ! encrypt _ iv _ sent ) { encrypt _ iv _ sent = true ; rand _ bytes ( outbuf , iv _ len ) ; init _ cipher ( outbuf , true ) ; outlength = length + iv _ len ; lock ( tempbuf )
splash . <%> <*> panel . size -> target _ rect </%> = new <%> <*> size -> rectangle </%> ( <%> <+> ( int ) min _ x , ( int ) min _ y , </%> ( int ) max _ x - ( int ) min _ x , ( int ) max _ y - ( int ) min _ y ) ; splash . size = <%> <*> splash -> new size ( full _ image </%> . <%> <*> panel -> width , full _ image </%> . <%> <*> size -> height ) </%> ; splash . show ( ) ; return ; } } } message _ box . show ( n . get _ string ( STR ) ) ; } void splash _ form _ closed ( object sender , form _ closed _ event _ args e )
splash . show ( ) ; return ; } } } message _ box . show ( n . get _ string ( STR ) ) ; } void splash _ form _ closed ( object sender , form _ closed _ event _ args e ) { show _ config _ form ( ) ;
{ <%> <+> public class qr _ rect _ view : control { private pen pen ; private brush brush ; public qr _ rect _ view ( ) { pen = new pen ( color . red , NUM ) ; brush = new solid _ brush ( color . from _ argb ( NUM , color . red ) ) ; set _ style ( control _ styles . resize _ redraw , true ) ; </%>
} private timer timer ; private int step ; private void qr _ code _ splash _ form _ load ( object sender , event _ args e ) { <%> <*> step = 0 ; -> set _ style ( control _ styles . supports _ transparent _ back _ color , true ) ; </%> <%> <+> this . back _ color = color . transparent ; animation _ step = 0 ; flash _ step = 0 ; </%>
timer = new timer ( ) ; timer . interval = <%> <*> NUM ; -> ( int ) ( animation _ time * NUM / animation _ steps ) ; </%> timer . tick + = timer _ tick ; timer . start ( ) ; <%> <+> bitmap = new bitmap ( width , height , pixel _ format . format _ bpp _ argb ) ; g = graphics . from _ image ( bitmap ) ; pen = new pen ( color . red , NUM ) ; brush = new solid _ brush ( color . from _ argb ( NUM , color . red ) ) ; } protected override create _ params create _ params </%>
timer . tick + = timer _ tick ; timer . start ( ) ; <%> <+> bitmap = new bitmap ( width , height , pixel _ format . format _ bpp _ argb ) ; g = graphics . from _ image ( bitmap ) ; pen = new pen ( color . red , NUM ) ; brush = new solid _ brush ( color . from _ argb ( NUM , color . red ) ) ; } protected override create _ params create _ params { get </%>
{ <%> <*> return -> file . write _ all _ text ( </%> pac _ file <%> <*> ; -> , resources . proxy _ pac _ txt ) ; </%> } <%> <-> else { file _ manager . uncompress _ file ( pac _ file , resources . proxy _ pac _ txt ) ; </%> return pac _ file ; <%> <-> } </%> } internal string touch _ user _ rule _ file ( )
} <%> <-> else { file _ manager . uncompress _ file ( pac _ file , resources . proxy _ pac _ txt ) ; </%> return pac _ file ; <%> <-> } </%> } internal string touch _ user _ rule _ file ( ) { <%> <-> if ( file . exists ( user _ rule _ file ) ) </%>
} internal string touch _ user _ rule _ file ( ) { <%> <*> if ( file . exists ( user _ rule _ file ) ) { return user _ rule _ file ; } else -> if ( ! file . exists ( user _ rule _ file ) ) </%> {
{ file . write _ all _ text ( user _ rule _ file , resources . user _ rule ) ; <%> <-> return user _ rule _ file ; </%> } <%> <+> return user _ rule _ file ; </%> } internal string get _ pac _ content ( ) { if ( file . exists ( pac _ file ) ) {
} <%> <+> return user _ rule _ file ; </%> } internal string get _ pac _ content ( ) { if ( file . exists ( pac _ file ) ) { return file . read _ all _ text ( pac _ file , encoding . ut ) ; } else
} } private void watch _ pac _ file ( ) { pac _ file _ watcher ? . dispose ( ) ; pac _ file _ watcher = new file _ system _ watcher ( directory . get _ current _ directory ( ) ) ; pac _ file _ watcher . notify _ filter = notify _ filters . last _ write | notify _ filters . file _ name | notify _ filters . directory _ name ; pac _ file _ watcher . filter = pac _ file ; pac _ file _ watcher . changed + = pac _ file _ watcher _ changed ; pac _ file _ watcher . created + = pac _ file _ watcher _ changed ;
{ <%> <*> logger -> group = config </%> . <%> <*> info ( STR ) -> geosite _ group </%> ; <%> <*> gfw _ list _ url -> blacklist </%> = config . <%> <*> gfw -> geosite </%> _ <%> <*> list -> blacklist </%> _ <%> <*> url -> mode </%> ; } <%> <+> if ( ! string . is _ null _ or _ white _ space ( config . geosite _ url ) ) { logger . info ( STR ) ; geosite _ url = config . geosite _ url ; } </%> logger . info ( $ STR ) ;
} <%> <+> if ( ! string . is _ null _ or _ white _ space ( config . geosite _ url ) ) { logger . info ( STR ) ; geosite _ url = config . geosite _ url ; } </%> logger . info ( $ STR ) ; web _ client http = new web _ client ( ) ; if ( config . enabled ) {
web _ client http = new web _ client ( ) ; if ( config . enabled ) { http . proxy = new web _ proxy ( config . is _ i _ pv _ enabled ? $ STR : ip _ address . loopback . to _ string ( ) , config . local _ port ) ; } http . download _ data _ completed + = ( o , e ) = >
update _ completed ? . invoke ( null , new geosite _ result _ event _ args ( pac _ file _ changed ) ) ; } catch ( exception ex ) { error ? . invoke ( null , new error _ event _ args ( ex ) ) ; } } ; http . download _ data _ async ( new uri ( <%> <*> gfw _ list -> geosite </%> _ url ) ) ; } public static bool merge _ and _ write _ pac _ file ( <%> <+> string group , bool blacklist </%> )
} public static bool merge _ and _ write _ pac _ file ( <%> <+> string group , bool blacklist </%> ) { <%> <*> return merge _ and _ write _ pac _ file ( geosites [ STR ] ) ; } private static bool merge _ and _ write _ pac _ file ( i _ list < domain _ object > domains ) { string abp _ content = merge _ pac _ file ( domains ) ; -> i _ list < domain _ object > domains = geosites [ group ] ; </%> <%> <+> string abp _ content = merge _ pac _ file ( domains , blacklist ) ; </%>
{ <%> <*> return merge _ and _ write _ pac _ file ( geosites [ STR ] ) ; } private static bool merge _ and _ write _ pac _ file ( i _ list < domain _ object > domains ) { string abp _ content = merge _ pac _ file ( domains ) ; -> i _ list < domain _ object > domains = geosites [ group ] ; </%> <%> <+> string abp _ content = merge _ pac _ file ( domains , blacklist ) ; </%> if ( file . exists ( pac _ daemon . pac _ file ) ) {
if ( file . exists ( pac _ daemon . pac _ file ) ) { string original = file _ manager . non _ exclusive _ read _ all _ text ( pac _ daemon . pac _ file , encoding . ut ) ; if ( original = = abp _ content ) { return false ; } } file . write _ all _ text ( pac _ daemon . pac _ file , abp _ content , encoding . ut ) ; return true ;
} list < string > gfw _ lines = <%> <*> parse -> geosite </%> _ to _ <%> <*> valid -> gfw </%> _ list ( domains <%> <+> , blacklist </%> ) ; abp _ content = $ @ STR var rules = { json _ convert . serialize _ object ( gfw _ lines , formatting . indented ) } ; { abp _ content } STR return abp _ content ; } private static readonly i _ enumerable < char > ignored _ line _ begins = new [ ] { '!' , '[' } ; private static list < string > <%> <*> parse -> pre </%> _ <%> <*> to -> process </%> _ <%> <*> valid -> gfw </%> _ list ( string content )
abp _ content = $ @ STR var rules = { json _ convert . serialize _ object ( gfw _ lines , formatting . indented ) } ; { abp _ content } STR return abp _ content ; } private static readonly i _ enumerable < char > ignored _ line _ begins = new [ ] { '!' , '[' } ; private static list < string > <%> <*> parse -> pre </%> _ <%> <*> to -> process </%> _ <%> <*> valid -> gfw </%> _ list ( string content ) { list < string > valid _ lines = new list < string > ( ) ;
{ list < string > valid _ lines = new list < string > ( ) ; using ( var sr = new string _ reader ( content ) ) { foreach ( var line in sr . non _ white _ space _ lines ( ) ) { if ( line . begin _ with _ any ( ignored _ line _ begins ) ) continue ; valid _ lines . add ( line ) ; }
{ <%> <+> return blacklist ? geosite _ to _ gfw _ list _ black ( domains ) : geosite _ to _ gfw _ list _ white ( domains ) ; } private static </%> list < string > <%> <*> ret = new -> geosite _ to _ gfw _ list _ black ( i _ </%> list < <%> <*> string -> domain _ object </%> > <%> <-> ( </%> domains <%> <-> . count + NUM </%> ) { <%> <-> STR </%> <%> <*> } ; -> list < string > ret = new list < string > ( domains . count + NUM ) ; </%> foreach ( var d in domains ) { string domain = d . value ;
foreach ( var d in domains ) { string domain = d . value ; switch ( d . type ) { case domain _ object . types . type . plain : ret . add ( <%> <*> $ STR -> domain </%> ) ; break ; case domain _ object . types . type . regex : ret . add ( $ STR ) ;
break ; case domain _ object . types . type . regex : ret . add ( $ STR ) ; break ; case domain _ object . types . type . domain : ret . add ( $ STR ) ; break ; case domain _ object . types . type . full : ret . add ( $ STR ) ; ret . add ( $ STR ) ;
{ <%> <+> this . config = config ; </%> touch _ pac _ file ( ) ; touch _ user _ rule _ file ( ) ; this . watch _ pac _ file ( ) ; this . watch _ user _ rule _ file ( ) ; } public string touch _ pac _ file ( ) { if ( ! file . exists ( pac _ file ) )
} return pac _ file ; } internal string touch _ user _ rule _ file ( ) { if ( ! file . exists ( user _ rule _ file ) ) { file . write _ all _ text ( user _ rule _ file , resources . user _ rule ) ; } return user _ rule _ file ;
{ if ( name . is _ null _ or _ empty ( ) ) throw new argument _ exception ( nameof ( name ) ) ; try { registry _ key user _ key = registry _ key . open _ base _ key ( <%> <-> registry _ </%> hive <%> <-> . current _ user </%> , environment . is _ bit _ operating _ system ? registry _ view . registry : registry _ view . registry ) . open _ sub _ key ( name , writable ) ; return user _ key ; } catch ( unauthorized _ access _ exception uae )
environment . is _ bit _ operating _ system ? registry _ view . registry : registry _ view . registry ) . open _ sub _ key ( name , writable ) ; return user _ key ; } catch ( unauthorized _ access _ exception uae ) { logging . log _ useful _ exception ( uae ) ; return null ; } catch ( security _ exception se )
} public void update _ outbound _ counter ( long n ) { <%> <+> interlocked . add ( ref </%> outbound _ counter <%> <*> + = -> , </%> n <%> <+> ) </%> ; } protected void reload ( ) { config = configuration . load ( ) ; statistics _ configuration = statistics _ strategy _ configuration . load ( ) ; if ( polipo _ runner = = null )
} protected void reload ( ) { config = configuration . load ( ) ; statistics _ configuration = statistics _ strategy _ configuration . load ( ) ; if ( polipo _ runner = = null ) { polipo _ runner = new polipo _ runner ( ) ; } if ( pac _ server = = null )
polipo _ runner = new polipo _ runner ( ) ; polipo _ runner . start ( config <%> <+> . get _ current _ server ( ) </%> ) ; local = new local ( config <%> <+> . get _ current _ server ( ) </%> ) ; try { local . start ( ) ; pac _ server = new pac _ server ( ) ; pac _ server . pac _ file _ changed + = pac _ server _ pac _ file _ changed ; pac _ server . start ( ) ; }
try { local . start ( ) ; pac _ server = new pac _ server ( ) ; pac _ server . pac _ file _ changed + = pac _ server _ pac _ file _ changed ; pac _ server . start ( ) ; } catch ( exception e ) { console . write _ line ( e . message ) ;
{ <%> <*> config -> configuration </%> . save ( new _ config ) ; config = new _ config ; local . stop ( ) ; polipo _ runner . stop ( ) ; polipo _ runner . start ( config <%> <+> . get _ current _ server ( ) </%> ) ; local = new local ( config <%> <+> . get _ current _ server ( ) </%> ) ; local . start ( ) ; if ( config _ changed ! = null ) {
config = new _ config ; local . stop ( ) ; polipo _ runner . stop ( ) ; polipo _ runner . start ( config <%> <+> . get _ current _ server ( ) </%> ) ; local = new local ( config <%> <+> . get _ current _ server ( ) </%> ) ; local . start ( ) ; if ( config _ changed ! = null ) { config _ changed ( this , new event _ args ( ) ) ; }
local . start ( ) ; if ( config _ changed ! = null ) { config _ changed ( this , new event _ args ( ) ) ; } } <%> <*> public config get _ config ( ) -> public server get _ current _ server ( ) </%> <%> <+> { return config . get _ current _ server ( ) ; </%>
{ return config ; } public void toggle _ enable ( bool enabled ) { config . enabled = enabled ; update _ system _ proxy ( ) ; save _ config ( config ) ; if ( enable _ status _ changed ! = null ) {
} private void form _ load ( object sender , event _ args e ) { if ( ! controller . get _ <%> <*> config -> configuration </%> ( ) . is _ default ) { this . opacity = 0 ; begin _ invoke ( new method _ invoker ( delegate { this . hide ( ) ; } ) ) ;
{ this . opacity = 0 ; begin _ invoke ( new method _ invoker ( delegate { this . hide ( ) ; } ) ) ; } } private void config _ click ( object sender , event _ args e ) {
{ server = text _ box . text , server _ port = int . parse ( text _ box . text ) , password = text _ box . text , local _ port = int . parse ( text _ box . text ) , <%> <*> method = combo _ box . text , is _ default = false -> method = combo _ box . text </%> } ; <%> <+> configuration config = controller . get _ configuration ( ) ; </%>
} ; <%> <+> configuration config = controller . get _ configuration ( ) ; config . configs . clear ( ) ; config . configs . add ( server ) ; config . index = 0 ; </%> controller . save _ config ( config ) ; this . hide ( ) ; } catch ( format _ exception ) {
{ <%> <+> if ( ! int . try _ parse ( locs [ 1 ] , out target _ port ) ) { </%> throw new exception ( STR + line ) ; <%> <+> } } else { target _ port = NUM ; </%> }
} } } } else { if ( line . is _ null _ or _ empty ( ) ) { return true ; }
{ <%> <+> if ( ! int . try _ parse ( locs [ 1 ] , out target _ port ) ) { </%> throw new exception ( STR + line ) ; <%> <+> } } else { target _ port = NUM ; </%> }
} } } } request _ line _ count + + ; return false ; } private void on _ finish ( byte [ ] last _ bytes , int index , int length , object state ) { if ( closed )
byte [ ] response = { NUM , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 } ; connection . begin _ send ( response , 0 , response . length , socket _ flags . none , response _ callback , null ) ; <%> <*> } else if ( command = = cmd _ udp _ assoc ) { -> break ; </%> <%> <+> case cmd _ udp _ assoc : </%> read _ address ( handle _ udp _ associate ) ; <%> <-> } </%>
read _ address ( handle _ udp _ associate ) ; <%> <*> } -> break ; </%> <%> <+> case cmd _ bind : default : logging . debug ( STR + command ) ; close ( ) ; break ; </%> } }
} } else { logging . debug ( STR ) ; close ( ) ; } } catch ( exception e )
using system _ diagnostics ; using system _ io ; using system _ i _ compression ; <%> <-> using system _ linq ; </%> using system _ runtime _ interop _ services ; <%> <-> using system _ security ; </%>
using system _ runtime _ interop _ services ; <%> <-> using system _ security ; </%>

return null ; } <%> <-> catch ( security _ exception se ) { logging . log _ useful _ exception ( se ) ; return null ; } </%> catch ( <%> <-> argument _ </%> exception <%> <*> ae -> e </%> ) { <%> <*> message _ box . show ( STR + ae -> logging </%> . <%> <*> to -> log _ useful </%> _ <%> <*> string -> exception </%> ( <%> <*> ) -> e </%> ) ;
return null ; } } public static bool is _ win _ vista _ or _ higher ( ) { return environment . os _ version . version . major > NUM ; } dll _ import _ kernel _ dll return _ marshal _ as _ unmanaged _ type _ bool private static extern bool set _ process _ working _ set _ size ( int _ ptr process , u _ int _ ptr minimum _ working _ set _ size , u _ int _ ptr maximum _ working _ set _ size ) ;
namespace shadowsocks _ util _ system _ proxy { <%> <*> public -> internal </%> static class <%> <*> ras -> remote _ access _ service </%> { private enum ras _ field _ size _ constants { ras _ max _ entry _ name = NUM , ras _ max _ path = NUM } private const int error _ success = 0 ;
{ private enum ras _ field _ size _ constants { ras _ max _ entry _ name = NUM , ras _ max _ path = NUM } private const int error _ success = 0 ; private const int rasbase = NUM ; private const int error _ buffer _ too _ small = rasbase + NUM ; struct _ layout _ layout _ kind _ sequential _ char _ set _ char _ set _ auto
using system _ collections ; <%> <-> using system _ collections _ generic ; using system _ diagnostics ; </%> using system _ io ; <%> <-> using system _ i _ compression ; </%> using system _ net ; using system _ net _ sockets ; using system _ text ; <%> <+> using shadowsocks _ model ; using shadowsocks _ properties ; </%>
using system _ io ; <%> <-> using system _ i _ compression ; </%> using system _ net ; using system _ net _ sockets ; using system _ text ; <%> <+> using shadowsocks _ model ; using shadowsocks _ properties ; using shadowsocks _ util ; </%> namespace shadowsocks _ controller {
using system _ net ; using system _ net _ sockets ; using system _ text ; <%> <+> using shadowsocks _ model ; using shadowsocks _ properties ; using shadowsocks _ util ; </%> namespace shadowsocks _ controller { class pac _ server : listener . service {
file _ system _ watcher pac _ file _ watcher ; file _ system _ watcher user _ rule _ file _ watcher ; private configuration config ; public event event _ handler pac _ file _ changed ; public event event _ handler user _ rule _ file _ changed ; public pac _ server ( ) { this . watch _ pac _ file ( ) ; this . watch _ user _ rule _ file ( ) ; }
{ string local = file . read _ all _ text ( <%> <+> pac _ server . </%> user _ rule _ file , encoding . ut ) ; string [ ] rules = local . split ( new char [ ] { '\r' , '\n' } , string _ split _ options . remove _ empty _ entries ) ; foreach ( string rule in rules ) { if ( rule . starts _ with ( STR ) | | rule . starts _ with ( STR ) ) continue ; lines . add ( rule ) ; } }
string [ ] rules = local . split ( new char [ ] { '\r' , '\n' } , string _ split _ options . remove _ empty _ entries ) ; foreach ( string rule in rules ) { if ( rule . starts _ with ( STR ) | | rule . starts _ with ( STR ) ) continue ; lines . add ( rule ) ; } } string abp _ content ; if ( file . exists ( <%> <+> pac _ server . </%> user _ abp _ file ) )
{ abp _ content = file . read _ all _ text ( <%> <+> pac _ server . </%> user _ abp _ file , encoding . ut ) ; } else { abp _ content = utils . un _ gzip ( resources . abp _ js ) ; } abp _ content = abp _ content . replace ( STR , json _ convert . serialize _ object ( lines , formatting . indented ) ) ; if ( file . exists ( pac _ server . pac _ file ) ) {
} else { abp _ content = utils . un _ gzip ( resources . abp _ js ) ; } abp _ content = abp _ content . replace ( STR , json _ convert . serialize _ object ( lines , formatting . indented ) ) ; if ( file . exists ( pac _ server . pac _ file ) ) { string original = file . read _ all _ text ( <%> <+> pac _ server . </%> pac _ file , encoding . ut ) ; if ( original = = abp _ content )
if ( original = = abp _ content ) { update _ completed ( this , new result _ event _ args ( false ) ) ; return ; } } file . write _ all _ text ( <%> <+> pac _ server . </%> pac _ file , abp _ content , encoding . ut ) ; if ( update _ completed ! = null ) { update _ completed ( this , new result _ event _ args ( true ) ) ;
if ( update _ completed ! = null ) { update _ completed ( this , new result _ event _ args ( true ) ) ; } } catch ( exception ex ) { if ( error ! = null ) { error ( this , new error _ event _ args ( ex ) ) ;
{ <%> <+> var reply = await ping . send _ task _ async ( server . server , timeout ) ; ret . add ( new list < key _ value _ pair < string , string > > { </%> new key _ value _ pair < string , string > ( STR , timestamp ) , new key _ value _ pair < string , string > ( STR , server . friendly _ name ( ) ) , new key _ value _ pair < string , string > ( STR , reply ? . status . to _ string ( ) ) , new key _ value _ pair < string , string > ( STR , reply ? . roundtrip _ time . to _ string ( ) ) } ) ; <%> <+> } </%>
} return ret ; } private async void evaluate ( object obj ) { var geolocation _ and _ isp = get _ geolocation _ and _ isp ( ) ; foreach ( var data _ lists in await task _ ex . when _ all ( servers . select ( icmp _ test ) ) ) { if ( data _ lists = = null ) continue ; foreach ( var data _ list in data _ lists . where ( data _ list = > data _ list ! = null ) )
return output ; } dll _ import _ kernel _ dll private static extern int _ ptr load _ library ( string path ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern <%> <*> void -> int </%> md <%> <+> _ ret </%> ( byte [ ] input , uint ilen , byte [ ] output ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern int cipher _ get _ size _ ex ( ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern int _ ptr cipher _ info _ from _ string ( string cipher _ name ) ;
dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern int cipher _ get _ size _ ex ( ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern int _ ptr cipher _ info _ from _ string ( string cipher _ name ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern void cipher _ init ( int _ ptr ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern int cipher _ setup ( int _ ptr ctx , int _ ptr cipher _ info ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern int cipher _ setkey ( int _ ptr ctx , byte [ ] key , int key _ bitlen , int operation ) ;
{ private configuration config ; <%> <-> private bool share _ over _ lan ; socket listener ; </%> public local ( configuration config ) { this . config = config ; <%> <-> share _ over _ lan = config . share _ over _ lan ; } public void start ( ) </%>
public local ( configuration config ) { this . config = config ; <%> <-> share _ over _ lan = config . share _ over _ lan ; } public void start ( ) { try { listener = new socket ( address _ family . inter _ network , socket _ type . stream , protocol _ type . tcp ) ; </%>
} } class handler { public i _ encryptor encryptor ; public server server ; public socket remote ; public socket connection ; <%> <+> private byte [ ] first _ packet ; private int first _ packet _ length ; </%>
if ( bytes _ read > 1 ) { byte [ ] response = { NUM , 0 } ; if ( <%> <*> connetion _ recv -> first </%> _ <%> <*> buffer -> packet </%> [ 0 ] ! = NUM ) { response = new byte [ ] { 0 , NUM } ; console . write _ line ( STR ) ; } connection . begin _ send ( response , 0 , response . length , 0 , new async _ callback ( handshake _ send _ callback ) , null ) ; }
{ response = new byte [ ] { 0 , NUM } ; console . write _ line ( STR ) ; } connection . begin _ send ( response , 0 , response . length , 0 , new async _ callback ( handshake _ send _ callback ) , null ) ; } else { this . close ( ) ; }
} polipo _ runner . stop ( ) ; try { polipo _ runner . start ( config ) ; <%> <*> local = new local ( config ) ; local . start ( ) ; -> local local = new local ( config ) ; </%> <%> <+> list < listener . service > services = new list < listener . service > ( ) ; services . add ( local ) ; </%>
pac _ server . start ( config ) ; } catch ( exception e ) { if ( e is socket _ exception ) { socket _ exception se = ( socket _ exception ) e ; if ( se . socket _ error _ code = = socket _ error . access _ denied ) { e = new exception ( n . get _ string ( STR ) , e ) ;
this . value _ label . tab _ index = NUM ; <%> <+> this . value _ label . text = STR ; </%>
{ new data _ unit ( state . geolocation , state . unknown ) , new data _ unit ( state . isp , state . unknown ) } ; <%> <+> } private static async task < data _ list > get _ info _ from _ api ( string api ) { </%> string json _ string ; try {
} dynamic obj ; if ( ! simple _ json . simple _ json . try _ deserialize _ object ( json _ string , out obj ) ) return <%> <*> ret -> null </%> ; string country = obj [ STR ] ; string city = obj [ STR ] ; string isp = obj [ STR ] ; <%> <*> string region _ name -> if ( country = = null | | city = = null | | isp = </%> = <%> <*> obj [ STR ] -> null ) return null </%> ; <%> <-> if ( country = = null | | city = = null | | isp = = null | | region _ name = = null ) </%> return <%> <*> ret ; -> new data _ list { </%> <%> <-> ret [ 0 ] = </%> new data _ unit ( state . geolocation , $ STR ) <%> <*> ; -> , </%> <%> <-> ret [ 1 ] = </%> new data _ unit ( state . isp , isp ) <%> <-> ; </%>
string country = obj [ STR ] ; string city = obj [ STR ] ; string isp = obj [ STR ] ; <%> <*> string region _ name -> if ( country = = null | | city = = null | | isp = </%> = <%> <*> obj [ STR ] -> null ) return null </%> ; <%> <-> if ( country = = null | | city = = null | | isp = = null | | region _ name = = null ) </%> return <%> <*> ret ; -> new data _ list { </%> <%> <-> ret [ 0 ] = </%> new data _ unit ( state . geolocation , $ STR ) <%> <*> ; -> , </%> <%> <-> ret [ 1 ] = </%> new data _ unit ( state . isp , isp ) <%> <-> ; </%> <%> <*> return ret -> } </%> ; } private async task < list < data _ list > > icmp _ test ( server server )
} private async task < list < data _ list > > icmp _ test ( server server ) { logging . debug ( STR + server . friendly _ name ( ) ) ; if ( server . server = = STR ) return null ; var ip = dns . get _ host _ addresses ( server . server ) . first ( ip = > ip . address _ family = = address _ family . inter _ network ) ; var ping = new ping ( ) ; var ret = new list < data _ list > ( ) ; foreach ( var timestamp in enumerable . range ( 0 , repeat ) . select ( = > date _ time . now . to _ string ( date _ time _ pattern ) ) )
{ <%> <+> string server _ name = servers [ server _ selector . selected _ index ] ; </%> data _ table . rows . clear ( ) ; list < availability _ statistics . raw _ statistics _ data > statistics ; if ( ! controller . availability _ statistics . filtered _ statistics . try _ get _ value ( server _ name , out statistics ) ) return ; <%> <*> foreach ( var data in statistics ) -> i _ enumerable < i _ grouping < int , availability _ statistics . raw _ statistics _ data > > data _ groups ; </%> <%> <+> if ( all _ mode . checked ) </%> { <%> <-> data _ table . rows . add ( data . timestamp , ( float ) new random ( ) . next ( ) % NUM , new random ( ) . next ( ) % NUM ) ; </%>
{ <%> <*> data _ table . rows . add ( data . timestamp , ( float ) new random ( ) . next ( ) % NUM , new random ( ) . next ( ) % NUM ) ; -> data _ groups = statistics . group _ by ( data = > data . timestamp . day _ of _ year ) ; </%> <%> <+> statistics _ chart . chart _ areas [ STR ] . axis _ x . label _ style . format = STR ; statistics _ chart . chart _ areas [ STR ] . axis . label _ style . format = STR ; </%> } <%> <+> else { data _ groups = statistics . group _ by ( data = > data . timestamp . hour ) ; statistics _ chart . chart _ areas [ STR ] . axis _ x . label _ style . format = STR ; </%>
} <%> <+> else { data _ groups = statistics . group _ by ( data = > data . timestamp . hour ) ; statistics _ chart . chart _ areas [ STR ] . axis _ x . label _ style . format = STR ; statistics _ chart . chart _ areas [ STR ] . axis . label _ style . format = STR ; } var final _ data = from data _ group in data _ groups orderby data _ group . key select new </%>
} } }
( ( system . component _ model . i _ support _ initialize ) ( this . statistics _ chart ) ) . begin _ init ( ) ; this . <%> <*> group -> chart _ mode </%> _ <%> <*> box -> selector </%> . suspend _ layout ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . begin _ init ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . suspend _ layout ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . begin _ init ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . suspend _ layout ( ) ;
( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . begin _ init ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . suspend _ layout ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . begin _ init ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . suspend _ layout ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . data _ collection _ minutes _ num ) ) . begin _ init ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . choice _ kept _ minutes _ num ) ) . begin _ init ( ) ;
this . auto _ scale _ mode = system . windows . forms . auto _ scale _ mode . font ; this . auto _ size = true ; this . client _ size = new system . drawing . size ( NUM , NUM ) ; this . controls . add ( this . split _ container ) ; this . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . minimum _ size = new system . drawing . size ( NUM , NUM ) ; this . name = STR ; this . text = STR ; ( ( system . component _ model . i _ support _ initialize ) ( this . statistics _ chart ) ) . end _ init ( ) ; this . <%> <*> group -> chart _ mode </%> _ <%> <*> box -> selector </%> . resume _ layout ( false ) ;
this . split _ container . panel . resume _ layout ( false ) ; this . split _ container . panel . resume _ layout ( false ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . end _ init ( ) ; this . split _ container . resume _ layout ( false ) ; this . split _ container . panel . resume _ layout ( false ) ; this . split _ container . panel . perform _ layout ( ) ; this . split _ container . panel . resume _ layout ( false ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . end _ init ( ) ; this . split _ container . resume _ layout ( false ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . data _ collection _ minutes _ num ) ) . end _ init ( ) ;

} } else { registry . set _ value ( STR , 0 ) ; registry . set _ value ( STR , STR ) ; registry . set _ value ( STR , STR ) ; } system _ proxy . notify _ ie ( ) ; copy _ proxy _ setting _ from _ lan ( ) ;
{ string argument = STR + update _ checker . latest _ version _ local _ name + STR ; <%> <-> system . diagnostics . </%> process . start ( STR , argument ) ; } } } private void notify _ icon _ balloon _ tip _ closed ( object sender , event _ args e ) { if ( update _ checker . new _ version _ found ) {
} } } private void notify _ icon _ balloon _ tip _ closed ( object sender , event _ args e ) { if ( update _ checker . new _ version _ found ) { update _ checker . new _ version _ found = false ; } }
namespace shadowsocks _ controller { class availability _ statistics { private <%> <*> static readonly -> const </%> string statistics _ files _ name = STR ; private <%> <*> static readonly -> const </%> string delimiter = STR ; private <%> <*> static readonly -> const </%> int timeout = NUM ; private <%> <*> static readonly -> const </%> int repeat = NUM ; private <%> <*> static readonly -> const </%> int interval = NUM * NUM * NUM ; private timer timer <%> <-> = null </%> ;
public static string availability _ statistics _ file ; static availability _ statistics ( ) { <%> <*> string -> var </%> temppath = path . get _ temp _ path ( ) ; availability _ statistics _ file = path . combine ( temppath , statistics _ files _ name ) ; } public bool set ( bool enabled ) { try {
availability _ statistics _ file = path . combine ( temppath , statistics _ files _ name ) ; } public bool set ( bool enabled ) { try { if ( enabled ) { <%> <*> if ( timer ? . change ( 0 , interval ) = = null ) { -> if ( timer ? . change ( 0 , interval ) ! = null ) return true ; </%>
} else { timer ? . dispose ( ) ; } return true ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ;
{ logging . debug ( STR + server . friendly _ name ( ) ) ; foreach ( var in enumerable . range ( 0 , repeat ) ) { <%> <*> string -> var </%> timestamp = date _ time . now . to _ string ( STR ) ; <%> <*> ping _ reply -> var </%> reply = ping . send ( server . server , timeout ) ; state . data = new list < key _ value _ pair < string , string > > <%> <*> ( ) ; state . data . add ( new key _ value _ pair < string , string > ( STR , timestamp ) ) ; -> { </%> <%> <-> state . data . add ( </%> new key _ value _ pair < string , string > ( STR , <%> <*> server . friendly _ name ( -> timestamp </%> ) <%> <*> ) ) ; -> , </%> <%> <-> state . data . add ( </%> new key _ value _ pair < string , string > ( STR , <%> <*> reply . status -> server </%> . <%> <*> to -> friendly </%> _ <%> <*> string -> name </%> ( ) ) <%> <*> ) ; -> , </%>
<%> <*> ping _ reply -> var </%> reply = ping . send ( server . server , timeout ) ; state . data = new list < key _ value _ pair < string , string > > <%> <*> ( ) ; state . data . add ( new key _ value _ pair < string , string > ( STR , timestamp ) ) ; -> { </%> <%> <-> state . data . add ( </%> new key _ value _ pair < string , string > ( STR , <%> <*> server . friendly _ name ( -> timestamp </%> ) <%> <*> ) ) ; -> , </%> <%> <-> state . data . add ( </%> new key _ value _ pair < string , string > ( STR , <%> <*> reply . status -> server </%> . <%> <*> to -> friendly </%> _ <%> <*> string -> name </%> ( ) ) <%> <*> ) ; -> , </%> <%> <-> state . data . add ( </%> new key _ value _ pair < string , string > ( STR , reply <%> <+> ? </%> . <%> <*> roundtrip _ time -> status </%> . to _ string ( ) ) <%> <*> ) ; -> , </%> <%> <+> new key _ value _ pair < string , string > ( STR , reply ? . roundtrip _ time . to _ string ( ) ) } ; </%> append ( state . data ) ; }
append ( state . data ) ; } } } private static void append ( list < key _ value _ pair < string , string > > data ) { <%> <*> string -> var </%> data _ line = string . join ( delimiter , data . select ( kv = > kv . value ) . to _ array ( ) ) ; string [ ] lines ; if ( ! file . exists ( availability _ statistics _ file ) ) {
string [ ] lines ; if ( ! file . exists ( availability _ statistics _ file ) ) { <%> <*> string -> var </%> header _ line = string . join ( delimiter , data . select ( kv = > kv . key ) . to _ array ( ) ) ; lines = new <%> <-> string </%> [ ] { header _ line , data _ line } ; } else { lines = new <%> <-> string </%> [ ] { data _ line } ; }
} else { lines = new <%> <-> string </%> [ ] { data _ line } ; } file . append _ all _ lines ( availability _ statistics _ file , lines ) ; } internal void update _ configuration ( configuration config ) { set ( config . availability _ statistics ) ;
} file . append _ all _ lines ( availability _ statistics _ file , lines ) ; } internal void update _ configuration ( configuration config ) { set ( config . availability _ statistics ) ; servers = config . configs ; } private class state {
using system _ collections _ generic ; using system _ linq ; using system _ net ; using system _ net _ sockets ; using system _ timers ; <%> <+> using n _ log ; </%> using shadowsocks _ controller _ strategy ; using shadowsocks _ encryption ; using shadowsocks _ encryption _ aead ; using shadowsocks _ encryption _ exception ;
{ public event event _ handler < sstcp _ connected _ event _ args > on _ connected ; public event event _ handler < ss _ transmit _ event _ args > on _ inbound ; public event event _ handler < ss _ transmit _ event _ args > on _ outbound ; public event event _ handler < ss _ relay _ event _ args > on _ failed ; private static <%> <+> readonly </%> logger logger = log _ manager . get _ current _ class _ logger ( ) ; private <%> <+> readonly </%> shadowsocks _ controller controller ; private date _ time last _ sweep _ time ; private <%> <+> readonly </%> configuration config ; public i _ set < tcp _ handler > handlers { get ; set ; }
private date _ time last _ sweep _ time ; private <%> <+> readonly </%> configuration config ; public i _ set < tcp _ handler > handlers { get ; set ; } public tcp _ relay ( shadowsocks _ controller controller , configuration conf ) { controller = controller ; config = conf ; handlers = new hash _ set < tcp _ handler > ( ) ; last _ sweep _ time = date _ time . now ; }
public i _ set < tcp _ handler > handlers { get ; set ; } public tcp _ relay ( shadowsocks _ controller controller , configuration conf ) { controller = controller ; config = conf ; handlers = new hash _ set < tcp _ handler > ( ) ; last _ sweep _ time = date _ time . now ; } public override bool handle ( byte [ ] first _ packet , int length , socket socket , object state ) {
{ public i _ proxy remote { get ; } public async _ session ( i _ proxy remote ) { remote = remote ; } } <%> <+> private </%> class async _ session < t > : async _ session { public t state { get ; set ; }
{ public t state { get ; set ; } public async _ session ( i _ proxy remote , t state ) : base ( remote ) { state = state ; } public async _ session ( async _ session session , t state ) : base ( session . remote ) { state = state ; }
private readonly int server _ timeout ; private readonly int proxy _ timeout ; public const int recv _ size = NUM ; public const int chunk _ overhead _ size = NUM * 2 public const uint max _ chunk _ size = aead _ encryptor . chunk _ len _ mask + aead _ encryptor . chunk _ len _ bytes + NUM * 2 ; public const int buffer _ size = recv _ size + ( int ) max _ chunk _ size + NUM public date _ time last _ activity ; private <%> <+> readonly </%> shadowsocks _ controller controller ; private <%> <+> readonly </%> proxy _ config config ; private <%> <+> readonly </%> socket connection ;
private i _ encryptor encryptor ; private server server ; private async _ session current _ remote _ session ; private bool proxy _ connected ; private bool dest _ connected ; private byte command ; private byte [ ] first _ packet ; private int first _ packet _ length ; private const int cmd _ connect = 0 ; private const int cmd _ bind = 0 ;
private <%> <+> readonly </%> byte [ ] connetion _ recv _ buffer = new byte [ buffer _ size ] ; private <%> <+> readonly </%> byte [ ] remote _ send _ buffer = new byte [ buffer _ size ] ; private <%> <+> readonly </%> byte [ ] connetion _ send _ buffer = new byte [ buffer _ size ] ; private bool connection _ shutdown = false ; private bool remote _ shutdown = false ; private bool closed = false ; private readonly object encryption _ lock = new object ( ) ; private readonly object decryption _ lock = new object ( ) ; private readonly object close _ conn _ lock = new object ( ) ; private date _ time start _ connect _ time ;
private <%> <+> readonly </%> byte [ ] remote _ send _ buffer = new byte [ buffer _ size ] ; private <%> <+> readonly </%> byte [ ] connetion _ send _ buffer = new byte [ buffer _ size ] ; private bool connection _ shutdown = false ; private bool remote _ shutdown = false ; private bool closed = false ; private readonly object encryption _ lock = new object ( ) ; private readonly object decryption _ lock = new object ( ) ; private readonly object close _ conn _ lock = new object ( ) ; private date _ time start _ connect _ time ; private date _ time start _ receiving _ time ;
private <%> <+> readonly </%> byte [ ] connetion _ send _ buffer = new byte [ buffer _ size ] ; private bool connection _ shutdown = false ; private bool remote _ shutdown = false ; private bool closed = false ; private readonly object encryption _ lock = new object ( ) ; private readonly object decryption _ lock = new object ( ) ; private readonly object close _ conn _ lock = new object ( ) ; private date _ time start _ connect _ time ; private date _ time start _ receiving _ time ; private date _ time start _ sending _ time ;
private bool connection _ shutdown = false ; private bool remote _ shutdown = false ; private bool closed = false ; private readonly object encryption _ lock = new object ( ) ; private readonly object decryption _ lock = new object ( ) ; private readonly object close _ conn _ lock = new object ( ) ; private date _ time start _ connect _ time ; private date _ time start _ receiving _ time ; private date _ time start _ sending _ time ; private end _ point dest _ end _ point = null ;
logger . trace ( $ STR ) ; encryptor . addr _ buf _ length = addr _ buf _ length ; } public void start ( byte [ ] first _ packet , int length ) { first _ packet = first _ packet ; first _ packet _ length = length ; handshake _ receive ( ) ; } private void check _ close ( )
closed = true ; } on _ closed ? . invoke ( this , new ss _ relay _ event _ args ( server ) ) ; try { connection . shutdown ( socket _ shutdown . both ) ; connection . close ( ) ; } catch ( exception e ) {
} } private void handshake _ send _ callback ( i _ async _ result ar ) { <%> <*> if ( closed ) return ; -> if ( closed ) </%> <%> <+> { return ; } </%> try
try { connection . end _ send ( ar ) ; connection . begin _ receive ( connetion _ recv _ buffer , 0 , NUM + addr _ atyp _ len + 1 , socket _ flags . none , <%> <*> handshake -> address </%> _ receive _ callback , null ) ; } catch ( exception e ) { <%> <*> logger . log _ useful _ exception ( e ) ; -> error _ </%> close ( <%> <+> e </%> ) ;
try { int bytes _ read = connection . end _ receive ( ar ) ; if ( bytes _ read > = NUM ) { command = connetion _ recv _ buffer [ 1 ] ; switch ( command ) { case cmd _ connect : byte [ ] response = { NUM , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 } ;
{ try { connection . end _ send ( ar ) ; read _ address ( start _ connect ) ; } catch ( exception e ) { <%> <-> logger . log _ useful _ exception ( e ) ; close ( ) ; </%>
} } private void read _ address ( action on _ success ) { int atyp = connetion _ recv _ buffer [ NUM ] ; switch ( atyp ) { case atyp _ i _ pv : read _ address ( NUM + addr _ port _ len - 1 , on _ success ) ; break ;
try { int bytes _ read = connection . end _ receive ( ar ) ; <%> <*> var -> object [ ] </%> states = ( object [ ] ) ar . async _ state ; int bytes _ remain = ( int ) states [ 0 ] ; <%> <*> var -> action </%> on _ success = ( action ) states [ 1 ] ; if ( bytes _ read > = bytes _ remain ) { first _ packet _ length = bytes _ read + 2 ; int atyp = connetion _ recv _ buffer [ 0 ] ;
int bytes _ remain = ( int ) states [ 0 ] ; <%> <*> var -> action </%> on _ success = ( action ) states [ 1 ] ; if ( bytes _ read > = bytes _ remain ) { first _ packet _ length = bytes _ read + 2 ; int atyp = connetion _ recv _ buffer [ 0 ] ; string dst _ addr = STR ; int dst _ port = - 1 ; switch ( atyp ) {
if ( bytes _ read > = bytes _ remain ) { first _ packet _ length = bytes _ read + 2 ; int atyp = connetion _ recv _ buffer [ 0 ] ; string dst _ addr = STR ; int dst _ port = - 1 ; switch ( atyp ) { case atyp _ i _ pv : dst _ addr = new ip _ address ( connetion _ recv _ buffer . skip ( 1 ) . take ( NUM ) . to _ array ( ) ) . to _ string ( ) ;
} } private class proxy _ timer : timer { public async _ session session ; public end _ point dest _ end _ point ; public server server ; public proxy _ timer ( int p ) : base ( p ) { }
} } private void proxy _ connect _ timer _ elapsed ( object sender , elapsed _ event _ args e ) { <%> <*> var -> proxy _ timer </%> timer = ( proxy _ timer ) sender ; timer . elapsed - = proxy _ connect _ timer _ elapsed ; timer . enabled = false ; timer . dispose ( ) ; if ( proxy _ connected | | dest _ connected | | closed ) {
timer . elapsed - = proxy _ connect _ timer _ elapsed ; timer . enabled = false ; timer . dispose ( ) ; if ( proxy _ connected | | dest _ connected | | closed ) { return ; } <%> <*> var -> i _ proxy </%> proxy = timer . session . remote ; logger . info ( $ STR ) ; proxy . close ( ) ;
logger . info ( $ STR ) ; proxy . close ( ) ; close ( ) ; } private void proxy _ connect _ callback ( i _ async _ result ar ) { if ( closed ) { return ; }
proxy _ timer timer = session . state ; <%> <*> var -> end _ point </%> dest _ end _ point = timer . dest _ end _ point ; <%> <*> var -> server </%> server = timer . server ; timer . elapsed - = proxy _ connect _ timer _ elapsed ; timer . enabled = false ; timer . dispose ( ) ; <%> <*> var -> i _ proxy </%> remote = session . remote ; remote . end _ connect _ proxy ( ar ) ; proxy _ connected = true ; if ( ! ( remote is direct _ connect ) )
timer . elapsed - = proxy _ connect _ timer _ elapsed ; timer . enabled = false ; timer . dispose ( ) ; <%> <*> var -> i _ proxy </%> remote = session . remote ; remote . end _ connect _ proxy ( ar ) ; proxy _ connected = true ; if ( ! ( remote is direct _ connect ) ) { logger . debug ( $ STR ) ; }
remote . end _ connect _ proxy ( ar ) ; proxy _ connected = true ; if ( ! ( remote is direct _ connect ) ) { logger . debug ( $ STR ) ; } start _ connect _ time = date _ time . now ; server _ timer connect _ timer = new server _ timer ( server _ timeout ) { auto _ reset = false } ; connect _ timer . elapsed + = dest _ connect _ timer _ elapsed ; connect _ timer . enabled = true ;
} } private void dest _ connect _ timer _ elapsed ( object sender , elapsed _ event _ args e ) { <%> <*> var -> server _ timer </%> timer = ( server _ timer ) sender ; timer . elapsed - = dest _ connect _ timer _ elapsed ; timer . enabled = false ; timer . dispose ( ) ; if ( dest _ connected | | closed ) {
timer . elapsed - = dest _ connect _ timer _ elapsed ; timer . enabled = false ; timer . dispose ( ) ; if ( dest _ connected | | closed ) { return ; } <%> <*> var -> async _ session </%> session = timer . session ; server server = timer . server ; on _ failed ? . invoke ( this , new ss _ relay _ event _ args ( server ) ) ;
server server = timer . server ; on _ failed ? . invoke ( this , new ss _ relay _ event _ args ( server ) ) ; logger . info ( $ STR ) ; session . remote . close ( ) ; close ( ) ; } private void connect _ callback ( i _ async _ result ar ) { <%> <+> if ( closed ) { </%>
server _ timer timer = session . state ; server = timer . server ; timer . elapsed - = dest _ connect _ timer _ elapsed ; timer . enabled = false ; timer . dispose ( ) ; <%> <*> var -> i _ proxy </%> remote = session . remote ; remote . end _ connect _ dest ( ar ) ; dest _ connected = true ; logger . debug ( $ STR ) ; <%> <*> var -> time _ span </%> latency = date _ time . now - start _ connect _ time ;
remote . end _ connect _ dest ( ar ) ; dest _ connected = true ; logger . debug ( $ STR ) ; <%> <*> var -> time _ span </%> latency = date _ time . now - start _ connect _ time ; on _ connected ? . invoke ( this , new sstcp _ connected _ event _ args ( server , latency ) ) ; start _ pipe ( session ) ; } catch ( argument _ exception ) { }
on _ connected ? . invoke ( this , new sstcp _ connected _ event _ args ( server , latency ) ) ; start _ pipe ( session ) ; } catch ( argument _ exception ) { } catch ( exception e ) { if ( server ! = null ) {
} } private void try _ read _ available _ data ( ) { int available = math . min ( connection . available , recv _ size - first _ packet _ length ) ; if ( available > 0 ) { <%> <*> var -> int </%> size = connection . receive ( connetion _ recv _ buffer , first _ packet _ length , available , socket _ flags . none ) ; first _ packet _ length + = size ;
socket _ flags . none ) ; first _ packet _ length + = size ; } } private void start _ pipe ( async _ session session ) { <%> <*> if ( closed ) return ; -> if ( closed ) </%> <%> <+> { return ; </%>
try { start _ receiving _ time = date _ time . now ; session . remote . begin _ receive ( remote _ recv _ buffer , 0 , recv _ size , socket _ flags . none , pipe _ remote _ receive _ callback , session ) ; try _ read _ available _ data ( ) ; logger . trace ( $ STR ) ; send _ to _ server ( first _ packet _ length , session ) ; } catch ( exception e )
} } private void pipe _ remote _ receive _ callback ( i _ async _ result ar ) { <%> <*> if ( closed ) return ; -> if ( closed ) { return ; </%> <%> <+> } </%> try {
int bytes _ read = session . remote . end _ receive ( ar ) ; total _ read + = bytes _ read ; on _ inbound ? . invoke ( this , new ss _ transmit _ event _ args ( server , bytes _ read ) ) ; if ( bytes _ read > 0 ) { last _ activity = date _ time . now ; int bytes _ to _ send = - 1 ; lock ( decryption _ lock ) { try
} } private void pipe _ connection _ receive _ callback ( i _ async _ result ar ) { <%> <*> if ( closed ) return ; -> if ( closed ) </%> <%> <+> { return ; } </%> try
try { int bytes _ read = connection . end _ receive ( ar ) ; <%> <*> var -> async _ session </%> session = ( async _ session ) ar . async _ state ; <%> <*> var -> i _ proxy </%> remote = session . remote ; if ( bytes _ read > 0 ) { send _ to _ server ( bytes _ read , session ) ; } else
if ( bytes _ read > 0 ) { send _ to _ server ( bytes _ read , session ) ; } else { remote . shutdown ( socket _ shutdown . send ) ; remote _ shutdown = true ; check _ close ( ) ; }
} } private void pipe _ connection _ send _ callback ( i _ async _ result ar ) { try { <%> <*> var -> object [ ] </%> container = ( object [ ] ) ar . async _ state ; <%> <*> var -> async _ session </%> session = ( async _ session ) container [ 0 ] ; <%> <*> var -> int </%> bytes _ should _ send = ( int ) container [ 1 ] ; <%> <*> var -> int </%> bytes _ sent = connection . end _ send ( ar ) ;
if ( bytes _ remaining > 0 ) { logger . info ( STR ) ; buffer . block _ copy ( remote _ send _ buffer , bytes _ sent , remote _ send _ buffer , 0 , bytes _ remaining ) ; connection . begin _ send ( remote _ send _ buffer , 0 , bytes _ remaining , socket _ flags . none , pipe _ connection _ send _ callback , new object [ ] { session , bytes _ remaining } ) ; return ; } session . remote . begin _ receive ( remote _ recv _ buffer , 0 , recv _ size , socket _ flags . none , pipe _ remote _ receive _ callback , session ) ;
private menu _ item edit _ pac _ file _ item ; private menu _ item qr _ code _ item ; private menu _ item show _ log _ item ; private menu _ item about _ item ; private menu _ item servers _ item ; private menu _ item <%> <*> menu -> seperator </%> _ item ; private menu _ item quit _ item ; private menu _ item <%> <*> menu -> seperator </%> _ item ;
private menu _ item quit _ item ; private menu _ item <%> <*> menu -> seperator </%> _ item ;

this . context _ menu . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . enable _ item , this . mode _ item , this . servers _ item , this . <%> <*> menu -> seperator </%> _ item , this . auto _ startup _ item , this . share _ over _ lan _ item , this . edit _ pac _ file _ item , this . <%> <*> menu -> seperator </%> _ item , this . qr _ code _ item ,
this . auto _ startup _ item , this . share _ over _ lan _ item , this . edit _ pac _ file _ item , this . <%> <*> menu -> seperator </%> _ item , this . qr _ code _ item , this . show _ log _ item , this . about _ item , this . <%> <*> menu -> seperator </%> _ item , this . quit _ item } ) ; <%> <-> this . enable _ item . index = 0 ; </%>
this . qr _ code _ item , this . show _ log _ item , this . about _ item , this . <%> <*> menu -> seperator </%> _ item , this . quit _ item } ) ; <%> <-> this . enable _ item . index = 0 ; this . enable _ item . text = n . get _ string ( STR ) ; this . enable _ item . click + = new system . event _ handler ( this . enable _ item _ click ) ; this . mode _ item . index = 1 ; this . mode _ item . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { </%>
this . quit _ item } ) ; <%> <-> this . enable _ item . index = 0 ; this . enable _ item . text = n . get _ string ( STR ) ; this . enable _ item . click + = new system . event _ handler ( this . enable _ item _ click ) ; this . mode _ item . index = 1 ; this . mode _ item . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . pac _ mode _ item , this . global _ mode _ item } ) ; this . mode _ item . text = n . get _ string ( STR ) ; this . pac _ mode _ item . index = 0 ; </%>
} private void controller _ config _ changed ( object sender , event _ args e ) { load _ current _ configuration ( ) ; update _ tray _ icon ( ) ; } private void controller _ enable _ status _ changed ( object sender , event _ args e ) { enable _ item . checked = controller . get _ configuration ( ) . enabled ; }
handler . send ( first _ packet , length ) ; handler . receive ( ) ; return true ; } <%> <+> public </%> class udp _ handler { private socket local ; private socket remote ; private server server ; private byte [ ] buffer = new byte [ NUM ] ;
{ private socket local ; private socket remote ; private server server ; private byte [ ] buffer = new byte [ NUM ] ; private ip _ end _ point local _ end _ point ; private ip _ end _ point remote _ end _ point ; public udp _ handler ( socket local , server server , ip _ end _ point local _ end _ point ) { local = local ;
} private void ok _ button _ click ( object sender , event _ args e ) { if ( <%> <+> modified _ proxy _ config . use _ proxy = </%> use _ proxy _ check _ box . checked ) { <%> <*> int port ; int timeout ; if ( ! int . try _ parse ( proxy _ port _ text _ box . text , out port ) ) -> if ( ! int . try _ parse ( proxy _ port _ text _ box . text , out modified _ proxy _ config . proxy _ port ) ) </%> {
{ <%> <*> int port ; int timeout ; if ( ! int . try _ parse ( proxy _ port _ text _ box . text , out port ) ) -> if ( ! int . try _ parse ( proxy _ port _ text _ box . text , out modified _ proxy _ config . proxy _ port ) ) </%> { message _ box . show ( n . get _ string ( STR ) ) ; return ; } if ( ! int . try _ parse ( proxy _ timeout _ text _ box . text , out <%> <+> modified _ proxy _ config . proxy _ </%> timeout ) )
{ message _ box . show ( n . get _ string ( STR ) ) ; return ; } if ( ! int . try _ parse ( proxy _ timeout _ text _ box . text , out <%> <+> modified _ proxy _ config . proxy _ </%> timeout ) ) { message _ box . show ( n . get _ string ( STR ) ) ; return ; } <%> <-> var type = proxy _ type _ combo _ box . selected _ index ; </%>
{ message _ box . show ( n . get _ string ( STR ) ) ; return ; } <%> <*> var type = proxy _ type _ combo _ box . selected _ index ; var proxy = proxy _ server _ text _ box . text ; -> modified _ proxy _ config . proxy _ type = proxy _ type _ combo _ box . selected _ index ; </%> try { configuration . check _ server ( <%> <+> modified _ </%> proxy <%> <*> ) ; -> _ config . proxy _ server = proxy _ server _ text _ box . text ) ; </%>
try { configuration . check _ server ( <%> <+> modified _ </%> proxy <%> <*> ) ; -> _ config . proxy _ server = proxy _ server _ text _ box . text ) ; </%> configuration . check _ port ( <%> <+> modified _ proxy _ config . proxy _ </%> port ) ; configuration . check _ timeout ( <%> <+> modified _ proxy _ config . proxy _ </%> timeout , proxy _ config . max _ proxy _ timeout _ sec ) ; } catch ( exception ex ) { message _ box . show ( ex . message ) ; return ;
} catch ( exception ex ) { message _ box . show ( ex . message ) ; return ; } <%> <-> controller . enable _ proxy ( type , proxy , port , timeout ) ; </%> } <%> <-> else { </%>
} <%> <*> else { controller . disable _ proxy ( ) ; } -> controller . save _ proxy ( modified _ proxy _ config ) ; </%> this . close ( ) ; } private void cancel _ button _ click ( object sender , event _ args e ) {
this . close ( ) ; } private void cancel _ button _ click ( object sender , event _ args e ) { this . close ( ) ; } private void proxy _ form _ form _ closed ( object sender , form _ closed _ event _ args e ) { controller . config _ changed - = controller _ config _ changed ; }
proxy _ type _ combo _ box . enabled = true ; } else { proxy _ server _ text _ box . enabled = <%> <-> false ; </%> proxy _ port _ text _ box . enabled = <%> <-> false ; </%> proxy _ timeout _ text _ box . enabled = <%> <-> false ; </%> proxy _ type _ combo _ box . enabled = false ; } }
} } } }
public void start ( configuration configuration ) { <%> <-> server server = configuration . get _ current _ server ( ) ; </%> if ( process = = null ) { process [ ] existing _ privoxy = process . get _ processes _ by _ name ( STR ) ; foreach ( process p in existing _ privoxy . where ( is _ child _ process ) ) { kill _ process ( p ) ; }
if ( process = = null ) { process [ ] existing _ privoxy = process . get _ processes _ by _ name ( STR ) ; foreach ( process p in existing _ privoxy . where ( is _ child _ process ) ) { kill _ process ( p ) ; } string privoxy _ config = resources . privoxy _ conf ; running _ port = this . get _ free _ port ( ) ; privoxy _ config = privoxy _ config . replace ( STR , configuration . local _ port . to _ string ( ) ) ;
} catch ( exception e ) { logging . log _ useful _ exception ( e ) ; return default _ port ; } <%> <-> throw new exception ( STR ) ; </%> } struct _ layout _ layout _ kind _ sequential public struct rect
} struct _ layout _ layout _ kind _ sequential public struct rect { public int left ; public int top ; public int right ; public int bottom ; } dll _ import _ user _ dll
{ <%> <+> string rule ; while ( ( rule = sr . read _ line ( ) ) ! = null ) { </%> if ( <%> <+> rule = = STR | | </%> rule [ 0 ] = = '!' | | rule [ 0 ] = = '[' ) continue ; lines . add ( rule ) ; <%> <+> } </%> } }
} } string abp _ content ; if ( file . exists ( pac _ server . user _ abp _ file ) ) { abp _ content = file . read _ all _ text ( pac _ server . user _ abp _ file , encoding . ut ) ; } else { abp _ content = utils . un _ gzip ( resources . abp _ js ) ;
{ <%> <+> string line ; while ( ( line = sr . read _ line ( ) ) ! = null ) { </%> if ( <%> <+> line = = STR | | </%> line [ 0 ] = = '!' | | line [ 0 ] = = '[' ) continue ; valid _ lines . add ( line ) ; <%> <+> } </%> } return valid _ lines ;
} return valid _ lines ; } } }
using system _ drawing ; using system _ windows _ forms ; <%> <+> using newtonsoft _ json ; </%> namespace shadowsocks _ model { serializable public class log _ viewer _ config { <%> <-> public string font _ name ; public float font _ size ; </%>
public bool top _ most ; public bool wrap _ text ; public bool toolbar _ shown ; public int width ; public int height ; public int top ; public int left ; public bool maximized ; public log _ viewer _ config ( ) {
top _ most = false ; wrap _ text = false ; toolbar _ shown = false ; <%> <-> width = NUM ; height = NUM ; left = get _ best _ left ( ) ; top = get _ best _ top ( ) ; maximized = true ; </%> } <%> <+> public void save _ size ( ) </%>
} <%> <+> public void save _ size ( ) { properties . settings . default . save ( ) ; } json _ ignore public int width { get { return properties . settings . default . log _ viewer _ width ; } set { properties . settings . default . log _ viewer _ width = value ; } </%>
{ <%> <-> width = ( width > = NUM ) ? width : NUM ; return screen . primary _ screen . working _ area . width - width ; } public int get _ best _ top ( ) { height = ( height > = NUM ) ? height : NUM ; return screen . primary _ screen . working _ area . height - height ; } public font get _ font ( ) </%>
{ return new font ( font _ name , font _ size , font _ style . regular ) ; } catch ( exception ) { } } <%> <*> public void set _ font ( font font ) -> json _ ignore </%> <%> <+> public int best _ top </%>
{ <%> <*> font _ name = font . name ; font _ size = font . size ; } public color get _ background _ color ( ) { try -> get </%> { <%> <-> return color _ translator . from _ html ( bg _ color ) ; </%>
{ <%> <*> return color _ translator . from _ html ( bg _ color ) ; } catch ( exception ) { return color _ translator . from _ html ( STR ) ; -> int height = height ; </%> <%> <+> height = ( height > = NUM ) ? height : NUM ; return screen . primary _ screen . working _ area . height - height ; </%> }
} } <%> <-> public void set _ background _ color ( color color ) { bg _ color = color _ translator . to _ html ( color ) ; } public color get _ text _ color ( ) { try { </%>
} }
} catch ( format _ exception ) { message _ box . show ( n . get _ string ( STR ) ) ; return ; } catch ( exception ex ) { message _ box . show ( ex . message ) ; return ;
namespace shadowsocks _ model { serializable public class proxy _ config { <%> <+> public const int proxy _ sock = 0 ; public const int proxy _ http = 1 ; </%> public bool use _ proxy ; <%> <+> public int proxy _ type ; </%> public string proxy _ server ;
this . table _ layout _ panel . controls . add ( this . use _ proxy _ check _ box , 0 , 0 ) ; <%> <+> this . table _ layout _ panel . controls . add ( this . table _ layout _ panel , 0 , 2 ) ; </%> this . table _ layout _ panel . controls . add ( this . table _ layout _ panel , 0 , 1 ) ; this . table _ layout _ panel . location = new system . drawing . point ( NUM , NUM ) ; this . table _ layout _ panel . name = STR ; this . table _ layout _ panel . row _ count = NUM ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; <%> <+> this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; </%>
this . table _ layout _ panel . location = new system . drawing . point ( NUM , NUM ) ; this . table _ layout _ panel . name = STR ; this . table _ layout _ panel . row _ count = NUM ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; <%> <+> this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; </%> this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ;

} public int end _ send ( i _ async _ result async _ result ) { return remote . end _ send ( async _ result ) ; } public void begin _ receive ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) { remote <%> <-> ? </%> . begin _ receive ( buffer , offset , size , socket _ flags , callback , state ) ; }
} public int end _ receive ( i _ async _ result async _ result ) { return remote . end _ receive ( async _ result ) ; } public void shutdown ( socket _ shutdown how ) { remote <%> <-> ? </%> . shutdown ( how ) ; } public void close ( )
} public void close ( ) { remote <%> <-> ? </%> . dispose ( ) ; } private void connect _ callback ( i _ async _ result ar ) { var state = ( socks _ state ) ar . async _ state ; try {
} private void connect _ callback ( i _ async _ result ar ) { var state = ( socks _ state ) ar . async _ state ; try { remote . end _ connect ( ar ) ; remote . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; byte [ ] handshake = { NUM , 1 , 0 } ; remote . begin _ send ( handshake , 0 , handshake . length , 0 , socks _ handshake _ send _ callback , state ) ;
{ config . proxy . use _ proxy = true ; <%> <+> config . proxy . proxy _ type = type ; </%> config . proxy . proxy _ server = proxy ; config . proxy . proxy _ port = port ; save _ config ( config ) ; } public void toggle _ verbose _ logging ( bool enabled ) { config . is _ verbose _ logging = enabled ;
xml _ document doc = new xml _ document ( ) ; <%> <+> xml _ element log _ file _ name _ element ; </%> xml _ element log _ level _ element ; <%> <-> xml _ element log _ file _ name _ element ; </%> public static n _ log _ config load _ xml ( ) { n _ log _ config config = new n _ log _ config ( ) ; config . doc . load ( nlog _ config _ file _ name ) ; config . log _ level _ element = ( xml _ element ) select _ single _ node ( config . doc , STR ) ; config . log _ file _ name _ element = ( xml _ element ) select _ single _ node ( config . doc , STR ) ;
public static n _ log _ config load _ xml ( ) { n _ log _ config config = new n _ log _ config ( ) ; config . doc . load ( nlog _ config _ file _ name ) ; config . log _ level _ element = ( xml _ element ) select _ single _ node ( config . doc , STR ) ; config . log _ file _ name _ element = ( xml _ element ) select _ single _ node ( config . doc , STR ) ; return config ; } public static void save _ xml ( n _ log _ config n _ log _ config ) {
} public void set _ log _ file _ name ( string file _ name ) { log _ file _ name _ element . set _ attribute ( <%> <+> logger _ </%> file _ name _ attribute , file _ name ) ; } private static xml _ node select _ single _ node ( xml _ document doc , string xpath ) { xml _ namespace _ manager manager = new xml _ namespace _ manager ( doc . name _ table ) ; manager . add _ namespace ( STR , STR ) ; return doc . select _ single _ node ( xpath , manager ) ;
using system _ collections _ generic ; using system _ diagnostics ; using system _ drawing ; <%> <-> using system _ text ; </%> using system _ windows _ forms ; using z _ xing ; using z _ xing _ common ; using z _ xing _ qr _ code ; <%> <+> using shadowsocks _ controller ; using shadowsocks _ model ; </%>
using system _ windows _ forms ; using z _ xing ; using z _ xing _ common ; using z _ xing _ qr _ code ; <%> <+> using shadowsocks _ controller ; using shadowsocks _ model ; using shadowsocks _ properties ; </%> namespace shadowsocks _ view { public class menu _ view _ controller
this . notify _ icon = new system . windows . forms . notify _ icon ( this . components ) ; this . context _ menu _ strip = new system . windows . forms . context _ menu _ strip ( this . components ) ; this . config _ item = new system . windows . forms . tool _ strip _ menu _ item ( ) ; this . about _ tool _ strip _ menu _ item = new system . windows . forms . tool _ strip _ menu _ item ( ) ; this . tool _ strip _ separator = new system . windows . forms . tool _ strip _ separator ( ) ; this . quit _ item = new system . windows . forms . tool _ strip _ menu _ item ( ) ; <%> <+> this . panel = new system . windows . forms . panel ( ) ; this . button = new system . windows . forms . button ( ) ; this . button = new system . windows . forms . button ( ) ; this . panel = new system . windows . forms . panel ( ) ; </%>
this . suspend _ layout ( ) ; this . table _ layout _ panel . auto _ size = true ; this . table _ layout _ panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . table _ layout _ panel . column _ count = 2 ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; <%> <+> this . table _ layout _ panel . controls . add ( this . label , 0 , NUM ) ; </%> this . table _ layout _ panel . controls . add ( this . label , 0 , 0 ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , 1 ) ; <%> <+> this . table _ layout _ panel . controls . add ( this . combo _ box , 1 , NUM ) ; </%>
this . resume _ layout ( false ) ; this . perform _ layout ( ) ; } private system . windows . forms . table _ layout _ panel table _ layout _ panel ; private system . windows . forms . label label ; private system . windows . forms . label label ; private system . windows . forms . label label ; private system . windows . forms . label label ; private system . windows . forms . text _ box text _ box ; private system . windows . forms . text _ box text _ box ;
private system . windows . forms . notify _ icon notify _ icon ; private system . windows . forms . context _ menu _ strip context _ menu _ strip ; private system . windows . forms . tool _ strip _ menu _ item config _ item ; private system . windows . forms . tool _ strip _ menu _ item quit _ item ; private system . windows . forms . tool _ strip _ menu _ item about _ tool _ strip _ menu _ item ; private system . windows . forms . tool _ strip _ separator tool _ strip _ separator ; <%> <+> private system . windows . forms . label label ; private system . windows . forms . combo _ box combo _ box ; private system . windows . forms . panel panel ; private system . windows . forms . button button ; </%>
{ m md = system . security . cryptography . m . create ( ) ; byte [ ] input _ bytes = system . text . encoding . ut . get _ bytes ( password ) ; byte [ ] hash = md . compute _ hash ( input _ bytes ) ; <%> <+> if ( method ! = null & & method . to _ lower _ invariant ( ) . equals ( STR ) ) { console . write _ line ( STR ) ; this . method = type _ r ; rc = new r ( ) ; encrypt _ table = rc . encrypt _ initalize ( hash ) ; decrypt _ table = rc . encrypt _ initalize ( hash ) ; </%>
} } public void encrypt ( byte [ ] buf , int length ) { <%> <*> for ( int i = 0 ; i < length ; i + + -> switch ( method </%> ) { <%> <+> case type _ table : for ( int i = 0 ; i < length ; i + + ) </%> buf [ i ] = encrypt _ table [ buf [ i ] ] ; <%> <+> break ; </%>
{ <%> <+> case type _ table : for ( int i = 0 ; i < length ; i + + ) </%> buf [ i ] = encrypt _ table [ buf [ i ] ] ; <%> <+> break ; case type _ r : rc . encrypt ( encrypt _ table , buf , length ) ; break ; </%> } }
} } public void decrypt ( byte [ ] buf , int length ) { <%> <*> for ( int i = 0 ; i < length ; i + + -> switch ( method </%> ) { <%> <+> case type _ table : for ( int i = 0 ; i < length ; i + + ) </%> buf [ i ] = decrypt _ table [ buf [ i ] ] ; <%> <+> break ; </%>
{ <%> <+> case type _ table : for ( int i = 0 ; i < length ; i + + ) </%> buf [ i ] = decrypt _ table [ buf [ i ] ] ; <%> <+> break ; case type _ r : rc . decrypt ( decrypt _ table , buf , length ) ; break ; </%> } }
} } } }
using system _ net _ sockets ; <%> <*> using system _ net ; -> using system _ timers ; </%> <%> <+> using shadowsocks _ controller _ strategy ; </%> using shadowsocks _ encryption ; using shadowsocks _ model ; <%> <-> using shadowsocks _ controller _ strategy ; using system _ timers ; </%> namespace shadowsocks _ controller {
using shadowsocks _ encryption ; using shadowsocks _ model ; <%> <-> using shadowsocks _ controller _ strategy ; using system _ timers ; </%> namespace shadowsocks _ controller { class tcp _ relay : listener . service { private shadowsocks _ controller controller ; private date _ time last _ sweep _ time ;
namespace shadowsocks _ controller { class tcp _ relay : listener . service { private shadowsocks _ controller controller ; private date _ time last _ sweep _ time ; public i _ set < <%> <+> tcp _ </%> handler > handlers { get ; set ; }
{ get ; set ; } public tcp _ relay ( shadowsocks _ controller controller ) { <%> <-> this . </%> controller = controller ; <%> <-> this . </%> handlers = new hash _ set < <%> <+> tcp _ </%> handler > ( ) ; <%> <-> this . </%> last _ sweep _ time = date _ time . now ; } public bool handle ( byte [ ] first _ packet , int length , socket socket , object state )
} public bool handle ( byte [ ] first _ packet , int length , socket socket , object state ) { if ( socket . protocol _ type ! = protocol _ type . tcp ) { return false ; } if ( length < 2 | | first _ packet [ 0 ] ! = NUM ) { return false ;
handler . connection = socket ; handler . controller = controller ; handler . relay = this ; handler . start ( first _ packet , length ) ; i _ list < <%> <+> tcp _ </%> handler > handlers _ to _ close = new list < <%> <+> tcp _ </%> handler > ( ) ; lock ( <%> <-> this . </%> handlers ) { <%> <-> this . </%> handlers . add ( handler ) ; <%> <-> logging . debug ( $ STR ) ; </%> date _ time now = date _ time . now ;
date _ time now = date _ time . now ; if ( now - last _ sweep _ time > time _ span . from _ seconds ( 1 ) ) { last _ sweep _ time = now ; foreach ( <%> <+> tcp _ </%> handler handler in <%> <-> this . </%> handlers ) { if ( now - handler . last _ activity > time _ span . from _ seconds ( NUM ) ) { handlers _ to _ close . add ( handler ) ; }
{ if ( now - handler . last _ activity > time _ span . from _ seconds ( NUM ) ) { handlers _ to _ close . add ( handler ) ; } } } } foreach ( <%> <+> tcp _ </%> handler handler in handlers _ to _ close ) {
{ logging . debug ( STR ) ; handler . close ( ) ; } return true ; } <%> <+> public void update _ inbound _ counter ( long n ) { controller . update _ inbound _ counter ( n ) ; } </%>
{ public i _ encryptor encryptor ; public server server ; public socket remote ; public socket connection ; public shadowsocks _ controller controller ; public tcp _ relay relay ; public date _ time last _ activity ; <%> <+> private const int max _ retry = NUM ; </%> private int retry _ count = 0 ;
this . server = server ; } public void start ( byte [ ] first _ packet , int length ) { <%> <-> this . </%> first _ packet = first _ packet ; <%> <-> this . </%> first _ packet _ length = length ; <%> <-> this . </%> handshake _ receive ( ) ; <%> <-> this . </%> last _ activity = date _ time . now ; } private void check _ close ( )
} private void check _ close ( ) { if ( connection _ shutdown & & remote _ shutdown ) { <%> <-> this . </%> close ( ) ; } } public void close ( ) {
} } public void close ( ) { lock ( relay . handlers ) { <%> <-> logging . debug ( $ STR ) ; </%> relay . handlers . remove ( this ) ; } lock ( this )
relay . handlers . remove ( this ) ; } lock ( this ) { if ( closed ) { return ; } closed = true ; }
connection . begin _ send ( response , 0 , response . length , 0 , new async _ callback ( handshake _ send _ callback ) , null ) ; } else { <%> <-> this . </%> close ( ) ; } } catch ( exception e ) { logging . log _ useful _ exception ( e ) ;
} } private void handshake _ send _ callback ( i _ async _ result ar ) { if ( closed ) { return ; } try {
connection . begin _ send ( response , 0 , response . length , 0 , new async _ callback ( response _ callback ) , null ) ; } else if ( command = = NUM ) { handle _ udp _ associate ( ) ; } } else { logging . <%> <*> error -> debug </%> ( STR ) ;
} } private void handle _ udp _ associate ( ) { ip _ end _ point end _ point = ( ip _ end _ point ) connection . local _ end _ point ; byte [ ] address = end _ point . address . get _ address _ bytes ( ) ; int port = end _ point . port ; byte [ ] response = new byte [ NUM + address . length + 2 ] ; response [ 0 ] = NUM ; if ( end _ point . address _ family = = address _ family . inter _ network )
} else { int bytes _ read = connection . end _ receive ( ar ) ; if ( bytes _ read > 0 ) { <%> <*> logging . debug ( $ STR + recv _ size ) ; connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , 0 , new async _ callback ( read _ all ) , null ) ; -> logging . debug ( remote , recv _ size , STR ) ; </%>
} else { <%> <-> this . </%> close ( ) ; } } } catch ( exception e ) { logging . log _ useful _ exception ( e ) ;
} } private void response _ callback ( i _ async _ result ar ) { try { connection . end _ send ( ar ) ; start _ connect ( ) ; } catch ( exception e )
start _ connect ( ) ; retry _ count + + ; } else { <%> <-> this . </%> close ( ) ; } } private void connect _ callback ( i _ async _ result ar ) {
} } private void connect _ callback ( i _ async _ result ar ) { server server = null ; if ( closed ) { return ; } try
int bytes _ to _ send ; lock ( decryption _ lock ) { if ( closed ) { return ; } encryptor . decrypt ( remote _ recv _ buffer , bytes _ read , remote _ send _ buffer , out bytes _ to _ send ) ; } logging . debug ( <%> <*> $ STR + -> remote , </%> bytes _ to _ send <%> <+> , STR , STR </%> ) ;
connection . begin _ send ( remote _ send _ buffer , 0 , bytes _ to _ send , 0 , new async _ callback ( pipe _ connection _ send _ callback ) , null ) ; i _ strategy strategy = controller . get _ current _ strategy ( ) ; if ( strategy ! = null ) { strategy . update _ last _ read ( <%> <-> this . </%> server ) ; } } else { connection . shutdown ( socket _ shutdown . send ) ;
} } else { connection . shutdown ( socket _ shutdown . send ) ; connection _ shutdown = true ; check _ close ( ) ; <%> <-> if ( total _ read = = 0 ) { } </%>
} } private void pipe _ connection _ receive _ callback ( i _ async _ result ar ) { if ( closed ) { return ; } try {
remote . begin _ send ( connetion _ send _ buffer , 0 , bytes _ to _ send , 0 , new async _ callback ( pipe _ remote _ send _ callback ) , null ) ; i _ strategy strategy = controller . get _ current _ strategy ( ) ; if ( strategy ! = null ) { strategy . update _ last _ write ( <%> <-> this . </%> server ) ; } } else { remote . shutdown ( socket _ shutdown . send ) ;
} } else { remote . shutdown ( socket _ shutdown . send ) ; remote _ shutdown = true ; check _ close ( ) ; } } catch ( exception e )
using system _ collections _ generic ; using system _ net ; using system _ net _ network _ information ; using system _ net _ sockets ; using <%> <*> system -> shadowsocks </%> _ <%> <*> text -> model </%> ; namespace shadowsocks _ controller { public class listener { public interface service
namespace shadowsocks _ controller { public class listener { public interface service { bool handle ( byte [ ] first _ packet , int length , socket socket , object state ) ; } public class udp _ state {
using system _ collections _ generic ; <%> <+> using system _ io ; using system _ net ; using system _ net _ sockets ; </%> using system _ text ; using system _ threading ; <%> <-> using system _ net _ sockets ; </%> using shadowsocks _ controller _ strategy ; <%> <*> using system _ net ; -> using shadowsocks _ model ; </%>
using shadowsocks _ controller _ strategy ; <%> <*> using system _ net ; -> using shadowsocks _ model ; </%> <%> <+> using shadowsocks _ properties ; </%> using shadowsocks _ util ; <%> <-> using shadowsocks _ properties ; </%> namespace shadowsocks _ controller { public class shadowsocks _ controller {
using shadowsocks _ util ; <%> <-> using shadowsocks _ properties ; </%> namespace shadowsocks _ controller { public class shadowsocks _ controller { private thread ram _ thread ; private listener listener ; private pac _ server pac _ server ; private configuration config ;
namespace shadowsocks _ controller { public class shadowsocks _ controller { private thread ram _ thread ; private listener listener ; private pac _ server pac _ server ; private configuration config ; private strategy _ manager strategy _ manager ; private polipo _ runner polipo _ runner ;
using shadowsocks _ encryption ; using shadowsocks _ model ; <%> <-> using system _ net _ sockets ; using system _ net ; using system _ runtime _ compiler _ services ; using shadowsocks _ controller _ strategy ; </%> namespace shadowsocks _ controller { class udp _ relay : listener . service {
namespace shadowsocks _ controller { class udp _ relay : listener . service { private shadowsocks _ controller controller ; private lru _ cache < ip _ end _ point , udp _ handler > cache ; <%> <+> public long outbound = 0 ; public long inbound = 0 ; </%> public udp _ relay ( shadowsocks _ controller controller ) {
using system _ diagnostics ; using system _ io ; using system _ i _ compression ; using system _ runtime _ interop _ services ; <%> <-> using system _ text ; </%> using system _ windows _ forms ; using shadowsocks _ controller ; namespace shadowsocks _ util { public class utils
using system _ windows _ forms ; using shadowsocks _ controller ; namespace shadowsocks _ util { public class utils { public static string get _ temp _ path ( ) { if ( file . exists ( application . startup _ path + STR ) ) {
using system _ drawing ; using system _ io ; <%> <-> using system _ linq ; using system _ text ; </%> using system _ windows _ forms ; using shadowsocks _ controller ; using shadowsocks _ properties ; using shadowsocks _ model ; <%> <+> using shadowsocks _ util ; </%> namespace shadowsocks _ view
using system _ windows _ forms ; using shadowsocks _ controller ; using shadowsocks _ properties ; using shadowsocks _ model ; <%> <+> using shadowsocks _ util ; </%> namespace shadowsocks _ view { public partial class log _ form : form { long last _ offset ;
using system _ net ; using system _ net _ sockets ; <%> <-> using system _ text ; </%> namespace shadowsocks _ controller { class port _ forwarder : listener . service { int target _ port ; public port _ forwarder ( int target _ port ) {
namespace shadowsocks _ controller { class port _ forwarder : listener . service { int target _ port ; public port _ forwarder ( int target _ port ) { this . target _ port = target _ port ; } public bool handle ( byte [ ] first _ packet , int length , socket socket , object state )
public void update _ inbound ( long delta ) { <%> <-> bool lock _ taken = false ; try { lock . enter ( ref lock _ taken ) ; </%> interlocked . add ( ref inbound , delta ) ; <%> <-> } finally { </%>
} public void update _ outbound ( long delta ) { <%> <-> bool lock _ taken = false ; try { lock . enter ( ref lock _ taken ) ; </%> interlocked . add ( ref outbound , delta ) ; <%> <-> } finally </%>
} public void get _ delta ( out long inbound _ delta , out long outbound _ delta ) { <%> <-> bool lock _ taken = false ; try { lock . enter ( ref lock _ taken ) ; </%> var i = interlocked . read ( ref inbound ) ; var il = interlocked . exchange ( ref last _ inbound , i ) ; inbound _ delta = i - il ;
} } private readonly time _ span delay _ before _ start = time _ span . from _ seconds ( 1 ) ; private readonly time _ span retry _ interval = time _ span . from _ minutes ( 2 ) ; private timer recorder ; private time _ span recording _ interval = > time _ span . from _ minutes ( config . data _ collection _ minutes ) ; private timer speed _ monior ; private readonly time _ span monitor _ interval = time _ span . from _ seconds ( 1 ) ; private shadowsocks _ controller controller ; private statistics _ strategy _ configuration config = > controller . statistics _ configuration ;
void begin _ connect _ proxy ( end _ point remote _ ep , async _ callback callback , object state ) ; void end _ connect _ proxy ( i _ async _ result async _ result ) ; void begin _ connect _ dest ( <%> <*> string host , int port -> end _ point dest _ end _ point </%> , async _ callback callback , object state ) ; void end _ connect _ dest ( i _ async _ result async _ result ) ; void begin _ send ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) ; int end _ send ( i _ async _ result async _ result ) ; void begin _ receive ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) ; int end _ receive ( i _ async _ result async _ result ) ;
void end _ connect _ dest ( i _ async _ result async _ result ) ; void begin _ send ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) ; int end _ send ( i _ async _ result async _ result ) ; void begin _ receive ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) ; int end _ receive ( i _ async _ result async _ result ) ; void shutdown ( socket _ shutdown how ) ; void close ( ) ; }
byte [ ] request = null ; byte atyp = 0 ; <%> <*> ip _ address ip _ address -> int port </%> ; <%> <*> bool parsed -> var dep </%> = <%> <*> ip -> dest </%> _ <%> <*> address . try -> end </%> _ <%> <*> parse ( host , out ip -> point as dns _ end </%> _ <%> <*> address ) -> point </%> ; if ( <%> <*> parsed -> dep ! = null </%> ) { <%> <*> ip _ end _ point ep = new ip _ end _ point ( ip _ address , port ) ; switch ( ep . address _ family ) -> atyp = NUM ; </%> <%> <+> var enc = encoding . ut ; var host _ byte _ count = enc . get _ byte _ count ( dep . host ) ; </%>
{ case address _ family . inter _ network : request = new byte [ NUM + NUM + 2 ] ; atyp = 1 ; break ; case address _ family . inter _ network : request = new byte [ NUM + NUM + 2 ] ; atyp = NUM ; break ; default :
array . copy ( addr , 0 , request , NUM , request . length - NUM - 2 ) ; <%> <-> } else { atyp = NUM ; var enc = encoding . ut ; var host _ byte _ count = enc . get _ byte _ count ( host ) ; request = new byte [ NUM + 1 request [ NUM ] = ( byte ) host _ byte _ count ; enc . get _ bytes ( host , 0 , host . length , request , NUM ) ; </%>
} request [ 0 ] = NUM ; request [ 1 ] = 1 ; request [ 2 ] = 0 ; request [ NUM ] = atyp ; request [ request . length - 2 ] = ( byte ) ( ( port > > NUM ) & 0 xff ) ; request [ request . length - 1 ] = ( byte ) ( port & 0 xff ) ; var st = new socks _ state ( ) ; st . callback = callback ; st . async _ state = state ;
public void begin _ connect _ proxy ( end _ point remote _ ep , async _ callback callback , object state ) { var r = new fake _ async _ result ( state ) ; callback ? . invoke ( r ) ; } public void end _ connect _ proxy ( i _ async _ result async _ result ) { } public void begin _ connect _ dest ( <%> <*> string host , int port -> end _ point dest _ end _ point </%> , async _ callback callback , object state ) {
{ <%> <*> ip _ address ip _ address ; -> end _ point real _ end _ point = dest _ end _ point = dest _ end _ point ; </%> <%> <+> * on windows vista or later , dual - mode socket is supported , so that </%> <%> <*> bool parsed = ip -> * we don ' t need to resolve a dns _ end </%> _ <%> <*> address -> point manually </%> . <%> <*> try _ parse ( host , out ip _ address ) ; if ( ! parsed ) -> * we could just create a dual - mode socket and pass the dns _ end _ point </%> <%> <+> * directly to it ' s begin _ connect and the system will handle it correctlly * so that we won ' t worry about async resolving any more . * * see : https : * </%>
{ <%> <*> ip _ host _ entry ip _ host _ info = dns . get _ host _ entry ( host ) ; ip _ address = ip _ host _ info . address _ list [ 0 ] ; -> ip _ host _ entry ip _ host _ info = dns . get _ host _ entry ( dep . host ) ; </%> <%> <+> ip _ address ip _ address = ip _ host _ info . address _ list [ 0 ] ; real _ end _ point = new ip _ end _ point ( ip _ address , dep . port ) ; </%> } <%> <-> ip _ end _ point remote _ ep = new ip _ end _ point ( ip _ address , port ) ; dest _ host = host ; dest _ port = port ; </%>
} <%> <-> ip _ end _ point remote _ ep = new ip _ end _ point ( ip _ address , port ) ; dest _ host = host ; dest _ port = port ; </%> if ( remote = = null ) { remote = new socket ( <%> <*> remote -> real _ end </%> _ <%> <*> ep -> point </%> . address _ family , socket _ type . stream , protocol _ type . tcp ) ; remote . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; } remote . begin _ connect ( <%> <*> remote -> real _ end </%> _ <%> <*> ep -> point </%> , callback , state ) ;
if ( remote = = null ) { remote = new socket ( <%> <*> remote -> real _ end </%> _ <%> <*> ep -> point </%> . address _ family , socket _ type . stream , protocol _ type . tcp ) ; remote . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; } remote . begin _ connect ( <%> <*> remote -> real _ end </%> _ <%> <*> ep -> point </%> , callback , state ) ; } public void end _ connect _ dest ( i _ async _ result async _ result ) { remote ? . end _ connect ( async _ result ) ;
remote . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; } remote . begin _ connect ( <%> <*> remote -> real _ end </%> _ <%> <*> ep -> point </%> , callback , state ) ; } public void end _ connect _ dest ( i _ async _ result async _ result ) { remote ? . end _ connect ( async _ result ) ; } public void begin _ send ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state )
} public void end _ connect _ dest ( i _ async _ result async _ result ) { remote ? . end _ connect ( async _ result ) ; } public void begin _ send ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) { remote ? . begin _ send ( buffer , offset , size , socket _ flags , callback , state ) ; }
{ this . controller = controller ; <%> <-> this . filename = filename ; </%> initialize _ component ( ) ; icon = icon . from _ handle ( resources . ssw . get _ hicon ( ) ) ; <%> <+> var n _ log _ config = n _ log _ config . load _ xml ( ) ; this . filename = n _ log _ config . get _ log _ file _ name ( ) ; </%> log _ viewer _ config config = controller . get _ configuration _ copy ( ) . log _ viewer ; top _ most _ trigger = config . top _ most ; wrap _ text _ trigger = config . wrap _ text ;
initialize _ component ( ) ; icon = icon . from _ handle ( resources . ssw . get _ hicon ( ) ) ; <%> <+> var n _ log _ config = n _ log _ config . load _ xml ( ) ; this . filename = n _ log _ config . get _ log _ file _ name ( ) ; </%> log _ viewer _ config config = controller . get _ configuration _ copy ( ) . log _ viewer ; top _ most _ trigger = config . top _ most ; wrap _ text _ trigger = config . wrap _ text ; toolbar _ trigger = config . toolbar _ shown ; log _ message _ text _ box . back _ color = config . background _ color ; log _ message _ text _ box . fore _ color = config . text _ color ;
{ public class <%> <+> stream _ </%> sodium _ encryptor : <%> <*> iv -> stream </%> _ encryptor , i _ disposable { const int cipher _ sals = 1 ; const int cipher _ chach = 2 ; const int cipher _ chach _ ietf = NUM ; const int sodium _ block _ size = NUM ; protected int encrypt _ bytes _ remaining ; protected int decrypt _ bytes _ remaining ;
{ const int cipher _ sals = 1 ; const int cipher _ chach = 2 ; const int cipher _ chach _ ietf = NUM ; const int sodium _ block _ size = NUM ; protected int encrypt _ bytes _ remaining ; protected int decrypt _ bytes _ remaining ; protected ulong encrypt _ ic ; protected ulong decrypt _ ic ; protected byte [ ] encrypt _ buf ;
{ int bytes _ remaining ; ulong ic ; byte [ ] sodium _ buf ; byte [ ] iv ; <%> <*> if ( is _ cipher ) -> int ret = - 1 ; </%> <%> <+> if ( is _ encrypt ) </%> { bytes _ remaining = encrypt _ bytes _ remaining ;
{ bytes _ remaining = encrypt _ bytes _ remaining ; ic = encrypt _ ic ; sodium _ buf = encrypt _ buf ; iv = encrypt _ iv ; } else { bytes _ remaining = decrypt _ bytes _ remaining ; ic = decrypt _ ic ;
break ; case cipher _ chach : <%> <+> ret = </%> sodium . crypto _ stream _ chacha _ xor _ ic ( sodium _ buf , sodium _ buf , ( ulong ) ( padding + length ) , iv , ic , key ) ; break ; case cipher _ chach _ ietf : <%> <+> ret = </%> sodium . crypto _ stream _ chacha _ ietf _ xor _ ic ( sodium _ buf , sodium _ buf , ( ulong ) ( padding + length ) , iv , ( uint ) ic , key ) ; break ; } <%> <+> if ( ret ! = 0 ) throw new crypto _ error _ exception ( ) ; </%> buffer . block _ copy ( sodium _ buf , padding , outbuf , 0 , length ) ;
break ; case cipher _ chach _ ietf : <%> <+> ret = </%> sodium . crypto _ stream _ chacha _ ietf _ xor _ ic ( sodium _ buf , sodium _ buf , ( ulong ) ( padding + length ) , iv , ( uint ) ic , key ) ; break ; } <%> <+> if ( ret ! = 0 ) throw new crypto _ error _ exception ( ) ; </%> buffer . block _ copy ( sodium _ buf , padding , outbuf , 0 , length ) ; padding + = length ; ic + = ( ulong ) padding / sodium _ block _ size ; bytes _ remaining = padding % sodium _ block _ size ;
break ; } <%> <+> if ( ret ! = 0 ) throw new crypto _ error _ exception ( ) ; </%> buffer . block _ copy ( sodium _ buf , padding , outbuf , 0 , length ) ; padding + = length ; ic + = ( ulong ) padding / sodium _ block _ size ; bytes _ remaining = padding % sodium _ block _ size ; if ( is _ <%> <*> cipher -> encrypt </%> ) { encrypt _ bytes _ remaining = bytes _ remaining ;
{ encrypt _ bytes _ remaining = bytes _ remaining ; encrypt _ ic = ic ; } else { decrypt _ bytes _ remaining = bytes _ remaining ; decrypt _ ic = ic ; } }
{ public <%> <*> struct -> class </%> encryptor _ info { public int key _ size ; public int iv _ size ; <%> <+> public int salt _ size ; public int tag _ size ; public int nonce _ size ; </%> public int type ; public string inner _ lib _ name ;
{ public int key _ size ; public int iv _ size ; <%> <+> public int salt _ size ; public int tag _ size ; public int nonce _ size ; </%> public int type ; public string inner _ lib _ name ; public encryptor _ info ( string inner _ lib _ name , int key _ size , int iv _ size , int type ) {
{ method = method ; password = password ; <%> <-> onetime _ auth = onetimeauth ; is _ udp = isudp ; </%> } protected string method ; protected string password ; <%> <-> protected bool onetime _ auth ; protected bool is _ udp ; </%>
} protected string method ; protected string password ; <%> <-> protected bool onetime _ auth ; protected bool is _ udp ; protected byte [ ] get _ password _ hash ( ) { byte [ ] input _ bytes = encoding . ut . get _ bytes ( password ) ; byte [ ] hash = mbed _ tls . m ( input _ bytes ) ; return hash ; </%>
public abstract void encrypt ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength ) ; public abstract void decrypt ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength ) ; <%> <+> public abstract void encrypt _ udp ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength ) ; public abstract void decrypt _ udp ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength ) ; </%> public abstract void dispose ( ) ; <%> <+> public int addr _ buf _ length { get ; set ; } = - 1 ; </%> } }
{ <%> <*> const string dllname = STR ; -> private const string dllname = STR ; </%> <%> <+> private static bool initialized = false ; private static readonly object init _ lock = new object ( ) ; </%> static sodium ( ) { string dll _ path = utils . get _ temp _ path ( <%> <*> STR -> dllname </%> ) ; try {
static sodium ( ) { string dll _ path = utils . get _ temp _ path ( <%> <*> STR -> dllname </%> ) ; try { file _ manager . uncompress _ file ( dll _ path , resources . libsscrypto _ dll ) ; } catch ( io _ exception ) { }
try { file _ manager . uncompress _ file ( dll _ path , resources . libsscrypto _ dll ) ; } catch ( io _ exception ) { } catch ( <%> <+> system . </%> exception e ) { logging . log _ useful _ exception ( e ) ;
{ logging . log _ useful _ exception ( e ) ; } load _ library ( dll _ path ) ; <%> <+> lock ( init _ lock ) { if ( ! initialized ) { if ( sodium _ init ( ) = = - 1 ) { </%>
dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern int <%> <*> crypto _ stream _ chacha _ xor -> sodium </%> _ <%> <*> ic -> increment </%> ( <%> <-> byte [ ] c , byte [ ] m , ulong mlen , </%> byte [ ] n , <%> <*> ulong ic , byte [ ] k -> int nlen </%> ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl <%> <*> public static extern int crypto _ stream _ chacha _ ietf _ xor _ ic ( byte [ ] c , byte [ ] m , ulong mlen , byte [ ] n , uint ic , byte [ ] k ) ; -> public static extern int crypto _ aead _ chacha _ poly _ ietf _ encrypt ( byte [ ] c , ref ulong clen _ p , byte [ ] m , </%> <%> <+> ulong mlen , byte [ ] ad , ulong adlen , byte [ ] nsec , byte [ ] npub , byte [ ] k ) ; </%> dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl <%> <-> public static extern void ss _ sha _ hmac _ ex ( byte [ ] key , uint keylen , byte [ ] input , int ioff , uint ilen , byte [ ] output ) ; </%>
dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl <%> <*> public static extern int crypto _ stream _ chacha _ ietf _ xor _ ic ( byte [ ] c , byte [ ] m , ulong mlen , byte [ ] n , uint ic , byte [ ] k ) ; -> public static extern int crypto _ aead _ chacha _ poly _ ietf _ encrypt ( byte [ ] c , ref ulong clen _ p , byte [ ] m , </%> <%> <+> ulong mlen , byte [ ] ad , ulong adlen , byte [ ] nsec , byte [ ] npub , byte [ ] k ) ; </%> dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl <%> <*> public static extern void ss _ sha _ hmac _ ex ( byte [ ] key , uint keylen , byte [ ] input , int ioff , uint ilen , byte [ ] output ) ; -> public static extern int crypto _ aead _ chacha _ poly _ ietf _ decrypt ( byte [ ] m , ref ulong mlen _ p , </%> <%> <+> byte [ ] nsec , byte [ ] c , ulong clen , byte [ ] ad , ulong adlen , byte [ ] npub , byte [ ] k ) ; </%>
dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl <%> <*> public static extern void ss _ sha _ hmac _ ex ( byte [ ] key , uint keylen , byte [ ] input , int ioff , uint ilen , byte [ ] output ) ; -> public static extern int crypto _ aead _ chacha _ poly _ ietf _ decrypt ( byte [ ] m , ref ulong mlen _ p , </%> <%> <+> byte [ ] nsec , byte [ ] c , ulong clen , byte [ ] ad , ulong adlen , byte [ ] npub , byte [ ] k ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern int crypto _ stream _ salsa _ xor _ ic ( byte [ ] c , byte [ ] m , ulong mlen , byte [ ] n , ulong ic , byte [ ] k ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl </%>
} }
} public static void get _ bytes ( byte [ ] buf , int len ) { <%> <+> if ( rng = = null ) reload ( ) ; </%> try { rng . get _ bytes ( buf , 0 , len ) ; } catch ( <%> <+> system . </%> exception ) {
{ byte [ ] tmp = new byte [ len ] ; rng . get _ bytes ( tmp ) ; buffer . block _ copy ( tmp , 0 , buf , 0 , len ) ; } } } }
public long outbound = 0 ; public long inbound = 0 ; public udp _ relay ( shadowsocks _ controller controller ) { this . controller = controller ; <%> <-> this . cache = new lru _ cache < ip _ end _ point , udp _ handler > ( NUM ) ; </%> } public override bool handle ( byte [ ] first _ packet , int length , socket socket , object state ) { if ( socket . protocol _ type ! = protocol _ type . udp )
} public override bool handle ( byte [ ] first _ packet , int length , socket socket , object state ) { if ( socket . protocol _ type ! = protocol _ type . udp ) { return false ; } if ( length < NUM ) { return false ;
array . copy ( data , NUM , data _ in , 0 , length - NUM ) ; byte [ ] data _ out = new byte [ length - NUM + NUM <%> <-> + iv _ encryptor . onetimeauth _ bytes </%> ] ; int outlen ; encryptor . encrypt <%> <+> _ udp </%> ( data _ in , length - NUM , data _ out , out outlen ) ; logging . debug ( local _ end _ point , remote _ end _ point , outlen , STR ) ; remote ? . send _ to ( data _ out , outlen , socket _ flags . none , remote _ end _ point ) ; } public void receive ( ) { end _ point remote _ end _ point = new ip _ end _ point ( ip _ address . any , 0 ) ;
int outlen ; encryptor . encrypt <%> <+> _ udp </%> ( data _ in , length - NUM , data _ out , out outlen ) ; logging . debug ( local _ end _ point , remote _ end _ point , outlen , STR ) ; remote ? . send _ to ( data _ out , outlen , socket _ flags . none , remote _ end _ point ) ; } public void receive ( ) { end _ point remote _ end _ point = new ip _ end _ point ( ip _ address . any , 0 ) ; logging . debug ( $ STR + buffer . length ) ; remote ? . begin _ receive _ from ( buffer , 0 , buffer . length , 0 , ref remote _ end _ point , new async _ callback ( recv _ from _ callback ) , null ) ;
logging . debug ( local _ end _ point , remote _ end _ point , outlen , STR ) ; remote ? . send _ to ( data _ out , outlen , socket _ flags . none , remote _ end _ point ) ; } public void receive ( ) { end _ point remote _ end _ point = new ip _ end _ point ( ip _ address . any , 0 ) ; logging . debug ( $ STR + buffer . length ) ; remote ? . begin _ receive _ from ( buffer , 0 , buffer . length , 0 , ref remote _ end _ point , new async _ callback ( recv _ from _ callback ) , null ) ; } public void recv _ from _ callback ( i _ async _ result ar )
public date _ time last _ activity ; private shadowsocks _ controller controller ; private configuration config ; private tcp _ relay tcprelay ; private socket connection ; private i _ encryptor encryptor ; private server server ; private async _ session current _ remote _ session ; private bool proxy _ connected ; private bool dest _ connected ;
private readonly object encryption _ lock = new object ( ) ; private readonly object decryption _ lock = new object ( ) ; private readonly object close _ conn _ lock = new object ( ) ; private date _ time start _ connect _ time ; private date _ time start _ receiving _ time ; private date _ time start _ sending _ time ; private end _ point dest _ end _ point = null ; public tcp _ handler ( shadowsocks _ controller controller , configuration config , tcp _ relay tcprelay , socket socket ) { controller = controller ;
this . server = server ; <%> <+> logging . debug ( $ STR ) ; encryptor . addr _ buf _ length = addr _ buf _ length ; </%> } public void start ( byte [ ] first _ packet , int length ) { first _ packet = first _ packet ; first _ packet _ length = length ; handshake _ receive ( ) ; }
{ if ( closed ) return ; try { int bytes _ read = connection . end _ receive ( ar ) ; if ( bytes _ read > = NUM ) { command = connetion _ recv _ buffer [ 1 ] ; if ( command ! = <%> <*> 1 -> cmd _ connect </%> & & command ! = <%> <*> NUM -> cmd _ udp _ assoc </%> ) {
{ logging . debug ( STR + command ) ; close ( ) ; } else { if ( command = = <%> <*> 1 -> cmd _ connect </%> ) { byte [ ] response = { NUM , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 } ; connection . begin _ send ( response , 0 , response . length , socket _ flags . none ,
{ byte [ ] response = { NUM , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 } ; connection . begin _ send ( response , 0 , response . length , socket _ flags . none , <%> <-> new async _ callback ( </%> response _ callback <%> <-> ) </%> , null ) ; } else if ( command = = <%> <*> NUM -> cmd _ udp _ assoc </%> ) { read _ address ( handle _ udp _ associate ) ; } }
} else if ( command = = <%> <*> NUM -> cmd _ udp _ assoc </%> ) { read _ address ( handle _ udp _ associate ) ; } } } else { <%> <-> logging . debug ( STR ) ; </%>
{ read _ address ( handle _ udp _ associate ) ; } } } else { <%> <*> logging . debug ( STR ) ; -> logging . debug ( </%> <%> <+> STR ) ; </%>
break ; case <%> <*> NUM -> atyp _ domain </%> : int len = connetion _ recv _ buffer [ NUM ] ; read _ address ( len + <%> <*> 2 -> addr _ port _ len </%> , on _ success ) ; break ; case <%> <*> NUM -> atyp _ i _ pv </%> : read _ address ( NUM + <%> <*> 2 -> addr _ port _ len </%> - 1 , on _ success ) ; break ; default : logging . debug ( STR + atyp ) ;
int len = connetion _ recv _ buffer [ NUM ] ; read _ address ( len + <%> <*> 2 -> addr _ port _ len </%> , on _ success ) ; break ; case <%> <*> NUM -> atyp _ i _ pv </%> : read _ address ( NUM + <%> <*> 2 -> addr _ port _ len </%> - 1 , on _ success ) ; break ; default : logging . debug ( STR + atyp ) ; close ( ) ; break ;
break ; case <%> <*> NUM -> atyp _ i _ pv </%> : read _ address ( NUM + <%> <*> 2 -> addr _ port _ len </%> - 1 , on _ success ) ; break ; default : logging . debug ( STR + atyp ) ; close ( ) ; break ; } }
break ; default : logging . debug ( STR + atyp ) ; close ( ) ; break ; } } private void read _ address ( int bytes _ remain , action on _ success ) { <%> <-> array . copy ( connetion _ recv _ buffer , NUM , connetion _ recv _ buffer , 0 , 2 ) ; </%>
<%> <*> connection . begin _ receive ( connetion _ recv _ buffer , 2 , recv _ size - 2 , socket _ flags . none , on _ address _ fully _ read , new object [ ] { bytes _ remain , on _ success } ) ; -> connection . begin _ receive ( connetion _ recv _ buffer , 2 , recv _ size - 2 , socket _ flags . none , on _ address _ fully _ read , </%> <%> <+> new object [ ] { bytes _ remain , on _ success } ) ; </%> } private void on _ address _ fully _ read ( i _ async _ result ar ) { if ( closed ) return ; try { int bytes _ read = connection . end _ receive ( ar ) ;
break ; case <%> <*> NUM -> atyp _ domain </%> : int len = connetion _ recv _ buffer [ 1 ] ; dst _ addr = system . text . encoding . ut . get _ string ( connetion _ recv _ buffer , 2 , len ) ; dst _ port = ( connetion _ recv _ buffer [ len + 2 ] < < NUM ) + connetion _ recv _ buffer [ len + NUM ] ; <%> <+> addr _ buf _ length = addr _ atyp _ len + 1 + len + addr _ port _ len ; </%> break ; case <%> <*> NUM -> atyp _ i _ pv </%> : dst _ addr = $ STR ; dst _ port = ( connetion _ recv _ buffer [ NUM ] < < NUM ) + connetion _ recv _ buffer [ NUM ] ;
int len = connetion _ recv _ buffer [ 1 ] ; dst _ addr = system . text . encoding . ut . get _ string ( connetion _ recv _ buffer , 2 , len ) ; dst _ port = ( connetion _ recv _ buffer [ len + 2 ] < < NUM ) + connetion _ recv _ buffer [ len + NUM ] ; <%> <+> addr _ buf _ length = addr _ atyp _ len + 1 + len + addr _ port _ len ; </%> break ; case <%> <*> NUM -> atyp _ i _ pv </%> : dst _ addr = $ STR ; dst _ port = ( connetion _ recv _ buffer [ NUM ] < < NUM ) + connetion _ recv _ buffer [ NUM ] ; <%> <+> addr _ buf _ length = addr _ atyp _ len + NUM + addr _ port _ len ; </%> break ;
break ; case <%> <*> NUM -> atyp _ i _ pv </%> : dst _ addr = $ STR ; dst _ port = ( connetion _ recv _ buffer [ NUM ] < < NUM ) + connetion _ recv _ buffer [ NUM ] ; <%> <+> addr _ buf _ length = addr _ atyp _ len + NUM + addr _ port _ len ; </%> break ; } if ( config . is _ verbose _ logging ) { logging . info ( $ STR ) ;
break ; } if ( config . is _ verbose _ logging ) { logging . info ( $ STR ) ; } dest _ end _ point = socket _ util . get _ end _ point ( dst _ addr , dst _ port ) ; on _ success . invoke ( ) ; } else
response [ 0 ] = NUM ; switch ( end _ point . address _ family ) { case address _ family . inter _ network : response [ NUM ] = <%> <*> 1 -> atyp _ i _ pv </%> ; break ; case address _ family . inter _ network : response [ NUM ] = <%> <*> NUM -> atyp _ i _ pv </%> ; break ; }
break ; case address _ family . inter _ network : response [ NUM ] = <%> <*> NUM -> atyp _ i _ pv </%> ; break ; } address . copy _ to ( response , NUM ) ; response [ response . length - 1 ] = ( byte ) ( port & 0 xff ) ; response [ response . length - 2 ] = ( byte ) ( ( port > > NUM ) & 0 xff ) ; connection . begin _ send ( response , 0 , response . length , socket _ flags . none , <%> <-> new async _ callback ( </%> read _ all <%> <-> ) </%> , true ) ; }
break ; } address . copy _ to ( response , NUM ) ; response [ response . length - 1 ] = ( byte ) ( port & 0 xff ) ; response [ response . length - 2 ] = ( byte ) ( ( port > > NUM ) & 0 xff ) ; connection . begin _ send ( response , 0 , response . length , socket _ flags . none , <%> <-> new async _ callback ( </%> read _ all <%> <-> ) </%> , true ) ; } private void read _ all ( i _ async _ result ar ) { if ( closed ) return ;
} private void read _ all ( i _ async _ result ar ) { if ( closed ) return ; try { if ( ar . async _ state ! = null ) { connection . end _ send ( ar ) ; <%> <-> connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , socket _ flags . none , new async _ callback ( read _ all ) , null ) ; </%>
} else { int bytes _ read = connection . end _ receive ( ar ) ; if ( bytes _ read > 0 ) { <%> <*> connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , socket _ flags . none , new async _ callback ( read _ all ) , null ) ; -> connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , socket _ flags . none , </%> <%> <+> read _ all , null ) ; </%> }
} else close ( ) ; } } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; }
if ( config . proxy . use _ proxy ) { switch ( config . proxy . proxy _ type ) { case proxy _ config . proxy _ sock : remote = new socks _ proxy ( ) ; break ; case proxy _ config . proxy _ http : remote = new http _ proxy ( ) ; break ;
proxy _ timer . enabled = true ; proxy _ timer . session = session ; proxy _ timer . dest _ end _ point = socket _ util . get _ end _ point ( server . server , server . server _ port ) ; proxy _ timer . server = server ; proxy _ connected = false ; <%> <*> remote . begin _ connect _ proxy ( proxy _ ep , new async _ callback ( proxy _ connect _ callback ) , -> remote . begin _ connect _ proxy ( proxy _ ep , proxy _ connect _ callback , </%> new async _ session < proxy _ timer > ( remote , proxy _ timer ) ) ; } catch ( exception e ) {
timer . enabled = false ; timer . dispose ( ) ; if ( proxy _ connected | | dest _ connected | | closed ) { return ; } var proxy = timer . session . remote ; logging . info ( $ STR ) ; proxy . close ( ) ; close ( ) ;
if ( closed ) { return ; } try { var session = ( async _ session < proxy _ timer > ) ar . async _ state ; proxy _ timer timer = session . state ; var dest _ end _ point = timer . dest _ end _ point ; <%> <+> var </%> server = timer . server ;
timer . enabled = false ; timer . dispose ( ) ; var remote = session . remote ; remote . end _ connect _ proxy ( ar ) ; proxy _ connected = true ; if ( config . is _ verbose _ logging ) { if ( ! ( remote is direct _ connect ) ) { logging . info ( $ STR ) ;
connect _ timer . enabled = true ; connect _ timer . session = session ; connect _ timer . server = server ; dest _ connected = false ; <%> <*> remote . begin _ connect _ dest ( dest _ end _ point , new async _ callback ( connect _ callback ) , new async _ session < server _ timer > ( session , connect _ timer ) ) ; -> remote . begin _ connect _ dest ( dest _ end _ point , connect _ callback , </%> <%> <+> new async _ session < server _ timer > ( session , connect _ timer ) ) ; </%> } catch ( argument _ exception ) {
} catch ( argument _ exception ) { } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; } }
lock ( decryption _ lock ) { <%> <+> try { </%> encryptor . decrypt ( remote _ recv _ buffer , bytes _ read , remote _ send _ buffer , out bytes _ to _ send ) ; } <%> <*> connection . begin _ send ( remote _ send _ buffer , 0 , bytes _ to _ send , socket _ flags . none , new async _ callback -> catch </%> ( <%> <*> pipe _ connection -> crypto </%> _ <%> <*> send -> error </%> _ <%> <*> callback -> exception </%> ) <%> <*> , session ) ; -> { </%> <%> <+> logging . error ( STR ) ; close ( ) ; </%>
i _ strategy strategy = controller . get _ current _ strategy ( ) ; strategy ? . update _ last _ read ( server ) ; } else { connection . shutdown ( socket _ shutdown . send ) ; connection _ shutdown = true ; check _ close ( ) ; } }
} tcprelay . update _ outbound _ counter ( server , bytes _ to _ send ) ; start _ sending _ time = date _ time . now ; <%> <*> session . remote . begin _ send ( connetion _ send _ buffer , 0 , bytes _ to _ send , socket _ flags . none , new async _ callback ( pipe _ remote _ send _ callback ) , session ) ; -> session . remote . begin _ send ( connetion _ send _ buffer , 0 , bytes _ to _ send , socket _ flags . none , </%> <%> <+> pipe _ remote _ send _ callback , new object [ ] { session , bytes _ to _ send } ) ; </%> i _ strategy strategy = controller . get _ current _ strategy ( ) ; strategy ? . update _ last _ write ( server ) ; } private void pipe _ remote _ send _ callback ( i _ async _ result ar )
i _ strategy strategy = controller . get _ current _ strategy ( ) ; strategy ? . update _ last _ write ( server ) ; } private void pipe _ remote _ send _ callback ( i _ async _ result ar ) { if ( closed ) return ; try { <%> <+> var container = ( object [ ] ) ar . async _ state ; var session = ( async _ session ) container [ 0 ] ; </%>
private void pipe _ connection _ send _ callback ( i _ async _ result ar ) { try { <%> <*> var session = ( async _ session ) ar . async _ state ; connection . end _ send ( ar ) ; session . remote . begin _ receive ( remote _ recv _ buffer , 0 , recv _ size , socket _ flags . none , new async _ callback ( pipe _ remote _ receive _ callback ) , session ) ; -> var container = ( object [ ] ) ar . async _ state ; </%> <%> <+> var session = ( async _ session ) container [ 0 ] ; var bytes _ should _ send = ( int ) container [ 1 ] ; </%>
} catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; } } } }
{ public class <%> <+> stream _ </%> mbed _ tls _ encryptor : <%> <*> iv -> stream </%> _ encryptor , i _ disposable { const int cipher _ r = 1 ; const int cipher _ aes = 2 ; const int cipher _ blowfish = NUM ; const int cipher _ camellia = NUM ; private int _ ptr encrypt _ ctx = int _ ptr . zero ; private int _ ptr decrypt _ ctx = int _ ptr . zero ;
{ const int cipher _ r = 1 ; const int cipher _ aes = 2 ; const int cipher _ blowfish = NUM ; const int cipher _ camellia = NUM ; private int _ ptr encrypt _ ctx = int _ ptr . zero ; private int _ ptr decrypt _ ctx = int _ ptr . zero ; public <%> <+> stream _ </%> mbed _ tls _ encryptor ( string method , string password <%> <-> , bool onetimeauth , bool isudp </%> ) : base ( method , password <%> <-> , onetimeauth , isudp </%> ) {
{ } private static dictionary < string , encryptor _ info > ciphers = new dictionary < string , encryptor _ info > { { STR , new encryptor _ info ( STR , NUM , NUM , cipher _ aes ) } , { STR , new encryptor _ info ( STR , NUM , NUM , cipher _ aes ) } , { STR , new encryptor _ info ( STR , NUM , NUM , cipher _ aes ) } , { STR , new encryptor _ info ( STR , NUM , NUM , cipher _ aes ) } , { STR , new encryptor _ info ( STR , NUM , NUM , cipher _ aes ) } , { STR , new encryptor _ info ( STR , NUM , NUM , cipher _ aes ) } , { STR , new encryptor _ info ( STR , NUM , NUM , cipher _ blowfish ) } ,
int _ ptr ctx = marshal . alloc _ h _ global ( mbed _ tls . cipher _ get _ size _ ex ( ) ) ; if ( is _ <%> <*> cipher -> encrypt </%> ) { encrypt _ ctx = ctx ; } else { decrypt _ ctx = ctx ; } byte [ ] realkey ;
if ( mbed _ tls . cipher _ set _ iv ( ctx , iv , iv _ len ) ! = 0 ) throw new <%> <+> system . </%> exception ( STR ) ; if ( mbed _ tls . cipher _ reset ( ctx ) ! = 0 ) throw new <%> <+> system . </%> exception ( STR ) ; } protected override void cipher _ update ( bool is _ <%> <*> cipher -> encrypt </%> , int length , byte [ ] buf , byte [ ] outbuf ) { if ( disposed ) { throw new object _ disposed _ exception ( this . to _ string ( ) ) ;
if ( mbed _ tls . cipher _ reset ( ctx ) ! = 0 ) throw new <%> <+> system . </%> exception ( STR ) ; } protected override void cipher _ update ( bool is _ <%> <*> cipher -> encrypt </%> , int length , byte [ ] buf , byte [ ] outbuf ) { if ( disposed ) { throw new object _ disposed _ exception ( this . to _ string ( ) ) ; } if ( mbed _ tls . cipher _ update ( is _ <%> <*> cipher -> encrypt </%> ? encrypt _ ctx : decrypt _ ctx ,
} protected override void cipher _ update ( bool is _ <%> <*> cipher -> encrypt </%> , int length , byte [ ] buf , byte [ ] outbuf ) { if ( disposed ) { throw new object _ disposed _ exception ( this . to _ string ( ) ) ; } if ( mbed _ tls . cipher _ update ( is _ <%> <*> cipher -> encrypt </%> ? encrypt _ ctx : decrypt _ ctx , buf , length , outbuf , ref length ) ! = 0 ) throw new <%> <+> crypto _ error _ </%> exception ( <%> <-> STR </%> ) ;
{ if ( disposed ) { throw new object _ disposed _ exception ( this . to _ string ( ) ) ; } if ( mbed _ tls . cipher _ update ( is _ <%> <*> cipher -> encrypt </%> ? encrypt _ ctx : decrypt _ ctx , buf , length , outbuf , ref length ) ! = 0 ) throw new <%> <+> crypto _ error _ </%> exception ( <%> <-> STR </%> ) ; } private bool disposed ;
buf , length , outbuf , ref length ) ! = 0 ) throw new <%> <+> crypto _ error _ </%> exception ( <%> <-> STR </%> ) ; } private bool disposed ; private readonly object lock = new object ( ) ; public override void dispose ( ) { dispose ( true ) ; gc . suppress _ finalize ( this ) ; }
} private bool disposed ; private readonly object lock = new object ( ) ; public override void dispose ( ) { dispose ( true ) ; gc . suppress _ finalize ( this ) ; } ~ <%> <+> stream _ </%> mbed _ tls _ encryptor ( ) {
{ dispose ( false ) ; } protected virtual void dispose ( bool disposing ) { lock ( lock ) { if ( disposed ) return ; disposed = true ; }
static encryptor _ factory ( ) { <%> <*> registered _ encryptors = new dictionary < string , type > ( ) ; foreach ( string method in mbed _ tls _ encryptor . supported _ ciphers ( ) ) -> foreach ( string method in stream _ mbed _ tls _ encryptor . supported _ ciphers ( ) ) </%> { registered _ encryptors . add ( method , typeof ( <%> <+> stream _ </%> mbed _ tls _ encryptor ) ) ; } foreach ( string method in <%> <+> stream _ </%> sodium _ encryptor . supported _ ciphers ( ) ) {
{ registered _ encryptors . add ( method , typeof ( <%> <+> stream _ </%> mbed _ tls _ encryptor ) ) ; } foreach ( string method in <%> <+> stream _ </%> sodium _ encryptor . supported _ ciphers ( ) ) { <%> <*> registered _ encryptors . add ( method , typeof ( sodium _ encryptor ) ) ; -> registered _ encryptors . add ( method , typeof ( stream _ sodium _ encryptor ) ) ; </%> <%> <+> } foreach ( string method in aead _ mbed _ tls _ encryptor . supported _ ciphers ( ) ) { </%>
} foreach ( string method in <%> <+> stream _ </%> sodium _ encryptor . supported _ ciphers ( ) ) { <%> <*> registered _ encryptors . add ( method , typeof ( sodium _ encryptor ) ) ; -> registered _ encryptors . add ( method , typeof ( stream _ sodium _ encryptor ) ) ; </%> <%> <+> } foreach ( string method in aead _ mbed _ tls _ encryptor . supported _ ciphers ( ) ) { registered _ encryptors . add ( method , typeof ( aead _ mbed _ tls _ encryptor ) ) ; } </%>
{ <%> <*> registered _ encryptors . add ( method , typeof ( sodium _ encryptor ) ) ; -> registered _ encryptors . add ( method , typeof ( stream _ sodium _ encryptor ) ) ; </%> <%> <+> } foreach ( string method in aead _ mbed _ tls _ encryptor . supported _ ciphers ( ) ) { registered _ encryptors . add ( method , typeof ( aead _ mbed _ tls _ encryptor ) ) ; } foreach ( string method in aead _ sodium _ encryptor . supported _ ciphers ( ) ) { </%>
} } public static i _ encryptor get _ encryptor ( string method , string password <%> <-> , bool onetimeauth , bool isudp </%> ) { if ( method . is _ null _ or _ empty ( ) ) { method = STR ; } method = method . to _ lower _ invariant ( ) ; type t = registered _ encryptors [ method ] ;
{ if ( method . is _ null _ or _ empty ( ) ) { method = STR ; } method = method . to _ lower _ invariant ( ) ; type t = registered _ encryptors [ method ] ; constructor _ info c = t . get _ constructor ( constructor _ types ) ; <%> <*> i _ encryptor result -> if ( c </%> = <%> <*> ( i _ encryptor ) c -> = null ) throw new system </%> . <%> <*> invoke -> exception </%> ( <%> <*> new object [ ] { method , password , onetimeauth , isudp } -> STR </%> ) ; <%> <+> i _ encryptor result = ( i _ encryptor ) c . invoke ( new object [ ] { method , password } ) ; </%>
return result ; } } }
{ <%> <+> private </%> const string dllname = STR ; public const int mbedtls _ encrypt = 1 ; public const int mbedtls _ decrypt = 0 ; static mbed _ tls ( ) { string dll _ path = utils . get _ temp _ path ( <%> <*> STR -> dllname </%> ) ; try { file _ manager . uncompress _ file ( dll _ path , resources . libsscrypto _ dll ) ;
public const int mbedtls _ encrypt = 1 ; public const int mbedtls _ decrypt = 0 ; static mbed _ tls ( ) { string dll _ path = utils . get _ temp _ path ( <%> <*> STR -> dllname </%> ) ; try { file _ manager . uncompress _ file ( dll _ path , resources . libsscrypto _ dll ) ; } catch ( io _ exception )
try { file _ manager . uncompress _ file ( dll _ path , resources . libsscrypto _ dll ) ; } catch ( io _ exception ) { } catch ( <%> <+> system . </%> exception e ) { logging . log _ useful _ exception ( e ) ;
{ logging . log _ useful _ exception ( e ) ; } load _ library ( dll _ path ) ; } public static byte [ ] m ( byte [ ] input ) { byte [ ] output = new byte [ NUM ] ; md ( input , ( uint ) input . length , output ) ; return output ;
dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl <%> <*> public static extern int cipher _ get _ size _ ex ( ) ; -> public static extern int cipher _ auth _ decrypt ( int _ ptr ctx , </%> <%> <+> byte [ ] iv , uint iv _ len , int _ ptr ad , uint ad _ len , byte [ ] input , uint ilen , byte [ ] output , ref uint olen , byte [ ] tag , uint tag _ len ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern int hkdf ( byte [ ] salt , </%>
} }
} * once failed , try after NUM min * and ( last write - last read ) < NUM s * and ( now - last read ) < NUM s * and latency < NUM ms , try after NUM s * / public void choose _ new _ server ( ) { server <%> <+> _ status </%> old _ server = current _ server ;

{ <%> <*> console . write _ line ( STR , current _ server . friendly _ name ( ) ) ; -> current _ server = max ; </%> <%> <+> console . write _ line ( STR , current _ server . server . friendly _ name ( ) ) ; </%> } <%> <-> logging . debug ( string . format ( STR , current _ server . friendly _ name ( ) ) ) ; </%> } } public void update _ latency ( model . server server , time _ span latency ) {
} <%> <-> logging . debug ( string . format ( STR , current _ server . friendly _ name ( ) ) ) ; </%> } } public void update _ latency ( model . server server , time _ span latency ) { logging . debug ( string . format ( STR , server . friendly _ name ( ) , latency ) ) ; server _ status status ; if ( server _ status . try _ get _ value ( server , out status ) ) {
} } public void update _ latency ( model . server server , time _ span latency ) { logging . debug ( string . format ( STR , server . friendly _ name ( ) , latency ) ) ; server _ status status ; if ( server _ status . try _ get _ value ( server , out status ) ) { status . latency = latency ; status . last _ time _ detect _ latency = date _ time . now ;
this . password _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . password _ text _ box . tab _ index = 2 ; this . password _ text _ box . word _ wrap = false ; <%> <+> this . password _ text _ box . use _ system _ password _ char = true ; </%>
} ) ; thread . sleep ( timeout + new random ( ) . next ( ) % timeout ) ; } catch ( exception e ) { logging . error ( $ STR ) ; logging . log _ useful _ exception ( e ) ; } } return ret ;
foreach ( var data _ lists in await task _ ex . when _ all ( servers . select ( icmp _ test ) ) ) { if ( data _ lists = = null ) continue ; foreach ( var data _ list in data _ lists . where ( data _ list = > data _ list ! = null ) ) { append ( data _ list , <%> <*> geolocation _ and -> enumerable . empty < data </%> _ <%> <*> isp . result -> unit > ( </%> ) <%> <+> ) </%> ; } } } private static void append ( data _ list data _ list , i _ enumerable < data _ unit > extra )
} } } private static void append ( data _ list data _ list , i _ enumerable < data _ unit > extra ) { var data = data _ list . concat ( extra ) ; var data _ line = string . join ( delimiter , data . select ( kv = > kv . value ) . to _ array ( ) ) ; string [ ] lines ; if ( ! file . exists ( availability _ statistics _ file ) ) {
public const string unknown = STR ; } public class raw _ statistics _ data { public date _ time timestamp ; public string server _ name ; public string icmp _ status ; public int roundtrip _ time ; <%> <-> public string geolocation ; public string isp ; </%>
} public class statistics _ data { public float package _ loss ; public int average _ response ; public int min _ response ; public int max _ response ; } public void update _ latency ( int latency ) {
array . copy ( iv , encrypt _ iv , iv _ len ) ; } else { decrypt _ iv = new byte [ iv _ len ] ; <%> <-> decrypt _ iv _ offset = new byte [ NUM ] ; </%> array . copy ( iv , decrypt _ iv , iv _ len ) ; } } else if ( cipher = = cipher _ bf )
array . copy ( iv , decrypt _ iv , iv _ len ) ; } } else if ( cipher = = cipher _ bf ) { polar _ ssl . blowfish _ init ( ctx ) ; polar _ ssl . blowfish _ setkey ( ctx , realkey , key _ len * NUM ) ; if ( is _ cipher ) { encrypt _ iv = new byte [ iv _ len ] ;
array . copy ( iv , encrypt _ iv , iv _ len ) ; } else { decrypt _ iv = new byte [ iv _ len ] ; <%> <-> decrypt _ iv _ offset = new byte [ NUM ] ; </%> array . copy ( iv , decrypt _ iv , iv _ len ) ; } } else if ( cipher = = cipher _ r )
array . copy ( iv , decrypt _ iv , iv _ len ) ; } } else if ( cipher = = cipher _ r ) { polar _ ssl . arc _ init ( ctx ) ; polar _ ssl . arc _ setup ( ctx , realkey , key _ len ) ; } } static byte [ ] tempbuf = new byte [ NUM ] ;
break ; case cipher _ bf : polar _ ssl . blowfish _ crypt _ cfb ( encrypt _ ctx , polar _ ssl . blowfish _ encrypt , length , <%> <+> ref </%> encrypt _ iv _ offset , encrypt _ iv , buf , tempbuf ) ; break ; case cipher _ r : polar _ ssl . arc _ crypt ( encrypt _ ctx , length , buf , tempbuf ) ; break ; } outlength = length + iv _ len ; buffer . block _ copy ( tempbuf , 0 , outbuf , iv _ len , length ) ;
break ; case cipher _ r : polar _ ssl . arc _ crypt ( encrypt _ ctx , length , buf , tempbuf ) ; break ; } outlength = length + iv _ len ; buffer . block _ copy ( tempbuf , 0 , outbuf , iv _ len , length ) ; } } else
break ; case cipher _ bf : polar _ ssl . blowfish _ crypt _ cfb ( encrypt _ ctx , polar _ ssl . blowfish _ encrypt , length , <%> <+> ref </%> encrypt _ iv _ offset , encrypt _ iv , buf , outbuf ) ; break ; case cipher _ r : polar _ ssl . arc _ crypt ( encrypt _ ctx , length , buf , outbuf ) ; break ; } } }
break ; case cipher _ r : polar _ ssl . arc _ crypt ( encrypt _ ctx , length , buf , outbuf ) ; break ; } } } public override void decrypt ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength ) { if ( decrypt _ ctx = = int _ ptr . zero )
break ; case cipher _ bf : polar _ ssl . blowfish _ crypt _ cfb ( decrypt _ ctx , polar _ ssl . blowfish _ decrypt , length - iv _ len , <%> <+> ref </%> decrypt _ iv _ offset , decrypt _ iv , tempbuf , outbuf ) ; break ; case cipher _ r : polar _ ssl . arc _ crypt ( decrypt _ ctx , length - iv _ len , tempbuf , outbuf ) ; break ; } } }
break ; case cipher _ r : polar _ ssl . arc _ crypt ( decrypt _ ctx , length - iv _ len , tempbuf , outbuf ) ; break ; } } } else { outlength = length ;
break ; case cipher _ bf : polar _ ssl . blowfish _ crypt _ cfb ( decrypt _ ctx , polar _ ssl . blowfish _ decrypt , length , <%> <+> ref </%> decrypt _ iv _ offset , decrypt _ iv , buf , outbuf ) ; break ; case cipher _ r : polar _ ssl . arc _ crypt ( decrypt _ ctx , length , buf , outbuf ) ; break ; } } }
break ; case cipher _ r : polar _ ssl . arc _ crypt ( decrypt _ ctx , length , buf , outbuf ) ; break ; } } } private bool disposed ; public override void dispose ( ) {
this . my _ cancel _ button . name = STR ; this . my _ cancel _ button . size = new system . drawing . size ( NUM , NUM ) ; this . my _ cancel _ button . tab _ index = NUM ; this . my _ cancel _ button . text = STR ; this . my _ cancel _ button . use _ visual _ style _ back _ color = true ; this . my _ cancel _ button . click + = new system . event _ handler ( this . cancel _ button _ click ) ; <%> <+> this . apply _ button . enabled = false ; this . apply _ button . dock = system . windows . forms . dock _ style . right ; this . apply _ button . location = new system . drawing . point ( NUM , NUM ) ; this . apply _ button . margin = new system . windows . forms . padding ( NUM , NUM , 0 , 0 ) ; </%>
using system _ drawing ; <%> <-> using system _ text ; </%> using system _ windows _ forms ; <%> <-> using system _ diagnostics ; using microsoft _ win ; </%> using shadowsocks _ controller ; using shadowsocks _ model ; using shadowsocks _ properties ; <%> <-> using system _ threading _ tasks ; </%> namespace shadowsocks _ view
using system _ windows _ forms ; <%> <-> using system _ diagnostics ; using microsoft _ win ; </%> using shadowsocks _ controller ; using shadowsocks _ model ; using shadowsocks _ properties ; <%> <-> using system _ threading _ tasks ; </%> namespace shadowsocks _ view { public partial class config _ form : form
using shadowsocks _ controller ; using shadowsocks _ model ; using shadowsocks _ properties ; <%> <-> using system _ threading _ tasks ; </%> namespace shadowsocks _ view { public partial class config _ form : form { private shadowsocks _ controller controller ; private configuration modified _ configuration ;
namespace shadowsocks _ view { public partial class config _ form : form { private shadowsocks _ controller controller ; private configuration modified _ configuration ; private int last _ selected _ index = - 1 ; public config _ form ( shadowsocks _ controller controller ) { this . font = system _ fonts . message _ box _ font ;
byte [ ] data _ in = new byte [ length - NUM + iv _ encryptor . onetimeauth _ bytes ] ; array . copy ( data , NUM , data _ in , 0 , length - NUM ) ; byte [ ] data _ out = new byte [ length - NUM + NUM + iv _ encryptor . onetimeauth _ bytes ] ; int outlen ; encryptor . encrypt ( data _ in , length - NUM , data _ out , out outlen <%> <-> , true </%> ) ; remote . send _ to ( data _ out , outlen , socket _ flags . none , remote _ end _ point ) ; } public void receive ( ) { end _ point remote _ end _ point = new ip _ end _ point ( ip _ address . any , 0 ) ;
remote . send _ to ( data _ out , outlen , socket _ flags . none , remote _ end _ point ) ; } public void receive ( ) { end _ point remote _ end _ point = new ip _ end _ point ( ip _ address . any , 0 ) ; remote . begin _ receive _ from ( buffer , 0 , buffer . length , 0 , ref remote _ end _ point , new async _ callback ( recv _ from _ callback ) , null ) ; } public void recv _ from _ callback ( i _ async _ result ar ) { try
{ if ( ! encrypt _ iv _ sent ) { <%> <*> encrypt _ iv _ sent = true ; -> int head _ len = get _ head _ len ( buf , length ) ; </%> <%> <+> int data _ len = length - head _ len ; buf [ 0 ] | = onetimeauth _ flag ; byte [ ] hash = gen _ onetime _ auth _ hash ( buf , head _ len ) ; buffer . block _ copy ( buf , head _ len , buf , head _ len + onetimeauth _ bytes + auth _ bytes , data _ len ) ; buffer . block _ copy ( hash , 0 , buf , head _ len , onetimeauth _ bytes ) ; </%>
rand _ bytes ( outbuf , iv _ len ) ; init _ cipher ( outbuf , true ) ; outlength = length + iv _ len ; <%> <-> if ( onetime _ auth & & iv _ len > 0 ) { if ( ! udp ) { int head _ len = get _ head _ len ( buf , length ) ; int data _ len = length - head _ len ; buf [ 0 ] | = onetimeauth _ flag ; </%>
lock ( tempbuf ) { cipher _ update ( true , length , buf , tempbuf ) ; outlength = length + iv _ len ; buffer . block _ copy ( tempbuf , 0 , outbuf , iv _ len , length ) ; } } else { <%> <-> if ( onetime _ auth & & iv _ len > 0 ) </%>
outlength = length ; cipher _ update ( true , length , buf , outbuf ) ; } } public override void decrypt ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength ) { if ( ! decrypt _ iv _ received ) { decrypt _ iv _ received = true ; init _ cipher ( buf , false ) ;
{ method = method ; password = password ; onetime _ auth = onetimeauth ; <%> <+> is _ udp = isudp ; </%> } protected string method ; protected string password ; protected bool onetime _ auth ; <%> <+> protected bool is _ udp ; </%>
public abstract void decrypt ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength ) ; public abstract void dispose ( ) ; } }
{ if ( string . is _ null _ or _ empty ( method ) ) { method = STR ; } method = method . to _ lower _ invariant ( ) ; type t = registered _ encryptors [ method ] ; constructor _ info c = t . get _ constructor ( constructor _ types ) ; i _ encryptor result = ( i _ encryptor ) c . invoke ( new object [ ] { method , password , onetimeauth <%> <+> , isudp </%> } ) ; return result ;
return result ; } } }
decryptor . decrypt ( cipher , out _ len , plain , out out _ len ) ; assert . are _ equal ( plain . length , out _ len ) ; for ( int j = 0 ; j < plain . length ; j + + ) { assert . are _ equal ( plain [ j ] , plain [ j ] ) ; } encryptor . encrypt ( plain , NUM , cipher , out out _ len <%> <-> , false </%> ) ; decryptor . decrypt ( cipher , out _ len , plain , out out _ len ) ; assert . are _ equal ( NUM , out _ len ) ; for ( int j = 0 ; j < out _ len ; j + + )
decryptor . decrypt ( cipher , out _ len , plain , out out _ len ) ; assert . are _ equal ( NUM , out _ len ) ; for ( int j = 0 ; j < out _ len ; j + + ) { assert . are _ equal ( plain [ j ] , plain [ j ] ) ; } encryptor . encrypt ( plain , NUM , cipher , out out _ len <%> <-> , false </%> ) ; decryptor . decrypt ( cipher , out _ len , plain , out out _ len ) ; assert . are _ equal ( NUM , out _ len ) ; for ( int j = 0 ; j < out _ len ; j + + )
decryptor . decrypt ( cipher , out _ len , plain , out out _ len ) ; assert . are _ equal ( NUM , out _ len ) ; for ( int j = 0 ; j < out _ len ; j + + ) { assert . are _ equal ( plain [ j ] , plain [ j ] ) ; } } private static bool encryption _ failed = false ; private static object locker = new object ( ) ; test _ method
this . table _ layout _ panel = new system . windows . forms . table _ layout _ panel ( ) ; <%> <+> this . notify _ icon = new system . windows . forms . notify _ icon ( this . components ) ; this . context _ menu _ strip = new system . windows . forms . context _ menu _ strip ( this . components ) ; this . config = new system . windows . forms . tool _ strip _ menu _ item ( ) ; this . quit = new system . windows . forms . tool _ strip _ menu _ item ( ) ; </%> this . table _ layout _ panel . suspend _ layout ( ) ; this . panel . suspend _ layout ( ) ; this . table _ layout _ panel . suspend _ layout ( ) ; <%> <+> this . context _ menu _ strip . suspend _ layout ( ) ; </%>

<%> <*> private long last _ inbound _ counter ; private list < int > inbound _ speed _ records ; private long last _ outbound _ counter ; private list < int > outbound _ speed _ records ; -> private readonly concurrent _ dictionary < string , long > inbound _ counter = new concurrent _ dictionary < string , long > ( ) ; </%> <%> <+> private readonly concurrent _ dictionary < string , long > last _ inbound _ counter = new concurrent _ dictionary < string , long > ( ) ; private readonly concurrent _ dictionary < string , list < int > > inbound _ speed _ records = new concurrent _ dictionary < string , list < int > > ( ) ; private readonly concurrent _ dictionary < string , long > outbound _ counter = new concurrent _ dictionary < string , long > ( ) ; private readonly concurrent _ dictionary < string , long > last _ outbound _ counter = new concurrent _ dictionary < string , long > ( ) ; private readonly concurrent _ dictionary < string , list < int > > outbound _ speed _ records = new concurrent _ dictionary < string , list < int > > ( ) ; </%>
private readonly time _ span delay _ before _ start = time _ span . from _ seconds ( 1 ) ; private readonly time _ span retry _ interval = time _ span . from _ minutes ( 2 ) ; private timer recorder ; private time _ span recording _ interval = > time _ span . from _ minutes ( config . data _ collection _ minutes ) ; private timer speed _ monior ; private readonly time _ span monitor _ interval = time _ span . from _ seconds ( 1 ) ; <%> <-> private timer writer ; private readonly time _ span writing _ interval = time _ span . from _ minutes ( 1 ) ; </%> private shadowsocks _ controller controller ; private statistics _ strategy _ configuration config = > controller . statistics _ configuration ;
private shadowsocks _ controller controller ; private statistics _ strategy _ configuration config = > controller . statistics _ configuration ; <%> <-> private server current _ server = > controller . get _ current _ server ( ) ; </%> public static availability _ statistics instance { get ; } = new availability _ statistics ( ) ; public statistics raw _ statistics { get ; private set ; } public statistics filtered _ statistics { get ; private set ; } private availability _ statistics ( ) { raw _ statistics = new statistics ( ) ; }
public static availability _ statistics instance { get ; } = new availability _ statistics ( ) ; public statistics raw _ statistics { get ; private set ; } public statistics filtered _ statistics { get ; private set ; } private availability _ statistics ( ) { raw _ statistics = new statistics ( ) ; } internal void update _ configuration ( shadowsocks _ controller controller ) { controller = controller ;
} else { recorder ? . dispose ( ) ; speed _ monior ? . dispose ( ) ; <%> <-> writer ? . dispose ( ) ; </%> } } catch ( exception e ) {
} } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; } } private void start _ timer _ without _ state ( ref timer timer , timer _ callback callback , time _ span interval ) { if ( timer ? . change ( delay _ before _ start , interval ) = = null )
} private void run ( object ) { update _ records ( ) ; <%> <+> save ( ) ; </%> reset ( ) ; filter _ raw _ statistics ( ) ; } private async void update _ records ( ) {
return ; } <%> <-> var icmp _ results = task _ ex . when _ all ( controller . get _ current _ configuration ( ) . configs . select ( icmp _ test ) ) ; foreach ( var result in ( await icmp _ results ) . where ( result = > result ! = null ) ) { if ( result . server . equals ( current _ server ) ) { current _ server _ record . set _ response ( result . roundtrip _ time ) ; append _ record ( current _ server , current _ server _ record ) ; } </%>
try { <%> <*> file -> var content = json _ convert </%> . <%> <*> write _ all -> serialize </%> _ <%> <*> text -> object </%> ( <%> <*> availability -> raw </%> _ statistics <%> <-> _ file </%> , <%> <+> formatting . none ) ; </%> <%> <*> json -> file . write </%> _ <%> <*> convert . serialize -> all </%> _ <%> <*> object -> text </%> ( <%> <*> raw -> availability </%> _ statistics <%> <+> _ file </%> , <%> <*> formatting . none ) -> content </%> ) ; } catch ( io _ exception e ) { logging . log _ useful _ exception ( e ) ; <%> <-> writer . change ( retry _ interval , writing _ interval ) ; </%> }
} catch ( io _ exception e ) { logging . log _ useful _ exception ( e ) ; <%> <-> writer . change ( retry _ interval , writing _ interval ) ; </%> } } private bool is _ valid _ record ( statistics _ record record ) { if ( config . by _ hour _ of _ day )
} } private bool is _ valid _ record ( statistics _ record record ) { if ( config . by _ hour _ of _ day ) { if ( ! record . timestamp . hour . equals ( date _ time . now . hour ) ) return false ; } return true ; }
speed _ monior . dispose ( ) ; <%> <+> } public void update _ latency ( server server , int latency ) { list < int > records ; latency _ records . try _ get _ value ( server . identifier ( ) , out records ) ; if ( records = = null ) { records = new list < int > ( ) ; } </%>
{ interlocked . add ( ref inbound _ counter , n ) ; <%> <+> if ( config . availability _ statistics ) { new task ( ( ) = > availability _ statistics . update _ inbound _ counter ( server , n ) ) . start ( ) ; </%> } <%> <-> public void update _ outbound _ counter ( long n ) </%> <%> <+> } public void update _ outbound _ counter ( server server , long n ) </%> { interlocked . add ( ref outbound _ counter , n ) ;
{ interlocked . add ( ref outbound _ counter , n ) ; <%> <+> if ( config . availability _ statistics ) { new task ( ( ) = > availability _ statistics . update _ outbound _ counter ( server , n ) ) . start ( ) ; } </%> } protected void reload ( ) { config = configuration . load ( ) ;
public int? average _ latency ; public int? min _ latency ; public int? max _ latency ; <%> <+> private bool empty _ latency _ data = > ( average _ latency = = null ) & & ( min _ latency = = null ) & & ( max _ latency = = null ) ; </%> public int? average _ inbound _ speed ; public int? min _ inbound _ speed ; public int? max _ inbound _ speed ; <%> <+> private bool empty _ inbound _ speed _ data = > ( average _ inbound _ speed = = null ) & & ( min _ inbound _ speed = = null ) & & ( max _ inbound _ speed = = null ) ; </%> public int? average _ outbound _ speed ;
{ server _ <%> <*> name -> identifier </%> = identifier ; if ( inbound _ speed _ records ! = null & & inbound _ speed _ records . any ( ) ) { average _ inbound _ speed = ( int ) inbound _ speed _ records . average ( ) ; min _ inbound _ speed = inbound _ speed _ records . min ( ) ; max _ inbound _ speed = inbound _ speed _ records . max ( ) ; } if ( outbound _ speed _ records ! = null & & outbound _ speed _ records . any ( ) ) {
if ( inbound _ speed _ records ! = null & & inbound _ speed _ records . any ( ) ) { average _ inbound _ speed = ( int ) inbound _ speed _ records . average ( ) ; min _ inbound _ speed = inbound _ speed _ records . min ( ) ; max _ inbound _ speed = inbound _ speed _ records . max ( ) ; } if ( outbound _ speed _ records ! = null & & outbound _ speed _ records . any ( ) ) { average _ outbound _ speed = ( int ) outbound _ speed _ records . average ( ) ; min _ outbound _ speed = outbound _ speed _ records . min ( ) ;
} public void set _ response ( i _ <%> <*> enumerable -> collection </%> < int? > response _ records ) { if ( response _ records = = null ) return ; var records = response _ records . where ( response = > response ! = null ) . select ( response = > response . value ) . to _ list ( ) ; if ( ! records . any ( ) ) return ; average _ response = ( int? ) records . average ( ) ; min _ response = records . min ( ) ; max _ response = records . max ( ) ; package _ loss = response _ records . count ( response = > response ! = null ) / ( float ) response _ records . count <%> <-> ( ) </%> ;
{ if ( response _ records = = null ) return ; var records = response _ records . where ( response = > response ! = null ) . select ( response = > response . value ) . to _ list ( ) ; if ( ! records . any ( ) ) return ; average _ response = ( int? ) records . average ( ) ; min _ response = records . min ( ) ; max _ response = records . max ( ) ; package _ loss = response _ records . count ( response = > response ! = null ) / ( float ) response _ records . count <%> <-> ( ) </%> ; } }
} } }
{ var config = controller . statistics _ configuration ; <%> <+> float? score = null ; </%> <%> <*> list < -> var average _ record = new </%> statistics _ record <%> <*> > records ; if ( filtered -> ( identifier , records . where ( record = > record . max _ inbound </%> _ <%> <*> statistics = -> speed ! </%> = null <%> <*> | | ! filtered _ statistics -> ) . select ( record = > record </%> . <%> <*> try -> max </%> _ <%> <*> get -> inbound </%> _ <%> <+> speed . </%> value <%> <*> ( server -> ) . to </%> _ <%> <*> name , out records -> list ( </%> ) <%> <*> ) return 0 ; -> , </%> <%> <-> float factor ; </%> <%> <+> records . where ( record = > record . max _ outbound _ speed ! = null ) . select ( record = > record . max _ outbound _ speed . value ) . to _ list ( ) , </%> <%> <*> float score -> records . where ( record </%> = <%> <*> 0 ; -> > record . average _ latency ! = null ) . select ( record = > record . average _ latency . value ) . to _ list ( ) ) ; </%> <%> <-> var </%> average _ record <%> <*> = new statistics -> . set </%> _ <%> <*> record -> response </%> ( <%> <*> server _ name , records . find _ all ( record = > record . max _ inbound _ speed ! = null ) . select ( record = > record . max _ inbound _ speed -> records . select ( record = > record . average _ response ) . to _ list ( ) ) ; foreach ( var calculation in config </%> . <%> <*> value -> calculations </%> ) <%> <*> , records . find _ all ( record = > record . max _ outbound _ speed ! = null ) . select ( record = > record . max _ outbound _ speed . value ) , -> { </%>
return score ; } private void choose _ new _ server ( list < server > servers ) { if ( filtered _ statistics = = null | | servers . count = = 0 ) { return ; } try {
( ( system . component _ model . i _ support _ initialize ) ( this . statistics _ chart ) ) . begin _ init ( ) ; <%> <+> ( ( system . component _ model . i _ support _ initialize ) ( this . binding _ configuration ) ) . begin _ init ( ) ; </%> this . chart _ mode _ selector . suspend _ layout ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . begin _ init ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . suspend _ layout ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . begin _ init ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . panel . suspend _ layout ( ) ;
this . servers _ list _ box . location = new system . drawing . point ( NUM , NUM ) ; this . servers _ list _ box . name = STR ; this . servers _ list _ box . size = new system . drawing . size ( NUM , NUM ) ; this . servers _ list _ box . tab _ index = NUM ; this . servers _ list _ box . selected _ index _ changed + = new system . event _ handler ( this . servers _ list _ box _ selected _ index _ changed ) ; <%> <-> this . label . anchor = system . windows . forms . anchor _ styles . right ; this . label . auto _ size = true ; this . label . location = new system . drawing . point ( NUM , NUM ) ; this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ; </%>

{ if ( line <%> <*> . begin _ with ( -> [ 0 ] = = </%> '#' ) <%> <-> ) </%> continue ; var pos = line . index _ of ( '=' ) ; if ( pos < 1 ) continue ; strings [ line . substring ( 0 , pos ) ] = line . substring ( pos + 1 ) ; } } }
continue ; var pos = line . index _ of ( '=' ) ; if ( pos < 1 ) continue ; strings [ line . substring ( 0 , pos ) ] = line . substring ( pos + 1 ) ; } } } } public static string get _ string ( string key )
private encryptor encryptor ; socket listener ; public local ( <%> <*> int port -> config config </%> ) { this . <%> <*> port -> config </%> = <%> <*> port -> config </%> ; this . encryptor = new encryptor ( <%> <*> STR -> config . password </%> ) ; } public void start ( ) { listener = new socket ( address _ family . inter _ network ,
} public void start ( ) { listener = new socket ( address _ family . inter _ network , socket _ type . stream , protocol _ type . tcp ) ; ip _ end _ point local _ end _ point = new ip _ end _ point ( 0 , <%> <+> config . local _ </%> port ) ; listener . bind ( local _ end _ point ) ; listener . listen ( NUM ) ; console . write _ line ( STR ) ; listener . begin _ accept (
listener . bind ( local _ end _ point ) ; listener . listen ( NUM ) ; console . write _ line ( STR ) ; listener . begin _ accept ( new async _ callback ( accept _ callback ) , listener ) ; } public void stop ( ) { listener . close ( ) ;
ip _ address ip _ address = ip _ host _ info . address _ list [ 0 ] ; ip _ end _ point remote _ ep = new ip _ end _ point ( ip _ address , <%> <*> NUM -> config . server _ port </%> ) ; remote = new socket ( address _ family . inter _ network , socket _ type . stream , protocol _ type . tcp ) ; remote . begin _ connect ( remote _ ep , new async _ callback ( connect _ callback ) , null ) ; } <%> <+> public void close ( ) { connection . close ( ) ; </%>
remote = new socket ( address _ family . inter _ network , socket _ type . stream , protocol _ type . tcp ) ; remote . begin _ connect ( remote _ ep , new async _ callback ( connect _ callback ) , null ) ; } <%> <+> public void close ( ) { connection . close ( ) ; remote . close ( ) ; } </%>
{ show _ balloon _ tip ( n . get _ string ( STR ) , e . get _ exception ( ) . message , tool _ tip _ icon . error , NUM ) ; logger . log _ useful _ exception ( e . get _ exception ( ) ) ; } void controller _ update _ pac _ from <%> <-> _ gfw </%> _ <%> <*> list -> geosite </%> _ completed ( object sender , geosite _ result _ event _ args e ) { string result = e . success ? n . get _ string ( STR ) : n . get _ string ( STR ) ; show _ balloon _ tip ( n . get _ string ( STR ) , result , tool _ tip _ icon . info , NUM ) ;
{ string result = e . success ? n . get _ string ( STR ) : n . get _ string ( STR ) ; show _ balloon _ tip ( n . get _ string ( STR ) , result , tool _ tip _ icon . info , NUM ) ; } void update _ checker _ check _ update _ completed ( object sender , event _ args e ) { if ( update _ checker . new _ version _ found ) {
} private void pac _ server _ pac _ update _ error ( object sender , error _ event _ args e ) { update _ pac _ from <%> <-> _ gfw </%> _ <%> <*> list -> geosite </%> _ error ? . invoke ( this , e ) ; } private static readonly i _ enumerable < char > ignored _ line _ begins = new [ ] { '!' , '[' } ; private void pac _ daemon _ user _ rule _ file _ changed ( object sender , event _ args e ) { geosite _ updater . merge _ and _ write _ pac _ file ( ) ; update _ system _ proxy ( ) ;
} private static readonly i _ enumerable < char > ignored _ line _ begins = new [ ] { '!' , '[' } ; private void pac _ daemon _ user _ rule _ file _ changed ( object sender , event _ args e ) { geosite _ updater . merge _ and _ write _ pac _ file ( ) ; update _ system _ proxy ( ) ; } public void copy _ pac _ url ( ) { clipboard . set _ data _ object ( pac _ server . pac _ url ) ;
} public static void disable ( ) { <%> <*> registry _ key registry = registry . current _ user . open _ sub _ key ( STR , -> try { registry _ key registry = registry . current _ user . open _ sub _ key ( STR , </%> true ) ; registry . set _ value ( STR , 0 ) ; registry . set _ value ( STR , STR ) ;
} private static string get _ timestamp ( date _ time value ) { return value . to _ string ( STR ) ; } } }
{ string original = file _ manager . non _ exclusive _ read _ all _ text ( pac _ <%> <*> server -> daemon </%> . pac _ file , encoding . ut ) ; if ( original = = abp _ content ) { return false ; } } file . write _ all _ text ( pac _ <%> <*> server -> daemon </%> . pac _ file , abp _ content , encoding . ut ) ; return true ; }
if ( original = = abp _ content ) { return false ; } } file . write _ all _ text ( pac _ <%> <*> server -> daemon </%> . pac _ file , abp _ content , encoding . ut ) ; return true ; } private static string merge _ pac _ file ( string gfw _ list _ result ) {
return true ; } private static string merge _ pac _ file ( string gfw _ list _ result ) { string abp _ content ; if ( file . exists ( pac _ <%> <*> server -> daemon </%> . user _ abp _ file ) ) { abp _ content = file _ manager . non _ exclusive _ read _ all _ text ( pac _ <%> <*> server -> daemon </%> . user _ abp _ file , encoding . ut ) ; } else
pac _ file _ ready _ to _ open ? . invoke ( this , new path _ event _ args ( ) { path = pac _ filename } ) ; } public void touch _ user _ rule _ file ( ) { string user _ rule _ filename = pac _ <%> <*> server -> daemon </%> . touch _ user _ rule _ file ( ) ; user _ rule _ file _ ready _ to _ open ? . invoke ( this , new path _ event _ args ( ) { path = user _ rule _ filename } ) ; } public string get _ server _ url _ for _ current _ server ( ) { server server = get _ current _ server ( ) ;
user _ rule _ file _ ready _ to _ open ? . invoke ( this , new path _ event _ args ( ) { path = user _ rule _ filename } ) ; } public string get _ server _ url _ for _ current _ server ( ) { server server = get _ current _ server ( ) ; return get _ server _ url ( server ) ; } public static string get _ server _ url ( server server ) { string tag = string . empty ;
if ( gfw _ list _ updater = = null ) { gfw _ list _ updater = new gfw _ list _ updater ( ) ; gfw _ list _ updater . update _ completed + = pac _ server _ pac _ update _ completed ; gfw _ list _ updater . error + = pac _ server _ pac _ update _ error ; } availability _ statistics . update _ configuration ( this ) ; if ( listener ! = null ) { listener . stop ( ) ;
private string pac _ secret { get ; set ; } = STR ; public string pac _ url { get ; private set ; } = STR ; <%> <-> file _ system _ watcher pac _ file _ watcher ; file _ system _ watcher user _ rule _ file _ watcher ; </%> private configuration config ; <%> <*> public event event _ handler pac _ file _ changed ; public event event _ handler user _ rule _ file _ changed ; public pac _ server ( ) -> private pac _ daemon pac _ daemon ; </%> <%> <+> public pac _ server ( pac _ daemon pac _ daemon ) </%>
private configuration config ; <%> <*> public event event _ handler pac _ file _ changed ; public event event _ handler user _ rule _ file _ changed ; public pac _ server ( ) -> private pac _ daemon pac _ daemon ; </%> <%> <+> public pac _ server ( pac _ daemon pac _ daemon ) </%> { <%> <*> this . watch _ pac _ file ( ) ; this . watch _ user _ rule _ file ( ) ; -> pac _ daemon = pac _ daemon ; </%>
{ <%> <*> this . watch _ pac _ file ( ) ; this . watch _ user _ rule _ file ( ) ; -> pac _ daemon = pac _ daemon ; </%> } public void update _ <%> <*> configuration -> pacurl </%> ( configuration config ) { this . config = config ; if ( config . secure _ local _ pac ) {
} public void update _ <%> <*> configuration -> pacurl </%> ( configuration config ) { this . config = config ; if ( config . secure _ local _ pac ) { var rd = new byte [ NUM ] ; rng . get _ bytes ( rd ) ; pac _ secret = $ STR ; }
{ this . config = config ; if ( config . secure _ local _ pac ) { var rd = new byte [ NUM ] ; rng . get _ bytes ( rd ) ; pac _ secret = $ STR ; } else {
{ <%> <*> string [ ] kv = line . split ( new char [ ] { ':' } , 2 ) ; -> return false ; </%> <%> <+> } string request _ line = lines [ 0 ] ; string [ ] request _ items = request _ line . split ( ' ' ) ; if ( request _ items . length = = NUM & & request _ items [ 0 ] = = STR ) { int index = request _ items [ 1 ] . index _ of ( '?' ) ; if ( index < 0 ) </%>
if ( kv . length = = 2 ) { if ( kv [ 0 ] = = STR ) { if ( kv [ 1 ] . trim ( ) = = ( ( ip _ end _ point ) socket . local _ end _ point ) . to _ string ( ) ) { host _ match = true ; } } <%> <-> } </%>
} } if ( host _ match & & path _ match ) { if ( ! secret _ match ) { socket . close ( ) ; } else {
public void send _ response ( socket socket , bool use _ socks ) { try { ip _ end _ point local _ end _ point = ( ip _ end _ point ) socket . local _ end _ point ; string proxy = get _ pac _ address ( local _ end _ point , use _ socks ) ; string pac _ content = <%> <+> pac _ daemon . </%> get _ pac _ content ( ) . replace ( STR , proxy ) ; string response _ head = string . format ( @ STR server : shadowsocks content - type : application / x - ns - proxy - autoconfig
string response _ head = string . format ( @ STR server : shadowsocks content - type : application / x - ns - proxy - autoconfig content - length : { 0 } connection : close STR byte [ ] response = encoding . ut . get _ bytes ( response _ head + pac _ content ) ; socket . begin _ send ( response , 0 , response . length , 0 , new async _ callback ( send _ callback ) , socket ) ; utils . release _ memory ( true ) ; }
private time _ span recording _ interval = > time _ span . from _ minutes ( config . data _ collection _ minutes ) ; private timer <%> <*> speed -> per _ second </%> _ <%> <*> monior -> timer </%> ; private readonly time _ span monitor _ interval = time _ span . from _ seconds ( 1 ) ; private shadowsocks _ controller controller ; private statistics _ strategy _ configuration config = > controller . statistics _ configuration ; public static availability _ statistics instance { get ; } = new availability _ statistics ( ) ; public statistics raw _ statistics { get ; private set ; } public statistics filtered _ statistics { get ; private set ; } private availability _ statistics ( ) {
private readonly time _ span monitor _ interval = time _ span . from _ seconds ( 1 ) ; private shadowsocks _ controller controller ; private statistics _ strategy _ configuration config = > controller . statistics _ configuration ; public static availability _ statistics instance { get ; } = new availability _ statistics ( ) ; public statistics raw _ statistics { get ; private set ; } public statistics filtered _ statistics { get ; private set ; } private availability _ statistics ( ) { raw _ statistics = new statistics ( ) ; }
load _ raw _ statistics ( ) ; <%> <*> start _ timer _ without _ state ( ref speed _ monior , update _ speed , monitor _ interval ) ; -> if ( per _ second _ timer = = null ) </%> <%> <+> { per _ second _ timer = new timer ( operations _ per _ second , new counter ( ) , delay _ before _ start , time _ span . from _ seconds ( 1 ) ) ; } </%> } else { <%> <-> recorder ? . dispose ( ) ; </%>
} else { <%> <*> recorder ? . dispose ( ) ; speed _ monior ? . dispose ( ) ; -> per _ second _ timer ? . dispose ( ) ; </%> } } catch ( exception e ) {
} } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; } } <%> <+> private void operations _ per _ second ( object state ) { lock ( state ) </%>
{ foreach ( var kv in in _ out _ bound _ records ) { var id = kv . key ; var record = kv . value ; long inbound _ delta , outbound _ delta ; record . get _ delta ( out inbound _ delta , out outbound _ delta ) ; var inbound _ speed = get _ speed _ in _ ki _ b _ per _ second ( inbound _ delta , monitor _ interval . total _ seconds ) ; var outbound _ speed = get _ speed _ in _ ki _ b _ per _ second ( outbound _ delta , monitor _ interval . total _ seconds ) ; var in _ r = inbound _ speed _ records . get _ or _ add ( id , ( k ) = > new list < int > ( ) ) ;
{ update _ records ( ) ; reset ( ) ; } private void update _ records ( ) { var records = new dictionary < string , statistics _ record > ( ) ; update _ records _ state state = new update _ records _ state ( ) ; <%> <+> int server _ count = controller . get _ current _ configuration ( ) . configs . count ; state . counter = server _ count ; </%>
{ save ( ) ; filter _ raw _ statistics ( ) ; } } private void ping _ completed ( object sender , my _ ping . completed _ event _ args e ) { ping _ state ping _ state = ( ping _ state ) e . user _ state ; update _ records _ state state = ping _ state . state ; server server = e . server ;
foreach ( var server _ and _ records in raw _ statistics ) { var server = server _ and _ records . key ; var filtered _ records = server _ and _ records . value . find _ all ( is _ valid _ record ) ; filtered _ statistics [ server ] = filtered _ records ; } <%> <+> filtered _ statistics = filtered _ statistics ; </%> } catch ( exception e ) {
} catch ( exception e ) { logging . log _ useful _ exception ( e ) ; } } private void load _ raw _ statistics ( ) { try {
} } private static int get _ speed _ in _ ki _ b _ per _ second ( long bytes , double seconds ) { var result = ( int ) ( bytes / seconds ) / NUM ; return result ; } public void dispose ( ) { <%> <-> recorder . dispose ( ) ; </%>
} public void update _ latency ( server server , int latency ) { latency _ records . get _ or _ add ( server . identifier ( ) , ( k ) = > { list < int > records = new list < int > ( ) ; records . add ( latency ) ; return records ; } ) ; }
public string pac _ url { get ; private set ; } = STR ; private configuration config ; private pac _ daemon pac _ daemon ; public pac _ server ( pac _ daemon pac _ daemon ) { pac _ daemon = pac _ daemon ; } public void update _ pacurl ( configuration config ) { <%> <-> this . config = config ; </%>
} private static string get _ hash ( string content ) { var content _ bytes = encoding . ascii . get _ bytes ( content ) ; using ( var md = system . security . cryptography . m . create ( ) ) { var md _ bytes = md . compute _ hash ( content _ bytes ) ; return <%> <*> bit -> http _ server </%> _ <%> <*> converter -> utility </%> . <%> <*> to -> url _ token </%> _ <%> <*> string -> encode </%> ( md _ bytes ) <%> <*> . replace ( STR , STR ) ; -> ; </%>

{ <%> <*> protected -> private </%> static dictionary < string , string > strings <%> <*> ; -> = new dictionary < string , string > ( ) ; </%> <%> <+> private </%> static void init ( string res ) { using ( var sr = new string _ reader ( res ) ) { foreach ( var line in sr . non _ white _ space _ lines ( ) ) { if ( line [ 0 ] = = '#' ) continue ;
{ using ( var sr = new string _ reader ( res ) ) { foreach ( var line in sr . non _ white _ space _ lines ( ) ) { if ( line [ 0 ] = = '#' ) continue ; var pos = line . index _ of ( '=' ) ; if ( pos < 1 ) continue ;
{ <%> <*> if ( name = = STR | | name = = STR ) { init ( resources . cn ) ; } else { init ( resources . zh _ tw ) ; } -> init ( name . contains ( STR ) </%>
} } public static string get _ string ( string key ) { <%> <-> if ( strings . contains _ key ( key ) ) { return strings [ key ] ; } else { </%>
} } }
} else { <%> <+> logging . info ( STR ) ; </%> n = file . read _ all _ text ( n _ file , encoding . ut ) ; } logging . info ( STR + locale ) ; init ( n , locale ) ; } public static string get _ string ( string key , params object [ ] args )
using system _ diagnostics ; using system _ drawing ; <%> <*> using system _ drawing _ imaging ; -> using system _ io ; </%> <%> <+> using system _ linq ; using system _ text ; </%> using system _ windows _ forms ; using z _ xing ; using z _ xing _ common ; using z _ xing _ qr _ code ;
using system _ windows _ forms ; using z _ xing ; using z _ xing _ common ; using z _ xing _ qr _ code ; <%> <-> using shadowsocks _ controller ; using shadowsocks _ model ; using shadowsocks _ properties ; using shadowsocks _ util ; using system _ linq ; using microsoft _ win ; </%>
namespace shadowsocks _ view { public class menu _ view _ controller { private shadowsocks _ controller controller ; private update _ checker update _ checker ; private notify _ icon notify _ icon ; private icon icon , icon _ in , icon _ out , icon _ both , previous _ icon ; private bool is _ first _ run ; private bool is _ startup _ checking ;
list < listener . service > services = new list < listener . service > ( ) ; <%> <*> services . add ( local ) ; -> services . add ( tcp _ relay ) ; </%> <%> <+> services . add ( udp _ relay ) ; </%> services . add ( pac _ server ) ; services . add ( new port _ forwarder ( polipo _ runner . running _ port ) ) ; listener = new listener ( services ) ; listener . start ( config ) ; } catch ( exception e )
services . add ( pac _ server ) ; services . add ( new port _ forwarder ( polipo _ runner . running _ port ) ) ; listener = new listener ( services ) ; listener . start ( config ) ; } catch ( exception e ) { if ( e is socket _ exception ) { socket _ exception se = ( socket _ exception ) e ;
} configuration config ; bool share _ over _ lan ; <%> <*> socket socket ; -> socket tcp _ socket ; </%> <%> <+> socket udp _ socket ; </%> i _ list < service > services ; public listener ( i _ list < service > services ) { this . services = services ;
i _ list < service > services ; public listener ( i _ list < service > services ) { this . services = services ; } private bool check _ if _ port _ in _ use ( int port ) { ip _ global _ properties ip _ properties = ip _ global _ properties . get _ ip _ global _ properties ( ) ; ip _ end _ point [ ] ip _ end _ points = ip _ properties . get _ active _ tcp _ listeners ( ) ; foreach ( ip _ end _ point end _ point in ip _ end _ points )
ip _ end _ point local _ end _ point = null ; if ( share _ over _ lan ) { local _ end _ point = new ip _ end _ point ( ip _ address . any , config . local _ port ) ; } else { local _ end _ point = new ip _ end _ point ( ip _ address . loopback , config . local _ port ) ; } <%> <-> socket . bind ( local _ end _ point ) ; </%>
console . write _ line ( STR ) ; <%> <+> tcp _ </%> socket . begin _ accept ( new async _ callback ( accept _ callback ) , <%> <*> socket ) ; -> tcp _ socket ) ; </%> <%> <+> udp _ state udp _ state = new udp _ state ( ) ; udp _ socket . begin _ receive _ from ( udp _ state . buffer , 0 , udp _ state . buffer . length , 0 , ref udp _ state . remote _ end _ point , new async _ callback ( recv _ from _ callback ) , udp _ state ) ; </%> } catch ( socket _ exception ) {
new async _ callback ( accept _ callback ) , <%> <*> socket ) ; -> tcp _ socket ) ; </%> <%> <+> udp _ state udp _ state = new udp _ state ( ) ; udp _ socket . begin _ receive _ from ( udp _ state . buffer , 0 , udp _ state . buffer . length , 0 , ref udp _ state . remote _ end _ point , new async _ callback ( recv _ from _ callback ) , udp _ state ) ; </%> } catch ( socket _ exception ) { <%> <+> tcp _ </%> socket . close ( ) ; throw ;
} catch ( socket _ exception ) { <%> <+> tcp _ </%> socket . close ( ) ; throw ; } } public void stop ( ) { if ( <%> <+> tcp _ </%> socket ! = null )
throw ; } } public void stop ( ) { if ( <%> <+> tcp _ </%> socket ! = null ) { <%> <*> socket . close ( ) ; socket = null ; -> tcp _ socket . close ( ) ; </%>
{ <%> <*> socket . close ( ) ; socket = null ; -> tcp _ socket . close ( ) ; </%> <%> <+> tcp _ socket = null ; } if ( udp _ socket ! = null ) { udp _ socket . close ( ) ; udp _ socket = null ; </%>
} } public void accept _ callback ( i _ async _ result ar ) { socket listener = ( socket ) ar . async _ state ; try { socket conn = listener . end _ accept ( ar ) ; byte [ ] buf = new byte [ NUM ] ; object [ ] state = new object [ ] {
{ return ; } } <%> <+> if ( conn . protocol _ type = = protocol _ type . tcp ) { </%> conn . close ( ) ; <%> <+> } </%> } catch ( exception e )
} catch ( exception e ) { console . write _ line ( e ) ; conn . close ( ) ; } } } }
{ private configuration config ; public <%> <*> local -> tcp _ relay </%> ( configuration config ) { this . config = config ; } public bool handle ( byte [ ] first _ packet , int length , socket socket <%> <+> , object state </%> ) { <%> <+> if ( socket . protocol _ type ! = protocol _ type . tcp ) { </%>
{ this . config = config ; } public bool handle ( byte [ ] first _ packet , int length , socket socket <%> <+> , object state </%> ) { <%> <+> if ( socket . protocol _ type ! = protocol _ type . tcp ) { return false ; } </%> if ( length < 2 | | first _ packet [ 0 ] ! = NUM )
if ( length < 2 | | first _ packet [ 0 ] ! = NUM ) { return false ; } socket . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; handler handler = new handler ( ) ; handler . connection = socket ; server server = config . get _ current _ server ( ) ; handler . encryptor = encryptor _ factory . get _ encryptor ( server . method , server . password ) ; handler . server = server ;
{ <%> <+> if ( socket . protocol _ type ! = protocol _ type . tcp ) { return false ; } </%> try { string request = encoding . ut . get _ string ( first _ packet , 0 , length ) ; string [ ] lines = request . split ( '\r' , '\n' ) ; bool host _ match = false , path _ match = false , use _ socks = false ;
{ <%> <+> if ( socket . protocol _ type ! = protocol _ type . tcp ) { return false ; } </%> new handler ( ) . start ( first _ packet , length , socket , this . target _ port ) ; return true ; } class handler {
void end _ connect _ proxy ( i _ async _ result async _ result ) ; <%> <*> i _ async _ result -> void </%> begin _ connect _ dest ( end _ point remote _ ep , async _ callback callback , object state ) ; void end _ connect _ dest ( i _ async _ result async _ result ) ; <%> <*> i _ async _ result -> void </%> begin _ send ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) ; int end _ send ( i _ async _ result async _ result ) ; <%> <*> i _ async _ result -> void </%> begin _ receive ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) ; int end _ receive ( i _ async _ result async _ result ) ; void shutdown ( socket _ shutdown how ) ;
void end _ connect _ dest ( i _ async _ result async _ result ) ; <%> <*> i _ async _ result -> void </%> begin _ send ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) ; int end _ send ( i _ async _ result async _ result ) ; <%> <*> i _ async _ result -> void </%> begin _ receive ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) ; int end _ receive ( i _ async _ result async _ result ) ; void shutdown ( socket _ shutdown how ) ; void close ( ) ; }
object state ) ; int end _ send ( i _ async _ result async _ result ) ; <%> <*> i _ async _ result -> void </%> begin _ receive ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) ; int end _ receive ( i _ async _ result async _ result ) ; void shutdown ( socket _ shutdown how ) ; void close ( ) ; } }
object state ) ; int end _ receive ( i _ async _ result async _ result ) ; void shutdown ( socket _ shutdown how ) ; void close ( ) ; } }
{ proxy _ end _ point = remote _ ep ; var r = new fake _ async _ result ( state ) ; callback ? . invoke ( r ) ; <%> <-> return r ; </%> } public void end _ connect _ proxy ( i _ async _ result async _ result ) { } public <%> <*> i _ async _ result -> void </%> begin _ connect _ dest ( end _ point remote _ ep , async _ callback callback , object state )
} public void end _ connect _ proxy ( i _ async _ result async _ result ) { } public <%> <*> i _ async _ result -> void </%> begin _ connect _ dest ( end _ point remote _ ep , async _ callback callback , object state ) { if ( remote = = null ) { remote = new socket ( remote _ ep . address _ family , socket _ type . stream , protocol _ type . tcp ) ; remote . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ;
{ if ( remote = = null ) { remote = new socket ( remote _ ep . address _ family , socket _ type . stream , protocol _ type . tcp ) ; remote . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; } dest _ end _ point = remote _ ep ; <%> <-> return </%> remote . begin _ connect ( remote _ ep , callback , state ) ; } public void end _ connect _ dest ( i _ async _ result async _ result )
} public void end _ connect _ dest ( i _ async _ result async _ result ) { remote . end _ connect ( async _ result ) ; } public <%> <*> i _ async _ result -> void </%> begin _ send ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) { <%> <-> return </%> remote . begin _ send ( buffer , offset , size , socket _ flags , callback , state ) ; }
object state ) { <%> <-> return </%> remote . begin _ send ( buffer , offset , size , socket _ flags , callback , state ) ; } public int end _ send ( i _ async _ result async _ result ) { return remote . end _ send ( async _ result ) ; } public <%> <*> i _ async _ result -> void </%> begin _ receive ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state )
} public int end _ send ( i _ async _ result async _ result ) { return remote . end _ send ( async _ result ) ; } public <%> <*> i _ async _ result -> void </%> begin _ receive ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) { <%> <-> return </%> remote . begin _ receive ( buffer , offset , size , socket _ flags , callback , state ) ; }
object state ) { <%> <-> return </%> remote . begin _ receive ( buffer , offset , size , socket _ flags , callback , state ) ; } public int end _ receive ( i _ async _ result async _ result ) { return remote . end _ receive ( async _ result ) ; } public void shutdown ( socket _ shutdown how ) {
} public int end _ receive ( i _ async _ result async _ result ) { return remote . end _ receive ( async _ result ) ; } public void shutdown ( socket _ shutdown how ) { remote ? . shutdown ( how ) ; } public void close ( )
{ kill _ process ( p ) ; } string polipo _ config = resources . privoxy _ conf ; running _ port = this . get _ free _ port ( ) ; polipo _ config = polipo _ config . replace ( STR , configuration . local _ port . to _ string ( ) ) ; polipo _ config = polipo _ config . replace ( STR , running _ port . to _ string ( ) ) ; polipo _ config = polipo _ config . replace ( STR , configuration . share _ over _ lan ? STR : STR ) ; file _ manager . byte _ array _ to _ file ( utils . get _ temp _ path ( <%> <*> STR -> unique _ config _ file </%> ) , encoding . ut . get _ bytes ( polipo _ config ) ) ; process = new process ( ) ;
process = new process ( ) ; process . start _ info . file _ name = STR ; process . start _ info . arguments = <%> <*> STR -> unique _ config _ file </%> ; process . start _ info . working _ directory = utils . get _ temp _ path ( ) ; process . start _ info . window _ style = process _ window _ style . hidden ; process . start _ info . use _ shell _ execute = true ; process . start _ info . create _ no _ window = true ; process . start ( ) ; <%> <+> * add this process to job obj associated with this ss process , so that * when ss exit unexpectedly , this process will be forced killed by system . </%>
process . start _ info . working _ directory = utils . get _ temp _ path ( ) ; process . start _ info . window _ style = process _ window _ style . hidden ; process . start _ info . use _ shell _ execute = true ; process . start _ info . create _ no _ window = true ; process . start ( ) ; <%> <+> * add this process to job obj associated with this ss process , so that * when ss exit unexpectedly , this process will be forced killed by system . * / polipo _ job . add _ process ( process . handle ) ; </%> }
try { directory . create _ directory ( path . combine ( application . startup _ path , STR ) ) ; } catch ( exception e ) { temp _ path = path . get _ temp _ path ( ) ; logging . log _ useful _ exception ( e ) ; } finally
log _ message _ text _ box . scroll _ to _ caret ( ) ; last _ offset = reader . base _ stream . position ; } } private void update _ content ( ) { try { using ( stream _ reader reader = new stream _ reader ( new file _ stream ( filename , file _ mode . open , file _ access . read , file _ share . read _ write ) ) )
} if ( changed ) { <%> <+> log _ message _ text _ box . append _ text ( append _ text . to _ string ( ) ) ; </%> log _ message _ text _ box . scroll _ to _ caret ( ) ; } last _ offset = reader . base _ stream . position ; } } catch ( file _ not _ found _ exception )
public static string get _ temp _ path ( ) { if ( temp _ path = = null ) { <%> <+> bool is _ portable _ mode = configuration . load ( ) . portable _ mode ; </%> try { <%> <*> var temp _ folder = configuration . load ( ) . temp _ folder ; if ( string . is _ null _ or _ white _ space ( temp _ folder ) ) -> if ( is _ portable _ mode ) </%>
<%> <*> temp _ folder = STR ; else if ( common _ env . contains ( temp _ folder , string _ comparer . ordinal _ ignore _ case ) ) temp _ folder + = ( STR + application . executable _ path . get _ hash _ code ( ) ) ; temp _ folder = environment . expand _ environment _ variables ( temp _ folder ) ; var temp _ directory = directory . create _ directory ( path . combine ( application . startup _ path , temp _ folder ) ) ; temp _ path = temp _ directory . full _ name ; file . append _ all _ text ( path . combine ( temp _ path , temp _ log ) , $ STR u STR ) ; -> } </%> <%> <+> else { </%>

configuration . check _ server ( server ) ; configuration . check _ local _ port ( local _ port ) ; modified _ configuration . configs [ last _ selected _ index ] = server ; modified _ configuration . local _ port = local _ port ; <%> <+> modified _ configuration . portable _ mode = portable _ mode _ check _ box . checked ; </%> return true ; } catch ( exception ex ) { message _ box . show ( ex . message ) ;
{ config . configs = servers ; config . local _ port = local _ port ; <%> <*> configuration . save ( config ) ; } public void save _ temp _ folder ( string temp _ folder ) { config . temp _ folder = temp _ folder ; -> config . portable _ mode = portable _ mode ; </%> configuration . save ( config ) ;
configuration . save ( config ) ; } public void save _ strategy _ configurations ( statistics _ strategy _ configuration configuration ) { statistics _ configuration = configuration ; statistics _ strategy _ configuration . save ( configuration ) ; } public bool add _ server _ by _ ssurl ( string ss _ url ) { try
private system . windows . forms . text _ box plugin _ arguments _ text _ box ; private system . windows . forms . label plugin _ arguments _ label ; private system . windows . forms . tool _ tip tool _ tip ; private system . windows . forms . <%> <*> text -> check </%> _ box <%> <*> temp -> portable </%> _ <%> <*> folder -> mode </%> _ <%> <*> text -> check </%> _ box ; } }
} }
} catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; } } private void pipe _ connection _ send _ callback ( i _ async _ result ar ) { <%> <-> if ( closed ) return ; </%>
try { var session = ( async _ session ) ar . async _ state ; connection <%> <-> ? </%> . end _ send ( ar ) ; session . remote . begin _ receive ( remote _ recv _ buffer , 0 , recv _ size , socket _ flags . none , new async _ callback ( pipe _ remote _ receive _ callback ) , session ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ;
session . remote . begin _ receive ( remote _ recv _ buffer , 0 , recv _ size , socket _ flags . none , new async _ callback ( pipe _ remote _ receive _ callback ) , session ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; } } } }
this . client _ size = new system . drawing . size ( NUM , NUM ) ; this . control _ box = false ; <%> <+> this . controls . add ( this . panel ) ; </%>
screen . primary _ screen . bounds . height ) ) { using ( graphics g = graphics . from _ image ( <%> <+> full _ </%> image ) ) { g . copy _ from _ screen ( screen . primary _ screen . bounds . x , screen . primary _ screen . bounds . y , 0 , 0 , <%> <+> full _ </%> image . size , copy _ pixel _ operation . source _ copy ) ; }
{ g . copy _ from _ screen ( screen . primary _ screen . bounds . x , screen . primary _ screen . bounds . y , 0 , 0 , <%> <+> full _ </%> image . size , copy _ pixel _ operation . source _ copy ) ; } <%> <*> var reader -> for ( int i </%> = <%> <*> new barcode _ reader -> 0 ; i < NUM ; i + + ) </%> { <%> <-> try _ harder = true , </%>
copy _ pixel _ operation . source _ copy ) ; } <%> <*> var reader -> for ( int i </%> = <%> <*> new barcode _ reader -> 0 ; i < NUM ; i + + ) </%> { <%> <*> try _ harder = true , possible _ formats = new list < barcode _ format > -> int margin _ left = full _ image . width * i / NUM / NUM ; </%> <%> <+> int margin _ top = full _ image . height * i / NUM / NUM ; rectangle crop _ rect = new rectangle ( margin _ left , margin _ top , full _ image . width - margin _ left * 2 , full _ image . height - margin _ top * 2 ) ; bitmap target = new bitmap ( crop _ rect . width , crop _ rect . height ) ; </%>
{ <%> <*> try _ harder = true , possible _ formats = new list < barcode _ format > -> int margin _ left = full _ image . width * i / NUM / NUM ; </%> <%> <+> int margin _ top = full _ image . height * i / NUM / NUM ; rectangle crop _ rect = new rectangle ( margin _ left , margin _ top , full _ image . width - margin _ left * 2 , full _ image . height - margin _ top * 2 ) ; bitmap target = new bitmap ( crop _ rect . width , crop _ rect . height ) ; using ( graphics g = graphics . from _ image ( target ) ) </%> { <%> <-> barcode _ format . qr _ code </%>
{ <%> <*> barcode _ format . qr _ code -> g . draw _ image ( full _ image , new rectangle ( 0 , 0 , target . width , target . height ) , </%> <%> <+> crop _ rect , graphics _ unit . pixel ) ; </%> } <%> <-> } ; var result = reader . decode ( image ) ; if ( result ! = null ) { </%>
} <%> <*> } ; var result = reader . decode ( image ) ; if ( result ! = null ) { var success = controller . add _ server _ by _ ssurl ( result . text ) ; if ( success ) -> var reader = new barcode _ reader </%> { <%> <+> try _ harder = true , </%>
{ <%> <+> try _ harder = true , possible _ formats = new list < barcode _ format > { barcode _ format . qr _ code } } ; var result = reader . decode ( target ) ; if ( result ! = null ) { </%>
splash . location = new point ( ( int ) min _ x , ( int ) min _ y ) ; <%> <*> splash . size = new size ( ( int ) max _ x - ( int ) min _ x , ( int ) max _ y - ( int ) min _ y ) ; -> splash . panel . size = new size ( ( int ) max _ x - ( int ) min _ x , ( int ) max _ y - ( int ) min _ y ) ; </%> <%> <+> splash . size = splash . panel . size ; </%> splash . show ( ) ; return ; } } <%> <-> message _ box . show ( n . get _ string ( STR ) ) ; </%> <%> <*> } -> } </%> <%> <+> message _ box . show ( n . get _ string ( STR ) ) ; </%>
splash . show ( ) ; return ; } } <%> <-> message _ box . show ( n . get _ string ( STR ) ) ; </%> <%> <*> } -> } </%> <%> <+> message _ box . show ( n . get _ string ( STR ) ) ; </%> } void splash _ form _ closed ( object sender , form _ closed _ event _ args e ) { show _ config _ form ( ) ;
} void splash _ form _ closed ( object sender , form _ closed _ event _ args e ) { show _ config _ form ( ) ; <%> <+> } void open _ url _ from _ qr _ code ( object sender , form _ closed _ event _ args e ) { process . start ( url _ to _ open ) ; </%> } private void auto _ startup _ item _ click ( object sender , event _ args e ) {
private hotkey _ config modified _ config ; <%> <*> private string _ builder sb = new string _ builder ( ) ; private i _ enumerable < text _ box > all _ text _ boxes ; private label lb = null ; private hot _ keys . hot _ key _ call _ back _ handler call _ back = null ; -> private readonly i _ enumerable < text _ box > all _ text _ boxes ; </%> public hotkey _ settings _ form ( shadowsocks _ controller controller ) { initialize _ component ( ) ; update _ texts ( ) ;
public hotkey _ settings _ form ( shadowsocks _ controller controller ) { initialize _ component ( ) ; update _ texts ( ) ; <%> <-> this . </%> icon = icon . from _ handle ( resources . ssw . get _ hicon ( ) ) ; controller = controller ; controller . config _ changed + = controller _ config _ changed ; load _ current _ configuration ( ) ; all _ text _ boxes = <%> <*> hot -> table _ layout </%> _ <%> <*> keys -> panel </%> . get _ child _ controls < text _ box > ( <%> <-> this . table _ layout _ panel </%> ) ; if ( ! all _ text _ boxes . any ( ) ) throw new exception ( STR ) ;
controller = controller ; controller . config _ changed + = controller _ config _ changed ; load _ current _ configuration ( ) ; all _ text _ boxes = <%> <*> hot -> table _ layout </%> _ <%> <*> keys -> panel </%> . get _ child _ controls < text _ box > ( <%> <-> this . table _ layout _ panel </%> ) ; if ( ! all _ text _ boxes . any ( ) ) throw new exception ( STR ) ; } private void controller _ config _ changed ( object sender , event _ args e ) { load _ current _ configuration ( ) ; }
if ( ! all _ text _ boxes . any ( ) ) throw new exception ( STR ) ; } private void controller _ config _ changed ( object sender , event _ args e ) { load _ current _ configuration ( ) ; } private void load _ current _ configuration ( ) { modified _ config = controller . get _ configuration _ copy ( ) . hotkey ; load _ configuration ( modified _ config ) ;
} private void hotkey _ down ( object sender , key _ event _ args e ) { <%> <+> string _ builder </%> sb <%> <-> . length </%> = <%> <*> 0 -> new string _ builder ( ) </%> ; if ( e . modifiers ! = 0 ) { if ( e . control ) { sb . append ( STR ) ; }
if ( e . modifiers ! = 0 ) { if ( e . control ) { sb . append ( STR ) ; } if ( e . alt ) { sb . append ( STR ) ; }
if ( content . length > = 1 & & content [ content . length - 1 ] = = '+' ) { tb . text = STR ; } } private void text _ box _ text _ changed ( object sender , event _ args e ) { <%> <*> text _ box -> var </%> tb = <%> <*> sender as -> ( </%> text _ box <%> <+> ) sender </%> ; if ( tb . text = = STR ) {
if ( tb . text = = STR ) { unreg _ hotkey ( tb ) ; } } private void unreg _ hotkey ( text _ box tb ) { <%> <+> hot _ keys . hot _ key _ call _ back _ handler call _ back ; label lb ; </%> prepare _ for _ hotkey ( tb , out call _ back , out lb ) ;
} private void cancel _ button _ click ( object sender , event _ args e ) { <%> <-> this . </%> close ( ) ; } private void ok _ button _ click ( object sender , event _ args e ) { foreach ( var tb in all _ text _ boxes ) { if ( tb . text . is _ null _ or _ empty ( ) )
} private void ok _ button _ click ( object sender , event _ args e ) { foreach ( var tb in all _ text _ boxes ) { if ( tb . text . is _ null _ or _ empty ( ) ) { continue ; } if ( ! try _ reg _ hotkey ( tb ) )
logging . info ( STR ) ; } logging . info ( STR ) ; break ; } } private static void timer _ elapsed ( object sender , system . timers . elapsed _ event _ args e ) { try {
logging . info ( STR ) ; } } catch ( exception ex ) { logging . log _ useful _ exception ( ex ) ; } finally { try
} } } }
} catch ( io _ exception ) { } catch ( exception e ) { console . write _ line ( e . to _ string ( ) ) ; } <%> <+> load _ library ( dll _ path ) ; </%> }
logging . info ( $ STR ) ; proxy . close ( ) ; retry _ connect ( ) ; } private void proxy _ connect _ callback ( i _ async _ result ar ) { server server = null ; if ( closed ) { return ;
i _ strategy strategy = controller . get _ current _ strategy ( ) ; strategy ? . set _ failure ( server ) ; logging . info ( $ STR ) ; session . remote . close ( ) ; retry _ connect ( ) ; } private void retry _ connect ( ) { if ( retry _ count < max _ retry ) {
{ <%> <*> public async _ callback callback { get ; } public socket _ async _ event _ args args { get ; } -> public bool is _ completed { get ; } = true ; </%> <%> <+> public wait _ handle async _ wait _ handle { get ; } = null ; public object async _ state { get ; set ; } public bool completed _ synchronously { get ; } = true ; public tcp _ user _ token user _ token { get ; set ; } ~ auto _ release _ async _ result ( ) { </%>
public tcp _ user _ token ( async _ callback callback , object state , socket _ async _ event _ args args ) { callback = callback ; async _ state = state ; args = args ; } <%> <-> public bool is _ completed { get ; } = true ; public wait _ handle async _ wait _ handle { get ; } = null ; public object async _ state { get ; } public bool completed _ synchronously { get ; } = true ; </%>
} private static void on _ tcp _ connect _ completed ( object sender , socket _ async _ event _ args args ) { <%> <+> args . completed - = on _ tcp _ connect _ completed ; </%> tcp _ user _ token token = ( tcp _ user _ token ) args . user _ token ; <%> <*> token . callback ( token ) ; -> auto _ release _ async _ result r = new auto _ release _ async _ result </%> <%> <+> { async _ state = token . async _ state , user _ token = token </%>
} public static void begin _ connect _ tcp ( end _ point end _ point , async _ callback callback , object state ) { var arg = new socket _ async _ event _ args ( ) ; arg . remote _ end _ point = end _ point ; arg . completed + = on _ tcp _ connect _ completed ; arg . user _ token = new tcp _ user _ token ( callback , state , arg ) ; socket . connect _ async ( socket _ type . stream , protocol _ type . tcp , arg ) ; } public static socket end _ connect _ tcp ( i _ async _ result async _ result )
{ throw new argument _ exception ( STR , nameof ( async _ result ) ) ; } <%> <+> var tut = r . user _ token ; </%> var arg = tut . args ; if ( arg . socket _ error ! = socket _ error . success ) { if ( arg . connect _ by _ name _ error ! = null ) { throw arg . connect _ by _ name _ error ;
this . panel = new system . windows . forms . panel ( ) ; this . ok _ button = new system . windows . forms . button ( ) ; this . my _ cancel _ button = new system . windows . forms . button ( ) ; this . panel = new system . windows . forms . panel ( ) ; <%> <-> this . context _ menu = new system . windows . forms . context _ menu ( ) ; this . enable _ item = new system . windows . forms . menu _ item ( ) ; this . auto _ startup _ item = new system . windows . forms . menu _ item ( ) ; this . share _ over _ lan _ item = new system . windows . forms . menu _ item ( ) ; this . servers _ item = new system . windows . forms . menu _ item ( ) ; this . seperator _ item = new system . windows . forms . menu _ item ( ) ; </%>
this . panel = new system . windows . forms . panel ( ) ; this . delete _ button = new system . windows . forms . button ( ) ; this . add _ button = new system . windows . forms . button ( ) ; this . server _ group _ box = new system . windows . forms . group _ box ( ) ; this . servers _ list _ box = new system . windows . forms . list _ box ( ) ; <%> <-> this . menu _ item = new system . windows . forms . menu _ item ( ) ; </%> this . table _ layout _ panel . suspend _ layout ( ) ; this . panel . suspend _ layout ( ) ; this . panel . suspend _ layout ( ) ; this . server _ group _ box . suspend _ layout ( ) ;
this . table _ layout _ panel . suspend _ layout ( ) ; this . panel . suspend _ layout ( ) ; this . panel . suspend _ layout ( ) ; this . server _ group _ box . suspend _ layout ( ) ; this . suspend _ layout ( ) ; this . table _ layout _ panel . auto _ size = true ; this . table _ layout _ panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . table _ layout _ panel . column _ count = 2 ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ;
this . table _ layout _ panel . name = STR ; this . table _ layout _ panel . padding = new system . windows . forms . padding ( <%> <-> NUM , NUM , NUM , </%> NUM ) ; this . table _ layout _ panel . row _ count = NUM ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ;
this . table _ layout _ panel . row _ count = NUM ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ; this . table _ layout _ panel . tab _ index = 0 ; this . remarks _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ;
private system . windows . forms . label label ; private system . windows . forms . combo _ box encryption _ select ; private system . windows . forms . panel panel ; private system . windows . forms . button ok _ button ; private system . windows . forms . button my _ cancel _ button ; private system . windows . forms . panel panel ; <%> <-> private system . windows . forms . context _ menu context _ menu ; private system . windows . forms . menu _ item enable _ item ; private system . windows . forms . menu _ item about _ item ; private system . windows . forms . menu _ item menu _ item ; </%>
private system . windows . forms . panel panel ; private system . windows . forms . button delete _ button ; private system . windows . forms . button add _ button ; private system . windows . forms . group _ box server _ group _ box ; private system . windows . forms . list _ box servers _ list _ box ; <%> <-> private system . windows . forms . menu _ item servers _ item ; private system . windows . forms . menu _ item seperator _ item ; private system . windows . forms . menu _ item menu _ item ; </%> private system . windows . forms . text _ box remarks _ text _ box ; private system . windows . forms . label label ;
private system . windows . forms . text _ box remarks _ text _ box ; private system . windows . forms . label label ; <%> <-> private system . windows . forms . menu _ item qr _ code _ item ; private system . windows . forms . menu _ item show _ log _ item ; private system . windows . forms . menu _ item share _ over _ lan _ item ; private system . windows . forms . menu _ item auto _ startup _ item ; private system . windows . forms . menu _ item menu _ item ; </%> } }
} }
this . controller = controller ; <%> <-> controller . enable _ status _ changed + = controller _ enable _ status _ changed ; </%> controller . config _ changed + = controller _ config _ changed ; <%> <-> controller . pac _ file _ ready _ to _ open + = controller _ pac _ file _ ready _ to _ open ; controller . share _ over _ lan _ status _ changed + = controller _ share _ over _ lan _ status _ changed ; this . update _ checker = new update _ checker ( ) ; update _ checker . new _ version _ found + = update _ checker _ new _ version _ found ; </%> load _ current _ configuration ( ) ; <%> <-> } private void load _ tray _ icon ( ) </%>
controller . config _ changed + = controller _ config _ changed ; <%> <-> controller . pac _ file _ ready _ to _ open + = controller _ pac _ file _ ready _ to _ open ; controller . share _ over _ lan _ status _ changed + = controller _ share _ over _ lan _ status _ changed ; this . update _ checker = new update _ checker ( ) ; update _ checker . new _ version _ found + = update _ checker _ new _ version _ found ; </%> load _ current _ configuration ( ) ; <%> <-> } private void load _ tray _ icon ( ) { int dpi ; </%>
load _ current _ configuration ( ) ; <%> <-> } private void load _ tray _ icon ( ) { int dpi ; graphics graphics = this . create _ graphics ( ) ; dpi = ( int ) graphics . dpi _ x ; graphics . dispose ( ) ; bitmap icon = null ; if ( dpi < NUM ) </%>
} private void controller _ config _ changed ( object sender , event _ args e ) { load _ current _ configuration ( ) ; <%> <-> } private void controller _ enable _ status _ changed ( object sender , event _ args e ) { enable _ item . checked = controller . get _ configuration ( ) . enabled ; } void controller _ share _ over _ lan _ status _ changed ( object sender , event _ args e ) </%>
} void notify _ icon _ balloon _ tip _ clicked ( object sender , event _ args e ) { process . start ( update _ checker . latest _ version _ url ) ; } private void show _ window ( ) { this . opacity = 1 ; this . show ( ) ; ip _ text _ box . focus ( ) ;
} private void config _ form _ load ( object sender , event _ args e ) { <%> <-> if ( ! controller . get _ configuration ( ) . is _ default ) { this . opacity = 0 ; begin _ invoke ( new method _ invoker ( delegate { this . hide ( ) ; } ) ) ; </%>
} private void servers _ list _ box _ selected _ index _ changed ( object sender , event _ args e ) { if ( old _ selected _ index = = servers _ list _ box . selected _ index ) { return ; } if ( ! save _ old _ selected _ server ( ) ) { servers _ list _ box . selected _ index = old _ selected _ index ;
} private void cancel _ button _ click ( object sender , event _ args e ) { <%> <-> this . hide ( ) ; load _ current _ configuration ( ) ; show _ first _ time _ balloon ( ) ; } private void config _ form _ form _ closed ( object sender , form _ closed _ event _ args e ) { controller . stop ( ) ; </%>
} private void config _ form _ shown ( object sender , event _ args e ) { ip _ text _ box . focus ( ) ; } private void <%> <*> qr -> config </%> _ <%> <*> code -> form </%> _ <%> <*> item -> form </%> _ <%> <*> click -> closed </%> ( object sender , <%> <+> form _ closed _ </%> event _ args e ) { <%> <-> qr _ code _ form qr _ code _ form = new qr _ code _ form ( controller . get _ qr _ code _ for _ current _ server ( ) ) ; qr _ code _ form . icon = this . icon ; qr _ code _ form . show ( ) ; </%>
{ <%> <*> qr _ code _ form qr _ code _ form = new qr _ code _ form ( controller . get _ qr _ code _ for _ current _ server ( ) ) ; qr _ code _ form . icon = this . icon ; qr _ code _ form . show ( ) ; -> controller . config _ changed - = controller _ config _ changed ; </%> } <%> <-> private void auto _ startup _ item _ click ( object sender , event _ args e ) { auto _ startup _ item . checked = ! auto _ startup _ item . checked ; if ( ! auto _ startup . set ( auto _ startup _ item . checked ) ) { message _ box . show ( STR ) ; </%>
} <%> <-> private void auto _ startup _ item _ click ( object sender , event _ args e ) { auto _ startup _ item . checked = ! auto _ startup _ item . checked ; if ( ! auto _ startup . set ( auto _ startup _ item . checked ) ) { message _ box . show ( STR ) ; } } </%> } }
} }
socket conn = listener . end _ accept ( ar ) ; conn . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; <%> <-> listener . begin _ accept ( new async _ callback ( accept _ callback ) , listener ) ; </%> handler handler = new handler ( ) ; handler . connection = conn ; handler . encryptor = encryptor _ factory . get _ encryptor ( server . method , server . password ) ; handler . config = server ; handler . start ( ) ;
handler handler = new handler ( ) ; handler . connection = conn ; handler . encryptor = encryptor _ factory . get _ encryptor ( server . method , server . password ) ; handler . config = server ; handler . start ( ) ; } catch { <%> <+> } finally </%>
socket conn = listener . end _ accept ( ar ) ; <%> <-> listener . begin _ accept ( new async _ callback ( accept _ callback ) , listener ) ; </%> byte [ ] buf = new byte [ NUM ] ; object [ ] state = new object [ ] { conn , buf } ; conn . begin _ receive ( buf , 0 , NUM , 0 ,
byte [ ] buf = new byte [ NUM ] ; object [ ] state = new object [ ] { conn , buf } ; conn . begin _ receive ( buf , 0 , NUM , 0 , new async _ callback ( receive _ callback ) , state ) ; } catch ( object _ disposed _ exception ) {
this . delete _ button = new system . windows . forms . button ( ) ; this . add _ button = new system . windows . forms . button ( ) ; this . server _ group _ box = new system . windows . forms . group _ box ( ) ; this . servers _ list _ box = new system . windows . forms . list _ box ( ) ; <%> <+> this . table _ layout _ panel = new system . windows . forms . table _ layout _ panel ( ) ; this . table _ layout _ panel = new system . windows . forms . table _ layout _ panel ( ) ; this . table _ layout _ panel = new system . windows . forms . table _ layout _ panel ( ) ; </%> this . table _ layout _ panel . suspend _ layout ( ) ; <%> <-> this . panel . suspend _ layout ( ) ; this . panel . suspend _ layout ( ) ; </%>
this . server _ group _ box . suspend _ layout ( ) ; <%> <+> this . table _ layout _ panel . suspend _ layout ( ) ; this . table _ layout _ panel . suspend _ layout ( ) ; this . table _ layout _ panel . suspend _ layout ( ) ; </%> this . suspend _ layout ( ) ; this . table _ layout _ panel . auto _ size = true ; this . table _ layout _ panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . table _ layout _ panel . column _ count = 2 ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ;
this . ok _ button . name = STR ; this . ok _ button . size = new system . drawing . size ( NUM , NUM ) ; this . ok _ button . tab _ index = NUM ; this . ok _ button . text = STR ; this . ok _ button . use _ visual _ style _ back _ color = true ; this . ok _ button . click + = new system . event _ handler ( this . ok _ button _ click ) ; this . my _ cancel _ button . dialog _ result = system . windows . forms . dialog _ result . cancel ; <%> <+> this . my _ cancel _ button . dock = system . windows . forms . dock _ style . right ; </%> this . my _ cancel _ button . location = new system . drawing . point ( NUM , NUM ) ; <%> <+> this . my _ cancel _ button . margin = new system . windows . forms . padding ( NUM , NUM , 0 , 0 ) ; </%>
this . my _ cancel _ button . name = STR ; this . my _ cancel _ button . size = new system . drawing . size ( NUM , NUM ) ; this . my _ cancel _ button . tab _ index = NUM ; this . my _ cancel _ button . text = STR ; this . my _ cancel _ button . use _ visual _ style _ back _ color = true ; this . my _ cancel _ button . click + = new system . event _ handler ( this . cancel _ button _ click ) ; <%> <-> this . panel . auto _ size = true ; this . panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . panel . controls . add ( this . my _ cancel _ button ) ; this . panel . controls . add ( this . ok _ button ) ; </%>
<%> <+> this . delete _ button . dock = system . windows . forms . dock _ style . right ; </%> this . delete _ button . location = new system . drawing . point ( NUM , NUM ) ; <%> <+> this . delete _ button . margin = new system . windows . forms . padding ( NUM , NUM , 0 , NUM ) ; </%> this . delete _ button . name = STR ; this . delete _ button . size = new system . drawing . size ( NUM , NUM ) ; this . delete _ button . tab _ index = NUM ; this . delete _ button . text = STR ; this . delete _ button . use _ visual _ style _ back _ color = true ; this . delete _ button . click + = new system . event _ handler ( this . delete _ button _ click ) ; <%> <-> this . add _ button . location = new system . drawing . point ( NUM , NUM ) ; </%>
this . delete _ button . name = STR ; this . delete _ button . size = new system . drawing . size ( NUM , NUM ) ; this . delete _ button . tab _ index = NUM ; this . delete _ button . text = STR ; this . delete _ button . use _ visual _ style _ back _ color = true ; this . delete _ button . click + = new system . event _ handler ( this . delete _ button _ click ) ; <%> <*> this . add _ button . location = new system . drawing . point ( NUM , NUM ) ; -> this . add _ button . dock = system . windows . forms . dock _ style . left ; </%> <%> <+> this . add _ button . location = new system . drawing . point ( 0 , NUM ) ; this . add _ button . margin = new system . windows . forms . padding ( 0 , NUM , NUM , NUM ) ; </%>
this . add _ button . name = STR ; this . add _ button . size = new system . drawing . size ( NUM , NUM ) ; this . add _ button . tab _ index = NUM ; this . add _ button . text = STR ; this . add _ button . use _ visual _ style _ back _ color = true ; this . add _ button . click + = new system . event _ handler ( this . add _ button _ click ) ; <%> <+> this . server _ group _ box . auto _ size = true ; this . server _ group _ box . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; </%> this . server _ group _ box . controls . add ( this . table _ layout _ panel ) ; <%> <-> this . server _ group _ box . location = new system . drawing . point ( NUM , NUM ) ; </%>
this . server _ group _ box . name = STR ; this . server _ group _ box . size = new system . drawing . size ( NUM , NUM ) ; this . server _ group _ box . tab _ index = NUM ; this . server _ group _ box . tab _ stop = false ; this . server _ group _ box . text = STR ; this . servers _ list _ box . formatting _ enabled = true ; <%> <*> this . servers _ list _ box . location = new system . drawing . point ( NUM , NUM ) ; -> this . servers _ list _ box . integral _ height = false ; </%> <%> <+> this . servers _ list _ box . location = new system . drawing . point ( 0 , 0 ) ; this . servers _ list _ box . margin = new system . windows . forms . padding ( 0 ) ; </%>
this . servers _ list _ box . name = STR ; this . servers _ list _ box . size = new system . drawing . size ( NUM , NUM ) ; this . servers _ list _ box . tab _ index = NUM ; this . servers _ list _ box . selected _ index _ changed + = new system . event _ handler ( this . servers _ list _ box _ selected _ index _ changed ) ; this . accept _ button = this . ok _ button ; <%> <+> this . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; </%> this . cancel _ button = this . my _ cancel _ button ; this . client _ size = new system . drawing . size ( NUM , NUM ) ; this . controls . add ( this . <%> <*> servers -> table </%> _ <%> <*> list -> layout </%> _ <%> <*> box -> panel </%> ) ; <%> <-> this . controls . add ( this . server _ group _ box ) ; </%>
this . controls . add ( this . panel ) ; this . form _ border _ style = system . windows . forms . form _ border _ style . fixed _ single ; this . maximize _ box = false ; this . minimize _ box = false ; this . name = STR ; <%> <+> this . padding = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; </%> this . start _ position = system . windows . forms . form _ start _ position . center _ screen ; this . text = STR ; this . form _ closed + = new system . windows . forms . form _ closed _ event _ handler ( this . config _ form _ form _ closed ) ; this . load + = new system . event _ handler ( this . config _ form _ load ) ;
this . server _ group _ box . resume _ layout ( false ) ; this . server _ group _ box . perform _ layout ( ) ; <%> <+> this . table _ layout _ panel . resume _ layout ( false ) ; this . table _ layout _ panel . perform _ layout ( ) ; this . table _ layout _ panel . resume _ layout ( false ) ; this . table _ layout _ panel . resume _ layout ( false ) ; </%> this . resume _ layout ( false ) ; this . perform _ layout ( ) ; } private system . windows . forms . table _ layout _ panel table _ layout _ panel ;
private system . windows . forms . button delete _ button ; private system . windows . forms . button add _ button ; private system . windows . forms . group _ box server _ group _ box ; private system . windows . forms . list _ box servers _ list _ box ; private system . windows . forms . text _ box remarks _ text _ box ; private system . windows . forms . label remarks _ label ; <%> <+> private system . windows . forms . table _ layout _ panel table _ layout _ panel ; private system . windows . forms . table _ layout _ panel table _ layout _ panel ; private system . windows . forms . table _ layout _ panel table _ layout _ panel ; </%> }
using system _ net _ sockets ; using system _ text ; <%> <*> using system _ threading _ tasks ; -> using system _ text _ regular _ expressions ; </%> <%> <+> using shadowsocks _ forward _ proxy ; </%> using shadowsocks _ util _ sockets ; namespace shadowsocks _ controller _ service { class http _ socks : listener . service {
using shadowsocks _ util _ sockets ; namespace shadowsocks _ controller _ service { class http _ socks : listener . service { <%> <+> private readonly byte _ search . search _ target connect _ search = new byte _ search . search _ target ( encoding . ut . get _ bytes ( STR ) ) ; private readonly int socks _ port ; public http _ socks ( int socks _ port ) { </%>
registry . set _ value ( STR , pac _ url ) ; } } else { registry . set _ value ( STR , 0 ) ; <%> <+> if ( global ) { </%> registry . set _ value ( STR , STR ) ; <%> <+> } </%>
registry . set _ value ( STR , STR ) ; } <%> <+> ie _ auto _ detect _ proxy ( false ) ; </%> system _ proxy . notify _ ie ( ) ; copy _ proxy _ setting _ from _ lan ( ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; message _ box . show ( n . get _ string ( STR ) ) ;
using system _ collections _ generic ; using system _ text ; namespace shadowsocks _ csharp <%> <+> _ controller </%> { public class shadowsocks _ controller { private local local ; private pac _ server pac _ server ; private config config ; private polipo _ runner polipo _ runner ;
{ public class shadowsocks _ controller { private local local ; private pac _ server pac _ server ; private config config ; private polipo _ runner polipo _ runner ; private bool stopped = false ; <%> <+> public class path _ event _ args : event _ args { </%>
using system ; using system _ collections _ generic ; using system _ diagnostics ; using system _ io ; using system _ i _ compression ; using system _ text ; namespace shadowsocks _ csharp <%> <+> _ controller </%> { class polipo _ runner {
{ class polipo _ runner { private process process ; <%> <-> private bool byte _ array _ to _ file ( string file _ name , byte [ ] content ) { try { system . io . file _ stream file _ stream = new system . io . file _ stream ( file _ name , system . io . file _ mode . create , </%>
public void start ( config config ) { if ( process = = null ) { process [ ] existing _ polipo = process . get _ processes _ by _ name ( STR ) ; foreach ( process p in existing _ polipo ) { p . kill ( ) ; p . wait _ for _ exit ( ) ; }
{ <%> <+> public </%> class system _ proxy { dll _ import _ wininet _ dll public static extern bool internet _ set _ option ( int _ ptr h _ internet , int dw _ option , int _ ptr lp _ buffer , int dw _ buffer _ length ) ; public const int internet _ option _ settings _ changed = NUM ; public const int internet _ option _ refresh = NUM ; static bool settings _ return , refresh _ return ; public static void notify _ ie ( ) {
{ dll _ import _ wininet _ dll public static extern bool internet _ set _ option ( int _ ptr h _ internet , int dw _ option , int _ ptr lp _ buffer , int dw _ buffer _ length ) ; public const int internet _ option _ settings _ changed = NUM ; public const int internet _ option _ refresh = NUM ; static bool settings _ return , refresh _ return ; public static void notify _ ie ( ) { settings _ return = internet _ set _ option ( int _ ptr . zero , internet _ option _ settings _ changed , int _ ptr . zero , 0 ) ; refresh _ return = internet _ set _ option ( int _ ptr . zero , internet _ option _ refresh , int _ ptr . zero , 0 ) ;
} } else if ( e is object _ disposed _ exception ) { } else { <%> <*> console . write _ line -> info </%> ( e ) ; } }
} } } public class stream _ writer _ with _ timestamp : stream _ writer { public stream _ writer _ with _ timestamp ( stream stream ) : base ( stream ) { } private string get _ timestamp ( ) {
{ bool handle ( byte [ ] first _ packet , int length , socket socket , object state ) ; <%> <+> void stop ( ) ; } public abstract class service : i _ service { public abstract bool handle ( byte [ ] first _ packet , int length , socket socket , object state ) ; public virtual void stop ( ) { } </%> } public class udp _ state
{ if ( service . handle ( state . buffer , bytes _ read , udp _ socket , state ) ) { break ; } } } catch ( object _ disposed _ exception ) { }
{ register _ application _ restart ( null , ( int ) application _ restart _ flags . restart _ no _ crash | ( int ) application _ restart _ flags . restart _ no _ hang ) ; logging . debug ( STR ) ; } else if ( ! <%> <*> regist -> register </%> ) { unregister _ application _ restart ( ) ; logging . debug ( STR ) ; } }
{ web _ client http = new web _ client ( ) ; http . proxy = new web _ proxy ( ip _ address . loopback . to _ string ( ) , <%> <*> NUM -> config . local _ port </%> ) ; http . download _ string _ completed + = http _ download _ string _ completed ; http . download _ string _ async ( new uri ( update _ url ) ) ; } public static int compare _ version ( string l , string r ) { var ls = l . split ( '.' ) ; var rs = r . split ( '.' ) ;
http . download _ string _ completed + = http _ download _ string _ completed ; http . download _ string _ async ( new uri ( update _ url ) ) ; } public static int compare _ version ( string l , string r ) { var ls = l . split ( '.' ) ; var rs = r . split ( '.' ) ; for ( int i = 0 ; i < math . max ( ls . length , rs . length ) ; i + + ) { int lp = ( i < ls . length ) ? int . parse ( ls [ i ] ) : 0 ;
this . table _ layout _ panel . controls . add ( this . toolbar _ flow _ layout _ panel , 0 , 0 ) ; <%> <+> this . table _ layout _ panel . controls . add ( this . split _ container , 0 , 1 ) ; </%> this . table _ layout _ panel . dock = system . windows . forms . dock _ style . fill ; this . table _ layout _ panel . location = new system . drawing . point ( 0 , 0 ) ; this . table _ layout _ panel . name = STR ; this . table _ layout _ panel . row _ count = 2 ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ; this . table _ layout _ panel . tab _ index = 2 ;
} dll _ import _ kernel _ dll return _ marshal _ as _ unmanaged _ type _ bool private static extern bool set _ process _ working _ set _ size ( int _ ptr process , u _ int _ ptr minimum _ working _ set _ size , u _ int _ ptr maximum _ working _ set _ size ) ; } }
if ( dpi < NUM ) { icon <%> <+> _ base _ bitmap </%> = resources . ss ; } else if ( dpi < NUM ) { icon <%> <+> _ base _ bitmap </%> = resources . ss ; } else {
} else if ( dpi < NUM ) { icon <%> <+> _ base _ bitmap </%> = resources . ss ; } else { icon <%> <+> _ base _ bitmap </%> = resources . ss ; } configuration config = controller . get _ configuration _ copy ( ) ;
} else { icon <%> <+> _ base _ bitmap </%> = resources . ss ; } configuration config = controller . get _ configuration _ copy ( ) ; bool enabled = config . enabled ; bool global = config . global ; <%> <-> icon = get _ tray _ icon _ by _ state ( icon , enabled , global ) ; notify _ icon . icon = icon . from _ handle ( icon . get _ hicon ( ) ) ; </%>
} configuration config = controller . get _ configuration _ copy ( ) ; bool enabled = config . enabled ; bool global = config . global ; <%> <*> icon = get _ tray _ icon _ by _ state ( icon , enabled , global ) ; notify _ icon . icon = icon . from _ handle ( icon . get _ hicon ( ) ) ; -> icon _ base _ bitmap = get _ tray _ icon _ by _ state ( icon _ base _ bitmap , enabled , global ) ; </%> <%> <+> icon _ base = icon . from _ handle ( icon _ base _ bitmap . get _ hicon ( ) ) ; target _ icon = icon _ base ; icon _ in = icon . from _ handle ( add _ bitmap _ overlay ( icon _ base _ bitmap , resources . ss _ in ) . get _ hicon ( ) ) ; </%>

{ <%> <-> g . copy _ from _ screen ( screen . primary _ screen . bounds . x , screen . primary _ screen . bounds . y , 0 , 0 , full _ image . size , copy _ pixel _ operation . source _ copy ) ; } for ( int i = 0 ; i < NUM ; i + + ) { int margin _ left = full _ image . width * i / NUM / NUM ; </%>
{ <%> <*> g . draw _ image ( full _ image , new rectangle ( 0 , 0 , target . width , target . height ) , crop _ rect , graphics _ unit . pixel ) ; -> g . copy _ from _ screen ( screen . bounds . x , </%> <%> <+> screen . bounds . y , 0 , 0 , full _ image . size , copy _ pixel _ operation . source _ copy ) ; </%> }
} <%> <*> var source = new bitmap _ luminance _ source ( target ) ; var bitmap = new binary _ bitmap ( new hybrid _ binarizer ( source ) ) ; qr _ code _ reader reader = new qr _ code _ reader ( ) ; var result = reader . decode ( bitmap ) ; if ( result ! = null ) -> int max _ try = NUM ; </%> <%> <+> for ( int i = 0 ; i < max _ try ; i + + ) </%> { <%> <-> var success = controller . add _ server _ by _ ssurl ( result . text ) ; </%>
{ <%> <*> var success = controller . add _ server _ by _ ssurl ( result . text ) ; qr _ code _ splash _ form splash = new qr _ code _ splash _ form ( ) ; if ( success ) -> int margin _ left = full _ image . width * i / NUM / max _ try ; </%> <%> <+> int margin _ top = full _ image . height * i / NUM / max _ try ; rectangle crop _ rect = new rectangle ( margin _ left , margin _ top , full _ image . width - margin _ left * 2 , full _ image . height - margin _ top * 2 ) ; bitmap target = new bitmap ( crop _ rect . width , crop _ rect . height ) ; using ( graphics g = graphics . from _ image ( target ) ) </%> {
{ <%> <*> splash . form _ closed + = splash _ form _ closed ; -> g . draw _ image ( full _ image , new rectangle ( 0 , 0 , target . width , target . height ) , </%> <%> <+> crop _ rect , graphics _ unit . pixel ) ; </%> } <%> <*> else if ( result . text . starts _ with ( STR ) | | result . text . starts _ with ( STR ) ) -> var source = new bitmap _ luminance _ source ( target ) ; </%> <%> <+> var bitmap = new binary _ bitmap ( new hybrid _ binarizer ( source ) ) ; qr _ code _ reader reader = new qr _ code _ reader ( ) ; </%>
} <%> <*> else if ( result . text . starts _ with ( STR ) | | result . text . starts _ with ( STR ) ) -> var source = new bitmap _ luminance _ source ( target ) ; </%> <%> <+> var bitmap = new binary _ bitmap ( new hybrid _ binarizer ( source ) ) ; qr _ code _ reader reader = new qr _ code _ reader ( ) ; var result = reader . decode ( bitmap ) ; if ( result ! = null ) </%> { url _ to _ open = result . text ; splash . form _ closed + = open _ url _ from _ qr _ code ;
{ url _ to _ open = result . text ; splash . form _ closed + = open _ url _ from _ qr _ code ; } else { message _ box . show ( n . get _ string ( STR ) ) ; return ; } float min _ x = int . max _ value , min _ y = int . max _ value , max _ x = 0 , max _ y = 0 ;
break ; case STR : rc . encrypt ( encrypt _ table , buf , length ) ; <%> <*> return -> return byte _ array _ with ( </%> buf <%> <+> , length ) </%> ; break ; default : return ssl _ encrypt ( buf , length ) ; } } public byte [ ] decrypt ( byte [ ] buf , int length )
break ; default : return ssl _ encrypt ( buf , length ) ; } } public byte [ ] decrypt ( byte [ ] buf , int length ) { switch ( method ) { case STR :
break ; case STR : rc . decrypt ( decrypt _ table , buf , length ) ; <%> <*> return -> return byte _ array _ with ( </%> buf <%> <+> , length ) </%> ; break ; default : return ssl _ decrypt ( buf , length ) ; } } }
break ; default : return ssl _ decrypt ( buf , length ) ; } } } }
{ <%> <-> config = config . load ( ) ; </%> initialize _ component ( ) ; notify _ icon . context _ menu = context _ menu ; <%> <*> enable _ item . checked = config . enabled ; config _ to _ text _ box ( ) ; -> this . controller = controller ; </%> <%> <+> controller . enable _ status _ changed + = controller _ enable _ status _ changed ; controller . config _ changed + = controller _ config _ changed ; update _ ui ( ) ; </%>
initialize _ component ( ) ; notify _ icon . context _ menu = context _ menu ; <%> <*> enable _ item . checked = config . enabled ; config _ to _ text _ box ( ) ; -> this . controller = controller ; </%> <%> <+> controller . enable _ status _ changed + = controller _ enable _ status _ changed ; controller . config _ changed + = controller _ config _ changed ; update _ ui ( ) ; } private void controller _ config _ changed ( object sender , event _ args e ) </%>
} private void show _ window ( ) { this . opacity = 1 ; this . show ( ) ; } private void <%> <*> config _ to _ text -> update </%> _ <%> <*> box -> ui </%> ( ) { <%> <+> config config = controller . get _ config ( ) ; </%> text _ box . text = config . server ;
{ <%> <+> config config = controller . get _ config ( ) ; </%> text _ box . text = config . server ; text _ box . text = config . server _ port . to _ string ( ) ; text _ box . text = config . password ; text _ box . text = config . local _ port . to _ string ( ) ; combo _ box . text = config . method = = null ? STR : config . method ; <%> <+> enable _ item . checked = config . enabled ; </%> } private void form _ load ( object sender , event _ args e )
} private void form _ load ( object sender , event _ args e ) { if ( ! <%> <+> controller . get _ </%> config <%> <+> ( ) </%> . is _ default ) { this . opacity = 0 ; <%> <-> reload ( config ) ; </%> begin _ invoke ( new method _ invoker ( delegate { this . hide ( ) ; } ) ) ;
{ this . opacity = 0 ; <%> <-> reload ( config ) ; </%> begin _ invoke ( new method _ invoker ( delegate { this . hide ( ) ; } ) ) ; } <%> <-> pac _ server = new pac _ server ( ) ; pac _ server . start ( ) ; update _ system _ proxy ( ) ; </%>
{ this . hide ( ) ; } ) ) ; } <%> <-> pac _ server = new pac _ server ( ) ; pac _ server . start ( ) ; update _ system _ proxy ( ) ; } private void reload ( config config ) { </%>
} private void config _ click ( object sender , event _ args e ) { show _ window ( ) ; } private void quit _ click ( object sender , event _ args e ) { this . close ( ) ; } private void ok _ button _ click ( object sender , event _ args e )
} private void form _ form _ closed ( object sender , form _ closed _ event _ args e ) { <%> <*> if ( local ! = null ) local . stop ( ) ; if ( polipo _ runner ! = null ) polipo _ runner . stop ( ) ; if ( config . enabled ) { system _ proxy . disable ( ) ; } -> controller . stop ( ) ; </%>
} private void about _ tool _ strip _ menu _ item _ click ( object sender , event _ args e ) { process . start ( STR ) ; } private void notify _ icon _ double _ click ( object sender , event _ args e ) { show _ window ( ) ; } <%> <-> private void update _ system _ proxy ( ) </%>
private void enable _ item _ click ( object sender , event _ args e ) { enable _ item . checked = ! enable _ item . checked ; <%> <*> config . enabled = enable _ item . checked ; config . save ( config ) ; update _ system _ proxy ( ) ; -> controller . toggle _ enable ( enable _ item . checked ) ; </%> } } }
} } }
{ config . proxy . use _ proxy = true ; config . proxy . proxy _ type = type ; config . proxy . proxy _ server = proxy ; config . proxy . proxy _ port = port ; <%> <+> config . proxy . proxy _ timeout = timeout ; </%> save _ config ( config ) ; } public void toggle _ verbose _ logging ( bool enabled ) {
if ( use _ proxy _ check _ box . checked ) { <%> <*> try { port = int . parse ( proxy _ port _ text _ box . text ) ; } catch ( format _ exception ) -> int port ; </%> <%> <+> int timeout ; if ( ! int . try _ parse ( proxy _ port _ text _ box . text , out port ) ) </%>
{ message _ box . show ( n . get _ string ( STR ) ) ; <%> <-> proxy _ port _ text _ box . clear ( ) ; </%> return ; } <%> <-> try { timeout = int . parse ( proxy _ timeout _ text _ box . text ) ; } catch ( format _ exception ) </%>
return ; } <%> <*> try { timeout = int . parse ( proxy _ timeout _ text _ box . text ) ; } catch ( format _ exception ) -> if ( ! int . try _ parse ( proxy _ timeout _ text _ box . text , out timeout ) ) </%> { message _ box . show ( n . get _ string ( STR ) ) ;
{ message _ box . show ( n . get _ string ( STR ) ) ; <%> <-> proxy _ timeout _ text _ box . clear ( ) ; </%> return ; } <%> <+> var type = proxy _ type _ combo _ box . selected _ index ; var proxy = proxy _ server _ text _ box . text ; </%> try { configuration . check _ server ( proxy ) ;
return ; } <%> <+> var type = proxy _ type _ combo _ box . selected _ index ; var proxy = proxy _ server _ text _ box . text ; </%> try { configuration . check _ server ( proxy ) ; configuration . check _ port ( port ) ; configuration . check _ timeout ( timeout , proxy _ config . max _ proxy _ timeout _ sec ) ; }
} else { controller . disable _ proxy ( ) ; } <%> <-> modified _ configuration . use _ proxy = use _ proxy _ check _ box . checked ; modified _ configuration . proxy _ type = type ; modified _ configuration . proxy _ server = proxy ; modified _ configuration . proxy _ port = port ; modified _ configuration . proxy _ timeout = timeout ; </%>
this . close ( ) ; } private void cancel _ button _ click ( object sender , event _ args e ) { this . close ( ) ; } private void proxy _ form _ form _ closed ( object sender , form _ closed _ event _ args e ) { controller . config _ changed - = controller _ config _ changed ; }
if ( method = = STR ) { is _ connect = true ; if ( ! parse _ host ( <%> <*> path -> m . groups [ 2 ] . value </%> ) ) { throw new exception ( STR + line ) ; } } <%> <-> else { </%>
{ throw new exception ( STR + line ) ; } } <%> <-> else { var target _ url = new uri ( path ) ; if ( ! parse _ host ( target _ url . authority ) ) { throw new exception ( STR + line ) ; </%>
if ( line . is _ null _ or _ empty ( ) ) { return true ; } if ( ! is _ connect ) { if ( line . starts _ with ( STR ) ) { if ( ! parse _ host ( line . substring ( NUM ) . trim ( ) ) ) {
if ( config . availability _ statistics ) { availability _ statistics . update _ latency ( <%> <+> args . </%> server , ( int ) <%> <+> args . </%> latency . total _ milliseconds ) ; } } public void update _ inbound _ counter ( <%> <*> server server -> object sender </%> , <%> <*> long n ) -> ss _ transmit _ event _ args args ) </%> { <%> <*> interlocked -> get _ current _ strategy ( ) ? </%> . <%> <*> add ( ref inbound -> update _ last </%> _ <%> <*> counter , n -> read ( args . server </%> ) ; <%> <+> interlocked . add ( ref inbound _ counter , args . length ) ; </%> if ( config . availability _ statistics )
if ( config . availability _ statistics ) { availability _ statistics . update _ inbound _ counter ( <%> <+> args . </%> server , <%> <*> n -> args . length </%> ) ; } } public void update _ outbound _ counter ( <%> <*> server server -> object sender </%> , <%> <*> long n ) -> ss _ transmit _ event _ args args ) </%> { <%> <*> interlocked -> get _ current _ strategy ( ) ? </%> . <%> <*> add ( ref outbound -> update _ last </%> _ <%> <*> counter , n -> write ( args . server </%> ) ; <%> <+> interlocked . add ( ref outbound _ counter , args . length ) ; </%> if ( config . availability _ statistics )
if ( config . availability _ statistics ) { availability _ statistics . update _ outbound _ counter ( <%> <+> args . </%> server , <%> <*> n -> args . length </%> ) ; } } protected void reload ( ) { encryption . rng . reload ( ) ; config = configuration . load ( ) ; n _ log _ config . load _ configuration ( ) ;
} } protected void reload ( ) { encryption . rng . reload ( ) ; config = configuration . load ( ) ; n _ log _ config . load _ configuration ( ) ; statistics _ configuration = statistics _ strategy _ configuration . load ( ) ; privoxy _ runner = privoxy _ runner ? ? new privoxy _ runner ( ) ; pac _ daemon = pac _ daemon ? ? new pac _ daemon ( ) ;
} <%> <+> public </%> class ss _ relay _ event _ args : event _ args { public readonly server server ; public ss _ relay _ event _ args ( server server ) { this . server = server ; } } <%> <+> public </%> class ss _ <%> <*> inbound -> transmit </%> _ event _ args : ss _ relay _ event _ args
{ public readonly server server ; public ss _ relay _ event _ args ( server server ) { this . server = server ; } } <%> <+> public </%> class ss _ <%> <*> inbound -> transmit </%> _ event _ args : ss _ relay _ event _ args { public readonly long length ;
{ public readonly long length ; public ss _ <%> <*> inbound -> transmit </%> _ event _ args ( server server , long length ) : base ( server ) { this . length = length ; } } <%> <-> class ss _ outbound _ event _ args : ss _ relay _ event _ args { public readonly long length ; </%>
{ this . length = length ; } } <%> <-> class ss _ outbound _ event _ args : ss _ relay _ event _ args { public readonly long length ; public ss _ outbound _ event _ args ( server server , long length ) : base ( server ) { this . length = length ; </%>
{ public readonly time _ span latency ; public sstcp _ connected _ event _ args ( server server , time _ span latency ) : base ( server ) { this . latency = latency ; <%> <-> } } class sstcp _ closed _ event _ args : ss _ relay _ event _ args { public readonly tcp _ handler handler ; </%>
} } internal class tcp _ handler { public event event _ handler < sstcp _ connected _ event _ args > on _ connected ; <%> <*> public event event _ handler < ss _ inbound _ event _ args > on _ inbound ; public event event _ handler < ss _ outbound _ event _ args > on _ outbound ; public event event _ handler < sstcp _ closed _ event _ args > on _ closed ; -> public event event _ handler < ss _ transmit _ event _ args > on _ inbound ; </%> <%> <+> public event event _ handler < ss _ transmit _ event _ args > on _ outbound ; </%>
class async _ session { public i _ proxy remote { get ; } public async _ session ( i _ proxy remote ) { remote = remote ; } } class async _ session < t > : async _ session {
start _ sending _ time = date _ time . now ; session . remote . begin _ send ( connetion _ send _ buffer , 0 , bytes _ to _ send , socket _ flags . none , pipe _ remote _ send _ callback , new object [ ] { session , bytes _ to _ send } ) ; <%> <-> i _ strategy strategy = controller . get _ current _ strategy ( ) ; strategy ? . update _ last _ write ( server ) ; </%> } private void pipe _ remote _ send _ callback ( i _ async _ result ar ) { if ( closed ) return ; try
} private void pipe _ remote _ send _ callback ( i _ async _ result ar ) { if ( closed ) return ; try { var container = ( object [ ] ) ar . async _ state ; var session = ( async _ session ) container [ 0 ] ; var bytes _ should _ send = ( int ) container [ 1 ] ; int bytes _ sent = session . remote . end _ send ( ar ) ;
{ init _ key ( method , password ) ; <%> <+> if ( onetime _ auth ) { crc _ buf = new byte [ crc _ buf _ len ] ; } </%> } protected abstract dictionary < string , int [ ] > get _ ciphers ( ) ; protected void init _ key ( string method , string password ) {
} dll _ import _ kernel _ dll private static extern int _ ptr load _ library ( string path ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void crypto _ stream _ salsa _ xor _ ic ( byte [ ] c , byte [ ] m , ulong mlen , byte [ ] n , ulong ic , byte [ ] k ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void crypto _ stream _ chacha _ xor _ ic ( byte [ ] c , byte [ ] m , ulong mlen , byte [ ] n , ulong ic , byte [ ] k ) ; <%> <+> dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int ss _ gen _ crc ( byte [ ] buf , ref int buf _ offset , ref int data _ len , byte [ ] crc _ buf , ref int crc _ idx , int buf _ size ) ; </%>
{ method = method ; password = password ; <%> <+> onetime _ auth = onetimeauth ; </%> } protected string method ; protected string password ; <%> <+> protected bool onetime _ auth ; </%> protected byte [ ] get _ password _ hash ( ) {
this . table _ layout _ panel . tab _ index = 0 ; this . remarks _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . remarks _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . remarks _ text _ box . max _ length = NUM ; this . remarks _ text _ box . name = STR ; this . remarks _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . remarks _ text _ box . tab _ index = NUM ; this . remarks _ text _ box . word _ wrap = false ; this . remarks _ label . anchor = system . windows . forms . anchor _ styles . right ; this . remarks _ label . auto _ size = true ;
this . server _ group _ box . tab _ stop = false ; this . server _ group _ box . text = STR ; this . servers _ list _ box . formatting _ enabled = true ; this . servers _ list _ box . integral _ height = false ; <%> <-> this . servers _ list _ box . item _ height = NUM ; </%> this . servers _ list _ box . location = new system . drawing . point ( 0 , 0 ) ; this . servers _ list _ box . margin = new system . windows . forms . padding ( 0 ) ; this . servers _ list _ box . name = STR ; this . servers _ list _ box . size = new system . drawing . size ( NUM , NUM ) ; this . servers _ list _ box . tab _ index = NUM ;
this . servers _ list _ box . location = new system . drawing . point ( 0 , 0 ) ; this . servers _ list _ box . margin = new system . windows . forms . padding ( 0 ) ; this . servers _ list _ box . name = STR ; this . servers _ list _ box . size = new system . drawing . size ( NUM , NUM ) ; this . servers _ list _ box . tab _ index = NUM ; this . servers _ list _ box . selected _ index _ changed + = new system . event _ handler ( this . servers _ list _ box _ selected _ index _ changed ) ; this . table _ layout _ panel . auto _ size = true ; this . table _ layout _ panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . table _ layout _ panel . column _ count = 2 ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ;
{ if ( string . is _ null _ or _ empty ( method ) ) { method = STR ; } method = method . to _ lower _ invariant ( ) ; type t = registered _ encryptors [ method ] ; constructor _ info c = t . get _ constructor ( constructor _ types ) ; i _ encryptor result = ( i _ encryptor ) c . invoke ( new object [ ] { method , password <%> <+> , onetimeauth </%> } ) ; return result ;
return result ; } } }
this . plugin _ options _ label . name = STR ; this . plugin _ options _ label . size = new system . drawing . size ( NUM , NUM ) ; this . plugin _ options _ label . tab _ index = NUM ; this . plugin _ options _ label . text = STR ; this . tool _ tip . set _ tool _ tip ( this . plugin _ options _ label , STR ) ; this . plugin _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . plugin _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; <%> <+> this . plugin _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; </%> this . plugin _ text _ box . max _ length = NUM ; this . plugin _ text _ box . name = STR ;
this . plugin _ text _ box . max _ length = NUM ; this . plugin _ text _ box . name = STR ; this . plugin _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . plugin _ text _ box . tab _ index = NUM ; this . plugin _ text _ box . word _ wrap = false ; this . remarks _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . remarks _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; <%> <+> this . remarks _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; </%> this . remarks _ text _ box . max _ length = NUM ; this . remarks _ text _ box . name = STR ;
this . remarks _ text _ box . max _ length = NUM ; this . remarks _ text _ box . name = STR ; this . remarks _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . remarks _ text _ box . tab _ index = NUM ; this . remarks _ text _ box . word _ wrap = false ; this . ip _ label . anchor = system . windows . forms . anchor _ styles . right ; this . ip _ label . auto _ size = true ; this . ip _ label . location = new system . drawing . point ( NUM , NUM ) ; <%> <+> this . ip _ label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ; </%> this . ip _ label . name = STR ;
this . ip _ label . name = STR ; this . ip _ label . size = new system . drawing . size ( NUM , NUM ) ; this . ip _ label . tab _ index = 0 ; this . ip _ label . text = STR ; this . server _ port _ label . anchor = system . windows . forms . anchor _ styles . right ; this . server _ port _ label . auto _ size = true ; this . server _ port _ label . location = new system . drawing . point ( NUM , NUM ) ; <%> <+> this . server _ port _ label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ; </%> this . server _ port _ label . name = STR ; this . server _ port _ label . size = new system . drawing . size ( NUM , NUM ) ;
this . server _ port _ label . name = STR ; this . server _ port _ label . size = new system . drawing . size ( NUM , NUM ) ; this . server _ port _ label . tab _ index = 1 ; this . server _ port _ label . text = STR ; this . password _ label . anchor = system . windows . forms . anchor _ styles . right ; this . password _ label . auto _ size = true ; this . password _ label . location = new system . drawing . point ( NUM , NUM ) ; <%> <+> this . password _ label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ; </%> this . password _ label . name = STR ; this . password _ label . size = new system . drawing . size ( NUM , NUM ) ;
this . password _ label . name = STR ; this . password _ label . size = new system . drawing . size ( NUM , NUM ) ; this . password _ label . tab _ index = 2 ; this . password _ label . text = STR ; this . password _ label . text _ align = system . drawing . content _ alignment . middle _ center ; this . ip _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . ip _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; <%> <+> this . ip _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; </%> this . ip _ text _ box . max _ length = NUM ; this . ip _ text _ box . name = STR ;
this . ip _ text _ box . max _ length = NUM ; this . ip _ text _ box . name = STR ; this . ip _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . ip _ text _ box . tab _ index = 0 ; this . ip _ text _ box . word _ wrap = false ; this . server _ port _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . server _ port _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; <%> <+> this . server _ port _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; </%> this . server _ port _ text _ box . max _ length = NUM ; this . server _ port _ text _ box . name = STR ;
this . server _ port _ text _ box . max _ length = NUM ; this . server _ port _ text _ box . name = STR ; this . server _ port _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . server _ port _ text _ box . tab _ index = 1 ; this . server _ port _ text _ box . word _ wrap = false ; this . password _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . password _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; <%> <+> this . password _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; </%> this . password _ text _ box . max _ length = NUM ; this . password _ text _ box . name = STR ;
this . password _ text _ box . max _ length = NUM ; this . password _ text _ box . name = STR ; this . password _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . password _ text _ box . tab _ index = 2 ; this . password _ text _ box . use _ system _ password _ char = true ; this . password _ text _ box . word _ wrap = false ; this . encryption _ label . anchor = system . windows . forms . anchor _ styles . right ; this . encryption _ label . auto _ size = true ; this . encryption _ label . location = new system . drawing . point ( NUM , NUM ) ; <%> <+> this . encryption _ label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ; </%>
this . encryption _ label . name = STR ; this . encryption _ label . size = new system . drawing . size ( NUM , NUM ) ; this . encryption _ label . tab _ index = NUM ; this . encryption _ label . text = STR ; this . encryption _ select . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( ( system . windows . forms . anchor _ styles . top | system . windows . forms . anchor _ styles . left ) | system . windows . forms . anchor _ styles . right ) ) ) ; this . encryption _ select . drop _ down _ style = system . windows . forms . combo _ box _ style . drop _ down _ list ; this . encryption _ select . formatting _ enabled = true ; this . encryption _ select . ime _ mode = system . windows . forms . ime _ mode . no _ control ; <%> <-> this . encryption _ select . item _ height = NUM ; </%>
this . encryption _ select . name = STR ; this . encryption _ select . size = new system . drawing . size ( NUM , NUM ) ; this . encryption _ select . tab _ index = NUM ; this . timeout _ label . anchor = system . windows . forms . anchor _ styles . right ; this . timeout _ label . auto _ size = true ; this . timeout _ label . location = new system . drawing . point ( NUM , NUM ) ; <%> <+> this . timeout _ label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ; </%> this . timeout _ label . name = STR ; this . timeout _ label . right _ to _ left = system . windows . forms . right _ to _ left . no ; this . timeout _ label . size = new system . drawing . size ( NUM , NUM ) ;
this . timeout _ label . name = STR ; this . timeout _ label . right _ to _ left = system . windows . forms . right _ to _ left . no ; this . timeout _ label . size = new system . drawing . size ( NUM , NUM ) ; this . timeout _ label . tab _ index = NUM ; this . timeout _ label . text = STR ; this . timeout _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . timeout _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; <%> <+> this . timeout _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; </%> this . timeout _ text _ box . max _ length = NUM ; this . timeout _ text _ box . name = STR ;
this . timeout _ text _ box . max _ length = NUM ; this . timeout _ text _ box . name = STR ; this . timeout _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . timeout _ text _ box . tab _ index = NUM ; this . plugin _ label . anchor = system . windows . forms . anchor _ styles . right ; this . plugin _ label . auto _ size = true ; this . plugin _ label . location = new system . drawing . point ( NUM , NUM ) ; <%> <+> this . plugin _ label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ; </%> this . plugin _ label . name = STR ; this . plugin _ label . size = new system . drawing . size ( NUM , NUM ) ;
this . plugin _ label . name = STR ; this . plugin _ label . size = new system . drawing . size ( NUM , NUM ) ; this . plugin _ label . tab _ index = NUM ; this . plugin _ label . text = STR ; this . plugin _ options _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . plugin _ options _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; <%> <+> this . plugin _ options _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; </%> this . plugin _ options _ text _ box . max _ length = NUM ; this . plugin _ options _ text _ box . name = STR ; this . plugin _ options _ text _ box . size = new system . drawing . size ( NUM , NUM ) ;
this . plugin _ options _ text _ box . max _ length = NUM ; this . plugin _ options _ text _ box . name = STR ; this . plugin _ options _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . plugin _ options _ text _ box . tab _ index = NUM ; this . plugin _ options _ text _ box . word _ wrap = false ; this . show _ passwd _ check _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( ( system . windows . forms . anchor _ styles . top | system . windows . forms . anchor _ styles . bottom ) | system . windows . forms . anchor _ styles . left ) ) ) ; this . show _ passwd _ check _ box . auto _ size = true ; this . show _ passwd _ check _ box . location = new system . drawing . point ( NUM , NUM ) ; <%> <+> this . show _ passwd _ check _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; </%>
this . show _ passwd _ check _ box . name = STR ; this . show _ passwd _ check _ box . size = new system . drawing . size ( NUM , NUM ) ; this . show _ passwd _ check _ box . tab _ index = NUM ; this . show _ passwd _ check _ box . text = STR ; this . show _ passwd _ check _ box . text _ align = system . drawing . content _ alignment . middle _ center ; this . show _ passwd _ check _ box . use _ visual _ style _ back _ color = true ; this . show _ passwd _ check _ box . checked _ changed + = new system . event _ handler ( this . show _ passwd _ check _ box _ checked _ changed ) ; this . plugin _ arguments _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . plugin _ arguments _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; <%> <+> this . plugin _ arguments _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; </%>
this . plugin _ arguments _ text _ box . max _ length = NUM ; this . plugin _ arguments _ text _ box . name = STR ; this . plugin _ arguments _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . plugin _ arguments _ text _ box . tab _ index = NUM ; this . plugin _ arguments _ text _ box . word _ wrap = false ; this . plugin _ arguments _ label . anchor = system . windows . forms . anchor _ styles . right ; this . plugin _ arguments _ label . auto _ size = true ; this . plugin _ arguments _ label . location = new system . drawing . point ( NUM , NUM ) ; <%> <+> this . plugin _ arguments _ label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ; </%> this . plugin _ arguments _ label . name = STR ;
this . plugin _ arguments _ label . name = STR ; this . plugin _ arguments _ label . size = new system . drawing . size ( NUM , NUM ) ; this . plugin _ arguments _ label . tab _ index = NUM ; this . plugin _ arguments _ label . text = STR ; this . tool _ tip . set _ tool _ tip ( this . plugin _ arguments _ label , STR + STR ) ; this . remarks _ label . anchor = system . windows . forms . anchor _ styles . right ; this . remarks _ label . auto _ size = true ; this . remarks _ label . location = new system . drawing . point ( NUM , NUM ) ; <%> <+> this . remarks _ label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ; </%>
this . remarks _ label . name = STR ; this . remarks _ label . size = new system . drawing . size ( NUM , NUM ) ; this . remarks _ label . tab _ index = NUM ; this . remarks _ label . text = STR ; this . need _ plugin _ arg _ check _ box . auto _ size = true ; this . need _ plugin _ arg _ check _ box . location = new system . drawing . point ( NUM , NUM ) ; <%> <+> this . need _ plugin _ arg _ check _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; </%> this . need _ plugin _ arg _ check _ box . name = STR ; this . need _ plugin _ arg _ check _ box . size = new system . drawing . size ( NUM , NUM ) ; this . need _ plugin _ arg _ check _ box . tab _ index = NUM ;
this . need _ plugin _ arg _ check _ box . name = STR ; this . need _ plugin _ arg _ check _ box . size = new system . drawing . size ( NUM , NUM ) ; this . need _ plugin _ arg _ check _ box . tab _ index = NUM ; this . need _ plugin _ arg _ check _ box . text = STR ; this . need _ plugin _ arg _ check _ box . use _ visual _ style _ back _ color = true ; this . need _ plugin _ arg _ check _ box . checked _ changed + = new system . event _ handler ( this . use _ plugin _ arg _ check _ box _ checked _ changed ) ; this . panel . anchor = system . windows . forms . anchor _ styles . top ; this . panel . auto _ size = true ; this . panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . panel . location = new system . drawing . point ( NUM , NUM ) ;
this . panel . name = STR ; this . panel . size = new system . drawing . size ( 0 , 0 ) ; this . panel . tab _ index = 1 ; this . ok _ button . dialog _ result = system . windows . forms . dialog _ result . ok ; this . ok _ button . dock = system . windows . forms . dock _ style . right ; this . ok _ button . location = new system . drawing . point ( NUM , NUM ) ; this . ok _ button . margin = new system . windows . forms . padding ( NUM , NUM , NUM , 0 ) ; this . ok _ button . name = STR ; this . ok _ button . size = new system . drawing . size ( NUM , NUM ) ; this . ok _ button . tab _ index = NUM ;
this . table _ layout _ panel . row _ count = 2 ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ; this . table _ layout _ panel . tab _ index = NUM ; this . proxy _ port _ text _ box . anchor = system . windows . forms . anchor _ styles . left ; this . proxy _ port _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; <%> <+> this . proxy _ port _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; </%> this . proxy _ port _ text _ box . max _ length = NUM ; this . proxy _ port _ text _ box . name = STR ;
this . proxy _ port _ text _ box . max _ length = NUM ; this . proxy _ port _ text _ box . name = STR ; this . proxy _ port _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . proxy _ port _ text _ box . tab _ index = NUM ; this . proxy _ port _ text _ box . word _ wrap = false ; this . proxy _ port _ label . anchor = system . windows . forms . anchor _ styles . right ; this . proxy _ port _ label . auto _ size = true ; this . proxy _ port _ label . location = new system . drawing . point ( NUM , NUM ) ; <%> <+> this . proxy _ port _ label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ; </%> this . proxy _ port _ label . name = STR ;
this . proxy _ port _ label . name = STR ; this . proxy _ port _ label . size = new system . drawing . size ( NUM , NUM ) ; this . proxy _ port _ label . tab _ index = NUM ; this . proxy _ port _ label . text = STR ; this . portable _ mode _ check _ box . anchor = system . windows . forms . anchor _ styles . left ; this . portable _ mode _ check _ box . auto _ size = true ; this . table _ layout _ panel . set _ column _ span ( this . portable _ mode _ check _ box , 2 ) ; this . portable _ mode _ check _ box . location = new system . drawing . point ( NUM , NUM ) ; <%> <+> this . portable _ mode _ check _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; </%> this . portable _ mode _ check _ box . name = STR ;
this . portable _ mode _ check _ box . name = STR ; this . portable _ mode _ check _ box . size = new system . drawing . size ( NUM , NUM ) ; this . portable _ mode _ check _ box . tab _ index = NUM ; this . portable _ mode _ check _ box . text = STR ; this . tool _ tip . set _ tool _ tip ( this . portable _ mode _ check _ box , STR ) ; this . portable _ mode _ check _ box . use _ visual _ style _ back _ color = true ; this . table _ layout _ panel . auto _ size = true ; this . table _ layout _ panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . table _ layout _ panel . column _ count = NUM ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ;
using global _ hot _ key ; using system _ windows _ input ; using system _ threading ; using system _ collections _ generic ; using shadowsocks _ controller _ hotkeys ; <%> <-> using shadowsocks _ encryption _ stream ; using shadowsocks _ model ; using shadowsocks _ controller _ service ; </%> using system _ diagnostics ; <%> <-> using system _ net ; </%>
using system _ diagnostics ; <%> <*> using system _ net ; namespace test -> namespace shadowsocks _ test </%> { test _ class public class unit _ test { test _ method public void test _ compare _ version ( )
{ test _ class public class unit _ test { test _ method public void test _ compare _ version ( ) { assert . is _ true ( update _ checker . asset . compare _ version ( STR , STR ) = = 0 ) ; assert . is _ true ( update _ checker . asset . compare _ version ( STR , STR ) < 0 ) ; assert . is _ true ( update _ checker . asset . compare _ version ( STR , STR ) > 0 ) ;
{ try { <%> <-> string pac = get _ pac _ content ( ) ; </%> ip _ end _ point local _ end _ point = ( ip _ end _ point ) socket . local _ end _ point ; string proxy = get _ pac _ address ( <%> <-> first _ packet , length , </%> local _ end _ point , use _ socks ) ; <%> <+> string </%> pac <%> <+> _ content </%> = <%> <+> get _ </%> pac <%> <+> _ content ( ) </%> . replace ( STR , proxy ) ; string <%> <*> text -> response _ head </%> = string . format ( @ STR server : shadowsocks content - type : application / x - ns - proxy - autoconfig
ip _ end _ point local _ end _ point = ( ip _ end _ point ) socket . local _ end _ point ; string proxy = get _ pac _ address ( <%> <-> first _ packet , length , </%> local _ end _ point , use _ socks ) ; <%> <+> string </%> pac <%> <+> _ content </%> = <%> <+> get _ </%> pac <%> <+> _ content ( ) </%> . replace ( STR , proxy ) ; string <%> <*> text -> response _ head </%> = string . format ( @ STR server : shadowsocks content - type : application / x - ns - proxy - autoconfig content - length : { 0 } connection : close STR byte [ ] response = encoding . ut . get _ bytes ( <%> <*> text -> response _ head + pac _ content </%> ) ;
server : shadowsocks content - type : application / x - ns - proxy - autoconfig content - length : { 0 } connection : close STR byte [ ] response = encoding . ut . get _ bytes ( <%> <*> text -> response _ head + pac _ content </%> ) ; socket . begin _ send ( response , 0 , response . length , 0 , new async _ callback ( send _ callback ) , socket ) ; utils . release _ memory ( true ) ; } catch ( exception e )
socket . begin _ send ( response , 0 , response . length , 0 , new async _ callback ( send _ callback ) , socket ) ; utils . release _ memory ( true ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; socket . close ( ) ; } } private void send _ callback ( i _ async _ result ar )
} catch ( io _ exception e ) { console . write _ line ( e . to _ string ( ) ) ; } <%> <+> load _ library ( dll _ path ) ; </%> logging . open _ log _ file ( ) ; application . enable _ visual _ styles ( ) ; application . set _ compatible _ text _ rendering _ default ( false ) ; shadowsocks _ controller controller = new shadowsocks _ controller ( ) ;
{ field _ offset public int dw _ value ; field _ offset public system . int _ ptr psz _ value ; field _ offset public system . runtime . interop _ services . com _ types . filetime ft _ value ; <%> <+> public void dispose ( ) { dispose ( true ) ; </%>
{ public int size ; public system . int _ ptr connection ; public int option _ count ; public int option _ error ; public system . int _ ptr p _ options ; <%> <+> public void dispose ( ) { dispose ( true ) ; gc . suppress _ finalize ( this ) ; </%>
return true ; } catch ( io _ exception e ) { console . write _ line ( e . to _ string ( ) ) ; return false ; } } <%> <-> private static void roll _ log _ file ( ) { </%>
private static void write _ to _ log _ file ( object o ) { <%> <-> if ( ( date _ time . now - log _ file _ creation _ time ) . days > = 1 ) roll _ log _ file ( ) ; </%> console . write _ line ( o ) ; } public static void error ( object o ) { write _ to _ log _ file ( STR + o ) ; }
console . write _ line ( o ) ; } public static void error ( object o ) { write _ to _ log _ file ( STR + o ) ; } public static void info ( object o ) { write _ to _ log _ file ( o ) ; }
private configuration modified _ configuration ; private int old _ selected _ index = - 1 ; <%> <-> private bool is _ first _ run ; </%> public config _ form ( shadowsocks _ controller controller ) { initialize _ component ( ) ; this . icon = icon . from _ handle ( resources . ssw . get _ hicon ( ) ) ; this . controller = controller ; controller . config _ changed + = controller _ config _ changed ; load _ current _ configuration ( ) ;
public config _ form ( shadowsocks _ controller controller ) { initialize _ component ( ) ; this . icon = icon . from _ handle ( resources . ssw . get _ hicon ( ) ) ; this . controller = controller ; controller . config _ changed + = controller _ config _ changed ; load _ current _ configuration ( ) ; } private void controller _ config _ changed ( object sender , event _ args e ) {
private static readonly concurrent _ dictionary < string , byte [ ] > cached _ keys = new concurrent _ dictionary < string , byte [ ] > ( ) ; protected byte [ ] encrypt _ iv ; protected byte [ ] decrypt _ iv ; protected bool decrypt _ iv _ received ; protected bool encrypt _ iv _ sent ; protected string method ; protected int cipher ; protected string cipher _ mbed _ name ; protected <%> <*> int [ ] -> encryptor _ info </%> cipher _ info ; protected byte [ ] key ;
protected byte [ ] key ; protected int key _ len ; protected int iv _ len ; public iv _ encryptor ( string method , string password , bool onetimeauth , bool isudp ) : base ( method , password , onetimeauth , isudp ) { init _ key ( method , password ) ; } protected abstract dictionary < string , <%> <*> dictionary < string , int [ ] > -> encryptor _ info </%> > get _ ciphers ( ) ; private void init _ key ( string method , string password )
private void init _ key ( string method , string password ) { method = method . to _ lower ( ) ; method = method ; string k = method + STR + password ; ciphers = get _ ciphers ( ) ; <%> <-> ciphers _ detail = ciphers [ method ] ; cipher _ mbed _ name = ciphers _ detail . keys . first _ or _ default ( ) ; cipher _ info = ciphers [ method ] [ cipher _ mbed _ name ] ; cipher = cipher _ info [ 2 ] ; </%>
if ( cipher = = 0 ) { throw new exception ( STR ) ; } key _ len = cipher _ info <%> <*> [ 0 ] -> . key _ size </%> ; iv _ len = cipher _ info <%> <*> [ 1 ] -> . iv _ size </%> ; key = cached _ keys . get _ or _ add ( k , ( nk ) = > { byte [ ] passbuf = encoding . ut . get _ bytes ( password ) ; byte [ ] key = new byte [ NUM ] ;
key = cached _ keys . get _ or _ add ( k , ( nk ) = > { byte [ ] passbuf = encoding . ut . get _ bytes ( password ) ; byte [ ] key = new byte [ NUM ] ; bytes _ to _ key ( passbuf , key ) ; return key ; } ) ; } protected void bytes _ to _ key ( byte [ ] password , byte [ ] key ) {
} ; public static list < string > supported _ ciphers ( ) { return new list < string > ( ciphers . keys ) ; } protected override dictionary < string , <%> <*> dictionary < string , int [ ] > -> encryptor _ info </%> > get _ ciphers ( ) { return ciphers ; } protected override void init _ cipher ( byte [ ] iv , bool is _ cipher )
{ return ciphers ; } protected override void init _ cipher ( byte [ ] iv , bool is _ cipher ) { base . init _ cipher ( iv , is _ cipher ) ; int _ ptr ctx = marshal . alloc _ h _ global ( mbed _ tls . cipher _ get _ size _ ex ( ) ) ; if ( is _ cipher ) { encrypt _ ctx = ctx ;
} ; protected override dictionary < string , <%> <*> dictionary < string , int [ ] > -> encryptor _ info </%> > get _ ciphers ( ) { return ciphers ; } public static list < string > supported _ ciphers ( ) { return new list < string > ( ciphers . keys ) ; } protected override void cipher _ update ( bool is _ cipher , int length , byte [ ] buf , byte [ ] outbuf )
{ return ciphers ; } public static list < string > supported _ ciphers ( ) { return new list < string > ( ciphers . keys ) ; } protected override void cipher _ update ( bool is _ cipher , int length , byte [ ] buf , byte [ ] outbuf ) { int bytes _ remaining ;
} <%> <+> private system . windows . forms . table _ layout _ panel table _ layout _ panel ; private system . windows . forms . label label ; private system . windows . forms . label label ; private system . windows . forms . label label ; private system . windows . forms . label label ; private system . windows . forms . text _ box text _ box ; private system . windows . forms . text _ box text _ box ; private system . windows . forms . text _ box text _ box ; private system . windows . forms . text _ box text _ box ; </%>
protected static byte [ ] tempbuf = new byte [ max _ input _ size ] ; protected dictionary < string , int [ ] > ciphers ; private static readonly dictionary < string , byte [ ] > cached _ keys = new dictionary < string , byte [ ] > ( ) ; protected byte [ ] encrypt _ iv ; protected byte [ ] decrypt _ iv ; protected bool decrypt _ iv _ received ; protected bool encrypt _ iv _ sent ; protected int encrypt _ iv _ offset = 0 ; protected int decrypt _ iv _ offset = 0 ; protected string method ;
public iv _ encryptor ( string method , string password , bool onetimeauth ) : base ( method , password , onetimeauth ) { init _ key ( method , password ) ; if ( onetime _ auth ) { <%> <*> crc -> hash </%> _ buf = new byte [ <%> <*> crc -> hash </%> _ buf _ len ] ; } } protected abstract dictionary < string , int [ ] > get _ ciphers ( ) ;
} } protected abstract dictionary < string , int [ ] > get _ ciphers ( ) ; protected void init _ key ( string method , string password ) { method = method . to _ lower ( ) ; method = method ; string k = method + STR + password ; ciphers = get _ ciphers ( ) ; cipher _ info = ciphers [ method ] ;
{ int head _ len = <%> <-> get _ </%> ss <%> <-> _ head </%> _ <%> <*> length -> headlen </%> ( buf , length ) ; int data _ len = length - head _ len ; buffer . block _ copy ( buf , head _ len , buf , head _ len + onetimeauth _ bytes , data _ len ) ; buf [ 0 ] | = onetimeauth _ flag ; byte [ ] auth = new byte [ onetimeauth _ bytes ] ; <%> <-> sodium . </%> ss _ onetimeauth ( auth , buf , head _ len , encrypt _ iv , iv _ len , key , key _ len ) ; buffer . block _ copy ( auth , 0 , buf , head _ len , onetimeauth _ bytes ) ; int buf _ offset = head _ len + onetimeauth _ bytes ; <%> <-> int rc = sodium . ss _ gen _ crc ( buf , ref buf _ offset , ref data _ len , crc _ buf , ref crc _ idx , buf . length ) ; </%>
int data _ len = length - head _ len ; buffer . block _ copy ( buf , head _ len , buf , head _ len + onetimeauth _ bytes , data _ len ) ; buf [ 0 ] | = onetimeauth _ flag ; byte [ ] auth = new byte [ onetimeauth _ bytes ] ; <%> <-> sodium . </%> ss _ onetimeauth ( auth , buf , head _ len , encrypt _ iv , iv _ len , key , key _ len ) ; buffer . block _ copy ( auth , 0 , buf , head _ len , onetimeauth _ bytes ) ; int buf _ offset = head _ len + onetimeauth _ bytes ; <%> <-> int rc = sodium . ss _ gen _ crc ( buf , ref buf _ offset , ref data _ len , crc _ buf , ref crc _ idx , buf . length ) ; if ( rc ! = 0 ) throw new exception ( STR ) ; </%>
buffer . block _ copy ( auth , 0 , buf , head _ len , onetimeauth _ bytes ) ; int buf _ offset = head _ len + onetimeauth _ bytes ; <%> <*> int rc = sodium . ss _ gen _ crc ( buf , ref buf _ offset , ref data _ len , crc _ buf , ref crc _ idx , buf . length ) ; if ( rc ! = 0 ) throw new exception ( STR ) ; -> ss _ gen _ hash ( buf , ref buf _ offset , ref data _ len , hash _ buf , ref hash _ idx , buf . length ) ; </%> length = head _ len + onetimeauth _ bytes + data _ len ; } } cipher _ update ( true , length , buf , tempbuf ) ;
length = head _ len + onetimeauth _ bytes + data _ len ; } } cipher _ update ( true , length , buf , tempbuf ) ; outlength = length + iv _ len ; buffer . block _ copy ( tempbuf , 0 , outbuf , iv _ len , length ) ; } } else {
{ int buf _ offset = 0 ; <%> <*> int rc = sodium . ss _ gen _ crc ( buf , ref buf _ offset , ref length , crc _ buf , ref crc _ idx , buf . length ) ; if ( rc ! = 0 ) throw new exception ( STR ) ; -> ss _ gen _ hash ( buf , ref buf _ offset , ref length , hash _ buf , ref hash _ idx , buf . length ) ; </%> } } outlength = length ; cipher _ update ( true , length , buf , outbuf ) ;
} } outlength = length ; cipher _ update ( true , length , buf , outbuf ) ; } } public override void decrypt ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength ) { if ( ! decrypt _ iv _ received ) {
dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl <%> <*> public extern static int ss _ onetimeauth ( byte [ ] auth , byte [ ] msg , int msg _ len , byte [ ] iv , int iv _ len , byte [ ] key , int key _ len ) ; -> public extern static int crypto _ onetimeauth ( byte [ ] outbuf , byte [ ] inbuf , ulong inlen , byte [ ] k ) ; </%> <%> <+> dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int crypto _ onetimeauth _ verify ( byte [ ] h , byte [ ] inbuf , ulong inlen , byte [ ] k ) ; </%> } }
} }
private void auto _ startup _ click ( object sender , event _ args e ) { auto _ startup . checked = ! auto _ startup . checked ; if ( ! <%> <-> set _ </%> auto _ startup <%> <+> . set </%> ( auto _ startup . checked ) ) { <%> <+> message _ box . show ( STR ) ; </%> } } private void context _ menu _ popup ( object sender , event _ args e ) { auto _ startup . checked = <%> <-> check _ </%> auto _ startup <%> <+> . check </%> ( ) ; } }
} } private void context _ menu _ popup ( object sender , event _ args e ) { auto _ startup . checked = <%> <-> check _ </%> auto _ startup <%> <+> . check </%> ( ) ; } } }
} } }
using ( graphics g = graphics . from _ image ( draw _ area ) ) { g . clear ( color . white ) ; using ( brush b = new solid _ brush ( color . black ) ) { for ( int row = 0 ; row < m . <%> <*> height -> width </%> ; row + + ) { for ( int col = 0 ; col < m . height ; col + + ) { if ( m [ row , col ] ! = 0 )
<%> <*> string encoding = hints = = null | | ! hints . contains _ key ( encode _ hint _ type . character _ set ) ? null : ( string ) hints [ encode _ hint _ type . character _ set ] ; if ( encoding = = null ) { encoding = default _ byte _ mode _ encoding ; } bool generate _ eci = ! default _ byte _ mode _ encoding . equals ( encoding ) ; -> string encoding = default _ byte _ mode _ encoding ; </%> const string encoding = STR ; bool generate _ eci = ( hints ! = null & & hints . contains _ key ( encode _ hint _ type . character _ set ) ) ; mode mode = <%> <-> choose _ </%> mode <%> <*> ( content , encoding ) -> . byte </%> ;
const string encoding = STR ; bool generate _ eci = ( hints ! = null & & hints . contains _ key ( encode _ hint _ type . character _ set ) ) ; mode mode = <%> <-> choose _ </%> mode <%> <*> ( content , encoding ) -> . byte </%> ; bit _ array header _ bits = new bit _ array ( ) ; if ( mode = = mode . byte & & generate _ eci ) { character _ set _ eci eci = character _ set _ eci . get _ character _ set _ eci _ by _ name ( encoding ) ; if ( eci ! = null ) { var eci _ is _ explicit _ disabled = ( hints ! = null & & hints . contains _ key ( encode _ hint _ type . disable _ eci ) ? ( bool ) hints [ encode _ hint _ type . disable _ eci ] : false ) ;
bit _ array header _ bits = new bit _ array ( ) ; if ( mode = = mode . byte & & generate _ eci ) { character _ set _ eci eci = character _ set _ eci . get _ character _ set _ eci _ by _ name ( encoding ) ; if ( eci ! = null ) { var eci _ is _ explicit _ disabled = ( hints ! = null & & hints . contains _ key ( encode _ hint _ type . disable _ eci ) ? ( bool ) hints [ encode _ hint _ type . disable _ eci ] : false ) ; if ( ! eci _ is _ explicit _ disabled ) { append _ eci ( eci , header _ bits ) ;
if ( mode . equals ( mode . byte ) ) append _ bit _ bytes ( content , bits , encoding ) ; <%> <-> else if ( mode . equals ( mode . kanji ) ) append _ kanji _ bytes ( content , bits ) ; </%> else throw new exception ( STR + mode ) ; <%> <-> } internal static void append _ numeric _ bytes ( string content , bit _ array bits ) { </%>
else throw new exception ( STR + mode ) ; <%> <-> } internal static void append _ numeric _ bytes ( string content , bit _ array bits ) { int length = content . length ; int i = 0 ; while ( i < length ) { int num = content [ i ] - '0' ; </%>
} internal static void append _ bit _ bytes ( string content , bit _ array bits , string encoding ) { byte [ ] bytes ; try { bytes = encoding . get _ encoding ( encoding ) . get _ bytes ( content ) ; } catch ( platform _ not _ supported _ exception ) {
public static version get _ version _ for _ number ( int version _ number ) { if ( version _ number < 1 | | version _ number > NUM ) { throw new argument _ exception ( ) ; } return versions [ version _ number - 1 ] ; <%> <-> } internal static version decode _ version _ information ( int version _ bits ) { </%>
} public sealed class ec _ blocks { private readonly int ec _ codewords _ per _ block ; private readonly ecb [ ] ec _ blocks ; internal ec _ blocks ( int ec _ codewords _ per _ block , params ecb [ ] ec _ blocks ) { this . ec _ codewords _ per _ block = ec _ codewords _ per _ block ; this . ec _ blocks = ec _ blocks ; }
public int generator _ base { get { return generator _ base ; } } <%> <-> override public string to _ string ( ) { return STR + primitive . to _ string ( STR ) + ',' + size + ')' ; } </%> } }
} }
} public bit _ array ( ) { this . size = 0 ; this . bits = new int [ 1 ] ; <%> <-> } public bit _ array ( int size ) { if ( size < 1 ) { </%>
} private void ensure _ capacity ( int size ) { if ( size > bits . length < < NUM ) { int [ ] new _ bits = make _ array ( size ) ; system . array . copy ( bits , 0 , new _ bits , 0 , bits . length ) ; bits = new _ bits ; }
private static int [ ] make _ array ( int size ) { return new int [ ( size + NUM ) > > NUM ] ; } <%> <-> public override bool equals ( object o ) { var other = o as bit _ array ; if ( other = = null ) return false ; if ( size ! = other . size ) </%>
} }
} else { <%> <*> log _ forms _ visible = ! log _ forms _ visible ; foreach ( log _ form f in log _ forms ) { f . visible = log _ forms _ visible ; } -> log _ form = new log _ form ( controller , logging . log _ file _ path ) ; </%> <%> <+> log _ form . show ( ) ; </%>
} } void log _ form _ form _ closed ( object sender , form _ closed _ event _ args e ) { <%> <*> log _ forms . remove ( ( log _ form ) sender ) ; -> log _ form = null ; </%> <%> <+> utils . release _ memory ( true ) ; </%> } void config _ form _ form _ closed ( object sender , form _ closed _ event _ args e ) {
} void config _ form _ form _ closed ( object sender , form _ closed _ event _ args e ) { config _ form = null ; utils . release _ memory ( true ) ; if ( is _ first _ run ) { check _ update _ for _ first _ run ( ) ; show _ first _ time _ balloon ( ) ; is _ first _ run = false ;
bytes _ to _ key ( passbuf , key ) ; return key ; } ) ; } protected <%> <+> static </%> void bytes _ to _ key ( byte [ ] password , byte [ ] key ) { byte [ ] result = new byte [ password . length + NUM ] ; int i = 0 ; byte [ ] md _ sum = null ; while ( i < key . length )
{ byte [ ] result = new byte [ password . length + NUM ] ; int i = 0 ; byte [ ] md _ sum = null ; while ( i < key . length ) { if ( i = = 0 ) { md _ sum = mbed _ tls . m ( password ) ; }
{ <%> <+> if ( file . exists ( nlog _ config _ file _ name ) ) return ; </%> file . write _ all _ text ( nlog _ config _ file _ name , properties . resources . n _ log _ config ) ; <%> <-> log _ manager . load _ configuration ( nlog _ config _ file _ name ) ; </%> } <%> <+> catch ( exception ex ) { n _ log . common . internal _ logger . error ( ex , STR , nlog _ config _ file _ name ) ; return ; </%>
} <%> <+> catch ( exception ex ) { n _ log . common . internal _ logger . error ( ex , STR , nlog _ config _ file _ name ) ; return ; } load _ configuration ( ) ; </%> } public static void load _ configuration ( ) {
} private sip _ plugin ( string plugin , string plugin _ opts <%> <+> , string plugin _ args </%> , string server _ address , int server _ port ) { if ( plugin = = null ) throw new argument _ null _ exception ( nameof ( plugin ) ) ; if ( string . is _ null _ or _ white _ space ( server _ address ) ) { throw new argument _ exception ( STR , nameof ( server _ address ) ) ; } if ( server _ port < = 0 | | server _ port > NUM ) {
{ if ( plugin = = null ) throw new argument _ null _ exception ( nameof ( plugin ) ) ; if ( string . is _ null _ or _ white _ space ( server _ address ) ) { throw new argument _ exception ( STR , nameof ( server _ address ) ) ; } if ( server _ port < = 0 | | server _ port > NUM ) { throw new argument _ out _ of _ range _ exception ( STR ) ; }
this . table _ layout _ panel . tab _ index = 0 ; this . plugin _ options _ label . anchor = system . windows . forms . anchor _ styles . right ; this . plugin _ options _ label . auto _ size = true ; this . plugin _ options _ label . location = new system . drawing . point ( NUM , NUM ) ; this . plugin _ options _ label . name = STR ; this . plugin _ options _ label . size = new system . drawing . size ( NUM , NUM ) ; this . plugin _ options _ label . tab _ index = NUM ; this . plugin _ options _ label . text = STR ; this . plugin _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . plugin _ text _ box . location = new system . drawing . point ( NUM , NUM ) ;
private system . windows . forms . text _ box ip _ text _ box ; private system . windows . forms . text _ box server _ port _ text _ box ; private system . windows . forms . text _ box password _ text _ box ; <%> <-> private system . windows . forms . text _ box proxy _ port _ text _ box ; </%> private system . windows . forms . label encryption _ label ; private system . windows . forms . combo _ box encryption _ select ; private system . windows . forms . panel panel ; private system . windows . forms . button ok _ button ; private system . windows . forms . button my _ cancel _ button ; private system . windows . forms . button delete _ button ;
private system . windows . forms . label encryption _ label ; private system . windows . forms . combo _ box encryption _ select ; private system . windows . forms . panel panel ; private system . windows . forms . button ok _ button ; private system . windows . forms . button my _ cancel _ button ; private system . windows . forms . button delete _ button ; private system . windows . forms . button add _ button ; private system . windows . forms . group _ box server _ group _ box ; private system . windows . forms . list _ box servers _ list _ box ; private system . windows . forms . text _ box remarks _ text _ box ;
this . panel = new system . windows . forms . panel ( ) ; this . add _ button = new system . windows . forms . button ( ) ; this . delete _ button = new system . windows . forms . button ( ) ; this . group _ box = new system . windows . forms . group _ box ( ) ; <%> <+> this . servers _ list _ box = new system . windows . forms . list _ box ( ) ; </%> this . table _ layout _ panel . suspend _ layout ( ) ; this . panel . suspend _ layout ( ) ; this . panel . suspend _ layout ( ) ; this . group _ box . suspend _ layout ( ) ; this . suspend _ layout ( ) ;
this . controls . add ( this . panel ) ; this . controls . add ( this . panel ) ; this . controls . add ( this . panel ) ; this . form _ border _ style = system . windows . forms . form _ border _ style . fixed _ single ; this . icon = ( ( system . drawing . icon ) ( resources . get _ object ( STR ) ) ) ; this . maximize _ box = false ; this . name = STR ; this . start _ position = system . windows . forms . form _ start _ position . center _ screen ; this . text = STR ; this . form _ closed + = new system . windows . forms . form _ closed _ event _ handler ( this . config _ form _ form _ closed ) ;
private system . windows . forms . panel panel ; private system . windows . forms . button delete _ button ; private system . windows . forms . button add _ button ; private system . windows . forms . group _ box group _ box ; <%> <+> private system . windows . forms . list _ box servers _ list _ box ; </%> } }
assembly _ assembly _ product _ shadowsocks assembly _ assembly _ copyright _ copyright _ clowwindy assembly _ assembly _ trademark assembly _ assembly _ culture assembly _ com _ visible _ false assembly _ guid _ bbd _ dcf assembly _ assembly _ version <%> <-> assembly _ assembly _ file _ version </%>

unknown _ fields = pb : : unknown _ field _ set . clone ( other . unknown _ fields ) ; } global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute public geosite clone ( ) { return new geosite ( this ) ; } public const int <%> <*> country -> group </%> _ <%> <*> code -> name </%> _ field _ number = 1 ; private string <%> <*> country -> group </%> _ <%> <*> code -> name </%> = STR ; global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute public string <%> <*> country -> group </%> _ <%> <*> code -> name </%> {
set { <%> <*> country -> group </%> _ <%> <*> code -> name </%> = pb : : proto _ preconditions . check _ not _ null ( value , STR ) ; } } public const int <%> <*> domain -> domains </%> _ field _ number = 2 ; private static readonly pb : : field _ codec < global :: domain _ object > repeated _ <%> <*> domain -> domains </%> _ codec = pb : : field _ codec . for _ message ( NUM , global :: domain _ object . parser ) ; private readonly pbc : : repeated _ field < global :: domain _ object > <%> <*> domain -> domains </%> = new pbc : : repeated _ field < global :: domain _ object > ( ) ; global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute public pbc : : repeated _ field < global :: domain _ object > <%> <*> domain -> domains </%> {
= pb : : field _ codec . for _ message ( NUM , global :: domain _ object . parser ) ; private readonly pbc : : repeated _ field < global :: domain _ object > <%> <*> domain -> domains </%> = new pbc : : repeated _ field < global :: domain _ object > ( ) ; global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute public pbc : : repeated _ field < global :: domain _ object > <%> <*> domain -> domains </%> { get { return <%> <*> domain -> domains </%> ; } } global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute public override bool equals ( object other ) { return equals ( other as geosite ) ; }
} global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute public override bool equals ( object other ) { return equals ( other as geosite ) ; } global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute public bool equals ( geosite other ) { if ( reference _ equals ( other , null ) ) { return false ; }
return equals ( unknown _ fields , other . unknown _ fields ) ; } global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute public override int get _ hash _ code ( ) { int hash = 1 ; if ( <%> <*> country -> group </%> _ <%> <*> code -> name </%> . length ! = 0 ) hash ^ = <%> <*> country -> group </%> _ <%> <*> code -> name </%> . get _ hash _ code ( ) ; hash ^ = <%> <*> domain -> domains </%> . get _ hash _ code ( ) ; if ( unknown _ fields ! = null ) { hash ^ = unknown _ fields . get _ hash _ code ( ) ; }
if ( unknown _ fields ! = null ) { hash ^ = unknown _ fields . get _ hash _ code ( ) ; } return hash ; } global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute public override string to _ string ( ) { return pb : : json _ formatter . to _ diagnostic _ string ( this ) ; } global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute
output . write _ raw _ tag ( NUM ) ; output . write _ string ( <%> <*> country -> group </%> _ <%> <*> code -> name </%> ) ; } <%> <*> domain -> domains </%> . write _ to ( output , repeated _ <%> <*> domain -> domains </%> _ codec ) ; if ( unknown _ fields ! = null ) { unknown _ fields . write _ to ( output ) ; } } global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute public int calculate _ size ( ) {
if ( unknown _ fields ! = null ) { unknown _ fields . write _ to ( output ) ; } } global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute public int calculate _ size ( ) { int size = 0 ; if ( <%> <*> country -> group </%> _ <%> <*> code -> name </%> . length ! = 0 ) { size + = 1 + pb : : coded _ output _ stream . compute _ string _ size ( <%> <*> country -> group </%> _ <%> <*> code -> name </%> ) ; }
if ( unknown _ fields ! = null ) { size + = unknown _ fields . calculate _ size ( ) ; } return size ; } global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute public void merge _ from ( geosite other ) { if ( other = = null ) { return ; }
break ; } case NUM : { <%> <*> domain -> domains </%> . add _ entries _ from ( input , repeated _ <%> <*> domain -> domains </%> _ codec ) ; break ; } } } } }
break ; } } } } } public sealed partial class geosite _ list : pb : : i _ message < geosite _ list > { private static readonly pb : : message _ parser < geosite _ list > parser = new pb : : message _ parser < geosite _ list > ( ( ) = > new geosite _ list ( ) ) ; private pb : : unknown _ field _ set unknown _ fields ; global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute
= pb : : field _ codec . for _ message ( NUM , global :: geosite . parser ) ; private readonly pbc : : repeated _ field < global :: geosite > <%> <*> entry -> entries </%> = new pbc : : repeated _ field < global :: geosite > ( ) ; global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute public pbc : : repeated _ field < global :: geosite > <%> <*> entry -> entries </%> { get { return <%> <*> entry -> entries </%> ; } } global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute public override bool equals ( object other ) { return equals ( other as geosite _ list ) ; }
} global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute public override bool equals ( object other ) { return equals ( other as geosite _ list ) ; } global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute public bool equals ( geosite _ list other ) { if ( reference _ equals ( other , null ) ) { return false ; }
return equals ( unknown _ fields , other . unknown _ fields ) ; } global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute public override int get _ hash _ code ( ) { int hash = 1 ; hash ^ = <%> <*> entry -> entries </%> . get _ hash _ code ( ) ; if ( unknown _ fields ! = null ) { hash ^ = unknown _ fields . get _ hash _ code ( ) ; } return hash ;
static geosite _ updater ( ) { if ( ! file . exists ( database _ path ) ) { file . write _ all _ bytes ( database _ path , resources . dlc _ dat ) ; } <%> <*> list = geosite _ list . parser . parse _ from ( file . read _ all _ bytes ( database _ path ) ) ; foreach ( var item in list . entry ) -> load _ geosite _ list ( ) ; </%> <%> <+> } </%>
{ geosites [ item . <%> <*> country -> group </%> _ <%> <*> code ] = item . domain -> name </%> . to _ <%> <*> list -> lower </%> ( ) <%> <+> ] = item . domains </%> ; } <%> <+> } public static void update _ pac _ from _ geosite ( configuration config ) { string gfw _ list _ url = geosite _ url ; if ( ! string . is _ null _ or _ white _ space ( config . gfw _ list _ url ) ) { logger . info ( STR ) ; </%>
} <%> <+> } public static void update _ pac _ from _ geosite ( configuration config ) { string gfw _ list _ url = geosite _ url ; if ( ! string . is _ null _ or _ white _ space ( config . gfw _ list _ url ) ) { logger . info ( STR ) ; gfw _ list _ url = config . gfw _ list _ url ; } </%>
line = line . replace ( STR , STR ) ; if ( line . starts _ with ( STR ) ) <%> <+> while ( line . starts _ with ( STR ) ) </%> line = line . substring ( 2 ) ; else if ( line . starts _ with ( STR ) ) line = line . <%> <*> substring -> trim _ start </%> ( <%> <*> 1 -> '|' </%> ) ; else if ( line . starts _ with ( STR ) ) line = line . <%> <*> substring -> trim _ start </%> ( <%> <*> 1 -> '.' </%> ) ; if ( line . starts _ with ( STR ) ) continue ;
else if ( line . starts _ with ( STR ) ) line = line . <%> <*> substring -> trim _ start </%> ( <%> <*> 1 -> '|' </%> ) ; else if ( line . starts _ with ( STR ) ) line = line . <%> <*> substring -> trim _ start </%> ( <%> <*> 1 -> '.' </%> ) ; if ( line . starts _ with ( STR ) ) continue ; else if ( line . starts _ with ( STR ) ) continue ; else if ( line . starts _ with ( STR ) ) continue ;
else if ( line . starts _ with ( STR ) ) line = line . <%> <*> substring -> trim _ start </%> ( <%> <*> 1 -> '.' </%> ) ; if ( line . starts _ with ( STR ) ) continue ; else if ( line . starts _ with ( STR ) ) continue ; else if ( line . starts _ with ( STR ) ) continue ; <%> <+> int pos = line . index _ of _ any ( new char [ ] { '/' } ) ; if ( pos > = 0 ) </%>
if ( line . starts _ with ( STR ) ) continue ; else if ( line . starts _ with ( STR ) ) continue ; else if ( line . starts _ with ( STR ) ) continue ; <%> <+> int pos = line . index _ of _ any ( new char [ ] { '/' } ) ; if ( pos > = 0 ) line = line . substring ( 0 , pos ) ; if ( line . length > 0 ) </%>
} public string [ ] get _ reduced _ domains ( ) { string [ ] domains = get _ domains ( ) ; list < string > new _ domains = new list < string > ( domains . length ) ; tld _ index tld _ index = get _ tld _ index ( ) ; foreach ( string domain in domains ) { string last _ root _ domain = null ; int pos ;
{ e = new exception ( n . get _ string ( STR , config . local _ port ) , e ) ; <%> <+> } else if ( se . socket _ error _ code = = socket _ error . access _ denied ) { e = new exception ( n . get _ string ( STR , config . local _ port ) , e ) ; </%> } } logging . log _ useful _ exception ( e ) ; report _ error ( e ) ;
} }
initialize _ component ( ) ; <%> <-> this . </%> servers _ list _ box . dock = dock _ style . fill ; <%> <-> this . </%> table _ layout _ panel . dock = dock _ style . fill ; <%> <-> this . </%> perform _ layout ( ) ; update _ texts ( ) ; setup _ value _ changed _ listeners ( ) ; <%> <-> this . </%> icon = icon . from _ handle ( resources . ssw . get _ hicon ( ) ) ; this . controller = controller ; controller . config _ changed + = controller _ config _ changed ; load _ current _ configuration ( ) ;
update _ texts ( ) ; setup _ value _ changed _ listeners ( ) ; <%> <-> this . </%> icon = icon . from _ handle ( resources . ssw . get _ hicon ( ) ) ; this . controller = controller ; controller . config _ changed + = controller _ config _ changed ; load _ current _ configuration ( ) ; } private void update _ texts ( ) { add _ button . text = n . get _ string ( STR ) ;
this . controller = controller ; controller . config _ changed + = controller _ config _ changed ; load _ current _ configuration ( ) ; } private void update _ texts ( ) { add _ button . text = n . get _ string ( STR ) ; delete _ button . text = n . get _ string ( STR ) ; duplicate _ button . text = n . get _ string ( STR ) ; ip _ label . text = n . get _ string ( STR ) ;
remarks _ label . text = n . get _ string ( STR ) ; timeout _ label . text = n . get _ string ( STR ) ; server _ group _ box . text = n . get _ string ( STR ) ; ok _ button . text = n . get _ string ( STR ) ; my _ cancel _ button . text = n . get _ string ( STR ) ; apply _ button . text = n . get _ string ( STR ) ; move _ up _ button . text = n . get _ string ( STR ) ; move _ down _ button . text = n . get _ string ( STR ) ; <%> <-> this . </%> text = n . get _ string ( STR ) ; }
} private void setup _ value _ changed _ listeners ( ) { ip _ text _ box . text _ changed + = config _ value _ changed ; proxy _ port _ text _ box . text _ changed + = config _ value _ changed ; password _ text _ box . text _ changed + = config _ value _ changed ; encryption _ select . selected _ index _ changed + = config _ value _ changed ; plugin _ text _ box . text _ changed + = config _ value _ changed ; plugin _ arguments _ text _ box . text _ changed + = config _ value _ changed ; plugin _ options _ text _ box . text _ changed + = config _ value _ changed ;
{ try { if ( last _ selected _ index = = - 1 | | last _ selected _ index > = modified _ configuration . configs . count ) { return true ; } <%> <*> server server -> bool verify </%> = get _ server _ details _ from _ ui ( <%> <+> out server server , is _ save , is _ copy </%> ) ; if ( server <%> <*> = -> ! </%> = null ) {
return true ; }
load _ server _ name _ list _ to _ ui ( modified _ configuration ) ; <%> <-> servers _ list _ box . selected _ index = modified _ configuration . configs . count - 1 ; last _ selected _ index = servers _ list _ box . selected _ index ; } private void duplicate _ button _ click ( object sender , event _ args e ) { if ( last _ selected _ index = = - 1 | | last _ selected _ index > modified _ configuration . configs . count | | ! validate _ and _ save _ selected _ server _ details ( ) ) { return ; </%>
load _ selected _ server _ details ( ) ; update _ buttons ( ) ; } <%> <+> private void update _ buttons ( ) { delete _ button . enabled = ( servers _ list _ box . items . count > 0 ) ; move _ up _ button . enabled = ( servers _ list _ box . selected _ index > 0 ) ; move _ down _ button . enabled = ( servers _ list _ box . selected _ index < servers _ list _ box . items . count - 1 ) ; } </%> private void <%> <*> ok -> move _ up </%> _ button _ click ( object sender , event _ args e )
} private void move _ config _ item ( int step ) { int index = servers _ list _ box . selected _ index ; server server = modified _ configuration . configs [ index ] ; object item = servers _ list _ box . items [ index ] ; modified _ configuration . configs . remove ( server ) ; modified _ configuration . configs . insert ( index + step , server ) ; modified _ configuration . index + = step ; servers _ list _ box . begin _ update ( ) ;
} private void show _ passwd _ check _ box _ checked _ changed ( object sender , event _ args e ) { <%> <-> this . </%> password _ text _ box . use _ system _ password _ char = ! <%> <-> this . </%> show _ passwd _ check _ box . checked ; } private void use _ plugin _ arg _ check _ box _ checked _ changed ( object sender , event _ args e ) { show _ hide _ plugin _ arg _ input ( <%> <-> this . </%> need _ plugin _ arg _ check _ box . checked ) ; } }
} private void use _ plugin _ arg _ check _ box _ checked _ changed ( object sender , event _ args e ) { show _ hide _ plugin _ arg _ input ( <%> <-> this . </%> need _ plugin _ arg _ check _ box . checked ) ; } } }
} } }
namespace shadowsocks _ model { serializable public class configuration { public string version ; public list < server > configs ; public string strategy ; public int index ; public bool global ;
public server get _ current _ server ( ) { if ( index > = 0 & & index < configs . count ) return configs [ index ] ; else return get _ default _ server ( ) ; } public static void check _ server ( server server ) { <%> <+> check _ server ( server . server ) ; </%>
check _ timeout ( server . timeout , server . max _ server _ timeout _ sec ) ; <%> <+> } public static bool checks _ server ( server server ) { try { check _ server ( server ) ; return true ; } catch ( exception ) </%>
{ if ( config ! = null & & config . configs ! = null ) { server = ( server ? ? get _ default _ server ( ) ) ; <%> <*> config . configs . add ( server ) ; -> config . configs . insert ( index . get _ value _ or _ default ( config . configs . count ) , server ) ; </%> } return server ; } public static server get _ default _ server ( )
} return server ; } public static server get _ default _ server ( ) { return new server ( ) ; } private static void assert ( bool condition ) { if ( ! condition )
private void pac _ file _ watcher _ changed ( object sender , file _ system _ event _ args e ) { <%> <-> string path = e . full _ path . to _ string ( ) ; string current _ last _ write _ time = file . get _ last _ write _ time ( e . full _ path ) . to _ string ( culture _ info . invariant _ culture ) ; if ( ! file _ changed _ time . contains _ key ( path ) | | file _ changed _ time [ path ] . to _ string ( ) ! = current _ last _ write _ time ) { </%> if ( pac _ file _ changed ! = null ) { logging . info ( $ STR ) ; <%> <+> task . factory . start _ new ( ( ) = > </%>
pac _ file _ changed ( this , new event _ args ( ) ) ; <%> <*> } file _ changed _ time [ path ] = current _ last _ write _ time ; -> ( ( file _ system _ watcher ) sender ) . enable _ raising _ events = true ; </%> <%> <+> } ) ; </%> } } private void user _ rule _ file _ watcher _ changed ( object sender , file _ system _ event _ args e ) { <%> <-> string path = e . full _ path . to _ string ( ) ; </%>
} } private void user _ rule _ file _ watcher _ changed ( object sender , file _ system _ event _ args e ) { <%> <-> string path = e . full _ path . to _ string ( ) ; string current _ last _ write _ time = file . get _ last _ write _ time ( e . full _ path ) . to _ string ( culture _ info . invariant _ culture ) ; if ( ! file _ changed _ time . contains _ key ( path ) | | file _ changed _ time [ path ] . to _ string ( ) ! = current _ last _ write _ time ) { </%> if ( user _ rule _ file _ changed ! = null ) {
user _ rule _ file _ changed ( this , new event _ args ( ) ) ; <%> <*> } file _ changed _ time [ path ] = current _ last _ write _ time ; -> ( ( file _ system _ watcher ) sender ) . enable _ raising _ events = true ; </%> <%> <+> } ) ; </%> } } private string get _ pac _ address ( byte [ ] request _ buf , int length , ip _ end _ point local _ end _ point , bool use _ socks ) { return ( use _ socks ? STR : STR ) + local _ end _ point . address + STR + this . config . local _ port + STR ;
} } private string get _ pac _ address ( byte [ ] request _ buf , int length , ip _ end _ point local _ end _ point , bool use _ socks ) { return ( use _ socks ? STR : STR ) + local _ end _ point . address + STR + this . config . local _ port + STR ; } } }
using n _ log ; <%> <-> using microsoft _ win ; </%> using shadowsocks _ controller ; using shadowsocks _ controller _ hotkeys ; using shadowsocks _ util ; using shadowsocks _ view ; <%> <+> using system ; using system _ collections _ generic ; using system _ diagnostics ; using system _ io ; </%>
using shadowsocks _ controller ; using shadowsocks _ controller _ hotkeys ; using shadowsocks _ util ; using shadowsocks _ view ; <%> <+> using system ; using system _ collections _ generic ; using system _ diagnostics ; using system _ io ; using system _ i _ pipes ; </%> using system _ linq ;
using system _ text ; using system _ <%> <*> net -> threading </%> ; using system _ threading _ tasks ; using system _ <%> <*> collections -> windows </%> _ <%> <*> generic -> forms </%> ; namespace shadowsocks { <%> <+> internal </%> static class program { private static <%> <+> readonly </%> logger logger = log _ manager . get _ current _ class _ logger ( ) ; public static shadowsocks _ controller main _ controller { get ; private set ; }
using system _ threading _ tasks ; using system _ <%> <*> collections -> windows </%> _ <%> <*> generic -> forms </%> ; namespace shadowsocks { <%> <+> internal </%> static class program { private static <%> <+> readonly </%> logger logger = log _ manager . get _ current _ class _ logger ( ) ; public static shadowsocks _ controller main _ controller { get ; private set ; } public static menu _ view _ controller menu _ controller { get ; private set ; } public static string [ ] args { get ; private set ; }
namespace shadowsocks { <%> <+> internal </%> static class program { private static <%> <+> readonly </%> logger logger = log _ manager . get _ current _ class _ logger ( ) ; public static shadowsocks _ controller main _ controller { get ; private set ; } public static menu _ view _ controller menu _ controller { get ; private set ; } public static string [ ] args { get ; private set ; } sta _ thread <%> <+> private </%> static void main ( string [ ] args )
{ private static <%> <+> readonly </%> logger logger = log _ manager . get _ current _ class _ logger ( ) ; public static shadowsocks _ controller main _ controller { get ; private set ; } public static menu _ view _ controller menu _ controller { get ; private set ; } public static string [ ] args { get ; private set ; } sta _ thread <%> <+> private </%> static void main ( string [ ] args ) { directory . set _ current _ directory ( application . startup _ path ) ; model . n _ log _ config . touch _ and _ apply _ n _ log _ config ( ) ;
public static shadowsocks _ controller main _ controller { get ; private set ; } public static menu _ view _ controller menu _ controller { get ; private set ; } public static string [ ] args { get ; private set ; } sta _ thread <%> <+> private </%> static void main ( string [ ] args ) { directory . set _ current _ directory ( application . startup _ path ) ; model . n _ log _ config . touch _ and _ apply _ n _ log _ config ( ) ; <%> <-> system . net . </%> service _ point _ manager . security _ protocol | = <%> <-> system . net . </%> security _ protocol _ type . tls | <%> <-> system . net . </%> security _ protocol _ type . tls | <%> <-> system . net . </%> security _ protocol _ type . tls ;
{ directory . set _ current _ directory ( application . startup _ path ) ; model . n _ log _ config . touch _ and _ apply _ n _ log _ config ( ) ; <%> <-> system . net . </%> service _ point _ manager . security _ protocol | = <%> <-> system . net . </%> security _ protocol _ type . tls | <%> <-> system . net . </%> security _ protocol _ type . tls | <%> <-> system . net . </%> security _ protocol _ type . tls ; args = args ; if ( ! utils . is _ win _ vista _ or _ higher ( ) ) { message _ box . show ( n . get _ string ( STR ) , STR , message _ box _ buttons . ok , message _ box _ icon . error ) ;
args = args ; if ( ! utils . is _ win _ vista _ or _ higher ( ) ) { message _ box . show ( n . get _ string ( STR ) , STR , message _ box _ buttons . ok , message _ box _ icon . error ) ; return ; } if ( ! utils . is _ supported _ runtime _ version ( ) ) { if ( dialog _ result . ok = = message _ box . show ( n . get _ string ( STR , STR ) ,
int urlidx = alist . index _ of ( STR ) + 1 ; if ( urlidx > 0 ) { <%> <+> if ( args . length < = urlidx ) { return ; } if ( ! pipe _ exist ) { added _ url = args [ urlidx ] ; </%>
else if ( pipe _ exist ) { process [ ] old _ processes = process . get _ processes _ by _ name ( STR ) ; if ( old _ processes . length > 0 ) { process old _ process = old _ processes [ 0 ] ; } message _ box . show ( n . get _ string ( STR ) + environment . new _ line + n . get _ string ( STR ) ,
{ public rectangle target _ rect ; public qr _ code _ splash _ form ( ) { <%> <+> form _ border _ style = form _ border _ style . none ; </%>
public event event _ handler config _ changed ; public event event _ handler enable _ status _ changed ; <%> <-> public event event _ handler < error _ event _ args > local _ fail _ to _ start ; </%> public event event _ handler < path _ event _ args > pac _ file _ ready _ to _ open ; public shadowsocks _ controller ( ) { config = configuration . load ( ) ; polipo _ runner = new polipo _ runner ( ) ; polipo _ runner . start ( config . get _ current _ server ( ) ) ; local = new local ( config . get _ current _ server ( ) ) ;
public event event _ handler < path _ event _ args > pac _ file _ ready _ to _ open ; public shadowsocks _ controller ( ) { config = configuration . load ( ) ; polipo _ runner = new polipo _ runner ( ) ; polipo _ runner . start ( config . get _ current _ server ( ) ) ; local = new local ( config . get _ current _ server ( ) ) ; try { local . start ( ) ;
enable _ item . checked = controller . get _ configuration ( ) . enabled ; } private void <%> <+> cinfig _ </%> form _ load ( object sender , event _ args e ) { if ( ! controller . get _ configuration ( ) . is _ default ) { this . opacity = 0 ; begin _ invoke ( new method _ invoker ( delegate { this . hide ( ) ;
{ if ( ! controller . get _ configuration ( ) . is _ default ) { this . opacity = 0 ; begin _ invoke ( new method _ invoker ( delegate { this . hide ( ) ; } ) ) ; } }
{ controller . stop ( ) ; } private void about <%> <-> _ tool _ strip _ menu </%> _ item _ click ( object sender , event _ args e ) { process . start ( STR ) ; } private void notify _ icon _ double _ click ( object sender , event _ args e ) { show _ window ( ) ;
this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ; this . <%> <+> ip _ </%> text _ box = new system . windows . forms . text _ box ( ) ; this . <%> <+> server _ port _ </%> text _ box = new system . windows . forms . text _ box ( ) ; this . <%> <+> password _ </%> text _ box = new system . windows . forms . text _ box ( ) ; this . <%> <+> proxy _ port _ </%> text _ box = new system . windows . forms . text _ box ( ) ; this . notify _ icon = new system . windows . forms . notify _ icon ( this . components ) ; this . panel = new system . windows . forms . panel ( ) ; this . <%> <+> ok _ </%> button = new system . windows . forms . button ( ) ; this . <%> <+> my _ cancel _ </%> button = new system . windows . forms . button ( ) ;
this . notify _ icon = new system . windows . forms . notify _ icon ( this . components ) ; this . panel = new system . windows . forms . panel ( ) ; this . <%> <+> ok _ </%> button = new system . windows . forms . button ( ) ; this . <%> <+> my _ cancel _ </%> button = new system . windows . forms . button ( ) ; this . panel = new system . windows . forms . panel ( ) ; this . context _ menu = new system . windows . forms . context _ menu ( ) ; this . enable _ item = new system . windows . forms . menu _ item ( ) ; this . config _ item = new system . windows . forms . menu _ item ( ) ; <%> <+> this . edit _ pac _ file _ item = new system . windows . forms . menu _ item ( ) ; </%> this . about _ item = new system . windows . forms . menu _ item ( ) ;
this . panel = new system . windows . forms . panel ( ) ; this . context _ menu = new system . windows . forms . context _ menu ( ) ; this . enable _ item = new system . windows . forms . menu _ item ( ) ; this . config _ item = new system . windows . forms . menu _ item ( ) ; <%> <+> this . edit _ pac _ file _ item = new system . windows . forms . menu _ item ( ) ; </%> this . about _ item = new system . windows . forms . menu _ item ( ) ; this . menu _ item = new system . windows . forms . menu _ item ( ) ; this . quit _ item = new system . windows . forms . menu _ item ( ) ; <%> <*> this . edit _ pac _ file _ item = new system . windows . forms . menu _ item ( ) ; -> this . table _ layout _ panel = new system . windows . forms . table _ layout _ panel ( ) ; </%>
this . table _ layout _ panel . suspend _ layout ( ) ; this . panel . suspend _ layout ( ) ; <%> <+> this . table _ layout _ panel . suspend _ layout ( ) ; this . table _ layout _ panel . suspend _ layout ( ) ; </%> this . suspend _ layout ( ) ; this . table _ layout _ panel . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( ( system . windows . forms . anchor _ styles . top | system . windows . forms . anchor _ styles . left ) | system . windows . forms . anchor _ styles . right ) ) ) ; this . table _ layout _ panel . auto _ size = true ; this . table _ layout _ panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . table _ layout _ panel . column _ count = 2 ;
this . table _ layout _ panel . controls . add ( this . label , 0 , 2 ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . <%> <+> ip _ </%> text _ box , 1 , 0 ) ; this . table _ layout _ panel . controls . add ( this . <%> <+> server _ port _ </%> text _ box , 1 , 1 ) ; this . table _ layout _ panel . controls . add ( this . <%> <+> password _ </%> text _ box , 1 , 2 ) ; this . table _ layout _ panel . controls . add ( this . <%> <+> proxy _ port _ </%> text _ box , 1 , NUM ) ; this . table _ layout _ panel . location = new system . drawing . point ( NUM , NUM ) ; this . table _ layout _ panel . margin = new system . windows . forms . padding ( NUM ) ; this . table _ layout _ panel . name = STR ; this . table _ layout _ panel . padding = new system . windows . forms . padding ( NUM ) ;
this . table _ layout _ panel . margin = new system . windows . forms . padding ( NUM ) ; this . table _ layout _ panel . name = STR ; this . table _ layout _ panel . padding = new system . windows . forms . padding ( NUM ) ; this . table _ layout _ panel . row _ count = NUM ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ;
STR , STR , STR , STR , STR , STR , STR } ) ; this . <%> <*> combo -> encryption </%> _ <%> <*> box -> select </%> . location = new system . drawing . point ( NUM , NUM ) ; this . <%> <*> combo -> encryption </%> _ <%> <*> box -> select </%> . name = STR ; this . <%> <*> combo -> encryption </%> _ <%> <*> box -> select </%> . size = new system . drawing . size ( NUM , NUM ) ;
<%> <*> this . panel . anchor = system . windows . forms . anchor _ styles . top ; -> this . panel . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( ( system . windows . forms . anchor _ styles . top | system . windows . forms . anchor _ styles . bottom ) </%> <%> <+> | system . windows . forms . anchor _ styles . right ) ) ) ; </%> this . panel . auto _ size = true ; this . panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . panel . controls . add ( this . <%> <+> my _ cancel _ </%> button ) ; this . panel . controls . add ( this . <%> <+> ok _ </%> button ) ; this . panel . location = new system . drawing . point ( NUM , NUM ) ; this . panel . name = STR ; this . panel . size = new system . drawing . size ( NUM , NUM ) ;
this . panel . auto _ size = true ; this . panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . panel . controls . add ( this . <%> <+> my _ cancel _ </%> button ) ; this . panel . controls . add ( this . <%> <+> ok _ </%> button ) ; this . panel . location = new system . drawing . point ( NUM , NUM ) ; this . panel . name = STR ; this . panel . size = new system . drawing . size ( NUM , NUM ) ; this . panel . tab _ index = 1 ; this . context _ menu . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . enable _ item ,
this . panel . name = STR ; this . panel . size = new system . drawing . size ( NUM , NUM ) ; this . panel . tab _ index = 1 ; this . context _ menu . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . enable _ item , this . config _ item , this . edit _ pac _ file _ item , this . about _ item , this . menu _ item , this . quit _ item } ) ;
this . menu _ item . index = NUM ; this . menu _ item . text = STR ; this . quit _ item . index = NUM ; this . quit _ item . text = STR ; this . quit _ item . click + = new system . event _ handler ( this . quit _ click ) ; this . edit _ pac _ file _ item . index = 2 ; this . edit _ pac _ file _ item . text = STR ; this . edit _ pac _ file _ item . click + = new system . event _ handler ( this . edit _ pac _ file _ item _ click ) ; this . accept _ button = this . button ; this . auto _ size = true ;
this . controls . add ( this . panel ) ; <%> <*> this . controls . add ( this . table _ layout _ panel ) ; this . controls . add ( this . panel ) ; -> this . form _ border _ style = system . windows . forms . form _ border _ style . fixed _ single ; </%> this . icon = ( ( system . drawing . icon ) ( resources . get _ object ( STR ) ) ) ; <%> <+> this . maximize _ box = false ; </%> this . name = STR ; this . start _ position = system . windows . forms . form _ start _ position . center _ screen ; this . text = STR ; this . form _ closed + = new system . windows . forms . form _ closed _ event _ handler ( this . <%> <+> config _ </%> form _ form _ closed ) ;
this . icon = ( ( system . drawing . icon ) ( resources . get _ object ( STR ) ) ) ; <%> <+> this . maximize _ box = false ; </%> this . name = STR ; this . start _ position = system . windows . forms . form _ start _ position . center _ screen ; this . text = STR ; this . form _ closed + = new system . windows . forms . form _ closed _ event _ handler ( this . <%> <+> config _ </%> form _ form _ closed ) ; this . load + = new system . event _ handler ( this . <%> <+> cinfig _ </%> form _ load ) ; this . table _ layout _ panel . resume _ layout ( false ) ; this . table _ layout _ panel . perform _ layout ( ) ; this . panel . resume _ layout ( false ) ;
this . table _ layout _ panel . resume _ layout ( false ) ; this . table _ layout _ panel . perform _ layout ( ) ; this . panel . resume _ layout ( false ) ; <%> <+> this . table _ layout _ panel . resume _ layout ( false ) ; this . table _ layout _ panel . perform _ layout ( ) ; this . table _ layout _ panel . resume _ layout ( false ) ; this . table _ layout _ panel . perform _ layout ( ) ; </%> this . resume _ layout ( false ) ; this . perform _ layout ( ) ; }
private system . windows . forms . notify _ icon notify _ icon ; private system . windows . forms . label label ; private system . windows . forms . combo _ box <%> <*> combo -> encryption </%> _ <%> <*> box -> select </%> ; private system . windows . forms . panel panel ; private system . windows . forms . button <%> <+> ok _ </%> button ; private system . windows . forms . button <%> <+> my _ cancel _ </%> button ; private system . windows . forms . panel panel ; private system . windows . forms . context _ menu context _ menu ; private system . windows . forms . menu _ item enable _ item ; private system . windows . forms . menu _ item about _ item ;
private system . windows . forms . panel panel ; private system . windows . forms . button <%> <+> ok _ </%> button ; private system . windows . forms . button <%> <+> my _ cancel _ </%> button ; private system . windows . forms . panel panel ; private system . windows . forms . context _ menu context _ menu ; private system . windows . forms . menu _ item enable _ item ; private system . windows . forms . menu _ item about _ item ; private system . windows . forms . menu _ item menu _ item ; private system . windows . forms . menu _ item quit _ item ; private system . windows . forms . menu _ item config _ item ;
private system . windows . forms . panel panel ; private system . windows . forms . context _ menu context _ menu ; private system . windows . forms . menu _ item enable _ item ; private system . windows . forms . menu _ item about _ item ; private system . windows . forms . menu _ item menu _ item ; private system . windows . forms . menu _ item quit _ item ; private system . windows . forms . menu _ item config _ item ; private system . windows . forms . menu _ item edit _ pac _ file _ item ; <%> <+> private system . windows . forms . table _ layout _ panel table _ layout _ panel ; private system . windows . forms . list _ view list _ view ; </%>
using system _ net ; using system _ io ; <%> <-> using system _ i _ compression ; using system _ security _ cryptography ; using system _ text _ regular _ expressions ; using shadowsocks _ model ; using shadowsocks _ properties ; </%> namespace shadowsocks _ controller { public class gfw _ list _ updater
namespace shadowsocks _ controller { public class gfw _ list _ updater { private const string gfwlist _ url = STR ; public i _ web _ proxy proxy = null ; public class gfw _ list _ download _ completed _ args : event _ args { public string content ; }
using system _ collections _ generic ; using system _ diagnostics ; using system _ io ; using system _ i _ compression ; using system _ net ; using system _ net _ sockets ; using system _ text ; <%> <-> using system _ text _ regular _ expressions ; </%> namespace shadowsocks _ controller {
namespace shadowsocks _ controller { class pac _ server { private static int port = NUM ; private static string pac _ file = STR ; private static configuration config ; socket listener ; file _ system _ watcher watcher ; public event event _ handler pac _ file _ changed ;
flash _ step = 0 ; x = 0 ; y = 0 ; w = width ; h = height ; <%> <+> sw = stopwatch . start _ new ( ) ; </%> timer = new timer ( ) ; timer . interval = ( int ) ( animation _ time * NUM / animation _ steps ) ; timer . tick + = timer _ tick ; timer . start ( ) ;
if ( flash _ step = = 0 ) { <%> <+> timer . interval = NUM ; </%> g . clear ( color . transparent ) ; set _ bitmap ( bitmap ) ; } else if ( flash _ step = = 1 ) { <%> <+> timer . interval = NUM ; </%> g . fill _ rectangle ( brush , x , y , w , h ) ;
registry . set _ value ( STR , pac _ url ) ; } } else { registry . set _ value ( STR , 0 ) ; <%> <-> if ( global ) { </%> registry . set _ value ( STR , STR ) ; <%> <-> } </%>
registry . set _ value ( STR , STR ) ; } ie _ auto _ detect _ proxy ( false ) ; system _ proxy . notify _ ie ( ) ; copy _ proxy _ setting _ from _ lan ( ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; message _ box . show ( n . get _ string ( STR ) ) ;
string before _ at = data . substring ( 0 , index _ last _ at ) ; string [ ] parts = before _ at . split ( new [ ] { ':' } ) ; <%> <-> this . </%> method = parts [ 0 ] ; <%> <-> this . </%> password = parts [ 1 ] ; } catch ( index _ out _ of _ range _ exception ) { throw new format _ exception ( ) ; } }
} catch ( index _ out _ of _ range _ exception ) { throw new format _ exception ( ) ; } } } }
return configs [ index ] ; <%> <-> } </%> else <%> <-> { </%> return get _ default _ server ( ) ; <%> <-> } </%> } public static void check _ server ( server server ) { check _ port ( server . server _ port ) ;
else <%> <-> { </%> return get _ default _ server ( ) ; <%> <-> } </%> } public static void check _ server ( server server ) { check _ port ( server . server _ port ) ; check _ password ( server . password ) ; check _ server ( server . server ) ;
return get _ default _ server ( ) ; <%> <-> } </%> } public static void check _ server ( server server ) { check _ port ( server . server _ port ) ; check _ password ( server . password ) ; check _ server ( server . server ) ; } public static configuration load ( )
} public static void check _ server ( server server ) { check _ port ( server . server _ port ) ; check _ password ( server . password ) ; check _ server ( server . server ) ; } public static configuration load ( ) { try
config . local _ port = NUM ; <%> <*> } if ( config . index = = - 1 ) { if ( config . strategy = = null ) { -> if ( config . index = = - 1 & & config . strategy = = null ) </%> config . index = 0 ; <%> <-> } } </%> return config ;
return config ; } catch ( exception e ) { if ( ! ( e is file _ not _ found _ exception ) ) <%> <-> { </%> logging . log _ useful _ exception ( e ) ; <%> <-> } </%> return new configuration {
logging . log _ useful _ exception ( e ) ; <%> <-> } </%> return new configuration { index = 0 , is _ default = true , local _ port = NUM , auto _ check _ update = true , configs = new list < server > ( ) {
return new configuration { index = 0 , is _ default = true , local _ port = NUM , auto _ check _ update = true , configs = new list < server > ( ) { get _ default _ server ( ) }
config . index = config . configs . count - 1 ; <%> <-> } </%> if ( config . index < - 1 ) <%> <-> { </%> config . index = - 1 ; <%> <*> } if ( config . index = = - 1 ) { if ( config . strategy = = null ) { -> if ( config . index = = - 1 & & config . strategy = = null ) </%>
if ( config . index < - 1 ) <%> <-> { </%> config . index = - 1 ; <%> <*> } if ( config . index = = - 1 ) { if ( config . strategy = = null ) { -> if ( config . index = = - 1 & & config . strategy = = null ) </%> config . index = 0 ; <%> <-> } </%>
config . index = - 1 ; <%> <*> } if ( config . index = = - 1 ) { if ( config . strategy = = null ) { -> if ( config . index = = - 1 & & config . strategy = = null ) </%> config . index = 0 ; <%> <-> } } </%> config . is _ default = false ;
config . is _ default = false ; try { using ( stream _ writer sw = new stream _ writer ( file . open ( config _ file , file _ mode . create ) ) ) { string json _ string = json _ convert . serialize _ object ( config , formatting . indented ) ; sw . write ( json _ string ) ; sw . flush ( ) ; } }
throw new exception ( n . get _ string ( STR ) ) ; <%> <-> } </%> } public static void check _ port ( int port ) { if ( port < = 0 | | port > NUM ) <%> <-> { </%> throw new argument _ exception ( n . get _ string ( STR ) ) ; <%> <-> } </%> }
} public static void check _ port ( int port ) { if ( port < = 0 | | port > NUM ) <%> <-> { </%> throw new argument _ exception ( n . get _ string ( STR ) ) ; <%> <-> } </%> } public static void check _ local _ port ( int port ) {
throw new argument _ exception ( n . get _ string ( STR ) ) ; <%> <-> } </%> } public static void check _ local _ port ( int port ) { check _ port ( port ) ; if ( port = = NUM ) <%> <-> { </%> throw new argument _ exception ( n . get _ string ( STR ) ) ; <%> <-> } </%>
} public static void check _ local _ port ( int port ) { check _ port ( port ) ; if ( port = = NUM ) <%> <-> { </%> throw new argument _ exception ( n . get _ string ( STR ) ) ; <%> <-> } </%> } private static void check _ password ( string password )
throw new argument _ exception ( n . get _ string ( STR ) ) ; <%> <-> } </%> } private static void check _ password ( string password ) { if ( string . is _ null _ or _ empty ( password ) ) <%> <-> { </%> throw new argument _ exception ( n . get _ string ( STR ) ) ; <%> <-> } </%> }
} private static void check _ password ( string password ) { if ( string . is _ null _ or _ empty ( password ) ) <%> <-> { </%> throw new argument _ exception ( n . get _ string ( STR ) ) ; <%> <-> } </%> } private static void check _ server ( string server ) {
throw new argument _ exception ( n . get _ string ( STR ) ) ; <%> <-> } </%> } private static void check _ server ( string server ) { if ( string . is _ null _ or _ empty ( server ) ) <%> <-> { </%> throw new argument _ exception ( n . get _ string ( STR ) ) ; <%> <-> } </%> }
} private static void check _ server ( string server ) { if ( string . is _ null _ or _ empty ( server ) ) <%> <-> { </%> throw new argument _ exception ( n . get _ string ( STR ) ) ; <%> <-> } </%> } } }
throw new argument _ exception ( n . get _ string ( STR ) ) ; <%> <-> } </%> } } }
} } }
using system _ diagnostics ; using system _ io ; <%> <-> using system _ linq ; </%> using system _ text ; <%> <-> using system _ threading _ tasks ; </%> using shadowsocks _ controller ; using shadowsocks _ properties ; namespace shadowsocks _ util _ system _ proxy { public static class sysproxy
using system _ text ; <%> <-> using system _ threading _ tasks ; </%> using shadowsocks _ controller ; using shadowsocks _ properties ; namespace shadowsocks _ util _ system _ proxy { public static class sysproxy { <%> <+> private static bool user _ settings _ recorded = false ; private static string [ ] user _ settings = new string [ NUM ] ; </%>
using shadowsocks _ controller ; using shadowsocks _ properties ; namespace shadowsocks _ util _ system _ proxy { public static class sysproxy { <%> <+> private static bool user _ settings _ recorded = false ; private static string [ ] user _ settings = new string [ NUM ] ; </%> enum ret _ errors : int {
} else { <%> <*> arguments = STR ; -> var flags = user _ settings [ 0 ] ; </%> <%> <+> var proxy _ server = user _ settings [ 1 ] ? ? STR ; var bypass _ list = user _ settings [ 2 ] ? ? STR ; var pac _ url = user _ settings [ NUM ] ? ? STR ; arguments = $ STR ; user _ settings _ recorded = false ; </%>
} <%> <+> exec _ sysproxy ( arguments , out str ) ; } private static void exec _ sysproxy ( string arguments , out string query _ str ) { </%> using ( var process = new process ( ) ) { process . start _ info . file _ name = utils . get _ temp _ path ( STR ) ; process . start _ info . arguments = arguments ; process . start _ info . working _ directory = utils . get _ temp _ path ( ) ;
process . wait _ for _ exit ( ) ; var exit _ code = process . exit _ code ; if ( exit _ code ! = ( int ) ret _ errors . ret _ no _ error ) { throw new proxy _ exception ( <%> <*> error -> stderr </%> ) ; } <%> <+> if ( arguments = = STR & & stdout . is _ null _ or _ white _ space ( ) ) { throw new proxy _ exception ( STR ) ; } </%>
} <%> <+> if ( arguments = = STR & & stdout . is _ null _ or _ white _ space ( ) ) { throw new proxy _ exception ( STR ) ; } query _ str = stdout ; } } private static void parse _ query _ str ( string str ) { </%>
} } else { sysproxy . set _ ie _ proxy ( false , false , <%> <*> STR -> null </%> , <%> <*> STR -> null </%> ) ; } } catch ( proxy _ exception ex ) { logging . log _ useful _ exception ( ex ) ;
} } catch ( proxy _ exception ex ) { logging . log _ useful _ exception ( ex ) ; } } } }
{ use _ socks = true ; } <%> <+> * / </%> } } else if ( kv . length = = 1 ) { if ( line . index _ of ( STR ) > = 0 ) { path _ match = true ;
} } else if ( kv . length = = 1 ) { if ( line . index _ of ( STR ) > = 0 ) { path _ match = true ; } } }
system _ proxy _ is _ dirty = true ; } else { if ( system _ proxy _ is _ dirty ) { system _ proxy . <%> <*> disable -> update </%> ( <%> <+> config , false </%> ) ; system _ proxy _ is _ dirty = false ; } }
system _ proxy _ is _ dirty = false ; } } } private void pac _ server _ pac _ file _ changed ( object sender , event _ args e ) { update _ system _ proxy ( ) ; } private void pac _ server _ pac _ update _ completed ( object sender , event _ args e ) {
{ <%> <+> bool global = config . global ; bool enabled = config . enabled ; if ( force _ disable ) { enabled = false ; } </%> try { registry _ key registry =
{ <%> <+> if ( global ) { </%> registry . set _ value ( STR , 1 ) ; registry . set _ value ( STR , STR <%> <+> + config . local _ port . to _ string ( ) </%> ) ; registry . set _ value ( STR , STR ) ; <%> <+> } else { registry . set _ value ( STR , 0 ) ; </%>
} else { registry . set _ value ( STR , 0 ) ; registry . set _ value ( STR , STR ) ; registry . set _ value ( STR , STR <%> <-> + get _ timestamp ( date _ time . now ) </%> ) ; } system _ proxy . notify _ ie ( ) ; <%> <-> copy _ proxy _ setting _ from _ lan ( ) ; } </%>
} system _ proxy . notify _ ie ( ) ; <%> <-> copy _ proxy _ setting _ from _ lan ( ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; message _ box . show ( n . get _ string ( STR ) ) ; } } </%>
copy _ proxy _ setting _ from _ lan ( ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; message _ box . show ( n . get _ string ( STR ) ) ; } } private static void copy _ proxy _ setting _ from _ lan ( ) {
} if ( changed ) { <%> <+> log _ message _ </%> text _ box . scroll _ to _ caret ( ) ; } last _ offset = reader . base _ stream . position ; } } private void log _ form _ load ( object sender , event _ args e ) {
} last _ offset = reader . base _ stream . position ; } } private void log _ form _ load ( object sender , event _ args e ) { init _ content ( ) ; timer = new timer ( ) ; timer . interval = NUM ; timer . tick + = timer _ tick ;
{ string argument = STR + filename ; system . diagnostics . process . start ( STR , argument ) ; } <%> <*> private void menu _ item _ click ( object sender , event _ args e ) { } private void menu _ item _ click ( object sender , event _ args e ) -> private void exit _ menu _ item _ click ( object sender , event _ args e ) </%> {
{ this . close ( ) ; } private void log _ form _ shown ( object sender , event _ args e ) { <%> <*> text _ box . scroll _ to _ caret ( ) ; -> log _ message _ text _ box . scroll _ to _ caret ( ) ; </%> <%> <+> } private void wrap _ text _ check _ box _ checked _ changed ( object sender , event _ args e ) { </%>
} } }
this . context _ menu _ strip = new system . windows . forms . context _ menu _ strip ( this . components ) ; this . main _ menu = new system . windows . forms . main _ menu ( this . components ) ; <%> <*> this . menu _ item = new system . windows . forms . menu _ item ( ) ; this . menu _ item = new system . windows . forms . menu _ item ( ) ; this . menu _ item = new system . windows . forms . menu _ item ( ) ; -> this . file _ menu _ item = new system . windows . forms . menu _ item ( ) ; </%> <%> <+> this . open _ location _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . exit _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . panel = new system . windows . forms . panel ( ) ; this . change _ font _ button = new system . windows . forms . button ( ) ; </%>
this . suspend _ layout ( ) ; this . text _ box . back _ color = system . drawing . color . black ; this . text _ box . dock = system . windows . forms . dock _ style . fill ; this . context _ menu _ strip . name = STR ; this . context _ menu _ strip . size = new system . drawing . size ( NUM , NUM ) ; this . main _ menu . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . <%> <+> file _ </%> menu _ item } ) ; this . <%> <+> file _ </%> menu _ item . index = 0 ; this . <%> <+> file _ </%> menu _ item . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . <%> <+> open _ location _ </%> menu _ item ,
this . <%> <+> file _ </%> menu _ item . index = 0 ; this . <%> <+> file _ </%> menu _ item . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . <%> <+> open _ location _ </%> menu _ item , this . <%> <+> exit _ </%> menu _ item } ) ; this . <%> <+> file _ </%> menu _ item . text = STR ; this . <%> <+> open _ location _ </%> menu _ item . index = 0 ; this . <%> <+> open _ location _ </%> menu _ item . text = STR ; this . <%> <+> open _ location _ </%> menu _ item . click + = new system . event _ handler ( this . <%> <+> open _ location _ </%> menu _ item _ click ) ; this . menu _ item . index = 1 ; this . menu _ item . text = STR ;
this . <%> <+> open _ location _ </%> menu _ item . index = 0 ; this . <%> <+> open _ location _ </%> menu _ item . text = STR ; this . <%> <+> open _ location _ </%> menu _ item . click + = new system . event _ handler ( this . <%> <+> open _ location _ </%> menu _ item _ click ) ; this . menu _ item . index = 1 ; this . menu _ item . text = STR ; this . menu _ item . click + = new system . event _ handler ( this . menu _ item _ click ) ; this . auto _ scale _ mode = system . windows . forms . auto _ scale _ mode . font ; this . client _ size = new system . drawing . size ( NUM , NUM ) ; this . controls . add ( this . <%> <*> text -> table _ layout </%> _ <%> <*> box -> panel </%> ) ; this . menu = this . main _ menu ;
this . menu _ item . index = 1 ; this . menu _ item . text = STR ; this . menu _ item . click + = new system . event _ handler ( this . menu _ item _ click ) ; this . auto _ scale _ mode = system . windows . forms . auto _ scale _ mode . font ; this . client _ size = new system . drawing . size ( NUM , NUM ) ; this . controls . add ( this . <%> <*> text -> table _ layout </%> _ <%> <*> box -> panel </%> ) ; this . menu = this . main _ menu ; this . name = STR ; this . start _ position = system . windows . forms . form _ start _ position . center _ screen ; this . text = STR ;
this . menu = this . main _ menu ; this . name = STR ; this . start _ position = system . windows . forms . form _ start _ position . center _ screen ; this . text = STR ; this . form _ closing + = new system . windows . forms . form _ closing _ event _ handler ( this . log _ form _ form _ closing ) ; this . load + = new system . event _ handler ( this . log _ form _ load ) ; this . shown + = new system . event _ handler ( this . log _ form _ shown ) ; <%> <+> this . panel . resume _ layout ( false ) ; this . panel . perform _ layout ( ) ; this . table _ layout _ panel . resume _ layout ( false ) ; </%>
} private system . windows . forms . text _ box <%> <+> log _ message _ </%> text _ box ; private system . windows . forms . context _ menu _ strip context _ menu _ strip ; private system . windows . forms . main _ menu main _ menu ; <%> <*> private system . windows . forms . menu _ item menu _ item ; private system . windows . forms . menu _ item menu _ item ; private system . windows . forms . menu _ item menu _ item ; -> private system . windows . forms . menu _ item file _ menu _ item ; </%> <%> <+> private system . windows . forms . menu _ item open _ location _ menu _ item ; private system . windows . forms . menu _ item exit _ menu _ item ; </%>
private system . windows . forms . context _ menu _ strip context _ menu _ strip ; private system . windows . forms . main _ menu main _ menu ; <%> <*> private system . windows . forms . menu _ item menu _ item ; private system . windows . forms . menu _ item menu _ item ; private system . windows . forms . menu _ item menu _ item ; -> private system . windows . forms . menu _ item file _ menu _ item ; </%> <%> <+> private system . windows . forms . menu _ item open _ location _ menu _ item ; private system . windows . forms . menu _ item exit _ menu _ item ; private system . windows . forms . panel panel ; private system . windows . forms . check _ box wrap _ text _ check _ box ; </%>
} }
} } private static void check _ port ( int port ) { if ( port < = 0 | | port > NUM ) { throw new argument _ exception <%> <+> ( n . get _ string </%> ( STR ) <%> <+> ) </%> ; } } private static void check _ password ( string password )
} } private static void check _ password ( string password ) { if ( string . is _ null _ or _ empty ( password ) ) { throw new argument _ exception <%> <+> ( n . get _ string </%> ( STR ) <%> <+> ) </%> ; } } private static void check _ server ( string server )
} } private static void check _ server ( string server ) { if ( string . is _ null _ or _ empty ( server ) ) { throw new argument _ exception <%> <+> ( n . get _ string </%> ( STR ) <%> <+> ) </%> ; } } private static void check _ remark ( string remark )
} } private static void check _ remark ( string remark ) { } private class json _ serializer _ strategy : simple _ json . poco _ json _ serializer _ strategy { public override object deserialize _ object ( object value , type type ) { if ( type = = typeof ( int ) & & value . get _ type ( ) = = typeof ( string ) )
public event error _ event _ handler error ; <%> <+> public class result _ event _ args : event _ args { public bool success ; public result _ event _ args ( bool success ) { this . success = success ; } } </%> private void http _ download _ string _ completed ( object sender , download _ string _ completed _ event _ args e )
} } catch ( exception ex ) { if ( error ! = null ) { error ( this , new error _ event _ args ( ex ) ) ; } } }
stream _ writer _ with _ timestamp sw = new stream _ writer _ with _ timestamp ( fs ) ; sw . auto _ flush = true ; console . set _ out ( sw ) ; console . set _ error ( sw ) ; return true ; } catch ( io _ exception e ) { console . write _ line ( e . to _ string ( ) ) ; return false ;
} private void receive _ callback ( i _ async _ result ar ) { <%> <-> int length = ( int ) ar . async _ state ; </%> try { var bytes _ read = socket . end _ receive ( ar ) ; if ( bytes _ read = = 0 ) { on _ finish ( <%> <-> length </%> ) ;
try { var bytes _ read = socket . end _ receive ( ar ) ; if ( bytes _ read = = 0 ) { on _ finish ( <%> <-> length </%> ) ; return ; } <%> <+> buffer _ data _ length + = bytes _ read ; new _ package _ recv ( ) ; </%>
return ; } <%> <+> buffer _ data _ length + = bytes _ read ; new _ package _ recv ( ) ; } catch ( exception ex ) { on _ exception ( ex ) ; on _ finish ( ) ; } </%>
return ; } <%> <+> } </%> if ( buffer _ <%> <*> index > 0 ) -> data _ length = = line _ buffer . length ) </%> { <%> <-> buffer . block _ copy ( line _ buffer , buffer _ index , line _ buffer , 0 , length ) ; </%> <%> <*> buffer -> on _ exception ( new index _ out _ of _ range </%> _ <%> <*> index = 0 -> exception ( STR ) ) </%> ; <%> <-> } </%> <%> <+> on _ finish ( ) ; </%> <%> <*> socket . begin _ receive ( line _ buffer , length , line _ buffer . length - length , 0 , receive _ callback , length ) -> return </%> ; }
} private void on _ exception ( exception ex ) { on _ exception ? . invoke ( ex , state ) ; } private void on _ finish ( <%> <-> int length </%> ) { on _ finish ? . invoke ( line _ buffer , buffer <%> <+> _ data </%> _ index , <%> <+> buffer _ data _ </%> length , state ) ; } <%> <*> public -> private </%> static int index _ of ( byte [ ] haystack , int index , int length , byte [ ] needle , int [ ] offset _ table , int [ ] char _ table )
} <%> <*> public -> private </%> static int index _ of ( byte [ ] haystack , int index , int length , byte [ ] needle , int [ ] offset _ table , int [ ] char _ table ) { var end = index + length ; for ( int i = needle . length - 1 + index , j ; i < end ; ) { for ( j = needle . length - 1 ; needle [ j ] = = haystack [ i ] ; - - i , - - j ) { if ( j = = 0 ) {
{ var end = index + length ; for ( int i = needle . length - 1 + index , j ; i < end ; ) { for ( j = needle . length - 1 ; needle [ j ] = = haystack [ i ] ; - - i , - - j ) { if ( j = = 0 ) { return i ; }
using system _ runtime _ interop _ services ; <%> <-> using system _ text ; </%> using system _ io ; using shadowsocks _ model ; <%> <+> using shadowsocks _ util ; </%> namespace shadowsocks _ controller { public static class system _ proxy { dll _ import _ wininet _ dll
using system _ io ; using shadowsocks _ model ; <%> <+> using shadowsocks _ util ; </%> namespace shadowsocks _ controller { public static class system _ proxy { dll _ import _ wininet _ dll public static extern bool internet _ set _ option ( int _ ptr h _ internet , int dw _ option , int _ ptr lp _ buffer , int dw _ buffer _ length ) ; public const int internet _ option _ settings _ changed = NUM ;
} } private static void copy _ proxy _ setting _ from _ lan ( ) { <%> <*> var registry = registry . current _ user -> registry _ key registry = null ; try { registry = utils . open _ user _ reg _ key ( STR , true ) ; if ( registry = = null ) { logging . error ( STR ) ; </%> <%> <+> return ; </%>
var connections = registry . get _ value _ names ( ) ; <%> <*> foreach ( var each in connections ) { switch ( each . to _ upper _ invariant ( ) ) { -> foreach ( var each in connections ) { </%> <%> <+> switch ( each . to _ upper _ invariant ( ) ) { </%> case STR : case STR : case STR :
} } private static void ie _ auto _ detect _ proxy ( bool set ) { <%> <*> var registry = registry . current _ user -> registry _ key registry = null ; try { registry = utils . open _ user _ reg _ key ( STR , true ) ; if ( registry = = null ) { logging . error ( STR ) ; </%> <%> <+> return ; </%>
} <%> <-> else { def _ connection [ options _ offset ] = ( byte ) ( def _ connection [ options _ offset ] & ~ NUM ) ; saved _ legacy _ setting [ options _ offset ] = ( byte ) ( saved _ legacy _ setting [ options _ offset ] & ~ NUM ) ; } bit _ converter . get _ bytes ( unchecked ( bit _ converter . to _ u _ int ( def _ connection , version _ offset ) + 1 ) ) . copy _ to ( def _ connection , version _ offset ) ; bit _ converter . get _ bytes ( </%>
} } }
{ <%> <-> application . set _ unhandled _ exception _ mode ( unhandled _ exception _ mode . catch _ exception ) ; application . thread _ exception + = application _ thread _ exception ; app _ domain . current _ domain . unhandled _ exception + = current _ domain _ unhandled _ exception ; application . application _ exit + = application _ application _ exit ; system _ events . power _ mode _ changed + = system _ events _ power _ mode _ changed ; application . enable _ visual _ styles ( ) ; application . set _ compatible _ text _ rendering _ default ( false ) ; auto _ startup . register _ for _ restart ( true ) ; if ( ! mutex . wait _ one ( 0 , false ) ) </%>
{ process [ ] old _ processes = process . get _ processes _ by _ name ( STR ) ; if ( old _ processes . length > 0 ) { process old _ process = old _ processes [ 0 ] ; } message _ box . show ( n . get _ string ( STR ) + environment . new _ line + n . get _ string ( STR ) , n . get _ string ( STR ) ) ;
string privoxy _ log _ filename = utils . get _ temp _ path ( STR ) ; if ( file . exists ( privoxy _ log _ filename ) ) using ( new file _ stream ( privoxy _ log _ filename , file _ mode . truncate ) ) { } main _ controller = new shadowsocks _ controller ( ) ; menu _ controller = new menu _ view _ controller ( main _ controller ) ; hot _ keys . init ( main _ controller ) ; main _ controller . start ( ) ; application . run ( ) ; <%> <-> } </%> }
} private static int exited = 0 ; private static void current _ domain _ unhandled _ exception ( object sender , unhandled _ exception _ event _ args e ) { if ( interlocked . increment ( ref exited ) = = 1 ) { string err _ msg = e . exception _ object . to _ string ( ) ; logger . error ( err _ msg ) ; message _ box . show ( $ STR unexpected error , shadowsocks will exit . please report to STR ,
statistics _ chart . data _ source = data _ table ; load _ chart _ data ( ) ; statistics _ chart . data _ bind ( ) ; } private void cancel _ button _ click ( object sender , event _ args e ) { close ( ) ; } private void ok _ button _ click ( object sender , event _ args e ) {
foreach ( var data in final _ data ) { data _ table . rows . add ( data . timestamp <%> <+> , data . speed </%> , data . package _ loss <%> <+> _ percentage </%> , data . ping ) ; } statistics _ chart . data _ bind ( ) ; } private void server _ selector _ <%> <*> selected -> selection </%> _ <%> <*> index -> change </%> _ <%> <*> changed -> committed </%> ( object sender , event _ args e ) { load _ chart _ data ( ) ; <%> <-> } </%>
} statistics _ chart . data _ bind ( ) ; } private void server _ selector _ <%> <*> selected -> selection </%> _ <%> <*> index -> change </%> _ <%> <*> changed -> committed </%> ( object sender , event _ args e ) { load _ chart _ data ( ) ; <%> <-> } private void chart _ mode _ selector _ enter ( object sender , event _ args e ) { </%> }
{ load _ chart _ data ( ) ; <%> <-> } private void chart _ mode _ selector _ enter ( object sender , event _ args e ) { </%> } private void day _ mode _ checked _ changed ( object sender , event _ args e ) { load _ chart _ data ( ) ; }
} private void day _ mode _ checked _ changed ( object sender , event _ args e ) { load _ chart _ data ( ) ; } private void all _ mode _ checked _ changed ( object sender , event _ args e ) { load _ chart _ data ( ) ; } private void ping _ check _ box _ checked _ changed ( object sender , event _ args e )
this . chart _ mode _ selector . suspend _ layout ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . begin _ init ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . suspend _ layout ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . begin _ init ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . suspend _ layout ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . data _ collection _ minutes _ num ) ) . begin _ init ( ) ;
series . legend = STR ; series . name = STR ; series . <%> <*> x _ value -> tool </%> _ <%> <*> type -> tip </%> = <%> <*> system . windows . forms . data _ visualization . charting . chart _ value _ type . date _ time ; -> STR ; </%> <%> <-> series . y _ values _ per _ point = 2 ; series . border _ width = NUM ; </%> series . chart _ area = STR ; <%> <*> series . chart _ type = system . windows . forms . data _ visualization . charting . series _ chart _ type . line ; series . color = system . drawing . color . from _ argb ( ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) , ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) , ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) ) ; -> series . chart _ type = system . windows . forms . data _ visualization . charting . series _ chart _ type . bubble ; </%> <%> <+> series . color = system . drawing . color . crimson ; </%>
series . chart _ area = STR ; <%> <*> series . chart _ type = system . windows . forms . data _ visualization . charting . series _ chart _ type . line ; series . color = system . drawing . color . from _ argb ( ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) , ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) , ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) ) ; -> series . chart _ type = system . windows . forms . data _ visualization . charting . series _ chart _ type . bubble ; </%> <%> <+> series . color = system . drawing . color . crimson ; series . custom _ properties = STR ; </%> series . legend = STR ; series . name = STR ; series . <%> <*> x _ value -> tool </%> _ <%> <*> type -> tip </%> = <%> <*> system . windows . forms . data _ visualization . charting . chart _ value _ type . date _ time ; -> STR ; </%> <%> <+> series . y _ axis _ type = system . windows . forms . data _ visualization . charting . axis _ type . secondary ; </%>
series . legend = STR ; series . name = STR ; series . <%> <*> x _ value -> tool </%> _ <%> <*> type -> tip </%> = <%> <*> system . windows . forms . data _ visualization . charting . chart _ value _ type . date _ time ; -> STR ; </%> <%> <+> series . y _ axis _ type = system . windows . forms . data _ visualization . charting . axis _ type . secondary ; series . y _ values _ per _ point = 2 ; series . border _ width = NUM ; </%> series . chart _ area = STR ; <%> <*> series . chart _ type = system . windows . forms . data _ visualization . charting . series _ chart _ type . area ; -> series . chart _ type = system . windows . forms . data _ visualization . charting . series _ chart _ type . line ; </%> <%> <+> series . color = system . drawing . color . dodger _ blue ; </%>
series . chart _ area = STR ; <%> <*> series . chart _ type = system . windows . forms . data _ visualization . charting . series _ chart _ type . area ; -> series . chart _ type = system . windows . forms . data _ visualization . charting . series _ chart _ type . line ; </%> <%> <+> series . color = system . drawing . color . dodger _ blue ; </%> series . legend = STR ; <%> <+> series . marker _ size = NUM ; series . marker _ style = system . windows . forms . data _ visualization . charting . marker _ style . circle ; </%> series . name = STR ; <%> <+> series . tool _ tip = STR ; </%> this . statistics _ chart . series . add ( series ) ;
series . legend = STR ; <%> <+> series . marker _ size = NUM ; series . marker _ style = system . windows . forms . data _ visualization . charting . marker _ style . circle ; </%> series . name = STR ; <%> <+> series . tool _ tip = STR ; </%> this . statistics _ chart . series . add ( series ) ; this . statistics _ chart . series . add ( series ) ; this . statistics _ chart . series . add ( series ) ; this . statistics _ chart . size = new system . drawing . size ( NUM , NUM ) ; this . statistics _ chart . tab _ index = 2 ;
this . statistics _ chart . series . add ( series ) ; this . statistics _ chart . series . add ( series ) ; this . statistics _ chart . series . add ( series ) ; this . statistics _ chart . size = new system . drawing . size ( NUM , NUM ) ; this . statistics _ chart . tab _ index = 2 ; <%> <-> this . statistics _ chart . click + = new system . event _ handler ( this . statistics _ chart _ click ) ; </%> this . ping _ check _ box . auto _ size = true ; this . ping _ check _ box . data _ bindings . add ( new system . windows . forms . binding ( STR , this . binding _ configuration , STR , true ) ) ; this . ping _ check _ box . location = new system . drawing . point ( NUM , NUM ) ; this . ping _ check _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;
this . ping _ check _ box . auto _ size = true ; this . ping _ check _ box . data _ bindings . add ( new system . windows . forms . binding ( STR , this . binding _ configuration , STR , true ) ) ; this . ping _ check _ box . location = new system . drawing . point ( NUM , NUM ) ; this . ping _ check _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . ping _ check _ box . name = STR ; this . ping _ check _ box . size = new system . drawing . size ( NUM , NUM ) ; this . ping _ check _ box . tab _ index = NUM ; this . ping _ check _ box . text = STR ; this . ping _ check _ box . use _ visual _ style _ back _ color = true ; this . ping _ check _ box . checked _ changed + = new system . event _ handler ( this . ping _ check _ box _ checked _ changed ) ;
this . chart _ mode _ selector . resume _ layout ( false ) ; this . chart _ mode _ selector . perform _ layout ( ) ; this . split _ container . panel . resume _ layout ( false ) ; this . split _ container . panel . resume _ layout ( false ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . end _ init ( ) ; this . split _ container . resume _ layout ( false ) ; this . split _ container . panel . resume _ layout ( false ) ; this . split _ container . panel . perform _ layout ( ) ; this . split _ container . panel . resume _ layout ( false ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . end _ init ( ) ;
public static readonly mode byte = new mode ( new int [ ] { NUM , NUM , NUM } , 0 , STR ) ; <%> <-> public static readonly mode eci = new mode ( null , 0 , STR ) ; public static readonly mode kanji = new mode ( new int [ ] { NUM , NUM , NUM } , 0 , STR ) ; public static readonly mode fn _ first _ position = new mode ( null , 0 , STR ) ; public static readonly mode fn _ second _ position = new mode ( null , 0 , STR ) ; public static readonly mode hanzi = new mode ( new int [ ] { NUM , NUM , NUM } , 0 d , STR ) ; </%> private readonly int [ ] character _ count _ bits _ for _ versions ; private readonly int bits ; private readonly string name ; private mode ( int [ ] character _ count _ bits _ for _ versions , int bits , system . string name )
private readonly int [ ] character _ count _ bits _ for _ versions ; private readonly int bits ; private readonly string name ; private mode ( int [ ] character _ count _ bits _ for _ versions , int bits , system . string name ) { this . character _ count _ bits _ for _ versions = character _ count _ bits _ for _ versions ; this . bits = bits ; this . name = name ; } public static mode for _ bits ( int bits )
case 0 : return byte ; <%> <-> case 0 : return fn _ first _ position ; case 0 : return eci ; case 0 : return kanji ; case 0 : return fn _ second _ position ; </%>
default : throw new argument _ exception ( ) ; } } public int get _ character _ count _ bits ( version version ) { if ( character _ count _ bits _ for _ versions = = null ) { throw new argument _ exception ( STR ) ; }
public static generic _ gf qr _ code _ field = new generic _ gf ( 0 d , NUM , 0 ) ; <%> <-> public static generic _ gf data _ matrix _ field = new generic _ gf ( 0 d , NUM , 1 ) ; public static generic _ gf aztec _ data = data _ matrix _ field ; public static generic _ gf maxicode _ field = aztec _ data ; </%> private int [ ] exp _ table ; private int [ ] log _ table ; private generic _ gf _ poly zero ; private generic _ gf _ poly one ; private readonly int size ; private readonly int primitive ;
private int [ ] exp _ table ; private int [ ] log _ table ; private generic _ gf _ poly zero ; private generic _ gf _ poly one ; private readonly int size ; private readonly int primitive ; private readonly int generator _ base ; public generic _ gf ( int primitive , int size , int gen _ base ) { this . primitive = primitive ;
{ private static logger logger = log _ manager . get _ current _ class _ logger ( ) ; <%> <-> public static event event _ handler < result _ event _ args > update _ completed ; public class result _ event _ args : event _ args { public bool success ; public result _ event _ args ( bool success ) { this . success = success ; } </%>
public static event error _ event _ handler error ; private static readonly string database _ path = utils . get _ temp _ path ( STR ) ; private static readonly string geosite _ url = STR ; public static readonly dictionary < string , i _ list < domain _ object > > geosites = new dictionary < string , i _ list < domain _ object > > ( ) ; static geosite _ updater ( ) { if ( ! file . exists ( database _ path ) ) { file . write _ all _ bytes ( database _ path , resources . dlc _ dat ) ; }
} update _ system _ proxy ( ) ; } public server get _ current _ server ( ) { return config . get _ current _ server ( ) ; } public configuration get _ configuration ( ) { return configuration . load ( ) ;
if ( methodname . is _ null _ or _ empty ( ) ) throw new argument _ exception ( nameof ( methodname ) ) ; <%> <*> type delegate _ type = type . get _ type ( STR ) . get _ nested _ type ( STR ) ; method _ info dyn _ method = type . get _ method ( methodname , -> method _ info dyn _ method = typeof ( hotkey _ callbacks ) . get _ method ( methodname , </%> binding _ flags . non _ public | binding _ flags . instance | binding _ flags . ignore _ case ) ; return dyn _ method = = null ? null : delegate . create _ delegate ( <%> <*> delegate -> typeof ( hot _ keys . hot _ key _ call _ back </%> _ <%> <*> type -> handler ) </%> , <%> <*> this -> hotkey _ callbacks . instance </%> , dyn _ method ) ; } } }
binding _ flags . non _ public | binding _ flags . instance | binding _ flags . ignore _ case ) ; return dyn _ method = = null ? null : delegate . create _ delegate ( <%> <*> delegate -> typeof ( hot _ keys . hot _ key _ call _ back </%> _ <%> <*> type -> handler ) </%> , <%> <*> this -> hotkey _ callbacks . instance </%> , dyn _ method ) ; } } }
} } }
using global _ hot _ key ; using system _ windows _ input ; using system _ threading ; using system _ collections _ generic ; <%> <+> using shadowsocks _ controller _ hotkeys ; </%> namespace test { test _ class public class unit _ test {
{ public static class hot _ keys { private static hot _ key _ manager hot _ key _ manager ; public delegate void hot _ key _ call _ back _ handler ( ) ; private static dictionary < hot _ key , hot _ key _ call _ back _ handler > keymap = new dictionary < hot _ key , hot _ key _ call _ back _ handler > ( ) ; public static void init ( <%> <+> shadowsocks _ controller controller </%> ) { hot _ key _ manager = new hot _ key _ manager ( ) ; hot _ key _ manager . key _ pressed + = hot _ key _ manager _ pressed ;
{ hot _ key _ manager = new hot _ key _ manager ( ) ; hot _ key _ manager . key _ pressed + = hot _ key _ manager _ pressed ; <%> <+> hotkey _ callbacks . init _ instance ( controller ) ; </%> } public static void destroy ( ) { hot _ key _ manager . key _ pressed - = hot _ key _ manager _ pressed ; hot _ key _ manager . dispose ( ) ; }
int red = color . r * fly _ blue . r / NUM ; int green = color . g * fly _ blue . g / NUM ; int blue = color . b * fly _ blue . b / NUM ; <%> <*> icon _ copy . set _ pixel ( x , y , color . from _ argb ( color . a , red , green , blue ) ) ; -> int alpha = color . a * fly _ blue . a / NUM ; </%> <%> <+> icon _ copy . set _ pixel ( x , y , color . from _ argb ( alpha , red , green , blue ) ) ; </%> } else if ( global ) { color fly _ blue = color . from _ argb ( NUM , NUM , NUM ) ;
} else if ( global ) { color fly _ blue = color . from _ argb ( NUM , NUM , NUM ) ; int red = color . r * fly _ blue . r / NUM ; int green = color . g * fly _ blue . g / NUM ; int blue = color . b * fly _ blue . b / NUM ; icon _ copy . set _ pixel ( x , y , color . from _ argb ( color . a , red , green , blue ) ) ; } }
try { var strategy = get _ current _ strategy ( ) ; if ( strategy ! = null ) { strategy . reload _ servers ( ) ; } <%> <-> privoxy _ runner . start ( config ) ; </%> tcp _ relay tcp _ relay = new tcp _ relay ( this , config ) ; udp _ relay udp _ relay = new udp _ relay ( this ) ;
tcp _ relay tcp _ relay = new tcp _ relay ( this , config ) ; udp _ relay udp _ relay = new udp _ relay ( this ) ; list < listener . i _ service > services = new list < listener . i _ service > ( ) ; services . add ( tcp _ relay ) ; services . add ( udp _ relay ) ; services . add ( pac _ server ) ; <%> <-> services . add ( new port _ forwarder ( privoxy _ runner . running _ port ) ) ; </%> listener = new listener ( services ) ; listener . start ( config ) ; }
listener = new listener ( services ) ; listener . start ( config ) ; } catch ( exception e ) { if ( e is socket _ exception ) { socket _ exception se = ( socket _ exception ) e ; if ( se . socket _ error _ code = = socket _ error . access _ denied ) {
dll _ import _ kernel _ dll <%> <+> private </%> static extern bool set _ information _ job _ object ( int _ ptr h _ job , job _ object _ info _ type info _ type , int _ ptr lp _ job _ object _ info , u _ int cb _ job _ object _ info _ length ) ; dll _ import _ kernel _ dll _ set _ last _ error _ true <%> <+> private </%> static extern bool assign _ process _ to _ job _ object ( int _ ptr job , int _ ptr process ) ; dll _ import _ kernel _ dll _ set _ last _ error _ true return _ marshal _ as _ unmanaged _ type _ bool <%> <+> private </%> static extern bool close _ handle ( int _ ptr h _ object ) ; private int _ ptr handle ; private bool disposed ; public job ( )
dll _ import _ kernel _ dll _ set _ last _ error _ true <%> <+> private </%> static extern bool assign _ process _ to _ job _ object ( int _ ptr job , int _ ptr process ) ; dll _ import _ kernel _ dll _ set _ last _ error _ true return _ marshal _ as _ unmanaged _ type _ bool <%> <+> private </%> static extern bool close _ handle ( int _ ptr h _ object ) ; private int _ ptr handle ; private bool disposed ; public job ( ) { handle = create _ job _ object ( int _ ptr . zero , null ) ;
dll _ import _ kernel _ dll _ set _ last _ error _ true return _ marshal _ as _ unmanaged _ type _ bool <%> <+> private </%> static extern bool close _ handle ( int _ ptr h _ object ) ; private int _ ptr handle ; private bool disposed ; public job ( ) { handle = create _ job _ object ( int _ ptr . zero , null ) ; <%> <+> var extended _ info _ ptr = int _ ptr . zero ; </%> var info = new jobobject _ basic _ limit _ information
private int _ ptr handle ; private bool disposed ; public job ( ) { handle = create _ job _ object ( int _ ptr . zero , null ) ; <%> <+> var extended _ info _ ptr = int _ ptr . zero ; </%> var info = new jobobject _ basic _ limit _ information { limit _ flags = 0 } ;
} public void dispose ( ) { dispose ( true ) ; gc . suppress _ finalize ( this ) ; } private void dispose ( bool disposing ) { if ( disposed ) return ;
servers _ list _ box . selected _ index = modified _ configuration . index ; <%> <*> old -> load </%> _ selected _ <%> <*> index = servers _ list _ box . selected _ index ; -> server ( ) ; </%> enable _ item . checked = modified _ configuration . enabled ; } private void config _ form _ load ( object sender , event _ args e ) { if ( ! controller . get _ configuration ( ) . is _ default ) { this . opacity = 0 ; begin _ invoke ( new method _ invoker ( delegate
enable _ item . checked = modified _ configuration . enabled ; } private void config _ form _ load ( object sender , event _ args e ) { if ( ! controller . get _ configuration ( ) . is _ default ) { this . opacity = 0 ; begin _ invoke ( new method _ invoker ( delegate { this . hide ( ) ;

using system _ collections _ generic ; using system _ runtime _ interop _ services ; using system _ text ; namespace shadowsocks _ csharp _ encrypt { public class openssl _ encryptor : encryptor _ base , i _ disposable { <%> <+> static dictionary < string , int [ ] > ciphers = new dictionary < string , int [ ] > { { STR , new int [ ] { NUM , NUM } } , </%>
byte [ ] iv = new byte [ iv _ len ] ; <%> <*> native -> open _ ssl </%> . rand _ bytes ( iv , iv . length ) ; init _ cipher ( ref encrypt _ ctx , iv , true ) ; int out _ len = length + <%> <*> cipher . block -> iv </%> _ <%> <*> size -> len </%> ; byte [ ] cipher _ text = new byte [ out _ len ] ; <%> <*> native -> open _ ssl </%> . evp _ cipher _ update ( encrypt _ ctx , cipher _ text , out out _ len , buf , length ) ; byte [ ] result = new byte [ out _ len + iv _ len ] ; buffer . block _ copy ( iv , 0 , result , 0 , iv _ len ) ; buffer . block _ copy ( cipher _ text , 0 , result , iv _ len , out _ len ) ; return result ;
init _ cipher ( ref encrypt _ ctx , iv , true ) ; int out _ len = length + <%> <*> cipher . block -> iv </%> _ <%> <*> size -> len </%> ; byte [ ] cipher _ text = new byte [ out _ len ] ; <%> <*> native -> open _ ssl </%> . evp _ cipher _ update ( encrypt _ ctx , cipher _ text , out out _ len , buf , length ) ; byte [ ] result = new byte [ out _ len + iv _ len ] ; buffer . block _ copy ( iv , 0 , result , 0 , iv _ len ) ; buffer . block _ copy ( cipher _ text , 0 , result , iv _ len , out _ len ) ; return result ; } else
byte [ ] cipher _ text = new byte [ out _ len ] ; <%> <*> native -> open _ ssl </%> . evp _ cipher _ update ( encrypt _ ctx , cipher _ text , out out _ len , buf , length ) ; byte [ ] result = new byte [ out _ len + iv _ len ] ; buffer . block _ copy ( iv , 0 , result , 0 , iv _ len ) ; buffer . block _ copy ( cipher _ text , 0 , result , iv _ len , out _ len ) ; return result ; } else { int out _ len = length + <%> <*> cipher . block -> iv </%> _ <%> <*> size -> len </%> ;
byte [ ] result = new byte [ out _ len + iv _ len ] ; buffer . block _ copy ( iv , 0 , result , 0 , iv _ len ) ; buffer . block _ copy ( cipher _ text , 0 , result , iv _ len , out _ len ) ; return result ; } else { int out _ len = length + <%> <*> cipher . block -> iv </%> _ <%> <*> size -> len </%> ; byte [ ] cipher _ text = new byte [ out _ len ] ; <%> <*> native -> open _ ssl </%> . evp _ cipher _ update ( encrypt _ ctx , cipher _ text , out out _ len , buf , length ) ;
byte [ ] cipher _ text = new byte [ out _ len ] ; <%> <*> native -> open _ ssl </%> . evp _ cipher _ update ( encrypt _ ctx , cipher _ text , out out _ len , buf , length ) ; byte [ ] result = new byte [ out _ len ] ; buffer . block _ copy ( cipher _ text , 0 , result , 0 , out _ len ) ; return result ; } } public override byte [ ] decrypt ( byte [ ] buf , int length ) { if ( decrypt _ ctx = = int _ ptr . zero )
byte [ ] result = new byte [ out _ len ] ; buffer . block _ copy ( cipher _ text , 0 , result , 0 , out _ len ) ; return result ; } } public override byte [ ] decrypt ( byte [ ] buf , int length ) { if ( decrypt _ ctx = = int _ ptr . zero ) { <%> <-> int iv _ len = cipher . iv _ length ; </%>
byte [ ] iv = new byte [ iv _ len ] ; buffer . block _ copy ( buf , 0 , iv , 0 , iv _ len ) ; init _ cipher ( ref decrypt _ ctx , iv , false ) ; int out _ len = length + <%> <*> cipher . block -> iv </%> _ <%> <*> size -> len </%> ; out _ len - = iv _ len ; byte [ ] cipher _ text = new byte [ out _ len ] ; byte [ ] subset = new byte [ length - iv _ len ] ; buffer . block _ copy ( buf , iv _ len , subset , 0 , length - iv _ len ) ; <%> <*> native -> open _ ssl </%> . evp _ cipher _ update ( decrypt _ ctx , cipher _ text , out out _ len , subset , length - iv _ len ) ; byte [ ] result = new byte [ out _ len ] ;
out _ len - = iv _ len ; byte [ ] cipher _ text = new byte [ out _ len ] ; byte [ ] subset = new byte [ length - iv _ len ] ; buffer . block _ copy ( buf , iv _ len , subset , 0 , length - iv _ len ) ; <%> <*> native -> open _ ssl </%> . evp _ cipher _ update ( decrypt _ ctx , cipher _ text , out out _ len , subset , length - iv _ len ) ; byte [ ] result = new byte [ out _ len ] ; buffer . block _ copy ( cipher _ text , 0 , result , 0 , out _ len ) ; return result ; } else
byte [ ] result = new byte [ out _ len ] ; buffer . block _ copy ( cipher _ text , 0 , result , 0 , out _ len ) ; return result ; } else { int out _ len = length + <%> <*> cipher . block -> iv </%> _ <%> <*> size -> len </%> ; byte [ ] cipher _ text = new byte [ out _ len ] ; <%> <*> native -> open _ ssl </%> . evp _ cipher _ update ( decrypt _ ctx , cipher _ text , out out _ len , buf , length ) ; byte [ ] result = new byte [ out _ len ] ;
byte [ ] cipher _ text = new byte [ out _ len ] ; <%> <*> native -> open _ ssl </%> . evp _ cipher _ update ( decrypt _ ctx , cipher _ text , out out _ len , buf , length ) ; byte [ ] result = new byte [ out _ len ] ; buffer . block _ copy ( cipher _ text , 0 , result , 0 , out _ len ) ; return result ; } } private static readonly dictionary < string , byte [ ] > cached _ keys = new dictionary < string , byte [ ] > ( ) ; <%> <-> private static readonly dictionary < string , cipher > cached _ ciphers = new dictionary < string , cipher > ( ) ; </%> private byte [ ] key ;
byte [ ] result = new byte [ out _ len ] ; buffer . block _ copy ( cipher _ text , 0 , result , 0 , out _ len ) ; return result ; } } private static readonly dictionary < string , byte [ ] > cached _ keys = new dictionary < string , byte [ ] > ( ) ; <%> <-> private static readonly dictionary < string , cipher > cached _ ciphers = new dictionary < string , cipher > ( ) ; </%> private byte [ ] key ; <%> <-> private cipher cipher ; </%> private int _ ptr encrypt _ ctx ;
private byte [ ] key ; <%> <-> private cipher cipher ; </%> private int _ ptr encrypt _ ctx ; private int _ ptr decrypt _ ctx ; <%> <+> private int _ ptr cipher ; private int key _ len ; private int iv _ len ; </%> private void init _ key ( string method , string password ) { <%> <+> open _ ssl . open _ ssl _ add _ all _ ciphers ( ) ; </%>
private int _ ptr encrypt _ ctx ; private int _ ptr decrypt _ ctx ; <%> <+> private int _ ptr cipher ; private int key _ len ; private int iv _ len ; </%> private void init _ key ( string method , string password ) { <%> <+> open _ ssl . open _ ssl _ add _ all _ ciphers ( ) ; method = method . to _ lower ( ) ; </%> string k = method + STR + password ;
} <%> <*> cipher = cipher . create _ by _ name ( method ) ; if ( cipher = = null ) -> else </%> { <%> <*> throw new null _ reference _ exception ( ) ; -> byte [ ] passbuf = encoding . ut . get _ bytes ( password ) ; </%> <%> <+> key = new byte [ NUM ] ; byte [ ] iv = new byte [ NUM ] ; open _ ssl . evp _ bytes _ to _ key ( cipher , open _ ssl . evp _ md ( ) , int _ ptr . zero , passbuf , passbuf . length , 1 , key , iv ) ; </%>
{ <%> <*> throw new null _ reference _ exception ( ) ; -> byte [ ] passbuf = encoding . ut . get _ bytes ( password ) ; </%> <%> <+> key = new byte [ NUM ] ; byte [ ] iv = new byte [ NUM ] ; open _ ssl . evp _ bytes _ to _ key ( cipher , open _ ssl . evp _ md ( ) , int _ ptr . zero , passbuf , passbuf . length , 1 , key , iv ) ; cached _ keys [ k ] = key ; </%> } <%> <-> byte [ ] passbuf = encoding . ut . get _ bytes ( password ) ; key = new byte [ cipher . key _ length ] ; </%>
} <%> <-> byte [ ] passbuf = encoding . ut . get _ bytes ( password ) ; key = new byte [ cipher . key _ length ] ; byte [ ] iv = new byte [ cipher . iv _ length ] ; native . evp _ bytes _ to _ key ( cipher . handle , message _ digest . m . handle , null , passbuf , passbuf . length , 1 , key , iv ) ; cached _ keys [ k ] = key ; cached _ ciphers [ k ] = cipher ; </%> } private void init _ cipher ( ref int _ ptr ctx , byte [ ] iv , bool is _ cipher ) {
} private void init _ cipher ( ref int _ ptr ctx , byte [ ] iv , bool is _ cipher ) { ctx = <%> <*> native . openssl _ malloc ( marshal . size _ of ( typeof ( cipher -> open </%> _ <%> <*> context -> ssl </%> . evp _ cipher _ ctx <%> <*> ) ) -> _ new ( </%> ) ; int enc = is _ cipher ? 1 : 0 ; <%> <-> native . evp _ cipher _ ctx _ init ( ctx ) ; native . expect _ success ( native . evp _ cipher _ init _ ex ( ctx , cipher . handle , int _ ptr . zero , null , null , enc ) ) ; native . expect _ success ( native . evp _ cipher _ ctx _ set _ key _ length ( ctx , key . length ) ) ; native . expect _ success ( native . evp _ cipher _ ctx _ set _ padding ( ctx , 1 ) ) ; native . expect _ success ( native . evp _ cipher _ init _ ex ( ctx , cipher . handle , int _ ptr . zero , key , iv , enc ) ) ; </%>
int enc = is _ cipher ? 1 : 0 ; <%> <*> native . evp _ cipher _ ctx _ init ( ctx ) ; native . expect _ success ( native . evp _ cipher _ init _ ex ( ctx , cipher . handle , int _ ptr . zero , null , null , enc ) ) ; native . expect _ success ( native . evp _ cipher _ ctx _ set _ key _ length ( ctx , key . length ) ) ; native . expect _ success ( native . evp _ cipher _ ctx _ set _ padding ( ctx , 1 ) ) ; native . expect _ success ( native . evp _ cipher _ init _ ex ( ctx , cipher . handle , int _ ptr . zero , key , iv , enc ) ) ; -> open _ ssl . evp _ cipher _ init _ ex ( ctx , cipher , int _ ptr . zero , key , iv , enc ) ; </%> } private bool disposed ; public void dispose ( )
} private bool disposed ; public void dispose ( ) { dispose ( true ) ; gc . suppress _ finalize ( this ) ; } ~ openssl _ encryptor ( ) { dispose ( false ) ;
availability _ statistics . update _ configuration ( this ) ; <%> <*> if ( listener ! = null ) { listener . stop ( ) ; } -> listener ? . stop ( ) ; </%> stop _ plugins ( ) ; privoxy _ runner . stop ( ) ; try {
stop _ plugins ( ) ; privoxy _ runner . stop ( ) ; try { var strategy = get _ current _ strategy ( ) ; <%> <*> if ( strategy ! = null ) { strategy . reload _ servers ( ) ; } -> strategy ? . reload _ servers ( ) ; </%>
start _ plugin ( ) ; privoxy _ runner . start ( config ) ; tcp _ relay tcp _ relay = new tcp _ relay ( this , config ) ; udp _ relay udp _ relay = new udp _ relay ( this ) ; list < listener . i _ service > services = new list < listener . i _ service > { tcp _ relay , udp _ relay , pac _ server , new port _ forwarder ( privoxy _ runner . running _ port )
} catch ( exception e ) { logging . log _ useful _ exception ( e ) ; return false ; <%> <+> } } public static bool check ( ) { try </%>
} <%> <-> } } } </%>

new menu _ item ( STR ) , create _ menu _ item ( STR , new event _ handler ( this . show _ log _ item _ click ) ) , create _ menu _ item ( STR , new event _ handler ( this . about _ item _ click ) ) , new menu _ item ( STR ) , create _ menu _ item ( STR , new event _ handler ( this . quit _ click ) ) } ) ; } private void controller _ config _ changed ( object sender , event _ args e ) { load _ current _ configuration ( ) ;
{ <%> <+> console . write _ line ( e . to _ string ( ) ) ; </%> } process = null ; } } } }
return remarks . is _ null _ or _ empty ( ) ? server _ str : $ STR ; <%> <+> } public string format _ host _ name ( string host _ name ) { switch ( uri . check _ host _ name ( host _ name ) ) { case uri _ host _ name _ type . i _ pv : return $ STR ; </%>
private static string get _ timestamp ( date _ time value ) { return value . to _ string ( STR ) ; } public static void update ( configuration config , bool force _ disable , pac _ server pac _ srv <%> <*> ) -> , bool no _ retry = false ) </%> { <%> <-> if ( failed ) return ; </%> bool global = config . global ; bool enabled = config . enabled ; if ( force _ disable )
{ <%> <-> if ( failed ) return ; </%> bool global = config . global ; bool enabled = config . enabled ; if ( force _ disable ) { enabled = false ; } try {
bool global = config . global ; bool enabled = config . enabled ; if ( force _ disable ) { enabled = false ; } try { if ( enabled ) {
{ <%> <*> case proxy -> var ret = message _ box . show ( n . get _ string ( STR ) , n . get _ string ( STR ) , message </%> _ <%> <*> exception -> box </%> _ <%> <*> type -> buttons </%> . <%> <*> fail -> yes </%> _ <%> <*> to -> no , message </%> _ <%> <*> run : message _ box . show -> box _ icon . warning ) ; if </%> ( <%> <*> n . get -> ret = = dialog </%> _ <%> <*> string ( STR -> result . yes </%> ) <%> <*> , n . get _ string ( STR ) ) ; break ; case proxy _ exception _ type -> { sysproxy </%> . <%> <*> query -> reset </%> _ <%> <*> return -> ie </%> _ <%> <*> malformed : case proxy _ exception -> proxy ( ) ; update ( config , force </%> _ <%> <*> type . query -> disable , pac </%> _ <%> <*> return _ empty : -> srv , true ) ; </%> <%> <-> message _ box . show ( n . get _ string ( STR ) , n . get _ string ( STR ) ) ; </%> <%> <*> break ; -> } </%> <%> <*> case proxy _ exception _ type . sysproxy _ exit _ error : -> } </%> <%> <*> message _ box . show ( n . get _ string ( STR ) + ex . message , n . get _ string ( STR ) ) ; -> else </%> <%> <+> { </%>
} } } } }
{ <%> <-> registry _ key registry = registry . current _ user . open _ sub _ key ( STR , true ) ; registry . set _ value ( STR , 1 ) ; registry . set _ value ( STR , STR ) ; </%> settings _ return = internet _ set _ option ( int _ ptr . zero , internet _ option _ settings _ changed , int _ ptr . zero , 0 ) ; refresh _ return = internet _ set _ option ( int _ ptr . zero , internet _ option _ refresh , int _ ptr . zero , 0 ) ; } <%> <*> public void disable ( ) -> public static void enable ( ) </%> <%> <+> { </%>
settings _ return = internet _ set _ option ( int _ ptr . zero , internet _ option _ settings _ changed , int _ ptr . zero , 0 ) ; refresh _ return = internet _ set _ option ( int _ ptr . zero , internet _ option _ refresh , int _ ptr . zero , 0 ) ; } <%> <*> public void disable ( ) -> public static void enable ( ) </%> <%> <+> { registry _ key registry = registry . current _ user . open _ sub _ key ( STR , true ) ; registry . set _ value ( STR , 1 ) ; registry . set _ value ( STR , STR ) ; system _ proxy . update _ ie ( ) ; </%>
{ registry _ key registry = registry . current _ user . open _ sub _ key ( STR , true ) ; registry . set _ value ( STR , 0 ) ; registry . set _ value ( STR , STR ) ; <%> <*> settings _ return = internet _ set _ option ( int _ ptr . zero , internet _ option _ settings _ changed , int _ ptr . zero , 0 ) ; refresh _ return = internet _ set _ option ( int _ ptr . zero , internet _ option _ refresh , int _ ptr . zero , 0 ) ; -> system _ proxy . update _ ie ( ) ; </%> } } }
} } }
public class availability _ statistics { public static readonly string date _ time _ pattern = STR ; private const string statistics _ files _ name = STR ; private const string delimiter = STR ; private const int timeout = NUM ; private const int delay _ before _ start = NUM ; public <%> <-> raw _ </%> statistics raw _ statistics { get ; private set ; } public <%> <-> raw _ </%> statistics filtered _ statistics { get ; private set ; } private int repeat = > config . repeat _ times _ num ;
private const int retry _ interval = 2 * NUM * NUM ; private int interval = > ( int ) time _ span . from _ minutes ( config . data _ collection _ minutes ) . total _ milliseconds ; private timer timer ; private state state ; private list < server > servers ; private statistics _ strategy _ configuration config ; public static string availability _ statistics _ file ; static availability _ statistics ( ) { var temppath = utils . get _ temp _ path ( ) ;
ret . add ( new list < key _ value _ pair < string , string > > { new key _ value _ pair < string , string > ( STR , timestamp ) , new key _ value _ pair < string , string > ( STR , server . friendly _ name ( ) ) , new key _ value _ pair < string , string > ( STR , reply ? . status . to _ string ( ) ) , new key _ value _ pair < string , string > ( STR , reply ? . roundtrip _ time . to _ string ( ) ) } ) ; thread . sleep ( <%> <+> timeout + </%> new random ( ) . next ( ) % timeout ) ; } catch ( exception e )
} catch ( exception e ) { console . write _ line ( $ STR ) ; logging . log _ useful _ exception ( e ) ; } } return ret ; } private void run ( object obj )
tcprelay . update _ outbound _ counter ( server , bytes _ to _ send ) ; start _ sending _ time = date _ time . now ; bytes _ to _ send = bytes _ to _ send ; remote . begin _ send ( connetion _ send _ buffer , 0 , bytes _ to _ send , 0 , new async _ callback ( pipe _ remote _ send _ callback ) , null ) ; i _ strategy strategy = controller . get _ current _ strategy ( ) ; strategy ? . update _ last _ write ( server ) ; } else { remote . shutdown ( socket _ shutdown . send ) ;
this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ; <%> <-> this . label = new system . windows . forms . label ( ) ; </%> this . chart _ mode _ selector = new system . windows . forms . group _ box ( ) ; this . all _ mode = new system . windows . forms . radio _ button ( ) ; this . day _ mode = new system . windows . forms . radio _ button ( ) ; this . split _ container = new system . windows . forms . split _ container ( ) ; this . split _ container = new system . windows . forms . split _ container ( ) ; this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ;
this . chart _ mode _ selector = new system . windows . forms . group _ box ( ) ; this . all _ mode = new system . windows . forms . radio _ button ( ) ; this . day _ mode = new system . windows . forms . radio _ button ( ) ; this . split _ container = new system . windows . forms . split _ container ( ) ; this . split _ container = new system . windows . forms . split _ container ( ) ; this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ; this . data _ collection _ minutes _ num = new system . windows . forms . numeric _ up _ down ( ) ; this . statistics _ enabled _ check _ box = new system . windows . forms . check _ box ( ) ; this . choice _ kept _ minutes _ num = new system . windows . forms . numeric _ up _ down ( ) ;
private system . windows . forms . label label ; private system . windows . forms . label label ; <%> <-> private system . windows . forms . label label ; </%> private system . windows . forms . group _ box chart _ mode _ selector ; private system . windows . forms . radio _ button all _ mode ; private system . windows . forms . radio _ button day _ mode ; private system . windows . forms . split _ container split _ container ; private system . windows . forms . label label ; private system . windows . forms . split _ container split _ container ; private system . windows . forms . flow _ layout _ panel calculation _ container ;
private system . windows . forms . group _ box chart _ mode _ selector ; private system . windows . forms . radio _ button all _ mode ; private system . windows . forms . radio _ button day _ mode ; private system . windows . forms . split _ container split _ container ; private system . windows . forms . label label ; private system . windows . forms . split _ container split _ container ; private system . windows . forms . flow _ layout _ panel calculation _ container ; private system . windows . forms . split _ container split _ container ; private system . windows . forms . numeric _ up _ down repeat _ times _ num ; private system . windows . forms . label label ;
public static string availability _ statistics _ file ; <%> <-> private readonly time _ span delay _ before _ start = time _ span . from _ seconds ( 1 ) ; private readonly time _ span monitor _ interval = time _ span . from _ seconds ( 1 ) ; private readonly time _ span retry _ interval = time _ span . from _ minutes ( 2 ) ; private readonly time _ span writing _ interval = time _ span . from _ minutes ( 1 ) ; private statistics _ strategy _ configuration config ; private shadowsocks _ controller controller ; private server current _ server ; private list < int > inbound _ speed _ records ; private long last _ inbound _ counter ; </%>
static availability _ statistics ( ) { availability _ statistics _ file = utils . get _ temp _ path ( statistics _ files _ name ) ; <%> <-> } private availability _ statistics ( ) { </%> <%> <*> raw -> unknown _ date </%> _ <%> <*> statistics -> time </%> = new <%> <*> statistics -> date _ time </%> ( <%> <+> NUM , 1 , 1 </%> ) ; } <%> <+> private int repeat = > config . repeat _ times _ num ; private const int timeout _ milliseconds = NUM ; </%>
public static availability _ statistics instance { get ; } = new availability _ statistics ( ) ; public statistics raw _ statistics { get ; private set ; } public statistics filtered _ statistics { get ; private set ; } <%> <*> private int repeat = > config . repeat _ times -> private availability </%> _ <%> <*> num ; -> statistics ( ) </%> <%> <-> private time _ span recording _ interval = > time _ span . from _ minutes ( config . data _ collection _ minutes ) ; </%> <%> <+> { </%> <%> <*> public bool set ( statistics -> raw </%> _ <%> <*> strategy _ configuration config -> statistics = new statistics ( </%> ) <%> <*> { -> ; </%> <%> <*> config = config ; -> } </%> <%> <*> try -> internal void update _ configuration ( shadowsocks _ controller controller ) </%> <%> <*> { -> { </%> <%> <+> controller = controller ; </%>
load _ raw _ statistics ( ) ; <%> <*> if ( speed _ monior ? . change ( delay _ before _ start , monitor _ interval ) = = null ) { speed _ monior = new timer ( update _ speed , null , delay _ before _ start , monitor _ interval ) ; } if ( writer ? . change ( delay _ before _ start , recording _ interval ) = = null ) { writer = new timer ( save , null , delay _ before _ start , recording _ interval ) ; } -> start _ timer _ without _ state ( ref speed _ monior , update _ speed , monitor _ interval ) ; </%>
} else { recorder ? . dispose ( ) ; speed _ monior ? . dispose ( ) ; <%> <-> } </%> <%> <*> return true ; -> writer ? . dispose ( ) ; </%> <%> <+> } </%> } catch ( exception e ) {
} catch ( exception e ) { logging . log _ useful _ exception ( e ) ; <%> <-> return false ; </%> } } private void <%> <*> update -> start </%> _ <%> <*> speed ( object -> timer _ without _ </%> state <%> <*> ) -> ( ref timer timer , timer _ callback callback , time _ span interval ) </%> <%> <+> { if ( timer ? . change ( delay _ before _ start , interval ) = = null ) </%>
{ var bytes = controller . inbound _ counter - last _ inbound _ counter ; last _ inbound _ counter = controller . inbound _ counter ; var inbound _ speed = get _ speed _ in _ ki _ b _ per _ second ( bytes , monitor _ interval . total _ seconds ) ; inbound _ speed _ records . add ( inbound _ speed ) ; bytes = controller . outbound _ counter - last _ outbound _ counter ; last _ outbound _ counter = controller . outbound _ counter ; var outbound _ speed = get _ speed _ in _ ki _ b _ per _ second ( bytes , monitor _ interval . total _ seconds ) ; outbound _ speed _ records . add ( outbound _ speed ) ; logging . debug (
reset ( ) ; filter _ raw _ statistics ( ) ; } private async void <%> <*> append -> update </%> _ <%> <*> record -> records </%> ( ) { <%> <+> var current _ server _ record = new statistics _ record ( current _ server . identifier ( ) , inbound _ speed _ records , outbound _ speed _ records , latency _ records ) ; </%> <%> <*> var icmp _ results = task _ ex . when _ all ( servers . select -> if </%> ( <%> <*> icmp _ test ) -> ! config . ping </%> ) <%> <*> ; var current _ server _ record = new statistics _ record ( current _ server . identifier ( ) , inbound -> { append </%> _ <%> <*> speed -> record ( current </%> _ <%> <*> records -> server </%> , <%> <*> outbound -> current </%> _ <%> <*> speed _ records , latency -> server </%> _ <%> <*> records -> record </%> ) ; <%> <+> return ; </%>
foreach ( var result in ( await icmp _ results ) . where ( result = > result ! = null ) ) { <%> <-> list < statistics _ record > records ; if ( ! raw _ statistics . try _ get _ value ( result . server . identifier ( ) , out records ) ) { records = new list < statistics _ record > ( ) ; } </%> if ( result . server . equals ( current _ server ) ) { current _ server _ record . set _ response ( result . roundtrip _ time ) ;
{ current _ server _ record . set _ response ( result . roundtrip _ time ) ; <%> <*> records . add -> append _ record </%> ( <%> <+> current _ server , </%> current _ server _ record ) ; } else { <%> <*> records -> append _ record ( result </%> . <%> <*> add ( -> server , </%> new statistics _ record ( result . server . identifier ( ) , result . roundtrip _ time ) ) ; } <%> <-> raw _ statistics [ result . server . identifier ( ) ] = records ; </%> <%> <+> } </%> }
} else { <%> <*> records -> append _ record ( result </%> . <%> <*> add ( -> server , </%> new statistics _ record ( result . server . identifier ( ) , result . roundtrip _ time ) ) ; } <%> <-> raw _ statistics [ result . server . identifier ( ) ] = records ; </%> <%> <+> } </%> } <%> <+> private void append _ record ( server server , statistics _ record record ) { list < statistics _ record > records ; </%>
} private void save ( object ) { try { file . write _ all _ text ( availability _ statistics _ file , json _ convert . serialize _ object ( raw _ statistics , formatting . none ) ) ; } catch ( io _ exception e ) {
private bool is _ valid _ record ( statistics _ record record ) { if ( config . by _ hour _ of _ day ) { <%> <-> var current _ hour = date _ time . now . hour ; </%> if ( record . timestamp = = unknown _ date _ time ) return false ; if ( ! record . timestamp . hour . equals ( date _ time . now . hour ) ) return false ; } return true ; }
if ( record . timestamp = = unknown _ date _ time ) return false ; if ( ! record . timestamp . hour . equals ( date _ time . now . hour ) ) return false ; } return true ; } private void filter _ raw _ statistics ( ) { if ( raw _ statistics = = null ) return ; if ( filtered _ statistics = = null ) {
{ choose _ new _ server ( controller . get _ current _ configuration ( ) . configs ) ; <%> <-> } if ( old _ server ! = current _ server ) { </%> } return current _ server ; } public void reload _ servers ( ) {
} return current _ server ; } public void reload _ servers ( ) { choose _ new _ server ( controller . get _ current _ configuration ( ) . configs ) ; timer ? . change ( 0 , choice _ kept _ milliseconds ) ; } public void set _ failure ( server server ) {
} private void clean _ logs _ button _ click ( object sender , event _ args e ) { <%> <*> log _ message -> do </%> _ <%> <*> text -> clean </%> _ <%> <*> box . clear -> logs </%> ( ) ; } <%> <*> private void change _ font _ button _ click ( object sender , event _ args e ) -> private void do _ change _ font ( ) </%> { try {
{ try { font _ dialog fd = new font _ dialog ( ) ; fd . font = log _ message _ text _ box . font ; if ( fd . show _ dialog ( ) = = dialog _ result . ok ) { log _ message _ text _ box . font = new font ( fd . font . font _ family , fd . font . size , fd . font . style ) ; } }
} } }
this . file _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . open _ location _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . exit _ menu _ item = new system . windows . forms . menu _ item ( ) ; <%> <*> this . panel = new system . windows . forms . panel ( ) ; -> this . view _ menu _ item = new system . windows . forms . menu _ item ( ) ; </%> <%> <+> this . clean _ logs _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . change _ font _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . wrap _ text _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . top _ most _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . menu _ item _ separater = new system . windows . forms . menu _ item ( ) ; </%>
this . change _ font _ button = new system . windows . forms . button ( ) ; this . clean _ logs _ button = new system . windows . forms . button ( ) ; this . wrap _ text _ check _ box = new system . windows . forms . check _ box ( ) ; this . table _ layout _ panel = new system . windows . forms . table _ layout _ panel ( ) ; <%> <*> this . top _ most _ check _ box = new system . windows . forms . check _ box ( ) ; this . panel . suspend _ layout ( ) ; -> this . toolbar _ flow _ layout _ panel = new system . windows . forms . flow _ layout _ panel ( ) ; </%> this . table _ layout _ panel . suspend _ layout ( ) ; <%> <+> this . toolbar _ flow _ layout _ panel . suspend _ layout ( ) ; </%>
this . table _ layout _ panel . suspend _ layout ( ) ; <%> <+> this . toolbar _ flow _ layout _ panel . suspend _ layout ( ) ; </%>
<%> <+> this . change _ font _ button . auto _ size = true ; </%> this . change _ font _ button . location = new system . drawing . point ( NUM , NUM ) ; this . change _ font _ button . name = STR ; this . change _ font _ button . size = new system . drawing . size ( NUM , NUM ) ; this . change _ font _ button . tab _ index = 2 ; this . change _ font _ button . text = STR ; this . change _ font _ button . use _ visual _ style _ back _ color = true ; this . change _ font _ button . click + = new system . event _ handler ( this . change _ font _ button _ click ) ; <%> <+> this . clean _ logs _ button . auto _ size = true ; </%> this . clean _ logs _ button . location = new system . drawing . point ( NUM , NUM ) ;
this . change _ font _ button . name = STR ; this . change _ font _ button . size = new system . drawing . size ( NUM , NUM ) ; this . change _ font _ button . tab _ index = 2 ; this . change _ font _ button . text = STR ; this . change _ font _ button . use _ visual _ style _ back _ color = true ; this . change _ font _ button . click + = new system . event _ handler ( this . change _ font _ button _ click ) ; <%> <+> this . clean _ logs _ button . auto _ size = true ; </%> this . clean _ logs _ button . location = new system . drawing . point ( NUM , NUM ) ; this . clean _ logs _ button . name = STR ; this . clean _ logs _ button . size = new system . drawing . size ( NUM , NUM ) ;
this . clean _ logs _ button . name = STR ; this . clean _ logs _ button . size = new system . drawing . size ( NUM , NUM ) ; this . clean _ logs _ button . tab _ index = 1 ; this . clean _ logs _ button . text = STR ; this . clean _ logs _ button . use _ visual _ style _ back _ color = true ; this . clean _ logs _ button . click + = new system . event _ handler ( this . clean _ logs _ button _ click ) ; <%> <+> this . wrap _ text _ check _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( ( system . windows . forms . anchor _ styles . top | system . windows . forms . anchor _ styles . bottom ) | system . windows . forms . anchor _ styles . left ) ) ) ; </%> this . wrap _ text _ check _ box . auto _ size = true ; this . wrap _ text _ check _ box . location = new system . drawing . point ( NUM , NUM ) ;
this . table _ layout _ panel . controls . add ( this . log _ message _ text _ box , 0 , 1 ) ; <%> <+> this . table _ layout _ panel . controls . add ( this . toolbar _ flow _ layout _ panel , 0 , 0 ) ; </%> this . table _ layout _ panel . dock = system . windows . forms . dock _ style . fill ; this . table _ layout _ panel . location = new system . drawing . point ( 0 , 0 ) ; this . table _ layout _ panel . name = STR ; this . table _ layout _ panel . row _ count = 2 ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; <%> <+> this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; </%> this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ; this . table _ layout _ panel . tab _ index = 2 ;
this . table _ layout _ panel . tab _ index = 2 ; this . <%> <*> top -> toolbar </%> _ <%> <*> most -> flow </%> _ <%> <*> check -> layout </%> _ <%> <*> box -> panel </%> . auto _ size = true ; this . <%> <*> top -> toolbar </%> _ <%> <*> most -> flow </%> _ <%> <*> check -> layout </%> _ <%> <*> box -> panel </%> . <%> <*> location = new system -> controls </%> . <%> <*> drawing -> add ( this </%> . <%> <*> point ( NUM , NUM -> clean _ logs _ button </%> ) ; this . <%> <*> top -> toolbar </%> _ <%> <*> most -> flow </%> _ <%> <*> check -> layout </%> _ <%> <*> box -> panel </%> . <%> <*> name = STR ; -> controls . add ( this . change _ font _ button ) ; </%> this . <%> <*> top -> toolbar </%> _ <%> <*> most -> flow </%> _ <%> <*> check -> layout </%> _ <%> <*> box -> panel </%> . <%> <*> size = new system -> controls . add ( this </%> . <%> <*> drawing . size ( NUM , NUM -> wrap _ text _ check _ box </%> ) ; <%> <+> this . toolbar _ flow _ layout _ panel . controls . add ( </%> this . top _ most _ check _ box <%> <*> . tab _ index = NUM -> ) </%> ; this . <%> <*> top -> toolbar </%> _ <%> <*> most -> flow </%> _ <%> <*> check -> layout </%> _ <%> <*> box -> panel </%> . <%> <*> text -> dock </%> = <%> <*> STR ; -> system . windows . forms . dock _ style . fill ; </%> this . <%> <*> top -> toolbar </%> _ <%> <*> most -> flow </%> _ <%> <*> check -> layout </%> _ <%> <*> box -> panel </%> . <%> <*> use _ visual _ style _ back _ color = true -> location = new system . drawing . point ( NUM , NUM ) </%> ; this . <%> <*> top -> toolbar </%> _ <%> <*> most -> flow </%> _ <%> <*> check -> layout </%> _ <%> <*> box -> panel </%> . <%> <*> checked _ changed + -> name </%> = <%> <*> new system . event _ handler ( this . top _ most _ check _ box _ checked _ changed ) ; -> STR ; </%> <%> <+> this . toolbar _ flow _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ; </%>

this . table _ layout _ panel . resume _ layout ( false ) ; this . table _ layout _ panel . perform _ layout ( ) ; <%> <+> this . toolbar _ flow _ layout _ panel . resume _ layout ( false ) ; this . toolbar _ flow _ layout _ panel . perform _ layout ( ) ; </%> this . resume _ layout ( false ) ; } private system . windows . forms . text _ box log _ message _ text _ box ; <%> <-> private system . windows . forms . context _ menu _ strip context _ menu _ strip ; </%> private system . windows . forms . main _ menu main _ menu ; private system . windows . forms . menu _ item file _ menu _ item ;
private system . windows . forms . menu _ item file _ menu _ item ; private system . windows . forms . menu _ item open _ location _ menu _ item ; private system . windows . forms . menu _ item exit _ menu _ item ; <%> <-> private system . windows . forms . panel panel ; </%> private system . windows . forms . check _ box wrap _ text _ check _ box ; private system . windows . forms . button clean _ logs _ button ; private system . windows . forms . button change _ font _ button ; private system . windows . forms . table _ layout _ panel table _ layout _ panel ; private system . windows . forms . check _ box top _ most _ check _ box ; <%> <+> private system . windows . forms . menu _ item view _ menu _ item ; </%>
private system . windows . forms . check _ box wrap _ text _ check _ box ; private system . windows . forms . button clean _ logs _ button ; private system . windows . forms . button change _ font _ button ; private system . windows . forms . table _ layout _ panel table _ layout _ panel ; private system . windows . forms . check _ box top _ most _ check _ box ; <%> <+> private system . windows . forms . menu _ item view _ menu _ item ; private system . windows . forms . menu _ item clean _ logs _ menu _ item ; private system . windows . forms . menu _ item change _ font _ menu _ item ; private system . windows . forms . menu _ item wrap _ text _ menu _ item ; private system . windows . forms . menu _ item top _ most _ menu _ item ; </%>
public port _ forwarder ( int target _ port ) { <%> <-> this . </%> target _ port = target _ port ; } public override bool handle ( byte [ ] first _ packet , int length , socket socket , object state ) { if ( socket . protocol _ type ! = protocol _ type . tcp ) { return false ; }
} public override bool handle ( byte [ ] first _ packet , int length , socket socket , object state ) { if ( socket . protocol _ type ! = protocol _ type . tcp ) { return false ; } new handler ( ) . start ( first _ packet , length , socket , <%> <-> this . </%> target _ port ) ; return true ; }
return true ; } <%> <+> private </%> class handler { private byte [ ] first _ packet ; private int first _ packet _ length ; private socket local ; private wrapped _ socket remote ; private bool closed = false ; private bool local _ shutdown = false ;
{ private byte [ ] first _ packet ; private int first _ packet _ length ; private socket local ; private wrapped _ socket remote ; private bool closed = false ; private bool local _ shutdown = false ; private bool remote _ shutdown = false ; <%> <*> public -> private </%> const int recv _ size = NUM ; private byte [ ] remote _ recv _ buffer = new byte [ recv _ size ] ;
private byte [ ] remote _ recv _ buffer = new byte [ recv _ size ] ; private byte [ ] connetion _ recv _ buffer = new byte [ recv _ size ] ; private readonly object lock = new object ( ) ; public void start ( byte [ ] first _ packet , int length , socket socket , int target _ port ) { <%> <-> this . </%> first _ packet = first _ packet ; <%> <-> this . </%> first _ packet _ length = length ; <%> <-> this . </%> local = socket ; try {
try { end _ point remote _ ep = socket _ util . get _ end _ point ( STR , target _ port ) ; remote = new wrapped _ socket ( ) ; remote . begin _ connect ( remote _ ep , connect _ callback , null ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; <%> <-> this . </%> close ( ) ;
} } private void connect _ callback ( i _ async _ result ar ) { if ( closed ) { return ; } try {
local . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , 0 , <%> <-> new async _ callback ( </%> pipe _ connection _ receive _ callback <%> <-> ) </%> , null ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; <%> <-> this . </%> close ( ) ; } } private void pipe _ remote _ receive _ callback ( i _ async _ result ar )
} } private void pipe _ remote _ receive _ callback ( i _ async _ result ar ) { if ( closed ) { return ; } try {
} } private void check _ close ( ) { if ( local _ shutdown & & remote _ shutdown ) { <%> <-> this . </%> close ( ) ; } } public void close ( )
} } public void close ( ) { lock ( lock ) { if ( closed ) { return ; }
key = cached _ keys [ k ] ; <%> <-> } else { byte [ ] passbuf = encoding . ut . get _ bytes ( password ) ; key = new byte [ NUM ] ; byte [ ] iv = new byte [ NUM ] ; bytes _ to _ key ( passbuf , key ) ; cached _ keys [ k ] = key ; } </%>
} protected void bytes _ to _ key ( byte [ ] password , byte [ ] key ) { byte [ ] result = new byte [ password . length + NUM ] ; int i = 0 ; byte [ ] md _ sum = null ; while ( i < key . length ) { if ( i = = 0 ) {
{ public class direct _ connect : i <%> <+> _ forward </%> _ proxy { private class fake _ async _ result : i _ async _ result { public fake _ async _ result ( object state ) { async _ state = state ; } public bool is _ completed { get ; } = true ;
{ private class fake _ async _ result : i _ async _ result { public fake _ async _ result ( object state ) { async _ state = state ; } public bool is _ completed { get ; } = true ; public wait _ handle async _ wait _ handle { get ; } = null ; public object async _ state { get ; }
{ public class http _ proxy : i <%> <+> _ forward </%> _ proxy { private class fake _ async _ result : i _ async _ result { public readonly http _ state inner _ state ; private readonly i _ async _ result r ; public fake _ async _ result ( i _ async _ result orig , http _ state state ) { r = orig ;
{ private class fake _ async _ result : i _ async _ result { public readonly http _ state inner _ state ; private readonly i _ async _ result r ; public fake _ async _ result ( i _ async _ result orig , http _ state state ) { r = orig ; inner _ state = state ; }
using shadowsocks _ util _ sockets ; namespace shadowsocks _ controller { class tcp _ relay : listener . service { private shadowsocks _ controller controller ; private date _ time last _ sweep _ time ; private configuration config ; public i _ set < tcp _ handler > handlers { get ; set ; } public tcp _ relay ( shadowsocks _ controller controller , configuration conf )
{ public interface i <%> <+> _ forward </%> _ proxy { end _ point local _ end _ point { get ; } end _ point proxy _ end _ point { get ; } end _ point dest _ end _ point { get ; } void begin _ connect _ proxy ( end _ point remote _ ep , async _ callback callback , object state ) ; void end _ connect _ proxy ( i _ async _ result async _ result ) ; void begin _ connect _ dest ( end _ point dest _ end _ point , async _ callback callback , object state ) ; void end _ connect _ dest ( i _ async _ result async _ result ) ;
{ end _ point local _ end _ point { get ; } end _ point proxy _ end _ point { get ; } end _ point dest _ end _ point { get ; } void begin _ connect _ proxy ( end _ point remote _ ep , async _ callback callback , object state ) ; void end _ connect _ proxy ( i _ async _ result async _ result ) ; void begin _ connect _ dest ( end _ point dest _ end _ point , async _ callback callback , object state ) ; void end _ connect _ dest ( i _ async _ result async _ result ) ; void begin _ send ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) ;
{ public class socks _ proxy : i <%> <+> _ forward </%> _ proxy { private class fake _ async _ result : i _ async _ result { public readonly socks _ state inner _ state ; private readonly i _ async _ result r ; public fake _ async _ result ( i _ async _ result orig , socks _ state state ) { r = orig ;
{ private class fake _ async _ result : i _ async _ result { public readonly socks _ state inner _ state ; private readonly i _ async _ result r ; public fake _ async _ result ( i _ async _ result orig , socks _ state state ) { r = orig ; inner _ state = state ; }
this . statistics _ chart = new system . windows . forms . data _ visualization . charting . chart ( ) ; <%> <*> this . check _ box = new system . windows . forms . check _ box ( ) ; -> this . by _ isp _ check _ box = new system . windows . forms . check _ box ( ) ; </%> <%> <+> this . binding _ configuration = new system . windows . forms . binding _ source ( this . components ) ; </%> this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ; this . group _ box = new system . windows . forms . group _ box ( ) ; this . radio _ button = new system . windows . forms . radio _ button ( ) ; this . radio _ button = new system . windows . forms . radio _ button ( ) ;
this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ; this . group _ box = new system . windows . forms . group _ box ( ) ; this . radio _ button = new system . windows . forms . radio _ button ( ) ; this . radio _ button = new system . windows . forms . radio _ button ( ) ; this . split _ container = new system . windows . forms . split _ container ( ) ; this . split _ container = new system . windows . forms . split _ container ( ) ; <%> <-> this . numeric _ up _ down = new system . windows . forms . numeric _ up _ down ( ) ; this . check _ box = new system . windows . forms . check _ box ( ) ; </%>
this . label = new system . windows . forms . label ( ) ; this . split _ container = new system . windows . forms . split _ container ( ) ; this . label = new system . windows . forms . label ( ) ; <%> <*> this . flow _ layout _ panel = new system . windows . forms . flow _ layout _ panel ( ) ; this . panel = new system . windows . forms . panel ( ) ; this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ; this . text _ box = new system . windows . forms . text _ box ( ) ; this . combo _ box = new system . windows . forms . combo _ box ( ) ; -> this . calculation _ container = new system . windows . forms . flow _ layout _ panel ( ) ; </%>
( ( system . component _ model . i _ support _ initialize ) ( this . statistics _ chart ) ) . begin _ init ( ) ; <%> <+> ( ( system . component _ model . i _ support _ initialize ) ( this . binding _ configuration ) ) . begin _ init ( ) ; </%> this . group _ box . suspend _ layout ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . begin _ init ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . suspend _ layout ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . begin _ init ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . panel . suspend _ layout ( ) ;
( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . begin _ init ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . suspend _ layout ( ) ; <%> <-> this . flow _ layout _ panel . suspend _ layout ( ) ; this . panel . suspend _ layout ( ) ; </%> this . suspend _ layout ( ) ; this . statistics _ chart . back _ color = system . drawing . color . transparent ; chart _ area . axis _ x . major _ grid . enabled = false ; chart _ area . axis _ y . major _ grid . enabled = false ;
this . suspend _ layout ( ) ; this . statistics _ chart . back _ color = system . drawing . color . transparent ; chart _ area . axis _ x . major _ grid . enabled = false ; chart _ area . axis _ y . major _ grid . enabled = false ; chart _ area . axis . major _ grid . enabled = false ; chart _ area . back _ color = system . drawing . color . transparent ; chart _ area . name = STR ; this . statistics _ chart . chart _ areas . add ( chart _ area ) ; this . statistics _ chart . dock = system . windows . forms . dock _ style . fill ; legend . back _ color = system . drawing . color . transparent ;
<%> <+> this . split _ container . panel . controls . add ( this . cancel _ button ) ; this . split _ container . panel . controls . add ( this . ok _ button ) ; </%> this . split _ container . panel . controls . add ( this . group _ box ) ; this . split _ container . panel . controls . add ( this . statistics _ chart ) ; this . split _ container . size = new system . drawing . size ( NUM , NUM ) ; this . split _ container . splitter _ distance = NUM ; this . split _ container . splitter _ width = NUM ; this . split _ container . tab _ index = NUM ; this . split _ container . dock = system . windows . forms . dock _ style . fill ; this . split _ container . fixed _ panel = system . windows . forms . fixed _ panel . panel ;
this . split _ container . panel . controls . add ( this . label ) ; this . split _ container . panel . controls . add ( this . label ) ; this . split _ container . panel . controls . add ( this . label ) ; this . split _ container . panel . controls . add ( this . <%> <+> by _ isp _ </%> check _ box ) ; this . split _ container . panel . controls . add ( this . label ) ; this . split _ container . panel . controls . add ( this . split _ container ) ; this . split _ container . size = new system . drawing . size ( NUM , NUM ) ; this . split _ container . splitter _ distance = NUM ; this . split _ container . splitter _ width = NUM ; this . split _ container . tab _ index = NUM ;
this . split _ container . panel . controls . add ( this . label ) ; this . split _ container . panel . controls . add ( this . split _ container ) ; this . split _ container . size = new system . drawing . size ( NUM , NUM ) ; this . split _ container . splitter _ distance = NUM ; this . split _ container . splitter _ width = NUM ; this . split _ container . tab _ index = NUM ; <%> <*> this . numeric _ up _ down . location = new system . drawing . point ( NUM , NUM ) ; this . numeric _ up _ down . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . numeric _ up _ down . maximum = new decimal ( new int [ ] { NUM , -> this . label . auto _ size = true ; </%>
NUM , 0 , 0 , 0 } ) ; <%> <*> this . numeric _ up _ down . name = STR ; this . numeric _ up _ down . size = new system . drawing . size ( NUM , NUM ) ; this . numeric _ up _ down . tab _ index = NUM ; this . numeric _ up _ down . value = new decimal ( new int [ ] { -> this . data _ collection _ minutes _ num . location = new system . drawing . point ( NUM , NUM ) ; </%> <%> <+> this . data _ collection _ minutes _ num . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; </%>
NUM , 0 , 0 , 0 } ) ; this . label . auto _ size = true ; this . label . location = new system . drawing . point ( NUM , NUM ) ; this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ; this . label . tab _ index = NUM ; this . label . text = STR ;
( ( system . component _ model . i _ support _ initialize ) ( this . statistics _ chart ) ) . end _ init ( ) ; <%> <+> ( ( system . component _ model . i _ support _ initialize ) ( this . binding _ configuration ) ) . end _ init ( ) ; </%> this . group _ box . resume _ layout ( false ) ; this . group _ box . perform _ layout ( ) ; this . split _ container . panel . resume _ layout ( false ) ; this . split _ container . panel . resume _ layout ( false ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . end _ init ( ) ; this . split _ container . resume _ layout ( false ) ; this . split _ container . panel . resume _ layout ( false ) ; this . split _ container . panel . perform _ layout ( ) ;
this . split _ container . panel . resume _ layout ( false ) ; this . split _ container . panel . perform _ layout ( ) ; this . split _ container . panel . resume _ layout ( false ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . end _ init ( ) ; this . split _ container . resume _ layout ( false ) ; <%> <-> this . flow _ layout _ panel . resume _ layout ( false ) ; this . flow _ layout _ panel . perform _ layout ( ) ; this . panel . resume _ layout ( false ) ; this . panel . perform _ layout ( ) ; </%> this . resume _ layout ( false ) ;
this . resume _ layout ( false ) ; } private system . windows . forms . data _ visualization . charting . chart statistics _ chart ; private system . windows . forms . check _ box <%> <+> by _ isp _ </%> check _ box ; private system . windows . forms . label label ; private system . windows . forms . label label ; private system . windows . forms . label label ; private system . windows . forms . group _ box group _ box ; private system . windows . forms . radio _ button radio _ button ; private system . windows . forms . radio _ button radio _ button ;
private system . windows . forms . label label ; private system . windows . forms . label label ; private system . windows . forms . label label ; private system . windows . forms . group _ box group _ box ; private system . windows . forms . radio _ button radio _ button ; private system . windows . forms . radio _ button radio _ button ; private system . windows . forms . split _ container split _ container ; private system . windows . forms . label label ; private system . windows . forms . split _ container split _ container ; private system . windows . forms . flow _ layout _ panel <%> <*> flow _ layout -> calculation </%> _ <%> <*> panel -> container </%> ;
private system . windows . forms . split _ container split _ container ; <%> <*> private system . windows . forms . panel panel ; private system . windows . forms . label label ; private system . windows . forms . label label ; private system . windows . forms . text _ box text _ box ; private system . windows . forms . combo _ box combo _ box ; private system . windows . forms . numeric _ up _ down numeric _ up _ down ; -> private system . windows . forms . numeric _ up _ down repeat _ times _ num ; </%> private system . windows . forms . label label ; <%> <-> private system . windows . forms . check _ box check _ box ; </%>
private system . windows . forms . label label ; <%> <*> private system . windows . forms . check _ box check _ box ; private system . windows . forms . numeric _ up _ down numeric _ up _ down ; -> private system . windows . forms . check _ box by _ hour _ of _ day _ check _ box ; </%> <%> <+> private system . windows . forms . numeric _ up _ down choice _ kept _ minutes _ num ; private system . windows . forms . check _ box statistics _ enabled _ check _ box ; private system . windows . forms . label label ; private system . windows . forms . label label ; private system . windows . forms . numeric _ up _ down data _ collection _ minutes _ num ; private system . windows . forms . binding _ source binding _ configuration ; </%>
} }
{ private readonly shadowsocks _ controller controller ; private server current _ server ; private readonly timer timer ; private dictionary < string , statistics _ data > statistics ; private const int cached _ interval = NUM * NUM * NUM ; private const int retry _ interval = 2 * NUM * NUM ; <%> <*> public simply _ choose _ by _ statistics _ strategy ( shadowsocks _ controller controller ) -> public class statistics _ data </%> <%> <+> { </%>
{ controller = controller ; var servers = controller . get _ current _ configuration ( ) . configs ; var random _ index = new random ( ) . next ( ) % servers . count ( ) ; current _ server = servers [ random _ index ] ; timer = new timer ( reload _ statistics _ and _ choose _ a _ server ) ; } private void reload _ statistics _ and _ choose _ a _ server ( object obj ) { logging . debug ( STR ) ;
{ var statistics _ strategy _ options _ form = new statistics _ strategy _ <%> <*> options -> configuration </%> _ form ( <%> <+> controller </%> ) ;

current _ server = best _ result . server ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; } } <%> <+> public </%> string <%> <-> i _ strategy . </%> id { get { return STR ; }
{ get { return STR ; } } <%> <+> public </%> string <%> <-> i _ strategy . </%> name { get { return n . get _ string ( STR ) ; } } <%> <+> public </%> server <%> <-> i _ strategy . </%> get _ a _ server ( i _ strategy _ caller _ type type , ip _ end _ point local _ ip _ end _ point ) { <%> <-> console . write _ line ( STR , current _ server . friendly _ name ( ) ) ; </%>
{ get { return n . get _ string ( STR ) ; } } <%> <+> public </%> server <%> <-> i _ strategy . </%> get _ a _ server ( i _ strategy _ caller _ type type , ip _ end _ point local _ ip _ end _ point ) { <%> <*> console . write _ line ( STR , current _ server . friendly _ name ( ) ) ; -> var old _ server = current _ server ; </%> <%> <+> if ( old _ server = = null ) { choose _ new _ server ( controller . get _ current _ configuration ( ) . configs ) ; </%>
{ <%> <*> console . write _ line ( STR , current _ server . friendly _ name ( ) ) ; -> var old _ server = current _ server ; </%> <%> <+> if ( old _ server = = null ) { choose _ new _ server ( controller . get _ current _ configuration ( ) . configs ) ; } if ( old _ server ! = current _ server ) { } </%>
return current _ server ; } <%> <+> public </%> void <%> <-> i _ strategy . </%> reload _ servers ( ) { choose _ new _ server ( controller . get _ current _ configuration ( ) . configs ) ; timer ? . change ( 0 , cached _ interval ) ; } <%> <+> public </%> void <%> <-> i _ strategy . </%> set _ failure ( server server ) { logging . debug ( string . format ( STR , server . friendly _ name ( ) ) ) ;
{ choose _ new _ server ( controller . get _ current _ configuration ( ) . configs ) ; timer ? . change ( 0 , cached _ interval ) ; } <%> <+> public </%> void <%> <-> i _ strategy . </%> set _ failure ( server server ) { logging . debug ( string . format ( STR , server . friendly _ name ( ) ) ) ; } <%> <+> public </%> void <%> <-> i _ strategy . </%> update _ last _ read ( server server ) {
{ logging . debug ( string . format ( STR , server . friendly _ name ( ) ) ) ; } <%> <+> public </%> void <%> <-> i _ strategy . </%> update _ last _ read ( server server ) { } <%> <+> public </%> void <%> <-> i _ strategy . </%> update _ last _ write ( server server ) { } <%> <+> public </%> void <%> <-> i _ strategy . </%> update _ latency ( server server , time _ span latency )
{ } <%> <+> public </%> void <%> <-> i _ strategy . </%> update _ last _ write ( server server ) { } <%> <+> public </%> void <%> <-> i _ strategy . </%> update _ latency ( server server , time _ span latency ) { } } }
{ } <%> <+> public </%> void <%> <-> i _ strategy . </%> update _ latency ( server server , time _ span latency ) { } } }
{ } } }
load _ server _ name _ list _ to _ ui ( modified _ configuration ) ; servers _ list _ box . selected _ index = modified _ configuration . configs . count - 1 ; last _ selected _ index = servers _ list _ box . selected _ index ; } private void duplicate _ button _ click ( object sender , event _ args e ) { <%> <*> if ( ! validate _ and _ save _ selected _ server _ details ( ) ) -> if ( last _ selected _ index = = - 1 | | last _ selected _ index > modified _ configuration . configs . count </%> <%> <+> | | ! validate _ and _ save _ selected _ server _ details ( ) ) </%> {
{ return ; } server curr _ server = modified _ configuration . configs [ last _ selected _ index ] ; var curr _ index = modified _ configuration . configs . index _ of ( curr _ server ) ; modified _ configuration . configs . insert ( curr _ index + 1 , curr _ server ) ; load _ server _ name _ list _ to _ ui ( modified _ configuration ) ; servers _ list _ box . selected _ index = curr _ index + 1 ; last _ selected _ index = servers _ list _ box . selected _ index ; }
} else if ( ! register ) { unregister _ application _ restart ( ) ; logging . debug ( STR ) ; } } } }
{ <%> <+> args = args ; </%> if ( ! utils . is _ win _ vista _ or _ higher ( ) ) { message _ box . show ( n . get _ string ( STR ) , STR , message _ box _ buttons . ok , message _ box _ icon . error ) ; return ; } if ( ! utils . is _ supported _ runtime _ version ( ) ) {
} private byte [ ] merge _ sort ( byte [ ] array , <%> <*> u _ int -> ulong </%> a , int j ) { if ( array . length = = 1 ) return array ; int middle = array . length / 2 ; byte [ ] left = new byte [ middle ] ; for ( int i = 0 ; i < middle ; i + + ) { left [ i ] = array [ i ] ;
{ if ( array . length = = 1 ) return array ; int middle = array . length / 2 ; byte [ ] left = new byte [ middle ] ; for ( int i = 0 ; i < middle ; i + + ) { left [ i ] = array [ i ] ; } byte [ ] right = new byte [ array . length - middle ] ;
socket _ type . stream , protocol _ type . tcp ) ; ip _ end _ point local _ end _ point = new ip _ end _ point ( 0 , port ) ; listener . bind ( local _ end _ point ) ; listener . listen ( NUM ) ; console . write _ line ( STR ) ; listener . begin _ accept ( new async _ callback ( accept _ callback ) , listener ) ; <%> <+> } public void stop ( ) </%>
application . enable _ visual _ styles ( ) ; application . set _ compatible _ text _ rendering _ default ( false ) ; application . run ( new form ( ) ) ; <%> <+> local . stop ( ) ; </%> } } }
} else { remote . shutdown ( socket _ shutdown . send ) ; remote _ shutdown = true ; check _ close ( ) ; } } catch ( exception e ) {
private const string statistics _ files _ name = STR ; private const string delimiter = STR ; private const int timeout = NUM ; private <%> <*> const int -> readonly time _ span </%> delay _ before _ start = <%> <*> NUM ; -> time _ span . from _ seconds ( 1 ) ; </%> public statistics raw _ statistics { get ; private set ; } public statistics filtered _ statistics { get ; private set ; } public static readonly date _ time unknown _ date _ time = new date _ time ( NUM , 1 , 1 ) ; private int repeat = > config . repeat _ times _ num ; private <%> <*> const int -> readonly time _ span </%> retry _ interval = <%> <*> 2 * NUM * NUM -> time _ span . from _ minutes ( 2 ) </%> ; private <%> <*> int -> time _ span </%> interval = > <%> <-> ( int ) </%> time _ span . from _ minutes ( config . data _ collection _ minutes ) <%> <-> . total _ milliseconds </%> ;
public statistics raw _ statistics { get ; private set ; } public statistics filtered _ statistics { get ; private set ; } public static readonly date _ time unknown _ date _ time = new date _ time ( NUM , 1 , 1 ) ; private int repeat = > config . repeat _ times _ num ; private <%> <*> const int -> readonly time _ span </%> retry _ interval = <%> <*> 2 * NUM * NUM -> time _ span . from _ minutes ( 2 ) </%> ; private <%> <*> int -> time _ span </%> interval = > <%> <-> ( int ) </%> time _ span . from _ minutes ( config . data _ collection _ minutes ) <%> <-> . total _ milliseconds </%> ; private timer timer ; <%> <+> private timer speed _ monior ; </%> private state state ; private list < server > servers ;
private timer timer ; <%> <+> private timer speed _ monior ; </%> private state state ; private list < server > servers ; private statistics _ strategy _ configuration config ; <%> <+> private const string empty = STR ; </%> public static string availability _ statistics _ file ; <%> <+> private int inbound _ speed = 0 ; private int outbound _ speed = 0 ; private int? latency = 0 ; </%>
} public bool set ( statistics _ strategy _ configuration config ) { config = config ; try { if ( config . statistics _ enabled ) { if ( timer ? . change ( delay _ before _ start , interval ) = = null ) {
append ( data _ list , geolocation _ and _ isp . result ) ; } } } private static void append ( data _ list data _ list , i _ enumerable < data _ unit > extra ) { var data = data _ list . concat ( extra ) ; var data _ line = string . join ( delimiter , data . select ( kv = > kv . value ) . to _ array ( ) ) ; string [ ] lines ; if ( ! file . exists ( availability _ statistics _ file ) )
try { <%> <+> process . kill ( ) ; </%> process . wait _ for _ exit ( ) ; } catch ( invalid _ operation _ exception ) { } process = null ; }
{ <%> <+> ip _ global _ properties properties = ip _ global _ properties . get _ ip _ global _ properties ( ) ; ip _ end _ point [ ] tcp _ end _ points = properties . get _ active _ tcp _ listeners ( ) ; list < int > used _ ports = new list < int > ( ) ; foreach ( ip _ end _ point end _ point in ip _ global _ properties . get _ ip _ global _ properties ( ) . get _ active _ tcp _ listeners ( ) ) { </%> used _ ports . add ( end _ point . port ) ; <%> <+> } for ( int port = default _ port ; port < NUM ; port + + ) { </%>
} <%> <*> for ( int port = NUM ; port < NUM ; port + + -> catch ( exception e </%> ) { <%> <*> if ( ! used _ ports . contains ( port ) ) { return port ; } -> logging . log _ useful _ exception ( e ) ; </%> <%> <+> return default _ port ; </%> }
{ <%> <*> if ( ! used _ ports . contains ( port ) ) { return port ; } -> logging . log _ useful _ exception ( e ) ; </%> <%> <+> return default _ port ; </%> } throw new exception ( STR ) ; }
} throw new exception ( STR ) ; } } }
switch _ allow _ lan _ text _ box . text = config . switch _ allow _ lan ; show _ logs _ text _ box . text = config . show _ logs ; server _ move _ up _ text _ box . text = config . server _ move _ up ; server _ move _ down _ text _ box . text = config . server _ move _ down ; } private void update _ texts ( ) { switch _ system _ proxy _ label . text = n . get _ string ( STR ) ; <%> <-> change _ to _ pac _ label . text = n . get _ string ( STR ) ; change _ to _ global _ label . text = n . get _ string ( STR ) ; </%>
switch _ allow _ lan _ label . text = n . get _ string ( STR ) ; show _ logs _ label . text = n . get _ string ( STR ) ; server _ move _ up _ label . text = n . get _ string ( STR ) ; server _ move _ down _ label . text = n . get _ string ( STR ) ; btn _ ok . text = n . get _ string ( STR ) ; btn _ cancel . text = n . get _ string ( STR ) ; btn _ register _ all . text = n . get _ string ( STR ) ; this . text = n . get _ string ( STR ) ; } private void hotkey _ down ( object sender , key _ event _ args e )
public string switch _ allow _ lan ; public string show _ logs ; public string server _ move _ up ; public string server _ move _ down ; public hotkey _ config ( ) { switch _ system _ proxy = STR ; <%> <*> change _ to _ pac = STR ; change _ to _ global = STR ; -> switch _ system _ proxy _ mode = STR ; </%>
switch _ allow _ lan = STR ; show _ logs = STR ; server _ move _ up = STR ; server _ move _ down = STR ; } } }
this . switch _ allow _ lan _ label = new system . windows . forms . label ( ) ; this . show _ logs _ label = new system . windows . forms . label ( ) ; this . server _ move _ up _ label = new system . windows . forms . label ( ) ; this . server _ move _ down _ label = new system . windows . forms . label ( ) ; this . switch _ system _ proxy _ text _ box = new system . windows . forms . text _ box ( ) ; <%> <*> this . change _ to _ pac _ text _ box = new system . windows . forms . text _ box ( ) ; this . change _ to _ global _ text _ box = new system . windows . forms . text _ box ( ) ; -> this . switch _ proxy _ mode _ text _ box = new system . windows . forms . text _ box ( ) ; </%> this . switch _ allow _ lan _ text _ box = new system . windows . forms . text _ box ( ) ; this . show _ logs _ text _ box = new system . windows . forms . text _ box ( ) ;
this . switch _ allow _ lan _ text _ box = new system . windows . forms . text _ box ( ) ; this . show _ logs _ text _ box = new system . windows . forms . text _ box ( ) ; this . server _ move _ up _ text _ box = new system . windows . forms . text _ box ( ) ; this . server _ move _ down _ text _ box = new system . windows . forms . text _ box ( ) ; flow _ layout _ panel = new system . windows . forms . flow _ layout _ panel ( ) ; flow _ layout _ panel . suspend _ layout ( ) ; this . table _ layout _ panel . suspend _ layout ( ) ; this . suspend _ layout ( ) ; this . table _ layout _ panel . set _ column _ span ( flow _ layout _ panel , 2 ) ; flow _ layout _ panel . controls . add ( this . btn _ ok ) ;
this . table _ layout _ panel . controls . add ( this . switch _ system _ proxy _ text _ box , 1 , 0 ) ; <%> <-> this . table _ layout _ panel . controls . add ( this . change _ to _ pac _ text _ box , 1 , 1 ) ; </%> this . table _ layout _ panel . controls . add ( this . <%> <*> change -> switch </%> _ <%> <*> to -> proxy </%> _ <%> <*> global -> mode </%> _ text _ box , 1 , <%> <*> 2 -> 1 </%> ) ; this . table _ layout _ panel . controls . add ( this . switch _ allow _ lan _ text _ box , 1 , <%> <*> NUM -> 2 </%> ) ; this . table _ layout _ panel . controls . add ( this . show _ logs _ text _ box , 1 , NUM ) ; this . table _ layout _ panel . controls . add ( this . server _ move _ up _ text _ box , 1 , NUM ) ; this . table _ layout _ panel . controls . add ( this . server _ move _ down _ text _ box , 1 , NUM ) ; this . table _ layout _ panel . dock = system . windows . forms . dock _ style . fill ; this . table _ layout _ panel . location = new system . drawing . point ( 0 , 0 ) ; this . table _ layout _ panel . name = STR ;
this . table _ layout _ panel . dock = system . windows . forms . dock _ style . fill ; this . table _ layout _ panel . location = new system . drawing . point ( 0 , 0 ) ; this . table _ layout _ panel . name = STR ; this . table _ layout _ panel . row _ count = NUM ; this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ; this . table _ layout _ panel . tab _ index = 0 ; this . switch _ system _ proxy _ label . auto _ size = true ; this . switch _ system _ proxy _ label . dock = system . windows . forms . dock _ style . right ; this . switch _ system _ proxy _ label . location = new system . drawing . point ( NUM , 0 ) ; this . switch _ system _ proxy _ label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ;
private system . windows . forms . label switch _ allow _ lan _ label ; private system . windows . forms . label show _ logs _ label ; private system . windows . forms . label server _ move _ up _ label ; private system . windows . forms . label server _ move _ down _ label ; private system . windows . forms . button btn _ ok ; private system . windows . forms . button btn _ cancel ; private system . windows . forms . text _ box show _ logs _ text _ box ; private system . windows . forms . text _ box switch _ allow _ lan _ text _ box ; <%> <-> private system . windows . forms . text _ box change _ to _ global _ text _ box ; private system . windows . forms . text _ box change _ to _ pac _ text _ box ; </%>
private system . windows . forms . text _ box switch _ system _ proxy _ text _ box ; private system . windows . forms . text _ box server _ move _ up _ text _ box ; private system . windows . forms . text _ box server _ move _ down _ text _ box ; private system . windows . forms . button btn _ register _ all ; private system . windows . forms . table _ layout _ panel table _ layout _ panel ; } }
string [ ] run _ list = run _ key . get _ value _ names ( ) ; foreach ( string item in run _ list ) { if ( item <%> <*> . equals ( -> = = </%> key ) <%> <-> ) </%> return true ; else if ( item <%> <*> . equals ( -> = = </%> STR ) <%> <-> ) </%> { string value = convert . to _ string ( run _ key . get _ value ( item ) ) ; if ( path . equals ( value , string _ comparison . invariant _ culture _ ignore _ case ) ) {
return true ; else if ( item <%> <*> . equals ( -> = = </%> STR ) <%> <-> ) </%> { string value = convert . to _ string ( run _ key . get _ value ( item ) ) ; if ( path . equals ( value , string _ comparison . invariant _ culture _ ignore _ case ) ) { run _ key . delete _ value ( item ) ; run _ key . set _ value ( key , path ) ; return true ; }
{ string value = convert . to _ string ( run _ key . get _ value ( item ) ) ; if ( path . equals ( value , string _ comparison . invariant _ culture _ ignore _ case ) ) { run _ key . delete _ value ( item ) ; run _ key . set _ value ( key , path ) ; return true ; } } }
private int _ ptr handle = int _ ptr . zero ; <%> <-> private bool disposed ; </%> public job ( ) { handle = create _ job _ object ( int _ ptr . zero , null ) ; var extended _ info _ ptr = int _ ptr . zero ; var info = new jobobject _ basic _ limit _ information { limit _ flags = 0 } ;
public job ( ) { handle = create _ job _ object ( int _ ptr . zero , null ) ; var extended _ info _ ptr = int _ ptr . zero ; var info = new jobobject _ basic _ limit _ information { limit _ flags = 0 } ; var extended _ info = new jobobject _ extended _ limit _ information {


this . table _ layout _ panel . resume _ layout ( false ) ; this . table _ layout _ panel . perform _ layout ( ) ; this . panel . resume _ layout ( false ) ; this . context _ menu _ strip . resume _ layout ( false ) ; this . resume _ layout ( false ) ; this . perform _ layout ( ) ; } private system . windows . forms . table _ layout _ panel table _ layout _ panel ; private system . windows . forms . label label ; private system . windows . forms . label label ;
} public void close ( ) { connection . close ( ) ; <%> <+> if ( remote ! = null ) { </%> remote . close ( ) ; <%> <+> } </%> } private void connect _ callback ( i _ async _ result ar )
} private void connect _ callback ( i _ async _ result ar ) { try { remote . end _ connect ( ar ) ; console . write _ line ( STR , remote . remote _ end _ point . to _ string ( ) ) ; handshake _ receive ( ) ; }
using system _ text ; using system _ io ; using system _ diagnostics ; <%> <+> using simple _ json ; </%> namespace shadowsocks _ csharp { serializable public class config { public string server ;
public bool is _ default ; private static void assert ( bool condition ) { if ( ! condition ) { throw new exception ( STR ) ; } } public static config load ( ) {
try { using ( <%> <*> file -> stream </%> _ <%> <*> stream fs -> reader sr </%> = <%> <+> new stream _ reader ( </%> file . open _ read ( STR ) ) <%> <+> ) </%> { config config = <%> <*> ser -> simple _ json . simple _ json . deserialize _ object < config > ( sr </%> . read <%> <+> _ to </%> _ <%> <*> object -> end </%> ( <%> <*> fs -> ) </%> ) <%> <-> as config </%> ; assert ( ! string . is _ null _ or _ empty ( config . server ) ) ; assert ( ! string . is _ null _ or _ empty ( config . password ) ) ; assert ( config . local _ port > 0 ) ; assert ( config . server _ port > 0 ) ; config . is _ default = false ;
{ config config = <%> <*> ser -> simple _ json . simple _ json . deserialize _ object < config > ( sr </%> . read <%> <+> _ to </%> _ <%> <*> object -> end </%> ( <%> <*> fs -> ) </%> ) <%> <-> as config </%> ; assert ( ! string . is _ null _ or _ empty ( config . server ) ) ; assert ( ! string . is _ null _ or _ empty ( config . password ) ) ; assert ( config . local _ port > 0 ) ; assert ( config . server _ port > 0 ) ; config . is _ default = false ; return config ; } }
assert ( ! string . is _ null _ or _ empty ( config . server ) ) ; assert ( ! string . is _ null _ or _ empty ( config . password ) ) ; assert ( config . local _ port > 0 ) ; assert ( config . server _ port > 0 ) ; config . is _ default = false ; return config ; } } catch ( exception e ) {
try { using ( <%> <*> file -> stream </%> _ <%> <*> stream fs -> writer sw </%> = <%> <+> new stream _ writer ( </%> file . open ( STR , file _ mode . create ) ) <%> <+> ) </%> { <%> <*> ser . write _ object ( fs , config ) ; -> string json _ string = simple _ json . simple _ json . serialize _ object ( new </%> <%> <+> { server = config . server , server _ port = config . server _ port , local _ port = config . local _ port , </%>
{ <%> <*> ser . write _ object ( fs , config ) ; -> string json _ string = simple _ json . simple _ json . serialize _ object ( new </%> <%> <+> { server = config . server , server _ port = config . server _ port , local _ port = config . local _ port , password = config . password } ) ; sw . write ( json _ string ) ; </%>
} } catch ( io _ exception e ) { console . error . write _ line ( e ) ; } } } }
} ) , this . servers _ item = create _ menu _ group ( STR , new <%> <-> system . windows . forms . </%> menu _ item [ ] { this . seperator _ item = new menu _ item ( STR ) , this . config _ item = create _ menu _ item ( STR , new <%> <-> system . </%> event _ handler ( this . config _ click ) ) } ) , new menu _ item ( STR ) , this . auto _ startup _ item = create _ menu _ item ( STR , new <%> <-> system . </%> event _ handler ( this . auto _ startup _ item _ click ) ) , this . share _ over _ lan _ item = create _ menu _ item ( STR , new <%> <-> system . </%> event _ handler ( this . share _ over _ lan _ item _ click ) ) , create _ menu _ item ( STR , new <%> <-> system . </%> event _ handler ( this . edit _ pac _ file _ item _ click ) ) , new menu _ item ( STR ) ,
this . seperator _ item = new menu _ item ( STR ) , this . config _ item = create _ menu _ item ( STR , new <%> <-> system . </%> event _ handler ( this . config _ click ) ) } ) , new menu _ item ( STR ) , this . auto _ startup _ item = create _ menu _ item ( STR , new <%> <-> system . </%> event _ handler ( this . auto _ startup _ item _ click ) ) , this . share _ over _ lan _ item = create _ menu _ item ( STR , new <%> <-> system . </%> event _ handler ( this . share _ over _ lan _ item _ click ) ) , create _ menu _ item ( STR , new <%> <-> system . </%> event _ handler ( this . edit _ pac _ file _ item _ click ) ) , new menu _ item ( STR ) , create _ menu _ item ( STR , new <%> <-> system . </%> event _ handler ( this . qr _ code _ item _ click ) ) , create _ menu _ item ( STR , new <%> <-> system . </%> event _ handler ( this . show _ log _ item _ click ) ) ,
} ) , new menu _ item ( STR ) , this . auto _ startup _ item = create _ menu _ item ( STR , new <%> <-> system . </%> event _ handler ( this . auto _ startup _ item _ click ) ) , this . share _ over _ lan _ item = create _ menu _ item ( STR , new <%> <-> system . </%> event _ handler ( this . share _ over _ lan _ item _ click ) ) , create _ menu _ item ( STR , new <%> <-> system . </%> event _ handler ( this . edit _ pac _ file _ item _ click ) ) , new menu _ item ( STR ) , create _ menu _ item ( STR , new <%> <-> system . </%> event _ handler ( this . qr _ code _ item _ click ) ) , create _ menu _ item ( STR , new <%> <-> system . </%> event _ handler ( this . show _ log _ item _ click ) ) , create _ menu _ item ( STR , new <%> <-> system . </%> event _ handler ( this . config _ click ) ) , new menu _ item ( STR ) ,
new menu _ item ( STR ) , create _ menu _ item ( STR , new <%> <-> system . </%> event _ handler ( this . qr _ code _ item _ click ) ) , create _ menu _ item ( STR , new <%> <-> system . </%> event _ handler ( this . show _ log _ item _ click ) ) , create _ menu _ item ( STR , new <%> <-> system . </%> event _ handler ( this . config _ click ) ) , new menu _ item ( STR ) , create _ menu _ item ( STR , new <%> <-> system . </%> event _ handler ( this . quit _ click ) ) } ) ; } private void controller _ config _ changed ( object sender , event _ args e ) {
new menu _ item ( STR ) , create _ menu _ item ( STR , new <%> <-> system . </%> event _ handler ( this . quit _ click ) ) } ) ; } private void controller _ config _ changed ( object sender , event _ args e ) { load _ current _ configuration ( ) ; update _ tray _ icon ( ) ; } private void controller _ enable _ status _ changed ( object sender , event _ args e )
} ) ; } private void controller _ config _ changed ( object sender , event _ args e ) { load _ current _ configuration ( ) ; update _ tray _ icon ( ) ; } private void controller _ enable _ status _ changed ( object sender , event _ args e ) { enable _ item . checked = controller . get _ configuration ( ) . enabled ;
} load _ library ( dll _ path ) ; } <%> <-> dll _ import _ kernel _ dll private static extern int _ ptr load _ library ( string path ) ; public const int m _ ctx _ size = NUM ; </%> public static byte [ ] m ( byte [ ] input ) { byte [ ] output = new byte [ NUM ] ; <%> <-> mbed _ tls . </%> md ( input , ( uint ) input . length , output ) ;
public static byte [ ] m ( byte [ ] input ) { byte [ ] output = new byte [ NUM ] ; <%> <-> mbed _ tls . </%> md ( input , ( uint ) input . length , output ) ; return output ; } <%> <+> dll _ import _ kernel _ dll private static extern int _ ptr load _ library ( string path ) ; </%> dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl <%> <-> public extern static void md ( byte [ ] input , uint ilen , byte [ ] output ) ; </%>
return output ; } <%> <+> dll _ import _ kernel _ dll private static extern int _ ptr load _ library ( string path ) ; </%> dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl <%> <*> public extern static void md ( byte [ ] input , uint ilen , byte [ ] output ) ; -> public static extern int _ ptr cipher _ info _ from _ string ( string cipher _ name ) ; </%> <%> <+> dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern void cipher _ init ( int _ ptr ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl </%>
} }
private static readonly concurrent _ dictionary < string , byte [ ] > cached _ keys = new concurrent _ dictionary < string , byte [ ] > ( ) ; protected byte [ ] encrypt _ iv ; protected byte [ ] decrypt _ iv ; protected bool decrypt _ iv _ received ; protected bool encrypt _ iv _ sent ; <%> <-> protected int encrypt _ iv _ offset = 0 ; protected int decrypt _ iv _ offset = 0 ; </%> protected string method ; protected int cipher ; <%> <+> protected string cipher _ mbed _ name ; </%>
protected string method ; protected int cipher ; <%> <+> protected string cipher _ mbed _ name ; </%> protected int [ ] cipher _ info ; protected byte [ ] key ; protected int key _ len ; protected int iv _ len ; protected uint counter = 0 ; protected byte [ ] key _ buffer = null ; public iv _ encryptor ( string method , string password , bool onetimeauth , bool isudp )
protected void init _ key ( string method , string password ) { method = method . to _ lower ( ) ; method = method ; string k = method + STR + password ; ciphers = get _ ciphers ( ) ; <%> <*> cipher _ info = ciphers [ method ] ; -> ciphers _ detail = ciphers [ method ] ; </%> <%> <+> cipher _ mbed _ name = ciphers _ detail . keys . first _ or _ default ( ) ; cipher _ info = ciphers [ method ] [ cipher _ mbed _ name ] ; </%>
cipher = cipher _ info [ 2 ] ; if ( cipher = = 0 ) { throw new exception ( STR ) ; } key _ len = <%> <*> ciphers [ method ] -> cipher _ info </%> [ 0 ] ; iv _ len = <%> <*> ciphers [ method ] -> cipher _ info </%> [ 1 ] ; key = cached _ keys . get _ or _ add ( k , ( nk ) = > { byte [ ] passbuf = encoding . ut . get _ bytes ( password ) ;
key = cached _ keys . get _ or _ add ( k , ( nk ) = > { byte [ ] passbuf = encoding . ut . get _ bytes ( password ) ; byte [ ] key = new byte [ NUM ] ; byte [ ] iv = new byte [ NUM ] ; bytes _ to _ key ( passbuf , key ) ; return key ; } ) ; } protected void bytes _ to _ key ( byte [ ] password , byte [ ] key )
} ; protected override <%> <+> dictionary < string , </%> dictionary < string , int [ ] > <%> <+> > </%> get _ ciphers ( ) { return ciphers ; } public static list < string > supported _ ciphers ( ) { return new list < string > ( ciphers . keys ) ; } protected override void cipher _ update ( bool is _ cipher , int length , byte [ ] buf , byte [ ] outbuf )
{ return ciphers ; } public static list < string > supported _ ciphers ( ) { return new list < string > ( ciphers . keys ) ; } protected override void cipher _ update ( bool is _ cipher , int length , byte [ ] buf , byte [ ] outbuf ) { int bytes _ remaining ;
{ run _ single _ <%> <*> polar -> mbed </%> _ <%> <*> ssl -> tls </%> _ encryption _ thread ( ) ; list < thread > threads = new list < thread > ( ) ; for ( int i = 0 ; i < NUM ; i + + ) { thread t = new thread ( new thread _ start ( run _ single _ <%> <*> polar -> mbed </%> _ <%> <*> ssl -> tls </%> _ encryption _ thread ) ) ; threads . add ( t ) ; t . start ( ) ; } foreach ( thread t in threads )
threads . add ( t ) ; t . start ( ) ; } foreach ( thread t in threads ) { t . join ( ) ; } assert . is _ false ( encryption _ failed ) ; } private void run _ single _ <%> <*> polar -> mbed </%> _ <%> <*> ssl -> tls </%> _ encryption _ thread ( )
{ try { for ( int i = 0 ; i < NUM ; i + + ) { i _ encryptor encryptor ; i _ encryptor decryptor ; encryptor = new <%> <*> polar -> mbed </%> _ <%> <*> ssl -> tls </%> _ encryptor ( STR , STR , false , false ) ; decryptor = new <%> <*> polar -> mbed </%> _ <%> <*> ssl -> tls </%> _ encryptor ( STR , STR , false , false ) ; run _ encryption _ round ( encryptor , decryptor ) ;
run _ encryption _ round ( encryptor , decryptor ) ; } } catch { encryption _ failed = true ; throw ; } } test _ method
logging . dump ( STR , ciphertext , ( int ) enc _ clen ) ; clen = ( uint ) enc _ clen ; <%> <-> return ret ; </%> } public override <%> <*> int -> void </%> cipher _ decrypt ( byte [ ] ciphertext , uint clen , byte [ ] plaintext , ref uint plen ) { debug . assert ( sodium _ dec _ subkey ! = null ) ; int ret ; ulong dec _ plen = 0 ; logging . dump ( STR , dec _ nonce , nonce _ len ) ;
} public override <%> <*> int -> void </%> cipher _ decrypt ( byte [ ] ciphertext , uint clen , byte [ ] plaintext , ref uint plen ) { debug . assert ( sodium _ dec _ subkey ! = null ) ; int ret ; ulong dec _ plen = 0 ; logging . dump ( STR , dec _ nonce , nonce _ len ) ; logging . dump ( STR , sodium _ dec _ subkey , key _ len ) ; logging . dump ( STR , ciphertext , ( int ) clen ) ; switch ( cipher )
{ debug . assert ( sodium _ dec _ subkey ! = null ) ; int ret ; ulong dec _ plen = 0 ; logging . dump ( STR , dec _ nonce , nonce _ len ) ; logging . dump ( STR , sodium _ dec _ subkey , key _ len ) ; logging . dump ( STR , ciphertext , ( int ) clen ) ; switch ( cipher ) { case cipher _ chach _ ietfpol :
logging . dump ( STR , plaintext , ( int ) dec _ plen ) ; plen = ( uint ) dec _ plen ; <%> <-> return ret ; </%> } public override void dispose ( ) { } } }
} public override void dispose ( ) { } } }
{ <%> <*> registered _ encryptors . add ( method , typeof ( stream _ mbed _ tls _ encryptor ) ) ; -> if ( ! registered _ encryptors . contains _ key ( method ) ) </%> <%> <+> registered _ encryptors . add ( method , typeof ( stream _ open _ ssl _ encryptor ) ) ; </%> } foreach ( string method in stream _ sodium _ encryptor . supported _ ciphers ( ) ) { <%> <+> if ( ! registered _ encryptors . contains _ key ( method ) ) </%> registered _ encryptors . add ( method , typeof ( stream _ sodium _ encryptor ) ) ; <%> <+> } </%>
} foreach ( string method in stream _ sodium _ encryptor . supported _ ciphers ( ) ) { <%> <+> if ( ! registered _ encryptors . contains _ key ( method ) ) </%> registered _ encryptors . add ( method , typeof ( stream _ sodium _ encryptor ) ) ; <%> <+> } foreach ( string method in stream _ mbed _ tls _ encryptor . supported _ ciphers ( ) ) { if ( ! registered _ encryptors . contains _ key ( method ) ) registered _ encryptors . add ( method , typeof ( stream _ mbed _ tls _ encryptor ) ) ; </%>
} foreach ( string method in aead _ mbed _ tls _ encryptor _ supported _ ciphers ) { <%> <+> if ( ! registered _ encryptors . contains _ key ( method ) ) </%> registered _ encryptors . add ( method , typeof ( aead _ mbed _ tls _ encryptor ) ) ; <%> <-> } foreach ( string method in aead _ sodium _ encryptor _ supported _ ciphers ) { registered _ encryptors . add ( method , typeof ( aead _ sodium _ encryptor ) ) ; </%> }
} } public static i _ encryptor get _ encryptor ( string method , string password ) { if ( method . is _ null _ or _ empty ( ) ) { method = STR ; } method = method . to _ lower _ invariant ( ) ; type t = registered _ encryptors [ method ] ;
debug . assert ( olen = = plen ) ; array . copy ( tagbuf , 0 , ciphertext , ( int ) plen , tag _ len ) ; clen = olen + ( uint ) tag _ len ; <%> <*> return ret -> break </%> ; default : throw new system . exception ( STR ) ; } } public override <%> <*> int -> void </%> cipher _ decrypt ( byte [ ] ciphertext , uint clen , byte [ ] plaintext , ref uint plen ) {
default : throw new system . exception ( STR ) ; } } public override <%> <*> int -> void </%> cipher _ decrypt ( byte [ ] ciphertext , uint clen , byte [ ] plaintext , ref uint plen ) { int ret ; uint olen = 0 ; byte [ ] tagbuf = new byte [ tag _ len ] ; array . copy ( ciphertext , ( int ) ( clen - tag _ len ) , tagbuf , 0 , tag _ len ) ;
{ int ret ; uint olen = 0 ; byte [ ] tagbuf = new byte [ tag _ len ] ; array . copy ( ciphertext , ( int ) ( clen - tag _ len ) , tagbuf , 0 , tag _ len ) ; switch ( cipher ) { case cipher _ aes : ret = mbed _ tls . cipher _ auth _ decrypt ( decrypt _ ctx , dec _ nonce , ( uint ) nonce _ len ,
debug . assert ( olen = = clen - tag _ len ) ; plen = olen ; <%> <*> return ret -> break </%> ; default : throw new system . exception ( STR ) ; } } private bool disposed ; private readonly object lock = new object ( ) ; public override void dispose ( )
default : throw new system . exception ( STR ) ; } } private bool disposed ; private readonly object lock = new object ( ) ; public override void dispose ( ) { dispose ( true ) ; gc . suppress _ finalize ( this ) ;
this . file _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . open _ location _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . exit _ menu _ item = new system . windows . forms . menu _ item ( ) ; <%> <*> this . panel = new system . windows . forms . panel ( ) ; -> this . view _ menu _ item = new system . windows . forms . menu _ item ( ) ; </%> <%> <+> this . clean _ logs _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . change _ font _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . wrap _ text _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . top _ most _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . menu _ item _ separater = new system . windows . forms . menu _ item ( ) ; </%>
this . change _ font _ button = new system . windows . forms . button ( ) ; this . clean _ logs _ button = new system . windows . forms . button ( ) ; this . wrap _ text _ check _ box = new system . windows . forms . check _ box ( ) ; this . table _ layout _ panel = new system . windows . forms . table _ layout _ panel ( ) ; <%> <*> this . top _ most _ check _ box = new system . windows . forms . check _ box ( ) ; this . panel . suspend _ layout ( ) ; -> this . toolbar _ flow _ layout _ panel = new system . windows . forms . flow _ layout _ panel ( ) ; </%> this . table _ layout _ panel . suspend _ layout ( ) ; <%> <+> this . toolbar _ flow _ layout _ panel . suspend _ layout ( ) ; </%>
this . table _ layout _ panel . suspend _ layout ( ) ; <%> <+> this . toolbar _ flow _ layout _ panel . suspend _ layout ( ) ; </%>
<%> <+> this . change _ font _ button . auto _ size = true ; </%> this . change _ font _ button . location = new system . drawing . point ( NUM , NUM ) ; this . change _ font _ button . name = STR ; this . change _ font _ button . size = new system . drawing . size ( NUM , NUM ) ; this . change _ font _ button . tab _ index = 2 ; this . change _ font _ button . text = STR ; this . change _ font _ button . use _ visual _ style _ back _ color = true ; this . change _ font _ button . click + = new system . event _ handler ( this . change _ font _ button _ click ) ; <%> <+> this . clean _ logs _ button . auto _ size = true ; </%> this . clean _ logs _ button . location = new system . drawing . point ( NUM , NUM ) ;
this . change _ font _ button . name = STR ; this . change _ font _ button . size = new system . drawing . size ( NUM , NUM ) ; this . change _ font _ button . tab _ index = 2 ; this . change _ font _ button . text = STR ; this . change _ font _ button . use _ visual _ style _ back _ color = true ; this . change _ font _ button . click + = new system . event _ handler ( this . change _ font _ button _ click ) ; <%> <+> this . clean _ logs _ button . auto _ size = true ; </%> this . clean _ logs _ button . location = new system . drawing . point ( NUM , NUM ) ; this . clean _ logs _ button . name = STR ; this . clean _ logs _ button . size = new system . drawing . size ( NUM , NUM ) ;
this . clean _ logs _ button . name = STR ; this . clean _ logs _ button . size = new system . drawing . size ( NUM , NUM ) ; this . clean _ logs _ button . tab _ index = 1 ; this . clean _ logs _ button . text = STR ; this . clean _ logs _ button . use _ visual _ style _ back _ color = true ; this . clean _ logs _ button . click + = new system . event _ handler ( this . clean _ logs _ button _ click ) ; <%> <+> this . wrap _ text _ check _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( ( system . windows . forms . anchor _ styles . top | system . windows . forms . anchor _ styles . bottom ) | system . windows . forms . anchor _ styles . left ) ) ) ; </%> this . wrap _ text _ check _ box . auto _ size = true ; this . wrap _ text _ check _ box . location = new system . drawing . point ( NUM , NUM ) ;
this . table _ layout _ panel . controls . add ( this . log _ message _ text _ box , 0 , 1 ) ; <%> <+> this . table _ layout _ panel . controls . add ( this . toolbar _ flow _ layout _ panel , 0 , 0 ) ; </%> this . table _ layout _ panel . dock = system . windows . forms . dock _ style . fill ; this . table _ layout _ panel . location = new system . drawing . point ( 0 , 0 ) ; this . table _ layout _ panel . name = STR ; this . table _ layout _ panel . row _ count = 2 ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; <%> <+> this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; </%> this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ; this . table _ layout _ panel . tab _ index = 2 ;
this . table _ layout _ panel . tab _ index = 2 ; this . <%> <*> top -> toolbar </%> _ <%> <*> most -> flow </%> _ <%> <*> check -> layout </%> _ <%> <*> box -> panel </%> . auto _ size = true ; this . <%> <*> top -> toolbar </%> _ <%> <*> most -> flow </%> _ <%> <*> check -> layout </%> _ <%> <*> box -> panel </%> . <%> <*> location = new system -> controls </%> . <%> <*> drawing -> add ( this </%> . <%> <*> point ( NUM , NUM -> clean _ logs _ button </%> ) ; this . <%> <*> top -> toolbar </%> _ <%> <*> most -> flow </%> _ <%> <*> check -> layout </%> _ <%> <*> box -> panel </%> . <%> <*> name = STR ; -> controls . add ( this . change _ font _ button ) ; </%> this . <%> <*> top -> toolbar </%> _ <%> <*> most -> flow </%> _ <%> <*> check -> layout </%> _ <%> <*> box -> panel </%> . <%> <*> size = new system -> controls . add ( this </%> . <%> <*> drawing . size ( NUM , NUM -> wrap _ text _ check _ box </%> ) ; <%> <+> this . toolbar _ flow _ layout _ panel . controls . add ( </%> this . top _ most _ check _ box <%> <*> . tab _ index = NUM -> ) </%> ; this . <%> <*> top -> toolbar </%> _ <%> <*> most -> flow </%> _ <%> <*> check -> layout </%> _ <%> <*> box -> panel </%> . <%> <*> text -> dock </%> = <%> <*> STR ; -> system . windows . forms . dock _ style . fill ; </%> this . <%> <*> top -> toolbar </%> _ <%> <*> most -> flow </%> _ <%> <*> check -> layout </%> _ <%> <*> box -> panel </%> . <%> <*> use _ visual _ style _ back _ color = true -> location = new system . drawing . point ( NUM , NUM ) </%> ; this . <%> <*> top -> toolbar </%> _ <%> <*> most -> flow </%> _ <%> <*> check -> layout </%> _ <%> <*> box -> panel </%> . <%> <*> checked _ changed + -> name </%> = <%> <*> new system . event _ handler ( this . top _ most _ check _ box _ checked _ changed ) ; -> STR ; </%> <%> <+> this . toolbar _ flow _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ; </%>

this . table _ layout _ panel . resume _ layout ( false ) ; this . table _ layout _ panel . perform _ layout ( ) ; <%> <+> this . toolbar _ flow _ layout _ panel . resume _ layout ( false ) ; this . toolbar _ flow _ layout _ panel . perform _ layout ( ) ; </%> this . resume _ layout ( false ) ; } private system . windows . forms . text _ box log _ message _ text _ box ; <%> <-> private system . windows . forms . context _ menu _ strip context _ menu _ strip ; </%> private system . windows . forms . main _ menu main _ menu ; private system . windows . forms . menu _ item file _ menu _ item ;
private system . windows . forms . menu _ item file _ menu _ item ; private system . windows . forms . menu _ item open _ location _ menu _ item ; private system . windows . forms . menu _ item exit _ menu _ item ; <%> <-> private system . windows . forms . panel panel ; </%> private system . windows . forms . check _ box wrap _ text _ check _ box ; private system . windows . forms . button clean _ logs _ button ; private system . windows . forms . button change _ font _ button ; private system . windows . forms . table _ layout _ panel table _ layout _ panel ; private system . windows . forms . check _ box top _ most _ check _ box ; <%> <+> private system . windows . forms . menu _ item view _ menu _ item ; </%>
private system . windows . forms . check _ box wrap _ text _ check _ box ; private system . windows . forms . button clean _ logs _ button ; private system . windows . forms . button change _ font _ button ; private system . windows . forms . table _ layout _ panel table _ layout _ panel ; private system . windows . forms . check _ box top _ most _ check _ box ; <%> <+> private system . windows . forms . menu _ item view _ menu _ item ; private system . windows . forms . menu _ item clean _ logs _ menu _ item ; private system . windows . forms . menu _ item change _ font _ menu _ item ; private system . windows . forms . menu _ item wrap _ text _ menu _ item ; private system . windows . forms . menu _ item top _ most _ menu _ item ; </%>
} private void clean _ logs _ button _ click ( object sender , event _ args e ) { <%> <*> log _ message -> do </%> _ <%> <*> text -> clean </%> _ <%> <*> box . clear -> logs </%> ( ) ; } <%> <*> private void change _ font _ button _ click ( object sender , event _ args e ) -> private void do _ change _ font ( ) </%> { font _ dialog fd = new font _ dialog ( ) ; fd . font = log _ message _ text _ box . font ;
{ font _ dialog fd = new font _ dialog ( ) ; fd . font = log _ message _ text _ box . font ; if ( fd . show _ dialog ( ) = = dialog _ result . ok ) { log _ message _ text _ box . font = fd . font ; } } <%> <+> private void change _ font _ menu _ item _ click ( object sender , event _ args e ) { </%>
} } }
{ <%> <-> case 1 : read _ address ( NUM + 2 - 1 ) ; break ; case NUM : int len = connetion _ recv _ buffer [ NUM ] ; read _ address ( len + 2 ) ; break ; case NUM : read _ address ( NUM + 2 - 1 ) ; </%>
} } } else { logging . debug ( STR ) ; close ( ) ; } } catch ( exception e )
{ array . copy ( connetion _ recv _ buffer , NUM , connetion _ recv _ buffer , 0 , 2 ) ; connection . begin _ receive ( connetion _ recv _ buffer , 2 , recv _ size - 2 , socket _ flags . none , on _ address _ fully _ read , <%> <+> new object [ ] { </%> bytes _ remain <%> <+> , on _ success } </%> ) ; } private void on _ address _ fully _ read ( i _ async _ result ar ) { if ( closed ) return ; try { int bytes _ read = connection . end _ receive ( ar ) ;
} private void on _ address _ fully _ read ( i _ async _ result ar ) { if ( closed ) return ; try { int bytes _ read = connection . end _ receive ( ar ) ; <%> <*> int bytes _ remain = ( int ) ar . async _ state ; -> var states = ( object [ ] ) ar . async _ state ; </%> <%> <+> int bytes _ remain = ( int ) states [ 0 ] ; </%>
if ( bytes _ read > = bytes _ remain ) { first _ packet _ length = bytes _ read + 2 ; int atyp = connetion _ recv _ buffer [ 0 ] ; string dst _ addr = STR ; int dst _ port = - 1 ; switch ( atyp ) { case 1 : dst _ addr = new ip _ address ( connetion _ recv _ buffer . skip ( 1 ) . take ( NUM ) . to _ array ( ) ) . to _ string ( ) ;
} <%> <*> else { return remarks + STR + server + STR + server _ port + STR ; } -> return null ; </%> } public server ( ) { server = STR ;
} public server ( ) { server = STR ; server _ port = NUM ; method = STR ; password = STR ; remarks = STR ; auth = false ; }
if ( request _ line _ count = = 0 ) { var m = http _ request _ header _ regex . match ( line ) ; if ( m . success ) { <%> <*> var method = m . groups [ 1 ] . value ; -> var method = m . groups [ STR ] . value ; </%> <%> <+> var path = m . groups [ STR ] . value ; </%> if ( method = = STR ) {
if ( method = = STR ) { is _ connect = true ; if ( ! parse _ host ( <%> <*> m . groups [ 2 ] . value -> path </%> ) ) { throw new exception ( STR + line ) ; } } <%> <+> else { </%>
{ throw new exception ( STR + line ) ; } } <%> <+> else { var target _ url = new uri ( path ) ; if ( ! parse _ host ( target _ url . authority ) ) { throw new exception ( STR + line ) ; </%>
if ( line . is _ null _ or _ empty ( ) ) { return true ; } if ( ! is _ connect ) { if ( line . starts _ with ( STR ) ) { if ( ! parse _ host ( line . substring ( NUM ) . trim ( ) ) ) {
byte [ ] response = { NUM , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 } ; connection . begin _ send ( response , 0 , response . length , 0 , new async _ callback ( start _ <%> <*> pipe -> connect </%> ) , null ) ; } else { console . write _ line ( STR ) ; this . close ( ) ; } } catch ( exception e )
} else { console . write _ line ( STR ) ; this . close ( ) ; } } catch ( exception e ) { logging . log _ useful _ exception ( e ) ;
this . pac _ url _ text _ box . max _ length = NUM ; this . pac _ url _ text _ box . name = STR ; this . pac _ url _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . pac _ url _ text _ box . tab _ index = NUM ; this . pac _ url _ text _ box . word _ wrap = false ; <%> <+> this . pac _ url _ label . anchor = system . windows . forms . anchor _ styles . left ; </%> this . pac _ url _ label . auto _ size = true ; this . pac _ url _ label . location = new system . drawing . point ( NUM , NUM ) ; <%> <+> this . pac _ url _ label . margin = new system . windows . forms . padding ( NUM ) ; </%> this . pac _ url _ label . name = STR ;
this . pac _ url _ label . name = STR ; this . pac _ url _ label . size = new system . drawing . size ( NUM , NUM ) ; this . pac _ url _ label . tab _ index = NUM ; this . pac _ url _ label . text = STR ; <%> <+> this . pac _ url _ label . text _ align = system . drawing . content _ alignment . middle _ left ; </%> this . ok _ button . location = new system . drawing . point ( NUM , NUM ) ; this . ok _ button . name = STR ; this . ok _ button . size = new system . drawing . size ( NUM , NUM ) ; this . ok _ button . tab _ index = NUM ; this . ok _ button . text = STR ;
this . form _ border _ style = system . windows . forms . form _ border _ style . fixed _ single ; this . maximize _ box = false ; this . minimize _ box = false ; this . name = STR ; <%> <+> this . padding = new system . windows . forms . padding ( NUM ) ; </%> this . start _ position = system . windows . forms . form _ start _ position . center _ screen ; this . text = STR ; this . load + = new system . event _ handler ( this . pac _ url _ form _ load ) ; <%> <+> this . table _ layout _ panel . resume _ layout ( false ) ; this . table _ layout _ panel . perform _ layout ( ) ; </%>
const string encoding = STR ; bool generate _ eci = ( hints ! = null & & hints . contains _ key ( encode _ hint _ type . character _ set ) ) ; mode mode = <%> <+> choose _ </%> mode <%> <*> . byte -> ( content , encoding ) </%> ; bit _ array header _ bits = new bit _ array ( ) ; <%> <-> if ( mode = = mode . byte & & generate _ eci ) { character _ set _ eci eci = character _ set _ eci . get _ character _ set _ eci _ by _ name ( encoding ) ; if ( eci ! = null ) { var eci _ is _ explicit _ disabled = ( hints ! = null & & hints . contains _ key ( encode _ hint _ type . disable _ eci ) ? ( bool ) hints [ encode _ hint _ type . disable _ eci ] : false ) ; </%>
bit _ array header _ bits = new bit _ array ( ) ; <%> <-> if ( mode = = mode . byte & & generate _ eci ) { character _ set _ eci eci = character _ set _ eci . get _ character _ set _ eci _ by _ name ( encoding ) ; if ( eci ! = null ) { var eci _ is _ explicit _ disabled = ( hints ! = null & & hints . contains _ key ( encode _ hint _ type . disable _ eci ) ? ( bool ) hints [ encode _ hint _ type . disable _ eci ] : false ) ; if ( ! eci _ is _ explicit _ disabled ) { append _ eci ( eci , header _ bits ) ; </%>
append _ mode _ info ( mode , header _ bits ) ; bit _ array data _ bits = new bit _ array ( ) ; append _ bytes ( content , mode , data _ bits , encoding ) ; int provisional _ bits _ needed = header _ bits . size + mode . get _ character _ count _ bits ( version . get _ version _ for _ number ( 1 ) ) + data _ bits . size ; version provisional _ version = choose _ version ( provisional _ bits _ needed , ec _ level ) ; int bits _ needed = header _ bits . size + mode . get _ character _ count _ bits ( provisional _ version ) + data _ bits . size ;
} internal static void terminate _ bits ( int num _ data _ bytes , bit _ array bits ) { int capacity = num _ data _ bytes < < NUM ; if ( bits . size > capacity ) { throw new <%> <+> writer _ </%> exception ( STR + bits . size + STR + capacity ) ; } for ( int i = 0 ; i < NUM & & bits . size < capacity ; + + i )
} if ( num _ rs _ blocks ! = num _ rs _ blocks _ in _ group + num _ rs _ blocks _ in _ group ) { throw new <%> <+> writer _ </%> exception ( STR ) ; } if ( num _ total _ bytes ! = ( ( num _ data _ bytes _ in _ group + num _ ec _ bytes _ in _ group ) * num _ rs _ blocks _ in _ group ) + ( ( num _ data _ bytes _ in _ group + num _ ec _ bytes _ in _ group ) * num _ rs _ blocks _ in _ group ) )
} if ( num _ total _ bytes ! = ( ( num _ data _ bytes _ in _ group + num _ ec _ bytes _ in _ group ) * num _ rs _ blocks _ in _ group ) + ( ( num _ data _ bytes _ in _ group + num _ ec _ bytes _ in _ group ) * num _ rs _ blocks _ in _ group ) ) { throw new <%> <+> writer _ </%> exception ( STR ) ; } if ( block _ id < num _ rs _ blocks _ in _ group )
} if ( block _ id < num _ rs _ blocks _ in _ group ) { num _ data _ bytes _ in _ block [ 0 ] = num _ data _ bytes _ in _ group ; num _ ec _ bytes _ in _ block [ 0 ] = num _ ec _ bytes _ in _ group ; } else { num _ data _ bytes _ in _ block [ 0 ] = num _ data _ bytes _ in _ group ; num _ ec _ bytes _ in _ block [ 0 ] = num _ ec _ bytes _ in _ group ;
} bits . append _ bits ( num _ letters , num _ bits ) ; } internal static void append _ bytes ( string content , mode mode , bit _ array bits , string encoding ) { <%> <+> if ( mode . equals ( mode . numeric ) ) append _ numeric _ bytes ( content , bits ) ; </%>
} internal static void append _ bit _ bytes ( string content , bit _ array bits , string encoding ) { byte [ ] bytes ; try { bytes = encoding . get _ encoding ( encoding ) . get _ bytes ( content ) ; } catch ( platform _ not _ supported _ exception ) {
} foreach ( byte b in bytes ) { bits . append _ bits ( b , NUM ) ; <%> <+> } } internal static void append _ kanji _ bytes ( string content , bit _ array bits ) { byte [ ] bytes ; try </%>
} matrix [ NUM , matrix . height - NUM ] = 1 ; } private static void embed _ horizontal _ separation _ pattern ( int x _ start , int y _ start , byte _ matrix matrix ) { for ( int x = 0 ; x < NUM ; + + x ) { if ( ! is _ empty ( matrix [ x _ start + x , y _ start ] ) ) { throw new <%> <+> writer _ </%> exception ( ) ;
} matrix [ x _ start + x , y _ start ] = 0 ; } } private static void embed _ vertical _ separation _ pattern ( int x _ start , int y _ start , byte _ matrix matrix ) { for ( int y = 0 ; y < NUM ; + + y ) { if ( ! is _ empty ( matrix [ x _ start , y _ start + y ] ) ) {
} catch ( exception e ) { if ( e is socket _ exception ) { socket _ exception se = ( socket _ exception ) e ; if ( se . socket _ error _ code = = socket _ error . access _ denied ) { e = new exception ( n . get _ string ( STR ) , e ) ; }
{ private static int port = NUM ; public static string pac _ file = STR ; <%> <-> private static configuration config ; socket listener ; </%> file _ system _ watcher watcher ; public event event _ handler pac _ file _ changed ; <%> <*> public void start ( configuration configuration ) -> public pac _ server ( ) </%> <%> <+> { </%>
file _ system _ watcher watcher ; public event event _ handler pac _ file _ changed ; <%> <*> public void start ( configuration configuration ) -> public pac _ server ( ) </%> <%> <+> { this . watch _ pac _ file ( ) ; } public bool handle ( byte [ ] first _ packet , int length , socket socket ) </%> { try
{ try { <%> <*> config = configuration ; listener = new socket ( address _ family . inter _ network , socket _ type . stream , protocol _ type . tcp ) ; listener . set _ socket _ option ( socket _ option _ level . socket , socket _ option _ name . reuse _ address , true ) ; ip _ end _ point local _ end _ point = null ; if ( configuration . share _ over _ lan ) -> string request = encoding . ut . get _ string ( first _ packet , 0 , length ) ; </%> <%> <+> string [ ] lines = request . split ( '\r' , '\n' ) ; </%>
{ <%> <*> local _ end _ point = new ip _ end _ point ( ip _ address . any , port ) ; -> string [ ] kv = line . split ( new char [ ] { ':' } , 2 ) ; </%> <%> <+> if ( kv . length = = 2 ) { if ( kv [ 0 ] = = STR ) { if ( kv [ 1 ] . trim ( ) = = ( ( ip _ end _ point ) socket . local _ end _ point ) . to _ string ( ) ) { host _ match = true ; </%>
} <%> <-> else </%> <%> <+> if ( host _ match & & path _ match ) </%> { <%> <*> local _ end _ point = new ip _ end _ point ( ip _ address . loopback , port ) ; -> send _ response ( first _ packet , length , socket ) ; </%> <%> <+> return true ; </%> } <%> <-> listener . bind ( local _ end _ point ) ; listener . listen ( NUM ) ; listener . begin _ accept ( </%>
{ <%> <*> local _ end _ point = new ip _ end _ point ( ip _ address . loopback , port ) ; -> send _ response ( first _ packet , length , socket ) ; </%> <%> <+> return true ; </%> } <%> <-> listener . bind ( local _ end _ point ) ; listener . listen ( NUM ) ; listener . begin _ accept ( new async _ callback ( accept _ callback ) , listener ) ; </%>
} <%> <*> listener . bind ( local _ end _ point ) ; listener . listen ( NUM ) ; listener . begin _ accept ( new async _ callback ( accept _ callback ) , listener ) ; watch _ pac _ file ( ) ; -> return false ; </%> } catch ( <%> <*> socket -> argument </%> _ exception )
} catch ( <%> <*> socket -> argument </%> _ exception ) { <%> <-> listener . close ( ) ; throw ; } } public void stop ( ) { if ( listener ! = null ) </%>
{ <%> <-> listener . close ( ) ; throw ; } } public void stop ( ) { if ( listener ! = null ) { listener . close ( ) ; </%>
} } public string touch _ pac _ file ( ) { if ( file . exists ( pac _ file ) ) { return pac _ file ; } else {
{ <%> <-> object [ ] state = ( object [ ] ) ar . async _ state ; socket conn = ( socket ) state [ 0 ] ; byte [ ] request _ buf = ( byte [ ] ) state [ 1 ] ; </%> try { <%> <-> int bytes _ read = conn . end _ receive ( ar ) ; </%> string pac = get _ pac _ content ( ) ; ip _ end _ point local _ end _ point = ( ip _ end _ point ) <%> <*> conn -> socket </%> . local _ end _ point ; string proxy = get _ pac _ address ( <%> <*> request -> first </%> _ <%> <*> buf -> packet , length </%> , local _ end _ point ) ;
try { <%> <-> int bytes _ read = conn . end _ receive ( ar ) ; </%> string pac = get _ pac _ content ( ) ; ip _ end _ point local _ end _ point = ( ip _ end _ point ) <%> <*> conn -> socket </%> . local _ end _ point ; string proxy = get _ pac _ address ( <%> <*> request -> first </%> _ <%> <*> buf -> packet , length </%> , local _ end _ point ) ; pac = pac . replace ( STR , proxy ) ; <%> <-> if ( bytes _ read > 0 ) { </%> string text = string . format ( @ STR
string pac = get _ pac _ content ( ) ; ip _ end _ point local _ end _ point = ( ip _ end _ point ) <%> <*> conn -> socket </%> . local _ end _ point ; string proxy = get _ pac _ address ( <%> <*> request -> first </%> _ <%> <*> buf -> packet , length </%> , local _ end _ point ) ; pac = pac . replace ( STR , proxy ) ; <%> <-> if ( bytes _ read > 0 ) { </%> string text = string . format ( @ STR server : shadowsocks content - type : application / x - ns - proxy - autoconfig content - length : { 0 }
pac = pac . replace ( STR , proxy ) ; <%> <-> if ( bytes _ read > 0 ) { </%> string text = string . format ( @ STR server : shadowsocks content - type : application / x - ns - proxy - autoconfig content - length : { 0 } connection : close STR byte [ ] response = system . text . encoding . ut . get _ bytes ( text ) ;
server : shadowsocks content - type : application / x - ns - proxy - autoconfig content - length : { 0 } connection : close STR byte [ ] response = system . text . encoding . ut . get _ bytes ( text ) ; <%> <*> conn -> socket </%> . begin _ send ( response , 0 , response . length , 0 , new async _ callback ( send _ callback ) , <%> <*> conn -> socket </%> ) ; util . utils . release _ memory ( ) ; <%> <-> } else </%>
} catch ( exception e ) { console . write _ line ( e ) ; <%> <*> conn -> socket </%> . close ( ) ; } } private void send _ callback ( i _ async _ result ar ) { socket conn = ( socket ) ar . async _ state ;
} } private void send _ callback ( i _ async _ result ar ) { socket conn = ( socket ) ar . async _ state ; try { conn . shutdown ( socket _ shutdown . send ) ; } catch
{ <%> <*> string proxy = STR + local _ end _ point . address + STR ; return proxy ; -> return STR + local _ end _ point . address + STR ; </%> } } }
} } }
socket . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; handler handler = new handler ( ) ; handler . connection = socket ; server server = config . get _ current _ server ( ) ; handler . encryptor = encryptor _ factory . get _ encryptor ( server . method , server . password ) ; handler . server = server ; handler . start ( first _ packet , length ) ; <%> <+> return true ; </%> } }
{ server = STR , server _ port = NUM , password = STR , method = STR } ; <%> <*> var server _ canon _ url = STR ; var server = new server -> server _ canon _ url = STR ; </%> <%> <+> server = new server </%>
{ server = STR , server _ port = NUM , password = STR , method = STR } ; <%> <-> var </%> server _ canon _ url = STR ; <%> <-> var </%> server _ with _ remark = new server { server = server . server ,
remarks = STR } ; <%> <-> var </%> server _ with _ remark _ canon _ url = STR ; <%> <-> var </%> server _ with _ remark = new server { server = server . server , server _ port = server . server _ port , password = server . password , method = server . method , remarks = STR
{ server = server . server , server _ port = server . server _ port , password = server . password , method = server . method , remarks = STR } ; <%> <-> var </%> server _ with _ remark _ canon _ url = STR ; <%> <-> var </%> server _ with _ plugin = new server {
plugin = STR , plugin _ opts = STR } ; <%> <-> var </%> server _ with _ plugin _ canon _ url = STR ; <%> <-> var </%> server _ with _ plugin = new server { server = server . server , server _ port = server . server _ port , password = server . password ,
STR ; <%> <-> var </%> server _ with _ plugin = new server { server = server . server , server _ port = server . server _ port , password = server . password , method = server . method , plugin = STR , plugin _ opts = STR } ;
{ server = server . server , server _ port = server . server _ port , password = server . password , method = server . method , plugin = STR , plugin _ opts = STR } ; <%> <-> var </%> server _ with _ plugin _ canon _ url = STR ;
STR ; <%> <-> var </%> server _ with _ plugin _ and _ remark = new server { server = server . server , server _ port = server . server _ port , password = server . password , method = server . method , plugin = server _ with _ plugin . plugin , plugin _ opts = server _ with _ plugin . plugin _ opts , remarks = server _ with _ remark . remarks
STR ; <%> <-> var </%> server _ with _ plugin _ and _ remark = new server { server = server . server , server _ port = server . server _ port , password = server . password , method = server . method , plugin = server _ with _ plugin . plugin , plugin _ opts = server _ with _ plugin . plugin _ opts , remarks = server _ with _ remark . remarks
{ server = server . server , server _ port = server . server _ port , password = server . password , method = server . method , plugin = server _ with _ plugin . plugin , plugin _ opts = server _ with _ plugin . plugin _ opts , remarks = server _ with _ remark . remarks } ; <%> <-> var </%> server _ with _ plugin _ and _ remark _ canon _ url =
STR ; <%> <+> } test _ method public void test _ parse _ url _ server ( ) { </%> run _ parse _ shadowsocks _ url _ test ( string . join ( STR , server _ canon _ url , STR ,
STR , STR , server _ with _ remark _ canon _ url , STR ) , new [ ] { server , server , server _ with _ remark , server _ with _ remark
run _ parse _ shadowsocks _ url _ test ( string . join ( STR , server _ canon _ url , STR , STR , server _ with _ remark _ canon _ url , STR ) , new [ ] {
{ <%> <-> string fake _ plugin = STR ; </%> var no _ plugin = sip _ plugin . create _ if _ configured ( new server { server = STR , server _ port = NUM , password = STR , method = STR } ) ; run _ plugin _ support _ test (
var no _ plugin = sip _ plugin . create _ if _ configured ( new server { server = STR , server _ port = NUM , password = STR , method = STR } ) ; run _ plugin _ support _ test ( no _ plugin , STR ,
public hotkey _ settings _ form ( shadowsocks _ controller controller ) { initialize _ component ( ) ; update _ texts ( ) ; icon = icon . from _ handle ( resources . ssw . get _ hicon ( ) ) ; controller = controller ; controller . config _ changed + = controller _ config _ changed ; load _ current _ configuration ( ) ; <%> <-> all _ text _ boxes = table _ layout _ panel . get _ child _ controls < text _ box > ( ) ; if ( ! all _ text _ boxes . any ( ) ) throw new exception ( STR ) ; </%>
} private void update _ texts ( ) { switch _ system _ proxy _ label . text = n . get _ string ( STR ) ; switch _ proxy _ mode _ label . text = n . get _ string ( STR ) ; switch _ allow _ lan _ label . text = n . get _ string ( STR ) ; show _ logs _ label . text = n . get _ string ( STR ) ; server _ move _ up _ label . text = n . get _ string ( STR ) ; server _ move _ down _ label . text = n . get _ string ( STR ) ; btn _ ok . text = n . get _ string ( STR ) ;
} private bool <%> <-> try _ </%> reg _ hotkey _ from _ string ( string hotkey _ str , string callback _ name , label indicator = null ) { var callback = hotkey _ callbacks . get _ callback ( callback _ name ) ; if ( callback = = null ) { throw new exception ( $ STR ) ; } var callback = callback as hot _ keys . hot _ key _ call _ back _ handler ; if ( hotkey _ str . is _ null _ or _ empty ( ) )
{ var callback = hotkey _ callbacks . get _ callback ( callback _ name ) ; if ( callback = = null ) { throw new exception ( $ STR ) ; } var callback = callback as hot _ keys . hot _ key _ call _ back _ handler ; if ( hotkey _ str . is _ null _ or _ empty ( ) ) { <%> <-> unreg _ prev _ hotkey ( callback ) ; </%>
return true ; } else { var hotkey = hot _ keys . str _ hot _ key ( hotkey _ str ) ; if ( hotkey = = null ) { message _ box . show ( string . format ( n . get _ string ( STR ) , hotkey _ str ) ) ; return false ; }
if ( indicator ! = null ) { indicator . back _ color = reg _ result ? color . green : color . yellow ; } return reg _ result ; } } } <%> <-> private bool try _ reg _ hotkey ( global _ hot _ key . hot _ key hotkey , hot _ keys . hot _ key _ call _ back _ handler callback ) { </%>
} }
foreach ( var d in domains ) { string domain = d . value ; switch ( d . type ) { case domain _ object . types . type . plain : ret . add ( <%> <*> domain -> $ STR </%> ) ; break ; case domain _ object . types . type . regex : ret . add ( $ STR ) ;
break ; case domain _ object . types . type . regex : ret . add ( $ STR ) ; break ; case domain _ object . types . type . domain : ret . add ( $ STR ) ; break ; case domain _ object . types . type . full : ret . add ( $ STR ) ; ret . add ( $ STR ) ;

this . table _ layout _ panel . location = new system . drawing . point ( NUM , NUM ) ; this . table _ layout _ panel . margin = new system . windows . forms . padding ( 0 ) ; this . table _ layout _ panel . name = STR ; this . table _ layout _ panel . padding = new system . windows . forms . padding ( NUM ) ; this . table _ layout _ panel . row _ count = NUM ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ;
this . table _ layout _ panel . tab _ index = 0 ; this . plugin _ options _ label . anchor = system . windows . forms . anchor _ styles . right ; this . plugin _ options _ label . auto _ size = true ; this . plugin _ options _ label . location = new system . drawing . point ( NUM , NUM ) ; this . plugin _ options _ label . name = STR ; this . plugin _ options _ label . size = new system . drawing . size ( NUM , NUM ) ; this . plugin _ options _ label . tab _ index = NUM ; this . plugin _ options _ label . text = STR ; this . plugin _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . plugin _ text _ box . location = new system . drawing . point ( NUM , NUM ) ;
return configuration ; } catch ( file _ not _ found _ exception <%> <+> e </%> ) { var configuration = new statistics _ strategy _ configuration ( ) ; save ( configuration ) ; return configuration ; } catch ( exception e ) {
{ var configuration = new statistics _ strategy _ configuration ( ) ; save ( configuration ) ; return configuration ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; return new statistics _ strategy _ configuration ( ) ; }
this . chart _ mode _ selector = new system . windows . forms . group _ box ( ) ; this . all _ mode = new system . windows . forms . radio _ button ( ) ; this . day _ mode = new system . windows . forms . radio _ button ( ) ; this . split _ container = new system . windows . forms . split _ container ( ) ; this . split _ container = new system . windows . forms . split _ container ( ) ; this . <%> <+> collect _ data _ per _ </%> label = new system . windows . forms . label ( ) ; this . <%> <+> minutes _ </%> label = new system . windows . forms . label ( ) ; this . data _ collection _ minutes _ num = new system . windows . forms . numeric _ up _ down ( ) ; this . statistics _ enabled _ check _ box = new system . windows . forms . check _ box ( ) ; this . choice _ kept _ minutes _ num = new system . windows . forms . numeric _ up _ down ( ) ;
this . data _ collection _ minutes _ num = new system . windows . forms . numeric _ up _ down ( ) ; this . statistics _ enabled _ check _ box = new system . windows . forms . check _ box ( ) ; this . choice _ kept _ minutes _ num = new system . windows . forms . numeric _ up _ down ( ) ; this . by _ hour _ of _ day _ check _ box = new system . windows . forms . check _ box ( ) ; this . repeat _ times _ num = new system . windows . forms . numeric _ up _ down ( ) ; this . <%> <+> package _ per _ ping _ </%> label = new system . windows . forms . label ( ) ; this . split _ container = new system . windows . forms . split _ container ( ) ; this . <%> <+> final _ score _ </%> label = new system . windows . forms . label ( ) ; this . calculation _ container = new system . windows . forms . flow _ layout _ panel ( ) ; this . server _ selector = new system . windows . forms . combo _ box ( ) ;
this . split _ container = new system . windows . forms . split _ container ( ) ; this . <%> <+> final _ score _ </%> label = new system . windows . forms . label ( ) ; this . calculation _ container = new system . windows . forms . flow _ layout _ panel ( ) ; this . server _ selector = new system . windows . forms . combo _ box ( ) ; this . cancel _ button = new system . windows . forms . button ( ) ; this . ok _ button = new system . windows . forms . button ( ) ; this . calculatin _ tip = new system . windows . forms . tool _ tip ( this . components ) ; <%> <+> this . binding _ configuration = new system . windows . forms . binding _ source ( this . components ) ; </%> ( ( system . component _ model . i _ support _ initialize ) ( this . statistics _ chart ) ) . begin _ init ( ) ; <%> <-> ( ( system . component _ model . i _ support _ initialize ) ( this . binding _ configuration ) ) . begin _ init ( ) ; </%>
this . calculation _ container = new system . windows . forms . flow _ layout _ panel ( ) ; this . server _ selector = new system . windows . forms . combo _ box ( ) ; this . cancel _ button = new system . windows . forms . button ( ) ; this . ok _ button = new system . windows . forms . button ( ) ; this . calculatin _ tip = new system . windows . forms . tool _ tip ( this . components ) ; <%> <+> this . binding _ configuration = new system . windows . forms . binding _ source ( this . components ) ; </%> ( ( system . component _ model . i _ support _ initialize ) ( this . statistics _ chart ) ) . begin _ init ( ) ; <%> <-> ( ( system . component _ model . i _ support _ initialize ) ( this . binding _ configuration ) ) . begin _ init ( ) ; </%> this . chart _ mode _ selector . suspend _ layout ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . begin _ init ( ) ;
this . chart _ mode _ selector . suspend _ layout ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . begin _ init ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . suspend _ layout ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . begin _ init ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . suspend _ layout ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . data _ collection _ minutes _ num ) ) . begin _ init ( ) ;
this . split _ container . panel . controls . add ( this . data _ collection _ minutes _ num ) ; this . split _ container . panel . controls . add ( this . statistics _ enabled _ check _ box ) ; this . split _ container . panel . controls . add ( this . choice _ kept _ minutes _ num ) ; this . split _ container . panel . controls . add ( this . by _ hour _ of _ day _ check _ box ) ; this . split _ container . panel . controls . add ( this . repeat _ times _ num ) ; this . split _ container . panel . controls . add ( this . <%> <+> package _ per _ ping _ </%> label ) ; this . split _ container . panel . controls . add ( this . <%> <+> keep _ choice _ for _ </%> label ) ; this . split _ container . panel . controls . add ( this . ping _ check _ box ) ; this . split _ container . panel . controls . add ( this . <%> <+> minutes _ </%> label ) ; this . split _ container . panel . controls . add ( this . split _ container ) ;
this . split _ container . panel . controls . add ( this . ping _ check _ box ) ; this . split _ container . panel . controls . add ( this . <%> <+> minutes _ </%> label ) ; this . split _ container . panel . controls . add ( this . split _ container ) ; this . split _ container . size = new system . drawing . size ( NUM , NUM ) ; this . split _ container . splitter _ distance = NUM ; this . split _ container . splitter _ width = NUM ; this . split _ container . tab _ index = NUM ; this . label . auto _ size = true ; this . label . location = new system . drawing . point ( NUM , NUM ) ; this . label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ;
this . split _ container . panel . controls . add ( this . split _ container ) ; this . split _ container . size = new system . drawing . size ( NUM , NUM ) ; this . split _ container . splitter _ distance = NUM ; this . split _ container . splitter _ width = NUM ; this . split _ container . tab _ index = NUM ; this . label . auto _ size = true ; this . label . location = new system . drawing . point ( NUM , NUM ) ; this . label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ; this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ;
this . split _ container . panel . controls . add ( this . calculation _ container ) ; this . split _ container . size = new system . drawing . size ( NUM , NUM ) ; this . split _ container . splitter _ distance = NUM ; this . split _ container . splitter _ width = 1 ; this . split _ container . tab _ index = NUM ; this . <%> <+> final _ score _ </%> label . auto _ size = true ; this . <%> <+> final _ score _ </%> label . location = new system . drawing . point ( NUM , NUM ) ; this . <%> <+> final _ score _ </%> label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ; this . <%> <+> final _ score _ </%> label . name = STR ; this . <%> <+> final _ score _ </%> label . size = new system . drawing . size ( NUM , NUM ) ;
this . calculation _ container . auto _ scroll = true ; this . calculation _ container . dock = system . windows . forms . dock _ style . fill ; this . calculation _ container . location = new system . drawing . point ( 0 , 0 ) ; this . calculation _ container . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . calculation _ container . name = STR ; this . calculation _ container . size = new system . drawing . size ( NUM , NUM ) ; this . calculation _ container . tab _ index = 1 ; this . server _ selector . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . bottom | system . windows . forms . anchor _ styles . right ) ) ) ; this . server _ selector . formatting _ enabled = true ; this . server _ selector . location = new system . drawing . point ( NUM , NUM ) ;
this . chart _ mode _ selector . resume _ layout ( false ) ; this . chart _ mode _ selector . perform _ layout ( ) ; this . split _ container . panel . resume _ layout ( false ) ; this . split _ container . panel . resume _ layout ( false ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . end _ init ( ) ; this . split _ container . resume _ layout ( false ) ; this . split _ container . panel . resume _ layout ( false ) ; this . split _ container . panel . perform _ layout ( ) ; this . split _ container . panel . resume _ layout ( false ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . end _ init ( ) ;
private system . windows . forms . group _ box chart _ mode _ selector ; private system . windows . forms . radio _ button all _ mode ; private system . windows . forms . radio _ button day _ mode ; private system . windows . forms . split _ container split _ container ; private system . windows . forms . label <%> <+> final _ score _ </%> label ; private system . windows . forms . split _ container split _ container ; private system . windows . forms . flow _ layout _ panel calculation _ container ; private system . windows . forms . split _ container split _ container ; private system . windows . forms . numeric _ up _ down repeat _ times _ num ; private system . windows . forms . label <%> <+> package _ per _ ping _ </%> label ;
private system . windows . forms . split _ container split _ container ; private system . windows . forms . flow _ layout _ panel calculation _ container ; private system . windows . forms . split _ container split _ container ; private system . windows . forms . numeric _ up _ down repeat _ times _ num ; private system . windows . forms . label <%> <+> package _ per _ ping _ </%> label ; private system . windows . forms . check _ box by _ hour _ of _ day _ check _ box ; private system . windows . forms . numeric _ up _ down choice _ kept _ minutes _ num ; private system . windows . forms . check _ box statistics _ enabled _ check _ box ; private system . windows . forms . label <%> <+> collect _ data _ per _ </%> label ; private system . windows . forms . label <%> <+> minutes _ </%> label ;
private system . windows . forms . check _ box by _ hour _ of _ day _ check _ box ; private system . windows . forms . numeric _ up _ down choice _ kept _ minutes _ num ; private system . windows . forms . check _ box statistics _ enabled _ check _ box ; private system . windows . forms . label <%> <+> collect _ data _ per _ </%> label ; private system . windows . forms . label <%> <+> minutes _ </%> label ; private system . windows . forms . numeric _ up _ down data _ collection _ minutes _ num ; private system . windows . forms . binding _ source binding _ configuration ; private new system . windows . forms . button cancel _ button ; private system . windows . forms . button ok _ button ; private system . windows . forms . combo _ box server _ selector ;
private system . windows . forms . numeric _ up _ down data _ collection _ minutes _ num ; private system . windows . forms . binding _ source binding _ configuration ; private new system . windows . forms . button cancel _ button ; private system . windows . forms . button ok _ button ; private system . windows . forms . combo _ box server _ selector ; private system . windows . forms . tool _ tip calculatin _ tip ; } }
this . hot _ key _ item = create _ menu _ item ( STR , new event _ handler ( this . hot _ key _ item _ click ) ) , <%> <+> create _ menu _ group ( STR , new menu _ item [ ] { create _ menu _ item ( STR , new event _ handler ( this . show _ log _ item _ click ) ) , this . verbose _ logging _ toggle _ item = create _ menu _ item ( STR , new event _ handler ( this . verbose _ logging _ toggle _ item _ click ) ) , </%> create _ menu _ group ( STR , new menu _ item [ ] { create _ menu _ item ( STR , new event _ handler ( this . check _ updates _ item _ click ) ) , new menu _ item ( STR ) , this . auto _ check _ updates _ toggle _ item = create _ menu _ item ( STR , new event _ handler ( this . auto _ check _ updates _ toggle _ item _ click ) ) , this . check _ pre _ release _ toggle _ item = create _ menu _ item ( STR , new event _ handler ( this . check _ pre _ release _ toggle _ item _ click ) ) , <%> <+> } ) , </%>
} ) , <%> <-> create _ menu _ item ( STR , new event _ handler ( this . about _ item _ click ) ) , </%>

using shadowsocks _ controller _ strategy ; using shadowsocks _ model ; <%> <-> using shadowsocks _ properties ; </%> using shadowsocks _ util ; <%> <-> using system _ linq ; using shadowsocks _ controller _ service ; using shadowsocks _ proxy ; </%> namespace shadowsocks _ controller { public class shadowsocks _ controller
using shadowsocks _ util ; <%> <-> using system _ linq ; using shadowsocks _ controller _ service ; using shadowsocks _ proxy ; </%> namespace shadowsocks _ controller { public class shadowsocks _ controller { private thread ram _ thread ; private thread traffic _ thread ;
namespace shadowsocks _ controller { public class shadowsocks _ controller { private thread ram _ thread ; private thread traffic _ thread ; private listener listener ; private pac _ server pac _ server ; private configuration config ; private strategy _ manager strategy _ manager ;
} public void toggle _ global ( bool global ) { config . global = global ; save _ config ( config ) ; <%> <*> if ( enable _ global _ changed ! = null ) { enable _ global _ changed ( this , new event _ args ( ) ) ; } -> enable _ global _ changed ? . invoke ( this , new event _ args ( ) ) ; </%>
} public void toggle _ share _ over _ lan ( bool enabled ) { config . share _ over _ lan = enabled ; save _ config ( config ) ; <%> <*> if ( share _ over _ lan _ status _ changed ! = null ) { share _ over _ lan _ status _ changed ( this , new event _ args ( ) ) ; } -> share _ over _ lan _ status _ changed ? . invoke ( this , new event _ args ( ) ) ; </%>
} public void save _ proxy ( proxy _ config proxy _ config ) { config . proxy = proxy _ config ; save _ config ( config ) ; } public void toggle _ verbose _ logging ( bool enabled ) { config . is _ verbose _ logging = enabled ; save _ config ( config ) ;
} public void touch _ user _ rule _ file ( ) { string user _ rule _ filename = pac _ server . touch _ user _ rule _ file ( ) ; <%> <*> if ( user _ rule _ file _ ready _ to _ open ! = null ) { user _ rule _ file _ ready _ to _ open ( this , new path _ event _ args ( ) { path = user _ rule _ filename } ) ; } -> user _ rule _ file _ ready _ to _ open ? . invoke ( this , new path _ event _ args ( ) { path = user _ rule _ filename } ) ; </%> }
} public string get _ server _ url _ for _ current _ server ( ) { server server = get _ current _ server ( ) ; return get _ server _ url ( server ) ; } public static string get _ server _ url ( server server ) { string tag = string . empty ; string url = string . empty ;
} public void save _ pac _ url ( string pac _ url ) { config . pac _ url = pac _ url ; save _ config ( config ) ; <%> <*> if ( config _ changed ! = null ) { config _ changed ( this , new event _ args ( ) ) ; } -> config _ changed ? . invoke ( this , new event _ args ( ) ) ; </%>
} public void use _ online _ pac ( bool use _ online _ pac ) { config . use _ online _ pac = use _ online _ pac ; save _ config ( config ) ; <%> <*> if ( config _ changed ! = null ) { config _ changed ( this , new event _ args ( ) ) ; } -> config _ changed ? . invoke ( this , new event _ args ( ) ) ; </%>
} public void toggle _ secure _ local _ pac ( bool enabled ) { config . secure _ local _ pac = enabled ; save _ config ( config ) ; <%> <*> if ( config _ changed ! = null ) { config _ changed ( this , new event _ args ( ) ) ; } -> config _ changed ? . invoke ( this , new event _ args ( ) ) ; </%>
} public void toggle _ checking _ update ( bool enabled ) { config . auto _ check _ update = enabled ; configuration . save ( config ) ; <%> <*> if ( config _ changed ! = null ) { config _ changed ( this , new event _ args ( ) ) ; } -> config _ changed ? . invoke ( this , new event _ args ( ) ) ; </%>
} public void toggle _ checking _ pre _ release ( bool enabled ) { config . check _ pre _ release = enabled ; configuration . save ( config ) ; <%> <*> if ( config _ changed ! = null ) { config _ changed ( this , new event _ args ( ) ) ; } -> config _ changed ? . invoke ( this , new event _ args ( ) ) ; </%>
} public void save _ log _ viewer _ config ( log _ viewer _ config new _ config ) { config . log _ viewer = new _ config ; new _ config . save _ size ( ) ; configuration . save ( config ) ; <%> <-> if ( config _ changed ! = null ) { config _ changed ( this , new event _ args ( ) ) ; } </%>
} public void save _ hotkey _ config ( hotkey _ config new _ config ) { config . hotkey = new _ config ; save _ config ( config ) ; <%> <*> if ( config _ changed ! = null ) { config _ changed ( this , new event _ args ( ) ) ; } -> config _ changed ? . invoke ( this , new event _ args ( ) ) ; </%>
} public void update _ latency ( server server , time _ span latency ) { if ( config . availability _ statistics ) { availability _ statistics . update _ latency ( server , ( int ) latency . total _ milliseconds ) ; } } public void update _ inbound _ counter ( server server , long n ) {
listener = new listener ( services ) ; listener . start ( config ) ; } catch ( exception e ) { if ( e is socket _ exception <%> <+> se </%> ) { <%> <-> socket _ exception se = ( socket _ exception ) e ; </%> if ( se . socket _ error _ code = = socket _ error . address _ already _ in _ use ) {
if ( se . socket _ error _ code = = socket _ error . address _ already _ in _ use ) { e = new exception ( n . get _ string ( STR , config . local _ port ) , e ) ; } else if ( se . socket _ error _ code = = socket _ error . access _ denied ) { e = new exception ( n . get _ string ( STR , config . local _ port ) , e ) ; } } logging . log _ useful _ exception ( e ) ;
traffic _ thread . start ( ) ; } private void traffic _ statistics ( int queue _ max _ size ) { traffic _ per _ second previous , current ; while ( true ) { previous = traffic _ per _ second _ queue . last ( ) ; <%> <-> current = new traffic _ per _ second ( ) ; current . inbound _ counter = inbound _ counter ; </%>
current . inbound _ increasement = current . inbound _ counter - previous . inbound _ counter ; current . outbound _ increasement = current . outbound _ counter - previous . outbound _ counter ; traffic _ per _ second _ queue . enqueue ( current ) ; if ( traffic _ per _ second _ queue . count > queue _ max _ size ) traffic _ per _ second _ queue . dequeue ( ) ; traffic _ changed ? . invoke ( this , new event _ args ( ) ) ; thread . sleep ( NUM ) ; } } }
} private void receive _ callback ( i _ async _ result ar ) { <%> <+> int length = ( int ) ar . async _ state ; </%> try { var bytes _ read = socket . end _ receive ( ar ) ; if ( bytes _ read = = 0 ) { on _ finish ( <%> <+> length </%> ) ;
return ; } <%> <*> buffer _ data _ length + = bytes _ read ; new _ package _ recv ( ) ; -> length + = bytes _ read ; </%> <%> <+> int i ; while ( ( i = index _ of ( line _ buffer , buffer _ index , length , delimiter _ bytes , delimiter _ search _ offset _ table , delimiter _ search _ char _ table ) ) ! = - 1 ) { var decode _ len = i - buffer _ index ; </%>
} catch ( exception ex ) { on _ exception ( ex ) ; <%> <-> on _ finish ( ) ; } } private void new _ package _ recv ( ) { int i ; </%>
} private void on _ exception ( exception ex ) { on _ exception ? . invoke ( ex , state ) ; } private void on _ finish ( <%> <+> int length </%> ) { on _ finish ? . invoke ( line _ buffer , buffer <%> <-> _ data </%> _ index , <%> <-> buffer _ data _ </%> length , state ) ; } <%> <*> private -> public </%> static int index _ of ( byte [ ] haystack , int index , int length , byte [ ] needle , int [ ] offset _ table , int [ ] char _ table )
} <%> <*> private -> public </%> static int index _ of ( byte [ ] haystack , int index , int length , byte [ ] needle , int [ ] offset _ table , int [ ] char _ table ) { var end = index + length ; for ( int i = needle . length - 1 + index , j ; i < end ; ) { for ( j = needle . length - 1 ; needle [ j ] = = haystack [ i ] ; - - i , - - j ) { if ( j = = 0 ) {
{ var end = index + length ; for ( int i = needle . length - 1 + index , j ; i < end ; ) { for ( j = needle . length - 1 ; needle [ j ] = = haystack [ i ] ; - - i , - - j ) { if ( j = = 0 ) { return i ; }
{ <%> <+> logging . log _ useful _ exception ( ex ) ; </%> } finally { try { udp _ socket . begin _ receive _ from ( state . buffer , 0 , state . buffer . length , 0 , ref state . remote _ end _ point , new async _ callback ( recv _ from _ callback ) , state ) ; } catch ( object _ disposed _ exception )
public udp _ handler ( socket local , server server , ip _ end _ point local _ end _ point ) { local = local ; server = server ; local _ end _ point = local _ end _ point ; <%> <*> remote _ end _ point = socket _ util . get _ end _ point ( server . server , server . server _ port ) ; remote = socket _ util . create _ socket ( remote _ end _ point , protocol _ type . udp ) ; -> ip _ address ip _ address ; </%> <%> <+> bool parsed = ip _ address . try _ parse ( server . server , out ip _ address ) ; if ( ! parsed ) </%>
} public void send ( byte [ ] data , int length ) { i _ encryptor encryptor = encryptor _ factory . get _ encryptor ( server . method , server . password , server . auth , true ) ; byte [ ] data _ in = new byte [ length - NUM + iv _ encryptor . onetimeauth _ bytes ] ; array . copy ( data , NUM , data _ in , 0 , length - NUM ) ; byte [ ] data _ out = new byte [ length - NUM + NUM + iv _ encryptor . onetimeauth _ bytes ] ; int outlen ; encryptor . encrypt ( data _ in , length - NUM , data _ out , out outlen ) ; logging . debug ( local _ end _ point , remote _ end _ point , outlen , STR ) ;
} else if ( global ) { icon _ copy . set _ pixel ( x , y , color . from _ argb ( color . a , <%> <*> NUM -> 0 </%> , <%> <*> NUM -> color . g </%> , <%> <*> NUM -> 0 </%> ) ) ; } else { icon _ copy . set _ pixel ( x , y , color . from _ argb ( color . a , <%> <*> NUM -> color . r </%> , <%> <*> NUM -> color . g </%> , <%> <*> NUM -> 0 </%> ) ) ;
} else { icon _ copy . set _ pixel ( x , y , color . from _ argb ( color . a , <%> <*> NUM -> color . r </%> , <%> <*> NUM -> color . g </%> , <%> <*> NUM -> 0 </%> ) ) ;

var ret = new list < data _ list > ( ) ; <%> <+> try { var ip = dns . get _ host _ addresses ( server . server ) . first ( ip = > ( ip . address _ family = = address _ family . inter _ network | | ip . address _ family = = address _ family . inter _ network ) ) ; var ping = new ping ( ) ; </%> foreach ( var timestamp in enumerable . range ( 0 , repeat ) . select ( = > date _ time . now . to _ string ( date _ time _ pattern ) ) ) { try { var reply = await ping . send _ task _ async ( ip , timeout ) ; ret . add ( new list < key _ value _ pair < string , string > >
{ new key _ value _ pair < string , string > ( STR , timestamp ) , new key _ value _ pair < string , string > ( STR , server . friendly _ name ( ) ) , new key _ value _ pair < string , string > ( STR , reply ? . status . to _ string ( ) ) , new key _ value _ pair < string , string > ( STR , reply ? . roundtrip _ time . to _ string ( ) ) } ) ; thread . sleep ( timeout + new random ( ) . next ( ) % timeout ) ; } catch ( exception e ) {
} return ret ; } private void run ( object obj ) { load _ raw _ statistics ( ) ; filter _ raw _ statistics ( ) ; evaluate ( ) ; } private async void evaluate ( )
} public void end _ connect _ dest ( i _ async _ result async _ result ) { <%> <*> remote = socket _ util . end _ connect _ tcp ( async _ result ) ; -> remote . end _ connect ( async _ result ) ; </%> <%> <+> remote . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; </%> } public void begin _ send ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) {
} public void begin _ send ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) { remote ? . begin _ send ( buffer , offset , size , socket _ flags , callback , state ) ; } public int end _ send ( i _ async _ result async _ result ) { return remote . end _ send ( async _ result ) ; }
using system _ net ; using system _ net _ sockets ; using system _ text ; using system _ threading ; using shadowsocks _ controller ; using shadowsocks _ util <%> <+> _ sockets </%> ; namespace shadowsocks _ proxy { public class socks _ proxy : i _ proxy {
namespace shadowsocks _ proxy { public class socks _ proxy : i _ proxy { private class fake _ async _ result : i _ async _ result { public readonly socks _ state inner _ state ; private readonly i _ async _ result r ; public fake _ async _ result ( i _ async _ result orig , socks _ state state ) {
} private void connect _ callback ( i _ async _ result ar ) { var state = ( socks _ state ) ar . async _ state ; try { <%> <*> remote = socket _ util . end _ connect _ tcp ( ar ) ; -> remote . end _ connect ( ar ) ; </%> <%> <+> remote . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; </%> byte [ ] handshake = { NUM , 1 , 0 } ;
byte [ ] handshake = { NUM , 1 , 0 } ; remote . begin _ send ( handshake , 0 , handshake . length , 0 , socks _ handshake _ send _ callback , state ) ; } catch ( exception ex ) { state . ex = ex ; state . callback ? . invoke ( new fake _ async _ result ( ar , state ) ) ; } } private void socks _ handshake _ send _ callback ( i _ async _ result ar )
{ <%> <*> enable _ item . checked = ! enable _ item . checked ; if ( enable _ item . checked ) -> if ( config . enabled ) </%> { system _ proxy . enable ( ) ; } else { system _ proxy . disable ( ) ;
{ system _ proxy . enable ( ) ; } else { system _ proxy . disable ( ) ; } } <%> <+> private void enable _ item _ click ( object sender , event _ args e ) { </%>
get { <%> <*> return resource _ manager . get _ string ( STR , resource _ culture ) ; -> object obj = resource _ manager . get _ object ( STR , resource _ culture ) ; </%> <%> <+> return ( ( byte [ ] ) ( obj ) ) ; </%> } } } }
} } } }
string proxy = STR ; pac = pac . replace ( STR , proxy ) ; if ( bytes _ read > 0 ) { string text = string . format ( @ STR server : shadowsocks content - type : application / x - ns - proxy - autoconfig content - length : { 0 } connection : close STR
this . panel = new system . windows . forms . panel ( ) ; this . button = new system . windows . forms . button ( ) ; this . button = new system . windows . forms . button ( ) ; this . panel = new system . windows . forms . panel ( ) ; <%> <*> this . enable _ item = new system . windows . forms . tool _ strip _ menu _ item ( ) ; -> this . context _ menu = new system . windows . forms . context _ menu ( ) ; </%> <%> <+> this . enable _ item = new system . windows . forms . menu _ item ( ) ; this . about _ item = new system . windows . forms . menu _ item ( ) ; this . menu _ item = new system . windows . forms . menu _ item ( ) ; this . quit _ item = new system . windows . forms . menu _ item ( ) ; </%>
this . table _ layout _ panel . suspend _ layout ( ) ; <%> <-> this . context _ menu _ strip . suspend _ layout ( ) ; </%> this . panel . suspend _ layout ( ) ; this . suspend _ layout ( ) ; this . table _ layout _ panel . auto _ size = true ; this . table _ layout _ panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . table _ layout _ panel . column _ count = 2 ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , NUM ) ;
this . panel . suspend _ layout ( ) ; this . suspend _ layout ( ) ; this . table _ layout _ panel . auto _ size = true ; this . table _ layout _ panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . table _ layout _ panel . column _ count = 2 ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , 0 ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , 1 ) ;
this . notify _ icon . icon = ( ( system . drawing . icon ) ( resources . get _ object ( STR ) ) ) ; this . notify _ icon . text = STR ; this . notify _ icon . visible = true ; this . notify _ icon . double _ click + = new system . event _ handler ( this . notify _ icon _ double _ click ) ; <%> <-> this . context _ menu _ strip . items . add _ range ( new system . windows . forms . tool _ strip _ item [ ] { this . enable _ item , this . config _ item , this . about _ tool _ strip _ menu _ item , this . tool _ strip _ separator , this . quit _ item } ) ; </%>
this . panel . anchor = system . windows . forms . anchor _ styles . top ; this . panel . auto _ size = true ; this . panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . panel . location = new system . drawing . point ( NUM , NUM ) ; this . panel . name = STR ; this . panel . size = new system . drawing . size ( 0 , 0 ) ; this . panel . tab _ index = 1 ; this . button . dialog _ result = system . windows . forms . dialog _ result . ok ; this . button . location = new system . drawing . point ( NUM , NUM ) ; this . button . name = STR ;
private system . windows . forms . label label ; private system . windows . forms . combo _ box combo _ box ; private system . windows . forms . panel panel ; private system . windows . forms . button button ; private system . windows . forms . button button ; private system . windows . forms . panel panel ; <%> <*> private system . windows . forms . tool _ strip _ menu _ item enable _ item ; -> private system . windows . forms . context _ menu context _ menu ; </%> <%> <+> private system . windows . forms . menu _ item enable _ item ; private system . windows . forms . menu _ item about _ item ; </%>
} }
this . table _ layout _ panel . suspend _ layout ( ) ; this . panel . suspend _ layout ( ) ; this . suspend _ layout ( ) ; <%> <+> this . table _ layout _ panel . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( ( system . windows . forms . anchor _ styles . top | system . windows . forms . anchor _ styles . left ) | system . windows . forms . anchor _ styles . right ) ) ) ; </%> this . table _ layout _ panel . auto _ size = true ; this . table _ layout _ panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . table _ layout _ panel . column _ count = 2 ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ;
this . table _ layout _ panel . name = STR ; <%> <+> this . table _ layout _ panel . padding = new system . windows . forms . padding ( NUM ) ; </%> this . table _ layout _ panel . row _ count = NUM ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ; this . table _ layout _ panel . tab _ index = 0 ;

private void update _ online _ pacurl _ item _ click ( object sender , event _ args e ) { <%> <*> show _ pac _ url _ form ( ) ; -> string orig _ pac _ url = controller . get _ configuration ( ) . pac _ url ; </%> <%> <+> string pac _ url = microsoft . visual _ basic . interaction . input _ box ( n . get _ string ( STR ) , n . get _ string ( STR ) , orig _ pac _ url , - 1 , - 1 ) ; if ( ! string . is _ null _ or _ empty ( pac _ url ) & & pac _ url ! = orig _ pac _ url ) { </%>
} } }
} catch ( exception ex ) { <%> <*> if ( error ! = null ) { error ( this , new error _ event _ args ( ex ) ) ; } -> error ? . invoke ( this , new error _ event _ args ( ex ) ) ; </%> } }
} } public void update _ pac _ from _ gfw _ list ( configuration config ) { web _ client http = new web _ client ( ) ; http . proxy = new web _ proxy ( ip _ address . loopback . to _ string ( ) , config . local _ port ) ; http . download _ string _ completed + = http _ download _ string _ completed ; http . download _ string _ async ( new uri ( gfwlist _ url ) ) ; } public static list < string > parse _ result ( string response )
using system _ collections _ generic ; using system _ <%> <*> text -> globalization </%> ; using system <%> <-> _ text _ regular </%> _ <%> <*> expressions -> io </%> ; namespace shadowsocks _ controller { <%> <+> using shadowsocks _ properties ; </%> public class n { protected static dictionary < string , string > strings ; static n ( )
namespace shadowsocks _ controller { <%> <+> using shadowsocks _ properties ; </%> public class n { protected static dictionary < string , string > strings ; static n ( ) { strings = new dictionary < string , string > ( ) ; if ( <%> <-> system . globalization . </%> culture _ info . current _ culture . ietf _ language _ tag . <%> <*> to -> starts </%> _ <%> <*> lower -> with ( STR , string </%> _ <%> <*> invariant ( ) -> comparison </%> . <%> <*> starts -> ordinal </%> _ <%> <*> with ( STR -> ignore _ case </%> ) )
{ <%> <*> string [ ] lines = regex . split ( resources . cn , STR ) ; foreach ( string line in lines ) -> using ( var sr = new string _ reader ( resources . cn ) ) </%> { <%> <*> if ( line . starts _ with ( STR ) ) -> string line ; </%> <%> <+> while ( ( line = sr . read _ line ( ) ) ! = null ) </%> { <%> <-> continue ; </%> <%> <+> if ( line [ 0 ] = = '#' ) </%>
{ <%> <*> if ( line . starts _ with ( STR ) ) -> string line ; </%> <%> <+> while ( ( line = sr . read _ line ( ) ) ! = null ) </%> { <%> <-> continue ; </%> <%> <*> } -> if ( line [ 0 ] = = '#' ) </%> <%> <+> continue ; </%> <%> <*> string [ ] kv -> var pos </%> = <%> <*> regex -> line </%> . <%> <*> split ( line , STR -> index _ of ( '=' </%> ) ; if ( <%> <*> kv . length = = 2 -> pos < 1 </%> ) <%> <-> { </%> <%> <+> continue ; </%>
{ <%> <-> continue ; </%> <%> <*> } -> if ( line [ 0 ] = = '#' ) </%> <%> <+> continue ; </%> <%> <*> string [ ] kv -> var pos </%> = <%> <*> regex -> line </%> . <%> <*> split ( line , STR -> index _ of ( '=' </%> ) ; if ( <%> <*> kv . length = = 2 -> pos < 1 </%> ) <%> <-> { </%> <%> <+> continue ; </%> strings [ <%> <*> kv [ -> line . substring ( </%> 0 <%> <*> ] -> , pos ) </%> ] = <%> <*> kv [ -> line . substring ( pos + </%> 1 <%> <*> ] -> ) </%> ; } } }
} } } } public static string get _ string ( string key ) { if ( strings . contains _ key ( key ) ) { return strings [ key ] ; }
return true ; else if ( item <%> <*> = = -> . equals ( </%> STR <%> <*> ) -> , string _ comparison . ordinal _ ignore _ case ) ) </%> { string value = convert . to _ string ( run _ key . get _ value ( item ) ) ; if ( path . equals ( value , string _ comparison . <%> <*> invariant _ culture -> ordinal </%> _ ignore _ case ) ) { run _ key . delete _ value ( item ) ; run _ key . set _ value ( key , path ) ; return true ; }
{ string value = convert . to _ string ( run _ key . get _ value ( item ) ) ; if ( path . equals ( value , string _ comparison . <%> <*> invariant _ culture -> ordinal </%> _ ignore _ case ) ) { run _ key . delete _ value ( item ) ; run _ key . set _ value ( key , path ) ; return true ; } } }
{ run _ key . delete _ value ( item ) ; run _ key . set _ value ( key , path ) ; return true ; } } } return false ; } catch ( exception e )
try { int bytes _ read = conn . end _ receive ( ar ) ; string pac = get _ pac _ content ( ) ; ip _ end _ point local _ end _ point = ( ip _ end _ point ) conn . local _ end _ point ; string proxy = <%> <*> STR + -> get _ pac _ address ( request _ buf , </%> local _ end _ point <%> <*> . address + STR -> ) </%> ; pac = pac . replace ( STR , proxy ) ; if ( bytes _ read > 0 ) { string text = string . format ( @ STR
pac = pac . replace ( STR , proxy ) ; if ( bytes _ read > 0 ) { string text = string . format ( @ STR server : shadowsocks content - type : application / x - ns - proxy - autoconfig content - length : { 0 } connection : close STR byte [ ] response = system . text . encoding . ut . get _ bytes ( text ) ;
method = encryption _ select . text , remarks = remarks _ text _ box . text } ; <%> <+> int local _ port = int . parse ( proxy _ port _ text _ box . text ) ; </%> configuration . check _ server ( server ) ; <%> <+> configuration . check _ port ( local _ port ) ; </%> modified _ configuration . configs [ old _ selected _ index ] = server ; <%> <+> modified _ configuration . local _ port = local _ port ; </%> return true ; }
private bool share _ over _ lan ; socket listener ; public local ( configuration config ) { this . <%> <*> server -> config </%> = config <%> <*> . get _ current _ server ( ) ; -> ; </%> share _ over _ lan = config . share _ over _ lan ; } public void start ( ) { try
share _ over _ lan = config . share _ over _ lan ; } public void start ( ) { try { listener = new socket ( address _ family . inter _ network , socket _ type . stream , protocol _ type . tcp ) ; listener . set _ socket _ option ( socket _ option _ level . socket , socket _ option _ name . reuse _ address , true ) ; ip _ end _ point local _ end _ point = null ; if ( share _ over _ lan )
} else { local _ end _ point = new ip _ end _ point ( ip _ address . loopback , <%> <*> server -> config </%> . local _ port ) ; } listener . bind ( local _ end _ point ) ; listener . listen ( NUM ) ; console . write _ line ( STR ) ; listener . begin _ accept ( new async _ callback ( accept _ callback ) ,
} listener . bind ( local _ end _ point ) ; listener . listen ( NUM ) ; console . write _ line ( STR ) ; listener . begin _ accept ( new async _ callback ( accept _ callback ) , listener ) ; } catch ( socket _ exception ) {
if ( ! parsed ) { ip _ host _ entry ip _ host _ info = dns . get _ host _ entry ( <%> <*> config -> server </%> . server ) ; ip _ address = ip _ host _ info . address _ list [ 0 ] ; } ip _ end _ point remote _ ep = new ip _ end _ point ( ip _ address , <%> <*> config -> server </%> . server _ port ) ; remote = new socket ( ip _ address . address _ family , socket _ type . stream , protocol _ type . tcp ) ; remote . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; remote . begin _ connect ( remote _ ep ,
ip _ address = ip _ host _ info . address _ list [ 0 ] ; } ip _ end _ point remote _ ep = new ip _ end _ point ( ip _ address , <%> <*> config -> server </%> . server _ port ) ; remote = new socket ( ip _ address . address _ family , socket _ type . stream , protocol _ type . tcp ) ; remote . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; remote . begin _ connect ( remote _ ep , new async _ callback ( connect _ callback ) , null ) ; } catch ( exception e )
remote = new socket ( ip _ address . address _ family , socket _ type . stream , protocol _ type . tcp ) ; remote . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; remote . begin _ connect ( remote _ ep , new async _ callback ( connect _ callback ) , null ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; this . close ( ) ;
using system _ collections _ generic ; using system _ globalization ; using system _ io ; using system _ linq ; using system _ net ; <%> <-> using system _ net _ http ; </%> using system _ net _ network _ information ; using system _ net _ sockets ; using system _ threading ; using system _ threading _ tasks ;
using system _ net _ network _ information ; using system _ net _ sockets ; using system _ threading ; using system _ threading _ tasks ; <%> <-> using newtonsoft _ json ; using newtonsoft _ json _ linq ; </%> using shadowsocks _ model ; using shadowsocks _ util ; namespace shadowsocks _ controller {
using shadowsocks _ model ; using shadowsocks _ util ; namespace shadowsocks _ controller { using data _ unit = key _ value _ pair < string , string > ; using data _ list = list < key _ value _ pair < string , string > > ; using statistics = dictionary < string , list < availability _ statistics . raw _ statistics _ data > > ; <%> <*> public class availability _ statistics -> public sealed class availability _ statistics </%> {
{ <%> <+> public static availability _ statistics instance { get ; } = new availability _ statistics ( ) ; private availability _ statistics ( ) { } </%> public const string date _ time _ pattern = STR ; private const string statistics _ files _ name = STR ; private const string delimiter = STR ; private const int timeout <%> <+> _ milliseconds </%> = NUM ; private readonly time _ span delay _ before _ start = time _ span . from _ seconds ( 1 ) ; public statistics raw _ statistics { get ; private set ; } public statistics filtered _ statistics { get ; private set ; }
public statistics raw _ statistics { get ; private set ; } public statistics filtered _ statistics { get ; private set ; } public static readonly date _ time unknown _ date _ time = new date _ time ( NUM , 1 , 1 ) ; private int repeat = > config . repeat _ times _ num ; private readonly time _ span retry _ interval = time _ span . from _ minutes ( 2 ) ; private time _ span interval = > time _ span . from _ minutes ( config . data _ collection _ minutes ) ; private timer timer ; private timer speed _ monior ; private state state ; private list < server > servers ;
private long last _ inbound _ counter = 0 ; private long last _ outbound _ counter = 0 ; private readonly time _ span monitor _ interval = time _ span . from _ seconds ( 1 ) ; static availability _ statistics ( ) { availability _ statistics _ file = utils . get _ temp _ path ( statistics _ files _ name ) ; } <%> <-> public availability _ statistics ( shadowsocks _ controller controller ) { controller = controller ; </%>
public bool set ( statistics _ strategy _ configuration config ) { config = config ; try { if ( config . statistics _ enabled ) { if ( timer ? . change ( delay _ before _ start , interval ) = = null ) { state = new state ( ) ;
} private string get _ recent _ inbound _ speed ( server server ) { <%> <*> if ( server ! = current _ server ) return empty ; return inbound _ speed . to _ string ( ) ; -> return server ! = current _ server ? empty : inbound _ speed . to _ string ( ) ; </%> } private string get _ recent _ latency ( server server ) { if ( server ! = current _ server ) return empty ;
} private string get _ recent _ latency ( server server ) { if ( server ! = current _ server ) return empty ; return latency = = null ? empty : latency . to _ string ( ) ; } private void reset _ speed ( ) { current _ server = <%> <*> global _ config -> controller </%> . get _ current _ server ( ) ; latency = null ;
latency = null ; inbound _ speed = 0 ; outbound _ speed = 0 ; } private void run ( object obj ) { if ( speed _ monior ? . change ( delay _ before _ start , monitor _ interval ) = = null ) { speed _ monior = new timer ( update _ speed , null , delay _ before _ start , monitor _ interval ) ; }
reset _ speed ( ) ; <%> <+> set ( controller . statistics _ configuration ) ; servers = controller . get _ current _ configuration ( ) . configs ; </%> } private <%> <-> async </%> void filter _ raw _ statistics ( ) { if ( raw _ statistics = = null ) return ; if ( filtered _ statistics = = null ) { filtered _ statistics = new statistics ( ) ;
{ if ( raw _ statistics = = null ) return ; if ( filtered _ statistics = = null ) { filtered _ statistics = new statistics ( ) ; } foreach ( i _ enumerable < raw _ statistics _ data > raw _ data in raw _ statistics . values ) { var filtered _ data = raw _ data ; if ( config . by _ hour _ of _ day )
} } public void update _ inbound _ counter ( server server , long n ) { interlocked . add ( ref inbound _ counter , n ) ; if ( config . availability _ statistics ) { <%> <-> new task ( ( ) = > </%> availability _ statistics . update _ inbound _ counter ( server , n <%> <-> ) ) . start ( </%> ) ; } }
} } public void update _ outbound _ counter ( server server , long n ) { interlocked . add ( ref outbound _ counter , n ) ; if ( config . availability _ statistics ) { <%> <-> new task ( ( ) = > </%> availability _ statistics . update _ outbound _ counter ( server , n <%> <-> ) ) . start ( </%> ) ; } }
} } protected void reload ( ) { config = configuration . load ( ) ; statistics _ configuration = statistics _ strategy _ configuration . load ( ) ; if ( polipo _ runner = = null ) { polipo _ runner = new polipo _ runner ( ) ; }
process = null ; } refresh _ tray _ area ( ) ; <%> <+> } private static void kill _ process ( process p ) { try { p . close _ main _ window ( ) ; p . wait _ for _ exit ( NUM ) ; </%>
var last _ outbound = last _ outbound _ counter [ id ] ; var outbound = outbound _ counter [ id ] ; bytes = outbound - last _ outbound ; last _ outbound _ counter [ id ] = outbound ; var outbound _ speed = get _ speed _ in _ ki _ b _ per _ second ( bytes , monitor _ interval . total _ seconds ) ; <%> <*> outbound _ speed _ records . get _ or _ add ( id , new list < int > { outbound _ speed } ) . add ( outbound _ speed ) ; -> outbound _ speed _ records . get _ or _ add ( id , ( k ) = > </%> <%> <+> { list < int > records = new list < int > ( ) ; records . add ( outbound _ speed ) ; </%>
logging . debug ( $ STR ) ; } <%> <-> } private async task < icmp _ result > icmp _ test ( server server ) { logging . debug ( STR + server . friendly _ name ( ) ) ; if ( server . server = = STR ) return null ; var result = new icmp _ result ( server ) ; try </%>
} private void reset ( ) { inbound _ speed _ records . clear ( ) ; outbound _ speed _ records . clear ( ) ; latency _ records . clear ( ) ; } private void run ( object ) { update _ records ( ) ;
reset ( ) ; <%> <-> filter _ raw _ statistics ( ) ; </%> } private <%> <-> async </%> void update _ records ( ) { var records = new dictionary < string , statistics _ record > ( ) ; <%> <+> update _ records _ state state = new update _ records _ state ( ) ; state . counter = controller . get _ current _ configuration ( ) . configs . count ; </%> foreach ( var server in controller . get _ current _ configuration ( ) . configs ) {
{ var records = new dictionary < string , statistics _ record > ( ) ; <%> <+> update _ records _ state state = new update _ records _ state ( ) ; state . counter = controller . get _ current _ configuration ( ) . configs . count ; </%> foreach ( var server in controller . get _ current _ configuration ( ) . configs ) { var id = server . identifier ( ) ; list < int > inbound _ speed _ records = null ; list < int > outbound _ speed _ records = null ; list < int > latency _ records = null ;
} } private void append _ record ( string server _ identifier , statistics _ record record ) { <%> <+> try { </%> list < statistics _ record > records ; <%> <+> lock ( raw _ statistics ) { </%> if ( ! raw _ statistics . try _ get _ value ( server _ identifier , out records ) )
} private void save ( ) { <%> <+> logging . debug ( $ STR ) ; </%> if ( raw _ statistics . count = = 0 ) { return ; } try {
file . write _ all _ text ( availability _ statistics _ file , content ) ; } catch ( io _ exception e ) { logging . log _ useful _ exception ( e ) ; } } private bool is _ valid _ record ( statistics _ record record ) { if ( config . by _ hour _ of _ day )
} public void dispose ( ) { recorder . dispose ( ) ; speed _ monior . dispose ( ) ; } public void update _ latency ( server server , int latency ) { <%> <-> list < int > records ; latency _ records . try _ get _ value ( server . identifier ( ) , out records ) ; </%>
} public void update _ inbound _ counter ( server server , long n ) { <%> <*> long count ; if ( inbound _ counter . try _ get _ value ( server . identifier ( ) , out count ) ) { count + = n ; } else -> inbound _ counter . add _ or _ update ( server . identifier ( ) , ( k ) = > </%> {
} public void update _ outbound _ counter ( server server , long n ) { <%> <+> outbound _ counter . add _ or _ update ( server . identifier ( ) , ( k ) = > { last _ outbound _ counter . get _ or _ add ( server . identifier ( ) , 0 ) ; return n ; } , ( k , v ) = > ( v + n ) ) ; } class update _ records _ state </%>
} } }
string privoxy _ log _ filename = utils . get _ temp _ path ( STR ) ; if ( file . exists ( privoxy _ log _ filename ) ) using ( new file _ stream ( privoxy _ log _ filename , file _ mode . truncate ) ) { } <%> <-> logging . open _ log _ file ( ) ; </%> main _ controller = new shadowsocks _ controller ( ) ; menu _ controller = new menu _ view _ controller ( main _ controller ) ; <%> <+> main _ controller . program _ updated + = ( o , e ) = > { logging . info ( $ STR ) ; } ; </%>
main _ controller = new shadowsocks _ controller ( ) ; menu _ controller = new menu _ view _ controller ( main _ controller ) ; <%> <+> main _ controller . program _ updated + = ( o , e ) = > { logging . info ( $ STR ) ; } ; </%> hot _ keys . init ( main _ controller ) ; main _ controller . start ( ) ; application . run ( ) ; }
system _ proxy _ is _ dirty = true ; } else { if ( system _ proxy _ is _ dirty ) { system _ proxy . update ( config , false <%> <+> , pac _ server </%> ) ; system _ proxy _ is _ dirty = false ; } }
system _ proxy _ is _ dirty = false ; } } } private void pac _ server _ pac _ file _ changed ( object sender , event _ args e ) { update _ system _ proxy ( ) ; } private void pac _ server _ pac _ update _ completed ( object sender , gfw _ list _ updater . result _ event _ args e ) {
{ public const string pac _ file = STR ; public const string user _ rule _ file = STR ; public const string user _ abp _ file = STR ; <%> <+> public string pac _ secret { get ; private set ; } = STR ; </%> file _ system _ watcher pac _ file _ watcher ; file _ system _ watcher user _ rule _ file _ watcher ; private configuration config ; public event event _ handler pac _ file _ changed ; public event event _ handler user _ rule _ file _ changed ;
object [ ] state = new object [ ] { conn , <%> <+> request _ </%> buf } ; conn . begin _ receive ( <%> <+> request _ </%> buf , 0 , <%> <*> NUM -> request _ buf . length </%> , 0 , new async _ callback ( receive _ callback ) , state ) ; } catch ( object _ disposed _ exception ) { }
} ; conn . begin _ receive ( <%> <+> request _ </%> buf , 0 , <%> <*> NUM -> request _ buf . length </%> , 0 , new async _ callback ( receive _ callback ) , state ) ; } catch ( object _ disposed _ exception ) { } catch ( exception e ) { console . write _ line ( e ) ;
new async _ callback ( receive _ callback ) , state ) ; } catch ( object _ disposed _ exception ) { } catch ( exception e ) { console . write _ line ( e ) ; } finally
int n ; using ( g _ zip _ stream input = new g _ zip _ stream ( new memory _ stream ( pac _ gz ) , compression _ mode . decompress , false ) ) { <%> <*> n = input . read ( buffer , 0 , buffer . length ) ; if ( n = = 0 ) -> while ( ( n = input . read ( buffer , 0 , buffer . length ) ) > 0 ) </%> { <%> <*> throw new io _ exception -> sb . write </%> ( <%> <*> STR -> buffer , 0 , n </%> ) ; }
{ <%> <*> throw new io _ exception -> sb . write </%> ( <%> <*> STR -> buffer , 0 , n </%> ) ; } return system . text . encoding . ut . get _ string ( <%> <*> buffer , 0 , n -> sb . to _ array ( ) </%> ) ; } } } private void receive _ callback ( i _ async _ result ar ) { object [ ] state = ( object [ ] ) ar . async _ state ;
} return system . text . encoding . ut . get _ string ( <%> <*> buffer , 0 , n -> sb . to _ array ( ) </%> ) ; } } } private void receive _ callback ( i _ async _ result ar ) { object [ ] state = ( object [ ] ) ar . async _ state ; socket conn = ( socket ) state [ 0 ] ; byte [ ] request _ buf = ( byte [ ] ) state [ 1 ] ;
} } } private void receive _ callback ( i _ async _ result ar ) { object [ ] state = ( object [ ] ) ar . async _ state ; socket conn = ( socket ) state [ 0 ] ; byte [ ] request _ buf = ( byte [ ] ) state [ 1 ] ; try {
{ dest _ end _ point = dest _ end _ point ; <%> <*> string request = string . format ( http _ connect _ template , dest _ end _ point ) ; -> string auth _ info = STR ; </%> <%> <+> if ( auth ! = null ) { string auth _ key = convert . to _ base _ string ( encoding . ut . get _ bytes ( auth . user _ name + STR + auth . password ) ) ; auth _ info = string . format ( proxy _ auth _ template , auth _ key ) ; } string request = string . format ( http _ connect _ template , dest _ end _ point , auth _ info ) ; </%>
var b = encoding . ut . get _ bytes ( request ) ; var st = new http _ state ( ) ; st . callback = callback ; st . async _ state = state ; remote . begin _ send ( b , 0 , b . length , 0 , http _ request _ send _ callback , st ) ; } public void end _ connect _ dest ( i _ async _ result async _ result ) { var state = ( ( fake _ async _ result ) async _ result ) . inner _ state ; if ( state . ex ! = null )
} catch ( argument _ exception ) { } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; } }
} <%> <+> } private void proxy _ type _ combo _ box _ selected _ index _ changed ( object sender , event _ args e ) { if ( proxy _ type _ combo _ box . selected _ index ! = proxy _ config . proxy _ http ) { use _ auth _ check _ box . checked = false ; auth _ user _ text _ box . clear ( ) ; auth _ pwd _ text _ box . clear ( ) ; } </%>
modified _ configuration = new proxy _ config ( ) ; <%> <+> controller . save _ proxy _ config ( modified _ configuration ) ; } </%> use _ proxy _ check _ box . checked = modified _ configuration . use _ proxy ; proxy _ server _ text _ box . text = modified _ configuration . proxy _ server ; proxy _ port _ text _ box . text = modified _ configuration . proxy _ port . to _ string ( ) ; } private void ok _ button _ click ( object sender , event _ args e ) { if ( use _ proxy _ check _ box . checked )
} private void use _ proxy _ check _ box _ checked _ changed ( object sender , event _ args e ) { update _ enabled ( ) ; } private void update _ enabled ( ) { if ( use _ proxy _ check _ box . checked ) { proxy _ server _ text _ box . enabled = true ;
byte [ ] input , int ioff , uint ilen , byte [ ] output ) ; } }
disposed = true ; } if ( disposing ) { <%> <+> } </%> if ( encrypt _ ctx ! = int _ ptr . zero ) { mbed _ tls . cipher _ free ( encrypt _ ctx ) ; marshal . free _ h _ global ( encrypt _ ctx ) ; encrypt _ ctx = int _ ptr . zero ;
} } } }
if ( disposing ) { } close ( ) ; <%> <-> disposed = true ; </%> } <%> <*> public -> private </%> void close ( ) { <%> <+> if ( handle ! = int _ ptr . zero ) { </%> close _ handle ( handle ) ; handle = int _ ptr . zero ;
} <%> <*> public -> private </%> void close ( ) { <%> <+> if ( handle ! = int _ ptr . zero ) { </%> close _ handle ( handle ) ; handle = int _ ptr . zero ; <%> <+> } } ~ job ( ) </%>
{ <%> <+> if ( handle ! = int _ ptr . zero ) { </%> close _ handle ( handle ) ; handle = int _ ptr . zero ; <%> <+> } } ~ job ( ) { dispose ( false ) ; </%>
} public bool add _ process ( int _ ptr process _ handle ) { var succ = assign _ process _ to _ job _ object ( handle , process _ handle ) ; if ( ! succ ) { logging . error ( STR + marshal . get _ last _ win _ error ( ) ) ; } return succ ; }
{ average _ inbound _ speed = ( int ) inbound <%> <-> _ speed _ records </%> . average ( ) ; min _ inbound _ speed = inbound <%> <-> _ speed _ records </%> . min ( ) ; max _ inbound _ speed = inbound <%> <-> _ speed _ records </%> . max ( ) ; } <%> <*> if ( outbound _ speed _ records ! = null & & outbound _ speed _ records . any ( ) ) -> var outbound = outbound _ speed _ records ? . where ( s = > s > 0 ) . to _ list ( ) ; </%> <%> <+> if ( outbound ! = null & & outbound . any ( ) ) </%> { average _ outbound _ speed = ( int ) outbound <%> <-> _ speed _ records </%> . average ( ) ;
} <%> <*> if ( outbound _ speed _ records ! = null & & outbound _ speed _ records . any ( ) ) -> var outbound = outbound _ speed _ records ? . where ( s = > s > 0 ) . to _ list ( ) ; </%> <%> <+> if ( outbound ! = null & & outbound . any ( ) ) </%> { average _ outbound _ speed = ( int ) outbound <%> <-> _ speed _ records </%> . average ( ) ; min _ outbound _ speed = outbound <%> <-> _ speed _ records </%> . min ( ) ; max _ outbound _ speed = outbound <%> <-> _ speed _ records </%> . max ( ) ; } <%> <-> if ( latency _ records ! = null & & latency _ records . any ( ) ) </%>
{ average _ outbound _ speed = ( int ) outbound <%> <-> _ speed _ records </%> . average ( ) ; min _ outbound _ speed = outbound <%> <-> _ speed _ records </%> . min ( ) ; max _ outbound _ speed = outbound <%> <-> _ speed _ records </%> . max ( ) ; } <%> <*> if ( latency _ records ! = null & & latency _ records . any ( ) ) -> var latency = latency _ records ? . where ( s = > s > 0 ) . to _ list ( ) ; </%> <%> <+> if ( latency ! = null & & latency . any ( ) ) </%> { average _ latency = ( int ) latency <%> <-> _ records </%> . average ( ) ;
} <%> <*> if ( latency _ records ! = null & & latency _ records . any ( ) ) -> var latency = latency _ records ? . where ( s = > s > 0 ) . to _ list ( ) ; </%> <%> <+> if ( latency ! = null & & latency . any ( ) ) </%> { average _ latency = ( int ) latency <%> <-> _ records </%> . average ( ) ; min _ latency = latency <%> <-> _ records </%> . min ( ) ; max _ latency = latency <%> <-> _ records </%> . max ( ) ; } }
{ average _ latency = ( int ) latency <%> <-> _ records </%> . average ( ) ; min _ latency = latency <%> <-> _ records </%> . min ( ) ; max _ latency = latency <%> <-> _ records </%> . max ( ) ; } } public statistics _ record ( string identifier , i _ collection < int? > response _ records ) { server _ identifier = identifier ; set _ response ( response _ records ) ;
} } public statistics _ record ( string identifier , i _ collection < int? > response _ records ) { server _ identifier = identifier ; set _ response ( response _ records ) ; } public void set _ response ( i _ collection < int? > response _ records ) { if ( response _ records = = null ) return ;
} ; foreach ( var data in final _ data <%> <*> ) -> . where ( data = > data . speed ! = 0 | | data . package _ loss _ percentage ! = 0 | | data . ping ! = 0 ) ) </%> { data _ table . rows . add ( data . timestamp , data . speed , data . package _ loss _ percentage , data . ping ) ; } statistics _ chart . data _ bind ( ) ; } private void server _ selector _ selection _ change _ committed ( object sender , event _ args e ) { load _ chart _ data ( ) ;
{ data _ table . rows . add ( data . timestamp , data . speed , data . package _ loss _ percentage , data . ping ) ; } statistics _ chart . data _ bind ( ) ; } private void server _ selector _ selection _ change _ committed ( object sender , event _ args e ) { load _ chart _ data ( ) ; } private void day _ mode _ checked _ changed ( object sender , event _ args e )
using system _ net _ network _ information ; using system <%> <-> _ windows </%> _ <%> <*> forms -> threading </%> ; using newtonsoft _ json ; using shadowsocks _ model ; <%> <-> using timer = system . threading . timer ; </%> namespace shadowsocks _ controller _ strategy { <%> <-> using data _ unit = key _ value _ pair < string , string > ; using data _ list = list < key _ value _ pair < string , string > > ; </%> class statistics _ strategy : i _ strategy
using newtonsoft _ json ; using shadowsocks _ model ; <%> <-> using timer = system . threading . timer ; </%> namespace shadowsocks _ controller _ strategy { <%> <-> using data _ unit = key _ value _ pair < string , string > ; using data _ list = list < key _ value _ pair < string , string > > ; </%> class statistics _ strategy : i _ strategy { private readonly shadowsocks _ controller controller ;
namespace shadowsocks _ controller _ strategy { <%> <-> using data _ unit = key _ value _ pair < string , string > ; using data _ list = list < key _ value _ pair < string , string > > ; </%> class statistics _ strategy : i _ strategy { private readonly shadowsocks _ controller controller ; private server current _ server ; private readonly timer timer ; private dictionary < string , list < <%> <+> availability _ </%> statistics <%> <+> . raw </%> _ <%> <*> raw -> statistics </%> _ data > > <%> <*> raw -> filtered </%> _ statistics ;
class statistics _ strategy : i _ strategy { private readonly shadowsocks _ controller controller ; private server current _ server ; private readonly timer timer ; private dictionary < string , list < <%> <+> availability _ </%> statistics <%> <+> . raw </%> _ <%> <*> raw -> statistics </%> _ data > > <%> <*> raw -> filtered </%> _ statistics ; private int choice _ kept _ milliseconds = > ( int ) time _ span . from _ minutes ( controller . statistics _ configuration . choice _ kept _ minutes ) . total _ milliseconds ; <%> <-> private const int retry _ interval = 2 * NUM * NUM ; </%> public statistics _ strategy ( shadowsocks _ controller controller )
private int choice _ kept _ milliseconds = > ( int ) time _ span . from _ minutes ( controller . statistics _ configuration . choice _ kept _ minutes ) . total _ milliseconds ; <%> <-> private const int retry _ interval = 2 * NUM * NUM ; </%> public statistics _ strategy ( shadowsocks _ controller controller ) { controller = controller ; var servers = controller . get _ current _ configuration ( ) . configs ; var random _ index = new random ( ) . next ( ) % servers . count ( ) ; current _ server = servers [ random _ index ] ; timer = new timer ( reload _ statistics _ and _ choose _ a _ server ) ;
public statistics _ strategy ( shadowsocks _ controller controller ) { controller = controller ; var servers = controller . get _ current _ configuration ( ) . configs ; var random _ index = new random ( ) . next ( ) % servers . count ( ) ; current _ server = servers [ random _ index ] ; timer = new timer ( reload _ statistics _ and _ choose _ a _ server ) ; } private void reload _ statistics _ and _ choose _ a _ server ( object obj ) {
} private float get _ score ( <%> <*> i _ enumerable < statistics _ raw _ data > raw _ data -> string server </%> _ <%> <*> list -> name </%> ) { var config = controller . statistics _ configuration ; <%> <-> if ( config . by _ isp ) { var current = availability _ statistics . get _ geolocation _ and _ isp ( ) . result ; raw _ data _ list = raw _ data _ list . where ( data = > data . geolocation = = current [ 0 ] . value | | data . geolocation = = availability _ statistics . state . unknown ) ; raw _ data _ list = raw _ data _ list . where ( data = > data . isp = = current [ 1 ] . value | | data . isp = = availability _ statistics . state . unknown ) ; if ( raw _ data _ list . long _ count ( ) = = 0 ) return 0 ; </%>
{ var config = controller . statistics _ configuration ; <%> <-> if ( config . by _ isp ) { var current = availability _ statistics . get _ geolocation _ and _ isp ( ) . result ; raw _ data _ list = raw _ data _ list . where ( data = > data . geolocation = = current [ 0 ] . value | | data . geolocation = = availability _ statistics . state . unknown ) ; raw _ data _ list = raw _ data _ list . where ( data = > data . isp = = current [ 1 ] . value | | data . isp = = availability _ statistics . state . unknown ) ; if ( raw _ data _ list . long _ count ( ) = = 0 ) return 0 ; } if ( config . by _ hour _ of _ day ) </%>
var success _ times = ( float ) data _ list . count ( data = > data . icmp _ status . equals ( ip _ status . success . to _ string ( ) ) ) ; var timed _ out _ times = ( float ) data _ list . count ( data = > data . icmp _ status . equals ( ip _ status . timed _ out . to _ string ( ) ) ) ; var statistics _ data = new <%> <+> availability _ statistics . </%> statistics _ data ( ) { package _ loss = timed _ out _ times / ( success _ times + timed _ out _ times ) * NUM , average _ response = convert . to _ int ( data _ list . average ( data = > data . roundtrip _ time ) ) , min _ response = data _ list . min ( data = > data . roundtrip _ time ) , max _ response = data _ list . max ( data = > data . roundtrip _ time ) } ; float factor ;
{ package _ loss = timed _ out _ times / ( success _ times + timed _ out _ times ) * NUM , average _ response = convert . to _ int ( data _ list . average ( data = > data . roundtrip _ time ) ) , min _ response = data _ list . min ( data = > data . roundtrip _ time ) , max _ response = data _ list . max ( data = > data . roundtrip _ time ) } ; float factor ; float score = 0 ; if ( ! config . calculations . try _ get _ value ( STR , out factor ) ) factor = 0 ; score + = statistics _ data . package _ loss * factor ;
private void choose _ new _ server ( list < server > servers ) { if ( <%> <*> raw -> filtered </%> _ statistics = = null | | servers . count = = 0 ) { return ; } try { var best _ result = ( from server in servers let name = server . friendly _ name ( )
{ return ; } try { var best _ result = ( from server in servers let name = server . friendly _ name ( ) where <%> <*> raw -> filtered </%> _ statistics . contains _ key ( name ) select new {
select new { server , score = get _ score ( <%> <-> raw _ statistics [ </%> name <%> <-> ] </%> ) } ) . aggregate ( ( result , result ) = > result . score > result . score ? result : result ) ; if ( ! current _ server . equals ( best _ result . server ) ) { log _ when _ enabled ( $ STR ) ; }
} ) . aggregate ( ( result , result ) = > result . score > result . score ? result : result ) ; if ( ! current _ server . equals ( best _ result . server ) ) { log _ when _ enabled ( $ STR ) ; } current _ server = best _ result . server ; } catch ( exception e ) {
using system _ net _ http ; using system _ net _ network _ information ; using system _ net _ sockets ; using system _ threading ; using system _ threading _ tasks ; <%> <-> using system _ windows _ forms ; </%> using shadowsocks _ model ; using shadowsocks _ util ; <%> <-> using timer = system . threading . timer ; </%> namespace shadowsocks _ controller
using shadowsocks _ model ; using shadowsocks _ util ; <%> <-> using timer = system . threading . timer ; </%> namespace shadowsocks _ controller { using data _ unit = key _ value _ pair < string , string > ; using data _ list = list < key _ value _ pair < string , string > > ; <%> <*> internal class availability _ statistics -> using raw _ statistics = dictionary < string , list < availability _ statistics . raw _ statistics _ data > > ; </%> <%> <+> using statistics = dictionary < string , list < availability _ statistics . statistics _ data > > ; </%>
namespace shadowsocks _ controller { using data _ unit = key _ value _ pair < string , string > ; using data _ list = list < key _ value _ pair < string , string > > ; <%> <*> internal class availability _ statistics -> using raw _ statistics = dictionary < string , list < availability _ statistics . raw _ statistics _ data > > ; </%> <%> <+> using statistics = dictionary < string , list < availability _ statistics . statistics _ data > > ; public class availability _ statistics </%> { public static readonly string date _ time _ pattern = STR ;
{ public static readonly string date _ time _ pattern = STR ; private const string statistics _ files _ name = STR ; private const string delimiter = STR ; private const int timeout = NUM ; private const int delay _ before _ start = NUM ; <%> <+> public raw _ statistics raw _ statistics { get ; private set ; } public raw _ statistics filtered _ statistics { get ; private set ; } </%> private int repeat = > config . repeat _ times _ num ; <%> <+> private const int retry _ interval = 2 * NUM * NUM ; </%>
( ( system . component _ model . i _ support _ initialize ) ( this . statistics _ chart ) ) . begin _ init ( ) ; <%> <+> ( ( system . component _ model . i _ support _ initialize ) ( this . binding _ configuration ) ) . begin _ init ( ) ; </%> this . chart _ mode _ selector . suspend _ layout ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . begin _ init ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . suspend _ layout ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . begin _ init ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . panel . suspend _ layout ( ) ;
{ registered _ encryptors . add ( method , typeof ( aead _ mbed _ tls _ encryptor ) ) ; } foreach ( string method in aead _ sodium _ encryptor <%> <*> . -> _ </%> supported _ ciphers <%> <-> ( </%> ) <%> <-> ) </%> { registered _ encryptors . add ( method , typeof ( aead _ sodium _ encryptor ) ) ; } } public static i _ encryptor get _ encryptor ( string method , string password ) {
{ registered _ encryptors . add ( method , typeof ( aead _ sodium _ encryptor ) ) ; } } public static i _ encryptor get _ encryptor ( string method , string password ) { if ( method . is _ null _ or _ empty ( ) ) { method = STR ; }
this . close ( ) ; } } private void connect _ callback ( i _ async _ result ar ) { <%> <+> server server = null ; </%> if ( closed ) { return ; }
remote . end _ connect ( ar ) ; <%> <+> connected = true ; </%> var latency = date _ time . now - start _ connect _ time ; controller . get _ current _ strategy ( ) . update _ latency ( <%> <-> this . </%> server , latency ) ; start _ pipe ( ) ; } <%> <+> catch ( argument _ exception e ) { } </%> catch ( exception e )
start _ pipe ( ) ; } <%> <+> catch ( argument _ exception e ) { } </%> catch ( exception e ) { <%> <-> controller . get _ current _ strategy ( ) . set _ failure ( this . server ) ; logging . log _ useful _ exception ( e ) ; if ( retry _ count < NUM ) </%>
} } private void start _ pipe ( ) { if ( closed ) { return ; } try {
{ <%> <+> if ( ! ( each . equals ( STR ) | | each . equals ( STR ) | | each . equals ( STR ) ) ) { </%> registry . set _ value ( each , <%> <*> defulat -> default </%> _ value ) ; <%> <+> } </%> } <%> <+> system _ proxy . notify _ ie ( ) ; } catch ( io _ exception e ) { </%>
} <%> <+> system _ proxy . notify _ ie ( ) ; } catch ( io _ exception e ) { logging . log _ useful _ exception ( e ) ; </%> } <%> <-> notify _ ie ( ) ; </%> } private static string get _ timestamp ( date _ time value ) { return value . to _ string ( STR ) ;
} private static string get _ timestamp ( date _ time value ) { return value . to _ string ( STR ) ; } } }
{ g . copy _ from _ screen ( screen . primary _ screen . bounds . x , screen . primary _ screen . bounds . y , 0 , 0 , <%> <*> bmp _ screen _ capture -> image </%> . size , copy _ pixel _ operation . source _ copy ) ; } <%> <*> result _ points . clear ( ) ; -> var reader = new barcode _ reader </%> {
copy _ pixel _ operation . source _ copy ) ; } <%> <*> result _ points . clear ( ) ; -> var reader = new barcode _ reader </%> { <%> <+> try _ harder = true , </%> possible _ formats = new list < barcode _ format > { barcode _ format . qr _ code }
{ <%> <+> try _ harder = true , </%> possible _ formats = new list < barcode _ format > { barcode _ format . qr _ code } } ; var result = reader . decode ( image ) ; <%> <-> var result = barcode _ reader . decode ( image ) ; var timer _ start = date _ time . now . ticks ; </%>
{ <%> <*> txt -> console . write </%> _ <%> <*> decoder _ content -> line ( result </%> . text <%> <*> = STR -> ) </%> ; } <%> <-> lab _ duration . text = new time _ span ( timer _ stop - timer _ start ) . milliseconds . to _ string ( STR ) ; } </%> } <%> <-> * * / </%> } private void auto _ startup _ item _ click ( object sender , event _ args e ) { auto _ startup _ item . checked = ! auto _ startup _ item . checked ;
} <%> <-> lab _ duration . text = new time _ span ( timer _ stop - timer _ start ) . milliseconds . to _ string ( STR ) ; } </%> } <%> <-> * * / </%> } private void auto _ startup _ item _ click ( object sender , event _ args e ) { auto _ startup _ item . checked = ! auto _ startup _ item . checked ; if ( ! auto _ startup . set ( auto _ startup _ item . checked ) ) { message _ box . show ( STR ) ;
} private void auto _ startup _ item _ click ( object sender , event _ args e ) { auto _ startup _ item . checked = ! auto _ startup _ item . checked ; if ( ! auto _ startup . set ( auto _ startup _ item . checked ) ) { message _ box . show ( STR ) ; } } } }
{ <%> <+> console . write _ line ( e ) ; </%> return new config { server = STR , server _ port = NUM , local _ port = NUM , <%> <*> password = STR -> password = STR , </%> <%> <+> is _ default = true </%>
} ; } } public static void save ( config config ) { data _ contract _ json _ serializer ser = new data _ contract _ json _ serializer ( typeof ( config ) ) ; try { using ( file _ stream fs = file . open ( STR , file _ mode . create ) ) {
initialize _ component ( ) ; <%> <+> config _ to _ text _ box ( ) ; } private void show _ window ( ) { this . opacity = 1 ; this . show ( ) ; } private void config _ to _ text _ box ( ) { </%>
{ <%> <*> reload ( config . load ( ) ) ; -> try </%> <%> <+> { config config = new config { server = text _ box . text , server _ port = int . parse ( text _ box . text ) , password = text _ box . text , local _ port = int . parse ( text _ box . text ) , </%>
} private void <%> <+> cancel _ </%> button _ click ( object sender , event _ args e ) { <%> <+> this . hide ( ) ; config _ to _ text _ box ( ) ; </%> } private void form _ form _ closed ( object sender , form _ closed _ event _ args e ) { local . stop ( ) ; }
{ <%> <+> this . hide ( ) ; config _ to _ text _ box ( ) ; </%> } private void form _ form _ closed ( object sender , form _ closed _ event _ args e ) { local . stop ( ) ; } <%> <+> private void about _ tool _ strip _ menu _ item _ click ( object sender , event _ args e ) { </%>
this . button . dialog _ result = system . windows . forms . dialog _ result . ok ; this . button . location = new system . drawing . point ( NUM , NUM ) ; this . button . name = STR ; this . button . size = new system . drawing . size ( NUM , NUM ) ; this . button . tab _ index = 0 ; this . button . text = STR ; this . button . use _ visual _ style _ back _ color = true ; this . button . click + = new system . event _ handler ( this . <%> <+> ok _ </%> button _ click ) ; this . notify _ icon . context _ menu _ strip = this . context _ menu _ strip ; this . notify _ icon . icon = ( ( system . drawing . icon ) ( resources . get _ object ( STR ) ) ) ;
this . notify _ icon . context _ menu _ strip = this . context _ menu _ strip ; this . notify _ icon . icon = ( ( system . drawing . icon ) ( resources . get _ object ( STR ) ) ) ; this . notify _ icon . text = STR ; this . notify _ icon . visible = true ; <%> <+> this . notify _ icon . double _ click + = new system . event _ handler ( this . notify _ icon _ double _ click ) ; </%> this . context _ menu _ strip . items . add _ range ( new system . windows . forms . tool _ strip _ item [ ] { this . config _ item , <%> <+> this . about _ tool _ strip _ menu _ item , this . tool _ strip _ separator , </%> this . quit _ item } ) ;
this . config _ item . name = STR ; this . config _ item . size = new system . drawing . size ( NUM , NUM ) ; this . config _ item . text = STR ; this . config _ item . click + = new system . event _ handler ( this . config _ click ) ; <%> <+> this . about _ tool _ strip _ menu _ item . name = STR ; this . about _ tool _ strip _ menu _ item . size = new system . drawing . size ( NUM , NUM ) ; this . about _ tool _ strip _ menu _ item . text = STR ; this . about _ tool _ strip _ menu _ item . click + = new system . event _ handler ( this . about _ tool _ strip _ menu _ item _ click ) ; </%> this . quit _ item . name = STR ; this . quit _ item . size = new system . drawing . size ( NUM , NUM ) ;
} public static string get _ string ( string key , params object [ ] args ) { return string . format ( strings . try _ get _ value ( key . trim ( ) , out var value ) ? value : key , args ) ; } public static void translate _ form ( form c ) { if ( c = = null ) return ; c . text = get _ string ( c . text ) ; foreach ( var item in view _ utils . get _ child _ controls < control > ( c ) )
<%> <*> public -> private </%> byte [ ] remote _ send _ buffer = new byte [ buffer _ size ] ; <%> <*> public -> private </%> byte [ ] connetion _ recv _ buffer = new byte [ recv _ size ] ; <%> <*> public -> private </%> byte [ ] connetion _ send _ buffer = new byte [ buffer _ size ] ; <%> <-> public string _ builder sb = new string _ builder ( ) ; </%> private bool connection _ shutdown = false ; private bool remote _ shutdown = false ; private bool closed = false ; public void start ( ) { try
<%> <*> public -> private </%> byte [ ] connetion _ recv _ buffer = new byte [ recv _ size ] ; <%> <*> public -> private </%> byte [ ] connetion _ send _ buffer = new byte [ buffer _ size ] ; <%> <-> public string _ builder sb = new string _ builder ( ) ; </%> private bool connection _ shutdown = false ; private bool remote _ shutdown = false ; private bool closed = false ; public void start ( ) { try {
<%> <*> public -> private </%> byte [ ] connetion _ send _ buffer = new byte [ buffer _ size ] ; <%> <-> public string _ builder sb = new string _ builder ( ) ; </%> private bool connection _ shutdown = false ; private bool remote _ shutdown = false ; private bool closed = false ; public void start ( ) { try { ip _ address ip _ address ;
<%> <-> public string _ builder sb = new string _ builder ( ) ; </%> private bool connection _ shutdown = false ; private bool remote _ shutdown = false ; private bool closed = false ; public void start ( ) { try { ip _ address ip _ address ; bool parsed = ip _ address . try _ parse ( config . server , out ip _ address ) ;
private bool connection _ shutdown = false ; private bool remote _ shutdown = false ; private bool closed = false ; public void start ( ) { try { ip _ address ip _ address ; bool parsed = ip _ address . try _ parse ( config . server , out ip _ address ) ; if ( ! parsed )
this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; <%> <+> this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; </%> this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ; this . table _ layout _ panel . tab _ index = NUM ; <%> <+> this . duplicate _ button . dock = system . windows . forms . dock _ style . left ; this . duplicate _ button . location = new system . drawing . point ( 0 , NUM ) ; this . duplicate _ button . margin = new system . windows . forms . padding ( 0 , NUM , NUM , NUM ) ; this . duplicate _ button . name = STR ; this . duplicate _ button . size = new system . drawing . size ( NUM , NUM ) ; this . duplicate _ button . tab _ index = NUM ; </%>
this . table _ layout _ panel . tab _ index = NUM ; <%> <+> this . duplicate _ button . dock = system . windows . forms . dock _ style . left ; this . duplicate _ button . location = new system . drawing . point ( 0 , NUM ) ; this . duplicate _ button . margin = new system . windows . forms . padding ( 0 , NUM , NUM , NUM ) ; this . duplicate _ button . name = STR ; this . duplicate _ button . size = new system . drawing . size ( NUM , NUM ) ; this . duplicate _ button . tab _ index = NUM ; this . duplicate _ button . text = STR ; this . duplicate _ button . use _ visual _ style _ back _ color = true ; this . duplicate _ button . click + = new system . event _ handler ( this . duplicate _ button _ click ) ; </%>
} public void update _ outbound _ counter ( long n ) { interlocked . add ( ref outbound _ counter , n ) ; <%> <-> config . get _ current _ server ( ) . bandwidth _ out = outbound _ counter ; </%> } protected void reload ( ) { config = configuration . load ( ) ; <%> <-> inbound _ counter = config . get _ current _ server ( ) . bandwidth _ in ; </%>
} protected void reload ( ) { config = configuration . load ( ) ; <%> <-> inbound _ counter = config . get _ current _ server ( ) . bandwidth _ in ; outbound _ counter = config . get _ current _ server ( ) . bandwidth _ out ; </%> statistics _ configuration = statistics _ strategy _ configuration . load ( ) ; if ( polipo _ runner = = null ) { polipo _ runner = new polipo _ runner ( ) ;
statistics _ configuration = statistics _ strategy _ configuration . load ( ) ; if ( polipo _ runner = = null ) { polipo _ runner = new polipo _ runner ( ) ; } if ( pac _ server = = null ) { pac _ server = new pac _ server ( ) ; pac _ server . pac _ file _ changed + = pac _ server _ pac _ file _ changed ; pac _ server . user _ rule _ file _ changed + = pac _ server _ user _ rule _ file _ changed ;
public udp _ handler ( socket local , server server , ip _ end _ point local _ end _ point ) { local = local ; server = server ; local _ end _ point = local _ end _ point ; <%> <-> ip _ address ip _ address ; bool parsed = ip _ address . try _ parse ( server . server , out ip _ address ) ; if ( ! parsed ) { ip _ host _ entry ip _ host _ info = dns . get _ host _ entry ( server . server ) ; </%>
} public void send ( byte [ ] data , int length ) { i _ encryptor encryptor = encryptor _ factory . get _ encryptor ( server . method , server . password , server . auth , true ) ; byte [ ] data _ in = new byte [ length - NUM + iv _ encryptor . onetimeauth _ bytes ] ; array . copy ( data , NUM , data _ in , 0 , length - NUM ) ; byte [ ] data _ out = new byte [ length - NUM + NUM + iv _ encryptor . onetimeauth _ bytes ] ; int outlen ; encryptor . encrypt ( data _ in , length - NUM , data _ out , out outlen ) ; logging . debug ( local _ end _ point , remote _ end _ point , outlen , STR ) ;
if ( remote = = null ) { remote = <%> <-> new </%> socket <%> <-> ( real _ end </%> _ <%> <*> point -> util </%> . <%> <*> address -> create </%> _ <%> <-> family , </%> socket <%> <*> _ type . stream , protocol -> ( dest </%> _ <%> <*> type . tcp -> end _ point </%> ) ; remote . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; } remote . begin _ connect ( <%> <*> real -> dest </%> _ end _ point , callback , state ) ; } public void end _ connect _ dest ( i _ async _ result async _ result ) { remote ? . end _ connect ( async _ result ) ;
remote . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; } remote . begin _ connect ( <%> <*> real -> dest </%> _ end _ point , callback , state ) ; } public void end _ connect _ dest ( i _ async _ result async _ result ) { remote ? . end _ connect ( async _ result ) ; } public void begin _ send ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state )
} public void end _ connect _ dest ( i _ async _ result async _ result ) { remote ? . end _ connect ( async _ result ) ; } public void begin _ send ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) { remote ? . begin _ send ( buffer , offset , size , socket _ flags , callback , state ) ; }
if ( config . use _ proxy ) { <%> <-> ip _ address ip _ address ; bool parsed = ip _ address . try _ parse ( config . proxy _ server , out ip _ address ) ; if ( ! parsed ) { * todo really necessary to resolve a proxy ' s address ? maybe from local hosts ? * also we may simplify it by using dual - mode socket with * the approach described in direct _ connect . begin _ connect _ dest * / </%>
remote = new socks _ proxy ( ) ; proxy _ ep = <%> <*> new ip -> socket _ util . get </%> _ end _ point ( <%> <*> ip -> config . proxy </%> _ <%> <*> address -> server </%> , config . proxy _ port ) ; } else { remote = new direct _ connect ( ) ; proxy _ ep = null ; } proxy _ timer proxy _ timer = new proxy _ timer ( NUM ) ; proxy _ timer . auto _ reset = false ;
} else { remote = new direct _ connect ( ) ; proxy _ ep = null ; } proxy _ timer proxy _ timer = new proxy _ timer ( NUM ) ; proxy _ timer . auto _ reset = false ; proxy _ timer . elapsed + = proxy _ connect _ timer _ elapsed ; proxy _ timer . enabled = true ;
notify _ icon . visible = true ; <%> <-> notify _ icon . text = n . get _ string ( STR ) ; </%> notify _ icon . context _ menu = context _ menu ; notify _ icon . double _ click + = notify _ icon _ double _ click ; this . update _ checker = new update _ checker ( ) ; update _ checker . new _ version _ found + = update _ checker _ new _ version _ found ; load _ current _ configuration ( ) ; update _ checker . check _ update ( ) ; if ( controller . get _ configuration ( ) . is _ default ) {
notify _ icon . context _ menu = context _ menu ; notify _ icon . double _ click + = notify _ icon _ double _ click ; this . update _ checker = new update _ checker ( ) ; update _ checker . new _ version _ found + = update _ checker _ new _ version _ found ; load _ current _ configuration ( ) ; update _ checker . check _ update ( ) ; if ( controller . get _ configuration ( ) . is _ default ) { is _ first _ run = true ; show _ config _ form ( ) ;
} void controller _ share _ over _ lan _ status _ changed ( object sender , event _ args e ) { share _ over _ lan _ item . checked = controller . get _ configuration ( ) . share _ over _ lan ; } void controller _ enable _ global _ changed ( object sender , event _ args e ) { global _ mode _ item . checked = controller . get _ configuration ( ) . global ; pac _ mode _ item . checked = ! global _ mode _ item . checked ; }
this . encryption _ label . anchor = system . windows . forms . anchor _ styles . right ; this . encryption _ label . auto _ size = true ; this . encryption _ label . location = new system . drawing . point ( NUM , NUM ) ; this . encryption _ label . name = STR ; this . encryption _ label . size = new system . drawing . size ( NUM , NUM ) ; this . encryption _ label . tab _ index = NUM ; this . encryption _ label . text = STR ; this . encryption _ select . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( ( system . windows . forms . anchor _ styles . top | system . windows . forms . anchor _ styles . left ) | system . windows . forms . anchor _ styles . right ) ) ) ; this . encryption _ select . drop _ down _ style = system . windows . forms . combo _ box _ style . drop _ down _ list ;
private bool is _ first _ run ; private bool is _ startup _ checking ; <%> <+> private string url _ to _ open ; private context _ menu context _ menu ; </%> private menu _ item disable _ item ; private menu _ item auto _ startup _ item ; private menu _ item share _ over _ lan _ item ; private menu _ item seperator _ item ; private menu _ item config _ item ; private menu _ item servers _ item ;
notify _ icon . icon = new _ icon ; } } void controller _ errored ( object sender , system . io . error _ event _ args e ) { message _ box . show ( e . get _ exception ( ) . to _ string ( ) , n . get _ string ( STR , e . get _ exception ( ) . message ) ) ; } <%> <-> private void update _ tray _ icon ( ) { int dpi ; </%>
configuration config = controller . get _ configuration _ copy ( ) ; bool enabled = config . enabled ; bool global = config . global ; <%> <-> current _ windows _ theme _ mode = utils . get _ windows _ system _ theme _ setting ( ) ; if ( current _ windows _ theme _ mode = = utils . windows _ theme _ mode . light ) if ( ! global | | ! enabled ) icon _ base _ bitmap = get _ dark _ tray _ icon ( icon _ base _ bitmap ) ; icon _ base _ bitmap = get _ tray _ icon _ by _ state ( icon _ base _ bitmap , enabled , global ) ; icon _ base = icon . from _ handle ( icon _ base _ bitmap . get _ hicon ( ) ) ; target _ icon = icon _ base ; </%>
string server _ info = null ; if ( controller . get _ current _ strategy ( ) ! = null ) { server _ info = controller . get _ current _ strategy ( ) . name ; } else { server _ info = config . get _ current _ server ( ) . friendly _ name ( ) ; } string text = n . get _ string ( STR ) + STR + update _ checker . version + STR +
{ <%> <*> color fly _ blue = color . from _ argb ( NUM , 0 , 0 , 0 ) ; int red = color . r * fly _ blue . r / NUM ; int green = color . g * fly _ blue . g / NUM ; int blue = color . b * fly _ blue . b / NUM ; int alpha = color . a ; icon _ copy . set _ pixel ( x , y , color . from _ argb ( alpha , red , green , blue ) ) ; -> color _ mask = color _ mask _ eclipse ; </%> } <%> <-> else </%>
} <%> <-> else { icon _ copy . set _ pixel ( x , y , color . from _ argb ( color . a , color . r , color . g , color . b ) ) ; } } } return icon _ copy ; } private bitmap get _ tray _ icon _ by _ state ( bitmap origin _ icon , bool enabled , bool global ) </%>
} private menu _ item create _ menu _ item ( string text , event _ handler click ) { return new menu _ item ( n . get _ string ( text ) , click ) ; } private menu _ item create _ menu _ group ( string text , menu _ item [ ] items ) { return new menu _ item ( n . get _ string ( text ) , items ) ; } private void load _ menu ( )
try { <%> <*> registry _ key reg _ hkcu = registry . current _ user ; registry _ key reg _ themes _ personalize = reg _ hkcu . open _ sub _ key ( STR , false ) ; -> registry _ key reg _ themes _ personalize = registry . current _ user . open _ sub _ key ( STR , false ) ; </%> if ( reg _ themes _ personalize . get _ value ( STR ) ! = null ) { if ( <%> <*> convert . to _ -> ( </%> int <%> <+> ) </%> ( reg _ themes _ personalize . get _ value ( STR <%> <-> ) . to _ string ( </%> ) ) = = 0 ) <%> <*> regist -> theme </%> _ <%> <*> data -> mode </%> = windows _ theme _ mode . dark ; else
if ( reg _ themes _ personalize . get _ value ( STR ) ! = null ) { if ( <%> <*> convert . to _ -> ( </%> int <%> <+> ) </%> ( reg _ themes _ personalize . get _ value ( STR <%> <-> ) . to _ string ( </%> ) ) = = 0 ) <%> <*> regist -> theme </%> _ <%> <*> data -> mode </%> = windows _ theme _ mode . dark ; else <%> <*> regist _ data = windows _ theme _ mode . light ; -> theme _ mode = windows _ theme _ mode . light ; </%> } else {
else <%> <*> regist _ data = windows _ theme _ mode . light ; -> theme _ mode = windows _ theme _ mode . light ; </%> } else { throw new exception ( STR ) ; } } catch
} else { throw new exception ( STR ) ; } } catch { logging . info ( $ STR ) ;

initialize _ component ( ) ; <%> <*> this . servers _ list _ box . dock = system . windows . forms . dock _ style . fill ; -> this . servers _ list _ box . dock = dock _ style . fill ; </%> <%> <+> this . table _ layout _ panel . dock = dock _ style . fill ; </%> this . perform _ layout ( ) ; update _ texts ( ) ; this . icon = icon . from _ handle ( resources . ssw . get _ hicon ( ) ) ; this . controller = controller ; controller . config _ changed + = controller _ config _ changed ; load _ current _ configuration ( ) ;
this . perform _ layout ( ) ; update _ texts ( ) ; this . icon = icon . from _ handle ( resources . ssw . get _ hicon ( ) ) ; this . controller = controller ; controller . config _ changed + = controller _ config _ changed ; load _ current _ configuration ( ) ; } private void update _ texts ( ) { add _ button . text = n . get _ string ( STR ) ;
this . plugin _ arguments _ text _ box = new system . windows . forms . text _ box ( ) ; this . plugin _ arguments _ label = new system . windows . forms . label ( ) ; <%> <+> this . remarks _ label = new system . windows . forms . label ( ) ; </%> this . panel = new system . windows . forms . panel ( ) ; this . ok _ button = new system . windows . forms . button ( ) ; this . my _ cancel _ button = new system . windows . forms . button ( ) ; this . delete _ button = new system . windows . forms . button ( ) ; this . add _ button = new system . windows . forms . button ( ) ; this . server _ group _ box = new system . windows . forms . group _ box ( ) ; this . servers _ list _ box = new system . windows . forms . list _ box ( ) ;
this . table _ layout _ panel . auto _ size = true ; this . table _ layout _ panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . table _ layout _ panel . column _ count = 2 ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . controls . add ( this . proxy _ port _ text _ box , 1 , 0 ) ; this . table _ layout _ panel . controls . add ( this . proxy _ port _ label , 0 , 0 ) ; <%> <+> this . table _ layout _ panel . controls . add ( this . temp _ folder _ label , 0 , 1 ) ; this . table _ layout _ panel . controls . add ( this . temp _ folder _ text _ box , 1 , 1 ) ; </%> this . table _ layout _ panel . location = new system . drawing . point ( NUM , NUM ) ;
this . table _ layout _ panel . margin = new system . windows . forms . padding ( 0 ) ; this . table _ layout _ panel . name = STR ; this . table _ layout _ panel . padding = new system . windows . forms . padding ( NUM ) ; this . table _ layout _ panel . row _ count = <%> <*> 1 -> 2 </%> ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ; this . table _ layout _ panel . tab _ index = NUM ; this . proxy _ port _ text _ box . anchor = system . windows . forms . anchor _ styles . left ; this . proxy _ port _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . proxy _ port _ text _ box . max _ length = NUM ;
this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ; this . table _ layout _ panel . tab _ index = NUM ; this . proxy _ port _ text _ box . anchor = system . windows . forms . anchor _ styles . left ; this . proxy _ port _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . proxy _ port _ text _ box . max _ length = NUM ; this . proxy _ port _ text _ box . name = STR ; this . proxy _ port _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . proxy _ port _ text _ box . tab _ index = NUM ; this . proxy _ port _ text _ box . word _ wrap = false ;
string json _ string = json _ convert . serialize _ object ( user _ settings , formatting . indented ) ; sw . write ( json _ string ) ; sw . flush ( ) ; } <%> <*> } catch ( io _ exception e ) { -> } </%> <%> <+> catch ( io _ exception e ) { </%> logging . log _ useful _ exception ( e ) ; }
user _ settings = json _ convert . deserialize _ object < sysproxy _ config > ( config _ content ) ; <%> <*> } catch ( exception ) -> } catch ( exception ) </%> { } <%> <*> finally { -> finally </%> <%> <+> { </%> if ( user _ settings = = null ) user _ settings = new sysproxy _ config ( ) ; } }
using system _ net ; using system _ net _ sockets ; using system _ timers ; using shadowsocks _ controller _ strategy ; using shadowsocks _ encryption ; using shadowsocks _ forward _ proxy ; using shadowsocks _ model ; using shadowsocks _ util _ sockets ; namespace shadowsocks _ controller <%> <+> _ service </%> {
{ class tcp _ relay : listener . service { private shadowsocks _ controller controller ; private date _ time last _ sweep _ time ; private configuration config ; <%> <*> public i _ set < tcp _ handler > handlers { get ; set ; } -> private readonly list < itcp _ handler _ factory > factories = new list < itcp _ handler _ factory > ( ) ; </%> <%> <+> public i _ set < tcp _ handler > handlers { get ; } = new hash _ set < tcp _ handler > ( ) ; </%> public tcp _ relay ( shadowsocks _ controller controller , configuration conf )
public tcp _ relay ( shadowsocks _ controller controller , configuration conf ) { controller = controller ; config = conf ; <%> <-> handlers = new hash _ set < tcp _ handler > ( ) ; </%> last _ sweep _ time = date _ time . now ; <%> <+> factories . add ( new socks _ handler _ factory ( ) ) ; factories . add ( new http _ handler _ handler _ factory ( ) ) ; </%> } public override bool handle ( byte [ ] first _ packet , int length , socket socket , object state )
last _ sweep _ time = date _ time . now ; <%> <+> factories . add ( new socks _ handler _ factory ( ) ) ; factories . add ( new http _ handler _ handler _ factory ( ) ) ; </%> } public override bool handle ( byte [ ] first _ packet , int length , socket socket , object state ) { <%> <*> if ( socket . protocol _ type ! = protocol _ type . tcp | | ( length < 2 | | first _ packet [ 0 ] ! = NUM ) ) -> tcp _ handler handler = null ; </%> <%> <+> foreach ( var factory in factories ) </%>
return false ; <%> <+> } </%> socket . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; <%> <-> tcp _ handler handler = new tcp _ handler ( controller , config , this , socket ) ; </%> i _ list < tcp _ handler > handlers _ to _ close = new list < tcp _ handler > ( ) ; lock ( handlers ) { handlers . add ( handler ) ; date _ time now = date _ time . now ; if ( now - last _ sweep _ time > time _ span . from _ seconds ( 1 ) )
i _ list < tcp _ handler > handlers _ to _ close = new list < tcp _ handler > ( ) ; lock ( handlers ) { handlers . add ( handler ) ; date _ time now = date _ time . now ; if ( now - last _ sweep _ time > time _ span . from _ seconds ( 1 ) ) { last _ sweep _ time = now ; foreach ( tcp _ handler handler in handlers ) if ( now - handler . last _ activity > time _ span . from _ seconds ( NUM ) )
{ <%> <*> class async _ session -> bool can _ handle ( byte [ ] first _ packet , int length ) ; </%> <%> <+> tcp _ handler new _ handler ( shadowsocks _ controller controller , configuration config , tcp _ relay tcprelay , socket socket ) ; } abstract class tcp _ handler { public abstract void start _ handshake ( byte [ ] first _ packet , int length ) ; protected abstract void on _ server _ connected ( async _ session session ) ; protected class async _ session </%>
{ public i _ forward _ proxy remote { get ; } public async _ session ( i _ forward _ proxy remote ) { remote = remote ; } } <%> <+> protected </%> class async _ session < t > : async _ session { public t state { get ; set ; }
{ public t state { get ; set ; } public async _ session ( i _ forward _ proxy remote , t state ) : base ( remote ) { state = state ; } public async _ session ( async _ session session , t state ) : base ( session . remote ) { state = state ; }
private async _ session current _ remote _ session ; private bool proxy _ connected ; private bool dest _ connected ; <%> <-> private byte command ; private byte [ ] first _ packet ; private int first _ packet _ length ; </%> private int total _ read = 0 ; private int total _ write = 0 ; <%> <+> protected byte [ ] remote _ recv _ buffer { get ; } = new byte [ buffer _ size ] ; private readonly byte [ ] remote _ send _ buffer = new byte [ buffer _ size ] ; </%>
private date _ time start _ connect _ time ; private date _ time start _ receiving _ time ; private date _ time start _ sending _ time ; private end _ point dest _ end _ point = null ; public tcp _ handler ( shadowsocks _ controller controller , configuration config , tcp _ relay tcprelay , socket socket <%> <*> ) -> , bool auto _ append _ header = true ) </%> { controller = controller ; config = config ; tcprelay = tcprelay ; connection = socket ;
{ controller = controller ; config = config ; tcprelay = tcprelay ; connection = socket ; proxy _ timeout = config . proxy . proxy _ timeout * NUM ; server _ timeout = config . get _ current _ server ( ) . timeout * NUM ; last _ activity = date _ time . now ; <%> <+> server _ header _ sent = ! auto _ append _ header ; </%> }
if ( server = = null | | server . server = = STR ) throw new argument _ exception ( STR ) ; lock ( encryption _ lock ) { lock ( decryption _ lock ) { encryptor = encryptor _ factory . get _ encryptor ( server . method , server . password , server . auth , false ) ; } } this . server = server ;
try { start _ receiving _ time = date _ time . now ; session . remote . begin _ receive ( remote _ recv _ buffer , 0 , recv _ size , socket _ flags . none , <%> <-> new async _ callback ( </%> pipe _ remote _ receive _ callback <%> <-> ) </%> , session ) ; <%> <*> send -> connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv </%> _ <%> <*> to -> size , socket </%> _ <%> <*> server ( first -> flags . none , pipe _ connection </%> _ <%> <*> packet -> receive </%> _ <%> <*> length -> callback </%> , session ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ;
} catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; } } private void pipe _ remote _ receive _ callback ( i _ async _ result ar ) { if ( closed ) return ;
i _ strategy strategy = controller . get _ current _ strategy ( ) ; strategy ? . update _ last _ write ( server ) ; } <%> <+> protected async _ session end _ send _ to _ server ( i _ async _ result ar ) { var session = ( async _ session ) ar . async _ state ; session . remote . end _ send ( ar ) ; return session ; } </%> private void pipe _ remote _ send _ callback ( i _ async _ result ar )
try { var session = ( async _ session ) ar . async _ state ; <%> <-> session . remote . end _ send ( ar ) ; connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , socket _ flags . none , new async _ callback ( pipe _ connection _ receive _ callback ) , session ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; </%>
} catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; } } } }
listener = new listener ( services ) ; listener . start ( config ) ; } catch ( exception e ) { if ( e is socket _ exception ) { socket _ exception se = ( socket _ exception ) e ; if ( se . socket _ error _ code = = socket _ error . access _ denied ) {
request [ 0 ] = NUM ; request [ 1 ] = 1 ; request [ 2 ] = 0 ; <%> <-> request [ NUM ] = atyp ; request [ request . length - 2 ] = ( byte ) ( ( port > > NUM ) & 0 xff ) ; request [ request . length - 1 ] = ( byte ) ( port & 0 xff ) ; </%> var st = new socks _ state ( ) ; st . callback = callback ; st . async _ state = state ; remote . begin _ send ( request , 0 , request . length , 0 , socks _ request _ send _ callback , st ) ;
var st = new socks _ state ( ) ; st . callback = callback ; st . async _ state = state ; remote . begin _ send ( request , 0 , request . length , 0 , socks _ request _ send _ callback , st ) ; } public void end _ connect _ dest ( i _ async _ result async _ result ) { var state = ( ( fake _ async _ result ) async _ result ) . inner _ state ; if ( state . ex ! = null ) {
int entry _ name _ size = 0 ; int lp _ size = 0 ; uint retval = error _ success ; ras _ entry _ name [ ] names = null ; entry _ name _ size = marshal . size _ of ( typeof ( ras _ entry _ name ) ) ; <%> <*> lp _ size = lp _ names * entry _ name _ size ; names = new ras _ entry _ name [ lp _ names ] ; names [ 0 ] . dw _ size = entry _ name _ size ; retval = ras . ras _ enum _ entries ( null , null , names , ref lp _ size , out lp _ names ) ; -> retval = ras _ enum _ entries ( null , null , null , ref lp _ size , out lp _ names ) ; </%>
if ( retval = = error _ buffer _ too _ small ) { names = new ras _ entry _ name [ lp _ names ] ; for ( int i = 0 ; i < names . length ; i + + ) { names [ i ] . dw _ size = entry _ name _ size ; } retval = <%> <-> ras . </%> ras _ enum _ entries ( null , null , names , ref lp _ size , out lp _ names ) ; } if ( retval = = error _ success )
} if ( retval = = error _ success ) { if ( lp _ names = = 0 ) { return 1 ; } all _ conns = new string [ names . length ] ; for ( int i = 0 ; i < names . length ; i + + ) {
foreach ( var strategy in controller . get _ strategies ( ) ) { menu _ item item = new menu _ item ( strategy . name ) ; item . tag = strategy . id ; item . click + = a _ strategy _ item _ click ; items . add ( <%> <*> i -> strategy _ count </%> , item ) ; <%> <*> i -> strategy _ count </%> + + ; } items . add ( <%> <*> i -> strategy _ count </%> + + , new menu _ item ( STR ) ) ; int <%> <*> strategy -> server </%> _ count = <%> <*> i -> 0 </%> ;
} items . add ( <%> <*> i -> strategy _ count </%> + + , new menu _ item ( STR ) ) ; int <%> <*> strategy -> server </%> _ count = <%> <*> i -> 0 </%> ; configuration configuration = controller . get _ configuration _ copy ( ) ; foreach ( var server in configuration . configs ) { if ( configuration . checks _ server ( server ) ) { menu _ item item = new menu _ item ( server . friendly _ name ( ) ) ; item . tag = <%> <*> i - strategy -> configuration . configs . find </%> _ <%> <*> count ; -> index ( s = > s = = server ) ; </%>
configuration configuration = controller . get _ configuration _ copy ( ) ; foreach ( var server in configuration . configs ) { if ( configuration . checks _ server ( server ) ) { menu _ item item = new menu _ item ( server . friendly _ name ( ) ) ; item . tag = <%> <*> i - strategy -> configuration . configs . find </%> _ <%> <*> count ; -> index ( s = > s = = server ) ; </%> item . click + = a _ server _ item _ click ; items . add ( <%> <*> i -> strategy _ count + server _ count </%> , item ) ; <%> <*> i -> server _ count </%> + + ;
item . click + = a _ server _ item _ click ; items . add ( <%> <*> i -> strategy _ count + server _ count </%> , item ) ; <%> <*> i -> server _ count </%> + + ;

} ) , new menu _ item ( STR ) , this . auto _ startup _ item = create _ menu _ item ( STR , new event _ handler ( this . auto _ startup _ item _ click ) ) , this . share _ over _ lan _ item = create _ menu _ item ( STR , new event _ handler ( this . share _ over _ lan _ item _ click ) ) , create _ menu _ item ( STR , new event _ handler ( this . edit _ pac _ file _ item _ click ) ) , create _ menu _ item ( STR , new event _ handler ( this . update _ pac _ from _ gfw _ list _ item _ click ) ) , new menu _ item ( STR ) , <%> <-> create _ menu _ item ( STR , new event _ handler ( this . qr _ code _ item _ click ) ) , create _ menu _ item ( STR , new event _ handler ( this . scan _ qr _ code _ item _ click ) ) , </%> create _ menu _ item ( STR , new event _ handler ( this . show _ log _ item _ click ) ) ,
create _ menu _ item ( STR , new event _ handler ( this . show _ log _ item _ click ) ) , create _ menu _ item ( STR , new event _ handler ( this . about _ item _ click ) ) , new menu _ item ( STR ) , create _ menu _ item ( STR , new event _ handler ( this . quit _ click ) ) } ) ; } private void controller _ config _ changed ( object sender , event _ args e ) { load _ current _ configuration ( ) ; update _ tray _ icon ( ) ;
configuration configuration = controller . get _ configuration ( ) ; for ( int i = 0 ; i < configuration . configs . count ; i + + ) { server server = configuration . configs [ i ] ; menu _ item item = new menu _ item ( server . friendly _ name ( ) ) ; item . tag = i ; item . click + = a _ server _ item _ click ; items . add ( <%> <+> i , </%> item ) ; } <%> <-> items . add ( seperator _ item ) ; </%>
if ( configuration . index > = 0 & & configuration . index < configuration . configs . count ) { items [ configuration . index ] . checked = true ; } } private void show _ config _ form ( ) { if ( config _ form ! = null ) { config _ form . activate ( ) ;
} <%> <+> message _ box . show ( n . get _ string ( STR ) ) ; </%> } } private void auto _ startup _ item _ click ( object sender , event _ args e ) { auto _ startup _ item . checked = ! auto _ startup _ item . checked ; if ( ! auto _ startup . set ( auto _ startup _ item . checked ) ) { message _ box . show ( STR ) ; } }
if ( file . exists ( pac _ server . user _ rule _ file ) ) { string local = file <%> <+> _ manager </%> . <%> <+> non _ exclusive _ </%> read _ all _ text ( pac _ server . user _ rule _ file , encoding . ut ) ; using ( var sr = new string _ reader ( local ) ) { foreach ( var rule in sr . non _ white _ space _ lines ( ) ) { if ( rule . begin _ with _ any ( ignored _ line _ begins ) ) continue ; lines . add ( rule ) ;
using ( var sr = new string _ reader ( local ) ) { foreach ( var rule in sr . non _ white _ space _ lines ( ) ) { if ( rule . begin _ with _ any ( ignored _ line _ begins ) ) continue ; lines . add ( rule ) ; } } }
} void controller _ share _ over _ lan _ status _ changed ( object sender , event _ args e ) { share _ over _ lan _ item . checked = controller . get _ configuration _ copy ( ) . share _ over _ lan ; } <%> <*> void controller _ verbose _ logging _ status _ changed ( object sender , event _ args e ) { -> void controller _ verbose _ logging _ status _ changed ( object sender , event _ args e ) </%> <%> <+> { </%> verbose _ logging _ toggle _ item . checked = controller . get _ configuration _ copy ( ) . is _ verbose _ logging ; }
} private void global _ mode _ item _ click ( object sender , event _ args e ) { <%> <+> controller . toggle _ enable ( true ) ; </%> controller . toggle _ global ( true ) ; <%> <+> configuration config = controller . get _ configuration _ copy ( ) ; update _ system _ proxy _ items _ enabled _ status ( config ) ; </%> } private void pac _ mode _ item _ click ( object sender , event _ args e ) {
stream _ writer _ with _ timestamp sw = new stream _ writer _ with _ timestamp ( fs ) ; sw . auto _ flush = true ; console . set _ out ( sw ) ; console . set _ error ( sw ) ; return true ; } catch ( io _ exception e ) { console . write _ line ( e . to _ string ( ) ) ; return false ;
if ( polipo _ runner = = null ) { polipo _ runner = new polipo _ runner ( ) ; } polipo _ runner . start ( config ) ; <%> <+> local = new local ( config ) ; local . start ( ) ; </%> } private void config _ click ( object sender , event _ args e ) {
{ menu _ item result = new menu _ item ( n . get _ string ( text ) , click ) ; <%> <-> result . index = index ; </%> return result ; } private menu _ item create _ seperator _ item ( <%> <-> int index </%> ) { menu _ item result = new menu _ item ( STR ) ; <%> <-> result . index = index ; </%> return result ;
return result ; } private menu _ item create _ seperator _ item ( <%> <-> int index </%> ) { menu _ item result = new menu _ item ( STR ) ; <%> <-> result . index = index ; </%> return result ; } private menu _ item create _ menu _ group ( <%> <-> int index , </%> string text , menu _ item [ ] items ) {
{ menu _ item result = new menu _ item ( STR ) ; <%> <-> result . index = index ; </%> return result ; } private menu _ item create _ menu _ group ( <%> <-> int index , </%> string text , menu _ item [ ] items ) { <%> <+> for ( int i = 0 ; i < items . length ; i + + ) { items [ i ] . index = i ; </%>
return result ; } private menu _ item create _ menu _ group ( <%> <-> int index , </%> string text , menu _ item [ ] items ) { <%> <+> for ( int i = 0 ; i < items . length ; i + + ) { items [ i ] . index = i ; } </%> menu _ item result = new menu _ item ( n . get _ string ( text ) , items ) ; <%> <-> result . index = index ; </%>
menu _ item result = new menu _ item ( n . get _ string ( text ) , items ) ; <%> <-> result . index = index ; </%> return result ; } private void load _ menu ( ) { this . context _ menu = new system . windows . forms . context _ menu ( ) ; <%> <-> this . pac _ mode _ item = create _ menu _ item ( 0 , STR , new system . event _ handler ( this . pac _ mode _ item _ click ) ) ; this . global _ mode _ item = create _ menu _ item ( 1 , STR , new system . event _ handler ( this . global _ mode _ item _ click ) ) ; this . seperator _ item = create _ seperator _ item ( 0 ) ; </%>
return result ; } private void load _ menu ( ) { this . context _ menu = new system . windows . forms . context _ menu ( ) ; <%> <-> this . pac _ mode _ item = create _ menu _ item ( 0 , STR , new system . event _ handler ( this . pac _ mode _ item _ click ) ) ; this . global _ mode _ item = create _ menu _ item ( 1 , STR , new system . event _ handler ( this . global _ mode _ item _ click ) ) ; this . seperator _ item = create _ seperator _ item ( 0 ) ; this . config _ item = create _ menu _ item ( 1 , STR , new system . event _ handler ( this . config _ click ) ) ; this . enable _ item = create _ menu _ item ( 0 , STR , new system . event _ handler ( this . enable _ item _ click ) ) ; </%>
} ) ; <%> <-> this . auto _ startup _ item = create _ menu _ item ( NUM , STR , new system . event _ handler ( this . auto _ startup _ item _ click ) ) ; this . share _ over _ lan _ item = create _ menu _ item ( NUM , STR , new system . event _ handler ( this . share _ over _ lan _ item _ click ) ) ; this . context _ menu . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . enable _ item , create _ menu _ group ( 1 , STR , new system . windows . forms . menu _ item [ ] { this . pac _ mode _ item , this . global _ mode _ item } ) , this . servers _ item , </%>
} private void controller _ config _ changed ( object sender , event _ args e ) { load _ current _ configuration ( ) ; update _ tray _ icon ( ) ; } private void controller _ enable _ status _ changed ( object sender , event _ args e ) { enable _ item . checked = controller . get _ configuration ( ) . enabled ; }
{ <%> <+> int atyp = connetion _ recv _ buffer [ 0 ] ; string dst _ addr ; int dst _ port ; switch ( atyp ) { </%> case 1 : dst _ addr = new ip _ address ( connetion _ recv _ buffer . skip ( 1 ) . take ( NUM ) . to _ array ( ) ) . to _ string ( ) ; dst _ port = ( connetion _ recv _ buffer [ NUM ] < < NUM ) + connetion _ recv _ buffer [ NUM ] ; <%> <-> if ( config . is _ verbose _ logging ) { </%>
} int bytes _ to _ send ; lock ( encryption _ lock ) { if ( closed ) return ; encryptor . encrypt ( connetion _ recv _ buffer , bytes _ read , connetion _ send _ buffer , out bytes _ to _ send ) ; } tcprelay . update _ outbound _ counter ( server , bytes _ to _ send ) ; start _ sending _ time = date _ time . now ; bytes _ to _ send = bytes _ to _ send ;
public string version ; public list < server > configs ; public string strategy ; public int index ; public bool global ; public bool enabled ; public bool share _ over _ lan ; public bool is _ default ; <%> <-> public bool is _ i _ pv _ enabled = false ; </%> public int local _ port ;
public int local _ port ; public bool portable _ mode = true ; public bool show _ plugin _ output ; public string pac _ url ; <%> <-> public string geosite _ url ; public string geosite _ group = STR ; public bool geosite _ blacklist _ mode = true ; </%> public bool use _ online _ pac ; public bool secure _ local _ pac = true ; public bool availability _ statistics ;
public bool use _ online _ pac ; public bool secure _ local _ pac = true ; public bool availability _ statistics ; public bool auto _ check _ update ; public bool check _ pre _ release ; public bool is _ verbose _ logging ; <%> <+> public bool is _ i _ pv _ enabled = false ; </%> public bool generate _ legacy _ url = false ; <%> <+> public string geosite _ url ; public string geosite _ group = STR ; </%>
public log _ viewer _ config log _ viewer ; public proxy _ config proxy ; public hotkey _ config hotkey ; json _ ignore n _ log _ config n _ log _ config ; private static readonly string config _ file = STR ; <%> <*> private static readonly n _ log _ config . log _ level verbose _ log _ level = -> private static readonly n _ log _ config . log _ level verbose _ log _ level = </%> n _ log _ config . log _ level . trace ; <%> <+> private static readonly n _ log _ config . log _ level verbose _ log _ level = </%> n _ log _ config . log _ level . debug ; json _ ignore
<%> <+> private static readonly n _ log _ config . log _ level verbose _ log _ level = </%> n _ log _ config . log _ level . trace ; <%> <+> private static readonly n _ log _ config . log _ level verbose _ log _ level = </%> n _ log _ config . log _ level . debug ; json _ ignore public bool updated = false ; json _ ignore public string local _ host = > get _ local _ host ( ) ; private string get _ local _ host ( ) { return is _ i _ pv _ enabled ? STR : STR ; }
<%> <+> private static readonly n _ log _ config . log _ level verbose _ log _ level = </%> n _ log _ config . log _ level . debug ; json _ ignore public bool updated = false ; json _ ignore public string local _ host = > get _ local _ host ( ) ; private string get _ local _ host ( ) { return is _ i _ pv _ enabled ? STR : STR ; } public server get _ current _ server ( )
json _ ignore public bool updated = false ; json _ ignore public string local _ host = > get _ local _ host ( ) ; private string get _ local _ host ( ) { return is _ i _ pv _ enabled ? STR : STR ; } public server get _ current _ server ( ) {
using system _ text ; using system _ windows _ forms ; using shadowsocks _ controller ; <%> <-> using shadowsocks _ controller _ hotkeys ; </%> using shadowsocks _ model ; using shadowsocks _ properties ; using <%> <+> static </%> shadowsocks <%> <+> . controller . hotkey </%> _ <%> <*> util -> reg </%> ; namespace shadowsocks _ view { public partial class hotkey _ settings _ form : form
using shadowsocks _ model ; using shadowsocks _ properties ; using <%> <+> static </%> shadowsocks <%> <+> . controller . hotkey </%> _ <%> <*> util -> reg </%> ; namespace shadowsocks _ view { public partial class hotkey _ settings _ form : form { private readonly shadowsocks _ controller controller ; private hotkey _ config modified _ hotkey _ config ; public hotkey _ settings _ form ( shadowsocks _ controller controller )
namespace shadowsocks _ view { public partial class hotkey _ settings _ form : form { private readonly shadowsocks _ controller controller ; private hotkey _ config modified _ hotkey _ config ; public hotkey _ settings _ form ( shadowsocks _ controller controller ) { initialize _ component ( ) ; update _ texts ( ) ;
} private <%> <*> bool reg _ hotkey -> void handle </%> _ <%> <*> from -> reg </%> _ <%> <*> string -> result </%> ( string hotkey _ str , <%> <*> string callback _ name -> label label </%> , <%> <*> label indicator = null -> reg _ result result </%> ) { <%> <*> var callback = hotkey _ callbacks . get _ callback ( callback _ name ) ; if ( callback = = null ) -> switch ( result ) </%> { <%> <-> throw new exception ( $ STR ) ; } var callback = callback as hot _ keys . hot _ key _ call _ back _ handler ; </%>
{ <%> <*> var callback = hotkey _ callbacks . get _ callback ( callback _ name ) ; if ( callback = = null ) -> switch ( result ) </%> { <%> <-> throw new exception ( $ STR ) ; } var callback = callback as hot _ keys . hot _ key _ call _ back _ handler ; if ( hotkey _ str . is _ null _ or _ empty ( ) ) { </%>
{ <%> <-> throw new exception ( $ STR ) ; } var callback = callback as hot _ keys . hot _ key _ call _ back _ handler ; if ( hotkey _ str . is _ null _ or _ empty ( ) ) { hot _ keys . unreg _ existing _ hotkey ( callback ) ; if ( indicator ! = null ) { indicator . reset _ back _ color ( ) ; </%>
message _ box . show ( string . format ( n . get _ string ( STR ) , hotkey _ str ) ) ; <%> <-> return false ; } else { bool reg _ result = ( hot _ keys . reg _ hotkey ( hotkey , callback ) ) ; if ( indicator ! = null ) { indicator . back _ color = reg _ result ? color . green : color . yellow ; } </%>
} } } }
{ is _ startup _ checking = true ; update _ checker . check _ update ( config , NUM ) ; <%> <-> } if ( config . is _ default ) { is _ first _ run = true ; show _ config _ form ( ) ; </%>

} else if ( ! is _ startup _ checking ) { show _ balloon _ tip ( n . get _ string ( STR ) , n . get _ string ( STR ) , tool _ tip _ icon . info , NUM ) ; <%> <-> is _ first _ run = false ; </%> } is _ startup _ checking = false ; } void notify _ icon _ balloon _ tip _ clicked ( object sender , event _ args e ) {
} is _ startup _ checking = false ; } void notify _ icon _ balloon _ tip _ clicked ( object sender , event _ args e ) { if ( update _ checker . new _ version _ found ) { update _ checker . new _ version _ found = false ; if ( system . io . file . exists ( update _ checker . latest _ version _ local _ name ) ) {

update _ move _ up _ and _ down _ button ( ) ; load _ selected _ server ( ) ; } private void config _ form _ load ( object sender , event _ args e ) { } private void servers _ list _ box _ selected _ index _ changed ( object sender , event _ args e ) { if ( <%> <*> old -> last </%> _ selected _ index = = servers _ list _ box . selected _ index ) {
{ <%> <*> old -> last </%> _ selected _ index = modified _ configuration . configs . count - 1 ; } servers _ list _ box . selected _ index = <%> <*> old -> last </%> _ selected _ index ; load _ configuration ( modified _ configuration ) ; servers _ list _ box . selected _ index = <%> <*> old -> last </%> _ selected _ index ; load _ selected _ server ( ) ; } private void ok _ button _ click ( object sender , event _ args e ) {
controller . save _ servers ( modified _ configuration . configs , modified _ configuration . local _ port ) ; controller . select _ server _ index ( <%> <+> modified _ configuration . configs . </%> index <%> <+> _ of ( server ) </%> ) ; this . close ( ) ; } private void cancel _ button _ click ( object sender , event _ args e ) { this . close ( ) ; } private void config _ form _ shown ( object sender , event _ args e ) {
this . close ( ) ; } private void cancel _ button _ click ( object sender , event _ args e ) { this . close ( ) ; } private void config _ form _ shown ( object sender , event _ args e ) { ip _ text _ box . focus ( ) ; }
protected int encrypt _ bytes _ remaining ; protected int decrypt _ bytes _ remaining ; protected ulong encrypt _ ic ; protected ulong decrypt _ ic ; <%> <+> protected byte [ ] encrypt _ buf ; protected byte [ ] decrypt _ buf ; </%> public sodium _ encryptor ( string method , string password , bool onetimeauth , bool isudp ) : base ( method , password , onetimeauth , isudp ) { <%> <+> encrypt _ buf = new byte [ max _ input _ size + sodium _ block _ size ] ; </%>
{ <%> <-> if ( is _ cipher ) { </%> bytes _ remaining = encrypt _ bytes _ remaining ; ic = encrypt _ ic ; <%> <+> sodium _ buf = encrypt _ buf ; </%> iv = encrypt _ iv ; } else {
} } public override void dispose ( ) { } } }
using system ; using system _ collections _ generic ; using system _ diagnostics ; using system _ io ; using system _ i _ compression ; using system _ text ; namespace shadowsocks <%> <-> _ csharp </%> _ controller { class polipo _ runner {
{ class polipo _ runner { private process process ; public void start ( server config ) { if ( process = = null ) { process [ ] existing _ polipo = process . get _ processes _ by _ name ( STR ) ; foreach ( process p in existing _ polipo )
using system ; using system _ collections _ generic ; using system _ diagnostics ; using system _ io ; using system _ i _ compression ; using system _ net ; using system _ net _ sockets ; using system _ text ; namespace shadowsocks <%> <-> _ csharp </%> _ controller {
{ class pac _ server { private static string pac _ file = STR ; socket listener ; file _ system _ watcher watcher ; public event event _ handler pac _ file _ changed ; public void start ( ) { listener = new socket ( address _ family . inter _ network ,
using system ; using system _ collections _ generic ; using system _ text ; namespace shadowsocks <%> <-> _ csharp </%> _ controller { public class shadowsocks _ controller { private local local ; private pac _ server pac _ server ; private configuration config ;
{ public class shadowsocks _ controller { private local local ; private pac _ server pac _ server ; private configuration config ; private polipo _ runner polipo _ runner ; private bool stopped = false ; public class path _ event _ args : event _ args {
using system ; using system _ collections _ generic ; using system _ io ; using system _ runtime _ interop _ services ; using system _ windows _ forms ; namespace shadowsocks <%> <-> _ csharp </%> { static class program { dll _ import _ kernel _ dll
{ static class program { dll _ import _ kernel _ dll private static extern int _ ptr load _ library ( string path ) ; sta _ thread static void main ( ) { string temp _ path = path . get _ temp _ path ( ) ; string dll _ path = temp _ path + STR ;
} } private void load _ current _ configuration ( ) { modified _ configuration = controller . get _ configuration ( ) ; load _ configuration ( modified _ configuration ) ; old _ selected _ index = modified _ configuration . index ; servers _ list _ box . selected _ index = modified _ configuration . index ; load _ selected _ server ( ) ; <%> <+> update _ servers _ menu ( ) ; </%>
this . edit _ pac _ file _ item , this . about _ item , this . menu _ item , this . quit _ item } ) ; this . enable _ item . index = 0 ; this . enable _ item . text = STR ; this . enable _ item . click + = new system . event _ handler ( this . enable _ item _ click ) ; <%> <+> this . servers _ item . index = 1 ; this . servers _ item . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . seperator _ item , </%>
this . edit _ pac _ file _ item . index = <%> <*> 2 -> NUM </%> ; this . edit _ pac _ file _ item . text = STR ; this . edit _ pac _ file _ item . click + = new system . event _ handler ( this . edit _ pac _ file _ item _ click ) ; this . about _ item . index = NUM ; this . about _ item . text = STR ; this . about _ item . click + = new system . event _ handler ( this . about _ item _ click ) ; this . menu _ item . index = NUM ; this . menu _ item . text = STR ; this . quit _ item . index = NUM ; this . quit _ item . text = STR ;
this . edit _ pac _ file _ item . click + = new system . event _ handler ( this . edit _ pac _ file _ item _ click ) ; this . about _ item . index = NUM ; this . about _ item . text = STR ; this . about _ item . click + = new system . event _ handler ( this . about _ item _ click ) ; this . menu _ item . index = NUM ; this . menu _ item . text = STR ; this . quit _ item . index = NUM ; this . quit _ item . text = STR ; this . quit _ item . click + = new system . event _ handler ( this . quit _ click ) ; this . panel . auto _ size = true ;
listener = new listener ( services ) ; listener . start ( config ) ; } catch ( exception e ) { if ( e is socket _ exception ) { socket _ exception se = ( socket _ exception ) e ; if ( se . socket _ error _ code = = socket _ error . access _ denied ) {
{ private static int uid ; private static string unique _ config _ file ; private static job <%> <*> polipo -> privoxy </%> _ job ; private process process ; private int running _ port ; static <%> <*> polipo -> privoxy </%> _ runner ( ) { try {
{ try { uid = application . startup _ path . get _ hash _ code ( ) ; unique _ config _ file = $ STR ; <%> <*> polipo -> privoxy </%> _ job = new job ( ) ; file _ manager . uncompress _ file ( utils . get _ temp _ path ( STR ) , resources . privoxy _ exe ) ; file _ manager . uncompress _ file ( utils . get _ temp _ path ( STR ) , resources . mgwz _ dll ) ; } catch ( io _ exception e )
{ kill _ process ( p ) ; } string <%> <*> polipo -> privoxy </%> _ config = resources . privoxy _ conf ; running _ port = this . get _ free _ port ( ) ; <%> <*> polipo -> privoxy </%> _ config = <%> <*> polipo -> privoxy </%> _ config . replace ( STR , configuration . local _ port . to _ string ( ) ) ; <%> <*> polipo -> privoxy </%> _ config = <%> <*> polipo -> privoxy </%> _ config . replace ( STR , running _ port . to _ string ( ) ) ; <%> <*> polipo -> privoxy </%> _ config = <%> <*> polipo -> privoxy </%> _ config . replace ( STR , configuration . share _ over _ lan ? STR : STR ) ; file _ manager . byte _ array _ to _ file ( utils . get _ temp _ path ( unique _ config _ file ) , encoding . ut . get _ bytes ( <%> <*> polipo -> privoxy </%> _ config ) ) ; process = new process ( ) ;
running _ port = this . get _ free _ port ( ) ; <%> <*> polipo -> privoxy </%> _ config = <%> <*> polipo -> privoxy </%> _ config . replace ( STR , configuration . local _ port . to _ string ( ) ) ; <%> <*> polipo -> privoxy </%> _ config = <%> <*> polipo -> privoxy </%> _ config . replace ( STR , running _ port . to _ string ( ) ) ; <%> <*> polipo -> privoxy </%> _ config = <%> <*> polipo -> privoxy </%> _ config . replace ( STR , configuration . share _ over _ lan ? STR : STR ) ; file _ manager . byte _ array _ to _ file ( utils . get _ temp _ path ( unique _ config _ file ) , encoding . ut . get _ bytes ( <%> <*> polipo -> privoxy </%> _ config ) ) ; process = new process ( ) ; process . start _ info . file _ name = STR ; process . start _ info . arguments = unique _ config _ file ; process . start _ info . working _ directory = utils . get _ temp _ path ( ) ; process . start _ info . window _ style = process _ window _ style . hidden ;
process = new process ( ) ; process . start _ info . file _ name = STR ; process . start _ info . arguments = unique _ config _ file ; process . start _ info . working _ directory = utils . get _ temp _ path ( ) ; process . start _ info . window _ style = process _ window _ style . hidden ; process . start _ info . use _ shell _ execute = true ; process . start _ info . create _ no _ window = true ; process . start ( ) ; * add this process to job obj associated with this ss process , so that * when ss exit unexpectedly , this process will be forced killed by system .
{ throw new file _ not _ found _ exception ( n . get _ string ( STR ) , plugin _ process . start _ info . file _ name , ex ) ; } <%> <+> throw new application _ exception ( n . get _ string ( STR ) , ex ) ; </%> } plugin _ job . add _ process ( plugin _ process . handle ) ; started = true ; } return true ; }
using shadowsocks _ controller ; using shadowsocks _ model ; <%> <-> using simple _ json ; using system _ net _ network _ information ; </%> namespace shadowsocks _ view { public partial class statistics _ strategy _ configuration _ form : form { private readonly shadowsocks _ controller controller ; private statistics _ strategy _ configuration configuration ;
namespace shadowsocks _ view { public partial class statistics _ strategy _ configuration _ form : form { private readonly shadowsocks _ controller controller ; private statistics _ strategy _ configuration configuration ; private data _ table data _ table = new data _ table ( ) ; private list < string > servers ; public statistics _ strategy _ configuration _ form ( shadowsocks _ controller controller ) {
list < asset > asserts = new list < asset > ( ) ; <%> <*> foreach -> if </%> ( <%> <*> json _ object release in result -> result ! = null </%> ) { <%> <*> if -> foreach </%> ( <%> <*> ( bool ) -> j _ object </%> release <%> <*> [ STR ] -> in result </%> ) { <%> <-> continue ; </%> <%> <*> } -> if ( ( bool ) release [ STR ] ) </%> <%> <-> foreach ( json _ object asset in ( json _ array ) release [ STR ] ) { asset ass = new asset ( ) ; </%>
{ <%> <+> continue ; } foreach ( j _ object asset in ( j _ array ) release [ STR ] ) { asset ass = new asset ( ) ; ass . parse ( asset ) ; if ( ass . is _ new _ version ( version ) ) { </%> asserts . add ( ass ) ;
} } } if ( asserts . count ! = 0 ) { sort _ by _ versions ( asserts ) ; asset asset = asserts [ asserts . count - 1 ] ; new _ version _ found = true ; latest _ version _ url = asset . browser _ download _ url ; latest _ version _ number = asset . version ;
using system _ text ; <%> <*> using system _ io ; using system _ diagnostics ; using simple _ json ; -> using system _ text _ regular _ expressions ; </%> using shadowsocks _ controller ; <%> <-> using system _ text _ regular _ expressions ; </%> namespace shadowsocks _ model { serializable
using shadowsocks _ controller ; <%> <-> using system _ text _ regular _ expressions ; </%> namespace shadowsocks _ model { serializable public class server { public string server ; public int server _ port ; public string password ;
namespace shadowsocks _ model { serializable public class server { public string server ; public int server _ port ; public string password ; public string method ; public string remarks ;
using system _ collections _ generic ; using system _ io ; <%> <*> using system _ text ; using system _ windows _ forms ; using simple _ json ; -> using shadowsocks _ controller ; </%> <%> <+> using newtonsoft _ json ; </%> namespace shadowsocks _ model { serializable
namespace shadowsocks _ model { serializable public class configuration { public list < server > configs ; public string strategy ; public int index ; public bool global ; public bool enabled ;
{ <%> <*> public const int type _ table = 1 ; public const int type _ r = 2 ; -> public static string [ ] encryption _ names = new string [ ] { </%> <%> <+> STR , STR , STR , STR , STR , STR </%>
public byte [ ] encrypt _ table = new byte [ NUM ] ; public byte [ ] decrypt _ table = new byte [ NUM ] ; <%> <*> public int method = type _ table ; public r rc = null ; -> public string method = STR ; </%> <%> <+> public string password ; public byte [ ] key ; private r rc = null ; private cipher cipher = null ; private int _ ptr encrypt _ ctx ; </%>
private long compare ( byte x , byte y , ulong a , int i ) { return ( long ) ( a % ( ulong ) ( x + i ) ) - ( long ) ( a % ( ulong ) ( y + i ) ) ; } private byte [ ] merge _ sort ( byte [ ] array , ulong a , int j ) { if ( array . length = = 1 ) return array ; int middle = array . length / 2 ; byte [ ] left = new byte [ middle ] ;
rc = new r ( ) ; encrypt _ table = rc . encrypt _ initalize ( hash ) ; decrypt _ table = rc . encrypt _ initalize ( hash ) ; <%> <*> } else { -> } </%> <%> <+> else if ( method = = STR | | method = = STR | | method = = null ) { </%> console . write _ line ( STR ) ; <%> <-> this . method = type _ table ; </%> var a = bit _ converter . to _ u _ int ( hash , 0 ) ;
console . write _ line ( STR ) ; <%> <-> this . method = type _ table ; </%> var a = bit _ converter . to _ u _ int ( hash , 0 ) ; for ( int i = 0 ; i < NUM ; i + + ) { encrypt _ table [ i ] = ( byte ) i ; } for ( int i = 1 ; i < NUM ; i + + ) { encrypt _ table = merge _ sort ( encrypt _ table , a , i ) ;
var a = bit _ converter . to _ u _ int ( hash , 0 ) ; for ( int i = 0 ; i < NUM ; i + + ) { encrypt _ table [ i ] = ( byte ) i ; } for ( int i = 1 ; i < NUM ; i + + ) { encrypt _ table = merge _ sort ( encrypt _ table , a , i ) ; } for ( int i = 0 ; i < NUM ; i + + )
{ switch ( method ) { case <%> <*> type _ table -> STR </%> : for ( int i = 0 ; i < length ; i + + ) buf [ i ] = encrypt _ table [ buf [ i ] ] ; <%> <+> return buf ; </%> break ; case <%> <*> type _ r -> STR </%> : rc . encrypt ( encrypt _ table , buf , length ) ;
for ( int i = 0 ; i < length ; i + + ) buf [ i ] = encrypt _ table [ buf [ i ] ] ; <%> <+> return buf ; </%> break ; case <%> <*> type _ r -> STR </%> : rc . encrypt ( encrypt _ table , buf , length ) ; <%> <+> return buf ; </%> break ; <%> <+> default : return ssl _ encrypt ( buf , length ) ; </%>
rc . encrypt ( encrypt _ table , buf , length ) ; <%> <+> return buf ; </%> break ; <%> <+> default : return ssl _ encrypt ( buf , length ) ; </%> } } public <%> <*> void -> byte [ ] </%> decrypt ( byte [ ] buf , int length ) { switch ( method )
{ switch ( method ) { case <%> <*> type _ table -> STR </%> : for ( int i = 0 ; i < length ; i + + ) buf [ i ] = decrypt _ table [ buf [ i ] ] ; <%> <+> return buf ; </%> break ; case <%> <*> type _ r -> STR </%> : rc . decrypt ( decrypt _ table , buf , length ) ;
for ( int i = 0 ; i < length ; i + + ) buf [ i ] = decrypt _ table [ buf [ i ] ] ; <%> <+> return buf ; </%> break ; case <%> <*> type _ r -> STR </%> : rc . decrypt ( decrypt _ table , buf , length ) ; <%> <+> return buf ; </%> break ; <%> <+> default : return ssl _ decrypt ( buf , length ) ; </%>
rc . decrypt ( decrypt _ table , buf , length ) ; <%> <+> return buf ; </%> break ; <%> <+> default : return ssl _ decrypt ( buf , length ) ; </%> } } } }
} } } }
{ message _ box . show <%> <+> ( ex . to _ string </%> ( <%> <*> STR -> ) </%> ) ; } } private void cancel _ button _ click ( object sender , event _ args e ) { this . hide ( ) ; config _ to _ text _ box ( ) ; } private void form _ form _ closed ( object sender , form _ closed _ event _ args e )
} } private void cancel _ button _ click ( object sender , event _ args e ) { this . hide ( ) ; config _ to _ text _ box ( ) ; } private void form _ form _ closed ( object sender , form _ closed _ event _ args e ) { if ( local ! = null ) local . stop ( ) ;
if ( remote ! = null ) { remote . <%> <*> close -> shutdown </%> ( <%> <+> socket _ shutdown . send </%> ) ; } <%> <+> encryptor . dispose ( ) ; </%> } private void connect _ callback ( i _ async _ result ar ) { try {
} private void connect _ callback ( i _ async _ result ar ) { try { remote . end _ connect ( ar ) ; console . write _ line ( STR , remote . remote _ end _ point . to _ string ( ) ) ; handshake _ receive ( ) ; }
{ if ( server = = null ) { throw new argument _ null _ exception ( nameof ( server ) ) ; } if ( string . is _ null _ or _ white _ space ( server . plugin ) ) { return null ; } <%> <-> return new sip _ plugin ( server . plugin , server . plugin _ opts , server . plugin _ args , server . server , server . server _ port ) ; </%>
} private sip _ plugin ( string plugin , string plugin _ opts , string plugin _ args , string server _ address , int server _ port <%> <*> ) -> , bool show _ plugin _ output ) </%> { if ( plugin = = null ) throw new argument _ null _ exception ( nameof ( plugin ) ) ; if ( string . is _ null _ or _ white _ space ( server _ address ) ) { throw new argument _ exception ( STR , nameof ( server _ address ) ) ; } if ( server _ port < = 0 | | server _ port > NUM ) {
{ if ( plugin = = null ) throw new argument _ null _ exception ( nameof ( plugin ) ) ; if ( string . is _ null _ or _ white _ space ( server _ address ) ) { throw new argument _ exception ( STR , nameof ( server _ address ) ) ; } if ( server _ port < = 0 | | server _ port > NUM ) { throw new argument _ out _ of _ range _ exception ( STR ) ; }
application . enable _ visual _ styles ( ) ; application . set _ compatible _ text _ rendering _ default ( false ) ; application . run ( new form ( ) ) ; <%> <-> local . stop ( ) ; </%> } } }
} } }
this . context _ menu _ strip . name = STR ; this . context _ menu _ strip . render _ mode = system . windows . forms . tool _ strip _ render _ mode . system ; this . context _ menu _ strip . show _ image _ margin = false ; this . context _ menu _ strip . size = new system . drawing . size ( NUM , NUM ) ; this . config <%> <+> _ item </%> . name = STR ; this . config <%> <+> _ item </%> . size = new system . drawing . size ( NUM , NUM ) ; this . config <%> <+> _ item </%> . text = STR ; this . config <%> <+> _ item </%> . click + = new system . event _ handler ( this . config _ click ) ; this . quit <%> <+> _ item </%> . name = STR ; this . quit <%> <+> _ item </%> . size = new system . drawing . size ( NUM , NUM ) ;

var ret = new data _ list { new data _ unit ( state . geolocation , state . unknown ) , new data _ unit ( state . isp , state . unknown ) , } ; <%> <+> string json _ string ; try { json _ string = await new http _ client ( ) . get _ string _ async ( api ) ; } </%>
{ <%> <+> await geolocation _ and _ isp ; </%> append ( data _ list , geolocation _ and _ isp . result ) ; } } } private static void append ( data _ list data _ list , i _ enumerable < data _ unit > extra ) { var data = data _ list . concat ( extra ) ; var data _ line = string . join ( delimiter , data . select ( kv = > kv . value ) . to _ array ( ) ) ;
} polipo _ runner . stop ( ) ; try { var strategy = get _ current _ strategy ( ) ; if ( strategy ! = null ) { strategy . reload _ servers ( ) ; } polipo _ runner . start ( config ) ;
{ local local ; pac _ server pac _ server ; config config ; polipo _ runner polipo _ runner ; public <%> <+> config _ </%> form ( ) { config = config . load ( ) ; initialize _ component ( ) ; notify _ icon . context _ menu = context _ menu ;
{ config = config . load ( ) ; initialize _ component ( ) ; notify _ icon . context _ menu = context _ menu ; enable _ item . checked = config . enabled ; config _ to _ text _ box ( ) ; } private void show _ window ( ) { this . opacity = 1 ;
} else { console . write _ line ( STR ) ; this . close ( ) ; <%> <+> } } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; </%>
{ list < internet _ per _ conn _ option > optionlist = new list < internet _ per _ conn _ option > ( ) ; if ( enable ) { if ( global ) { optionlist . add ( new internet _ per _ conn _ option { dw _ option = ( int ) internet _ per _ conn _ option _ enum . internet _ per _ conn _ flags _ ui , <%> <-> value = { dw _ value = ( int ) internet _ option _ per _ conn _ flags _ ui . proxy _ type _ proxy } </%>
} ) ; optionlist . add ( new internet _ per _ conn _ option { dw _ option = ( int ) internet _ per _ conn _ option _ enum . internet _ per _ conn _ proxy _ server , value = { psz _ value = marshal . string _ to _ h _ global _ <%> <*> ansi -> auto </%> ( proxy _ server ) } } ) ; optionlist . add ( new internet _ per _ conn _ option { dw _ option = ( int ) internet _ per _ conn _ option _ enum . internet _ per _ conn _ proxy _ bypass , value = { psz _ value = marshal . string _ to _ h _ global _ <%> <*> ansi -> auto </%> ( STR ) }
} ) ; optionlist . add ( new internet _ per _ conn _ option { dw _ option = ( int ) internet _ per _ conn _ option _ enum . internet _ per _ conn _ proxy _ bypass , value = { psz _ value = marshal . string _ to _ h _ global _ <%> <*> ansi -> auto </%> ( STR ) } } ) ; } else { optionlist . add ( new internet _ per _ conn _ option
} ) ; } else { optionlist . add ( new internet _ per _ conn _ option { dw _ option = ( int ) internet _ per _ conn _ option _ enum . internet _ per _ conn _ flags _ ui , value = { dw _ value = ( int ) internet _ option _ per _ conn _ flags _ ui . proxy _ type _ auto _ proxy _ url } } ) ; optionlist . add ( new internet _ per _ conn _ option
int _ ptr . zero , internet _ option . internet _ option <%> <+> _ proxy </%> _ settings _ changed , int _ ptr . zero , 0 ) ; <%> <*> native _ methods . internet _ set _ option ( -> if ( ! b _ return ) </%> <%> <+> { logging . error ( STR ) ; } b _ return = native _ methods . internet _ set _ option ( </%> int _ ptr . zero ,
int _ ptr . zero , 0 ) ; <%> <*> native _ methods . internet _ set _ option ( -> if ( ! b _ return ) </%> <%> <+> { logging . error ( STR ) ; } b _ return = native _ methods . internet _ set _ option ( </%> int _ ptr . zero , internet _ option . internet _ option _ refresh , int _ ptr . zero , 0 ) ;
int _ ptr . zero , internet _ option . internet _ option _ refresh , int _ ptr . zero , 0 ) ; <%> <+> if ( ! b _ return ) { logging . error ( STR ) ; } } public static void set _ ie _ proxy ( bool enable , bool global , string proxy _ server , string pac _ url ) { </%>
using system _ globalization ; using system _ io ; <%> <*> using shadowsocks _ properties ; using shadowsocks _ util ; -> using system _ text ; </%> using system _ windows _ forms ; <%> <-> using microsoft _ visual _ basic _ file _ io ; using system _ text ; </%> namespace shadowsocks _ controller {
using system _ windows _ forms ; <%> <-> using microsoft _ visual _ basic _ file _ io ; using system _ text ; </%> namespace shadowsocks _ controller { public static class n { private static readonly string n _ file = STR ; private static dictionary < string , string > strings = new dictionary < string , string > ( ) ; private static void init ( string res , string locale )
namespace shadowsocks _ controller { public static class n { private static readonly string n _ file = STR ; private static dictionary < string , string > strings = new dictionary < string , string > ( ) ; private static void init ( string res , string locale ) { using ( text _ field _ parser csv _ parser = new text _ field _ parser ( new string _ reader ( res ) ) ) {
static sodium ( ) <%> <-> { load _ ss _ crypto _ library ( ) ; load _ ss _ crypto _ library ( ) ; } static void load _ ss _ crypto _ library ( ) </%> { string temp _ path = utils . get _ temp _ path ( ) ; string dll _ path = temp _ path + STR ; try
{ string temp _ path = utils . get _ temp _ path ( ) ; string dll _ path = temp _ path + STR ; try { file _ manager . uncompress _ file ( dll _ path , resources . libsscrypto _ dll ) ; <%> <-> load _ library ( dll _ path ) ; </%> } catch ( io _ exception ) {
} catch ( io _ exception ) { } catch ( exception e ) { console . write _ line ( e . to _ string ( ) ) ; } <%> <-> } static void load _ ss _ crypto _ library ( ) </%>
} dll _ import _ kernel _ dll private static extern int _ ptr load _ library ( string path ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static <%> <*> void -> int </%> crypto _ stream _ salsa _ xor _ ic ( byte [ ] c , byte [ ] m , ulong mlen , byte [ ] n , ulong ic , byte [ ] k ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static <%> <*> void -> int </%> crypto _ stream _ chacha _ xor _ ic ( byte [ ] c , byte [ ] m , ulong mlen , byte [ ] n , ulong ic , byte [ ] k ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int ss _ gen _ crc ( byte [ ] buf , ref int buf _ offset , ref int data _ len , byte [ ] crc _ buf , ref int crc _ idx , int buf _ size ) ;
dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static <%> <*> void -> int </%> crypto _ stream _ chacha _ xor _ ic ( byte [ ] c , byte [ ] m , ulong mlen , byte [ ] n , ulong ic , byte [ ] k ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int ss _ gen _ crc ( byte [ ] buf , ref int buf _ offset , ref int data _ len , byte [ ] crc _ buf , ref int crc _ idx , int buf _ size ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int ss _ onetimeauth ( byte [ ] auth , byte [ ] msg , int msg _ len , byte [ ] iv , int iv _ len , byte [ ] key , int key _ len ) ;
public extern static int ss _ gen _ crc ( byte [ ] buf , ref int buf _ offset , ref int data _ len , byte [ ] crc _ buf , ref int crc _ idx , int buf _ size ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int ss _ onetimeauth ( byte [ ] auth , byte [ ] msg , int msg _ len , byte [ ] iv , int iv _ len , byte [ ] key , int key _ len ) ; } }
} public int end _ send ( i _ async _ result async _ result ) { return remote . end _ send ( async _ result ) ; } public void begin _ receive ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) { remote <%> <-> ? </%> . begin _ receive ( buffer , offset , size , socket _ flags , callback , state ) ; }
} public int end _ receive ( i _ async _ result async _ result ) { return remote . end _ receive ( async _ result ) ; } public void shutdown ( socket _ shutdown how ) { remote <%> <-> ? </%> . shutdown ( how ) ; } public void close ( )
} public void close ( ) { remote <%> <-> ? </%> . dispose ( ) ; } } }
} } }
this . qr _ code _ web _ browser . location = new system . drawing . point ( 0 , 0 ) ; <%> <+> this . qr _ code _ web _ browser . margin = new system . windows . forms . padding ( 0 ) ; </%> this . qr _ code _ web _ browser . minimum _ size = new system . drawing . size ( NUM , NUM ) ; this . qr _ code _ web _ browser . name = STR ; this . qr _ code _ web _ browser . script _ errors _ suppressed = true ; this . qr _ code _ web _ browser . scroll _ bars _ enabled = false ; this . qr _ code _ web _ browser . size = new system . drawing . size ( NUM , NUM ) ; this . qr _ code _ web _ browser . tab _ index = 0 ; <%> <+> this . auto _ size = true ; this . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; </%>
this . controls . add ( this . qr _ code _ web _ browser ) ; this . form _ border _ style = system . windows . forms . form _ border _ style . fixed _ single ; this . maximize _ box = false ; this . name = STR ; this . start _ position = system . windows . forms . form _ start _ position . center _ screen ; this . load + = new system . event _ handler ( this . qr _ code _ form _ load ) ; this . resume _ layout ( false ) ; } private system . windows . forms . web _ browser qr _ code _ web _ browser ; }
private byte [ ] encrypt _ iv ; private byte [ ] decrypt _ iv ; private <%> <*> int -> byte [ ] </%> encrypt _ iv _ offset ; private <%> <*> int -> byte [ ] </%> decrypt _ iv _ offset ; private string method ; private int key _ len ; private int iv _ len ; public polar _ ssl _ encryptor ( string method , string password ) : base ( method , password ) {
private string method ; private int key _ len ; private int iv _ len ; public polar _ ssl _ encryptor ( string method , string password ) : base ( method , password ) { init _ key ( method , password ) ; } private static void rand _ bytes ( byte [ ] buf , int length ) {
} else { <%> <-> realkey = key ; } if ( cipher = = cipher _ aes ) { polar _ ssl . aes _ init ( ctx ) ; polar _ ssl . aes _ setkey _ enc ( ctx , realkey , key _ len * NUM ) ; if ( is _ cipher ) </%>
} } static byte [ ] tempbuf = new byte [ NUM ] ; public override void encrypt ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength ) { if ( encrypt _ ctx = = <%> <*> null -> int _ ptr . zero </%> ) { rand _ bytes ( outbuf , iv _ len ) ; init _ cipher ( ref encrypt _ ctx , outbuf , true ) ; outlength = length + iv _ len ;
{ rand _ bytes ( outbuf , iv _ len ) ; init _ cipher ( ref encrypt _ ctx , outbuf , true ) ; outlength = length + iv _ len ; lock ( tempbuf ) { <%> <-> lock ( encrypt _ ctx ) { </%> if ( disposed ) {
} } else { outlength = length ; <%> <-> lock ( encrypt _ ctx ) { </%> if ( disposed ) { throw new object _ disposed _ exception ( this . to _ string ( ) ) ;
} } } public override void decrypt ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength ) { if ( decrypt _ ctx = = <%> <*> null -> int _ ptr . zero </%> ) { init _ cipher ( ref decrypt _ ctx , buf , false ) ; outlength = length - iv _ len ; lock ( tempbuf )
{ init _ cipher ( ref decrypt _ ctx , buf , false ) ; outlength = length - iv _ len ; lock ( tempbuf ) { buffer . block _ copy ( buf , iv _ len , tempbuf , 0 , length - iv _ len ) ; <%> <-> lock ( decrypt _ ctx ) { </%> if ( disposed ) {
} } } else { outlength = length ; <%> <-> lock ( decrypt _ ctx ) { </%> if ( disposed ) {
} } } private bool disposed ; public override void dispose ( ) { dispose ( true ) ; gc . suppress _ finalize ( this ) ; } ~ polar _ ssl _ encryptor ( )
dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void aes _ free ( <%> <*> byte [ ] -> int _ ptr </%> ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int aes _ setkey _ enc ( <%> <*> byte [ ] -> int _ ptr </%> ctx , byte [ ] key , int keysize ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int aes _ crypt _ cfb ( <%> <*> byte [ ] -> int _ ptr </%> ctx , int mode , int length , <%> <*> ref int -> byte [ ] </%> iv _ off , byte [ ] iv , byte [ ] input , byte [ ] output ) ; public const int ar _ ctx _ size = NUM ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void arc _ init ( <%> <*> byte [ ] -> int _ ptr </%> ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl
dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int aes _ setkey _ enc ( <%> <*> byte [ ] -> int _ ptr </%> ctx , byte [ ] key , int keysize ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int aes _ crypt _ cfb ( <%> <*> byte [ ] -> int _ ptr </%> ctx , int mode , int length , <%> <*> ref int -> byte [ ] </%> iv _ off , byte [ ] iv , byte [ ] input , byte [ ] output ) ; public const int ar _ ctx _ size = NUM ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void arc _ init ( <%> <*> byte [ ] -> int _ ptr </%> ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void arc _ free ( <%> <*> byte [ ] -> int _ ptr </%> ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl
dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int aes _ crypt _ cfb ( <%> <*> byte [ ] -> int _ ptr </%> ctx , int mode , int length , <%> <*> ref int -> byte [ ] </%> iv _ off , byte [ ] iv , byte [ ] input , byte [ ] output ) ; public const int ar _ ctx _ size = NUM ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void arc _ init ( <%> <*> byte [ ] -> int _ ptr </%> ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void arc _ free ( <%> <*> byte [ ] -> int _ ptr </%> ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void arc _ setup ( <%> <*> byte [ ] -> int _ ptr </%> ctx , byte [ ] key , int keysize ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl
public const int ar _ ctx _ size = NUM ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void arc _ init ( <%> <*> byte [ ] -> int _ ptr </%> ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void arc _ free ( <%> <*> byte [ ] -> int _ ptr </%> ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void arc _ setup ( <%> <*> byte [ ] -> int _ ptr </%> ctx , byte [ ] key , int keysize ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int arc _ crypt ( <%> <*> byte [ ] -> int _ ptr </%> ctx , int length , byte [ ] input , byte [ ] output ) ; public const int blowfish _ ctx _ size = NUM ;
dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void arc _ free ( <%> <*> byte [ ] -> int _ ptr </%> ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void arc _ setup ( <%> <*> byte [ ] -> int _ ptr </%> ctx , byte [ ] key , int keysize ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int arc _ crypt ( <%> <*> byte [ ] -> int _ ptr </%> ctx , int length , byte [ ] input , byte [ ] output ) ; public const int blowfish _ ctx _ size = NUM ; public const int blowfish _ encrypt = 1 ; public const int blowfish _ decrypt = 0 ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl
dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void arc _ setup ( <%> <*> byte [ ] -> int _ ptr </%> ctx , byte [ ] key , int keysize ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int arc _ crypt ( <%> <*> byte [ ] -> int _ ptr </%> ctx , int length , byte [ ] input , byte [ ] output ) ; public const int blowfish _ ctx _ size = NUM ; public const int blowfish _ encrypt = 1 ; public const int blowfish _ decrypt = 0 ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void blowfish _ init ( <%> <*> byte [ ] -> int _ ptr </%> ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl
dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int arc _ crypt ( <%> <*> byte [ ] -> int _ ptr </%> ctx , int length , byte [ ] input , byte [ ] output ) ; public const int blowfish _ ctx _ size = NUM ; public const int blowfish _ encrypt = 1 ; public const int blowfish _ decrypt = 0 ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void blowfish _ init ( <%> <*> byte [ ] -> int _ ptr </%> ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void blowfish _ free ( <%> <*> byte [ ] -> int _ ptr </%> ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl
public const int blowfish _ ctx _ size = NUM ; public const int blowfish _ encrypt = 1 ; public const int blowfish _ decrypt = 0 ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void blowfish _ init ( <%> <*> byte [ ] -> int _ ptr </%> ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void blowfish _ free ( <%> <*> byte [ ] -> int _ ptr </%> ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int blowfish _ setkey ( <%> <*> byte [ ] -> int _ ptr </%> ctx , byte [ ] key , int keysize ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl
dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void blowfish _ free ( <%> <*> byte [ ] -> int _ ptr </%> ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int blowfish _ setkey ( <%> <*> byte [ ] -> int _ ptr </%> ctx , byte [ ] key , int keysize ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int blowfish _ crypt _ cfb ( <%> <*> byte [ ] -> int _ ptr </%> ctx , int mode , int length , <%> <*> ref int -> byte [ ] </%> iv _ off , byte [ ] iv , byte [ ] input , byte [ ] output ) ; } }
dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int blowfish _ setkey ( <%> <*> byte [ ] -> int _ ptr </%> ctx , byte [ ] key , int keysize ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int blowfish _ crypt _ cfb ( <%> <*> byte [ ] -> int _ ptr </%> ctx , int mode , int length , <%> <*> ref int -> byte [ ] </%> iv _ off , byte [ ] iv , byte [ ] input , byte [ ] output ) ; } }
dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int blowfish _ crypt _ cfb ( <%> <*> byte [ ] -> int _ ptr </%> ctx , int mode , int length , <%> <*> ref int -> byte [ ] </%> iv _ off , byte [ ] iv , byte [ ] input , byte [ ] output ) ; } }
} }
byte [ ] plain = new byte [ NUM ] ; byte [ ] cipher = new byte [ plain . length + NUM ] ; byte [ ] plain = new byte [ plain . length + NUM ] ; int out _ len = 0 ; int out _ len = 0 ; random . next _ bytes ( plain ) ; encryptor . encrypt ( plain , plain . length , cipher , out out _ len ) ; decryptor . decrypt ( cipher , out _ len , plain , out out _ len ) ; assert . are _ equal ( plain . length , out _ len ) ; <%> <+> for ( int j = 0 ; j < plain . length ; j + + ) </%>
} } catch { encryption _ failed = true ; <%> <+> throw ; </%> } } } }
using shadowsocks _ util _ sockets ; namespace shadowsocks _ controller _ service { class http _ socks : listener . service { <%> <-> private readonly byte _ search . search _ target connect _ search = new byte _ search . search _ target ( encoding . ut . get _ bytes ( STR ) ) ; private readonly int socks _ port ; public http _ socks ( int socks _ port ) { </%>
public override bool handle ( byte [ ] first _ packet , int length , socket socket , object state ) { if ( socket . protocol _ type ! = protocol _ type . tcp ) { return false ; }
{ <%> <*> return value . to _ string ( STR ) ; -> var content _ bytes = encoding . ascii . get _ bytes ( content ) ; </%> <%> <+> using ( var md = system . security . cryptography . m . create ( ) ) { var md _ bytes = md . compute _ hash ( content _ bytes ) ; return bit _ converter . to _ string ( md _ bytes ) . replace ( STR , STR ) ; } ; </%>

{ <%> <+> case STR : case STR : case STR : continue ; default : </%> registry . set _ value ( each , default _ value ) ; <%> <+> continue ; </%> } }
} } notify _ ie ( ) ; } catch ( io _ exception e ) { logging . log _ useful _ exception ( e ) ; } } private static void ie _ auto _ detect _ proxy ( bool set )
public bool ping { get ; set ; } public int choice _ kept _ minutes { get <%> <+> ; set </%> ; } = NUM ; public int data _ collection _ minutes { get <%> <+> ; set </%> ; } = NUM ; public int repeat _ times _ num { get <%> <+> ; set </%> ; } = NUM ; private const string config _ file = STR ; public static statistics _ strategy _ configuration load ( ) { try { var content = file . read _ all _ text ( config _ file ) ;
private const string config _ file = STR ; public static statistics _ strategy _ configuration load ( ) { try { var content = file . read _ all _ text ( config _ file ) ; var configuration = json _ convert . deserialize _ object < statistics _ strategy _ configuration > ( content ) ; return configuration ; } catch ( file _ not _ found _ exception )
using system _ linq ; using system _ windows _ forms ; <%> <-> using system _ windows _ forms _ data _ visualization _ charting ; </%> using shadowsocks _ controller ; using shadowsocks _ model ; namespace shadowsocks _ view { <%> <-> using statistics = dictionary < string , list < statistics _ record > > ; </%> public partial class statistics _ strategy _ configuration _ form : form {
using shadowsocks _ controller ; using shadowsocks _ model ; namespace shadowsocks _ view { <%> <-> using statistics = dictionary < string , list < statistics _ record > > ; </%> public partial class statistics _ strategy _ configuration _ form : form { private readonly shadowsocks _ controller controller ; private statistics _ strategy _ configuration configuration ; private readonly data _ table data _ table = new data _ table ( ) ;
public partial class statistics _ strategy _ configuration _ form : form { private readonly shadowsocks _ controller controller ; private statistics _ strategy _ configuration configuration ; private readonly data _ table data _ table = new data _ table ( ) ; private list < string > servers ; public statistics _ strategy _ configuration _ form ( shadowsocks _ controller controller ) { if ( controller = = null ) return ; initialize _ component ( ) ;
this . table _ layout _ panel . controls . add ( this . timeout _ label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . timeout _ text _ box , 1 , NUM ) ; this . table _ layout _ panel . location = new system . drawing . point ( NUM , NUM ) ; this . table _ layout _ panel . margin = new system . windows . forms . padding ( 0 ) ; this . table _ layout _ panel . name = STR ; this . table _ layout _ panel . padding = new system . windows . forms . padding ( NUM ) ; this . table _ layout _ panel . row _ count = NUM ; <%> <-> this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; </%> this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ;
this . table _ layout _ panel . tab _ index = 0 ; this . remarks _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . remarks _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . remarks _ text _ box . max _ length = NUM ; this . remarks _ text _ box . name = STR ; this . remarks _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . remarks _ text _ box . tab _ index = NUM ; this . remarks _ text _ box . word _ wrap = false ; this . remarks _ label . anchor = system . windows . forms . anchor _ styles . right ; this . remarks _ label . auto _ size = true ;
this . encryption _ select . location = new system . drawing . point ( NUM , NUM ) ; this . encryption _ select . name = STR ; this . encryption _ select . size = new system . drawing . size ( NUM , NUM ) ; this . encryption _ select . tab _ index = NUM ; this . <%> <*> one -> timeout </%> _ <%> <*> time _ auth -> label . anchor = system . windows . forms </%> . <%> <*> auto -> anchor </%> _ <%> <*> size = true -> styles . right </%> ; this . <%> <*> one -> timeout </%> _ <%> <*> time _ auth . location -> label . auto _ size </%> = <%> <*> new system . drawing . point ( NUM , NUM ) ; -> true ; </%> this . <%> <*> one _ time -> timeout </%> _ <%> <*> auth -> label </%> . <%> <*> name -> location </%> = <%> <*> STR ; -> new system . drawing . point ( NUM , NUM ) ; </%> this . <%> <*> one _ time -> timeout </%> _ <%> <*> auth -> label </%> . <%> <*> size -> name </%> = <%> <*> new system . drawing . size ( NUM , NUM ) ; -> STR ; </%> this . <%> <*> one -> timeout </%> _ <%> <*> time _ auth . tab -> label . right _ to </%> _ <%> <*> index -> left </%> = <%> <*> NUM ; -> system . windows . forms . right _ to _ left . no ; </%> this . <%> <*> one _ time -> timeout </%> _ <%> <*> auth -> label </%> . <%> <*> text -> size </%> = <%> <*> STR ; -> new system . drawing . size ( NUM , NUM ) ; </%>
this . panel . anchor = system . windows . forms . anchor _ styles . top ; this . panel . auto _ size = true ; this . panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . panel . location = new system . drawing . point ( NUM , NUM ) ; this . panel . name = STR ; this . panel . size = new system . drawing . size ( 0 , 0 ) ; this . panel . tab _ index = 1 ; this . ok _ button . dialog _ result = system . windows . forms . dialog _ result . ok ; this . ok _ button . dock = system . windows . forms . dock _ style . right ; this . ok _ button . location = new system . drawing . point ( NUM , NUM ) ;
try { local . start ( ) ; pac _ server = new pac _ server ( ) ; pac _ server . pac _ file _ changed + = pac _ server _ pac _ file _ changed ; pac _ server . start ( <%> <+> config </%> ) ; } catch ( exception e ) { console . write _ line ( e . message ) ;
} catch ( exception e ) { console . write _ line ( e . message ) ; } update _ system _ proxy ( ) ; } public void save _ config ( configuration new _ config ) { configuration . save ( new _ config ) ;
socket listener ; public local ( <%> <*> server -> configuration </%> config ) { this . <%> <*> config -> server </%> = config <%> <*> ; -> . get _ current _ server ( ) ; </%> <%> <+> share _ over _ lan = config . share _ over _ lan ; </%> } public void start ( ) { try {
} public void start ( ) { try { <%> <*> listener = new socket ( address _ family . inter _ network , socket _ type . stream , protocol _ type . tcp ) ; ip _ end _ point local _ end _ point = new ip _ end _ point ( 0 , config . local _ port ) ; -> listener = new socket ( address _ family . inter _ network , socket _ type . stream , protocol _ type . tcp ) ; </%> <%> <+> listener . set _ socket _ option ( socket _ option _ level . socket , socket _ option _ name . reuse _ address , true ) ; </%>
listener . bind ( local _ end _ point ) ; listener . listen ( NUM ) ; console . write _ line ( STR ) ; listener . begin _ accept ( new async _ callback ( accept _ callback ) , listener ) ; } catch ( socket _ exception ) { listener . close ( ) ;
{ <%> <+> try { listener = new socket ( address _ family . inter _ network , socket _ type . stream , protocol _ type . tcp ) ; listener . set _ socket _ option ( socket _ option _ level . socket , socket _ option _ name . reuse _ address , true ) ; ip _ end _ point local _ end _ point = null ; if ( configuration . share _ over _ lan ) { local _ end _ point = new ip _ end _ point ( ip _ address . any , port ) ; } </%>
} public string touch _ pac _ file ( ) { if ( file . exists ( pac _ file ) ) { return pac _ file ; } else { file _ manager . uncompress _ file ( pac _ file , resources . proxy _ pac _ txt ) ;
conn . begin _ receive ( new byte [ NUM ] , 0 , NUM , 0 , new async _ callback ( receive _ callback ) , conn ) ; } catch ( exception e ) { console . write _ line ( e . message ) ; } } private string get _ pac _ content ( ) {
} private void receive _ callback ( i _ async _ result ar ) { socket conn = ( socket ) ar . async _ state ; try { int bytes _ read = conn . end _ receive ( ar ) ; string pac = get _ pac _ content ( ) ; <%> <*> string proxy = STR ; -> ip _ end _ point local _ end _ point = ( ip _ end _ point ) conn . local _ end _ point ; </%>
pac = pac . replace ( STR , proxy ) ; if ( bytes _ read > 0 ) { string text = string . format ( @ STR server : shadowsocks content - type : application / x - ns - proxy - autoconfig content - length : { 0 } connection : close STR byte [ ] response = system . text . encoding . ut . get _ bytes ( text ) ;
this . table _ layout _ panel . suspend _ layout ( ) ; this . panel . suspend _ layout ( ) ; this . panel . suspend _ layout ( ) ; this . server _ group _ box . suspend _ layout ( ) ; this . suspend _ layout ( ) ; this . table _ layout _ panel . auto _ size = true ; this . table _ layout _ panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . table _ layout _ panel . column _ count = 2 ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ;
this . servers _ item . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . seperator _ item , this . config _ item } ) ; this . servers _ item . text = STR ; this . seperator _ item . index = 0 ; this . seperator _ item . text = STR ; this . config _ item . index = 1 ; this . config _ item . text = STR ; this . config _ item . click + = new system . event _ handler ( this . config _ click ) ; this . menu _ item . index = <%> <*> 2 -> NUM </%> ;
this . menu _ item . text = STR ; this . edit _ pac _ file _ item . index = NUM ; this . edit _ pac _ file _ item . text = STR ; this . edit _ pac _ file _ item . click + = new system . event _ handler ( this . edit _ pac _ file _ item _ click ) ; this . qr _ code _ item . index = NUM ; this . qr _ code _ item . text = STR ; this . qr _ code _ item . click + = new system . event _ handler ( this . qr _ code _ item _ click ) ; <%> <+> this . show _ log _ item . index = NUM ; this . show _ log _ item . text = STR ; this . show _ log _ item . click + = new system . event _ handler ( this . show _ log _ item _ click ) ; </%>
{ <%> <+> server server = configuration . get _ current _ server ( ) ; </%> if ( process = = null ) { process [ ] existing _ polipo = process . get _ processes _ by _ name ( STR ) ; foreach ( process p in existing _ polipo ) { try { p . kill ( ) ;
{ this . tcprelay = tcprelay ; <%> <+> this . config = config ; </%> } public void create _ remote ( ) { server server = controller . get _ a _ server ( i _ strategy _ caller _ type . tcp , ( ip _ end _ point ) connection . remote _ end _ point ) ; if ( server = = null | | server . server = = STR ) { throw new argument _ exception ( STR ) ;
proxy _ timer proxy _ timer = new proxy _ timer ( NUM ) ; proxy _ timer . auto _ reset = false ; proxy _ timer . elapsed + = proxy _ connect _ timer _ elapsed ; proxy _ timer . enabled = true ; proxy _ timer . dest _ end _ point = <%> <*> remote -> dest </%> _ ep ; proxy _ timer . server = server ; proxy _ connected = false ; remote . begin _ connect _ proxy ( <%> <*> remote -> proxy </%> _ ep , new async _ callback ( proxy _ connect _ callback ) , proxy _ timer ) ; } catch ( exception e )
proxy _ timer . server = server ; proxy _ connected = false ; remote . begin _ connect _ proxy ( <%> <*> remote -> proxy </%> _ ep , new async _ callback ( proxy _ connect _ callback ) , proxy _ timer ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; } }
} catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; } } private void proxy _ connect _ timer _ elapsed ( object sender , elapsed _ event _ args e ) { if ( proxy _ connected | | dest _ connected )
{ <%> <-> if ( ! int . try _ parse ( locs [ 1 ] , out target _ port ) ) { </%> throw new exception ( STR + line ) ; <%> <-> } } else { target _ port = NUM ; </%> }
} } } } else { if ( line . is _ null _ or _ empty ( ) ) { return true ; }
{ <%> <-> if ( ! int . try _ parse ( locs [ 1 ] , out target _ port ) ) { </%> throw new exception ( STR + line ) ; <%> <-> } } else { target _ port = NUM ; </%> }
} } } } request _ line _ count + + ; return false ; } private void on _ finish ( byte [ ] last _ bytes , int index , int length , object state ) { if ( closed )
public void encrypt ( byte [ ] table , byte [ ] data , int length ) { encrypt _ output ( <%> <-> enc _ index , </%> enc _ <%> <*> index -> ctx </%> , table , data , length ) ; } public void decrypt ( byte [ ] table , byte [ ] data , int length ) { encrypt _ output ( <%> <-> dec _ index , </%> dec _ <%> <*> index -> ctx </%> , table , data , length ) ; } public byte [ ] encrypt _ initalize ( byte [ ] key ) {
} public void decrypt ( byte [ ] table , byte [ ] data , int length ) { encrypt _ output ( <%> <-> dec _ index , </%> dec _ <%> <*> index -> ctx </%> , table , data , length ) ; } public byte [ ] encrypt _ initalize ( byte [ ] key ) { byte [ ] s = new byte [ NUM ] ; for ( int i = 0 ; i < NUM ; i + + ) {
} public byte [ ] encrypt _ initalize ( byte [ ] key ) { byte [ ] s = new byte [ NUM ] ; for ( int i = 0 ; i < NUM ; i + + ) { s [ i ] = ( byte ) i ; } for ( int i = 0 , j = 0 ; i < NUM ; i + + ) {
{ for ( int n = 0 ; n < length ; n + + ) { byte b = data [ n ] ; <%> <+> ctx . </%> index = ( <%> <+> ctx . </%> index + 1 ) & NUM ; <%> <+> ctx . </%> index = ( <%> <+> ctx . </%> index + s [ <%> <+> ctx . </%> index ] ) & NUM ; swap ( s , <%> <+> ctx . </%> index , <%> <+> ctx . </%> index ) ; data [ n ] = ( byte ) ( b ^ s [ ( s [ <%> <+> ctx . </%> index ] + s [ <%> <+> ctx . </%> index ] ) & NUM ] ) ; } }
} } private static void swap ( byte [ ] s , int i , int j ) { byte c = s [ i ] ; s [ i ] = s [ j ] ; s [ j ] = c ; } } }
public static string get _ temp _ path ( ) { if ( temp _ path = = null ) { <%> <-> if ( is _ portable _ mode ( ) ) </%> try { directory . create _ directory ( path . combine ( application . startup _ path , STR ) ) ; <%> <+> temp _ path = path . combine ( application . startup _ path , STR ) ; </%> }
