{ class auto _ startup { public static bool set ( bool enabled ) { try { string path = application . executable _ path ;
public static bool set ( bool enabled ) { try { string path = application . executable _ path ; registry _ key run _ key = microsoft . win . registry . current _ user . open _ sub _ key ( STR , true ) ; if ( enabled ) {
try { string path = application . executable _ path ; registry _ key run _ key = microsoft . win . registry . current _ user . open _ sub _ key ( STR , true ) ; if ( enabled ) { run _ key . set _ value ( STR , path ) ; } else {
string path = application . executable _ path ; registry _ key run _ key = microsoft . win . registry . current _ user . open _ sub _ key ( STR , true ) ; if ( enabled ) { run _ key . set _ value ( STR , path ) ; } else { run _ key . delete _ value ( STR ) ; }
} public static bool check ( ) { try { string path = application . executable _ path ;
} public static bool check ( ) { try { string path = application . executable _ path ; registry _ key run _ key = microsoft . win . registry . current _ user . open _ sub _ key ( STR ) ; string [ ] run _ list = run _ key . get _ value _ names ( ) ;
{ try { string path = application . executable _ path ; registry _ key run _ key = microsoft . win . registry . current _ user . open _ sub _ key ( STR ) ; string [ ] run _ list = run _ key . get _ value _ names ( ) ; run _ key . close ( ) ; foreach ( string item in run _ list ) {
if ( disposed ) { throw new object _ disposed _ exception ( get _ type ( ) . full _ name ) ; } lock ( start _ process _ lock ) { if ( started & & ! plugin _ process . has _ exited ) { return false ; }
if ( started & & ! plugin _ process . has _ exited ) { return false ; } if ( ! file . exists ( plugin _ process . start _ info . file _ name ) ) { throw new file _ not _ found _ exception ( n . get _ string ( STR ) , plugin _ process . start _ info . file _ name ) ; } var local _ port = get _ next _ free _ tcp _ port ( ) ; local _ end _ point = new ip _ end _ point ( ip _ address . loopback , local _ port ) ; plugin _ process . start _ info . environment [ STR ] = local _ end _ point . address . to _ string ( ) ; plugin _ process . start _ info . environment [ STR ] = local _ end _ point . port . to _ string ( ) ; plugin _ process . start _ info . arguments = expand _ environment _ variables ( plugin _ process . start _ info . arguments , plugin _ process . start _ info . environment _ variables ) ;

using system ; using system _ diagnostics ; using system _ io ; using system _ text ; using system _ threading ;
{ if ( e . data = = null ) { error _ wait _ handle . set ( ) ; } else { error . append _ line ( e . data ) ; } } ;
process . start ( ) ; process . begin _ error _ read _ line ( ) ; process . begin _ output _ read _ line ( ) ; process . wait _ for _ exit ( ) ; var stderr = error . to _ string ( ) ; var stdout = output . to _ string ( ) ; var exit _ code = process . exit _ code ; if ( exit _ code ! = ( int ) ret _ errors . ret _ no _ error ) {
var stdout = output . to _ string ( ) ; var exit _ code = process . exit _ code ; if ( exit _ code ! = ( int ) ret _ errors . ret _ no _ error ) { throw new proxy _ exception ( stderr ) ; } if ( arguments = = STR ) { if ( stdout . is _ null _ or _ white _ space ( ) | | stdout . is _ null _ or _ empty ( ) ) {
bitmap icon _ copy = new bitmap ( origin _ icon ) ; for ( int x = 0 ; x < icon _ copy . width ; x + + ) { for ( int y = 0 ; y < icon _ copy . height ; y + + ) { color color = origin _ icon . get _ pixel ( x , y ) ; if ( color . a ! = 0 ) { if ( ! enabled ) {
this . table _ layout _ panel . controls . add ( this . ip _ text _ box , 1 , 0 ) ; this . table _ layout _ panel . controls . add ( this . server _ port _ text _ box , 1 , 1 ) ; this . table _ layout _ panel . controls . add ( this . password _ text _ box , 1 , 2 ) ; this . table _ layout _ panel . controls . add ( this . encryption _ label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . encryption _ select , 1 , NUM ) ; this . table _ layout _ panel . controls . add ( this . timeout _ label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . timeout _ text _ box , 1 , NUM ) ; this . table _ layout _ panel . controls . add ( this . plugin _ label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . plugin _ options _ text _ box , 1 , NUM ) ; this . table _ layout _ panel . controls . add ( this . show _ passwd _ check _ box , 1 , NUM ) ;
this . table _ layout _ panel . controls . add ( this . plugin _ options _ text _ box , 1 , NUM ) ; this . table _ layout _ panel . controls . add ( this . show _ passwd _ check _ box , 1 , NUM ) ; this . table _ layout _ panel . controls . add ( this . plugin _ arguments _ text _ box , 1 , NUM ) ; this . table _ layout _ panel . controls . add ( this . plugin _ arguments _ label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . remarks _ label , 0 , NUM ) ; this . table _ layout _ panel . location = new system . drawing . point ( NUM , NUM ) ; this . table _ layout _ panel . margin = new system . windows . forms . padding ( 0 ) ; this . table _ layout _ panel . name = STR ; this . table _ layout _ panel . padding = new system . windows . forms . padding ( NUM ) ;
this . context _ menu = new system . windows . forms . context _ menu ( ) ; this . enable _ item = new system . windows . forms . menu _ item ( ) ; this . config _ item = new system . windows . forms . menu _ item ( ) ; this . edit _ pac _ file _ item = new system . windows . forms . menu _ item ( ) ; this . about _ item = new system . windows . forms . menu _ item ( ) ; this . menu _ item = new system . windows . forms . menu _ item ( ) ; this . quit _ item = new system . windows . forms . menu _ item ( ) ; this . panel = new system . windows . forms . panel ( ) ; this . delete _ button = new system . windows . forms . button ( ) ; this . add _ button = new system . windows . forms . button ( ) ;
try {
public event error _ event _ handler errored ; public shadowsocks _ controller ( ) { config = configuration . load ( ) ; statistics _ configuration = statistics _ strategy _ configuration . load ( ) ; strategy _ manager = new strategy _ manager ( this ) ; plugins _ by _ server = new concurrent _ dictionary < server , sip _ plugin > ( ) ; start _ releasing _ memory ( ) ; start _ traffic _ statistics ( NUM ) ; }
config = configuration . load ( ) ; statistics _ configuration = statistics _ strategy _ configuration . load ( ) ; strategy _ manager = new strategy _ manager ( this ) ; plugins _ by _ server = new concurrent _ dictionary < server , sip _ plugin > ( ) ; start _ releasing _ memory ( ) ; start _ traffic _ statistics ( NUM ) ; } public void start ( ) { reload ( ) ;
{ console . write _ line ( e . to _ string ( ) ) ; } load _ library ( dll _ path ) ; } dll _ import _ kernel _ dll private static extern int _ ptr load _ library ( string path ) ; public const int m _ ctx _ size = NUM ; public static byte [ ] m ( byte [ ] input ) {
} load _ library ( dll _ path ) ; } dll _ import _ kernel _ dll private static extern int _ ptr load _ library ( string path ) ; public const int m _ ctx _ size = NUM ; public static byte [ ] m ( byte [ ] input ) { int _ ptr ctx = marshal . alloc _ h _ global ( m _ ctx _ size ) ; byte [ ] output = new byte [ NUM ] ;
private static extern int _ ptr load _ library ( string path ) ; public const int m _ ctx _ size = NUM ; public static byte [ ] m ( byte [ ] input ) { int _ ptr ctx = marshal . alloc _ h _ global ( m _ ctx _ size ) ; byte [ ] output = new byte [ NUM ] ; mbed _ tls . md _ init ( ctx ) ; mbed _ tls . md _ starts ( ctx ) ; mbed _ tls . md _ update ( ctx , input , ( uint ) input . length ) ; mbed _ tls . md _ finish ( ctx , output ) ; mbed _ tls . md _ free ( ctx ) ; marshal . free _ h _ global ( ctx ) ; return output ; } dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl

using system ; using system _ collections ; using system _ globalization ; using system _ io ; using system _ net ; using system _ net _ sockets ; using system _ text ;

namespace shadowsocks _ view { public partial class log _ form : form { long last _ offset ; string filename ; timer timer ; const int back _ offset = NUM ;
string filename ; timer timer ; const int back _ offset = NUM ; model . configuration config ; public log _ form ( string filename ) { this . filename = filename ; initialize _ component ( ) ; this . icon = icon . from _ handle ( resources . ssw . get _ hicon ( ) ) ;
} private void read _ all ( i _ async _ result ar ) { if ( closed ) return ; try { if ( ar . async _ state ! = null ) { connection . end _ send ( ar ) ; logging . debug ( remote , recv _ size , STR ) ;
connection . end _ send ( ar ) ; logging . debug ( remote , recv _ size , STR ) ; connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , 0 , new async _ callback ( read _ all ) , null ) ; } else { int bytes _ read = connection . end _ receive ( ar ) ; if ( bytes _ read > 0 ) { logging . debug ( remote , recv _ size , STR ) ;
this . edit _ pac _ file _ item , this . menu _ item , this . qr _ code _ item , this . show _ log _ item , this . about _ item , this . menu _ item , this . quit _ item } ) ; this . enable _ item . index = 0 ; this . enable _ item . text = STR ; this . enable _ item . click + = new system . event _ handler ( this . enable _ item _ click ) ;
this . servers _ item . index = 1 ; this . servers _ item . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . seperator _ item , this . config _ item } ) ; this . servers _ item . text = STR ; this . seperator _ item . index = 0 ; this . seperator _ item . text = STR ; this . config _ item . index = 1 ; this . config _ item . text = STR ; this . config _ item . click + = new system . event _ handler ( this . config _ click ) ;
dll _ import _ wininet _ dll public static extern bool internet _ set _ option ( int _ ptr h _ internet , int dw _ option , int _ ptr lp _ buffer , int dw _ buffer _ length ) ; public const int internet _ option _ settings _ changed = NUM ; public const int internet _ option _ refresh = NUM ; static bool settings _ return , refresh _ return ; public static void notify _ ie ( ) { settings _ return = internet _ set _ option ( int _ ptr . zero , internet _ option _ settings _ changed , int _ ptr . zero , 0 ) ; refresh _ return = internet _ set _ option ( int _ ptr . zero , internet _ option _ refresh , int _ ptr . zero , 0 ) ; }
settings _ return = internet _ set _ option ( int _ ptr . zero , internet _ option _ settings _ changed , int _ ptr . zero , 0 ) ; refresh _ return = internet _ set _ option ( int _ ptr . zero , internet _ option _ refresh , int _ ptr . zero , 0 ) ; } public static void enable ( ) { try { registry _ key registry = registry . current _ user . open _ sub _ key ( STR , true ) ;
using system _ text ; namespace shadowsocks _ csharp { class system _ proxy { dll _ import _ wininet _ dll public static extern bool internet _ set _ option ( int _ ptr h _ internet , int dw _ option , int _ ptr lp _ buffer , int dw _ buffer _ length ) ; public const int internet _ option _ settings _ changed = NUM ; public const int internet _ option _ refresh = NUM ; static bool settings _ return , refresh _ return ;
public const int internet _ option _ refresh = NUM ; static bool settings _ return , refresh _ return ; public static void update _ ie ( ) { settings _ return = internet _ set _ option ( int _ ptr . zero , internet _ option _ settings _ changed , int _ ptr . zero , 0 ) ; refresh _ return = internet _ set _ option ( int _ ptr . zero , internet _ option _ refresh , int _ ptr . zero , 0 ) ; } public static void enable ( ) { registry _ key registry = registry . current _ user . open _ sub _ key ( STR , true ) ;
registry . set _ value ( STR , 1 ) ; registry . set _ value ( STR , STR ) ; system _ proxy . update _ ie ( ) ; } public static void disable ( ) { registry _ key registry = registry . current _ user . open _ sub _ key ( STR , true ) ; registry . set _ value ( STR , 0 ) ; registry . set _ value ( STR , STR ) ;
using system ; using system _ collections _ generic ; using system _ text ;
using system _ text ; using system _ text _ regular _ expressions ; using system _ web ; using shadowsocks _ controller ; namespace shadowsocks _ model { serializable public class server {
server _ port = NUM ; method = STR ; password = STR ; remarks = STR ; timeout = default _ server _ timeout _ sec ; } public static list < server > get _ servers ( string ss _ url ) {
password = STR ; remarks = STR ; timeout = default _ server _ timeout _ sec ; } public static list < server > get _ servers ( string ss _ url ) { var matches = url _ finder . matches ( ss _ url ) ; if ( matches . count < = 0 ) return null ; list < server > servers = new list < server > ( ) ;
password = STR ; remarks = STR ; timeout = default _ server _ timeout _ sec ; } public static list < server > get _ servers ( string ss _ url ) { var matches = url _ finder . matches ( ss _ url ) ; if ( matches . count < = 0 ) return null ; list < server > servers = new list < server > ( ) ; foreach ( match match in matches ) {
timeout = default _ server _ timeout _ sec ; } public static list < server > get _ servers ( string ss _ url ) { var matches = url _ finder . matches ( ss _ url ) ; if ( matches . count < = 0 ) return null ; list < server > servers = new list < server > ( ) ; foreach ( match match in matches ) { server tmp = new server ( ) ; var base = match . groups [ STR ] . value ; var tag = match . groups [ STR ] . value ; if ( ! tag . is _ null _ or _ empty ( ) ) {
public static list < server > get _ servers ( string ss _ url ) { var matches = url _ finder . matches ( ss _ url ) ; if ( matches . count < = 0 ) return null ; list < server > servers = new list < server > ( ) ; foreach ( match match in matches ) { server tmp = new server ( ) ; var base = match . groups [ STR ] . value ; var tag = match . groups [ STR ] . value ; if ( ! tag . is _ null _ or _ empty ( ) ) { tmp . remarks = http _ utility . url _ decode ( tag , encoding . ut ) ; }
list < server > servers = new list < server > ( ) ; foreach ( match match in matches ) { server tmp = new server ( ) ; var base = match . groups [ STR ] . value ; var tag = match . groups [ STR ] . value ; if ( ! tag . is _ null _ or _ empty ( ) ) { tmp . remarks = http _ utility . url _ decode ( tag , encoding . ut ) ; } match details = details _ parser . match ( encoding . ut . get _ string ( convert . from _ base _ string ( base . pad _ right ( base . length + ( NUM - base . length % NUM ) % NUM , '=' ) ) ) ) ; if ( ! details . success ) continue ;
this . table _ layout _ panel . suspend _ layout ( ) ; this . table _ layout _ panel . suspend _ layout ( ) ; this . table _ layout _ panel . suspend _ layout ( ) ; this . table _ layout _ panel . suspend _ layout ( ) ; this . suspend _ layout ( ) ; this . table _ layout _ panel . auto _ size = true ; this . table _ layout _ panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . table _ layout _ panel . column _ count = 2 ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ;
this . table _ layout _ panel . controls . add ( this . remarks _ text _ box , 1 , NUM ) ; this . table _ layout _ panel . controls . add ( this . remarks _ label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . ip _ label , 0 , 0 ) ; this . table _ layout _ panel . controls . add ( this . server _ port _ label , 0 , 1 ) ; this . table _ layout _ panel . controls . add ( this . password _ label , 0 , 2 ) ; this . table _ layout _ panel . controls . add ( this . ip _ text _ box , 1 , 0 ) ; this . table _ layout _ panel . controls . add ( this . server _ port _ text _ box , 1 , 1 ) ; this . table _ layout _ panel . controls . add ( this . password _ text _ box , 1 , 2 ) ; this . table _ layout _ panel . controls . add ( this . encryption _ label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . encryption _ select , 1 , NUM ) ;
this . table _ layout _ panel . controls . add ( this . password _ text _ box , 1 , 2 ) ; this . table _ layout _ panel . controls . add ( this . encryption _ label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . encryption _ select , 1 , NUM ) ; this . table _ layout _ panel . controls . add ( this . timeout _ label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . timeout _ text _ box , 1 , NUM ) ; this . table _ layout _ panel . location = new system . drawing . point ( NUM , NUM ) ; this . table _ layout _ panel . margin = new system . windows . forms . padding ( 0 ) ; this . table _ layout _ panel . name = STR ; this . table _ layout _ panel . padding = new system . windows . forms . padding ( NUM ) ;
public static event error _ event _ handler error ; private static readonly string database _ path = utils . get _ temp _ path ( STR ) ; private static readonly string geosite _ url = STR ; public static readonly dictionary < string , i _ list < domain _ object > > geosites = new dictionary < string , i _ list < domain _ object > > ( ) ; static geosite _ updater ( ) {
public static readonly dictionary < string , i _ list < domain _ object > > geosites = new dictionary < string , i _ list < domain _ object > > ( ) ; static geosite _ updater ( ) { if ( ! file . exists ( database _ path ) ) { file . write _ all _ bytes ( database _ path , resources . dlc _ dat ) ; } load _ geosite _ list ( ) ; }
foreach ( var item in list . entries ) { geosites [ item . group _ name . to _ lower ( ) ] = item . domains ; } } public static void reset _ event ( ) { update _ completed = null ; error = null ; }
string group = config . geosite _ group ; bool blacklist = config . geosite _ blacklist _ mode ; if ( ! string . is _ null _ or _ white _ space ( config . geosite _ url ) ) { logger . info ( STR ) ; geosite _ url = config . geosite _ url ; } logger . info ( $ STR ) ;
if ( ! string . is _ null _ or _ white _ space ( config . geosite _ url ) ) { logger . info ( STR ) ; geosite _ url = config . geosite _ url ; } logger . info ( $ STR ) ; web _ client http = new web _ client ( ) ; if ( config . enabled ) {
web _ client http = new web _ client ( ) ; if ( config . enabled ) { http . proxy = new web _ proxy ( config . is _ i _ pv _ enabled ? $ STR : ip _ address . loopback . to _ string ( ) , config . local _ port ) ; }
using system _ drawing ; using system _ text ; using system _ windows _ forms ; using system _ diagnostics ; using shadowsocks _ controller ; using shadowsocks _ model ; namespace shadowsocks _ view { public partial class config _ form : form {
shadowsocks _ controller controller ; public config _ form ( shadowsocks _ controller controller ) { initialize _ component ( ) ; notify _ icon . context _ menu = context _ menu ; this . controller = controller ; controller . enable _ status _ changed + = controller _ enable _ status _ changed ; controller . config _ changed + = controller _ config _ changed ; controller . pac _ file _ ready _ to _ open + = controller _ pac _ file _ ready _ to _ open ;
initialize _ component ( ) ; notify _ icon . context _ menu = context _ menu ; this . controller = controller ; controller . enable _ status _ changed + = controller _ enable _ status _ changed ; controller . config _ changed + = controller _ config _ changed ; controller . pac _ file _ ready _ to _ open + = controller _ pac _ file _ ready _ to _ open ; update _ ui ( ) ; } private void controller _ config _ changed ( object sender , event _ args e ) {
controller . config _ changed + = controller _ config _ changed ; controller . pac _ file _ ready _ to _ open + = controller _ pac _ file _ ready _ to _ open ; update _ ui ( ) ; } private void controller _ config _ changed ( object sender , event _ args e ) { update _ ui ( ) ; } private void controller _ enable _ status _ changed ( object sender , event _ args e ) {
void controller _ pac _ file _ ready _ to _ open ( object sender , shadowsocks _ controller . path _ event _ args e ) { string argument = STR + e . path ; system . diagnostics . process . start ( STR , argument ) ; } private void show _ window ( ) { this . opacity = 1 ; this . show ( ) ; }
string argument = STR + e . path ; system . diagnostics . process . start ( STR , argument ) ; } private void show _ window ( ) { this . opacity = 1 ; this . show ( ) ; } private void update _ ui ( ) {
} private void update _ ui ( ) { server server = controller . get _ current _ server ( ) ; ip _ text _ box . text = server . server ; server _ port _ text _ box . text = server . server _ port . to _ string ( ) ; password _ text _ box . text = server . password ; proxy _ port _ text _ box . text = server . local _ port . to _ string ( ) ; encryption _ select . text = server . method = = null ? STR : server . method ;
{ server server = controller . get _ current _ server ( ) ; ip _ text _ box . text = server . server ; server _ port _ text _ box . text = server . server _ port . to _ string ( ) ; password _ text _ box . text = server . password ; proxy _ port _ text _ box . text = server . local _ port . to _ string ( ) ; encryption _ select . text = server . method = = null ? STR : server . method ; enable _ item . checked = controller . get _ configuration ( ) . enabled ; }
private void config _ click ( object sender , event _ args e ) { show _ window ( ) ; } private void quit _ click ( object sender , event _ args e ) { this . close ( ) ; } private void ok _ button _ click ( object sender , event _ args e ) {
message _ box . show ( STR ) ; } catch ( exception ex ) { message _ box . show ( ex . message ) ; } } private void cancel _ button _ click ( object sender , event _ args e ) { this . hide ( ) ;
{ components . dispose ( ) ; } base . dispose ( disposing ) ; } private void initialize _ component ( ) { this . components = new system . component _ model . container ( ) ; system . component _ model . component _ resource _ manager resources = new system . component _ model . component _ resource _ manager ( typeof ( config _ form ) ) ; this . table _ layout _ panel = new system . windows . forms . table _ layout _ panel ( ) ;
base . dispose ( disposing ) ; } private void initialize _ component ( ) { this . components = new system . component _ model . container ( ) ; system . component _ model . component _ resource _ manager resources = new system . component _ model . component _ resource _ manager ( typeof ( config _ form ) ) ; this . table _ layout _ panel = new system . windows . forms . table _ layout _ panel ( ) ; this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ;
{ this . components = new system . component _ model . container ( ) ; system . component _ model . component _ resource _ manager resources = new system . component _ model . component _ resource _ manager ( typeof ( config _ form ) ) ; this . table _ layout _ panel = new system . windows . forms . table _ layout _ panel ( ) ; this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ; this . encryption _ select = new system . windows . forms . combo _ box ( ) ; this . label = new system . windows . forms . label ( ) ;
this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ; this . encryption _ select = new system . windows . forms . combo _ box ( ) ; this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ; this . ip _ text _ box = new system . windows . forms . text _ box ( ) ; this . server _ port _ text _ box = new system . windows . forms . text _ box ( ) ; this . password _ text _ box = new system . windows . forms . text _ box ( ) ;
this . context _ menu = new system . windows . forms . context _ menu ( ) ; this . enable _ item = new system . windows . forms . menu _ item ( ) ; this . config _ item = new system . windows . forms . menu _ item ( ) ; this . edit _ pac _ file _ item = new system . windows . forms . menu _ item ( ) ; this . about _ item = new system . windows . forms . menu _ item ( ) ; this . menu _ item = new system . windows . forms . menu _ item ( ) ; this . quit _ item = new system . windows . forms . menu _ item ( ) ; this . panel = new system . windows . forms . panel ( ) ; this . add _ button = new system . windows . forms . button ( ) ;
this . label . anchor = system . windows . forms . anchor _ styles . right ; this . label . auto _ size = true ; this . label . location = new system . drawing . point ( NUM , NUM ) ; this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ; this . label . tab _ index = NUM ; this . label . text = STR ;
this . add _ button . location = new system . drawing . point ( NUM , NUM ) ; this . add _ button . name = STR ; this . add _ button . size = new system . drawing . size ( NUM , NUM ) ; this . add _ button . tab _ index = NUM ; this . add _ button . text = STR ; this . add _ button . use _ visual _ style _ back _ color = true ;
} } private void load _ raw _ statistics ( ) { try { var path = availability _ statistics _ file ; logging . debug ( $ STR ) ; if ( ! file . exists ( path ) ) {
private void load _ raw _ statistics ( ) { try { var path = availability _ statistics _ file ; logging . debug ( $ STR ) ; if ( ! file . exists ( path ) ) { try {
{ var path = availability _ statistics _ file ; logging . debug ( $ STR ) ; if ( ! file . exists ( path ) ) { try { using ( file . create ( path ) ) { } }
private readonly func < string , object , bool > on _ line _ read ; private readonly action < exception , object > on _ exception ; private readonly action < byte [ ] , int , int , object > on _ finish ; private readonly encoding encoding ; private readonly byte [ ] delimiter _ bytes ; private readonly byte _ search . search _ target delimiter _ search ; private readonly object state ; private readonly byte [ ] line _ buffer ; private int buffer _ data _ index ; private int buffer _ data _ length ;
private readonly encoding encoding ; private readonly byte [ ] delimiter _ bytes ; private readonly byte _ search . search _ target delimiter _ search ; private readonly object state ; private readonly byte [ ] line _ buffer ; private int buffer _ data _ index ; private int buffer _ data _ length ; public line _ reader ( wrapped _ socket socket , byte [ ] first _ packge , int index , int length , func < string , object , bool > on _ line _ read , action < exception , object > on _ exception , action < byte [ ] , int , int , object > on _ finish ,
throw new argument _ null _ exception ( nameof ( on _ line _ read ) ) ; } if ( encoding = = null ) { throw new argument _ null _ exception ( nameof ( encoding ) ) ; } if ( delimiter = = null ) { throw new argument _ null _ exception ( nameof ( delimiter ) ) ; }
if ( encoding = = null ) { throw new argument _ null _ exception ( nameof ( encoding ) ) ; } if ( delimiter = = null ) { throw new argument _ null _ exception ( nameof ( delimiter ) ) ; } if ( max _ line _ bytes < length ) {
on _ line _ read = on _ line _ read ; on _ exception = on _ exception ; on _ finish = on _ finish ; encoding = encoding ; state = state ; delimiter _ bytes = encoding . get _ bytes ( delimiter ) ; if ( delimiter _ bytes . length = = 0 ) { throw new argument _ exception ( STR , nameof ( delimiter ) ) ; }
on _ finish = on _ finish ; encoding = encoding ; state = state ; delimiter _ bytes = encoding . get _ bytes ( delimiter ) ; if ( delimiter _ bytes . length = = 0 ) { throw new argument _ exception ( STR , nameof ( delimiter ) ) ; } if ( max _ line _ bytes < delimiter _ bytes . length ) {
delimiter _ bytes = encoding . get _ bytes ( delimiter ) ; if ( delimiter _ bytes . length = = 0 ) { throw new argument _ exception ( STR , nameof ( delimiter ) ) ; } if ( max _ line _ bytes < delimiter _ bytes . length ) { throw new argument _ exception ( STR , nameof ( max _ line _ bytes ) ) ; } delimiter _ search = new byte _ search . search _ target ( delimiter _ bytes ) ;
throw new argument _ exception ( STR , nameof ( delimiter ) ) ; } if ( max _ line _ bytes < delimiter _ bytes . length ) { throw new argument _ exception ( STR , nameof ( max _ line _ bytes ) ) ; } delimiter _ search = new byte _ search . search _ target ( delimiter _ bytes ) ; line _ buffer = new byte [ max _ line _ bytes ] ; if ( length > 0 ) {
new _ package _ recv ( ) ; } catch ( exception ex ) { on _ exception ( ex ) ; on _ finish ( ) ; } } else {
{ on _ exception ( ex ) ; on _ finish ( ) ; } } else { socket . begin _ receive ( line _ buffer , 0 , max _ line _ bytes , 0 , receive _ callback , 0 ) ; } }
{ var state = ( ( fake _ async _ result ) async _ result ) . inner _ state ; if ( state . ex ! = null ) { throw state . ex ; } } public void begin _ connect _ dest ( end _ point dest _ end _ point , async _ callback callback , object state ) { dest _ end _ point = dest _ end _ point ;
using system _ collections _ generic ; using system _ net ; using system _ net _ sockets ; using system _ timers ; using shadowsocks _ controller _ strategy ; using shadowsocks _ encryption ; using shadowsocks _ forward _ proxy ; using shadowsocks _ model ; using shadowsocks _ util _ sockets ;
using shadowsocks _ forward _ proxy ; using shadowsocks _ model ; using shadowsocks _ util _ sockets ; namespace shadowsocks _ controller _ service { class tcp _ relay : listener . service { private shadowsocks _ controller controller ; private date _ time last _ sweep _ time ; private configuration config ;
private shadowsocks _ controller controller ; private date _ time last _ sweep _ time ; private configuration config ; private readonly list < itcp _ handler _ factory > factories = new list < itcp _ handler _ factory > ( ) ; public i _ set < tcp _ handler > handlers { get ; } = new hash _ set < tcp _ handler > ( ) ; public tcp _ relay ( shadowsocks _ controller controller , configuration conf ) { controller = controller ; config = conf ; last _ sweep _ time = date _ time . now ;
public tcp _ relay ( shadowsocks _ controller controller , configuration conf ) { controller = controller ; config = conf ; last _ sweep _ time = date _ time . now ; factories . add ( new socks _ handler _ factory ( ) ) ; factories . add ( new http _ handler _ handler _ factory ( ) ) ; } public override bool handle ( byte [ ] first _ packet , int length , socket socket , object state ) {
config = conf ; last _ sweep _ time = date _ time . now ; factories . add ( new socks _ handler _ factory ( ) ) ; factories . add ( new http _ handler _ handler _ factory ( ) ) ; } public override bool handle ( byte [ ] first _ packet , int length , socket socket , object state ) { { if ( factory . can _ handle ( first _ packet , length ) ) { handler = factory . new _ handler ( controller , config , this , socket ) ; break ; } } if ( handler = = null ) { return false ;
} public void update _ outbound _ counter ( server server , long n ) { controller . update _ outbound _ counter ( server , n ) ; } public void update _ latency ( server server , time _ span latency ) { controller . update _ latency ( server , latency ) ; } }
{ controller . update _ outbound _ counter ( server , n ) ; } public void update _ latency ( server server , time _ span latency ) { controller . update _ latency ( server , latency ) ; } } interface itcp _ handler _ factory {
interface itcp _ handler _ factory { public abstract void start _ handshake ( byte [ ] first _ packet , int length ) ; protected abstract void on _ server _ connected ( async _ session session ) ; protected class async _ session { public i _ forward _ proxy remote { get ; } public async _ session ( i _ forward _ proxy remote ) { remote = remote ; } }
{ state = state ; } } private readonly int server _ timeout ; private readonly int proxy _ timeout ; public static readonly int recv _ size = NUM ; public static readonly int recv _ reserve _ size = iv _ encryptor . onetimeauth _ bytes + iv _ encryptor . auth _ bytes ; public static readonly int buffer _ size = recv _ size + recv _ reserve _ size + NUM ; public date _ time last _ activity ;
public static readonly int recv _ size = NUM ; public static readonly int recv _ reserve _ size = iv _ encryptor . onetimeauth _ bytes + iv _ encryptor . auth _ bytes ; public static readonly int buffer _ size = recv _ size + recv _ reserve _ size + NUM ; public date _ time last _ activity ; private shadowsocks _ controller controller ; protected configuration config { get ; } private tcp _ relay tcprelay ; protected socket connection { get ; } private server server ; private async _ session current _ remote _ session ;
private readonly object encryption _ lock = new object ( ) ; private readonly object decryption _ lock = new object ( ) ; private bool connection _ shutdown = false ; private bool remote _ shutdown = false ; protected bool closed { get ; private set ; } = false ; private readonly object close _ conn _ lock = new object ( ) ; private date _ time start _ connect _ time ; private date _ time start _ receiving _ time ; private date _ time start _ sending _ time ; private end _ point dest _ end _ point = null ;
private end _ point dest _ end _ point = null ; public tcp _ handler ( shadowsocks _ controller controller , configuration config , tcp _ relay tcprelay , socket socket , bool auto _ append _ header = true ) { controller = controller ; config = config ; tcprelay = tcprelay ; connection = socket ; proxy _ timeout = config . proxy . proxy _ timeout * NUM ; server _ timeout = config . get _ current _ server ( ) . timeout * NUM ; last _ activity = date _ time . now ;
{ if ( server ! = null ) { i _ strategy strategy = controller . get _ current _ strategy ( ) ; strategy ? . set _ failure ( server ) ; } logging . log _ useful _ exception ( e ) ; close ( ) ; } }
logging . log _ useful _ exception ( e ) ; close ( ) ; } } protected void start _ pipe ( async _ session session ) { if ( closed ) return ; try { start _ receiving _ time = date _ time . now ;
} } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; } } private void send _ to _ server ( int length , async _ session session ) {
length + = len ; } total _ write + = length ; int bytes _ to _ send ; lock ( encryption _ lock ) { encryptor . encrypt ( connetion _ recv _ buffer , length , connetion _ send _ buffer , out bytes _ to _ send ) ; } tcprelay . update _ outbound _ counter ( server , bytes _ to _ send ) ; start _ sending _ time = date _ time . now ;
lock ( encryption _ lock ) { encryptor . encrypt ( connetion _ recv _ buffer , length , connetion _ send _ buffer , out bytes _ to _ send ) ; } tcprelay . update _ outbound _ counter ( server , bytes _ to _ send ) ; start _ sending _ time = date _ time . now ; session . remote . begin _ send ( connetion _ send _ buffer , 0 , bytes _ to _ send , socket _ flags . none , callback , session ) ; i _ strategy strategy = controller . get _ current _ strategy ( ) ; strategy ? . update _ last _ write ( server ) ; }
} tcprelay . update _ outbound _ counter ( server , bytes _ to _ send ) ; start _ sending _ time = date _ time . now ; session . remote . begin _ send ( connetion _ send _ buffer , 0 , bytes _ to _ send , socket _ flags . none , callback , session ) ; i _ strategy strategy = controller . get _ current _ strategy ( ) ; strategy ? . update _ last _ write ( server ) ; } protected async _ session end _ send _ to _ server ( i _ async _ result ar ) { var session = ( async _ session ) ar . async _ state ; session . remote . end _ send ( ar ) ; return session ; } private void pipe _ remote _ send _ callback ( i _ async _ result ar ) {
try { var strategy = get _ current _ strategy ( ) ; if ( strategy ! = null ) { strategy . reload _ servers ( ) ; } tcp _ relay tcp _ relay = new tcp _ relay ( this , config ) ; udp _ relay udp _ relay = new udp _ relay ( this ) ; list < listener . i _ service > services = new list < listener . i _ service > ( ) ;
else { realkey = key ; } if ( cipher = = cipher _ aes ) { polar _ ssl . aes _ init ( ctx ) ; if ( is _ cipher ) {
polar _ ssl . aes _ init ( ctx ) ; if ( is _ cipher ) { polar _ ssl . aes _ setkey _ enc ( ctx , realkey , key _ len * NUM ) ; encrypt _ iv = new byte [ iv _ len ] ; array . copy ( iv , encrypt _ iv , iv _ len ) ; } else {
using system _ text _ regular _ expressions ; namespace shadowsocks _ controller { class pac _ server { private static int port = NUM ; private static string pac _ file = STR ; private static configuration config ; socket listener ; file _ system _ watcher watcher ;
else { local _ end _ point = new ip _ end _ point ( ip _ address . loopback , port ) ; } listener . bind ( local _ end _ point ) ; listener . listen ( NUM ) ; listener . begin _ accept ( new async _ callback ( accept _ callback ) , listener ) ; watch _ pac _ file ( ) ;
start _ gfw _ list _ updater ( ) ; } catch ( socket _ exception ) { listener . close ( ) ; throw ; } } public void stop ( ) {
using system _ i _ compression ; using system _ security _ cryptography ; using system _ text _ regular _ expressions ; using shadowsocks _ model ; using shadowsocks _ properties ; namespace shadowsocks _ controller { public class gfw _ list _ updater { private const string gfwlist _ url = STR ;
using system _ text _ regular _ expressions ; using shadowsocks _ model ; using shadowsocks _ properties ; namespace shadowsocks _ controller { public class gfw _ list _ updater { private const string gfwlist _ url = STR ; private const int expire _ hours = NUM ; public i _ web _ proxy proxy = null ;
{ lock ( locker ) { last _ update _ time _ utc = date _ time . utc _ now . add _ hours ( - 1 * expire _ hours ) . add _ seconds ( delay _ seconds ) ; } } private string download _ gfw _ list _ file ( ) { try {
} private string download _ gfw _ list _ file ( ) { try { web _ client http = new web _ client ( ) ; http . proxy = use _ system _ proxy ? web _ request . get _ system _ web _ proxy ( ) : proxy ; return http . download _ string ( new uri ( gfwlist _ url ) ) ; } catch ( exception ex ) {
} thread . sleep ( NUM ) ; } } class parser { public string content { get ; private set ; } public parser ( string response ) { byte [ ] bytes = convert . from _ base _ string ( response ) ;
byte [ ] bytes = convert . from _ base _ string ( response ) ; this . content = encoding . ascii . get _ string ( bytes ) ; } public string [ ] get _ lines ( ) { return content . split ( new char [ ] { '\r' , '\n' } , string _ split _ options . remove _ empty _ entries ) ; } public string [ ] get _ domains ( ) {
this . edit _ online _ pac _ item = create _ menu _ item ( STR , new event _ handler ( this . update _ online _ pacurl _ item _ click ) ) ,
this . edit _ pac _ file _ item = new system . windows . forms . menu _ item ( ) ; this . about _ item = new system . windows . forms . menu _ item ( ) ; this . menu _ item = new system . windows . forms . menu _ item ( ) ; this . quit _ item = new system . windows . forms . menu _ item ( ) ; this . panel = new system . windows . forms . panel ( ) ; this . delete _ button = new system . windows . forms . button ( ) ; this . add _ button = new system . windows . forms . button ( ) ; this . server _ group _ box = new system . windows . forms . group _ box ( ) ; this . servers _ list _ box = new system . windows . forms . list _ box ( ) ;
} items . add ( seperator _ item ) ; items . add ( config _ item ) ; if ( configuration . index > = 0 & & configuration . index < configuration . configs . count ) { items [ configuration . index ] . checked = true ; } } private void config _ form _ load ( object sender , event _ args e ) {
{ items [ configuration . index ] . checked = true ; } } private void config _ form _ load ( object sender , event _ args e ) { if ( ! controller . get _ configuration ( ) . is _ default ) { this . opacity = 0 ;
user _ rule _ file _ watcher . filter = user _ rule _ file ; user _ rule _ file _ watcher . changed + = user _ rule _ file _ watcher _ changed ; user _ rule _ file _ watcher . created + = user _ rule _ file _ watcher _ changed ; user _ rule _ file _ watcher . deleted + = user _ rule _ file _ watcher _ changed ; user _ rule _ file _ watcher . renamed + = user _ rule _ file _ watcher _ changed ; user _ rule _ file _ watcher . enable _ raising _ events = true ; } private void pac _ file _ watcher _ changed ( object sender , file _ system _ event _ args e ) {
if ( pac _ file _ changed ! = null ) { console . write _ line ( STR , e . name , e . change _ type . to _ string ( ) . to _ lower ( ) ) ; pac _ file _ changed ( this , new event _ args ( ) ) ; } } private void user _ rule _ file _ watcher _ changed ( object sender , file _ system _ event _ args e ) {
string temppath = path . get _ temp _ path ( ) ; string polipo _ config = resources . polipo _ config ; polipo _ config = polipo _ config . replace ( STR , server . local _ port . to _ string ( ) ) ; polipo _ config = polipo _ config . replace ( STR , configuration . share _ over _ lan ? STR : STR ) ; file _ manager . byte _ array _ to _ file ( temppath + STR , system . text . encoding . ut . get _ bytes ( polipo _ config ) ) ; file _ manager . uncompress _ file ( temppath + STR , resources . polipo _ exe ) ; process = new process ( ) ; process . start _ info . file _ name = temppath + STR ; process . start _ info . arguments = STR + temppath + STR ; process . start _ info . window _ style = process _ window _ style . hidden ;
polipo _ config = polipo _ config . replace ( STR , server . local _ port . to _ string ( ) ) ; polipo _ config = polipo _ config . replace ( STR , configuration . share _ over _ lan ? STR : STR ) ; file _ manager . byte _ array _ to _ file ( temppath + STR , system . text . encoding . ut . get _ bytes ( polipo _ config ) ) ; file _ manager . uncompress _ file ( temppath + STR , resources . polipo _ exe ) ; process = new process ( ) ; process . start _ info . file _ name = temppath + STR ; process . start _ info . arguments = STR + temppath + STR ; process . start _ info . window _ style = process _ window _ style . hidden ; process . start _ info . use _ shell _ execute = false ; process . start _ info . create _ no _ window = true ;
private void load _ current _ configuration ( ) { configuration config = controller . get _ configuration ( ) ; update _ servers _ menu ( ) ; enable _ item . checked = config . enabled ; mode _ item . enabled = config . enabled ; global _ mode _ item . checked = config . global ; pac _ mode _ item . checked = ! config . global ; share _ over _ lan _ item . checked = config . share _ over _ lan ; auto _ startup _ item . checked = auto _ startup . check ( ) ;
} } private void online _ pac _ item _ click ( object sender , event _ args e ) { if ( ! online _ pac _ item . checked ) {
using system ;
using system ; using system _ collections _ generic ; using system _ io ; using system _ i _ compression ;
using system _ i _ compression ; using system _ text ; namespace shadowsocks _ controller { public class file _ manager { public static bool byte _ array _ to _ file ( string file _ name , byte [ ] content ) { try {
return false ; } public static void uncompress _ file ( string file _ name , byte [ ] content ) { file _ stream destination _ file = file . create ( file _ name ) ; byte [ ] buffer = new byte [ NUM ] ; int n ; using ( g _ zip _ stream input = new g _ zip _ stream ( new memory _ stream ( content ) , compression _ mode . decompress , false ) ) {
public static void uncompress _ file ( string file _ name , byte [ ] content ) { file _ stream destination _ file = file . create ( file _ name ) ; byte [ ] buffer = new byte [ NUM ] ; int n ; using ( g _ zip _ stream input = new g _ zip _ stream ( new memory _ stream ( content ) , compression _ mode . decompress , false ) ) { while ( true ) {
{ public class logging { public static string log _ file _ path ; public static bool open _ log _ file ( ) { try { log _ file _ path = utils . get _ temp _ path ( STR ) ;
public static void error ( object o ) {
public static void error ( object o ) { console . write _ line ( STR + o ) ; } public static void info ( object o ) {
public static void error ( object o ) { console . write _ line ( STR + o ) ; } public static void info ( object o ) { console . write _ line ( o ) ; } public static void debug ( object o ) {
} } catch ( exception ex ) { if ( error ! = null ) { error ( this , new error _ event _ args ( ex ) ) ; } } }
{ if ( error ! = null ) { error ( this , new error _ event _ args ( ex ) ) ; } } } public void update _ pac _ from _ gfw _ list ( ) { web _ client http = new web _ client ( ) ;
if ( traffic _ info _ queue . count > queue _ max _ length ) traffic _ info _ queue . dequeue ( ) ; } } } private void update _ texts ( ) { file _ menu _ item . text = n . get _ string ( STR ) ; open _ location _ menu _ item . text = n . get _ string ( STR ) ; exit _ menu _ item . text = n . get _ string ( STR ) ;
private void update _ texts ( ) { file _ menu _ item . text = n . get _ string ( STR ) ; open _ location _ menu _ item . text = n . get _ string ( STR ) ; exit _ menu _ item . text = n . get _ string ( STR ) ; clean _ logs _ button . text = n . get _ string ( STR ) ; change _ font _ button . text = n . get _ string ( STR ) ; wrap _ text _ check _ box . text = n . get _ string ( STR ) ; top _ most _ check _ box . text = n . get _ string ( STR ) ; view _ menu _ item . text = n . get _ string ( STR ) ;
system . diagnostics . process . start ( STR , argument ) ; } private void exit _ menu _ item _ click ( object sender , event _ args e ) { close ( ) ; } private void log _ form _ shown ( object sender , event _ args e ) { log _ message _ text _ box . scroll _ to _ caret ( ) ; }
private void log _ form _ shown ( object sender , event _ args e ) { log _ message _ text _ box . scroll _ to _ caret ( ) ; } private void do _ clean _ logs ( ) { logging . clear ( ) ; last _ offset = 0 ; log _ message _ text _ box . clear ( ) ; }
system . windows . forms . data _ visualization . charting . chart _ area chart _ area = new system . windows . forms . data _ visualization . charting . chart _ area ( ) ; system . windows . forms . data _ visualization . charting . legend legend = new system . windows . forms . data _ visualization . charting . legend ( ) ; system . windows . forms . data _ visualization . charting . series series = new system . windows . forms . data _ visualization . charting . series ( ) ; system . windows . forms . data _ visualization . charting . series series = new system . windows . forms . data _ visualization . charting . series ( ) ; this . log _ message _ text _ box = new system . windows . forms . text _ box ( ) ; this . main _ menu = new system . windows . forms . main _ menu ( this . components ) ; this . file _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . open _ location _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . exit _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . view _ menu _ item = new system . windows . forms . menu _ item ( ) ;
this . exit _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . view _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . clean _ logs _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . change _ font _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . wrap _ text _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . top _ most _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . menu _ item _ separater = new system . windows . forms . menu _ item ( ) ; this . show _ toolbar _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . top _ most _ check _ box = new system . windows . forms . check _ box ( ) ; this . change _ font _ button = new system . windows . forms . button ( ) ;
this . clean _ logs _ menu _ item , this . change _ font _ menu _ item , this . wrap _ text _ menu _ item , this . top _ most _ menu _ item , this . menu _ item _ separater , this . show _ toolbar _ menu _ item } ) ; this . view _ menu _ item . text = STR ;

private system . windows . forms . button clean _ logs _ button ; private system . windows . forms . button change _ font _ button ; private system . windows . forms . table _ layout _ panel table _ layout _ panel ; private system . windows . forms . check _ box top _ most _ check _ box ; private system . windows . forms . menu _ item view _ menu _ item ;
en _ index = i ; if ( locale _ names [ i ] = = locale ) target _ index = i ; } if ( target _ index = = - 1 ) { string locale _ no _ region = locale . split ( '-' ) [ 0 ] ; for ( int i = 0 ; i < locale _ names . length ; i + + ) { if ( locale _ names [ i ] . split ( '-' ) [ 0 ] = = locale _ no _ region )
target _ index = i ; } if ( target _ index = = - 1 ) { string locale _ no _ region = locale . split ( '-' ) [ 0 ] ; for ( int i = 0 ; i < locale _ names . length ; i + + ) { if ( locale _ names [ i ] . split ( '-' ) [ 0 ] = = locale _ no _ region ) { target _ index = i ;
string locale _ no _ region = locale . split ( '-' ) [ 0 ] ; for ( int i = 0 ; i < locale _ names . length ; i + + ) { if ( locale _ names [ i ] . split ( '-' ) [ 0 ] = = locale _ no _ region ) { target _ index = i ; } } }
connection . begin _ send ( response , 0 , response . length , socket _ flags . none , new async _ callback ( read _ all ) , true ) ; } private void read _ all ( i _ async _ result ar ) { if ( closed ) return ; try { if ( ar . async _ state ! = null ) { connection . end _ send ( ar ) ;
{ connection . end _ send ( ar ) ; logging . debug ( remote . local _ end _ point , remote . dest _ end _ point , recv _ size , STR ) ; connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , socket _ flags . none , new async _ callback ( read _ all ) , null ) ; } else { int bytes _ read = connection . end _ receive ( ar ) ; if ( bytes _ read > 0 ) {
private class server _ timer : timer { public server server ; public server _ timer ( int p ) : base ( p ) { } } private void start _ connect ( ) { try { create _ remote ( ) ;
} private void start _ connect ( ) { try { create _ remote ( ) ; bool parsed = ip _ address . try _ parse ( server . server , out ip _ address ) ; if ( ! parsed ) { ip _ host _ entry ip _ host _ info = dns . get _ host _ entry ( server . server ) ; ip _ address = ip _ host _ info . address _ list [ 0 ] ; } ip _ end _ point dest _ ep = new ip _ end _ point ( ip _ address , server . server _ port ) ; ip _ end _ point proxy _ ep ; if ( config . use _ proxy ) {
{ ip _ host _ entry ip _ host _ info = dns . get _ host _ entry ( config . proxy _ server ) ; ip _ address = ip _ host _ info . address _ list [ 0 ] ; } remote = new socks _ proxy ( ) ; proxy _ ep = new ip _ end _ point ( ip _ address , config . proxy _ port ) ; } else { remote = new direct _ connect ( ) ;
} else { remote = new direct _ connect ( ) ; proxy _ ep = dest _ ep ; } proxy _ timer proxy _ timer = new proxy _ timer ( NUM ) ; proxy _ timer . auto _ reset = false ; proxy _ timer . elapsed + = proxy _ connect _ timer _ elapsed ; proxy _ timer . enabled = true ;
private socket remote ; public end _ point local _ end _ point = > remote . local _ end _ point ;
private socket remote ; public end _ point local _ end _ point = > remote . local _ end _ point ; public end _ point proxy _ end _ point { get ; private set ; } public end _ point dest _ end _ point { get ; private set ; } public void begin _ connect _ proxy ( end _ point remote _ ep , async _ callback callback , object state ) {
public end _ point dest _ end _ point { get ; private set ; } public void begin _ connect _ proxy ( end _ point remote _ ep , async _ callback callback , object state ) { proxy _ end _ point = remote _ ep ; var r = new fake _ async _ result ( state ) ; callback ? . invoke ( r ) ; } public void end _ connect _ proxy ( i _ async _ result async _ result ) { }
if ( remote = = null ) { remote = new socket ( remote _ ep . address _ family , socket _ type . stream , protocol _ type . tcp ) ; remote . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; }
using system ; using system _ net ; using system _ net _ sockets ; namespace shadowsocks _ proxy { public interface i _ proxy { end _ point local _ end _ point { get ; } end _ point proxy _ end _ point { get ; }
namespace shadowsocks _ proxy { public interface i _ proxy { end _ point local _ end _ point { get ; } end _ point proxy _ end _ point { get ; } end _ point dest _ end _ point { get ; } void begin _ connect _ proxy ( end _ point remote _ ep , async _ callback callback , object state ) ; void end _ connect _ proxy ( i _ async _ result async _ result ) ;
{ private string code ; public qr _ code _ form ( string code ) { this . code = code ; initialize _ component ( ) ; } private void gen _ qr ( string ssconfig ) { string qr _ text = ssconfig ;
private void gen _ qr ( string ssconfig ) { string qr _ text = ssconfig ; qr _ code _ cs . qr _ code qr _ coded = new qr _ code _ cs . qr _ code ( NUM , qr _ error _ correct _ level . h ) ; qr _ coded . add _ data ( qr _ text ) ; qr _ coded . make ( ) ; int block _ size = NUM ; bitmap draw _ area = new bitmap ( ( qr _ coded . get _ module _ count ( ) * block _ size ) , ( qr _ coded . get _ module _ count ( ) * block _ size ) ) ;
string qr _ text = ssconfig ; qr _ code _ cs . qr _ code qr _ coded = new qr _ code _ cs . qr _ code ( NUM , qr _ error _ correct _ level . h ) ; qr _ coded . add _ data ( qr _ text ) ; qr _ coded . make ( ) ; int block _ size = NUM ; bitmap draw _ area = new bitmap ( ( qr _ coded . get _ module _ count ( ) * block _ size ) , ( qr _ coded . get _ module _ count ( ) * block _ size ) ) ; for ( int row = 0 ; row < qr _ coded . get _ module _ count ( ) ; row + + ) {
qr _ code _ cs . qr _ code qr _ coded = new qr _ code _ cs . qr _ code ( NUM , qr _ error _ correct _ level . h ) ; qr _ coded . add _ data ( qr _ text ) ; qr _ coded . make ( ) ; int block _ size = NUM ; bitmap draw _ area = new bitmap ( ( qr _ coded . get _ module _ count ( ) * block _ size ) , ( qr _ coded . get _ module _ count ( ) * block _ size ) ) ; for ( int row = 0 ; row < qr _ coded . get _ module _ count ( ) ; row + + ) { for ( int col = 0 ; col < qr _ coded . get _ module _ count ( ) ; col + + ) {
qr _ coded . make ( ) ; int block _ size = NUM ; bitmap draw _ area = new bitmap ( ( qr _ coded . get _ module _ count ( ) * block _ size ) , ( qr _ coded . get _ module _ count ( ) * block _ size ) ) ; for ( int row = 0 ; row < qr _ coded . get _ module _ count ( ) ; row + + ) { for ( int col = 0 ; col < qr _ coded . get _ module _ count ( ) ; col + + ) { bool is _ dark = qr _ coded . is _ dark ( row , col ) ; if ( is _ dark ) {
bitmap draw _ area = new bitmap ( ( qr _ coded . get _ module _ count ( ) * block _ size ) , ( qr _ coded . get _ module _ count ( ) * block _ size ) ) ; for ( int row = 0 ; row < qr _ coded . get _ module _ count ( ) ; row + + ) { for ( int col = 0 ; col < qr _ coded . get _ module _ count ( ) ; col + + ) { bool is _ dark = qr _ coded . is _ dark ( row , col ) ; if ( is _ dark ) { for ( int y = 0 ; y < block _ size ; y + + ) {
for ( int col = 0 ; col < qr _ coded . get _ module _ count ( ) ; col + + ) { bool is _ dark = qr _ coded . is _ dark ( row , col ) ; if ( is _ dark ) { for ( int y = 0 ; y < block _ size ; y + + ) { int my _ col = ( block _ size * ( col - 1 ) ) + ( y + block _ size ) ; for ( int x = 0 ; x < block _ size ; x + + ) {
{ return false ; } } public static configuration load ( ) { try { string config _ content = file . read _ all _ text ( config _ file ) ;
config . log _ viewer = new log _ viewer _ config ( ) ; if ( config . proxy = = null ) config . proxy = new proxy _ config ( ) ; if ( config . hotkey = = null ) config . hotkey = new hotkey _ config ( ) ; if ( ! system . net . sockets . socket . os _ supports _ i _ pv ) { config . is _ i _ pv _ enabled = false ; } config . proxy . check _ config ( ) ;
config . is _ i _ pv _ enabled = false ; } config . proxy . check _ config ( ) ; catch ( exception e ) { logger . error ( e , STR ) ; } return config ; } catch ( exception e ) { if ( ! ( e is file _ not _ found _ exception ) ) logger . log _ useful _ exception ( e ) ;
{ log _ message _ text _ box . word _ wrap = wrap _ text _ check _ box . checked ; log _ message _ text _ box . scroll _ to _ caret ( ) ; } private void clean _ logs _ button _ click ( object sender , event _ args e ) { log _ message _ text _ box . clear ( ) ; } private void change _ font _ button _ click ( object sender , event _ args e ) {
log _ message _ text _ box . scroll _ to _ caret ( ) ; } private void clean _ logs _ button _ click ( object sender , event _ args e ) { log _ message _ text _ box . clear ( ) ; } private void change _ font _ button _ click ( object sender , event _ args e ) { font _ dialog fd = new font _ dialog ( ) ; fd . font = log _ message _ text _ box . font ; if ( fd . show _ dialog ( ) = = dialog _ result . ok ) {
} global _ system _ component _ model _ editor _ browsable _ attribute _ global _ system _ component _ model _ editor _ browsable _ state _ advanced internal static global :: system . globalization . culture _ info culture { get { return resource _ culture ; } set { resource _ culture = value ; } }
remarks = STR ; timeout = default _ server _ timeout _ sec ; } public static list < server > get _ servers ( string ss _ url ) { var server _ urls = ss _ url . split ( '\r' , '\n' ) ; list < server > servers = new list < server > ( ) ; foreach ( string server _ url in server _ urls ) {
uri parsed _ url ; try {
parsed _ url = new uri ( server _ url ) ; } catch ( uri _ format _ exception ) { continue ; } server tmp = new server { remarks = parsed _ url . get _ components ( uri _ components . fragment , uri _ format . unescaped ) } ;
this . table _ layout _ panel . controls . add ( this . remarks _ text _ box , 1 , NUM ) ; this . table _ layout _ panel . controls . add ( this . remarks _ label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . ip _ label , 0 , 0 ) ; this . table _ layout _ panel . controls . add ( this . server _ port _ label , 0 , 1 ) ; this . table _ layout _ panel . controls . add ( this . password _ label , 0 , 2 ) ; this . table _ layout _ panel . controls . add ( this . ip _ text _ box , 1 , 0 ) ; this . table _ layout _ panel . controls . add ( this . server _ port _ text _ box , 1 , 1 ) ; this . table _ layout _ panel . controls . add ( this . password _ text _ box , 1 , 2 ) ; this . table _ layout _ panel . controls . add ( this . encryption _ label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . encryption _ select , 1 , NUM ) ;
this . table _ layout _ panel . controls . add ( this . server _ port _ text _ box , 1 , 1 ) ; this . table _ layout _ panel . controls . add ( this . password _ text _ box , 1 , 2 ) ; this . table _ layout _ panel . controls . add ( this . encryption _ label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . encryption _ select , 1 , NUM ) ; this . table _ layout _ panel . controls . add ( this . one _ time _ auth , 1 , NUM ) ; this . table _ layout _ panel . location = new system . drawing . point ( NUM , NUM ) ; this . table _ layout _ panel . margin = new system . windows . forms . padding ( 0 ) ; this . table _ layout _ panel . name = STR ; this . table _ layout _ panel . padding = new system . windows . forms . padding ( NUM ) ;
private void initialize _ component ( ) { this . table _ layout _ panel = new system . windows . forms . table _ layout _ panel ( ) ; this . table _ layout _ panel = new system . windows . forms . table _ layout _ panel ( ) ; this . my _ cancel _ button = new system . windows . forms . button ( ) ; this . ok _ button = new system . windows . forms . button ( ) ; this . use _ proxy _ check _ box = new system . windows . forms . check _ box ( ) ; this . table _ layout _ panel = new system . windows . forms . table _ layout _ panel ( ) ; this . proxy _ addr _ label = new system . windows . forms . label ( ) ; this . proxy _ server _ text _ box = new system . windows . forms . text _ box ( ) ;

this . proxy _ addr _ label . size = new system . drawing . size ( NUM , NUM ) ; this . proxy _ addr _ label . tab _ index = 0 ; this . proxy _ addr _ label . text = STR ; this . proxy _ server _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . proxy _ server _ text _ box . max _ length = NUM ; this . proxy _ server _ text _ box . name = STR ; this . proxy _ server _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . proxy _ server _ text _ box . tab _ index = 1 ; this . proxy _ server _ text _ box . word _ wrap = false ;
this . proxy _ port _ lable . tab _ index = 2 ; this . proxy _ port _ lable . text = STR ; this . proxy _ port _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . proxy _ port _ text _ box . max _ length = NUM ; this . proxy _ port _ text _ box . name = STR ; this . proxy _ port _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . proxy _ port _ text _ box . tab _ index = NUM ; this . proxy _ port _ text _ box . word _ wrap = false ; this . table _ layout _ panel . auto _ size = true ;
this . table _ layout _ panel . controls . add ( this . proxy _ type _ label , 0 , 0 ) ; this . table _ layout _ panel . controls . add ( this . proxy _ type _ combo _ box , 1 , 0 ) ; this . table _ layout _ panel . location = new system . drawing . point ( NUM , NUM ) ; this . table _ layout _ panel . name = STR ; this . table _ layout _ panel . row _ count = 1 ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ; this . table _ layout _ panel . tab _ index = NUM ;
this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ; this . table _ layout _ panel . tab _ index = NUM ; this . proxy _ type _ label . anchor = system . windows . forms . anchor _ styles . left ; this . proxy _ type _ label . auto _ size = true ; this . proxy _ type _ label . location = new system . drawing . point ( NUM , NUM ) ; this . proxy _ type _ label . name = STR ; this . proxy _ type _ label . size = new system . drawing . size ( NUM , NUM ) ; this . proxy _ type _ label . tab _ index = 1 ; this . proxy _ type _ label . text = STR ;

new _ config . save _ size ( ) ; configuration . save ( config ) ; config _ changed ? . invoke ( this , new event _ args ( ) ) ; } public void save _ hotkey _ config ( hotkey _ config new _ config ) { config . hotkey = new _ config ; save _ config ( config ) ; config _ changed ? . invoke ( this , new event _ args ( ) ) ; }
{ config . hotkey = new _ config ; save _ config ( config ) ; config _ changed ? . invoke ( this , new event _ args ( ) ) ; } public void update _ latency ( server server , time _ span latency ) { if ( config . availability _ statistics ) {
{ availability _ statistics . update _ latency ( server , ( int ) latency . total _ milliseconds ) ; } } public void update _ inbound _ counter ( server server , long n ) { interlocked . add ( ref inbound _ counter , n ) ; if ( config . availability _ statistics ) {
{ availability _ statistics . update _ inbound _ counter ( server , n ) ; } } public void update _ outbound _ counter ( server server , long n ) { interlocked . add ( ref outbound _ counter , n ) ; if ( config . availability _ statistics ) {

using shadowsocks _ controller _ strategy ; using shadowsocks _ encryption ; using shadowsocks _ encryption _ aead ; using shadowsocks _ encryption _ exception ; using shadowsocks _ model ; using shadowsocks _ proxy ; using shadowsocks _ util _ sockets ; using static shadowsocks . encryption . encryptor _ base ; namespace shadowsocks _ controller {
using shadowsocks _ encryption _ aead ; using shadowsocks _ encryption _ exception ; using shadowsocks _ model ; using shadowsocks _ proxy ; using shadowsocks _ util _ sockets ; using static shadowsocks . encryption . encryptor _ base ; namespace shadowsocks _ controller { class tcp _ relay : listener . service {
using shadowsocks _ proxy ; using shadowsocks _ util _ sockets ; using static shadowsocks . encryption . encryptor _ base ; namespace shadowsocks _ controller { class tcp _ relay : listener . service { private static logger logger = log _ manager . get _ current _ class _ logger ( ) ; private shadowsocks _ controller controller ; private date _ time last _ sweep _ time ;
last _ sweep _ time = date _ time . now ; } public override bool handle ( byte [ ] first _ packet , int length , socket socket , object state ) { if ( socket . protocol _ type ! = protocol _ type . tcp | | ( length < 2 | | first _ packet [ 0 ] ! = NUM ) ) return false ; socket . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ;
} public override void stop ( ) { list < tcp _ handler > handlers _ to _ close = new list < tcp _ handler > ( ) ; lock ( handlers ) { handlers _ to _ close . add _ range ( handlers ) ; } handlers _ to _ close . for _ each ( h = > h . close ( ) ) ; }
{ controller . update _ outbound _ counter ( server , n ) ; } public void update _ latency ( server server , time _ span latency ) { controller . update _ latency ( server , latency ) ; } } internal class tcp _ handler {
{ class async _ session { public i _ proxy remote { get ; } public async _ session ( i _ proxy remote ) { remote = remote ; } }
public t state { get ; set ; } public async _ session ( i _ proxy remote , t state ) : base ( remote ) { state = state ; } public async _ session ( async _ session session , t state ) : base ( session . remote ) { state = state ; } }
} } private static logger logger = log _ manager . get _ current _ class _ logger ( ) ; private readonly int server _ timeout ; private readonly int proxy _ timeout ; public const int recv _ size = NUM ; public const int chunk _ overhead _ size = NUM * 2 public const uint max _ chunk _ size = aead _ encryptor . chunk _ len _ mask + aead _ encryptor . chunk _ len _ bytes + NUM * 2 ; public const int buffer _ size = recv _ size + ( int ) max _ chunk _ size + NUM public date _ time last _ activity ;
private bool dest _ connected ; private byte command ; private byte [ ] first _ packet ; private int first _ packet _ length ; private const int cmd _ connect = 0 ; private const int cmd _ bind = 0 ; private const int cmd _ udp _ assoc = 0 ; private int addr _ buf _ length = - 1 ; private int total _ read = 0 ; private int total _ write = 0 ;
private byte command ; private byte [ ] first _ packet ; private int first _ packet _ length ; private const int cmd _ connect = 0 ; private const int cmd _ bind = 0 ; private const int cmd _ udp _ assoc = 0 ; private int addr _ buf _ length = - 1 ; private int total _ read = 0 ; private int total _ write = 0 ; private byte [ ] remote _ recv _ buffer = new byte [ buffer _ size ] ;
private byte [ ] first _ packet ; private int first _ packet _ length ; private const int cmd _ connect = 0 ; private const int cmd _ bind = 0 ; private const int cmd _ udp _ assoc = 0 ; private int addr _ buf _ length = - 1 ; private int total _ read = 0 ; private int total _ write = 0 ; private byte [ ] remote _ recv _ buffer = new byte [ buffer _ size ] ; private byte [ ] connetion _ recv _ buffer = new byte [ buffer _ size ] ;
private int first _ packet _ length ; private const int cmd _ connect = 0 ; private const int cmd _ bind = 0 ; private const int cmd _ udp _ assoc = 0 ; private int addr _ buf _ length = - 1 ; private int total _ read = 0 ; private int total _ write = 0 ; private byte [ ] remote _ recv _ buffer = new byte [ buffer _ size ] ; private byte [ ] connetion _ recv _ buffer = new byte [ buffer _ size ] ; private byte [ ] remote _ send _ buffer = new byte [ buffer _ size ] ;
private bool connection _ shutdown = false ; private bool remote _ shutdown = false ; private bool closed = false ; private readonly object encryption _ lock = new object ( ) ; private readonly object decryption _ lock = new object ( ) ; private readonly object close _ conn _ lock = new object ( ) ; private date _ time start _ connect _ time ; private date _ time start _ receiving _ time ; private date _ time start _ sending _ time ; private end _ point dest _ end _ point = null ;
private readonly object decryption _ lock = new object ( ) ; private readonly object close _ conn _ lock = new object ( ) ; private date _ time start _ connect _ time ; private date _ time start _ receiving _ time ; private date _ time start _ sending _ time ; private end _ point dest _ end _ point = null ; public tcp _ handler ( shadowsocks _ controller controller , configuration config , tcp _ relay tcprelay , socket socket ) { controller = controller ;
} public void create _ remote ( ) { server server = controller . get _ a _ server ( i _ strategy _ caller _ type . tcp , ( ip _ end _ point ) connection . remote _ end _ point , dest _ end _ point ) ; if ( server = = null | | server . server = = STR ) throw new argument _ exception ( STR ) ; encryptor = encryptor _ factory . get _ encryptor ( server . method , server . password ) ;
} public void close ( ) { lock ( close _ conn _ lock ) {
} public void close ( ) { lock ( close _ conn _ lock ) { if ( closed ) return ; closed = true ; }
{ response = new byte [ ] { 0 , NUM } ; logger . error ( STR ) ; } connection . begin _ send ( response , 0 , response . length , socket _ flags . none , handshake _ send _ callback , null ) ; } else close ( ) ;
close ( ) ; } catch ( exception e ) { logger . log _ useful _ exception ( e ) ; close ( ) ; } } private void handshake _ send _ callback ( i _ async _ result ar ) {
} } private void handshake _ send _ callback ( i _ async _ result ar ) { if ( closed ) return ; try { connection . end _ send ( ar ) ; connection . begin _ receive ( connetion _ recv _ buffer , 0 , NUM + addr _ atyp _ len + 1 , socket _ flags . none ,
} else { logger . debug ( STR ) ; close ( ) ; } } catch ( exception e ) {
} private void response _ callback ( i _ async _ result ar ) { try { connection . end _ send ( ar ) ; read _ address ( start _ connect ) ; } catch ( exception e ) {
} } private void read _ address ( int bytes _ remain , action on _ success ) { array . copy ( connetion _ recv _ buffer , NUM , connetion _ recv _ buffer , 0 , addr _ atyp _ len + 1 ) ; connection . begin _ receive ( connetion _ recv _ buffer , 2 , recv _ size - 2 , socket _ flags . none , on _ address _ fully _ read , new object [ ] { bytes _ remain , on _ success } ) ; } private void on _ address _ fully _ read ( i _ async _ result ar ) {
connection . begin _ receive ( connetion _ recv _ buffer , 2 , recv _ size - 2 , socket _ flags . none , on _ address _ fully _ read , new object [ ] { bytes _ remain , on _ success } ) ; } private void on _ address _ fully _ read ( i _ async _ result ar ) { if ( closed ) return ; try { int bytes _ read = connection . end _ receive ( ar ) ;
} private void on _ address _ fully _ read ( i _ async _ result ar ) { if ( closed ) return ; try { int bytes _ read = connection . end _ receive ( ar ) ; var states = ( object [ ] ) ar . async _ state ; int bytes _ remain = ( int ) states [ 0 ] ;
{ int bytes _ read = connection . end _ receive ( ar ) ; if ( bytes _ read > 0 ) { connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , socket _ flags . none , read _ all , null ) ; } else close ( ) ;
{ case proxy _ config . proxy _ sock : remote = new socks _ proxy ( ) ; break ; case proxy _ config . proxy _ http : remote = new http _ proxy ( ) ; break ; default : throw new not _ supported _ exception ( STR ) ; }
break ; default : throw new not _ supported _ exception ( STR ) ; } proxy _ ep = socket _ util . get _ end _ point ( config . proxy . proxy _ server , config . proxy . proxy _ port ) ; } else { remote = new direct _ connect ( ) ; }
proxy _ timer . enabled = true ; proxy _ timer . session = session ; proxy _ timer . dest _ end _ point = server _ ep ; proxy _ timer . server = server ; proxy _ connected = false ; remote . begin _ connect _ proxy ( proxy _ ep , proxy _ connect _ callback , new async _ session < proxy _ timer > ( remote , proxy _ timer ) ) ; } catch ( exception e ) {
remote . begin _ connect _ proxy ( proxy _ ep , proxy _ connect _ callback , new async _ session < proxy _ timer > ( remote , proxy _ timer ) ) ; } catch ( exception e ) { logger . log _ useful _ exception ( e ) ; close ( ) ; } } private void proxy _ connect _ timer _ elapsed ( object sender , elapsed _ event _ args e ) {
private void proxy _ connect _ timer _ elapsed ( object sender , elapsed _ event _ args e ) { var timer = ( proxy _ timer ) sender ; timer . elapsed - = proxy _ connect _ timer _ elapsed ; timer . enabled = false ; timer . dispose ( ) ; if ( proxy _ connected | | dest _ connected | | closed ) { return ; }
close ( ) ; } private void proxy _ connect _ callback ( i _ async _ result ar ) { if ( closed ) { return ; } try {
private void proxy _ connect _ callback ( i _ async _ result ar ) { if ( closed ) { return ; } try { var session = ( async _ session < proxy _ timer > ) ar . async _ state ; proxy _ timer timer = session . state ;
} try { var session = ( async _ session < proxy _ timer > ) ar . async _ state ; proxy _ timer timer = session . state ; var dest _ end _ point = timer . dest _ end _ point ; var server = timer . server ; timer . elapsed - = proxy _ connect _ timer _ elapsed ; timer . enabled = false ; timer . dispose ( ) ;
logger . debug ( $ STR ) ; } start _ connect _ time = date _ time . now ; server _ timer connect _ timer = new server _ timer ( server _ timeout ) { auto _ reset = false } ; connect _ timer . elapsed + = dest _ connect _ timer _ elapsed ; connect _ timer . enabled = true ; connect _ timer . session = session ; connect _ timer . server = server ; dest _ connected = false ; network _ credential auth = null ;
auth = new network _ credential ( config . proxy . auth _ user , config . proxy . auth _ pwd ) ; } remote . begin _ connect _ dest ( dest _ end _ point , connect _ callback , new async _ session < server _ timer > ( session , connect _ timer ) , auth ) ; } catch ( argument _ exception ) { } catch ( exception e ) {
catch ( argument _ exception ) { } catch ( exception e ) { logger . log _ useful _ exception ( e ) ; close ( ) ; } } private void dest _ connect _ timer _ elapsed ( object sender , elapsed _ event _ args e ) {
private void dest _ connect _ timer _ elapsed ( object sender , elapsed _ event _ args e ) { var timer = ( server _ timer ) sender ; timer . elapsed - = dest _ connect _ timer _ elapsed ; timer . enabled = false ; timer . dispose ( ) ; if ( dest _ connected | | closed ) { return ; }
var timer = ( server _ timer ) sender ; timer . elapsed - = dest _ connect _ timer _ elapsed ; timer . enabled = false ; timer . dispose ( ) ; if ( dest _ connected | | closed ) { return ; } var session = timer . session ; server server = timer . server ;
} var session = timer . session ; server server = timer . server ; i _ strategy strategy = controller . get _ current _ strategy ( ) ; strategy ? . set _ failure ( server ) ; logger . info ( $ STR ) ; session . remote . close ( ) ; close ( ) ; } private void connect _ callback ( i _ async _ result ar ) {
if ( closed ) return ; try { var session = ( async _ session < server _ timer > ) ar . async _ state ; server _ timer timer = session . state ; server = timer . server ; timer . elapsed - = dest _ connect _ timer _ elapsed ; timer . enabled = false ; timer . dispose ( ) ;
var session = ( async _ session < server _ timer > ) ar . async _ state ; server _ timer timer = session . state ; server = timer . server ; timer . elapsed - = dest _ connect _ timer _ elapsed ; timer . enabled = false ; timer . dispose ( ) ; var remote = session . remote ; remote . end _ connect _ dest ( ar ) ; dest _ connected = true ; logger . debug ( $ STR ) ;
tcprelay . update _ latency ( server , latency ) ; start _ pipe ( session ) ; } catch ( argument _ exception ) { } catch ( exception e ) { if ( server ! = null ) {
} logger . log _ useful _ exception ( e ) ; close ( ) ; } } private void try _ read _ available _ data ( ) { int available = math . min ( connection . available , recv _ size - first _ packet _ length ) ; if ( available > 0 ) {
int available = math . min ( connection . available , recv _ size - first _ packet _ length ) ; if ( available > 0 ) { var size = connection . receive ( connetion _ recv _ buffer , first _ packet _ length , available , socket _ flags . none ) ; first _ packet _ length + = size ; } } private void start _ pipe ( async _ session session ) {
{ start _ receiving _ time = date _ time . now ; session . remote . begin _ receive ( remote _ recv _ buffer , 0 , recv _ size , socket _ flags . none , pipe _ remote _ receive _ callback , session ) ; try _ read _ available _ data ( ) ; logger . trace ( $ STR ) ; send _ to _ server ( first _ packet _ length , session ) ; } catch ( exception e ) {
logger . trace ( $ STR ) ; send _ to _ server ( first _ packet _ length , session ) ; } catch ( exception e ) { logger . log _ useful _ exception ( e ) ; close ( ) ; } } private void pipe _ remote _ receive _ callback ( i _ async _ result ar ) {
} private void pipe _ remote _ receive _ callback ( i _ async _ result ar ) { if ( closed ) return ; try { var session = ( async _ session ) ar . async _ state ; int bytes _ read = session . remote . end _ receive ( ar ) ; total _ read + = bytes _ read ;
} else { connection . shutdown ( socket _ shutdown . send ) ; connection _ shutdown = true ; check _ close ( ) ; } } catch ( exception e ) {
check _ close ( ) ; } } catch ( exception e ) { logger . log _ useful _ exception ( e ) ; close ( ) ; } } private void pipe _ connection _ receive _ callback ( i _ async _ result ar ) {
close ( ) ; } } private void pipe _ connection _ receive _ callback ( i _ async _ result ar ) { if ( closed ) return ; try { int bytes _ read = connection . end _ receive ( ar ) ;
{ encryptor . encrypt ( connetion _ recv _ buffer , length , connetion _ send _ buffer , out bytes _ to _ send ) ; } catch ( crypto _ error _ exception ) { logger . debug ( STR ) ; close ( ) ; return ; } }
{ logger . debug ( STR ) ; close ( ) ; return ; } } tcprelay . update _ outbound _ counter ( server , bytes _ to _ send ) ; start _ sending _ time = date _ time . now ; session . remote . begin _ send ( connetion _ send _ buffer , 0 , bytes _ to _ send , socket _ flags . none , pipe _ remote _ send _ callback , new object [ ] { session , bytes _ to _ send } ) ;
} } tcprelay . update _ outbound _ counter ( server , bytes _ to _ send ) ; start _ sending _ time = date _ time . now ; session . remote . begin _ send ( connetion _ send _ buffer , 0 , bytes _ to _ send , socket _ flags . none , pipe _ remote _ send _ callback , new object [ ] { session , bytes _ to _ send } ) ; i _ strategy strategy = controller . get _ current _ strategy ( ) ; strategy ? . update _ last _ write ( server ) ; } private void pipe _ remote _ send _ callback ( i _ async _ result ar ) {
buffer . block _ copy ( connetion _ send _ buffer , bytes _ sent , connetion _ send _ buffer , 0 , bytes _ remaining ) ; session . remote . begin _ send ( connetion _ send _ buffer , 0 , bytes _ remaining , socket _ flags . none , pipe _ remote _ send _ callback , new object [ ] { session , bytes _ remaining } ) ; return ; } connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , socket _ flags . none , pipe _ connection _ receive _ callback , session ) ; } catch ( exception e ) {
} catch ( exception e ) { logger . log _ useful _ exception ( e ) ; close ( ) ; } } private void pipe _ connection _ send _ callback ( i _ async _ result ar ) { try {
this . encryption _ label . size = new system . drawing . size ( NUM , NUM ) ; this . encryption _ label . tab _ index = NUM ; this . encryption _ label . text = STR ; this . encryption _ select . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( ( system . windows . forms . anchor _ styles . top | system . windows . forms . anchor _ styles . left ) | system . windows . forms . anchor _ styles . right ) ) ) ; this . encryption _ select . drop _ down _ style = system . windows . forms . combo _ box _ style . drop _ down _ list ; this . encryption _ select . formatting _ enabled = true ; this . encryption _ select . ime _ mode = system . windows . forms . ime _ mode . no _ control ; this . encryption _ select . item _ height = NUM ; this . encryption _ select . items . add _ range ( new object [ ] {
this . encryption _ select . formatting _ enabled = true ; this . encryption _ select . ime _ mode = system . windows . forms . ime _ mode . no _ control ; this . encryption _ select . item _ height = NUM ; this . encryption _ select . items . add _ range ( new object [ ] { STR , STR , STR , STR , STR , STR ,
thread t = new thread ( new thread _ start ( run _ single _ polar _ ssl _ encryption _ thread ) ) ; threads . add ( t ) ; t . start ( ) ; } foreach ( thread t in threads ) { t . join ( ) ; } assert . is _ false ( encryption _ failed ) ; }
{ t . join ( ) ; } assert . is _ false ( encryption _ failed ) ; } private static bool encryption _ failed = false ; private static object locker = new object ( ) ; private void run _ single _ polar _ ssl _ encryption _ thread ( ) { try {
protected override void dispose ( bool disposing ) { if ( disposing & & ( components ! = null ) ) { components . dispose ( ) ; } base . dispose ( disposing ) ; } private void initialize _ component ( ) {
components . dispose ( ) ; } base . dispose ( disposing ) ; } private void initialize _ component ( ) { this . table _ layout _ panel = new system . windows . forms . table _ layout _ panel ( ) ; this . table _ layout _ panel = new system . windows . forms . table _ layout _ panel ( ) ; this . my _ cancel _ button = new system . windows . forms . button ( ) ; this . ok _ button = new system . windows . forms . button ( ) ; this . use _ proxy _ check _ box = new system . windows . forms . check _ box ( ) ;
{ this . table _ layout _ panel = new system . windows . forms . table _ layout _ panel ( ) ; this . table _ layout _ panel = new system . windows . forms . table _ layout _ panel ( ) ; this . my _ cancel _ button = new system . windows . forms . button ( ) ; this . ok _ button = new system . windows . forms . button ( ) ; this . use _ proxy _ check _ box = new system . windows . forms . check _ box ( ) ; this . table _ layout _ panel = new system . windows . forms . table _ layout _ panel ( ) ; this . proxy _ addr _ label = new system . windows . forms . label ( ) ; this . proxy _ server _ text _ box = new system . windows . forms . text _ box ( ) ; this . proxy _ port _ label = new system . windows . forms . label ( ) ; this . proxy _ port _ text _ box = new system . windows . forms . text _ box ( ) ;
this . proxy _ port _ text _ box = new system . windows . forms . text _ box ( ) ; this . table _ layout _ panel = new system . windows . forms . table _ layout _ panel ( ) ; this . proxy _ type _ label = new system . windows . forms . label ( ) ; this . proxy _ type _ combo _ box = new system . windows . forms . combo _ box ( ) ; this . proxy _ timeout _ text _ box = new system . windows . forms . text _ box ( ) ; this . proxy _ timeout _ label = new system . windows . forms . label ( ) ; this . table _ layout _ panel . suspend _ layout ( ) ;
this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ; this . table _ layout _ panel . tab _ index = 0 ; this . table _ layout _ panel . auto _ size = true ; this . table _ layout _ panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . table _ layout _ panel . column _ count = 2 ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . my _ cancel _ button . dialog _ result = system . windows . forms . dialog _ result . cancel ;
this . my _ cancel _ button . dock = system . windows . forms . dock _ style . right ; this . my _ cancel _ button . location = new system . drawing . point ( NUM , NUM ) ; this . my _ cancel _ button . margin = new system . windows . forms . padding ( NUM , NUM , 0 , 0 ) ; this . my _ cancel _ button . name = STR ; this . my _ cancel _ button . size = new system . drawing . size ( NUM , NUM ) ; this . my _ cancel _ button . tab _ index = NUM ; this . my _ cancel _ button . text = STR ; this . my _ cancel _ button . use _ visual _ style _ back _ color = true ; this . my _ cancel _ button . click + = new system . event _ handler ( this . cancel _ button _ click ) ; this . ok _ button . dialog _ result = system . windows . forms . dialog _ result . ok ;
this . form _ border _ style = system . windows . forms . form _ border _ style . fixed _ single ; this . maximize _ box = false ; this . minimize _ box = false ; this . name = STR ; this . padding = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . start _ position = system . windows . forms . form _ start _ position . center _ screen ; this . text = STR ; this . form _ closed + = new system . windows . forms . form _ closed _ event _ handler ( this . proxy _ form _ form _ closed ) ; this . table _ layout _ panel . resume _ layout ( false ) ; this . table _ layout _ panel . perform _ layout ( ) ;
this . minimize _ box = false ; this . name = STR ; this . padding = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . start _ position = system . windows . forms . form _ start _ position . center _ screen ; this . text = STR ; this . form _ closed + = new system . windows . forms . form _ closed _ event _ handler ( this . proxy _ form _ form _ closed ) ; this . table _ layout _ panel . resume _ layout ( false ) ; this . table _ layout _ panel . perform _ layout ( ) ; this . table _ layout _ panel . resume _ layout ( false ) ; this . table _ layout _ panel . resume _ layout ( false ) ; this . table _ layout _ panel . perform _ layout ( ) ; this . table _ layout _ panel . resume _ layout ( false ) ; this . table _ layout _ panel . perform _ layout ( ) ; this . resume _ layout ( false ) ;
this . padding = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . start _ position = system . windows . forms . form _ start _ position . center _ screen ; this . text = STR ; this . form _ closed + = new system . windows . forms . form _ closed _ event _ handler ( this . proxy _ form _ form _ closed ) ; this . table _ layout _ panel . resume _ layout ( false ) ; this . table _ layout _ panel . perform _ layout ( ) ; this . table _ layout _ panel . resume _ layout ( false ) ; this . table _ layout _ panel . resume _ layout ( false ) ; this . table _ layout _ panel . perform _ layout ( ) ; this . table _ layout _ panel . resume _ layout ( false ) ; this . table _ layout _ panel . perform _ layout ( ) ; this . resume _ layout ( false ) ; this . perform _ layout ( ) ; }
this . text = STR ; this . form _ closed + = new system . windows . forms . form _ closed _ event _ handler ( this . proxy _ form _ form _ closed ) ; this . table _ layout _ panel . resume _ layout ( false ) ; this . table _ layout _ panel . perform _ layout ( ) ; this . table _ layout _ panel . resume _ layout ( false ) ; this . table _ layout _ panel . resume _ layout ( false ) ; this . table _ layout _ panel . perform _ layout ( ) ; this . table _ layout _ panel . resume _ layout ( false ) ; this . table _ layout _ panel . perform _ layout ( ) ; this . resume _ layout ( false ) ; this . perform _ layout ( ) ; } private system . windows . forms . table _ layout _ panel table _ layout _ panel ; private system . windows . forms . check _ box use _ proxy _ check _ box ;
this . resume _ layout ( false ) ; this . perform _ layout ( ) ; } private system . windows . forms . table _ layout _ panel table _ layout _ panel ; private system . windows . forms . check _ box use _ proxy _ check _ box ; private system . windows . forms . table _ layout _ panel table _ layout _ panel ; private system . windows . forms . label proxy _ addr _ label ; private system . windows . forms . text _ box proxy _ server _ text _ box ; private system . windows . forms . label proxy _ port _ label ; private system . windows . forms . text _ box proxy _ port _ text _ box ;
private system . windows . forms . table _ layout _ panel table _ layout _ panel ; private system . windows . forms . check _ box use _ proxy _ check _ box ; private system . windows . forms . table _ layout _ panel table _ layout _ panel ; private system . windows . forms . label proxy _ addr _ label ; private system . windows . forms . text _ box proxy _ server _ text _ box ; private system . windows . forms . label proxy _ port _ label ; private system . windows . forms . text _ box proxy _ port _ text _ box ; private system . windows . forms . table _ layout _ panel table _ layout _ panel ; private system . windows . forms . button my _ cancel _ button ; private system . windows . forms . button ok _ button ;
this . ok _ button = new system . windows . forms . button ( ) ; this . my _ cancel _ button = new system . windows . forms . button ( ) ; this . panel = new system . windows . forms . panel ( ) ; this . context _ menu = new system . windows . forms . context _ menu ( ) ; this . enable _ item = new system . windows . forms . menu _ item ( ) ; this . servers _ item = new system . windows . forms . menu _ item ( ) ; this . seperator _ item = new system . windows . forms . menu _ item ( ) ; this . config _ item = new system . windows . forms . menu _ item ( ) ; this . menu _ item = new system . windows . forms . menu _ item ( ) ; this . edit _ pac _ file _ item = new system . windows . forms . menu _ item ( ) ;
this . edit _ pac _ file _ item = new system . windows . forms . menu _ item ( ) ; this . qr _ code _ item = new system . windows . forms . menu _ item ( ) ; this . about _ item = new system . windows . forms . menu _ item ( ) ; this . menu _ item = new system . windows . forms . menu _ item ( ) ; this . quit _ item = new system . windows . forms . menu _ item ( ) ; this . panel = new system . windows . forms . panel ( ) ; this . delete _ button = new system . windows . forms . button ( ) ; this . add _ button = new system . windows . forms . button ( ) ; this . server _ group _ box = new system . windows . forms . group _ box ( ) ; this . servers _ list _ box = new system . windows . forms . list _ box ( ) ;
this . panel = new system . windows . forms . panel ( ) ; this . delete _ button = new system . windows . forms . button ( ) ; this . add _ button = new system . windows . forms . button ( ) ; this . server _ group _ box = new system . windows . forms . group _ box ( ) ; this . servers _ list _ box = new system . windows . forms . list _ box ( ) ; this . lock _ button = new system . windows . forms . button ( ) ; this . panel = new system . windows . forms . panel ( ) ; this . table _ layout _ panel . suspend _ layout ( ) ; this . panel . suspend _ layout ( ) ; this . panel . suspend _ layout ( ) ; this . server _ group _ box . suspend _ layout ( ) ;

this . cancel _ button = this . my _ cancel _ button ; this . client _ size = new system . drawing . size ( NUM , NUM ) ;
this . controls . add ( this . server _ group _ box ) ; this . controls . add ( this . panel ) ; this . controls . add ( this . panel ) ; this . controls . add ( this . panel ) ; this . form _ border _ style = system . windows . forms . form _ border _ style . fixed _ single ; this . icon = ( ( system . drawing . icon ) ( resources . get _ object ( STR ) ) ) ; this . maximize _ box = false ; this . name = STR ; this . start _ position = system . windows . forms . form _ start _ position . center _ screen ; this . text = STR ;
this . top _ most = true ; this . form _ closed + = new system . windows . forms . form _ closed _ event _ handler ( this . config _ form _ form _ closed ) ; this . load + = new system . event _ handler ( this . config _ form _ load ) ; this . shown + = new system . event _ handler ( this . config _ form _ shown ) ; this . table _ layout _ panel . resume _ layout ( false ) ; this . table _ layout _ panel . perform _ layout ( ) ; this . panel . resume _ layout ( false ) ; this . panel . resume _ layout ( false ) ; this . server _ group _ box . resume _ layout ( false ) ; this . server _ group _ box . perform _ layout ( ) ;
} items . add ( seperator _ item ) ; items . add ( config _ item ) ; if ( configuration . index > = 0 & & configuration . index < configuration . configs . count ) { items [ configuration . index ] . checked = true ; } } private void config _ form _ load ( object sender , event _ args e ) {
} private void config _ form _ load ( object sender , event _ args e ) { if ( controller = = null | | controller . get _ configuration ( ) . is _ default ) { is _ first _ run = true ; } else {
{ server = ( server ) obj ; return server = = . server & & server _ port = = . server _ port ; } public string friendly _ name ( ) { if ( server . is _ null _ or _ empty ( ) ) { return n . get _ string ( STR ) ; }
} public string friendly _ name ( ) { if ( server . is _ null _ or _ empty ( ) ) { return n . get _ string ( STR ) ; } ip _ address addr ; if ( ! ip _ address . try _ parse ( server , out addr ) ) { logging . error ( STR ) ; }
{ return n . get _ string ( STR ) ; } ip _ address addr ; if ( ! ip _ address . try _ parse ( server , out addr ) ) { logging . error ( STR ) ; } return $ STR ; } } else { switch ( addr . address _ family ) { case address _ family . inter _ network : return $ STR ; case address _ family . inter _ network : return $ STR ; } }

top _ most _ trigger = config . top _ most ; wrap _ text _ trigger = config . wrap _ text ; toolbar _ trigger = config . toolbar _ shown ; log _ message _ text _ box . back _ color = config . get _ background _ color ( ) ; log _ message _ text _ box . fore _ color = config . get _ text _ color ( ) ; log _ message _ text _ box . font = config . get _ font ( ) ; } controller . traffic _ changed + = controller _ traffic _ changed ; update _ texts ( ) ; }
log _ message _ text _ box . fore _ color = config . get _ text _ color ( ) ; log _ message _ text _ box . font = config . get _ font ( ) ; } controller . traffic _ changed + = controller _ traffic _ changed ; update _ texts ( ) ; } private void controller _ traffic _ changed ( object sender , event _ args e ) { long max _ speed = 0 ;
outbound _ points . clear ( ) ; foreach ( var traffic _ per _ second in controller . traffic ) { inbound _ points . add ( traffic _ per _ second . inbound _ increasement ) ; outbound _ points . add ( traffic _ per _ second . outbound _ increasement ) ; max _ speed = math . max ( max _ speed , math . max ( traffic _ per _ second . inbound _ increasement , traffic _ per _ second . outbound _ increasement ) ) ; } bandwidth _ scale = utils . get _ bandwidth _ scale ( max _ speed ) ; inbound _ points = inbound _ points . select ( p = > p / bandwidth _ scale . item ) . to _ list ( ) ; outbound _ points = outbound _ points . select ( p = > p / bandwidth _ scale . item ) . to _ list ( ) ;
this . plugin _ options _ label . auto _ size = true ; this . plugin _ options _ label . location = new system . drawing . point ( NUM , NUM ) ; this . plugin _ options _ label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ; this . plugin _ options _ label . name = STR ; this . plugin _ options _ label . size = new system . drawing . size ( NUM , NUM ) ; this . plugin _ options _ label . tab _ index = NUM ; this . plugin _ options _ label . text = STR ; this . tool _ tip . set _ tool _ tip ( this . plugin _ options _ label , STR ) ; this . plugin _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . plugin _ text _ box . location = new system . drawing . point ( NUM , NUM ) ;
this . plugin _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . plugin _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . plugin _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . plugin _ text _ box . max _ length = NUM ; this . plugin _ text _ box . name = STR ; this . plugin _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . plugin _ text _ box . tab _ index = NUM ; this . plugin _ text _ box . word _ wrap = false ; this . remarks _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . remarks _ text _ box . location = new system . drawing . point ( NUM , NUM ) ;
this . password _ label . auto _ size = true ; this . password _ label . location = new system . drawing . point ( NUM , NUM ) ; this . password _ label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ; this . password _ label . name = STR ; this . password _ label . size = new system . drawing . size ( NUM , NUM ) ; this . password _ label . tab _ index = 2 ; this . password _ label . text = STR ; this . password _ label . text _ align = system . drawing . content _ alignment . middle _ center ; this . ip _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . ip _ text _ box . location = new system . drawing . point ( NUM , NUM ) ;
this . ip _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . ip _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . ip _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . ip _ text _ box . max _ length = NUM ; this . ip _ text _ box . name = STR ; this . ip _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . ip _ text _ box . tab _ index = 0 ; this . ip _ text _ box . word _ wrap = false ; this . server _ port _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . server _ port _ text _ box . location = new system . drawing . point ( NUM , NUM ) ;
this . server _ port _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . server _ port _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . server _ port _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . server _ port _ text _ box . max _ length = NUM ; this . server _ port _ text _ box . name = STR ; this . server _ port _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . server _ port _ text _ box . tab _ index = 1 ; this . server _ port _ text _ box . word _ wrap = false ; this . password _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . password _ text _ box . location = new system . drawing . point ( NUM , NUM ) ;
this . plugin _ label . anchor = system . windows . forms . anchor _ styles . right ; this . plugin _ label . auto _ size = true ; this . plugin _ label . location = new system . drawing . point ( NUM , NUM ) ; this . plugin _ label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ; this . plugin _ label . name = STR ; this . plugin _ label . size = new system . drawing . size ( NUM , NUM ) ; this . plugin _ label . tab _ index = NUM ; this . plugin _ label . text = STR ; this . plugin _ options _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . plugin _ options _ text _ box . location = new system . drawing . point ( NUM , NUM ) ;
this . plugin _ options _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . plugin _ options _ text _ box . max _ length = NUM ; this . plugin _ options _ text _ box . name = STR ; this . plugin _ options _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . plugin _ options _ text _ box . tab _ index = NUM ; this . plugin _ options _ text _ box . word _ wrap = false ; this . show _ passwd _ check _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( ( system . windows . forms . anchor _ styles . top | system . windows . forms . anchor _ styles . bottom ) | system . windows . forms . anchor _ styles . left ) ) ) ; this . show _ passwd _ check _ box . auto _ size = true ; this . show _ passwd _ check _ box . location = new system . drawing . point ( NUM , NUM ) ;
this . show _ passwd _ check _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . show _ passwd _ check _ box . name = STR ; this . show _ passwd _ check _ box . size = new system . drawing . size ( NUM , NUM ) ; this . show _ passwd _ check _ box . tab _ index = NUM ; this . show _ passwd _ check _ box . text = STR ; this . show _ passwd _ check _ box . text _ align = system . drawing . content _ alignment . middle _ center ; this . show _ passwd _ check _ box . use _ visual _ style _ back _ color = true ; this . show _ passwd _ check _ box . checked _ changed + = new system . event _ handler ( this . show _ passwd _ check _ box _ checked _ changed ) ; this . plugin _ arguments _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . plugin _ arguments _ text _ box . location = new system . drawing . point ( NUM , NUM ) ;
this . table _ layout _ panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . table _ layout _ panel . column _ count = 2 ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . controls . add ( this . proxy _ port _ text _ box , 1 , 0 ) ; this . table _ layout _ panel . controls . add ( this . proxy _ port _ label , 0 , 0 ) ; this . table _ layout _ panel . controls . add ( this . portable _ mode _ check _ box , 0 , 1 ) ; this . table _ layout _ panel . location = new system . drawing . point ( NUM , NUM ) ; this . table _ layout _ panel . margin = new system . windows . forms . padding ( 0 ) ; this . table _ layout _ panel . name = STR ;
this . table _ layout _ panel . margin = new system . windows . forms . padding ( 0 ) ; this . table _ layout _ panel . name = STR ; this . table _ layout _ panel . padding = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . table _ layout _ panel . row _ count = 2 ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ; this . table _ layout _ panel . tab _ index = NUM ; this . proxy _ port _ text _ box . anchor = system . windows . forms . anchor _ styles . left ; this . proxy _ port _ text _ box . location = new system . drawing . point ( NUM , NUM ) ;
using system _ threading _ tasks ; using newtonsoft _ json ; using shadowsocks _ model ; using shadowsocks _ util ; namespace shadowsocks _ controller { using statistics = dictionary < string , list < statistics _ record > > ; public sealed class availability _ statistics : i _ disposable { public const string date _ time _ pattern = STR ;
using statistics = dictionary < string , list < statistics _ record > > ; public sealed class availability _ statistics : i _ disposable { public const string date _ time _ pattern = STR ; public static readonly date _ time unknown _ date _ time ; private const string statistics _ files _ name = STR ; public static string availability _ statistics _ file ; static availability _ statistics ( ) { availability _ statistics _ file = utils . get _ temp _ path ( statistics _ files _ name ) ;
this . chart _ mode _ selector . controls . add ( this . day _ mode ) ; this . chart _ mode _ selector . location = new system . drawing . point ( NUM , NUM ) ; this . chart _ mode _ selector . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . chart _ mode _ selector . name = STR ; this . chart _ mode _ selector . padding = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . chart _ mode _ selector . size = new system . drawing . size ( NUM , NUM ) ; this . chart _ mode _ selector . tab _ index = NUM ; this . chart _ mode _ selector . tab _ stop = false ; this . chart _ mode _ selector . text = STR ; this . all _ mode . auto _ size = true ;
this . chart _ mode _ selector . tab _ index = NUM ; this . chart _ mode _ selector . tab _ stop = false ; this . chart _ mode _ selector . text = STR ; this . all _ mode . auto _ size = true ; this . all _ mode . checked = true ; this . all _ mode . location = new system . drawing . point ( NUM , NUM ) ; this . all _ mode . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . all _ mode . name = STR ; this . all _ mode . size = new system . drawing . size ( NUM , NUM ) ; this . all _ mode . tab _ index = 1 ;
this . split _ container . splitter _ width = NUM ; this . split _ container . tab _ index = NUM ; this . label . auto _ size = true ; this . label . location = new system . drawing . point ( NUM , NUM ) ; this . label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ; this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ; this . label . tab _ index = NUM ; this . label . text = STR ; this . label . auto _ size = true ;
this . split _ container . size = new system . drawing . size ( NUM , NUM ) ; this . split _ container . splitter _ distance = NUM ; this . split _ container . splitter _ width = NUM ; this . split _ container . tab _ index = NUM ; this . label . auto _ size = true ; this . label . location = new system . drawing . point ( NUM , NUM ) ; this . label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ; this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ; this . label . tab _ index = 0 ;
using shadowsocks _ encryption ; using shadowsocks _ model ; namespace shadowsocks _ controller { class tcp _ relay : listener . service { private shadowsocks _ controller controller ; private date _ time last _ sweep _ time ; public i _ set < tcp _ handler > handlers { get ; set ; }
handlers = new hash _ set < tcp _ handler > ( ) ; last _ sweep _ time = date _ time . now ; } public bool handle ( byte [ ] first _ packet , int length , socket socket , object state ) { if ( socket . protocol _ type ! = protocol _ type . tcp | | ( length < 2 | | first _ packet [ 0 ] ! = NUM ) ) return false ; socket . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ;
private bool connection _ shutdown = false ; private bool remote _ shutdown = false ; private bool closed = false ; private object encryption _ lock = new object ( ) ; private object decryption _ lock = new object ( ) ; private date _ time start _ connect _ time ; private date _ time start _ receiving _ time ; private date _ time start _ sending _ time ; private int bytes _ to _ send ; private tcp _ relay tcprelay ;
if ( bytes _ read > 0 ) { int atyp = connetion _ recv _ buffer [ 0 ] ; string dst _ addr ; int dst _ port ; switch ( atyp ) { case 1 : dst _ addr = new ip _ address ( connetion _ recv _ buffer . skip ( 1 ) . take ( NUM ) . to _ array ( ) ) . to _ string ( ) ; dst _ port = ( connetion _ recv _ buffer [ NUM ] < < NUM ) + connetion _ recv _ buffer [ NUM ] ;
dst _ addr = new ip _ address ( connetion _ recv _ buffer . skip ( 1 ) . take ( NUM ) . to _ array ( ) ) . to _ string ( ) ; dst _ port = ( connetion _ recv _ buffer [ NUM ] < < NUM ) + connetion _ recv _ buffer [ NUM ] ; if ( controller . get _ current _ configuration ( ) . is _ verbose _ logging ) { logging . info ( $ STR ) ; } break ; case NUM : int len = connetion _ recv _ buffer [ 1 ] ; dst _ addr = system . text . encoding . ut . get _ string ( connetion _ recv _ buffer , 2 , len ) ; dst _ port = ( connetion _ recv _ buffer [ len + 2 ] < < NUM ) + connetion _ recv _ buffer [ len + NUM ] ;
int len = connetion _ recv _ buffer [ 1 ] ; dst _ addr = system . text . encoding . ut . get _ string ( connetion _ recv _ buffer , 2 , len ) ; dst _ port = ( connetion _ recv _ buffer [ len + 2 ] < < NUM ) + connetion _ recv _ buffer [ len + NUM ] ; if ( controller . get _ current _ configuration ( ) . is _ verbose _ logging ) { logging . info ( $ STR ) ; } break ; case NUM : dst _ addr = new ip _ address ( connetion _ recv _ buffer . skip ( 1 ) . take ( NUM ) . to _ array ( ) ) . to _ string ( ) ; dst _ port = ( connetion _ recv _ buffer [ NUM ] < < NUM ) + connetion _ recv _ buffer [ NUM ] ;

{ is _ update _ pac _ from _ gfw _ list _ running = false ; notify _ icon . balloon _ tip _ title = n . get _ string ( STR ) ; notify _ icon . balloon _ tip _ text = n . get _ string ( STR ) ; notify _ icon . balloon _ tip _ icon = tool _ tip _ icon . info ; notify _ icon . show _ balloon _ tip ( NUM ) ; logging . log _ useful _ exception ( e . get _ exception ( ) ) ; } void controller _ update _ pac _ from _ gfw _ list _ completed ( object sender , event _ args e ) {
notify _ icon . balloon _ tip _ icon = tool _ tip _ icon . info ; notify _ icon . show _ balloon _ tip ( NUM ) ; logging . log _ useful _ exception ( e . get _ exception ( ) ) ; } void controller _ update _ pac _ from _ gfw _ list _ completed ( object sender , event _ args e ) { is _ update _ pac _ from _ gfw _ list _ running = false ; notify _ icon . balloon _ tip _ title = n . get _ string ( STR ) ; notify _ icon . balloon _ tip _ text = n . get _ string ( STR ) ; notify _ icon . balloon _ tip _ icon = tool _ tip _ icon . info ; notify _ icon . show _ balloon _ tip ( NUM ) ; } void update _ checker _ new _ version _ found ( object sender , event _ args e ) {
logging . log _ useful _ exception ( e . get _ exception ( ) ) ; } void controller _ update _ pac _ from _ gfw _ list _ completed ( object sender , event _ args e ) { is _ update _ pac _ from _ gfw _ list _ running = false ; notify _ icon . balloon _ tip _ title = n . get _ string ( STR ) ; notify _ icon . balloon _ tip _ text = n . get _ string ( STR ) ; notify _ icon . balloon _ tip _ icon = tool _ tip _ icon . info ; notify _ icon . show _ balloon _ tip ( NUM ) ; } void update _ checker _ new _ version _ found ( object sender , event _ args e ) { notify _ icon . balloon _ tip _ title = string . format ( n . get _ string ( STR ) , update _ checker . latest _ version _ number ) ; notify _ icon . balloon _ tip _ text = n . get _ string ( STR ) ; notify _ icon . balloon _ tip _ icon = tool _ tip _ icon . info ; notify _ icon . balloon _ tip _ clicked + = notify _ icon _ balloon _ tip _ clicked ;
public server server ; public server _ timer ( int p ) : base ( p ) { } } private void start _ connect ( ) { try { create _ remote ( ) ; i _ proxy remote ; end _ point proxy _ ep ;
private void start _ connect ( ) { try { create _ remote ( ) ; i _ proxy remote ; end _ point proxy _ ep ; if ( config . use _ proxy ) { remote = new socks _ proxy ( ) ;
{ config . share _ over _ lan = enabled ; save _ config ( config ) ; if ( share _ over _ lan _ status _ changed ! = null ) { share _ over _ lan _ status _ changed ( this , new event _ args ( ) ) ; } } public void disable _ proxy ( ) {
share _ over _ lan _ status _ changed ( this , new event _ args ( ) ) ; } } public void disable _ proxy ( ) { config . use _ proxy = false ; save _ config ( config ) ; } public void enable _ proxy ( string proxy , int port ) {
using system _ text ; using system _ text _ regular _ expressions ; using system _ web ; using shadowsocks _ controller ; namespace shadowsocks _ model { serializable public class server { public static readonly regex
using system _ web ; using shadowsocks _ controller ; namespace shadowsocks _ model { serializable public class server { public static readonly regex url _ finder = new regex ( STR , regex _ options . ignore _ case | regex _ options . compiled ) , details _ parser = new regex ( STR +
private void ok _ button _ click ( object sender , event _ args e ) { if ( use _ proxy _ check _ box . checked ) { try {
message _ box . show ( ex . message ) ; return ; } } else { controller . disable _ proxy ( ) ; } modified _ configuration . use _ proxy = use _ proxy _ check _ box . checked ;
ip _ text _ box . focus ( ) ; } private bool save _ old _ selected _ server ( ) { try { if ( last _ selected _ index = = - 1 | | last _ selected _ index > = modified _ configuration . configs . count ) { return true ; }
remarks = remarks _ text _ box . text , timeout = int . parse ( timeout _ text _ box . text ) , auth = one _ time _ auth . checked } ; int local _ port = int . parse ( proxy _ port _ text _ box . text ) ; configuration . check _ server ( server ) ; configuration . check _ local _ port ( local _ port ) ; modified _ configuration . configs [ last _ selected _ index ] = server ; modified _ configuration . local _ port = local _ port ; return true ;
protected override void dispose ( bool disposing ) { if ( disposing & & ( components ! = null ) ) { components . dispose ( ) ; } base . dispose ( disposing ) ; } private void initialize _ component ( ) {
base . dispose ( disposing ) ; } private void initialize _ component ( ) { this . qr _ code _ web _ browser = new system . windows . forms . web _ browser ( ) ; this . picture _ box = new system . windows . forms . picture _ box ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . picture _ box ) ) . begin _ init ( ) ; this . suspend _ layout ( ) ;
} private void initialize _ component ( ) { this . qr _ code _ web _ browser = new system . windows . forms . web _ browser ( ) ; this . picture _ box = new system . windows . forms . picture _ box ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . picture _ box ) ) . begin _ init ( ) ; this . suspend _ layout ( ) ; | system . windows . forms . anchor _ styles . left ) | system . windows . forms . anchor _ styles . right ) ) ) ; this . qr _ code _ web _ browser . location = new system . drawing . point ( 0 , 0 ) ; this . qr _ code _ web _ browser . margin = new system . windows . forms . padding ( 0 ) ; this . qr _ code _ web _ browser . minimum _ size = new system . drawing . size ( NUM , NUM ) ; this . qr _ code _ web _ browser . name = STR ; this . qr _ code _ web _ browser . script _ errors _ suppressed = true ; this . qr _ code _ web _ browser . scroll _ bars _ enabled = false ; this . qr _ code _ web _ browser . size = new system . drawing . size ( NUM , NUM ) ; this . qr _ code _ web _ browser . tab _ index = 0 ;
this . qr _ code _ web _ browser = new system . windows . forms . web _ browser ( ) ; this . picture _ box = new system . windows . forms . picture _ box ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . picture _ box ) ) . begin _ init ( ) ; this . suspend _ layout ( ) ; this . qr _ code _ web _ browser . margin = new system . windows . forms . padding ( 0 ) ; this . qr _ code _ web _ browser . minimum _ size = new system . drawing . size ( NUM , NUM ) ; this . qr _ code _ web _ browser . name = STR ; this . qr _ code _ web _ browser . script _ errors _ suppressed = true ; this . qr _ code _ web _ browser . scroll _ bars _ enabled = false ; this . qr _ code _ web _ browser . size = new system . drawing . size ( NUM , NUM ) ; this . qr _ code _ web _ browser . tab _ index = 0 ; this . picture _ box . location = new system . drawing . point ( 0 , 0 ) ; this . picture _ box . name = STR ;

this . maximize _ box = false ; this . minimize _ box = false ; this . name = STR ; this . start _ position = system . windows . forms . form _ start _ position . center _ screen ; this . text = STR ; this . load + = new system . event _ handler ( this . qr _ code _ form _ load ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . picture _ box ) ) . end _ init ( ) ; this . resume _ layout ( false ) ; }
private bool connection _ shutdown = false ; private bool remote _ shutdown = false ; private bool closed = false ; private readonly object encryption _ lock = new object ( ) ; private readonly object decryption _ lock = new object ( ) ; private readonly object close _ conn _ lock = new object ( ) ; private date _ time start _ connect _ time ; private date _ time start _ receiving _ time ; private date _ time start _ sending _ time ; private end _ point dest _ end _ point = null ;
private readonly object decryption _ lock = new object ( ) ; private readonly object close _ conn _ lock = new object ( ) ; private date _ time start _ connect _ time ; private date _ time start _ receiving _ time ; private date _ time start _ sending _ time ; private end _ point dest _ end _ point = null ; public tcp _ handler ( shadowsocks _ controller controller , configuration config , tcp _ relay tcprelay , socket socket ) { controller = controller ; config = config ;
config . configs = servers ; config . local _ port = local _ port ; config . portable _ mode = portable _ mode ; configuration . save ( config ) ; } public void save _ strategy _ configurations ( statistics _ strategy _ configuration configuration ) { statistics _ configuration = configuration ; statistics _ strategy _ configuration . save ( configuration ) ; }
public void save _ strategy _ configurations ( statistics _ strategy _ configuration configuration ) { statistics _ configuration = configuration ; statistics _ strategy _ configuration . save ( configuration ) ; } public void ask _ add _ server _ by _ ssurl ( string ss _ url ) { var dr = message _ box . show ( n . get _ string ( STR , ss _ url ) , n . get _ string ( STR ) , message _ box _ buttons . yes _ no ) ; if ( dr = = dialog _ result . yes ) {
{ if ( update _ pac _ from _ gfw _ list _ error ! = null ) update _ pac _ from _ gfw _ list _ error ( this , e ) ; } private static readonly i _ enumerable < char > ignored _ line _ begins = new [ ] { '!' , '[' } ; private void pac _ server _ user _ rule _ file _ changed ( object sender , event _ args e ) { if ( ! file . exists ( utils . get _ temp _ path ( STR ) ) ) { update _ pac _ from _ gfw _ list ( ) ;
private static readonly i _ enumerable < char > ignored _ line _ begins = new [ ] { '!' , '[' } ; private void pac _ server _ user _ rule _ file _ changed ( object sender , event _ args e ) { if ( ! file . exists ( utils . get _ temp _ path ( STR ) ) ) { update _ pac _ from _ gfw _ list ( ) ; } } lines . add _ range ( gfw _ list _ updater . parse _ result ( file _ manager . non _ exclusive _ read _ all _ text ( utils . get _ temp _ path ( STR ) ) ) ) ; string abp _ content ; if ( file . exists ( pac _ server . user _ abp _ file ) ) { abp _ content = file _ manager . non _ exclusive _ read _ all _ text ( pac _ server . user _ abp _ file , encoding . ut ) ; } else {
{ this . success = success ; } } private static readonly i _ enumerable < char > ignored _ line _ begins = new [ ] { '!' , '[' } ; private void http _ download _ string _ completed ( object sender , download _ string _ completed _ event _ args e ) { try { file . write _ all _ text ( utils . get _ temp _ path ( STR ) , e . result , encoding . ut ) ;
public socket connection ; public shadowsocks _ controller controller ; public tcp _ relay relay ; public date _ time last _ activity ; private int retry _ count = 0 ; private bool connected ; private byte command ; private byte [ ] first _ packet ; private int first _ packet _ length ; public const int recv _ size = NUM ;
private int retry _ count = 0 ; private bool connected ; private byte command ; private byte [ ] first _ packet ; private int first _ packet _ length ; public const int recv _ size = NUM ; public const int buffer _ size = recv _ size + ( recv _ size / iv _ encryptor . crc _ buf _ len + 1 ) * iv _ encryptor . crc _ bytes + NUM ; private int total _ read = 0 ; private int total _ write = 0 ;
private byte command ; private byte [ ] first _ packet ; private int first _ packet _ length ; public const int recv _ size = NUM ; public const int buffer _ size = recv _ size + ( recv _ size / iv _ encryptor . crc _ buf _ len + 1 ) * iv _ encryptor . crc _ bytes + NUM ; private int total _ read = 0 ; private int total _ write = 0 ; private byte [ ] remote _ recv _ buffer = new byte [ recv _ size ] ; private byte [ ] remote _ send _ buffer = new byte [ buffer _ size ] ;
} private bool save _ old _ selected _ server ( ) { try { if ( last _ selected _ index = = - 1 | | last _ selected _ index > = modified _ configuration . configs . count ) { return true ; } server server = new server ( ) ;
} server server = new server ( ) ; server . server = ip _ text _ box . text . trim ( ) ; try { server . server _ port = int . parse ( server _ port _ text _ box . text ) ; } catch ( format _ exception ) { message _ box . show ( n . get _ string ( STR ) ) ;
} catch ( format _ exception ) { message _ box . show ( n . get _ string ( STR ) ) ; server _ port _ text _ box . clear ( ) ; return false ; } server . password = password _ text _ box . text ; server . method = encryption _ select . text ; server . remarks = remarks _ text _ box . text ;
message _ box . show ( n . get _ string ( STR ) ) ; server _ port _ text _ box . clear ( ) ; return false ; } server . password = password _ text _ box . text ; server . method = encryption _ select . text ; server . remarks = remarks _ text _ box . text ; try { server . timeout = int . parse ( timeout _ text _ box . text ) ; } catch ( format _ exception ) { message _ box . show ( n . get _ string ( STR ) ) ;
private date _ time last _ sweep _ time ; public i _ set < tcp _ handler > handlers { get ; set ; } public tcp _ relay ( shadowsocks _ controller controller ) { controller = controller ; handlers = new hash _ set < tcp _ handler > ( ) ; last _ sweep _ time = date _ time . now ; } public bool handle ( byte [ ] first _ packet , int length , socket socket , object state ) {
public tcp _ relay ( shadowsocks _ controller controller ) { controller = controller ; handlers = new hash _ set < tcp _ handler > ( ) ; last _ sweep _ time = date _ time . now ; } public bool handle ( byte [ ] first _ packet , int length , socket socket , object state ) { if ( socket . protocol _ type ! = protocol _ type . tcp ) { return false ;
private bool closed = false ; private object encryption _ lock = new object ( ) ; private object decryption _ lock = new object ( ) ; private date _ time start _ connect _ time ; private date _ time start _ receiving _ time ; private date _ time start _ sending _ time ; private int bytes _ to _ send ; private tcp _ relay tcprelay ; public tcp _ handler ( tcp _ relay tcprelay ) {
private int bytes _ to _ send ; private tcp _ relay tcprelay ; public tcp _ handler ( tcp _ relay tcprelay ) { this . tcprelay = tcprelay ; } public void create _ remote ( ) { server server = controller . get _ a _ server ( i _ strategy _ caller _ type . tcp , ( ip _ end _ point ) connection . remote _ end _ point ) ; if ( server = = null | | server . server = = STR )
public tcp _ handler ( tcp _ relay tcprelay ) { this . tcprelay = tcprelay ; } public void create _ remote ( ) { server server = controller . get _ a _ server ( i _ strategy _ caller _ type . tcp , ( ip _ end _ point ) connection . remote _ end _ point ) ; if ( server = = null | | server . server = = STR ) { throw new argument _ exception ( STR ) ;
} public void close ( ) { lock ( tcprelay . handlers ) { tcprelay . handlers . remove ( this ) ; } lock ( this ) { if ( closed )
{ lock ( tcprelay . handlers ) { tcprelay . handlers . remove ( this ) ; } lock ( this ) { if ( closed ) { return ;
} catch ( exception e ) { logging . log _ useful _ exception ( e ) ; } } lock ( encryption _ lock ) { lock ( decryption _ lock ) {
lock ( encryption _ lock ) { lock ( decryption _ lock ) { if ( encryptor ! = null ) { ( ( i _ disposable ) encryptor ) . dispose ( ) ; } } } } private void handshake _ receive ( ) {
{ byte [ ] response = { NUM , 0 } ; if ( first _ packet [ 0 ] ! = NUM ) { response = new byte [ ] { 0 , NUM } ; logging . error ( STR ) ; } connection . begin _ send ( response , 0 , response . length , 0 , new async _ callback ( handshake _ send _ callback ) , null ) ; } else
if ( first _ packet [ 0 ] ! = NUM ) { response = new byte [ ] { 0 , NUM } ; logging . error ( STR ) ; } connection . begin _ send ( response , 0 , response . length , 0 , new async _ callback ( handshake _ send _ callback ) , null ) ; } else { close ( ) ;
} } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; } } private void handshake _ send _ callback ( i _ async _ result ar ) {
int bytes _ read = connection . end _ receive ( ar ) ; if ( bytes _ read > = NUM ) { command = connetion _ recv _ buffer [ 1 ] ; if ( command = = 1 ) { byte [ ] response = { NUM , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 } ; connection . begin _ send ( response , 0 , response . length , 0 , new async _ callback ( response _ callback ) , null ) ; } else if ( command = = NUM )
{ command = connetion _ recv _ buffer [ 1 ] ; if ( command = = 1 ) { byte [ ] response = { NUM , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 } ; connection . begin _ send ( response , 0 , response . length , 0 , new async _ callback ( response _ callback ) , null ) ; } else if ( command = = NUM ) { handle _ udp _ associate ( ) ;
close ( ) ; } } private void handle _ udp _ associate ( ) { ip _ end _ point end _ point = ( ip _ end _ point ) connection . local _ end _ point ; byte [ ] address = end _ point . address . get _ address _ bytes ( ) ; int port = end _ point . port ; byte [ ] response = new byte [ NUM + address . length + 2 ] ; response [ 0 ] = NUM ;
{ response [ NUM ] = NUM ; } address . copy _ to ( response , NUM ) ; response [ response . length - 1 ] = ( byte ) ( port & 0 xff ) ; response [ response . length - 2 ] = ( byte ) ( ( port > > NUM ) & 0 xff ) ; connection . begin _ send ( response , 0 , response . length , 0 , new async _ callback ( read _ all ) , true ) ; } private void read _ all ( i _ async _ result ar ) {
} else { int bytes _ read = connection . end _ receive ( ar ) ; if ( bytes _ read > 0 ) { logging . debug ( remote , recv _ size , STR ) ; connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , 0 , new async _ callback ( read _ all ) , null ) ; } else
{ int bytes _ read = connection . end _ receive ( ar ) ; if ( bytes _ read > 0 ) { logging . debug ( remote , recv _ size , STR ) ; connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , 0 , new async _ callback ( read _ all ) , null ) ; } else { close ( ) ;
remote . begin _ connect ( remote _ ep , new async _ callback ( connect _ callback ) , connect _ timer ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; } } private void connect _ timer _ elapsed ( object sender , elapsed _ event _ args e ) {
{ logging . log _ useful _ exception ( e ) ; close ( ) ; } } private void connect _ timer _ elapsed ( object sender , elapsed _ event _ args e ) { if ( connected ) { return ; } server server = ( ( server _ timer ) sender ) . server ; i _ strategy strategy = controller . get _ current _ strategy ( ) ;
} private void retry _ connect ( ) { if ( retry _ count < max _ retry ) { logging . debug ( $ STR ) ; start _ connect ( ) ; retry _ count + + ; } else
start _ connect ( ) ; retry _ count + + ; } else { close ( ) ; } } private void connect _ callback ( i _ async _ result ar ) {
{ close ( ) ; } } private void connect _ callback ( i _ async _ result ar ) { server server = null ; if ( closed ) { return ; } try { server _ timer timer = ( server _ timer ) ar . async _ state ;
start _ pipe ( ) ; } catch ( argument _ exception ) { } catch ( exception e ) { if ( server ! = null ) { i _ strategy strategy = controller . get _ current _ strategy ( ) ;
{ i _ strategy strategy = controller . get _ current _ strategy ( ) ; { strategy . set _ failure ( server ) ; } } logging . log _ useful _ exception ( e ) ; retry _ connect ( ) ; } } private void start _ pipe ( ) {
{ int bytes _ read = remote . end _ receive ( ar ) ; total _ read + = bytes _ read ; tcprelay . update _ inbound _ counter ( server , bytes _ read ) ; if ( bytes _ read > 0 ) { last _ activity = date _ time . now ; int bytes _ to _ send ; lock ( decryption _ lock ) {
{ last _ activity = date _ time . now ; int bytes _ to _ send ; lock ( decryption _ lock ) { if ( closed ) { return ; } encryptor . decrypt ( remote _ recv _ buffer , bytes _ read , remote _ send _ buffer , out bytes _ to _ send ) ; } connection . begin _ send ( remote _ send _ buffer , 0 , bytes _ to _ send , 0 , new async _ callback ( pipe _ connection _ send _ callback ) , null ) ; i _ strategy strategy = controller . get _ current _ strategy ( ) ;
* / public void choose _ new _ server ( ) { list < server _ status > servers = new list < server _ status > ( server _ status . values ) ; date _ time now = date _ time . now ; foreach ( var status in servers ) { status . score = NUM * NUM * math . min ( NUM * NUM , ( now - status . last _ failure ) . total _ seconds )
public static list < server > get _ servers ( string ss _ url ) {
} string line = STR ; while ( ( line = reader . read _ line ( ) ) ! = null ) log _ message _ text _ box . append _ text ( line + environment . new _ line ) ; log _ message _ text _ box . scroll _ to _ caret ( ) ; last _ offset = reader . base _ stream . position ; } } private void update _ content ( ) {
file _ mode . open , file _ access . read , file _ share . read _ write ) ) ) { reader . base _ stream . seek ( last _ offset , seek _ origin . begin ) ; string line = STR ; bool changed = false ; while ( ( line = reader . read _ line ( ) ) ! = null ) { changed = true ; log _ message _ text _ box . append _ text ( line + environment . new _ line ) ; }
public class logging { public static string log _ file _ path ; public static bool open _ log _ file ( ) { try { log _ file _ path = utils . get _ temp _ path ( STR ) ;
return true ; } catch ( io _ exception e ) { console . write _ line ( e . to _ string ( ) ) ; return false ; } } private static void write _ to _ log _ file ( object o ) {
} catch ( exception e ) { logging . log _ useful _ exception ( e ) ; return false ; } } public void toggle _ enable ( bool enabled ) { config . enabled = enabled ;
update _ system _ proxy ( ) ; save _ config ( config ) ; if ( enable _ status _ changed ! = null ) { enable _ status _ changed ( this , new event _ args ( ) ) ; } } public void toggle _ global ( bool global ) { config . global = global ;
public void update _ statistics _ configuration ( bool enabled ) { if ( availability _ statistics = = null ) return ; availability _ statistics . update _ configuration ( this ) ; config . availability _ statistics = enabled ; save _ config ( config ) ; } public void save _ pac _ url ( string pac _ url ) { config . pac _ url = pac _ url ;
update _ system _ proxy ( ) ; save _ config ( config ) ; if ( config _ changed ! = null ) { config _ changed ( this , new event _ args ( ) ) ; } } public void use _ online _ pac ( bool use _ online _ pac ) { config . use _ online _ pac = use _ online _ pac ;
using system ;
using system ; using system _ collections _ generic ; using system _ component _ model ; using system _ diagnostics ; using system _ io ; using system _ linq ; using system _ net ;
using system ; using system _ collections _ generic ; using system _ component _ model ; using system _ diagnostics ; using system _ io ; using system _ linq ; using system _ net ; using system _ net _ network _ information ; using system _ net _ sockets ;
public void start ( configuration configuration ) { if ( process = = null ) { process [ ] existing _ privoxy = process . get _ processes _ by _ name ( STR ) ; foreach ( process p in existing _ privoxy . where ( is _ child _ process ) ) { kill _ process ( p ) ; } string privoxy _ config = resources . privoxy _ conf ;
process [ ] existing _ privoxy = process . get _ processes _ by _ name ( STR ) ; foreach ( process p in existing _ privoxy . where ( is _ child _ process ) ) { kill _ process ( p ) ; } string privoxy _ config = resources . privoxy _ conf ; running _ port = this . get _ free _ port ( ) ; privoxy _ config = privoxy _ config . replace ( STR , configuration . local _ port . to _ string ( ) ) ; privoxy _ config = privoxy _ config . replace ( STR , running _ port . to _ string ( ) ) ; privoxy _ config = privoxy _ config . replace ( STR , configuration . share _ over _ lan ? STR : STR ) ;
process . start _ info . working _ directory = utils . get _ temp _ path ( ) ; process . start _ info . window _ style = process _ window _ style . hidden ; process . start _ info . use _ shell _ execute = true ; process . start _ info . create _ no _ window = true ; process . start ( ) ; * add this process to job obj associated with this ss process , so that * when ss exit unexpectedly , this process will be forced killed by system . * / privoxy _ job . add _ process ( process . handle ) ; }
refresh _ tray _ area ( ) ; } public void stop ( ) { if ( process ! = null ) { kill _ process ( process ) ; process . dispose ( ) ; process = null ; }
{ if ( disposing & & ( components ! = null ) ) { components . dispose ( ) ; } base . dispose ( disposing ) ; } private void initialize _ component ( ) { this . picture _ box = new system . windows . forms . picture _ box ( ) ;
{ components . dispose ( ) ; } base . dispose ( disposing ) ; } private void initialize _ component ( ) { this . picture _ box = new system . windows . forms . picture _ box ( ) ; this . panel = new system . windows . forms . panel ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . picture _ box ) ) . begin _ init ( ) ;
} base . dispose ( disposing ) ; } private void initialize _ component ( ) { this . picture _ box = new system . windows . forms . picture _ box ( ) ; this . panel = new system . windows . forms . panel ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . picture _ box ) ) . begin _ init ( ) ; this . panel . suspend _ layout ( ) ; this . suspend _ layout ( ) ;
{ this . picture _ box = new system . windows . forms . picture _ box ( ) ; this . panel = new system . windows . forms . panel ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . picture _ box ) ) . begin _ init ( ) ; this . panel . suspend _ layout ( ) ; this . suspend _ layout ( ) ; this . picture _ box . dock = system . windows . forms . dock _ style . fill ; this . picture _ box . location = new system . drawing . point ( NUM , NUM ) ; this . picture _ box . margin = new system . windows . forms . padding ( 0 ) ; this . picture _ box . name = STR ;
this . panel . suspend _ layout ( ) ; this . suspend _ layout ( ) ; this . picture _ box . dock = system . windows . forms . dock _ style . fill ; this . picture _ box . location = new system . drawing . point ( NUM , NUM ) ; this . picture _ box . margin = new system . windows . forms . padding ( 0 ) ; this . picture _ box . name = STR ; this . picture _ box . size = new system . drawing . size ( NUM , NUM ) ; this . picture _ box . size _ mode = system . windows . forms . picture _ box _ size _ mode . stretch _ image ; this . picture _ box . tab _ index = 1 ; this . picture _ box . tab _ stop = false ;
this . picture _ box . dock = system . windows . forms . dock _ style . fill ; this . picture _ box . location = new system . drawing . point ( NUM , NUM ) ; this . picture _ box . margin = new system . windows . forms . padding ( 0 ) ; this . picture _ box . name = STR ; this . picture _ box . size = new system . drawing . size ( NUM , NUM ) ; this . picture _ box . size _ mode = system . windows . forms . picture _ box _ size _ mode . stretch _ image ; this . picture _ box . tab _ index = 1 ; this . picture _ box . tab _ stop = false ; this . panel . controls . add ( this . picture _ box ) ; this . panel . dock = system . windows . forms . dock _ style . fill ; this . panel . location = new system . drawing . point ( 0 , 0 ) ; this . panel . margin = new system . windows . forms . padding ( 0 ) ; this . panel . name = STR ; this . panel . padding = new system . windows . forms . padding ( NUM ) ; this . panel . size = new system . drawing . size ( NUM , NUM ) ; this . panel . tab _ index = 2 ; this . back _ color = system . drawing . color . white ;
this . controls . add ( this . panel ) ; this . form _ border _ style = system . windows . forms . form _ border _ style . fixed _ single ; this . maximize _ box = false ; this . minimize _ box = false ; this . name = STR ; this . start _ position = system . windows . forms . form _ start _ position . center _ screen ; this . text = STR ; this . load + = new system . event _ handler ( this . qr _ code _ form _ load ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . picture _ box ) ) . end _ init ( ) ;
this . name = STR ; this . start _ position = system . windows . forms . form _ start _ position . center _ screen ; this . text = STR ; this . load + = new system . event _ handler ( this . qr _ code _ form _ load ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . picture _ box ) ) . end _ init ( ) ; this . panel . resume _ layout ( false ) ; this . resume _ layout ( false ) ; } private system . windows . forms . picture _ box picture _ box ;
public const string date _ time _ pattern = STR ; private const string statistics _ files _ name = STR ; public static string availability _ statistics _ file ; static availability _ statistics ( ) { availability _ statistics _ file = utils . get _ temp _ path ( statistics _ files _ name ) ; } private int repeat = > config . repeat _ times _ num ; public const int timeout _ milliseconds = NUM ; private readonly concurrent _ dictionary < string , list < int > > latency _ records = new concurrent _ dictionary < string , list < int > > ( ) ;
public static string availability _ statistics _ file ; static availability _ statistics ( ) { availability _ statistics _ file = utils . get _ temp _ path ( statistics _ files _ name ) ; } private int repeat = > config . repeat _ times _ num ; public const int timeout _ milliseconds = NUM ; private readonly concurrent _ dictionary < string , list < int > > latency _ records = new concurrent _ dictionary < string , list < int > > ( ) ; private readonly concurrent _ dictionary < string , long > inbound _ counter = new concurrent _ dictionary < string , long > ( ) ; private readonly concurrent _ dictionary < string , long > last _ inbound _ counter = new concurrent _ dictionary < string , long > ( ) ; private readonly concurrent _ dictionary < string , list < int > > inbound _ speed _ records = new concurrent _ dictionary < string , list < int > > ( ) ;
} private void start _ timer _ without _ state ( ref timer timer , timer _ callback callback , time _ span interval ) { if ( timer ? . change ( delay _ before _ start , interval ) = = null ) { timer = new timer ( callback , null , delay _ before _ start , interval ) ; } } private void update _ speed ( object ) {
if ( timer ? . change ( delay _ before _ start , interval ) = = null ) { timer = new timer ( callback , null , delay _ before _ start , interval ) ; } } private void update _ speed ( object ) { foreach ( var kv in last _ inbound _ counter ) { var id = kv . key ;
{ latency _ records . get _ or _ add ( server . identifier ( ) , ( k ) = > { list < int > records = new list < int > ( ) ; records . add ( latency ) ; return records ; } ) ; } public void update _ inbound _ counter ( server server , long n ) {
{ inbound _ counter . add _ or _ update ( server . identifier ( ) , ( k ) = > { last _ inbound _ counter . get _ or _ add ( server . identifier ( ) , 0 ) ; return n ; } , ( k , v ) = > ( v + n ) ) ; } public void update _ outbound _ counter ( server server , long n ) {
throw new argument _ exception ( n . get _ string ( STR ) ) ; } public static void check _ local _ port ( int port ) { check _ port ( port ) ; if ( port = = NUM ) throw new argument _ exception ( n . get _ string ( STR ) ) ; } private static void check _ password ( string password ) {
if ( port = = NUM ) throw new argument _ exception ( n . get _ string ( STR ) ) ; } private static void check _ password ( string password ) { if ( string . is _ null _ or _ empty ( password ) ) throw new argument _ exception ( n . get _ string ( STR ) ) ; } private static void check _ server ( string server ) {
{ return server . get _ hash _ code ( ) ^ server _ port ; } public override bool equals ( object obj ) { server = ( server ) obj ; return server = = . server & & server _ port = = . server _ port ; } public string friendly _ name ( ) {
{ server = ( server ) obj ; return server = = . server & & server _ port = = . server _ port ; } public string friendly _ name ( ) { if ( string . is _ null _ or _ empty ( server ) ) { return n . get _ string ( STR ) ; }

if ( string . is _ null _ or _ empty ( controller . get _ configuration _ copy ( ) . pac _ url ) ) { update _ online _ pacurl _ item _ click ( sender , e ) ; }
cached _ keys [ k ] = key ; } } protected void bytes _ to _ key ( byte [ ] password , byte [ ] key ) { byte [ ] result = new byte [ password . length + NUM ] ; int i = 0 ; byte [ ] md _ sum = null ; while ( i < key . length ) {
protected void bytes _ to _ key ( byte [ ] password , byte [ ] key ) { byte [ ] result = new byte [ password . length + NUM ] ; int i = 0 ; byte [ ] md _ sum = null ; while ( i < key . length ) { m md = m . create ( ) ; if ( i = = 0 ) {
{ m md = m . create ( ) ; if ( i = = 0 ) { md _ sum = md . compute _ hash ( password ) ; } else { md _ sum . copy _ to ( result , 0 ) ; password . copy _ to ( result , md _ sum . length ) ;
this . edit _ pac _ file _ item , this . qr _ code _ item , this . show _ log _ item , this . about _ item , this . menu _ item , this . quit _ item } ) ; this . enable _ item . index = 0 ; this . enable _ item . text = STR ; this . enable _ item . click + = new system . event _ handler ( this . enable _ item _ click ) ;
this . about _ item , this . menu _ item , this . quit _ item } ) ; this . enable _ item . index = 0 ; this . enable _ item . text = STR ; this . enable _ item . click + = new system . event _ handler ( this . enable _ item _ click ) ; this . share _ over _ lan _ item . index = 1 ; this . share _ over _ lan _ item . text = STR ; this . share _ over _ lan _ item . click + = new system . event _ handler ( this . share _ over _ lan _ item _ click ) ;
else if ( result . text . starts _ with ( STR ) | | result . text . starts _ with ( STR ) ) { url _ to _ open = result . text ; splash . form _ closed + = open _ url _ from _ qr _ code ; } else { message _ box . show ( n . get _ string ( STR ) ) ; return ; }
using system _ i _ compression ; using system _ net ; using system _ net _ sockets ; using system _ text ; namespace shadowsocks _ controller { class pac _ server : listener . service { public static string pac _ file = STR ; public static string user _ rule _ file = STR ;
socket conn = ( socket ) ar . async _ state ; try { conn . shutdown ( socket _ shutdown . send ) ; } catch { } } private void watch _ pac _ file ( ) {
{ private static dictionary < string , string > strings = new dictionary < string , string > ( ) ; private static void init ( string res , string locale ) { using ( text _ field _ parser csv _ parser = new text _ field _ parser ( new string _ reader ( res ) ) ) { csv _ parser . set _ delimiters ( STR ) ; string [ ] locale _ names = csv _ parser . read _ fields ( ) ; int en _ index = 0 ;
if ( locale _ names [ i ] = = STR ) {
} } while ( ! csv _ parser . end _ of _ data ) { string [ ] translations = csv _ parser . read _ fields ( ) ;
while ( ! csv _ parser . end _ of _ data ) { string [ ] translations = csv _ parser . read _ fields ( ) ; if ( string . is _ null _ or _ white _ space ( translations [ 0 ] ) ) continue ; if ( translations [ 0 ] . trim _ start ( ' ' ) [ 0 ] = = '#' ) continue ;
if ( string . is _ null _ or _ white _ space ( translations [ 0 ] ) ) continue ; if ( translations [ 0 ] . trim _ start ( ' ' ) [ 0 ] = = '#' ) continue ; strings [ translations [ en _ index ] ] = translations [ target _ index ] ; } } } static n ( ) {
this . repeat _ times _ num = new system . windows . forms . numeric _ up _ down ( ) ; this . label = new system . windows . forms . label ( ) ; this . split _ container = new system . windows . forms . split _ container ( ) ; this . label = new system . windows . forms . label ( ) ; this . calculation _ container = new system . windows . forms . flow _ layout _ panel ( ) ; this . cancel _ button = new system . windows . forms . button ( ) ; this . ok _ button = new system . windows . forms . button ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . statistics _ chart ) ) . begin _ init ( ) ;
public class state { public data _ list data _ list = new data _ list ( ) ; public const string geolocation = STR ; public const string isp = STR ; public const string unknown = STR ; } public class raw _ statistics _ data {
public static list < server > get _ servers ( string ss _ url ) {
int prefix _ length = STR . length ; var server _ urls = ss _ url . split ( '\r' , '\n' ) ; list < server > servers = new list < server > ( ) ; foreach ( string server _ url in server _ urls ) { string server _ url = server _ url . trim ( ) ; if ( ! server _ url . begin _ with ( STR , string _ comparison . invariant _ culture _ ignore _ case ) ) { continue ; }
foreach ( string server _ url in server _ urls ) { string server _ url = server _ url . trim ( ) ; if ( ! server _ url . begin _ with ( STR , string _ comparison . invariant _ culture _ ignore _ case ) ) { continue ; } string web _ safe _ base _ str = index _ of _ hash _ or _ slash = = - 1 ? server _ url . substring ( prefix _ length ) : server _ url . substring ( prefix _ length , index _ of _ hash _ or _ slash - prefix _ length ) ; string base _ str = web _ safe _ base _ str . replace ( '-' , '+' ) . replace ( '_' , '/' ) ; string base = base _ str . pad _ right ( base _ str . length + ( NUM - base _ str . length % NUM ) % NUM , '=' ) ; string decoded _ base = encoding . ut . get _ string ( convert . from _ base _ string ( base ) ) ; string decoded _ server _ url = server _ url . replace ( web _ safe _ base _ str , decoded _ base ) ; uri parsed _ url ; try {
string server _ url = server _ url . trim ( ) ; if ( ! server _ url . begin _ with ( STR , string _ comparison . invariant _ culture _ ignore _ case ) ) { continue ; } server _ url . substring ( prefix _ length , index _ of _ hash _ or _ slash - prefix _ length ) ; string base _ str = web _ safe _ base _ str . replace ( '-' , '+' ) . replace ( '_' , '/' ) ; string base = base _ str . pad _ right ( base _ str . length + ( NUM - base _ str . length % NUM ) % NUM , '=' ) ; string decoded _ base = encoding . ut . get _ string ( convert . from _ base _ string ( base ) ) ; string decoded _ server _ url = server _ url . replace ( web _ safe _ base _ str , decoded _ base ) ; uri parsed _ url ; try { parsed _ url = new uri ( decoded _ server _ url ) ; }
{ continue ; } string base = base _ str . pad _ right ( base _ str . length + ( NUM - base _ str . length % NUM ) % NUM , '=' ) ; string decoded _ base = encoding . ut . get _ string ( convert . from _ base _ string ( base ) ) ; string decoded _ server _ url = server _ url . replace ( web _ safe _ base _ str , decoded _ base ) ; uri parsed _ url ; try { parsed _ url = new uri ( decoded _ server _ url ) ; } catch ( uri _ format _ exception ) {
{ parsed _ url = new uri ( decoded _ server _ url ) ; } catch ( uri _ format _ exception ) { continue ; }
: iv _ encryptor , i _ disposable { const int cipher _ sals = 1 ; const int cipher _ chach = 2 ; const int sodium _ block _ size = NUM ; protected int encrypt _ bytes _ remaining ; protected int decrypt _ bytes _ remaining ; protected ulong encrypt _ ic ; protected ulong decrypt _ ic ;
protected int encrypt _ bytes _ remaining ; protected int decrypt _ bytes _ remaining ; protected ulong encrypt _ ic ; protected ulong decrypt _ ic ; protected byte [ ] encrypt _ buf ; protected byte [ ] decrypt _ buf ; public sodium _ encryptor ( string method , string password ) : base ( method , password ) { init _ key ( method , password ) ;
return ciphers ; } public static list < string > supported _ ciphers ( ) { return new list < string > ( ciphers . keys ) ; } protected override void cipher _ update ( bool is _ cipher , int length , byte [ ] buf , byte [ ] outbuf ) { int bytes _ remaining ; ulong ic ;
public static list < string > supported _ ciphers ( ) { return new list < string > ( ciphers . keys ) ; } protected override void cipher _ update ( bool is _ cipher , int length , byte [ ] buf , byte [ ] outbuf ) { int bytes _ remaining ; ulong ic ; byte [ ] sodium _ buf ; byte [ ] iv ;
} protected override void cipher _ update ( bool is _ cipher , int length , byte [ ] buf , byte [ ] outbuf ) { int bytes _ remaining ; ulong ic ; byte [ ] sodium _ buf ; byte [ ] iv ; if ( is _ cipher ) {
public async void run ( string path ) { byte [ ] buf = new byte [ NUM ] ; while ( true ) { using ( named _ pipe _ server _ stream stream = new named _ pipe _ server _ stream ( path ) ) { stream . wait _ for _ connection ( ) ; await stream . read _ async ( buf , 0 , NUM ) ;
} public event event _ handler config _ changed ; public event event _ handler enable _ status _ changed ; public event event _ handler enable _ global _ changed ; public event event _ handler share _ over _ lan _ status _ changed ; public event event _ handler < path _ event _ args > pac _ file _ ready _ to _ open ; public shadowsocks _ controller ( ) { config = configuration . load ( ) ;
pac _ file _ ready _ to _ open ( this , new path _ event _ args ( ) { path = pac _ filename } ) ; } } public string get _ qr _ code _ for _ current _ server ( ) { server server = get _ current _ server ( ) ; string parts = server . method + STR + server . password + STR + server . server + STR + server . server _ port ; string base = system . convert . to _ base _ string ( encoding . ut . get _ bytes ( parts ) ) ; return STR + base ; }
pac _ server . stop ( ) ;
pac _ server . stop ( ) ; local . stop ( ) ; polipo _ runner . stop ( ) ;
try { server _ timer timer = ( server _ timer ) ar . async _ state ; server = timer . server ; timer . elapsed - = connect _ timer _ elapsed ; timer . enabled = false ; timer . dispose ( ) ; remote . end _ connect ( ar ) ; connected = true ; var latency = date _ time . now - start _ connect _ time ;
controller . get _ current _ strategy ( ) . update _ latency ( server , latency ) ; start _ pipe ( ) ; } catch ( argument _ exception e ) { } catch ( exception e ) { if ( server ! = null ) {
private shadowsocks _ controller controller ; private update _ checker update _ checker ; private notify _ icon notify _ icon ; private context _ menu context _ menu ; private bool is _ first _ run ; private menu _ item enable _ item ; private menu _ item auto _ startup _ item ; private menu _ item share _ over _ lan _ item ; private menu _ item seperator _ item ; private menu _ item config _ item ;
private notify _ icon notify _ icon ; private context _ menu context _ menu ; private bool is _ first _ run ; private menu _ item enable _ item ; private menu _ item auto _ startup _ item ; private menu _ item share _ over _ lan _ item ; private menu _ item seperator _ item ; private menu _ item config _ item ; private menu _ item seperator _ item ; private menu _ item edit _ pac _ file _ item ; private menu _ item qr _ code _ item ; private menu _ item show _ log _ item ; private menu _ item about _ item ; private menu _ item servers _ item ;

this . mode _ item = create _ menu _ group ( 1 , STR , new system . windows . forms . menu _ item [ ] { this . pac _ mode _ item , this . global _ mode _ item } ) ; this . servers _ item = create _ menu _ group ( 2 , STR , new system . windows . forms . menu _ item [ ] {
this . mode _ item = create _ menu _ group ( 1 , STR , new system . windows . forms . menu _ item [ ] { this . pac _ mode _ item , this . global _ mode _ item } ) ; this . servers _ item = create _ menu _ group ( 2 , STR , new system . windows . forms . menu _ item [ ] { this . seperator _ item , this . config _ item } ) ; this . seperator _ item = create _ seperator _ item ( NUM ) ; this . auto _ startup _ item = create _ menu _ item ( NUM , STR , new system . event _ handler ( this . auto _ startup _ item _ click ) ) ; this . share _ over _ lan _ item = create _ menu _ item ( NUM , STR , new system . event _ handler ( this . share _ over _ lan _ item _ click ) ) ;
this . global _ mode _ item } ) ; this . servers _ item = create _ menu _ group ( 2 , STR , new system . windows . forms . menu _ item [ ] { this . seperator _ item , this . config _ item } ) ; this . seperator _ item = create _ seperator _ item ( NUM ) ; this . auto _ startup _ item = create _ menu _ item ( NUM , STR , new system . event _ handler ( this . auto _ startup _ item _ click ) ) ; this . share _ over _ lan _ item = create _ menu _ item ( NUM , STR , new system . event _ handler ( this . share _ over _ lan _ item _ click ) ) ; this . edit _ pac _ file _ item = create _ menu _ item ( NUM , STR , new system . event _ handler ( this . edit _ pac _ file _ item _ click ) ) ; this . seperator _ item = create _ seperator _ item ( NUM ) ; this . qr _ code _ item = create _ menu _ item ( NUM , STR , new system . event _ handler ( this . qr _ code _ item _ click ) ) ; this . show _ log _ item = create _ menu _ item ( NUM , STR , new system . event _ handler ( this . show _ log _ item _ click ) ) ; this . about _ item = create _ menu _ item ( NUM , STR , new system . event _ handler ( this . config _ click ) ) ; this . seperator _ item = create _ seperator _ item ( NUM ) ; this . quit _ item = create _ menu _ item ( NUM , STR , new system . event _ handler ( this . quit _ click ) ) ; this . context _ menu . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . enable _ item ,
this . config _ item } ) ; this . seperator _ item = create _ seperator _ item ( NUM ) ; this . auto _ startup _ item = create _ menu _ item ( NUM , STR , new system . event _ handler ( this . auto _ startup _ item _ click ) ) ; this . share _ over _ lan _ item = create _ menu _ item ( NUM , STR , new system . event _ handler ( this . share _ over _ lan _ item _ click ) ) ; this . qr _ code _ item = create _ menu _ item ( NUM , STR , new system . event _ handler ( this . qr _ code _ item _ click ) ) ; this . show _ log _ item = create _ menu _ item ( NUM , STR , new system . event _ handler ( this . show _ log _ item _ click ) ) ; this . about _ item = create _ menu _ item ( NUM , STR , new system . event _ handler ( this . config _ click ) ) ; this . seperator _ item = create _ seperator _ item ( NUM ) ; this . quit _ item = create _ menu _ item ( NUM , STR , new system . event _ handler ( this . quit _ click ) ) ; this . context _ menu . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . enable _ item , this . mode _ item , this . servers _ item ,
this . share _ over _ lan _ item = create _ menu _ item ( NUM , STR , new system . event _ handler ( this . share _ over _ lan _ item _ click ) ) ; this . seperator _ item = create _ seperator _ item ( NUM ) ; this . quit _ item = create _ menu _ item ( NUM , STR , new system . event _ handler ( this . quit _ click ) ) ; this . context _ menu . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . enable _ item , this . mode _ item , this . servers _ item , this . seperator _ item , this . auto _ startup _ item , this . share _ over _ lan _ item ,
return false ; } string current _ version = version ; return compare _ version ( version , current _ version ) > 0 ; } private void http _ download _ string _ completed ( object sender , download _ string _ completed _ event _ args e ) { try { string response = e . result ;
string current _ version = version ; return compare _ version ( version , current _ version ) > 0 ; } private void http _ download _ string _ completed ( object sender , download _ string _ completed _ event _ args e ) { try { string response = e . result ; xml _ document xml _ doc = new xml _ document ( ) ; xml _ doc . load _ xml ( response ) ; xml _ node _ list elements = xml _ doc . get _ elements _ by _ tag _ name ( STR ) ; list < string > versions = new list < string > ( ) ;
} private void http _ download _ string _ completed ( object sender , download _ string _ completed _ event _ args e ) { try { string response = e . result ; xml _ document xml _ doc = new xml _ document ( ) ; xml _ doc . load _ xml ( response ) ; xml _ node _ list elements = xml _ doc . get _ elements _ by _ tag _ name ( STR ) ; list < string > versions = new list < string > ( ) ; foreach ( xml _ node el in elements ) {
{ try { string response = e . result ; xml _ document xml _ doc = new xml _ document ( ) ; xml _ doc . load _ xml ( response ) ; xml _ node _ list elements = xml _ doc . get _ elements _ by _ tag _ name ( STR ) ; list < string > versions = new list < string > ( ) ; foreach ( xml _ node el in elements ) { foreach ( xml _ attribute attr in el . attributes ) {
string response = e . result ; xml _ doc . load _ xml ( response ) ; xml _ node _ list elements = xml _ doc . get _ elements _ by _ tag _ name ( STR ) ; list < string > versions = new list < string > ( ) ; foreach ( xml _ node el in elements ) { foreach ( xml _ attribute attr in el . attributes ) { if ( attr . name = = STR ) {
using system ; using system _ diagnostics ; using system _ io ;
using system _ text ; using shadowsocks _ controller ; using shadowsocks _ properties ; namespace shadowsocks _ util _ system _ proxy { public static class sysproxy {
using shadowsocks _ properties ; namespace shadowsocks _ util _ system _ proxy { public static class sysproxy { private static bool user _ settings _ recorded = false ;
file _ manager . uncompress _ file ( utils . get _ temp _ path ( STR ) , environment . is _ bit _ operating _ system ? resources . sysproxy _ exe : resources . sysproxy _ exe ) ; } catch ( io _ exception e ) { logging . log _ useful _ exception ( e ) ; } } public static void set _ ie _ proxy ( bool enable , bool global , string proxy _ server , string pac _ url ) {
catch ( io _ exception e ) { logging . log _ useful _ exception ( e ) ; } } public static void set _ ie _ proxy ( bool enable , bool global , string proxy _ server , string pac _ url ) { string str ; if ( user _ settings _ recorded = = false ) {
} string arguments ; if ( enable ) { arguments = global ? $ STR : $ STR ; } else {
? $ STR : $ STR ; } else { var flags = user _ settings [ 0 ] ; var proxy _ server = user _ settings [ 1 ] ? ? STR ; var bypass _ list = user _ settings [ 2 ] ? ? STR ; var pac _ url = user _ settings [ NUM ] ? ? STR ; arguments = $ STR ;
} else { var flags = user _ settings [ 0 ] ; var proxy _ server = user _ settings [ 1 ] ? ? STR ; var bypass _ list = user _ settings [ 2 ] ? ? STR ; var pac _ url = user _ settings [ NUM ] ? ? STR ; arguments = $ STR ; user _ settings _ recorded = false ; }
var flags = user _ settings [ 0 ] ; var proxy _ server = user _ settings [ 1 ] ? ? STR ; var bypass _ list = user _ settings [ 2 ] ? ? STR ; var pac _ url = user _ settings [ NUM ] ? ? STR ; arguments = $ STR ; user _ settings _ recorded = false ; } exec _ sysproxy ( arguments , out str ) ; }
process . start _ info . create _ no _ window = true ; process . start ( ) ; var stderr = process . standard _ error . read _ to _ end ( ) ; var stdout = process . standard _ output . read _ to _ end ( ) ; process . wait _ for _ exit ( ) ; var exit _ code = process . exit _ code ; if ( exit _ code ! = ( int ) ret _ errors . ret _ no _ error ) { throw new proxy _ exception ( stderr ) ; }
var exit _ code = process . exit _ code ; if ( exit _ code ! = ( int ) ret _ errors . ret _ no _ error ) { throw new proxy _ exception ( stderr ) ; } if ( arguments = = STR & & stdout . is _ null _ or _ white _ space ( ) ) { throw new proxy _ exception ( STR ) ; }
if ( arguments = = STR & & stdout . is _ null _ or _ white _ space ( ) ) { throw new proxy _ exception ( STR ) ; } query _ str = stdout ; } } private static void parse _ query _ str ( string str ) {

using shadowsocks _ controller ; using shadowsocks _ properties ; using shadowsocks _ view ; using system ; using system _ collections _ generic ; using system _ diagnostics ;
using system ; using system _ collections _ generic ; using system _ diagnostics ; using system _ io ; using system _ reflection ; using system _ runtime _ interop _ services ; using system _ threading ; using system _ windows _ forms ; namespace shadowsocks { static class program {
byte [ ] auth = new byte [ onetimeauth _ bytes ] ; byte [ ] hash = new byte [ NUM ] ; byte [ ] auth _ key = new byte [ max _ iv _ length + max _ key _ length ] ; buffer . block _ copy ( encrypt _ iv , 0 , auth _ key , 0 , iv _ len ) ; buffer . block _ copy ( key , 0 , auth _ key , iv _ len , key _ len ) ; sodium . ss _ sha _ hmac _ ex ( auth _ key , ( uint ) ( iv _ len + key _ len ) , msg , 0 , ( uint ) msg _ len , hash ) ; buffer . block _ copy ( hash , 0 , auth , 0 , onetimeauth _ bytes ) ; return auth ; }
key _ buffer = new byte [ max _ iv _ length + NUM ] ; buffer . block _ copy ( encrypt _ iv , 0 , key _ buffer , 0 , iv _ len ) ; } byte [ ] counter _ bytes = bit _ converter . get _ bytes ( ( uint ) ip _ address . host _ to _ network _ order ( ( int ) counter ) ) ; buffer . block _ copy ( counter _ bytes , 0 , key _ buffer , iv _ len , NUM ) ; counter + + ; } protected byte [ ] gen _ hash ( byte [ ] buf , int offset , int len ) { byte [ ] hash = new byte [ NUM ] ;
byte [ ] hash = new byte [ NUM ] ; update _ key _ buffer ( ) ; sodium . ss _ sha _ hmac _ ex ( key _ buffer , ( uint ) key _ buffer . length , buf , offset , ( uint ) len , hash ) ; return hash ; } protected void react _ buffer _ tcp ( byte [ ] buf , ref int length ) { if ( ! encrypt _ iv _ sent ) {
buf , offset , ( uint ) len , hash ) ; return hash ; } protected void react _ buffer _ tcp ( byte [ ] buf , ref int length ) { if ( ! encrypt _ iv _ sent ) { int head _ len = get _ head _ len ( buf , length ) ; int data _ len = length - head _ len ; buf [ 0 ] | = onetimeauth _ flag ;
buffer . block _ copy ( buf , 0 , buf , auth _ bytes , length ) ; byte [ ] len _ bytes = bit _ converter . get _ bytes ( ( ushort ) ip _ address . host _ to _ network _ order ( ( short ) length ) ) ; buffer . block _ copy ( len _ bytes , 0 , buf , 0 , clen _ bytes ) ; buffer . block _ copy ( hash , 0 , buf , clen _ bytes , onetimeauth _ bytes ) ; length + = auth _ bytes ; } } protected void react _ buffer _ udp ( byte [ ] buf , ref int length ) { buf [ 0 ] | = onetimeauth _ flag ;
byte [ ] hash = gen _ onetime _ auth _ hash ( buf , length ) ; buffer . block _ copy ( hash , 0 , buf , length , onetimeauth _ bytes ) ; length + = onetimeauth _ bytes ; } protected void react _ buffer ( byte [ ] buf , ref int length ) { if ( onetime _ auth & & iv _ len > 0 ) { if ( ! is _ udp ) {
protected void react _ buffer ( byte [ ] buf , ref int length ) { if ( onetime _ auth & & iv _ len > 0 ) { if ( ! is _ udp ) { react _ buffer _ tcp ( buf , ref length ) ; } else {
react _ buffer _ udp ( buf , ref length ) ; } } } public override void encrypt ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength ) { if ( ! encrypt _ iv _ sent ) { rand _ bytes ( outbuf , iv _ len ) ; init _ cipher ( outbuf , true ) ;

internal class resources { private static global :: system . resources . resource _ manager resource _ man ; private static global :: system . globalization . culture _ info resource _ culture ; global _ system _ diagnostics _ code _ analysis _ suppress _ message _ attribute _ microsoft _ performance _ c _ avoid _ uncalled _ private _ code internal resources ( ) { } global _ system _ component _ model _ editor _ browsable _ attribute _ global _ system _ component _ model _ editor _ browsable _ state _ advanced
if ( last _ selected _ index < 0 | | last _ selected _ index > = servers _ list _ box . items . count ) { last _ selected _ index = 0 ; } servers _ list _ box . selected _ index = last _ selected _ index ; update _ buttons ( ) ; load _ selected _ server _ details ( ) ; proxy _ port _ text _ box . text = modified _ configuration . local _ port . to _ string ( ) ; portable _ mode _ check _ box . checked = modified _ configuration . portable _ mode ; }
} private void ok _ button _ click ( object sender , event _ args e ) { if ( ! validate _ and _ save _ selected _ server _ details ( ) ) { return ; } if ( modified _ configuration . configs . count = = 0 ) { message _ box . show ( n . get _ string ( STR ) ) ;
{ message _ box . show ( n . get _ string ( STR ) ) ; return ; } int local _ port = int . parse ( proxy _ port _ text _ box . text ) ; configuration . check _ local _ port ( local _ port ) ; modified _ configuration . local _ port = local _ port ; modified _ configuration . portable _ mode = portable _ mode _ check _ box . checked ; controller . save _ servers ( modified _ configuration . configs , modified _ configuration . local _ port , modified _ configuration . portable _ mode ) ; controller . select _ server _ index ( servers _ list _ box . selected _ index ) ;
this . my _ cancel _ button . location = new system . drawing . point ( NUM , NUM ) ; this . my _ cancel _ button . margin = new system . windows . forms . padding ( NUM , NUM , NUM , 0 ) ; this . my _ cancel _ button . name = STR ; this . my _ cancel _ button . size = new system . drawing . size ( NUM , NUM ) ; this . my _ cancel _ button . tab _ index = NUM ; this . my _ cancel _ button . text = STR ; this . my _ cancel _ button . use _ visual _ style _ back _ color = true ; this . my _ cancel _ button . click + = new system . event _ handler ( this . cancel _ button _ click ) ; this . apply _ button . enabled = false ;
configuration . save ( config ) ; } public void save _ log _ viewer _ config ( log _ viewer _ config new _ config ) { config . log _ viewer = new _ config ; configuration . save ( config ) ; } public void update _ inbound _ counter ( long n ) { interlocked . add ( ref inbound _ counter , n ) ;
configuration . save ( config ) ; } public void update _ inbound _ counter ( long n ) { interlocked . add ( ref inbound _ counter , n ) ; config . bandwidth _ in = inbound _ counter ; } public void update _ outbound _ counter ( long n ) { interlocked . add ( ref outbound _ counter , n ) ;
config . bandwidth _ in = inbound _ counter ; } public void update _ outbound _ counter ( long n ) { interlocked . add ( ref outbound _ counter , n ) ; config . bandwidth _ out = outbound _ counter ; } protected void reload ( ) { config = configuration . load ( ) ;
this . statistics _ enabled _ check _ box = new system . windows . forms . check _ box ( ) ; this . choice _ kept _ minutes _ num = new system . windows . forms . numeric _ up _ down ( ) ; this . by _ hour _ of _ day _ check _ box = new system . windows . forms . check _ box ( ) ; this . repeat _ times _ num = new system . windows . forms . numeric _ up _ down ( ) ; this . label = new system . windows . forms . label ( ) ; this . split _ container = new system . windows . forms . split _ container ( ) ; this . label = new system . windows . forms . label ( ) ; this . calculation _ container = new system . windows . forms . flow _ layout _ panel ( ) ; this . ok _ button = new system . windows . forms . button ( ) ;
this . by _ hour _ of _ day _ check _ box = new system . windows . forms . check _ box ( ) ; this . repeat _ times _ num = new system . windows . forms . numeric _ up _ down ( ) ; this . label = new system . windows . forms . label ( ) ; this . split _ container = new system . windows . forms . split _ container ( ) ; this . label = new system . windows . forms . label ( ) ; this . calculation _ container = new system . windows . forms . flow _ layout _ panel ( ) ; this . ok _ button = new system . windows . forms . button ( ) ; this . cancel _ button = new system . windows . forms . button ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . statistics _ chart ) ) . begin _ init ( ) ;
this . ok _ button . location = new system . drawing . point ( NUM , NUM ) ; this . ok _ button . name = STR ; this . ok _ button . size = new system . drawing . size ( NUM , NUM ) ; this . ok _ button . tab _ index = NUM ; this . ok _ button . text = STR ; this . ok _ button . use _ visual _ style _ back _ color = true ; this . ok _ button . click + = new system . event _ handler ( this . ok _ button _ click ) ;
{ if ( controller = = null ) return ; initialize _ component ( ) ; controller = controller ; controller . config _ changed + = ( sender , args ) = > load _ configuration ( ) ; load _ configuration ( ) ; load + = ( sender , args ) = > init _ data ( ) ; } private void load _ configuration ( ) {
using shadowsocks _ properties ; using system ; using system _ collections _ generic ; using system _ diagnostics ; using system _ io ; using system _ i _ compression ; using system _ net ; using system _ net _ sockets ; using system _ text ;
using system _ i _ compression ; using system _ net ; using system _ net _ sockets ; using system _ text ; using system _ text _ regular _ expressions ; namespace shadowsocks _ controller { class pac _ server { private static int port = NUM ;
namespace shadowsocks _ controller { class pac _ server { private static int port = NUM ; private static string pac _ file = STR ; private static configuration config ; socket listener ; file _ system _ watcher watcher ; public event event _ handler pac _ file _ changed ;
namespace shadowsocks _ controller { public class gfw _ list _ updater { private const string gfwlist _ url = STR ;
namespace shadowsocks _ controller { public class gfw _ list _ updater { private const string gfwlist _ url = STR ; public i _ web _ proxy proxy = null ; public class gfw _ list _ download _ completed _ args : event _ args { public string content ; } public event event _ handler < gfw _ list _ download _ completed _ args > download _ completed ; public event error _ event _ handler error ;
{ private const string gfwlist _ url = STR ; { public string content ; } public event event _ handler < gfw _ list _ download _ completed _ args > download _ completed ; public event error _ event _ handler error ; { if ( error ! = null ) { error ( this , new error _ event _ args ( e ) ) ; } } private void http _ download _ string _ completed ( object sender , download _ string _ completed _ event _ args e ) { try {
public event event _ handler < gfw _ list _ download _ completed _ args > download _ completed ; public event error _ event _ handler error ; error ( this , new error _ event _ args ( e ) ) ; } } private void http _ download _ string _ completed ( object sender , download _ string _ completed _ event _ args e ) { try { string response = e . result ; if ( download _ completed ! = null ) {
try { string response = e . result ; if ( download _ completed ! = null ) { download _ completed ( this , new gfw _ list _ download _ completed _ args { content = response } ) ; } } catch ( exception ex ) {
{ content = response } ) ; } } catch ( exception ex ) { report _ error ( ex ) ; } }
} } catch ( exception ex ) { report _ error ( ex ) ; } } public class parser {
{ report _ error ( ex ) ; } } public class parser { private string content ; public string content {
} } public class parser { private string content ; public string content { get { return content ; } }
} private void pac _ server _ pac _ file _ changed ( object sender , event _ args e ) { update _ system _ proxy ( ) ; } private void pac _ server _ update _ pac _ from _ gfw _ list _ completed ( object sender , event _ args e ) { if ( update _ pac _ from _ gfw _ list _ completed ! = null ) update _ pac _ from _ gfw _ list _ completed ( this , e ) ; }
using system ; using system _ collections _ generic ; using system _ diagnostics ; using system _ runtime _ interop _ services ; using system _ text ; namespace shadowsocks _ util {
namespace shadowsocks _ controller { class polipo _ runner { private process process ; private static string temppath ; private int running _ port ; static polipo _ runner ( ) {
handler handler = new handler ( ) ; handler . connection = socket ; handler . controller = controller ; handler . relay = this ; handler . start ( first _ packet , length ) ; lock ( this . handlers ) { this . handlers . add ( handler ) ; logging . debug ( $ STR ) ;

} if ( has _ alphanumeric ) { return mode . alphanumeric ; } if ( has _ numeric ) { return mode . numeric ; } return mode . byte ;
{ throw new writer _ exception ( num _ letters + STR + ( ( 1 < < num _ bits ) - 1 ) ) ; } bits . append _ bits ( num _ letters , num _ bits ) ; } internal static void append _ bytes ( string content , mode mode , bit _ array bits , string encoding ) {
bits . append _ bits ( num _ letters , num _ bits ) ; } internal static void append _ bytes ( string content , mode mode , bit _ array bits , string encoding ) { if ( mode . equals ( mode . numeric ) ) append _ numeric _ bytes ( content , bits ) ; else if ( mode . equals ( mode . alphanumeric ) ) append _ alphanumeric _ bytes ( content , bits ) ; else
var index = ( - num & num ) % NUM ; if ( index < 0 ) index * = - 1 ; return lookup [ index ] ; } private static readonly int [ ] lookup = { NUM , 0 , 1 , NUM , 2 , NUM , NUM , 0 , NUM , NUM , NUM , NUM , NUM , NUM , 0 , NUM , NUM , NUM , NUM , 0 , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , 0 , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ;
0 , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM , 0 , NUM , NUM , NUM , NUM , NUM , NUM , NUM , NUM } ; } current _ bits = ~ bits [ bits _ offset ] ; } int result = ( bits _ offset < < NUM ) + number _ of _ trailing _ zeros ( current _ bits ) ; return result > size ? size : result ; } public void set _ bulk ( int i , int new _ bits ) { bits [ i > > NUM ] = new _ bits ; }
bits [ i > > NUM ] = new _ bits ; } bits [ i ] | = mask ; } } public void clear ( ) { int max = bits . length ; for ( int i = 0 ; i < max ; i + + ) { bits [ i ] = 0 ; }
using system ; using system _ collections _ generic ; using system _ io ; using system _ linq ; using system _ net _ network _ information ;
timer ? . dispose ( ) ; } return true ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; return false ; } }
var ping = new ping ( ) ;
var ping = new ping ( ) ; var state = ( state ) obj ; foreach ( var server in servers ) {
var ping = new ping ( ) ; var state = ( state ) obj ; foreach ( var server in servers ) { logging . debug ( STR + server . friendly _ name ( ) ) ; foreach ( var in enumerable . range ( 0 , repeat ) ) {
{ new key _ value _ pair < string , string > ( STR , timestamp ) , new key _ value _ pair < string , string > ( STR , server . friendly _ name ( ) ) , new key _ value _ pair < string , string > ( STR , reply ? . status . to _ string ( ) ) , new key _ value _ pair < string , string > ( STR , reply ? . roundtrip _ time . to _ string ( ) ) } ; append ( state . data ) ; } } }
{ asserts . sort ( new version _ comparer ( ) ) ; } public class asset { public bool prerelease ; public string name ; public string version ; public string browser _ download _ url ; public string suffix ;
public static asset parse _ asset ( j _ object aj _ object ) { var name = ( string ) aj _ object [ STR ] ; match match = regex . match ( name , STR , regex _ options . ignore _ case ) ; if ( match . success ) { string version = match . groups [ STR ] . value ; var asset = new asset {
using system _ windows _ forms _ data _ visualization _ charting ; using system _ collections _ generic ; using system _ linq ; using shadowsocks _ controller ; using shadowsocks _ properties ; using shadowsocks _ model ; using shadowsocks _ util ; using system _ text ; namespace shadowsocks _ view {
{ } } public partial class log _ form : form { long last _ offset ; string filename ; timer timer ; const int back _ offset = NUM ; shadowsocks _ controller controller ; private static readonly object lock = new object ( ) ;
log _ viewer _ config config = controller . get _ configuration _ copy ( ) . log _ viewer ; top _ most _ trigger = config . top _ most ; wrap _ text _ trigger = config . wrap _ text ; toolbar _ trigger = config . toolbar _ shown ; log _ message _ text _ box . back _ color = config . background _ color ; log _ message _ text _ box . fore _ color = config . text _ color ; log _ message _ text _ box . font = config . font ; controller . traffic _ changed + = controller _ traffic _ changed ; update _ texts ( ) ; }
log _ message _ text _ box . fore _ color = config . text _ color ; log _ message _ text _ box . font = config . font ; controller . traffic _ changed + = controller _ traffic _ changed ; update _ texts ( ) ; } list < float > inbound _ points = new list < float > ( ) ; list < float > outbound _ points = new list < float > ( ) ; text _ annotation inbound _ annotation = new text _ annotation ( ) ; text _ annotation outbound _ annotation = new text _ annotation ( ) ; bandwidth _ scale _ info bandwidth _ scale ; const long min _ scale = NUM ; long max _ speed = 0 ; long last _ inbound , last _ outbound ; lock ( lock ) {
controller . traffic _ changed + = controller _ traffic _ changed ; update _ texts ( ) ; } text _ annotation inbound _ annotation = new text _ annotation ( ) ; text _ annotation outbound _ annotation = new text _ annotation ( ) ; bandwidth _ scale _ info bandwidth _ scale ; const long min _ scale = NUM ; long max _ speed = 0 ; long last _ inbound , last _ outbound ; lock ( lock ) { if ( traffic . count = = 0 ) return ;
private configuration config ; private strategy _ manager strategy _ manager ; private privoxy _ runner privoxy _ runner ; private gfw _ list _ updater gfw _ list _ updater ; public availability _ statistics availability _ statistics = availability _ statistics . instance ; public statistics _ strategy _ configuration statistics _ configuration { get ; private set ; } private long inbound _ counter = 0 ; private long outbound _ counter = 0 ; public long inbound _ counter = > interlocked . read ( ref inbound _ counter ) ; public long outbound _ counter = > interlocked . read ( ref outbound _ counter ) ;
private long inbound _ counter = 0 ; private long outbound _ counter = 0 ; public long inbound _ counter = > interlocked . read ( ref inbound _ counter ) ; public long outbound _ counter = > interlocked . read ( ref outbound _ counter ) ; public queue _ last < traffic _ per _ second > traffic ; private bool stopped = false ; private bool system _ proxy _ is _ dirty = false ; public class path _ event _ args : event _ args { public string path ;
private void release _ memory ( ) { while ( true ) { utils . release _ memory ( false ) ; thread . sleep ( NUM * NUM ) ; } } private void start _ traffic _ statistics ( int queue _ max _ size ) {
{ utils . release _ memory ( false ) ; thread . sleep ( NUM * NUM ) ; } } private void start _ traffic _ statistics ( int queue _ max _ size ) { traffic = new queue _ last < traffic _ per _ second > ( ) ; for ( int i = 0 ; i < queue _ max _ size ; i + + ) {
} traffic _ thread = new thread ( new thread _ start ( ( ) = > traffic _ statistics ( queue _ max _ size ) ) ) ; traffic _ thread . is _ background = true ; traffic _ thread . start ( ) ; } private void traffic _ statistics ( int queue _ max _ size ) { while ( true ) {
class tcp _ handler { public i _ encryptor encryptor ; public server server ; public socket remote ; public socket connection ; public shadowsocks _ controller controller ;
public socket connection ; public shadowsocks _ controller controller ; public tcp _ relay relay ; public date _ time last _ activity ; private const int max _ retry = NUM ; private int retry _ count = 0 ; private bool connected ; private byte command ; private byte [ ] first _ packet ; private int first _ packet _ length ;
private void top _ most _ menu _ item _ click ( object sender , event _ args e ) { if ( ! top _ most _ trigger _ lock ) { trigger _ top _ most ( ) ; } } private bool show _ toolbar _ trigger = false ; private void show _ toolbar _ menu _ item _ click ( object sender , event _ args e ) {
console . write _ line ( e . to _ string ( ) ) ; } } } class handler { public i _ encryptor encryptor ; public config config ; public socket remote ; public socket connection ;
} } class handler { public i _ encryptor encryptor ; public config config ; public socket remote ; public socket connection ; public const int buffer _ size = NUM ;
class handler { public i _ encryptor encryptor ; public config config ; public socket remote ; public socket connection ; public const int buffer _ size = NUM ; public byte [ ] remote _ buffer = new byte [ buffer _ size ] ;
{ console . write _ line ( e . to _ string ( ) ) ; this . close ( ) ; } } private void start _ pipe ( i _ async _ result ar ) { try { connection . end _ receive ( ar ) ;
this . close ( ) ; } } private void start _ pipe ( i _ async _ result ar ) { try { connection . end _ receive ( ar ) ; remote . begin _ receive ( remote _ buffer , 0 , buffer _ size , 0 , new async _ callback ( pipe _ remote _ receive _ callback ) , null ) ;
} ; static openssl _ encryptor ( ) { open _ ssl . open _ ssl _ add _ all _ ciphers ( ) ; } public openssl _ encryptor ( string method , string password ) : base ( method , password ) { init _ key ( method , password ) ; }
public openssl _ encryptor ( string method , string password ) : base ( method , password ) { init _ key ( method , password ) ; } public override byte [ ] encrypt ( byte [ ] buf , int length ) { if ( encrypt _ ctx = = int _ ptr . zero ) {
public override byte [ ] encrypt ( byte [ ] buf , int length ) { if ( encrypt _ ctx = = int _ ptr . zero ) { int out _ len = length + iv _ len ; byte [ ] cipher _ text = new byte [ out _ len ] ; open _ ssl . evp _ cipher _ update ( encrypt _ ctx , cipher _ text , out out _ len , buf , length ) ; byte [ ] result = new byte [ out _ len + iv _ len ] ; buffer . block _ copy ( iv , 0 , result , 0 , iv _ len ) ; buffer . block _ copy ( cipher _ text , 0 , result , iv _ len , out _ len ) ; return result ; } else {
{ buffer . block _ copy ( iv , 0 , result , 0 , iv _ len ) ; buffer . block _ copy ( cipher _ text , 0 , result , iv _ len , out _ len ) ; return result ; } else { int out _ len = length + iv _ len ; byte [ ] cipher _ text = new byte [ out _ len ] ; open _ ssl . evp _ cipher _ update ( encrypt _ ctx , cipher _ text , out out _ len , buf , length ) ; byte [ ] result = new byte [ out _ len ] ; buffer . block _ copy ( cipher _ text , 0 , result , 0 , out _ len ) ; return result ; } }
else { open _ ssl . evp _ cipher _ update ( encrypt _ ctx , cipher _ text , out out _ len , buf , length ) ; byte [ ] result = new byte [ out _ len ] ; buffer . block _ copy ( cipher _ text , 0 , result , 0 , out _ len ) ; return result ; } } public override byte [ ] decrypt ( byte [ ] buf , int length ) { if ( decrypt _ ctx = = int _ ptr . zero ) {
} public override byte [ ] decrypt ( byte [ ] buf , int length ) { if ( decrypt _ ctx = = int _ ptr . zero ) { byte [ ] cipher _ text = new byte [ out _ len ] ; byte [ ] subset = new byte [ length - iv _ len ] ; buffer . block _ copy ( buf , iv _ len , subset , 0 , length - iv _ len ) ; open _ ssl . evp _ cipher _ update ( decrypt _ ctx , cipher _ text , out out _ len , subset , length - iv _ len ) ; byte [ ] result = new byte [ out _ len ] ; buffer . block _ copy ( cipher _ text , 0 , result , 0 , out _ len ) ; return result ; } else {
using system ; using system _ collections _ generic ; using system _ text ; namespace shadowsocks _ csharp _ encrypt {
using system ; using system _ collections _ generic ; using system _ text ; namespace shadowsocks _ csharp _ encrypt { public interface i _ encryptor {
} for ( int i = 1 ; i < NUM ; i + + ) { encrypt _ table = merge _ sort ( encrypt _ table , a , i ) ; } for ( int i = 0 ; i < NUM ; i + + ) { decrypt _ table [ encrypt _ table [ i ] ] = ( byte ) i ; } }
for ( int i = 0 ; i < NUM ; i + + ) { decrypt _ table [ encrypt _ table [ i ] ] = ( byte ) i ; } } public override byte [ ] encrypt ( byte [ ] buf , int length ) { byte [ ] result = new byte [ length ] ; for ( int i = 0 ; i < length ; i + + ) {
decrypt _ table [ encrypt _ table [ i ] ] = ( byte ) i ; } } public override byte [ ] encrypt ( byte [ ] buf , int length ) { byte [ ] result = new byte [ length ] ; for ( int i = 0 ; i < length ; i + + ) { result [ i ] = encrypt _ table [ buf [ i ] ] ; }
} public override byte [ ] encrypt ( byte [ ] buf , int length ) { byte [ ] result = new byte [ length ] ; for ( int i = 0 ; i < length ; i + + ) { result [ i ] = encrypt _ table [ buf [ i ] ] ; } return result ; }
{ result [ i ] = encrypt _ table [ buf [ i ] ] ; } return result ; } public override byte [ ] decrypt ( byte [ ] buf , int length ) { byte [ ] result = new byte [ length ] ; for ( int i = 0 ; i < length ; i + + ) {
} return result ; } public override byte [ ] decrypt ( byte [ ] buf , int length ) { byte [ ] result = new byte [ length ] ; for ( int i = 0 ; i < length ; i + + ) { result [ i ] = decrypt _ table [ buf [ i ] ] ; }
using system ; using system _ windows _ forms ; using microsoft _ win ; using shadowsocks _ util ; namespace shadowsocks _ controller {
using system ; using system _ windows _ forms ; using microsoft _ win ; using shadowsocks _ util ; namespace shadowsocks _ controller { class auto _ startup {
{ class auto _ startup { static string key = STR + application . startup _ path . get _ hash _ code ( ) ; public static bool set ( bool enabled ) { registry _ key run _ key = null ; try {
try { string path = application . executable _ path ; run _ key = utils . open _ reg _ key ( STR , true ) ; if ( run _ key = = null ) { logging . error ( STR ) ; return false ; } if ( enabled ) {
foreach ( string item in run _ list ) { if ( item . equals ( key , string _ comparison . ordinal _ ignore _ case ) ) return true ; else if ( item . equals ( STR , string _ comparison . ordinal _ ignore _ case ) ) { string value = convert . to _ string ( run _ key . get _ value ( item ) ) ; if ( path . equals ( value , string _ comparison . ordinal _ ignore _ case ) ) { run _ key . delete _ value ( item ) ;
state = state ; } public async _ session ( async _ session session , t state ) : base ( session . remote ) { state = state ; } } public static readonly int recv _ size = NUM ; public static readonly int recv _ reserve _ size = iv _ encryptor . onetimeauth _ bytes + iv _ encryptor . auth _ bytes ; public static readonly int buffer _ size = recv _ size + recv _ reserve _ size + NUM ;
{ state = state ; } } public static readonly int recv _ size = NUM ; public static readonly int recv _ reserve _ size = iv _ encryptor . onetimeauth _ bytes + iv _ encryptor . auth _ bytes ; public static readonly int buffer _ size = recv _ size + recv _ reserve _ size + NUM ; public i _ encryptor encryptor ; public server server ; private async _ session current _ remote _ session ;
private byte [ ] connetion _ recv _ buffer = new byte [ buffer _ size ] ; private byte [ ] connetion _ send _ buffer = new byte [ buffer _ size ] ; private bool connection _ shutdown = false ; private bool remote _ shutdown = false ; private bool closed = false ; private object encryption _ lock = new object ( ) ; private object decryption _ lock = new object ( ) ; private date _ time start _ connect _ time ; private date _ time start _ receiving _ time ; private date _ time start _ sending _ time ;
private object encryption _ lock = new object ( ) ; private object decryption _ lock = new object ( ) ; private date _ time start _ connect _ time ; private date _ time start _ receiving _ time ; private date _ time start _ sending _ time ; private int bytes _ to _ send ; private tcp _ relay tcprelay ; private configuration config ; public tcp _ handler ( tcp _ relay tcprelay , configuration config ) { this . tcprelay = tcprelay ;
handshake _ receive ( ) ; last _ activity = date _ time . now ; } private void check _ close ( ) { if ( connection _ shutdown & & remote _ shutdown ) close ( ) ; } public void close ( ) {
close ( ) ; } public void close ( ) { lock ( tcprelay . handlers ) { tcprelay . handlers . remove ( this ) ; } lock ( this ) { if ( closed ) return ; closed = true ; }
* cipher _ setkey ( ) will set the correct key schedule * and operation * * mbedtls _ aes { en , de } crypt * = = mbedtls _ blowfish { en , de } crypt * = = mbedtls _ camellia { en , de } crypt * = = mbedtls { en , de } crypt * * / if ( mbed _ tls . cipher _ setkey ( ctx , realkey , key _ len * NUM , is _ cipher ? mbed _ tls . mbedtls _ encrypt : mbed _ tls . mbedtls _ decrypt ) ! = 0 )
* * mbedtls _ aes { en , de } crypt * = = mbedtls _ blowfish { en , de } crypt * = = mbedtls _ camellia { en , de } crypt * = = mbedtls { en , de } crypt * * / if ( mbed _ tls . cipher _ setkey ( ctx , realkey , key _ len * NUM , is _ cipher ? mbed _ tls . mbedtls _ encrypt : mbed _ tls . mbedtls _ decrypt ) ! = 0 ) throw new exception ( ) ; if ( mbed _ tls . cipher _ set _ iv ( ctx , iv , iv _ len ) ! = 0 )
* = = mbedtls _ blowfish { en , de } crypt * = = mbedtls _ camellia { en , de } crypt * = = mbedtls { en , de } crypt * * / if ( mbed _ tls . cipher _ setkey ( ctx , realkey , key _ len * NUM , is _ cipher ? mbed _ tls . mbedtls _ encrypt : mbed _ tls . mbedtls _ decrypt ) ! = 0 ) throw new exception ( ) ; if ( mbed _ tls . cipher _ set _ iv ( ctx , iv , iv _ len ) ! = 0 ) throw new exception ( ) ; if ( mbed _ tls . cipher _ reset ( ctx ) ! = 0 )
strings [ line . substring ( 0 , pos ) ] = line . substring ( pos + 1 ) ; } } } static n ( ) { string name = culture _ info . current _ culture . english _ name ; if ( name . starts _ with ( STR , string _ comparison . ordinal _ ignore _ case ) ) { init ( name . contains ( STR )
{ string name = culture _ info . current _ culture . english _ name ; if ( name . starts _ with ( STR , string _ comparison . ordinal _ ignore _ case ) ) { init ( name . contains ( STR ) ? resources . zh _ tw : resources . cn ) ; } else if ( name . starts _ with ( STR , string _ comparison . ordinal _ ignore _ case ) ) {
using shadowsocks _ encryption ; using shadowsocks _ model ; using system _ net _ sockets ; using system _ net ; using system _ runtime _ compiler _ services ; namespace shadowsocks _ controller { class udp _ relay : listener . service {
using system _ net _ sockets ; using system _ net ; using system _ runtime _ compiler _ services ; namespace shadowsocks _ controller { class udp _ relay : listener . service { private configuration config ; private lru _ cache < ip _ end _ point , udp _ handler > cache ;
using system _ runtime _ compiler _ services ; namespace shadowsocks _ controller { class udp _ relay : listener . service { private configuration config ; private lru _ cache < ip _ end _ point , udp _ handler > cache ; public udp _ relay ( configuration config ) {
string text = n . get _ string ( STR ) + STR + update _ checker . version + STR + ( enabled ? n . get _ string ( STR ) + ( global ? n . get _ string ( STR ) : n . get _ string ( STR ) ) : string . format ( n . get _ string ( STR ) , config . local _ port ) )
create _ menu _ item ( STR , new event _ handler ( this . quit _ click ) ) } ) ; } private void controller _ config _ changed ( object sender , event _ args e ) { load _ current _ configuration ( ) ; update _ tray _ icon ( ) ; } private void controller _ enable _ status _ changed ( object sender , event _ args e ) {
load _ current _ configuration ( ) ; update _ tray _ icon ( ) ; } private void controller _ enable _ status _ changed ( object sender , event _ args e ) { enable _ item . checked = controller . get _ configuration ( ) . enabled ; mode _ item . enabled = enable _ item . checked ; } void controller _ share _ over _ lan _ status _ changed ( object sender , event _ args e ) {
{ enable _ item . checked = controller . get _ configuration ( ) . enabled ; mode _ item . enabled = enable _ item . checked ; } void controller _ share _ over _ lan _ status _ changed ( object sender , event _ args e ) { share _ over _ lan _ item . checked = controller . get _ configuration ( ) . share _ over _ lan ; } void controller _ enable _ global _ changed ( object sender , event _ args e ) {
local _ pac _ item . checked = ! online _ pac _ item . checked ; update _ pac _ items _ enabled _ status ( ) ; } private void update _ servers _ menu ( ) { var items = servers _ item . menu _ items ; while ( items [ 0 ] ! = seperator _ item ) { items . remove _ at ( 0 ) ; }
} configuration configuration = controller . get _ configuration ( ) ; for ( int i = 0 ; i < configuration . configs . count ; i + + ) { server server = configuration . configs [ i ] ; menu _ item item = new menu _ item ( server . friendly _ name ( ) ) ; item . tag = i ; item . click + = a _ server _ item _ click ; items . add ( i , item ) ;
using system _ text ; using system _ net _ sockets ; using system _ net ; using shadowsocks _ encryption ; using shadowsocks _ model ; namespace shadowsocks _ controller { class tcp _ relay : listener . service {
{ if ( errored ! = null ) { errored ( this , new error _ event _ args ( e ) ) ; } } public server get _ current _ server ( ) { return config . get _ current _ server ( ) ; }
} } ; } } public static void save ( configuration config ) { if ( config . index > = config . configs . count ) { config . index = config . configs . count - 1 ; }
} } public static void save ( configuration config ) { if ( config . index > = config . configs . count ) { config . index = config . configs . count - 1 ; } if ( config . index < 0 ) {
this . close ( ) ; } } } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; this . close ( ) ; } }
if ( controller ! = null ) { system . timers . timer timer = new system . timers . timer ( NUM * NUM ) ; timer . elapsed + = timer _ elapsed ; timer . auto _ reset = false ; timer . enabled = true ; timer . start ( ) ; } break ; case power _ modes . suspend :
controller ? . stop ( ) ; logging . info ( STR ) ; break ; } } private static void timer _ elapsed ( object sender , system . timers . elapsed _ event _ args e ) { try {
user _ rule _ file _ ready _ to _ open ( this , new path _ event _ args ( ) { path = user _ rule _ filename } ) ; } } public string get _ qr _ code _ for _ current _ server ( ) { server server = get _ current _ server ( ) ; return get _ qr _ code ( server ) ; } public static string get _ qr _ code ( server server ) {
{ server server = get _ current _ server ( ) ; return get _ qr _ code ( server ) ; } public static string get _ qr _ code ( server server ) { string parts = server . method ; if ( server . auth ) parts + = STR ; parts + = STR + server . password + STR + server . server + STR + server . server _ port ; string base = convert . to _ base _ string ( encoding . ut . get _ bytes ( parts ) ) ;
password = STR ; remarks = STR ; auth = false ; timeout = default _ server _ timeout _ sec ; } public server ( string ss _ url ) : this ( ) { var match = url _ finder . match ( ss _ url ) ; if ( ! match . success ) throw new format _ exception ( ) ; var base = match . groups [ 1 ] . value ;
auth = false ; timeout = default _ server _ timeout _ sec ; } public server ( string ss _ url ) : this ( ) { var match = url _ finder . match ( ss _ url ) ; if ( ! match . success ) throw new format _ exception ( ) ; var base = match . groups [ 1 ] . value ; var tag = match . groups [ 2 ] . value ; if ( ! tag . is _ null _ or _ empty ( ) )
connection . begin _ send ( response , 0 , response . length , socket _ flags . none , new async _ callback ( read _ all ) , true ) ; } private void read _ all ( i _ async _ result ar ) { if ( closed ) return ; try { if ( ar . async _ state ! = null ) { connection . end _ send ( ar ) ;
{ connection . end _ send ( ar ) ; logging . debug ( remote . local _ end _ point , remote . dest _ end _ point , recv _ size , STR ) ; connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , socket _ flags . none , new async _ callback ( read _ all ) , null ) ; } else { int bytes _ read = connection . end _ receive ( ar ) ; if ( bytes _ read > 0 ) {
{ console . write _ line ( e . to _ string ( ) ) ; this . close ( ) ; } } private void handshake _ receive _ callback ( i _ async _ result ar ) { try { int bytes _ read = connection . end _ receive ( ar ) ;
{ dispose ( false ) ; } protected virtual void dispose ( bool disposing ) { if ( ! disposed ) { if ( disposing ) { }
{ if ( disposing ) { } if ( encrypt _ ctx ! = int _ ptr . zero ) { open _ ssl . evp _ cipher _ ctx _ cleanup ( encrypt _ ctx ) ; open _ ssl . evp _ cipher _ ctx _ free ( encrypt _ ctx ) ; encrypt _ ctx = int _ ptr . zero ; }
private static void ie _ auto _ detect _ proxy ( bool set ) { var registry = registry . current _ user . open _ sub _ key ( STR , true ) ; var def _ connection = ( byte [ ] ) registry . get _ value ( STR ) ; var saved _ legacy _ setting = ( byte [ ] ) registry . get _ value ( STR ) ; if ( set ) {
var saved _ legacy _ setting = ( byte [ ] ) registry . get _ value ( STR ) ; if ( set ) { def _ connection [ NUM ] = ( byte ) ( def _ connection [ NUM ] | NUM ) ; saved _ legacy _ setting [ NUM ] = ( byte ) ( saved _ legacy _ setting [ NUM ] | NUM ) ; } else {
if ( set ) { def _ connection [ NUM ] = ( byte ) ( def _ connection [ NUM ] | NUM ) ; saved _ legacy _ setting [ NUM ] = ( byte ) ( saved _ legacy _ setting [ NUM ] | NUM ) ; } else { def _ connection [ NUM ] = ( byte ) ( def _ connection [ NUM ] & ~ NUM ) ; saved _ legacy _ setting [ NUM ] = ( byte ) ( saved _ legacy _ setting [ NUM ] & ~ NUM ) ; }
using system _ net ; using system _ net _ network _ information ; using system _ net _ sockets ; using system _ threading ; using system _ threading _ tasks ; using shadowsocks _ model ; using shadowsocks _ util ; namespace shadowsocks _ controller {
public static availability _ statistics instance { get ; } = new availability _ statistics ( ) ;
public static availability _ statistics instance { get ; } = new availability _ statistics ( ) ; private availability _ statistics ( ) { } public const string date _ time _ pattern = STR ; private const string statistics _ files _ name = STR ; private const string delimiter = STR ; private const int timeout _ milliseconds = NUM ; private readonly time _ span delay _ before _ start = time _ span . from _ seconds ( 1 ) ; public statistics raw _ statistics { get ; private set ; } public statistics filtered _ statistics { get ; private set ; }
public static availability _ statistics instance { get ; } = new availability _ statistics ( ) ; private availability _ statistics ( ) { } public const string date _ time _ pattern = STR ; private const string statistics _ files _ name = STR ; private const string delimiter = STR ; private const int timeout _ milliseconds = NUM ; private readonly time _ span delay _ before _ start = time _ span . from _ seconds ( 1 ) ; public statistics raw _ statistics { get ; private set ; } public statistics filtered _ statistics { get ; private set ; } public static readonly date _ time unknown _ date _ time = new date _ time ( NUM , 1 , 1 ) ; private int repeat = > config . repeat _ times _ num ;
{ availability _ statistics _ file = utils . get _ temp _ path ( statistics _ files _ name ) ; } public bool set ( statistics _ strategy _ configuration config ) { config = config ; try { if ( config . statistics _ enabled ) {
if ( config . statistics _ enabled ) { if ( timer ? . change ( delay _ before _ start , interval ) = = null ) { state = new state ( ) ; timer = new timer ( run , state , delay _ before _ start , interval ) ; } } else {
catch ( exception e ) { logging . log _ useful _ exception ( e ) ; return false ; } } private void update _ speed ( object state ) { var bytes = controller . inbound _ counter - last _ inbound _ counter ; last _ inbound _ counter = controller . inbound _ counter ;
} private void update _ speed ( object state ) { var bytes = controller . inbound _ counter - last _ inbound _ counter ; last _ inbound _ counter = controller . inbound _ counter ; var inbound _ speed = get _ speed _ in _ ki _ b _ per _ second ( bytes , monitor _ interval . total _ seconds ) ; bytes = controller . outbound _ counter - last _ outbound _ counter ; last _ outbound _ counter = controller . outbound _ counter ; var outbound _ speed = get _ speed _ in _ ki _ b _ per _ second ( bytes , monitor _ interval . total _ seconds ) ;
var outbound _ speed = get _ speed _ in _ ki _ b _ per _ second ( bytes , monitor _ interval . total _ seconds ) ; if ( outbound _ speed > outbound _ speed ) { outbound _ speed = outbound _ speed ; } logging . debug ( $ STR ) ; } private async task < list < data _ list > > icmp _ test ( server server ) { logging . debug ( STR + server . friendly _ name ( ) ) ; if ( server . server = = STR ) return null ;
} logging . debug ( $ STR ) ; } private async task < list < data _ list > > icmp _ test ( server server ) { logging . debug ( STR + server . friendly _ name ( ) ) ; if ( server . server = = STR ) return null ; var ret = new list < data _ list > ( ) ; try { var ip = dns . get _ host _ addresses ( server . server ) . first ( ip = > ( ip . address _ family = = address _ family . inter _ network | | ip . address _ family = = address _ family . inter _ network ) ) ; var ping = new ping ( ) ;
logging . debug ( STR + server . friendly _ name ( ) ) ; if ( server . server = = STR ) return null ; var ret = new list < data _ list > ( ) ; try { var ip = dns . get _ host _ addresses ( server . server ) . first ( ip = > ( ip . address _ family = = address _ family . inter _ network | | ip . address _ family = = address _ family . inter _ network ) ) ; var ping = new ping ( ) ; foreach ( var timestamp in enumerable . range ( 0 , repeat ) . select ( = > date _ time . now . to _ string ( date _ time _ pattern ) ) ) { try { var reply = await ping . send _ task _ async ( ip , timeout _ milliseconds ) ;
logging . log _ useful _ exception ( e ) ; } } } catch ( exception e ) { logging . error ( $ STR ) ; logging . log _ useful _ exception ( e ) ; }
outbound _ speed = 0 ; } private void run ( object obj ) { if ( speed _ monior ? . change ( delay _ before _ start , monitor _ interval ) = = null ) { speed _ monior = new timer ( update _ speed , null , delay _ before _ start , monitor _ interval ) ; } load _ raw _ statistics ( ) ; filter _ raw _ statistics ( ) ;
} catch ( io _ exception e ) { logging . log _ useful _ exception ( e ) ; } } internal void update _ configuration ( shadowsocks _ controller controller ) { controller = controller ;
private void filter _ raw _ statistics ( ) { if ( raw _ statistics = = null ) return ; if ( filtered _ statistics = = null ) { filtered _ statistics = new statistics ( ) ; }
try { using ( var fs = file . create ( path ) ) { } } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; }
} catch ( exception e ) { logging . log _ useful _ exception ( e ) ; } if ( ! file . exists ( path ) ) { console . write _ line ( $ STR ) ; timer . change ( retry _ interval , interval ) ; return ; } }
} ) . to _ dictionary ( server = > server . server _ name , server = > server . data ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; } } private date _ time parse _ exact _ or _ unknown ( string str ) { date _ time date _ time ;
} private date _ time parse _ exact _ or _ unknown ( string str ) { date _ time date _ time ; } public class statistics _ data { public float package _ loss ; public int average _ response ; public int min _ response ; public int max _ response ; } public void update _ latency ( int latency ) {
} controller ? . save _ strategy _ configurations ( configuration ) ; controller ? . update _ statistics _ configuration ( statistics _ enabled _ check _ box . checked ) ; close ( ) ; } private void load _ chart _ data ( ) { string server _ name = servers [ server _ selector . selected _ index ] ; data _ table . rows . clear ( ) ; if ( controller . availability _ statistics ? . filtered _ statistics = = null ) return ;
controller ? . update _ statistics _ configuration ( statistics _ enabled _ check _ box . checked ) ; close ( ) ; } private void load _ chart _ data ( ) { string server _ name = servers [ server _ selector . selected _ index ] ; data _ table . rows . clear ( ) ; if ( controller . availability _ statistics ? . filtered _ statistics = = null ) return ; list < availability _ statistics . raw _ statistics _ data > statistics ; if ( ! controller . availability _ statistics . filtered _ statistics . try _ get _ value ( server _ name , out statistics ) ) return ;
using newtonsoft _ json ; using shadowsocks _ model ; namespace shadowsocks _ controller _ strategy { class statistics _ strategy : i _ strategy { private readonly shadowsocks _ controller controller ; private server current _ server ; private readonly timer timer ;
} private void reload _ statistics _ and _ choose _ a _ server ( object obj ) { logging . debug ( STR ) ; var servers = controller . get _ current _ configuration ( ) . configs ; load _ statistics ( ) ; choose _ new _ server ( servers ) ; } private void load _ statistics ( ) {
choose _ new _ server ( servers ) ; } private void load _ statistics ( ) { filtered _ statistics = controller . availability _ statistics . raw _ statistics ? ? filtered _ statistics ? ? new dictionary < string , list < availability _ statistics . raw _ statistics _ data > > ( ) ; } private float get _ score ( string server _ name ) { var config = controller . statistics _ configuration ;
max _ response = data _ list . max ( data = > data . roundtrip _ time ) } ; float factor ; float score = 0 ; if ( ! config . calculations . try _ get _ value ( STR , out factor ) ) factor = 0 ;
float factor ; float score = 0 ; if ( ! config . calculations . try _ get _ value ( STR , out factor ) ) factor = 0 ; score + = statistics _ data . package _ loss * factor ; if ( ! config . calculations . try _ get _ value ( STR , out factor ) ) factor = 0 ;
if ( ! config . calculations . try _ get _ value ( STR , out factor ) ) factor = 0 ; score + = statistics _ data . package _ loss * factor ; if ( ! config . calculations . try _ get _ value ( STR , out factor ) ) factor = 0 ; score + = statistics _ data . average _ response * factor ; if ( ! config . calculations . try _ get _ value ( STR , out factor ) ) factor = 0 ;
if ( ! config . calculations . try _ get _ value ( STR , out factor ) ) factor = 0 ; score + = statistics _ data . package _ loss * factor ; if ( ! config . calculations . try _ get _ value ( STR , out factor ) ) factor = 0 ; score + = statistics _ data . average _ response * factor ; if ( ! config . calculations . try _ get _ value ( STR , out factor ) ) factor = 0 ; score + = statistics _ data . min _ response * factor ; if ( ! config . calculations . try _ get _ value ( STR , out factor ) ) factor = 0 ;
this . edit _ pac _ file _ item = new system . windows . forms . menu _ item ( ) ; this . about _ item = new system . windows . forms . menu _ item ( ) ; this . menu _ item = new system . windows . forms . menu _ item ( ) ; this . quit _ item = new system . windows . forms . menu _ item ( ) ; this . panel = new system . windows . forms . panel ( ) ; this . delete _ button = new system . windows . forms . button ( ) ; this . add _ button = new system . windows . forms . button ( ) ; this . server _ group _ box = new system . windows . forms . group _ box ( ) ; this . servers _ list _ box = new system . windows . forms . list _ box ( ) ;
this . table _ layout _ panel . controls . add ( this . label , 0 , 0 ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , 1 ) ; this . table _ layout _ panel . controls . add ( this . proxy _ port _ text _ box , 1 , NUM ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , 2 ) ; this . table _ layout _ panel . controls . add ( this . ip _ text _ box , 1 , 0 ) ; this . table _ layout _ panel . controls . add ( this . server _ port _ text _ box , 1 , 1 ) ; this . table _ layout _ panel . controls . add ( this . password _ text _ box , 1 , 2 ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . encryption _ select , 1 , NUM ) ;
this . table _ layout _ panel . controls . add ( this . label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , 2 ) ; this . table _ layout _ panel . controls . add ( this . ip _ text _ box , 1 , 0 ) ; this . table _ layout _ panel . controls . add ( this . server _ port _ text _ box , 1 , 1 ) ; this . table _ layout _ panel . controls . add ( this . password _ text _ box , 1 , 2 ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . encryption _ select , 1 , NUM ) ; this . table _ layout _ panel . location = new system . drawing . point ( NUM , NUM ) ; this . table _ layout _ panel . margin = new system . windows . forms . padding ( NUM ) ; this . table _ layout _ panel . name = STR ;
this . table _ layout _ panel . row _ count = NUM ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ; this . table _ layout _ panel . tab _ index = 0 ; this . remarks _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ;
this . table _ layout _ panel . tab _ index = 0 ; this . remarks _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . remarks _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . remarks _ text _ box . name = STR ; this . remarks _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . remarks _ text _ box . tab _ index = NUM ; this . remarks _ text _ box . word _ wrap = false ; this . label . anchor = system . windows . forms . anchor _ styles . right ; this . label . auto _ size = true ;
this . label . anchor = system . windows . forms . anchor _ styles . right ; this . label . auto _ size = true ; this . label . location = new system . drawing . point ( NUM , NUM ) ; this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ; this . label . tab _ index = NUM ; this . label . text = STR ; this . label . anchor = system . windows . forms . anchor _ styles . right ; this . label . auto _ size = true ;
this . label . anchor = system . windows . forms . anchor _ styles . right ; this . label . auto _ size = true ; this . label . location = new system . drawing . point ( NUM , NUM ) ; this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ; this . label . tab _ index = 0 ; this . label . text = STR ; this . label . anchor = system . windows . forms . anchor _ styles . right ; this . label . auto _ size = true ;
this . label . text = STR ; this . label . anchor = system . windows . forms . anchor _ styles . right ; this . label . auto _ size = true ; this . label . location = new system . drawing . point ( NUM , NUM ) ; this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ; this . label . tab _ index = 1 ; this . label . text = STR ; this . proxy _ port _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ;
this . label . text = STR ; this . proxy _ port _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . proxy _ port _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . proxy _ port _ text _ box . name = STR ; this . proxy _ port _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . proxy _ port _ text _ box . tab _ index = NUM ; this . proxy _ port _ text _ box . word _ wrap = false ; this . label . anchor = system . windows . forms . anchor _ styles . right ; this . label . auto _ size = true ;
this . label . anchor = system . windows . forms . anchor _ styles . right ; this . label . auto _ size = true ; this . label . location = new system . drawing . point ( NUM , NUM ) ; this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ; this . label . tab _ index = NUM ; this . label . text = STR ; this . label . anchor = system . windows . forms . anchor _ styles . right ; this . label . auto _ size = true ;
this . label . text = STR ; this . label . anchor = system . windows . forms . anchor _ styles . right ; this . label . auto _ size = true ; this . label . location = new system . drawing . point ( NUM , NUM ) ; this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ; this . label . tab _ index = 2 ; this . label . text = STR ; this . ip _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ;
this . label . tab _ index = 2 ; this . label . text = STR ; this . ip _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . ip _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . ip _ text _ box . name = STR ; this . ip _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . ip _ text _ box . tab _ index = 0 ; this . ip _ text _ box . word _ wrap = false ; this . server _ port _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ;
this . ip _ text _ box . tab _ index = 0 ; this . ip _ text _ box . word _ wrap = false ; this . server _ port _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . server _ port _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . server _ port _ text _ box . name = STR ; this . server _ port _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . server _ port _ text _ box . tab _ index = 1 ; this . server _ port _ text _ box . word _ wrap = false ; this . password _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ;
this . password _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . password _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . password _ text _ box . name = STR ; this . password _ text _ box . password _ char = '*' ; this . password _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . password _ text _ box . tab _ index = 2 ; this . password _ text _ box . word _ wrap = false ; this . label . anchor = system . windows . forms . anchor _ styles . right ; this . label . auto _ size = true ;
this . encryption _ select . ime _ mode = system . windows . forms . ime _ mode . no _ control ; this . encryption _ select . item _ height = NUM ; this . encryption _ select . items . add _ range ( new object [ ] { STR , STR , STR , STR , STR , STR , STR } ) ;
STR , STR , STR , STR , STR } ) ; this . encryption _ select . location = new system . drawing . point ( NUM , NUM ) ; this . encryption _ select . name = STR ; this . encryption _ select . size = new system . drawing . size ( NUM , NUM ) ; this . encryption _ select . tab _ index = NUM ;
STR , STR , STR } ) ; this . encryption _ select . location = new system . drawing . point ( NUM , NUM ) ; this . encryption _ select . name = STR ; this . encryption _ select . size = new system . drawing . size ( NUM , NUM ) ; this . encryption _ select . tab _ index = NUM ; this . notify _ icon . icon = ( ( system . drawing . icon ) ( resources . get _ object ( STR ) ) ) ; this . notify _ icon . text = STR ;
this . encryption _ select . name = STR ; this . encryption _ select . size = new system . drawing . size ( NUM , NUM ) ; this . encryption _ select . tab _ index = NUM ; this . notify _ icon . icon = ( ( system . drawing . icon ) ( resources . get _ object ( STR ) ) ) ; this . notify _ icon . text = STR ; this . notify _ icon . visible = true ; this . notify _ icon . double _ click + = new system . event _ handler ( this . notify _ icon _ double _ click ) ; this . panel . anchor = system . windows . forms . anchor _ styles . top ; this . panel . auto _ size = true ; this . panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ;
this . notify _ icon . double _ click + = new system . event _ handler ( this . notify _ icon _ double _ click ) ; this . panel . anchor = system . windows . forms . anchor _ styles . top ; this . panel . auto _ size = true ; this . panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . panel . location = new system . drawing . point ( NUM , NUM ) ; this . panel . name = STR ; this . panel . size = new system . drawing . size ( 0 , 0 ) ; this . panel . tab _ index = 1 ; this . ok _ button . dialog _ result = system . windows . forms . dialog _ result . ok ;
this . ok _ button . dialog _ result = system . windows . forms . dialog _ result . ok ; this . ok _ button . location = new system . drawing . point ( NUM , NUM ) ; this . ok _ button . name = STR ; this . ok _ button . size = new system . drawing . size ( NUM , NUM ) ; this . ok _ button . tab _ index = NUM ; this . ok _ button . text = STR ; this . ok _ button . use _ visual _ style _ back _ color = true ; this . ok _ button . click + = new system . event _ handler ( this . ok _ button _ click ) ; this . my _ cancel _ button . dialog _ result = system . windows . forms . dialog _ result . cancel ;
this . quit _ item . text = STR ; this . quit _ item . click + = new system . event _ handler ( this . quit _ click ) ; this . panel . auto _ size = true ; this . panel . controls . add ( this . delete _ button ) ; this . panel . controls . add ( this . add _ button ) ; this . panel . location = new system . drawing . point ( NUM , NUM ) ; this . panel . margin = new system . windows . forms . padding ( 0 ) ; this . panel . name = STR ; this . panel . size = new system . drawing . size ( NUM , NUM ) ; this . panel . tab _ index = NUM ;
this . panel . size = new system . drawing . size ( NUM , NUM ) ; this . panel . tab _ index = NUM ; this . delete _ button . location = new system . drawing . point ( NUM , NUM ) ; this . delete _ button . name = STR ; this . delete _ button . size = new system . drawing . size ( NUM , NUM ) ; this . delete _ button . tab _ index = NUM ; this . delete _ button . text = STR ; this . delete _ button . use _ visual _ style _ back _ color = true ; this . delete _ button . click + = new system . event _ handler ( this . delete _ button _ click ) ;
this . delete _ button . click + = new system . event _ handler ( this . delete _ button _ click ) ; this . add _ button . location = new system . drawing . point ( NUM , NUM ) ; this . add _ button . name = STR ; this . add _ button . size = new system . drawing . size ( NUM , NUM ) ; this . add _ button . tab _ index = NUM ; this . add _ button . text = STR ; this . add _ button . use _ visual _ style _ back _ color = true ; this . add _ button . click + = new system . event _ handler ( this . add _ button _ click ) ; this . server _ group _ box . controls . add ( this . table _ layout _ panel ) ;
this . add _ button . name = STR ; this . add _ button . size = new system . drawing . size ( NUM , NUM ) ; this . add _ button . tab _ index = NUM ; this . add _ button . text = STR ; this . add _ button . use _ visual _ style _ back _ color = true ; this . add _ button . click + = new system . event _ handler ( this . add _ button _ click ) ; this . server _ group _ box . controls . add ( this . table _ layout _ panel ) ; this . server _ group _ box . location = new system . drawing . point ( NUM , NUM ) ; this . server _ group _ box . name = STR ;
this . server _ group _ box . controls . add ( this . table _ layout _ panel ) ; this . server _ group _ box . location = new system . drawing . point ( NUM , NUM ) ; this . server _ group _ box . name = STR ; this . server _ group _ box . size = new system . drawing . size ( NUM , NUM ) ; this . server _ group _ box . tab _ index = NUM ; this . server _ group _ box . tab _ stop = false ; this . server _ group _ box . text = STR ; this . servers _ list _ box . formatting _ enabled = true ;
internal string touch _ user _ rule _ file ( ) { if ( ! file . exists ( user _ rule _ file ) ) { file . write _ all _ text ( user _ rule _ file , resources . user _ rule ) ; } return user _ rule _ file ; } internal string get _ pac _ content ( ) {
if ( ! file . exists ( user _ rule _ file ) ) { file . write _ all _ text ( user _ rule _ file , resources . user _ rule ) ; } return user _ rule _ file ; } internal string get _ pac _ content ( ) { if ( file . exists ( pac _ file ) ) {
file . write _ all _ text ( user _ rule _ file , resources . user _ rule ) ; } return user _ rule _ file ; } internal string get _ pac _ content ( ) { if ( file . exists ( pac _ file ) ) { return file . read _ all _ text ( pac _ file , encoding . ut ) ; }
listener . udp _ state udp _ state = ( listener . udp _ state ) state ; ip _ end _ point remote _ end _ point = ( ip _ end _ point ) udp _ state . remote _ end _ point ; udp _ handler handler = cache . get ( remote _ end _ point ) ; if ( handler = = null ) { handler = new udp _ handler ( socket , controller . get _ a _ server ( i _ strategy _ caller _ type . udp , remote _ end _ point , null cache . add ( remote _ end _ point , handler ) ; } handler . send ( first _ packet , length ) ;
timeout = timeout . value , } ; return true ; } if ( check _ ip = = null | | check _ port = = null | | check _ timeout = = null ) { modified _ configuration . configs . remove _ at ( last _ selected _ index ) ; servers _ list _ box . selected _ index _ changed - = servers _ list _ box _ selected _ index _ changed ; load _ server _ name _ list _ to _ ui ( modified _ configuration ) ;
update _ buttons ( ) ; load _ selected _ server _ details ( ) ; last _ selected _ index = servers _ list _ box . selected _ index ; } private void add _ button _ click ( object sender , event _ args e ) { if ( validate _ and _ save _ selected _ server _ details ( is _ save : true ) ) { configuration . add _ default _ server _ or _ server ( modified _ configuration ) ; load _ server _ name _ list _ to _ ui ( modified _ configuration ) ;
configuration . add _ default _ server _ or _ server ( modified _ configuration ) ; load _ server _ name _ list _ to _ ui ( modified _ configuration ) ; update _ index _ to _ end ( ) ; } } private void duplicate _ button _ click ( object sender , event _ args e ) { if ( validate _ and _ save _ selected _ server _ details ( is _ copy : true ) ) { server curr _ server = modified _ configuration . configs [ last _ selected _ index ] ;
update _ index _ to _ end ( ) ; } } private void duplicate _ button _ click ( object sender , event _ args e ) { if ( validate _ and _ save _ selected _ server _ details ( is _ copy : true ) ) { server curr _ server = modified _ configuration . configs [ last _ selected _ index ] ; configuration . add _ default _ server _ or _ server ( modified _ configuration , curr _ server ) ; load _ server _ name _ list _ to _ ui ( modified _ configuration ) ;
} private void move _ down _ button _ click ( object sender , event _ args e ) { if ( servers _ list _ box . selected _ index < servers _ list _ box . items . count - 1 ) { move _ config _ item ( + 1 ) ; } } private void move _ config _ item ( int step ) {
if ( servers _ list _ box . selected _ index < servers _ list _ box . items . count - 1 ) { move _ config _ item ( + 1 ) ; } } private void move _ config _ item ( int step ) { int index = servers _ list _ box . selected _ index ; server server = modified _ configuration . configs [ index ] ; object item = servers _ list _ box . items [ index ] ; modified _ configuration . configs . remove ( server ) ; modified _ configuration . configs . insert ( index + step , server ) ; modified _ configuration . index + = step ; servers _ list _ box . begin _ update ( ) ;
byte [ ] passbuf = encoding . ut . get _ bytes ( password ) ; key = new byte [ NUM ] ; byte [ ] iv = new byte [ NUM ] ; bytes _ to _ key ( passbuf , key ) ; cached _ keys [ k ] = key ; } } private void init _ cipher ( ref byte [ ] ctx , byte [ ] iv , bool is _ cipher ) { ctx = new byte [ cipher _ info [ NUM ] ] ;
{ polar _ ssl . aes _ init ( ctx ) ; polar _ ssl . aes _ setkey _ enc ( ctx , realkey , key _ len * NUM ) ; if ( is _ cipher ) { encrypt _ iv = new byte [ iv _ len ] ; array . copy ( iv , encrypt _ iv , iv _ len ) ; } else {
switch ( cipher ) { case cipher _ aes :
switch ( cipher ) { case cipher _ aes : polar _ ssl . aes _ crypt _ cfb ( encrypt _ ctx , polar _ ssl . aes _ encrypt , length , ref encrypt _ iv _ offset , encrypt _ iv , buf , tempbuf ) ; break ; case cipher _ bf :
switch ( cipher ) { case cipher _ aes : polar _ ssl . aes _ crypt _ cfb ( encrypt _ ctx , polar _ ssl . aes _ encrypt , length , ref encrypt _ iv _ offset , encrypt _ iv , buf , tempbuf ) ; break ; case cipher _ bf : polar _ ssl . blowfish _ crypt _ cfb ( encrypt _ ctx , polar _ ssl . blowfish _ encrypt , length , ref encrypt _ iv _ offset , encrypt _ iv , buf , tempbuf ) ; break ; case cipher _ r :
switch ( cipher ) { case cipher _ aes :
switch ( cipher ) { case cipher _ aes : polar _ ssl . aes _ crypt _ cfb ( decrypt _ ctx , polar _ ssl . aes _ decrypt , length - iv _ len , ref decrypt _ iv _ offset , decrypt _ iv , tempbuf , outbuf ) ; break ; case cipher _ bf :
switch ( cipher ) { case cipher _ aes : polar _ ssl . aes _ crypt _ cfb ( decrypt _ ctx , polar _ ssl . aes _ decrypt , length - iv _ len , ref decrypt _ iv _ offset , decrypt _ iv , tempbuf , outbuf ) ; break ; case cipher _ bf : polar _ ssl . blowfish _ crypt _ cfb ( decrypt _ ctx , polar _ ssl . blowfish _ decrypt , length - iv _ len , ref decrypt _ iv _ offset , decrypt _ iv , tempbuf , outbuf ) ; break ; case cipher _ r :
{ dispose ( true ) ; gc . suppress _ finalize ( this ) ; } ~ polar _ ssl _ encryptor ( ) { dispose ( false ) ; } protected virtual void dispose ( bool disposing ) {
{ if ( ! disposed ) { if ( disposing ) { } if ( encrypt _ ctx ! = null ) {
case cipher _ bf : polar _ ssl . blowfish _ free ( encrypt _ ctx ) ; break ; case cipher _ r : polar _ ssl . arc _ free ( encrypt _ ctx ) ; break ; } } if ( decrypt _ ctx ! = null ) {

string pac _ content = $ STR + pac _ daemon . get _ pac _ content ( ) ; string response _ head = string . format ( @ STR server : shadowsocks content - type : application / x - ns - proxy - autoconfig
fs . write ( buffer , 0 , n ) ; } } } public static string non _ exclusive _ read _ all _ text ( string path ) { return non _ exclusive _ read _ all _ text ( path , encoding . default ) ; } public static string non _ exclusive _ read _ all _ text ( string path , encoding encoding ) {
} } public static string non _ exclusive _ read _ all _ text ( string path ) { return non _ exclusive _ read _ all _ text ( path , encoding . default ) ; } public static string non _ exclusive _ read _ all _ text ( string path , encoding encoding ) { using ( var fs = new file _ stream ( path , file _ mode . open , file _ access . read , file _ share . read _ write ) ) using ( var sr = new stream _ reader ( fs , encoding ) ) {
using system ; using system _ collections _ generic ; using system _ text ; namespace shadowsocks _ encrypt { public class sodium _ encryptor : iv _ encryptor , i _ disposable { const int cipher _ sals = 1 ; const int cipher _ chach = 2 ;
} protected override dictionary < string , int [ ] > get _ ciphers ( ) { return new dictionary < string , int [ ] > { { STR , new int [ ] { NUM , NUM , cipher _ sals , polar _ ssl . aes _ ctx _ size } } , { STR , new int [ ] { NUM , NUM , cipher _ chach , polar _ ssl . aes _ ctx _ size } } , } ; ; } protected override void cipher _ update ( bool is _ cipher , int length , byte [ ] buf , byte [ ] outbuf ) {
using system _ reflection ; using system _ runtime _ compiler _ services ; using system _ runtime _ interop _ services ;
using system _ reflection ; using system _ runtime _ compiler _ services ; using system _ runtime _ interop _ services ; assembly _ assembly _ title _ shadowsocks _ csharp assembly _ assembly _ description assembly _ assembly _ configuration assembly _ assembly _ company _ clowwindy

namespace shadowsocks _ csharp { static class program { sta _ thread static void main ( ) { try
else if ( line . starts _ with ( STR ) ) continue ; domains . add ( line ) ; } return domains . to _ array ( ) ; } public string [ ] get _ reduced _ domains ( ) { string [ ] domains = get _ domains ( ) ; list < string > new _ domains = new list < string > ( domains . length ) ;
{ string [ ] domains = get _ domains ( ) ; list < string > new _ domains = new list < string > ( domains . length ) ; i _ dictionary < string , string > tld _ dic = get _ tld _ dictionary ( ) ; foreach ( string domain in domains ) { string last _ root _ domain = null ; int pos ; pos = domain . last _ index _ of ( '.' ) ; last _ root _ domain = domain . substring ( pos + 1 ) ;
while ( ( n = input . read ( buffer , 0 , buffer . length ) ) > 0 ) { sb . write ( buffer , 0 , n ) ; } } tlds = system . text . encoding . ut . get _ string ( sb . to _ array ( ) ) . split ( new char [ ] { '\r' , '\n' } , string _ split _ options . remove _ empty _ entries ) ; } return tlds ; }
} } tlds = system . text . encoding . ut . get _ string ( sb . to _ array ( ) ) . split ( new char [ ] { '\r' , '\n' } , string _ split _ options . remove _ empty _ entries ) ; } return tlds ; } private i _ dictionary < string , string > get _ tld _ dictionary ( ) { string [ ] tlds = get _ tlds ( ) ;
. split ( new char [ ] { '\r' , '\n' } , string _ split _ options . remove _ empty _ entries ) ; } return tlds ; } private i _ dictionary < string , string > get _ tld _ dictionary ( ) { string [ ] tlds = get _ tlds ( ) ; i _ dictionary < string , string > dic = new dictionary < string , string > ( tlds . length ) ; foreach ( string tld in tlds ) {
} private i _ dictionary < string , string > get _ tld _ dictionary ( ) { string [ ] tlds = get _ tlds ( ) ; i _ dictionary < string , string > dic = new dictionary < string , string > ( tlds . length ) ; foreach ( string tld in tlds ) { if ( ! dic . contains _ key ( tld ) ) dic . add ( tld , tld ) ;

console . write _ line ( STR , current _ server . server . friendly _ name ( ) ) ; } } } public void update _ latency ( model . server server , time _ span latency ) {
logging . debug ( string . format ( STR , server . friendly _ name ( ) , latency ) ) ; server _ status status ; if ( server _ status . try _ get _ value ( server , out status ) ) { status . latency = latency ; status . last _ time _ detect _ latency = date _ time . now ; } } public void update _ last _ read ( model . server server ) {
{ logging . debug ( string . format ( STR , server . friendly _ name ( ) ) ) ; server _ status status ; if ( server _ status . try _ get _ value ( server , out status ) ) { status . last _ read = date _ time . now ; } } public void update _ last _ write ( model . server server ) {
{ logging . debug ( string . format ( STR , server . friendly _ name ( ) ) ) ; server _ status status ; if ( server _ status . try _ get _ value ( server , out status ) ) { status . last _ write = date _ time . now ; } } public void set _ failure ( model . server server ) {
{ try { system . io . file _ stream file _ stream = new system . io . file _ stream ( file _ name , system . io . file _ mode . create , system . io . file _ access . write ) ; file _ stream . write ( content , 0 , content . length ) ; file _ stream . close ( ) ; return true ; }
{ system . io . file _ stream file _ stream = new system . io . file _ stream ( file _ name , system . io . file _ mode . create , system . io . file _ access . write ) ; file _ stream . write ( content , 0 , content . length ) ; file _ stream . close ( ) ; return true ; } catch ( exception exception ) {
console . write _ line ( e . to _ string ( ) ) ; return false ; } } public static void debug ( object o ) {
public partial class log _ form : form { long last _ offset ; string filename ; timer timer ; const int back _ offset = NUM ; shadowsocks _ controller controller ; long last _ max _ speed ;
log _ message _ text _ box . font = config . get _ font ( ) ; controller . traffic _ changed + = controller _ traffic _ changed ; update _ texts ( ) ; } private void update _ traffic _ chart ( ) { list < float > inbound _ points = new list < float > ( ) ; list < float > outbound _ points = new list < float > ( ) ; text _ annotation inbound _ annotation = new text _ annotation ( ) ; text _ annotation outbound _ annotation = new text _ annotation ( ) ;
tuple < float , string , long > bandwidth _ scale ; const long min _ scale = NUM ; long max _ speed = 0 ; long last _ inbound , last _ outbound ; lock ( this ) { if ( traffic . count = = 0 ) return ; foreach ( var traffic _ per _ second in traffic ) {
{ last _ max _ speed - = last _ max _ speed / NUM ; max _ speed = math . max ( min _ scale , math . max ( max _ speed , last _ max _ speed ) ) ; last _ max _ speed = max _ speed ; } else { max _ speed = last _ max _ speed = min _ scale ; } bandwidth _ scale = utils . get _ bandwidth _ scale ( max _ speed ) ;
{ max _ speed = last _ max _ speed = min _ scale ; } bandwidth _ scale = utils . get _ bandwidth _ scale ( max _ speed ) ; inbound _ points = inbound _ points . select ( p = > p / bandwidth _ scale . item ) . to _ list ( ) ; outbound _ points = outbound _ points . select ( p = > p / bandwidth _ scale . item ) . to _ list ( ) ; if ( traffic _ chart . is _ handle _ created ) { traffic _ chart . series [ STR ] . points . data _ bind _ y ( inbound _ points ) ; traffic _ chart . series [ STR ] . points . data _ bind _ y ( outbound _ points ) ;
outbound _ annotation . text = utils . format _ bandwidth ( last _ outbound ) ; traffic _ chart . annotations . clear ( ) ; traffic _ chart . annotations . add ( inbound _ annotation ) ; traffic _ chart . annotations . add ( outbound _ annotation ) ; } } private void controller _ traffic _ changed ( object sender , event _ args e ) { lock ( this ) {
traffic _ chart . annotations . add ( outbound _ annotation ) ; } } private void controller _ traffic _ changed ( object sender , event _ args e ) { lock ( this ) { traffic = new shadowsocks _ controller . queue _ last < tuple < long , long > > ( ) ; foreach ( var traffic _ per _ second in controller . traffic ) {
if ( bytes > = m * NUM ) { return ( bytes / ( double ) m ) . to _ string ( STR ) + STR ; } if ( bytes > = k * NUM ) { return ( bytes / ( double ) m ) . to _ string ( STR ) + STR ; } if ( bytes > k * 2 ) {
if ( bytes > = k * NUM ) { return ( bytes / ( double ) m ) . to _ string ( STR ) + STR ; } if ( bytes > k * 2 ) { return ( bytes / ( double ) k ) . to _ string ( STR ) + STR ; } return bytes . to _ string ( ) ; }
using system ; using system _ collections _ generic ; using system _ linq ; using system _ net ; using system _ net _ sockets ; using system _ timers ; using shadowsocks _ controller _ strategy ; using shadowsocks _ encryption ;
using system ; using system _ net ; using system _ net _ sockets ; using system _ text ; using system _ threading ; using shadowsocks _ controller ; using shadowsocks _ util _ sockets ;
using system ; using system _ net ; using system _ net _ sockets ; using system _ text ; using system _ threading ; using shadowsocks _ controller ; using shadowsocks _ util _ sockets ; namespace shadowsocks _ forward _ proxy {
using system ; using system _ net ; using system _ net _ sockets ; using system _ text ; using system _ text _ regular _ expressions ; using system _ threading ; using shadowsocks _ controller ; using shadowsocks _ util _ sockets ;
using system ; using system _ net ; using system _ net _ sockets ; using system _ text ; using system _ text _ regular _ expressions ; using system _ threading ; using shadowsocks _ controller ; using shadowsocks _ util _ sockets ; namespace shadowsocks _ forward _ proxy {
using system ; using system _ net ; using system _ net _ sockets ;
using system ; using system _ net ; using system _ net _ sockets ; namespace shadowsocks _ forward _ proxy {
using system ; using system _ net ; using system _ net _ sockets ; using system _ threading ; using shadowsocks _ util _ sockets ;
using system ; using system _ net ; using system _ net _ sockets ; using system _ threading ; using shadowsocks _ util _ sockets ; namespace shadowsocks _ forward _ proxy {
using system _ text _ regular _ expressions ; using simple _ json ; namespace shadowsocks _ controller { public class update _ checker { private const string update _ url = STR ; public string latest _ version _ number ; public string latest _ version _ url ;
} foreach ( json _ object asset in ( json _ array ) release [ STR ] ) { string url = ( string ) asset [ STR ] ; if ( is _ new _ version ( url ) ) { versions . add ( url ) ; } } }
{ string url = ( string ) asset [ STR ] ; if ( is _ new _ version ( url ) ) { versions . add ( url ) ; } } } if ( versions . count = = 0 ) {
{ versions . add ( url ) ; } } } if ( versions . count = = 0 ) { return ; }
} } } if ( versions . count = = 0 ) { return ; } sort _ versions ( versions ) ; latest _ version _ url = versions [ versions . count - 1 ] ; latest _ version _ number = parse _ version _ from _ url ( latest _ version _ url ) ; if ( new _ version _ found ! = null ) {
controller . enable _ global _ changed + = controller _ enable _ global _ changed ; controller . errored + = controller _ errored ; controller . update _ pac _ from _ gfw _ list _ completed + = controller _ update _ pac _ from _ gfw _ list _ completed ; controller . update _ pac _ from _ gfw _ list _ error + = controller _ update _ pac _ from _ gfw _ list _ error ; notify _ icon = new notify _ icon ( ) ; update _ tray _ icon ( ) ; notify _ icon . visible = true ; notify _ icon . context _ menu = context _ menu ; notify _ icon . mouse _ double _ click + = notify _ icon _ double _ click ; this . update _ checker = new update _ checker ( ) ;
controller . update _ pac _ from _ gfw _ list _ completed + = controller _ update _ pac _ from _ gfw _ list _ completed ; controller . update _ pac _ from _ gfw _ list _ error + = controller _ update _ pac _ from _ gfw _ list _ error ; notify _ icon = new notify _ icon ( ) ; update _ tray _ icon ( ) ; notify _ icon . visible = true ; notify _ icon . context _ menu = context _ menu ; notify _ icon . mouse _ double _ click + = notify _ icon _ double _ click ; this . update _ checker = new update _ checker ( ) ; update _ checker . new _ version _ found + = update _ checker _ new _ version _ found ; load _ current _ configuration ( ) ;
using system ; using system _ collections _ generic ; using system _ diagnostics ; using system _ text ;
using system _ diagnostics ; using system _ text ; using cyotek _ collections _ generic ; using shadowsocks _ controller ; namespace shadowsocks _ encryption _ stream { public abstract class stream _ encryptor : encryptor _ base { protected static byte [ ] udp _ tmp _ buf = new byte [ NUM ] ;
} private void unreg _ hotkey ( text _ box tb ) { hot _ keys . hot _ key _ call _ back _ handler call _ back ; label lb ; prepare _ for _ hotkey ( tb , out call _ back , out lb ) ; unreg _ prev _ hotkey ( call _ back ) ; } private void cancel _ button _ click ( object sender , event _ args e ) {
label lb ; prepare _ for _ hotkey ( tb , out call _ back , out lb ) ; unreg _ prev _ hotkey ( call _ back ) ; } private void cancel _ button _ click ( object sender , event _ args e ) { close ( ) ; } private void ok _ button _ click ( object sender , event _ args e ) {
} private void ok _ button _ click ( object sender , event _ args e ) { { continue ; } if ( ! try _ reg _ hotkey ( tb ) ) { message _ box . show ( n . get _ string ( STR ) ) ; return ; } } save _ config ( ) ;
foreach ( var tb in all _ text _ boxes ) { if ( tb . text . is _ null _ or _ empty ( ) ) { continue ; }
if ( hotkey = = null ) { message _ box . show ( string . format ( n . get _ string ( STR ) , tb . text ) ) ; tb . clear ( ) ; return false ; } hot _ keys . hot _ key _ call _ back _ handler call _ back ; label lb ; prepare _ for _ hotkey ( tb , out call _ back , out lb ) ; unreg _ prev _ hotkey ( call _ back ) ;
unreg _ prev _ hotkey ( call _ back ) ; bool reg _ result = hot _ keys . regist ( hotkey , call _ back ) ; lb . back _ color = reg _ result ? color . green : color . yellow ; return reg _ result ; } private static void unreg _ prev _ hotkey ( hot _ keys . hot _ key _ call _ back _ handler cb ) { global _ hot _ key . hot _ key prev _ hot _ key ; if ( hot _ keys . is _ callback _ exists ( cb , out prev _ hot _ key ) ) {
private static void unreg _ prev _ hotkey ( hot _ keys . hot _ key _ call _ back _ handler cb ) { global _ hot _ key . hot _ key prev _ hot _ key ; if ( hot _ keys . is _ callback _ exists ( cb , out prev _ hot _ key ) ) { hot _ keys . un _ regist ( prev _ hot _ key ) ; } } private void save _ config ( ) {
private void top _ most _ menu _ item _ click ( object sender , event _ args e ) { if ( ! top _ most _ trigger _ lock ) { trigger _ top _ most ( ) ; } } private bool show _ toolbar _ trigger = false ; private void show _ toolbar _ menu _ item _ click ( object sender , event _ args e ) {
public class server _ status { public time _ span latency ; public date _ time last _ read ; public date _ time last _ write ; public date _ time last _ failure ; public server server ; }
status . server = server ; new _ server _ status [ server ] = status ; } } server _ status = new _ server _ status ;
using system ; using system _ collections _ generic ; using system _ io ; using system _ linq ; using system _ reflection ; using shadowsocks _ controller ;
} public server ( ) { server = STR ; server _ port = NUM ; method = STR ; password = STR ; remarks = STR ; timeout = default _ server _ timeout _ sec ; }
{ server = STR ; server _ port = NUM ; method = STR ; password = STR ; remarks = STR ; timeout = default _ server _ timeout _ sec ; } public server ( string ss _ url ) : this ( ) {
} for ( int i = 1 ; i < NUM ; i + + ) { encrypt _ table = merge _ sort ( encrypt _ table , a , i ) ; } for ( int i = 0 ; i < NUM ; i + + ) { decrypt _ table [ encrypt _ table [ i ] ] = ( byte ) i ; } }
{ encrypt _ table = merge _ sort ( encrypt _ table , a , i ) ; } for ( int i = 0 ; i < NUM ; i + + ) { decrypt _ table [ encrypt _ table [ i ] ] = ( byte ) i ; } } public void encrypt ( byte [ ] buf ) {
decrypt _ table [ encrypt _ table [ i ] ] = ( byte ) i ; } } public void encrypt ( byte [ ] buf ) { for ( int i = 0 ; i < buf . length ; i + + ) { buf [ i ] = encrypt _ table [ buf [ i ] ] ; } }
} public void encrypt ( byte [ ] buf ) { for ( int i = 0 ; i < buf . length ; i + + ) { buf [ i ] = encrypt _ table [ buf [ i ] ] ; } } public void decrypt ( byte [ ] buf ) {
using system ; using system _ collections _ generic ; using system _ linq ; using system _ net ;
using system _ linq ; using system _ net ; using system _ text ; using shadowsocks _ model ; using system _ io ; using system _ net _ network _ information ; using system _ threading ; namespace shadowsocks _ controller _ strategy { class simply _ choose _ by _ statistics _ strategy : i _ strategy {
using system _ io ; using system _ net _ network _ information ; using system _ threading ; namespace shadowsocks _ controller _ strategy { class simply _ choose _ by _ statistics _ strategy : i _ strategy { private shadowsocks _ controller controller ; private server current _ server ;
private shadowsocks _ controller controller ; private server current _ server ; private timer timer ; private dictionary < string , statistics _ data > statistics ; private static readonly int cached _ interval = NUM * NUM * NUM ; public simply _ choose _ by _ statistics _ strategy ( shadowsocks _ controller controller ) { controller = controller ; var servers = controller . get _ current _ configuration ( ) . configs ;
{ controller = controller ; var servers = controller . get _ current _ configuration ( ) . configs ; int random _ index = new random ( ) . next ( ) % servers . count ( ) ; current _ server = servers [ random _ index ] ; timer = new timer ( reload _ statistics _ and _ choose _ a _ server ) ; } private void reload _ statistics _ and _ choose _ a _ server ( object obj ) { logging . debug ( STR ) ;
{ var best _ result = ( from server in servers let name = server . friendly _ name ( ) where statistics . contains _ key ( name ) select new { server , score = get _ score ( statistics [ name ] ) } ) . aggregate ( ( result , result ) = > result . score > result . score ? result : result ) ;
let name = server . friendly _ name ( ) where statistics . contains _ key ( name ) select new { server , score = get _ score ( statistics [ name ] ) } ) . aggregate ( ( result , result ) = > result . score > result . score ? result : result ) ; if ( controller . get _ current _ strategy ( ) . id = = id & & current _ server ! = best _ result . server ) {
{ console . write _ line ( STR , best _ result . server . friendly _ name ( ) , 1 - best _ result . score ) ; } current _ server = best _ result . server ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; } }
} current _ server = best _ result . server ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; } } public string id {
catch ( exception e ) { logging . log _ useful _ exception ( e ) ; } } public string id { get { return STR ; } }
} { get { return n . get _ string ( STR ) ; } } public server get _ a _ server ( i _ strategy _ caller _ type type , ip _ end _ point local _ ip _ end _ point ) { var old _ server = current _ server ; if ( old _ server = = null ) { choose _ new _ server ( controller . get _ current _ configuration ( ) . configs ) ; }
} return current _ server ; } public void reload _ servers ( ) { choose _ new _ server ( controller . get _ current _ configuration ( ) . configs ) ; timer ? . change ( 0 , cached _ interval ) ; } public void set _ failure ( server server ) {
utils . release _ memory ( true ) ; } void config _ form _ form _ closed ( object sender , form _ closed _ event _ args e ) { config _ form . dispose ( ) ; config _ form = null ; utils . release _ memory ( true ) ; if ( is _ first _ run ) { check _ update _ for _ first _ run ( ) ;
hot _ keys . init ( ) ; controller . start ( ) ; application . run ( ) ; } } private static int exited = 0 ; private static void current _ domain _ unhandled _ exception ( object sender , unhandled _ exception _ event _ args e ) { if ( interlocked . increment ( ref exited ) = = 1 ) {
logging . error ( e . exception _ object ? . to _ string ( ) ) ; message _ box . show ( $ STR unexpected error , shadowsocks will exit . please report to STR , STR , message _ box _ buttons . ok , message _ box _ icon . error ) ; application . exit ( ) ; } } private static void application _ thread _ exception ( object sender , thread _ exception _ event _ args e ) {
public static registry _ key open _ user _ reg _ key ( string name , bool writable ) {

using system _ windows _ forms ; using microsoft _ win ; using system ; using system _ runtime _ interop _ services ; using system _ io ; using shadowsocks _ model ;
using microsoft _ win ; using system ; using system _ runtime _ interop _ services ; using system _ io ; using shadowsocks _ model ; using shadowsocks _ util ; namespace shadowsocks _ controller { public static class system _ proxy {
return value . to _ string ( STR ) ; } public static void update ( configuration config , bool force _ disable ) { bool global = config . global ; bool enabled = config . enabled ; if ( force _ disable ) { enabled = false ; }
{ bool global = config . global ; bool enabled = config . enabled ; if ( force _ disable ) { enabled = false ; } registry _ key registry = null ; try { registry = utils . open _ user _ reg _ key ( STR , true ) ; if ( registry = = null ) { logging . error ( STR ) ; return ; }
message _ box . show ( n . get _ string ( STR ) ) ; } finally { if ( registry ! = null ) { try { registry . close ( ) ; registry . dispose ( ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; } } }
copy _ proxy _ setting _ from _ lan ( ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; message _ box . show ( n . get _ string ( STR ) ) ; } } private static void copy _ proxy _ setting _ from _ lan ( ) {
} } private static void copy _ proxy _ setting _ from _ lan ( ) { registry _ key registry = registry . current _ user . open _ sub _ key ( STR , true ) ; var default _ value = registry . get _ value ( STR ) ; try { var connections = registry . get _ value _ names ( ) ;
var connections = registry . get _ value _ names ( ) ; foreach ( string each in connections ) { if ( ! ( each . equals ( STR ) | | each . equals ( STR ) | | each . equals ( STR ) ) ) { registry . set _ value ( each , default _ value ) ; } }
| | each . equals ( STR ) | | each . equals ( STR ) ) ) { registry . set _ value ( each , default _ value ) ; } } system _ proxy . notify _ ie ( ) ; } catch ( io _ exception e ) { logging . log _ useful _ exception ( e ) ; }
} } system _ proxy . notify _ ie ( ) ; } catch ( io _ exception e ) { logging . log _ useful _ exception ( e ) ; } } private static string get _ timestamp ( date _ time value ) { return value . to _ string ( STR ) ; } private static void ie _ auto _ detect _ proxy ( bool set ) {
logging . log _ useful _ exception ( e ) ; } private static string get _ timestamp ( date _ time value ) { return value . to _ string ( STR ) ; } private static void ie _ auto _ detect _ proxy ( bool set ) { registry _ key registry = registry . current _ user . open _ sub _ key ( STR , true ) ; byte [ ] def _ connection = ( byte [ ] ) registry . get _ value ( STR ) ; byte [ ] saved _ legacy _ setting = ( byte [ ] ) registry . get _ value ( STR ) ; if ( set ) {
{ true ) ; byte [ ] def _ connection = ( byte [ ] ) registry . get _ value ( STR ) ; byte [ ] saved _ legacy _ setting = ( byte [ ] ) registry . get _ value ( STR ) ; if ( set ) { def _ connection [ NUM ] = convert . to _ byte ( def _ connection [ NUM ] & NUM ) ; saved _ legacy _ setting [ NUM ] = convert . to _ byte ( saved _ legacy _ setting [ NUM ] & NUM ) ; } else {
using system _ io ; using system _ i _ compression ; namespace shadowsocks _ controller { public class file _ manager { public static bool byte _ array _ to _ file ( string file _ name , byte [ ] content ) { try {
public class file _ manager { public static bool byte _ array _ to _ file ( string file _ name , byte [ ] content ) { try { file _ stream file _ stream = new file _ stream ( file _ name , file _ mode . create , file _ access . write ) ; file _ stream . write ( content , 0 , content . length ) ; file _ stream . close ( ) ; return true ; }
{ try { file _ stream file _ stream = new file _ stream ( file _ name , file _ mode . create , file _ access . write ) ; file _ stream . write ( content , 0 , content . length ) ; file _ stream . close ( ) ; return true ; } catch ( exception exception ) { console . write _ line ( STR ,
} catch ( exception exception ) { console . write _ line ( STR , exception . to _ string ( ) ) ; } return false ; } public static void uncompress _ file ( string file _ name , byte [ ] content ) {
console . write _ line ( STR , exception . to _ string ( ) ) ; } return false ; } public static void uncompress _ file ( string file _ name , byte [ ] content ) { file _ stream destination _ file = file . create ( file _ name ) ; byte [ ] buffer = new byte [ NUM ] ; int n ;
{ file _ stream destination _ file = file . create ( file _ name ) ; byte [ ] buffer = new byte [ NUM ] ; int n ; using ( g _ zip _ stream input = new g _ zip _ stream ( new memory _ stream ( content ) , compression _ mode . decompress , false ) ) { while ( ( n = input . read ( buffer , 0 , buffer . length ) ) > 0 ) {
int n ; using ( g _ zip _ stream input = new g _ zip _ stream ( new memory _ stream ( content ) , compression _ mode . decompress , false ) ) { while ( ( n = input . read ( buffer , 0 , buffer . length ) ) > 0 ) { destination _ file . write ( buffer , 0 , n ) ; } }
this . ok _ button = new system . windows . forms . button ( ) ; this . my _ cancel _ button = new system . windows . forms . button ( ) ; this . panel = new system . windows . forms . panel ( ) ; this . context _ menu = new system . windows . forms . context _ menu ( ) ; this . enable _ item = new system . windows . forms . menu _ item ( ) ; this . config _ item = new system . windows . forms . menu _ item ( ) ; this . edit _ pac _ file _ item = new system . windows . forms . menu _ item ( ) ; this . about _ item = new system . windows . forms . menu _ item ( ) ; this . menu _ item = new system . windows . forms . menu _ item ( ) ; this . quit _ item = new system . windows . forms . menu _ item ( ) ;
this . enable _ item = new system . windows . forms . menu _ item ( ) ; this . config _ item = new system . windows . forms . menu _ item ( ) ; this . edit _ pac _ file _ item = new system . windows . forms . menu _ item ( ) ; this . about _ item = new system . windows . forms . menu _ item ( ) ; this . menu _ item = new system . windows . forms . menu _ item ( ) ; this . quit _ item = new system . windows . forms . menu _ item ( ) ; this . table _ layout _ panel = new system . windows . forms . table _ layout _ panel ( ) ; this . list _ view = new system . windows . forms . list _ view ( ) ; this . table _ layout _ panel = new system . windows . forms . table _ layout _ panel ( ) ; this . table _ layout _ panel . suspend _ layout ( ) ; this . panel . suspend _ layout ( ) ;
this . about _ item = new system . windows . forms . menu _ item ( ) ; this . menu _ item = new system . windows . forms . menu _ item ( ) ; this . quit _ item = new system . windows . forms . menu _ item ( ) ; this . table _ layout _ panel = new system . windows . forms . table _ layout _ panel ( ) ; this . list _ view = new system . windows . forms . list _ view ( ) ; this . table _ layout _ panel = new system . windows . forms . table _ layout _ panel ( ) ; this . table _ layout _ panel . suspend _ layout ( ) ; this . panel . suspend _ layout ( ) ; this . table _ layout _ panel . suspend _ layout ( ) ; this . table _ layout _ panel . suspend _ layout ( ) ; this . suspend _ layout ( ) ;
this . panel . suspend _ layout ( ) ; this . table _ layout _ panel . suspend _ layout ( ) ; this . table _ layout _ panel . suspend _ layout ( ) ; this . suspend _ layout ( ) ; this . table _ layout _ panel . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( ( system . windows . forms . anchor _ styles . top | system . windows . forms . anchor _ styles . left ) | system . windows . forms . anchor _ styles . right ) ) ) ; this . table _ layout _ panel . auto _ size = true ; this . table _ layout _ panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . table _ layout _ panel . column _ count = 2 ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ;
this . suspend _ layout ( ) ; this . table _ layout _ panel . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( ( system . windows . forms . anchor _ styles . top | system . windows . forms . anchor _ styles . left ) | system . windows . forms . anchor _ styles . right ) ) ) ; this . table _ layout _ panel . auto _ size = true ; this . table _ layout _ panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . table _ layout _ panel . column _ count = 2 ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , 0 ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , 1 ) ;
this . table _ layout _ panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . table _ layout _ panel . column _ count = 2 ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , 0 ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , 1 ) ; this . table _ layout _ panel . controls . add ( this . encryption _ select , 1 , NUM ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , 2 ) ;
this . table _ layout _ panel . controls . add ( this . label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , 0 ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , 1 ) ; this . table _ layout _ panel . controls . add ( this . encryption _ select , 1 , NUM ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , 2 ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . ip _ text _ box , 1 , 0 ) ; this . table _ layout _ panel . controls . add ( this . server _ port _ text _ box , 1 , 1 ) ; this . table _ layout _ panel . controls . add ( this . password _ text _ box , 1 , 2 ) ;
this . ok _ button . use _ visual _ style _ back _ color = true ; this . ok _ button . click + = new system . event _ handler ( this . ok _ button _ click ) ; this . my _ cancel _ button . dialog _ result = system . windows . forms . dialog _ result . cancel ; this . my _ cancel _ button . location = new system . drawing . point ( NUM , NUM ) ; this . my _ cancel _ button . name = STR ; this . my _ cancel _ button . size = new system . drawing . size ( NUM , NUM ) ; this . my _ cancel _ button . tab _ index = 1 ; this . my _ cancel _ button . text = STR ; this . my _ cancel _ button . use _ visual _ style _ back _ color = true ; this . my _ cancel _ button . click + = new system . event _ handler ( this . cancel _ button _ click ) ;
this . my _ cancel _ button . size = new system . drawing . size ( NUM , NUM ) ; this . my _ cancel _ button . tab _ index = 1 ; this . my _ cancel _ button . text = STR ; this . my _ cancel _ button . use _ visual _ style _ back _ color = true ; this . my _ cancel _ button . click + = new system . event _ handler ( this . cancel _ button _ click ) ; this . panel . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( ( system . windows . forms . anchor _ styles . top | system . windows . forms . anchor _ styles . bottom ) | system . windows . forms . anchor _ styles . right ) ) ) ; this . panel . auto _ size = true ; this . panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . panel . controls . add ( this . my _ cancel _ button ) ; this . panel . controls . add ( this . ok _ button ) ;
this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . suspend _ layout ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . numeric _ up _ down ) ) . begin _ init ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . begin _ init ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . suspend _ layout ( ) ; this . flow _ layout _ panel . suspend _ layout ( ) ; this . panel . suspend _ layout ( ) ;
this . split _ container . name = STR ; this . split _ container . panel . controls . add ( this . numeric _ up _ down ) ; this . split _ container . panel . controls . add ( this . check _ box ) ; this . split _ container . panel . controls . add ( this . numeric _ up _ down ) ; this . split _ container . panel . controls . add ( this . label ) ; this . split _ container . panel . controls . add ( this . label ) ; this . split _ container . panel . controls . add ( this . label ) ; this . split _ container . panel . controls . add ( this . check _ box ) ; this . split _ container . panel . controls . add ( this . label ) ; this . split _ container . panel . controls . add ( this . split _ container ) ;
this . check _ box . auto _ size = true ; this . check _ box . location = new system . drawing . point ( NUM , NUM ) ; this . check _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . check _ box . name = STR ; this . check _ box . size = new system . drawing . size ( NUM , NUM ) ; this . check _ box . tab _ index = NUM ; this . check _ box . text = STR ; this . check _ box . use _ visual _ style _ back _ color = true ;

using shadowsocks _ model ; using shadowsocks _ properties ; using system ; using system _ collections _ generic ; using system _ diagnostics ; using system _ io ;
using shadowsocks _ model ; using shadowsocks _ properties ; using system ; using system _ collections _ generic ; using system _ diagnostics ; using system _ io ; using system _ i _ compression ; using system _ text ;
using system _ i _ compression ; using system _ text ; using system _ net _ network _ information ; using system _ net ; using system _ runtime _ interop _ services ; using shadowsocks _ util ; namespace shadowsocks _ controller { class polipo _ runner { private process process ;
using shadowsocks _ util ; namespace shadowsocks _ controller { class polipo _ runner { private process process ; private static string temppath ; private int running _ port ; static polipo _ runner ( ) {
class polipo _ runner { private process process ; private static string temppath ; private int running _ port ; static polipo _ runner ( ) { temppath = utils . get _ temp _ path ( ) ; try {
catch ( exception e ) { logging . log _ useful _ exception ( e ) ; } } string polipo _ config = resources . privoxy _ conf ; running _ port = this . get _ free _ port ( ) ; polipo _ config = polipo _ config . replace ( STR , configuration . local _ port . to _ string ( ) ) ; polipo _ config = polipo _ config . replace ( STR , running _ port . to _ string ( ) ) ; polipo _ config = polipo _ config . replace ( STR , configuration . share _ over _ lan ? STR : STR ) ;
logging . log _ useful _ exception ( e ) ; } } string polipo _ config = resources . privoxy _ conf ; running _ port = this . get _ free _ port ( ) ; polipo _ config = polipo _ config . replace ( STR , configuration . local _ port . to _ string ( ) ) ; polipo _ config = polipo _ config . replace ( STR , running _ port . to _ string ( ) ) ; polipo _ config = polipo _ config . replace ( STR , configuration . share _ over _ lan ? STR : STR ) ; file _ manager . byte _ array _ to _ file ( temppath + STR , system . text . encoding . ut . get _ bytes ( polipo _ config ) ) ; if ( ! ( temppath . ends _ with ( STR ) | | temppath . ends _ with ( STR ) ) ) { temppath = temppath + STR ; } process = new process ( ) ;

using shadowsocks _ controller ; using shadowsocks _ properties ; using shadowsocks _ util ;

namespace shadowsocks { static class program { sta _ thread static void main ( ) {

using shadowsocks _ controller ; using shadowsocks _ properties ; using shadowsocks _ util ;
using shadowsocks _ properties ; using shadowsocks _ util ; using system _ io ; using system _ runtime _ interop _ services ; using system _ text ; namespace shadowsocks _ encryption { public class sodium { const string dllname = STR ; static sodium ( ) {

using shadowsocks _ controller ; using shadowsocks _ properties ; using shadowsocks _ util ;
using shadowsocks _ properties ; using shadowsocks _ util ; using system _ io ; using system _ runtime _ interop _ services ; using system _ text ; namespace shadowsocks _ encryption { public class mbed _ tls { const string dllname = STR ; static mbed _ tls ( ) {

using shadowsocks _ util ; using system ; using system _ collections _ generic ; using system _ io ; using system _ net _ sockets ;
using system _ text ; namespace shadowsocks _ controller { public class logging { public static string log _ file ; public static bool open _ log _ file ( ) { try {
if ( update _ pac _ from _ gfw _ list _ completed ! = null ) update _ pac _ from _ gfw _ list _ completed ( this , e ) ; } private void pac _ server _ pac _ update _ error ( object sender , error _ event _ args e ) { if ( update _ pac _ from _ gfw _ list _ error ! = null ) update _ pac _ from _ gfw _ list _ error ( this , e ) ; } private void pac _ server _ user _ rule _ file _ changed ( object sender , event _ args e ) {
if ( update _ pac _ from _ gfw _ list _ error ! = null ) update _ pac _ from _ gfw _ list _ error ( this , e ) ; } private void pac _ server _ user _ rule _ file _ changed ( object sender , event _ args e ) { if ( ! file . exists ( utils . get _ temp _ path ( ) + STR ) ) { update _ pac _ from _ gfw _ list ( ) ; return ; }
using system ; using system _ collections _ generic ; using system _ text ;
using system ; using system _ collections _ generic ; using system _ text ; using system _ net ; using system _ io ; using shadowsocks _ properties ;
using system ; using system _ collections _ generic ; using system _ text ; using system _ net ; using system _ io ; using shadowsocks _ properties ; using simple _ json ; using shadowsocks _ util ;
using system ;
using system ; using system _ collections ; using system _ collections _ generic ; using system _ net ;
using system ; using system _ collections ; using system _ collections _ generic ; using system _ net ; using system _ reflection ; using system _ text ; using system _ text _ regular _ expressions ;
using system _ runtime _ interop _ services ; using system _ windows _ forms ; using shadowsocks _ controller ; namespace shadowsocks _ util { public class utils { public static string get _ temp _ path ( ) {
using shadowsocks _ controller ; namespace shadowsocks _ util { public class utils { public static string get _ temp _ path ( ) { if ( file . exists ( application . startup _ path + STR ) ) {
try { directory . create _ directory ( application . startup _ path + STR ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; } return application . startup _ path + STR ; }
traffic _ thread = new thread ( new thread _ start ( ( ) = > traffic _ statistics ( queue _ max _ size ) ) ) ; traffic _ thread . is _ background = true ; traffic _ thread . start ( ) ; } private void traffic _ statistics ( int queue _ max _ size ) { while ( true ) { traffic _ per _ second previous = traffic . last ; traffic _ per _ second current = new traffic _ per _ second ( ) ;
{ traffic _ per _ second previous = traffic . last ; traffic _ per _ second current = new traffic _ per _ second ( ) ; current . inbound _ counter = inbound _ counter ; current . outbound _ counter = outbound _ counter ; current . inbound _ increasement = inbound _ counter - previous . inbound _ counter ; current . outbound _ increasement = outbound _ counter - previous . outbound _ counter ; traffic . enqueue ( current ) ; if ( traffic . count > queue _ max _ size ) traffic . dequeue ( ) ;
logging . log _ useful _ exception ( e ) ; close ( ) ; } } private void pipe _ connection _ receive _ callback ( i _ async _ result ar ) { if ( closed ) return ; try { int bytes _ read = connection . end _ receive ( ar ) ;
private void pipe _ connection _ receive _ callback ( i _ async _ result ar ) { if ( closed ) return ; try { int bytes _ read = connection . end _ receive ( ar ) ; total _ write + = bytes _ read ; var session = ( async _ session < bool > ) ar . async _ state ; var remote = session . remote ; if ( bytes _ read > 0 ) {
{ foreach ( var strategy in strategy _ manager . get _ strategies ( ) ) { if ( strategy . id = = this . config . strategy ) { return strategy ; } } return null ; }
return strategy ; } } return null ; } public server get _ a _ server ( i _ strategy _ caller _ type type , ip _ end _ point local _ ip _ end _ point ) { i _ strategy strategy = get _ current _ strategy ( ) ; if ( strategy ! = null ) {
* we won ' t like to kill other ss instances ' ss _ privoxy . exe . * this function will check whether the given process is created * by this process by checking the module path or command line . * * since it ' s required to put ss in different dirs to run muti instances , * different instance will create their unique STR where * uid is hash of ss ' s location . * / private static bool is _ child _ process ( process process ) {
* different instance will create their unique STR where * uid is hash of ss ' s location . * / private static bool is _ child _ process ( process process ) { if ( utils . is _ portable _ mode ( ) ) { * under portable _ mode , we could identify it by the path of ss _ privoxy . exe . * / try {
* / private static bool is _ child _ process ( process process ) { if ( utils . is _ portable _ mode ( ) ) { * under portable _ mode , we could identify it by the path of ss _ privoxy . exe . * / try { * sometimes process . get _ processes _ by _ name will return some processes that * are already dead , and that will cause exceptions here . * we could simply ignore those exceptions . * /
{ * under portable _ mode , we could identify it by the path of ss _ privoxy . exe . * / try { * sometimes process . get _ processes _ by _ name will return some processes that * are already dead , and that will cause exceptions here . * we could simply ignore those exceptions . * / string path = process . main _ module . file _ name ; return utils . get _ temp _ path ( STR ) . equals ( path ) ; }
string path = process . main _ module . file _ name ; return utils . get _ temp _ path ( STR ) . equals ( path ) ; } return false ; } } else { try { var cmd = process . get _ command _ line ( ) ; return cmd . contains ( unique _ config _ file ) ; }
} else { iv = decrypt _ iv ; iv _ offset = decrypt _ iv _ offset ; } switch ( cipher ) { case cipher _ aes :
{ assert . is _ true ( update _ checker . compare _ version ( STR , STR ) = = 0 ) ; assert . is _ true ( update _ checker . compare _ version ( STR , STR ) < 0 ) ; assert . is _ true ( update _ checker . compare _ version ( STR , STR ) > 0 ) ; assert . is _ true ( update _ checker . compare _ version ( STR , STR ) = = 0 ) ; assert . is _ true ( update _ checker . compare _ version ( STR , STR ) > 0 ) ; assert . is _ true ( update _ checker . compare _ version ( STR , STR ) < 0 ) ; assert . is _ true ( update _ checker . compare _ version ( STR , STR ) > 0 ) ; } test _ method
assert . is _ true ( update _ checker . compare _ version ( STR , STR ) < 0 ) ; assert . is _ true ( update _ checker . compare _ version ( STR , STR ) > 0 ) ; } test _ method public void test _ encryption ( ) { run _ single _ encryption _ thread ( ) ; list < thread > threads = new list < thread > ( ) ; for ( int i = 0 ; i < NUM ; i + + ) {
ok _ button . text = n . get _ string ( STR ) ; my _ cancel _ button . text = n . get _ string ( STR ) ; move _ up _ button . text = n . get _ string ( STR ) ; move _ down _ button . text = n . get _ string ( STR ) ; this . text = n . get _ string ( STR ) ; } private void controller _ config _ changed ( object sender , event _ args e ) { load _ current _ configuration ( ) ; }
load _ current _ configuration ( ) ; } ip _ text _ box . focus ( ) ; } private bool save _ old _ selected _ server ( ) { try { if ( last _ selected _ index = = - 1 | | last _ selected _ index > = modified _ configuration . configs . count ) { return true ; }
private bool save _ old _ selected _ server ( ) { try { if ( last _ selected _ index = = - 1 | | last _ selected _ index > = modified _ configuration . configs . count ) { return true ; } server . plugin _ args = plugin _ arguments _ text _ box . text ; server . remarks = remarks _ text _ box . text ; if ( ! int . try _ parse ( timeout _ text _ box . text , out server . timeout ) ) { message _ box . show ( n . get _ string ( STR ) ) ; timeout _ text _ box . focus ( ) ; return false ; } int local _ port = int . parse ( proxy _ port _ text _ box . text ) ; configuration . check _ server ( server ) ;
try { if ( last _ selected _ index = = - 1 | | last _ selected _ index > = modified _ configuration . configs . count ) { return true ; } if ( ! int . try _ parse ( timeout _ text _ box . text , out server . timeout ) ) { message _ box . show ( n . get _ string ( STR ) ) ; timeout _ text _ box . focus ( ) ; return false ; } int local _ port = int . parse ( proxy _ port _ text _ box . text ) ; configuration . check _ server ( server ) ; configuration . check _ local _ port ( local _ port ) ; modified _ configuration . configs [ last _ selected _ index ] = server ;
modified _ configuration . configs [ last _ selected _ index ] = server ; modified _ configuration . local _ port = local _ port ; modified _ configuration . portable _ mode = portable _ mode _ check _ box . checked ; return true ; } catch ( exception ex ) { message _ box . show ( ex . message ) ; } return false ; }
message _ box . show ( ex . message ) ; } return false ; } private void load _ selected _ server ( ) { if ( servers _ list _ box . selected _ index > = 0 & & servers _ list _ box . selected _ index < modified _ configuration . configs . count ) { server server = modified _ configuration . configs [ servers _ list _ box . selected _ index ] ;
plugin _ text _ box . text = server . plugin ; plugin _ options _ text _ box . text = server . plugin _ opts ; plugin _ arguments _ text _ box . text = server . plugin _ args ; remarks _ text _ box . text = server . remarks ; timeout _ text _ box . text = server . timeout . to _ string ( ) ; } } private void load _ configuration ( configuration configuration ) { servers _ list _ box . items . clear ( ) ;
{ servers _ list _ box . items . clear ( ) ; foreach ( server server in modified _ configuration . configs ) { servers _ list _ box . items . add ( server . friendly _ name ( ) ) ; } } private void load _ current _ configuration ( ) { modified _ configuration = controller . get _ configuration _ copy ( ) ;
private void load _ current _ configuration ( ) { modified _ configuration = controller . get _ configuration _ copy ( ) ; load _ configuration ( modified _ configuration ) ; last _ selected _ index = modified _ configuration . index ; if ( last _ selected _ index < 0 | | last _ selected _ index > = servers _ list _ box . items . count ) { last _ selected _ index = 0 ; } servers _ list _ box . selected _ index = last _ selected _ index ;
load _ configuration ( modified _ configuration ) ; last _ selected _ index = modified _ configuration . index ; if ( last _ selected _ index < 0 | | last _ selected _ index > = servers _ list _ box . items . count ) { last _ selected _ index = 0 ; } servers _ list _ box . selected _ index = last _ selected _ index ; update _ move _ up _ and _ down _ button ( ) ; load _ selected _ server ( ) ; portable _ mode _ check _ box . checked = modified _ configuration . portable _ mode ;
update _ move _ up _ and _ down _ button ( ) ; load _ selected _ server ( ) ; portable _ mode _ check _ box . checked = modified _ configuration . portable _ mode ; } private void config _ form _ load ( object sender , event _ args e ) { } private void config _ form _ key _ down ( object sender , key _ event _ args e ) { if ( e . key _ code = = keys . enter ) { server server = controller . get _ current _ server ( ) ;
private void servers _ list _ box _ selected _ index _ changed ( object sender , event _ args e ) { if ( ! servers _ list _ box . can _ select ) { return ; } if ( last _ selected _ index = = servers _ list _ box . selected _ index ) { return ; }
} if ( ! save _ old _ selected _ server ( ) ) { servers _ list _ box . selected _ index = last _ selected _ index ; return ; } if ( last _ selected _ index > = 0 ) { servers _ list _ box . items [ last _ selected _ index ] = modified _ configuration . configs [ last _ selected _ index ] . friendly _ name ( ) ; }
if ( last _ selected _ index > = 0 ) { servers _ list _ box . items [ last _ selected _ index ] = modified _ configuration . configs [ last _ selected _ index ] . friendly _ name ( ) ; } update _ move _ up _ and _ down _ button ( ) ; load _ selected _ server ( ) ; last _ selected _ index = servers _ list _ box . selected _ index ; } private void add _ button _ click ( object sender , event _ args e ) {
last _ selected _ index = servers _ list _ box . selected _ index ; } private void add _ button _ click ( object sender , event _ args e ) { if ( ! save _ old _ selected _ server ( ) ) { return ; } server server = configuration . get _ default _ server ( ) ; modified _ configuration . configs . add ( server ) ;
return ; } server server = configuration . get _ default _ server ( ) ; modified _ configuration . configs . add ( server ) ; load _ configuration ( modified _ configuration ) ; servers _ list _ box . selected _ index = modified _ configuration . configs . count - 1 ; last _ selected _ index = servers _ list _ box . selected _ index ; } private void duplicate _ button _ click ( object sender , event _ args e ) {
} private void duplicate _ button _ click ( object sender , event _ args e ) { if ( ! save _ old _ selected _ server ( ) ) { return ; } server curr _ server = modified _ configuration . configs [ last _ selected _ index ] ; var curr _ index = modified _ configuration . configs . index _ of ( curr _ server ) ; modified _ configuration . configs . insert ( curr _ index + 1 , curr _ server ) ;
last _ selected _ index = servers _ list _ box . selected _ index ; if ( last _ selected _ index > = 0 & & last _ selected _ index < modified _ configuration . configs . count ) { modified _ configuration . configs . remove _ at ( last _ selected _ index ) ; } if ( last _ selected _ index > = modified _ configuration . configs . count ) { last _ selected _ index = modified _ configuration . configs . count - 1 ; } servers _ list _ box . selected _ index = last _ selected _ index ;
{ modified _ configuration . configs . remove _ at ( last _ selected _ index ) ; } if ( last _ selected _ index > = modified _ configuration . configs . count ) { last _ selected _ index = modified _ configuration . configs . count - 1 ; } servers _ list _ box . selected _ index = last _ selected _ index ; load _ configuration ( modified _ configuration ) ; servers _ list _ box . selected _ index = last _ selected _ index ;
{ last _ selected _ index = modified _ configuration . configs . count - 1 ; } servers _ list _ box . selected _ index = last _ selected _ index ; load _ configuration ( modified _ configuration ) ; servers _ list _ box . selected _ index = last _ selected _ index ; load _ selected _ server ( ) ; } private void ok _ button _ click ( object sender , event _ args e ) {
modified _ configuration . configs . insert ( index + step , server ) ; modified _ configuration . index + = step ; servers _ list _ box . begin _ update ( ) ; servers _ list _ box . enabled = false ; last _ selected _ index = index + step ; servers _ list _ box . items . remove ( item ) ; servers _ list _ box . items . insert ( index + step , item ) ; servers _ list _ box . enabled = true ; servers _ list _ box . selected _ index = index + step ; servers _ list _ box . end _ update ( ) ;
{ move _ down _ button . enabled = false ; } else { move _ down _ button . enabled = true ; } } private void move _ up _ button _ click ( object sender , event _ args e ) {
using system ; using system _ collections _ generic ; using system _ runtime _ interop _ services ; using system _ security _ cryptography ; using system _ text ; using system _ threading ; namespace shadowsocks _ encrypt { public class polar _ ssl _ encryptor
using system _ security _ cryptography ; using system _ text ; using system _ threading ; namespace shadowsocks _ encrypt { public class polar _ ssl _ encryptor : encryptor _ base , i _ disposable { const int cipher _ aes = 1 ; const int cipher _ r = 2 ;
namespace shadowsocks _ encrypt { public class polar _ ssl _ encryptor : encryptor _ base , i _ disposable { const int cipher _ aes = 1 ; const int cipher _ r = 2 ; { STR , new int [ ] { NUM , NUM , cipher _ aes , polar _ ssl . aes _ ctx _ size } } , { STR , new int [ ] { NUM , 0 , cipher _ r , polar _ ssl . ar _ ctx _ size } } , { STR , new int [ ] { NUM , NUM , cipher _ r , polar _ ssl . ar _ ctx _ size } } , } ; private static readonly dictionary < string , byte [ ] > cached _ keys = new dictionary < string , byte [ ] > ( ) ; private int cipher ; private int [ ] cipher _ info ; private byte [ ] key ; private int _ ptr encrypt _ ctx = int _ ptr . zero ; private int _ ptr decrypt _ ctx = int _ ptr . zero ;
const int cipher _ r = 2 ; private int [ ] cipher _ info ; private byte [ ] key ; private int _ ptr encrypt _ ctx = int _ ptr . zero ; private int _ ptr decrypt _ ctx = int _ ptr . zero ; private int encrypt _ iv _ offset = 0 ; private int decrypt _ iv _ offset = 0 ; private string method ; private int key _ len ; private int iv _ len ; public polar _ ssl _ encryptor ( string method , string password ) : base ( method , password ) { init _ key ( method , password ) ; }
private int _ ptr encrypt _ ctx = int _ ptr . zero ; private int _ ptr decrypt _ ctx = int _ ptr . zero ; private string method ; private int key _ len ; private int iv _ len ; public polar _ ssl _ encryptor ( string method , string password ) : base ( method , password ) { init _ key ( method , password ) ; } private static void rand _ bytes ( byte [ ] buf , int length ) {
public polar _ ssl _ encryptor ( string method , string password ) : base ( method , password ) { init _ key ( method , password ) ; } private static void rand _ bytes ( byte [ ] buf , int length ) { byte [ ] temp = new byte [ length ] ; new random ( ) . next _ bytes ( temp ) ; temp . copy _ to ( buf , 0 ) ; }
{ init _ key ( method , password ) ; } private static void rand _ bytes ( byte [ ] buf , int length ) { byte [ ] temp = new byte [ length ] ; new random ( ) . next _ bytes ( temp ) ; temp . copy _ to ( buf , 0 ) ; } private void bytes _ to _ key ( byte [ ] password , byte [ ] key ) {
new random ( ) . next _ bytes ( temp ) ; temp . copy _ to ( buf , 0 ) ; } private void bytes _ to _ key ( byte [ ] password , byte [ ] key ) { byte [ ] result = new byte [ password . length + NUM ] ; int i = 0 ; byte [ ] md _ sum = null ; while ( i < key . length ) {
{ byte [ ] result = new byte [ password . length + NUM ] ; int i = 0 ; byte [ ] md _ sum = null ; while ( i < key . length ) { throw new exception ( STR ) ; } key _ len = ciphers [ method ] [ 0 ] ; iv _ len = ciphers [ method ] [ 1 ] ; if ( cached _ keys . contains _ key ( k ) ) { key = cached _ keys [ k ] ; } else {
int i = 0 ; byte [ ] md _ sum = null ; while ( i < key . length ) { key _ len = ciphers [ method ] [ 0 ] ; iv _ len = ciphers [ method ] [ 1 ] ; if ( cached _ keys . contains _ key ( k ) ) { key = cached _ keys [ k ] ; } else { byte [ ] passbuf = encoding . ut . get _ bytes ( password ) ; key = new byte [ NUM ] ; byte [ ] iv = new byte [ NUM ] ; bytes _ to _ key ( passbuf , key ) ; cached _ keys [ k ] = key ; }
realkey = m . create ( ) . compute _ hash ( temp ) ; } else { realkey = key ; } if ( cipher = = cipher _ aes ) { polar _ ssl . aes _ init ( ctx ) ; polar _ ssl . aes _ setkey _ enc ( ctx , realkey , key _ len * NUM ) ;
polar _ ssl . aes _ init ( ctx ) ; polar _ ssl . aes _ setkey _ enc ( ctx , realkey , key _ len * NUM ) ; decrypt _ iv = new byte [ iv _ len ] ; array . copy ( iv , decrypt _ iv , iv _ len ) ; } } else if ( cipher = = cipher _ r ) { polar _ ssl . arc _ init ( ctx ) ; polar _ ssl . arc _ setup ( ctx , realkey , key _ len ) ; } }
} } else if ( cipher = = cipher _ r ) { polar _ ssl . arc _ init ( ctx ) ; polar _ ssl . arc _ setup ( ctx , realkey , key _ len ) ; } } static byte [ ] tempbuf = new byte [ NUM ] ; public override void encrypt ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength ) {
{ polar _ ssl . arc _ init ( ctx ) ; polar _ ssl . arc _ setup ( ctx , realkey , key _ len ) ; } } static byte [ ] tempbuf = new byte [ NUM ] ; public override void encrypt ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength ) { if ( encrypt _ ctx = = int _ ptr . zero ) {
case cipher _ r : polar _ ssl . arc _ crypt ( encrypt _ ctx , length , buf , tempbuf ) ; break ; } outlength = length + iv _ len ; buffer . block _ copy ( tempbuf , 0 , outbuf , iv _ len , length ) ; } } else {
} outlength = length + iv _ len ; buffer . block _ copy ( tempbuf , 0 , outbuf , iv _ len , length ) ; } } else { switch ( cipher ) { case cipher _ aes : polar _ ssl . aes _ crypt _ cfb ( encrypt _ ctx , polar _ ssl . aes _ encrypt , length , ref encrypt _ iv _ offset , encrypt _ iv , buf , outbuf ) ; break ; case cipher _ r : polar _ ssl . arc _ crypt ( encrypt _ ctx , length , buf , outbuf ) ; break ; } }
buffer . block _ copy ( tempbuf , 0 , outbuf , iv _ len , length ) ; } } else { case cipher _ aes : polar _ ssl . aes _ crypt _ cfb ( encrypt _ ctx , polar _ ssl . aes _ encrypt , length , ref encrypt _ iv _ offset , encrypt _ iv , buf , outbuf ) ; break ; case cipher _ r : polar _ ssl . arc _ crypt ( encrypt _ ctx , length , buf , outbuf ) ; break ; } } } public override void decrypt ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength ) { if ( decrypt _ ctx = = int _ ptr . zero ) {
{ polar _ ssl . arc _ crypt ( encrypt _ ctx , length , buf , outbuf ) ; break ; } } } public override void decrypt ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength ) { if ( decrypt _ ctx = = int _ ptr . zero ) { init _ cipher ( ref decrypt _ ctx , buf , false ) ; outlength = length - iv _ len ; lock ( tempbuf ) { buffer . block _ copy ( buf , iv _ len , tempbuf , 0 , length - iv _ len ) ; if ( disposed ) {
} } public override void decrypt ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength ) { if ( decrypt _ ctx = = int _ ptr . zero ) { init _ cipher ( ref decrypt _ ctx , buf , false ) ; outlength = length - iv _ len ; lock ( tempbuf ) { buffer . block _ copy ( buf , iv _ len , tempbuf , 0 , length - iv _ len ) ; if ( disposed ) { throw new object _ disposed _ exception ( this . to _ string ( ) ) ; }
if ( decrypt _ ctx = = int _ ptr . zero ) { outlength = length - iv _ len ; lock ( tempbuf ) { buffer . block _ copy ( buf , iv _ len , tempbuf , 0 , length - iv _ len ) ; if ( disposed ) { throw new object _ disposed _ exception ( this . to _ string ( ) ) ; } switch ( cipher ) {
{ buffer . block _ copy ( buf , iv _ len , tempbuf , 0 , length - iv _ len ) ; if ( disposed ) { throw new object _ disposed _ exception ( this . to _ string ( ) ) ; } switch ( cipher ) { case cipher _ aes : polar _ ssl . aes _ crypt _ cfb ( decrypt _ ctx , polar _ ssl . aes _ decrypt , length - iv _ len , ref decrypt _ iv _ offset , decrypt _ iv , tempbuf , outbuf ) ; break ; case cipher _ r : polar _ ssl . arc _ crypt ( decrypt _ ctx , length - iv _ len , tempbuf , outbuf ) ; break ; }
{ dll _ import _ kernel _ dll private static extern int _ ptr load _ library ( string path ) ; sta _ thread static void main ( ) { try {
private static extern int _ ptr load _ library ( string path ) ; sta _ thread static void main ( ) { try { string temp _ path = path . get _ temp _ path ( ) ; string dll _ path = temp _ path + STR ; file _ manager . uncompress _ file ( dll _ path , resources . polarssl _ dll ) ;
conn . begin _ receive ( new byte [ NUM ] , 0 , NUM , 0 , new async _ callback ( receive _ callback ) , conn ) ; } catch ( exception e ) { console . write _ line ( e . to _ string ( ) ) ; } } private string get _ pac _ content ( ) {
} catch ( exception e ) { console . write _ line ( e . to _ string ( ) ) ; } } private string get _ pac _ content ( ) { byte [ ] pac _ gz = resources . proxy _ pac _ txt ; byte [ ] buffer = new byte [ NUM * NUM ] ; int n ; using ( g _ zip _ stream input = new g _ zip _ stream ( new memory _ stream ( pac _ gz ) , compression _ mode . decompress , false ) ) {
console . write _ line ( e . to _ string ( ) ) ; } } private string get _ pac _ content ( ) { byte [ ] pac _ gz = resources . proxy _ pac _ txt ; byte [ ] buffer = new byte [ NUM * NUM ] ; int n ; using ( g _ zip _ stream input = new g _ zip _ stream ( new memory _ stream ( pac _ gz ) , compression _ mode . decompress , false ) ) { n = input . read ( buffer , 0 , buffer . length ) ; if ( n = = 0 ) {
{ using ( g _ zip _ stream input = new g _ zip _ stream ( new memory _ stream ( pac _ gz ) , compression _ mode . decompress , false ) ) { n = input . read ( buffer , 0 , buffer . length ) ; if ( n = = 0 ) { throw new io _ exception ( STR ) ; }
public event event _ handler config _ changed ; public event event _ handler enable _ status _ changed ; public event event _ handler < path _ event _ args > pac _ file _ ready _ to _ open ; public shadowsocks _ controller ( ) { config = config . load ( ) ; polipo _ runner = new polipo _ runner ( ) ; polipo _ runner . start ( config ) ; local = new local ( config ) ;
this . about _ item , this . menu _ item , this . quit _ item } ) ; this . enable _ item . index = 0 ; this . enable _ item . text = STR ; this . enable _ item . click + = new system . event _ handler ( this . enable _ item _ click ) ; this . config _ item . index = 1 ; this . config _ item . text = STR ; this . config _ item . click + = new system . event _ handler ( this . config _ click ) ;
{ const int cipher _ aes = 1 ; const int cipher _ r = 2 ; private int _ ptr encrypt _ ctx = int _ ptr . zero ; private int _ ptr decrypt _ ctx = int _ ptr . zero ; public polar _ ssl _ encryptor ( string method , string password ) : base ( method , password ) { init _ key ( method , password ) ; }
: base ( method , password ) { init _ key ( method , password ) ; } protected override dictionary < string , int [ ] > get _ ciphers ( ) { return new dictionary < string , int [ ] > { { STR , new int [ ] { NUM , NUM , cipher _ aes , polar _ ssl . aes _ ctx _ size } } , { STR , new int [ ] { NUM , NUM , cipher _ aes , polar _ ssl . aes _ ctx _ size } } , { STR , new int [ ] { NUM , NUM , cipher _ aes , polar _ ssl . aes _ ctx _ size } } , { STR , new int [ ] { NUM , 0 , cipher _ r , polar _ ssl . ar _ ctx _ size } } , { STR , new int [ ] { NUM , NUM , cipher _ r , polar _ ssl . ar _ ctx _ size } } ,
init _ key ( method , password ) ; encrypt _ buf = new byte [ max _ input _ size + sodium _ block _ size ] ; decrypt _ buf = new byte [ max _ input _ size + sodium _ block _ size ] ; } protected override dictionary < string , int [ ] > get _ ciphers ( ) {
public static i _ encryptor get _ encryptor ( string method , string password ) {
public static i _ encryptor get _ encryptor ( string method , string password ) { if ( string . is _ null _ or _ empty ( method ) | | method . to _ lower _ invariant ( ) = = STR ) {
public static i _ encryptor get _ encryptor ( string method , string password ) { if ( string . is _ null _ or _ empty ( method ) | | method . to _ lower _ invariant ( ) = = STR ) { return new table _ encryptor ( method , password ) ; }
flow _ layout _ panel . controls . add ( this . btn _ register _ all ) ; flow _ layout _ panel . flow _ direction = system . windows . forms . flow _ direction . bottom _ up ; flow _ layout _ panel . location = new system . drawing . point ( 0 , NUM ) ; flow _ layout _ panel . margin = new system . windows . forms . padding ( 0 ) ; flow _ layout _ panel . name = STR ; flow _ layout _ panel . padding = new system . windows . forms . padding ( 0 , 0 , NUM , 0 ) ; flow _ layout _ panel . right _ to _ left = system . windows . forms . right _ to _ left . yes ; flow _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ; flow _ layout _ panel . tab _ index = NUM ; this . btn _ ok . dialog _ result = system . windows . forms . dialog _ result . ok ;
this . btn _ ok . dialog _ result = system . windows . forms . dialog _ result . ok ; this . btn _ ok . location = new system . drawing . point ( NUM , NUM ) ; this . btn _ ok . name = STR ; this . btn _ ok . size = new system . drawing . size ( NUM , NUM ) ; this . btn _ ok . tab _ index = 0 ; this . btn _ ok . text = STR ; this . btn _ ok . use _ visual _ style _ back _ color = true ; this . btn _ ok . click + = new system . event _ handler ( this . ok _ button _ click ) ; this . btn _ cancel . dialog _ result = system . windows . forms . dialog _ result . cancel ;
this . btn _ cancel . dialog _ result = system . windows . forms . dialog _ result . cancel ; this . btn _ cancel . location = new system . drawing . point ( NUM , NUM ) ; this . btn _ cancel . name = STR ; this . btn _ cancel . size = new system . drawing . size ( NUM , NUM ) ; this . btn _ cancel . tab _ index = 1 ; this . btn _ cancel . text = STR ; this . btn _ cancel . use _ visual _ style _ back _ color = true ; this . btn _ cancel . click + = new system . event _ handler ( this . cancel _ button _ click ) ; this . btn _ register _ all . dialog _ result = system . windows . forms . dialog _ result . cancel ;

using system ; using system _ collections _ generic ; using system _ drawing ;
using system ; using system _ collections _ generic ; using system _ drawing ; using system _ linq ; using system _ text ; using system _ windows _ forms ;

using system ; using system _ collections _ generic ; using system _ globalization ; using system _ io ; namespace shadowsocks _ controller {
namespace shadowsocks _ controller { using shadowsocks _ properties ; public static class n { private static dictionary < string , string > strings = new dictionary < string , string > ( ) ;
namespace shadowsocks _ controller { using shadowsocks _ properties ; public static class n { private static dictionary < string , string > strings = new dictionary < string , string > ( ) ; private static void init ( string res ) {
namespace shadowsocks _ controller { using shadowsocks _ properties ; public static class n { private static dictionary < string , string > strings = new dictionary < string , string > ( ) ; private static void init ( string res ) { using ( var sr = new string _ reader ( res ) ) {
public static class n { private static dictionary < string , string > strings = new dictionary < string , string > ( ) ; private static void init ( string res ) { using ( var sr = new string _ reader ( res ) ) { foreach ( var line in sr . non _ white _ space _ lines ( ) ) {
foreach ( var line in sr . non _ white _ space _ lines ( ) ) { continue ; var pos = line . index _ of ( '=' ) ; if ( pos < 1 ) continue ; strings [ line . substring ( 0 , pos ) ] = line . substring ( pos + 1 ) ; } } } static n ( ) {
using system ; using system _ drawing ; using system _ windows _ forms ;
perform _ layout ( ) ; update _ texts ( ) ; setup _ value _ changed _ listeners ( ) ; icon = icon . from _ handle ( resources . ssw . get _ hicon ( ) ) ; this . controller = controller ; controller . config _ changed + = controller _ config _ changed ; load _ current _ configuration ( ) ; } private void update _ texts ( ) {
setup _ value _ changed _ listeners ( ) ; icon = icon . from _ handle ( resources . ssw . get _ hicon ( ) ) ; this . controller = controller ; controller . config _ changed + = controller _ config _ changed ; load _ current _ configuration ( ) ; } private void update _ texts ( ) { password _ label . text = n . get _ string ( STR ) ; show _ passwd _ check _ box . text = n . get _ string ( STR ) ; encryption _ label . text = n . get _ string ( STR ) ; plugin _ label . text = n . get _ string ( STR ) ; plugin _ options _ label . text = n . get _ string ( STR ) ; plugin _ arguments _ label . text = n . get _ string ( STR ) ; need _ plugin _ arg _ check _ box . text = n . get _ string ( STR ) ; proxy _ port _ label . text = n . get _ string ( STR ) ; portable _ mode _ check _ box . text = n . get _ string ( STR ) ; tool _ tip . set _ tool _ tip ( portable _ mode _ check _ box , n . get _ string ( STR ) ) ;

using system _ reflection ; using shadowsocks _ view ; namespace shadowsocks _ controller _ hotkeys { public class hotkey _ callbacks {
using system ; using system _ collections _ generic ; using system _ io ; using system _ linq ; using system _ net ; using system _ text ; using shadowsocks _ model ; using system _ io ; using system _ net _ network _ information ;
namespace shadowsocks _ controller _ strategy { class statistics _ strategy : i _ strategy { private readonly shadowsocks _ controller controller ; private server current _ server ; private readonly timer timer ;
current _ server = servers [ random _ index ] ; timer = new timer ( reload _ statistics _ and _ choose _ a _ server ) ; } private void reload _ statistics _ and _ choose _ a _ server ( object obj ) { logging . debug ( STR ) ; var servers = controller . get _ current _ configuration ( ) . configs ; load _ statistics ( ) ; choose _ new _ server ( servers ) ; }
} } * / private void load _ statistics ( ) { try { var path = availability _ statistics . availability _ statistics _ file ; logging . debug ( $ STR ) ; if ( ! file . exists ( path ) ) {
try { var path = availability _ statistics . availability _ statistics _ file ; logging . debug ( $ STR ) ; if ( ! file . exists ( path ) ) { log _ when _ enabled ( $ STR ) ; timer . change ( retry _ interval , cached _ interval ) ; return ; }
min _ response = server . min ( data = > data . roundtrip _ time ) , max _ response = server . max ( data = > data . roundtrip _ time ) } } ) . to _ dictionary ( server = > server . server _ name , server = > server . data ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; } }
logging . log _ useful _ exception ( e ) ; } } private static double get _ score ( statistics _ data data ) { return ( double ) data . success _ times / ( data . success _ times + data . timed _ out _ times ) ; } public class statistics _ data {
} public class statistics _ data { public int success _ times ; public int timed _ out _ times ; public int average _ response ; public int min _ response ; public int max _ response ; } private void choose _ new _ server ( list < server > servers ) {
private void choose _ new _ server ( list < server > servers ) { if ( statistics = = null | | servers . count = = 0 ) { return ; } try { var best _ result = ( from server in servers let name = server . friendly _ name ( )
return ; } try { var best _ result = ( from server in servers let name = server . friendly _ name ( ) where statistics . contains _ key ( name ) select new { server ,
using system _ drawing ; using system _ data ; using system _ linq ; using system _ text ; using system _ windows _ forms ; namespace shadowsocks _ view { public partial class calculation _ control : user _ control {
using system _ linq ; using system _ text ; using system _ windows _ forms ; namespace shadowsocks _ view { public partial class calculation _ control : user _ control { public calculation _ control ( string value ) { initialize _ component ( ) ;
{ public partial class calculation _ control : user _ control { public calculation _ control ( string value ) { initialize _ component ( ) ; value _ label . text = value ; } public string value = > value _ label . text ;
} base . dispose ( disposing ) ; } private void initialize _ component ( ) { this . components = new system . component _ model . container ( ) ; system . windows . forms . data _ visualization . charting . chart _ area chart _ area = new system . windows . forms . data _ visualization . charting . chart _ area ( ) ; system . windows . forms . data _ visualization . charting . legend legend = new system . windows . forms . data _ visualization . charting . legend ( ) ; system . windows . forms . data _ visualization . charting . series series = new system . windows . forms . data _ visualization . charting . series ( ) ; system . windows . forms . data _ visualization . charting . series series = new system . windows . forms . data _ visualization . charting . series ( ) ;
this . statistics _ enabled _ check _ box = new system . windows . forms . check _ box ( ) ; this . choice _ kept _ minutes _ num = new system . windows . forms . numeric _ up _ down ( ) ; this . by _ hour _ of _ day _ check _ box = new system . windows . forms . check _ box ( ) ; this . repeat _ times _ num = new system . windows . forms . numeric _ up _ down ( ) ; this . label = new system . windows . forms . label ( ) ; this . split _ container = new system . windows . forms . split _ container ( ) ; this . label = new system . windows . forms . label ( ) ; this . calculation _ container = new system . windows . forms . flow _ layout _ panel ( ) ; this . cancel _ button = new system . windows . forms . button ( ) ; this . ok _ button = new system . windows . forms . button ( ) ;
this . statistics _ chart . chart _ areas . add ( chart _ area ) ; this . statistics _ chart . dock = system . windows . forms . dock _ style . fill ; legend . back _ color = system . drawing . color . transparent ; legend . name = STR ; this . statistics _ chart . legends . add ( legend ) ; this . statistics _ chart . location = new system . drawing . point ( 0 , 0 ) ; this . statistics _ chart . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . statistics _ chart . name = STR ; this . statistics _ chart . palette = system . windows . forms . data _ visualization . charting . chart _ color _ palette . pastel ; series . chart _ area = STR ;
legend . name = STR ; this . statistics _ chart . legends . add ( legend ) ; this . statistics _ chart . location = new system . drawing . point ( 0 , 0 ) ; this . statistics _ chart . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . statistics _ chart . name = STR ; this . statistics _ chart . palette = system . windows . forms . data _ visualization . charting . chart _ color _ palette . pastel ; series . chart _ area = STR ; series . chart _ type = system . windows . forms . data _ visualization . charting . series _ chart _ type . area ; series . color = system . drawing . color . from _ argb ( ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) , ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) , ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) ) ; series . legend = STR ;
this . statistics _ chart . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . statistics _ chart . name = STR ; this . statistics _ chart . palette = system . windows . forms . data _ visualization . charting . chart _ color _ palette . pastel ; series . chart _ area = STR ; series . chart _ type = system . windows . forms . data _ visualization . charting . series _ chart _ type . area ; series . color = system . drawing . color . from _ argb ( ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) , ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) , ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) ) ; series . legend = STR ; series . name = STR ; series . chart _ area = STR ;
series . chart _ area = STR ; series . chart _ type = system . windows . forms . data _ visualization . charting . series _ chart _ type . area ; series . color = system . drawing . color . from _ argb ( ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) , ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) , ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) ) ; series . legend = STR ; series . name = STR ; series . chart _ area = STR ; series . chart _ type = system . windows . forms . data _ visualization . charting . series _ chart _ type . bubble ; series . color = system . drawing . color . from _ argb ( ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) , ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) , ( ( int ) ( ( ( byte ) ( 0 ) ) ) ) ) ; series . legend = STR ;
series . name = STR ; series . chart _ area = STR ; series . chart _ type = system . windows . forms . data _ visualization . charting . series _ chart _ type . bubble ; series . color = system . drawing . color . from _ argb ( ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) , ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) , ( ( int ) ( ( ( byte ) ( 0 ) ) ) ) ) ; series . legend = STR ; series . name = STR ; series . y _ values _ per _ point = NUM ; series . border _ width = NUM ; series . chart _ area = STR ; series . chart _ type = system . windows . forms . data _ visualization . charting . series _ chart _ type . line ; series . color = system . drawing . color . from _ argb ( ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) , ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) , ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) ) ; series . legend = STR ; series . name = STR ; this . statistics _ chart . series . add ( series ) ; this . statistics _ chart . series . add ( series ) ;
using system _ linq ; using system _ net ; using simple _ json ; using system _ net _ http ; using system _ net _ network _ information ; using system _ threading _ tasks ; using system _ windows _ forms ; using shadowsocks _ model ;
namespace shadowsocks _ controller { using data _ unit = key _ value _ pair < string , string > ; using data _ list = list < key _ value _ pair < string , string > > ; internal class availability _ statistics { private const string statistics _ files _ name = STR ; private const string delimiter = STR ; private const int timeout = NUM ;
private const int repeat = NUM ; private const int interval = NUM * NUM * NUM ; private const int delay _ before _ start = 1 * NUM ; private timer timer ; private state state ; private list < server > servers ; public static string availability _ statistics _ file ; static availability _ statistics ( ) {
private timer timer ; private state state ; private list < server > servers ; public static string availability _ statistics _ file ; static availability _ statistics ( ) { string temppath = utils . get _ temp _ path ( ) ; availability _ statistics _ file = path . combine ( temppath , statistics _ files _ name ) ; }
} public bool set ( bool enabled ) { try {
{ try { if ( enabled ) {
try { if ( enabled ) { if ( timer ? . change ( 0 , interval ) = = null ) { state = new state ( ) ;
if ( ! global :: simple _ json . simple _ json . try _ deserialize _ object ( json _ string , out obj ) ) return ret ; string country = obj [ STR ] ; string city = obj [ STR ] ; string isp = obj [ STR ] ; string region _ name = obj [ STR ] ; if ( country = = null | | city = = null | | isp = = null | | region _ name = = null ) return ret ; ret [ 0 ] = new data _ unit ( state . geolocation , $ STR ) ; ret [ 1 ] = new data _ unit ( state . isp , isp ) ; return ret ; }
return ret ; } private static async task < list < data _ list > > icmp _ test ( server server ) { logging . debug ( STR + server . friendly _ name ( ) ) ; if ( server . server = = STR ) return null ; var ping = new ping ( ) ; var ret = new list < data _ list > ( ) ; foreach (
logging . debug ( STR + server . friendly _ name ( ) ) ; if ( server . server = = STR ) return null ; var ping = new ping ( ) ; var ret = new list < data _ list > ( ) ; foreach ( var timestamp in enumerable . range ( 0 , repeat ) . select ( = > date _ time . now . to _ string ( STR ) ) ) { try {
string [ ] lines ; if ( ! file . exists ( availability _ statistics _ file ) ) { var header _ line = string . join ( delimiter , data . select ( kv = > kv . key ) . to _ array ( ) ) ; lines = new [ ] { header _ line , data _ line } ; } else { lines = new [ ] { data _ line } ; }
lines = new [ ] { header _ line , data _ line } ; } else { lines = new [ ] { data _ line } ; } file . append _ all _ lines ( availability _ statistics _ file , lines ) ; }
else { lines = new [ ] { data _ line } ; } file . append _ all _ lines ( availability _ statistics _ file , lines ) ; } internal void update _ configuration ( configuration config ) {
} file . append _ all _ lines ( availability _ statistics _ file , lines ) ; } internal void update _ configuration ( configuration config ) { set ( config . availability _ statistics ) ; servers = config . configs ; }
using system _ text ; using system _ threading _ tasks ; namespace shadowsocks _ controller { static class protocol _ handler { private static logger logger = log _ manager . get _ current _ class _ logger ( ) ; private static readonly string executable _ path = assembly . get _ entry _ assembly ( ) . location ; public static bool set ( bool enabled ) {
{ static class protocol _ handler { private static logger logger = log _ manager . get _ current _ class _ logger ( ) ; private static readonly string executable _ path = assembly . get _ entry _ assembly ( ) . location ; public static bool set ( bool enabled ) { registry _ key run _ key = null ; try {
try { registry _ key hkcr = registry _ key . open _ base _ key ( registry _ hive . classes _ root , environment . is _ bit _ operating _ system ? registry _ view . registry : registry _ view . registry ) ; run _ key = hkcr . create _ sub _ key ( STR , registry _ key _ permission _ check . read _ write _ sub _ tree ) ; if ( run _ key = = null ) { logger . error ( STR ) ; return false ; } if ( enabled ) {
if ( enabled ) { run _ key . set _ value ( STR , STR ) ; run _ key . set _ value ( STR , STR ) ; var shell _ open = run _ key . create _ sub _ key ( STR ) . create _ sub _ key ( STR ) . create _ sub _ key ( STR ) ; shell _ open . set _ value ( STR , $ STR ) ; } else {
{ logger . log _ useful _ exception ( e ) ; return false ; } finally { if ( run _ key ! = null ) { try {
run _ key . close ( ) ; run _ key . dispose ( ) ; } catch ( exception e ) { logger . log _ useful _ exception ( e ) ; } } } } public static bool check ( ) {
catch ( exception e ) { logger . log _ useful _ exception ( e ) ; } } } } public static bool check ( ) { registry _ key run _ key = null ; try {
} } public static bool check ( ) { registry _ key run _ key = null ; try { run _ key = utils . open _ reg _ key ( STR , true , registry _ hive . classes _ root ) ; if ( run _ key = = null ) {
{ registry _ key run _ key = null ; try { run _ key = utils . open _ reg _ key ( STR , true , registry _ hive . classes _ root ) ; if ( run _ key = = null ) { logger . error ( STR ) ; return false ; }
{ logger . log _ useful _ exception ( e ) ; return false ; } finally { if ( run _ key ! = null ) { try {
using system _ reflection ; using system _ runtime _ compiler _ services ; using system _ runtime _ interop _ services ; assembly _ assembly _ title _ shadowsocks _ csharp assembly _ assembly _ description assembly _ assembly _ configuration
using system _ reflection ; using system _ runtime _ compiler _ services ; using system _ runtime _ interop _ services ; assembly _ assembly _ title _ shadowsocks _ csharp assembly _ assembly _ description assembly _ assembly _ configuration assembly _ assembly _ company assembly _ assembly _ product _ shadowsocks _ csharp
using system _ collections _ generic ; using system _ diagnostics ; using system _ io ; using system _ i _ compression ; using system _ runtime _ interop _ services ; using system _ text ; namespace shadowsocks _ util { public class utils {
using system _ runtime _ interop _ services ; using system _ text ; namespace shadowsocks _ util { public class utils { public static void release _ memory ( ) { gc . collect ( gc . max _ generation ) ; gc . wait _ for _ pending _ finalizers ( ) ;
try { remote . shutdown ( socket _ shutdown . both ) ; remote . close ( ) ; } catch ( socket _ exception e ) { console . write _ line ( e ) ; } }
try { int bytes _ read = remote . end _ receive ( ar ) ; if ( bytes _ read > 0 ) { int bytes _ to _ send ;
try { int bytes _ read = connection . end _ receive ( ar ) ; if ( bytes _ read > 0 ) { int bytes _ to _ send ;
new async _ callback ( accept _ callback ) , listener ) ; conn . begin _ receive ( new byte [ NUM ] , 0 , NUM , 0 , new async _ callback ( receive _ callback ) , conn ) ; } catch ( exception e ) {
sta _ thread static void main ( ) { if ( ! utils . is _ win _ vista _ or _ higher ( ) ) { message _ box . show ( n . get _ string ( STR ) , STR , message _ box _ buttons . ok , message _ box _ icon . error ) ; return ; } utils . release _ memory ( true ) ;
controller . start ( ) ; application . run ( ) ; } } private static int exited = 0 ; private static void current _ domain _ unhandled _ exception ( object sender , unhandled _ exception _ event _ args e ) { if ( interlocked . increment ( ref exited ) = = 1 ) { logging . error ( e . exception _ object ? . to _ string ( ) ) ;
if ( closed ) return ; try { int bytes _ read = first _ packet _ length ; if ( bytes _ read > 1 ) { byte [ ] response = { NUM , 0 } ; if ( first _ packet [ 0 ] ! = NUM ) { response = new byte [ ] { 0 , NUM } ;
logging . error ( STR ) ; } connection . begin _ send ( response , 0 , response . length , socket _ flags . none , handshake _ send _ callback , null ) ; } else close ( ) ; } catch ( exception e ) {
case cmd _ connect : byte [ ] response = { NUM , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 } ; connection . begin _ send ( response , 0 , response . length , socket _ flags . none , response _ callback , null ) ; break ; case cmd _ udp _ assoc : read _ address ( handle _ udp _ associate ) ; break ; case cmd _ bind : default :
} else { logging . debug ( STR ) ; close ( ) ; } } catch ( exception e ) {
addr _ buf _ length = addr _ atyp _ len + 1 + len + addr _ port _ len ; break ; case atyp _ i _ pv : dst _ addr = $ STR ; dst _ port = ( connetion _ recv _ buffer [ NUM ] < < NUM ) + connetion _ recv _ buffer [ NUM ] ; addr _ buf _ length = addr _ atyp _ len + NUM + addr _ port _ len ; break ; } if ( config . is _ verbose _ logging ) {
} if ( config . is _ verbose _ logging ) { logging . info ( $ STR ) ; } dest _ end _ point = socket _ util . get _ end _ point ( dst _ addr , dst _ port ) ; on _ success . invoke ( ) ; } else {
on _ success . invoke ( ) ; } else { logging . debug ( STR ) ; close ( ) ; } } catch ( exception e ) {
} private void start _ pipe ( async _ session session ) { if ( closed ) return ; try { start _ receiving _ time = date _ time . now ; session . remote . begin _ receive ( remote _ recv _ buffer , 0 , recv _ size , socket _ flags . none , pipe _ remote _ receive _ callback , session ) ; try _ read _ available _ data ( ) ;
{ start _ receiving _ time = date _ time . now ; session . remote . begin _ receive ( remote _ recv _ buffer , 0 , recv _ size , socket _ flags . none , pipe _ remote _ receive _ callback , session ) ; try _ read _ available _ data ( ) ; logging . debug ( $ STR ) ; send _ to _ server ( first _ packet _ length , session ) ; } catch ( exception e ) {
last _ activity = date _ time . now ; int bytes _ to _ send = - 1 ; lock ( decryption _ lock ) { try { encryptor . decrypt ( remote _ recv _ buffer , bytes _ read , remote _ send _ buffer , out bytes _ to _ send ) ; } catch ( crypto _ error _ exception ) {
server , x = > sip _ plugin . create _ if _ configured ( x , config . show _ plugin _ output ) ) ; if ( plugin = = null ) { return null ; } try { if ( plugin . start _ if _ needed ( ) ) {
try { if ( plugin . start _ if _ needed ( ) ) { logging . info ( $ STR ) ; } } catch ( exception ex ) {
if ( ! raw _ statistics . try _ get _ value ( server _ identifier , out records ) ) { records = new list < statistics _ record > ( ) ; raw _ statistics [ server _ identifier ] = records ; } } records . add ( record ) ; } catch ( exception e ) {
} records . add ( record ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; } } private void save ( ) {
foreach ( var server _ and _ records in raw _ statistics ) { var server = server _ and _ records . key ; var filtered _ records = server _ and _ records . value . find _ all ( is _ valid _ record ) ; filtered _ statistics [ server ] = filtered _ records ; } filtered _ statistics = filtered _ statistics ; } catch ( exception e ) {
catch ( exception e ) { logging . log _ useful _ exception ( e ) ; } } private void load _ raw _ statistics ( ) { try { var path = availability _ statistics _ file ;
ip . address _ family = = address _ family . inter _ network | | ip . address _ family = = address _ family . inter _ network ) ; } repeat - - ; if ( delay > 0 ) thread . sleep ( delay ) ; ping . send _ async ( ip , timeout _ milliseconds , userstate ) ; } catch ( exception e ) {
} else { logging . debug ( $ STR ) ; roundtrip _ time . add ( null ) ; } test _ next ( e . user _ state ) ; } catch ( exception ex ) {
} public virtual void init _ cipher ( byte [ ] salt , bool is _ encrypt , bool is _ udp ) { if ( is _ encrypt ) { encrypt _ salt = new byte [ salt _ len ] ; array . copy ( salt , encrypt _ salt , salt _ len ) ; } else { decrypt _ salt = new byte [ salt _ len ] ; array . copy ( salt , decrypt _ salt , salt _ len ) ; }
return ; } byte [ ] enc _ len _ bytes = dec _ circular _ buffer . peek ( chunk _ len _ bytes + tag _ len ) ; uint dec _ chunk _ len _ length = 0 ; byte [ ] dec _ chunk _ len _ bytes = new byte [ chunk _ len _ bytes ] ; cipher _ decrypt ( enc _ len _ bytes , chunk _ len _ bytes + ( uint ) tag _ len , dec _ chunk _ len _ bytes , ref dec _ chunk _ len _ length ) ; debug . assert ( dec _ chunk _ len _ length = = chunk _ len _ bytes ) ; ushort chunk _ len = ( ushort ) ip _ address . network _ to _ host _ order ( ( short ) bit _ converter . to _ u _ int ( dec _ chunk _ len _ bytes , 0 ) ) ; if ( chunk _ len > chunk _ len _ mask ) {


{ max = status ; } } } if ( max ! = null ) { if ( current _ server = = null | | max . score - current _ server . score > NUM ) { current _ server = max ;
ip _ end _ point local _ end _ point = null ; local _ end _ point = share _ over _ lan ? new ip _ end _ point ( config . is _ i _ pv _ enabled ? ip _ address . i _ pv _ any : ip _ address . any , config . local _ port ) : new ip _ end _ point ( config . is _ i _ pv _ enabled ? ip _ address . i _ pv _ loopback : ip _ address . loopback , config . local _ port ) ; tcp _ socket . bind ( local _ end _ point ) ; udp _ socket . bind ( local _ end _ point ) ; tcp _ socket . listen ( NUM ) ; logging . info ( $ STR ) ; if ( config . is _ verbose _ logging ) {
timer . elapsed - = timer _ elapsed ; timer . enabled = false ; timer . dispose ( ) ; check _ update ( config ) ; } public void check _ update ( configuration config ) { this . config = config ; try {
this . config = config ; try { logging . debug ( STR ) ; web _ client http = create _ web _ client ( ) ; http . download _ string _ completed + = http _ download _ string _ completed ; http . download _ string _ async ( new uri ( update _ url ) ) ; } catch ( exception ex ) {
asset asset = asserts [ asserts . count - 1 ] ; new _ version _ found = true ; latest _ version _ url = asset . browser _ download _ url ; latest _ version _ number = asset . version ; latest _ version _ name = asset . name ; latest _ version _ suffix = asset . suffix = = null ? STR : $ STR ; start _ download ( ) ; } else {
{ logging . debug ( STR ) ; if ( check _ update _ completed ! = null ) { check _ update _ completed ( this , new event _ args ( ) ) ; } } } catch ( exception ex ) {
} private void http _ download _ file _ completed ( object sender , system . component _ model . async _ completed _ event _ args e ) { try { if ( e . error ! = null ) { logging . log _ useful _ exception ( e . error ) ; return ; }
return ; } logging . debug ( $ STR ) ; if ( check _ update _ completed ! = null ) { check _ update _ completed ( this , new event _ args ( ) ) ; } } catch ( exception ex ) {
} if ( ret ! = 0 ) throw new crypto _ error _ exception ( string . format ( STR , ret ) ) ; logging . dump ( STR , ciphertext , ( int ) enc _ clen ) ; clen = ( uint ) enc _ clen ; } public override void cipher _ decrypt ( byte [ ] ciphertext , uint clen , byte [ ] plaintext , ref uint plen ) { debug . assert ( sodium _ dec _ subkey ! = null ) ; int ret ; ulong dec _ plen = 0 ;
remote . bind ( new ip _ end _ point ( get _ ip _ address ( ) , 0 ) ) ; } public void send ( byte [ ] data , int length ) { i _ encryptor encryptor = encryptor _ factory . get _ encryptor ( server . method , server . password ) ; byte [ ] data _ in = new byte [ length - NUM ] ; array . copy ( data , NUM , data _ in , 0 , length - NUM ) ; byte [ ] data _ out = new byte [ NUM ] ; int outlen ; encryptor . encrypt _ udp ( data _ in , length - NUM , data _ out , out outlen ) ;
{ process old _ process = old _ processes [ 0 ] ; } message _ box . show ( n . get _ string ( STR ) + environment . new _ line + n . get _ string ( STR ) , n . get _ string ( STR ) ) ; return ; } directory . set _ current _ directory ( application . startup _ path ) ;
+ environment . new _ line + n . get _ string ( STR ) , n . get _ string ( STR ) ) ; return ; } directory . set _ current _ directory ( application . startup _ path ) ; logging . open _ log _ file ( ) ; string privoxy _ log _ filename = utils . get _ temp _ path ( STR ) ; if ( file . exists ( privoxy _ log _ filename ) ) using ( new file _ stream ( privoxy _ log _ filename , file _ mode . truncate ) ) { }
private static int exited = 0 ; private static void current _ domain _ unhandled _ exception ( object sender , unhandled _ exception _ event _ args e ) { if ( interlocked . increment ( ref exited ) = = 1 ) { string err _ msg = e . exception _ object . to _ string ( ) ;
system . threading . tasks . task . factory . start _ new ( ( ) = > { thread . sleep ( NUM * NUM ) ; try { main _ controller . start ( false ) ; logging . info ( STR ) ; } catch ( exception ex ) {
} public void accept _ callback ( i _ async _ result ar ) { try { socket listener = ( socket ) ar . async _ state ; listener . begin _ accept ( new async _ callback ( accept _ callback ) , listener ) ;
listener . begin _ accept ( new async _ callback ( accept _ callback ) , listener ) ; socket conn = listener . end _ accept ( ar ) ; handler handler = new handler ( ) ; handler . connection = conn ; handler . encryptor = encryptor _ factory . get _ encryptor ( config . method , config . password ) ; handler . config = config ; handler . start ( ) ; }
{ init ( name . contains ( STR ) ? resources . zh _ tw : resources . zh _ cn ) ; } else if ( name . starts _ with ( STR , string _ comparison . ordinal _ ignore _ case ) ) { init ( resources . ja ) ; } }
: resources . zh _ cn ) ; } else if ( name . starts _ with ( STR , string _ comparison . ordinal _ ignore _ case ) ) { init ( resources . ja ) ; } } public static string get _ string ( string key ) { return strings . contains _ key ( key )
socket tcp _ socket ; socket udp _ socket ; list < i _ service > services ; public listener ( list < i _ service > services ) { this . services = services ; } private bool check _ if _ port _ in _ use ( int port ) { ip _ global _ properties ip _ properties = ip _ global _ properties . get _ ip _ global _ properties ( ) ;
private bool check _ if _ port _ in _ use ( int port ) { ip _ global _ properties ip _ properties = ip _ global _ properties . get _ ip _ global _ properties ( ) ; return true ; } } return false ; } public void start ( configuration config ) { this . config = config ; this . share _ over _ lan = config . share _ over _ lan ; if ( check _ if _ port _ in _ use ( config . local _ port ) )
public void end _ connect _ proxy ( i _ async _ result async _ result ) { var state = ( ( fake _ async _ result ) async _ result ) . inner _ state ; if ( state . ex ! = null ) { throw state . ex ; } } public void begin _ connect _ dest ( string host , int port , async _ callback callback , object state ) {
throw state . ex ; } } public void begin _ connect _ dest ( string host , int port , async _ callback callback , object state ) { if ( ! parsed ) { ip _ host _ entry ip _ host _ info = dns . get _ host _ entry ( host ) ; ip _ address = ip _ host _ info . address _ list [ 0 ] ; } ip _ end _ point ep = new ip _ end _ point ( ip _ address , port ) ; dest _ host = host ; dest _ port = port ; byte [ ] request = null ; byte atyp = 0 ;
} if ( request = = null ) { throw new exception ( n . get _ string ( STR ) ) ; } var addr = ep . address . get _ address _ bytes ( ) ; request [ 0 ] = NUM ; request [ 1 ] = 1 ; request [ 2 ] = 0 ; request [ NUM ] = atyp ;
if ( bytes _ read > 0 ) { int atyp = connetion _ recv _ buffer [ 0 ] ; string dst _ addr ; int dst _ port ; switch ( atyp ) { case 1 : dst _ addr = new ip _ address ( connetion _ recv _ buffer . skip ( 1 ) . take ( NUM ) . to _ array ( ) ) . to _ string ( ) ; dst _ port = ( connetion _ recv _ buffer [ NUM ] < < NUM ) + connetion _ recv _ buffer [ NUM ] ;
case 1 : dst _ addr = new ip _ address ( connetion _ recv _ buffer . skip ( 1 ) . take ( NUM ) . to _ array ( ) ) . to _ string ( ) ; dst _ port = ( connetion _ recv _ buffer [ NUM ] < < NUM ) + connetion _ recv _ buffer [ NUM ] ; logging . debug ( $ STR ) ; break ; case NUM : int len = connetion _ recv _ buffer [ 1 ] ; dst _ addr = system . text . encoding . ut . get _ string ( connetion _ recv _ buffer , 2 , len ) ; dst _ port = ( connetion _ recv _ buffer [ len + 2 ] < < NUM ) + connetion _ recv _ buffer [ len + NUM ] ;
case NUM : int len = connetion _ recv _ buffer [ 1 ] ; dst _ addr = system . text . encoding . ut . get _ string ( connetion _ recv _ buffer , 2 , len ) ; dst _ port = ( connetion _ recv _ buffer [ len + 2 ] < < NUM ) + connetion _ recv _ buffer [ len + NUM ] ; logging . debug ( $ STR ) ; break ; case NUM : dst _ addr = new ip _ address ( connetion _ recv _ buffer . skip ( 1 ) . take ( NUM ) . to _ array ( ) ) . to _ string ( ) ; dst _ port = ( connetion _ recv _ buffer [ NUM ] < < NUM ) + connetion _ recv _ buffer [ NUM ] ;
static n ( ) { strings = new dictionary < string , string > ( ) ;
static n ( ) { strings = new dictionary < string , string > ( ) ; if ( culture _ info . current _ culture . ietf _ language _ tag . starts _ with ( STR , string _ comparison . ordinal _ ignore _ case ) ) {
static n ( ) { strings = new dictionary < string , string > ( ) ; if ( culture _ info . current _ culture . ietf _ language _ tag . starts _ with ( STR , string _ comparison . ordinal _ ignore _ case ) ) { using ( var sr = new string _ reader ( resources . cn ) ) {
} finally { if ( user _ settings = = null ) user _ settings = new sysproxy _ config ( ) ; } } private static void parse _ query _ str ( string str ) { string [ ] user _ settings _ arr = str . split ( new string [ ] { STR } , string _ split _ options . remove _ empty _ entries ) ;
using system _ net ; using system _ diagnostics ; using system _ text ; using shadowsocks _ util _ system _ proxy ; namespace n _ log { public static class logger _ extension { public static void dump ( this logger logger , string tag , byte [ ] arr , int length ) {
using system _ text ; using shadowsocks _ util _ system _ proxy ; namespace n _ log { public static class logger _ extension { public static void dump ( this logger logger , string tag , byte [ ] arr , int length ) { var sb = new string _ builder ( $ STR ) ; for ( int i = 0 ; i < length - 1 ; i + + ) {
public static class logger _ extension { public static void dump ( this logger logger , string tag , byte [ ] arr , int length ) { var sb = new string _ builder ( $ STR ) ; for ( int i = 0 ; i < length - 1 ; i + + ) { sb . append ( $ STR ) ; }
for ( int i = 0 ; i < length - 1 ; i + + ) { sb . append ( $ STR ) ; } sb . append ( $ STR ) ; sb . append ( environment . new _ line ) ; logger . debug ( sb . to _ string ( ) ) ; } public static void debug ( this logger logger , end _ point local , end _ point remote , int len , string header = null , string tailer = null ) {
logger . debug ( $ STR ) ; else if ( header = = null & & tailer ! = null ) logger . debug ( $ STR ) ; else if ( header ! = null & & tailer = = null ) logger . debug ( $ STR ) ; else logger . debug ( $ STR ) ; } public static void debug ( this logger logger , socket sock , int len , string header = null , string tailer = null ) {
private bool by _ hour _ of _ day = false ; private int choice _ kept _ minutes = NUM ; private int data _ collection _ minutes = NUM ; private int repeat _ times _ num = NUM ; private const string config _ file = STR ; public static statistics _ strategy _ configuration load ( ) { try { var content = file . read _ all _ text ( config _ file ) ;
private int repeat _ times _ num = NUM ; private const string config _ file = STR ; public static statistics _ strategy _ configuration load ( ) { try { var content = file . read _ all _ text ( config _ file ) ; var configuration = json _ convert . deserialize _ object < statistics _ strategy _ configuration > ( content ) ; return configuration ; }
json [ index + 1 ] = = 'u' & & json [ index + 2 ] = = 'l' & & json [ index + NUM ] = = 'l' ) { index + = NUM ; return token _ null ; } } return token _ none ; }
return token _ none ; } protected static bool serialize _ value ( i _ json _ serializer _ strategy json _ serializer _ strategy , object value , string _ builder builder ) { bool success = true ; if ( value is string ) success = serialize _ string ( ( string ) value , builder ) ; else if ( value is i _ dictionary < string , object > ) { i _ dictionary < string , object > dict = ( i _ dictionary < string , object > ) value ;
if ( value is string ) success = serialize _ string ( ( string ) value , builder ) ; else if ( value is i _ dictionary < string , object > ) { i _ dictionary < string , object > dict = ( i _ dictionary < string , object > ) value ; success = serialize _ object ( json _ serializer _ strategy , dict . keys , dict . values , builder ) ; } else if ( value is i _ dictionary < string , string > ) { i _ dictionary < string , string > dict = ( i _ dictionary < string , string > ) value ;
{ i _ dictionary < string , object > dict = ( i _ dictionary < string , object > ) value ; success = serialize _ object ( json _ serializer _ strategy , dict . keys , dict . values , builder ) ; } else if ( value is i _ dictionary < string , string > ) { i _ dictionary < string , string > dict = ( i _ dictionary < string , string > ) value ; success = serialize _ object ( json _ serializer _ strategy , dict . keys , dict . values , builder ) ; } else if ( value is i _ enumerable )
success = serialize _ number ( value , builder ) ; else if ( value is boolean ) builder . append ( ( bool ) value ? STR : STR ) ; else if ( value = = null ) builder . append ( STR ) ; else { object serialized _ object ; success = json _ serializer _ strategy . serialize _ non _ primitive _ object ( value , out serialized _ object ) ; if ( success )
builder . append ( STR ) ; else { object serialized _ object ; success = json _ serializer _ strategy . serialize _ non _ primitive _ object ( value , out serialized _ object ) ; if ( success ) serialize _ value ( json _ serializer _ strategy , serialized _ object , builder ) ; } return success ; }
while ( ke . move _ next ( ) & & ve . move _ next ( ) ) { object key = ke . current ; object value = ve . current ; if ( ! first ) builder . append ( STR ) ; if ( key is string ) serialize _ string ( ( string ) key , builder ) ; else
object key = ke . current ; object value = ve . current ; if ( ! first ) builder . append ( STR ) ; if ( key is string ) serialize _ string ( ( string ) key , builder ) ; else if ( ! serialize _ value ( json _ serializer _ strategy , value , builder ) ) return false ; builder . append ( STR ) ;
if ( key is string ) serialize _ string ( ( string ) key , builder ) ; else if ( ! serialize _ value ( json _ serializer _ strategy , value , builder ) ) return false ; builder . append ( STR ) ; if ( ! serialize _ value ( json _ serializer _ strategy , value , builder ) ) return false ; first = false ; }
if ( ! serialize _ value ( json _ serializer _ strategy , value , builder ) ) return false ; builder . append ( STR ) ; if ( ! serialize _ value ( json _ serializer _ strategy , value , builder ) ) return false ; first = false ; } builder . append ( STR ) ; return true ; }
return true ; } protected static bool serialize _ array ( i _ json _ serializer _ strategy json _ serializer _ strategy , i _ enumerable an _ array , string _ builder builder ) { builder . append ( STR ) ; bool first = true ; foreach ( object value in an _ array ) { if ( ! first )
bool first = true ; foreach ( object value in an _ array ) { if ( ! first ) builder . append ( STR ) ; if ( ! serialize _ value ( json _ serializer _ strategy , value , builder ) ) return false ; first = false ; }
using system ; using system _ security _ cryptography ; namespace shadowsocks _ encryption { public static class rng { private static rng _ crypto _ service _ provider rng = null ; public static void init ( ) {
{ public static class rng { private static rng _ crypto _ service _ provider rng = null ; public static void init ( ) { if ( rng = = null ) rng = new rng _ crypto _ service _ provider ( ) ; } public static void close ( ) {
{ close ( ) ; init ( ) ; } public static void get _ bytes ( byte [ ] buf ) { get _ bytes ( buf , buf . length ) ; } public static void get _ bytes ( byte [ ] buf , int len ) {
{ get _ bytes ( buf , buf . length ) ; } public static void get _ bytes ( byte [ ] buf , int len ) { if ( rng = = null ) reload ( ) ; try { rng . get _ bytes ( buf , 0 , len ) ; }
public class gfw _ list _ updater { private const string gfwlist _ url = STR ; private static string pac _ file = pac _ server . pac _ file ; public event event _ handler update _ completed ; public event error _ event _ handler error ; private void http _ download _ string _ completed ( object sender , download _ string _ completed _ event _ args e ) { try {
private const string gfwlist _ url = STR ; private static string pac _ file = pac _ server . pac _ file ; public event event _ handler update _ completed ; public event error _ event _ handler error ; private void http _ download _ string _ completed ( object sender , download _ string _ completed _ event _ args e ) { try { string [ ] lines = parse _ result ( e . result ) ; json _ array rules = new json _ array ( ) ; rules . add _ range ( lines ) ; string abp _ content = utils . un _ gzip ( resources . abp _ js ) ;
} } } public void update _ pac _ from _ gfw _ list ( ) { web _ client http = new web _ client ( ) ; http . download _ string _ completed + = http _ download _ string _ completed ; http . download _ string _ async ( new uri ( gfwlist _ url ) ) ; }
} else { registry . set _ value ( STR , 0 ) ; registry . set _ value ( STR , STR ) ; registry . set _ value ( STR , STR + get _ timestamp ( date _ time . now ) ) ; } system _ proxy . notify _ ie ( ) ; copy _ proxy _ setting _ from _ lan ( ) ; }
{ registry . set _ value ( STR , 0 ) ; registry . set _ value ( STR , STR ) ; registry . set _ value ( STR , STR + get _ timestamp ( date _ time . now ) ) ; } system _ proxy . notify _ ie ( ) ; copy _ proxy _ setting _ from _ lan ( ) ; } catch ( exception ) {
{ registry _ key registry = registry . current _ user . open _ sub _ key ( STR , true ) ; registry . set _ value ( STR , 0 ) ; registry . set _ value ( STR , STR ) ; registry . set _ value ( STR , STR ) ; system _ proxy . notify _ ie ( ) ; copy _ proxy _ setting _ from _ lan ( ) ; }
registry . current _ user . open _ sub _ key ( STR , true ) ; registry . set _ value ( STR , 0 ) ; registry . set _ value ( STR , STR ) ; registry . set _ value ( STR , STR ) ; system _ proxy . notify _ ie ( ) ; copy _ proxy _ setting _ from _ lan ( ) ; } catch ( exception ) {
using system _ collections _ generic ; using system _ text ; using system _ net _ sockets ; using system _ net ; namespace shadowsocks _ csharp { class local { private config config ;
namespace shadowsocks _ csharp { class local { private config config ; private encryptor encryptor ; socket listener ; public local ( config config ) { this . config = config ;
return value . to _ string ( STR ) ; } public static void update ( configuration config , bool force _ disable ) { bool global = config . global ; bool enabled = config . enabled ; if ( force _ disable ) { enabled = false ; }
public static void update ( configuration config , bool force _ disable ) { bool global = config . global ; bool enabled = config . enabled ; if ( force _ disable ) { enabled = false ; } if ( enabled ) {
bool global = config . global ; bool enabled = config . enabled ; if ( force _ disable ) { enabled = false ; } if ( enabled ) { if ( global ) {
if ( enabled ) { if ( global ) { win _ i _ net . set _ ie _ proxy ( true , true , STR + config . local _ port . to _ string ( ) , STR ) ; } else {
{ win _ i _ net . set _ ie _ proxy ( true , true , STR + config . local _ port . to _ string ( ) , STR ) ; } else { string pac _ url ; if ( config . use _ online _ pac & & ! config . pac _ url . is _ null _ or _ empty ( ) ) pac _ url = config . pac _ url ; else pac _ url = $ STR ; win _ i _ net . set _ ie _ proxy ( true , false , STR , pac _ url ) ; } }
win _ i _ net . set _ ie _ proxy ( true , true , STR + config . local _ port . to _ string ( ) , STR ) ; } else { string pac _ url ; if ( config . use _ online _ pac & & ! config . pac _ url . is _ null _ or _ empty ( ) ) pac _ url = config . pac _ url ; else pac _ url = $ STR ; win _ i _ net . set _ ie _ proxy ( true , false , STR , pac _ url ) ; } } else {
} private void log _ form _ load ( object sender , event _ args e ) { init _ content ( ) ; timer = new timer ( ) ; timer . interval = NUM ; timer . tick + = timer _ tick ; timer . start ( ) ; this . top _ most = top _ most _ menu _ item . checked = top _ most _ check _ box . checked = top _ most _ trigger ;
if ( cipher = = 0 ) { throw new system . exception ( STR ) ; } key _ len = cipher _ info . key _ size ; iv _ len = cipher _ info . iv _ size ; } private void init _ key ( string password ) { byte [ ] passbuf = encoding . ut . get _ bytes ( password ) ; if ( key = = null ) key = new byte [ key _ len ] ;
key _ len = cipher _ info . key _ size ; iv _ len = cipher _ info . iv _ size ; } private void init _ key ( string password ) { byte [ ] passbuf = encoding . ut . get _ bytes ( password ) ; if ( key = = null ) key = new byte [ key _ len ] ; if ( key . length < key _ len ) array . resize ( ref key , key _ len ) ; legacy _ derive _ key ( passbuf , key ) ; }
} private void init _ key ( string password ) { byte [ ] passbuf = encoding . ut . get _ bytes ( password ) ; if ( key = = null ) key = new byte [ key _ len ] ; if ( key . length < key _ len ) array . resize ( ref key , key _ len ) ; legacy _ derive _ key ( passbuf , key ) ; } public static void legacy _ derive _ key ( byte [ ] password , byte [ ] key ) {
byte [ ] passbuf = encoding . ut . get _ bytes ( password ) ; if ( key = = null ) key = new byte [ key _ len ] ; if ( key . length < key _ len ) array . resize ( ref key , key _ len ) ; legacy _ derive _ key ( passbuf , key ) ; } public static void legacy _ derive _ key ( byte [ ] password , byte [ ] key ) { byte [ ] result = new byte [ password . length + NUM ] ; int i = 0 ; byte [ ] md _ sum = null ;
} public static void legacy _ derive _ key ( byte [ ] password , byte [ ] key ) { byte [ ] result = new byte [ password . length + NUM ] ; int i = 0 ; byte [ ] md _ sum = null ; while ( i < key . length ) { if ( i = = 0 ) { md _ sum = mbed _ tls . m ( password ) ; } else {
int i = 0 ; byte [ ] md _ sum = null ; while ( i < key . length ) { if ( i = = 0 ) { md _ sum = mbed _ tls . m ( password ) ; } else { md _ sum . copy _ to ( result , 0 ) ; password . copy _ to ( result , md _ sum . length ) ; md _ sum = mbed _ tls . m ( result ) ; }
} key _ len = cipher _ info . key _ size ; salt _ len = cipher _ info . salt _ size ; tag _ len = cipher _ info . tag _ size ; nonce _ len = cipher _ info . nonce _ size ; } protected void init _ key ( string password ) { byte [ ] passbuf = encoding . ut . get _ bytes ( password ) ; if ( masterkey = = null ) masterkey = new byte [ key _ len ] ;
nonce _ len = cipher _ info . nonce _ size ; } protected void init _ key ( string password ) { byte [ ] passbuf = encoding . ut . get _ bytes ( password ) ; if ( masterkey = = null ) masterkey = new byte [ key _ len ] ; if ( masterkey . length < key _ len ) array . resize ( ref masterkey , key _ len ) ; derive _ key ( passbuf , masterkey ) ; if ( session _ key = = null ) session _ key = new byte [ key _ len ] ; }
{ serializable public class server { public string server ; public int server _ port ; public int local _ port ; public string password ; public string method ; public string remarks ;
public class server { public string server ; public int server _ port ; public int local _ port ; public string password ; public string method ; public string remarks ; public string friendly _ name {
public string server ; public int server _ port ; public int local _ port ; public string password ; public string method ; public string remarks ; public string friendly _ name { get {
try { p . kill ( ) ; p . wait _ for _ exit ( ) ; } catch ( exception e ) { console . write _ line ( e . to _ string ( ) ) ; } }
catch ( exception e ) { console . write _ line ( e . to _ string ( ) ) ; } } string temppath = path . get _ temp _ path ( ) ; string polipo _ config = resources . polipo _ config ; polipo _ config = polipo _ config . replace ( STR , server . local _ port . to _ string ( ) ) ; polipo _ config = polipo _ config . replace ( STR , configuration . share _ over _ lan ? STR : STR ) ; file _ manager . byte _ array _ to _ file ( temppath + STR , system . text . encoding . ut . get _ bytes ( polipo _ config ) ) ;
public static readonly int recv _ size = NUM ; public static readonly int recv _ reserve _ size = iv _ encryptor . onetimeauth _ bytes + iv _ encryptor . auth _ bytes ; public static readonly int buffer _ size = recv _ size + recv _ reserve _ size + NUM ; public i _ encryptor encryptor ; public server server ;
start _ connect ( ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; } } private class proxy _ timer : timer {
{ remote = new direct _ connect ( ) ; proxy _ ep = null ; } proxy _ timer proxy _ timer = new proxy _ timer ( NUM ) ; proxy _ timer . auto _ reset = false ; proxy _ timer . elapsed + = proxy _ connect _ timer _ elapsed ; proxy _ timer . enabled = true ;
proxy _ timer proxy _ timer = new proxy _ timer ( NUM ) ; proxy _ timer . auto _ reset = false ; proxy _ timer . elapsed + = proxy _ connect _ timer _ elapsed ; proxy _ timer . enabled = true ; proxy _ timer . proxy = remote ; proxy _ timer . dest _ end _ point = socket _ util . get _ end _ point ( server . server , server . server _ port ) ; proxy _ timer . server = server ; proxy _ connected = false ;
logging . log _ useful _ exception ( e ) ; close ( ) ; } } private void proxy _ connect _ timer _ elapsed ( object sender , elapsed _ event _ args e ) { if ( proxy _ connected | | dest _ connected ) { return ; }
} } private void proxy _ connect _ timer _ elapsed ( object sender , elapsed _ event _ args e ) { if ( proxy _ connected | | dest _ connected ) { return ; } var proxy = ( ( proxy _ timer ) sender ) . proxy ; logging . info ( $ STR ) ;
} private void proxy _ connect _ callback ( i _ async _ result ar ) { server server = null ; if ( closed ) { return ; } try {
} } start _ connect _ time = date _ time . now ; server _ timer connect _ timer = new server _ timer ( NUM ) ; connect _ timer . auto _ reset = false ; connect _ timer . elapsed + = dest _ connect _ timer _ elapsed ; connect _ timer . enabled = true ; connect _ timer . server = server ; dest _ connected = false ;
{ if ( dest _ connected ) { return ; } server server = ( ( server _ timer ) sender ) . server ; i _ strategy strategy = controller . get _ current _ strategy ( ) ; strategy ? . set _ failure ( server ) ; logging . info ( $ STR ) ;
retry _ count + + ; } else close ( ) ; } private void connect _ callback ( i _ async _ result ar ) { if ( closed ) return ; try {
{ if ( server ! = null ) { i _ strategy strategy = controller . get _ current _ strategy ( ) ; strategy ? . set _ failure ( server ) ; } logging . log _ useful _ exception ( e ) ; retry _ connect ( ) ; } }
logging . log _ useful _ exception ( e ) ; retry _ connect ( ) ; } } private void start _ pipe ( ) { if ( closed ) return ; try { start _ receiving _ time = date _ time . now ;
} } private void start _ pipe ( ) { if ( closed ) return ; try { start _ receiving _ time = date _ time . now ; remote ? . begin _ receive ( remote _ recv _ buffer , 0 , recv _ size , socket _ flags . none , new async _ callback ( pipe _ remote _ receive _ callback ) , null ) ; connection ? . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , socket _ flags . none , new async _ callback ( pipe _ connection _ receive _ callback ) ,
if ( connection = = null ) return ; int bytes _ read = connection . end _ receive ( ar ) ; total _ write + = bytes _ read ; if ( bytes _ read > 0 ) { * only the first packet contains the socks header , it doesn ' t make sense to parse every packets . * also it ' s unnecessary to parse these data if we turn off the verbose _ logging . * /
int len = connetion _ recv _ buffer [ 1 ] ; dst _ addr = system . text . encoding . ut . get _ string ( connetion _ recv _ buffer , 2 , len ) ; dst _ port = ( connetion _ recv _ buffer [ len + 2 ] < < NUM ) + connetion _ recv _ buffer [ len + NUM ] ; logging . info ( $ STR ) ; break ; case NUM : dst _ addr = new ip _ address ( connetion _ recv _ buffer . skip ( 1 ) . take ( NUM ) . to _ array ( ) ) . to _ string ( ) ; dst _ port = ( connetion _ recv _ buffer [ NUM ] < < NUM ) + connetion _ recv _ buffer [ NUM ] ; logging . info ( $ STR ) ;
close ( ) ; } } private void pipe _ connection _ send _ callback ( i _ async _ result ar ) { if ( closed ) return ; try { connection ? . end _ send ( ar ) ;
using system _ security _ cryptography ; using system _ text ; using system _ threading ; namespace shadowsocks _ encrypt { public class polar _ ssl _ encryptor : encryptor _ base , i _ disposable { const int cipher _ aes = 1 ; const int cipher _ r = 2 ;
public class polar _ ssl _ encryptor : encryptor _ base , i _ disposable { const int cipher _ aes = 1 ; const int cipher _ r = 2 ; const int cipher _ bf = NUM ; static dictionary < string , int [ ] > ciphers = new dictionary < string , int [ ] > { { STR , new int [ ] { NUM , NUM , cipher _ aes , polar _ ssl . aes _ ctx _ size } } , { STR , new int [ ] { NUM , NUM , cipher _ aes , polar _ ssl . aes _ ctx _ size } } , { STR , new int [ ] { NUM , NUM , cipher _ aes , polar _ ssl . aes _ ctx _ size } } ,
private byte [ ] remote _ recv _ buffer = new byte [ recv _ size ] ; private byte [ ] connetion _ recv _ buffer = new byte [ recv _ size ] ; public void start ( byte [ ] first _ packet , int length , socket socket , int target _ port ) { this . first _ packet = first _ packet ; this . first _ packet _ length = length ; this . local = socket ; try { end _ point remote _ ep = socket _ util . get _ end _ point ( STR , target _ port ) ;
private byte [ ] connetion _ recv _ buffer = new byte [ recv _ size ] ; public void start ( byte [ ] first _ packet , int length , socket socket , int target _ port ) { this . first _ packet = first _ packet ; this . first _ packet _ length = length ; this . local = socket ; try { end _ point remote _ ep = socket _ util . get _ end _ point ( STR , target _ port ) ; remote = socket _ util . create _ socket ( remote _ ep ) ; remote . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ;
{ var r = new fake _ async _ result ( state ) ; callback ? . invoke ( r ) ; } public void end _ connect _ proxy ( i _ async _ result async _ result ) { } public void begin _ connect _ dest ( end _ point dest _ end _ point , async _ callback callback , object state ) { dest _ end _ point = dest _ end _ point ;
public void end _ connect _ proxy ( i _ async _ result async _ result ) { } public void begin _ connect _ dest ( end _ point dest _ end _ point , async _ callback callback , object state ) { dest _ end _ point = dest _ end _ point ; if ( remote = = null ) { remote = socket _ util . create _ socket ( dest _ end _ point ) ; remote . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; } remote . begin _ connect ( dest _ end _ point , callback , state ) ; } public void end _ connect _ dest ( i _ async _ result async _ result ) {
public exception ex { get ; set ; } } private socket remote ; private const int socks _ pkt _ max _ size = NUM + NUM + 2 ; private readonly byte [ ] receive _ buffer = new byte [ socks _ pkt _ max _ size ] ; public end _ point local _ end _ point = > remote . local _ end _ point ; public end _ point proxy _ end _ point { get ; private set ; } public end _ point dest _ end _ point { get ; private set ; } public void begin _ connect _ proxy ( end _ point remote _ ep , async _ callback callback , object state ) {
public end _ point local _ end _ point = > remote . local _ end _ point ; public end _ point proxy _ end _ point { get ; private set ; } public end _ point dest _ end _ point { get ; private set ; } public void begin _ connect _ proxy ( end _ point remote _ ep , async _ callback callback , object state ) { remote = socket _ util . create _ socket ( remote _ ep ) ; remote . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; var st = new socks _ state ( ) ; st . callback = callback ; st . async _ state = state ; proxy _ end _ point = remote _ ep ;
public static end _ point get _ end _ point ( string host , int port ) { ip _ address ip _ address ; bool parsed = ip _ address . try _ parse ( host , out ip _ address ) ; if ( parsed ) { return new ip _ end _ point ( ip _ address , port ) ; } return new dns _ end _ point ( host , port ) ; }
ip _ address ip _ address ; bool parsed = ip _ address . try _ parse ( host , out ip _ address ) ; if ( parsed ) { return new ip _ end _ point ( ip _ address , port ) ; } return new dns _ end _ point ( host , port ) ; } public static socket create _ socket ( end _ point end _ point , protocol _ type protocol _ type = protocol _ type . tcp ) {
{ return new ip _ end _ point ( ip _ address , port ) ; } return new dns _ end _ point ( host , port ) ; } public static socket create _ socket ( end _ point end _ point , protocol _ type protocol _ type = protocol _ type . tcp ) { socket _ type socket _ type ; switch ( protocol _ type ) {
return new dns _ end _ point ( host , port ) ; } public static socket create _ socket ( end _ point end _ point , protocol _ type protocol _ type = protocol _ type . tcp ) { socket _ type socket _ type ; switch ( protocol _ type ) { case protocol _ type . tcp : socket _ type = socket _ type . stream ; break ; case protocol _ type . udp : socket _ type = socket _ type . dgram ; break ; default : throw new not _ supported _ exception ( STR + protocol _ type + STR ) ; }
{ socket _ type socket _ type ; switch ( protocol _ type ) { break ; case protocol _ type . udp : socket _ type = socket _ type . dgram ; break ; default : throw new not _ supported _ exception ( STR + protocol _ type + STR ) ; } if ( end _ point is dns _ end _ point ) {
switch ( protocol _ type ) { socket _ type = socket _ type . dgram ; break ; default : throw new not _ supported _ exception ( STR + protocol _ type + STR ) ; } if ( end _ point is dns _ end _ point ) { var socket = new socket ( address _ family . inter _ network , socket _ type , protocol _ type ) ; socket . set _ socket _ option ( socket _ option _ level . i _ pv , ( socket _ option _ name ) NUM , false ) ; return socket ; }
throw new not _ supported _ exception ( STR + protocol _ type + STR ) ; } if ( end _ point is dns _ end _ point ) { var socket = new socket ( address _ family . inter _ network , socket _ type , protocol _ type ) ; socket . set _ socket _ option ( socket _ option _ level . i _ pv , ( socket _ option _ name ) NUM , false ) ; return socket ; } else {
{ try { string response = e . result ; j _ array result = j _ array . parse ( response ) ; list < asset > asserts = new list < asset > ( ) ; if ( result ! = null ) { foreach ( j _ object release in result ) {
{ foreach ( j _ object release in result ) { if ( ( bool ) release [ STR ] ) { continue ; } foreach ( j _ object asset in ( j _ array ) release [ STR ] ) {
if ( ( bool ) release [ STR ] ) { continue ; } foreach ( j _ object asset in ( j _ array ) release [ STR ] ) { asset ass = new asset ( ) ; ass . parse ( asset ) ; if ( ass . is _ new _ version ( version ) ) {
private void sort _ by _ versions ( list < asset > asserts ) { asserts . sort ( new version _ comparer ( ) ) ; } public class asset { public bool prerelease ; public string name ; public string version ; public string browser _ download _ url ;
public bool is _ new _ version ( string current _ version ) { if ( prerelease ) { return false ; } if ( version = = null ) { return false ; }
} private void update _ system _ proxy ( ) { if ( config . enabled ) { system _ proxy . enable ( ) ; } else {
STR , message _ box _ buttons . ok , message _ box _ icon . error ) ; application . exit ( ) ; } } private static void system _ events _ power _ mode _ changed ( object sender , power _ mode _ changed _ event _ args e ) { switch ( e . mode ) { case power _ modes . resume : logging . info ( STR ) ;
} catch ( exception ex ) { state . ex = ex ; state . callback ? . invoke ( new fake _ async _ result ( ar , state ) ) ; } } private void on _ finish ( byte [ ] last _ bytes , int index , int length , object state ) { var st = ( fake _ async _ result ) state ;
{ state . ex = ex ; state . callback ? . invoke ( new fake _ async _ result ( ar , state ) ) ; } } private void on _ finish ( byte [ ] last _ bytes , int index , int length , object state ) { var st = ( fake _ async _ result ) state ; if ( ! established ) {
st . inner _ state . ex = new exception ( n . get _ string ( STR ) ) ; } st . inner _ state . callback ? . invoke ( st ) ; } private void on _ exception ( exception ex , object state ) { var st = ( fake _ async _ result ) state ; st . inner _ state . ex = ex ;
} } if ( host _ match & & path _ match ) {
assert . is _ true ( update _ checker . asset . compare _ version ( STR , STR ) < 0 ) ; assert . is _ true ( update _ checker . asset . compare _ version ( STR , STR ) > 0 ) ; assert . is _ true ( update _ checker . asset . compare _ version ( STR , STR ) = = 0 ) ; assert . is _ true ( update _ checker . asset . compare _ version ( STR , STR ) > 0 ) ; assert . is _ true ( update _ checker . asset . compare _ version ( STR , STR ) < 0 ) ; assert . is _ true ( update _ checker . asset . compare _ version ( STR , STR ) > 0 ) ; } private void run _ encryption _ round ( i _ encryptor encryptor , i _ encryptor decryptor ) { byte [ ] plain = new byte [ NUM ] ;
} private void run _ encryption _ round ( i _ encryptor encryptor , i _ encryptor decryptor ) { byte [ ] plain = new byte [ NUM ] ; byte [ ] cipher = new byte [ plain . length + NUM ] ; byte [ ] plain = new byte [ plain . length + NUM ] ; int out _ len = 0 ; int out _ len = 0 ; var random = new random ( ) ; random . next _ bytes ( plain ) ;
int out _ len = 0 ; var random = new random ( ) ; random . next _ bytes ( plain ) ; encryptor . encrypt ( plain , plain . length , cipher , out out _ len ) ; decryptor . decrypt ( cipher , out _ len , plain , out out _ len ) ; assert . are _ equal ( plain . length , out _ len ) ; for ( int j = 0 ; j < plain . length ; j + + ) { assert . are _ equal ( plain [ j ] , plain [ j ] ) ; }
{ assert . are _ equal ( plain [ j ] , plain [ j ] ) ; } encryptor . encrypt ( plain , NUM , cipher , out out _ len ) ; decryptor . decrypt ( cipher , out _ len , plain , out out _ len ) ; assert . are _ equal ( NUM , out _ len ) ; for ( int j = 0 ; j < out _ len ; j + + ) { assert . are _ equal ( plain [ j ] , plain [ j ] ) ; }
using system _ net ; namespace shadowsocks _ encryption { public abstract class iv _ encryptor : encryptor _ base { public const int max _ key _ length = NUM ; public const int max _ iv _ length = NUM ; public const int onetimeauth _ flag = 0 ; public const int addrtype _ mask = 0 xf ;
public abstract class iv _ encryptor : encryptor _ base { public const int max _ key _ length = NUM ; public const int max _ iv _ length = NUM ; public const int onetimeauth _ flag = 0 ; public const int addrtype _ mask = 0 xf ; public const int onetimeauth _ bytes = NUM ; public const int onetimeauth _ keybytes = NUM ; public const int hash _ bytes = NUM ; public const int clen _ bytes = 2 ;
len = NUM + name _ len ; } else if ( atyp = = NUM ) { len = NUM ; } if ( len = = 0 | | len > length ) throw new exception ( $ STR ) ; return len ; }
int size = len + auth _ bytes ; if ( buf _ size < ( size + offset ) ) throw new exception ( STR ) ; if ( key _ buffer = = null ) { key _ buffer = new byte [ max _ iv _ length + NUM ] ; buffer . block _ copy ( encrypt _ iv , 0 , key _ buffer , 0 , iv _ len ) ; } byte [ ] counter _ bytes = bit _ converter . get _ bytes ( ( uint ) ip _ address . host _ to _ network _ order ( ( int ) counter ) ) ; buffer . block _ copy ( counter _ bytes , 0 , key _ buffer , iv _ len , NUM ) ;
throw new exception ( STR ) ; if ( key _ buffer = = null ) { key _ buffer = new byte [ max _ iv _ length + NUM ] ; buffer . block _ copy ( encrypt _ iv , 0 , key _ buffer , 0 , iv _ len ) ; } byte [ ] counter _ bytes = bit _ converter . get _ bytes ( ( uint ) ip _ address . host _ to _ network _ order ( ( int ) counter ) ) ; buffer . block _ copy ( counter _ bytes , 0 , key _ buffer , iv _ len , NUM ) ; byte [ ] hash = new byte [ hash _ bytes ] ; byte [ ] tmp = new byte [ len ] ; buffer . block _ copy ( buf , offset , tmp , 0 , len ) ; sodium . crypto _ generichash ( hash , hash _ bytes , tmp , ( ulong ) len , key _ buffer , ( uint ) key _ buffer . length ) ; buffer . block _ copy ( buf , offset , buf , offset + auth _ bytes , len ) ; buffer . block _ copy ( hash , 0 , buf , offset + clen _ bytes , hash _ bytes ) ; byte [ ] clen = bit _ converter . get _ bytes ( ( ushort ) ip _ address . host _ to _ network _ order ( ( short ) len ) ) ; buffer . block _ copy ( clen , 0 , buf , offset , clen _ bytes ) ; counter + + ;
lock ( tempbuf ) {
lock ( tempbuf ) { ss _ gen _ hash ( buf , ref offset , ref len , buf . length ) ; length = head _ len + onetimeauth _ bytes + len ; } cipher _ update ( true , length , buf , tempbuf ) ; outlength = length + iv _ len ; buffer . block _ copy ( tempbuf , 0 , outbuf , iv _ len , length ) ; } } else {
if ( ! parsed ) { ip _ host _ entry ip _ host _ info = dns . get _ host _ entry ( server . server ) ; ip _ address = ip _ host _ info . address _ list [ 0 ] ; } remote _ end _ point = new ip _ end _ point ( ip _ address , server . server _ port ) ; remote = new socket ( remote _ end _ point . address _ family , socket _ type . dgram , protocol _ type . udp ) ; } public void send ( byte [ ] data , int length ) {
ip _ address = ip _ host _ info . address _ list [ 0 ] ; } remote _ end _ point = new ip _ end _ point ( ip _ address , server . server _ port ) ; remote = new socket ( remote _ end _ point . address _ family , socket _ type . dgram , protocol _ type . udp ) ; } public void send ( byte [ ] data , int length ) { i _ encryptor encryptor = encryptor _ factory . get _ encryptor ( server . method , server . password ) ; byte [ ] data _ in = new byte [ length - NUM ] ; array . copy ( data , NUM , data _ in , 0 , length - NUM ) ;
remote _ end _ point = new ip _ end _ point ( ip _ address , server . server _ port ) ; remote = new socket ( remote _ end _ point . address _ family , socket _ type . dgram , protocol _ type . udp ) ; } public void send ( byte [ ] data , int length ) { i _ encryptor encryptor = encryptor _ factory . get _ encryptor ( server . method , server . password ) ; byte [ ] data _ in = new byte [ length - NUM ] ; array . copy ( data , NUM , data _ in , 0 , length - NUM ) ; byte [ ] data _ out = new byte [ length - NUM + NUM ] ; int outlen ;
this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ; this . text _ box = new system . windows . forms . text _ box ( ) ; this . text _ box = new system . windows . forms . text _ box ( ) ; this . text _ box = new system . windows . forms . text _ box ( ) ; this . text _ box = new system . windows . forms . text _ box ( ) ; this . panel = new system . windows . forms . panel ( ) ; this . button = new system . windows . forms . button ( ) ; this . button = new system . windows . forms . button ( ) ;
this . panel = new system . windows . forms . panel ( ) ; this . button = new system . windows . forms . button ( ) ; this . button = new system . windows . forms . button ( ) ; this . table _ layout _ panel = new system . windows . forms . table _ layout _ panel ( ) ; this . notify _ icon = new system . windows . forms . notify _ icon ( this . components ) ; this . context _ menu _ strip = new system . windows . forms . context _ menu _ strip ( this . components ) ; this . config _ item = new system . windows . forms . tool _ strip _ menu _ item ( ) ; this . quit _ item = new system . windows . forms . tool _ strip _ menu _ item ( ) ; this . table _ layout _ panel . suspend _ layout ( ) ; this . panel . suspend _ layout ( ) ;
this . context _ menu _ strip . size = new system . drawing . size ( NUM , NUM ) ; this . config _ item . name = STR ; this . config _ item . size = new system . drawing . size ( NUM , NUM ) ; this . config _ item . text = STR ; this . config _ item . click + = new system . event _ handler ( this . config _ click ) ; this . quit _ item . name = STR ; this . quit _ item . size = new system . drawing . size ( NUM , NUM ) ; this . quit _ item . text = STR ; this . quit _ item . click + = new system . event _ handler ( this . quit _ click ) ; this . accept _ button = this . button ;
this . controls . add ( this . table _ layout _ panel ) ; this . controls . add ( this . table _ layout _ panel ) ; this . name = STR ; this . text = STR ; this . form _ closed + = new system . windows . forms . form _ closed _ event _ handler ( this . form _ form _ closed ) ; this . table _ layout _ panel . resume _ layout ( false ) ; this . table _ layout _ panel . perform _ layout ( ) ; this . panel . resume _ layout ( false ) ;
btn _ register _ all . text = n . get _ string ( STR ) ; this . text = n . get _ string ( STR ) ; } private void controller _ config _ changed ( object sender , event _ args e ) { load _ current _ configuration ( ) ; } private void load _ current _ configuration ( ) { modified _ hotkey _ config = controller . get _ configuration _ copy ( ) . hotkey ;
label lb ; prepare _ for _ hotkey ( tb , out call _ back , out lb ) ; unreg _ prev _ hotkey ( call _ back ) ; } private void cancel _ button _ click ( object sender , event _ args e ) { this . close ( ) ; } private void ok _ button _ click ( object sender , event _ args e ) {
{ if ( ! register _ all _ hotkeys ( out ) ) { message _ box . show ( n . get _ string ( STR ) ) ; } save _ config ( ) ; this . close ( ) ; } private void register _ all _ button _ click ( object sender , event _ args e ) {
save _ config ( ) ; this . close ( ) ; } private void register _ all _ button _ click ( object sender , event _ args e ) { register _ all _ hotkeys ( out ) ; } private bool register _ all _ hotkeys ( out string failure _ info _ str ) { bool is _ success = true ;
string _ builder failure _ info = new string _ builder ( ) ; foreach ( var tb in all _ text _ boxes ) { if ( tb . text . is _ null _ or _ empty ( ) ) { continue ; } if ( ! try _ reg _ hotkey ( tb ) ) { is _ success = false ;
public void start ( configuration configuration ) { if ( process = = null ) { process [ ] existing _ privoxy = process . get _ processes _ by _ name ( STR ) ; foreach ( process p in existing _ privoxy . where ( is _ child _ process ) ) { kill _ process ( p ) ; } string privoxy _ config = resources . privoxy _ conf ;
{ process [ ] existing _ privoxy = process . get _ processes _ by _ name ( STR ) ; foreach ( process p in existing _ privoxy . where ( is _ child _ process ) ) { kill _ process ( p ) ; } string privoxy _ config = resources . privoxy _ conf ; running _ port = get _ free _ port ( ) ; privoxy _ config = privoxy _ config . replace ( STR , configuration . local _ port . to _ string ( ) ) ; privoxy _ config = privoxy _ config . replace ( STR , running _ port . to _ string ( ) ) ;
catch ( exception ex ) { * sometimes process . get _ processes _ by _ name will return some processes that * are already dead , and that will cause exceptions here . * we could simply ignore those exceptions . * / logging . log _ useful _ exception ( ex ) ; return false ; } }
* / logging . log _ useful _ exception ( ex ) ; return false ; } } private int get _ free _ port ( ) { int default _ port = NUM ; try {
} public class udp _ state { public socket socket ; public byte [ ] buffer = new byte [ NUM ] ;
return ip _ properties . get _ active _ tcp _ listeners ( ) . any ( end _ point = > end _ point . port = = port ) ; } public void start ( configuration config ) { this . config = config ; this . share _ over _ lan = config . share _ over _ lan ; if ( check _ if _ port _ in _ use ( config . local _ port ) ) throw new exception ( n . get _ string ( STR , config . local _ port ) ) ; try {
if ( check _ if _ port _ in _ use ( config . local _ port ) ) throw new exception ( n . get _ string ( STR , config . local _ port ) ) ; try { tcp _ socket = new socket ( address _ family . inter _ network , socket _ type . stream , protocol _ type . tcp ) ; udp _ socket = new socket ( address _ family . inter _ network , socket _ type . dgram , protocol _ type . udp ) ; tcp _ socket . set _ socket _ option ( socket _ option _ level . socket , socket _ option _ name . reuse _ address , true ) ; udp _ socket . set _ socket _ option ( socket _ option _ level . socket , socket _ option _ name . reuse _ address , true ) ; ip _ end _ point local _ end _ point = null ; local _ end _ point = share _ over _ lan
: new ip _ end _ point ( ip _ address . loopback , config . local _ port ) ; tcp _ socket . bind ( local _ end _ point ) ; udp _ socket . bind ( local _ end _ point ) ; tcp _ socket . listen ( NUM ) ; logging . info ( $ STR ) ; if ( config . is _ verbose _ logging ) { logging . info ( encryption . encryptor _ factory . dump _ registered _ encryptor ( ) ) ; } tcp _ socket . begin _ accept ( new async _ callback ( accept _ callback ) , tcp _ socket ) ;
byte [ ] data _ in = new byte [ length - NUM ] ; array . copy ( data , NUM , data _ in , 0 , length - NUM ) ; byte [ ] data _ out = new byte [ NUM ] ; int outlen ; encryptor . encrypt _ udp ( data _ in , length - NUM , data _ out , out outlen ) ; logging . debug ( local _ end _ point , remote _ end _ point , outlen , STR ) ; remote ? . send _ to ( data _ out , outlen , socket _ flags . none , remote _ end _ point ) ; } public void receive ( ) {
{ end _ point remote _ end _ point = new ip _ end _ point ( ip _ address . any , 0 ) ; logging . debug ( $ STR + buffer . length ) ; remote ? . begin _ receive _ from ( buffer , 0 , buffer . length , 0 , ref remote _ end _ point , new async _ callback ( recv _ from _ callback ) , null ) ; } public void recv _ from _ callback ( i _ async _ result ar ) { try { if ( remote = = null ) return ;
if ( udp _ socket ! = null ) { udp _ socket . close ( ) ; udp _ socket = null ; } services . for _ each ( s = > s . stop ( ) ) ; } public void recv _ from _ callback ( i _ async _ result ar ) { udp _ state state = ( udp _ state ) ar . async _ state ;
} public void recv _ from _ callback ( i _ async _ result ar ) { udp _ state state = ( udp _ state ) ar . async _ state ; try { int bytes _ read = udp _ socket . end _ receive _ from ( ar , ref state . remote _ end _ point ) ; foreach ( i _ service service in services ) {
pac _ server = new pac _ server ( ) ; pac _ server . pac _ file _ changed + = pac _ server _ pac _ file _ changed ; pac _ server . start ( config ) ; } catch ( exception e ) { console . write _ line ( e . message ) ; } update _ system _ proxy ( ) ; }
} } public void touch _ user _ rule _ file ( ) { string user _ rule _ filename = pac _ server . touch _ user _ rule _ file ( ) ; if ( user _ rule _ file _ ready _ to _ open ! = null ) { user _ rule _ file _ ready _ to _ open ( this , new path _ event _ args ( ) { path = user _ rule _ filename } ) ; } }
if ( remote = = null ) { remote = new socket ( remote _ ep . address _ family , socket _ type . stream , protocol _ type . tcp ) ; remote . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; } dest _ end _ point = remote _ ep ; remote . begin _ connect ( remote _ ep , callback , state ) ; } public void end _ connect _ dest ( i _ async _ result async _ result ) {
dest _ end _ point = remote _ ep ; remote . begin _ connect ( remote _ ep , callback , state ) ; } public void end _ connect _ dest ( i _ async _ result async _ result ) { remote . end _ connect ( async _ result ) ; } public void begin _ send ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) {
{ remote . begin _ send ( buffer , offset , size , socket _ flags , callback , state ) ; } public int end _ send ( i _ async _ result async _ result ) { return remote . end _ send ( async _ result ) ; } public void begin _ receive ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) {
{ var state = ( ( fake _ async _ result ) async _ result ) . inner _ state ; if ( state . ex ! = null ) { throw state . ex ; } } public void begin _ send ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) {
{ remote . begin _ send ( buffer , offset , size , socket _ flags , callback , state ) ; } public int end _ send ( i _ async _ result async _ result ) { return remote . end _ send ( async _ result ) ; } public void begin _ receive ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) {
} public void send ( byte [ ] data , int length ) { i _ encryptor encryptor = encryptor _ factory . get _ encryptor ( server . method , server . password , server . auth , true ) ; byte [ ] data _ in = new byte [ length - NUM + iv _ encryptor . onetimeauth _ bytes ] ; array . copy ( data , NUM , data _ in , 0 , length - NUM ) ; byte [ ] data _ out = new byte [ length - NUM + NUM + iv _ encryptor . onetimeauth _ bytes ] ; int outlen ; encryptor . encrypt ( data _ in , length - NUM , data _ out , out outlen ) ; logging . debug ( local _ end _ point , remote _ end _ point , outlen , STR ) ;
byte [ ] data _ out = new byte [ length - NUM + NUM + iv _ encryptor . onetimeauth _ bytes ] ; int outlen ; encryptor . encrypt ( data _ in , length - NUM , data _ out , out outlen ) ; logging . debug ( local _ end _ point , remote _ end _ point , outlen , STR ) ; remote . send _ to ( data _ out , outlen , socket _ flags . none , remote _ end _ point ) ; } public void receive ( ) { end _ point remote _ end _ point = new ip _ end _ point ( ip _ address . any , 0 ) ; logging . debug ( $ STR + buffer . length ) ;
end _ point remote _ end _ point = new ip _ end _ point ( ip _ address . any , 0 ) ; int bytes _ read = remote . end _ receive _ from ( ar , ref remote _ end _ point ) ; byte [ ] data _ out = new byte [ bytes _ read ] ; int outlen ; i _ encryptor encryptor = encryptor _ factory . get _ encryptor ( server . method , server . password , server . auth , true ) ; encryptor . decrypt ( buffer , bytes _ read , data _ out , out outlen ) ; byte [ ] send _ buf = new byte [ outlen + NUM ] ; array . copy ( data _ out , 0 , send _ buf , NUM , outlen ) ; logging . debug ( local _ end _ point , remote _ end _ point , outlen , STR ) ;
using system ; using system _ diagnostics ; using system _ io ; using shadowsocks _ controller ; using shadowsocks _ properties ; using shadowsocks _ model ;
var bypass _ list = user _ settings . bypass _ list ? ? STR ; var pac _ url = user _ settings . pac _ url ? ? STR ; arguments = $ STR ; user _ settings . user _ settings _ recorded = false ; } save ( ) ; exec _ sysproxy ( arguments ) ; } private static void exec _ sysproxy ( string arguments ) {
user _ settings . user _ settings _ recorded = false ; } save ( ) ; exec _ sysproxy ( arguments ) ; } private static void exec _ sysproxy ( string arguments ) { using ( var process = new process ( ) ) {
exec _ sysproxy ( arguments ) ; } private static void exec _ sysproxy ( string arguments ) { using ( var process = new process ( ) ) { process . start _ info . standard _ output _ encoding = encoding . unicode ; process . start _ info . standard _ error _ encoding = encoding . unicode ; process . start _ info . create _ no _ window = true ; process . start ( ) ; var stderr = process . standard _ error . read _ to _ end ( ) ; var stdout = process . standard _ output . read _ to _ end ( ) ; process . wait _ for _ exit ( ) ; var exit _ code = process . exit _ code ; if ( exit _ code ! = ( int ) ret _ errors . ret _ no _ error ) {
using ( var process = new process ( ) ) { var stderr = process . standard _ error . read _ to _ end ( ) ; var stdout = process . standard _ output . read _ to _ end ( ) ; process . wait _ for _ exit ( ) ; var exit _ code = process . exit _ code ; if ( exit _ code ! = ( int ) ret _ errors . ret _ no _ error ) { throw new proxy _ exception ( stderr ) ; } if ( arguments = = STR ) { if ( stdout . is _ null _ or _ white _ space ( ) | | stdout . is _ null _ or _ empty ( ) ) {
var exit _ code = process . exit _ code ; if ( exit _ code ! = ( int ) ret _ errors . ret _ no _ error ) { throw new proxy _ exception ( stderr ) ; } if ( arguments = = STR ) { if ( stdout . is _ null _ or _ white _ space ( ) | | stdout . is _ null _ or _ empty ( ) ) { throw new proxy _ exception ( STR ) ; }
private void update _ servers _ menu ( ) { var items = servers _ item . menu _ items ; while ( items [ 0 ] ! = seperator _ item ) { items . remove _ at ( 0 ) ; } int i = 0 ; foreach ( var strategy in controller . get _ strategies ( ) ) {
item . tag = strategy . id ; item . click + = a _ strategy _ item _ click ; items . add ( i , item ) ; i + + ; } configuration configuration = controller . get _ configuration _ copy ( ) ; foreach ( var server in configuration . configs ) { menu _ item item = new menu _ item ( server . friendly _ name ( ) ) ;
{ shadowsocks _ controller controller ; random random ; public balancing _ strategy ( shadowsocks _ controller controller ) { controller = controller ; random = new random ( ) ; } public string name {
{ controller = controller ; random = new random ( ) ; } public string name { get { return STR ; } } public string id {
public interface i _ strategy { string name { get ; } string id { get ; } server get _ a _ server ( i _ strategy _ caller _ type type , ip _ end _ point local _ ip _ end _ point ) ;
this . table _ layout _ panel . row _ count = NUM ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ; this . table _ layout _ panel . tab _ index = 0 ; this . remarks _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ;
this . table _ layout _ panel . tab _ index = 0 ; this . remarks _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . remarks _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . remarks _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . remarks _ text _ box . name = STR ; this . remarks _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . remarks _ text _ box . tab _ index = NUM ; this . remarks _ text _ box . word _ wrap = false ; this . label . anchor = system . windows . forms . anchor _ styles . right ; this . label . auto _ size = true ;
this . label . anchor = system . windows . forms . anchor _ styles . right ; this . label . auto _ size = true ; this . label . location = new system . drawing . point ( NUM , NUM ) ; this . label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ; this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ; this . label . tab _ index = NUM ; this . label . text = STR ; this . label . anchor = system . windows . forms . anchor _ styles . right ; this . label . auto _ size = true ;
this . label . anchor = system . windows . forms . anchor _ styles . right ; this . label . auto _ size = true ; this . label . location = new system . drawing . point ( NUM , NUM ) ; this . label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ; this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ; this . label . tab _ index = 0 ; this . label . text = STR ; this . label . anchor = system . windows . forms . anchor _ styles . right ; this . label . auto _ size = true ;
this . label . text = STR ; this . label . anchor = system . windows . forms . anchor _ styles . right ; this . label . auto _ size = true ; this . label . location = new system . drawing . point ( NUM , NUM ) ; this . label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ; this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ; this . label . tab _ index = 1 ; this . label . text = STR ; this . proxy _ port _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ;
this . label . text = STR ; this . proxy _ port _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . proxy _ port _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . proxy _ port _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . proxy _ port _ text _ box . name = STR ; this . proxy _ port _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . proxy _ port _ text _ box . tab _ index = NUM ; this . proxy _ port _ text _ box . word _ wrap = false ; this . label . anchor = system . windows . forms . anchor _ styles . right ; this . label . auto _ size = true ;
this . label . anchor = system . windows . forms . anchor _ styles . right ; this . label . auto _ size = true ; this . label . location = new system . drawing . point ( NUM , NUM ) ; this . label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ; this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ; this . label . tab _ index = NUM ; this . label . text = STR ; this . label . anchor = system . windows . forms . anchor _ styles . right ; this . label . auto _ size = true ;
this . label . text = STR ; this . label . anchor = system . windows . forms . anchor _ styles . right ; this . label . auto _ size = true ; this . label . location = new system . drawing . point ( NUM , NUM ) ; this . label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ; this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ; this . label . tab _ index = 2 ; this . label . text = STR ; this . ip _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ;
this . label . tab _ index = 2 ; this . label . text = STR ; this . ip _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . ip _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . ip _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . ip _ text _ box . name = STR ; this . ip _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . ip _ text _ box . tab _ index = 0 ; this . ip _ text _ box . word _ wrap = false ; this . server _ port _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ;
this . ip _ text _ box . tab _ index = 0 ; this . ip _ text _ box . word _ wrap = false ; this . server _ port _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . server _ port _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . server _ port _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . server _ port _ text _ box . name = STR ; this . server _ port _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . server _ port _ text _ box . tab _ index = 1 ; this . server _ port _ text _ box . word _ wrap = false ; this . password _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ;
this . password _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . password _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . password _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . password _ text _ box . name = STR ; this . password _ text _ box . password _ char = '*' ; this . password _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . password _ text _ box . tab _ index = 2 ; this . password _ text _ box . word _ wrap = false ; this . label . anchor = system . windows . forms . anchor _ styles . right ; this . label . auto _ size = true ;
this . encryption _ select . ime _ mode = system . windows . forms . ime _ mode . no _ control ; this . encryption _ select . item _ height = NUM ; this . encryption _ select . items . add _ range ( new object [ ] { STR , STR , STR , STR , STR , STR , STR } ) ;
this . encryption _ select . location = new system . drawing . point ( NUM , NUM ) ; this . encryption _ select . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . encryption _ select . name = STR ; this . encryption _ select . size = new system . drawing . size ( NUM , NUM ) ; this . encryption _ select . tab _ index = NUM ; this . notify _ icon . text = STR ; this . notify _ icon . double _ click + = new system . event _ handler ( this . notify _ icon _ double _ click ) ; this . panel . anchor = system . windows . forms . anchor _ styles . top ; this . panel . auto _ size = true ; this . panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ;
this . notify _ icon . double _ click + = new system . event _ handler ( this . notify _ icon _ double _ click ) ; this . panel . anchor = system . windows . forms . anchor _ styles . top ; this . panel . auto _ size = true ; this . panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . panel . location = new system . drawing . point ( NUM , NUM ) ; this . panel . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . panel . name = STR ; this . panel . size = new system . drawing . size ( 0 , 0 ) ; this . panel . tab _ index = 1 ; this . ok _ button . dialog _ result = system . windows . forms . dialog _ result . ok ;
this . ok _ button . dialog _ result = system . windows . forms . dialog _ result . ok ; this . ok _ button . location = new system . drawing . point ( NUM , NUM ) ; this . ok _ button . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . ok _ button . name = STR ; this . ok _ button . size = new system . drawing . size ( NUM , NUM ) ; this . ok _ button . tab _ index = NUM ; this . ok _ button . text = STR ; this . ok _ button . use _ visual _ style _ back _ color = true ; this . ok _ button . click + = new system . event _ handler ( this . ok _ button _ click ) ; this . my _ cancel _ button . dialog _ result = system . windows . forms . dialog _ result . cancel ;
this . panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . panel . controls . add ( this . my _ cancel _ button ) ; this . panel . controls . add ( this . ok _ button ) ; this . panel . location = new system . drawing . point ( NUM , NUM ) ; this . panel . margin = new system . windows . forms . padding ( 0 ) ; this . panel . name = STR ; this . panel . size = new system . drawing . size ( NUM , NUM ) ; this . panel . tab _ index = 1 ; this . context _ menu . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . enable _ item ,
this . panel . location = new system . drawing . point ( NUM , NUM ) ; this . panel . margin = new system . windows . forms . padding ( 0 ) ; this . panel . name = STR ; this . panel . size = new system . drawing . size ( NUM , NUM ) ; this . panel . tab _ index = 1 ; this . context _ menu . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . enable _ item , this . auto _ startup , this . share _ over _ lan _ item ,
this . panel . name = STR ; this . panel . size = new system . drawing . size ( NUM , NUM ) ; this . panel . tab _ index = 1 ; this . context _ menu . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . enable _ item , this . auto _ startup , this . share _ over _ lan _ item , this . servers _ item , this . menu _ item ,
this . auto _ startup , this . share _ over _ lan _ item , this . servers _ item , this . menu _ item , this . edit _ pac _ file _ item , this . qr _ code _ item , this . show _ log _ item , this . about _ item , this . menu _ item , this . quit _ item } ) ;
this . about _ item , this . menu _ item , this . quit _ item } ) ; this . context _ menu . popup + = new system . event _ handler ( this . context _ menu _ popup ) ; this . enable _ item . index = 0 ; this . enable _ item . text = STR ; this . enable _ item . click + = new system . event _ handler ( this . enable _ item _ click ) ;
this . context _ menu . popup + = new system . event _ handler ( this . context _ menu _ popup ) ; this . enable _ item . index = 0 ; this . enable _ item . text = STR ; this . enable _ item . click + = new system . event _ handler ( this . enable _ item _ click ) ; this . share _ over _ lan _ item . index = 2 ; this . share _ over _ lan _ item . text = STR ; this . share _ over _ lan _ item . click + = new system . event _ handler ( this . share _ over _ lan _ item _ click ) ;
this . quit _ item . text = STR ; this . quit _ item . click + = new system . event _ handler ( this . quit _ click ) ; this . panel . auto _ size = true ; this . panel . controls . add ( this . delete _ button ) ; this . panel . controls . add ( this . add _ button ) ; this . panel . location = new system . drawing . point ( NUM , NUM ) ; this . panel . margin = new system . windows . forms . padding ( 0 ) ; this . panel . name = STR ; this . panel . size = new system . drawing . size ( NUM , NUM ) ; this . panel . tab _ index = NUM ;
this . panel . size = new system . drawing . size ( NUM , NUM ) ; this . panel . tab _ index = NUM ; this . delete _ button . location = new system . drawing . point ( NUM , NUM ) ; this . delete _ button . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . delete _ button . name = STR ; this . delete _ button . size = new system . drawing . size ( NUM , NUM ) ; this . delete _ button . tab _ index = NUM ; this . delete _ button . text = STR ; this . delete _ button . use _ visual _ style _ back _ color = true ; this . delete _ button . click + = new system . event _ handler ( this . delete _ button _ click ) ;
this . delete _ button . click + = new system . event _ handler ( this . delete _ button _ click ) ; this . add _ button . location = new system . drawing . point ( NUM , NUM ) ; this . add _ button . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . add _ button . name = STR ; this . add _ button . size = new system . drawing . size ( NUM , NUM ) ; this . add _ button . tab _ index = NUM ; this . add _ button . text = STR ; this . add _ button . use _ visual _ style _ back _ color = true ; this . add _ button . click + = new system . event _ handler ( this . add _ button _ click ) ; this . server _ group _ box . controls . add ( this . table _ layout _ panel ) ;
this . add _ button . name = STR ; this . add _ button . size = new system . drawing . size ( NUM , NUM ) ; this . add _ button . tab _ index = NUM ; this . add _ button . text = STR ; this . add _ button . use _ visual _ style _ back _ color = true ; this . add _ button . click + = new system . event _ handler ( this . add _ button _ click ) ; this . server _ group _ box . controls . add ( this . table _ layout _ panel ) ; this . server _ group _ box . location = new system . drawing . point ( NUM , NUM ) ; this . server _ group _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . server _ group _ box . name = STR ;
this . server _ group _ box . controls . add ( this . table _ layout _ panel ) ; this . server _ group _ box . location = new system . drawing . point ( NUM , NUM ) ; this . server _ group _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . server _ group _ box . name = STR ; this . server _ group _ box . padding = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . server _ group _ box . size = new system . drawing . size ( NUM , NUM ) ; this . server _ group _ box . tab _ index = NUM ; this . server _ group _ box . tab _ stop = false ; this . server _ group _ box . text = STR ; this . servers _ list _ box . formatting _ enabled = true ;
this . server _ group _ box . tab _ stop = false ; this . server _ group _ box . text = STR ; this . servers _ list _ box . formatting _ enabled = true ; this . servers _ list _ box . item _ height = NUM ; this . servers _ list _ box . location = new system . drawing . point ( NUM , NUM ) ; this . servers _ list _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . servers _ list _ box . name = STR ; this . servers _ list _ box . size = new system . drawing . size ( NUM , NUM ) ; this . servers _ list _ box . tab _ index = NUM ; this . servers _ list _ box . selected _ index _ changed + = new system . event _ handler ( this . servers _ list _ box _ selected _ index _ changed ) ;
private void config _ form _ shown ( object sender , event _ args e ) { ip _ text _ box . focus ( ) ; } private void qr _ code _ item _ click ( object sender , event _ args e ) { qr _ code _ form qr _ code _ form = new qr _ code _ form ( controller . get _ qr _ code _ for _ current _ server ( ) ) ; qr _ code _ form . icon = this . icon ; qr _ code _ form . show ( ) ; }
qr _ code _ form qr _ code _ form = new qr _ code _ form ( controller . get _ qr _ code _ for _ current _ server ( ) ) ; qr _ code _ form . icon = this . icon ; qr _ code _ form . show ( ) ; } private void auto _ startup _ click ( object sender , event _ args e ) { auto _ startup . checked = ! auto _ startup . checked ; if ( ! auto _ startup . set ( auto _ startup . checked ) ) { message _ box . show ( STR ) ; } }


public bool new _ version _ found ; public string latest _ version _ number ; public string latest _ version _ url ; public event event _ handler check _ update _ completed ; public const string version = STR ; public void check _ update ( configuration config ) {
public string latest _ version _ url ; public event event _ handler check _ update _ completed ; public const string version = STR ; public void check _ update ( configuration config ) { http . proxy = new web _ proxy ( ip _ address . loopback . to _ string ( ) , config . local _ port ) ; http . download _ string _ completed + = http _ download _ string _ completed ; http . download _ string _ async ( new uri ( update _ url ) ) ; } public static int compare _ version ( string l , string r ) { var ls = l . split ( '.' ) ; var rs = r . split ( '.' ) ; for ( int i = 0 ; i < math . max ( ls . length , rs . length ) ; i + + ) {
public event event _ handler check _ update _ completed ; public const string version = STR ; public void check _ update ( configuration config ) { } public static int compare _ version ( string l , string r ) { var ls = l . split ( '.' ) ; var rs = r . split ( '.' ) ; for ( int i = 0 ; i < math . max ( ls . length , rs . length ) ; i + + ) { int lp = ( i < ls . length ) ? int . parse ( ls [ i ] ) : 0 ; int rp = ( i < rs . length ) ? int . parse ( rs [ i ] ) : 0 ; if ( lp ! = rp ) { return lp - rp ; } }
{ var ls = l . split ( '.' ) ; var rs = r . split ( '.' ) ; for ( int i = 0 ; i < math . max ( ls . length , rs . length ) ; i + + ) { int lp = ( i < ls . length ) ? int . parse ( ls [ i ] ) : 0 ; int rp = ( i < rs . length ) ? int . parse ( rs [ i ] ) : 0 ; if ( lp ! = rp ) { return lp - rp ; } } return 0 ; } public class version _ comparer : i _ comparer < string > { public int compare ( string x , string y ) {
for ( int i = 0 ; i < math . max ( ls . length , rs . length ) ; i + + ) { if ( lp ! = rp ) { return lp - rp ; } } return 0 ; } public class version _ comparer : i _ comparer < string > { public int compare ( string x , string y ) { return compare _ version ( parse _ version _ from _ url ( x ) , parse _ version _ from _ url ( y ) ) ; }
return compare _ version ( parse _ version _ from _ url ( x ) , parse _ version _ from _ url ( y ) ) ; } } string current _ version = version ; return compare _ version ( version , current _ version ) > 0 ; } private void http _ download _ string _ completed ( object sender , download _ string _ completed _ event _ args e ) { try { string response = e . result ; json _ array result = ( json _ array ) simple _ json . simple _ json . deserialize _ object ( e . result ) ;
json _ array result = ( json _ array ) simple _ json . simple _ json . deserialize _ object ( e . result ) ; list < string > versions = new list < string > ( ) ; foreach ( json _ object release in result ) { if ( ( bool ) release [ STR ] ) { continue ; } foreach ( json _ object asset in ( json _ array ) release [ STR ] ) {
{ if ( ( bool ) release [ STR ] ) { continue ; } foreach ( json _ object asset in ( json _ array ) release [ STR ] ) { string url = ( string ) asset [ STR ] ; if ( is _ new _ version ( url ) ) {
} foreach ( json _ object asset in ( json _ array ) release [ STR ] ) { string url = ( string ) asset [ STR ] ; if ( is _ new _ version ( url ) ) { versions . add ( url ) ; } } }
{ string url = ( string ) asset [ STR ] ; if ( is _ new _ version ( url ) ) { versions . add ( url ) ; } } } if ( versions . count ! = 0 ) {
{ versions . add ( url ) ; } } } if ( versions . count ! = 0 ) { sort _ versions ( versions ) ; new _ version _ found = true ;
latest _ version _ url = versions [ versions . count - 1 ] ; latest _ version _ number = parse _ version _ from _ url ( latest _ version _ url ) ; } if ( check _ update _ completed ! = null ) { check _ update _ completed ( this , new event _ args ( ) ) ; } } catch ( exception ex ) {
{ if ( file . exists ( pac _ file ) ) { return file . read _ all _ text ( pac _ file , encoding . ut ) ; } else { return utils . un _ gzip ( resources . proxy _ pac _ txt ) ; } }
{ return utils . un _ gzip ( resources . proxy _ pac _ txt ) ; } } public void send _ response ( byte [ ] first _ packet , int length , socket socket ) { try { string pac = get _ pac _ content ( ) ; ip _ end _ point local _ end _ point = ( ip _ end _ point ) socket . local _ end _ point ;
watcher . renamed + = watcher _ changed ; watcher . enable _ raising _ events = true ; } private void watcher _ changed ( object sender , file _ system _ event _ args e ) { if ( pac _ file _ changed ! = null ) { pac _ file _ changed ( this , new event _ args ( ) ) ; } }
} private void watcher _ changed ( object sender , file _ system _ event _ args e ) { if ( pac _ file _ changed ! = null ) { pac _ file _ changed ( this , new event _ args ( ) ) ; } } private string get _ pac _ address ( byte [ ] request _ buf , int length , ip _ end _ point local _ end _ point ) {
p . wait _ for _ exit ( ) ; } catch ( exception e ) { console . write _ line ( e . to _ string ( ) ) ; } } string polipo _ config = resources . polipo _ config ; polipo _ config = polipo _ config . replace ( STR , configuration . local _ port . to _ string ( ) ) ;
sysproxy . set _ ie _ proxy ( true , true , STR + config . local _ port . to _ string ( ) , STR ) ; } else { string pac _ url ; if ( config . use _ online _ pac & & ! config . pac _ url . is _ null _ or _ empty ( ) ) pac _ url = config . pac _ url ; else
g . fill _ rectangle ( b , block _ size * row , block _ size * col , block _ size , block _ size ) ; } } } } } picture _ box . image = draw _ area ; } private void qr _ code _ form _ load ( object sender , event _ args e ) {
} } } picture _ box . image = draw _ area ; } private void qr _ code _ form _ load ( object sender , event _ args e ) { var servers = configuration . load ( ) ; var server _ datas = servers . configs . select ( server = >
picture _ box . image = draw _ area ; } private void qr _ code _ form _ load ( object sender , event _ args e ) { var servers = configuration . load ( ) ; var server _ datas = servers . configs . select ( server = > new key _ value _ pair < string , string > ( server . url , server . to _ string ( ) ) ) . to _ list ( ) ; list _ box . data _ source = server _ datas ;
{ if ( server . is _ null _ or _ empty ( ) ) { return n . get _ string ( STR ) ; } string server _ str = $ STR ; return remarks . is _ null _ or _ empty ( ) ? server _ str : $ STR ; }
else { string parts = $ STR ; string base = convert . to _ base _ string ( encoding . ut . get _ bytes ( parts ) ) ; string websafe _ base = base . replace ( '+' , '-' ) . replace ( '/' , '_' ) . trim _ end ( '=' ) ; string plugin _ part = plugin ; if ( ! string . is _ null _ or _ white _ space ( plugin _ opts ) ) { plugin _ part + = STR + plugin _ opts ; }
private readonly func < string , object , bool > on _ line _ read ; private readonly action < exception , object > on _ exception ; private readonly action < byte [ ] , int , int , object > on _ finish ; private readonly encoding encoding ; private readonly byte [ ] delimiter _ bytes ; private readonly byte _ search . search _ target delimiter _ search ; private readonly object state ; private readonly byte [ ] line _ buffer ; private int buffer _ data _ index ; private int buffer _ data _ length ;
private readonly encoding encoding ; private readonly byte [ ] delimiter _ bytes ; private readonly byte _ search . search _ target delimiter _ search ; private readonly object state ; private readonly byte [ ] line _ buffer ; private int buffer _ data _ index ; private int buffer _ data _ length ; public line _ reader ( byte [ ] buffer , wrapped _ socket socket , byte [ ] first _ packge , int index , int length , func < string , object , bool > on _ line _ read , action < exception , object > on _ exception , action < byte [ ] , int , int , object > on _ finish ,
private readonly object state ; private readonly byte [ ] line _ buffer ; private int buffer _ data _ index ; private int buffer _ data _ length ; public line _ reader ( byte [ ] buffer , wrapped _ socket socket , byte [ ] first _ packge , int index , int length , func < string , object , bool > on _ line _ read , action < exception , object > on _ exception , action < byte [ ] , int , int , object > on _ finish , encoding encoding , string delimiter , object state ) {
throw new argument _ null _ exception ( nameof ( on _ line _ read ) ) ; } if ( encoding = = null ) { throw new argument _ null _ exception ( nameof ( encoding ) ) ; } if ( delimiter = = null ) { throw new argument _ null _ exception ( nameof ( delimiter ) ) ; }
if ( encoding = = null ) { throw new argument _ null _ exception ( nameof ( encoding ) ) ; } if ( delimiter = = null ) { throw new argument _ null _ exception ( nameof ( delimiter ) ) ; } if ( buffer . length < length ) {
on _ line _ read = on _ line _ read ; on _ exception = on _ exception ; on _ finish = on _ finish ; encoding = encoding ; state = state ; delimiter _ bytes = encoding . get _ bytes ( delimiter ) ; if ( delimiter _ bytes . length = = 0 ) { throw new argument _ exception ( STR , nameof ( delimiter ) ) ; }
on _ finish = on _ finish ; encoding = encoding ; state = state ; delimiter _ bytes = encoding . get _ bytes ( delimiter ) ; if ( delimiter _ bytes . length = = 0 ) { throw new argument _ exception ( STR , nameof ( delimiter ) ) ; } if ( buffer . length < delimiter _ bytes . length ) {
delimiter _ bytes = encoding . get _ bytes ( delimiter ) ; if ( delimiter _ bytes . length = = 0 ) { throw new argument _ exception ( STR , nameof ( delimiter ) ) ; } if ( buffer . length < delimiter _ bytes . length ) { throw new argument _ exception ( STR , nameof ( buffer ) ) ; } delimiter _ search = new byte _ search . search _ target ( delimiter _ bytes ) ;
throw new argument _ exception ( STR , nameof ( delimiter ) ) ; } if ( buffer . length < delimiter _ bytes . length ) { throw new argument _ exception ( STR , nameof ( buffer ) ) ; } delimiter _ search = new byte _ search . search _ target ( delimiter _ bytes ) ; line _ buffer = buffer ; if ( length > 0 ) {
new _ package _ recv ( ) ; } catch ( exception ex ) { on _ exception ( ex ) ; on _ finish ( ) ; } } else {
{ on _ exception ( ex ) ; on _ finish ( ) ; } } else { socket . begin _ receive ( line _ buffer , 0 , line _ buffer . length , 0 , receive _ callback , 0 ) ; } }
if ( force _ disable ) { enabled = false ; } try { if ( enabled ) { if ( global ) {
static class protocol _ handler { private static logger logger = log _ manager . get _ current _ class _ logger ( ) ; private static readonly string executable _ path = assembly . get _ entry _ assembly ( ) . location ; public static bool set ( bool enabled ) { registry _ key ss _ url _ association = null ; try {
{ check _ port ( server . local _ port ) ; check _ port ( server . server _ port ) ; check _ password ( server . password ) ; check _ server ( server . server ) ; } public static configuration load ( ) { try {
check _ port ( server . server _ port ) ; check _ password ( server . password ) ; check _ server ( server . server ) ; } public static configuration load ( ) { try { var json = STR ; var result = simple _ json . simple _ json . deserialize _ object < list < int > > ( json ) ; string config _ content = file . read _ all _ text ( config _ file ) ;
public qr _ code _ form ( string code ) { this . code = code ; initialize _ component ( ) ; this . icon = icon . from _ handle ( resources . ssw . get _ hicon ( ) ) ; this . text = n . get _ string ( STR ) ; } private void gen _ qr ( string ssconfig ) { string qr _ text = ssconfig ;
private void gen _ qr ( string ssconfig ) { string qr _ text = ssconfig ; { return ; } int block _ size = math . max ( NUM / qr _ coded . get _ module _ count ( ) , 1 ) ; bitmap draw _ area = new bitmap ( ( qr _ coded . get _ module _ count ( ) * block _ size ) , ( qr _ coded . get _ module _ count ( ) * block _ size ) ) ; using ( graphics g = graphics . from _ image ( draw _ area ) ) { g . clear ( color . white ) ; using ( brush b = new solid _ brush ( color . black ) ) {
string qr _ text = ssconfig ; } int block _ size = math . max ( NUM / qr _ coded . get _ module _ count ( ) , 1 ) ; bitmap draw _ area = new bitmap ( ( qr _ coded . get _ module _ count ( ) * block _ size ) , ( qr _ coded . get _ module _ count ( ) * block _ size ) ) ; using ( graphics g = graphics . from _ image ( draw _ area ) ) { g . clear ( color . white ) ; using ( brush b = new solid _ brush ( color . black ) ) { for ( int row = 0 ; row < qr _ coded . get _ module _ count ( ) ; row + + ) {
bitmap draw _ area = new bitmap ( ( qr _ coded . get _ module _ count ( ) * block _ size ) , ( qr _ coded . get _ module _ count ( ) * block _ size ) ) ; using ( graphics g = graphics . from _ image ( draw _ area ) ) { g . clear ( color . white ) ; using ( brush b = new solid _ brush ( color . black ) ) { for ( int row = 0 ; row < qr _ coded . get _ module _ count ( ) ; row + + ) { for ( int col = 0 ; col < qr _ coded . get _ module _ count ( ) ; col + + ) {

menu _ item result = new menu _ item ( n . get _ string ( text ) , click ) ; return result ; } private menu _ item create _ seperator _ item ( ) { menu _ item result = new menu _ item ( STR ) ; return result ; } private menu _ item create _ menu _ group ( string text , menu _ item [ ] items ) {
private void load _ menu ( ) { this . context _ menu = new system . windows . forms . context _ menu ( ) ; this . context _ menu . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . enable _ item = create _ menu _ item ( STR , new system . event _ handler ( this . enable _ item _ click ) ) , create _ menu _ group ( STR , new system . windows . forms . menu _ item [ ] { this . pac _ mode _ item = create _ menu _ item ( STR , new system . event _ handler ( this . pac _ mode _ item _ click ) ) , this . global _ mode _ item = create _ menu _ item ( STR , new system . event _ handler ( this . global _ mode _ item _ click ) ) } ) , this . servers _ item = create _ menu _ group ( STR , new system . windows . forms . menu _ item [ ] {
this . context _ menu . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . enable _ item = create _ menu _ item ( STR , new system . event _ handler ( this . enable _ item _ click ) ) , create _ menu _ group ( STR , new system . windows . forms . menu _ item [ ] { this . pac _ mode _ item = create _ menu _ item ( STR , new system . event _ handler ( this . pac _ mode _ item _ click ) ) , this . global _ mode _ item = create _ menu _ item ( STR , new system . event _ handler ( this . global _ mode _ item _ click ) ) } ) , this . servers _ item = create _ menu _ group ( STR , new system . windows . forms . menu _ item [ ] { this . seperator _ item = create _ seperator _ item ( ) , this . config _ item = create _ menu _ item ( STR , new system . event _ handler ( this . config _ click ) ) } ) ,
this . global _ mode _ item = create _ menu _ item ( STR , new system . event _ handler ( this . global _ mode _ item _ click ) ) } ) , this . servers _ item = create _ menu _ group ( STR , new system . windows . forms . menu _ item [ ] { this . seperator _ item = create _ seperator _ item ( ) , this . config _ item = create _ menu _ item ( STR , new system . event _ handler ( this . config _ click ) ) } ) , create _ seperator _ item ( ) , this . auto _ startup _ item = create _ menu _ item ( STR , new system . event _ handler ( this . auto _ startup _ item _ click ) ) , this . share _ over _ lan _ item = create _ menu _ item ( STR , new system . event _ handler ( this . share _ over _ lan _ item _ click ) ) , create _ menu _ item ( STR , new system . event _ handler ( this . edit _ pac _ file _ item _ click ) ) ,
this . config _ item = create _ menu _ item ( STR , new system . event _ handler ( this . config _ click ) ) } ) , create _ seperator _ item ( ) , this . auto _ startup _ item = create _ menu _ item ( STR , new system . event _ handler ( this . auto _ startup _ item _ click ) ) , this . share _ over _ lan _ item = create _ menu _ item ( STR , new system . event _ handler ( this . share _ over _ lan _ item _ click ) ) , create _ menu _ item ( STR , new system . event _ handler ( this . edit _ pac _ file _ item _ click ) ) , create _ seperator _ item ( ) , create _ menu _ item ( STR , new system . event _ handler ( this . qr _ code _ item _ click ) ) , create _ menu _ item ( STR , new system . event _ handler ( this . show _ log _ item _ click ) ) , create _ menu _ item ( STR , new system . event _ handler ( this . config _ click ) ) ,
public void update _ pac _ from _ gfw _ list ( configuration config ) { web _ client http = new web _ client ( ) ; http . proxy = new web _ proxy ( ip _ address . loopback . to _ string ( ) , config . local _ port ) ; http . download _ string _ completed + = http _ download _ string _ completed ; http . download _ string _ async ( new uri ( gfwlist _ url ) ) ; }
logging . log _ useful _ exception ( e ) ; } } public static void set _ ie _ proxy ( bool enable , bool global , string proxy _ server , string pac _ url ) { string arguments ; if ( enable ) { if ( global ) {
{ string arguments ; if ( enable ) { if ( global ) { arguments = STR + proxy _ server ; } else {
private menu _ item quit _ item ; private menu _ item menu _ item ; private menu _ item mode _ item ; private menu _ item global _ mode _ item ; private menu _ item pac _ mode _ item ; private config _ form config _ form ; public menu _ view _ controller ( shadowsocks _ controller controller ) { load _ menu ( ) ;
this . auto _ startup _ item , this . share _ over _ lan _ item , this . edit _ pac _ file _ item , this . menu _ item , this . qr _ code _ item , this . show _ log _ item , this . about _ item , this . menu _ item , this . quit _ item } ) ; this . enable _ item . index = 0 ;
this . about _ item , this . menu _ item , this . quit _ item } ) ; this . enable _ item . index = 0 ; this . enable _ item . text = STR ; this . enable _ item . click + = new system . event _ handler ( this . enable _ item _ click ) ; this . mode _ item . index = 1 ; this . mode _ item . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . pac _ mode _ item , this . global _ mode _ item } ) ;
this . quit _ item } ) ; this . enable _ item . index = 0 ; this . enable _ item . text = STR ; this . enable _ item . click + = new system . event _ handler ( this . enable _ item _ click ) ; this . mode _ item . index = 1 ; this . mode _ item . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . pac _ mode _ item , this . global _ mode _ item } ) ; this . mode _ item . text = STR ; this . pac _ mode _ item . index = 0 ;
this . enable _ item . click + = new system . event _ handler ( this . enable _ item _ click ) ; this . mode _ item . index = 1 ; this . mode _ item . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . pac _ mode _ item , this . global _ mode _ item } ) ; this . mode _ item . text = STR ; this . pac _ mode _ item . index = 0 ; this . pac _ mode _ item . text = STR ; this . pac _ mode _ item . click + = new system . event _ handler ( this . pac _ mode _ item _ click ) ; this . global _ mode _ item . index = 1 ;
this . pac _ mode _ item . index = 0 ; this . pac _ mode _ item . text = STR ; this . pac _ mode _ item . click + = new system . event _ handler ( this . pac _ mode _ item _ click ) ; this . global _ mode _ item . index = 1 ; this . global _ mode _ item . text = STR ; this . global _ mode _ item . click + = new system . event _ handler ( this . global _ mode _ item _ click ) ; this . servers _ item . index = 2 ; this . servers _ item . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . seperator _ item , this . config _ item } ) ;
this . global _ mode _ item . text = STR ; this . global _ mode _ item . click + = new system . event _ handler ( this . global _ mode _ item _ click ) ; this . servers _ item . index = 2 ; this . servers _ item . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . seperator _ item , this . config _ item } ) ; this . servers _ item . text = STR ; this . seperator _ item . index = 0 ; this . seperator _ item . text = STR ; this . config _ item . index = 1 ;
this . config _ item } ) ; this . servers _ item . text = STR ; this . seperator _ item . index = 0 ; this . seperator _ item . text = STR ; this . config _ item . index = 1 ; this . config _ item . text = STR ; this . config _ item . click + = new system . event _ handler ( this . config _ click ) ; this . menu _ item . index = NUM ; this . menu _ item . text = STR ; this . auto _ startup _ item . index = NUM ;
this . seperator _ item . text = STR ; this . config _ item . index = 1 ; this . config _ item . text = STR ; this . config _ item . click + = new system . event _ handler ( this . config _ click ) ; this . menu _ item . index = NUM ; this . menu _ item . text = STR ; this . auto _ startup _ item . index = NUM ; this . auto _ startup _ item . text = STR ; this . auto _ startup _ item . click + = new system . event _ handler ( this . auto _ startup _ item _ click ) ; this . share _ over _ lan _ item . index = NUM ;
this . config _ item . click + = new system . event _ handler ( this . config _ click ) ; this . menu _ item . index = NUM ; this . menu _ item . text = STR ; this . auto _ startup _ item . index = NUM ; this . auto _ startup _ item . text = STR ; this . auto _ startup _ item . click + = new system . event _ handler ( this . auto _ startup _ item _ click ) ; this . share _ over _ lan _ item . index = NUM ; this . share _ over _ lan _ item . text = STR ; this . share _ over _ lan _ item . click + = new system . event _ handler ( this . share _ over _ lan _ item _ click ) ; this . edit _ pac _ file _ item . index = NUM ;
this . auto _ startup _ item . click + = new system . event _ handler ( this . auto _ startup _ item _ click ) ; this . share _ over _ lan _ item . index = NUM ; this . share _ over _ lan _ item . text = STR ; this . share _ over _ lan _ item . click + = new system . event _ handler ( this . share _ over _ lan _ item _ click ) ; this . edit _ pac _ file _ item . index = NUM ; this . edit _ pac _ file _ item . text = STR ; this . edit _ pac _ file _ item . click + = new system . event _ handler ( this . edit _ pac _ file _ item _ click ) ; this . menu _ item . index = NUM ; this . menu _ item . text = STR ; this . qr _ code _ item . index = NUM ;
this . share _ over _ lan _ item . click + = new system . event _ handler ( this . share _ over _ lan _ item _ click ) ; this . edit _ pac _ file _ item . index = NUM ; this . edit _ pac _ file _ item . text = STR ; this . edit _ pac _ file _ item . click + = new system . event _ handler ( this . edit _ pac _ file _ item _ click ) ; this . menu _ item . index = NUM ; this . menu _ item . text = STR ; this . qr _ code _ item . index = NUM ; this . qr _ code _ item . text = STR ; this . qr _ code _ item . click + = new system . event _ handler ( this . qr _ code _ item _ click ) ; this . show _ log _ item . index = NUM ;
this . edit _ pac _ file _ item . click + = new system . event _ handler ( this . edit _ pac _ file _ item _ click ) ; this . menu _ item . index = NUM ; this . menu _ item . text = STR ; this . qr _ code _ item . index = NUM ; this . qr _ code _ item . text = STR ; this . qr _ code _ item . click + = new system . event _ handler ( this . qr _ code _ item _ click ) ; this . show _ log _ item . index = NUM ; this . show _ log _ item . text = STR ; this . show _ log _ item . click + = new system . event _ handler ( this . show _ log _ item _ click ) ; this . about _ item . index = NUM ;
this . qr _ code _ item . click + = new system . event _ handler ( this . qr _ code _ item _ click ) ; this . show _ log _ item . index = NUM ; this . show _ log _ item . text = STR ; this . show _ log _ item . click + = new system . event _ handler ( this . show _ log _ item _ click ) ; this . about _ item . index = NUM ; this . about _ item . text = STR ; this . about _ item . click + = new system . event _ handler ( this . about _ item _ click ) ; this . menu _ item . index = NUM ; this . menu _ item . text = STR ; this . quit _ item . index = NUM ;
if ( disposing & & ( components ! = null ) ) { components . dispose ( ) ; } base . dispose ( disposing ) ; } private void initialize _ component ( ) { this . table _ layout _ panel = new system . windows . forms . table _ layout _ panel ( ) ; this . remarks _ text _ box = new system . windows . forms . text _ box ( ) ;
base . dispose ( disposing ) ; } private void initialize _ component ( ) { this . table _ layout _ panel = new system . windows . forms . table _ layout _ panel ( ) ; this . remarks _ text _ box = new system . windows . forms . text _ box ( ) ; this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ; this . proxy _ port _ text _ box = new system . windows . forms . text _ box ( ) ;
this . remarks _ text _ box = new system . windows . forms . text _ box ( ) ; this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ; this . proxy _ port _ text _ box = new system . windows . forms . text _ box ( ) ; this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ; this . ip _ text _ box = new system . windows . forms . text _ box ( ) ; this . server _ port _ text _ box = new system . windows . forms . text _ box ( ) ; this . password _ text _ box = new system . windows . forms . text _ box ( ) ;
this . panel . suspend _ layout ( ) ; this . panel . suspend _ layout ( ) ; this . server _ group _ box . suspend _ layout ( ) ; this . suspend _ layout ( ) ; this . table _ layout _ panel . auto _ size = true ; this . table _ layout _ panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . table _ layout _ panel . column _ count = 2 ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . controls . add ( this . remarks _ text _ box , 1 , NUM ) ;
this . table _ layout _ panel . auto _ size = true ; this . table _ layout _ panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . table _ layout _ panel . column _ count = 2 ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . controls . add ( this . remarks _ text _ box , 1 , NUM ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , 0 ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , 1 ) ; this . table _ layout _ panel . controls . add ( this . proxy _ port _ text _ box , 1 , NUM ) ;
this . table _ layout _ panel . controls . add ( this . remarks _ text _ box , 1 , NUM ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , 0 ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , 1 ) ; this . table _ layout _ panel . controls . add ( this . proxy _ port _ text _ box , 1 , NUM ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , 2 ) ; this . table _ layout _ panel . controls . add ( this . ip _ text _ box , 1 , 0 ) ; this . table _ layout _ panel . controls . add ( this . server _ port _ text _ box , 1 , 1 ) ; this . table _ layout _ panel . controls . add ( this . password _ text _ box , 1 , 2 ) ;
this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ; this . table _ layout _ panel . tab _ index = 0 ; this . remarks _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . remarks _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . remarks _ text _ box . name = STR ; this . remarks _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . remarks _ text _ box . tab _ index = NUM ; this . remarks _ text _ box . word _ wrap = false ;
this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ; this . label . tab _ index = 1 ; this . label . text = STR ; this . proxy _ port _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . proxy _ port _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . proxy _ port _ text _ box . name = STR ; this . proxy _ port _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . proxy _ port _ text _ box . tab _ index = NUM ; this . proxy _ port _ text _ box . word _ wrap = false ;

private system . windows . forms . label label ; private system . windows . forms . label label ; private system . windows . forms . label label ; private system . windows . forms . label label ; private system . windows . forms . text _ box ip _ text _ box ; private system . windows . forms . text _ box server _ port _ text _ box ; private system . windows . forms . text _ box password _ text _ box ; private system . windows . forms . text _ box proxy _ port _ text _ box ;
servers _ list _ box . selected _ index = modified _ configuration . configs . count - 1 ; last _ selected _ index = servers _ list _ box . selected _ index ; } private void duplicate _ button _ click ( object sender , event _ args e ) { if ( ! save _ old _ selected _ server ( ) ) { return ; } server curr _ server = modified _ configuration . configs [ last _ selected _ index ] ;
private void duplicate _ button _ click ( object sender , event _ args e ) { if ( ! save _ old _ selected _ server ( ) ) { return ; } server curr _ server = modified _ configuration . configs [ last _ selected _ index ] ; modified _ configuration . configs . add ( curr _ server ) ; load _ configuration ( modified _ configuration ) ;
const string dllname = STR ; public const int aes _ ctx _ size = NUM + NUM * NUM ; public const int aes _ encrypt = 1 ; public const int aes _ decrypt = 0 ; static polar _ ssl ( ) { string temp _ path = path . get _ temp _ path ( ) ; string dll _ path = temp _ path + STR ; try {
public const int aes _ decrypt = 0 ; static polar _ ssl ( ) { string temp _ path = path . get _ temp _ path ( ) ; string dll _ path = temp _ path + STR ; try { file _ manager . uncompress _ file ( dll _ path , resources . polarssl _ dll ) ; }
try { file _ manager . uncompress _ file ( dll _ path , resources . polarssl _ dll ) ; } catch ( io _ exception e ) { console . write _ line ( e . to _ string ( ) ) ; }
} global _ system _ component _ model _ editor _ browsable _ attribute _ global _ system _ component _ model _ editor _ browsable _ state _ advanced internal static global :: system . globalization . culture _ info culture { get { return resource _ culture ; } set { resource _ culture = value ; } }
internal static global :: system . globalization . culture _ info culture { get { return resource _ culture ; } set { resource _ culture = value ; } } internal static byte [ ] libsodium _ dll { get {
{ public class sodium { const string dllname = STR ; static sodium ( ) { string temp _ path = path . get _ temp _ path ( ) ; string dll _ path = temp _ path + STR ; try {
const string dllname = STR ; static sodium ( ) { string temp _ path = path . get _ temp _ path ( ) ; string dll _ path = temp _ path + STR ; try { file _ manager . uncompress _ file ( dll _ path , resources . libsodium _ dll ) ; }
try { file _ manager . uncompress _ file ( dll _ path , resources . libsodium _ dll ) ; } catch ( io _ exception e ) { console . write _ line ( e . to _ string ( ) ) ; }
} private void log _ form _ load ( object sender , event _ args e ) { init _ content ( ) ; timer = new timer ( ) ; timer . interval = NUM ; timer . tick + = timer _ tick ; timer . start ( ) ; this . top _ most = top _ most _ menu _ item . checked = top _ most _ check _ box . checked = top _ most _ trigger ;
if ( ! int . try _ parse ( locs [ 1 ] , out target _ port ) ) { throw new exception ( STR + line ) ; } } else { target _ port = NUM ; } }
target _ port = NUM ; } } headers . enqueue ( line ) ; } } else { if ( line . is _ null _ or _ empty ( ) ) {
} headers . enqueue ( line ) ; } } else { if ( line . is _ null _ or _ empty ( ) ) { headers . enqueue ( STR ) ; return true ;
callback ( ) ; } public static bool is _ hotkey _ exists ( hot _ key hot _ key ) { if ( hot _ key = = null ) throw new argument _ null _ exception ( nameof ( hot _ key ) ) ; return keymap . any ( v = > v . key . equals ( hot _ key ) ) ; } public static bool is _ callback _ exists ( hot _ key _ call _ back _ handler cb , out hot _ key hotkey ) { if ( cb = = null ) throw new argument _ null _ exception ( nameof ( cb ) ) ;
public static bool is _ hotkey _ exists ( hot _ key hot _ key ) { if ( hot _ key = = null ) throw new argument _ null _ exception ( nameof ( hot _ key ) ) ; return keymap . any ( v = > v . key . equals ( hot _ key ) ) ; } public static bool is _ callback _ exists ( hot _ key _ call _ back _ handler cb , out hot _ key hotkey ) { if ( cb = = null ) throw new argument _ null _ exception ( nameof ( cb ) ) ; try {
return keymap . any ( v = > v . key . equals ( hot _ key ) ) ; } public static bool is _ callback _ exists ( hot _ key _ call _ back _ handler cb , out hot _ key hotkey ) { if ( cb = = null ) throw new argument _ null _ exception ( nameof ( cb ) ) ; try { var key = keymap . first ( x = > x . value = = cb ) . key ; hotkey = key ; return true ; }
} private void hotkey _ up ( object sender , key _ event _ args e ) { var tb = ( text _ box ) sender ; var content = tb . text . trim _ end ( ) ; if ( content . length > = 1 & & content [ content . length - 1 ] = = '+' ) { tb . text = STR ; } }
} prepare _ for _ hotkey ( tb , out call _ back , out lb ) ; unreg _ prev _ hotkey ( call _ back ) ; } private void cancel _ button _ click ( object sender , event _ args e ) { this . close ( ) ; } private void ok _ button _ click ( object sender , event _ args e ) {
if ( ! register _ all _ hotkeys ( ) ) { message _ box . show ( n . get _ string ( STR ) ) ; } save _ config ( ) ; this . close ( ) ; } private void register _ all _ button _ click ( object sender , event _ args e ) {
return reg _ result ; } private static void unreg _ prev _ hotkey ( hot _ keys . hot _ key _ call _ back _ handler cb ) { global _ hot _ key . hot _ key prev _ hot _ key ; if ( hot _ keys . is _ callback _ exists ( cb , out prev _ hot _ key ) ) { hot _ keys . unregister ( prev _ hot _ key ) ; } }

this . switch _ system _ proxy _ text _ box . text _ changed + = new system . event _ handler ( this . text _ box _ text _ changed ) ; this . switch _ system _ proxy _ text _ box . key _ down + = new system . windows . forms . key _ event _ handler ( this . hotkey _ down ) ; this . switch _ system _ proxy _ text _ box . key _ up + = new system . windows . forms . key _ event _ handler ( this . hotkey _ up ) ; this . switch _ proxy _ mode _ text _ box . dock = system . windows . forms . dock _ style . fill ; this . switch _ proxy _ mode _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . switch _ proxy _ mode _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . switch _ proxy _ mode _ text _ box . name = STR ; this . switch _ proxy _ mode _ text _ box . read _ only = true ; this . switch _ proxy _ mode _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . switch _ proxy _ mode _ text _ box . tab _ index = NUM ;
this . switch _ proxy _ mode _ text _ box . text _ changed + = new system . event _ handler ( this . text _ box _ text _ changed ) ; this . switch _ proxy _ mode _ text _ box . key _ down + = new system . windows . forms . key _ event _ handler ( this . hotkey _ down ) ; this . switch _ proxy _ mode _ text _ box . key _ up + = new system . windows . forms . key _ event _ handler ( this . hotkey _ up ) ; this . switch _ allow _ lan _ text _ box . dock = system . windows . forms . dock _ style . fill ; this . switch _ allow _ lan _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . switch _ allow _ lan _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . switch _ allow _ lan _ text _ box . name = STR ; this . switch _ allow _ lan _ text _ box . read _ only = true ; this . switch _ allow _ lan _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . switch _ allow _ lan _ text _ box . tab _ index = NUM ;
this . switch _ allow _ lan _ text _ box . text _ changed + = new system . event _ handler ( this . text _ box _ text _ changed ) ; this . switch _ allow _ lan _ text _ box . key _ down + = new system . windows . forms . key _ event _ handler ( this . hotkey _ down ) ; this . switch _ allow _ lan _ text _ box . key _ up + = new system . windows . forms . key _ event _ handler ( this . hotkey _ up ) ; this . show _ logs _ text _ box . dock = system . windows . forms . dock _ style . fill ; this . show _ logs _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . show _ logs _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . show _ logs _ text _ box . name = STR ; this . show _ logs _ text _ box . read _ only = true ; this . show _ logs _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . show _ logs _ text _ box . tab _ index = NUM ;
this . show _ logs _ text _ box . text _ changed + = new system . event _ handler ( this . text _ box _ text _ changed ) ; this . show _ logs _ text _ box . key _ down + = new system . windows . forms . key _ event _ handler ( this . hotkey _ down ) ; this . show _ logs _ text _ box . key _ up + = new system . windows . forms . key _ event _ handler ( this . hotkey _ up ) ; this . server _ move _ up _ text _ box . dock = system . windows . forms . dock _ style . fill ; this . server _ move _ up _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . server _ move _ up _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . server _ move _ up _ text _ box . name = STR ; this . server _ move _ up _ text _ box . read _ only = true ; this . server _ move _ up _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . server _ move _ up _ text _ box . tab _ index = NUM ;
this . server _ move _ up _ text _ box . text _ changed + = new system . event _ handler ( this . text _ box _ text _ changed ) ; this . server _ move _ up _ text _ box . key _ down + = new system . windows . forms . key _ event _ handler ( this . hotkey _ down ) ; this . server _ move _ up _ text _ box . key _ up + = new system . windows . forms . key _ event _ handler ( this . hotkey _ up ) ; this . server _ move _ down _ text _ box . dock = system . windows . forms . dock _ style . fill ; this . server _ move _ down _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . server _ move _ down _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . server _ move _ down _ text _ box . name = STR ; this . server _ move _ down _ text _ box . read _ only = true ; this . server _ move _ down _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . server _ move _ down _ text _ box . tab _ index = NUM ;
{ class tcp _ relay : listener . service { private shadowsocks _ controller controller ; private date _ time last _ sweep _ time ; public i _ set < tcp _ handler > handlers { get ; set ; }
} public void update _ latency ( server server , time _ span latency ) { controller . update _ latency ( server , latency ) ; } } class tcp _ handler { public i _ encryptor encryptor ; public server server ;
{ public i _ encryptor encryptor ; public server server ; public socket remote ; public socket connection ; public shadowsocks _ controller controller ; public tcp _ relay relay ; public date _ time last _ activity ; private const int max _ retry = NUM ; private int retry _ count = 0 ;
{ if ( closed ) { return ; } try { if ( ar . async _ state ! = null ) { connection . end _ send ( ar ) ;
{ connection . end _ send ( ar ) ; logging . debug ( remote , recv _ size , STR ) ; connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , 0 , new async _ callback ( read _ all ) , null ) ; } else { int bytes _ read = connection . end _ receive ( ar ) ; if ( bytes _ read > 0 ) {
{ create _ remote ( ) ; ip _ address ip _ address ; bool parsed = ip _ address . try _ parse ( server . server , out ip _ address ) ; if ( ! parsed ) { ip _ host _ entry ip _ host _ info = dns . get _ host _ entry ( server . server ) ; ip _ address = ip _ host _ info . address _ list [ 0 ] ; } ip _ end _ point remote _ ep = new ip _ end _ point ( ip _ address , server . server _ port ) ;
ip _ address = ip _ host _ info . address _ list [ 0 ] ; } ip _ end _ point remote _ ep = new ip _ end _ point ( ip _ address , server . server _ port ) ; remote = new socket ( ip _ address . address _ family , socket _ type . stream , protocol _ type . tcp ) ; remote . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; start _ connect _ time = date _ time . now ; server _ timer connect _ timer = new server _ timer ( NUM ) ; connect _ timer . auto _ reset = false ;
remote = new socket ( ip _ address . address _ family , socket _ type . stream , protocol _ type . tcp ) ; remote . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; start _ connect _ time = date _ time . now ; server _ timer connect _ timer = new server _ timer ( NUM ) ; connect _ timer . auto _ reset = false ; connect _ timer . elapsed + = connect _ timer _ elapsed ; connect _ timer . enabled = true ; connect _ timer . server = server ;
remote = new socket ( ip _ address . address _ family , socket _ type . stream , protocol _ type . tcp ) ; remote . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; start _ connect _ time = date _ time . now ; server _ timer connect _ timer = new server _ timer ( NUM ) ; connect _ timer . auto _ reset = false ; connect _ timer . elapsed + = connect _ timer _ elapsed ; connect _ timer . enabled = true ; connect _ timer . server = server ; connected = false ;
{ server server = null ; if ( closed ) { return ; } try { server _ timer timer = ( server _ timer ) ar . async _ state ; server = timer . server ;
{ return ; } try { server _ timer timer = ( server _ timer ) ar . async _ state ; server = timer . server ; timer . elapsed - = connect _ timer _ elapsed ; timer . enabled = false ; timer . dispose ( ) ;
using system _ text ; namespace shadowsocks _ encryption { public struct encryptor _ info {
{ public struct encryptor _ info { public string name ; public int key _ size ; public int iv _ size ; public int type ; public encryptor _ info ( string name , int key _ size , int iv _ size , int type ) {
using system _ windows _ forms ; namespace shadowsocks { static class program { dll _ import _ kernel _ dll private static extern int _ ptr load _ library ( string path ) ; sta _ thread static void main ( ) {
{ static class program { dll _ import _ kernel _ dll private static extern int _ ptr load _ library ( string path ) ; sta _ thread static void main ( ) { string temp _ path = path . get _ temp _ path ( ) ; string dll _ path = temp _ path + STR ; try {
sta _ thread static void main ( ) { string temp _ path = path . get _ temp _ path ( ) ; string dll _ path = temp _ path + STR ; try { file _ manager . uncompress _ file ( dll _ path , resources . polarssl _ dll ) ; }

series . color = system . drawing . color . from _ argb ( ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) , ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) , ( ( int ) ( ( ( byte ) ( 0 ) ) ) ) ) ; series . is _ x _ value _ indexed = true ; series . legend = STR ; series . name = STR ; series . chart _ area = STR ; series . chart _ type = system . windows . forms . data _ visualization . charting . series _ chart _ type . line ;
{ public abstract class iv _ encryptor : encryptor _ base { public const int max _ key _ length = NUM ; public const int max _ iv _ length = NUM ; public const int onetimeauth _ flag = 0 ; public const int addrtype _ mask = 0 xf ; public const int onetimeauth _ bytes = NUM ; public const int onetimeauth _ keybytes = NUM ;
protected bool decrypt _ iv _ received ; protected bool encrypt _ iv _ sent ; protected int encrypt _ iv _ offset = 0 ; protected int decrypt _ iv _ offset = 0 ; protected string method ; protected int cipher ; protected int [ ] cipher _ info ; protected byte [ ] key ; protected int key _ len ; protected int iv _ len ;
protected int [ ] cipher _ info ; protected byte [ ] key ; protected int key _ len ; protected int iv _ len ; protected byte [ ] hash _ buf ; protected int hash _ idx = 0 ; public iv _ encryptor ( string method , string password , bool onetimeauth ) : base ( method , password , onetimeauth ) { init _ key ( method , password ) ;
len = NUM + name _ len ; } else if ( atyp = = NUM ) { len = NUM ; } if ( len = = 0 | | len > length ) throw new exception ( $ STR ) ; return len ; }
len = NUM ; } if ( len = = 0 | | len > length ) throw new exception ( $ STR ) ; return len ; } protected int ss _ onetimeauth ( byte [ ] auth , byte [ ] msg , int msg _ len , byte [ ] iv , int iv _ len , byte [ ] key , int key _ len ) { byte [ ] auth _ key = new byte [ onetimeauth _ keybytes ] ; byte [ ] auth _ bytes = new byte [ max _ iv _ length + max _ key _ length ] ;
} byte [ ] iv , int iv _ len , byte [ ] key , int key _ len ) { byte [ ] auth _ key = new byte [ onetimeauth _ keybytes ] ; byte [ ] auth _ bytes = new byte [ max _ iv _ length + max _ key _ length ] ; buffer . block _ copy ( iv , 0 , auth _ bytes , 0 , iv _ len ) ; buffer . block _ copy ( key , 0 , auth _ bytes , iv _ len , key _ len ) ; sodium . crypto _ generichash ( auth _ key , onetimeauth _ keybytes , auth _ bytes , ( ulong ) ( iv _ len + key _ len ) , null , 0 ) ; return sodium . crypto _ onetimeauth ( auth , msg , ( ulong ) msg _ len , auth _ key ) ; }
if ( buf _ size < ( size + offset ) ) throw new exception ( STR ) ; byte [ ] hash = new byte [ hash _ bytes ] ;

splash . location = new point ( ( int ) min _ x , ( int ) min _ y ) ;
using system _ collections _ generic ; using system _ component _ model ; using system _ data ; using system _ drawing ; using system _ text ; using system _ windows _ forms ; namespace shadowsocks _ view {
public qr _ code _ splash _ form ( ) {
public qr _ code _ splash _ form ( ) { initialize _ component ( ) ; } private timer timer ; private int step ; private void qr _ code _ splash _ form _ load ( object sender , event _ args e ) {
initialize _ component ( ) ; } private timer timer ; private int step ; private void qr _ code _ splash _ form _ load ( object sender , event _ args e ) { step = 0 ; timer = new timer ( ) ;
public event event _ handler user _ rule _ file _ changed ; public pac _ daemon ( ) { this . watch _ pac _ file ( ) ; this . watch _ user _ rule _ file ( ) ; } public string touch _ pac _ file ( ) {
{ this . watch _ pac _ file ( ) ; this . watch _ user _ rule _ file ( ) ; } public string touch _ pac _ file ( ) { if ( file . exists ( pac _ file ) ) {
this . watch _ pac _ file ( ) ; this . watch _ user _ rule _ file ( ) ; } public string touch _ pac _ file ( ) { if ( file . exists ( pac _ file ) ) { return pac _ file ; }
if ( file . exists ( pac _ file ) ) { return pac _ file ; } else { file _ manager . uncompress _ file ( pac _ file , resources . proxy _ pac _ txt ) ; return pac _ file ; } } internal string touch _ user _ rule _ file ( ) {
} { file _ manager . uncompress _ file ( pac _ file , resources . proxy _ pac _ txt ) ; return pac _ file ; } } internal string touch _ user _ rule _ file ( ) { if ( file . exists ( user _ rule _ file ) ) { return user _ rule _ file ; } else { file . write _ all _ text ( user _ rule _ file , resources . user _ rule ) ;
} internal string get _ pac _ content ( ) { if ( file . exists ( pac _ file ) ) { return file . read _ all _ text ( pac _ file , encoding . ut ) ; } else {
geosites [ item . group _ name . to _ lower ( ) ] = item . domains ; } } public static void reset _ event ( ) { update _ completed = null ; error = null ; } public static void update _ pac _ from _ geosite ( configuration config ) {
public static void reset _ event ( ) { update _ completed = null ; error = null ; } public static void update _ pac _ from _ geosite ( configuration config ) { string gfw _ list _ url = geosite _ url ; if ( ! string . is _ null _ or _ white _ space ( config . gfw _ list _ url ) ) {
error = null ; } public static void update _ pac _ from _ geosite ( configuration config ) { string gfw _ list _ url = geosite _ url ; if ( ! string . is _ null _ or _ white _ space ( config . gfw _ list _ url ) ) { logger . info ( STR ) ; gfw _ list _ url = config . gfw _ list _ url ; }
? $ STR : ip _ address . loopback . to _ string ( ) , config . local _ port ) ; } http . download _ data _ completed + = ( o , e ) = > { try { file . write _ all _ bytes ( database _ path , e . result ) ; load _ geosite _ list ( ) ;
file . write _ all _ bytes ( database _ path , e . result ) ; load _ geosite _ list ( ) ; bool pac _ file _ changed = merge _ and _ write _ pac _ file ( ) ; update _ completed ? . invoke ( null , new geosite _ result _ event _ args ( pac _ file _ changed ) ) ; } catch ( exception ex ) { error ? . invoke ( null , new error _ event _ args ( ex ) ) ; } } ;
bool pac _ file _ changed = merge _ and _ write _ pac _ file ( ) ; update _ completed ? . invoke ( null , new geosite _ result _ event _ args ( pac _ file _ changed ) ) ; } catch ( exception ex ) { error ? . invoke ( null , new error _ event _ args ( ex ) ) ; } } ; http . download _ data _ async ( new uri ( gfw _ list _ url ) ) ; }
} catch ( exception ex ) { error ? . invoke ( null , new error _ event _ args ( ex ) ) ; } } ; http . download _ data _ async ( new uri ( gfw _ list _ url ) ) ; } public static bool merge _ and _ write _ pac _ file ( ) {
abp _ content = file _ manager . non _ exclusive _ read _ all _ text ( pac _ daemon . user _ abp _ file , encoding . ut ) ; } else { abp _ content = resources . abp _ js ; } list < string > userrule _ lines = new list < string > ( ) ; if ( file . exists ( pac _ daemon . user _ rule _ file ) ) { string userrules _ string = file _ manager . non _ exclusive _ read _ all _ text ( pac _ daemon . user _ rule _ file , encoding . ut ) ;
else { abp _ content = resources . abp _ js ; } list < string > userrule _ lines = new list < string > ( ) ; if ( file . exists ( pac _ daemon . user _ rule _ file ) ) { string userrules _ string = file _ manager . non _ exclusive _ read _ all _ text ( pac _ daemon . user _ rule _ file , encoding . ut ) ; userrule _ lines = parse _ to _ valid _ list ( userrules _ string ) ; }
userrule _ lines = parse _ to _ valid _ list ( userrules _ string ) ; } list < string > gfw _ lines = parse _ to _ valid _ list ( domains ) ; abp _ content = $ @ STR var rules = { json _ convert . serialize _ object ( gfw _ lines , formatting . indented ) } ; { abp _ content } STR return abp _ content ; } private static readonly i _ enumerable < char > ignored _ line _ begins = new [ ] { '!' , '[' } ;
{ foreach ( var line in sr . non _ white _ space _ lines ( ) ) { if ( line . begin _ with _ any ( ignored _ line _ begins ) ) continue ; valid _ lines . add ( line ) ; } } return valid _ lines ; }
{ if ( line . begin _ with _ any ( ignored _ line _ begins ) ) continue ; valid _ lines . add ( line ) ; } } return valid _ lines ; } private static list < string > parse _ to _ valid _ list ( i _ list < domain _ object > domains ) {
list < string > ret = new list < string > ( domains . count + NUM ) { STR } ; foreach ( var d in domains ) { string domain = d . value ; switch ( d . type ) { case domain _ object . types . type . plain :
{ private static logger logger = log _ manager . get _ current _ class _ logger ( ) ; public const string pac _ file = STR ; public const string user _ rule _ file = STR ; public const string user _ abp _ file = STR ; file _ system _ watcher pac _ file _ watcher ; file _ system _ watcher user _ rule _ file _ watcher ; public event event _ handler pac _ file _ changed ; public event event _ handler user _ rule _ file _ changed ;
touch _ pac _ file ( ) ; touch _ user _ rule _ file ( ) ; this . watch _ pac _ file ( ) ; this . watch _ user _ rule _ file ( ) ; } public string touch _ pac _ file ( ) { if ( ! file . exists ( pac _ file ) ) {

public static registry _ key open _ user _ reg _ key ( string name , bool writable ) { if ( name . is _ null _ or _ empty ( ) ) throw new argument _ exception ( nameof ( name ) ) ; try {
config . auto _ check _ update = enabled ; configuration . save ( config ) ; } public void save _ log _ viewer _ config ( log _ viewer _ config new _ config ) { config . log _ viewer = new _ config ; configuration . save ( config ) ; } public void update _ inbound _ counter ( long n ) {
{ config . log _ viewer = new _ config ; configuration . save ( config ) ; } public void update _ inbound _ counter ( long n ) { inbound _ counter + = n ; } public void update _ outbound _ counter ( long n ) {
public class error _ event _ args : event _ args { public string error ; } public event event _ handler config _ changed ; public event event _ handler enable _ status _ changed ; public event event _ handler < error _ event _ args > local _ fail _ to _ start ; public event event _ handler < path _ event _ args > pac _ file _ ready _ to _ open ; public shadowsocks _ controller ( ) {
public string error ; } public event event _ handler config _ changed ; public event event _ handler enable _ status _ changed ; public event event _ handler < error _ event _ args > local _ fail _ to _ start ; public event event _ handler < path _ event _ args > pac _ file _ ready _ to _ open ; public shadowsocks _ controller ( ) { config = config . load ( ) ; polipo _ runner = new polipo _ runner ( ) ;
pac _ server = new pac _ server ( ) ; pac _ server . pac _ file _ changed + = pac _ server _ pac _ file _ changed ; pac _ server . start ( ) ; } catch ( exception e ) { console . write _ line ( e . message ) ; } update _ system _ proxy ( ) ; }
pac _ server . start ( ) ; } catch ( exception e ) { console . write _ line ( e . message ) ; } update _ system _ proxy ( ) ; } public void save _ config ( config new _ config ) {
console . write _ line ( e . message ) ; } update _ system _ proxy ( ) ; } public void save _ config ( config new _ config ) { config . save ( new _ config ) ; config = new _ config ; local . stop ( ) ; polipo _ runner . stop ( ) ;
local . stop ( ) ; polipo _ runner . stop ( ) ; polipo _ runner . start ( config ) ; local = new local ( config ) ; local . start ( ) ; if ( config _ changed ! = null ) { config _ changed ( this , new event _ args ( ) ) ; } }
string argument = STR + e . path ; system . diagnostics . process . start ( STR , argument ) ; } private void show _ window ( ) { this . opacity = 1 ; this . show ( ) ; } private void update _ ui ( ) {
config config = controller . get _ config ( ) ; text _ box . text = config . server ; text _ box . text = config . server _ port . to _ string ( ) ; text _ box . text = config . password ; text _ box . text = config . local _ port . to _ string ( ) ; combo _ box . text = config . method = = null ? STR : config . method ; enable _ item . checked = config . enabled ; } private void form _ load ( object sender , event _ args e ) {
show _ window ( ) ; } private void quit _ click ( object sender , event _ args e ) { this . close ( ) ; } private void ok _ button _ click ( object sender , event _ args e ) { try {
private void ok _ button _ click ( object sender , event _ args e ) { try { config config = new config { server = text _ box . text , server _ port = int . parse ( text _ box . text ) , password = text _ box . text , local _ port = int . parse ( text _ box . text ) ,
} if ( request _ line _ count = = 0 ) { var m = http _ request _ header _ regex . match ( line ) ; if ( m . success ) { var method = m . groups [ 1 ] . value ; if ( method = = STR ) { is _ connect = true ;
var m = http _ request _ header _ regex . match ( line ) ; if ( m . success ) { var method = m . groups [ 1 ] . value ; if ( method = = STR ) { is _ connect = true ; if ( ! parse _ host ( m . groups [ 2 ] . value ) ) {
else { if ( line . is _ null _ or _ empty ( ) ) { return true ; } if ( ! is _ connect ) { if ( line . starts _ with ( STR ) ) {
{ return true ; } if ( ! is _ connect ) { if ( line . starts _ with ( STR ) ) { if ( ! parse _ host ( line . substring ( NUM ) . trim ( ) ) ) {
} private void handshake _ receive _ callback ( i _ async _ result ar ) { if ( closed ) return ; try { int bytes _ read = connection . end _ receive ( ar ) ; if ( bytes _ read > = NUM ) { command = connetion _ recv _ buffer [ 1 ] ;
if ( bytes _ read > = NUM ) { command = connetion _ recv _ buffer [ 1 ] ; logging . debug ( STR + command ) ; close ( ) ; } else { if ( command = = cmd _ connect ) { byte [ ] response = { NUM , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 } ; connection . begin _ send ( response , 0 , response . length , socket _ flags . none , response _ callback , null ) ;
else { if ( command = = cmd _ connect ) { byte [ ] response = { NUM , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 } ; connection . begin _ send ( response , 0 , response . length , socket _ flags . none , response _ callback , null ) ; } else if ( command = = cmd _ udp _ assoc ) { read _ address ( handle _ udp _ associate ) ;
using system ;
using system ; using system _ collections _ generic ; using system _ diagnostics ; using system _ io ; using system _ i _ compression ;
using system ; using system _ collections _ generic ; using system _ diagnostics ; using system _ io ; using system _ i _ compression ; using system _ linq ; using system _ runtime _ interop _ services ;

catch ( unauthorized _ access _ exception uae ) { logging . log _ useful _ exception ( uae ) ; return null ; }

using system ; using system _ collections _ generic ; using system _ linq ; using system _ runtime _ interop _ services ; using system _ text ; using system _ threading _ tasks ; namespace shadowsocks _ util _ system _ proxy {

using shadowsocks _ model ; using shadowsocks _ properties ; using shadowsocks _ util ; using system ; using system _ collections ;
using shadowsocks _ model ; using shadowsocks _ properties ; using shadowsocks _ util ; using system ; using system _ collections ; using system _ collections _ generic ; using system _ diagnostics ; using system _ io ;
using system _ net ; using system _ net _ sockets ; using system _ text ; namespace shadowsocks _ controller { class pac _ server : listener . service {
{ this . success = success ; } } private void http _ download _ string _ completed ( object sender , download _ string _ completed _ event _ args e ) { try { file . write _ all _ text ( utils . get _ temp _ path ( STR ) , e . result , encoding . ut ) ; list < string > lines = parse _ result ( e . result ) ;
} } private void http _ download _ string _ completed ( object sender , download _ string _ completed _ event _ args e ) { try { file . write _ all _ text ( utils . get _ temp _ path ( STR ) , e . result , encoding . ut ) ; list < string > lines = parse _ result ( e . result ) ; if ( file . exists ( user _ rule _ file ) ) {
string local = file . read _ all _ text ( user _ rule _ file , encoding . ut ) ; string [ ] rules = local . split ( new char [ ] { '\r' , '\n' } , string _ split _ options . remove _ empty _ entries ) ; foreach ( string rule in rules ) { if ( rule . starts _ with ( STR ) | | rule . starts _ with ( STR ) ) continue ; lines . add ( rule ) ; } } string abp _ content ;
foreach ( string rule in rules ) { if ( rule . starts _ with ( STR ) | | rule . starts _ with ( STR ) ) continue ; lines . add ( rule ) ; } } string abp _ content ; if ( file . exists ( user _ abp _ file ) ) {
{ abp _ content = file . read _ all _ text ( user _ abp _ file , encoding . ut ) ; } else { abp _ content = utils . un _ gzip ( resources . abp _ js ) ; } abp _ content = abp _ content . replace ( STR , json _ convert . serialize _ object ( lines , formatting . indented ) ) ; if ( file . exists ( pac _ server . pac _ file ) ) {
abp _ content = abp _ content . replace ( STR , json _ convert . serialize _ object ( lines , formatting . indented ) ) ; if ( file . exists ( pac _ server . pac _ file ) ) { string original = file . read _ all _ text ( pac _ file , encoding . ut ) ; if ( original = = abp _ content ) { update _ completed ( this , new result _ event _ args ( false ) ) ; return ; } }
return ret ; } private static async task < list < data _ list > > icmp _ test ( server server ) { logging . debug ( STR + server . friendly _ name ( ) ) ; if ( server . server = = STR ) return null ; var ping = new ping ( ) ; var ret = new list < data _ list > ( ) ; foreach ( var timestamp in enumerable . range ( 0 , repeat ) . select ( = > date _ time . now . to _ string ( STR ) ) ) {
private static async task < list < data _ list > > icmp _ test ( server server ) { logging . debug ( STR + server . friendly _ name ( ) ) ; if ( server . server = = STR ) return null ; var ping = new ping ( ) ; var ret = new list < data _ list > ( ) ; foreach ( var timestamp in enumerable . range ( 0 , repeat ) . select ( = > date _ time . now . to _ string ( STR ) ) ) { var reply = await ping . send _ task _ async ( server . server , timeout ) ; ret . add ( new list < key _ value _ pair < string , string > > {
} catch ( system . exception e ) { logging . log _ useful _ exception ( e ) ; } load _ library ( dll _ path ) ; } public static byte [ ] m ( byte [ ] input ) { byte [ ] output = new byte [ NUM ] ;
public static byte [ ] m ( byte [ ] input ) { byte [ ] output = new byte [ NUM ] ; md ( input , ( uint ) input . length , output ) ; return output ; } dll _ import _ kernel _ dll private static extern int _ ptr load _ library ( string path ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl
using system ; using system _ collections _ generic ; using system _ text ; using system _ net _ sockets ; using system _ net ; using shadowsocks _ encryption ; using shadowsocks _ model ; namespace shadowsocks _ controller {
using system _ text ; using system _ net _ sockets ; using system _ net ; using shadowsocks _ encryption ; using shadowsocks _ model ; namespace shadowsocks _ controller { class local { private configuration config ;
namespace shadowsocks _ controller { class local { private configuration config ; private bool share _ over _ lan ; socket listener ; public local ( configuration config ) { this . config = config ;
} } private void handshake _ receive ( ) { if ( closed ) { return ; } try {
if ( closed ) { return ; } try { if ( closed ) { return ; } try { int bytes _ read = connection . end _ receive ( ar ) ; if ( bytes _ read > 1 ) { byte [ ] response = { NUM , 0 } ;
pac _ server = new pac _ server ( ) ; pac _ server . pac _ file _ changed + = pac _ server _ pac _ file _ changed ; } if ( gfw _ list _ updater = = null ) { gfw _ list _ updater = new gfw _ list _ updater ( ) ; gfw _ list _ updater . update _ completed + = pac _ server _ pac _ update _ completed ; gfw _ list _ updater . error + = pac _ server _ pac _ update _ error ; } pac _ server . stop ( ) ;
} pac _ server . stop ( ) ; if ( local ! = null ) { local . stop ( ) ; } polipo _ runner . stop ( ) ; try { polipo _ runner . start ( config ) ;

} catch ( exception e ) { logging . log _ useful _ exception ( e ) ; return false ; } } public static async task < data _ list > get _ geolocation _ and _ isp ( ) { logging . debug ( STR ) ;
string json _ string ; try { json _ string = await new http _ client ( ) . get _ string _ async ( api ) ; } catch ( http _ request _ exception e ) { logging . log _ useful _ exception ( e ) ;
try { json _ string = await new http _ client ( ) . get _ string _ async ( api ) ; } catch ( http _ request _ exception e ) { logging . log _ useful _ exception ( e ) ; return ret ; } dynamic obj ;
catch ( http _ request _ exception e ) { logging . log _ useful _ exception ( e ) ; return ret ; } dynamic obj ; if ( ! simple _ json . simple _ json . try _ deserialize _ object ( json _ string , out obj ) ) return ret ; string country = obj [ STR ] ; string city = obj [ STR ] ; string isp = obj [ STR ] ;
private void ok _ button _ click ( object sender , event _ args e ) { foreach ( calculation _ control calculation in calculation _ container . controls ) { configuration . calculations [ calculation . value ] = calculation . factor ; } controller ? . save _ strategy _ configurations ( configuration ) ; controller ? . update _ statistics _ configuration ( statistics _ enabled _ check _ box . checked ) ; close ( ) ; }
controller ? . save _ strategy _ configurations ( configuration ) ; controller ? . update _ statistics _ configuration ( statistics _ enabled _ check _ box . checked ) ; close ( ) ; } private void load _ chart _ data ( string server _ name ) { data _ table . rows . clear ( ) ; list < availability _ statistics . raw _ statistics _ data > statistics ; if ( ! controller . availability _ statistics . filtered _ statistics . try _ get _ value ( server _ name , out statistics ) ) return ;
} private void load _ chart _ data ( string server _ name ) { data _ table . rows . clear ( ) ; list < availability _ statistics . raw _ statistics _ data > statistics ; if ( ! controller . availability _ statistics . filtered _ statistics . try _ get _ value ( server _ name , out statistics ) ) return ; foreach ( var data in statistics ) {
} private void server _ selector _ selected _ index _ changed ( object sender , event _ args e ) {
this . by _ hour _ of _ day _ check _ box = new system . windows . forms . check _ box ( ) ; this . repeat _ times _ num = new system . windows . forms . numeric _ up _ down ( ) ; this . label = new system . windows . forms . label ( ) ; this . split _ container = new system . windows . forms . split _ container ( ) ; this . label = new system . windows . forms . label ( ) ; this . calculation _ container = new system . windows . forms . flow _ layout _ panel ( ) ; this . cancel _ button = new system . windows . forms . button ( ) ; this . ok _ button = new system . windows . forms . button ( ) ; this . binding _ configuration = new system . windows . forms . binding _ source ( this . components ) ;
this . label = new system . windows . forms . label ( ) ; this . split _ container = new system . windows . forms . split _ container ( ) ; this . label = new system . windows . forms . label ( ) ; this . calculation _ container = new system . windows . forms . flow _ layout _ panel ( ) ; this . cancel _ button = new system . windows . forms . button ( ) ; this . ok _ button = new system . windows . forms . button ( ) ; this . binding _ configuration = new system . windows . forms . binding _ source ( this . components ) ; this . server _ selector = new system . windows . forms . combo _ box ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . statistics _ chart ) ) . begin _ init ( ) ;
this . cancel _ button . click + = new system . event _ handler ( this . cancel _ button _ click ) ; this . ok _ button . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . bottom | system . windows . forms . anchor _ styles . right ) ) ) ; this . ok _ button . location = new system . drawing . point ( NUM , NUM ) ; this . ok _ button . name = STR ; this . ok _ button . size = new system . drawing . size ( NUM , NUM ) ; this . ok _ button . tab _ index = NUM ; this . ok _ button . text = STR ; this . ok _ button . use _ visual _ style _ back _ color = true ; this . ok _ button . click + = new system . event _ handler ( this . ok _ button _ click ) ; this . binding _ configuration . data _ source = typeof ( shadowsocks . model . statistics _ strategy _ configuration ) ;
this . server _ selector . selected _ index _ changed + = new system . event _ handler ( this . server _ selector _ selected _ index _ changed ) ; this . auto _ scale _ mode = system . windows . forms . auto _ scale _ mode . font ; this . auto _ size = true ; this . client _ size = new system . drawing . size ( NUM , NUM ) ; this . controls . add ( this . split _ container ) ; this . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . minimum _ size = new system . drawing . size ( NUM , NUM ) ; this . name = STR ; this . text = STR ; ( ( system . component _ model . i _ support _ initialize ) ( this . statistics _ chart ) ) . end _ init ( ) ;
create _ menu _ item ( STR , new event _ handler ( this . qr _ code _ item _ click ) ) ,
} else { registry . set _ value ( STR , 0 ) ; registry . set _ value ( STR , STR ) ;
{ show _ balloon _ tip ( n . get _ string ( STR ) , n . get _ string ( STR ) , tool _ tip _ icon . info , NUM ) ; } is _ startup _ checking = false ; } void notify _ icon _ balloon _ tip _ clicked ( object sender , event _ args e ) { if ( update _ checker . new _ version _ found ) { update _ checker . new _ version _ found = false ;
is _ startup _ checking = false ; } void notify _ icon _ balloon _ tip _ clicked ( object sender , event _ args e ) { if ( update _ checker . new _ version _ found ) { update _ checker . new _ version _ found = false ; if ( system . io . file . exists ( update _ checker . latest _ version _ local _ name ) ) { string argument = STR + update _ checker . latest _ version _ local _ name + STR ;
using system ; using system _ collections _ generic ; using system _ io ; using system _ linq ; using system _ net _ network _ information ; using system _ threading ; using shadowsocks _ model ;
using system _ io ; using system _ linq ; using system _ net _ network _ information ; using system _ threading ; using shadowsocks _ model ; using system _ reflection ; namespace shadowsocks _ controller { class availability _ statistics {
private static readonly string delimiter = STR ; private static readonly int timeout = NUM ; private static readonly int repeat = NUM ; private static readonly int interval = NUM * NUM * NUM ; private timer timer = null ; private state state = null ; private list < server > servers ; public static string availability _ statistics _ file ; static availability _ statistics ( ) {
{ string temppath = path . get _ temp _ path ( ) ; availability _ statistics _ file = path . combine ( temppath , statistics _ files _ name ) ; } public bool set ( bool enabled ) { try { if ( enabled ) {
return true ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; return false ; } } private void evaluate ( object obj ) {
} private void evaluate ( object obj ) { ping ping = new ping ( ) ; state state = ( state ) obj ; foreach ( var server in servers ) { logging . debug ( STR + server . friendly _ name ( ) ) ; foreach ( var in enumerable . range ( 0 , repeat ) ) {
private void evaluate ( object obj ) { ping ping = new ping ( ) ; state state = ( state ) obj ; foreach ( var server in servers ) { logging . debug ( STR + server . friendly _ name ( ) ) ; foreach ( var in enumerable . range ( 0 , repeat ) ) { string timestamp = date _ time . now . to _ string ( STR ) ;
state . data . add ( new key _ value _ pair < string , string > ( STR , timestamp ) ) ; state . data . add ( new key _ value _ pair < string , string > ( STR , server . friendly _ name ( ) ) ) ; state . data . add ( new key _ value _ pair < string , string > ( STR , reply . status . to _ string ( ) ) ) ; state . data . add ( new key _ value _ pair < string , string > ( STR , reply . roundtrip _ time . to _ string ( ) ) ) ; append ( state . data ) ; } } } private static void append ( list < key _ value _ pair < string , string > > data ) {
append ( state . data ) ; } } } private static void append ( list < key _ value _ pair < string , string > > data ) { string data _ line = string . join ( delimiter , data . select ( kv = > kv . value ) . to _ array ( ) ) ; string [ ] lines ; if ( ! file . exists ( availability _ statistics _ file ) ) {
{ string data _ line = string . join ( delimiter , data . select ( kv = > kv . value ) . to _ array ( ) ) ; string [ ] lines ; if ( ! file . exists ( availability _ statistics _ file ) ) { string header _ line = string . join ( delimiter , data . select ( kv = > kv . key ) . to _ array ( ) ) ; lines = new string [ ] { header _ line , data _ line } ; } else {

using shadowsocks _ controller _ strategy ; using shadowsocks _ encryption ; using shadowsocks _ encryption _ aead ; using shadowsocks _ encryption _ exception ; using shadowsocks _ model ; using shadowsocks _ proxy ; using shadowsocks _ util _ sockets ; using static shadowsocks . encryption . encryptor _ base ; namespace shadowsocks _ controller {
using shadowsocks _ util _ sockets ; using static shadowsocks . encryption . encryptor _ base ; namespace shadowsocks _ controller { class tcp _ relay : listener . service { public event event _ handler < sstcp _ connected _ event _ args > on _ connected ; public event event _ handler < ss _ transmit _ event _ args > on _ inbound ; public event event _ handler < ss _ transmit _ event _ args > on _ outbound ; public event event _ handler < ss _ relay _ event _ args > on _ failed ;
{ class tcp _ relay : listener . service { public event event _ handler < sstcp _ connected _ event _ args > on _ connected ; public event event _ handler < ss _ transmit _ event _ args > on _ inbound ; public event event _ handler < ss _ transmit _ event _ args > on _ outbound ; public event event _ handler < ss _ relay _ event _ args > on _ failed ; private static logger logger = log _ manager . get _ current _ class _ logger ( ) ; private shadowsocks _ controller controller ; private date _ time last _ sweep _ time ;
this . latency = latency ; } } internal class tcp _ handler { public event event _ handler < sstcp _ connected _ event _ args > on _ connected ; public event event _ handler < ss _ transmit _ event _ args > on _ inbound ; public event event _ handler < ss _ transmit _ event _ args > on _ outbound ; public event event _ handler < ss _ relay _ event _ args > on _ closed ; public event event _ handler < ss _ relay _ event _ args > on _ failed ;
public event event _ handler < ss _ relay _ event _ args > on _ closed ; public event event _ handler < ss _ relay _ event _ args > on _ failed ; class async _ session { public i _ proxy remote { get ; } public async _ session ( i _ proxy remote ) { remote = remote ; } }
public t state { get ; set ; } public async _ session ( i _ proxy remote , t state ) : base ( remote ) { state = state ; } public async _ session ( async _ session session , t state ) : base ( session . remote ) { state = state ; } }
} } private static logger logger = log _ manager . get _ current _ class _ logger ( ) ; private readonly int server _ timeout ; private readonly int proxy _ timeout ; public const int recv _ size = NUM ; public const int chunk _ overhead _ size = NUM * 2 public const uint max _ chunk _ size = aead _ encryptor . chunk _ len _ mask + aead _ encryptor . chunk _ len _ bytes + NUM * 2 ; public const int buffer _ size = recv _ size + ( int ) max _ chunk _ size + NUM public date _ time last _ activity ;
private bool dest _ connected ; private byte command ; private byte [ ] first _ packet ; private int first _ packet _ length ; private const int cmd _ connect = 0 ; private const int cmd _ bind = 0 ; private const int cmd _ udp _ assoc = 0 ; private int addr _ buf _ length = - 1 ; private int total _ read = 0 ; private int total _ write = 0 ;
private byte command ; private byte [ ] first _ packet ; private int first _ packet _ length ; private const int cmd _ connect = 0 ; private const int cmd _ bind = 0 ; private const int cmd _ udp _ assoc = 0 ; private int addr _ buf _ length = - 1 ; private int total _ read = 0 ; private int total _ write = 0 ; private byte [ ] remote _ recv _ buffer = new byte [ buffer _ size ] ;
private byte [ ] first _ packet ; private int first _ packet _ length ; private const int cmd _ connect = 0 ; private const int cmd _ bind = 0 ; private const int cmd _ udp _ assoc = 0 ; private int addr _ buf _ length = - 1 ; private int total _ read = 0 ; private int total _ write = 0 ; private byte [ ] remote _ recv _ buffer = new byte [ buffer _ size ] ; private byte [ ] connetion _ recv _ buffer = new byte [ buffer _ size ] ;
private int first _ packet _ length ; private const int cmd _ connect = 0 ; private const int cmd _ bind = 0 ; private const int cmd _ udp _ assoc = 0 ; private int addr _ buf _ length = - 1 ; private int total _ read = 0 ; private int total _ write = 0 ; private byte [ ] remote _ recv _ buffer = new byte [ buffer _ size ] ; private byte [ ] connetion _ recv _ buffer = new byte [ buffer _ size ] ; private byte [ ] remote _ send _ buffer = new byte [ buffer _ size ] ;
} public void create _ remote ( ) { server server = controller . get _ a _ server ( i _ strategy _ caller _ type . tcp , ( ip _ end _ point ) connection . remote _ end _ point , dest _ end _ point ) ; if ( server = = null | | server . server = = STR ) throw new argument _ exception ( STR ) ; encryptor = encryptor _ factory . get _ encryptor ( server . method , server . password ) ;
} public void close ( ) { lock ( close _ conn _ lock ) {
{ response = new byte [ ] { 0 , NUM } ; logger . error ( STR ) ; } connection . begin _ send ( response , 0 , response . length , socket _ flags . none , handshake _ send _ callback , null ) ; } else close ( ) ;
close ( ) ; } catch ( exception e ) { logger . log _ useful _ exception ( e ) ; close ( ) ; } } private void handshake _ send _ callback ( i _ async _ result ar ) {
} } private void handshake _ send _ callback ( i _ async _ result ar ) { if ( closed ) return ; try { connection . end _ send ( ar ) ; connection . begin _ receive ( connetion _ recv _ buffer , 0 , NUM + addr _ atyp _ len + 1 , socket _ flags . none ,
} else { logger . debug ( STR ) ; close ( ) ; } } catch ( exception e ) {
} private void response _ callback ( i _ async _ result ar ) { try { connection . end _ send ( ar ) ; read _ address ( start _ connect ) ; } catch ( exception e ) {
} } private void read _ address ( int bytes _ remain , action on _ success ) { array . copy ( connetion _ recv _ buffer , NUM , connetion _ recv _ buffer , 0 , addr _ atyp _ len + 1 ) ; connection . begin _ receive ( connetion _ recv _ buffer , 2 , recv _ size - 2 , socket _ flags . none , on _ address _ fully _ read , new object [ ] { bytes _ remain , on _ success } ) ; } private void on _ address _ fully _ read ( i _ async _ result ar ) {
connection . begin _ receive ( connetion _ recv _ buffer , 2 , recv _ size - 2 , socket _ flags . none , on _ address _ fully _ read , new object [ ] { bytes _ remain , on _ success } ) ; } private void on _ address _ fully _ read ( i _ async _ result ar ) { if ( closed ) return ; try { int bytes _ read = connection . end _ receive ( ar ) ;
} private void on _ address _ fully _ read ( i _ async _ result ar ) { if ( closed ) return ; try { int bytes _ read = connection . end _ receive ( ar ) ; var states = ( object [ ] ) ar . async _ state ; int bytes _ remain = ( int ) states [ 0 ] ;
{ int bytes _ read = connection . end _ receive ( ar ) ; if ( bytes _ read > 0 ) { connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , socket _ flags . none , read _ all , null ) ; } else close ( ) ;
proxy _ timer . enabled = true ; proxy _ timer . session = session ; proxy _ timer . dest _ end _ point = server _ ep ; proxy _ timer . server = server ; proxy _ connected = false ; remote . begin _ connect _ proxy ( proxy _ ep , proxy _ connect _ callback , new async _ session < proxy _ timer > ( remote , proxy _ timer ) ) ; } catch ( exception e ) {
remote . begin _ connect _ proxy ( proxy _ ep , proxy _ connect _ callback , new async _ session < proxy _ timer > ( remote , proxy _ timer ) ) ; } catch ( exception e ) { logger . log _ useful _ exception ( e ) ; close ( ) ; } } private void proxy _ connect _ timer _ elapsed ( object sender , elapsed _ event _ args e ) {
private void proxy _ connect _ timer _ elapsed ( object sender , elapsed _ event _ args e ) { var timer = ( proxy _ timer ) sender ; timer . elapsed - = proxy _ connect _ timer _ elapsed ; timer . enabled = false ; timer . dispose ( ) ; if ( proxy _ connected | | dest _ connected | | closed ) { return ; }
close ( ) ; } private void proxy _ connect _ callback ( i _ async _ result ar ) { if ( closed ) { return ; } try {
private void proxy _ connect _ callback ( i _ async _ result ar ) { if ( closed ) { return ; } try { var session = ( async _ session < proxy _ timer > ) ar . async _ state ; proxy _ timer timer = session . state ;
} try { var session = ( async _ session < proxy _ timer > ) ar . async _ state ; proxy _ timer timer = session . state ; var dest _ end _ point = timer . dest _ end _ point ; var server = timer . server ; timer . elapsed - = proxy _ connect _ timer _ elapsed ; timer . enabled = false ; timer . dispose ( ) ;
auth = new network _ credential ( config . auth _ user , config . auth _ pwd ) ; } remote . begin _ connect _ dest ( dest _ end _ point , connect _ callback , new async _ session < server _ timer > ( session , connect _ timer ) , auth ) ; } catch ( argument _ exception ) { } catch ( exception e ) {
catch ( argument _ exception ) { } catch ( exception e ) { logger . log _ useful _ exception ( e ) ; close ( ) ; } } private void dest _ connect _ timer _ elapsed ( object sender , elapsed _ event _ args e ) {
private void dest _ connect _ timer _ elapsed ( object sender , elapsed _ event _ args e ) { var timer = ( server _ timer ) sender ; timer . elapsed - = dest _ connect _ timer _ elapsed ; timer . enabled = false ; timer . dispose ( ) ; if ( dest _ connected | | closed ) { return ; }
} var session = timer . session ; server server = timer . server ; on _ failed ? . invoke ( this , new ss _ relay _ event _ args ( server ) ) ; logger . info ( $ STR ) ; session . remote . close ( ) ; close ( ) ; } private void connect _ callback ( i _ async _ result ar ) {
if ( closed ) return ; try { var session = ( async _ session < server _ timer > ) ar . async _ state ; server _ timer timer = session . state ; server = timer . server ; timer . elapsed - = dest _ connect _ timer _ elapsed ; timer . enabled = false ; timer . dispose ( ) ;
var session = ( async _ session < server _ timer > ) ar . async _ state ; server _ timer timer = session . state ; server = timer . server ; timer . elapsed - = dest _ connect _ timer _ elapsed ; timer . enabled = false ; timer . dispose ( ) ; var remote = session . remote ; remote . end _ connect _ dest ( ar ) ; dest _ connected = true ; logger . debug ( $ STR ) ;
} catch ( argument _ exception ) { } catch ( exception e ) { if ( server ! = null ) { on _ failed ? . invoke ( this , new ss _ relay _ event _ args ( server ) ) ; }
on _ failed ? . invoke ( this , new ss _ relay _ event _ args ( server ) ) ; } logger . log _ useful _ exception ( e ) ; close ( ) ; } } private void try _ read _ available _ data ( ) { int available = math . min ( connection . available , recv _ size - first _ packet _ length ) ; if ( available > 0 ) {
int available = math . min ( connection . available , recv _ size - first _ packet _ length ) ; if ( available > 0 ) { var size = connection . receive ( connetion _ recv _ buffer , first _ packet _ length , available , socket _ flags . none ) ; first _ packet _ length + = size ; } } private void start _ pipe ( async _ session session ) {
{ start _ receiving _ time = date _ time . now ; session . remote . begin _ receive ( remote _ recv _ buffer , 0 , recv _ size , socket _ flags . none , pipe _ remote _ receive _ callback , session ) ; try _ read _ available _ data ( ) ; logger . trace ( $ STR ) ; send _ to _ server ( first _ packet _ length , session ) ; } catch ( exception e ) {
logger . trace ( $ STR ) ; send _ to _ server ( first _ packet _ length , session ) ; } catch ( exception e ) { logger . log _ useful _ exception ( e ) ; close ( ) ; } } private void pipe _ remote _ receive _ callback ( i _ async _ result ar ) {
} else { connection . shutdown ( socket _ shutdown . send ) ; connection _ shutdown = true ; check _ close ( ) ; } } catch ( exception e ) {
check _ close ( ) ; } } catch ( exception e ) { logger . log _ useful _ exception ( e ) ; close ( ) ; } } private void pipe _ connection _ receive _ callback ( i _ async _ result ar ) {
close ( ) ; } } private void pipe _ connection _ receive _ callback ( i _ async _ result ar ) { if ( closed ) return ; try { int bytes _ read = connection . end _ receive ( ar ) ;
buffer . block _ copy ( connetion _ send _ buffer , bytes _ sent , connetion _ send _ buffer , 0 , bytes _ remaining ) ; session . remote . begin _ send ( connetion _ send _ buffer , 0 , bytes _ remaining , socket _ flags . none , pipe _ remote _ send _ callback , new object [ ] { session , bytes _ remaining } ) ; return ; } connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , socket _ flags . none , pipe _ connection _ receive _ callback , session ) ; } catch ( exception e ) {
} catch ( exception e ) { logger . log _ useful _ exception ( e ) ; close ( ) ; } } private void pipe _ connection _ send _ callback ( i _ async _ result ar ) { try {
private shadowsocks _ controller controller ; private update _ checker update _ checker ; private notify _ icon notify _ icon ; private context _ menu context _ menu ; private bool is _ first _ run ; private menu _ item enable _ item ; private menu _ item auto _ startup _ item ; private menu _ item share _ over _ lan _ item ; private menu _ item seperator _ item ; private menu _ item config _ item ;
private menu _ item auto _ startup _ item ; private menu _ item share _ over _ lan _ item ; private menu _ item seperator _ item ; private menu _ item config _ item ; private menu _ item menu _ item ; private menu _ item edit _ pac _ file _ item ; private menu _ item qr _ code _ item ; private menu _ item show _ log _ item ; private menu _ item about _ item ; private menu _ item servers _ item ;
private menu _ item seperator _ item ; private menu _ item config _ item ; private menu _ item menu _ item ; private menu _ item edit _ pac _ file _ item ; private menu _ item qr _ code _ item ; private menu _ item show _ log _ item ; private menu _ item about _ item ; private menu _ item servers _ item ; private menu _ item menu _ item ; private menu _ item quit _ item ;
private void load _ menu ( ) { this . context _ menu = new system . windows . forms . context _ menu ( ) ;
private void load _ menu ( ) { this . context _ menu = new system . windows . forms . context _ menu ( ) ; this . qr _ code _ item = new system . windows . forms . menu _ item ( ) ; this . show _ log _ item = new system . windows . forms . menu _ item ( ) ; this . about _ item = new system . windows . forms . menu _ item ( ) ; this . menu _ item = new system . windows . forms . menu _ item ( ) ; this . quit _ item = new system . windows . forms . menu _ item ( ) ; this . menu _ item = new system . windows . forms . menu _ item ( ) ; this . context _ menu . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . enable _ item , this . mode _ item , this . servers _ item ,
this . quit _ item = new system . windows . forms . menu _ item ( ) ; this . menu _ item = new system . windows . forms . menu _ item ( ) ; this . context _ menu . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . enable _ item , this . mode _ item , this . servers _ item , this . menu _ item , this . auto _ startup _ item , this . share _ over _ lan _ item , this . edit _ pac _ file _ item ,
this . mode _ item , this . servers _ item , this . menu _ item , this . auto _ startup _ item , this . share _ over _ lan _ item , this . edit _ pac _ file _ item , this . menu _ item , this . qr _ code _ item , this . show _ log _ item , this . about _ item ,
this . menu _ item , this . auto _ startup _ item , this . share _ over _ lan _ item , this . edit _ pac _ file _ item , this . menu _ item , this . qr _ code _ item , this . show _ log _ item , this . about _ item , this . menu _ item , this . quit _ item } ) ;
{ if ( socket . protocol _ type ! = protocol _ type . udp ) { return false ; } if ( length < NUM ) { return false ; } listener . udp _ state udp _ state = ( listener . udp _ state ) state ;
{ return false ; } listener . udp _ state udp _ state = ( listener . udp _ state ) state ; udp _ handler handler = new udp _ handler ( socket , config . get _ current _ server ( ) , ( ip _ end _ point ) udp _ state . remote _ end _ point ) ; handler . send ( first _ packet , length ) ; handler . receive ( ) ; return true ; }
ok _ button . text = n . get _ string ( STR ) ; my _ cancel _ button . text = n . get _ string ( STR ) ; this . text = n . get _ string ( STR ) ; } private void controller _ config _ changed ( object sender , event _ args e ) { load _ current _ configuration ( ) ; } private void load _ current _ configuration ( ) {
{ modified _ configuration = controller . get _ configuration _ copy ( ) . proxy ; use _ proxy _ check _ box . checked = modified _ configuration . use _ proxy ; proxy _ server _ text _ box . text = modified _ configuration . proxy _ server ; proxy _ port _ text _ box . text = modified _ configuration . proxy _ port . to _ string ( ) ; proxy _ timeout _ text _ box . text = modified _ configuration . proxy _ timeout . to _ string ( ) ; proxy _ type _ combo _ box . selected _ index = modified _ configuration . proxy _ type ; } private void ok _ button _ click ( object sender , event _ args e ) {
use _ proxy _ check _ box . checked = modified _ configuration . use _ proxy ; proxy _ server _ text _ box . text = modified _ configuration . proxy _ server ; proxy _ port _ text _ box . text = modified _ configuration . proxy _ port . to _ string ( ) ; proxy _ timeout _ text _ box . text = modified _ configuration . proxy _ timeout . to _ string ( ) ; proxy _ type _ combo _ box . selected _ index = modified _ configuration . proxy _ type ; } private void ok _ button _ click ( object sender , event _ args e ) { if ( use _ proxy _ check _ box . checked ) {
} private void ok _ button _ click ( object sender , event _ args e ) { if ( use _ proxy _ check _ box . checked ) { int port ; int timeout ; if ( ! int . try _ parse ( proxy _ port _ text _ box . text , out port ) ) { message _ box . show ( n . get _ string ( STR ) ) ; return ; }
if ( ! int . try _ parse ( proxy _ port _ text _ box . text , out port ) ) { message _ box . show ( n . get _ string ( STR ) ) ; return ; } if ( ! int . try _ parse ( proxy _ timeout _ text _ box . text , out timeout ) ) { message _ box . show ( n . get _ string ( STR ) ) ; return ; }
return ; } if ( ! int . try _ parse ( proxy _ timeout _ text _ box . text , out timeout ) ) { message _ box . show ( n . get _ string ( STR ) ) ; return ; } var type = proxy _ type _ combo _ box . selected _ index ; var proxy = proxy _ server _ text _ box . text ; try {
{ configuration . check _ server ( proxy ) ; configuration . check _ port ( port ) ; configuration . check _ timeout ( timeout , proxy _ config . max _ proxy _ timeout _ sec ) ; } catch ( exception ex ) { message _ box . show ( ex . message ) ; return ; }
configuration . check _ port ( port ) ; configuration . check _ timeout ( timeout , proxy _ config . max _ proxy _ timeout _ sec ) ; } catch ( exception ex ) { message _ box . show ( ex . message ) ; return ; } controller . enable _ proxy ( type , proxy , port , timeout ) ; }
controller . config _ changed - = controller _ config _ changed ; } private void use _ proxy _ check _ box _ checked _ changed ( object sender , event _ args e ) { update _ enabled ( ) ; } private void update _ enabled ( ) { if ( use _ proxy _ check _ box . checked ) {
{ if ( use _ proxy _ check _ box . checked ) { proxy _ server _ text _ box . enabled = true ; proxy _ port _ text _ box . enabled = true ; proxy _ timeout _ text _ box . enabled = true ; proxy _ type _ combo _ box . enabled = true ; } else {
unique _ config _ file = $ STR ; privoxy _ job = new job ( ) ; file _ manager . uncompress _ file ( utils . get _ temp _ path ( STR ) , resources . privoxy _ exe ) ; file _ manager . uncompress _ file ( utils . get _ temp _ path ( STR ) , resources . mgwz _ dll ) ; } catch ( io _ exception e ) { logging . log _ useful _ exception ( e ) ; } }
file _ manager . uncompress _ file ( utils . get _ temp _ path ( STR ) , resources . mgwz _ dll ) ; } catch ( io _ exception e ) { logging . log _ useful _ exception ( e ) ; } } public int running _ port { get { return running _ port ; } } public void start ( configuration configuration ) {
* / logging . log _ useful _ exception ( ex ) ; return false ; } } private int get _ free _ port ( ) { int default _ port = NUM ; try {
{ return port ; } } } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; return default _ port ; }
} private void http _ download _ string _ completed ( object sender , download _ string _ completed _ event _ args e ) { try { file . write _ all _ text ( utils . get _ temp _ path ( STR ) , e . result , encoding . ut ) ; list < string > lines = parse _ result ( e . result ) ; if ( file . exists ( pac _ server . user _ rule _ file ) ) { string local = file . read _ all _ text ( pac _ server . user _ rule _ file , encoding . ut ) ;
{ try { file . write _ all _ text ( utils . get _ temp _ path ( STR ) , e . result , encoding . ut ) ; list < string > lines = parse _ result ( e . result ) ; if ( file . exists ( pac _ server . user _ rule _ file ) ) { string local = file . read _ all _ text ( pac _ server . user _ rule _ file , encoding . ut ) ; string [ ] rules = local . split ( new char [ ] { '\r' , '\n' } , string _ split _ options . remove _ empty _ entries ) ; foreach ( string rule in rules ) {
{ web _ client http = new web _ client ( ) ; http . proxy = new web _ proxy ( ip _ address . loopback . to _ string ( ) , config . local _ port ) ; http . download _ string _ completed + = http _ download _ string _ completed ; http . download _ string _ async ( new uri ( gfwlist _ url ) ) ; } public static list < string > parse _ result ( string response ) { byte [ ] bytes = convert . from _ base _ string ( response ) ; string content = encoding . ascii . get _ string ( bytes ) ;
http . download _ string _ completed + = http _ download _ string _ completed ; http . download _ string _ async ( new uri ( gfwlist _ url ) ) ; } public static list < string > parse _ result ( string response ) { byte [ ] bytes = convert . from _ base _ string ( response ) ; string content = encoding . ascii . get _ string ( bytes ) ; string [ ] lines = content . split ( new char [ ] { '\r' , '\n' } , string _ split _ options . remove _ empty _ entries ) ; list < string > valid _ lines = new list < string > ( lines . length ) ; foreach ( string line in lines ) {

using shadowsocks _ view ; using system ; using system _ drawing ; using system _ windows _ forms ; namespace shadowsocks _ model { serializable public class log _ viewer _ config {
public bool top _ most ; public bool wrap _ text ; public bool toolbar _ shown ; public int width ; public int height ; public int top ; public int left ; public bool maximized ; public log _ viewer _ config ( ) {
public int height ; public int top ; public int left ; public bool maximized ; public log _ viewer _ config ( ) { font _ name = STR ; font _ size = NUM ; bg _ color = STR ; text _ color = STR ; top _ most = false ; wrap _ text = false ; toolbar _ shown = false ;

public int get _ best _ left ( ) {
public int get _ best _ left ( ) { public font get _ font ( ) { try { return new font ( font _ name , font _ size , font _ style . regular ) ; } catch ( exception ) { } }
{ return new font ( font _ name , font _ size , font _ style . regular ) ; } catch ( exception ) { } } public void set _ font ( font font ) {
} catch ( exception ) { } } public void set _ font ( font font ) { font _ name = font . name ; font _ size = font . size ; } public color get _ background _ color ( ) { try {
} public void set _ font ( font font ) { font _ size = font . size ; } public color get _ background _ color ( ) { try { return color _ translator . from _ html ( bg _ color ) ; } catch ( exception ) { return color _ translator . from _ html ( STR ) ; } }
{ if ( use _ proxy _ check _ box . checked ) { try { var proxy = proxy _ server _ text _ box . text ; var port = int . parse ( proxy _ port _ text _ box . text ) ; configuration . check _ server ( proxy ) ; configuration . check _ port ( port ) ;

this . table _ layout _ panel . suspend _ layout ( ) ; this . table _ layout _ panel . suspend _ layout ( ) ; this . table _ layout _ panel . suspend _ layout ( ) ; this . suspend _ layout ( ) ; this . table _ layout _ panel . auto _ size = true ; this . table _ layout _ panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . table _ layout _ panel . column _ count = 1 ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ;
this . table _ layout _ panel . suspend _ layout ( ) ; this . table _ layout _ panel . suspend _ layout ( ) ; this . suspend _ layout ( ) ; this . table _ layout _ panel . auto _ size = true ; this . table _ layout _ panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . table _ layout _ panel . column _ count = 1 ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . controls . add ( this . table _ layout _ panel , 0 , 2 ) ; this . table _ layout _ panel . controls . add ( this . use _ proxy _ check _ box , 0 , 0 ) ;
this . table _ layout _ panel . auto _ size = true ; this . table _ layout _ panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . table _ layout _ panel . column _ count = 1 ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . controls . add ( this . table _ layout _ panel , 0 , 2 ) ; this . table _ layout _ panel . controls . add ( this . use _ proxy _ check _ box , 0 , 0 ) ; this . table _ layout _ panel . controls . add ( this . table _ layout _ panel , 0 , 1 ) ; this . table _ layout _ panel . location = new system . drawing . point ( NUM , NUM ) ; this . table _ layout _ panel . name = STR ;
{ var state = ( ( fake _ async _ result ) async _ result ) . inner _ state ; if ( state . ex ! = null ) { throw state . ex ; } } public void begin _ send ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) {
{ remote ? . begin _ send ( buffer , offset , size , socket _ flags , callback , state ) ; } public int end _ send ( i _ async _ result async _ result ) { return remote . end _ send ( async _ result ) ; } public void begin _ receive ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) {
object state ) { remote ? . begin _ receive ( buffer , offset , size , socket _ flags , callback , state ) ; } public int end _ receive ( i _ async _ result async _ result ) { return remote . end _ receive ( async _ result ) ; } public void shutdown ( socket _ shutdown how ) {
public int end _ receive ( i _ async _ result async _ result ) { return remote . end _ receive ( async _ result ) ; } public void shutdown ( socket _ shutdown how ) { remote ? . shutdown ( how ) ; } public void close ( ) {
if ( share _ over _ lan _ status _ changed ! = null ) { share _ over _ lan _ status _ changed ( this , new event _ args ( ) ) ; } } public void disable _ proxy ( ) { config . proxy . use _ proxy = false ; save _ config ( config ) ; }
public enum log _ level { fatal , error , warn , info , debug , trace , } const string nlog _ config _ file _ name = STR ;
info , debug , trace , } const string nlog _ config _ file _ name = STR ; const string min _ level _ attribute = STR ; const string file _ name _ attribute = STR ; xml _ document doc = new xml _ document ( ) ; xml _ element log _ level _ element ;
string level _ str = log _ level _ element . get _ attribute ( min _ level _ attribute ) ; enum . try _ parse ( level _ str , out level ) ; return level ; } public string get _ log _ file _ name ( ) { return log _ file _ name _ element . get _ attribute ( file _ name _ attribute ) ; } public void set _ log _ level ( log _ level log _ level ) {

using shadowsocks _ controller ; using shadowsocks _ model ; using shadowsocks _ properties ; using system ; using system _ collections _ generic ; using system _ diagnostics ; using system _ drawing ;
this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ; this . text _ box = new system . windows . forms . text _ box ( ) ; this . text _ box = new system . windows . forms . text _ box ( ) ; this . text _ box = new system . windows . forms . text _ box ( ) ; this . text _ box = new system . windows . forms . text _ box ( ) ;
this . about _ tool _ strip _ menu _ item = new system . windows . forms . tool _ strip _ menu _ item ( ) ; this . tool _ strip _ separator = new system . windows . forms . tool _ strip _ separator ( ) ; this . quit _ item = new system . windows . forms . tool _ strip _ menu _ item ( ) ; this . table _ layout _ panel . suspend _ layout ( ) ; this . panel . suspend _ layout ( ) ;
this . icon = ( ( system . drawing . icon ) ( resources . get _ object ( STR ) ) ) ; this . name = STR ; this . start _ position = system . windows . forms . form _ start _ position . center _ screen ; this . text = STR ; this . form _ closed + = new system . windows . forms . form _ closed _ event _ handler ( this . form _ form _ closed ) ; this . load + = new system . event _ handler ( this . form _ load ) ; this . table _ layout _ panel . resume _ layout ( false ) ; this . table _ layout _ panel . perform _ layout ( ) ; this . panel . resume _ layout ( false ) ;
} private system . windows . forms . table _ layout _ panel table _ layout _ panel ; private system . windows . forms . label label ; private system . windows . forms . label label ; private system . windows . forms . label label ; private system . windows . forms . label label ; private system . windows . forms . text _ box text _ box ; private system . windows . forms . text _ box text _ box ; private system . windows . forms . text _ box text _ box ; private system . windows . forms . text _ box text _ box ;
leftptr + + ; } else if ( leftptr = = left . length | | ( ( rightptr < right . length ) & & ( compare ( right [ rightptr ] , left [ leftptr ] , a , j ) ) < = 0 ) ) { sorted [ k ] = right [ rightptr ] ; rightptr + + ; } } return sorted ; }
rightptr + + ; } } return sorted ; } public encryptor ( string password ) { m md = system . security . cryptography . m . create ( ) ; byte [ ] input _ bytes = system . text . encoding . ut . get _ bytes ( password ) ; byte [ ] hash = md . compute _ hash ( input _ bytes ) ;
{ encrypt _ table = merge _ sort ( encrypt _ table , a , i ) ; } for ( int i = 0 ; i < NUM ; i + + ) { decrypt _ table [ encrypt _ table [ i ] ] = ( byte ) i ; } } public void encrypt ( byte [ ] buf , int length ) {
} for ( int i = 0 ; i < NUM ; i + + ) { decrypt _ table [ encrypt _ table [ i ] ] = ( byte ) i ; } } public void encrypt ( byte [ ] buf , int length ) { for ( int i = 0 ; i < length ; i + + ) {
{ for ( int i = 0 ; i < length ; i + + ) { buf [ i ] = encrypt _ table [ buf [ i ] ] ; } } public void decrypt ( byte [ ] buf , int length ) {
{ buf [ i ] = encrypt _ table [ buf [ i ] ] ; } } public void decrypt ( byte [ ] buf , int length ) { for ( int i = 0 ; i < length ; i + + ) {
using system ; using system _ collections _ generic ;
using system ; using system _ collections _ generic ; using system _ text ; using system _ net _ sockets ;
using system ; using system _ collections _ generic ; using system _ text ; using system _ net _ sockets ; using system _ net ; using shadowsocks _ encryption ; using shadowsocks _ model ;
using system _ net ; using shadowsocks _ encryption ; using shadowsocks _ model ; using shadowsocks _ controller _ strategy ; using system _ timers ; namespace shadowsocks _ controller { class tcp _ relay : listener . service { private shadowsocks _ controller controller ; private date _ time last _ sweep _ time ;
class tcp _ relay : listener . service { private shadowsocks _ controller controller ; private date _ time last _ sweep _ time ; public i _ set < handler > handlers { get ; set ; } public tcp _ relay ( shadowsocks _ controller controller ) {
{ if ( socket . protocol _ type ! = protocol _ type . tcp ) { return false ; } if ( length < 2 | | first _ packet [ 0 ] ! = NUM ) { return false ; } socket . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ;
if ( length < 2 | | first _ packet [ 0 ] ! = NUM ) { return false ; } socket . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; handler handler = new handler ( ) ; handler . connection = socket ; handler . controller = controller ; handler . relay = this ; handler . start ( first _ packet , length ) ;
handler . start ( first _ packet , length ) ; i _ list < handler > handlers _ to _ close = new list < handler > ( ) ; lock ( this . handlers ) { this . handlers . add ( handler ) ; logging . debug ( $ STR ) ; date _ time now = date _ time . now ; if ( now - last _ sweep _ time > time _ span . from _ seconds ( 1 ) ) { last _ sweep _ time = now ;
last _ sweep _ time = now ; foreach ( handler handler in this . handlers ) { if ( now - handler . last _ activity > time _ span . from _ seconds ( NUM ) ) { handlers _ to _ close . add ( handler ) ; } } } }
} }
public void create _ remote ( ) { server server = controller . get _ a _ server ( i _ strategy _ caller _ type . tcp , ( ip _ end _ point ) connection . remote _ end _ point ) ; if ( server = = null | | server . server = = STR ) { throw new argument _ exception ( STR ) ; }
server server = controller . get _ a _ server ( i _ strategy _ caller _ type . tcp , ( ip _ end _ point ) connection . remote _ end _ point ) ; if ( server = = null | | server . server = = STR ) { throw new argument _ exception ( STR ) ; } this . encryptor = encryptor _ factory . get _ encryptor ( server . method , server . password , server . auth , false ) ; this . server = server ; } public void start ( byte [ ] first _ packet , int length ) {
{ this . first _ packet = first _ packet ; this . first _ packet _ length = length ; this . handshake _ receive ( ) ; this . last _ activity = date _ time . now ; } private void check _ close ( ) { if ( connection _ shutdown & & remote _ shutdown ) {
{ if ( connection _ shutdown & & remote _ shutdown ) { this . close ( ) ; } } public void close ( ) { lock ( relay . handlers ) {
{ int bytes _ read = first _ packet _ length ; if ( bytes _ read > 1 ) { byte [ ] response = { NUM , 0 } ; if ( first _ packet [ 0 ] ! = NUM ) { response = new byte [ ] { 0 , NUM } ; logging . error ( STR ) ; }
if ( first _ packet [ 0 ] ! = NUM ) { response = new byte [ ] { 0 , NUM } ; logging . error ( STR ) ; } logging . debug ( $ STR + response . length ) ; connection . begin _ send ( response , 0 , response . length , 0 , new async _ callback ( handshake _ send _ callback ) , null ) ; } else {
} try { int bytes _ read = connection . end _ receive ( ar ) ; if ( bytes _ read > = NUM ) { command = connetion _ recv _ buffer [ 1 ] ; if ( command = = 1 ) { byte [ ] response = { NUM , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 } ;
logging . debug ( $ STR + response . length ) ; connection . begin _ send ( response , 0 , response . length , 0 , new async _ callback ( response _ callback ) , null ) ; } else if ( command = = NUM ) { handle _ udp _ associate ( ) ; } } else {
{ if ( closed ) { return ; } try { if ( ar . async _ state ! = null ) { connection . end _ send ( ar ) ;
{ connection . end _ send ( ar ) ; logging . debug ( $ STR + recv _ size ) ; connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , 0 , new async _ callback ( read _ all ) , null ) ; } else { int bytes _ read = connection . end _ receive ( ar ) ; if ( bytes _ read > 0 ) {
else { int bytes _ read = connection . end _ receive ( ar ) ; if ( bytes _ read > 0 ) { logging . debug ( $ STR + recv _ size ) ; connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , 0 , new async _ callback ( read _ all ) , null ) ; } else {
if ( strategy ! = null ) { strategy . set _ failure ( server ) ; } logging . info ( $ STR ) ; remote . close ( ) ; retry _ connect ( ) ; } private void retry _ connect ( ) {
private void retry _ connect ( ) { if ( retry _ count < NUM ) { logging . debug ( STR ) ; start _ connect ( ) ; retry _ count + + ; } else {
{ return ; } try { int bytes _ read = remote . end _ receive ( ar ) ; total _ read + = bytes _ read ; if ( bytes _ read > 0 ) {
this . last _ activity = date _ time . now ; int bytes _ to _ send ; lock ( decryption _ lock ) { if ( closed ) { return ; } encryptor . decrypt ( remote _ recv _ buffer , bytes _ read , remote _ send _ buffer , out bytes _ to _ send ) ; }
{ return ; } encryptor . decrypt ( remote _ recv _ buffer , bytes _ read , remote _ send _ buffer , out bytes _ to _ send ) ; } logging . debug ( $ STR + bytes _ to _ send ) ; connection . begin _ send ( remote _ send _ buffer , 0 , bytes _ to _ send , 0 , new async _ callback ( pipe _ connection _ send _ callback ) , null ) ; i _ strategy strategy = controller . get _ current _ strategy ( ) ; if ( strategy ! = null ) {
if ( strategy ! = null ) { strategy . update _ last _ read ( this . server ) ; } } else { connection . shutdown ( socket _ shutdown . send ) ; connection _ shutdown = true ; check _ close ( ) ;
{ int bytes _ to _ send ; lock ( encryption _ lock ) { if ( closed ) { return ; } encryptor . encrypt ( connetion _ recv _ buffer , bytes _ read , connetion _ send _ buffer , out bytes _ to _ send ) ; }
{ return ; } encryptor . encrypt ( connetion _ recv _ buffer , bytes _ read , connetion _ send _ buffer , out bytes _ to _ send ) ; } logging . debug ( $ STR + bytes _ to _ send ) ; remote . begin _ send ( connetion _ send _ buffer , 0 , bytes _ to _ send , 0 , new async _ callback ( pipe _ remote _ send _ callback ) , null ) ; i _ strategy strategy = controller . get _ current _ strategy ( ) ; if ( strategy ! = null ) {

using shadowsocks _ model ; using system ; using system _ collections _ generic ; using system _ net ; using system _ net _ network _ information ; using system _ net _ sockets ;

using system _ io ; using shadowsocks _ model ; using system ; using system _ collections _ generic ; using system _ text ; using system _ threading ;
using shadowsocks _ model ; using system ; using system _ collections _ generic ; using system _ text ; using system _ threading ; using system _ net _ sockets ; using shadowsocks _ controller _ strategy ;
using system _ text ; using system _ threading ; using system _ net _ sockets ; using shadowsocks _ controller _ strategy ; using system _ net ; using shadowsocks _ util ;
using system ; using system _ collections _ generic ;
using system ; using system _ collections _ generic ; using system _ text ; using shadowsocks _ encryption ; using shadowsocks _ model ;
using system ;
using system ; using system _ collections _ generic ; using system _ diagnostics ; using system _ io ; using system _ i _ compression ; using system _ runtime _ interop _ services ;
using system ;
using system ; using system _ collections _ generic ; using system _ component _ model ; using system _ data ; using system _ drawing ; using system _ io ;
using system ;
using system ; using system _ collections _ generic ; using system _ net ; using system _ net _ sockets ;
private readonly concurrent _ dictionary < string , list < int > > latency _ records = new concurrent _ dictionary < string , list < int > > ( ) ; private readonly concurrent _ dictionary < string , list < int > > inbound _ speed _ records = new concurrent _ dictionary < string , list < int > > ( ) ; private readonly concurrent _ dictionary < string , list < int > > outbound _ speed _ records = new concurrent _ dictionary < string , list < int > > ( ) ; private readonly concurrent _ dictionary < string , in _ out _ bound _ record > in _ out _ bound _ records = new concurrent _ dictionary < string , in _ out _ bound _ record > ( ) ; private class in _ out _ bound _ record { private long inbound ; private long last _ inbound ; private long outbound ; private long last _ outbound ;
private readonly concurrent _ dictionary < string , in _ out _ bound _ record > in _ out _ bound _ records = new concurrent _ dictionary < string , in _ out _ bound _ record > ( ) ; private class in _ out _ bound _ record { private long inbound ; private long last _ inbound ; private long outbound ; private long last _ outbound ; private spin _ lock lock = new spin _ lock ( ) ; public void update _ inbound ( long delta ) {
private long last _ outbound ; private spin _ lock lock = new spin _ lock ( ) ; public void update _ inbound ( long delta ) { finally { if ( lock _ taken ) { lock . exit ( false ) ; } } } public void update _ outbound ( long delta ) {
} } public void update _ outbound ( long delta ) { finally { if ( lock _ taken ) { lock . exit ( false ) ; } } } public void get _ delta ( out long inbound _ delta , out long outbound _ delta ) {
using system ; using system _ net ; using system _ net _ sockets ; namespace shadowsocks _ proxy { public interface i _ proxy { end _ point local _ end _ point { get ; } end _ point proxy _ end _ point { get ; }
using system _ net _ sockets ; namespace shadowsocks _ proxy { public interface i _ proxy { end _ point local _ end _ point { get ; } end _ point proxy _ end _ point { get ; } string dest _ host { get ; } int dest _ port { get ; } void begin _ connect _ proxy ( end _ point remote _ ep , async _ callback callback , object state ) ; void end _ connect _ proxy ( i _ async _ result async _ result ) ;
remote . begin _ connect ( remote _ ep , connect _ callback , st ) ; } public void end _ connect _ proxy ( i _ async _ result async _ result ) { var state = ( ( fake _ async _ result ) async _ result ) . inner _ state ; if ( state . ex ! = null ) { throw state . ex ; } }
{ throw state . ex ; } } public void begin _ connect _ dest ( string host , int port , async _ callback callback , object state ) { dest _ host = host ; dest _ port = port ; byte [ ] request = null ; byte atyp = 0 ;
request = new byte [ NUM + NUM + 2 ] ; atyp = 1 ; break ; case address _ family . inter _ network : request = new byte [ NUM + NUM + 2 ] ; atyp = NUM ; break ; default : throw new exception ( n . get _ string ( STR ) ) ; }
case address _ family . inter _ network : request = new byte [ NUM + NUM + 2 ] ; atyp = NUM ; break ; default : throw new exception ( n . get _ string ( STR ) ) ; } var addr = ep . address . get _ address _ bytes ( ) ; array . copy ( addr , 0 , request , NUM , request . length - NUM - 2 ) ;
{ public override address _ family address _ family { get ; } = address _ family . unspecified ; public override string to _ string ( ) { return STR ; } } private socket remote ; public end _ point local _ end _ point = > remote . local _ end _ point ; public end _ point proxy _ end _ point { get ; } = new fake _ end _ point ( ) ;
public end _ point proxy _ end _ point { get ; } = new fake _ end _ point ( ) ; public string dest _ host { get ; private set ; } public int dest _ port { get ; private set ; } public void begin _ connect _ proxy ( end _ point remote _ ep , async _ callback callback , object state ) { var r = new fake _ async _ result ( state ) ; callback ? . invoke ( r ) ; } public void end _ connect _ proxy ( i _ async _ result async _ result ) { }
public void begin _ connect _ proxy ( end _ point remote _ ep , async _ callback callback , object state ) { var r = new fake _ async _ result ( state ) ; callback ? . invoke ( r ) ; } public void end _ connect _ proxy ( i _ async _ result async _ result ) { } public void begin _ connect _ dest ( string host , int port , async _ callback callback , object state ) {
public void end _ connect _ proxy ( i _ async _ result async _ result ) { } public void begin _ connect _ dest ( string host , int port , async _ callback callback , object state ) { ip _ address ip _ address ; bool parsed = ip _ address . try _ parse ( host , out ip _ address ) ; if ( ! parsed ) {
public void begin _ connect _ dest ( string host , int port , async _ callback callback , object state ) { ip _ address ip _ address ; bool parsed = ip _ address . try _ parse ( host , out ip _ address ) ; if ( ! parsed ) { ip _ host _ entry ip _ host _ info = dns . get _ host _ entry ( host ) ; ip _ address = ip _ host _ info . address _ list [ 0 ] ; }
ip _ address ip _ address ; bool parsed = ip _ address . try _ parse ( host , out ip _ address ) ; if ( ! parsed ) { ip _ host _ entry ip _ host _ info = dns . get _ host _ entry ( host ) ; ip _ address = ip _ host _ info . address _ list [ 0 ] ; } ip _ end _ point remote _ ep = new ip _ end _ point ( ip _ address , port ) ; dest _ host = host ; dest _ port = port ; if ( remote = = null ) {
{ ip _ host _ entry ip _ host _ info = dns . get _ host _ entry ( host ) ; ip _ address = ip _ host _ info . address _ list [ 0 ] ; } ip _ end _ point remote _ ep = new ip _ end _ point ( ip _ address , port ) ; dest _ host = host ; dest _ port = port ; if ( remote = = null ) { remote = new socket ( remote _ ep . address _ family , socket _ type . stream , protocol _ type . tcp ) ; remote . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; }
queue < traffic _ info > traffic _ info _ queue = new queue < traffic _ info > ( ) ; const int queue _ max _ length = NUM ; long last _ inbound , last _ outbound ; long max _ speed = 0 , last _ max _ speed = 0 ; const long min _ scale = NUM ; bandwidth _ scale _ info bandwidth _ scale ; list < float > inbound _ points = new list < float > ( ) ; list < float > outbound _ points = new list < float > ( ) ; text _ annotation inbound _ annotation = new text _ annotation ( ) ; text _ annotation outbound _ annotation = new text _ annotation ( ) ;
long max _ speed = 0 , last _ max _ speed = 0 ; const long min _ scale = NUM ; bandwidth _ scale _ info bandwidth _ scale ; list < float > inbound _ points = new list < float > ( ) ; list < float > outbound _ points = new list < float > ( ) ; text _ annotation inbound _ annotation = new text _ annotation ( ) ; text _ annotation outbound _ annotation = new text _ annotation ( ) ; public log _ form ( shadowsocks _ controller controller , string filename = null ) { this . controller = controller ;
using system ; using system _ collections _ generic ;
using system ; using system _ collections _ generic ; namespace shadowsocks _ encryption {
{ STR , new encryptor _ info ( NUM , NUM , cipher _ chach _ ietf ) } } ; protected override dictionary < string , encryptor _ info > get _ ciphers ( ) { return ciphers ; } public static list < string > supported _ ciphers ( ) { return new list < string > ( ciphers . keys ) ; }
public static list < string > supported _ ciphers ( ) { return new list < string > ( ciphers . keys ) ; } protected override void cipher _ update ( bool is _ cipher , int length , byte [ ] buf , byte [ ] outbuf ) { int bytes _ remaining ; ulong ic ; byte [ ] sodium _ buf ; byte [ ] iv ;
bytes _ remaining = decrypt _ bytes _ remaining ; ic = decrypt _ ic ; sodium _ buf = decrypt _ buf ; iv = decrypt _ iv ; } int padding = bytes _ remaining ; buffer . block _ copy ( buf , 0 , sodium _ buf , padding , length ) ; switch ( cipher ) { case cipher _ sals :
iv = decrypt _ iv ; } int padding = bytes _ remaining ; buffer . block _ copy ( buf , 0 , sodium _ buf , padding , length ) ; switch ( cipher ) { case cipher _ sals : sodium . crypto _ stream _ salsa _ xor _ ic ( sodium _ buf , sodium _ buf , ( ulong ) ( padding + length ) , iv , ic , key ) ; break ; case cipher _ chach :
buffer . block _ copy ( buf , 0 , sodium _ buf , padding , length ) ; switch ( cipher ) { case cipher _ sals : sodium . crypto _ stream _ salsa _ xor _ ic ( sodium _ buf , sodium _ buf , ( ulong ) ( padding + length ) , iv , ic , key ) ; break ; case cipher _ chach : sodium . crypto _ stream _ chacha _ xor _ ic ( sodium _ buf , sodium _ buf , ( ulong ) ( padding + length ) , iv , ic , key ) ; break ; case cipher _ chach _ ietf :
break ; case cipher _ chach _ ietf : sodium . crypto _ stream _ chacha _ ietf _ xor _ ic ( sodium _ buf , sodium _ buf , ( ulong ) ( padding + length ) , iv , ( uint ) ic , key ) ; break ; } buffer . block _ copy ( sodium _ buf , padding , outbuf , 0 , length ) ; padding + = length ; ic + = ( ulong ) padding / sodium _ block _ size ; bytes _ remaining = padding % sodium _ block _ size ;

using system _ text ; namespace shadowsocks _ encryption {
} public abstract class encryptor _ base : i _ encryptor { public const int max _ input _ size = NUM ;
} public abstract class encryptor _ base : i _ encryptor { public const int max _ input _ size = NUM ; protected encryptor _ base ( string method , string password , bool onetimeauth , bool isudp ) { method = method ; password = password ;
public const int max _ input _ size = NUM ; protected encryptor _ base ( string method , string password , bool onetimeauth , bool isudp ) { method = method ; password = password ; onetime _ auth = onetimeauth ; is _ udp = isudp ; } protected string method ; protected string password ;
using system ; using system _ io ; using system _ runtime _ interop _ services ; using shadowsocks _ controller ; using shadowsocks _ properties ; using shadowsocks _ util ; namespace shadowsocks _ encryption {
using system ; using system _ io ; using system _ runtime _ interop _ services ; using shadowsocks _ controller ; using shadowsocks _ properties ; using shadowsocks _ util ; namespace shadowsocks _ encryption { public class sodium {
using shadowsocks _ properties ; using shadowsocks _ util ; namespace shadowsocks _ encryption { public class sodium { const string dllname = STR ; static sodium ( ) {
static sodium ( ) { string dll _ path = utils . get _ temp _ path ( STR ) ; try { file _ manager . uncompress _ file ( dll _ path , resources . libsscrypto _ dll ) ; } catch ( io _ exception ) { }
} dll _ import _ kernel _ dll private static extern int _ ptr load _ library ( string path ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl
} dll _ import _ kernel _ dll private static extern int _ ptr load _ library ( string path ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern int crypto _ stream _ salsa _ xor _ ic ( byte [ ] c , byte [ ] m , ulong mlen , byte [ ] n , ulong ic , byte [ ] k ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl
} dll _ import _ kernel _ dll private static extern int _ ptr load _ library ( string path ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern int crypto _ stream _ salsa _ xor _ ic ( byte [ ] c , byte [ ] m , ulong mlen , byte [ ] n , ulong ic , byte [ ] k ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern int crypto _ stream _ chacha _ xor _ ic ( byte [ ] c , byte [ ] m , ulong mlen , byte [ ] n , ulong ic , byte [ ] k ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl
dll _ import _ kernel _ dll private static extern int _ ptr load _ library ( string path ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern int crypto _ stream _ salsa _ xor _ ic ( byte [ ] c , byte [ ] m , ulong mlen , byte [ ] n , ulong ic , byte [ ] k ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern int crypto _ stream _ chacha _ xor _ ic ( byte [ ] c , byte [ ] m , ulong mlen , byte [ ] n , ulong ic , byte [ ] k ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern int crypto _ stream _ chacha _ ietf _ xor _ ic ( byte [ ] c , byte [ ] m , ulong mlen , byte [ ] n , uint ic , byte [ ] k ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl
rng . dispose ( ) ; rng = null ; } public static void reload ( ) { close ( ) ; init ( ) ; } public static void get _ bytes ( byte [ ] buf ) {
{ rng . get _ bytes ( buf ) ; } public static void get _ bytes ( byte [ ] buf , int len ) { try { rng . get _ bytes ( buf , 0 , len ) ; }
using system _ net _ sockets ; using system _ runtime _ compiler _ services ; using shadowsocks _ controller _ strategy ; using shadowsocks _ encryption ; using shadowsocks _ model ; namespace shadowsocks _ controller { class udp _ relay : listener . service { private shadowsocks _ controller controller ;
class udp _ relay : listener . service { private shadowsocks _ controller controller ; private lru _ cache < ip _ end _ point , udp _ handler > cache ; public long outbound = 0 ; public long inbound = 0 ; public udp _ relay ( shadowsocks _ controller controller ) { this . controller = controller ;
if ( ! parsed ) { ip _ host _ entry ip _ host _ info = dns . get _ host _ entry ( server . server ) ; ip _ address = ip _ host _ info . address _ list [ 0 ] ; } remote _ end _ point = new ip _ end _ point ( ip _ address , server . server _ port ) ; remote = new socket ( remote _ end _ point . address _ family , socket _ type . dgram , protocol _ type . udp ) ; } public void send ( byte [ ] data , int length ) {
ip _ address = ip _ host _ info . address _ list [ 0 ] ; } remote _ end _ point = new ip _ end _ point ( ip _ address , server . server _ port ) ; remote = new socket ( remote _ end _ point . address _ family , socket _ type . dgram , protocol _ type . udp ) ; } public void send ( byte [ ] data , int length ) { i _ encryptor encryptor = encryptor _ factory . get _ encryptor ( server . method , server . password , server . auth , true ) ; byte [ ] data _ in = new byte [ length - NUM + iv _ encryptor . onetimeauth _ bytes ] ; array . copy ( data , NUM , data _ in , 0 , length - NUM ) ;
remote _ end _ point = new ip _ end _ point ( ip _ address , server . server _ port ) ; remote = new socket ( remote _ end _ point . address _ family , socket _ type . dgram , protocol _ type . udp ) ; } public void send ( byte [ ] data , int length ) { i _ encryptor encryptor = encryptor _ factory . get _ encryptor ( server . method , server . password , server . auth , true ) ; byte [ ] data _ in = new byte [ length - NUM + iv _ encryptor . onetimeauth _ bytes ] ; array . copy ( data , NUM , data _ in , 0 , length - NUM ) ; byte [ ] data _ out = new byte [ length - NUM + NUM + iv _ encryptor . onetimeauth _ bytes ] ; int outlen ;
{ state = state ; } public async _ session ( async _ session session , t state ) : base ( session . remote ) { state = state ; } } private readonly int server _ timeout ; private readonly int proxy _ timeout ;
public static readonly int recv _ reserve _ size = iv _ encryptor . onetimeauth _ bytes + iv _ encryptor . auth _ bytes ; public static readonly int buffer _ size = recv _ size + recv _ reserve _ size + NUM ; public date _ time last _ activity ; private shadowsocks _ controller controller ; private configuration config ; private tcp _ relay tcprelay ; private socket connection ; private i _ encryptor encryptor ; private server server ; private async _ session current _ remote _ session ;
server _ timeout = config . get _ current _ server ( ) . timeout * NUM ; last _ activity = date _ time . now ; } public void create _ remote ( ) { server server = controller . get _ a _ server ( i _ strategy _ caller _ type . tcp , ( ip _ end _ point ) connection . remote _ end _ point , dest _ end _ point ) ; if ( server = = null | | server . server = = STR ) throw new argument _ exception ( STR ) ;
logging . log _ useful _ exception ( e ) ; close ( ) ; } } private void handshake _ send _ callback ( i _ async _ result ar ) { if ( closed ) return ; try { connection . end _ send ( ar ) ;
} private void handshake _ receive _ callback ( i _ async _ result ar ) { if ( closed ) return ; try { int bytes _ read = connection . end _ receive ( ar ) ; if ( bytes _ read > = NUM ) { command = connetion _ recv _ buffer [ 1 ] ;
if ( bytes _ read > = NUM ) { command = connetion _ recv _ buffer [ 1 ] ; if ( command ! = 1 & & command ! = NUM ) { logging . debug ( STR + command ) ; close ( ) ; } else {
{ logging . debug ( STR + command ) ; close ( ) ; } else { if ( command = = 1 ) { byte [ ] response = { NUM , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 } ; connection . begin _ send ( response , 0 , response . length , socket _ flags . none ,
close ( ) ; } else { if ( command = = 1 ) { byte [ ] response = { NUM , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 } ; connection . begin _ send ( response , 0 , response . length , socket _ flags . none , new async _ callback ( response _ callback ) , null ) ; }
{ logging . log _ useful _ exception ( e ) ; close ( ) ; } } private void read _ address ( action on _ success ) { int atyp = connetion _ recv _ buffer [ NUM ] ; switch ( atyp ) {
} } private void read _ address ( action on _ success ) { int atyp = connetion _ recv _ buffer [ NUM ] ; switch ( atyp ) { case 1 : read _ address ( NUM + 2 - 1 , on _ success ) ; break ;
private void read _ address ( action on _ success ) { int atyp = connetion _ recv _ buffer [ NUM ] ; switch ( atyp ) { case 1 : read _ address ( NUM + 2 - 1 , on _ success ) ; break ; case NUM : int len = connetion _ recv _ buffer [ NUM ] ;
int atyp = connetion _ recv _ buffer [ NUM ] ; switch ( atyp ) { case 1 : read _ address ( NUM + 2 - 1 , on _ success ) ; break ; case NUM : int len = connetion _ recv _ buffer [ NUM ] ; read _ address ( len + 2 , on _ success ) ; break ;
read _ address ( NUM + 2 - 1 , on _ success ) ; break ; default : logging . debug ( STR + atyp ) ; close ( ) ; break ; } } private void read _ address ( int bytes _ remain , action on _ success ) {
int bytes _ remain = ( int ) states [ 0 ] ; var on _ success = ( action ) states [ 1 ] ; if ( bytes _ read > = bytes _ remain ) { first _ packet _ length = bytes _ read + 2 ; int atyp = connetion _ recv _ buffer [ 0 ] ; string dst _ addr = STR ; int dst _ port = - 1 ; switch ( atyp ) {
int atyp = connetion _ recv _ buffer [ 0 ] ; string dst _ addr = STR ; int dst _ port = - 1 ; switch ( atyp ) { case 1 : dst _ addr = new ip _ address ( connetion _ recv _ buffer . skip ( 1 ) . take ( NUM ) . to _ array ( ) ) . to _ string ( ) ; dst _ port = ( connetion _ recv _ buffer [ NUM ] < < NUM ) + connetion _ recv _ buffer [ NUM ] ; break ;
int dst _ port = - 1 ; switch ( atyp ) { case 1 : dst _ addr = new ip _ address ( connetion _ recv _ buffer . skip ( 1 ) . take ( NUM ) . to _ array ( ) ) . to _ string ( ) ; dst _ port = ( connetion _ recv _ buffer [ NUM ] < < NUM ) + connetion _ recv _ buffer [ NUM ] ; break ; case NUM : int len = connetion _ recv _ buffer [ 1 ] ;
case 1 : dst _ addr = new ip _ address ( connetion _ recv _ buffer . skip ( 1 ) . take ( NUM ) . to _ array ( ) ) . to _ string ( ) ; dst _ port = ( connetion _ recv _ buffer [ NUM ] < < NUM ) + connetion _ recv _ buffer [ NUM ] ; break ; case NUM : int len = connetion _ recv _ buffer [ 1 ] ; dst _ addr = system . text . encoding . ut . get _ string ( connetion _ recv _ buffer , 2 , len ) ; dst _ port = ( connetion _ recv _ buffer [ len + 2 ] < < NUM ) + connetion _ recv _ buffer [ len + NUM ] ; break ;
{ logging . log _ useful _ exception ( e ) ; close ( ) ; } } private void handle _ udp _ associate ( ) { ip _ end _ point end _ point = ( ip _ end _ point ) connection . local _ end _ point ; byte [ ] address = end _ point . address . get _ address _ bytes ( ) ; int port = end _ point . port ;
private void handle _ udp _ associate ( ) { ip _ end _ point end _ point = ( ip _ end _ point ) connection . local _ end _ point ; byte [ ] address = end _ point . address . get _ address _ bytes ( ) ; int port = end _ point . port ; byte [ ] response = new byte [ NUM + address . length + 2 ] ; response [ 0 ] = NUM ; switch ( end _ point . address _ family ) { case address _ family . inter _ network :
byte [ ] address = end _ point . address . get _ address _ bytes ( ) ; int port = end _ point . port ; byte [ ] response = new byte [ NUM + address . length + 2 ] ; response [ 0 ] = NUM ; switch ( end _ point . address _ family ) { case address _ family . inter _ network : response [ NUM ] = 1 ; break ; case address _ family . inter _ network :
case address _ family . inter _ network : response [ NUM ] = 1 ; break ; case address _ family . inter _ network : response [ NUM ] = NUM ; break ; } address . copy _ to ( response , NUM ) ; response [ response . length - 1 ] = ( byte ) ( port & 0 xff ) ; response [ response . length - 2 ] = ( byte ) ( ( port > > NUM ) & 0 xff ) ;
connection . begin _ send ( response , 0 , response . length , socket _ flags . none , new async _ callback ( read _ all ) , true ) ; } private void read _ all ( i _ async _ result ar ) { if ( closed ) return ; try { if ( ar . async _ state ! = null ) { connection . end _ send ( ar ) ;
{ connection . end _ send ( ar ) ; connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , socket _ flags . none , new async _ callback ( read _ all ) , null ) ; } else { int bytes _ read = connection . end _ receive ( ar ) ; if ( bytes _ read > 0 ) {
public server _ timer ( int p ) : base ( p ) { } } private void start _ connect ( ) { try { create _ remote ( ) ; i _ proxy remote ;
var session = new async _ session ( remote ) ; lock ( close _ conn _ lock ) { if ( closed ) { remote . close ( ) ; return ; } current _ remote _ session = session ; }
current _ remote _ session = session ; } proxy _ timer proxy _ timer = new proxy _ timer ( proxy _ timeout ) ; proxy _ timer . auto _ reset = false ; proxy _ timer . elapsed + = proxy _ connect _ timer _ elapsed ; proxy _ timer . enabled = true ; proxy _ timer . session = session ; proxy _ timer . dest _ end _ point = socket _ util . get _ end _ point ( server . server , server . server _ port ) ; proxy _ timer . server = server ; proxy _ connected = false ;
{ return ; } var proxy = timer . session . remote ; logging . info ( $ STR ) ; proxy . close ( ) ; close ( ) ; } private void proxy _ connect _ callback ( i _ async _ result ar ) {
server server = null ; if ( closed ) { return ; } try { var session = ( async _ session < proxy _ timer > ) ar . async _ state ; proxy _ timer timer = session . state ; var dest _ end _ point = timer . dest _ end _ point ;
remote . end _ connect _ proxy ( ar ) ; proxy _ connected = true ; if ( config . is _ verbose _ logging ) { if ( ! ( remote is direct _ connect ) ) { logging . info ( $ STR ) ; } } start _ connect _ time = date _ time . now ;
} } start _ connect _ time = date _ time . now ; server _ timer connect _ timer = new server _ timer ( server _ timeout ) ; connect _ timer . auto _ reset = false ; connect _ timer . elapsed + = dest _ connect _ timer _ elapsed ; connect _ timer . enabled = true ; connect _ timer . session = session ; connect _ timer . server = server ; dest _ connected = false ;
if ( closed ) return ; try { var session = ( async _ session ) ar . async _ state ; int bytes _ read = session . remote . end _ receive ( ar ) ; total _ read + = bytes _ read ; tcprelay . update _ inbound _ counter ( server , bytes _ read ) ; if ( bytes _ read > 0 ) { last _ activity = date _ time . now ;
var session = ( async _ session ) ar . async _ state ; int bytes _ read = session . remote . end _ receive ( ar ) ; total _ read + = bytes _ read ; tcprelay . update _ inbound _ counter ( server , bytes _ read ) ; if ( bytes _ read > 0 ) { last _ activity = date _ time . now ; int bytes _ to _ send ; lock ( decryption _ lock ) {
logging . log _ useful _ exception ( e ) ; close ( ) ; } } private void send _ to _ server ( int length , async _ session session ) { total _ write + = length ; int bytes _ to _ send ; lock ( encryption _ lock ) {
total _ write + = length ; int bytes _ to _ send ; lock ( encryption _ lock ) { encryptor . encrypt ( connetion _ recv _ buffer , length , connetion _ send _ buffer , out bytes _ to _ send ) ; } tcprelay . update _ outbound _ counter ( server , bytes _ to _ send ) ; start _ sending _ time = date _ time . now ;
session . remote . begin _ send ( connetion _ send _ buffer , 0 , bytes _ to _ send , socket _ flags . none , new async _ callback ( pipe _ remote _ send _ callback ) , session ) ; i _ strategy strategy = controller . get _ current _ strategy ( ) ; strategy ? . update _ last _ write ( server ) ; } private void pipe _ remote _ send _ callback ( i _ async _ result ar ) { if ( closed ) return ; try {
catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; } } private void pipe _ connection _ send _ callback ( i _ async _ result ar ) { try {
using system ; using system _ collections _ generic ; using system _ runtime _ interop _ services ;
using system ; using system _ collections _ generic ; using system _ runtime _ interop _ services ; namespace shadowsocks _ encryption {
{ public class mbed _ tls _ encryptor : iv _ encryptor , i _ disposable { const int cipher _ r = 1 ; const int cipher _ aes = 2 ; const int cipher _ blowfish = NUM ; const int cipher _ camellia = NUM ; private int _ ptr encrypt _ ctx = int _ ptr . zero ; private int _ ptr decrypt _ ctx = int _ ptr . zero ;
public static list < string > supported _ ciphers ( ) { return new list < string > ( ciphers . keys ) ; } protected override dictionary < string , encryptor _ info > get _ ciphers ( ) { return ciphers ; } protected override void init _ cipher ( byte [ ] iv , bool is _ cipher ) {
* cipher _ setkey ( ) will set the correct key schedule * and operation * * mbedtls _ aes { en , de } crypt * = = mbedtls _ blowfish { en , de } crypt * = = mbedtls _ camellia { en , de } crypt * = = mbedtls { en , de } crypt * * / if ( mbed _ tls . cipher _ setkey ( ctx , realkey , key _ len * NUM ,
* mbedtls _ aes { en , de } crypt * = = mbedtls _ blowfish { en , de } crypt * = = mbedtls _ camellia { en , de } crypt * = = mbedtls { en , de } crypt * * / if ( mbed _ tls . cipher _ setkey ( ctx , realkey , key _ len * NUM , is _ cipher ? mbed _ tls . mbedtls _ encrypt : mbed _ tls . mbedtls _ decrypt ) ! = 0 ) throw new exception ( STR ) ; if ( mbed _ tls . cipher _ set _ iv ( ctx , iv , iv _ len ) ! = 0 )
* = = mbedtls _ camellia { en , de } crypt * = = mbedtls { en , de } crypt * * / if ( mbed _ tls . cipher _ setkey ( ctx , realkey , key _ len * NUM , is _ cipher ? mbed _ tls . mbedtls _ encrypt : mbed _ tls . mbedtls _ decrypt ) ! = 0 ) throw new exception ( STR ) ; if ( mbed _ tls . cipher _ set _ iv ( ctx , iv , iv _ len ) ! = 0 ) throw new exception ( STR ) ; if ( mbed _ tls . cipher _ reset ( ctx ) ! = 0 )
* * / if ( mbed _ tls . cipher _ setkey ( ctx , realkey , key _ len * NUM , is _ cipher ? mbed _ tls . mbedtls _ encrypt : mbed _ tls . mbedtls _ decrypt ) ! = 0 ) throw new exception ( STR ) ; if ( mbed _ tls . cipher _ set _ iv ( ctx , iv , iv _ len ) ! = 0 ) throw new exception ( STR ) ; if ( mbed _ tls . cipher _ reset ( ctx ) ! = 0 ) throw new exception ( STR ) ; }
throw new exception ( STR ) ; if ( mbed _ tls . cipher _ reset ( ctx ) ! = 0 ) throw new exception ( STR ) ; } protected override void cipher _ update ( bool is _ cipher , int length , byte [ ] buf , byte [ ] outbuf ) { if ( disposed ) { throw new object _ disposed _ exception ( this . to _ string ( ) ) ; }
throw new exception ( STR ) ; } protected override void cipher _ update ( bool is _ cipher , int length , byte [ ] buf , byte [ ] outbuf ) { if ( disposed ) { throw new object _ disposed _ exception ( this . to _ string ( ) ) ; } if ( mbed _ tls . cipher _ update ( is _ cipher ? encrypt _ ctx : decrypt _ ctx , buf , length , outbuf , ref length ) ! = 0 )
buf , length , outbuf , ref length ) ! = 0 ) throw new exception ( STR ) ; } private bool disposed ; private readonly object lock = new object ( ) ; public override void dispose ( ) { dispose ( true ) ; gc . suppress _ finalize ( this ) ; }
using system ; using system _ collections _ generic ; using system _ reflection ; namespace shadowsocks _ encryption { public static class encryptor _ factory {
namespace shadowsocks _ encryption { public static class encryptor _ factory { private static dictionary < string , type > registered _ encryptors ; private static type [ ] constructor _ types = new type [ ] { typeof ( string ) , typeof ( string ) , typeof ( bool ) , typeof ( bool ) } ; static encryptor _ factory ( ) {
namespace shadowsocks _ encryption { public static class encryptor _ factory { private static dictionary < string , type > registered _ encryptors ; private static type [ ] constructor _ types = new type [ ] { typeof ( string ) , typeof ( string ) , typeof ( bool ) , typeof ( bool ) } ; static encryptor _ factory ( ) { registered _ encryptors = new dictionary < string , type > ( ) ; foreach ( string method in mbed _ tls _ encryptor . supported _ ciphers ( ) ) {
public static class encryptor _ factory { private static dictionary < string , type > registered _ encryptors ; private static type [ ] constructor _ types = new type [ ] { typeof ( string ) , typeof ( string ) , typeof ( bool ) , typeof ( bool ) } ; static encryptor _ factory ( ) { registered _ encryptors = new dictionary < string , type > ( ) ; foreach ( string method in mbed _ tls _ encryptor . supported _ ciphers ( ) ) { registered _ encryptors . add ( method , typeof ( mbed _ tls _ encryptor ) ) ; }
private static dictionary < string , type > registered _ encryptors ; private static type [ ] constructor _ types = new type [ ] { typeof ( string ) , typeof ( string ) , typeof ( bool ) , typeof ( bool ) } ; static encryptor _ factory ( ) { registered _ encryptors = new dictionary < string , type > ( ) ; foreach ( string method in mbed _ tls _ encryptor . supported _ ciphers ( ) ) { registered _ encryptors . add ( method , typeof ( mbed _ tls _ encryptor ) ) ; } foreach ( string method in sodium _ encryptor . supported _ ciphers ( ) ) {
foreach ( string method in mbed _ tls _ encryptor . supported _ ciphers ( ) ) { registered _ encryptors . add ( method , typeof ( mbed _ tls _ encryptor ) ) ; } foreach ( string method in sodium _ encryptor . supported _ ciphers ( ) ) { registered _ encryptors . add ( method , typeof ( sodium _ encryptor ) ) ; } }
} } public static i _ encryptor get _ encryptor ( string method , string password , bool onetimeauth , bool isudp ) { if ( method . is _ null _ or _ empty ( ) ) { method = STR ; } method = method . to _ lower _ invariant ( ) ; type t = registered _ encryptors [ method ] ;
using system ; using system _ io ; using system _ runtime _ interop _ services ; using shadowsocks _ controller ; using shadowsocks _ properties ; using shadowsocks _ util ; namespace shadowsocks _ encryption {
using system ; using system _ io ; using system _ runtime _ interop _ services ; using shadowsocks _ controller ; using shadowsocks _ properties ; using shadowsocks _ util ; namespace shadowsocks _ encryption { public class mbed _ tls {
using shadowsocks _ util ; namespace shadowsocks _ encryption { public class mbed _ tls { const string dllname = STR ; public const int mbedtls _ encrypt = 1 ; public const int mbedtls _ decrypt = 0 ; static mbed _ tls ( ) {
static mbed _ tls ( ) { string dll _ path = utils . get _ temp _ path ( STR ) ; try { file _ manager . uncompress _ file ( dll _ path , resources . libsscrypto _ dll ) ; } catch ( io _ exception ) { }
public static extern int cipher _ setkey ( int _ ptr ctx , byte [ ] key , int key _ bitlen , int operation ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern int cipher _ set _ iv ( int _ ptr ctx , byte [ ] iv , int iv _ len ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern int cipher _ reset ( int _ ptr ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern int cipher _ update ( int _ ptr ctx , byte [ ] input , int ilen , byte [ ] output , ref int olen ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern void cipher _ free ( int _ ptr ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl
dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern int cipher _ reset ( int _ ptr ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern int cipher _ update ( int _ ptr ctx , byte [ ] input , int ilen , byte [ ] output , ref int olen ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern void cipher _ free ( int _ ptr ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern void md ( byte [ ] input , uint ilen , byte [ ] output ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl
} server _ status = new _ server _ status ; choose _ new _ server ( ) ; } public server get _ a _ server ( i _ strategy _ caller _ type type , system . net . ip _ end _ point local _ ip _ end _ point ) { if ( type = = i _ strategy _ caller _ type . tcp ) { choose _ new _ server ( ) ; }
return current _ server ; } * once failed , try after NUM min * and ( last write - last read ) < NUM s * and ( now - last read ) < NUM s * and latency < NUM ms , try after NUM s * / public void choose _ new _ server ( ) {

current _ server = max . server ; if ( current _ server ! = old _ server ) {
current _ server = max . server ; if ( current _ server ! = old _ server ) { console . write _ line ( STR , current _ server . friendly _ name ( ) ) ; }
this . server _ port _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . server _ port _ text _ box . max _ length = NUM ; this . server _ port _ text _ box . name = STR ; this . server _ port _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . server _ port _ text _ box . tab _ index = 1 ; this . server _ port _ text _ box . word _ wrap = false ; this . password _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . password _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . password _ text _ box . max _ length = NUM ; this . password _ text _ box . name = STR ;
{ var reply = await ping . send _ task _ async ( ip , timeout ) ; ret . add ( new list < key _ value _ pair < string , string > > { new key _ value _ pair < string , string > ( STR , timestamp ) , new key _ value _ pair < string , string > ( STR , server . friendly _ name ( ) ) , new key _ value _ pair < string , string > ( STR , get _ recent _ latency ( server ) ) , new key _ value _ pair < string , string > ( STR , get _ recent _ inbound _ speed ( server ) ) ,
{ speed _ monior = new timer ( update _ speed , null , delay _ before _ start , monitor _ interval ) ; } load _ raw _ statistics ( ) ; filter _ raw _ statistics ( ) ; evaluate ( ) ; reset _ speed ( ) ; } private async void evaluate ( ) {
reset _ speed ( ) ; } private async void evaluate ( ) { var geolocation _ and _ isp = get _ geolocation _ and _ isp ( ) ; foreach ( var data _ lists in await task _ ex . when _ all ( servers . select ( icmp _ test ) ) ) { if ( data _ lists = = null ) continue ; foreach ( var data _ list in data _ lists . where ( data _ list = > data _ list ! = null ) ) {
} } private date _ time parse _ exact _ or _ unknown ( string str ) { date _ time date _ time ; return ! date _ time . try _ parse _ exact ( str , date _ time _ pattern , null , date _ time _ styles . none , out date _ time ) ? unknown _ date _ time : date _ time ; } public class state { public data _ list data _ list = new data _ list ( ) ;
public data _ list data _ list = new data _ list ( ) ; public const string geolocation = STR ; public const string isp = STR ; public const string unknown = STR ; } public class raw _ statistics _ data { public date _ time timestamp ; public string server _ name ; public string icmp _ status ; public int roundtrip _ time ;
{ realkey = key ; } if ( cipher = = cipher _ aes ) { polar _ ssl . aes _ init ( ctx ) ; polar _ ssl . aes _ setkey _ enc ( ctx , realkey , key _ len * NUM ) ; if ( is _ cipher ) { encrypt _ iv = new byte [ iv _ len ] ;
polar _ ssl . aes _ setkey _ enc ( ctx , realkey , key _ len * NUM ) ; if ( is _ cipher ) { encrypt _ iv = new byte [ iv _ len ] ; encrypt _ iv _ offset = new byte [ NUM ] ; array . copy ( iv , encrypt _ iv , iv _ len ) ; } else { decrypt _ iv = new byte [ iv _ len ] ;
array . copy ( iv , decrypt _ iv , iv _ len ) ; } } else if ( cipher = = cipher _ bf ) { polar _ ssl . blowfish _ init ( ctx ) ; polar _ ssl . blowfish _ setkey ( ctx , realkey , key _ len * NUM ) ; if ( is _ cipher ) { encrypt _ iv = new byte [ iv _ len ] ;
polar _ ssl . blowfish _ setkey ( ctx , realkey , key _ len * NUM ) ; if ( is _ cipher ) { encrypt _ iv = new byte [ iv _ len ] ; encrypt _ iv _ offset = new byte [ NUM ] ; array . copy ( iv , encrypt _ iv , iv _ len ) ; } else { decrypt _ iv = new byte [ iv _ len ] ;
outlength = length + iv _ len ; lock ( tempbuf ) { if ( disposed ) { throw new object _ disposed _ exception ( this . to _ string ( ) ) ; } switch ( cipher ) { case cipher _ aes :
if ( disposed ) { throw new object _ disposed _ exception ( this . to _ string ( ) ) ; } switch ( cipher ) { case cipher _ aes : polar _ ssl . aes _ crypt _ cfb ( encrypt _ ctx , polar _ ssl . aes _ encrypt , length , encrypt _ iv _ offset , encrypt _ iv , buf , tempbuf ) ; break ; case cipher _ bf :
else { outlength = length ; if ( disposed ) { throw new object _ disposed _ exception ( this . to _ string ( ) ) ; } switch ( cipher ) { case cipher _ aes :
if ( disposed ) { throw new object _ disposed _ exception ( this . to _ string ( ) ) ; } switch ( cipher ) { case cipher _ aes : polar _ ssl . aes _ crypt _ cfb ( encrypt _ ctx , polar _ ssl . aes _ encrypt , length , encrypt _ iv _ offset , encrypt _ iv , buf , outbuf ) ; break ; case cipher _ bf :
lock ( tempbuf ) { buffer . block _ copy ( buf , iv _ len , tempbuf , 0 , length - iv _ len ) ; if ( disposed ) { throw new object _ disposed _ exception ( this . to _ string ( ) ) ; } switch ( cipher ) { case cipher _ aes :
if ( disposed ) { throw new object _ disposed _ exception ( this . to _ string ( ) ) ; } switch ( cipher ) { case cipher _ aes : polar _ ssl . aes _ crypt _ cfb ( decrypt _ ctx , polar _ ssl . aes _ decrypt , length - iv _ len , decrypt _ iv _ offset , decrypt _ iv , tempbuf , outbuf ) ; break ; case cipher _ bf :
else { outlength = length ; if ( disposed ) { throw new object _ disposed _ exception ( this . to _ string ( ) ) ; } switch ( cipher ) { case cipher _ aes :
if ( disposed ) { throw new object _ disposed _ exception ( this . to _ string ( ) ) ; } switch ( cipher ) { case cipher _ aes : polar _ ssl . aes _ crypt _ cfb ( decrypt _ ctx , polar _ ssl . aes _ decrypt , length , decrypt _ iv _ offset , decrypt _ iv , buf , outbuf ) ; break ; case cipher _ bf :
this . ok _ button . margin = new system . windows . forms . padding ( NUM , NUM , NUM , 0 ) ; this . ok _ button . name = STR ; this . ok _ button . size = new system . drawing . size ( NUM , NUM ) ; this . ok _ button . tab _ index = NUM ; this . ok _ button . text = STR ; this . ok _ button . use _ visual _ style _ back _ color = true ; this . ok _ button . click + = new system . event _ handler ( this . ok _ button _ click ) ; this . my _ cancel _ button . dialog _ result = system . windows . forms . dialog _ result . cancel ; this . my _ cancel _ button . dock = system . windows . forms . dock _ style . right ; this . my _ cancel _ button . location = new system . drawing . point ( NUM , NUM ) ;
using system ;
using system ; using system _ collections _ generic ; using system _ component _ model ; using system _ drawing ;
using system ; using system _ collections _ generic ; using system _ component _ model ; using system _ drawing ; using system _ text ; using system _ windows _ forms ;
using system ; using system _ collections _ generic ; using system _ component _ model ; using system _ drawing ; using system _ text ; using system _ windows _ forms ; using system _ diagnostics ; using microsoft _ win ; using shadowsocks _ controller ; using shadowsocks _ model ; using shadowsocks _ properties ;
if ( ! parsed ) { ip _ host _ entry ip _ host _ info = dns . get _ host _ entry ( server . server ) ; ip _ address = ip _ host _ info . address _ list [ 0 ] ; } remote _ end _ point = new ip _ end _ point ( ip _ address , server . server _ port ) ; remote = new socket ( remote _ end _ point . address _ family , socket _ type . dgram , protocol _ type . udp ) ; } public void send ( byte [ ] data , int length ) {
remote _ end _ point = new ip _ end _ point ( ip _ address , server . server _ port ) ; remote = new socket ( remote _ end _ point . address _ family , socket _ type . dgram , protocol _ type . udp ) ; } public void send ( byte [ ] data , int length ) { i _ encryptor encryptor = encryptor _ factory . get _ encryptor ( server . method , server . password , server . one _ time _ auth ) ; byte [ ] data _ in = new byte [ length - NUM + iv _ encryptor . onetimeauth _ bytes ] ; array . copy ( data , NUM , data _ in , 0 , length - NUM ) ; byte [ ] data _ out = new byte [ length - NUM + NUM + iv _ encryptor . onetimeauth _ bytes ] ; int outlen ;
counter + + ; } protected byte [ ] gen _ hash ( byte [ ] buf , int offset , int len ) { byte [ ] hash = new byte [ NUM ] ; update _ key _ buffer ( ) ; sodium . ss _ sha _ hmac _ ex ( key _ buffer , ( uint ) key _ buffer . length , buf , offset , ( uint ) len , hash ) ; return hash ; }
byte [ ] hash = new byte [ NUM ] ; update _ key _ buffer ( ) ; sodium . ss _ sha _ hmac _ ex ( key _ buffer , ( uint ) key _ buffer . length , buf , offset , ( uint ) len , hash ) ; return hash ; } public override void encrypt ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength , bool udp ) { if ( ! encrypt _ iv _ sent ) {
} public override void encrypt ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength , bool udp ) { if ( ! encrypt _ iv _ sent ) { encrypt _ iv _ sent = true ; rand _ bytes ( outbuf , iv _ len ) ; init _ cipher ( outbuf , true ) ; outlength = length + iv _ len ;
} lock ( tempbuf ) { cipher _ update ( true , length , buf , tempbuf ) ; outlength = length + iv _ len ; buffer . block _ copy ( tempbuf , 0 , outbuf , iv _ len , length ) ; } } else {
using system _ security _ cryptography ; using system _ text ; namespace shadowsocks _ encryption { public abstract class encryptor _ base : i _ encryptor { public const int max _ input _ size = NUM ;
protected string method ; protected string password ; protected bool onetime _ auth ; protected byte [ ] get _ password _ hash ( ) { byte [ ] input _ bytes = encoding . ut . get _ bytes ( password ) ; byte [ ] hash = m . create ( ) . compute _ hash ( input _ bytes ) ; return hash ; }
} foreach ( string method in polar _ ssl _ encryptor . supported _ ciphers ( ) ) { registered _ encryptors . add ( method , typeof ( polar _ ssl _ encryptor ) ) ; } foreach ( string method in sodium _ encryptor . supported _ ciphers ( ) ) { registered _ encryptors . add ( method , typeof ( sodium _ encryptor ) ) ; } }
} public static i _ encryptor get _ encryptor ( string method , string password , bool onetimeauth ) { if ( string . is _ null _ or _ empty ( method ) ) { method = STR ; } method = method . to _ lower _ invariant ( ) ; type t = registered _ encryptors [ method ] ; constructor _ info c = t . get _ constructor ( constructor _ types ) ;
} private void run _ encryption _ round ( i _ encryptor encryptor , i _ encryptor decryptor ) { byte [ ] plain = new byte [ NUM ] ; byte [ ] cipher = new byte [ plain . length + NUM + iv _ encryptor . onetimeauth _ bytes + iv _ encryptor . auth _ bytes ] ; byte [ ] plain = new byte [ plain . length + NUM ] ; int out _ len = 0 ; int out _ len = 0 ; var random = new random ( ) ; random . next _ bytes ( plain ) ;
int out _ len = 0 ; var random = new random ( ) ; random . next _ bytes ( plain ) ; encryptor . encrypt ( plain , plain . length , cipher , out out _ len , false ) ; decryptor . decrypt ( cipher , out _ len , plain , out out _ len ) ; assert . are _ equal ( plain . length , out _ len ) ; for ( int j = 0 ; j < plain . length ; j + + ) { assert . are _ equal ( plain [ j ] , plain [ j ] ) ; }
{ assert . are _ equal ( plain [ j ] , plain [ j ] ) ; } encryptor . encrypt ( plain , NUM , cipher , out out _ len , false ) ; decryptor . decrypt ( cipher , out _ len , plain , out out _ len ) ; assert . are _ equal ( NUM , out _ len ) ; for ( int j = 0 ; j < out _ len ; j + + ) { assert . are _ equal ( plain [ j ] , plain [ j ] ) ; }
this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ; this . text _ box = new system . windows . forms . text _ box ( ) ; this . text _ box = new system . windows . forms . text _ box ( ) ; this . text _ box = new system . windows . forms . text _ box ( ) ; this . text _ box = new system . windows . forms . text _ box ( ) ; this . panel = new system . windows . forms . panel ( ) ; this . button = new system . windows . forms . button ( ) ;
this . button . dialog _ result = system . windows . forms . dialog _ result . ok ; this . button . location = new system . drawing . point ( NUM , NUM ) ; this . button . name = STR ; this . button . size = new system . drawing . size ( NUM , NUM ) ; this . button . tab _ index = 0 ; this . button . text = STR ; this . button . use _ visual _ style _ back _ color = true ;
{ public const string date _ time _ pattern = STR ; private const string statistics _ files _ name = STR ; public static string availability _ statistics _ file ; static availability _ statistics ( ) { availability _ statistics _ file = utils . get _ temp _ path ( statistics _ files _ name ) ; } private int repeat = > config . repeat _ times _ num ; public const int timeout _ milliseconds = NUM ;
public const string date _ time _ pattern = STR ; private const string statistics _ files _ name = STR ; public static string availability _ statistics _ file ; static availability _ statistics ( ) { availability _ statistics _ file = utils . get _ temp _ path ( statistics _ files _ name ) ; } private int repeat = > config . repeat _ times _ num ; public const int timeout _ milliseconds = NUM ; private list < int > latency _ records ;
public const int timeout _ milliseconds = NUM ; private list < int > latency _ records ; private long last _ inbound _ counter ; private list < int > inbound _ speed _ records ; private long last _ outbound _ counter ; private list < int > outbound _ speed _ records ; private readonly time _ span delay _ before _ start = time _ span . from _ seconds ( 1 ) ; private readonly time _ span retry _ interval = time _ span . from _ minutes ( 2 ) ; private timer recorder ; private time _ span recording _ interval = > time _ span . from _ minutes ( config . data _ collection _ minutes ) ; private timer speed _ monior ; private readonly time _ span monitor _ interval = time _ span . from _ seconds ( 1 ) ;
private list < int > outbound _ speed _ records ; private readonly time _ span delay _ before _ start = time _ span . from _ seconds ( 1 ) ; private readonly time _ span retry _ interval = time _ span . from _ minutes ( 2 ) ; private timer recorder ; private time _ span recording _ interval = > time _ span . from _ minutes ( config . data _ collection _ minutes ) ; private timer speed _ monior ; private readonly time _ span monitor _ interval = time _ span . from _ seconds ( 1 ) ; private timer writer ; private readonly time _ span writing _ interval = time _ span . from _ minutes ( 1 ) ; private shadowsocks _ controller controller ; private statistics _ strategy _ configuration config = > controller . statistics _ configuration ;
{ controller = controller ; reset ( ) ; try { if ( config . statistics _ enabled ) { start _ timer _ without _ state ( ref recorder , run , recording _ interval ) ; load _ raw _ statistics ( ) ; start _ timer _ without _ state ( ref speed _ monior , update _ speed , monitor _ interval ) ;
{ start _ timer _ without _ state ( ref recorder , run , recording _ interval ) ; load _ raw _ statistics ( ) ; start _ timer _ without _ state ( ref speed _ monior , update _ speed , monitor _ interval ) ; start _ timer _ without _ state ( ref writer , save , writing _ interval ) ; } else { recorder ? . dispose ( ) ; speed _ monior ? . dispose ( ) ;
} catch ( exception e ) { logging . error ( $ STR ) ; logging . log _ useful _ exception ( e ) ; } return result ; } private void reset ( ) {
} private void run ( object ) { update _ records ( ) ; reset ( ) ; filter _ raw _ statistics ( ) ; } private async void update _ records ( ) {
} private async void update _ records ( ) { var current _ server _ record = new statistics _ record ( current _ server . identifier ( ) , inbound _ speed _ records , outbound _ speed _ records , latency _ records ) ; if ( ! config . ping ) { append _ record ( current _ server , current _ server _ record ) ; return ; }
var current _ server _ record = new statistics _ record ( current _ server . identifier ( ) , inbound _ speed _ records , outbound _ speed _ records , latency _ records ) ; if ( ! config . ping ) { append _ record ( current _ server , current _ server _ record ) ; return ; } { records = new list < statistics _ record > ( ) ; } records . add ( record ) ; raw _ statistics [ server . identifier ( ) ] = records ; } private void save ( object ) { try {
} private void save ( object ) { try { file . write _ all _ text ( availability _ statistics _ file , json _ convert . serialize _ object ( raw _ statistics , formatting . none ) ) ; } catch ( io _ exception e ) { logging . log _ useful _ exception ( e ) ;
internal readonly list < int? > roundtrip _ time = new list < int? > ( ) ; internal readonly server server ; internal icmp _ result ( server server ) { server = server ; } } public void dispose ( ) { recorder . dispose ( ) ;
public void toggle _ checking _ update ( bool enabled ) { config . auto _ check _ update = enabled ; configuration . save ( config ) ; } public void save _ log _ viewer _ config ( log _ viewer _ config new _ config ) { config . log _ viewer = new _ config ; configuration . save ( config ) ; }
} public void save _ log _ viewer _ config ( log _ viewer _ config new _ config ) { config . log _ viewer = new _ config ; configuration . save ( config ) ; } public void update _ inbound _ counter ( long n ) { interlocked . add ( ref inbound _ counter , n ) ;
using system ; using system _ collections _ generic ; using system _ linq ; using system _ text ; namespace shadowsocks _ model { public class statistics _ record { public date _ time timestamp { get ; set ; } = date _ time . now ;
public int? max _ response ; public float? package _ loss ; public statistics _ record ( ) { }
public statistics _ record ( ) { } public statistics _ record ( string identifier , i _ enumerable < int > inbound _ speed _ records , i _ enumerable < int > outbound _ speed _ records , i _ enumerable < int > latency _ records ) {
} if ( latency _ records ! = null & & latency _ records . any ( ) ) { average _ latency = ( int ) latency _ records . average ( ) ; min _ latency = latency _ records . min ( ) ; max _ latency = latency _ records . max ( ) ; } } public statistics _ record ( string identifier , i _ enumerable < int? > response _ records ) {
average _ latency = ( int ) latency _ records . average ( ) ; min _ latency = latency _ records . min ( ) ; max _ latency = latency _ records . max ( ) ; } } public statistics _ record ( string identifier , i _ enumerable < int? > response _ records ) { server _ name = identifier ; set _ response ( response _ records ) ; }
set _ response ( response _ records ) ; } public void set _ response ( i _ enumerable < int? > response _ records ) { if ( response _ records = = null ) return ; var records = response _ records . where ( response = > response ! = null ) . select ( response = > response . value ) . to _ list ( ) ; if ( ! records . any ( ) ) return ; average _ response = ( int? ) records . average ( ) ; min _ response = records . min ( ) ; max _ response = records . max ( ) ;
load _ statistics ( ) ; choose _ new _ server ( servers ) ; } private void load _ statistics ( ) { filtered _ statistics = service . filtered _ statistics ? ? service . raw _ statistics ? ? filtered _ statistics ; }
private void load _ statistics ( ) { filtered _ statistics = service . filtered _ statistics ? ? service . raw _ statistics ? ? filtered _ statistics ; } private float get _ score ( string server _ name ) { var config = controller . statistics _ configuration ;
this . by _ hour _ of _ day _ check _ box = new system . windows . forms . check _ box ( ) ; this . repeat _ times _ num = new system . windows . forms . numeric _ up _ down ( ) ; this . label = new system . windows . forms . label ( ) ; this . split _ container = new system . windows . forms . split _ container ( ) ; this . label = new system . windows . forms . label ( ) ; this . calculation _ container = new system . windows . forms . flow _ layout _ panel ( ) ; this . server _ selector = new system . windows . forms . combo _ box ( ) ; this . cancel _ button = new system . windows . forms . button ( ) ; this . ok _ button = new system . windows . forms . button ( ) ; this . calculatin _ tip = new system . windows . forms . tool _ tip ( this . components ) ;
this . add _ button . use _ visual _ style _ back _ color = true ; this . add _ button . click + = new system . event _ handler ( this . add _ button _ click ) ; this . server _ group _ box . controls . add ( this . table _ layout _ panel ) ; this . server _ group _ box . location = new system . drawing . point ( NUM , NUM ) ; this . server _ group _ box . name = STR ; this . server _ group _ box . size = new system . drawing . size ( NUM , NUM ) ; this . server _ group _ box . tab _ index = NUM ; this . server _ group _ box . tab _ stop = false ; this . server _ group _ box . text = STR ; this . servers _ list _ box . formatting _ enabled = true ;
this . server _ group _ box . tab _ index = NUM ; this . server _ group _ box . tab _ stop = false ; this . server _ group _ box . text = STR ; this . servers _ list _ box . formatting _ enabled = true ; this . servers _ list _ box . item _ height = NUM ; this . servers _ list _ box . location = new system . drawing . point ( NUM , NUM ) ; this . servers _ list _ box . name = STR ; this . servers _ list _ box . size = new system . drawing . size ( NUM , NUM ) ; this . servers _ list _ box . tab _ index = NUM ; this . servers _ list _ box . selected _ index _ changed + = new system . event _ handler ( this . servers _ list _ box _ selected _ index _ changed ) ;
public class n { protected static dictionary < string , string > strings ; static n ( ) { strings = new dictionary < string , string > ( ) ; if ( culture _ info . current _ culture . ietf _ language _ tag . starts _ with ( STR , string _ comparison . ordinal _ ignore _ case ) ) { using ( var sr = new string _ reader ( resources . cn ) ) {
protected static dictionary < string , string > strings ; static n ( ) { strings = new dictionary < string , string > ( ) ; if ( culture _ info . current _ culture . ietf _ language _ tag . starts _ with ( STR , string _ comparison . ordinal _ ignore _ case ) ) { using ( var sr = new string _ reader ( resources . cn ) ) { string line ; while ( ( line = sr . read _ line ( ) ) ! = null ) {
using system ; using system _ collections _ generic ; using system _ text ; using system _ net _ sockets ; using system _ net ; namespace shadowsocks _ csharp { class local {
using system _ text ; using system _ net _ sockets ; using system _ net ; namespace shadowsocks _ csharp { class local { private int port ; private encryptor encryptor ; socket listener ;
socket listener ; public local ( int port ) { this . port = port ; this . encryptor = new encryptor ( STR ) ; } public void start ( ) { listener = new socket ( address _ family . inter _ network , socket _ type . stream , protocol _ type . tcp ) ;
public encryptor encryptor ; public socket remote ; public socket connection ; public const int buffer _ size = NUM ; public byte [ ] remote _ buffer = new byte [ buffer _ size ] ; public byte [ ] connetion _ buffer = new byte [ buffer _ size ] ; public string _ builder sb = new string _ builder ( ) ; public void start ( ) {
public socket remote ; public socket connection ; public const int buffer _ size = NUM ; public byte [ ] remote _ buffer = new byte [ buffer _ size ] ; public byte [ ] connetion _ buffer = new byte [ buffer _ size ] ; public string _ builder sb = new string _ builder ( ) ; public void start ( ) { ip _ host _ entry ip _ host _ info = dns . get _ host _ entry ( STR ) ; ip _ address ip _ address = ip _ host _ info . address _ list [ 0 ] ;
string argument = STR + e . path ; process . start ( STR , argument ) ; } void show _ balloon _ tip ( string title , string content , tool _ tip _ icon icon , int timeout ) { notify _ icon . balloon _ tip _ title = title ; notify _ icon . balloon _ tip _ text = content ; notify _ icon . balloon _ tip _ icon = icon ; notify _ icon . show _ balloon _ tip ( timeout ) ; }
notify _ icon . balloon _ tip _ title = title ; notify _ icon . balloon _ tip _ text = content ; notify _ icon . balloon _ tip _ icon = icon ; notify _ icon . show _ balloon _ tip ( timeout ) ; } void controller _ update _ pac _ from _ gfw _ list _ error ( object sender , system . io . error _ event _ args e ) { show _ balloon _ tip ( n . get _ string ( STR ) , e . get _ exception ( ) . message , tool _ tip _ icon . error , NUM ) ; logger . log _ useful _ exception ( e . get _ exception ( ) ) ; }
private void update _ system _ proxy ( ) { system _ proxy . update ( config , false , pac _ server ) ; } private void pac _ daemon _ pac _ file _ changed ( object sender , event _ args e ) { update _ system _ proxy ( ) ; } private void pac _ server _ pac _ update _ completed ( object sender , geosite _ result _ event _ args e ) {
private void pac _ daemon _ pac _ file _ changed ( object sender , event _ args e ) { update _ system _ proxy ( ) ; } private void pac _ server _ pac _ update _ completed ( object sender , geosite _ result _ event _ args e ) { update _ pac _ from _ gfw _ list _ completed ? . invoke ( this , e ) ; } private void pac _ server _ pac _ update _ error ( object sender , error _ event _ args e ) {
public const int internet _ option _ settings _ changed = NUM ; public const int internet _ option _ refresh = NUM ; static bool settings _ return , refresh _ return ; public static void notify _ ie ( ) { settings _ return = internet _ set _ option ( int _ ptr . zero , internet _ option _ settings _ changed , int _ ptr . zero , 0 ) ; refresh _ return = internet _ set _ option ( int _ ptr . zero , internet _ option _ refresh , int _ ptr . zero , 0 ) ; } public static void enable ( ) {
registry _ key registry = registry . current _ user . open _ sub _ key ( STR , true ) ; registry . set _ value ( STR , 0 ) ; registry . set _ value ( STR , STR ) ; registry . set _ value ( STR , STR + get _ timestamp ( date _ time . now ) ) ; system _ proxy . notify _ ie ( ) ; } public static void disable ( ) {
update _ completed ? . invoke ( this , new result _ event _ args ( pac _ file _ changed ) ) ; } catch ( exception ex ) { error ? . invoke ( this , new error _ event _ args ( ex ) ) ; } } public static bool merge _ and _ write _ pac _ file ( string gfw _ list _ result ) { string abp _ content = merge _ pac _ file ( gfw _ list _ result ) ;
catch ( exception ex ) { error ? . invoke ( this , new error _ event _ args ( ex ) ) ; } } public static bool merge _ and _ write _ pac _ file ( string gfw _ list _ result ) { string abp _ content = merge _ pac _ file ( gfw _ list _ result ) ; if ( file . exists ( pac _ server . pac _ file ) ) {
{ string abp _ content = merge _ pac _ file ( gfw _ list _ result ) ; if ( file . exists ( pac _ server . pac _ file ) ) { string original = file _ manager . non _ exclusive _ read _ all _ text ( pac _ server . pac _ file , encoding . ut ) ; if ( original = = abp _ content ) { return false ; } }
private void stop _ plugins ( ) { foreach ( var server _ and _ plugin in plugins _ by _ server ) { server _ and _ plugin . value ? . dispose ( ) ; } plugins _ by _ server . clear ( ) ; } public void touch _ pac _ file ( ) {
} plugins _ by _ server . clear ( ) ; } public void touch _ pac _ file ( ) { string pac _ filename = pac _ server . touch _ pac _ file ( ) ; pac _ file _ ready _ to _ open ? . invoke ( this , new path _ event _ args ( ) { path = pac _ filename } ) ; } public void touch _ user _ rule _ file ( ) {
privoxy _ runner = new privoxy _ runner ( ) ; } if ( pac _ server = = null ) {
using system _ text ; using shadowsocks _ encryption ; using shadowsocks _ model ; using shadowsocks _ properties ; using shadowsocks _ util ; using system _ threading _ tasks ; namespace shadowsocks _ controller { public class pac _ server : listener . service {
using shadowsocks _ properties ; using shadowsocks _ util ; using system _ threading _ tasks ; namespace shadowsocks _ controller { public class pac _ server : listener . service { public const string pac _ file = STR ; public const string user _ rule _ file = STR ; public const string user _ abp _ file = STR ; private string pac _ secret { get ; set ; } = STR ; public string pac _ url { get ; private set ; } = STR ;
using system _ threading _ tasks ; namespace shadowsocks _ controller { public class pac _ server : listener . service { public const string pac _ file = STR ; public const string user _ rule _ file = STR ; public const string user _ abp _ file = STR ; private string pac _ secret { get ; set ; } = STR ; public string pac _ url { get ; private set ; } = STR ; file _ system _ watcher pac _ file _ watcher ; file _ system _ watcher user _ rule _ file _ watcher ; private configuration config ;
public class pac _ server : listener . service { public const string pac _ file = STR ; public const string user _ rule _ file = STR ; public const string user _ abp _ file = STR ; private string pac _ secret { get ; set ; } = STR ; public string pac _ url { get ; private set ; } = STR ; file _ system _ watcher pac _ file _ watcher ; file _ system _ watcher user _ rule _ file _ watcher ; private configuration config ; public event event _ handler pac _ file _ changed ; public event event _ handler user _ rule _ file _ changed ; public pac _ server ( ) {
public const string user _ abp _ file = STR ; private string pac _ secret { get ; set ; } = STR ; public string pac _ url { get ; private set ; } = STR ; file _ system _ watcher pac _ file _ watcher ; file _ system _ watcher user _ rule _ file _ watcher ; private configuration config ; public event event _ handler pac _ file _ changed ; public event event _ handler user _ rule _ file _ changed ; public pac _ server ( ) { this . watch _ pac _ file ( ) ; this . watch _ user _ rule _ file ( ) ; }
if ( socket . protocol _ type ! = protocol _ type . tcp ) { return false ; } try { string request = encoding . ut . get _ string ( first _ packet , 0 , length ) ; string [ ] lines = request . split ( '\r' , '\n' ) ; bool host _ match = false , path _ match = false , use _ socks = false ; bool secret _ match = pac _ secret . is _ null _ or _ empty ( ) ;
return false ; } try { string request = encoding . ut . get _ string ( first _ packet , 0 , length ) ; string [ ] lines = request . split ( '\r' , '\n' ) ; bool host _ match = false , path _ match = false , use _ socks = false ; bool secret _ match = pac _ secret . is _ null _ or _ empty ( ) ; foreach ( string line in lines ) {
string [ ] kv = line . split ( new char [ ] { ':' } , 2 ) ; if ( kv . length = = 2 ) { if ( kv [ 0 ] = = STR ) { if ( kv [ 1 ] . trim ( ) = = ( ( ip _ end _ point ) socket . local _ end _ point ) . to _ string ( ) ) { host _ match = true ; } }
} return true ; } return false ; } catch ( argument _ exception ) { return false ; } }
return false ; } } { return utils . un _ gzip ( resources . proxy _ pac _ txt ) ; } } public void send _ response ( socket socket , bool use _ socks ) { try { ip _ end _ point local _ end _ point = ( ip _ end _ point ) socket . local _ end _ point ; string proxy = get _ pac _ address ( local _ end _ point , use _ socks ) ;
var i = interlocked . read ( ref inbound ) ; var il = interlocked . exchange ( ref last _ inbound , i ) ; inbound _ delta = i - il ; var o = interlocked . read ( ref outbound ) ; var ol = interlocked . exchange ( ref last _ outbound , o ) ; outbound _ delta = o - ol ; } } private readonly time _ span delay _ before _ start = time _ span . from _ seconds ( 1 ) ; private readonly time _ span retry _ interval = time _ span . from _ minutes ( 2 ) ;
inbound _ delta = i - il ; var o = interlocked . read ( ref outbound ) ; var ol = interlocked . exchange ( ref last _ outbound , o ) ; outbound _ delta = o - ol ; } } private readonly time _ span delay _ before _ start = time _ span . from _ seconds ( 1 ) ; private readonly time _ span retry _ interval = time _ span . from _ minutes ( 2 ) ; private timer recorder ; private time _ span recording _ interval = > time _ span . from _ minutes ( config . data _ collection _ minutes ) ;
raw _ statistics = new statistics ( ) ; } internal void update _ configuration ( shadowsocks _ controller controller ) { controller = controller ; reset ( ) ; try { if ( config . statistics _ enabled ) {
internal void update _ configuration ( shadowsocks _ controller controller ) { controller = controller ; reset ( ) ; try { if ( config . statistics _ enabled ) { start _ timer _ without _ state ( ref recorder , run , recording _ interval ) ; load _ raw _ statistics ( ) ;
{ if ( config . statistics _ enabled ) { start _ timer _ without _ state ( ref recorder , run , recording _ interval ) ; load _ raw _ statistics ( ) ; start _ timer _ without _ state ( ref speed _ monior , update _ speed , monitor _ interval ) ; } else {
else { recorder ? . dispose ( ) ; speed _ monior ? . dispose ( ) ; } } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; } }
logging . debug ( $ STR ) ; } } private void reset ( ) { inbound _ speed _ records . clear ( ) ; outbound _ speed _ records . clear ( ) ; latency _ records . clear ( ) ; }
} private void run ( object ) { update _ records ( ) ; reset ( ) ; } private void update _ records ( ) { var records = new dictionary < string , statistics _ record > ( ) ; update _ records _ state state = new update _ records _ state ( ) ;
if ( ! record . timestamp . hour . equals ( date _ time . now . hour ) ) return false ; } return true ; } private void filter _ raw _ statistics ( ) { try { logging . debug ( STR ) ; if ( raw _ statistics = = null ) return ;
{ try { logging . debug ( STR ) ; if ( raw _ statistics = = null ) return ; if ( filtered _ statistics = = null ) { filtered _ statistics = new statistics ( ) ; } foreach ( var server _ and _ records in raw _ statistics ) { var server = server _ and _ records . key ; var filtered _ records = server _ and _ records . value . find _ all ( is _ valid _ record ) ;
using ( file . create ( path ) ) { } } var content = file . read _ all _ text ( path ) ; raw _ statistics = json _ convert . deserialize _ object < statistics > ( content ) ? ? raw _ statistics ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ;
recorder . change ( retry _ interval , recording _ interval ) ; } } private static int get _ speed _ in _ ki _ b _ per _ second ( long bytes , double seconds ) { var result = ( int ) ( bytes / seconds ) / NUM ; return result ; } public void dispose ( ) {
using shadowsocks _ model ; using shadowsocks _ properties ; using shadowsocks _ util ; using system _ threading _ tasks ; namespace shadowsocks _ controller { public class pac _ server : listener . service { public const string resource _ name = STR ;
private string pac _ secret { get ; set ; } = STR ; public string pac _ url { get ; private set ; } = STR ; private configuration config ; private pac _ daemon pac _ daemon ; public pac _ server ( pac _ daemon pac _ daemon ) { pac _ daemon = pac _ daemon ; } public void update _ pacurl ( configuration config ) {
pac _ secret = STR ; } pac _ url = $ STR ; } private static string get _ hash ( string content ) { var content _ bytes = encoding . ascii . get _ bytes ( content ) ; using ( var md = system . security . cryptography . m . create ( ) ) { var md _ bytes = md . compute _ hash ( content _ bytes ) ;
using system ; using system _ collections _ generic ; using system _ globalization ; using system _ io ; namespace shadowsocks _ controller { using shadowsocks _ properties ;
using system ; using system _ collections _ generic ; using system _ globalization ; using system _ io ; namespace shadowsocks _ controller { using shadowsocks _ properties ; public class n {
continue ; var pos = line . index _ of ( '=' ) ; if ( pos < 1 ) continue ; strings [ line . substring ( 0 , pos ) ] = line . substring ( pos + 1 ) ; } } } static n ( ) {
continue ; strings [ line . substring ( 0 , pos ) ] = line . substring ( pos + 1 ) ; } } } static n ( ) { strings = new dictionary < string , string > ( ) ; string name = culture _ info . current _ culture . name ; if ( name . starts _ with ( STR ) ) {
{ strings = new dictionary < string , string > ( ) ; string name = culture _ info . current _ culture . name ; if ( name . starts _ with ( STR ) ) { init ( resources . cn ) ; } else { init ( resources . zh _ tw ) ; } } } public static string get _ string ( string key ) {
} } } static n ( ) { string n ; string locale = culture _ info . current _ culture . name ; if ( ! file . exists ( n _ file ) ) { n = resources . n _ csv ;

using system ; using system _ diagnostics ; using system _ drawing ;
using system ; using system _ diagnostics ; using system _ drawing ; using system _ drawing _ imaging ; using system _ windows _ forms ; using z _ xing ; using z _ xing _ common ; using z _ xing _ qr _ code ;
gfw _ list _ updater . error + = pac _ server _ pac _ update _ error ; } if ( listener ! = null ) { listener . stop ( ) ; } polipo _ runner . stop ( ) ; try { polipo _ runner . start ( config ) ;
{ listener . stop ( ) ; } polipo _ runner . stop ( ) ; try { polipo _ runner . start ( config ) ; local local = new local ( config ) ; list < listener . service > services = new list < listener . service > ( ) ;
using system _ net ; using system _ net _ network _ information ; using system _ net _ sockets ; using system _ text ; namespace shadowsocks _ controller { public class listener { public interface service {
{ public class listener { public interface service { bool handle ( byte [ ] first _ packet , int length , socket socket ) ; } configuration config ; bool share _ over _ lan ;
return false ; } public void start ( configuration config ) { this . config = config ; this . share _ over _ lan = config . share _ over _ lan ; if ( check _ if _ port _ in _ use ( config . local _ port ) ) throw new exception ( n . get _ string ( STR ) ) ; try {
socket . set _ socket _ option ( socket _ option _ level . socket , socket _ option _ name . reuse _ address , true ) ; ip _ end _ point local _ end _ point = null ; if ( share _ over _ lan ) { local _ end _ point = new ip _ end _ point ( ip _ address . any , config . local _ port ) ; } else { local _ end _ point = new ip _ end _ point ( ip _ address . loopback , config . local _ port ) ; }
{ local _ end _ point = new ip _ end _ point ( ip _ address . any , config . local _ port ) ; } else { local _ end _ point = new ip _ end _ point ( ip _ address . loopback , config . local _ port ) ; } socket . bind ( local _ end _ point ) ; socket . listen ( NUM ) ; console . write _ line ( STR ) ;
} else { local _ end _ point = new ip _ end _ point ( ip _ address . loopback , config . local _ port ) ; } socket . bind ( local _ end _ point ) ; socket . listen ( NUM ) ; console . write _ line ( STR ) ; socket . begin _ accept ( new async _ callback ( accept _ callback ) ,
socket . bind ( local _ end _ point ) ; socket . listen ( NUM ) ; console . write _ line ( STR ) ; socket . begin _ accept ( new async _ callback ( accept _ callback ) , socket ) ; } catch ( socket _ exception ) {
socket ) ; } catch ( socket _ exception ) { socket . close ( ) ; throw ; } } public void stop ( ) {
catch ( socket _ exception ) { socket . close ( ) ; throw ; } } public void stop ( ) { if ( socket ! = null ) {
private void receive _ callback ( i _ async _ result ar ) { object [ ] state = ( object [ ] ) ar . async _ state ; socket conn = ( socket ) state [ 0 ] ; byte [ ] buf = ( byte [ ] ) state [ 1 ] ; try { int bytes _ read = conn . end _ receive ( ar ) ; foreach ( service service in services ) {
try { int bytes _ read = conn . end _ receive ( ar ) ; foreach ( service service in services ) { if ( service . handle ( buf , bytes _ read , conn ) ) { return ; } }
using system ; using system _ collections _ generic ; using system _ text ; using system _ net _ sockets ; using system _ net ; using shadowsocks _ encryption ; using shadowsocks _ model ; namespace shadowsocks _ controller {
using system _ text ; using system _ net _ sockets ; using system _ net ; using shadowsocks _ encryption ; using shadowsocks _ model ; namespace shadowsocks _ controller { class local : listener . service { private configuration config ;
using shadowsocks _ model ; namespace shadowsocks _ controller { class local : listener . service { private configuration config ; public local ( configuration config ) { this . config = config ; }
private configuration config ; public event event _ handler pac _ file _ changed ; public pac _ server ( ) { this . watch _ pac _ file ( ) ; } public void update _ configuration ( configuration config ) { this . config = config ; }
using system _ text ; namespace shadowsocks _ controller { class port _ forwarder : listener . service { int target _ port ; public port _ forwarder ( int target _ port ) { this . target _ port = target _ port ; }
using system ; using system _ net ; using system _ net _ sockets ; namespace shadowsocks _ proxy { public interface i _ proxy { end _ point local _ end _ point { get ; } end _ point proxy _ end _ point { get ; } end _ point dest _ end _ point { get ; }
using system _ net _ sockets ; namespace shadowsocks _ proxy { public interface i _ proxy { end _ point local _ end _ point { get ; } end _ point proxy _ end _ point { get ; } end _ point dest _ end _ point { get ; } i _ async _ result begin _ connect _ proxy ( end _ point remote _ ep , async _ callback callback , object state ) ; void end _ connect _ proxy ( i _ async _ result async _ result ) ;
{ public interface i _ proxy { end _ point local _ end _ point { get ; } end _ point proxy _ end _ point { get ; } end _ point dest _ end _ point { get ; } i _ async _ result begin _ connect _ proxy ( end _ point remote _ ep , async _ callback callback , object state ) ; void end _ connect _ proxy ( i _ async _ result async _ result ) ; i _ async _ result begin _ connect _ dest ( end _ point remote _ ep , async _ callback callback , object state ) ; void end _ connect _ dest ( i _ async _ result async _ result ) ;
end _ point local _ end _ point { get ; } end _ point proxy _ end _ point { get ; } end _ point dest _ end _ point { get ; } i _ async _ result begin _ connect _ proxy ( end _ point remote _ ep , async _ callback callback , object state ) ; void end _ connect _ proxy ( i _ async _ result async _ result ) ; i _ async _ result begin _ connect _ dest ( end _ point remote _ ep , async _ callback callback , object state ) ; void end _ connect _ dest ( i _ async _ result async _ result ) ; i _ async _ result begin _ send ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) ; int end _ send ( i _ async _ result async _ result ) ;
} public bool is _ completed { get ; } = true ; public wait _ handle async _ wait _ handle { get ; } = null ; public object async _ state { get ; } public bool completed _ synchronously { get ; } = true ; } private socket remote ; public end _ point local _ end _ point = > remote . local _ end _ point ; public end _ point proxy _ end _ point { get ; private set ; } public end _ point dest _ end _ point { get ; private set ; }
} private socket remote ; public end _ point local _ end _ point = > remote . local _ end _ point ; public end _ point proxy _ end _ point { get ; private set ; } public end _ point dest _ end _ point { get ; private set ; } public i _ async _ result begin _ connect _ proxy ( end _ point remote _ ep , async _ callback callback , object state ) { proxy _ end _ point = remote _ ep ; var r = new fake _ async _ result ( state ) ; callback ? . invoke ( r ) ;
public i _ async _ result begin _ connect _ proxy ( end _ point remote _ ep , async _ callback callback , object state ) { proxy _ end _ point = remote _ ep ; var r = new fake _ async _ result ( state ) ; callback ? . invoke ( r ) ; return r ; } public void end _ connect _ proxy ( i _ async _ result async _ result ) { }
{ } public i _ async _ result begin _ connect _ dest ( end _ point remote _ ep , async _ callback callback , object state ) { if ( remote = = null ) { remote = new socket ( remote _ ep . address _ family , socket _ type . stream , protocol _ type . tcp ) ; remote . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; } dest _ end _ point = remote _ ep ;
remote = new socket ( remote _ ep . address _ family , socket _ type . stream , protocol _ type . tcp ) ; remote . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; } dest _ end _ point = remote _ ep ; return remote . begin _ connect ( remote _ ep , callback , state ) ; } public void end _ connect _ dest ( i _ async _ result async _ result ) { remote . end _ connect ( async _ result ) ; }
dest _ end _ point = remote _ ep ; return remote . begin _ connect ( remote _ ep , callback , state ) ; } public void end _ connect _ dest ( i _ async _ result async _ result ) { remote . end _ connect ( async _ result ) ; } public i _ async _ result begin _ send ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) {
} public i _ async _ result begin _ send ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) { return remote . begin _ send ( buffer , offset , size , socket _ flags , callback , state ) ; } public int end _ send ( i _ async _ result async _ result ) { return remote . end _ send ( async _ result ) ; }
{ return remote . begin _ send ( buffer , offset , size , socket _ flags , callback , state ) ; } public int end _ send ( i _ async _ result async _ result ) { return remote . end _ send ( async _ result ) ; } public i _ async _ result begin _ receive ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) {
{ return running _ port ; } } public void start ( configuration configuration ) { server server = configuration . get _ current _ server ( ) ; if ( process = = null ) { process [ ] existing _ polipo = process . get _ processes _ by _ name ( STR ) ;
process [ ] existing _ polipo = process . get _ processes _ by _ name ( STR ) ; foreach ( process p in existing _ polipo ) { kill _ process ( p ) ; } string polipo _ config = resources . privoxy _ conf ; running _ port = this . get _ free _ port ( ) ; polipo _ config = polipo _ config . replace ( STR , configuration . local _ port . to _ string ( ) ) ; polipo _ config = polipo _ config . replace ( STR , running _ port . to _ string ( ) ) ; polipo _ config = polipo _ config . replace ( STR , configuration . share _ over _ lan ? STR : STR ) ;
kill _ process ( p ) ; } string polipo _ config = resources . privoxy _ conf ; running _ port = this . get _ free _ port ( ) ; polipo _ config = polipo _ config . replace ( STR , configuration . local _ port . to _ string ( ) ) ; polipo _ config = polipo _ config . replace ( STR , running _ port . to _ string ( ) ) ; polipo _ config = polipo _ config . replace ( STR , configuration . share _ over _ lan ? STR : STR ) ; file _ manager . byte _ array _ to _ file ( utils . get _ temp _ path ( STR ) , encoding . ut . get _ bytes ( polipo _ config ) ) ; process = new process ( ) ; process . start _ info . file _ name = STR ;
public static string get _ temp _ path ( ) { if ( temp _ path = = null ) {
file _ mode . open , file _ access . read , file _ share . read _ write ) ) ) { if ( reader . base _ stream . length > back _ offset ) { reader . base _ stream . seek ( - back _ offset , seek _ origin . end ) ; reader . read _ line ( ) ; } string line = STR ; while ( ( line = reader . read _ line ( ) ) ! = null )
using ( stream _ reader reader = new stream _ reader ( new file _ stream ( filename , file _ mode . open , file _ access . read , file _ share . read _ write ) ) ) { reader . base _ stream . seek ( last _ offset , seek _ origin . begin ) ; string line = STR ; bool changed = false ; while ( ( line = reader . read _ line ( ) ) ! = null ) { changed = true ;
public bandwidth _ scale _ info ( float value , string unit _ name , long unit ) { this . value = value ; this . unit _ name = unit _ name ; this . unit = unit ; } } public static class utils { private static string temp _ path = null ;
{ private static string temp _ path = null ; STR , STR , } ; public static string get _ temp _ path ( ) { if ( temp _ path = = null ) { try {
} ; public static string get _ temp _ path ( ) { if ( temp _ path = = null ) { try { var temp _ folder = configuration . load ( ) . temp _ folder ; if ( string . is _ null _ or _ white _ space ( temp _ folder ) )
server . plugin _ opts = plugin _ options _ text _ box . text ; server . plugin _ args = plugin _ arguments _ text _ box . text ; server . remarks = remarks _ text _ box . text ; if ( ! int . try _ parse ( timeout _ text _ box . text , out server . timeout ) ) { message _ box . show ( n . get _ string ( STR ) ) ; timeout _ text _ box . focus ( ) ; return false ; } int local _ port = int . parse ( proxy _ port _ text _ box . text ) ;
$ STR ) ; } } catch ( exception ex ) { logging . error ( STR + ex . message ) ; throw ; } return plugin . local _ end _ point ; }
{ logging . error ( STR + ex . message ) ; throw ; } return plugin . local _ end _ point ; } public void save _ servers ( list < server > servers , int local _ port ) { config . configs = servers ; config . local _ port = local _ port ;

private system . windows . forms . label temp _ folder _ label ; private system . windows . forms . text _ box plugin _ arguments _ text _ box ; private system . windows . forms . label plugin _ arguments _ label ; private system . windows . forms . tool _ tip tool _ tip ;
close ( ) ; } } private void pipe _ remote _ send _ callback ( i _ async _ result ar ) { if ( closed ) return ; try { var session = ( async _ session ) ar . async _ state ; session . remote . end _ send ( ar ) ;
connection ? . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , socket _ flags . none , new async _ callback ( pipe _ connection _ receive _ callback ) , session ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; } } private void pipe _ connection _ send _ callback ( i _ async _ result ar ) {
logging . log _ useful _ exception ( e ) ; close ( ) ; } } private void pipe _ connection _ send _ callback ( i _ async _ result ar ) { if ( closed ) return ; try { var session = ( async _ session ) ar . async _ state ;
{ this . suspend _ layout ( ) ; this . auto _ scale _ mode = system . windows . forms . auto _ scale _ mode . none ;

using ( bitmap image = new bitmap ( screen . primary _ screen . bounds . width , screen . primary _ screen . bounds . height ) ) {
using ( bitmap image = new bitmap ( screen . primary _ screen . bounds . width , screen . primary _ screen . bounds . height ) ) { using ( graphics g = graphics . from _ image ( image ) ) { g . copy _ from _ screen ( screen . primary _ screen . bounds . x , screen . primary _ screen . bounds . y , 0 , 0 ,
screen . primary _ screen . bounds . height ) ) { using ( graphics g = graphics . from _ image ( image ) ) { g . copy _ from _ screen ( screen . primary _ screen . bounds . x , screen . primary _ screen . bounds . y , 0 , 0 , image . size , copy _ pixel _ operation . source _ copy ) ; }
using ( graphics g = graphics . from _ image ( image ) ) { g . copy _ from _ screen ( screen . primary _ screen . bounds . x , screen . primary _ screen . bounds . y , 0 , 0 , image . size , copy _ pixel _ operation . source _ copy ) ; } var reader = new barcode _ reader {
screen . primary _ screen . bounds . y , 0 , 0 , image . size , copy _ pixel _ operation . source _ copy ) ; } var reader = new barcode _ reader { try _ harder = true , possible _ formats = new list < barcode _ format > {
copy _ pixel _ operation . source _ copy ) ; } var reader = new barcode _ reader { try _ harder = true , possible _ formats = new list < barcode _ format > { barcode _ format . qr _ code }

min _ x - = margin ; max _ x + = margin ; min _ y - = margin ; max _ y + = margin ; qr _ code _ splash _ form splash = new qr _ code _ splash _ form ( ) ; splash . form _ closed + = splash _ form _ closed ; splash . location = new point ( ( int ) min _ x , ( int ) min _ y ) ;
max _ y + = margin ; qr _ code _ splash _ form splash = new qr _ code _ splash _ form ( ) ; splash . form _ closed + = splash _ form _ closed ; splash . location = new point ( ( int ) min _ x , ( int ) min _ y ) ; splash . size = new size ( ( int ) max _ x - ( int ) min _ x , ( int ) max _ y - ( int ) min _ y ) ; splash . show ( ) ; return ; } }
using system _ windows _ forms ; using shadowsocks _ controller ; using shadowsocks _ controller _ hotkeys ; using shadowsocks _ model ; using shadowsocks _ properties ; using shadowsocks _ util ; namespace shadowsocks _ view { public partial class hotkey _ settings _ form : form {
using shadowsocks _ controller _ hotkeys ; using shadowsocks _ model ; using shadowsocks _ properties ; using shadowsocks _ util ; namespace shadowsocks _ view { public partial class hotkey _ settings _ form : form { private shadowsocks _ controller controller ; private hotkey _ config modified _ config ;
{ public partial class hotkey _ settings _ form : form { private shadowsocks _ controller controller ; private hotkey _ config modified _ config ; private string _ builder sb = new string _ builder ( ) ; private i _ enumerable < text _ box > all _ text _ boxes ; private label lb = null ; private hot _ keys . hot _ key _ call _ back _ handler call _ back = null ; public hotkey _ settings _ form ( shadowsocks _ controller controller ) { initialize _ component ( ) ; update _ texts ( ) ;
private hotkey _ config modified _ config ; private label lb = null ; private hot _ keys . hot _ key _ call _ back _ handler call _ back = null ; public hotkey _ settings _ form ( shadowsocks _ controller controller ) { initialize _ component ( ) ; update _ texts ( ) ; this . icon = icon . from _ handle ( resources . ssw . get _ hicon ( ) ) ; controller = controller ; controller . config _ changed + = controller _ config _ changed ; load _ current _ configuration ( ) ;
{ switch _ system _ proxy _ label . text = n . get _ string ( STR ) ; switch _ proxy _ mode _ label . text = n . get _ string ( STR ) ; switch _ allow _ lan _ label . text = n . get _ string ( STR ) ; show _ logs _ label . text = n . get _ string ( STR ) ; server _ move _ up _ label . text = n . get _ string ( STR ) ; server _ move _ down _ label . text = n . get _ string ( STR ) ; btn _ ok . text = n . get _ string ( STR ) ; btn _ cancel . text = n . get _ string ( STR ) ; btn _ register _ all . text = n . get _ string ( STR ) ;
show _ logs _ label . text = n . get _ string ( STR ) ; server _ move _ up _ label . text = n . get _ string ( STR ) ; server _ move _ down _ label . text = n . get _ string ( STR ) ; btn _ ok . text = n . get _ string ( STR ) ; btn _ cancel . text = n . get _ string ( STR ) ; btn _ register _ all . text = n . get _ string ( STR ) ; this . text = n . get _ string ( STR ) ; } private void hotkey _ down ( object sender , key _ event _ args e ) {
} else if ( keyvalue > = keys . num _ pad & & keyvalue < = keys . num _ pad ) { sb . append ( STR ) . append ( ( char ) ( e . key _ value - NUM ) ) ; } } ( ( text _ box ) sender ) . text = sb . to _ string ( ) ; } private void hotkey _ up ( object sender , key _ event _ args e ) {
{ text _ box tb = sender as text _ box ; string content = tb . text . trim _ end ( ) ; if ( content . length > = 1 & & content [ content . length - 1 ] = = '+' ) { tb . text = STR ; } } private void text _ box _ text _ changed ( object sender , event _ args e ) {
private void text _ box _ text _ changed ( object sender , event _ args e ) { text _ box tb = sender as text _ box ; if ( tb . text = = STR ) { unreg _ hotkey ( tb ) ; } } private void unreg _ hotkey ( text _ box tb ) {
} } private void unreg _ hotkey ( text _ box tb ) { prepare _ for _ hotkey ( tb , out call _ back , out lb ) ; unreg _ prev _ hotkey ( call _ back ) ; } private void cancel _ button _ click ( object sender , event _ args e ) {
system . timers . timer timer = new system . timers . timer ( NUM * NUM ) ; timer . elapsed + = timer _ elapsed ; timer . auto _ reset = false ; timer . enabled = true ; timer . start ( ) ; } break ; case power _ modes . suspend : if ( controller ! = null ) {
logging . info ( STR ) ; break ; } } private static void timer _ elapsed ( object sender , system . timers . elapsed _ event _ args e ) { try { if ( controller ! = null ) {
} } private static void application _ application _ exit ( object sender , event _ args e ) { application . application _ exit - = application _ application _ exit ; system _ events . power _ mode _ changed - = system _ events _ power _ mode _ changed ; application . thread _ exception - = application _ thread _ exception ; hot _ keys . destroy ( ) ; if ( controller ! = null ) {
public const int aes _ ctx _ size = NUM + NUM * NUM ; public const int aes _ encrypt = 1 ; public const int aes _ decrypt = 0 ; static polar _ ssl ( ) { string temp _ path = path . get _ temp _ path ( ) ; string dll _ path = temp _ path + STR ; try { file _ manager . uncompress _ file ( dll _ path , resources . libsscrypto _ dll ) ;
private void proxy _ connect _ timer _ elapsed ( object sender , elapsed _ event _ args e ) { if ( proxy _ connected | | dest _ connected ) { return ; }
private void dest _ connect _ timer _ elapsed ( object sender , elapsed _ event _ args e ) { if ( dest _ connected ) { return ; }
public static end _ point get _ end _ point ( string host , int port ) { ip _ address ip _ address ; bool parsed = ip _ address . try _ parse ( host , out ip _ address ) ; if ( parsed ) { return new ip _ end _ point ( ip _ address , port ) ; } return new dns _ end _ point ( host , port ) ; }
ip _ address ip _ address ; bool parsed = ip _ address . try _ parse ( host , out ip _ address ) ; if ( parsed ) { return new ip _ end _ point ( ip _ address , port ) ; } return new dns _ end _ point ( host , port ) ; } private class tcp _ user _ token : i _ async _ result {
private class tcp _ user _ token : i _ async _ result { public async _ callback callback { get ; } public socket _ async _ event _ args args { get ; } public tcp _ user _ token ( async _ callback callback , object state , socket _ async _ event _ args args ) { callback = callback ; async _ state = state ; args = args ; }
async _ state = state ; args = args ; } public bool is _ completed { get ; } = true ; public wait _ handle async _ wait _ handle { get ; } = null ; public object async _ state { get ; } public bool completed _ synchronously { get ; } = true ; } private static void on _ tcp _ connect _ completed ( object sender , socket _ async _ event _ args args ) { tcp _ user _ token token = ( tcp _ user _ token ) args . user _ token ;
public static void begin _ connect _ tcp ( end _ point end _ point , async _ callback callback , object state ) { var arg = new socket _ async _ event _ args ( ) ; arg . remote _ end _ point = end _ point ; arg . completed + = on _ tcp _ connect _ completed ; arg . user _ token = new tcp _ user _ token ( callback , state , arg ) ; socket . connect _ async ( socket _ type . stream , protocol _ type . tcp , arg ) ; } public static socket end _ connect _ tcp ( i _ async _ result async _ result ) {
this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ; this . proxy _ port _ text _ box = new system . windows . forms . text _ box ( ) ; this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ; this . ip _ text _ box = new system . windows . forms . text _ box ( ) ; this . server _ port _ text _ box = new system . windows . forms . text _ box ( ) ; this . password _ text _ box = new system . windows . forms . text _ box ( ) ; this . label = new system . windows . forms . label ( ) ; this . encryption _ select = new system . windows . forms . combo _ box ( ) ;
this . ip _ text _ box = new system . windows . forms . text _ box ( ) ; this . server _ port _ text _ box = new system . windows . forms . text _ box ( ) ; this . password _ text _ box = new system . windows . forms . text _ box ( ) ; this . label = new system . windows . forms . label ( ) ; this . encryption _ select = new system . windows . forms . combo _ box ( ) ; this . notify _ icon = new system . windows . forms . notify _ icon ( this . components ) ; this . panel = new system . windows . forms . panel ( ) ; this . ok _ button = new system . windows . forms . button ( ) ; this . my _ cancel _ button = new system . windows . forms . button ( ) ; this . panel = new system . windows . forms . panel ( ) ;
this . panel = new system . windows . forms . panel ( ) ; this . ok _ button = new system . windows . forms . button ( ) ; this . my _ cancel _ button = new system . windows . forms . button ( ) ; this . panel = new system . windows . forms . panel ( ) ; this . qr _ code _ item = new system . windows . forms . menu _ item ( ) ; this . show _ log _ item = new system . windows . forms . menu _ item ( ) ; this . about _ item = new system . windows . forms . menu _ item ( ) ; this . menu _ item = new system . windows . forms . menu _ item ( ) ; this . quit _ item = new system . windows . forms . menu _ item ( ) ; this . panel = new system . windows . forms . panel ( ) ; this . delete _ button = new system . windows . forms . button ( ) ; this . add _ button = new system . windows . forms . button ( ) ; this . server _ group _ box = new system . windows . forms . group _ box ( ) ; this . servers _ list _ box = new system . windows . forms . list _ box ( ) ;
this . table _ layout _ panel . controls . add ( this . label , 0 , 1 ) ; this . table _ layout _ panel . controls . add ( this . proxy _ port _ text _ box , 1 , NUM ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , 2 ) ; this . table _ layout _ panel . controls . add ( this . ip _ text _ box , 1 , 0 ) ; this . table _ layout _ panel . controls . add ( this . server _ port _ text _ box , 1 , 1 ) ; this . table _ layout _ panel . controls . add ( this . password _ text _ box , 1 , 2 ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . encryption _ select , 1 , NUM ) ; this . table _ layout _ panel . location = new system . drawing . point ( NUM , NUM ) ;
this . table _ layout _ panel . controls . add ( this . label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , 2 ) ; this . table _ layout _ panel . controls . add ( this . ip _ text _ box , 1 , 0 ) ; this . table _ layout _ panel . controls . add ( this . server _ port _ text _ box , 1 , 1 ) ; this . table _ layout _ panel . controls . add ( this . password _ text _ box , 1 , 2 ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . encryption _ select , 1 , NUM ) ; this . table _ layout _ panel . location = new system . drawing . point ( NUM , NUM ) ; this . table _ layout _ panel . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . table _ layout _ panel . name = STR ;

private system . windows . forms . notify _ icon notify _ icon ; private system . windows . forms . label label ; private system . windows . forms . combo _ box encryption _ select ; private system . windows . forms . panel panel ; private system . windows . forms . button ok _ button ; private system . windows . forms . button my _ cancel _ button ; private system . windows . forms . panel panel ;
private system . windows . forms . panel panel ; private system . windows . forms . button ok _ button ; private system . windows . forms . button my _ cancel _ button ; private system . windows . forms . panel panel ; private system . windows . forms . menu _ item about _ item ; private system . windows . forms . menu _ item menu _ item ; private system . windows . forms . menu _ item quit _ item ; private system . windows . forms . menu _ item config _ item ; private system . windows . forms . menu _ item edit _ pac _ file _ item ; private system . windows . forms . panel panel ; private system . windows . forms . button delete _ button ; private system . windows . forms . button add _ button ; private system . windows . forms . group _ box server _ group _ box ; private system . windows . forms . list _ box servers _ list _ box ;
private system . windows . forms . panel panel ; private system . windows . forms . menu _ item config _ item ; private system . windows . forms . menu _ item edit _ pac _ file _ item ; private system . windows . forms . panel panel ; private system . windows . forms . button delete _ button ; private system . windows . forms . button add _ button ; private system . windows . forms . group _ box server _ group _ box ; private system . windows . forms . list _ box servers _ list _ box ; private system . windows . forms . menu _ item servers _ item ; private system . windows . forms . menu _ item seperator _ item ; private system . windows . forms . menu _ item menu _ item ; private system . windows . forms . text _ box remarks _ text _ box ; private system . windows . forms . label label ;
public partial class config _ form : form { private shadowsocks _ controller controller ; private update _ checker update _ checker ; private configuration modified _ configuration ; private int old _ selected _ index = - 1 ; private bool is _ first _ run ; public config _ form ( shadowsocks _ controller controller ) { initialize _ component ( ) ;
private shadowsocks _ controller controller ; private update _ checker update _ checker ; private configuration modified _ configuration ; private int old _ selected _ index = - 1 ; private bool is _ first _ run ; public config _ form ( shadowsocks _ controller controller ) { initialize _ component ( ) ; load _ tray _ icon ( ) ; notify _ icon . context _ menu = context _ menu ; this . controller = controller ;
private configuration modified _ configuration ; private int old _ selected _ index = - 1 ; private bool is _ first _ run ; public config _ form ( shadowsocks _ controller controller ) { initialize _ component ( ) ; load _ tray _ icon ( ) ; notify _ icon . context _ menu = context _ menu ; this . controller = controller ; controller . enable _ status _ changed + = controller _ enable _ status _ changed ; controller . config _ changed + = controller _ config _ changed ;
private bool is _ first _ run ; public config _ form ( shadowsocks _ controller controller ) { initialize _ component ( ) ; load _ tray _ icon ( ) ; notify _ icon . context _ menu = context _ menu ; this . controller = controller ; controller . enable _ status _ changed + = controller _ enable _ status _ changed ; controller . config _ changed + = controller _ config _ changed ; controller . pac _ file _ ready _ to _ open + = controller _ pac _ file _ ready _ to _ open ; controller . share _ over _ lan _ status _ changed + = controller _ share _ over _ lan _ status _ changed ; this . update _ checker = new update _ checker ( ) ; update _ checker . new _ version _ found + = update _ checker _ new _ version _ found ; load _ current _ configuration ( ) ;
controller . config _ changed + = controller _ config _ changed ; this . update _ checker = new update _ checker ( ) ; update _ checker . new _ version _ found + = update _ checker _ new _ version _ found ; load _ current _ configuration ( ) ; { icon = resources . ss ; } notify _ icon . icon = icon . from _ handle ( icon . get _ hicon ( ) ) ; notify _ icon . visible = true ; this . icon = icon . from _ handle ( resources . ssw . get _ hicon ( ) ) ; } private void controller _ config _ changed ( object sender , event _ args e ) { load _ current _ configuration ( ) ;
servers _ list _ box . items . add ( string . is _ null _ or _ empty ( server . server ) ? STR : string . is _ null _ or _ empty ( server . remarks ) ? server . server + STR + server . server _ port : server . server + STR + server . server _ port + STR + server . remarks + STR ) ; } } private void load _ current _ configuration ( ) { modified _ configuration = controller . get _ configuration ( ) ; load _ configuration ( modified _ configuration ) ; old _ selected _ index = modified _ configuration . index ; servers _ list _ box . selected _ index = modified _ configuration . index ; load _ selected _ server ( ) ;
{ modified _ configuration = controller . get _ configuration ( ) ; load _ configuration ( modified _ configuration ) ; old _ selected _ index = modified _ configuration . index ; servers _ list _ box . selected _ index = modified _ configuration . index ; load _ selected _ server ( ) ; } items . add ( seperator _ item ) ; items . add ( config _ item ) ; if ( configuration . index > = 0 & & configuration . index < configuration . configs . count ) { items [ configuration . index ] . checked = true ; } } private void config _ form _ load ( object sender , event _ args e ) {
{ return ; } if ( modified _ configuration . configs . count = = 0 ) { message _ box . show ( STR ) ; return ; } controller . save _ servers ( modified _ configuration . configs ) ; this . hide ( ) ;
{ message _ box . show ( STR ) ; return ; } controller . save _ servers ( modified _ configuration . configs ) ; this . hide ( ) ; show _ first _ time _ balloon ( ) ; } private void cancel _ button _ click ( object sender , event _ args e ) {
show _ first _ time _ balloon ( ) ; } private void cancel _ button _ click ( object sender , event _ args e ) { } private void show _ log _ item _ click ( object sender , event _ args e ) { string argument = logging . log _ file ; system . diagnostics . process . start ( STR , argument ) ; } private void config _ form _ shown ( object sender , event _ args e ) { ip _ text _ box . focus ( ) ; }
private void cancel _ button _ click ( object sender , event _ args e ) { { string argument = logging . log _ file ; system . diagnostics . process . start ( STR , argument ) ; } private void config _ form _ shown ( object sender , event _ args e ) { ip _ text _ box . focus ( ) ; } private void qr _ code _ item _ click ( object sender , event _ args e ) {
system . diagnostics . process . start ( STR , argument ) ; } private void config _ form _ shown ( object sender , event _ args e ) { ip _ text _ box . focus ( ) ; } private void qr _ code _ item _ click ( object sender , event _ args e ) { qr _ code _ form qr _ code _ form = new qr _ code _ form ( controller . get _ qr _ code _ for _ current _ server ( ) ) ; qr _ code _ form . icon = this . icon ; qr _ code _ form . show ( ) ; }
listener . close ( ) ; throw ; } } public void stop ( ) { listener . close ( ) ; } public void accept _ callback ( i _ async _ result ar ) {
{ listener . close ( ) ; } public void accept _ callback ( i _ async _ result ar ) { try { socket listener = ( socket ) ar . async _ state ; socket conn = listener . end _ accept ( ar ) ; conn . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ;
return pac _ file ; } else { file _ manager . uncompress _ file ( pac _ file , resources . proxy _ pac _ txt ) ; return pac _ file ; } } public void accept _ callback ( i _ async _ result ar ) {
file _ manager . uncompress _ file ( pac _ file , resources . proxy _ pac _ txt ) ; return pac _ file ; } } public void accept _ callback ( i _ async _ result ar ) { try { socket listener = ( socket ) ar . async _ state ; socket conn = listener . end _ accept ( ar ) ;
this . proxy _ port _ label = new system . windows . forms . label ( ) ; this . password _ label = new system . windows . forms . label ( ) ; this . ip _ text _ box = new system . windows . forms . text _ box ( ) ; this . server _ port _ text _ box = new system . windows . forms . text _ box ( ) ; this . password _ text _ box = new system . windows . forms . text _ box ( ) ; this . encryption _ label = new system . windows . forms . label ( ) ; this . encryption _ select = new system . windows . forms . combo _ box ( ) ; this . panel = new system . windows . forms . panel ( ) ; this . ok _ button = new system . windows . forms . button ( ) ; this . my _ cancel _ button = new system . windows . forms . button ( ) ;
this . my _ cancel _ button = new system . windows . forms . button ( ) ; this . panel = new system . windows . forms . panel ( ) ; this . panel = new system . windows . forms . panel ( ) ; this . delete _ button = new system . windows . forms . button ( ) ; this . add _ button = new system . windows . forms . button ( ) ; this . server _ group _ box = new system . windows . forms . group _ box ( ) ; this . servers _ list _ box = new system . windows . forms . list _ box ( ) ; this . table _ layout _ panel . suspend _ layout ( ) ;
this . encryption _ select . size = new system . drawing . size ( NUM , NUM ) ; this . encryption _ select . tab _ index = NUM ; this . panel . anchor = system . windows . forms . anchor _ styles . top ; this . panel . auto _ size = true ; this . panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . panel . location = new system . drawing . point ( NUM , NUM ) ; this . panel . name = STR ; this . panel . size = new system . drawing . size ( 0 , 0 ) ; this . panel . tab _ index = 1 ; this . ok _ button . dialog _ result = system . windows . forms . dialog _ result . ok ;
this . ok _ button . location = new system . drawing . point ( NUM , NUM ) ; this . ok _ button . name = STR ; this . ok _ button . size = new system . drawing . size ( NUM , NUM ) ; this . ok _ button . tab _ index = NUM ; this . ok _ button . text = STR ; this . ok _ button . use _ visual _ style _ back _ color = true ; this . ok _ button . click + = new system . event _ handler ( this . ok _ button _ click ) ; this . my _ cancel _ button . dialog _ result = system . windows . forms . dialog _ result . cancel ;
this . my _ cancel _ button . dialog _ result = system . windows . forms . dialog _ result . cancel ; this . my _ cancel _ button . location = new system . drawing . point ( NUM , NUM ) ; this . my _ cancel _ button . name = STR ; this . my _ cancel _ button . size = new system . drawing . size ( NUM , NUM ) ; this . my _ cancel _ button . tab _ index = NUM ; this . my _ cancel _ button . text = STR ; this . my _ cancel _ button . use _ visual _ style _ back _ color = true ; this . my _ cancel _ button . click + = new system . event _ handler ( this . cancel _ button _ click ) ;
this . my _ cancel _ button . location = new system . drawing . point ( NUM , NUM ) ; this . my _ cancel _ button . name = STR ; this . my _ cancel _ button . size = new system . drawing . size ( NUM , NUM ) ; this . my _ cancel _ button . tab _ index = NUM ; this . my _ cancel _ button . text = STR ; this . my _ cancel _ button . use _ visual _ style _ back _ color = true ; this . my _ cancel _ button . click + = new system . event _ handler ( this . cancel _ button _ click ) ; this . panel . size = new system . drawing . size ( NUM , NUM ) ; this . panel . tab _ index = 1 ; this . panel . auto _ size = true ; this . panel . controls . add ( this . delete _ button ) ; this . panel . controls . add ( this . add _ button ) ; this . panel . location = new system . drawing . point ( NUM , NUM ) ; this . panel . margin = new system . windows . forms . padding ( 0 ) ; this . panel . name = STR ; this . panel . size = new system . drawing . size ( NUM , NUM ) ; this . panel . tab _ index = NUM ;
this . panel . tab _ index = NUM ; this . delete _ button . location = new system . drawing . point ( NUM , NUM ) ; this . delete _ button . name = STR ; this . delete _ button . size = new system . drawing . size ( NUM , NUM ) ; this . delete _ button . tab _ index = NUM ; this . delete _ button . text = STR ; this . delete _ button . use _ visual _ style _ back _ color = true ; this . delete _ button . click + = new system . event _ handler ( this . delete _ button _ click ) ;
this . add _ button . location = new system . drawing . point ( NUM , NUM ) ; this . add _ button . name = STR ; this . add _ button . size = new system . drawing . size ( NUM , NUM ) ; this . add _ button . tab _ index = NUM ; this . add _ button . text = STR ; this . add _ button . use _ visual _ style _ back _ color = true ; this . add _ button . click + = new system . event _ handler ( this . add _ button _ click ) ; this . server _ group _ box . controls . add ( this . table _ layout _ panel ) ;
this . server _ group _ box . controls . add ( this . table _ layout _ panel ) ; this . server _ group _ box . location = new system . drawing . point ( NUM , NUM ) ; this . server _ group _ box . name = STR ; this . server _ group _ box . size = new system . drawing . size ( NUM , NUM ) ; this . server _ group _ box . tab _ index = NUM ; this . server _ group _ box . tab _ stop = false ; this . server _ group _ box . text = STR ; this . servers _ list _ box . formatting _ enabled = true ;
this . servers _ list _ box . formatting _ enabled = true ; this . servers _ list _ box . location = new system . drawing . point ( NUM , NUM ) ; this . servers _ list _ box . name = STR ; this . servers _ list _ box . size = new system . drawing . size ( NUM , NUM ) ; this . servers _ list _ box . tab _ index = NUM ; this . servers _ list _ box . selected _ index _ changed + = new system . event _ handler ( this . servers _ list _ box _ selected _ index _ changed ) ; this . accept _ button = this . ok _ button ; this . cancel _ button = this . my _ cancel _ button ;
this . minimize _ box = false ; this . name = STR ; this . start _ position = system . windows . forms . form _ start _ position . center _ screen ; this . text = STR ; this . form _ closed + = new system . windows . forms . form _ closed _ event _ handler ( this . config _ form _ form _ closed ) ; this . load + = new system . event _ handler ( this . config _ form _ load ) ; this . shown + = new system . event _ handler ( this . config _ form _ shown ) ; this . table _ layout _ panel . resume _ layout ( false ) ; this . table _ layout _ panel . perform _ layout ( ) ;
private system . windows . forms . label proxy _ port _ label ; private system . windows . forms . text _ box ip _ text _ box ; private system . windows . forms . text _ box server _ port _ text _ box ; private system . windows . forms . text _ box password _ text _ box ; private system . windows . forms . text _ box proxy _ port _ text _ box ; private system . windows . forms . label encryption _ label ; private system . windows . forms . combo _ box encryption _ select ; private system . windows . forms . panel panel ; private system . windows . forms . button ok _ button ; private system . windows . forms . button my _ cancel _ button ;
using system ; using system _ collections _ generic ;
using system ; using system _ collections _ generic ; using system _ linq ; using system _ net _ sockets ; using system _ text ;
registry . set _ value ( STR , STR ) ; } else { string pac _ url ; if ( config . use _ online _ pac & & ! string . is _ null _ or _ empty ( config . pac _ url ) ) pac _ url = config . pac _ url ; else pac _ url = STR + config . local _ port . to _ string ( ) + STR + get _ timestamp ( date _ time . now ) ; registry . set _ value ( STR , 0 ) ;
else pac _ url = STR + config . local _ port . to _ string ( ) + STR + get _ timestamp ( date _ time . now ) ; registry . set _ value ( STR , 0 ) ; registry . set _ value ( STR , STR ) ; registry . set _ value ( STR , pac _ url ) ; } } else { registry . set _ value ( STR , 0 ) ;

using system ; using system _ collections _ generic ; using system _ text ;

using shadowsocks _ csharp _ properties ; using system ; using system _ collections _ generic ; using system _ diagnostics ; using system _ io ; using system _ i _ compression ; using system _ text ;
using system _ collections _ generic ; using system _ diagnostics ; using system _ io ; using system _ i _ compression ; using system _ text ; namespace shadowsocks _ csharp { class polipo _ runner { private process process ;
using microsoft _ win ; using system ; using system _ collections _ generic ; using system _ runtime _ interop _ services ; using system _ text ;
using microsoft _ win ; using system ; using system _ collections _ generic ; using system _ runtime _ interop _ services ; using system _ text ; namespace shadowsocks _ csharp {
{ } else {
else { console . write _ line ( e ) ; } } else if ( e is object _ disposed _ exception ) { } else {
using system _ collections _ generic ; using system _ net ; using system _ net _ network _ information ; using system _ net _ sockets ; using shadowsocks _ model ; namespace shadowsocks _ controller { public class listener {
udp _ socket = null ; } } public void recv _ from _ callback ( i _ async _ result ar ) { udp _ state state = ( udp _ state ) ar . async _ state ; try { int bytes _ read = udp _ socket . end _ receive _ from ( ar , ref state . remote _ end _ point ) ;
static extern int unregister _ application _ restart ( ) ; enum application _ restart _ flags { restart _ no _ crash = 1 , restart _ no _ hang = 2 , restart _ no _ patch = NUM , restart _ no _ reboot = NUM , } public static void register _ for _ restart ( bool regist ) {
using system _ xml ; namespace shadowsocks _ controller { public class update _ checker { private const string update _ url = STR ; public string latest _ version _ number ; public string latest _ version _ url ; public event event _ handler new _ version _ found ; public const string version = STR ;
public class update _ checker { private const string update _ url = STR ; public string latest _ version _ number ; public string latest _ version _ url ; public event event _ handler new _ version _ found ; public const string version = STR ; public void check _ update ( ) { web _ client http = new web _ client ( ) ;
| system . windows . forms . anchor _ styles . left ) ) ) ; this . wrap _ text _ check _ box . auto _ size = true ; this . wrap _ text _ check _ box . location = new system . drawing . point ( NUM , NUM ) ; this . wrap _ text _ check _ box . name = STR ; this . wrap _ text _ check _ box . size = new system . drawing . size ( NUM , NUM ) ; this . wrap _ text _ check _ box . tab _ index = 0 ; this . wrap _ text _ check _ box . text = STR ; this . wrap _ text _ check _ box . use _ visual _ style _ back _ color = true ; this . wrap _ text _ check _ box . checked _ changed + = new system . event _ handler ( this . wrap _ text _ check _ box _ checked _ changed ) ; this . table _ layout _ panel . column _ count = 1 ;
f = f / NUM ; unit = STR ; } if ( f > NUM ) { f = f / NUM ; unit = STR ; }
void controller _ errored ( object sender , system . io . error _ event _ args e ) { message _ box . show ( e . get _ exception ( ) . to _ string ( ) , string . format ( n . get _ string ( STR ) , e . get _ exception ( ) . message ) ) ; } private void update _ tray _ icon ( ) { int dpi ; graphics graphics = graphics . from _ hwnd ( int _ ptr . zero ) ; dpi = ( int ) graphics . dpi _ x ; graphics . dispose ( ) ;
} private void update _ tray _ icon ( ) { int dpi ; graphics graphics = graphics . from _ hwnd ( int _ ptr . zero ) ; dpi = ( int ) graphics . dpi _ x ; graphics . dispose ( ) ; bitmap icon = null ; if ( dpi < NUM ) {
graphics graphics = graphics . from _ hwnd ( int _ ptr . zero ) ; dpi = ( int ) graphics . dpi _ x ; graphics . dispose ( ) ; bitmap icon = null ; if ( dpi < NUM ) { icon = resources . ss ; } else if ( dpi < NUM ) {
if ( dpi < NUM ) { icon = resources . ss ; } else if ( dpi < NUM ) { icon = resources . ss ; } else {
{ icon = resources . ss ; } else { icon = resources . ss ; } configuration config = controller . get _ configuration _ copy ( ) ; bool enabled = config . enabled ; bool global = config . global ;

using ( bitmap full _ image = new bitmap ( screen . primary _ screen . bounds . width , screen . primary _ screen . bounds . height ) ) { using ( graphics g = graphics . from _ image ( full _ image ) ) {
using ( bitmap full _ image = new bitmap ( screen . primary _ screen . bounds . width , screen . primary _ screen . bounds . height ) ) { using ( graphics g = graphics . from _ image ( full _ image ) ) { copy _ pixel _ operation . source _ copy ) ; } for ( int i = 0 ; i < NUM ; i + + ) { int margin _ left = full _ image . width * i / NUM / NUM ; int margin _ top = full _ image . height * i / NUM / NUM ; rectangle crop _ rect = new rectangle ( margin _ left , margin _ top , full _ image . width - margin _ left * 2 , full _ image . height - margin _ top * 2 ) ; bitmap target = new bitmap ( crop _ rect . width , crop _ rect . height ) ; using ( graphics g = graphics . from _ image ( target ) ) {
using ( bitmap full _ image = new bitmap ( screen . primary _ screen . bounds . width , screen . primary _ screen . bounds . height ) ) { using ( graphics g = graphics . from _ image ( full _ image ) ) { { int margin _ left = full _ image . width * i / NUM / NUM ; int margin _ top = full _ image . height * i / NUM / NUM ; rectangle crop _ rect = new rectangle ( margin _ left , margin _ top , full _ image . width - margin _ left * 2 , full _ image . height - margin _ top * 2 ) ; bitmap target = new bitmap ( crop _ rect . width , crop _ rect . height ) ; using ( graphics g = graphics . from _ image ( target ) ) { g . draw _ image ( full _ image , new rectangle ( 0 , 0 , target . width , target . height ) , crop _ rect , graphics _ unit . pixel ) ; }
using ( graphics g = graphics . from _ image ( full _ image ) ) { rectangle crop _ rect = new rectangle ( margin _ left , margin _ top , full _ image . width - margin _ left * 2 , full _ image . height - margin _ top * 2 ) ; bitmap target = new bitmap ( crop _ rect . width , crop _ rect . height ) ; using ( graphics g = graphics . from _ image ( target ) ) { g . draw _ image ( full _ image , new rectangle ( 0 , 0 , target . width , target . height ) , crop _ rect , graphics _ unit . pixel ) ; } var source = new bitmap _ luminance _ source ( target ) ; var bitmap = new binary _ bitmap ( new hybrid _ binarizer ( source ) ) ; qr _ code _ reader reader = new qr _ code _ reader ( ) ; var result = reader . decode ( bitmap ) ; if ( result ! = null ) {
{ g . draw _ image ( full _ image , new rectangle ( 0 , 0 , target . width , target . height ) , crop _ rect , graphics _ unit . pixel ) ; } var source = new bitmap _ luminance _ source ( target ) ; var bitmap = new binary _ bitmap ( new hybrid _ binarizer ( source ) ) ; qr _ code _ reader reader = new qr _ code _ reader ( ) ; var result = reader . decode ( bitmap ) ; if ( result ! = null ) { var success = controller . add _ server _ by _ ssurl ( result . text ) ; qr _ code _ splash _ form splash = new qr _ code _ splash _ form ( ) ; if ( success ) {
} qr _ code _ reader reader = new qr _ code _ reader ( ) ; var result = reader . decode ( bitmap ) ; if ( result ! = null ) { var success = controller . add _ server _ by _ ssurl ( result . text ) ; qr _ code _ splash _ form splash = new qr _ code _ splash _ form ( ) ; if ( success ) { splash . form _ closed + = splash _ form _ closed ; }
public byte [ ] encrypt ( byte [ ] buf , int length ) { switch ( method ) { case STR : for ( int i = 0 ; i < length ; i + + ) buf [ i ] = encrypt _ table [ buf [ i ] ] ;
{ switch ( method ) { case STR : for ( int i = 0 ; i < length ; i + + ) buf [ i ] = encrypt _ table [ buf [ i ] ] ; return buf ; break ; case STR : rc . encrypt ( encrypt _ table , buf , length ) ;
return ssl _ encrypt ( buf , length ) ; } } public byte [ ] decrypt ( byte [ ] buf , int length ) { switch ( method ) { case STR : for ( int i = 0 ; i < length ; i + + ) buf [ i ] = decrypt _ table [ buf [ i ] ] ;
{ switch ( method ) { case STR : for ( int i = 0 ; i < length ; i + + ) buf [ i ] = decrypt _ table [ buf [ i ] ] ; return buf ; break ; case STR : rc . decrypt ( decrypt _ table , buf , length ) ;
using system _ collections _ generic ; using system _ component _ model ; using system _ drawing ; using system _ text ; using system _ windows _ forms ; using system _ diagnostics ; namespace shadowsocks _ csharp { public partial class config _ form : form {
using system _ text ; using system _ windows _ forms ; using system _ diagnostics ; namespace shadowsocks _ csharp { public partial class config _ form : form { local local ; pac _ server pac _ server ; config config ; polipo _ runner polipo _ runner ; public config _ form ( ) {
namespace shadowsocks _ csharp { public partial class config _ form : form { local local ; pac _ server pac _ server ; config config ; polipo _ runner polipo _ runner ; public config _ form ( ) { config = config . load ( ) ; initialize _ component ( ) ; notify _ icon . context _ menu = context _ menu ;
initialize _ component ( ) ; notify _ icon . context _ menu = context _ menu ; enable _ item . checked = config . enabled ; config _ to _ text _ box ( ) ; } private void show _ window ( ) { this . opacity = 1 ; this . show ( ) ; }
this . opacity = 1 ; this . show ( ) ; } private void config _ to _ text _ box ( ) { text _ box . text = config . server ; text _ box . text = config . server _ port . to _ string ( ) ; text _ box . text = config . password ; text _ box . text = config . local _ port . to _ string ( ) ;
text _ box . text = config . server ; text _ box . text = config . server _ port . to _ string ( ) ; text _ box . text = config . password ; text _ box . text = config . local _ port . to _ string ( ) ; combo _ box . text = config . method = = null ? STR : config . method ; } private void form _ load ( object sender , event _ args e ) {
text _ box . text = config . password ; text _ box . text = config . local _ port . to _ string ( ) ; combo _ box . text = config . method = = null ? STR : config . method ; } private void form _ load ( object sender , event _ args e ) { if ( ! config . is _ default ) { this . opacity = 0 ;
private void form _ load ( object sender , event _ args e ) { if ( ! config . is _ default ) { this . opacity = 0 ; reload ( config ) ; begin _ invoke ( new method _ invoker ( delegate { this . hide ( ) ; } ) ) ; }
message _ box . show ( STR ) ; } catch ( exception ex ) { message _ box . show ( ex . to _ string ( ) ) ; } } private void cancel _ button _ click ( object sender , event _ args e ) { this . hide ( ) ;
message _ box . show ( ex . to _ string ( ) ) ; } } private void cancel _ button _ click ( object sender , event _ args e ) { this . hide ( ) ; config _ to _ text _ box ( ) ; } private void form _ form _ closed ( object sender , form _ closed _ event _ args e ) {
} } private void about _ tool _ strip _ menu _ item _ click ( object sender , event _ args e ) { process . start ( STR ) ; } private void notify _ icon _ double _ click ( object sender , event _ args e ) { show _ window ( ) ; }
process . start ( STR ) ; } private void notify _ icon _ double _ click ( object sender , event _ args e ) { show _ window ( ) ; } system _ proxy . enable ( ) ; } else { system _ proxy . disable ( ) ; } } private void enable _ item _ click ( object sender , event _ args e ) { enable _ item . checked = ! enable _ item . checked ;
if ( share _ over _ lan _ status _ changed ! = null ) { share _ over _ lan _ status _ changed ( this , new event _ args ( ) ) ; } } public void disable _ proxy ( ) { config . proxy . use _ proxy = false ; save _ config ( config ) ; }
{ modified _ configuration = controller . get _ configuration _ copy ( ) . proxy ; use _ proxy _ check _ box . checked = modified _ configuration . use _ proxy ; proxy _ server _ text _ box . text = modified _ configuration . proxy _ server ; proxy _ port _ text _ box . text = modified _ configuration . proxy _ port . to _ string ( ) ; proxy _ timeout _ text _ box . text = modified _ configuration . proxy _ timeout . to _ string ( ) ; proxy _ type _ combo _ box . selected _ index = modified _ configuration . proxy _ type ; } private void ok _ button _ click ( object sender , event _ args e ) {
proxy _ server _ text _ box . text = modified _ configuration . proxy _ server ; proxy _ port _ text _ box . text = modified _ configuration . proxy _ port . to _ string ( ) ; proxy _ timeout _ text _ box . text = modified _ configuration . proxy _ timeout . to _ string ( ) ; proxy _ type _ combo _ box . selected _ index = modified _ configuration . proxy _ type ; } private void ok _ button _ click ( object sender , event _ args e ) { var type = proxy _ type _ combo _ box . selected _ index ; var proxy = proxy _ server _ text _ box . text ; var port = 0 ; var timeout = NUM ; if ( use _ proxy _ check _ box . checked ) {
} private void ok _ button _ click ( object sender , event _ args e ) { var type = proxy _ type _ combo _ box . selected _ index ; var proxy = proxy _ server _ text _ box . text ; var port = 0 ; var timeout = NUM ; if ( use _ proxy _ check _ box . checked ) { try { port = int . parse ( proxy _ port _ text _ box . text ) ; } catch ( format _ exception ) { message _ box . show ( n . get _ string ( STR ) ) ;
var timeout = NUM ; if ( use _ proxy _ check _ box . checked ) { try { port = int . parse ( proxy _ port _ text _ box . text ) ; } catch ( format _ exception ) { message _ box . show ( n . get _ string ( STR ) ) ; proxy _ port _ text _ box . clear ( ) ; return ; }
} catch ( format _ exception ) { message _ box . show ( n . get _ string ( STR ) ) ; proxy _ port _ text _ box . clear ( ) ; return ; } try { timeout = int . parse ( proxy _ timeout _ text _ box . text ) ; } catch ( format _ exception ) { message _ box . show ( n . get _ string ( STR ) ) ;
{ configuration . check _ server ( proxy ) ; configuration . check _ port ( port ) ; configuration . check _ timeout ( timeout , proxy _ config . max _ proxy _ timeout _ sec ) ; } catch ( exception ex ) { message _ box . show ( ex . message ) ; return ; }
{ message _ box . show ( ex . message ) ; return ; } controller . enable _ proxy ( type , proxy , port ) ; } else { controller . disable _ proxy ( ) ; }
logging . debug ( line ) ; if ( request _ line _ count = = 0 ) { var m = http _ request _ header _ regex . match ( line ) ; if ( m . success ) {
if ( request _ line _ count = = 0 ) { var m = http _ request _ header _ regex . match ( line ) ; if ( m . success ) { var method = m . groups [ STR ] . value ; var path = m . groups [ STR ] . value ; if ( method = = STR ) { is _ connect = true ;
{ var method = m . groups [ STR ] . value ; var path = m . groups [ STR ] . value ; if ( method = = STR ) { is _ connect = true ; if ( ! parse _ host ( path ) ) { throw new exception ( STR + line ) ; } }
new _ config . save _ size ( ) ; configuration . save ( config ) ; config _ changed ? . invoke ( this , new event _ args ( ) ) ; } public void save _ hotkey _ config ( hotkey _ config new _ config ) { config . hotkey = new _ config ; save _ config ( config ) ; config _ changed ? . invoke ( this , new event _ args ( ) ) ; }
{ config . hotkey = new _ config ; save _ config ( config ) ; config _ changed ? . invoke ( this , new event _ args ( ) ) ; } public void update _ latency ( server server , time _ span latency ) { if ( config . availability _ statistics ) {
{ availability _ statistics . update _ latency ( server , ( int ) latency . total _ milliseconds ) ; } } public void update _ inbound _ counter ( server server , long n ) { interlocked . add ( ref inbound _ counter , n ) ; if ( config . availability _ statistics ) {
{ availability _ statistics . update _ inbound _ counter ( server , n ) ; } } public void update _ outbound _ counter ( server server , long n ) { interlocked . add ( ref outbound _ counter , n ) ; if ( config . availability _ statistics ) {
} public override void stop ( ) { list < tcp _ handler > handlers _ to _ close = new list < tcp _ handler > ( ) ; lock ( handlers ) { handlers _ to _ close . add _ range ( handlers ) ; } handlers _ to _ close . for _ each ( h = > h . close ( ) ) ; }
{ list < tcp _ handler > handlers _ to _ close = new list < tcp _ handler > ( ) ; lock ( handlers ) { handlers _ to _ close . add _ range ( handlers ) ; } handlers _ to _ close . for _ each ( h = > h . close ( ) ) ; } { controller . update _ outbound _ counter ( server , n ) ; } public void update _ latency ( server server , time _ span latency ) { i _ strategy strategy = controller . get _ current _ strategy ( ) ; strategy ? . update _ latency ( server , latency ) ; controller . update _ latency ( server , latency ) ; } }
} } class ss _ relay _ event _ args : event _ args { public readonly server server ; public ss _ relay _ event _ args ( server server ) { this . server = server ; } }
{ public readonly server server ; public ss _ relay _ event _ args ( server server ) { this . server = server ; } } class ss _ inbound _ event _ args : ss _ relay _ event _ args { public readonly long length ;
} } class ss _ inbound _ event _ args : ss _ relay _ event _ args { public readonly long length ; public ss _ inbound _ event _ args ( server server , long length ) : base ( server ) { this . length = length ; } }
{ this . length = length ; } } { this . length = length ; } } class sstcp _ connected _ event _ args : ss _ relay _ event _ args { public readonly time _ span latency ; public sstcp _ connected _ event _ args ( server server , time _ span latency ) : base ( server ) { this . latency = latency ;
public readonly time _ span latency ; public sstcp _ connected _ event _ args ( server server , time _ span latency ) : base ( server ) { this . latency = latency ; { public readonly tcp _ handler handler ; public sstcp _ closed _ event _ args ( server server , tcp _ handler handler ) : base ( server ) { this . handler = handler ; } } internal class tcp _ handler { public event event _ handler < sstcp _ connected _ event _ args > on _ connected ;
{ encryptor . encrypt ( connetion _ recv _ buffer , length , connetion _ send _ buffer , out bytes _ to _ send ) ; } catch ( crypto _ error _ exception ) { logger . debug ( STR ) ; close ( ) ; return ; } }
{ logger . debug ( STR ) ; close ( ) ; return ; } } on _ outbound ? . invoke ( this , new ss _ outbound _ event _ args ( server , bytes _ to _ send ) ) ; start _ sending _ time = date _ time . now ; session . remote . begin _ send ( connetion _ send _ buffer , 0 , bytes _ to _ send , socket _ flags . none , pipe _ remote _ send _ callback , new object [ ] { session , bytes _ to _ send } ) ;
protected bool decrypt _ iv _ received ; protected bool encrypt _ iv _ sent ; protected int encrypt _ iv _ offset = 0 ; protected int decrypt _ iv _ offset = 0 ; protected string method ; protected int cipher ; protected int [ ] cipher _ info ; protected byte [ ] key ; protected int key _ len ; protected int iv _ len ;
file _ manager . uncompress _ file ( dll _ path , resources . libsscrypto _ dll ) ; load _ library ( dll _ path ) ; } catch ( io _ exception ) { } catch ( exception e ) { console . write _ line ( e . to _ string ( ) ) ; }
using system _ security _ cryptography ; using system _ text ; namespace shadowsocks _ encryption { public abstract class encryptor _ base : i _ encryptor { public const int max _ input _ size = NUM ;
this . table _ layout _ panel . controls . add ( this . ip _ text _ box , 1 , 0 ) ; this . table _ layout _ panel . controls . add ( this . server _ port _ text _ box , 1 , 1 ) ; this . table _ layout _ panel . controls . add ( this . password _ text _ box , 1 , 2 ) ; this . table _ layout _ panel . controls . add ( this . encryption _ label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . encryption _ select , 1 , NUM ) ; this . table _ layout _ panel . location = new system . drawing . point ( NUM , NUM ) ; this . table _ layout _ panel . margin = new system . windows . forms . padding ( 0 ) ; this . table _ layout _ panel . name = STR ; this . table _ layout _ panel . padding = new system . windows . forms . padding ( NUM ) ;
this . add _ button . tab _ index = NUM ; this . add _ button . text = STR ; this . add _ button . use _ visual _ style _ back _ color = true ; this . add _ button . click + = new system . event _ handler ( this . add _ button _ click ) ; this . server _ group _ box . auto _ size = true ; this . server _ group _ box . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . server _ group _ box . controls . add ( this . table _ layout _ panel ) ; this . server _ group _ box . location = new system . drawing . point ( NUM , 0 ) ; this . server _ group _ box . margin = new system . windows . forms . padding ( NUM , 0 , 0 , 0 ) ; this . server _ group _ box . name = STR ;
this . server _ group _ box . controls . add ( this . table _ layout _ panel ) ; this . server _ group _ box . location = new system . drawing . point ( NUM , 0 ) ; this . server _ group _ box . margin = new system . windows . forms . padding ( NUM , 0 , 0 , 0 ) ; this . server _ group _ box . name = STR ; this . server _ group _ box . size = new system . drawing . size ( NUM , NUM ) ; this . server _ group _ box . tab _ index = NUM ; this . server _ group _ box . tab _ stop = false ; this . server _ group _ box . text = STR ; this . servers _ list _ box . formatting _ enabled = true ; this . servers _ list _ box . integral _ height = false ;
} foreach ( string method in polar _ ssl _ encryptor . supported _ ciphers ( ) ) { registered _ encryptors . add ( method , typeof ( polar _ ssl _ encryptor ) ) ; } foreach ( string method in sodium _ encryptor . supported _ ciphers ( ) ) { registered _ encryptors . add ( method , typeof ( sodium _ encryptor ) ) ; } }
} public static i _ encryptor get _ encryptor ( string method , string password ) { if ( string . is _ null _ or _ empty ( method ) ) { method = STR ; } method = method . to _ lower _ invariant ( ) ; type t = registered _ encryptors [ method ] ; constructor _ info c = t . get _ constructor ( constructor _ types ) ;
this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ; this . table _ layout _ panel . tab _ index = 0 ; this . plugin _ options _ label . anchor = system . windows . forms . anchor _ styles . right ; this . plugin _ options _ label . auto _ size = true ;
this . plugin _ options _ label . anchor = system . windows . forms . anchor _ styles . right ; this . plugin _ options _ label . auto _ size = true ; this . plugin _ options _ label . location = new system . drawing . point ( NUM , NUM ) ; this . plugin _ options _ label . name = STR ; this . plugin _ options _ label . size = new system . drawing . size ( NUM , NUM ) ; this . plugin _ options _ label . tab _ index = NUM ; this . plugin _ options _ label . text = STR ; this . tool _ tip . set _ tool _ tip ( this . plugin _ options _ label , STR ) ; this . plugin _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ;
this . tool _ tip . set _ tool _ tip ( this . plugin _ options _ label , STR ) ; this . plugin _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . plugin _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . plugin _ text _ box . max _ length = NUM ; this . plugin _ text _ box . name = STR ; this . plugin _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . plugin _ text _ box . tab _ index = NUM ; this . plugin _ text _ box . word _ wrap = false ; this . remarks _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ;
this . remarks _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . remarks _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . remarks _ text _ box . max _ length = NUM ; this . remarks _ text _ box . name = STR ; this . remarks _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . remarks _ text _ box . tab _ index = NUM ; this . remarks _ text _ box . word _ wrap = false ; this . ip _ label . anchor = system . windows . forms . anchor _ styles . right ; this . ip _ label . auto _ size = true ;
this . ip _ label . anchor = system . windows . forms . anchor _ styles . right ; this . ip _ label . auto _ size = true ; this . ip _ label . location = new system . drawing . point ( NUM , NUM ) ; this . ip _ label . name = STR ; this . ip _ label . size = new system . drawing . size ( NUM , NUM ) ; this . ip _ label . tab _ index = 0 ; this . ip _ label . text = STR ; this . server _ port _ label . anchor = system . windows . forms . anchor _ styles . right ; this . server _ port _ label . auto _ size = true ;
this . server _ port _ label . anchor = system . windows . forms . anchor _ styles . right ; this . server _ port _ label . auto _ size = true ; this . server _ port _ label . location = new system . drawing . point ( NUM , NUM ) ; this . server _ port _ label . name = STR ; this . server _ port _ label . size = new system . drawing . size ( NUM , NUM ) ; this . server _ port _ label . tab _ index = 1 ; this . server _ port _ label . text = STR ; this . password _ label . anchor = system . windows . forms . anchor _ styles . right ; this . password _ label . auto _ size = true ;
this . password _ label . anchor = system . windows . forms . anchor _ styles . right ; this . password _ label . auto _ size = true ; this . password _ label . location = new system . drawing . point ( NUM , NUM ) ; this . password _ label . name = STR ; this . password _ label . size = new system . drawing . size ( NUM , NUM ) ; this . password _ label . tab _ index = 2 ; this . password _ label . text = STR ; this . password _ label . text _ align = system . drawing . content _ alignment . middle _ center ; this . ip _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ;
this . password _ label . text _ align = system . drawing . content _ alignment . middle _ center ; this . ip _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . ip _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . ip _ text _ box . max _ length = NUM ; this . ip _ text _ box . name = STR ; this . ip _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . ip _ text _ box . tab _ index = 0 ; this . ip _ text _ box . word _ wrap = false ; this . server _ port _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ;
this . ip _ text _ box . word _ wrap = false ; this . server _ port _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . server _ port _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . server _ port _ text _ box . max _ length = NUM ; this . server _ port _ text _ box . name = STR ; this . server _ port _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . server _ port _ text _ box . tab _ index = 1 ; this . server _ port _ text _ box . word _ wrap = false ; this . password _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ;
this . password _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . password _ text _ box . max _ length = NUM ; this . password _ text _ box . name = STR ; this . password _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . password _ text _ box . tab _ index = 2 ; this . password _ text _ box . use _ system _ password _ char = true ; this . password _ text _ box . word _ wrap = false ; this . encryption _ label . anchor = system . windows . forms . anchor _ styles . right ; this . encryption _ label . auto _ size = true ;
this . encryption _ label . location = new system . drawing . point ( NUM , NUM ) ; this . encryption _ label . name = STR ; this . encryption _ label . size = new system . drawing . size ( NUM , NUM ) ; this . encryption _ label . tab _ index = NUM ; this . encryption _ label . text = STR ; this . encryption _ select . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( ( system . windows . forms . anchor _ styles . top | system . windows . forms . anchor _ styles . left ) | system . windows . forms . anchor _ styles . right ) ) ) ; this . encryption _ select . drop _ down _ style = system . windows . forms . combo _ box _ style . drop _ down _ list ; this . encryption _ select . formatting _ enabled = true ; this . encryption _ select . ime _ mode = system . windows . forms . ime _ mode . no _ control ;
this . encryption _ select . ime _ mode = system . windows . forms . ime _ mode . no _ control ; STR , STR , STR , STR } ) ; this . encryption _ select . location = new system . drawing . point ( NUM , NUM ) ; this . encryption _ select . name = STR ; this . encryption _ select . size = new system . drawing . size ( NUM , NUM ) ; this . encryption _ select . tab _ index = NUM ; this . timeout _ label . anchor = system . windows . forms . anchor _ styles . right ; this . timeout _ label . auto _ size = true ;
this . timeout _ label . anchor = system . windows . forms . anchor _ styles . right ; this . timeout _ label . auto _ size = true ; this . timeout _ label . location = new system . drawing . point ( NUM , NUM ) ; this . timeout _ label . name = STR ; this . timeout _ label . right _ to _ left = system . windows . forms . right _ to _ left . no ; this . timeout _ label . size = new system . drawing . size ( NUM , NUM ) ; this . timeout _ label . tab _ index = NUM ; this . timeout _ label . text = STR ; this . timeout _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ;
this . timeout _ label . text = STR ; this . timeout _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . timeout _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . timeout _ text _ box . max _ length = NUM ; this . timeout _ text _ box . name = STR ; this . timeout _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . timeout _ text _ box . tab _ index = NUM ; this . plugin _ label . anchor = system . windows . forms . anchor _ styles . right ; this . plugin _ label . auto _ size = true ;
this . timeout _ text _ box . tab _ index = NUM ; this . plugin _ label . anchor = system . windows . forms . anchor _ styles . right ; this . plugin _ label . auto _ size = true ; this . plugin _ label . location = new system . drawing . point ( NUM , NUM ) ; this . plugin _ label . name = STR ; this . plugin _ label . size = new system . drawing . size ( NUM , NUM ) ; this . plugin _ label . tab _ index = NUM ; this . plugin _ label . text = STR ; this . plugin _ options _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ;
this . plugin _ options _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . plugin _ options _ text _ box . max _ length = NUM ; this . plugin _ options _ text _ box . name = STR ; this . plugin _ options _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . plugin _ options _ text _ box . tab _ index = NUM ; this . plugin _ options _ text _ box . word _ wrap = false ; this . show _ passwd _ check _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( ( system . windows . forms . anchor _ styles . top | system . windows . forms . anchor _ styles . bottom ) | system . windows . forms . anchor _ styles . left ) ) ) ; this . show _ passwd _ check _ box . auto _ size = true ;
this . show _ passwd _ check _ box . location = new system . drawing . point ( NUM , NUM ) ; this . show _ passwd _ check _ box . name = STR ; this . show _ passwd _ check _ box . size = new system . drawing . size ( NUM , NUM ) ; this . show _ passwd _ check _ box . tab _ index = NUM ; this . show _ passwd _ check _ box . text = STR ; this . show _ passwd _ check _ box . text _ align = system . drawing . content _ alignment . middle _ center ; this . show _ passwd _ check _ box . use _ visual _ style _ back _ color = true ; this . show _ passwd _ check _ box . checked _ changed + = new system . event _ handler ( this . show _ passwd _ check _ box _ checked _ changed ) ; this . plugin _ arguments _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ;
this . plugin _ arguments _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . plugin _ arguments _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . plugin _ arguments _ text _ box . max _ length = NUM ; this . plugin _ arguments _ text _ box . name = STR ; this . plugin _ arguments _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . plugin _ arguments _ text _ box . tab _ index = NUM ; this . plugin _ arguments _ text _ box . word _ wrap = false ; this . plugin _ arguments _ label . anchor = system . windows . forms . anchor _ styles . right ; this . plugin _ arguments _ label . auto _ size = true ;
this . plugin _ arguments _ label . location = new system . drawing . point ( NUM , NUM ) ; this . plugin _ arguments _ label . name = STR ; this . plugin _ arguments _ label . size = new system . drawing . size ( NUM , NUM ) ; this . plugin _ arguments _ label . tab _ index = NUM ; this . plugin _ arguments _ label . text = STR ; this . tool _ tip . set _ tool _ tip ( this . plugin _ arguments _ label , STR + STR ) ; this . remarks _ label . anchor = system . windows . forms . anchor _ styles . right ; this . remarks _ label . auto _ size = true ;
STR ) ; this . remarks _ label . anchor = system . windows . forms . anchor _ styles . right ; this . remarks _ label . auto _ size = true ; this . remarks _ label . location = new system . drawing . point ( NUM , NUM ) ; this . remarks _ label . name = STR ; this . remarks _ label . size = new system . drawing . size ( NUM , NUM ) ; this . remarks _ label . tab _ index = NUM ; this . remarks _ label . text = STR ; this . need _ plugin _ arg _ check _ box . auto _ size = true ;
this . need _ plugin _ arg _ check _ box . location = new system . drawing . point ( NUM , NUM ) ; this . need _ plugin _ arg _ check _ box . name = STR ; this . need _ plugin _ arg _ check _ box . size = new system . drawing . size ( NUM , NUM ) ; this . need _ plugin _ arg _ check _ box . tab _ index = NUM ; this . need _ plugin _ arg _ check _ box . text = STR ; this . need _ plugin _ arg _ check _ box . use _ visual _ style _ back _ color = true ; this . need _ plugin _ arg _ check _ box . checked _ changed + = new system . event _ handler ( this . use _ plugin _ arg _ check _ box _ checked _ changed ) ; this . panel . anchor = system . windows . forms . anchor _ styles . top ; this . panel . auto _ size = true ; this . panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ;
this . table _ layout _ panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . table _ layout _ panel . column _ count = 2 ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . controls . add ( this . proxy _ port _ text _ box , 1 , 0 ) ; this . table _ layout _ panel . controls . add ( this . proxy _ port _ label , 0 , 0 ) ; this . table _ layout _ panel . controls . add ( this . portable _ mode _ check _ box , 0 , 1 ) ; this . table _ layout _ panel . location = new system . drawing . point ( NUM , NUM ) ; this . table _ layout _ panel . margin = new system . windows . forms . padding ( 0 ) ; this . table _ layout _ panel . name = STR ;
this . table _ layout _ panel . location = new system . drawing . point ( NUM , NUM ) ; this . table _ layout _ panel . margin = new system . windows . forms . padding ( 0 ) ; this . table _ layout _ panel . name = STR ; this . table _ layout _ panel . padding = new system . windows . forms . padding ( NUM ) ; this . table _ layout _ panel . row _ count = 2 ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ; this . table _ layout _ panel . tab _ index = NUM ; this . proxy _ port _ text _ box . anchor = system . windows . forms . anchor _ styles . left ;
this . proxy _ port _ text _ box . anchor = system . windows . forms . anchor _ styles . left ; this . proxy _ port _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . proxy _ port _ text _ box . max _ length = NUM ; this . proxy _ port _ text _ box . name = STR ; this . proxy _ port _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . proxy _ port _ text _ box . tab _ index = NUM ; this . proxy _ port _ text _ box . word _ wrap = false ; this . proxy _ port _ label . anchor = system . windows . forms . anchor _ styles . right ; this . proxy _ port _ label . auto _ size = true ;
this . proxy _ port _ label . auto _ size = true ; this . proxy _ port _ label . location = new system . drawing . point ( NUM , NUM ) ; this . proxy _ port _ label . name = STR ; this . proxy _ port _ label . size = new system . drawing . size ( NUM , NUM ) ; this . proxy _ port _ label . tab _ index = NUM ; this . proxy _ port _ label . text = STR ; this . portable _ mode _ check _ box . anchor = system . windows . forms . anchor _ styles . left ; this . portable _ mode _ check _ box . auto _ size = true ; this . table _ layout _ panel . set _ column _ span ( this . portable _ mode _ check _ box , 2 ) ;
using system ; using microsoft _ visual _ studio _ test _ tools _ unit _ testing ; using shadowsocks _ controller ;
using system ; using microsoft _ visual _ studio _ test _ tools _ unit _ testing ; using shadowsocks _ controller ; using shadowsocks _ encryption ; using global _ hot _ key ; using system _ windows _ input ; using system _ threading ; using system _ collections _ generic ; using shadowsocks _ controller _ hotkeys ;
using microsoft _ visual _ studio _ test _ tools _ unit _ testing ; using shadowsocks _ controller ; using shadowsocks _ encryption ; using global _ hot _ key ; using system _ windows _ input ; using system _ threading ; using system _ collections _ generic ; using shadowsocks _ controller _ hotkeys ; using shadowsocks _ encryption _ stream ; using shadowsocks _ model ; using shadowsocks _ controller _ service ; using system _ diagnostics ;
{ if ( file . exists ( pac _ file ) ) { return file . read _ all _ text ( pac _ file , encoding . ut ) ; } else { return utils . un _ gzip ( resources . proxy _ pac _ txt ) ; } }
} else { return utils . un _ gzip ( resources . proxy _ pac _ txt ) ; } } public void send _ response ( byte [ ] first _ packet , int length , socket socket , bool use _ socks ) { try {
{ return utils . un _ gzip ( resources . proxy _ pac _ txt ) ; } } public void send _ response ( byte [ ] first _ packet , int length , socket socket , bool use _ socks ) { try { string pac = get _ pac _ content ( ) ; ip _ end _ point local _ end _ point = ( ip _ end _ point ) socket . local _ end _ point ;
{ string pac = get _ pac _ content ( ) ; ip _ end _ point local _ end _ point = ( ip _ end _ point ) socket . local _ end _ point ; string proxy = get _ pac _ address ( first _ packet , length , local _ end _ point , use _ socks ) ; pac = pac . replace ( STR , proxy ) ; string text = string . format ( @ STR server : shadowsocks content - type : application / x - ns - proxy - autoconfig content - length : { 0 } connection : close
{ process old _ process = old _ processes [ 0 ] ; } message _ box . show ( STR ) ; return ; } string temp _ path = path . get _ temp _ path ( ) ; string dll _ path = temp _ path + STR ; try {
} flags public enum internet _ option _ per _ conn _ flags _ ui { proxy _ type _ direct = 0 , proxy _ type _ proxy = 0 , proxy _ type _ auto _ proxy _ url = 0 , proxy _ type _ auto _ detect = 0 } struct _ layout _ layout _ kind _ explicit
all other rights reserved . this code and information is provided STR without warranty of any kind , either expressed or implied , including but not limited to the implied warranties of merchantability and / or fitness for a particular purpose . \ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * / using system _ runtime _ interop _ services ; namespace shadowsocks _ util _ system _ proxy { struct _ layout _ layout _ kind _ sequential _ char _ set _ char _ set _ ansi
{ public class logging { public static string log _ file _ path ; private static date _ time log _ file _ creation _ time ; public static bool open _ log _ file ( ) { try { log _ file _ path = utils . get _ temp _ path ( STR ) ;
console . set _ error ( sw ) ; } return true ; } catch ( io _ exception e ) { console . write _ line ( e . to _ string ( ) ) ; return false ; } }
} catch ( io _ exception e ) { console . write _ line ( e . to _ string ( ) ) ; return false ; } } file _ stream fs = new file _ stream ( log _ file _ path , file _ mode . create _ new ) ; log _ file _ creation _ time = date _ time . now ; ms . copy _ to ( fs ) ; stream _ writer _ with _ timestamp sw = new stream _ writer _ with _ timestamp ( fs ) ; sw . auto _ flush = true ; console . set _ out ( sw ) ; console . set _ error ( sw ) ; } private static void write _ to _ log _ file ( object o ) {
using system _ diagnostics ; using microsoft _ win ; using shadowsocks _ controller ; using shadowsocks _ model ; using shadowsocks _ properties ; namespace shadowsocks _ view { public partial class config _ form : form { private shadowsocks _ controller controller ;
using shadowsocks _ model ; using shadowsocks _ properties ; namespace shadowsocks _ view { public partial class config _ form : form { private shadowsocks _ controller controller ; private update _ checker update _ checker ; private configuration modified _ configuration ; private int old _ selected _ index = - 1 ;
using system _ text ; using system _ net ; namespace shadowsocks _ encryption { public abstract class iv _ encryptor : encryptor _ base { public const int max _ key _ length = NUM ; public const int max _ iv _ length = NUM ; protected static byte [ ] tempbuf = new byte [ max _ input _ size ] ;
protected static byte [ ] tempbuf = new byte [ max _ input _ size ] ; protected dictionary < string , dictionary < string , int [ ] > > ciphers ; protected dictionary < string , int [ ] > ciphers _ detail ; private static readonly concurrent _ dictionary < string , byte [ ] > cached _ keys = new concurrent _ dictionary < string , byte [ ] > ( ) ; protected byte [ ] encrypt _ iv ; protected byte [ ] decrypt _ iv ; protected bool decrypt _ iv _ received ; protected bool encrypt _ iv _ sent ; protected string method ; protected int cipher ; protected string cipher _ mbed _ name ;
protected string cipher _ mbed _ name ; protected int [ ] cipher _ info ; protected byte [ ] key ; protected int key _ len ; protected int iv _ len ; public iv _ encryptor ( string method , string password , bool onetimeauth , bool isudp ) : base ( method , password , onetimeauth , isudp ) { init _ key ( method , password ) ; }
{ init _ key ( method , password ) ; } protected abstract dictionary < string , dictionary < string , int [ ] > > get _ ciphers ( ) ; private void init _ key ( string method , string password ) { method = method . to _ lower ( ) ; method = method ; string k = method + STR + password ; ciphers = get _ ciphers ( ) ;
method = method . to _ lower ( ) ; method = method ; string k = method + STR + password ; ciphers = get _ ciphers ( ) ; ciphers _ detail = ciphers [ method ] ; cipher _ mbed _ name = ciphers _ detail . keys . first _ or _ default ( ) ; cipher _ info = ciphers [ method ] [ cipher _ mbed _ name ] ; cipher = cipher _ info [ 2 ] ; if ( cipher = = 0 ) { throw new exception ( STR ) ; }
const int cipher _ r = 1 ; const int cipher _ aes = 2 ; const int cipher _ blowfish = NUM ; const int cipher _ camellia = NUM ; private int _ ptr encrypt _ ctx = int _ ptr . zero ; private int _ ptr decrypt _ ctx = int _ ptr . zero ; public mbed _ tls _ encryptor ( string method , string password , bool onetimeauth , bool isudp ) : base ( method , password , onetimeauth , isudp ) { }
{ STR , new dictionary < string , int [ ] > { { STR , new int [ ] { NUM , NUM , cipher _ blowfish } } } } , { STR , new dictionary < string , int [ ] > { { STR , new int [ ] { NUM , NUM , cipher _ camellia } } } } , { STR , new dictionary < string , int [ ] > { { STR , new int [ ] { NUM , NUM , cipher _ camellia } } } } , { STR , new dictionary < string , int [ ] > { { STR , new int [ ] { NUM , NUM , cipher _ camellia } } } } , { STR , new dictionary < string , int [ ] > { { STR , new int [ ] { NUM , NUM , cipher _ r } } } } } ; public static list < string > supported _ ciphers ( ) { return new list < string > ( ciphers . keys ) ; }
const int sodium _ block _ size = NUM ; static byte [ ] sodium _ buf = new byte [ max _ input _ size + sodium _ block _ size ] ; protected int encrypt _ bytes _ remaining ; protected int decrypt _ bytes _ remaining ; protected ulong encrypt _ ic ; protected ulong decrypt _ ic ; public sodium _ encryptor ( string method , string password , bool onetimeauth , bool isudp ) : base ( method , password , onetimeauth , isudp ) { }
protected ulong decrypt _ ic ; public sodium _ encryptor ( string method , string password , bool onetimeauth , bool isudp ) : base ( method , password , onetimeauth , isudp ) { } private static dictionary < string , dictionary < string , int [ ] > > ciphers = new dictionary < string , dictionary < string , int [ ] > > { { STR , new dictionary < string , int [ ] > { { STR , new int [ ] { NUM , NUM , cipher _ sals } } } } , { STR , new dictionary < string , int [ ] > { { STR , new int [ ] { NUM , NUM , cipher _ chach } } } } , { STR , new dictionary < string , int [ ] > { { STR , new int [ ] { NUM , NUM , cipher _ chach _ ietf } } } } } ;
if ( disposing & & ( components ! = null ) ) { components . dispose ( ) ; } base . dispose ( disposing ) ; } private void initialize _ component ( ) { this . components = new system . component _ model . container ( ) ; this . auto _ scale _ mode = system . windows . forms . auto _ scale _ mode . font ;
namespace shadowsocks _ encryption { public abstract class iv _ encryptor : encryptor _ base { public const int onetimeauth _ flag = 0 ; public const int addrtype _ mask = 0 xf ; public const int onetimeauth _ bytes = NUM ;
protected bool decrypt _ iv _ received ; protected bool encrypt _ iv _ sent ; protected int encrypt _ iv _ offset = 0 ; protected int decrypt _ iv _ offset = 0 ; protected string method ; protected int cipher ; protected int [ ] cipher _ info ; protected byte [ ] key ; protected int key _ len ; protected int iv _ len ;
protected int key _ len ; protected int iv _ len ; protected byte [ ] crc _ buf ; protected int crc _ idx = 0 ; public iv _ encryptor ( string method , string password , bool onetimeauth ) : base ( method , password , onetimeauth ) { init _ key ( method , password ) ; if ( onetime _ auth ) {
if ( ! encrypt _ iv _ sent ) { encrypt _ iv _ sent = true ; rand _ bytes ( outbuf , iv _ len ) ; init _ cipher ( outbuf , true ) ; outlength = length + iv _ len ; lock ( tempbuf ) { if ( onetime _ auth ) {
encrypt _ iv _ sent = true ; rand _ bytes ( outbuf , iv _ len ) ; init _ cipher ( outbuf , true ) ; outlength = length + iv _ len ; lock ( tempbuf ) { if ( onetime _ auth ) { lock ( crc _ buf ) {
{ if ( onetime _ auth ) { lock ( crc _ buf ) { int head _ len = get _ ss _ head _ length ( buf , length ) ; int data _ len = length - head _ len ; buffer . block _ copy ( buf , head _ len , buf , head _ len + onetimeauth _ bytes , data _ len ) ; buf [ 0 ] | = onetimeauth _ flag ; byte [ ] auth = new byte [ onetimeauth _ bytes ] ;
lock ( crc _ buf ) { int head _ len = get _ ss _ head _ length ( buf , length ) ; int data _ len = length - head _ len ; buffer . block _ copy ( buf , head _ len , buf , head _ len + onetimeauth _ bytes , data _ len ) ; buf [ 0 ] | = onetimeauth _ flag ; byte [ ] auth = new byte [ onetimeauth _ bytes ] ; sodium . ss _ onetimeauth ( auth , buf , head _ len , encrypt _ iv , iv _ len , key , key _ len ) ; buffer . block _ copy ( auth , 0 , buf , head _ len , onetimeauth _ bytes ) ; int buf _ offset = head _ len + onetimeauth _ bytes ;
} cipher _ update ( true , length , buf , tempbuf ) ; outlength = length + iv _ len ; buffer . block _ copy ( tempbuf , 0 , outbuf , iv _ len , length ) ; } } else { if ( onetime _ auth ) {
buffer . block _ copy ( tempbuf , 0 , outbuf , iv _ len , length ) ; } } else { if ( onetime _ auth ) { lock ( crc _ buf ) { int buf _ offset = 0 ;
} load _ library ( dll _ path ) ; } dll _ import _ kernel _ dll private static extern int _ ptr load _ library ( string path ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int crypto _ stream _ salsa _ xor _ ic ( byte [ ] c , byte [ ] m , ulong mlen , byte [ ] n , ulong ic , byte [ ] k ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int crypto _ stream _ chacha _ xor _ ic ( byte [ ] c , byte [ ] m , ulong mlen , byte [ ] n , ulong ic , byte [ ] k ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl
dll _ import _ kernel _ dll private static extern int _ ptr load _ library ( string path ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int crypto _ stream _ salsa _ xor _ ic ( byte [ ] c , byte [ ] m , ulong mlen , byte [ ] n , ulong ic , byte [ ] k ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int crypto _ stream _ chacha _ xor _ ic ( byte [ ] c , byte [ ] m , ulong mlen , byte [ ] n , ulong ic , byte [ ] k ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int ss _ gen _ crc ( byte [ ] buf , ref int buf _ offset , ref int data _ len , byte [ ] crc _ buf , ref int crc _ idx , int buf _ size ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl
private void config _ form _ shown ( object sender , event _ args e ) { ip _ text _ box . focus ( ) ; } private void qr _ code _ item _ click ( object sender , event _ args e ) { qr _ code _ form qr _ code _ form = new qr _ code _ form ( controller . get _ qr _ code _ for _ current _ server ( ) ) ; qr _ code _ form . icon = this . icon ; qr _ code _ form . show ( ) ; }
} private void qr _ code _ item _ click ( object sender , event _ args e ) { qr _ code _ form qr _ code _ form = new qr _ code _ form ( controller . get _ qr _ code _ for _ current _ server ( ) ) ; qr _ code _ form . icon = this . icon ; qr _ code _ form . show ( ) ; } if ( item . equals ( STR ) ) return true ; } return false ; } catch ( exception e ) { return false ; } } private void auto _ startup _ click ( object sender , event _ args e ) { auto _ startup . checked = ! auto _ startup . checked ;
qr _ code _ form . show ( ) ; } return false ; } } private void auto _ startup _ click ( object sender , event _ args e ) { auto _ startup . checked = ! auto _ startup . checked ; if ( ! set _ auto _ startup ( auto _ startup . checked ) ) { } } private void context _ menu _ popup ( object sender , event _ args e ) {
initialize _ component ( ) ; this . icon = icon . from _ handle ( resources . ssw . get _ hicon ( ) ) ; this . text = n . get _ string ( STR ) ; } private void gen _ qr ( string ssconfig ) { string qr _ text = ssconfig ; qr _ code code = z _ xing . qr _ code . internal . encoder . encode ( qr _ text , error _ correction _ level . m ) ; byte _ matrix m = code . matrix ; int block _ size = math . max ( NUM / m . height , 1 ) ;
internal static string default _ byte _ mode _ encoding = STR ; private static int calculate _ mask _ penalty ( byte _ matrix matrix ) { return mask _ util . apply _ mask _ penalty _ rule ( matrix ) + mask _ util . apply _ mask _ penalty _ rule ( matrix ) + mask _ util . apply _ mask _ penalty _ rule ( matrix ) + mask _ util . apply _ mask _ penalty _ rule ( matrix ) ; } public static qr _ code encode ( string content , error _ correction _ level ec _ level ) {
{ return mask _ util . apply _ mask _ penalty _ rule ( matrix ) + mask _ util . apply _ mask _ penalty _ rule ( matrix ) + mask _ util . apply _ mask _ penalty _ rule ( matrix ) + mask _ util . apply _ mask _ penalty _ rule ( matrix ) ; } public static qr _ code encode ( string content , error _ correction _ level ec _ level ) { return encode ( content , ec _ level , null ) ; } public static qr _ code encode ( string content , error _ correction _ level ec _ level , i _ dictionary < encode _ hint _ type , object > hints ) {
+ mask _ util . apply _ mask _ penalty _ rule ( matrix ) + mask _ util . apply _ mask _ penalty _ rule ( matrix ) ; } public static qr _ code encode ( string content , error _ correction _ level ec _ level ) { return encode ( content , ec _ level , null ) ; } public static qr _ code encode ( string content , error _ correction _ level ec _ level , i _ dictionary < encode _ hint _ type , object > hints ) { string encoding = hints = = null | | ! hints . contains _ key ( encode _ hint _ type . character _ set ) ? null : ( string ) hints [ encode _ hint _ type . character _ set ] ; if ( encoding = = null ) { encoding = default _ byte _ mode _ encoding ; } bool generate _ eci = ! default _ byte _ mode _ encoding . equals ( encoding ) ; const string encoding = STR ; bool generate _ eci = ( hints ! = null & & hints . contains _ key ( encode _ hint _ type . character _ set ) ) ;
{ throw new exception ( num _ letters + STR + ( ( 1 < < num _ bits ) - 1 ) ) ; } bits . append _ bits ( num _ letters , num _ bits ) ; } internal static void append _ bytes ( string content , mode mode , bit _ array bits , string encoding ) {
bits . append _ bits ( num _ letters , num _ bits ) ; } internal static void append _ bytes ( string content , mode mode , bit _ array bits , string encoding ) { if ( mode . equals ( mode . numeric ) ) append _ numeric _ bytes ( content , bits ) ; else if ( mode . equals ( mode . alphanumeric ) ) append _ alphanumeric _ bytes ( content , bits ) ; else if ( mode . equals ( mode . byte ) ) append _ bit _ bytes ( content , bits , encoding ) ;
mode mode , bit _ array bits , string encoding ) { append _ numeric _ bytes ( content , bits ) ; else if ( mode . equals ( mode . alphanumeric ) ) append _ alphanumeric _ bytes ( content , bits ) ; else if ( mode . equals ( mode . byte ) ) append _ bit _ bytes ( content , bits , encoding ) ; else if ( mode . equals ( mode . kanji ) ) append _ kanji _ bytes ( content , bits ) ; else throw new exception ( STR + mode ) ;
{ get { return NUM + NUM * version _ number ; } } public ec _ blocks get _ ec _ blocks _ for _ level ( error _ correction _ level ec _ level ) { return ec _ blocks [ ec _ level . ordinal ( ) ] ; }
return ec _ blocks [ ec _ level . ordinal ( ) ] ; } return null ; } } public static version get _ version _ for _ number ( int version _ number ) { if ( version _ number < 1 | | version _ number > NUM ) { throw new argument _ exception ( ) ; } return versions [ version _ number - 1 ] ;
return exp _ table [ size - log _ table [ a ] - 1 ] ; } internal int multiply ( int a , int b ) { if ( a = = 0 | | b = = 0 ) { return 0 ; } return exp _ table [ ( log _ table [ a ] + log _ table [ b ] ) % ( size - 1 ) ] ; }
{ return 0 ; } return exp _ table [ ( log _ table [ a ] + log _ table [ b ] ) % ( size - 1 ) ] ; } public int size { get { return size ; } } public int generator _ base { get { return generator _ base ; } }

set { if ( value ) bits [ i > > NUM ] | = 1 < < ( i & 0 f ) ; } } public bit _ array ( ) { this . size = 0 ; this . bits = new int [ 1 ] ;
{ if ( this [ bit _ offset ] ) { the _ byte | = 1 < < ( NUM - j ) ; } bit _ offset + + ; } array [ offset + i ] = ( byte ) the _ byte ; } }
array [ offset + i ] = ( byte ) the _ byte ; } } current _ int = ( next _ int > > left _ offset ) & mask ; } new _ bits [ old _ bits _ len - 1 ] = current _ int ; } bits = new _ bits ; } private static int [ ] make _ array ( int size ) { return new int [ ( size + NUM ) > > NUM ] ; }
proxy _ form . activate ( ) ; } else { proxy _ form = new proxy _ form ( controller ) ; proxy _ form . show ( ) ; proxy _ form . activate ( ) ; proxy _ form . form _ closed + = proxy _ form _ form _ closed ; } }
} { log _ form f = new log _ form ( controller , logging . log _ file _ path ) ; f . show ( ) ; f . activate ( ) ; f . form _ closed + = log _ form _ form _ closed ; log _ forms . add ( f ) ; log _ forms _ visible = true ; } else {
log _ forms _ visible = true ; } else { log _ forms _ visible = ! log _ forms _ visible ; foreach ( log _ form f in log _ forms ) { f . visible = log _ forms _ visible ; } } } void log _ form _ form _ closed ( object sender , form _ closed _ event _ args e ) {
if ( cipher = = 0 ) { throw new exception ( STR ) ; } key _ len = cipher _ info [ 0 ] ; iv _ len = cipher _ info [ 1 ] ; key = cached _ keys . get _ or _ add ( k , ( nk ) = > { byte [ ] passbuf = encoding . ut . get _ bytes ( password ) ; byte [ ] key = new byte [ NUM ] ;
iv _ len = cipher _ info [ 1 ] ; key = cached _ keys . get _ or _ add ( k , ( nk ) = > { byte [ ] passbuf = encoding . ut . get _ bytes ( password ) ; byte [ ] key = new byte [ NUM ] ; byte [ ] iv = new byte [ NUM ] ; bytes _ to _ key ( passbuf , key ) ; return key ; } ) ; }
log _ file _ name _ element . set _ attribute ( logger _ file _ name _ attribute , file _ name ) ; } private static xml _ node select _ single _ node ( xml _ document doc , string xpath ) { xml _ namespace _ manager manager = new xml _ namespace _ manager ( doc . name _ table ) ; manager . add _ namespace ( STR , STR ) ; return doc . select _ single _ node ( xpath , manager ) ; } public static void touch _ and _ apply _ n _ log _ config ( ) {
manager . add _ namespace ( STR , STR ) ; return doc . select _ single _ node ( xpath , manager ) ; } public static void touch _ and _ apply _ n _ log _ config ( ) { if ( ! file . exists ( nlog _ config _ file _ name ) ) { file . write _ all _ text ( nlog _ config _ file _ name , properties . resources . n _ log _ config ) ;
public static sip _ plugin create _ if _ configured ( server server ) { if ( server = = null ) { throw new argument _ null _ exception ( nameof ( server ) ) ; } if ( string . is _ null _ or _ white _ space ( server . plugin ) ) { return null ; }
if ( server = = null ) { throw new argument _ null _ exception ( nameof ( server ) ) ; } if ( string . is _ null _ or _ white _ space ( server . plugin ) ) { return null ; } return new sip _ plugin ( server . plugin , server . plugin _ opts , server . server , server . server _ port ) ; }
this . table _ layout _ panel . controls . add ( this . plugin _ label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . plugin _ options _ text _ box , 1 , NUM ) ; this . table _ layout _ panel . controls . add ( this . show _ passwd _ check _ box , 1 , NUM ) ; this . table _ layout _ panel . location = new system . drawing . point ( NUM , NUM ) ; this . table _ layout _ panel . margin = new system . windows . forms . padding ( 0 ) ; this . table _ layout _ panel . name = STR ; this . table _ layout _ panel . padding = new system . windows . forms . padding ( NUM ) ;
this . table _ layout _ panel . resume _ layout ( false ) ; this . table _ layout _ panel . resume _ layout ( false ) ; this . resume _ layout ( false ) ; this . perform _ layout ( ) ; } private system . windows . forms . table _ layout _ panel table _ layout _ panel ; private system . windows . forms . label ip _ label ; private system . windows . forms . label server _ port _ label ; private system . windows . forms . label password _ label ;
this . perform _ layout ( ) ; } private system . windows . forms . table _ layout _ panel table _ layout _ panel ; private system . windows . forms . label ip _ label ; private system . windows . forms . label server _ port _ label ; private system . windows . forms . label password _ label ; private system . windows . forms . label proxy _ port _ label ; private system . windows . forms . text _ box ip _ text _ box ; private system . windows . forms . text _ box server _ port _ text _ box ; private system . windows . forms . text _ box password _ text _ box ;
this . ok _ button = new system . windows . forms . button ( ) ; this . my _ cancel _ button = new system . windows . forms . button ( ) ; this . panel = new system . windows . forms . panel ( ) ; this . context _ menu = new system . windows . forms . context _ menu ( ) ; this . enable _ item = new system . windows . forms . menu _ item ( ) ; this . config _ item = new system . windows . forms . menu _ item ( ) ; this . edit _ pac _ file _ item = new system . windows . forms . menu _ item ( ) ; this . about _ item = new system . windows . forms . menu _ item ( ) ; this . menu _ item = new system . windows . forms . menu _ item ( ) ; this . quit _ item = new system . windows . forms . menu _ item ( ) ;
this . controls . add ( this . group _ box ) ;
private system . windows . forms . button ok _ button ; private system . windows . forms . button my _ cancel _ button ; private system . windows . forms . panel panel ; private system . windows . forms . context _ menu context _ menu ; private system . windows . forms . menu _ item enable _ item ; private system . windows . forms . menu _ item about _ item ; private system . windows . forms . menu _ item menu _ item ; private system . windows . forms . menu _ item quit _ item ; private system . windows . forms . menu _ item config _ item ; private system . windows . forms . menu _ item edit _ pac _ file _ item ;
using system _ reflection ; using system _ runtime _ compiler _ services ; using system _ runtime _ interop _ services ; assembly _ assembly _ title _ shadowsocks assembly _ assembly _ description assembly _ assembly _ configuration
assembly _ assembly _ description assembly _ assembly _ configuration assembly _ assembly _ company _ clowwindy assembly _ assembly _ product _ shadowsocks assembly _ assembly _ copyright _ copyright _ clowwindy assembly _ assembly _ trademark assembly _ assembly _ culture assembly _ com _ visible _ false assembly _ guid _ bbd _ dcf assembly _ assembly _ version
public bool bool _ value { get { return typed _ value _ case = = typed _ value _ oneof _ case . bool _ value ? ( bool ) typed _ value : false ; } set { typed _ value = value ; typed _ value _ case = typed _ value _ oneof _ case . bool _ value ; } } public const int int _ value _ field _ number = NUM ; global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute public long int _ value {
global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute public long int _ value { country _ code = other . country _ code ; domain = other . domain . clone ( ) ; unknown _ fields = pb : : unknown _ field _ set . clone ( other . unknown _ fields ) ; } global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute public geosite clone ( ) { return new geosite ( this ) ; }
global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute public geosite clone ( ) { return new geosite ( this ) ; } public const int country _ code _ field _ number = 1 ; private string country _ code = STR ; global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute public string country _ code { get { return country _ code ; } set {
global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute public string country _ code { get { return country _ code ; } set { country _ code = pb : : proto _ preconditions . check _ not _ null ( value , STR ) ; } } public const int domain _ field _ number = 2 ; private static readonly pb : : field _ codec < global :: domain _ object > repeated _ domain _ codec = pb : : field _ codec . for _ message ( NUM , global :: domain _ object . parser ) ;
return equals ( other as geosite ) ; } global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute public bool equals ( geosite other ) { if ( reference _ equals ( other , null ) ) { return false ; } if ( reference _ equals ( other , this ) ) { return true ; }
if ( reference _ equals ( other , this ) ) { return true ; } if ( country _ code ! = other . country _ code ) return false ; if ( ! domain . equals ( other . domain ) ) return false ; return equals ( unknown _ fields , other . unknown _ fields ) ; } global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute public override int get _ hash _ code ( ) { int hash = 1 ;
hash ^ = unknown _ fields . get _ hash _ code ( ) ; } return hash ; } global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute public override string to _ string ( ) { return pb : : json _ formatter . to _ diagnostic _ string ( this ) ; } global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute public void write _ to ( pb : : coded _ output _ stream output ) {
return hash ; } global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute public override string to _ string ( ) { return pb : : json _ formatter . to _ diagnostic _ string ( this ) ; } global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute public void write _ to ( pb : : coded _ output _ stream output ) { if ( country _ code . length ! = 0 ) { output . write _ raw _ tag ( NUM ) ;
output . write _ string ( country _ code ) ; } domain . write _ to ( output , repeated _ domain _ codec ) ; if ( unknown _ fields ! = null ) { unknown _ fields . write _ to ( output ) ; } } global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute public int calculate _ size ( ) { int size = 0 ;
} global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute public void merge _ from ( pb : : coded _ input _ stream input ) { uint tag ; while ( ( tag = input . read _ tag ( ) ) ! = 0 ) { switch ( tag ) { default : unknown _ fields = pb : : unknown _ field _ set . merge _ field _ from ( unknown _ fields , input ) ; break ; case NUM : {
while ( ( tag = input . read _ tag ( ) ) ! = 0 ) { switch ( tag ) { default : unknown _ fields = pb : : unknown _ field _ set . merge _ field _ from ( unknown _ fields , input ) ; break ; case NUM : { country _ code = input . read _ string ( ) ; break ; } case NUM : {
partial void on _ construction ( ) ; global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute public geosite _ list ( geosite _ list other ) : this ( ) { entry = other . entry . clone ( ) ; unknown _ fields = pb : : unknown _ field _ set . clone ( other . unknown _ fields ) ; } global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute public geosite _ list clone ( ) { return new geosite _ list ( this ) ; }
entry = other . entry . clone ( ) ; unknown _ fields = pb : : unknown _ field _ set . clone ( other . unknown _ fields ) ; } global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute public geosite _ list clone ( ) { return new geosite _ list ( this ) ; } public const int entry _ field _ number = 1 ; private static readonly pb : : field _ codec < global :: geosite > repeated _ entry _ codec = pb : : field _ codec . for _ message ( NUM , global :: geosite . parser ) ;
return equals ( other as geosite _ list ) ; } global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute public bool equals ( geosite _ list other ) { if ( reference _ equals ( other , null ) ) { return false ; } if ( reference _ equals ( other , this ) ) { return true ; }
using system _ threading _ tasks ; using google _ protobuf ; namespace shadowsocks _ controller { static class geosite _ updater { private static logger logger = log _ manager . get _ current _ class _ logger ( ) ;
private static readonly string database _ path = utils . get _ temp _ path ( STR ) ; public static readonly geosite _ list list ; public static readonly dictionary < string , list < domain _ object > > geosites = new dictionary < string , list < domain _ object > > ( ) ; static geosite _ updater ( ) { if ( ! file . exists ( database _ path ) ) { file . write _ all _ bytes ( database _ path , resources . dlc _ dat ) ; }
public static readonly dictionary < string , list < domain _ object > > geosites = new dictionary < string , list < domain _ object > > ( ) ; static geosite _ updater ( ) { if ( ! file . exists ( database _ path ) ) { file . write _ all _ bytes ( database _ path , resources . dlc _ dat ) ; } list = geosite _ list . parser . parse _ from ( file . read _ all _ bytes ( database _ path ) ) ; foreach ( var item in list . entry ) {
public string [ ] get _ domains ( ) { list < string > lines = new list < string > ( get _ lines ( ) ) ; lines . add _ range ( get _ build _ in ( ) ) ; list < string > domains = new list < string > ( lines . count ) ; for ( int i = 0 ; i < lines . count ; i + + ) { string line = lines [ i ] ; if ( line . index _ of ( STR ) > = 0 ) continue ;
list < string > domains = new list < string > ( lines . count ) ; for ( int i = 0 ; i < lines . count ; i + + ) { string line = lines [ i ] ; if ( line . index _ of ( STR ) > = 0 ) continue ; else if ( line . index _ of ( STR ) > = 0 ) line = line . replace ( STR , STR ) ; if ( line . starts _ with ( STR ) )
string line = lines [ i ] ; if ( line . index _ of ( STR ) > = 0 ) continue ; else if ( line . index _ of ( STR ) > = 0 ) line = line . replace ( STR , STR ) ; if ( line . starts _ with ( STR ) ) line = line . substring ( 2 ) ; else if ( line . starts _ with ( STR ) )
continue ; else if ( line . index _ of ( STR ) > = 0 ) line = line . replace ( STR , STR ) ; if ( line . starts _ with ( STR ) ) line = line . substring ( 2 ) ; else if ( line . starts _ with ( STR ) ) line = line . substring ( 1 ) ; else if ( line . starts _ with ( STR ) )
else if ( line . starts _ with ( STR ) ) line = line . substring ( 1 ) ; else if ( line . starts _ with ( STR ) ) line = line . substring ( 1 ) ; if ( line . starts _ with ( STR ) ) continue ; else if ( line . starts _ with ( STR ) ) continue ; else if ( line . starts _ with ( STR ) ) continue ;
services . add ( pac _ server ) ; services . add ( new port _ forwarder ( privoxy _ runner . running _ port ) ) ; listener = new listener ( services ) ; listener . start ( config ) ; } catch ( exception e ) { if ( e is socket _ exception ) { socket _ exception se = ( socket _ exception ) e ;
break ; case cipher _ r : polar _ ssl . arc _ crypt ( decrypt _ ctx , length , buf , outbuf ) ; break ; } } } public override void dispose ( ) {
using shadowsocks _ properties ; namespace shadowsocks _ view { public partial class config _ form : form { private shadowsocks _ controller controller ; private configuration modified _ configuration ; private int last _ selected _ index = - 1 ; public config _ form ( shadowsocks _ controller controller ) {
{ public partial class config _ form : form { private shadowsocks _ controller controller ; private configuration modified _ configuration ; private int last _ selected _ index = - 1 ; public config _ form ( shadowsocks _ controller controller ) { this . font = system _ fonts . message _ box _ font ; initialize _ component ( ) ;
private int last _ selected _ index = - 1 ; public config _ form ( shadowsocks _ controller controller ) { this . font = system _ fonts . message _ box _ font ; initialize _ component ( ) ; this . servers _ list _ box . dock = dock _ style . fill ; this . table _ layout _ panel . dock = dock _ style . fill ; this . perform _ layout ( ) ; update _ texts ( ) ; setup _ value _ changed _ listeners ( ) ;
server _ port _ label . text = n . get _ string ( STR ) ; password _ label . text = n . get _ string ( STR ) ; show _ passwd _ check _ box . text = n . get _ string ( STR ) ; encryption _ label . text = n . get _ string ( STR ) ; plugin _ label . text = n . get _ string ( STR ) ; plugin _ options _ label . text = n . get _ string ( STR ) ; plugin _ arguments _ label . text = n . get _ string ( STR ) ; need _ plugin _ arg _ check _ box . text = n . get _ string ( STR ) ; proxy _ port _ label . text = n . get _ string ( STR ) ; portable _ mode _ check _ box . text = n . get _ string ( STR ) ;
portable _ mode _ check _ box . text = n . get _ string ( STR ) ; tool _ tip . set _ tool _ tip ( this . portable _ mode _ check _ box , n . get _ string ( STR ) ) ; remarks _ label . text = n . get _ string ( STR ) ; timeout _ label . text = n . get _ string ( STR ) ; server _ group _ box . text = n . get _ string ( STR ) ; ok _ button . text = n . get _ string ( STR ) ; my _ cancel _ button . text = n . get _ string ( STR ) ; apply _ button . text = n . get _ string ( STR ) ; move _ up _ button . text = n . get _ string ( STR ) ; move _ down _ button . text = n . get _ string ( STR ) ;
server _ port _ text _ box . text _ changed + = config _ value _ changed ; } private void controller _ config _ changed ( object sender , event _ args e ) { load _ current _ configuration ( ) ; } private void config _ value _ changed ( object sender , event _ args e ) { apply _ button . enabled = true ; }
} private bool validate _ and _ save _ selected _ server _ details ( ) { try { if ( last _ selected _ index = = - 1 | | last _ selected _ index > = modified _ configuration . configs . count ) { return true ; }
if ( last _ selected _ index > = 0 & & last _ selected _ index < modified _ configuration . configs . count ) { servers _ list _ box . items [ last _ selected _ index ] = modified _ configuration . configs [ last _ selected _ index ] . friendly _ name ( ) ; } update _ buttons ( ) ; load _ selected _ server _ details ( ) ; last _ selected _ index = servers _ list _ box . selected _ index ; } private void add _ button _ click ( object sender , event _ args e ) {
} private void add _ button _ click ( object sender , event _ args e ) { if ( ! validate _ and _ save _ selected _ server _ details ( ) ) { return ; } configuration . add _ default _ server _ or _ server ( modified _ configuration ) ; load _ server _ name _ list _ to _ ui ( modified _ configuration ) ;
{ return ; } configuration . add _ default _ server _ or _ server ( modified _ configuration ) ; load _ server _ name _ list _ to _ ui ( modified _ configuration ) ; if ( last _ selected _ index > = modified _ configuration . configs . count ) { last _ selected _ index = modified _ configuration . configs . count - 1 ; } servers _ list _ box . selected _ index = last _ selected _ index ; load _ server _ name _ list _ to _ ui ( modified _ configuration ) ; servers _ list _ box . selected _ index = last _ selected _ index ; load _ selected _ server _ details ( ) ; update _ buttons ( ) ; }
servers _ list _ box . begin _ update ( ) ; servers _ list _ box . enabled = false ; last _ selected _ index = index + step ; servers _ list _ box . items . remove ( item ) ; servers _ list _ box . items . insert ( index + step , item ) ; servers _ list _ box . enabled = true ; servers _ list _ box . selected _ index = index + step ; servers _ list _ box . end _ update ( ) ; update _ buttons ( ) ; }
{ return ; } if ( servers _ list _ box . selected _ index < servers _ list _ box . items . count - 1 ) { move _ config _ item ( + 1 ) ; } } private void show _ passwd _ check _ box _ checked _ changed ( object sender , event _ args e ) {
{ move _ config _ item ( + 1 ) ; } } private void show _ passwd _ check _ box _ checked _ changed ( object sender , event _ args e ) { this . password _ text _ box . use _ system _ password _ char = ! this . show _ passwd _ check _ box . checked ; } private void use _ plugin _ arg _ check _ box _ checked _ changed ( object sender , event _ args e ) {
using system ; using system _ collections _ generic ; using system _ io ; using shadowsocks _ controller ;
public string pac _ url ; public bool use _ online _ pac ; public bool secure _ local _ pac = true ; public bool availability _ statistics ; public bool auto _ check _ update ; public bool check _ pre _ release ; public bool is _ verbose _ logging ; public log _ viewer _ config log _ viewer ; public proxy _ config proxy ; public hotkey _ config hotkey ;
if ( index > = 0 & & index < configs . count ) return configs [ index ] ; else return get _ default _ server ( ) ; } public static void check _ server ( server server ) { check _ port ( server . server _ port ) ; check _ password ( server . password ) ;
string json _ string = json _ convert . serialize _ object ( config , formatting . indented ) ; sw . write ( json _ string ) ; sw . flush ( ) ; } } catch ( io _ exception e ) { logging . log _ useful _ exception ( e ) ; } }
catch ( io _ exception e ) { logging . log _ useful _ exception ( e ) ; } } public static server add _ default _ server _ or _ server ( configuration config , server server = null ) { if ( config ! = null & & config . configs ! = null ) { server = ( server ? ? get _ default _ server ( ) ) ;
} user _ rule _ file _ watcher = new file _ system _ watcher ( directory . get _ current _ directory ( ) ) ; user _ rule _ file _ watcher . notify _ filter = notify _ filters . last _ write | notify _ filters . file _ name | notify _ filters . directory _ name ; user _ rule _ file _ watcher . filter = user _ rule _ file ; user _ rule _ file _ watcher . changed + = user _ rule _ file _ watcher _ changed ; user _ rule _ file _ watcher . created + = user _ rule _ file _ watcher _ changed ; user _ rule _ file _ watcher . deleted + = user _ rule _ file _ watcher _ changed ; user _ rule _ file _ watcher . renamed + = user _ rule _ file _ watcher _ changed ; user _ rule _ file _ watcher . enable _ raising _ events = true ; }
user _ rule _ file _ watcher . filter = user _ rule _ file ; user _ rule _ file _ watcher . changed + = user _ rule _ file _ watcher _ changed ; user _ rule _ file _ watcher . created + = user _ rule _ file _ watcher _ changed ; user _ rule _ file _ watcher . deleted + = user _ rule _ file _ watcher _ changed ; user _ rule _ file _ watcher . renamed + = user _ rule _ file _ watcher _ changed ; user _ rule _ file _ watcher . enable _ raising _ events = true ; } private static hashtable file _ changed _ time = new hashtable ( ) ; private void pac _ file _ watcher _ changed ( object sender , file _ system _ event _ args e ) {
private static hashtable file _ changed _ time = new hashtable ( ) ; private void pac _ file _ watcher _ changed ( object sender , file _ system _ event _ args e ) { string path = e . full _ path . to _ string ( ) ; string current _ last _ write _ time = file . get _ last _ write _ time ( e . full _ path ) . to _ string ( culture _ info . invariant _ culture ) ; if ( ! file _ changed _ time . contains _ key ( path ) | | file _ changed _ time [ path ] . to _ string ( ) ! = current _ last _ write _ time ) { if ( pac _ file _ changed ! = null ) { logging . info ( $ STR ) ; pac _ file _ changed ( this , new event _ args ( ) ) ;
{ logging . info ( $ STR ) ; pac _ file _ changed ( this , new event _ args ( ) ) ; } file _ changed _ time [ path ] = current _ last _ write _ time ; } } private void user _ rule _ file _ watcher _ changed ( object sender , file _ system _ event _ args e ) {
} private void user _ rule _ file _ watcher _ changed ( object sender , file _ system _ event _ args e ) { string path = e . full _ path . to _ string ( ) ; string current _ last _ write _ time = file . get _ last _ write _ time ( e . full _ path ) . to _ string ( culture _ info . invariant _ culture ) ; if ( ! file _ changed _ time . contains _ key ( path ) | | file _ changed _ time [ path ] . to _ string ( ) ! = current _ last _ write _ time ) { if ( user _ rule _ file _ changed ! = null ) { logging . info ( $ STR ) ; user _ rule _ file _ changed ( this , new event _ args ( ) ) ;

using system ; using system _ diagnostics ; using system _ io ; using system _ threading ; using system _ windows _ forms ; using n _ log ;
using shadowsocks _ controller ; using shadowsocks _ controller _ hotkeys ; using shadowsocks _ util ; using shadowsocks _ view ; using system _ linq ;
using shadowsocks _ util ; using shadowsocks _ view ; using system _ linq ; using system _ i _ pipes ; using system _ text ;
using system _ linq ; using system _ i _ pipes ; using system _ text ; using system _ net ; using system _ threading _ tasks ;
using system _ linq ; using system _ i _ pipes ; using system _ text ; using system _ net ; using system _ threading _ tasks ; using system _ collections _ generic ; namespace shadowsocks {
using system _ linq ; using system _ i _ pipes ; using system _ text ; using system _ net ; using system _ threading _ tasks ; using system _ collections _ generic ; namespace shadowsocks { static class program {
using system _ collections _ generic ; namespace shadowsocks { static class program { private static logger logger = log _ manager . get _ current _ class _ logger ( ) ; public static shadowsocks _ controller main _ controller { get ; private set ; } public static menu _ view _ controller menu _ controller { get ; private set ; } public static string [ ] args { get ; private set ; } sta _ thread
{ private static logger logger = log _ manager . get _ current _ class _ logger ( ) ; public static shadowsocks _ controller main _ controller { get ; private set ; } public static menu _ view _ controller menu _ controller { get ; private set ; } public static string [ ] args { get ; private set ; } sta _ thread static void main ( string [ ] args ) { directory . set _ current _ directory ( application . startup _ path ) ; model . n _ log _ config . touch _ and _ apply _ n _ log _ config ( ) ;
bool pipe _ exist = false ; try { pipe . connect ( NUM ) ; pipe _ exist = true ; } catch ( timeout _ exception ) { pipe _ exist = false ; }
} catch ( timeout _ exception ) { pipe _ exist = false ; } var alist = args . to _ list ( ) ; int urlidx = alist . index _ of ( STR ) + 1 ; if ( urlidx > 0 ) {
using system _ component _ model ; using system _ data ; using system _ drawing ; using system _ text ; using system _ windows _ forms ; using system _ drawing _ imaging ; using system _ runtime _ interop _ services ; using system _ diagnostics ; namespace shadowsocks _ view {
{ private local local ; private pac _ server pac _ server ; private configuration config ; private polipo _ runner polipo _ runner ; private bool stopped = false ; public class path _ event _ args : event _ args { public string path ; }
private configuration config ; private polipo _ runner polipo _ runner ; private bool stopped = false ; public class path _ event _ args : event _ args { public string path ; } public class error _ event _ args : event _ args { public string error ; } public event event _ handler config _ changed ; public event event _ handler enable _ status _ changed ;
system . diagnostics . process . start ( STR , argument ) ; } private void show _ window ( ) { this . opacity = 1 ; this . show ( ) ; } private void update _ ui ( ) { server server = controller . get _ current _ server ( ) ;
private void update _ ui ( ) { server server = controller . get _ current _ server ( ) ; text _ box . text = server . server ; text _ box . text = server . server _ port . to _ string ( ) ; text _ box . text = server . password ; text _ box . text = server . local _ port . to _ string ( ) ; combo _ box . text = server . method = = null ? STR : server . method ; enable _ item . checked = controller . get _ configuration ( ) . enabled ; }
catch ( exception ex ) { message _ box . show ( ex . message ) ; } } private void cancel _ button _ click ( object sender , event _ args e ) { this . hide ( ) ; update _ ui ( ) ; }
base . dispose ( disposing ) ; } private void initialize _ component ( ) { this . components = new system . component _ model . container ( ) ; system . component _ model . component _ resource _ manager resources = new system . component _ model . component _ resource _ manager ( typeof ( config _ form ) ) ; this . table _ layout _ panel = new system . windows . forms . table _ layout _ panel ( ) ; this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ;
{ this . components = new system . component _ model . container ( ) ; system . component _ model . component _ resource _ manager resources = new system . component _ model . component _ resource _ manager ( typeof ( config _ form ) ) ; this . table _ layout _ panel = new system . windows . forms . table _ layout _ panel ( ) ; this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ; this . combo _ box = new system . windows . forms . combo _ box ( ) ; this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ;
this . label = new system . windows . forms . label ( ) ; this . combo _ box = new system . windows . forms . combo _ box ( ) ; this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ; this . text _ box = new system . windows . forms . text _ box ( ) ; this . text _ box = new system . windows . forms . text _ box ( ) ; this . text _ box = new system . windows . forms . text _ box ( ) ; this . text _ box = new system . windows . forms . text _ box ( ) ; this . notify _ icon = new system . windows . forms . notify _ icon ( this . components ) ; this . panel = new system . windows . forms . panel ( ) ;
this . button = new system . windows . forms . button ( ) ; this . button = new system . windows . forms . button ( ) ; this . panel = new system . windows . forms . panel ( ) ; this . context _ menu = new system . windows . forms . context _ menu ( ) ; this . enable _ item = new system . windows . forms . menu _ item ( ) ; this . config _ item = new system . windows . forms . menu _ item ( ) ; this . about _ item = new system . windows . forms . menu _ item ( ) ; this . menu _ item = new system . windows . forms . menu _ item ( ) ; this . quit _ item = new system . windows . forms . menu _ item ( ) ;
this . table _ layout _ panel . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( ( system . windows . forms . anchor _ styles . top | system . windows . forms . anchor _ styles . left ) | system . windows . forms . anchor _ styles . right ) ) ) ; this . table _ layout _ panel . auto _ size = true ; this . table _ layout _ panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . table _ layout _ panel . column _ count = 2 ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , 0 ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , 1 ) ;
this . table _ layout _ panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . table _ layout _ panel . column _ count = 2 ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , 0 ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , 1 ) ; this . table _ layout _ panel . controls . add ( this . combo _ box , 1 , NUM ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , 2 ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , NUM ) ;
this . label . size = new system . drawing . size ( NUM , NUM ) ; this . label . tab _ index = 0 ; this . label . text = STR ; this . label . anchor = system . windows . forms . anchor _ styles . right ; this . label . auto _ size = true ; this . label . location = new system . drawing . point ( NUM , NUM ) ; this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ; this . label . tab _ index = 1 ; this . label . text = STR ;
this . notify _ icon . text = STR ; this . notify _ icon . visible = true ; this . notify _ icon . double _ click + = new system . event _ handler ( this . notify _ icon _ double _ click ) ; this . panel . anchor = system . windows . forms . anchor _ styles . top ; this . panel . auto _ size = true ; this . panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . panel . location = new system . drawing . point ( NUM , NUM ) ; this . panel . name = STR ; this . panel . size = new system . drawing . size ( 0 , 0 ) ; this . panel . tab _ index = 1 ;
this . button . use _ visual _ style _ back _ color = true ; this . button . click + = new system . event _ handler ( this . ok _ button _ click ) ; this . button . dialog _ result = system . windows . forms . dialog _ result . cancel ; this . button . location = new system . drawing . point ( NUM , NUM ) ; this . button . name = STR ; this . button . size = new system . drawing . size ( NUM , NUM ) ; this . button . tab _ index = 1 ; this . button . text = STR ; this . button . use _ visual _ style _ back _ color = true ; this . button . click + = new system . event _ handler ( this . cancel _ button _ click ) ;
this . button . name = STR ; this . button . size = new system . drawing . size ( NUM , NUM ) ; this . button . tab _ index = 1 ; this . button . text = STR ; this . button . use _ visual _ style _ back _ color = true ; this . button . click + = new system . event _ handler ( this . cancel _ button _ click ) ; this . panel . anchor = system . windows . forms . anchor _ styles . top ; this . panel . auto _ size = true ; this . panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ;
this . enable _ item . text = STR ; this . enable _ item . click + = new system . event _ handler ( this . enable _ item _ click ) ; this . config _ item . index = 1 ; this . config _ item . text = STR ; this . config _ item . click + = new system . event _ handler ( this . config _ click ) ; this . about _ item . index = NUM ; this . about _ item . text = STR ;
this . menu _ item . text = STR ; this . quit _ item . index = NUM ; this . quit _ item . text = STR ; this . quit _ item . click + = new system . event _ handler ( this . quit _ click ) ; this . edit _ pac _ file _ item . index = 2 ; this . edit _ pac _ file _ item . text = STR ; this . edit _ pac _ file _ item . click + = new system . event _ handler ( this . edit _ pac _ file _ item _ click ) ; this . accept _ button = this . button ; this . auto _ size = true ; this . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ;
this . quit _ item . click + = new system . event _ handler ( this . quit _ click ) ; this . edit _ pac _ file _ item . index = 2 ; this . edit _ pac _ file _ item . text = STR ; this . edit _ pac _ file _ item . click + = new system . event _ handler ( this . edit _ pac _ file _ item _ click ) ; this . accept _ button = this . button ; this . auto _ size = true ; this . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . cancel _ button = this . button ; this . client _ size = new system . drawing . size ( NUM , NUM ) ; this . controls . add ( this . panel ) ;
this . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . cancel _ button = this . button ; this . client _ size = new system . drawing . size ( NUM , NUM ) ; this . controls . add ( this . panel ) ; this . controls . add ( this . table _ layout _ panel ) ; this . controls . add ( this . panel ) ; this . icon = ( ( system . drawing . icon ) ( resources . get _ object ( STR ) ) ) ; this . name = STR ; this . start _ position = system . windows . forms . form _ start _ position . center _ screen ; this . text = STR ;
this . resume _ layout ( false ) ; this . perform _ layout ( ) ; } private system . windows . forms . table _ layout _ panel table _ layout _ panel ; private system . windows . forms . label label ; private system . windows . forms . label label ; private system . windows . forms . label label ; private system . windows . forms . label label ;
private system . windows . forms . label label ; private system . windows . forms . label label ; private system . windows . forms . label label ; private system . windows . forms . label label ; private system . windows . forms . text _ box text _ box ; private system . windows . forms . text _ box text _ box ; private system . windows . forms . text _ box text _ box ; private system . windows . forms . text _ box text _ box ; private system . windows . forms . notify _ icon notify _ icon ; private system . windows . forms . label label ;
private system . windows . forms . label label ; private system . windows . forms . label label ; private system . windows . forms . text _ box text _ box ; private system . windows . forms . text _ box text _ box ; private system . windows . forms . text _ box text _ box ; private system . windows . forms . text _ box text _ box ; private system . windows . forms . notify _ icon notify _ icon ; private system . windows . forms . label label ; private system . windows . forms . combo _ box combo _ box ; private system . windows . forms . panel panel ;
using system ; using system _ collections _ generic ; using system _ text ;
using system ; using system _ collections _ generic ; using system _ text ; using system _ threading ; using system _ net ; using system _ io ;
using shadowsocks _ model ; using shadowsocks _ properties ; using system ;
using shadowsocks _ properties ; using system ; using system _ collections ; using system _ collections _ generic ; using system _ diagnostics ; using system _ io ; using system _ i _ compression ; using system _ net ; using system _ net _ sockets ; using system _ text ;
int w ; int h ; bitmap bitmap ; graphics g ; pen pen ; solid _ brush brush ; private void qr _ code _ splash _ form _ load ( object sender , event _ args e ) { set _ style ( control _ styles . supports _ transparent _ back _ color , true ) ; this . back _ color = color . transparent ;
h = ( int ) ( target _ rect . height * percent + this . size . height * ( 1 - percent ) ) ; pen . color = color . from _ argb ( ( int ) ( NUM * percent ) , color . red ) ; brush . color = color . from _ argb ( ( int ) ( NUM * percent ) , color . red ) ; g . clear ( color . transparent ) ; g . fill _ rectangle ( brush , x , y , w , h ) ; g . draw _ rectangle ( pen , x , y , w , h ) ; set _ bitmap ( bitmap ) ; } else {
} else { string pac _ url ; if ( config . use _ online _ pac & & ! string . is _ null _ or _ empty ( config . pac _ url ) ) pac _ url = config . pac _ url ; else pac _ url = STR + config . local _ port . to _ string ( ) + STR + get _ timestamp ( date _ time . now ) ; registry . set _ value ( STR , 0 ) ; var read _ proxy _ server = registry . get _ value ( STR ) ;
registry . set _ value ( STR , 0 ) ; var read _ proxy _ server = registry . get _ value ( STR ) ; if ( read _ proxy _ server ! = null & & read _ proxy _ server . equals ( STR + config . local _ port . to _ string ( ) ) ) registry . set _ value ( STR , STR ) ; registry . set _ value ( STR , pac _ url ) ; } } else { registry . set _ value ( STR , 0 ) ;
if ( bytes = = null ) { throw new format _ exception ( ) ; } try { string data = encoding . ut . get _ string ( bytes ) ; int index _ last _ at = data . last _ index _ of ( '@' ) ; string after _ at = data . substring ( index _ last _ at + 1 ) ; int index _ last _ colon = after _ at . last _ index _ of ( ':' ) ;
try { string data = encoding . ut . get _ string ( bytes ) ; int index _ last _ at = data . last _ index _ of ( '@' ) ; string after _ at = data . substring ( index _ last _ at + 1 ) ; int index _ last _ colon = after _ at . last _ index _ of ( ':' ) ; this . server _ port = int . parse ( after _ at . substring ( index _ last _ colon + 1 ) ) ; this . server = after _ at . substring ( 0 , index _ last _ colon ) ; string before _ at = data . substring ( 0 , index _ last _ at ) ; string [ ] parts = before _ at . split ( new [ ] { ':' } ) ;
public bool use _ online _ pac ; public bool availability _ statistics ; public bool auto _ check _ update ; public log _ viewer _ config log _ viewer ; private static string config _ file = STR ; public server get _ current _ server ( ) { if ( index > = 0 & & index < configs . count )
public bool auto _ check _ update ; public log _ viewer _ config log _ viewer ; private static string config _ file = STR ; public server get _ current _ server ( ) { if ( index > = 0 & & index < configs . count ) { return configs [ index ] ;
private static string config _ file = STR ; public server get _ current _ server ( ) { if ( index > = 0 & & index < configs . count ) { return configs [ index ] ; } else
private static string config _ file = STR ; public server get _ current _ server ( ) { if ( index > = 0 & & index < configs . count ) { return configs [ index ] ; } else { return get _ default _ server ( ) ;
check _ server ( server . server ) ; } public static configuration load ( ) { try { string config _ content = file . read _ all _ text ( config _ file ) ; configuration config = json _ convert . deserialize _ object < configuration > ( config _ content ) ; config . is _ default = false ; if ( config . local _ port = = 0 )
public static configuration load ( ) { try { string config _ content = file . read _ all _ text ( config _ file ) ; configuration config = json _ convert . deserialize _ object < configuration > ( config _ content ) ; config . is _ default = false ; if ( config . local _ port = = 0 ) { config . local _ port = NUM ;
{ config . local _ port = NUM ; if ( config . strategy = = null ) { config . index = 0 ; } } return config ; } catch ( exception e ) { if ( ! ( e is file _ not _ found _ exception ) )
config . index = 0 ; } } return config ; } catch ( exception e ) { if ( ! ( e is file _ not _ found _ exception ) ) { logging . log _ useful _ exception ( e ) ;
configs = new list < server > ( ) { get _ default _ server ( ) } } ; } } public static void save ( configuration config ) { if ( config . index > = config . configs . count )
get _ default _ server ( ) } } ; } } public static void save ( configuration config ) { if ( config . index > = config . configs . count ) { config . index = config . configs . count - 1 ;
} ; } } public static void save ( configuration config ) { if ( config . index > = config . configs . count ) { config . index = config . configs . count - 1 ; } if ( config . index < - 1 )
} public static void save ( configuration config ) { if ( config . index > = config . configs . count ) { config . index = config . configs . count - 1 ; } if ( config . index < - 1 ) { config . index = - 1 ;
console . error . write _ line ( e ) ; } } public static server get _ default _ server ( ) { return new server ( ) ; } private static void assert ( bool condition ) { if ( ! condition )
} public static server get _ default _ server ( ) { return new server ( ) ; } private static void assert ( bool condition ) { if ( ! condition ) { throw new exception ( n . get _ string ( STR ) ) ;
private static void assert ( bool condition ) { if ( ! condition ) { throw new exception ( n . get _ string ( STR ) ) ; } } public static void check _ port ( int port ) { if ( port < = 0 | | port > NUM )
if ( ! condition ) { throw new exception ( n . get _ string ( STR ) ) ; } } public static void check _ port ( int port ) { if ( port < = 0 | | port > NUM ) { throw new argument _ exception ( n . get _ string ( STR ) ) ;
{ if ( port < = 0 | | port > NUM ) { throw new argument _ exception ( n . get _ string ( STR ) ) ; } } public static void check _ local _ port ( int port ) { check _ port ( port ) ; if ( port = = NUM )
{ throw new argument _ exception ( n . get _ string ( STR ) ) ; } } public static void check _ local _ port ( int port ) { check _ port ( port ) ; if ( port = = NUM ) { throw new argument _ exception ( n . get _ string ( STR ) ) ;
{ check _ port ( port ) ; if ( port = = NUM ) { throw new argument _ exception ( n . get _ string ( STR ) ) ; } } private static void check _ password ( string password ) { if ( string . is _ null _ or _ empty ( password ) )
if ( port = = NUM ) { throw new argument _ exception ( n . get _ string ( STR ) ) ; } } private static void check _ password ( string password ) { if ( string . is _ null _ or _ empty ( password ) ) { throw new argument _ exception ( n . get _ string ( STR ) ) ;
private static void check _ password ( string password ) { if ( string . is _ null _ or _ empty ( password ) ) { throw new argument _ exception ( n . get _ string ( STR ) ) ; } } private static void check _ server ( string server ) { if ( string . is _ null _ or _ empty ( server ) )
if ( string . is _ null _ or _ empty ( password ) ) { throw new argument _ exception ( n . get _ string ( STR ) ) ; } } private static void check _ server ( string server ) { if ( string . is _ null _ or _ empty ( server ) ) { throw new argument _ exception ( n . get _ string ( STR ) ) ;
using system ;
using system ; using system _ collections _ generic ; using system _ diagnostics ; using system _ io ;
using system ; using system _ collections _ generic ; using system _ diagnostics ; using system _ io ; using system _ linq ; using system _ text ;
string arguments ; if ( enable ) {
string arguments ; if ( enable ) { { arguments = $ STR ; } else { arguments = $ STR ; } } else {
process . start _ info . arguments = arguments ; process . start _ info . working _ directory = utils . get _ temp _ path ( ) ; process . start _ info . window _ style = process _ window _ style . hidden ; process . start _ info . use _ shell _ execute = false ; process . start _ info . redirect _ standard _ error = true ; process . start _ info . create _ no _ window = true ; process . start ( ) ;
process . start _ info . create _ no _ window = true ; process . start ( ) ; var error = process . standard _ error . read _ to _ end ( ) ; process . wait _ for _ exit ( ) ; var exit _ code = process . exit _ code ; if ( exit _ code ! = ( int ) ret _ errors . ret _ no _ error ) {
{ string pac _ url ; if ( config . use _ online _ pac & & ! config . pac _ url . is _ null _ or _ empty ( ) ) { pac _ url = config . pac _ url ; } else { pac _ url = pac _ srv . pac _ url ; }
} else { pac _ url = pac _ srv . pac _ url ; } sysproxy . set _ ie _ proxy ( true , false , STR , pac _ url ) ; } } else {
{ if ( kv [ 0 ] = = STR ) { if ( kv [ 1 ] . trim ( ) = = ( ( ip _ end _ point ) socket . local _ end _ point ) . to _ string ( ) ) { host _ match = true ; } } else if ( kv [ 0 ] = = STR ) {
if ( kv [ 1 ] . trim ( ) = = ( ( ip _ end _ point ) socket . local _ end _ point ) . to _ string ( ) ) { host _ match = true ; } } else if ( kv [ 0 ] = = STR ) { if ( kv [ 1 ] . index _ of ( STR ) > = 0 ) { use _ socks = true ;
} protected void save _ config ( configuration new _ config ) { configuration . save ( new _ config ) ; reload ( ) ; } private void update _ system _ proxy ( ) { if ( config . enabled ) {
{ if ( config . enabled ) { system _ proxy . enable ( config . global ) ; system _ proxy _ is _ dirty = true ; } else { if ( system _ proxy _ is _ dirty ) {
dll _ import _ wininet _ dll public static extern bool internet _ set _ option ( int _ ptr h _ internet , int dw _ option , int _ ptr lp _ buffer , int dw _ buffer _ length ) ; public const int internet _ option _ settings _ changed = NUM ; public const int internet _ option _ refresh = NUM ; static bool settings _ return , refresh _ return ; public static void notify _ ie ( ) { settings _ return = internet _ set _ option ( int _ ptr . zero , internet _ option _ settings _ changed , int _ ptr . zero , 0 ) ; refresh _ return = internet _ set _ option ( int _ ptr . zero , internet _ option _ refresh , int _ ptr . zero , 0 ) ; }
try { registry _ key registry = registry . current _ user . open _ sub _ key ( STR , true ) ;
try { registry _ key registry = registry . current _ user . open _ sub _ key ( STR , true ) ; if ( global ) {
registry . set _ value ( STR , 1 ) ; registry . set _ value ( STR , STR ) ; registry . set _ value ( STR , STR ) ; } else { registry . set _ value ( STR , 0 ) ; registry . set _ value ( STR , STR ) ;
registry . set _ value ( STR , STR ) ; registry . set _ value ( STR , STR ) ; } else { registry . set _ value ( STR , 0 ) ; registry . set _ value ( STR , STR ) ; registry . set _ value ( STR , STR + get _ timestamp ( date _ time . now ) ) ; } system _ proxy . notify _ ie ( ) ;
{ using ( stream _ reader reader = new stream _ reader ( new file _ stream ( filename , file _ mode . open , file _ access . read , file _ share . read _ write ) ) ) { reader . base _ stream . seek ( last _ offset , seek _ origin . begin ) ; string line = STR ; bool changed = false ; while ( ( line = reader . read _ line ( ) ) ! = null ) { changed = true ;
reader . base _ stream . seek ( last _ offset , seek _ origin . begin ) ; string line = STR ; bool changed = false ; while ( ( line = reader . read _ line ( ) ) ! = null ) { changed = true ; text _ box . append _ text ( line + STR ) ; } if ( changed ) {
init _ content ( ) ; timer = new timer ( ) ; timer . interval = NUM ; timer . tick + = timer _ tick ; timer . start ( ) ; } private void log _ form _ form _ closing ( object sender , form _ closing _ event _ args e ) { timer . stop ( ) ; }
} private void log _ form _ form _ closing ( object sender , form _ closing _ event _ args e ) { timer . stop ( ) ; } private void menu _ item _ click ( object sender , event _ args e ) { string argument = STR + filename ; system . diagnostics . process . start ( STR , argument ) ; }
{ string argument = STR + filename ; system . diagnostics . process . start ( STR , argument ) ; } private void menu _ item _ click ( object sender , event _ args e ) { } private void menu _ item _ click ( object sender , event _ args e ) { this . close ( ) ; } private void log _ form _ shown ( object sender , event _ args e ) {
{ if ( disposing & & ( components ! = null ) ) { components . dispose ( ) ; } base . dispose ( disposing ) ; } private void initialize _ component ( ) { this . components = new system . component _ model . container ( ) ;
components . dispose ( ) ; } base . dispose ( disposing ) ; } private void initialize _ component ( ) { this . components = new system . component _ model . container ( ) ; this . text _ box = new system . windows . forms . text _ box ( ) ; this . context _ menu _ strip = new system . windows . forms . context _ menu _ strip ( this . components ) ; this . main _ menu = new system . windows . forms . main _ menu ( this . components ) ;
this . context _ menu _ strip = new system . windows . forms . context _ menu _ strip ( this . components ) ; this . main _ menu = new system . windows . forms . main _ menu ( this . components ) ; this . menu _ item = new system . windows . forms . menu _ item ( ) ; this . menu _ item = new system . windows . forms . menu _ item ( ) ; this . menu _ item = new system . windows . forms . menu _ item ( ) ; this . suspend _ layout ( ) ; this . text _ box . back _ color = system . drawing . color . black ; this . text _ box . dock = system . windows . forms . dock _ style . fill ; this . context _ menu _ strip . name = STR ; this . context _ menu _ strip . size = new system . drawing . size ( NUM , NUM ) ; this . main _ menu . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] {
this . main _ menu = new system . windows . forms . main _ menu ( this . components ) ; this . menu _ item = new system . windows . forms . menu _ item ( ) ; this . menu _ item = new system . windows . forms . menu _ item ( ) ; this . menu _ item = new system . windows . forms . menu _ item ( ) ; this . suspend _ layout ( ) ; this . text _ box . back _ color = system . drawing . color . black ; this . text _ box . dock = system . windows . forms . dock _ style . fill ; this . context _ menu _ strip . name = STR ; this . context _ menu _ strip . size = new system . drawing . size ( NUM , NUM ) ; this . main _ menu . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . menu _ item } ) ;
this . text _ box . dock = system . windows . forms . dock _ style . fill ; this . context _ menu _ strip . name = STR ; this . context _ menu _ strip . size = new system . drawing . size ( NUM , NUM ) ; this . main _ menu . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . menu _ item } ) ; this . menu _ item . index = 0 ; this . menu _ item . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . menu _ item , this . menu _ item } ) ; this . menu _ item . text = STR ;
this . menu _ item , this . menu _ item } ) ; this . menu _ item . text = STR ; this . menu _ item . index = 0 ; this . menu _ item . text = STR ; this . menu _ item . click + = new system . event _ handler ( this . menu _ item _ click ) ; this . menu _ item . index = 1 ; this . menu _ item . text = STR ; this . menu _ item . click + = new system . event _ handler ( this . menu _ item _ click ) ; this . auto _ scale _ mode = system . windows . forms . auto _ scale _ mode . font ;
this . start _ position = system . windows . forms . form _ start _ position . center _ screen ; this . text = STR ; this . form _ closing + = new system . windows . forms . form _ closing _ event _ handler ( this . log _ form _ form _ closing ) ; this . load + = new system . event _ handler ( this . log _ form _ load ) ; this . shown + = new system . event _ handler ( this . log _ form _ shown ) ; this . resume _ layout ( false ) ;
this . form _ closing + = new system . windows . forms . form _ closing _ event _ handler ( this . log _ form _ form _ closing ) ; this . load + = new system . event _ handler ( this . log _ form _ load ) ; this . shown + = new system . event _ handler ( this . log _ form _ shown ) ; this . resume _ layout ( false ) ; this . perform _ layout ( ) ; }
this . resume _ layout ( false ) ; this . perform _ layout ( ) ; } private system . windows . forms . text _ box text _ box ; private system . windows . forms . context _ menu _ strip context _ menu _ strip ; private system . windows . forms . main _ menu main _ menu ;
local _ port = NUM , method = STR , password = STR , remarks = STR } ; } private static void assert ( bool condition ) { if ( ! condition ) {
{ if ( ! condition ) { throw new exception ( STR ) ; } } private static void check _ port ( int port ) { if ( port < = 0 | | port > NUM ) {
{ if ( port < = 0 | | port > NUM ) { throw new argument _ exception ( STR ) ; } } private static void check _ password ( string password ) { if ( string . is _ null _ or _ empty ( password ) ) {
{ if ( string . is _ null _ or _ empty ( password ) ) { throw new argument _ exception ( STR ) ; } } private static void check _ server ( string server ) { if ( string . is _ null _ or _ empty ( server ) ) {
using shadowsocks _ properties ; using simple _ json ; using shadowsocks _ util ; using shadowsocks _ model ; namespace shadowsocks _ controller { public class gfw _ list _ updater { private const string gfwlist _ url = STR ; private static string pac _ file = pac _ server . pac _ file ;
file . write _ all _ text ( pac _ file , abp _ content , encoding . ut ) ; if ( update _ completed ! = null ) {
using shadowsocks _ util ; namespace shadowsocks _ controller { public class logging { public static string log _ file ; public static bool open _ log _ file ( ) { try {
{ throw new argument _ exception ( STR , nameof ( delimiter ) ) ; } if ( max _ line _ bytes < delimiter _ bytes . length ) { throw new argument _ exception ( STR , nameof ( max _ line _ bytes ) ) ; } delimiter _ search _ char _ table = make _ char _ table ( delimiter _ bytes ) ; delimiter _ search _ offset _ table = make _ offset _ table ( delimiter _ bytes ) ; line _ buffer = new byte [ max _ line _ bytes ] ;
delimiter _ search _ char _ table = make _ char _ table ( delimiter _ bytes ) ; delimiter _ search _ offset _ table = make _ offset _ table ( delimiter _ bytes ) ; line _ buffer = new byte [ max _ line _ bytes ] ; socket . begin _ receive ( line _ buffer , 0 , max _ line _ bytes , 0 , receive _ callback , 0 ) ; } private void receive _ callback ( i _ async _ result ar ) {
socket . begin _ receive ( line _ buffer , 0 , max _ line _ bytes , 0 , receive _ callback , 0 ) ; } private void receive _ callback ( i _ async _ result ar ) { int length = ( int ) ar . async _ state ; try { var bytes _ read = socket . end _ receive ( ar ) ; if ( bytes _ read = = 0 ) {
{ int length = ( int ) ar . async _ state ; try { var bytes _ read = socket . end _ receive ( ar ) ; if ( bytes _ read = = 0 ) { on _ finish ( length ) ; return ; }
on _ finish ( length ) ; return ; } } if ( length = = line _ buffer . length ) { on _ exception ( new index _ out _ of _ range _ exception ( STR ) ) ; on _ finish ( length ) ; return ; }
catch ( exception ex ) { on _ exception ( ex ) ; on _ finish ( length ) ; } } private void on _ exception ( exception ex ) { on _ exception ? . invoke ( ex , state ) ; }
} } private void on _ exception ( exception ex ) { on _ exception ? . invoke ( ex , state ) ; } private void on _ finish ( int length ) { on _ finish ? . invoke ( line _ buffer , buffer _ index , length , state ) ; }
using system _ windows _ forms ; using microsoft _ win ; using system ;
using system _ windows _ forms ; using microsoft _ win ; using system ; using system _ collections _ generic ; using system _ runtime _ interop _ services ;
registry . set _ value ( STR , STR ) ; registry . set _ value ( STR , STR ) ; } ie _ auto _ detect _ proxy ( ! enabled ) ; notify _ ie ( ) ; copy _ proxy _ setting _ from _ lan ( ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ;
} catch ( exception e ) { logging . log _ useful _ exception ( e ) ; message _ box . show ( n . get _ string ( STR ) ) ; } } private static void copy _ proxy _ setting _ from _ lan ( ) {
case STR : case STR : case STR : continue ; default : registry . set _ value ( each , default _ value ) ; continue ; } } notify _ ie ( ) ;
} notify _ ie ( ) ; } catch ( io _ exception e ) { logging . log _ useful _ exception ( e ) ; } } private static void ie _ auto _ detect _ proxy ( bool set ) {
. open _ sub _ key ( STR , true ) ; var def _ connection = ( byte [ ] ) registry . get _ value ( STR ) ; var saved _ legacy _ setting = ( byte [ ] ) registry . get _ value ( STR ) ; const int version _ offset = NUM ; const int options _ offset = NUM ; if ( set ) { def _ connection [ options _ offset ] = ( byte ) ( def _ connection [ options _ offset ] | NUM ) ; saved _ legacy _ setting [ options _ offset ] = ( byte ) ( saved _ legacy _ setting [ options _ offset ] | NUM ) ; }
} if ( ! utils . is _ supported _ runtime _ version ( ) ) { if ( dialog _ result . ok = = message _ box . show ( n . get _ string ( STR , STR ) , STR , message _ box _ buttons . ok _ cancel , message _ box _ icon . error ) ) { process . start ( STR ) ; } return ; }
if ( dialog _ result . ok = = message _ box . show ( n . get _ string ( STR , STR ) , STR , message _ box _ buttons . ok _ cancel , message _ box _ icon . error ) ) { process . start ( STR ) ; } return ; } utils . release _ memory ( true ) ; using ( mutex mutex = new mutex ( false , $ STR ) ) {
if ( old _ processes . length > 0 ) { process old _ process = old _ processes [ 0 ] ; } message _ box . show ( n . get _ string ( STR ) + environment . new _ line + n . get _ string ( STR ) , n . get _ string ( STR ) ) ; return ; }
n . get _ string ( STR ) ) ; return ; } directory . set _ current _ directory ( application . startup _ path ) ; string privoxy _ log _ filename = utils . get _ temp _ path ( STR ) ; if ( file . exists ( privoxy _ log _ filename ) ) using ( new file _ stream ( privoxy _ log _ filename , file _ mode . truncate ) ) { }
{ var calculation = new calculation _ control ( kv . key , kv . value ) ; calculation _ container . controls . add ( calculation ) ; } server _ selector . data _ source = servers ; data _ table . columns . add ( STR , typeof ( date _ time ) ) ; data _ table . columns . add ( STR , typeof ( int ) ) ;
{ data _ groups = statistics . group _ by ( data = > data . timestamp . hour ) ; statistics _ chart . chart _ areas [ STR ] . axis _ x . label _ style . format = STR ; statistics _ chart . chart _ areas [ STR ] . axis . label _ style . format = STR ; } var final _ data = from data _ group in data _ groups orderby data _ group . key select new { data _ group . first ( ) . timestamp ,
} var final _ data = from data _ group in data _ groups orderby data _ group . key select new { data _ group . first ( ) . timestamp , ping = ( int ) data _ group . average ( data = > data . average _ response ) , package _ loss = data _ group . average ( data = > data . package _ loss ) } ; foreach ( var data in final _ data ) {
{ data _ group . first ( ) . timestamp , ping = ( int ) data _ group . average ( data = > data . average _ response ) , package _ loss = data _ group . average ( data = > data . package _ loss ) } ; foreach ( var data in final _ data ) { data _ table . rows . add ( data . timestamp , data . package _ loss , data . ping ) ; } statistics _ chart . data _ bind ( ) ; }
package _ loss = data _ group . average ( data = > data . package _ loss ) } ; foreach ( var data in final _ data ) { data _ table . rows . add ( data . timestamp , data . package _ loss , data . ping ) ; } statistics _ chart . data _ bind ( ) ; } private void server _ selector _ selected _ index _ changed ( object sender , event _ args e ) { load _ chart _ data ( ) ;
this . repeat _ times _ num = new system . windows . forms . numeric _ up _ down ( ) ; this . label = new system . windows . forms . label ( ) ; this . split _ container = new system . windows . forms . split _ container ( ) ; this . label = new system . windows . forms . label ( ) ; this . calculation _ container = new system . windows . forms . flow _ layout _ panel ( ) ; this . server _ selector = new system . windows . forms . combo _ box ( ) ; this . cancel _ button = new system . windows . forms . button ( ) ; this . ok _ button = new system . windows . forms . button ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . statistics _ chart ) ) . begin _ init ( ) ;
this . statistics _ chart . chart _ areas . add ( chart _ area ) ; this . statistics _ chart . dock = system . windows . forms . dock _ style . fill ; legend . back _ color = system . drawing . color . transparent ; legend . name = STR ; this . statistics _ chart . legends . add ( legend ) ; this . statistics _ chart . location = new system . drawing . point ( 0 , 0 ) ; this . statistics _ chart . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . statistics _ chart . name = STR ; this . statistics _ chart . palette = system . windows . forms . data _ visualization . charting . chart _ color _ palette . pastel ; series . chart _ area = STR ;
legend . back _ color = system . drawing . color . transparent ; legend . name = STR ; this . statistics _ chart . legends . add ( legend ) ; this . statistics _ chart . location = new system . drawing . point ( 0 , 0 ) ; this . statistics _ chart . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . statistics _ chart . name = STR ; this . statistics _ chart . palette = system . windows . forms . data _ visualization . charting . chart _ color _ palette . pastel ; series . chart _ area = STR ; series . chart _ type = system . windows . forms . data _ visualization . charting . series _ chart _ type . bubble ; series . color = system . drawing . color . from _ argb ( ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) , ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) , ( ( int ) ( ( ( byte ) ( 0 ) ) ) ) ) ; series . legend = STR ;
this . statistics _ chart . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . statistics _ chart . name = STR ; this . statistics _ chart . palette = system . windows . forms . data _ visualization . charting . chart _ color _ palette . pastel ; series . chart _ area = STR ; series . chart _ type = system . windows . forms . data _ visualization . charting . series _ chart _ type . bubble ; series . color = system . drawing . color . from _ argb ( ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) , ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) , ( ( int ) ( ( ( byte ) ( 0 ) ) ) ) ) ; series . legend = STR ; series . name = STR ; series . x _ value _ type = system . windows . forms . data _ visualization . charting . chart _ value _ type . date _ time ; series . y _ values _ per _ point = 2 ; series . border _ width = NUM ; series . chart _ area = STR ;
series . chart _ area = STR ; series . chart _ type = system . windows . forms . data _ visualization . charting . series _ chart _ type . bubble ; series . color = system . drawing . color . from _ argb ( ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) , ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) , ( ( int ) ( ( ( byte ) ( 0 ) ) ) ) ) ; series . legend = STR ; series . name = STR ; series . x _ value _ type = system . windows . forms . data _ visualization . charting . chart _ value _ type . date _ time ; series . y _ values _ per _ point = 2 ; series . border _ width = NUM ; series . chart _ area = STR ; series . chart _ type = system . windows . forms . data _ visualization . charting . series _ chart _ type . line ; series . color = system . drawing . color . from _ argb ( ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) , ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) , ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) ) ; series . legend = STR ;
series . y _ values _ per _ point = 2 ; series . border _ width = NUM ; series . chart _ area = STR ; series . chart _ type = system . windows . forms . data _ visualization . charting . series _ chart _ type . line ; series . color = system . drawing . color . from _ argb ( ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) , ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) , ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) ) ; series . legend = STR ; series . name = STR ; series . x _ value _ type = system . windows . forms . data _ visualization . charting . chart _ value _ type . date _ time ; series . chart _ area = STR ;
series . chart _ type = system . windows . forms . data _ visualization . charting . series _ chart _ type . line ; series . color = system . drawing . color . from _ argb ( ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) , ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) , ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) ) ; series . legend = STR ; series . name = STR ; series . x _ value _ type = system . windows . forms . data _ visualization . charting . chart _ value _ type . date _ time ; series . chart _ area = STR ; series . chart _ type = system . windows . forms . data _ visualization . charting . series _ chart _ type . area ; series . legend = STR ;
series . chart _ type = system . windows . forms . data _ visualization . charting . series _ chart _ type . area ; series . legend = STR ; series . name = STR ; this . statistics _ chart . series . add ( series ) ; this . statistics _ chart . series . add ( series ) ; this . statistics _ chart . series . add ( series ) ; this . statistics _ chart . size = new system . drawing . size ( NUM , NUM ) ; this . statistics _ chart . tab _ index = 2 ;
this . ok _ button . size = new system . drawing . size ( NUM , NUM ) ; this . ok _ button . tab _ index = NUM ; this . ok _ button . text = STR ; this . ok _ button . use _ visual _ style _ back _ color = true ; this . ok _ button . click + = new system . event _ handler ( this . ok _ button _ click ) ; this . auto _ scale _ mode = system . windows . forms . auto _ scale _ mode . font ; this . auto _ size = true ; this . client _ size = new system . drawing . size ( NUM , NUM ) ; this . controls . add ( this . split _ container ) ;

public static readonly mode terminator = new mode ( new int [ ] { 0 , 0 , 0 } , 0 , STR ) ; public static readonly mode numeric = new mode ( new int [ ] { NUM , NUM , NUM } , 0 , STR ) ; public static readonly mode alphanumeric = new mode ( new int [ ] { NUM , NUM , NUM } , 0 , STR ) ; public static readonly mode structured _ append = new mode ( new int [ ] { 0 , 0 , 0 } , 0 , STR ) ; public static readonly mode byte = new mode ( new int [ ] { NUM , NUM , NUM } , 0 , STR ) ;
private mode ( int [ ] character _ count _ bits _ for _ versions , int bits , system . string name ) { this . character _ count _ bits _ for _ versions = character _ count _ bits _ for _ versions ; this . bits = bits ; this . name = name ; } public static mode for _ bits ( int bits ) { switch ( bits ) {
this . bits = bits ; this . name = name ; } public static mode for _ bits ( int bits ) { switch ( bits ) { case 0 : return terminator ; case 0 : return numeric ; case 0 : return alphanumeric ; case 0 : return structured _ append ; case 0 : return byte ;

public static generic _ gf aztec _ data = new generic _ gf ( 0 , NUM , 1 ) ; public static generic _ gf aztec _ data = new generic _ gf ( 0 , NUM , 1 ) ; public static generic _ gf aztec _ data = new generic _ gf ( 0 , NUM , 1 ) ; public static generic _ gf aztec _ param = new generic _ gf ( 0 , NUM , 1 ) ; public static generic _ gf qr _ code _ field = new generic _ gf ( 0 d , NUM , 0 ) ;
using system _ io ; using system _ linq ; using system _ text ; using system _ threading _ tasks ; using google _ protobuf ; using newtonsoft _ json ; using shadowsocks _ model ; using system _ net ; namespace shadowsocks _ controller {
using google _ protobuf ; using newtonsoft _ json ; using shadowsocks _ model ; using system _ net ; namespace shadowsocks _ controller { static class geosite _ updater { private static logger logger = log _ manager . get _ current _ class _ logger ( ) ;
pac _ server = new pac _ server ( ) ; pac _ server . pac _ file _ changed + = pac _ server _ pac _ file _ changed ; pac _ server . start ( config ) ; } catch ( exception e ) {
lb = label as label ; } private static object get _ field _ via _ name ( type type , string name , object obj ) { if ( type = = null ) throw new argument _ null _ exception ( nameof ( type ) ) ; if ( name . is _ null _ or _ empty ( ) ) throw new argument _ exception ( nameof ( name ) ) ; field _ info fi = type . get _ field ( name , binding _ flags . non _ public | binding _ flags . instance | binding _ flags . ignore _ case | binding _ flags . static ) ; return fi = = null ? null : fi . get _ value ( obj ) ; }
if ( type = = null ) throw new argument _ null _ exception ( nameof ( type ) ) ; if ( name . is _ null _ or _ empty ( ) ) throw new argument _ exception ( nameof ( name ) ) ; field _ info fi = type . get _ field ( name , binding _ flags . non _ public | binding _ flags . instance | binding _ flags . ignore _ case | binding _ flags . static ) ; return fi = = null ? null : fi . get _ value ( obj ) ; } private delegate get _ delegate _ via _ method _ name ( type type , string methodname ) { if ( type = = null ) throw new argument _ null _ exception ( nameof ( type ) ) ; if ( methodname . is _ null _ or _ empty ( ) ) throw new argument _ exception ( nameof ( methodname ) ) ;
field _ info fi = type . get _ field ( name , binding _ flags . non _ public | binding _ flags . instance | binding _ flags . ignore _ case | binding _ flags . static ) ; return fi = = null ? null : fi . get _ value ( obj ) ; } private delegate get _ delegate _ via _ method _ name ( type type , string methodname ) { if ( type = = null ) throw new argument _ null _ exception ( nameof ( type ) ) ; if ( methodname . is _ null _ or _ empty ( ) ) throw new argument _ exception ( nameof ( methodname ) ) ; type delegate _ type = type . get _ type ( STR ) . get _ nested _ type ( STR ) ; method _ info dyn _ method = type . get _ method ( methodname , binding _ flags . non _ public | binding _ flags . instance | binding _ flags . ignore _ case ) ;
using system ; using microsoft _ visual _ studio _ test _ tools _ unit _ testing ; using shadowsocks _ controller ; using shadowsocks _ encryption ;
using system ; using system _ collections _ generic ; using system _ component _ model ; using system _ linq ; using system _ windows _ forms ; using system _ windows _ input ; using global _ hot _ key ;
using system _ windows _ forms ; using system _ windows _ input ; using global _ hot _ key ; namespace shadowsocks _ util { public static class hot _ keys { private static hot _ key _ manager hot _ key _ manager ; public delegate void hot _ key _ call _ back _ handler ( ) ; private static dictionary < hot _ key , hot _ key _ call _ back _ handler > keymap = new dictionary < hot _ key , hot _ key _ call _ back _ handler > ( ) ;
bitmap icon _ copy = new bitmap ( origin _ icon ) ; for ( int x = 0 ; x < icon _ copy . width ; x + + ) { for ( int y = 0 ; y < icon _ copy . height ; y + + ) { color color = origin _ icon . get _ pixel ( x , y ) ; if ( color . a ! = 0 ) { if ( ! enabled ) {
{ color color = origin _ icon . get _ pixel ( x , y ) ; if ( color . a ! = 0 ) { if ( ! enabled ) { color fly _ blue = color . from _ argb ( NUM , NUM , NUM ) ; int red = color . r * fly _ blue . r / NUM ; int green = color . g * fly _ blue . g / NUM ; int blue = color . b * fly _ blue . b / NUM ;
{ gfw _ list _ updater = new gfw _ list _ updater ( ) ; gfw _ list _ updater . update _ completed + = pac _ server _ pac _ update _ completed ; gfw _ list _ updater . error + = pac _ server _ pac _ update _ error ; } availability _ statistics . update _ configuration ( this ) ; if ( listener ! = null ) { listener . stop ( ) ; }
listener . stop ( ) ; } privoxy _ runner . stop ( ) ; try { var strategy = get _ current _ strategy ( ) ; if ( strategy ! = null ) { strategy . reload _ servers ( ) ; }
{ strategy . reload _ servers ( ) ; } privoxy _ runner . start ( config ) ; tcp _ relay tcp _ relay = new tcp _ relay ( this , config ) ; udp _ relay udp _ relay = new udp _ relay ( this ) ; list < listener . i _ service > services = new list < listener . i _ service > ( ) ; services . add ( tcp _ relay ) ; services . add ( udp _ relay ) ; services . add ( pac _ server ) ;
using system _ runtime _ interop _ services ; using shadowsocks _ controller ; namespace shadowsocks _ util _ process _ management { * see : * http : * / public class job : i _ disposable { dll _ import _ kernel _ dll _ char _ set _ char _ set _ unicode
namespace shadowsocks _ util _ process _ management { * see : * http : * / public class job : i _ disposable { dll _ import _ kernel _ dll _ char _ set _ char _ set _ unicode static extern int _ ptr create _ job _ object ( int _ ptr a , string lp _ name ) ; dll _ import _ kernel _ dll
* see : * http : * / public class job : i _ disposable { dll _ import _ kernel _ dll _ char _ set _ char _ set _ unicode static extern int _ ptr create _ job _ object ( int _ ptr a , string lp _ name ) ; dll _ import _ kernel _ dll static extern bool set _ information _ job _ object ( int _ ptr h _ job , job _ object _ info _ type info _ type , int _ ptr lp _ job _ object _ info , u _ int cb _ job _ object _ info _ length ) ; dll _ import _ kernel _ dll _ set _ last _ error _ true
public class job : i _ disposable { dll _ import _ kernel _ dll _ char _ set _ char _ set _ unicode static extern int _ ptr create _ job _ object ( int _ ptr a , string lp _ name ) ; dll _ import _ kernel _ dll static extern bool set _ information _ job _ object ( int _ ptr h _ job , job _ object _ info _ type info _ type , int _ ptr lp _ job _ object _ info , u _ int cb _ job _ object _ info _ length ) ; dll _ import _ kernel _ dll _ set _ last _ error _ true static extern bool assign _ process _ to _ job _ object ( int _ ptr job , int _ ptr process ) ; dll _ import _ kernel _ dll _ set _ last _ error _ true return _ marshal _ as _ unmanaged _ type _ bool
handle = create _ job _ object ( int _ ptr . zero , null ) ; var info = new jobobject _ basic _ limit _ information { limit _ flags = 0 } ; var extended _ info = new jobobject _ extended _ limit _ information { basic _ limit _ information = info } ;
private void load _ current _ configuration ( ) { modified _ configuration = controller . get _ configuration ( ) ;
private void load _ current _ configuration ( ) { modified _ configuration = controller . get _ configuration ( ) ; servers _ list _ box . items . clear ( ) ; foreach ( server server in modified _ configuration . configs ) { servers _ list _ box . items . add ( server . server ) ; } servers _ list _ box . selected _ index = modified _ configuration . index ;
this . combo _ box . formatting _ enabled = true ; this . combo _ box . ime _ mode = system . windows . forms . ime _ mode . no _ control ; this . combo _ box . item _ height = NUM ; this . combo _ box . items . add _ range ( new object [ ] { STR , STR , STR , STR , STR ,

public openssl _ encryptor ( string method , string password ) : base ( method , password ) { init _ key ( method , password ) ; } public override byte [ ] encrypt ( byte [ ] buf , int length ) { if ( encrypt _ ctx = = int _ ptr . zero ) {
: base ( method , password ) { init _ key ( method , password ) ; } public override byte [ ] encrypt ( byte [ ] buf , int length ) { if ( encrypt _ ctx = = int _ ptr . zero ) { int iv _ len = cipher . iv _ length ; byte [ ] iv = new byte [ iv _ len ] ;
init _ key ( method , password ) ; } public override byte [ ] encrypt ( byte [ ] buf , int length ) { if ( encrypt _ ctx = = int _ ptr . zero ) { int iv _ len = cipher . iv _ length ; byte [ ] iv = new byte [ iv _ len ] ; native . rand _ bytes ( iv , iv . length ) ; init _ cipher ( ref encrypt _ ctx , iv , true ) ;
public override byte [ ] encrypt ( byte [ ] buf , int length ) { if ( encrypt _ ctx = = int _ ptr . zero ) { int iv _ len = cipher . iv _ length ; byte [ ] iv = new byte [ iv _ len ] ; native . rand _ bytes ( iv , iv . length ) ; init _ cipher ( ref encrypt _ ctx , iv , true ) ; int out _ len = length + cipher . block _ size ; byte [ ] cipher _ text = new byte [ out _ len ] ;
int out _ len = length + cipher . block _ size ; byte [ ] cipher _ text = new byte [ out _ len ] ; native . evp _ cipher _ update ( encrypt _ ctx , cipher _ text , out out _ len , buf , length ) ; byte [ ] result = new byte [ out _ len + iv _ len ] ; buffer . block _ copy ( iv , 0 , result , 0 , iv _ len ) ; buffer . block _ copy ( cipher _ text , 0 , result , iv _ len , out _ len ) ; return result ; } else {
native . evp _ cipher _ update ( encrypt _ ctx , cipher _ text , out out _ len , buf , length ) ; byte [ ] result = new byte [ out _ len + iv _ len ] ; buffer . block _ copy ( iv , 0 , result , 0 , iv _ len ) ; buffer . block _ copy ( cipher _ text , 0 , result , iv _ len , out _ len ) ; return result ; } else { int out _ len = length + cipher . block _ size ; byte [ ] cipher _ text = new byte [ out _ len ] ;
native . evp _ cipher _ update ( encrypt _ ctx , cipher _ text , out out _ len , buf , length ) ; byte [ ] result = new byte [ out _ len ] ; buffer . block _ copy ( cipher _ text , 0 , result , 0 , out _ len ) ; return result ; } } public override byte [ ] decrypt ( byte [ ] buf , int length ) { if ( decrypt _ ctx = = int _ ptr . zero ) {
} } public override byte [ ] decrypt ( byte [ ] buf , int length ) { if ( decrypt _ ctx = = int _ ptr . zero ) { int iv _ len = cipher . iv _ length ; byte [ ] iv = new byte [ iv _ len ] ; buffer . block _ copy ( buf , 0 , iv , 0 , iv _ len ) ; init _ cipher ( ref decrypt _ ctx , iv , false ) ;
{ int iv _ len = cipher . iv _ length ; byte [ ] iv = new byte [ iv _ len ] ; buffer . block _ copy ( buf , 0 , iv , 0 , iv _ len ) ; init _ cipher ( ref decrypt _ ctx , iv , false ) ; int out _ len = length + cipher . block _ size ; out _ len - = iv _ len ; byte [ ] cipher _ text = new byte [ out _ len ] ; byte [ ] subset = new byte [ length - iv _ len ] ; buffer . block _ copy ( buf , iv _ len , subset , 0 , length - iv _ len ) ;
byte [ ] cipher _ text = new byte [ out _ len ] ; byte [ ] subset = new byte [ length - iv _ len ] ; buffer . block _ copy ( buf , iv _ len , subset , 0 , length - iv _ len ) ; native . evp _ cipher _ update ( decrypt _ ctx , cipher _ text , out out _ len , subset , length - iv _ len ) ; byte [ ] result = new byte [ out _ len ] ; buffer . block _ copy ( cipher _ text , 0 , result , 0 , out _ len ) ; return result ; } else {
buffer . block _ copy ( buf , iv _ len , subset , 0 , length - iv _ len ) ; native . evp _ cipher _ update ( decrypt _ ctx , cipher _ text , out out _ len , subset , length - iv _ len ) ; byte [ ] result = new byte [ out _ len ] ; buffer . block _ copy ( cipher _ text , 0 , result , 0 , out _ len ) ; return result ; } else { int out _ len = length + cipher . block _ size ; byte [ ] cipher _ text = new byte [ out _ len ] ;
{ int out _ len = length + cipher . block _ size ; byte [ ] cipher _ text = new byte [ out _ len ] ; native . evp _ cipher _ update ( decrypt _ ctx , cipher _ text , out out _ len , buf , length ) ; byte [ ] result = new byte [ out _ len ] ; buffer . block _ copy ( cipher _ text , 0 , result , 0 , out _ len ) ; return result ; } } private static readonly dictionary < string , byte [ ] > cached _ keys = new dictionary < string , byte [ ] > ( ) ;
byte [ ] cipher _ text = new byte [ out _ len ] ; native . evp _ cipher _ update ( decrypt _ ctx , cipher _ text , out out _ len , buf , length ) ; byte [ ] result = new byte [ out _ len ] ; buffer . block _ copy ( cipher _ text , 0 , result , 0 , out _ len ) ; return result ; } } private static readonly dictionary < string , byte [ ] > cached _ keys = new dictionary < string , byte [ ] > ( ) ; private static readonly dictionary < string , cipher > cached _ ciphers = new dictionary < string , cipher > ( ) ; private byte [ ] key ;
if ( cached _ keys . contains _ key ( k ) ) { key = cached _ keys [ k ] ;
if ( cached _ keys . contains _ key ( k ) ) { key = cached _ keys [ k ] ; cipher = cached _ ciphers [ k ] ; return ; }
if ( cached _ keys . contains _ key ( k ) ) { key = cached _ keys [ k ] ; cipher = cached _ ciphers [ k ] ; return ; } cipher = cipher . create _ by _ name ( method ) ; if ( cipher = = null ) {
if ( cached _ keys . contains _ key ( k ) ) { key = cached _ keys [ k ] ; cipher = cached _ ciphers [ k ] ; return ; } cipher = cipher . create _ by _ name ( method ) ; if ( cipher = = null ) { throw new null _ reference _ exception ( ) ; }
} cipher = cipher . create _ by _ name ( method ) ; if ( cipher = = null ) { throw new null _ reference _ exception ( ) ; } byte [ ] passbuf = encoding . ut . get _ bytes ( password ) ; key = new byte [ cipher . key _ length ] ; byte [ ] iv = new byte [ cipher . iv _ length ] ; native . evp _ bytes _ to _ key ( cipher . handle , message _ digest . m . handle , null , passbuf , passbuf . length , 1 , key , iv ) ; cached _ keys [ k ] = key ; cached _ ciphers [ k ] = cipher ; } private void init _ cipher ( ref int _ ptr ctx , byte [ ] iv , bool is _ cipher ) {
{ throw new null _ reference _ exception ( ) ; } key = new byte [ cipher . key _ length ] ; byte [ ] iv = new byte [ cipher . iv _ length ] ; native . evp _ bytes _ to _ key ( cipher . handle , message _ digest . m . handle , null , passbuf , passbuf . length , 1 , key , iv ) ; cached _ keys [ k ] = key ; cached _ ciphers [ k ] = cipher ; } private void init _ cipher ( ref int _ ptr ctx , byte [ ] iv , bool is _ cipher ) { ctx = native . openssl _ malloc ( marshal . size _ of ( typeof ( cipher _ context . evp _ cipher _ ctx ) ) ) ; int enc = is _ cipher ? 1 : 0 ;
if ( config . availability _ statistics ) { availability _ statistics . update _ outbound _ counter ( server , n ) ; } } protected void reload ( ) { encryption . rng . reload ( ) ; config = configuration . load ( ) ; statistics _ configuration = statistics _ strategy _ configuration . load ( ) ;
{ pac _ server = new pac _ server ( pac _ daemon ) ; } if ( gfw _ list _ updater = = null ) { gfw _ list _ updater = new gfw _ list _ updater ( ) ; gfw _ list _ updater . update _ completed + = pac _ server _ pac _ update _ completed ; gfw _ list _ updater . error + = pac _ server _ pac _ update _ error ; } availability _ statistics . update _ configuration ( this ) ;
gfw _ list _ updater . update _ completed + = pac _ server _ pac _ update _ completed ; gfw _ list _ updater . error + = pac _ server _ pac _ update _ error ; } availability _ statistics . update _ configuration ( this ) ; if ( listener ! = null ) { listener . stop ( ) ; } stop _ plugins ( ) ; privoxy _ runner . stop ( ) ; try { var strategy = get _ current _ strategy ( ) ;
using system ; using system _ windows _ forms ; using microsoft _ win ;
run _ key . close ( ) ; foreach ( string item in run _ list ) { if ( item . equals ( STR ) ) return true ; } return false ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ;
return true ; } return false ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; return false ; }
this . auto _ startup _ item = create _ menu _ item ( STR , new event _ handler ( this . auto _ startup _ item _ click ) ) , this . share _ over _ lan _ item = create _ menu _ item ( STR , new event _ handler ( this . share _ over _ lan _ item _ click ) ) ,
} public void stop ( ) { if ( process ! = null ) { try { process . kill ( ) ; process . wait _ for _ exit ( ) ; }
{ server = ( server ) obj ; return server = = . server & & server _ port = = . server _ port ; } public string friendly _ name ( ) { if ( server . is _ null _ or _ empty ( ) ) { return n . get _ string ( STR ) ; }
using system ; using system _ windows _ forms ; using shadowsocks _ model ; using shadowsocks _ util _ system _ proxy ; namespace shadowsocks _ controller { public static class system _ proxy {
using shadowsocks _ util _ system _ proxy ; namespace shadowsocks _ controller { public static class system _ proxy { private static bool failed = false ; private static string get _ timestamp ( date _ time value ) { return value . to _ string ( STR ) ; }
{ public static class system _ proxy { private static bool failed = false ; private static string get _ timestamp ( date _ time value ) { return value . to _ string ( STR ) ; } public static void update ( configuration config , bool force _ disable , pac _ server pac _ srv ) {
} } else { sysproxy . set _ ie _ proxy ( false , false , null , null ) ; } } catch ( proxy _ exception ex ) { logging . log _ useful _ exception ( ex ) ;
else { sysproxy . set _ ie _ proxy ( false , false , null , null ) ; } } catch ( proxy _ exception ex ) { logging . log _ useful _ exception ( ex ) ; switch ( ex . type ) {
using system _ text ; namespace shadowsocks _ csharp { class system _ proxy { dll _ import _ wininet _ dll public static extern bool internet _ set _ option ( int _ ptr h _ internet , int dw _ option , int _ ptr lp _ buffer , int dw _ buffer _ length ) ; public const int internet _ option _ settings _ changed = NUM ; public const int internet _ option _ refresh = NUM ; static bool settings _ return , refresh _ return ;
{ class system _ proxy { dll _ import _ wininet _ dll public static extern bool internet _ set _ option ( int _ ptr h _ internet , int dw _ option , int _ ptr lp _ buffer , int dw _ buffer _ length ) ; public const int internet _ option _ settings _ changed = NUM ; public const int internet _ option _ refresh = NUM ; static bool settings _ return , refresh _ return ; public void enable ( ) {
public static extern bool internet _ set _ option ( int _ ptr h _ internet , int dw _ option , int _ ptr lp _ buffer , int dw _ buffer _ length ) ; public const int internet _ option _ settings _ changed = NUM ; public const int internet _ option _ refresh = NUM ; static bool settings _ return , refresh _ return ; public void enable ( ) { registry _ key registry = registry . current _ user . open _ sub _ key ( STR , true ) ; registry . set _ value ( STR , 1 ) ; registry . set _ value ( STR , STR ) ; settings _ return = internet _ set _ option ( int _ ptr . zero , internet _ option _ settings _ changed , int _ ptr . zero , 0 ) ; refresh _ return = internet _ set _ option ( int _ ptr . zero , internet _ option _ refresh , int _ ptr . zero , 0 ) ; }
registry . set _ value ( STR , STR ) ; settings _ return = internet _ set _ option ( int _ ptr . zero , internet _ option _ settings _ changed , int _ ptr . zero , 0 ) ; refresh _ return = internet _ set _ option ( int _ ptr . zero , internet _ option _ refresh , int _ ptr . zero , 0 ) ; } public void disable ( ) { registry _ key registry = registry . current _ user . open _ sub _ key ( STR , true ) ; registry . set _ value ( STR , 0 ) ; registry . set _ value ( STR , STR ) ;
using system _ net _ network _ information ; using system _ net _ sockets ; using system _ threading ; using system _ threading _ tasks ; using shadowsocks _ model ; using shadowsocks _ util ; namespace shadowsocks _ controller { using data _ unit = key _ value _ pair < string , string > ; using data _ list = list < key _ value _ pair < string , string > > ;
using data _ unit = key _ value _ pair < string , string > ; using data _ list = list < key _ value _ pair < string , string > > ; using raw _ statistics = dictionary < string , list < availability _ statistics . raw _ statistics _ data > > ; using statistics = dictionary < string , list < availability _ statistics . statistics _ data > > ; public class availability _ statistics { public static readonly string date _ time _ pattern = STR ; private const string statistics _ files _ name = STR ; private const string delimiter = STR ; private const int timeout = NUM ; private const int delay _ before _ start = NUM ;
logging . debug ( STR + server . friendly _ name ( ) ) ; if ( server . server = = STR ) return null ; var ip = dns . get _ host _ addresses ( server . server ) . first ( ip = > ip . address _ family = = address _ family . inter _ network ) ; var ping = new ping ( ) ; var ret = new list < data _ list > ( ) ; foreach ( var timestamp in enumerable . range ( 0 , repeat ) . select ( = > date _ time . now . to _ string ( date _ time _ pattern ) ) ) { try {
try { var reply = ping . send ( ip , timeout ) ; ret . add ( new list < key _ value _ pair < string , string > > { new key _ value _ pair < string , string > ( STR , timestamp ) , new key _ value _ pair < string , string > ( STR , server . friendly _ name ( ) ) , new key _ value _ pair < string , string > ( STR , reply ? . status . to _ string ( ) ) , new key _ value _ pair < string , string > ( STR , reply ? . roundtrip _ time . to _ string ( ) ) } ) ;
int bytes _ to _ send ; lock ( encryption _ lock ) { if ( closed ) { return ; } encryptor . encrypt ( connetion _ recv _ buffer , bytes _ read , connetion _ send _ buffer , out bytes _ to _ send ) ; }
base . dispose ( disposing ) ; } private void initialize _ component ( ) { this . components = new system . component _ model . container ( ) ; system . windows . forms . data _ visualization . charting . chart _ area chart _ area = new system . windows . forms . data _ visualization . charting . chart _ area ( ) ; system . windows . forms . data _ visualization . charting . legend legend = new system . windows . forms . data _ visualization . charting . legend ( ) ; system . windows . forms . data _ visualization . charting . series series = new system . windows . forms . data _ visualization . charting . series ( ) ; system . windows . forms . data _ visualization . charting . series series = new system . windows . forms . data _ visualization . charting . series ( ) ; this . statistics _ chart = new system . windows . forms . data _ visualization . charting . chart ( ) ;
{ this . components = new system . component _ model . container ( ) ; system . windows . forms . data _ visualization . charting . chart _ area chart _ area = new system . windows . forms . data _ visualization . charting . chart _ area ( ) ; system . windows . forms . data _ visualization . charting . legend legend = new system . windows . forms . data _ visualization . charting . legend ( ) ; system . windows . forms . data _ visualization . charting . series series = new system . windows . forms . data _ visualization . charting . series ( ) ; system . windows . forms . data _ visualization . charting . series series = new system . windows . forms . data _ visualization . charting . series ( ) ; this . statistics _ chart = new system . windows . forms . data _ visualization . charting . chart ( ) ; this . by _ isp _ check _ box = new system . windows . forms . check _ box ( ) ; this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ;
this . ok _ button . size = new system . drawing . size ( NUM , NUM ) ; this . ok _ button . tab _ index = NUM ; this . ok _ button . text = STR ; this . ok _ button . use _ visual _ style _ back _ color = true ; this . ok _ button . click + = new system . event _ handler ( this . ok _ button _ click ) ; this . binding _ configuration . data _ source = typeof ( shadowsocks . model . statistics _ strategy _ configuration ) ; this . auto _ scale _ mode = system . windows . forms . auto _ scale _ mode . font ; this . auto _ size = true ; this . client _ size = new system . drawing . size ( NUM , NUM ) ; this . controls . add ( this . split _ container ) ;
this . ok _ button . use _ visual _ style _ back _ color = true ; this . ok _ button . click + = new system . event _ handler ( this . ok _ button _ click ) ; this . binding _ configuration . data _ source = typeof ( shadowsocks . model . statistics _ strategy _ configuration ) ; this . auto _ scale _ mode = system . windows . forms . auto _ scale _ mode . font ; this . auto _ size = true ; this . client _ size = new system . drawing . size ( NUM , NUM ) ; this . controls . add ( this . split _ container ) ; private system . windows . forms . check _ box by _ isp _ check _ box ; private system . windows . forms . label label ; private system . windows . forms . label label ;
using shadowsocks _ model ; using shadowsocks _ util ; namespace shadowsocks _ controller { using statistics = dictionary < string , list < statistics _ record > > ; public sealed class availability _ statistics : i _ disposable { public const string date _ time _ pattern = STR ; private const string statistics _ files _ name = STR ;
namespace shadowsocks _ controller { using statistics = dictionary < string , list < statistics _ record > > ; public sealed class availability _ statistics : i _ disposable { public const string date _ time _ pattern = STR ; private const string statistics _ files _ name = STR ; private const int timeout _ milliseconds = NUM ; public static readonly date _ time unknown _ date _ time = new date _ time ( NUM , 1 , 1 ) ; public static string availability _ statistics _ file ;
public const string date _ time _ pattern = STR ; private const string statistics _ files _ name = STR ; private const int timeout _ milliseconds = NUM ; public static readonly date _ time unknown _ date _ time = new date _ time ( NUM , 1 , 1 ) ; public static string availability _ statistics _ file ; private long last _ outbound _ counter ; private list < int > latency _ records ; private list < int > outbound _ speed _ records ; private timer recorder ; private list < server > servers ; private timer speed _ monior ; private timer writer ; static availability _ statistics ( ) { availability _ statistics _ file = utils . get _ temp _ path ( statistics _ files _ name ) ;
} private availability _ statistics ( ) { raw _ statistics = new statistics ( ) ; } public static availability _ statistics instance { get ; } = new availability _ statistics ( ) ; public statistics raw _ statistics { get ; private set ; } public statistics filtered _ statistics { get ; private set ; }
config = config ; try { if ( config . statistics _ enabled ) { if ( recorder ? . change ( delay _ before _ start , recording _ interval ) = = null ) { recorder = new timer ( run , null , delay _ before _ start , recording _ interval ) ; } load _ raw _ statistics ( ) ;
recorder = new timer ( run , null , delay _ before _ start , recording _ interval ) ; } load _ raw _ statistics ( ) ; } if ( writer ? . change ( delay _ before _ start , recording _ interval ) = = null ) { writer = new timer ( save , null , delay _ before _ start , recording _ interval ) ; } } else { recorder ? . dispose ( ) ; speed _ monior ? . dispose ( ) ;
else { recorder ? . dispose ( ) ; speed _ monior ? . dispose ( ) ; } return true ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ;
return result ; } private void reset ( ) { inbound _ speed _ records = new list < int > ( ) ; outbound _ speed _ records = new list < int > ( ) ; latency _ records = new list < int > ( ) ; } private void run ( object ) {
inbound _ speed _ records = new list < int > ( ) ; outbound _ speed _ records = new list < int > ( ) ; latency _ records = new list < int > ( ) ; } private void run ( object ) { append _ record ( ) ; reset ( ) ; filter _ raw _ statistics ( ) ; }
filter _ raw _ statistics ( ) ; } private async void append _ record ( ) { var icmp _ results = task _ ex . when _ all ( servers . select ( icmp _ test ) ) ; var current _ server _ record = new statistics _ record ( current _ server . identifier ( ) , inbound _ speed _ records , outbound _ speed _ records , latency _ records ) ; foreach ( var result in ( await icmp _ results ) . where ( result = > result ! = null ) ) {
{ var icmp _ results = task _ ex . when _ all ( servers . select ( icmp _ test ) ) ; var current _ server _ record = new statistics _ record ( current _ server . identifier ( ) , inbound _ speed _ records , outbound _ speed _ records , latency _ records ) ; foreach ( var result in ( await icmp _ results ) . where ( result = > result ! = null ) ) { list < statistics _ record > records ; if ( ! raw _ statistics . try _ get _ value ( result . server . identifier ( ) , out records ) ) { records = new list < statistics _ record > ( ) ; } if ( result . server . equals ( current _ server ) ) { current _ server _ record . set _ response ( result . roundtrip _ time ) ;
foreach ( var result in ( await icmp _ results ) . where ( result = > result ! = null ) ) { { records = new list < statistics _ record > ( ) ; } if ( result . server . equals ( current _ server ) ) { current _ server _ record . set _ response ( result . roundtrip _ time ) ; records . add ( current _ server _ record ) ; } else {
{ file . write _ all _ text ( availability _ statistics _ file , json _ convert . serialize _ object ( raw _ statistics , formatting . none ) ) ; } catch ( io _ exception e ) { logging . log _ useful _ exception ( e ) ; writer . change ( retry _ interval , writing _ interval ) ; } }
} catch ( io _ exception e ) { logging . log _ useful _ exception ( e ) ; writer . change ( retry _ interval , writing _ interval ) ; } } internal void update _ configuration ( shadowsocks _ controller controller ) { controller = controller ; current _ server = controller . get _ current _ server ( ) ; reset ( ) ; set ( controller . statistics _ configuration ) ; servers = controller . get _ current _ configuration ( ) . configs ; } private bool is _ valid _ record ( statistics _ record record ) {
{ if ( controller . get _ current _ strategy ( ) ? . id = = id ) { console . write _ line ( log ) ; } } public string id = > STR ; public string name = > n . get _ string ( STR ) ; public server get _ a _ server ( i _ strategy _ caller _ type type , ip _ end _ point local _ ip _ end _ point ) {
console . write _ line ( log ) ; } } public string id = > STR ; public string name = > n . get _ string ( STR ) ; public server get _ a _ server ( i _ strategy _ caller _ type type , ip _ end _ point local _ ip _ end _ point ) { var old _ server = current _ server ; if ( old _ server = = null ) { choose _ new _ server ( controller . get _ current _ configuration ( ) . configs ) ;
system . diagnostics . process . start ( STR , argument ) ; } private void exit _ menu _ item _ click ( object sender , event _ args e ) { this . close ( ) ; } private void log _ form _ shown ( object sender , event _ args e ) { log _ message _ text _ box . scroll _ to _ caret ( ) ; }
{ log _ message _ text _ box . scroll _ to _ caret ( ) ; } private void wrap _ text _ check _ box _ checked _ changed ( object sender , event _ args e ) { log _ message _ text _ box . word _ wrap = wrap _ text _ check _ box . checked ; log _ message _ text _ box . scroll _ to _ caret ( ) ; } private void clean _ logs _ button _ click ( object sender , event _ args e ) {
private void top _ most _ check _ box _ checked _ changed ( object sender , event _ args e ) {
if ( disposing & & ( components ! = null ) ) { components . dispose ( ) ; } base . dispose ( disposing ) ; } private void initialize _ component ( ) { this . components = new system . component _ model . container ( ) ; this . log _ message _ text _ box = new system . windows . forms . text _ box ( ) ;
} private void initialize _ component ( ) { this . components = new system . component _ model . container ( ) ; this . log _ message _ text _ box = new system . windows . forms . text _ box ( ) ; this . context _ menu _ strip = new system . windows . forms . context _ menu _ strip ( this . components ) ; this . main _ menu = new system . windows . forms . main _ menu ( this . components ) ; this . file _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . open _ location _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . exit _ menu _ item = new system . windows . forms . menu _ item ( ) ;
this . main _ menu = new system . windows . forms . main _ menu ( this . components ) ; this . file _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . open _ location _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . exit _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . panel = new system . windows . forms . panel ( ) ; this . change _ font _ button = new system . windows . forms . button ( ) ; this . clean _ logs _ button = new system . windows . forms . button ( ) ; this . wrap _ text _ check _ box = new system . windows . forms . check _ box ( ) ; this . table _ layout _ panel = new system . windows . forms . table _ layout _ panel ( ) ;
this . file _ menu _ item . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . open _ location _ menu _ item , this . exit _ menu _ item } ) ; this . file _ menu _ item . text = STR ; this . open _ location _ menu _ item . index = 0 ; this . open _ location _ menu _ item . text = STR ; this . open _ location _ menu _ item . click + = new system . event _ handler ( this . open _ location _ menu _ item _ click ) ; this . exit _ menu _ item . index = 1 ; this . exit _ menu _ item . text = STR ; this . exit _ menu _ item . click + = new system . event _ handler ( this . exit _ menu _ item _ click ) ;
this . panel . controls . add ( this . top _ most _ check _ box ) ; this . panel . controls . add ( this . change _ font _ button ) ; this . panel . controls . add ( this . clean _ logs _ button ) ; this . panel . controls . add ( this . wrap _ text _ check _ box ) ; this . panel . dock = system . windows . forms . dock _ style . fill ; this . panel . location = new system . drawing . point ( NUM , NUM ) ; this . panel . name = STR ; this . panel . size = new system . drawing . size ( NUM , NUM ) ; this . panel . tab _ index = 1 ;
this . panel . size = new system . drawing . size ( NUM , NUM ) ; this . panel . tab _ index = 1 ; this . change _ font _ button . location = new system . drawing . point ( NUM , NUM ) ; this . change _ font _ button . name = STR ; this . change _ font _ button . size = new system . drawing . size ( NUM , NUM ) ; this . change _ font _ button . tab _ index = 2 ; this . change _ font _ button . text = STR ; this . change _ font _ button . use _ visual _ style _ back _ color = true ; this . change _ font _ button . click + = new system . event _ handler ( this . change _ font _ button _ click ) ;
this . wrap _ text _ check _ box . auto _ size = true ; this . wrap _ text _ check _ box . location = new system . drawing . point ( NUM , NUM ) ; this . wrap _ text _ check _ box . name = STR ; this . wrap _ text _ check _ box . size = new system . drawing . size ( NUM , NUM ) ; this . wrap _ text _ check _ box . tab _ index = 0 ; this . wrap _ text _ check _ box . text = STR ; this . wrap _ text _ check _ box . use _ visual _ style _ back _ color = true ; this . wrap _ text _ check _ box . checked _ changed + = new system . event _ handler ( this . wrap _ text _ check _ box _ checked _ changed ) ; this . table _ layout _ panel . column _ count = 1 ;
this . wrap _ text _ check _ box . checked _ changed + = new system . event _ handler ( this . wrap _ text _ check _ box _ checked _ changed ) ; this . table _ layout _ panel . column _ count = 1 ; this . table _ layout _ panel . controls . add ( this . panel , 0 , 0 ) ; this . table _ layout _ panel . controls . add ( this . log _ message _ text _ box , 0 , 1 ) ; this . table _ layout _ panel . dock = system . windows . forms . dock _ style . fill ; this . table _ layout _ panel . location = new system . drawing . point ( 0 , 0 ) ; this . table _ layout _ panel . name = STR ; this . table _ layout _ panel . row _ count = 2 ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ;
this . table _ layout _ panel . controls . add ( this . log _ message _ text _ box , 0 , 1 ) ; this . table _ layout _ panel . dock = system . windows . forms . dock _ style . fill ; this . table _ layout _ panel . location = new system . drawing . point ( 0 , 0 ) ; this . table _ layout _ panel . name = STR ; this . table _ layout _ panel . row _ count = 2 ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ; this . table _ layout _ panel . tab _ index = 2 ;

this . panel . resume _ layout ( false ) ; this . panel . perform _ layout ( ) ; this . table _ layout _ panel . resume _ layout ( false ) ; this . table _ layout _ panel . perform _ layout ( ) ; this . resume _ layout ( false ) ; } private system . windows . forms . text _ box log _ message _ text _ box ;
this . resume _ layout ( false ) ; } private system . windows . forms . text _ box log _ message _ text _ box ; private system . windows . forms . context _ menu _ strip context _ menu _ strip ; private system . windows . forms . main _ menu main _ menu ; private system . windows . forms . menu _ item file _ menu _ item ; private system . windows . forms . menu _ item open _ location _ menu _ item ; private system . windows . forms . menu _ item exit _ menu _ item ;
using system ; using system _ net ; using system _ net _ sockets ; using shadowsocks _ util _ sockets ; namespace shadowsocks _ controller { class port _ forwarder : listener . service {
using system _ net ; using system _ net _ sockets ; using shadowsocks _ util _ sockets ; namespace shadowsocks _ controller { class port _ forwarder : listener . service { int target _ port ; public port _ forwarder ( int target _ port ) {
public port _ forwarder ( int target _ port ) { this . target _ port = target _ port ; } public override bool handle ( byte [ ] first _ packet , int length , socket socket , object state ) { if ( socket . protocol _ type ! = protocol _ type . tcp ) { return false ; }
} public override bool handle ( byte [ ] first _ packet , int length , socket socket , object state ) { if ( socket . protocol _ type ! = protocol _ type . tcp ) { return false ; } new handler ( ) . start ( first _ packet , length , socket , this . target _ port ) ; return true ; }
} class handler { private byte [ ] first _ packet ; private int first _ packet _ length ; private socket local ; private wrapped _ socket remote ; private bool closed = false ; private bool local _ shutdown = false ; private bool remote _ shutdown = false ;
private wrapped _ socket remote ; private bool closed = false ; private bool local _ shutdown = false ; private bool remote _ shutdown = false ; public const int recv _ size = NUM ; private byte [ ] remote _ recv _ buffer = new byte [ recv _ size ] ; private byte [ ] connetion _ recv _ buffer = new byte [ recv _ size ] ; private readonly object lock = new object ( ) ; public void start ( byte [ ] first _ packet , int length , socket socket , int target _ port ) {
this . local = socket ; try { end _ point remote _ ep = socket _ util . get _ end _ point ( STR , target _ port ) ; remote = new wrapped _ socket ( ) ; remote . begin _ connect ( remote _ ep , connect _ callback , null ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ;
private void start _ pipe ( i _ async _ result ar ) { if ( closed ) { return ; } try { remote . end _ send ( ar ) ; remote . begin _ receive ( remote _ recv _ buffer , 0 , recv _ size , 0 ,
if ( closed ) { return ; } try { remote . end _ send ( ar ) ; remote . begin _ receive ( remote _ recv _ buffer , 0 , recv _ size , 0 , new async _ callback ( pipe _ remote _ receive _ callback ) , null ) ; local . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , 0 ,
} private void pipe _ connection _ send _ callback ( i _ async _ result ar ) { if ( closed ) { return ; } try { local . end _ send ( ar ) ;
catch ( exception e ) { logging . log _ useful _ exception ( e ) ; this . close ( ) ; } } private void check _ close ( ) { if ( local _ shutdown & & remote _ shutdown ) {
string k = method + STR + password ; ciphers = get _ ciphers ( ) ; cipher _ info = ciphers [ method ] ; cipher = cipher _ info [ 2 ] ; if ( cipher = = 0 ) { throw new exception ( STR ) ; } key _ len = ciphers [ method ] [ 0 ] ; iv _ len = ciphers [ method ] [ 1 ] ;
if ( cipher = = 0 ) { throw new exception ( STR ) ; } key _ len = ciphers [ method ] [ 0 ] ; iv _ len = ciphers [ method ] [ 1 ] ; if ( cached _ keys . contains _ key ( k ) ) { key = cached _ keys [ k ] ;
using system ; using system _ net ; using system _ net _ sockets ; using system _ threading ; using shadowsocks _ util _ sockets ;
using system ; using system _ net ; using system _ net _ sockets ; using system _ threading ; using shadowsocks _ util _ sockets ; namespace shadowsocks _ proxy {
using system ; using system _ net ; using system _ net _ sockets ; using system _ text ; using system _ text _ regular _ expressions ; using system _ threading ; using shadowsocks _ controller ; using shadowsocks _ util _ sockets ;
using system ; using system _ net ; using system _ net _ sockets ; using system _ text ; using system _ text _ regular _ expressions ; using system _ threading ; using shadowsocks _ controller ; using shadowsocks _ util _ sockets ; namespace shadowsocks _ proxy {
using system ; using system _ collections _ generic ; using system _ linq ; using system _ net ; using system _ net _ sockets ; using system _ timers ; using shadowsocks _ controller _ strategy ; using shadowsocks _ encryption ; using shadowsocks _ model ;
using system ; using system _ net ; using system _ net _ sockets ;
using system ; using system _ net ; using system _ net _ sockets ; namespace shadowsocks _ proxy {
using system ; using system _ net ; using system _ net _ sockets ; using system _ text ; using system _ threading ; using shadowsocks _ controller ; using shadowsocks _ util _ sockets ;
using system ; using system _ net ; using system _ net _ sockets ; using system _ text ; using system _ threading ; using shadowsocks _ controller ; using shadowsocks _ util _ sockets ; namespace shadowsocks _ proxy {
protected override void dispose ( bool disposing ) { if ( disposing & & ( components ! = null ) ) { components . dispose ( ) ; } base . dispose ( disposing ) ; } private void initialize _ component ( ) {
} private void initialize _ component ( ) { system . windows . forms . data _ visualization . charting . chart _ area chart _ area = new system . windows . forms . data _ visualization . charting . chart _ area ( ) ; system . windows . forms . data _ visualization . charting . legend legend = new system . windows . forms . data _ visualization . charting . legend ( ) ; system . windows . forms . data _ visualization . charting . series series = new system . windows . forms . data _ visualization . charting . series ( ) ; system . windows . forms . data _ visualization . charting . series series = new system . windows . forms . data _ visualization . charting . series ( ) ; system . windows . forms . data _ visualization . charting . series series = new system . windows . forms . data _ visualization . charting . series ( ) ; this . statistics _ chart = new system . windows . forms . data _ visualization . charting . chart ( ) ;
this . check _ box = new system . windows . forms . check _ box ( ) ; this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ; this . group _ box = new system . windows . forms . group _ box ( ) ; this . radio _ button = new system . windows . forms . radio _ button ( ) ; this . radio _ button = new system . windows . forms . radio _ button ( ) ; this . split _ container = new system . windows . forms . split _ container ( ) ; this . split _ container = new system . windows . forms . split _ container ( ) ;
this . group _ box = new system . windows . forms . group _ box ( ) ; this . radio _ button = new system . windows . forms . radio _ button ( ) ; this . radio _ button = new system . windows . forms . radio _ button ( ) ; this . split _ container = new system . windows . forms . split _ container ( ) ; this . split _ container = new system . windows . forms . split _ container ( ) ; this . numeric _ up _ down = new system . windows . forms . numeric _ up _ down ( ) ; this . check _ box = new system . windows . forms . check _ box ( ) ; this . numeric _ up _ down = new system . windows . forms . numeric _ up _ down ( ) ; this . label = new system . windows . forms . label ( ) ; this . split _ container = new system . windows . forms . split _ container ( ) ; this . label = new system . windows . forms . label ( ) ;
this . group _ box . suspend _ layout ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . begin _ init ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . suspend _ layout ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . begin _ init ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . suspend _ layout ( ) ;
( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . begin _ init ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . suspend _ layout ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . numeric _ up _ down ) ) . begin _ init ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . numeric _ up _ down ) ) . begin _ init ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . begin _ init ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . suspend _ layout ( ) ;
this . radio _ button . tab _ index = 0 ; this . radio _ button . tab _ stop = true ; this . radio _ button . text = STR ; this . radio _ button . use _ visual _ style _ back _ color = true ; this . split _ container . dock = system . windows . forms . dock _ style . fill ; this . split _ container . location = new system . drawing . point ( 0 , 0 ) ; this . split _ container . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . split _ container . name = STR ; this . split _ container . orientation = system . windows . forms . orientation . horizontal ; this . split _ container . panel . controls . add ( this . split _ container ) ;
this . split _ container . size = new system . drawing . size ( NUM , NUM ) ; this . split _ container . splitter _ distance = NUM ; this . split _ container . splitter _ width = NUM ; this . split _ container . tab _ index = NUM ; this . split _ container . dock = system . windows . forms . dock _ style . fill ; this . split _ container . fixed _ panel = system . windows . forms . fixed _ panel . panel ; this . split _ container . is _ splitter _ fixed = true ; this . split _ container . location = new system . drawing . point ( 0 , 0 ) ; this . split _ container . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . split _ container . name = STR ;
this . split _ container . fixed _ panel = system . windows . forms . fixed _ panel . panel ; this . split _ container . is _ splitter _ fixed = true ; this . split _ container . location = new system . drawing . point ( 0 , 0 ) ; this . split _ container . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . split _ container . name = STR ; this . split _ container . panel . controls . add ( this . numeric _ up _ down ) ; this . split _ container . panel . controls . add ( this . check _ box ) ; this . split _ container . panel . controls . add ( this . numeric _ up _ down ) ; this . split _ container . panel . controls . add ( this . label ) ; this . split _ container . panel . controls . add ( this . label ) ; this . split _ container . panel . controls . add ( this . label ) ;
this . split _ container . panel . controls . add ( this . label ) ; this . split _ container . panel . controls . add ( this . label ) ; this . split _ container . panel . controls . add ( this . label ) ; this . split _ container . panel . controls . add ( this . check _ box ) ; this . split _ container . panel . controls . add ( this . label ) ; this . split _ container . panel . controls . add ( this . split _ container ) ; this . split _ container . size = new system . drawing . size ( NUM , NUM ) ; this . split _ container . splitter _ distance = NUM ; this . split _ container . splitter _ width = NUM ; this . split _ container . tab _ index = NUM ;
this . check _ box . tab _ index = NUM ; this . check _ box . text = STR ; this . check _ box . use _ visual _ style _ back _ color = true ; this . numeric _ up _ down . location = new system . drawing . point ( NUM , NUM ) ; this . numeric _ up _ down . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . numeric _ up _ down . maximum = new decimal ( new int [ ] { NUM , 0 , 0 , 0 } ) ;

this . group _ box . perform _ layout ( ) ; this . split _ container . panel . resume _ layout ( false ) ; this . split _ container . panel . resume _ layout ( false ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . end _ init ( ) ; this . split _ container . resume _ layout ( false ) ; this . split _ container . panel . resume _ layout ( false ) ; this . split _ container . panel . perform _ layout ( ) ; this . split _ container . panel . resume _ layout ( false ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . end _ init ( ) ; this . split _ container . resume _ layout ( false ) ;
this . split _ container . panel . resume _ layout ( false ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . end _ init ( ) ; this . split _ container . resume _ layout ( false ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . numeric _ up _ down ) ) . end _ init ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . numeric _ up _ down ) ) . end _ init ( ) ; this . split _ container . panel . resume _ layout ( false ) ; this . split _ container . panel . perform _ layout ( ) ; this . split _ container . panel . resume _ layout ( false ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . end _ init ( ) ; this . split _ container . resume _ layout ( false ) ;
( ( system . component _ model . i _ support _ initialize ) ( this . numeric _ up _ down ) ) . end _ init ( ) ; this . split _ container . panel . resume _ layout ( false ) ; this . split _ container . panel . perform _ layout ( ) ; this . split _ container . panel . resume _ layout ( false ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . end _ init ( ) ; this . split _ container . resume _ layout ( false ) ; this . flow _ layout _ panel . resume _ layout ( false ) ; this . flow _ layout _ panel . perform _ layout ( ) ; this . panel . resume _ layout ( false ) ; this . panel . perform _ layout ( ) ; this . resume _ layout ( false ) ; } private system . windows . forms . data _ visualization . charting . chart statistics _ chart ;
private system . windows . forms . check _ box check _ box ; private system . windows . forms . label label ; private system . windows . forms . label label ; private system . windows . forms . label label ; private system . windows . forms . group _ box group _ box ; private system . windows . forms . radio _ button radio _ button ; private system . windows . forms . radio _ button radio _ button ; private system . windows . forms . split _ container split _ container ; private system . windows . forms . label label ; private system . windows . forms . split _ container split _ container ;
private system . windows . forms . label label ; private system . windows . forms . label label ; private system . windows . forms . group _ box group _ box ; private system . windows . forms . radio _ button radio _ button ; private system . windows . forms . radio _ button radio _ button ; private system . windows . forms . split _ container split _ container ; private system . windows . forms . label label ; private system . windows . forms . split _ container split _ container ; private system . windows . forms . flow _ layout _ panel flow _ layout _ panel ; private system . windows . forms . split _ container split _ container ;
private system . windows . forms . group _ box group _ box ; private system . windows . forms . radio _ button radio _ button ; private system . windows . forms . radio _ button radio _ button ; private system . windows . forms . split _ container split _ container ; private system . windows . forms . label label ; private system . windows . forms . split _ container split _ container ; private system . windows . forms . flow _ layout _ panel flow _ layout _ panel ; private system . windows . forms . split _ container split _ container ; private system . windows . forms . panel panel ; private system . windows . forms . label label ; private system . windows . forms . label label ; private system . windows . forms . text _ box text _ box ; private system . windows . forms . combo _ box combo _ box ; private system . windows . forms . numeric _ up _ down numeric _ up _ down ; private system . windows . forms . label label ;
using system ; using system _ collections _ generic ; using system _ io ; using system _ linq ; using system _ net ; using system _ net _ network _ information ; using system _ threading ; using shadowsocks _ model ; namespace shadowsocks _ controller _ strategy {
namespace shadowsocks _ controller _ strategy { class simply _ choose _ by _ statistics _ strategy : i _ strategy { private readonly shadowsocks _ controller controller ; private server current _ server ; private readonly timer timer ; private dictionary < string , statistics _ data > statistics ; private const int cached _ interval = NUM * NUM * NUM ; private const int retry _ interval = 2 * NUM * NUM ;
private void show _ log _ item _ click ( object sender , event _ args e ) { string argument = logging . log _ file ; new log _ form ( argument ) . show ( ) ; } private void qr _ code _ item _ click ( object sender , event _ args e ) { qr _ code _ form qr _ code _ form = new qr _ code _ form ( controller . get _ qr _ code _ for _ current _ server ( ) ) ; qr _ code _ form . show ( ) ; }
string argument = logging . log _ file ; new log _ form ( argument ) . show ( ) ; } private void qr _ code _ item _ click ( object sender , event _ args e ) { qr _ code _ form qr _ code _ form = new qr _ code _ form ( controller . get _ qr _ code _ for _ current _ server ( ) ) ; qr _ code _ form . show ( ) ; } private static void statistics _ strategy _ options _ item _ click ( object sender , event _ args e ) {
{ var best _ result = ( from server in servers let name = server . friendly _ name ( ) where statistics . contains _ key ( name ) select new { server , score = get _ score ( statistics [ name ] ) } ) . aggregate ( ( result , result ) = > result . score > result . score ? result : result ) ;
) . aggregate ( ( result , result ) = > result . score > result . score ? result : result ) ; logging . debug ( string . format ( STR , best _ result . server . friendly _ name ( ) , best _ result . score ) ) ; current _ server = best _ result . server ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; } }
} catch ( exception e ) { logging . log _ useful _ exception ( e ) ; } } string i _ strategy . id { get { return STR ; } }
} } string i _ strategy . id { get { return STR ; } } string i _ strategy . name { get { return n . get _ string ( STR ) ; } }
string i _ strategy . id { get { return STR ; } } string i _ strategy . name { get { return n . get _ string ( STR ) ; } } server i _ strategy . get _ a _ server ( i _ strategy _ caller _ type type , ip _ end _ point local _ ip _ end _ point ) {
string i _ strategy . name { get { return n . get _ string ( STR ) ; } } server i _ strategy . get _ a _ server ( i _ strategy _ caller _ type type , ip _ end _ point local _ ip _ end _ point ) { console . write _ line ( STR , current _ server . friendly _ name ( ) ) ; return current _ server ; }
{ console . write _ line ( STR , current _ server . friendly _ name ( ) ) ; return current _ server ; } void i _ strategy . reload _ servers ( ) { choose _ new _ server ( controller . get _ current _ configuration ( ) . configs ) ; timer ? . change ( 0 , cached _ interval ) ; }
} void i _ strategy . reload _ servers ( ) { choose _ new _ server ( controller . get _ current _ configuration ( ) . configs ) ; timer ? . change ( 0 , cached _ interval ) ; } void i _ strategy . set _ failure ( server server ) { logging . debug ( string . format ( STR , server . friendly _ name ( ) ) ) ; }
choose _ new _ server ( controller . get _ current _ configuration ( ) . configs ) ; timer ? . change ( 0 , cached _ interval ) ; } void i _ strategy . set _ failure ( server server ) { logging . debug ( string . format ( STR , server . friendly _ name ( ) ) ) ; } void i _ strategy . update _ last _ read ( server server ) { }
void i _ strategy . set _ failure ( server server ) { logging . debug ( string . format ( STR , server . friendly _ name ( ) ) ) ; } void i _ strategy . update _ last _ read ( server server ) { } void i _ strategy . update _ last _ write ( server server ) { }
update _ buttons ( ) ; load _ selected _ server _ details ( ) ; last _ selected _ index = servers _ list _ box . selected _ index ; } private void add _ button _ click ( object sender , event _ args e ) { if ( ! validate _ and _ save _ selected _ server _ details ( ) ) { return ; }
{ return ; } server server = configuration . get _ default _ server ( ) ; modified _ configuration . configs . add ( server ) ; load _ server _ name _ list _ to _ ui ( modified _ configuration ) ; servers _ list _ box . selected _ index = modified _ configuration . configs . count - 1 ; last _ selected _ index = servers _ list _ box . selected _ index ; } private void duplicate _ button _ click ( object sender , event _ args e ) {
} public static void register _ for _ restart ( bool register ) { if ( register & & ! check ( ) ) {
using shadowsocks _ util ; using shadowsocks _ view ; namespace shadowsocks { static class program { public static shadowsocks _ controller main _ controller { get ; private set ; } public static menu _ view _ controller menu _ controller { get ; private set ; } sta _ thread
using system ; using system _ collections _ generic ; using system _ text ; using system _ security _ cryptography ; namespace shadowsocks _ csharp { class encryptor { public byte [ ] encrypt _ table = new byte [ NUM ] ; public byte [ ] decrypt _ table = new byte [ NUM ] ;
using system _ security _ cryptography ; namespace shadowsocks _ csharp { class encryptor { public byte [ ] encrypt _ table = new byte [ NUM ] ; public byte [ ] decrypt _ table = new byte [ NUM ] ; private int compare ( byte x , byte y , u _ int a , int i ) { return ( int ) ( a % ( u _ int ) ( x + i ) ) - ( int ) ( a % ( u _ int ) ( y + i ) ) ; }
private int port ; private encryptor encryptor ; public local ( int port ) { this . port = port ; this . encryptor = new encryptor ( STR ) ; } public void start ( ) {
using system ; using system _ collections _ generic ; using system _ windows _ forms ; namespace shadowsocks _ csharp { static class program { sta _ thread static void main ( ) {
return ; } encryptor . encrypt ( connetion _ recv _ buffer , bytes _ read , connetion _ send _ buffer , out bytes _ to _ send ) ; } logging . debug ( remote , bytes _ to _ send , STR , STR ) ; tcprelay . update _ outbound _ counter ( bytes _ to _ send ) ; remote . begin _ send ( connetion _ send _ buffer , 0 , bytes _ to _ send , 0 , new async _ callback ( pipe _ remote _ send _ callback ) , null ) ; i _ strategy strategy = controller . get _ current _ strategy ( ) ;
using newtonsoft _ json _ linq ; using shadowsocks _ model ; using shadowsocks _ util ; namespace shadowsocks _ controller { using data _ unit = key _ value _ pair < string , string > ; using data _ list = list < key _ value _ pair < string , string > > ; using statistics = dictionary < string , list < availability _ statistics . raw _ statistics _ data > > ; public class availability _ statistics {
{ using data _ unit = key _ value _ pair < string , string > ; using data _ list = list < key _ value _ pair < string , string > > ; using statistics = dictionary < string , list < availability _ statistics . raw _ statistics _ data > > ; public class availability _ statistics { public static readonly string date _ time _ pattern = STR ; private const string statistics _ files _ name = STR ; private const string delimiter = STR ; private const int timeout = NUM ;
{ public static readonly string date _ time _ pattern = STR ; private const string statistics _ files _ name = STR ; private const string delimiter = STR ; private const int timeout = NUM ; private const int delay _ before _ start = NUM ; public statistics raw _ statistics { get ; private set ; } public statistics filtered _ statistics { get ; private set ; } public static readonly date _ time unknown _ date _ time = new date _ time ( NUM , 1 , 1 ) ; private int repeat = > config . repeat _ times _ num ;
static availability _ statistics ( ) { availability _ statistics _ file = utils . get _ temp _ path ( statistics _ files _ name ) ; }
} private async void evaluate ( ) { var geolocation _ and _ isp = get _ geolocation _ and _ isp ( ) ; foreach ( var data _ lists in await task _ ex . when _ all ( servers . select ( icmp _ test ) ) ) { if ( data _ lists = = null ) continue ; foreach ( var data _ list in data _ lists . where ( data _ list = > data _ list ! = null ) ) {
process . start _ info . create _ no _ window = true ; process . start _ info . redirect _ standard _ output = true ; process . start _ info . redirect _ standard _ error = true ; process . start ( ) ; } } public void stop ( ) { if ( process ! = null ) {
} catch ( exception e ) { console . write _ line ( e . to _ string ( ) ) ; } process = null ; } } private int get _ free _ port ( ) {
console . write _ line ( e . to _ string ( ) ) ; } process = null ; } } private int get _ free _ port ( ) { ip _ global _ properties properties = ip _ global _ properties . get _ ip _ global _ properties ( ) ; ip _ end _ point [ ] tcp _ end _ points = properties . get _ active _ tcp _ listeners ( ) ; list < int > used _ ports = new list < int > ( ) ; foreach ( ip _ end _ point end _ point in ip _ global _ properties . get _ ip _ global _ properties ( ) . get _ active _ tcp _ listeners ( ) ) {
} private int get _ free _ port ( ) { ip _ global _ properties properties = ip _ global _ properties . get _ ip _ global _ properties ( ) ; ip _ end _ point [ ] tcp _ end _ points = properties . get _ active _ tcp _ listeners ( ) ; list < int > used _ ports = new list < int > ( ) ; foreach ( ip _ end _ point end _ point in ip _ global _ properties . get _ ip _ global _ properties ( ) . get _ active _ tcp _ listeners ( ) ) { used _ ports . add ( end _ point . port ) ; }
{ ip _ end _ point [ ] tcp _ end _ points = properties . get _ active _ tcp _ listeners ( ) ; list < int > used _ ports = new list < int > ( ) ; foreach ( ip _ end _ point end _ point in ip _ global _ properties . get _ ip _ global _ properties ( ) . get _ active _ tcp _ listeners ( ) ) { used _ ports . add ( end _ point . port ) ; } for ( int port = NUM ; port < NUM ; port + + ) {
load _ current _ configuration ( ) ; } private void load _ current _ configuration ( ) { modified _ config = controller . get _ configuration _ copy ( ) . hotkey ; load _ configuration ( modified _ config ) ; } private void load _ configuration ( hotkey _ config config ) { switch _ system _ proxy _ text _ box . text = config . switch _ system _ proxy ;
switch _ system _ proxy _ text _ box . text = config . switch _ system _ proxy ; change _ to _ pac _ text _ box . text = config . change _ to _ pac ; change _ to _ global _ text _ box . text = config . change _ to _ global ; switch _ allow _ lan _ text _ box . text = config . switch _ allow _ lan ; show _ logs _ text _ box . text = config . show _ logs ; server _ move _ up _ text _ box . text = config . server _ move _ up ; server _ move _ down _ text _ box . text = config . server _ move _ down ; } private void update _ texts ( ) { switch _ system _ proxy _ label . text = n . get _ string ( STR ) ;
namespace shadowsocks _ model { * format : * < modifiers - combination > + < key > * * / serializable public class hotkey _ config { public string switch _ system _ proxy ;
{ public string switch _ system _ proxy ; public string change _ to _ pac ; public string change _ to _ global ; public string switch _ allow _ lan ; public string show _ logs ; public string server _ move _ up ; public string server _ move _ down ; public hotkey _ config ( ) { switch _ system _ proxy = STR ;
base . dispose ( disposing ) ; } private void initialize _ component ( ) { system . windows . forms . flow _ layout _ panel flow _ layout _ panel ; this . btn _ ok = new system . windows . forms . button ( ) ; this . btn _ cancel = new system . windows . forms . button ( ) ; this . btn _ register _ all = new system . windows . forms . button ( ) ; this . table _ layout _ panel = new system . windows . forms . table _ layout _ panel ( ) ; this . switch _ system _ proxy _ label = new system . windows . forms . label ( ) ;
this . btn _ cancel = new system . windows . forms . button ( ) ; this . btn _ register _ all = new system . windows . forms . button ( ) ; this . table _ layout _ panel = new system . windows . forms . table _ layout _ panel ( ) ; this . switch _ system _ proxy _ label = new system . windows . forms . label ( ) ; this . change _ to _ pac _ label = new system . windows . forms . label ( ) ; this . change _ to _ global _ label = new system . windows . forms . label ( ) ; this . switch _ allow _ lan _ label = new system . windows . forms . label ( ) ; this . show _ logs _ label = new system . windows . forms . label ( ) ; this . server _ move _ up _ label = new system . windows . forms . label ( ) ; this . server _ move _ down _ label = new system . windows . forms . label ( ) ; this . switch _ system _ proxy _ text _ box = new system . windows . forms . text _ box ( ) ;
this . btn _ register _ all . name = STR ; this . btn _ register _ all . size = new system . drawing . size ( NUM , NUM ) ; this . btn _ register _ all . tab _ index = 2 ; this . btn _ register _ all . text = STR ; this . btn _ register _ all . use _ visual _ style _ back _ color = true ; this . btn _ register _ all . click + = new system . event _ handler ( this . register _ all _ button _ click ) ; this . table _ layout _ panel . column _ count = 2 ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . controls . add ( this . switch _ system _ proxy _ label , 0 , 0 ) ;
this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . controls . add ( this . switch _ system _ proxy _ label , 0 , 0 ) ; this . table _ layout _ panel . controls . add ( this . change _ to _ pac _ label , 0 , 1 ) ; this . table _ layout _ panel . controls . add ( this . change _ to _ global _ label , 0 , 2 ) ; this . table _ layout _ panel . controls . add ( this . switch _ allow _ lan _ label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . show _ logs _ label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . server _ move _ up _ label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . server _ move _ down _ label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( flow _ layout _ panel , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . switch _ system _ proxy _ text _ box , 1 , 0 ) ;
this . server _ move _ down _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . server _ move _ down _ text _ box . name = STR ; this . server _ move _ down _ text _ box . read _ only = true ; this . server _ move _ down _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . server _ move _ down _ text _ box . tab _ index = NUM ; this . server _ move _ down _ text _ box . text _ changed + = new system . event _ handler ( this . text _ box _ text _ changed ) ; this . server _ move _ down _ text _ box . key _ down + = new system . windows . forms . key _ event _ handler ( this . hotkey _ down ) ; this . server _ move _ down _ text _ box . key _ up + = new system . windows . forms . key _ event _ handler ( this . hotkey _ up ) ; this . client _ size = new system . drawing . size ( NUM , NUM ) ; this . controls . add ( this . table _ layout _ panel ) ;
this . controls . add ( this . table _ layout _ panel ) ; private system . windows . forms . label change _ to _ pac _ label ; private system . windows . forms . label change _ to _ global _ label ; private system . windows . forms . label switch _ allow _ lan _ label ; private system . windows . forms . label show _ logs _ label ; private system . windows . forms . label server _ move _ up _ label ; private system . windows . forms . label server _ move _ down _ label ; private system . windows . forms . button btn _ ok ; private system . windows . forms . button btn _ cancel ; private system . windows . forms . text _ box show _ logs _ text _ box ; private system . windows . forms . text _ box switch _ allow _ lan _ text _ box ;
{ logging . log _ useful _ exception ( e ) ; } } } } public static bool check ( ) { registry _ key run _ key = null ; try { string path = application . executable _ path ;
public static bool check ( ) { registry _ key run _ key = null ; try { string path = application . executable _ path ; run _ key = microsoft . win . registry . current _ user . open _ sub _ key ( STR , true ) ; string [ ] run _ list = run _ key . get _ value _ names ( ) ; foreach ( string item in run _ list ) {
registry _ key run _ key = null ; try { string path = application . executable _ path ; run _ key = microsoft . win . registry . current _ user . open _ sub _ key ( STR , true ) ; string [ ] run _ list = run _ key . get _ value _ names ( ) ; foreach ( string item in run _ list ) { if ( item . equals ( key ) ) return true ;
using system _ diagnostics ; using system _ runtime _ interop _ services ; using shadowsocks _ controller ; namespace shadowsocks _ util _ process _ management { * see : * http : * / public class job : i _ disposable {
using shadowsocks _ controller ; namespace shadowsocks _ util _ process _ management { * see : * http : * / public class job : i _ disposable { dll _ import _ kernel _ dll _ char _ set _ char _ set _ unicode private static extern int _ ptr create _ job _ object ( int _ ptr a , string lp _ name ) ; dll _ import _ kernel _ dll _ set _ last _ error _ true private static extern bool set _ information _ job _ object ( int _ ptr h _ job , job _ object _ info _ type info _ type , int _ ptr lp _ job _ object _ info , u _ int cb _ job _ object _ info _ length ) ; dll _ import _ kernel _ dll _ set _ last _ error _ true private static extern bool assign _ process _ to _ job _ object ( int _ ptr job , int _ ptr process ) ; dll _ import _ kernel _ dll _ set _ last _ error _ true return _ marshal _ as _ unmanaged _ type _ bool private static extern bool close _ handle ( int _ ptr h _ object ) ; private int _ ptr handle = int _ ptr . zero ;
this . text _ box = new system . windows . forms . text _ box ( ) ; this . panel = new system . windows . forms . panel ( ) ; this . button = new system . windows . forms . button ( ) ; this . button = new system . windows . forms . button ( ) ; this . notify _ icon = new system . windows . forms . notify _ icon ( this . components ) ; this . context _ menu _ strip = new system . windows . forms . context _ menu _ strip ( this . components ) ; this . config _ item = new system . windows . forms . tool _ strip _ menu _ item ( ) ; this . about _ tool _ strip _ menu _ item = new system . windows . forms . tool _ strip _ menu _ item ( ) ; this . quit _ item = new system . windows . forms . tool _ strip _ menu _ item ( ) ;
this . quit _ item . name = STR ; this . quit _ item . size = new system . drawing . size ( NUM , NUM ) ; this . quit _ item . text = STR ; this . quit _ item . click + = new system . event _ handler ( this . quit _ click ) ;
this . name = STR ; this . start _ position = system . windows . forms . form _ start _ position . center _ screen ; this . text = STR ; this . load + = new system . event _ handler ( this . form _ load ) ;
public encryptor encryptor ; public config config ; public socket remote ; public socket connection ; public const int buffer _ size = NUM ; public byte [ ] remote _ buffer = new byte [ buffer _ size ] ; public byte [ ] connetion _ buffer = new byte [ buffer _ size ] ; public string _ builder sb = new string _ builder ( ) ; public void start ( ) {
ip _ address ip _ address = ip _ host _ info . address _ list [ 0 ] ; ip _ end _ point remote _ ep = new ip _ end _ point ( ip _ address , config . server _ port ) ; remote = new socket ( ip _ address . address _ family , socket _ type . stream , protocol _ type . tcp ) ; remote . begin _ connect ( remote _ ep , new async _ callback ( connect _ callback ) , null ) ; } public void close ( ) { connection . close ( ) ;
using system ; using system _ collections _ generic ;
namespace shadowsocks _ csharp { serializable public class config { public string server ; public int server _ port ; public int local _ port ; public string password ;
public bool is _ default ; private static void assert ( bool condition ) { if ( ! condition ) { throw new exception ( STR ) ; } } public static config load ( ) {
if ( ! condition ) { throw new exception ( STR ) ; } } public static config load ( ) { data _ contract _ json _ serializer ser = new data _ contract _ json _ serializer ( typeof ( config ) ) ; try {
throw new exception ( STR ) ; } } public static config load ( ) { data _ contract _ json _ serializer ser = new data _ contract _ json _ serializer ( typeof ( config ) ) ; try { using ( file _ stream fs = file . open _ read ( STR ) ) {
server = STR , server _ port = NUM , local _ port = NUM , password = STR , is _ default = true } ; } } public static void save ( config config ) {
password = STR , is _ default = true } ; } } public static void save ( config config ) { data _ contract _ json _ serializer ser = new data _ contract _ json _ serializer ( typeof ( config ) ) ; try {
} ; } } public static void save ( config config ) { data _ contract _ json _ serializer ser = new data _ contract _ json _ serializer ( typeof ( config ) ) ; try { using ( file _ stream fs = file . open ( STR , file _ mode . create ) ) {

this . context _ menu = new system . windows . forms . context _ menu ( new system . windows . forms . menu _ item [ ] { this . enable _ item = create _ menu _ item ( STR , new system . event _ handler ( this . enable _ item _ click ) ) , create _ menu _ group ( STR , new system . windows . forms . menu _ item [ ] { this . pac _ mode _ item = create _ menu _ item ( STR , new system . event _ handler ( this . pac _ mode _ item _ click ) ) , this . global _ mode _ item = create _ menu _ item ( STR , new system . event _ handler ( this . global _ mode _ item _ click ) ) } ) ,
this . context _ menu = new system . windows . forms . context _ menu ( new system . windows . forms . menu _ item [ ] { this . enable _ item = create _ menu _ item ( STR , new system . event _ handler ( this . enable _ item _ click ) ) , create _ menu _ group ( STR , new system . windows . forms . menu _ item [ ] { this . pac _ mode _ item = create _ menu _ item ( STR , new system . event _ handler ( this . pac _ mode _ item _ click ) ) , this . global _ mode _ item = create _ menu _ item ( STR , new system . event _ handler ( this . global _ mode _ item _ click ) ) } ) , this . servers _ item = create _ menu _ group ( STR , new system . windows . forms . menu _ item [ ] { this . seperator _ item = new menu _ item ( STR ) ,
this . enable _ item = create _ menu _ item ( STR , new system . event _ handler ( this . enable _ item _ click ) ) , create _ menu _ group ( STR , new system . windows . forms . menu _ item [ ] { this . pac _ mode _ item = create _ menu _ item ( STR , new system . event _ handler ( this . pac _ mode _ item _ click ) ) , this . global _ mode _ item = create _ menu _ item ( STR , new system . event _ handler ( this . global _ mode _ item _ click ) ) } ) , this . servers _ item = create _ menu _ group ( STR , new system . windows . forms . menu _ item [ ] { this . seperator _ item = new menu _ item ( STR ) , this . config _ item = create _ menu _ item ( STR , new system . event _ handler ( this . config _ click ) ) } ) , new menu _ item ( STR ) ,
} ) , this . servers _ item = create _ menu _ group ( STR , new system . windows . forms . menu _ item [ ] { this . seperator _ item = new menu _ item ( STR ) , this . config _ item = create _ menu _ item ( STR , new system . event _ handler ( this . config _ click ) ) } ) , new menu _ item ( STR ) , this . auto _ startup _ item = create _ menu _ item ( STR , new system . event _ handler ( this . auto _ startup _ item _ click ) ) , this . share _ over _ lan _ item = create _ menu _ item ( STR , new system . event _ handler ( this . share _ over _ lan _ item _ click ) ) , create _ menu _ item ( STR , new system . event _ handler ( this . edit _ pac _ file _ item _ click ) ) , new menu _ item ( STR ) ,
} ) , new menu _ item ( STR ) , this . auto _ startup _ item = create _ menu _ item ( STR , new system . event _ handler ( this . auto _ startup _ item _ click ) ) , this . share _ over _ lan _ item = create _ menu _ item ( STR , new system . event _ handler ( this . share _ over _ lan _ item _ click ) ) , create _ menu _ item ( STR , new system . event _ handler ( this . edit _ pac _ file _ item _ click ) ) , new menu _ item ( STR ) , create _ menu _ item ( STR , new system . event _ handler ( this . qr _ code _ item _ click ) ) , create _ menu _ item ( STR , new system . event _ handler ( this . show _ log _ item _ click ) ) , create _ menu _ item ( STR , new system . event _ handler ( this . config _ click ) ) , new menu _ item ( STR ) ,
string dll _ path = utils . get _ temp _ path ( STR ) ; try { file _ manager . uncompress _ file ( dll _ path , resources . libsscrypto _ dll ) ; } catch ( io _ exception ) { } catch ( exception e ) {
} catch ( io _ exception ) { } catch ( exception e ) { console . write _ line ( e . to _ string ( ) ) ; } load _ library ( dll _ path ) ; }
catch ( exception e ) { console . write _ line ( e . to _ string ( ) ) ; } load _ library ( dll _ path ) ; } dll _ import _ kernel _ dll private static extern int _ ptr load _ library ( string path ) ; public const int m _ ctx _ size = NUM ; public static byte [ ] m ( byte [ ] input ) { byte [ ] output = new byte [ NUM ] ;
public const int m _ ctx _ size = NUM ; public static byte [ ] m ( byte [ ] input ) { byte [ ] output = new byte [ NUM ] ; mbed _ tls . md ( input , ( uint ) input . length , output ) ; return output ; } dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl
: encryptor _ base { public const int max _ key _ length = NUM ; public const int max _ iv _ length = NUM ; public const int onetimeauth _ flag = 0 ; public const int addrtype _ mask = 0 xf ; public const int onetimeauth _ bytes = NUM ; public const int clen _ bytes = 2 ; public const int auth _ bytes = onetimeauth _ bytes + clen _ bytes ; protected static byte [ ] tempbuf = new byte [ max _ input _ size ] ;
public const int clen _ bytes = 2 ; public const int auth _ bytes = onetimeauth _ bytes + clen _ bytes ; protected static byte [ ] tempbuf = new byte [ max _ input _ size ] ; protected dictionary < string , int [ ] > ciphers ; private static readonly concurrent _ dictionary < string , byte [ ] > cached _ keys = new concurrent _ dictionary < string , byte [ ] > ( ) ; protected byte [ ] encrypt _ iv ; protected byte [ ] decrypt _ iv ; protected bool decrypt _ iv _ received ; protected bool encrypt _ iv _ sent ;
protected byte [ ] key ; protected int key _ len ; protected int iv _ len ; protected uint counter = 0 ; protected byte [ ] key _ buffer = null ; public iv _ encryptor ( string method , string password , bool onetimeauth , bool isudp ) : base ( method , password , onetimeauth , isudp ) { init _ key ( method , password ) ; }
{ init _ key ( method , password ) ; } protected abstract dictionary < string , int [ ] > get _ ciphers ( ) ; protected void init _ key ( string method , string password ) { method = method . to _ lower ( ) ; method = method ; string k = method + STR + password ; ciphers = get _ ciphers ( ) ;
method = method ; string k = method + STR + password ; ciphers = get _ ciphers ( ) ; cipher _ info = ciphers [ method ] ; cipher = cipher _ info [ 2 ] ; if ( cipher = = 0 ) { throw new exception ( STR ) ; }
static byte [ ] sodium _ buf = new byte [ max _ input _ size + sodium _ block _ size ] ; protected int encrypt _ bytes _ remaining ; protected int decrypt _ bytes _ remaining ; protected ulong encrypt _ ic ; protected ulong decrypt _ ic ; public sodium _ encryptor ( string method , string password , bool onetimeauth , bool isudp ) : base ( method , password , onetimeauth , isudp ) { init _ key ( method , password ) ; }
public sodium _ encryptor ( string method , string password , bool onetimeauth , bool isudp ) : base ( method , password , onetimeauth , isudp ) { init _ key ( method , password ) ; } private static dictionary < string , int [ ] > ciphers = new dictionary < string , int [ ] > { { STR , new int [ ] { NUM , NUM , cipher _ sals , polar _ ssl . aes _ ctx _ size } } , { STR , new int [ ] { NUM , NUM , cipher _ chach , polar _ ssl . aes _ ctx _ size } } , { STR , new int [ ] { NUM , NUM , cipher _ chach _ ietf , polar _ ssl . aes _ ctx _ size } } , } ;
decryptor . decrypt ( cipher , out _ len , plain , out out _ len ) ; assert . are _ equal ( NUM , out _ len ) ; for ( int j = 0 ; j < out _ len ; j + + ) { assert . are _ equal ( plain [ j ] , plain [ j ] ) ; } } private static bool encryption _ failed = false ; private static object locker = new object ( ) ; test _ method
} private static bool encryption _ failed = false ; private static object locker = new object ( ) ; test _ method public void test _ polar _ ssl _ encryption ( ) { run _ single _ polar _ ssl _ encryption _ thread ( ) ; list < thread > threads = new list < thread > ( ) ; for ( int i = 0 ; i < NUM ; i + + ) {
thread t = new thread ( new thread _ start ( run _ single _ polar _ ssl _ encryption _ thread ) ) ; threads . add ( t ) ; t . start ( ) ; } foreach ( thread t in threads ) { t . join ( ) ; } assert . is _ false ( encryption _ failed ) ; }
assert . is _ false ( encryption _ failed ) ; } private void run _ single _ polar _ ssl _ encryption _ thread ( ) { try { for ( int i = 0 ; i < NUM ; i + + ) { i _ encryptor encryptor ; i _ encryptor decryptor ;
case cipher _ ae _ gcm : ret = sodium . crypto _ aead _ aes _ gcm _ encrypt ( ciphertext , ref enc _ clen , plaintext , ( ulong ) plen , null , 0 , null , enc _ nonce , sodium _ enc _ subkey ) ; break ; default : throw new system . exception ( STR ) ; }
null , 0 , null , enc _ nonce , sodium _ enc _ subkey ) ; break ; default : throw new system . exception ( STR ) ; } if ( ret ! = 0 ) throw new crypto _ error _ exception ( ) ; logging . dump ( STR , ciphertext , ( int ) enc _ clen ) ; clen = ( uint ) enc _ clen ;
sodium _ enc _ subkey ) ; break ; default : throw new system . exception ( STR ) ; } if ( ret ! = 0 ) throw new crypto _ error _ exception ( ) ; logging . dump ( STR , ciphertext , ( int ) enc _ clen ) ; clen = ( uint ) enc _ clen ; return ret ; }
case cipher _ ae _ gcm : ret = sodium . crypto _ aead _ aes _ gcm _ decrypt ( plaintext , ref dec _ plen , null , ciphertext , ( ulong ) clen , null , 0 , dec _ nonce , sodium _ dec _ subkey ) ; break ; default : throw new system . exception ( STR ) ; }
ciphertext , ( ulong ) clen , null , 0 , dec _ nonce , sodium _ dec _ subkey ) ; break ; default : throw new system . exception ( STR ) ; } if ( ret ! = 0 ) throw new crypto _ error _ exception ( ) ; logging . dump ( STR , plaintext , ( int ) dec _ plen ) ; plen = ( uint ) dec _ plen ;
var aead _ mbed _ tls _ encryptor _ supported _ ciphers = aead _ mbed _ tls _ encryptor . supported _ ciphers ( ) ; var aead _ sodium _ encryptor _ supported _ ciphers = aead _ sodium _ encryptor . supported _ ciphers ( ) ; if ( sodium . ae _ gcm _ available ) { aead _ mbed _ tls _ encryptor _ supported _ ciphers . remove ( STR ) ; } else { aead _ sodium _ encryptor _ supported _ ciphers . remove ( STR ) ; }
{ aead _ mbed _ tls _ encryptor _ supported _ ciphers . remove ( STR ) ; } else { aead _ sodium _ encryptor _ supported _ ciphers . remove ( STR ) ; } foreach ( string method in stream _ mbed _ tls _ encryptor . supported _ ciphers ( ) ) {
aead _ sodium _ encryptor _ supported _ ciphers . remove ( STR ) ; } foreach ( string method in stream _ mbed _ tls _ encryptor . supported _ ciphers ( ) ) { registered _ encryptors . add ( method , typeof ( stream _ mbed _ tls _ encryptor ) ) ; } foreach ( string method in stream _ sodium _ encryptor . supported _ ciphers ( ) ) {
registered _ encryptors . add ( method , typeof ( stream _ mbed _ tls _ encryptor ) ) ; } foreach ( string method in stream _ sodium _ encryptor . supported _ ciphers ( ) ) { registered _ encryptors . add ( method , typeof ( stream _ sodium _ encryptor ) ) ; } foreach ( string method in aead _ mbed _ tls _ encryptor _ supported _ ciphers ) {
uint olen = 0 ; switch ( cipher ) { case cipher _ aes : ret = mbed _ tls . cipher _ auth _ encrypt ( encrypt _ ctx , enc _ nonce , ( uint ) nonce _ len , int _ ptr . zero , 0 , plaintext , plen , ciphertext , ref olen , tagbuf , ( uint ) tag _ len ) ;
ret = mbed _ tls . cipher _ auth _ encrypt ( encrypt _ ctx , enc _ nonce , ( uint ) nonce _ len , int _ ptr . zero , 0 , plaintext , plen , ciphertext , ref olen , tagbuf , ( uint ) tag _ len ) ; if ( ret ! = 0 ) throw new crypto _ error _ exception ( ) ; debug . assert ( olen = = plen ) ; array . copy ( tagbuf , 0 , ciphertext , ( int ) plen , tag _ len ) ; clen = olen + ( uint ) tag _ len ;
tagbuf , ( uint ) tag _ len ) ; if ( ret ! = 0 ) throw new crypto _ error _ exception ( ) ; debug . assert ( olen = = plen ) ; array . copy ( tagbuf , 0 , ciphertext , ( int ) plen , tag _ len ) ; clen = olen + ( uint ) tag _ len ; return ret ; default : throw new system . exception ( STR ) ; } }
array . copy ( ciphertext , ( int ) ( clen - tag _ len ) , tagbuf , 0 , tag _ len ) ; switch ( cipher ) { case cipher _ aes : ret = mbed _ tls . cipher _ auth _ decrypt ( decrypt _ ctx , dec _ nonce , ( uint ) nonce _ len , int _ ptr . zero , 0 , ciphertext , ( uint ) ( clen - tag _ len ) , plaintext , ref olen , tagbuf , ( uint ) tag _ len ) ;
case cipher _ aes : ret = mbed _ tls . cipher _ auth _ decrypt ( decrypt _ ctx , dec _ nonce , ( uint ) nonce _ len , int _ ptr . zero , 0 , ciphertext , ( uint ) ( clen - tag _ len ) , plaintext , ref olen , tagbuf , ( uint ) tag _ len ) ; if ( ret ! = 0 ) throw new crypto _ error _ exception ( ) ; debug . assert ( olen = = clen - tag _ len ) ; plen = olen ;
if ( disposing & & ( components ! = null ) ) { components . dispose ( ) ; } base . dispose ( disposing ) ; } private void initialize _ component ( ) { this . components = new system . component _ model . container ( ) ; this . log _ message _ text _ box = new system . windows . forms . text _ box ( ) ;
} private void initialize _ component ( ) { this . components = new system . component _ model . container ( ) ; this . log _ message _ text _ box = new system . windows . forms . text _ box ( ) ; this . context _ menu _ strip = new system . windows . forms . context _ menu _ strip ( this . components ) ; this . main _ menu = new system . windows . forms . main _ menu ( this . components ) ; this . file _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . open _ location _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . exit _ menu _ item = new system . windows . forms . menu _ item ( ) ;
this . main _ menu = new system . windows . forms . main _ menu ( this . components ) ; this . file _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . open _ location _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . exit _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . panel = new system . windows . forms . panel ( ) ; this . change _ font _ button = new system . windows . forms . button ( ) ; this . clean _ logs _ button = new system . windows . forms . button ( ) ; this . wrap _ text _ check _ box = new system . windows . forms . check _ box ( ) ; this . table _ layout _ panel = new system . windows . forms . table _ layout _ panel ( ) ;
this . file _ menu _ item . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . open _ location _ menu _ item , this . exit _ menu _ item } ) ; this . file _ menu _ item . text = STR ; this . open _ location _ menu _ item . index = 0 ; this . open _ location _ menu _ item . text = STR ; this . open _ location _ menu _ item . click + = new system . event _ handler ( this . open _ location _ menu _ item _ click ) ; this . exit _ menu _ item . index = 1 ; this . exit _ menu _ item . text = STR ; this . exit _ menu _ item . click + = new system . event _ handler ( this . exit _ menu _ item _ click ) ;
this . panel . controls . add ( this . top _ most _ check _ box ) ; this . panel . controls . add ( this . change _ font _ button ) ; this . panel . controls . add ( this . clean _ logs _ button ) ; this . panel . controls . add ( this . wrap _ text _ check _ box ) ; this . panel . dock = system . windows . forms . dock _ style . fill ; this . panel . location = new system . drawing . point ( NUM , NUM ) ; this . panel . name = STR ; this . panel . size = new system . drawing . size ( NUM , NUM ) ; this . panel . tab _ index = 1 ;
this . panel . size = new system . drawing . size ( NUM , NUM ) ; this . panel . tab _ index = 1 ; this . change _ font _ button . location = new system . drawing . point ( NUM , NUM ) ; this . change _ font _ button . name = STR ; this . change _ font _ button . size = new system . drawing . size ( NUM , NUM ) ; this . change _ font _ button . tab _ index = 2 ; this . change _ font _ button . text = STR ; this . change _ font _ button . use _ visual _ style _ back _ color = true ; this . change _ font _ button . click + = new system . event _ handler ( this . change _ font _ button _ click ) ;
this . wrap _ text _ check _ box . auto _ size = true ; this . wrap _ text _ check _ box . location = new system . drawing . point ( NUM , NUM ) ; this . wrap _ text _ check _ box . name = STR ; this . wrap _ text _ check _ box . size = new system . drawing . size ( NUM , NUM ) ; this . wrap _ text _ check _ box . tab _ index = 0 ; this . wrap _ text _ check _ box . text = STR ; this . wrap _ text _ check _ box . use _ visual _ style _ back _ color = true ; this . wrap _ text _ check _ box . checked _ changed + = new system . event _ handler ( this . wrap _ text _ check _ box _ checked _ changed ) ; this . table _ layout _ panel . column _ count = 1 ;
this . wrap _ text _ check _ box . checked _ changed + = new system . event _ handler ( this . wrap _ text _ check _ box _ checked _ changed ) ; this . table _ layout _ panel . column _ count = 1 ; this . table _ layout _ panel . controls . add ( this . panel , 0 , 0 ) ; this . table _ layout _ panel . controls . add ( this . log _ message _ text _ box , 0 , 1 ) ; this . table _ layout _ panel . dock = system . windows . forms . dock _ style . fill ; this . table _ layout _ panel . location = new system . drawing . point ( 0 , 0 ) ; this . table _ layout _ panel . name = STR ; this . table _ layout _ panel . row _ count = 2 ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ;
this . table _ layout _ panel . controls . add ( this . log _ message _ text _ box , 0 , 1 ) ; this . table _ layout _ panel . dock = system . windows . forms . dock _ style . fill ; this . table _ layout _ panel . location = new system . drawing . point ( 0 , 0 ) ; this . table _ layout _ panel . name = STR ; this . table _ layout _ panel . row _ count = 2 ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ; this . table _ layout _ panel . tab _ index = 2 ;

this . panel . resume _ layout ( false ) ; this . panel . perform _ layout ( ) ; this . table _ layout _ panel . resume _ layout ( false ) ; this . table _ layout _ panel . perform _ layout ( ) ; this . resume _ layout ( false ) ; } private system . windows . forms . text _ box log _ message _ text _ box ;
this . resume _ layout ( false ) ; } private system . windows . forms . text _ box log _ message _ text _ box ; private system . windows . forms . context _ menu _ strip context _ menu _ strip ; private system . windows . forms . main _ menu main _ menu ; private system . windows . forms . menu _ item file _ menu _ item ; private system . windows . forms . menu _ item open _ location _ menu _ item ; private system . windows . forms . menu _ item exit _ menu _ item ;
system . diagnostics . process . start ( STR , argument ) ; } private void exit _ menu _ item _ click ( object sender , event _ args e ) { this . close ( ) ; } private void log _ form _ shown ( object sender , event _ args e ) { log _ message _ text _ box . scroll _ to _ caret ( ) ; }
{ log _ message _ text _ box . scroll _ to _ caret ( ) ; } private void wrap _ text _ check _ box _ checked _ changed ( object sender , event _ args e ) { log _ message _ text _ box . word _ wrap = wrap _ text _ check _ box . checked ; log _ message _ text _ box . scroll _ to _ caret ( ) ; } private void clean _ logs _ button _ click ( object sender , event _ args e ) {
private void top _ most _ check _ box _ checked _ changed ( object sender , event _ args e ) {
if ( bytes _ read > = NUM ) { command = connetion _ recv _ buffer [ 1 ] ; if ( command ! = 1 & & command ! = NUM ) { logging . debug ( STR + command ) ; close ( ) ; } else {
command = connetion _ recv _ buffer [ 1 ] ; if ( command ! = 1 & & command ! = NUM ) { logging . debug ( STR + command ) ; close ( ) ; } else { int atyp = connetion _ recv _ buffer [ NUM ] ; switch ( atyp ) {
logging . debug ( STR ) ; close ( ) ; } } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; } }
catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; } } private void read _ address ( int bytes _ remain ) { array . copy ( connetion _ recv _ buffer , NUM , connetion _ recv _ buffer , 0 , 2 ) ;
{ array . copy ( connetion _ recv _ buffer , NUM , connetion _ recv _ buffer , 0 , 2 ) ; connection . begin _ receive ( connetion _ recv _ buffer , 2 , recv _ size - 2 , socket _ flags . none , on _ address _ fully _ read , bytes _ remain ) ; } private void on _ address _ fully _ read ( i _ async _ result ar ) { if ( closed ) return ; try { int bytes _ read = connection . end _ receive ( ar ) ;
{ server = ( server ) obj ; return server = = . server & & server _ port = = . server _ port ; } public string friendly _ name ( ) { if ( server . is _ null _ or _ empty ( ) ) { return n . get _ string ( STR ) ; }
} public string friendly _ name ( ) { if ( server . is _ null _ or _ empty ( ) ) { return n . get _ string ( STR ) ; } if ( remarks . is _ null _ or _ empty ( ) ) { return server + STR + server _ port ; }
} return true ; } private bool on _ line _ read ( string line , object state ) { if ( closed ) { return true ; } logging . debug ( line ) ;
{ return true ; } logging . debug ( line ) ; if ( ! line . starts _ with ( STR ) ) { headers . enqueue ( line ) ; } if ( request _ line _ count = = 0 ) { var m = http _ request _ header _ regex . match ( line ) ; if ( m . success ) {
if ( request _ line _ count = = 0 ) { var m = http _ request _ header _ regex . match ( line ) ; if ( m . success ) { var method = m . groups [ 1 ] . value ; if ( method = = STR ) { is _ connect = true ;
var method = m . groups [ 1 ] . value ; if ( method = = STR ) { is _ connect = true ; if ( ! parse _ host ( m . groups [ 2 ] . value ) ) { throw new exception ( STR + line ) ; } }
} private void handshake _ receive _ callback ( i _ async _ result ar ) { if ( closed ) { return ; } try { int bytes _ read = connection . end _ receive ( ar ) ;
{ return ; } try { int bytes _ read = connection . end _ receive ( ar ) ; if ( bytes _ read > 0 ) { byte [ ] response = { NUM , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 } ;
{ this . pac _ url _ text _ box = new system . windows . forms . text _ box ( ) ; this . pac _ url _ label = new system . windows . forms . label ( ) ; this . ok _ button = new system . windows . forms . button ( ) ; this . cancel _ button = new system . windows . forms . button ( ) ; this . suspend _ layout ( ) ;
this . suspend _ layout ( ) ; this . pac _ url _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . pac _ url _ text _ box . max _ length = NUM ; this . pac _ url _ text _ box . name = STR ; this . pac _ url _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . pac _ url _ text _ box . tab _ index = NUM ; this . pac _ url _ text _ box . word _ wrap = false ; this . pac _ url _ label . auto _ size = true ;

+ mask _ util . apply _ mask _ penalty _ rule ( matrix ) ; } public static qr _ code encode ( string content , error _ correction _ level ec _ level ) {
{ string encoding = default _ byte _ mode _ encoding ; const string encoding = STR ; bool generate _ eci = ( hints ! = null & & hints . contains _ key ( encode _ hint _ type . character _ set ) ) ;
{ string encoding = default _ byte _ mode _ encoding ; const string encoding = STR ; bool generate _ eci = ( hints ! = null & & hints . contains _ key ( encode _ hint _ type . character _ set ) ) ; mode mode = mode . byte ; bit _ array header _ bits = new bit _ array ( ) ;
int num _ bytes = version . total _ codewords ; version . ec _ blocks ec _ blocks = version . get _ ec _ blocks _ for _ level ( ec _ level ) ; int num _ ec _ bytes = ec _ blocks . total _ ec _ codewords ; int num _ data _ bytes = num _ bytes - num _ ec _ bytes ; int total _ input _ bytes = ( num _ input _ bits + NUM ) / NUM ; if ( num _ data _ bytes > = total _ input _ bytes ) { return version ; } }
int num _ rs _ blocks _ in _ group = num _ total _ bytes % num _ rs _ blocks ; int num _ rs _ blocks _ in _ group = num _ rs _ blocks - num _ rs _ blocks _ in _ group ; int num _ total _ bytes _ in _ group = num _ total _ bytes / num _ rs _ blocks ; int num _ total _ bytes _ in _ group = num _ total _ bytes _ in _ group + 1 ; int num _ data _ bytes _ in _ group = num _ data _ bytes / num _ rs _ blocks ; int num _ data _ bytes _ in _ group = num _ data _ bytes _ in _ group + 1 ; int num _ ec _ bytes _ in _ group = num _ total _ bytes _ in _ group - num _ data _ bytes _ in _ group ; int num _ ec _ bytes _ in _ group = num _ total _ bytes _ in _ group - num _ data _ bytes _ in _ group ; if ( num _ ec _ bytes _ in _ group ! = num _ ec _ bytes _ in _ group ) {
int num _ data _ bytes _ in _ group = num _ data _ bytes / num _ rs _ blocks ; int num _ data _ bytes _ in _ group = num _ data _ bytes _ in _ group + 1 ; int num _ ec _ bytes _ in _ group = num _ total _ bytes _ in _ group - num _ data _ bytes _ in _ group ; int num _ ec _ bytes _ in _ group = num _ total _ bytes _ in _ group - num _ data _ bytes _ in _ group ; if ( num _ ec _ bytes _ in _ group ! = num _ ec _ bytes _ in _ group ) { throw new exception ( STR ) ; } if ( num _ rs _ blocks ! = num _ rs _ blocks _ in _ group + num _ rs _ blocks _ in _ group ) {
if ( num _ rs _ blocks ! = num _ rs _ blocks _ in _ group + num _ rs _ blocks _ in _ group ) { throw new exception ( STR ) ; } if ( num _ total _ bytes ! = ( ( num _ data _ bytes _ in _ group + num _ ec _ bytes _ in _ group ) * num _ rs _ blocks _ in _ group ) + ( ( num _ data _ bytes _ in _ group + num _ ec _ bytes _ in _ group ) * num _ rs _ blocks _ in _ group ) ) {
} internal static void append _ mode _ info ( mode mode , bit _ array bits ) { bits . append _ bits ( mode . bits , NUM ) ; } internal static void append _ length _ info ( int num _ letters , version version , mode mode , bit _ array bits ) { int num _ bits = mode . get _ character _ count _ bits ( version ) ; if ( num _ letters > = ( 1 < < num _ bits ) ) {
if ( mode . equals ( mode . byte ) ) append _ bit _ bytes ( content , bits , encoding ) ; else
bytes = encoding . get _ encoding ( STR ) . get _ bytes ( content ) ; } } catch ( exception uee ) { throw new writer _ exception ( uee . message , uee ) ; } } catch ( exception uee ) {
if ( is _ empty ( matrix [ NUM , i ] ) ) { matrix [ NUM , i ] = bit ; } } } private static void embed _ dark _ dot _ at _ left _ bottom _ corner ( byte _ matrix matrix ) { if ( matrix [ NUM , matrix . height - NUM ] = = 0 ) {
throw new exception ( ) ; } matrix [ NUM , matrix . height - NUM ] = 1 ; } private static void embed _ horizontal _ separation _ pattern ( int x _ start , int y _ start , byte _ matrix matrix ) { for ( int x = 0 ; x < NUM ; + + x ) { if ( ! is _ empty ( matrix [ x _ start + x , y _ start ] ) ) {
polipo _ runner . stop ( ) ; try { polipo _ runner . start ( config ) ; local local = new local ( config ) ; list < listener . service > services = new list < listener . service > ( ) ; services . add ( local ) ; listener = new listener ( services ) ; listener . start ( config ) ;
using system ; using system _ collections _ generic ; using system _ diagnostics ; using system _ io ; using system _ i _ compression ; using system _ net ; using system _ net _ sockets ; using system _ text ; namespace shadowsocks _ controller {
using system _ i _ compression ; using system _ net ; using system _ net _ sockets ; using system _ text ; namespace shadowsocks _ controller { class pac _ server { private static int port = NUM ; public static string pac _ file = STR ;
using system _ text ; namespace shadowsocks _ controller { class pac _ server { private static int port = NUM ; public static string pac _ file = STR ; private static configuration config ; socket listener ; file _ system _ watcher watcher ; public event event _ handler pac _ file _ changed ;
private static int port = NUM ; public static string pac _ file = STR ; private static configuration config ; socket listener ; file _ system _ watcher watcher ; public event event _ handler pac _ file _ changed ; public void start ( configuration configuration ) { try {
public event event _ handler pac _ file _ changed ; public void start ( configuration configuration ) { try { config = configuration ; listener = new socket ( address _ family . inter _ network , socket _ type . stream , protocol _ type . tcp ) ; listener . set _ socket _ option ( socket _ option _ level . socket , socket _ option _ name . reuse _ address , true ) ; ip _ end _ point local _ end _ point = null ; if ( configuration . share _ over _ lan ) {
{ try { config = configuration ; listener = new socket ( address _ family . inter _ network , socket _ type . stream , protocol _ type . tcp ) ; listener . set _ socket _ option ( socket _ option _ level . socket , socket _ option _ name . reuse _ address , true ) ; ip _ end _ point local _ end _ point = null ; if ( configuration . share _ over _ lan ) { local _ end _ point = new ip _ end _ point ( ip _ address . any , port ) ; }
{ listener = new socket ( address _ family . inter _ network , socket _ type . stream , protocol _ type . tcp ) ; listener . set _ socket _ option ( socket _ option _ level . socket , socket _ option _ name . reuse _ address , true ) ; ip _ end _ point local _ end _ point = null ; if ( configuration . share _ over _ lan ) { local _ end _ point = new ip _ end _ point ( ip _ address . any , port ) ; } else {
if ( configuration . share _ over _ lan ) { local _ end _ point = new ip _ end _ point ( ip _ address . any , port ) ; } else { local _ end _ point = new ip _ end _ point ( ip _ address . loopback , port ) ; }
local _ end _ point = new ip _ end _ point ( ip _ address . any , port ) ; } else { local _ end _ point = new ip _ end _ point ( ip _ address . loopback , port ) ; } listener . bind ( local _ end _ point ) ; listener . listen ( NUM ) ; listener . begin _ accept ( new async _ callback ( accept _ callback ) , listener ) ; watch _ pac _ file ( ) ; }
} else { local _ end _ point = new ip _ end _ point ( ip _ address . loopback , port ) ; } listener . bind ( local _ end _ point ) ; listener . listen ( NUM ) ; listener . begin _ accept ( new async _ callback ( accept _ callback ) , listener ) ; watch _ pac _ file ( ) ; } catch ( socket _ exception ) {
{ if ( file . exists ( pac _ file ) ) { return file . read _ all _ text ( pac _ file , encoding . ut ) ; } else { return utils . un _ gzip ( resources . proxy _ pac _ txt ) ; } }
{ return file . read _ all _ text ( pac _ file , encoding . ut ) ; } else { return utils . un _ gzip ( resources . proxy _ pac _ txt ) ; } } private void receive _ callback ( i _ async _ result ar ) {
else { return utils . un _ gzip ( resources . proxy _ pac _ txt ) ; } } private void receive _ callback ( i _ async _ result ar ) { object [ ] state = ( object [ ] ) ar . async _ state ; socket conn = ( socket ) state [ 0 ] ; byte [ ] request _ buf = ( byte [ ] ) state [ 1 ] ; try {
return utils . un _ gzip ( resources . proxy _ pac _ txt ) ; } } private void receive _ callback ( i _ async _ result ar ) { object [ ] state = ( object [ ] ) ar . async _ state ; socket conn = ( socket ) state [ 0 ] ; byte [ ] request _ buf = ( byte [ ] ) state [ 1 ] ; try { int bytes _ read = conn . end _ receive ( ar ) ; string pac = get _ pac _ content ( ) ;
private void receive _ callback ( i _ async _ result ar ) { object [ ] state = ( object [ ] ) ar . async _ state ; socket conn = ( socket ) state [ 0 ] ; byte [ ] request _ buf = ( byte [ ] ) state [ 1 ] ; try { int bytes _ read = conn . end _ receive ( ar ) ; string pac = get _ pac _ content ( ) ; ip _ end _ point local _ end _ point = ( ip _ end _ point ) conn . local _ end _ point ; string proxy = get _ pac _ address ( request _ buf , local _ end _ point ) ; pac = pac . replace ( STR , proxy ) ;
ip _ end _ point local _ end _ point = ( ip _ end _ point ) conn . local _ end _ point ; string proxy = get _ pac _ address ( request _ buf , local _ end _ point ) ; pac = pac . replace ( STR , proxy ) ; if ( bytes _ read > 0 ) { string text = string . format ( @ STR server : shadowsocks content - type : application / x - ns - proxy - autoconfig content - length : { 0 } connection : close STR
connection : close STR util . utils . release _ memory ( ) ; } else { conn . close ( ) ; } } catch ( exception e ) { console . write _ line ( e ) ;
watcher . renamed + = watcher _ changed ; watcher . enable _ raising _ events = true ; } private void watcher _ changed ( object sender , file _ system _ event _ args e ) { if ( pac _ file _ changed ! = null ) { pac _ file _ changed ( this , new event _ args ( ) ) ; } }
} private void watcher _ changed ( object sender , file _ system _ event _ args e ) { if ( pac _ file _ changed ! = null ) { pac _ file _ changed ( this , new event _ args ( ) ) ; } } private string get _ pac _ address ( byte [ ] request _ buf , ip _ end _ point local _ end _ point ) {
using shadowsocks _ model ; namespace shadowsocks _ controller { class local : listener . service { private configuration config ; public local ( configuration config ) { this . config = config ; }
using shadowsocks _ controller ; using system _ threading ; using system _ collections _ generic ; using shadowsocks _ model ; using system _ diagnostics ; namespace shadowsocks _ test { test _ class public class url _ test {
test _ method public void parse _ and _ generate _ shadowsocks _ url ( ) { var server = new server { server = STR , server _ port = NUM , password = STR , method = STR } ;
method = STR } ; var server _ canon _ url = STR ; var server = new server { server = STR , server _ port = NUM , password = STR , method = STR } ;
} ; var server _ canon _ url = STR ; var server _ with _ remark = new server { server = server . server , server _ port = server . server _ port , password = server . password , method = server . method , remarks = STR } ;
} ; var server _ with _ remark _ canon _ url = STR ; var server _ with _ remark = new server { server = server . server , server _ port = server . server _ port , password = server . password , method = server . method , remarks = STR } ;
var server _ with _ remark _ canon _ url = STR ; var server _ with _ plugin = new server { server = server . server , server _ port = server . server _ port , password = server . password , method = server . method , plugin = STR , plugin _ opts = STR } ;
{ server = server . server , server _ port = server . server _ port , password = server . password , method = server . method , plugin = STR , plugin _ opts = STR } ; var server _ with _ plugin _ canon _ url = STR ;
STR ; var server _ with _ plugin = new server { server = server . server , server _ port = server . server _ port , password = server . password , method = server . method , plugin = STR , plugin _ opts = STR } ;
{ server = server . server , server _ port = server . server _ port , password = server . password , method = server . method , plugin = STR , plugin _ opts = STR } ; var server _ with _ plugin _ canon _ url = STR ;
server = server . server , server _ port = server . server _ port , password = server . password , method = server . method , plugin = server _ with _ plugin . plugin , plugin _ opts = server _ with _ plugin . plugin _ opts , remarks = server _ with _ remark . remarks } ; var server _ with _ plugin _ and _ remark _ canon _ url = STR ;
var server _ with _ plugin _ and _ remark = new server { server = server . server , server _ port = server . server _ port , password = server . password , method = server . method , plugin = server _ with _ plugin . plugin , plugin _ opts = server _ with _ plugin . plugin _ opts , remarks = server _ with _ remark . remarks } ;
server = server . server , server _ port = server . server _ port , password = server . password , method = server . method , plugin = server _ with _ plugin . plugin , plugin _ opts = server _ with _ plugin . plugin _ opts , remarks = server _ with _ remark . remarks } ; var server _ with _ plugin _ and _ remark _ canon _ url = STR ;
run _ parse _ shadowsocks _ url _ test ( string . join ( STR , server _ canon _ url , STR , STR , server _ with _ remark _ canon _ url , STR ) , new [ ] {
using shadowsocks _ controller _ service ; using system _ diagnostics ; using system _ net ; namespace shadowsocks _ test { test _ class public class sip _ plugin _ test { test _ method
using system _ net ; namespace shadowsocks _ test { test _ class public class sip _ plugin _ test { test _ method public void sip _ plugin _ support ( ) {
using shadowsocks _ controller _ hotkeys ; using shadowsocks _ model ; using shadowsocks _ properties ; using shadowsocks _ util ; namespace shadowsocks _ view { public partial class hotkey _ settings _ form : form { private readonly shadowsocks _ controller controller ; private hotkey _ config modified _ hotkey _ config ;
private hotkey _ config modified _ hotkey _ config ; private readonly i _ enumerable < text _ box > all _ text _ boxes ; public hotkey _ settings _ form ( shadowsocks _ controller controller ) { initialize _ component ( ) ; update _ texts ( ) ; icon = icon . from _ handle ( resources . ssw . get _ hicon ( ) ) ; controller = controller ; controller . config _ changed + = controller _ config _ changed ; load _ current _ configuration ( ) ;
this . close ( ) ; } private void register _ all _ button _ click ( object sender , event _ args e ) { modified _ hotkey _ config = get _ config _ from _ ui ( ) ; register _ all _ hotkeys ( modified _ hotkey _ config ) ; } private bool register _ all _ hotkeys ( hotkey _ config hotkey _ config ) { return
private bool register _ all _ hotkeys ( hotkey _ config hotkey _ config ) { return try _ reg _ hotkey _ from _ string ( hotkey _ config . switch _ system _ proxy , STR , switch _ system _ proxy _ label ) & & try _ reg _ hotkey _ from _ string ( hotkey _ config . switch _ system _ proxy _ mode , STR , switch _ proxy _ mode _ label ) & & try _ reg _ hotkey _ from _ string ( hotkey _ config . switch _ allow _ lan , STR , switch _ allow _ lan _ label ) & & try _ reg _ hotkey _ from _ string ( hotkey _ config . show _ logs , STR , show _ logs _ label ) & & try _ reg _ hotkey _ from _ string ( hotkey _ config . server _ move _ up , STR , server _ move _ up _ label ) & & try _ reg _ hotkey _ from _ string ( hotkey _ config . server _ move _ down , STR , server _ move _ down _ label ) ; }
private bool try _ reg _ hotkey _ from _ string ( string hotkey _ str , string callback _ name , label indicator = null ) { var callback = hotkey _ callbacks . get _ callback ( callback _ name ) ; if ( callback = = null ) { throw new exception ( $ STR ) ; } var callback = callback as hot _ keys . hot _ key _ call _ back _ handler ; if ( hotkey _ str . is _ null _ or _ empty ( ) ) {
else { var hotkey = hot _ keys . str _ hot _ key ( hotkey _ str ) ; if ( hotkey = = null ) { message _ box . show ( string . format ( n . get _ string ( STR ) , hotkey _ str ) ) ; return false ; } else {
{ bool reg _ result = ( try _ reg _ hotkey ( hotkey , callback ) ) ; if ( indicator ! = null ) { indicator . back _ color = reg _ result ? color . green : color . yellow ; } return reg _ result ; } } }
{ if ( line . begin _ with _ any ( ignored _ line _ begins ) ) continue ; valid _ lines . add ( line ) ; } } return valid _ lines ; } private static list < string > parse _ to _ valid _ list ( i _ list < domain _ object > domains ) {
private static list < string > parse _ to _ valid _ list ( i _ list < domain _ object > domains ) { list < string > ret = new list < string > ( domains . count + NUM ) ; foreach ( var d in domains ) { string domain = d . value ; switch ( d . type ) { case domain _ object . types . type . plain :
notify _ icon . mouse _ double _ click + = notify _ icon _ double _ click ; this . update _ checker = new update _ checker ( ) ; update _ checker . check _ update _ completed + = update _ checker _ check _ update _ completed ; load _ current _ configuration ( ) ; configuration config = controller . get _ configuration _ copy ( ) ; if ( config . auto _ check _ update ) { is _ startup _ checking = true ;
this . table _ layout _ panel . controls . add ( this . plugin _ options _ label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . plugin _ text _ box , 1 , NUM ) ; this . table _ layout _ panel . controls . add ( this . remarks _ text _ box , 1 , NUM ) ; this . table _ layout _ panel . controls . add ( this . remarks _ label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . ip _ label , 0 , 0 ) ; this . table _ layout _ panel . controls . add ( this . server _ port _ label , 0 , 1 ) ; this . table _ layout _ panel . controls . add ( this . password _ label , 0 , 2 ) ; this . table _ layout _ panel . controls . add ( this . ip _ text _ box , 1 , 0 ) ; this . table _ layout _ panel . controls . add ( this . server _ port _ text _ box , 1 , 1 ) ; this . table _ layout _ panel . controls . add ( this . password _ text _ box , 1 , 2 ) ;
this . table _ layout _ panel . controls . add ( this . encryption _ label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . encryption _ select , 1 , NUM ) ; this . table _ layout _ panel . controls . add ( this . timeout _ label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . timeout _ text _ box , 1 , NUM ) ; this . table _ layout _ panel . controls . add ( this . plugin _ label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . plugin _ options _ text _ box , 1 , NUM ) ; this . table _ layout _ panel . location = new system . drawing . point ( NUM , NUM ) ; this . table _ layout _ panel . margin = new system . windows . forms . padding ( 0 ) ; this . table _ layout _ panel . name = STR ; this . table _ layout _ panel . padding = new system . windows . forms . padding ( NUM ) ;
private bool by _ hour _ of _ day = false ; private int choice _ kept _ minutes = NUM ; private int data _ collection _ minutes = NUM ; private int repeat _ times _ num = NUM ; private const string config _ file = STR ; public static statistics _ strategy _ configuration load ( ) { try { var content = file . read _ all _ text ( config _ file ) ;
private int repeat _ times _ num = NUM ; private const string config _ file = STR ; public static statistics _ strategy _ configuration load ( ) { try { var content = file . read _ all _ text ( config _ file ) ; var configuration = simple _ json . simple _ json . deserialize _ object < statistics _ strategy _ configuration > ( content ) ; return configuration ; }
private void initialize _ component ( ) { this . components = new system . component _ model . container ( ) ; system . windows . forms . data _ visualization . charting . chart _ area chart _ area = new system . windows . forms . data _ visualization . charting . chart _ area ( ) ; system . windows . forms . data _ visualization . charting . legend legend = new system . windows . forms . data _ visualization . charting . legend ( ) ; system . windows . forms . data _ visualization . charting . series series = new system . windows . forms . data _ visualization . charting . series ( ) ; system . windows . forms . data _ visualization . charting . series series = new system . windows . forms . data _ visualization . charting . series ( ) ; system . windows . forms . data _ visualization . charting . series series = new system . windows . forms . data _ visualization . charting . series ( ) ; this . statistics _ chart = new system . windows . forms . data _ visualization . charting . chart ( ) ; this . ping _ check _ box = new system . windows . forms . check _ box ( ) ;
system . windows . forms . data _ visualization . charting . series series = new system . windows . forms . data _ visualization . charting . series ( ) ; this . statistics _ chart = new system . windows . forms . data _ visualization . charting . chart ( ) ; this . ping _ check _ box = new system . windows . forms . check _ box ( ) ; this . binding _ configuration = new system . windows . forms . binding _ source ( this . components ) ; this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ; this . chart _ mode _ selector = new system . windows . forms . group _ box ( ) ; this . all _ mode = new system . windows . forms . radio _ button ( ) ; this . day _ mode = new system . windows . forms . radio _ button ( ) ; this . split _ container = new system . windows . forms . split _ container ( ) ; this . split _ container = new system . windows . forms . split _ container ( ) ;
this . day _ mode = new system . windows . forms . radio _ button ( ) ; this . split _ container = new system . windows . forms . split _ container ( ) ; this . split _ container = new system . windows . forms . split _ container ( ) ; this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ; this . data _ collection _ minutes _ num = new system . windows . forms . numeric _ up _ down ( ) ; this . statistics _ enabled _ check _ box = new system . windows . forms . check _ box ( ) ; this . choice _ kept _ minutes _ num = new system . windows . forms . numeric _ up _ down ( ) ; this . by _ hour _ of _ day _ check _ box = new system . windows . forms . check _ box ( ) ; this . repeat _ times _ num = new system . windows . forms . numeric _ up _ down ( ) ;
this . split _ container = new system . windows . forms . split _ container ( ) ; this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ; this . data _ collection _ minutes _ num = new system . windows . forms . numeric _ up _ down ( ) ; this . statistics _ enabled _ check _ box = new system . windows . forms . check _ box ( ) ; this . choice _ kept _ minutes _ num = new system . windows . forms . numeric _ up _ down ( ) ; this . by _ hour _ of _ day _ check _ box = new system . windows . forms . check _ box ( ) ; this . repeat _ times _ num = new system . windows . forms . numeric _ up _ down ( ) ; this . label = new system . windows . forms . label ( ) ; this . split _ container = new system . windows . forms . split _ container ( ) ;
this . label = new system . windows . forms . label ( ) ; this . split _ container = new system . windows . forms . split _ container ( ) ; this . label = new system . windows . forms . label ( ) ; this . calculation _ container = new system . windows . forms . flow _ layout _ panel ( ) ; this . server _ selector = new system . windows . forms . combo _ box ( ) ; this . cancel _ button = new system . windows . forms . button ( ) ; this . ok _ button = new system . windows . forms . button ( ) ; this . calculatin _ tip = new system . windows . forms . tool _ tip ( this . components ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . statistics _ chart ) ) . begin _ init ( ) ;
this . split _ container . size = new system . drawing . size ( NUM , NUM ) ; this . split _ container . splitter _ distance = NUM ; this . split _ container . splitter _ width = NUM ; this . split _ container . tab _ index = NUM ; this . split _ container . dock = system . windows . forms . dock _ style . fill ; this . split _ container . fixed _ panel = system . windows . forms . fixed _ panel . panel ; this . split _ container . is _ splitter _ fixed = true ; this . split _ container . location = new system . drawing . point ( 0 , 0 ) ; this . split _ container . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . split _ container . name = STR ;
this . split _ container . location = new system . drawing . point ( 0 , 0 ) ; this . split _ container . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . split _ container . name = STR ; this . split _ container . panel . controls . add ( this . label ) ; this . split _ container . panel . controls . add ( this . label ) ; this . split _ container . panel . controls . add ( this . data _ collection _ minutes _ num ) ; this . split _ container . panel . controls . add ( this . statistics _ enabled _ check _ box ) ; this . split _ container . panel . controls . add ( this . choice _ kept _ minutes _ num ) ; this . split _ container . panel . controls . add ( this . by _ hour _ of _ day _ check _ box ) ; this . split _ container . panel . controls . add ( this . repeat _ times _ num ) ;
this . split _ container . panel . controls . add ( this . label ) ; this . split _ container . panel . controls . add ( this . label ) ; this . split _ container . panel . controls . add ( this . data _ collection _ minutes _ num ) ; this . split _ container . panel . controls . add ( this . statistics _ enabled _ check _ box ) ; this . split _ container . panel . controls . add ( this . choice _ kept _ minutes _ num ) ; this . split _ container . panel . controls . add ( this . by _ hour _ of _ day _ check _ box ) ; this . split _ container . panel . controls . add ( this . repeat _ times _ num ) ; this . split _ container . panel . controls . add ( this . label ) ; this . split _ container . panel . controls . add ( this . label ) ; this . split _ container . panel . controls . add ( this . ping _ check _ box ) ;
0 , 0 } ) ; this . label . auto _ size = true ; this . split _ container . dock = system . windows . forms . dock _ style . fill ; this . split _ container . fixed _ panel = system . windows . forms . fixed _ panel . panel ; this . split _ container . is _ splitter _ fixed = true ; this . split _ container . location = new system . drawing . point ( 0 , 0 ) ; this . split _ container . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . split _ container . name = STR ; this . split _ container . orientation = system . windows . forms . orientation . horizontal ;
this . split _ container . location = new system . drawing . point ( 0 , 0 ) ; this . split _ container . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . split _ container . name = STR ; this . split _ container . orientation = system . windows . forms . orientation . horizontal ; this . split _ container . panel . controls . add ( this . label ) ; this . split _ container . panel . controls . add ( this . calculation _ container ) ; this . split _ container . size = new system . drawing . size ( NUM , NUM ) ; this . split _ container . splitter _ distance = NUM ; this . split _ container . splitter _ width = 1 ; this . split _ container . tab _ index = NUM ;
this . auto _ scale _ mode = system . windows . forms . auto _ scale _ mode . font ; this . auto _ size = true ; this . client _ size = new system . drawing . size ( NUM , NUM ) ; this . controls . add ( this . split _ container ) ; this . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . minimum _ size = new system . drawing . size ( NUM , NUM ) ; this . name = STR ; this . text = STR ; ( ( system . component _ model . i _ support _ initialize ) ( this . statistics _ chart ) ) . end _ init ( ) ;
this . split _ container . panel . resume _ layout ( false ) ; this . split _ container . panel . perform _ layout ( ) ; this . split _ container . panel . resume _ layout ( false ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . end _ init ( ) ; this . split _ container . resume _ layout ( false ) ; this . resume _ layout ( false ) ; } private system . windows . forms . data _ visualization . charting . chart statistics _ chart ; private system . windows . forms . check _ box ping _ check _ box ;
this . resume _ layout ( false ) ; } private system . windows . forms . data _ visualization . charting . chart statistics _ chart ; private system . windows . forms . check _ box ping _ check _ box ; private system . windows . forms . label label ; private system . windows . forms . label label ; private system . windows . forms . group _ box chart _ mode _ selector ; private system . windows . forms . radio _ button all _ mode ; private system . windows . forms . radio _ button day _ mode ; private system . windows . forms . split _ container split _ container ;
private system . windows . forms . label label ; private system . windows . forms . group _ box chart _ mode _ selector ; private system . windows . forms . radio _ button all _ mode ; private system . windows . forms . radio _ button day _ mode ; private system . windows . forms . split _ container split _ container ; private system . windows . forms . label label ; private system . windows . forms . split _ container split _ container ; private system . windows . forms . flow _ layout _ panel calculation _ container ; private system . windows . forms . split _ container split _ container ; private system . windows . forms . numeric _ up _ down repeat _ times _ num ;
private system . windows . forms . split _ container split _ container ; private system . windows . forms . label label ; private system . windows . forms . split _ container split _ container ; private system . windows . forms . flow _ layout _ panel calculation _ container ; private system . windows . forms . split _ container split _ container ; private system . windows . forms . numeric _ up _ down repeat _ times _ num ; private system . windows . forms . label label ; private system . windows . forms . check _ box by _ hour _ of _ day _ check _ box ; private system . windows . forms . numeric _ up _ down choice _ kept _ minutes _ num ; private system . windows . forms . check _ box statistics _ enabled _ check _ box ;
this . edit _ gfw _ user _ rule _ item = create _ menu _ item ( STR , new event _ handler ( this . edit _ user _ rule _ file _ for _ gfw _ list _ item _ click ) ) , this . secure _ local _ pac _ url _ toggle _ item = create _ menu _ item ( STR , new event _ handler ( this . secure _ local _ pac _ url _ toggle _ item _ click ) ) , create _ menu _ item ( STR , new event _ handler ( this . copy _ local _ pac _ url _ item _ click ) ) , this . edit _ online _ pac _ item = create _ menu _ item ( STR , new event _ handler ( this . update _ online _ pacurl _ item _ click ) ) , } ) , this . proxy _ item = create _ menu _ item ( STR , new event _ handler ( this . proxy _ item _ click ) ) , new menu _ item ( STR ) , this . auto _ startup _ item = create _ menu _ item ( STR , new event _ handler ( this . auto _ startup _ item _ click ) ) , this . share _ over _ lan _ item = create _ menu _ item ( STR , new event _ handler ( this . share _ over _ lan _ item _ click ) ) , new menu _ item ( STR ) ,
create _ menu _ item ( STR , new event _ handler ( this . copy _ local _ pac _ url _ item _ click ) ) , this . edit _ online _ pac _ item = create _ menu _ item ( STR , new event _ handler ( this . update _ online _ pacurl _ item _ click ) ) , } ) , this . proxy _ item = create _ menu _ item ( STR , new event _ handler ( this . proxy _ item _ click ) ) , new menu _ item ( STR ) , this . auto _ startup _ item = create _ menu _ item ( STR , new event _ handler ( this . auto _ startup _ item _ click ) ) , this . share _ over _ lan _ item = create _ menu _ item ( STR , new event _ handler ( this . share _ over _ lan _ item _ click ) ) , new menu _ item ( STR ) , create _ menu _ item ( STR , new event _ handler ( this . show _ log _ item _ click ) ) , this . verbose _ logging _ toggle _ item = create _ menu _ item ( STR , new event _ handler ( this . verbose _ logging _ toggle _ item _ click ) ) , this . hot _ key _ item = create _ menu _ item ( STR , new event _ handler ( this . hot _ key _ item _ click ) ) ,
this . verbose _ logging _ toggle _ item = create _ menu _ item ( STR , new event _ handler ( this . verbose _ logging _ toggle _ item _ click ) ) , this . hot _ key _ item = create _ menu _ item ( STR , new event _ handler ( this . hot _ key _ item _ click ) ) , create _ menu _ group ( STR , new menu _ item [ ] { create _ menu _ item ( STR , new event _ handler ( this . check _ updates _ item _ click ) ) , new menu _ item ( STR ) , this . auto _ check _ updates _ toggle _ item = create _ menu _ item ( STR , new event _ handler ( this . auto _ check _ updates _ toggle _ item _ click ) ) , this . check _ pre _ release _ toggle _ item = create _ menu _ item ( STR , new event _ handler ( this . check _ pre _ release _ toggle _ item _ click ) ) , } ) ,
using system _ collections _ concurrent ; using system _ collections _ generic ; using system _ io ; using system _ net ; using system _ net _ sockets ; using system _ text ; using system _ threading ; using system _ web ; using system _ windows _ forms ;
using system _ net ; using system _ net _ sockets ; using system _ text ; using system _ threading ; using system _ web ; using system _ windows _ forms ; using newtonsoft _ json ; using shadowsocks _ controller _ strategy ; using shadowsocks _ model ;
using system _ net _ sockets ; using system _ text ; using system _ threading ; using system _ web ; using system _ windows _ forms ; using newtonsoft _ json ; using shadowsocks _ controller _ strategy ; using shadowsocks _ model ; using shadowsocks _ properties ; using shadowsocks _ util ;
catch ( exception e ) { logging . log _ useful _ exception ( e ) ; return false ; } } public void toggle _ enable ( bool enabled ) { config . enabled = enabled ; save _ config ( config ) ;
public void toggle _ enable ( bool enabled ) { config . enabled = enabled ; save _ config ( config ) ; if ( enable _ status _ changed ! = null ) { enable _ status _ changed ( this , new event _ args ( ) ) ; } } public void toggle _ global ( bool global ) { config . global = global ; save _ config ( config ) ;
public void toggle _ global ( bool global ) { config . global = global ; save _ config ( config ) ; if ( enable _ global _ changed ! = null ) { enable _ global _ changed ( this , new event _ args ( ) ) ; } } public void toggle _ share _ over _ lan ( bool enabled ) { config . share _ over _ lan = enabled ; save _ config ( config ) ;
{ foreach ( var server _ and _ plugin in plugins _ by _ server ) { server _ and _ plugin . value ? . dispose ( ) ; } plugins _ by _ server . clear ( ) ; } public void touch _ pac _ file ( ) { string pac _ filename = pac _ server . touch _ pac _ file ( ) ;
plugins _ by _ server . clear ( ) ; } public void touch _ pac _ file ( ) { string pac _ filename = pac _ server . touch _ pac _ file ( ) ; if ( pac _ file _ ready _ to _ open ! = null ) { pac _ file _ ready _ to _ open ( this , new path _ event _ args ( ) { path = pac _ filename } ) ; } } public void touch _ user _ rule _ file ( ) { string user _ rule _ filename = pac _ server . touch _ user _ rule _ file ( ) ;
} public void update _ pac _ from _ gfw _ list ( ) { if ( gfw _ list _ updater ! = null ) { gfw _ list _ updater . update _ pac _ from _ gfw _ list ( config ) ; } } public void update _ statistics _ configuration ( bool enabled ) {
if ( availability _ statistics = = null ) return ; availability _ statistics . update _ configuration ( this ) ; config . availability _ statistics = enabled ; save _ config ( config ) ; } public void save _ pac _ url ( string pac _ url ) { config . pac _ url = pac _ url ; save _ config ( config ) ;
public void save _ pac _ url ( string pac _ url ) { config . pac _ url = pac _ url ; save _ config ( config ) ; if ( config _ changed ! = null ) { config _ changed ( this , new event _ args ( ) ) ; } } public void use _ online _ pac ( bool use _ online _ pac ) { config . use _ online _ pac = use _ online _ pac ; save _ config ( config ) ;
public void use _ online _ pac ( bool use _ online _ pac ) { config . use _ online _ pac = use _ online _ pac ; save _ config ( config ) ; if ( config _ changed ! = null ) { config _ changed ( this , new event _ args ( ) ) ; } } public void toggle _ secure _ local _ pac ( bool enabled ) { config . secure _ local _ pac = enabled ; save _ config ( config ) ;
public void toggle _ secure _ local _ pac ( bool enabled ) { config . secure _ local _ pac = enabled ; save _ config ( config ) ; if ( config _ changed ! = null ) { config _ changed ( this , new event _ args ( ) ) ; } } public void toggle _ checking _ update ( bool enabled ) { config . auto _ check _ update = enabled ; configuration . save ( config ) ;
public void toggle _ checking _ update ( bool enabled ) { config . auto _ check _ update = enabled ; configuration . save ( config ) ; if ( config _ changed ! = null ) { config _ changed ( this , new event _ args ( ) ) ; } } public void toggle _ checking _ pre _ release ( bool enabled ) { config . check _ pre _ release = enabled ; configuration . save ( config ) ;
{ config . check _ pre _ release = enabled ; configuration . save ( config ) ; if ( config _ changed ! = null ) { config _ changed ( this , new event _ args ( ) ) ; } } public void save _ log _ viewer _ config ( log _ viewer _ config new _ config ) { config . log _ viewer = new _ config ; new _ config . save _ size ( ) ; configuration . save ( config ) ;
{ config . log _ viewer = new _ config ; new _ config . save _ size ( ) ; configuration . save ( config ) ; if ( config _ changed ! = null ) { config _ changed ( this , new event _ args ( ) ) ; } } public void save _ hotkey _ config ( hotkey _ config new _ config ) { config . hotkey = new _ config ; save _ config ( config ) ;
{ var strategy = get _ current _ strategy ( ) ; if ( strategy ! = null ) { strategy . reload _ servers ( ) ; } start _ plugin ( ) ; privoxy _ runner . start ( config ) ; tcp _ relay tcp _ relay = new tcp _ relay ( this , config ) ; udp _ relay udp _ relay = new udp _ relay ( this ) ;
privoxy _ runner . start ( config ) ; tcp _ relay tcp _ relay = new tcp _ relay ( this , config ) ; udp _ relay udp _ relay = new udp _ relay ( this ) ; list < listener . i _ service > services = new list < listener . i _ service > ( ) ; services . add ( tcp _ relay ) ; services . add ( udp _ relay ) ; services . add ( pac _ server ) ; services . add ( new port _ forwarder ( privoxy _ runner . running _ port ) ) ; listener = new listener ( services ) ; listener . start ( config ) ; } catch ( exception e ) {
thread . sleep ( NUM * NUM ) ; } } private void start _ traffic _ statistics ( int queue _ max _ size ) { traffic _ per _ second _ queue = new queue < traffic _ per _ second > ( ) ; for ( int i = 0 ; i < queue _ max _ size ; i + + ) { traffic _ per _ second _ queue . enqueue ( new traffic _ per _ second ( ) ) ; }
traffic _ thread = new thread ( new thread _ start ( ( ) = > traffic _ statistics ( queue _ max _ size ) ) ) ; traffic _ thread . is _ background = true ; traffic _ thread . start ( ) ; } private void traffic _ statistics ( int queue _ max _ size ) { traffic _ per _ second previous , current ; while ( true ) { previous = traffic _ per _ second _ queue . last ( ) ;
{ throw new argument _ exception ( STR , nameof ( delimiter ) ) ; } if ( max _ line _ bytes < delimiter _ bytes . length ) { throw new argument _ exception ( STR , nameof ( max _ line _ bytes ) ) ; } delimiter _ search _ char _ table = make _ char _ table ( delimiter _ bytes ) ; delimiter _ search _ offset _ table = make _ offset _ table ( delimiter _ bytes ) ; line _ buffer = new byte [ max _ line _ bytes ] ;
{ } private void receive _ callback ( i _ async _ result ar ) { try { var bytes _ read = socket . end _ receive ( ar ) ; if ( bytes _ read = = 0 ) {
{ try { var bytes _ read = socket . end _ receive ( ar ) ; if ( bytes _ read = = 0 ) { on _ finish ( ) ; return ; }
{ on _ finish ( ) ; return ; } buffer _ data _ length + = bytes _ read ; new _ package _ recv ( ) ; } catch ( exception ex ) { on _ exception ( ex ) ;
on _ exception ( ex ) ; { buffer . block _ copy ( line _ buffer , buffer _ data _ index , line _ buffer , 0 , buffer _ data _ length ) ; buffer _ data _ index = 0 ; } socket . begin _ receive ( line _ buffer , buffer _ data _ length , line _ buffer . length - buffer _ data _ length , 0 , receive _ callback , buffer _ data _ length ) ; } private void on _ exception ( exception ex ) { on _ exception ? . invoke ( ex , state ) ; }
socket . begin _ receive ( line _ buffer , buffer _ data _ length , line _ buffer . length - buffer _ data _ length , 0 , receive _ callback , buffer _ data _ length ) ; } private void on _ exception ( exception ex ) { on _ exception ? . invoke ( ex , state ) ; } private void on _ finish ( ) { on _ finish ? . invoke ( line _ buffer , buffer _ data _ index , buffer _ data _ length , state ) ; }
{ if ( service . handle ( state . buffer , bytes _ read , udp _ socket , state ) ) { break ; } } } catch ( object _ disposed _ exception ) { }
handler . receive ( ) ; return true ; } public class udp _ handler { private socket local ; private socket remote ; private server server ; private byte [ ] buffer = new byte [ NUM ] ; private ip _ end _ point local _ end _ point ;
private socket remote ; private server server ; private byte [ ] buffer = new byte [ NUM ] ; private ip _ end _ point local _ end _ point ; private end _ point remote _ end _ point ; public udp _ handler ( socket local , server server , ip _ end _ point local _ end _ point ) { local = local ; server = server ; local _ end _ point = local _ end _ point ;
bitmap icon _ copy = new bitmap ( origin _ icon ) ; for ( int x = 0 ; x < icon _ copy . width ; x + + ) { for ( int y = 0 ; y < icon _ copy . height ; y + + ) { color color = origin _ icon . get _ pixel ( x , y ) ; if ( color . a ! = 0 & & color . r > NUM ) { if ( ! enabled ) {
{ color color = origin _ icon . get _ pixel ( x , y ) ; if ( color . a ! = 0 & & color . r > NUM ) { if ( ! enabled ) { icon _ copy . set _ pixel ( x , y , color . from _ argb ( color . a , NUM , NUM , NUM ) ) ; } else if ( global ) {
if ( ! enabled ) { icon _ copy . set _ pixel ( x , y , color . from _ argb ( color . a , NUM , NUM , NUM ) ) ; } else if ( global ) { icon _ copy . set _ pixel ( x , y , color . from _ argb ( color . a , NUM , NUM , NUM ) ) ; } else {
if ( country = = null | | city = = null | | isp = = null ) return null ; return new data _ list { new data _ unit ( state . geolocation , $ STR ) , new data _ unit ( state . isp , $ STR ) } ; } private async task < list < data _ list > > icmp _ test ( server server ) { logging . debug ( STR + server . friendly _ name ( ) ) ; if ( server . server = = STR ) return null ;
new data _ unit ( state . geolocation , $ STR ) , new data _ unit ( state . isp , $ STR ) } ; } private async task < list < data _ list > > icmp _ test ( server server ) { logging . debug ( STR + server . friendly _ name ( ) ) ; if ( server . server = = STR ) return null ; var ip = dns . get _ host _ addresses ( server . server ) . first ( ip = > ( ip . address _ family = = address _ family . inter _ network | | ip . address _ family = = address _ family . inter _ network ) ) ; var ping = new ping ( ) ; var ret = new list < data _ list > ( ) ;
try { var reply = await ping . send _ task _ async ( ip , timeout ) ; ret . add ( new list < key _ value _ pair < string , string > > { new key _ value _ pair < string , string > ( STR , timestamp ) , new key _ value _ pair < string , string > ( STR , server . friendly _ name ( ) ) , new key _ value _ pair < string , string > ( STR , reply ? . status . to _ string ( ) ) , new key _ value _ pair < string , string > ( STR , reply ? . roundtrip _ time . to _ string ( ) ) } ) ;
{ var r = new fake _ async _ result ( state ) ; callback ? . invoke ( r ) ; } public void end _ connect _ proxy ( i _ async _ result async _ result ) { } public void begin _ connect _ dest ( end _ point dest _ end _ point , async _ callback callback , object state ) { dest _ end _ point = dest _ end _ point ;
public void end _ connect _ proxy ( i _ async _ result async _ result ) { } public void begin _ connect _ dest ( end _ point dest _ end _ point , async _ callback callback , object state ) { dest _ end _ point = dest _ end _ point ; socket _ util . begin _ connect _ tcp ( dest _ end _ point , callback , state ) ; } public void end _ connect _ dest ( i _ async _ result async _ result ) {
using system ;
using system ; using system _ collections _ generic ; using system _ linq ; using system _ net ; using system _ net _ sockets ; using system _ text ; using system _ threading ; using shadowsocks _ controller ;
public int end _ receive ( i _ async _ result async _ result ) { return remote . end _ receive ( async _ result ) ; } public void shutdown ( socket _ shutdown how ) { remote ? . shutdown ( how ) ; } public void close ( ) {
} public void close ( ) { remote ? . close ( ) ; } private void connect _ callback ( i _ async _ result ar ) { var state = ( socks _ state ) ar . async _ state ; try {
} private void about _ tool _ strip _ menu _ item _ click ( object sender , event _ args e ) { process . start ( STR ) ; } private void notify _ icon _ double _ click ( object sender , event _ args e ) { show _ window ( ) ; }
private void about _ tool _ strip _ menu _ item _ click ( object sender , event _ args e ) { process . start ( STR ) ; } private void notify _ icon _ double _ click ( object sender , event _ args e ) { show _ window ( ) ; } private void enable _ item _ click ( object sender , event _ args e ) {
get { return resource _ manager . get _ string ( STR , resource _ culture ) ; } } internal static byte [ ] polipo _ exe { get { object obj = resource _ manager . get _ object ( STR , resource _ culture ) ; return ( ( byte [ ] ) ( obj ) ) ; } }
} } internal static byte [ ] polipo _ exe { get { object obj = resource _ manager . get _ object ( STR , resource _ culture ) ; return ( ( byte [ ] ) ( obj ) ) ; } } internal static string proxy _ pac { get {
private void receive _ callback ( i _ async _ result ar ) { socket conn = ( socket ) ar . async _ state ; try { int bytes _ read = conn . end _ receive ( ar ) ;
this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ; this . combo _ box = new system . windows . forms . combo _ box ( ) ; this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ; this . text _ box = new system . windows . forms . text _ box ( ) ; this . text _ box = new system . windows . forms . text _ box ( ) ; this . text _ box = new system . windows . forms . text _ box ( ) ; this . text _ box = new system . windows . forms . text _ box ( ) ; this . notify _ icon = new system . windows . forms . notify _ icon ( this . components ) ;
this . text _ box = new system . windows . forms . text _ box ( ) ; this . text _ box = new system . windows . forms . text _ box ( ) ; this . text _ box = new system . windows . forms . text _ box ( ) ; this . text _ box = new system . windows . forms . text _ box ( ) ; this . notify _ icon = new system . windows . forms . notify _ icon ( this . components ) ; this . context _ menu _ strip = new system . windows . forms . context _ menu _ strip ( this . components ) ; this . config _ item = new system . windows . forms . tool _ strip _ menu _ item ( ) ; this . about _ tool _ strip _ menu _ item = new system . windows . forms . tool _ strip _ menu _ item ( ) ; this . tool _ strip _ separator = new system . windows . forms . tool _ strip _ separator ( ) ; this . quit _ item = new system . windows . forms . tool _ strip _ menu _ item ( ) ; this . panel = new system . windows . forms . panel ( ) ; this . button = new system . windows . forms . button ( ) ; this . button = new system . windows . forms . button ( ) ; this . panel = new system . windows . forms . panel ( ) ;
this . text _ box = new system . windows . forms . text _ box ( ) ; this . notify _ icon = new system . windows . forms . notify _ icon ( this . components ) ; this . about _ tool _ strip _ menu _ item = new system . windows . forms . tool _ strip _ menu _ item ( ) ; this . tool _ strip _ separator = new system . windows . forms . tool _ strip _ separator ( ) ; this . quit _ item = new system . windows . forms . tool _ strip _ menu _ item ( ) ; this . panel = new system . windows . forms . panel ( ) ; this . button = new system . windows . forms . button ( ) ; this . button = new system . windows . forms . button ( ) ; this . panel = new system . windows . forms . panel ( ) ; this . enable _ item = new system . windows . forms . tool _ strip _ menu _ item ( ) ; this . table _ layout _ panel . suspend _ layout ( ) ;
this . text _ box . name = STR ; this . text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . text _ box . tab _ index = NUM ; this . text _ box . word _ wrap = false ; this . text _ box . anchor = system . windows . forms . anchor _ styles . left ; this . text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . text _ box . name = STR ; this . text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . text _ box . tab _ index = NUM ; this . text _ box . word _ wrap = false ;
this . text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . text _ box . name = STR ; this . text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . text _ box . tab _ index = NUM ; this . text _ box . word _ wrap = false ; this . notify _ icon . context _ menu _ strip = this . context _ menu _ strip ; this . notify _ icon . icon = ( ( system . drawing . icon ) ( resources . get _ object ( STR ) ) ) ; this . notify _ icon . text = STR ; this . notify _ icon . visible = true ; this . notify _ icon . double _ click + = new system . event _ handler ( this . notify _ icon _ double _ click ) ;
private system . windows . forms . table _ layout _ panel table _ layout _ panel ; private system . windows . forms . label label ; private system . windows . forms . label label ; private system . windows . forms . label label ; private system . windows . forms . label label ; private system . windows . forms . text _ box text _ box ; private system . windows . forms . text _ box text _ box ; private system . windows . forms . text _ box text _ box ; private system . windows . forms . text _ box text _ box ; private system . windows . forms . notify _ icon notify _ icon ;
private system . windows . forms . text _ box text _ box ; private system . windows . forms . text _ box text _ box ; private system . windows . forms . notify _ icon notify _ icon ; private system . windows . forms . tool _ strip _ menu _ item config _ item ; private system . windows . forms . tool _ strip _ menu _ item quit _ item ; private system . windows . forms . tool _ strip _ menu _ item about _ tool _ strip _ menu _ item ; private system . windows . forms . tool _ strip _ separator tool _ strip _ separator ; private system . windows . forms . label label ; private system . windows . forms . combo _ box combo _ box ; private system . windows . forms . panel panel ; private system . windows . forms . button button ; private system . windows . forms . button button ; private system . windows . forms . panel panel ;
this . panel = new system . windows . forms . panel ( ) ; this . button = new system . windows . forms . button ( ) ; this . button = new system . windows . forms . button ( ) ; this . panel = new system . windows . forms . panel ( ) ; this . context _ menu = new system . windows . forms . context _ menu ( ) ; this . enable _ item = new system . windows . forms . menu _ item ( ) ; this . about _ item = new system . windows . forms . menu _ item ( ) ; this . menu _ item = new system . windows . forms . menu _ item ( ) ; this . quit _ item = new system . windows . forms . menu _ item ( ) ;
this . table _ layout _ panel . controls . add ( this . label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , 0 ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , 1 ) ; this . table _ layout _ panel . controls . add ( this . combo _ box , 1 , NUM ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , 2 ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . text _ box , 1 , 0 ) ; this . table _ layout _ panel . controls . add ( this . text _ box , 1 , 1 ) ; this . table _ layout _ panel . controls . add ( this . text _ box , 1 , 2 ) ; this . table _ layout _ panel . controls . add ( this . text _ box , 1 , NUM ) ;
this . about _ item . index = 2 ; this . about _ item . text = STR ; this . about _ item . click + = new system . event _ handler ( this . about _ tool _ strip _ menu _ item _ click ) ; this . menu _ item . index = NUM ; this . menu _ item . text = STR ; this . quit _ item . index = NUM ; this . quit _ item . text = STR ; this . quit _ item . click + = new system . event _ handler ( this . quit _ click ) ;

} } private void pac _ url _ form _ form _ closed ( object sender , form _ closed _ event _ args e ) { pac _ url _ form = null ; util . utils . release _ memory ( ) ; show _ first _ time _ balloon ( ) ; } private void update _ online _ pacurl _ item _ click ( object sender , event _ args e ) {
if ( file . exists ( pac _ server . pac _ file ) ) { string original = file _ manager . non _ exclusive _ read _ all _ text ( pac _ server . pac _ file , encoding . ut ) ; if ( original = = abp _ content ) { update _ completed ( this , new result _ event _ args ( false ) ) ; return ; } } file . write _ all _ text ( pac _ server . pac _ file , abp _ content , encoding . ut ) ;
{ update _ completed ( this , new result _ event _ args ( false ) ) ; return ; } } file . write _ all _ text ( pac _ server . pac _ file , abp _ content , encoding . ut ) ; if ( update _ completed ! = null ) { update _ completed ( this , new result _ event _ args ( true ) ) ; } } catch ( exception ex ) {

using shadowsocks _ properties ; using system ; using system _ collections _ generic ;
using system _ text _ regular _ expressions ; namespace shadowsocks _ controller { public class n { protected static dictionary < string , string > strings ; static n ( ) { strings = new dictionary < string , string > ( ) ;
{ public class n { protected static dictionary < string , string > strings ; static n ( ) { strings = new dictionary < string , string > ( ) ; if ( system . globalization . culture _ info . current _ culture . ietf _ language _ tag . to _ lower _ invariant ( ) . starts _ with ( STR ) ) {
public class n { protected static dictionary < string , string > strings ; static n ( ) { strings = new dictionary < string , string > ( ) ; if ( system . globalization . culture _ info . current _ culture . ietf _ language _ tag . to _ lower _ invariant ( ) . starts _ with ( STR ) ) { string [ ] lines = regex . split ( resources . cn , STR ) ; foreach ( string line in lines ) {
static n ( ) { strings = new dictionary < string , string > ( ) ; if ( system . globalization . culture _ info . current _ culture . ietf _ language _ tag . to _ lower _ invariant ( ) . starts _ with ( STR ) ) { string [ ] lines = regex . split ( resources . cn , STR ) ; foreach ( string line in lines ) { if ( line . starts _ with ( STR ) ) {
public static bool check ( ) { registry _ key run _ key = null ; try { string path = application . executable _ path ; run _ key = registry . current _ user . open _ sub _ key ( STR , true ) ; string [ ] run _ list = run _ key . get _ value _ names ( ) ; foreach ( string item in run _ list ) {
registry _ key run _ key = null ; try { string path = application . executable _ path ; run _ key = registry . current _ user . open _ sub _ key ( STR , true ) ; string [ ] run _ list = run _ key . get _ value _ names ( ) ; foreach ( string item in run _ list ) { if ( item = = key ) return true ;
string path = application . executable _ path ; run _ key = registry . current _ user . open _ sub _ key ( STR , true ) ; string [ ] run _ list = run _ key . get _ value _ names ( ) ; foreach ( string item in run _ list ) { if ( item = = key ) return true ; else if ( item = = STR ) { string value = convert . to _ string ( run _ key . get _ value ( item ) ) ;
if ( n = = 0 ) { throw new io _ exception ( STR ) ; } return system . text . encoding . ut . get _ string ( buffer , 0 , n ) ; } } } private void receive _ callback ( i _ async _ result ar ) {
} private void receive _ callback ( i _ async _ result ar ) { socket conn = ( socket ) ar . async _ state ; try { int bytes _ read = conn . end _ receive ( ar ) ; string pac = get _ pac _ content ( ) ; ip _ end _ point local _ end _ point = ( ip _ end _ point ) conn . local _ end _ point ;
{ if ( old _ selected _ index = = - 1 | | old _ selected _ index > = modified _ configuration . configs . count ) { return true ; } server server = new server { server = ip _ text _ box . text , server _ port = int . parse ( server _ port _ text _ box . text ) , password = password _ text _ box . text ,
using system _ collections _ generic ; using system _ text ; using system _ net _ sockets ; using system _ net ; using shadowsocks _ encryption ; using shadowsocks _ model ; namespace shadowsocks _ controller { class local {
using shadowsocks _ model ; namespace shadowsocks _ controller { class local { private server server ; private bool share _ over _ lan ; socket listener ; public local ( configuration config ) {
} public void start ( ) { try { listener = new socket ( address _ family . inter _ network , socket _ type . stream , protocol _ type . tcp ) ; listener . set _ socket _ option ( socket _ option _ level . socket , socket _ option _ name . reuse _ address , true ) ; ip _ end _ point local _ end _ point = null ; if ( share _ over _ lan ) {
{ listener = new socket ( address _ family . inter _ network , socket _ type . stream , protocol _ type . tcp ) ; listener . set _ socket _ option ( socket _ option _ level . socket , socket _ option _ name . reuse _ address , true ) ; ip _ end _ point local _ end _ point = null ; if ( share _ over _ lan ) { local _ end _ point = new ip _ end _ point ( ip _ address . any , server . local _ port ) ; } else {
private bool connection _ shutdown = false ; private bool remote _ shutdown = false ; private bool closed = false ; private object encryption _ lock = new object ( ) ; private object decryption _ lock = new object ( ) ; public void start ( ) { try { ip _ address ip _ address ;
private object encryption _ lock = new object ( ) ; private object decryption _ lock = new object ( ) ; public void start ( ) { try { ip _ address ip _ address ; bool parsed = ip _ address . try _ parse ( config . server , out ip _ address ) ; if ( ! parsed ) {
{ try { ip _ address ip _ address ; bool parsed = ip _ address . try _ parse ( config . server , out ip _ address ) ; if ( ! parsed ) { ip _ host _ entry ip _ host _ info = dns . get _ host _ entry ( config . server ) ; ip _ address = ip _ host _ info . address _ list [ 0 ] ; }
using system ;
using system ; using system _ collections ; using system _ collections _ generic ; using system _ globalization ; using system _ io ; using system _ linq ; using system _ net ;
using system _ collections _ generic ; using system _ globalization ; using system _ io ; using system _ linq ; using system _ net ; using system _ net _ http ; using system _ net _ network _ information ; using system _ net _ sockets ; using system _ threading ; using system _ threading _ tasks ;
using system _ threading ; using system _ threading _ tasks ; using newtonsoft _ json ; using newtonsoft _ json _ linq ; using shadowsocks _ model ; using shadowsocks _ util ; namespace shadowsocks _ controller { using data _ unit = key _ value _ pair < string , string > ; using data _ list = list < key _ value _ pair < string , string > > ; using statistics = dictionary < string , list < availability _ statistics . raw _ statistics _ data > > ;
using data _ unit = key _ value _ pair < string , string > ; using data _ list = list < key _ value _ pair < string , string > > ; using statistics = dictionary < string , list < availability _ statistics . raw _ statistics _ data > > ; public class availability _ statistics { public const string date _ time _ pattern = STR ; private const string statistics _ files _ name = STR ; private const string delimiter = STR ;
private state state ; private list < server > servers ; private statistics _ strategy _ configuration config ; private const string empty = STR ; public static string availability _ statistics _ file ; private int inbound _ speed = 0 ; private int outbound _ speed = 0 ; private int? latency = 0 ; private server current _ server ; private configuration global _ config ;
private server current _ server ; private configuration global _ config ; private readonly shadowsocks _ controller controller ; private long last _ inbound _ counter = 0 ; private long last _ outbound _ counter = 0 ; private readonly time _ span monitor _ interval = time _ span . from _ seconds ( 1 ) ; static availability _ statistics ( ) { availability _ statistics _ file = utils . get _ temp _ path ( statistics _ files _ name ) ; }
} } catch ( exception e ) { logging . error ( $ STR ) ; logging . log _ useful _ exception ( e ) ; } return ret ; } private string get _ recent _ outbound _ speed ( server server ) {
logging . log _ useful _ exception ( e ) ; } return ret ; } private string get _ recent _ outbound _ speed ( server server ) { if ( server ! = current _ server ) return empty ; return outbound _ speed . to _ string ( ) ; } private string get _ recent _ inbound _ speed ( server server ) {
{ if ( server ! = current _ server ) return empty ; return inbound _ speed . to _ string ( ) ; } private string get _ recent _ latency ( server server ) { if ( server ! = current _ server ) return empty ; return latency = = null ? empty : latency . to _ string ( ) ; } private void reset _ speed ( ) {
} try { file . append _ all _ lines ( availability _ statistics _ file , lines ) ; } catch ( io _ exception e ) { logging . log _ useful _ exception ( e ) ; } }
catch ( io _ exception e ) { logging . log _ useful _ exception ( e ) ; } } internal void update _ configuration ( configuration config , statistics _ strategy _ configuration statistics _ config ) { set ( statistics _ config ) ; servers = config . configs ; reset _ speed ( ) ;
} public void save _ log _ viewer _ config ( log _ viewer _ config new _ config ) { config . log _ viewer = new _ config ; configuration . save ( config ) ; } public void update _ latency ( server server , time _ span latency ) { if ( config . availability _ statistics ) {
if ( config . availability _ statistics ) { new task ( ( ) = > availability _ statistics . update _ latency ( server , ( int ) latency . total _ milliseconds ) ) . start ( ) ; } } public void update _ inbound _ counter ( server server , long n ) { interlocked . add ( ref inbound _ counter , n ) ; if ( config . availability _ statistics ) {
if ( config . availability _ statistics ) { new task ( ( ) = > availability _ statistics . update _ inbound _ counter ( server , n ) ) . start ( ) ; } } public void update _ outbound _ counter ( server server , long n ) { interlocked . add ( ref outbound _ counter , n ) ; if ( config . availability _ statistics ) {
process . start _ info . use _ shell _ execute = true ; process . start _ info . create _ no _ window = true ; process . start ( ) ; } refresh _ tray _ area ( ) ; } public void stop ( ) { if ( process ! = null ) {
private void update _ speed ( object ) { foreach ( var kv in last _ inbound _ counter ) { var id = kv . key ; var last _ inbound = kv . value ; var inbound = inbound _ counter [ id ] ; var bytes = inbound - last _ inbound ; last _ inbound _ counter [ id ] = inbound ; var inbound _ speed = get _ speed _ in _ ki _ b _ per _ second ( bytes , monitor _ interval . total _ seconds ) ;
var bytes = inbound - last _ inbound ; last _ inbound _ counter [ id ] = inbound ; var inbound _ speed = get _ speed _ in _ ki _ b _ per _ second ( bytes , monitor _ interval . total _ seconds ) ; inbound _ speed _ records . get _ or _ add ( id , new list < int > { inbound _ speed } ) . add ( inbound _ speed ) ; var last _ outbound = last _ outbound _ counter [ id ] ; var outbound = outbound _ counter [ id ] ; bytes = outbound - last _ outbound ; last _ outbound _ counter [ id ] = outbound ; var outbound _ speed = get _ speed _ in _ ki _ b _ per _ second ( bytes , monitor _ interval . total _ seconds ) ;
var last _ outbound = last _ outbound _ counter [ id ] ; var outbound = outbound _ counter [ id ] ; bytes = outbound - last _ outbound ; last _ outbound _ counter [ id ] = outbound ; var outbound _ speed = get _ speed _ in _ ki _ b _ per _ second ( bytes , monitor _ interval . total _ seconds ) ; outbound _ speed _ records . get _ or _ add ( id , new list < int > { outbound _ speed } ) . add ( outbound _ speed ) ; logging . debug ( $ STR ) ; }
} private void reset ( ) { inbound _ speed _ records . clear ( ) ; outbound _ speed _ records . clear ( ) ; latency _ records . clear ( ) ; } private void run ( object ) { update _ records ( ) ;
{ inbound _ speed _ records . clear ( ) ; outbound _ speed _ records . clear ( ) ; latency _ records . clear ( ) ; } private void run ( object ) { update _ records ( ) ; save ( ) ; reset ( ) ;
list < int > outbound _ speed _ records = null ; list < int > latency _ records = null ; inbound _ speed _ records . try _ get _ value ( id , out inbound _ speed _ records ) ; outbound _ speed _ records . try _ get _ value ( id , out outbound _ speed _ records ) ; latency _ records . try _ get _ value ( id , out latency _ records ) ; statistics _ record record = new statistics _ record ( id , inbound _ speed _ records , outbound _ speed _ records , latency _ records ) ; if ( records . contains _ key ( id ) ) records [ id ] = record ; else records . add ( id , record ) ;
records [ result . server . identifier ( ) ] . set _ response ( result . roundtrip _ time ) ; } } foreach ( var kv in records . where ( kv = > ! kv . value . is _ empty _ data ( ) ) ) { append _ record ( kv . key , kv . value ) ; } } private void append _ record ( string server _ identifier , statistics _ record record ) {
} private void save ( ) { if ( raw _ statistics . count = = 0 ) { return ; } try {
{ logging . log _ useful _ exception ( e ) ; console . write _ line ( $ STR ) ; recorder . change ( retry _ interval , recording _ interval ) ; } } private static int get _ speed _ in _ ki _ b _ per _ second ( long bytes , double seconds ) { var result = ( int ) ( bytes / seconds ) / NUM ; return result ;
return result ; server = server ; } } public void dispose ( ) { recorder . dispose ( ) ; speed _ monior . dispose ( ) ; } public void update _ latency ( server server , int latency ) {
latency _ records . try _ get _ value ( server . identifier ( ) , out records ) ; if ( records = = null ) { records = new list < int > ( ) ; } records . add ( latency ) ; latency _ records [ server . identifier ( ) ] = records ; } public void update _ inbound _ counter ( server server , long n ) {
public void update _ inbound _ counter ( server server , long n ) { } else { count = n ; last _ inbound _ counter [ server . identifier ( ) ] = 0 ; } inbound _ counter [ server . identifier ( ) ] = count ; } public void update _ outbound _ counter ( server server , long n ) {
process old _ process = old _ processes [ 0 ] ; } message _ box . show ( n . get _ string ( STR ) + environment . new _ line + n . get _ string ( STR ) , n . get _ string ( STR ) ) ; return ; } directory . set _ current _ directory ( application . startup _ path ) ;
+ n . get _ string ( STR ) , n . get _ string ( STR ) ) ; return ; } directory . set _ current _ directory ( application . startup _ path ) ; logging . open _ log _ file ( ) ; string privoxy _ log _ filename = utils . get _ temp _ path ( STR ) ; if ( file . exists ( privoxy _ log _ filename ) ) using ( new file _ stream ( privoxy _ log _ filename , file _ mode . truncate ) ) { }
} protected void save _ config ( configuration new _ config ) { configuration . save ( new _ config ) ; reload ( ) ; } private void update _ system _ proxy ( ) { if ( config . enabled ) {
{ if ( config . enabled ) { system _ proxy . update ( config , false ) ; system _ proxy _ is _ dirty = true ; } else { if ( system _ proxy _ is _ dirty ) {
using system _ globalization ; using system _ io ; using system _ net ; using system _ net _ sockets ; using system _ text ; using shadowsocks _ model ; using shadowsocks _ properties ; using shadowsocks _ util ; namespace shadowsocks _ controller {
return pac _ file ; } } public void accept _ callback ( i _ async _ result ar ) { socket listener = ( socket ) ar . async _ state ; try { socket conn = listener . end _ accept ( ar ) ;
public void accept _ callback ( i _ async _ result ar ) { socket listener = ( socket ) ar . async _ state ; try { socket conn = listener . end _ accept ( ar ) ; byte [ ] buf = new byte [ NUM ] ; object [ ] state = new object [ ] { conn ,
{ socket listener = ( socket ) ar . async _ state ; try { socket conn = listener . end _ accept ( ar ) ; byte [ ] buf = new byte [ NUM ] ; object [ ] state = new object [ ] { conn , buf } ;
} private string get _ pac _ content ( ) { if ( file . exists ( pac _ file ) ) { return file . read _ all _ text ( pac _ file , encoding . ut ) ; } else { byte [ ] pac _ gz = resources . proxy _ pac _ txt ;
} else { byte [ ] pac _ gz = resources . proxy _ pac _ txt ; byte [ ] buffer = new byte [ NUM * NUM ] ; int n ; using ( g _ zip _ stream input = new g _ zip _ stream ( new memory _ stream ( pac _ gz ) , compression _ mode . decompress , false ) ) {
{ byte [ ] pac _ gz = resources . proxy _ pac _ txt ; byte [ ] buffer = new byte [ NUM * NUM ] ; int n ; using ( g _ zip _ stream input = new g _ zip _ stream ( new memory _ stream ( pac _ gz ) , compression _ mode . decompress , false ) ) { n = input . read ( buffer , 0 , buffer . length ) ; if ( n = = 0 ) {
byte [ ] buffer = new byte [ NUM * NUM ] ; int n ; using ( g _ zip _ stream input = new g _ zip _ stream ( new memory _ stream ( pac _ gz ) , compression _ mode . decompress , false ) ) { n = input . read ( buffer , 0 , buffer . length ) ; if ( n = = 0 ) { throw new io _ exception ( STR ) ; }
remote . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; } private const string http _ crlf = STR ; private const string http _ connect _ template = STR + http _ crlf + STR + http _ crlf + STR + http _ crlf + STR + http _ crlf + STR + http _ crlf ;
STR + http _ crlf + STR + http _ crlf + STR + http _ crlf + STR + http _ crlf + STR + http _ crlf ; public void begin _ connect _ dest ( end _ point dest _ end _ point , async _ callback callback , object state ) { dest _ end _ point = dest _ end _ point ;
connect _ timer . enabled = true ; connect _ timer . session = session ; connect _ timer . server = server ; dest _ connected = false ; remote . begin _ connect _ dest ( dest _ end _ point , connect _ callback ,
} else { proxy _ server _ text _ box . enabled = proxy _ port _ text _ box . enabled = proxy _ timeout _ text _ box . enabled =
my _ cancel _ button . text = n . get _ string ( STR ) ; this . text = n . get _ string ( STR ) ; } private void controller _ config _ changed ( object sender , event _ args e ) { load _ current _ configuration ( ) ; } private void load _ current _ configuration ( ) { modified _ configuration = controller . get _ configuration _ copy ( ) . proxy ;
this . close ( ) ; } private void cancel _ button _ click ( object sender , event _ args e ) { this . close ( ) ; } private void proxy _ form _ form _ closed ( object sender , form _ closed _ event _ args e ) { controller . config _ changed - = controller _ config _ changed ;
} dll _ import _ kernel _ dll private static extern int _ ptr load _ library ( string path ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int crypto _ stream _ salsa _ xor _ ic ( byte [ ] c , byte [ ] m , ulong mlen , byte [ ] n , ulong ic , byte [ ] k ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int crypto _ stream _ chacha _ xor _ ic ( byte [ ] c , byte [ ] m , ulong mlen , byte [ ] n , ulong ic , byte [ ] k ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int crypto _ stream _ chacha _ ietf _ xor _ ic ( byte [ ] c , byte [ ] m , ulong mlen , byte [ ] n , uint ic , byte [ ] k ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl
gc . suppress _ finalize ( this ) ; } ~ mbed _ tls _ encryptor ( ) { dispose ( false ) ; } protected virtual void dispose ( bool disposing ) { lock ( lock ) {
} protected virtual void dispose ( bool disposing ) { lock ( lock ) { if ( disposed ) { return ; } disposed = true ; } if ( disposing ) {
} } } public void dispose ( ) { dispose ( true ) ; gc . suppress _ finalize ( this ) ; } private void dispose ( bool disposing ) {
{ dispose ( true ) ; gc . suppress _ finalize ( this ) ; } private void dispose ( bool disposing ) { if ( disposed ) return ; if ( disposing ) { } close ( ) ;
gc . suppress _ finalize ( this ) ; } private void dispose ( bool disposing ) { if ( disposed ) return ; if ( disposing ) { } close ( ) ; disposed = true ; }
private void dispose ( bool disposing ) { if ( disposed ) return ; if ( disposing ) { } close ( ) ; disposed = true ; } public void close ( ) {
= > ( average _ response = = null ) & & ( min _ response = = null ) & & ( max _ response = = null ) & & ( package _ loss = = null ) ; public bool is _ empty _ data ( ) { return empty _ inbound _ speed _ data & & empty _ outbound _ speed _ data & & empty _ response _ data & & empty _ latency _ data ; } public statistics _ record ( ) { } public statistics _ record ( string identifier , i _ collection < int > inbound _ speed _ records , i _ collection < int > outbound _ speed _ records , i _ collection < int > latency _ records ) { server _ identifier = identifier ;
} public statistics _ record ( ) { } public statistics _ record ( string identifier , i _ collection < int > inbound _ speed _ records , i _ collection < int > outbound _ speed _ records , i _ collection < int > latency _ records ) { server _ identifier = identifier ; if ( inbound _ speed _ records ! = null & & inbound _ speed _ records . any ( ) ) {
public statistics _ record ( string identifier , i _ collection < int > inbound _ speed _ records , i _ collection < int > outbound _ speed _ records , i _ collection < int > latency _ records ) { server _ identifier = identifier ; if ( inbound _ speed _ records ! = null & & inbound _ speed _ records . any ( ) ) { average _ inbound _ speed = ( int ) inbound _ speed _ records . average ( ) ; min _ inbound _ speed = inbound _ speed _ records . min ( ) ; max _ inbound _ speed = inbound _ speed _ records . max ( ) ; }
if ( inbound _ speed _ records ! = null & & inbound _ speed _ records . any ( ) ) { average _ inbound _ speed = ( int ) inbound _ speed _ records . average ( ) ; min _ inbound _ speed = inbound _ speed _ records . min ( ) ; max _ inbound _ speed = inbound _ speed _ records . max ( ) ; } if ( outbound _ speed _ records ! = null & & outbound _ speed _ records . any ( ) ) {
min _ inbound _ speed = inbound _ speed _ records . min ( ) ; max _ inbound _ speed = inbound _ speed _ records . max ( ) ; } if ( outbound _ speed _ records ! = null & & outbound _ speed _ records . any ( ) ) { average _ outbound _ speed = ( int ) outbound _ speed _ records . average ( ) ; min _ outbound _ speed = outbound _ speed _ records . min ( ) ; max _ outbound _ speed = outbound _ speed _ records . max ( ) ; }
if ( outbound _ speed _ records ! = null & & outbound _ speed _ records . any ( ) ) { average _ outbound _ speed = ( int ) outbound _ speed _ records . average ( ) ; min _ outbound _ speed = outbound _ speed _ records . min ( ) ; max _ outbound _ speed = outbound _ speed _ records . max ( ) ; } if ( latency _ records ! = null & & latency _ records . any ( ) ) {
statistics _ chart . chart _ areas [ STR ] . axis _ x . label _ style . format = STR ; statistics _ chart . chart _ areas [ STR ] . axis . label _ style . format = STR ; } var final _ data = from data _ group in data _ groups orderby data _ group . key select new { data _ group . first ( ) . timestamp , speed = data _ group . max ( data = > data . max _ inbound _ speed ) ? ? 0 , ping = ( int ) ( data _ group . average ( data = > data . average _ response ) ? ? 0 ) ,
} var final _ data = from data _ group in data _ groups orderby data _ group . key select new { data _ group . first ( ) . timestamp , speed = data _ group . max ( data = > data . max _ inbound _ speed ) ? ? 0 , ping = ( int ) ( data _ group . average ( data = > data . average _ response ) ? ? 0 ) , package _ loss _ percentage = ( data _ group . average ( data = > data . package _ loss ) ? ? 0 ) * NUM } ;
using system ; using system _ collections _ generic ; using system _ globalization ; using system _ io ; using system _ linq ; using system _ net ;
using system ; using system _ collections _ generic ; using system _ globalization ; using system _ io ; using system _ linq ; using system _ net ; using system _ text ; using shadowsocks _ model ; using system _ io ; using system _ net _ network _ information ;
using system _ collections _ generic ; using system _ globalization ; using system _ io ; using system _ linq ; using system _ net ; using system _ text ; using shadowsocks _ model ; using system _ io ; using system _ net _ network _ information ; using system _ windows _ forms ; using newtonsoft _ json ; using shadowsocks _ model ;
using system _ linq ; using system _ net ; using system _ text ; using shadowsocks _ model ; using system _ io ; using system _ net _ network _ information ; using system _ windows _ forms ; using newtonsoft _ json ; using shadowsocks _ model ; using timer = system . threading . timer ; namespace shadowsocks _ controller _ strategy {
using shadowsocks _ model ; using timer = system . threading . timer ; namespace shadowsocks _ controller _ strategy { using data _ unit = key _ value _ pair < string , string > ; using data _ list = list < key _ value _ pair < string , string > > ; class statistics _ strategy : i _ strategy { private readonly shadowsocks _ controller controller ; private server current _ server ; private readonly timer timer ;
{ using data _ unit = key _ value _ pair < string , string > ; using data _ list = list < key _ value _ pair < string , string > > ; class statistics _ strategy : i _ strategy { private readonly shadowsocks _ controller controller ; private server current _ server ; private readonly timer timer ; private dictionary < string , list < statistics _ raw _ data > > raw _ statistics ; private int choice _ kept _ milliseconds = > ( int ) time _ span . from _ minutes ( controller . statistics _ configuration . choice _ kept _ minutes ) . total _ milliseconds ;
} private void reload _ statistics _ and _ choose _ a _ server ( object obj ) { logging . debug ( STR ) ; var servers = controller . get _ current _ configuration ( ) . configs ; load _ statistics ( ) ; choose _ new _ server ( servers ) ; } private void load _ statistics ( ) {
{ logging . debug ( STR ) ; var servers = controller . get _ current _ configuration ( ) . configs ; load _ statistics ( ) ; choose _ new _ server ( servers ) ; } private void load _ statistics ( ) { { server _ name = server . key , data = server . to _ list ( ) } ) . to _ dictionary ( server = > server . server _ name , server = > server . data ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; } }
load _ statistics ( ) ; choose _ new _ server ( servers ) ; } private void load _ statistics ( ) { } ) . to _ dictionary ( server = > server . server _ name , server = > server . data ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; } } private float get _ score ( i _ enumerable < statistics _ raw _ data > raw _ data _ list ) { var config = controller . statistics _ configuration ;
{ logging . log _ useful _ exception ( e ) ; } } private float get _ score ( i _ enumerable < statistics _ raw _ data > raw _ data _ list ) { var config = controller . statistics _ configuration ; date _ time _ styles . none , out date _ time ) ; var result = date _ time . hour . equals ( current _ hour ) ; return result ; } ) ; if ( raw _ data _ list . long _ count ( ) = = 0 ) return 0 ; } var data _ list = raw _ data _ list as i _ list < statistics _ raw _ data > ? ? raw _ data _ list . to _ list ( ) ; var server _ name = data _ list [ 0 ] ? . server _ name ; var success _ times = ( float ) data _ list . count ( data = > data . icmp _ status . equals ( ip _ status . success . to _ string ( ) ) ) ; var timed _ out _ times = ( float ) data _ list . count ( data = > data . icmp _ status . equals ( ip _ status . timed _ out . to _ string ( ) ) ) ;
score + = statistics _ data . package _ loss * factor ; if ( ! config . calculations . try _ get _ value ( STR , out factor ) ) factor = 0 ; score + = statistics _ data . average _ response * factor ; if ( ! config . calculations . try _ get _ value ( STR , out factor ) ) factor = 0 ; score + = statistics _ data . min _ response * factor ; if ( ! config . calculations . try _ get _ value ( STR , out factor ) ) factor = 0 ; score + = statistics _ data . max _ response * factor ; logging . debug ( $ STR ) ; return score ; }
if ( ! config . calculations . try _ get _ value ( STR , out factor ) ) factor = 0 ; score + = statistics _ data . min _ response * factor ; if ( ! config . calculations . try _ get _ value ( STR , out factor ) ) factor = 0 ; score + = statistics _ data . max _ response * factor ; logging . debug ( $ STR ) ; return score ; } } public class statistics _ data { public float package _ loss ; public int average _ response ; public int min _ response ; public int max _ response ; } private void choose _ new _ server ( list < server > servers ) {
private void choose _ new _ server ( list < server > servers ) { if ( raw _ statistics = = null | | servers . count = = 0 ) { return ; } try { var best _ result = ( from server in servers let name = server . friendly _ name ( )
return ; } try { var best _ result = ( from server in servers let name = server . friendly _ name ( ) where raw _ statistics . contains _ key ( name ) select new { server ,
using system ; using system _ collections _ generic ; using system _ io ; using system _ linq ; using system _ net ;
using system _ io ; using system _ linq ; using system _ net ; using simple _ json ; using system _ net _ http ; using system _ net _ network _ information ; using system _ net _ sockets ; using system _ threading ; using system _ threading _ tasks ;
using system _ net ; using simple _ json ; using system _ net _ http ; using system _ net _ network _ information ; using system _ net _ sockets ; using system _ threading ; using system _ threading _ tasks ; using system _ windows _ forms ; using shadowsocks _ model ; using shadowsocks _ util ;
using system _ threading ; using system _ threading _ tasks ; using system _ windows _ forms ; using shadowsocks _ model ; using shadowsocks _ util ; using timer = system . threading . timer ; namespace shadowsocks _ controller { using data _ unit = key _ value _ pair < string , string > ; using data _ list = list < key _ value _ pair < string , string > > ;
this . choice _ kept _ minutes _ num = new system . windows . forms . numeric _ up _ down ( ) ; this . by _ hour _ of _ day _ check _ box = new system . windows . forms . check _ box ( ) ; this . repeat _ times _ num = new system . windows . forms . numeric _ up _ down ( ) ; this . label = new system . windows . forms . label ( ) ; this . split _ container = new system . windows . forms . split _ container ( ) ; this . label = new system . windows . forms . label ( ) ; this . calculation _ container = new system . windows . forms . flow _ layout _ panel ( ) ; this . server _ selector = new system . windows . forms . combo _ box ( ) ; this . cancel _ button = new system . windows . forms . button ( ) ; this . ok _ button = new system . windows . forms . button ( ) ;
foreach ( string method in stream _ mbed _ tls _ encryptor . supported _ ciphers ( ) ) { registered _ encryptors . add ( method , typeof ( stream _ mbed _ tls _ encryptor ) ) ; } foreach ( string method in stream _ sodium _ encryptor . supported _ ciphers ( ) ) { registered _ encryptors . add ( method , typeof ( stream _ sodium _ encryptor ) ) ; }
registered _ encryptors . add ( method , typeof ( stream _ mbed _ tls _ encryptor ) ) ; } foreach ( string method in stream _ sodium _ encryptor . supported _ ciphers ( ) ) { registered _ encryptors . add ( method , typeof ( stream _ sodium _ encryptor ) ) ; } foreach ( string method in aead _ mbed _ tls _ encryptor . supported _ ciphers ( ) ) { registered _ encryptors . add ( method , typeof ( aead _ mbed _ tls _ encryptor ) ) ; }
socket _ type . stream , protocol _ type . tcp ) ; remote . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; start _ connect _ time = date _ time . now ; remote . begin _ connect ( remote _ ep ,
new async _ callback ( connect _ callback ) , null ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; this . close ( ) ; } } private void connect _ callback ( i _ async _ result ar ) {
if ( closed ) { return ; } try { remote . end _ connect ( ar ) ; var latency = date _ time . now - start _ connect _ time ;
return ; } try { remote . end _ connect ( ar ) ; var latency = date _ time . now - start _ connect _ time ; controller . get _ current _ strategy ( ) . update _ latency ( this . server , latency ) ; start _ pipe ( ) ; }
{ message _ box . show ( STR ) ; throw ; } } private static void copy _ proxy _ setting _ from _ lan ( ) { registry _ key registry = registry . current _ user . open _ sub _ key ( STR , true ) ;
private static void copy _ proxy _ setting _ from _ lan ( ) { registry _ key registry = registry . current _ user . open _ sub _ key ( STR , true ) ; var defulat _ value = registry . get _ value ( STR ) ; var connections = registry . get _ value _ names ( ) ; foreach ( string each in connections ) { if ( ! ( each . equals ( STR ) | | each . equals ( STR ) | | each . equals ( STR ) ) ) {
| | each . equals ( STR ) ) ) { registry . set _ value ( each , defulat _ value ) ; } }
private void qr _ code _ item _ click ( object sender , event _ args e ) { qr _ code _ form qr _ code _ form = new qr _ code _ form ( controller . get _ qr _ code _ for _ current _ server ( ) ) ; qr _ code _ form . show ( ) ; } private void scan _ qr _ code _ item _ click ( object sender , event _ args e ) { using ( bitmap image = new bitmap ( screen . primary _ screen . bounds . width , screen . primary _ screen . bounds . height ) ) {
private void scan _ qr _ code _ item _ click ( object sender , event _ args e ) { using ( bitmap image = new bitmap ( screen . primary _ screen . bounds . width , screen . primary _ screen . bounds . height ) ) { using ( graphics g = graphics . from _ image ( bmp _ screen _ capture ) ) { g . copy _ from _ screen ( screen . primary _ screen . bounds . x , screen . primary _ screen . bounds . y , 0 , 0 ,
screen . primary _ screen . bounds . height ) ) { using ( graphics g = graphics . from _ image ( bmp _ screen _ capture ) ) { g . copy _ from _ screen ( screen . primary _ screen . bounds . x , screen . primary _ screen . bounds . y , 0 , 0 , bmp _ screen _ capture . size , copy _ pixel _ operation . source _ copy ) ; }
result _ points . clear ( ) ; { possible _ formats = new list < barcode _ format > { barcode _ format . qr _ code } } ; var result = reader . decode ( image ) ;
{ possible _ formats = new list < barcode _ format > { barcode _ format . qr _ code } } ; var result = reader . decode ( image ) ; var result = barcode _ reader . decode ( image ) ; var timer _ start = date _ time . now . ticks ; var timer _ stop = date _ time . now . ticks ; if ( result = = null ) {
possible _ formats = new list < barcode _ format > { barcode _ format . qr _ code } } ; var result = reader . decode ( image ) ; var result = barcode _ reader . decode ( image ) ; var timer _ start = date _ time . now . ticks ; var timer _ stop = date _ time . now . ticks ; if ( result = = null ) { txt _ decoder _ content . text = STR ; }
{ config config = ser . read _ object ( fs ) as config ; return config ; } }
} } catch ( io _ exception ) { return new config { server = STR , server _ port = NUM , local _ port = NUM ,
namespace shadowsocks _ csharp { public partial class form : form { local local ; config config ; public form ( ) { config = config . load ( ) ;
local . start ( ) ; } private void config _ click ( object sender , event _ args e ) { } private void quit _ click ( object sender , event _ args e ) { }
private void config _ click ( object sender , event _ args e ) { } private void quit _ click ( object sender , event _ args e ) { } private void button _ click ( object sender , event _ args e ) {
} private void quit _ click ( object sender , event _ args e ) { } private void button _ click ( object sender , event _ args e ) { reload ( config . load ( ) ) ; }

this . button . click + = new system . event _ handler ( this . button _ click ) ; this . button . dialog _ result = system . windows . forms . dialog _ result . ok ; this . button . location = new system . drawing . point ( NUM , NUM ) ; this . button . name = STR ; this . button . size = new system . drawing . size ( NUM , NUM ) ; this . button . tab _ index = 0 ; this . button . text = STR ; this . button . use _ visual _ style _ back _ color = true ;
this . notify _ icon . text = STR ; this . notify _ icon . visible = true ; this . context _ menu _ strip . items . add _ range ( new system . windows . forms . tool _ strip _ item [ ] { this . config _ item , this . quit _ item } ) ; this . context _ menu _ strip . name = STR ; this . context _ menu _ strip . render _ mode = system . windows . forms . tool _ strip _ render _ mode . system ;
if ( ! file . exists ( n _ file ) ) { n = resources . n _ csv ; file . write _ all _ text ( n _ file , n , encoding . ut ) ; } else { n = file . read _ all _ text ( n _ file , encoding . ut ) ; }
} } class handler { public i _ encryptor encryptor ; public server config ; public socket remote ; public socket connection ; public const int recv _ size = NUM ; public const int buffer _ size = recv _ size + NUM ;
} class handler { public i _ encryptor encryptor ; public server config ; public socket remote ; public socket connection ; public const int recv _ size = NUM ; public const int buffer _ size = recv _ size + NUM ; public byte [ ] remote _ recv _ buffer = new byte [ recv _ size ] ;
class handler { public i _ encryptor encryptor ; public server config ; public socket remote ; public socket connection ; public const int recv _ size = NUM ; public const int buffer _ size = recv _ size + NUM ; public byte [ ] remote _ recv _ buffer = new byte [ recv _ size ] ; public byte [ ] remote _ send _ buffer = new byte [ buffer _ size ] ;
{ public i _ encryptor encryptor ; public server config ; public socket remote ; public socket connection ; public const int recv _ size = NUM ; public const int buffer _ size = recv _ size + NUM ; public byte [ ] remote _ recv _ buffer = new byte [ recv _ size ] ; public byte [ ] remote _ send _ buffer = new byte [ buffer _ size ] ; public byte [ ] connetion _ recv _ buffer = new byte [ recv _ size ] ;
public i _ encryptor encryptor ; public server config ; public socket remote ; public socket connection ; public const int recv _ size = NUM ; public const int buffer _ size = recv _ size + NUM ; public byte [ ] remote _ recv _ buffer = new byte [ recv _ size ] ; public byte [ ] remote _ send _ buffer = new byte [ buffer _ size ] ; public byte [ ] connetion _ recv _ buffer = new byte [ recv _ size ] ; public byte [ ] connetion _ send _ buffer = new byte [ buffer _ size ] ;
this . table _ layout _ panel . column _ count = 2 ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . controls . add ( this . delete _ button , 1 , 0 ) ; this . table _ layout _ panel . controls . add ( this . add _ button , 0 , 0 ) ; this . table _ layout _ panel . dock = system . windows . forms . dock _ style . top ; this . table _ layout _ panel . location = new system . drawing . point ( 0 , NUM ) ; this . table _ layout _ panel . margin = new system . windows . forms . padding ( 0 ) ; this . table _ layout _ panel . name = STR ;
this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . controls . add ( this . delete _ button , 1 , 0 ) ; this . table _ layout _ panel . controls . add ( this . add _ button , 0 , 0 ) ; this . table _ layout _ panel . dock = system . windows . forms . dock _ style . top ; this . table _ layout _ panel . location = new system . drawing . point ( 0 , NUM ) ; this . table _ layout _ panel . margin = new system . windows . forms . padding ( 0 ) ; this . table _ layout _ panel . name = STR ; this . table _ layout _ panel . row _ count = 1 ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ;
configuration . save ( config ) ; } public void save _ log _ viewer _ config ( log _ viewer _ config new _ config ) { config . log _ viewer = new _ config ; configuration . save ( config ) ; } public void update _ inbound _ counter ( long n ) { interlocked . add ( ref inbound _ counter , n ) ;
configuration . save ( config ) ; } public void update _ inbound _ counter ( long n ) { interlocked . add ( ref inbound _ counter , n ) ; config . get _ current _ server ( ) . bandwidth _ in = inbound _ counter ; } public void update _ outbound _ counter ( long n ) { interlocked . add ( ref outbound _ counter , n ) ;
config . get _ current _ server ( ) . bandwidth _ in = inbound _ counter ; } public void update _ outbound _ counter ( long n ) { interlocked . add ( ref outbound _ counter , n ) ; config . get _ current _ server ( ) . bandwidth _ out = outbound _ counter ; } protected void reload ( ) { config = configuration . load ( ) ;
handler . receive ( ) ; return true ; } public class udp _ handler { private socket local ; private socket remote ; private server server ; private byte [ ] buffer = new byte [ NUM ] ; private ip _ end _ point local _ end _ point ;
private socket remote ; private server server ; private byte [ ] buffer = new byte [ NUM ] ; private ip _ end _ point local _ end _ point ; private ip _ end _ point remote _ end _ point ; public udp _ handler ( socket local , server server , ip _ end _ point local _ end _ point ) { local = local ; server = server ; local _ end _ point = local _ end _ point ;
public void begin _ connect _ proxy ( end _ point remote _ ep , async _ callback callback , object state ) { var r = new fake _ async _ result ( state ) ; callback ? . invoke ( r ) ; } public void end _ connect _ proxy ( i _ async _ result async _ result ) { } public void begin _ connect _ dest ( end _ point dest _ end _ point , async _ callback callback , object state ) {
public void end _ connect _ proxy ( i _ async _ result async _ result ) { } public void begin _ connect _ dest ( end _ point dest _ end _ point , async _ callback callback , object state ) { * / var dep = real _ end _ point as dns _ end _ point ; if ( dep ! = null ) { ip _ host _ entry ip _ host _ info = dns . get _ host _ entry ( dep . host ) ; ip _ address ip _ address = ip _ host _ info . address _ list [ 0 ] ; real _ end _ point = new ip _ end _ point ( ip _ address , dep . port ) ; } if ( remote = = null ) {
public void begin _ connect _ dest ( end _ point dest _ end _ point , async _ callback callback , object state ) { { ip _ host _ entry ip _ host _ info = dns . get _ host _ entry ( dep . host ) ; ip _ address ip _ address = ip _ host _ info . address _ list [ 0 ] ; real _ end _ point = new ip _ end _ point ( ip _ address , dep . port ) ; } if ( remote = = null ) { remote = new socket ( real _ end _ point . address _ family , socket _ type . stream , protocol _ type . tcp ) ; remote . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; }
private class server _ timer : timer { public server server ; public server _ timer ( int p ) : base ( p ) { } } private void start _ connect ( ) { try { create _ remote ( ) ;
public server _ timer ( int p ) : base ( p ) { } } private void start _ connect ( ) { try { create _ remote ( ) ; ip _ end _ point proxy _ ep ; if ( config . use _ proxy ) {
{ try { create _ remote ( ) ; ip _ end _ point proxy _ ep ; if ( config . use _ proxy ) { if ( ! parsed ) { * todo really necessary to resolve a proxy ' s address ? maybe from local hosts ? * also we may simplify it by using dual - mode socket with * the approach described in direct _ connect . begin _ connect _ dest * / ip _ host _ entry ip _ host _ info = dns . get _ host _ entry ( config . proxy _ server ) ; ip _ address = ip _ host _ info . address _ list [ 0 ] ; } remote = new socks _ proxy ( ) ;
{ this . controller = controller ; load _ menu ( ) ; controller . enable _ status _ changed + = controller _ enable _ status _ changed ; controller . config _ changed + = controller _ config _ changed ; controller . pac _ file _ ready _ to _ open + = controller _ pac _ file _ ready _ to _ open ; controller . share _ over _ lan _ status _ changed + = controller _ share _ over _ lan _ status _ changed ; controller . enable _ global _ changed + = controller _ enable _ global _ changed ; controller . errored + = controller _ errored ; notify _ icon = new notify _ icon ( ) ;
load _ menu ( ) ; controller . enable _ status _ changed + = controller _ enable _ status _ changed ; controller . config _ changed + = controller _ config _ changed ; controller . pac _ file _ ready _ to _ open + = controller _ pac _ file _ ready _ to _ open ; controller . share _ over _ lan _ status _ changed + = controller _ share _ over _ lan _ status _ changed ; controller . enable _ global _ changed + = controller _ enable _ global _ changed ; controller . errored + = controller _ errored ; notify _ icon = new notify _ icon ( ) ; load _ tray _ icon ( ) ; notify _ icon . visible = true ;
this . quit _ item . click + = new system . event _ handler ( this . quit _ click ) ; } private void controller _ config _ changed ( object sender , event _ args e ) { load _ current _ configuration ( ) ; } private void controller _ enable _ status _ changed ( object sender , event _ args e ) { enable _ item . checked = controller . get _ configuration ( ) . enabled ;
this . server _ port _ text _ box . tab _ index = 1 ; this . server _ port _ text _ box . word _ wrap = false ; this . password _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . password _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . password _ text _ box . max _ length = NUM ; this . password _ text _ box . name = STR ; this . password _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . password _ text _ box . tab _ index = 2 ; this . password _ text _ box . word _ wrap = false ;
using system _ linq ; using microsoft _ win ; using system _ windows _ interop ; namespace shadowsocks _ view { public class menu _ view _ controller { private shadowsocks _ controller controller ; private update _ checker update _ checker ; private notify _ icon notify _ icon ;
icon new _ icon ; bool has _ inbound = controller . traffic _ per _ second _ queue . last ( ) . inbound _ increasement > 0 ; bool has _ outbound = controller . traffic _ per _ second _ queue . last ( ) . outbound _ increasement > 0 ; if ( has _ inbound & & has _ outbound ) new _ icon = icon _ both ; else if ( has _ inbound ) new _ icon = icon _ in ; else if ( has _ outbound ) new _ icon = icon _ out ; else
if ( new _ icon ! = this . target _ icon ) { this . target _ icon = new _ icon ; notify _ icon . icon = new _ icon ; } } void controller _ errored ( object sender , system . io . error _ event _ args e ) { message _ box . show ( e . get _ exception ( ) . to _ string ( ) , n . get _ string ( STR , e . get _ exception ( ) . message ) ) ; }
message _ box . show ( e . get _ exception ( ) . to _ string ( ) , n . get _ string ( STR , e . get _ exception ( ) . message ) ) ; } { icon _ base _ bitmap = resources . ss ; } else { icon _ base _ bitmap = resources . ss ; } configuration config = controller . get _ configuration _ copy ( ) ; bool enabled = config . enabled ; bool global = config . global ;
( enabled ? n . get _ string ( STR ) + ( global ? n . get _ string ( STR ) : n . get _ string ( STR ) ) : n . get _ string ( STR , config . local _ port ) ) + STR + server _ info ; if ( text . length > NUM ) { text = text . substring ( 0 , NUM - NUM ) + STR ; } view _ utils . set _ notify _ icon _ text ( notify _ icon , text ) ; }
private bitmap get _ dark _ tray _ icon ( bitmap origin _ icon ) { bitmap icon _ copy = new bitmap ( origin _ icon ) ; for ( int x = 0 ; x < icon _ copy . width ; x + + ) { for ( int y = 0 ; y < icon _ copy . height ; y + + ) { color color = origin _ icon . get _ pixel ( x , y ) ; if ( color . a ! = 0 ) {
for ( int x = 0 ; x < icon _ copy . width ; x + + ) { for ( int y = 0 ; y < icon _ copy . height ; y + + ) { color color = origin _ icon . get _ pixel ( x , y ) ; if ( color . a ! = 0 ) { color fly _ blue = color . from _ argb ( NUM , 0 , 0 , 0 ) ; int red = color . r * fly _ blue . r / NUM ; int green = color . g * fly _ blue . g / NUM ; int blue = color . b * fly _ blue . b / NUM ; int alpha = color . a ; icon _ copy . set _ pixel ( x , y , color . from _ argb ( alpha , red , green , blue ) ) ; }
{ logging . error ( e ) ; throw ; } } return temp _ path ; } public enum windows _ theme _ mode { dark , light } public static windows _ theme _ mode get _ windows _ system _ theme _ setting ( ) {
} } return temp _ path ; } public enum windows _ theme _ mode { dark , light } public static windows _ theme _ mode get _ windows _ system _ theme _ setting ( ) { windows _ theme _ mode regist _ data = windows _ theme _ mode . dark ; try {
} public enum windows _ theme _ mode { dark , light } public static windows _ theme _ mode get _ windows _ system _ theme _ setting ( ) { windows _ theme _ mode regist _ data = windows _ theme _ mode . dark ; try { registry _ key reg _ hkcu = registry . current _ user ; registry _ key reg _ themes _ personalize = reg _ hkcu . open _ sub _ key ( STR , false ) ; if ( reg _ themes _ personalize . get _ value ( STR ) ! = null ) {
{ windows _ theme _ mode regist _ data = windows _ theme _ mode . dark ; try { registry _ key reg _ hkcu = registry . current _ user ; registry _ key reg _ themes _ personalize = reg _ hkcu . open _ sub _ key ( STR , false ) ; if ( reg _ themes _ personalize . get _ value ( STR ) ! = null ) { if ( convert . to _ int ( reg _ themes _ personalize . get _ value ( STR ) . to _ string ( ) ) = = 0 ) regist _ data = windows _ theme _ mode . dark ; else
public static string get _ temp _ path ( ) { if ( temp _ path = = null ) { try {
namespace shadowsocks _ view { public partial class config _ form : form { private shadowsocks _ controller controller ; private configuration modified _ configuration ; private int last _ selected _ index = - 1 ; public config _ form ( shadowsocks _ controller controller ) {
{ public partial class config _ form : form { private shadowsocks _ controller controller ; private configuration modified _ configuration ; private int last _ selected _ index = - 1 ; public config _ form ( shadowsocks _ controller controller ) { this . font = system . drawing . system _ fonts . message _ box _ font ; initialize _ component ( ) ;
this . ip _ text _ box = new system . windows . forms . text _ box ( ) ; this . server _ port _ text _ box = new system . windows . forms . text _ box ( ) ; this . password _ text _ box = new system . windows . forms . text _ box ( ) ; this . encryption _ label = new system . windows . forms . label ( ) ; this . encryption _ select = new system . windows . forms . combo _ box ( ) ; this . timeout _ label = new system . windows . forms . label ( ) ; this . timeout _ text _ box = new system . windows . forms . text _ box ( ) ; this . plugin _ label = new system . windows . forms . label ( ) ; this . plugin _ options _ text _ box = new system . windows . forms . text _ box ( ) ; this . show _ passwd _ check _ box = new system . windows . forms . check _ box ( ) ;
this . move _ up _ button . dock = system . windows . forms . dock _ style . left ; this . move _ up _ button . location = new system . drawing . point ( 0 , NUM ) ; this . move _ up _ button . margin = new system . windows . forms . padding ( 0 , NUM , NUM , NUM ) ; this . move _ up _ button . name = STR ; this . move _ up _ button . size = new system . drawing . size ( NUM , NUM ) ; this . move _ up _ button . tab _ index = NUM ; this . move _ up _ button . text = STR ; this . move _ up _ button . use _ visual _ style _ back _ color = true ; this . move _ up _ button . click + = new system . event _ handler ( this . move _ up _ button _ click ) ; this . table _ layout _ panel . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( ( system . windows . forms . anchor _ styles . top | system . windows . forms . anchor _ styles . bottom )
this . move _ up _ button . click + = new system . event _ handler ( this . move _ up _ button _ click ) ; this . table _ layout _ panel . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( ( system . windows . forms . anchor _ styles . top | system . windows . forms . anchor _ styles . bottom ) | system . windows . forms . anchor _ styles . right ) ) ) ; this . table _ layout _ panel . auto _ size = true ; this . table _ layout _ panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . table _ layout _ panel . column _ count = 2 ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . controls . add ( this . proxy _ port _ text _ box , 1 , 0 ) ; this . table _ layout _ panel . controls . add ( this . proxy _ port _ label , 0 , 0 ) ;
this . table _ layout _ panel . column _ count = 2 ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . controls . add ( this . proxy _ port _ text _ box , 1 , 0 ) ; this . table _ layout _ panel . controls . add ( this . proxy _ port _ label , 0 , 0 ) ; this . table _ layout _ panel . location = new system . drawing . point ( NUM , NUM ) ; this . table _ layout _ panel . margin = new system . windows . forms . padding ( 0 ) ; this . table _ layout _ panel . name = STR ; this . table _ layout _ panel . padding = new system . windows . forms . padding ( NUM ) ;
if ( arguments = = STR ) { if ( stdout . is _ null _ or _ white _ space ( ) | | stdout . is _ null _ or _ empty ( ) ) { throw new proxy _ exception ( STR ) ; } query _ str = stdout ; } } } private static void save ( ) {
} } catch ( io _ exception e ) { logging . log _ useful _ exception ( e ) ; } } private static void read ( ) {
using system ; using system _ collections _ generic ;
using system _ collections _ generic ; using system _ linq ; using system _ net ; using system _ net _ sockets ; using system _ timers ; using shadowsocks _ controller _ strategy ; using shadowsocks _ encryption ; using shadowsocks _ forward _ proxy ; using shadowsocks _ model ; using shadowsocks _ util _ sockets ;
using shadowsocks _ forward _ proxy ; using shadowsocks _ model ; using shadowsocks _ util _ sockets ; namespace shadowsocks _ controller { class tcp _ relay : listener . service { private shadowsocks _ controller controller ; private date _ time last _ sweep _ time ; private configuration config ;
{ private shadowsocks _ controller controller ; private date _ time last _ sweep _ time ; private configuration config ; public i _ set < tcp _ handler > handlers { get ; set ; } public tcp _ relay ( shadowsocks _ controller controller , configuration conf ) { controller = controller ; config = conf ;
{ controller = controller ; config = conf ; handlers = new hash _ set < tcp _ handler > ( ) ; last _ sweep _ time = date _ time . now ; } public override bool handle ( byte [ ] first _ packet , int length , socket socket , object state ) {
} public override bool handle ( byte [ ] first _ packet , int length , socket socket , object state ) { if ( socket . protocol _ type ! = protocol _ type . tcp | | ( length < 2 | | first _ packet [ 0 ] ! = NUM ) ) return false ; socket . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ;
} public void update _ outbound _ counter ( server server , long n ) { controller . update _ outbound _ counter ( server , n ) ; } public void update _ latency ( server server , time _ span latency ) { controller . update _ latency ( server , latency ) ; } }
{ controller . update _ outbound _ counter ( server , n ) ; } public void update _ latency ( server server , time _ span latency ) { controller . update _ latency ( server , latency ) ; } } class tcp _ handler {
{ class async _ session { public i _ forward _ proxy remote { get ; } public async _ session ( i _ forward _ proxy remote ) { remote = remote ; } }
{ state = state ; } } private readonly int server _ timeout ; private readonly int proxy _ timeout ; public static readonly int recv _ size = NUM ; public static readonly int recv _ reserve _ size = iv _ encryptor . onetimeauth _ bytes + iv _ encryptor . auth _ bytes ; public static readonly int buffer _ size = recv _ size + recv _ reserve _ size + NUM ; public date _ time last _ activity ;
public static readonly int recv _ reserve _ size = iv _ encryptor . onetimeauth _ bytes + iv _ encryptor . auth _ bytes ; public static readonly int buffer _ size = recv _ size + recv _ reserve _ size + NUM ; public date _ time last _ activity ; private shadowsocks _ controller controller ; private configuration config ; private tcp _ relay tcprelay ; private socket connection ; private i _ encryptor encryptor ; private server server ; private async _ session current _ remote _ session ;
private bool connection _ shutdown = false ; private bool remote _ shutdown = false ; private bool closed = false ; private readonly object encryption _ lock = new object ( ) ; private readonly object decryption _ lock = new object ( ) ; private readonly object close _ conn _ lock = new object ( ) ; private date _ time start _ connect _ time ; private date _ time start _ receiving _ time ; private date _ time start _ sending _ time ; private end _ point dest _ end _ point = null ;
private end _ point dest _ end _ point = null ; public tcp _ handler ( shadowsocks _ controller controller , configuration config , tcp _ relay tcprelay , socket socket ) { controller = controller ; config = config ; tcprelay = tcprelay ; connection = socket ; proxy _ timeout = config . proxy . proxy _ timeout * NUM ; server _ timeout = config . get _ current _ server ( ) . timeout * NUM ; last _ activity = date _ time . now ;
{ if ( server ! = null ) { i _ strategy strategy = controller . get _ current _ strategy ( ) ; strategy ? . set _ failure ( server ) ; } logging . log _ useful _ exception ( e ) ; close ( ) ; } }
logging . log _ useful _ exception ( e ) ; close ( ) ; } } private void start _ pipe ( async _ session session ) { if ( closed ) return ; try { start _ receiving _ time = date _ time . now ;
total _ write + = length ; int bytes _ to _ send ; lock ( encryption _ lock ) { encryptor . encrypt ( connetion _ recv _ buffer , length , connetion _ send _ buffer , out bytes _ to _ send ) ; } tcprelay . update _ outbound _ counter ( server , bytes _ to _ send ) ; start _ sending _ time = date _ time . now ;
strategy ? . update _ last _ write ( server ) ; } private void pipe _ remote _ send _ callback ( i _ async _ result ar ) {
private void pipe _ remote _ send _ callback ( i _ async _ result ar ) { if ( closed ) return ; try { var session = ( async _ session ) ar . async _ state ;
if ( strategy ! = null ) { strategy . reload _ servers ( ) ; } tcp _ relay tcp _ relay = new tcp _ relay ( this , config ) ; udp _ relay udp _ relay = new udp _ relay ( this ) ; list < listener . i _ service > services = new list < listener . i _ service > ( ) ; services . add ( tcp _ relay ) ; services . add ( udp _ relay ) ;
{ var state = ( ( fake _ async _ result ) async _ result ) . inner _ state ; if ( state . ex ! = null ) { throw state . ex ; } } public void begin _ connect _ dest ( end _ point dest _ end _ point , async _ callback callback , object state ) { dest _ end _ point = dest _ end _ point ;
} public void begin _ connect _ dest ( end _ point dest _ end _ point , async _ callback callback , object state ) { dest _ end _ point = dest _ end _ point ; default : throw new exception ( n . get _ string ( STR ) ) ; } port = ( ( ip _ end _ point ) dest _ end _ point ) . port ; var addr = ( ( ip _ end _ point ) dest _ end _ point ) . address . get _ address _ bytes ( ) ; array . copy ( addr , 0 , request , NUM , request . length - NUM - 2 ) ; } request [ 0 ] = NUM ; request [ 1 ] = 1 ; request [ 2 ] = 0 ;
dll _ import _ rasapi _ dll _ char _ set _ char _ set _ auto private static extern uint ras _ enum _ entries ( string reserved , string lpsz _ phonebook , in _ out ras _ entry _ name [ ] lprasentryname , ref int lpcb , out int lpc _ entries ) ; public static uint get _ all _ conns ( ref string [ ] all _ conns ) {
out int lpc _ entries ) ; public static uint get _ all _ conns ( ref string [ ] all _ conns ) { int lp _ names = 1 ; int entry _ name _ size = 0 ; int lp _ size = 0 ; uint retval = error _ success ; ras _ entry _ name [ ] names = null ; entry _ name _ size = marshal . size _ of ( typeof ( ras _ entry _ name ) ) ;
entry _ name _ size = marshal . size _ of ( typeof ( ras _ entry _ name ) ) ; names = new ras _ entry _ name [ lp _ names ] ; names [ 0 ] . dw _ size = entry _ name _ size ; retval = ras . ras _ enum _ entries ( null , null , names , ref lp _ size , out lp _ names ) ; if ( retval = = error _ buffer _ too _ small ) { names = new ras _ entry _ name [ lp _ names ] ; for ( int i = 0 ; i < names . length ; i + + ) { names [ i ] . dw _ size = entry _ name _ size ; }
update _ pac _ items _ enabled _ status ( ) ; update _ update _ menu ( ) ; } private void update _ servers _ menu ( ) { var items = servers _ item . menu _ items ; while ( items [ 0 ] ! = seperator _ item ) { items . remove _ at ( 0 ) ; }
while ( items [ 0 ] ! = seperator _ item ) { items . remove _ at ( 0 ) ; } int i = 0 ; foreach ( var strategy in controller . get _ strategies ( ) ) { menu _ item item = new menu _ item ( strategy . name ) ; item . tag = strategy . id ; item . click + = a _ strategy _ item _ click ;
} int i = 0 ; foreach ( var strategy in controller . get _ strategies ( ) ) { menu _ item item = new menu _ item ( strategy . name ) ; item . tag = strategy . id ; item . click + = a _ strategy _ item _ click ; items . add ( i , item ) ; i + + ; }
i + + ; } items . add ( i + + , new menu _ item ( STR ) ) ; int strategy _ count = i ; configuration configuration = controller . get _ configuration _ copy ( ) ; foreach ( var server in configuration . configs ) { if ( configuration . checks _ server ( server ) ) { menu _ item item = new menu _ item ( server . friendly _ name ( ) ) ;
items . add ( i + + , new menu _ item ( STR ) ) ; int strategy _ count = i ; configuration configuration = controller . get _ configuration _ copy ( ) ; foreach ( var server in configuration . configs ) { if ( configuration . checks _ server ( server ) ) { menu _ item item = new menu _ item ( server . friendly _ name ( ) ) ; item . tag = i - strategy _ count ; item . click + = a _ server _ item _ click ;

this . config _ item = create _ menu _ item ( STR , new event _ handler ( this . config _ click ) ) } ) , new menu _ item ( STR ) , this . auto _ startup _ item = create _ menu _ item ( STR , new event _ handler ( this . auto _ startup _ item _ click ) ) , this . share _ over _ lan _ item = create _ menu _ item ( STR , new event _ handler ( this . share _ over _ lan _ item _ click ) ) , create _ menu _ item ( STR , new event _ handler ( this . edit _ pac _ file _ item _ click ) ) , create _ menu _ item ( STR , new event _ handler ( this . update _ pac _ from _ gfw _ list _ item _ click ) ) , new menu _ item ( STR ) ,
update _ servers _ menu ( ) ; enable _ item . checked = config . enabled ; global _ mode _ item . checked = config . global ; pac _ mode _ item . checked = ! config . global ; share _ over _ lan _ item . checked = config . share _ over _ lan ; auto _ startup _ item . checked = auto _ startup . check ( ) ; } private void update _ servers _ menu ( ) { var items = servers _ item . menu _ items ;
var items = servers _ item . menu _ items ; items . clear ( ) ; configuration configuration = controller . get _ configuration ( ) ; for ( int i = 0 ; i < configuration . configs . count ; i + + ) { server server = configuration . configs [ i ] ; menu _ item item = new menu _ item ( server . friendly _ name ( ) ) ; item . tag = i ; item . click + = a _ server _ item _ click ;
{ try _ harder = true , possible _ formats = new list < barcode _ format > { barcode _ format . qr _ code } } ; var result = reader . decode ( image ) ; if ( result ! = null ) {
update _ pac _ from _ gfw _ list _ error ( this , e ) ; } private static readonly i _ enumerable < char > ignored _ line _ begins = new [ ] { '!' , '[' } ; private void pac _ server _ user _ rule _ file _ changed ( object sender , event _ args e ) { if ( ! file . exists ( utils . get _ temp _ path ( STR ) ) ) { update _ pac _ from _ gfw _ list ( ) ; return ; }
private void pac _ server _ user _ rule _ file _ changed ( object sender , event _ args e ) { if ( ! file . exists ( utils . get _ temp _ path ( STR ) ) ) { update _ pac _ from _ gfw _ list ( ) ; return ; } list < string > lines = gfw _ list _ updater . parse _ result ( file . read _ all _ text ( utils . get _ temp _ path ( STR ) ) ) ; if ( file . exists ( pac _ server . user _ rule _ file ) ) {
create _ menu _ item ( STR , new event _ handler ( this . quit _ click ) ) } ) ; } private void controller _ config _ changed ( object sender , event _ args e ) { load _ current _ configuration ( ) ; update _ tray _ icon ( ) ; } private void controller _ enable _ status _ changed ( object sender , event _ args e ) {
} private void notify _ icon _ double _ click ( object sender , mouse _ event _ args e ) { if ( e . button = = mouse _ buttons . left ) { show _ config _ form ( ) ; } } private void enable _ item _ click ( object sender , event _ args e ) {
namespace shadowsocks _ controller { public class logging { public static string log _ file ; public static bool open _ log _ file ( ) { try { string temppath = utils . get _ temp _ path ( ) ;
private void reload ( config config ) { if ( local ! = null ) { local . stop ( ) ; if ( polipo _ runner ! = null ) { polipo _ runner . stop ( ) ; } }

private menu _ item create _ menu _ item ( int index , string text , event _ handler click ) { menu _ item result = new menu _ item ( n . get _ string ( text ) , click ) ;
private menu _ item create _ menu _ item ( int index , string text , event _ handler click ) { menu _ item result = new menu _ item ( n . get _ string ( text ) , click ) ; result . index = index ; return result ; }
private menu _ item create _ menu _ item ( int index , string text , event _ handler click ) { menu _ item result = new menu _ item ( n . get _ string ( text ) , click ) ; result . index = index ; return result ; } private menu _ item create _ seperator _ item ( int index ) { menu _ item result = new menu _ item ( STR ) ;
menu _ item result = new menu _ item ( n . get _ string ( text ) , click ) ; result . index = index ; return result ; } private menu _ item create _ seperator _ item ( int index ) { menu _ item result = new menu _ item ( STR ) ; result . index = index ; return result ; }
private menu _ item create _ seperator _ item ( int index ) { menu _ item result = new menu _ item ( STR ) ; result . index = index ; return result ; } private menu _ item create _ menu _ group ( int index , string text , menu _ item [ ] items ) { menu _ item result = new menu _ item ( n . get _ string ( text ) , items ) ;
private menu _ item create _ menu _ group ( int index , string text , menu _ item [ ] items ) { menu _ item result = new menu _ item ( n . get _ string ( text ) , items ) ; result . index = index ; return result ; } private void load _ menu ( ) { this . context _ menu = new system . windows . forms . context _ menu ( ) ;
menu _ item result = new menu _ item ( n . get _ string ( text ) , items ) ; result . index = index ; return result ; } private void load _ menu ( ) { this . context _ menu = new system . windows . forms . context _ menu ( ) ; this . pac _ mode _ item = create _ menu _ item ( 0 , STR , new system . event _ handler ( this . pac _ mode _ item _ click ) ) ; this . global _ mode _ item = create _ menu _ item ( 1 , STR , new system . event _ handler ( this . global _ mode _ item _ click ) ) ; this . seperator _ item = create _ seperator _ item ( 0 ) ; this . config _ item = create _ menu _ item ( 1 , STR , new system . event _ handler ( this . config _ click ) ) ; this . enable _ item = create _ menu _ item ( 0 , STR , new system . event _ handler ( this . enable _ item _ click ) ) ; this . servers _ item = create _ menu _ group ( 2 , STR , new system . windows . forms . menu _ item [ ] { this . seperator _ item , this . config _ item } ) ;
private void pipe _ connection _ receive _ callback ( i _ async _ result ar ) { if ( closed ) return ; try { if ( connection = = null ) return ; int bytes _ read = connection . end _ receive ( ar ) ; total _ write + = bytes _ read ; if ( bytes _ read > 0 ) {
try { if ( connection = = null ) return ; int bytes _ read = connection . end _ receive ( ar ) ; total _ write + = bytes _ read ; if ( bytes _ read > 0 ) { int atyp = connetion _ recv _ buffer [ 0 ] ; string dst _ addr ; int dst _ port ; switch ( atyp ) {
using system _ io ; using newtonsoft _ json ; using n _ log ; using shadowsocks _ controller ; namespace shadowsocks _ model { serializable public class configuration { json _ ignore
json _ ignore private static logger logger = log _ manager . get _ current _ class _ logger ( ) ; public string version ; public list < server > configs ; public string strategy ; public int index ; public bool global ; public bool enabled ; public bool share _ over _ lan ; public bool is _ default ;
public int index ; public bool global ; public bool enabled ; public bool share _ over _ lan ; public bool is _ default ; public bool is _ i _ pv _ enabled = false ; public int local _ port ; public bool portable _ mode = true ; public bool show _ plugin _ output ; public string pac _ url ;
public bool portable _ mode = true ; public bool show _ plugin _ output ; public string pac _ url ; public string geosite _ url ; public string geosite _ group = STR ; public bool geosite _ blacklist _ mode = true ; public bool use _ online _ pac ; public bool secure _ local _ pac = true ; public bool availability _ statistics ; public bool auto _ check _ update ; public bool check _ pre _ release ; public bool is _ verbose _ logging ;
public bool is _ verbose _ logging ; public bool generate _ legacy _ url = false ; public log _ viewer _ config log _ viewer ; public proxy _ config proxy ; public hotkey _ config hotkey ; json _ ignore n _ log _ config n _ log _ config ; private static readonly string config _ file = STR ;
public bool generate _ legacy _ url = false ; public log _ viewer _ config log _ viewer ; public proxy _ config proxy ; public hotkey _ config hotkey ; json _ ignore n _ log _ config n _ log _ config ; private static readonly string config _ file = STR ; private static readonly n _ log _ config . log _ level verbose _ log _ level =
public bool generate _ legacy _ url = false ; public log _ viewer _ config log _ viewer ; public proxy _ config proxy ; public hotkey _ config hotkey ; json _ ignore n _ log _ config n _ log _ config ; private static readonly string config _ file = STR ; private static readonly n _ log _ config . log _ level verbose _ log _ level = n _ log _ config . log _ level . trace ;
using system ; using system _ collections _ generic ; using system _ drawing ; using system _ linq ;
using system ; using system _ collections _ generic ; using system _ drawing ; using system _ linq ; using system _ reflection ; using system _ text ; using system _ windows _ forms ; using shadowsocks _ controller ;
using system _ collections _ generic ; using system _ drawing ; using system _ linq ; using system _ reflection ; using system _ text ; using system _ windows _ forms ; using shadowsocks _ controller ; using shadowsocks _ controller _ hotkeys ; using shadowsocks _ model ; using shadowsocks _ properties ;
this . close ( ) ; } private void register _ all _ button _ click ( object sender , event _ args e ) { modified _ hotkey _ config = get _ config _ from _ ui ( ) ; register _ all _ hotkeys ( modified _ hotkey _ config ) ; } private bool register _ all _ hotkeys ( hotkey _ config hotkey _ config ) { return
private bool register _ all _ hotkeys ( hotkey _ config hotkey _ config ) { return reg _ hotkey _ from _ string ( hotkey _ config . switch _ system _ proxy , STR , switch _ system _ proxy _ label ) & & reg _ hotkey _ from _ string ( hotkey _ config . switch _ system _ proxy _ mode , STR , switch _ proxy _ mode _ label ) & & reg _ hotkey _ from _ string ( hotkey _ config . switch _ allow _ lan , STR , switch _ allow _ lan _ label ) & & reg _ hotkey _ from _ string ( hotkey _ config . show _ logs , STR , show _ logs _ label ) & & reg _ hotkey _ from _ string ( hotkey _ config . server _ move _ up , STR , server _ move _ up _ label ) & & reg _ hotkey _ from _ string ( hotkey _ config . server _ move _ down , STR , server _ move _ down _ label ) ; }
return reg _ hotkey _ from _ string ( hotkey _ config . switch _ system _ proxy , STR , switch _ system _ proxy _ label ) & & reg _ hotkey _ from _ string ( hotkey _ config . switch _ system _ proxy _ mode , STR , switch _ proxy _ mode _ label ) & & reg _ hotkey _ from _ string ( hotkey _ config . switch _ allow _ lan , STR , switch _ allow _ lan _ label ) & & reg _ hotkey _ from _ string ( hotkey _ config . show _ logs , STR , show _ logs _ label ) & & reg _ hotkey _ from _ string ( hotkey _ config . server _ move _ up , STR , server _ move _ up _ label ) & & reg _ hotkey _ from _ string ( hotkey _ config . server _ move _ down , STR , server _ move _ down _ label ) ; } private bool reg _ hotkey _ from _ string ( string hotkey _ str , string callback _ name , label indicator = null ) {
& & reg _ hotkey _ from _ string ( hotkey _ config . switch _ system _ proxy _ mode , STR , switch _ proxy _ mode _ label ) & & reg _ hotkey _ from _ string ( hotkey _ config . switch _ allow _ lan , STR , switch _ allow _ lan _ label ) & & reg _ hotkey _ from _ string ( hotkey _ config . show _ logs , STR , show _ logs _ label ) & & reg _ hotkey _ from _ string ( hotkey _ config . server _ move _ up , STR , server _ move _ up _ label ) & & reg _ hotkey _ from _ string ( hotkey _ config . server _ move _ down , STR , server _ move _ down _ label ) ; } private bool reg _ hotkey _ from _ string ( string hotkey _ str , string callback _ name , label indicator = null ) { var callback = hotkey _ callbacks . get _ callback ( callback _ name ) ; if ( callback = = null ) {
& & reg _ hotkey _ from _ string ( hotkey _ config . show _ logs , STR , show _ logs _ label ) & & reg _ hotkey _ from _ string ( hotkey _ config . server _ move _ up , STR , server _ move _ up _ label ) & & reg _ hotkey _ from _ string ( hotkey _ config . server _ move _ down , STR , server _ move _ down _ label ) ; } private bool reg _ hotkey _ from _ string ( string hotkey _ str , string callback _ name , label indicator = null ) { var callback = hotkey _ callbacks . get _ callback ( callback _ name ) ; if ( callback = = null ) { indicator . reset _ back _ color ( ) ; } return true ; } else { var hotkey = hot _ keys . str _ hot _ key ( hotkey _ str ) ; if ( hotkey = = null ) { message _ box . show ( string . format ( n . get _ string ( STR ) , hotkey _ str ) ) ;
notify _ icon . visible = true ; notify _ icon . context _ menu = context _ menu ; notify _ icon . balloon _ tip _ clicked + = notify _ icon _ balloon _ tip _ clicked ; notify _ icon . mouse _ click + = notify _ icon _ click ; notify _ icon . mouse _ double _ click + = notify _ icon _ double _ click ; notify _ icon . balloon _ tip _ closed + = notify _ icon _ balloon _ tip _ closed ; this . update _ checker = new update _ checker ( ) ; update _ checker . check _ update _ completed + = update _ checker _ check _ update _ completed ; load _ current _ configuration ( ) ; configuration config = controller . get _ configuration _ copy ( ) ;
notify _ icon . balloon _ tip _ closed + = notify _ icon _ balloon _ tip _ closed ; this . update _ checker = new update _ checker ( ) ; update _ checker . check _ update _ completed + = update _ checker _ check _ update _ completed ; load _ current _ configuration ( ) ; configuration config = controller . get _ configuration _ copy ( ) ; if ( config . auto _ check _ update ) { is _ startup _ checking = true ; update _ checker . check _ update ( config , NUM ) ;
show _ balloon _ tip ( string . format ( n . get _ string ( STR ) , update _ checker . latest _ version _ number ) , n . get _ string ( STR ) , tool _ tip _ icon . info , NUM ) ;
show _ balloon _ tip ( string . format ( n . get _ string ( STR ) , update _ checker . latest _ version _ number ) , n . get _ string ( STR ) , tool _ tip _ icon . info , NUM ) ; is _ first _ run = false ; } else if ( ! is _ startup _ checking ) { show _ balloon _ tip ( n . get _ string ( STR ) , n . get _ string ( STR ) , tool _ tip _ icon . info , NUM ) ;
private void show _ first _ time _ balloon ( ) {
servers _ list _ box . items . clear ( ) ; foreach ( server server in modified _ configuration . configs ) { servers _ list _ box . items . add ( server . friendly _ name ( ) ) ; } } private void load _ current _ configuration ( ) { modified _ configuration = controller . get _ configuration _ copy ( ) ; load _ configuration ( modified _ configuration ) ;
return ; } server server = configuration . get _ default _ server ( ) ; modified _ configuration . configs . add ( server ) ; load _ configuration ( modified _ configuration ) ; servers _ list _ box . selected _ index = modified _ configuration . configs . count - 1 ; old _ selected _ index = servers _ list _ box . selected _ index ; } private void delete _ button _ click ( object sender , event _ args e ) {
if ( ! save _ old _ selected _ server ( ) ) { return ; } if ( modified _ configuration . configs . count = = 0 ) { message _ box . show ( n . get _ string ( STR ) ) ; return ; }
{ return ; } if ( modified _ configuration . configs . count = = 0 ) { message _ box . show ( n . get _ string ( STR ) ) ; return ; } int index = modified _ configuration . index ; controller . save _ servers ( modified _ configuration . configs , modified _ configuration . local _ port ) ;
using system _ collections _ generic ; namespace shadowsocks _ encryption { public class sodium _ encryptor : iv _ encryptor , i _ disposable { const int cipher _ sals = 1 ; const int cipher _ chach = 2 ; const int cipher _ chach _ ietf = NUM ; const int sodium _ block _ size = NUM ;
public static list < string > supported _ ciphers ( ) { return new list < string > ( ciphers . keys ) ; } protected override void cipher _ update ( bool is _ cipher , int length , byte [ ] buf , byte [ ] outbuf ) { int bytes _ remaining ; ulong ic ; byte [ ] iv ;
return new list < string > ( ciphers . keys ) ; } protected override void cipher _ update ( bool is _ cipher , int length , byte [ ] buf , byte [ ] outbuf ) { int bytes _ remaining ; ulong ic ; byte [ ] iv ; lock ( sodium _ buf ) {

using shadowsocks _ csharp _ model ; using shadowsocks _ csharp _ properties ; using system ; using system _ collections _ generic ; using system _ diagnostics ; using system _ io ; using system _ i _ compression ; using system _ text ;

using shadowsocks _ csharp _ properties ; using system ; using system _ collections _ generic ; using system _ diagnostics ; using system _ io ; using system _ i _ compression ; using system _ net ; using system _ net _ sockets ; using system _ text ;

using shadowsocks _ csharp _ model ; using system ; using system _ collections _ generic ; using system _ text ;

using shadowsocks _ csharp _ controller ; using shadowsocks _ csharp _ properties ; using shadowsocks _ csharp _ view ; using system ; using system _ collections _ generic ; using system _ io ; using system _ runtime _ interop _ services ; using system _ windows _ forms ;
else { server _ group _ box . visible = false ; } } private void load _ configuration ( configuration configuration ) { servers _ list _ box . items . clear ( ) ; foreach ( server server in modified _ configuration . configs ) {
this . panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . panel . controls . add ( this . my _ cancel _ button ) ; this . panel . controls . add ( this . ok _ button ) ; this . panel . location = new system . drawing . point ( NUM , NUM ) ; this . panel . margin = new system . windows . forms . padding ( 0 ) ; this . panel . name = STR ; this . panel . size = new system . drawing . size ( NUM , NUM ) ; this . panel . tab _ index = 1 ; this . context _ menu . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . enable _ item ,
this . enable _ item , this . config _ item , this . edit _ pac _ file _ item , this . about _ item , this . menu _ item , this . quit _ item } ) ; this . enable _ item . index = 0 ; this . enable _ item . text = STR ; this . enable _ item . click + = new system . event _ handler ( this . enable _ item _ click ) ;
this . quit _ item } ) ; this . enable _ item . index = 0 ; this . enable _ item . text = STR ; this . enable _ item . click + = new system . event _ handler ( this . enable _ item _ click ) ; this . config _ item . index = 1 ; this . config _ item . text = STR ; this . config _ item . click + = new system . event _ handler ( this . config _ click ) ;
{ strategy . reload _ servers ( ) ; } polipo _ runner . start ( config ) ; tcp _ relay tcp _ relay = new tcp _ relay ( this , config ) ; udp _ relay udp _ relay = new udp _ relay ( this ) ; list < listener . i _ service > services = new list < listener . i _ service > ( ) ; services . add ( tcp _ relay ) ; services . add ( udp _ relay ) ; services . add ( pac _ server ) ;
using system _ net _ network _ information ; using system _ runtime _ interop _ services ; using system _ text ; using system _ windows _ forms ; using shadowsocks _ model ; using shadowsocks _ properties ; using shadowsocks _ util ; using shadowsocks _ util _ process _ management ; namespace shadowsocks _ controller {
using shadowsocks _ util _ process _ management ; namespace shadowsocks _ controller { class polipo _ runner { private static int uid ; private static string unique _ config _ file ; private static job polipo _ job ; private process process ; private int running _ port ;
get { return running _ port ; } } public void start ( configuration configuration ) { server server = configuration . get _ current _ server ( ) ; if ( process = = null ) {
public void start ( configuration configuration ) { server server = configuration . get _ current _ server ( ) ; if ( process = = null ) { process [ ] existing _ polipo = process . get _ processes _ by _ name ( STR ) ; foreach ( process p in existing _ polipo . where ( is _ child _ process ) ) { kill _ process ( p ) ; }
server server = configuration . get _ current _ server ( ) ; if ( process = = null ) { process [ ] existing _ polipo = process . get _ processes _ by _ name ( STR ) ; foreach ( process p in existing _ polipo . where ( is _ child _ process ) ) { kill _ process ( p ) ; } string polipo _ config = resources . privoxy _ conf ; running _ port = this . get _ free _ port ( ) ;
local _ end _ point = new ip _ end _ point ( ip _ address . loopback , local _ port ) ; plugin _ process . start _ info . environment [ STR ] = local _ end _ point . address . to _ string ( ) ; plugin _ process . start _ info . environment [ STR ] = local _ end _ point . port . to _ string ( ) ; plugin _ process . start _ info . arguments = expand _ environment _ variables ( plugin _ process . start _ info . arguments , plugin _ process . start _ info . environment _ variables ) ; try { plugin _ process . start ( ) ; } catch ( system . component _ model . win _ exception ex ) {
using system ; using system _ collections _ generic ; using system _ data ; using system _ linq ; using system _ windows _ forms ;
using system ; using system _ collections _ generic ; using system _ data ; using system _ linq ; using system _ windows _ forms ; using system _ windows _ forms _ data _ visualization _ charting ; using shadowsocks _ controller ; using shadowsocks _ model ;
catch ( exception ex ) { logging . log _ useful _ exception ( ex ) ; } } private void http _ download _ string _ completed ( object sender , download _ string _ completed _ event _ args e ) { try { string response = e . result ;
logging . log _ useful _ exception ( ex ) ; } } private void http _ download _ string _ completed ( object sender , download _ string _ completed _ event _ args e ) { try { string response = e . result ; json _ array result = ( json _ array ) simple _ json . simple _ json . deserialize _ object ( e . result ) ; list < asset > asserts = new list < asset > ( ) ;
string response = e . result ; json _ array result = ( json _ array ) simple _ json . simple _ json . deserialize _ object ( e . result ) ; list < asset > asserts = new list < asset > ( ) ; if ( ( bool ) release [ STR ] ) { continue ; } foreach ( json _ object asset in ( json _ array ) release [ STR ] ) { asset ass = new asset ( ) ; ass . parse ( asset ) ; if ( ass . is _ new _ version ( version ) ) {
using system ;
using system ; using system _ collections _ generic ; using system _ text ;
using system ; using system _ collections _ generic ; using system _ text ; using system _ io ; using system _ diagnostics ; using simple _ json ; using shadowsocks _ controller ;

using shadowsocks _ controller ; using system ; using system _ collections _ generic ; using system _ io ;
using system ; using system _ collections _ generic ; using system _ text ; using system _ security _ cryptography ; namespace shadowsocks _ csharp {
using system _ collections _ generic ; using system _ text ; using system _ security _ cryptography ; namespace shadowsocks _ csharp { class encryptor {
namespace shadowsocks _ csharp { class encryptor { public const int type _ table = 1 ; public const int type _ r = 2 ; public byte [ ] encrypt _ table = new byte [ NUM ] ; public byte [ ] decrypt _ table = new byte [ NUM ] ;
{ m md = system . security . cryptography . m . create ( ) ; byte [ ] input _ bytes = system . text . encoding . ut . get _ bytes ( password ) ; byte [ ] hash = md . compute _ hash ( input _ bytes ) ; if ( method ! = null & & method . to _ lower _ invariant ( ) . equals ( STR ) ) { console . write _ line ( STR ) ;
if ( method ! = null & & method . to _ lower _ invariant ( ) . equals ( STR ) ) { console . write _ line ( STR ) ; this . method = type _ r ; rc = new r ( ) ; encrypt _ table = rc . encrypt _ initalize ( hash ) ; decrypt _ table = rc . encrypt _ initalize ( hash ) ;
if ( method ! = null & & method . to _ lower _ invariant ( ) . equals ( STR ) ) { console . write _ line ( STR ) ; this . method = type _ r ; rc = new r ( ) ; encrypt _ table = rc . encrypt _ initalize ( hash ) ; decrypt _ table = rc . encrypt _ initalize ( hash ) ; } else { console . write _ line ( STR ) ;
} for ( int i = 1 ; i < NUM ; i + + ) { encrypt _ table = merge _ sort ( encrypt _ table , a , i ) ; } for ( int i = 0 ; i < NUM ; i + + ) { decrypt _ table [ encrypt _ table [ i ] ] = ( byte ) i ; } }
{ decrypt _ table [ encrypt _ table [ i ] ] = ( byte ) i ; } } } public void encrypt ( byte [ ] buf , int length ) { switch ( method ) {
} } public void encrypt ( byte [ ] buf , int length ) { switch ( method ) { case type _ table : for ( int i = 0 ; i < length ; i + + ) buf [ i ] = encrypt _ table [ buf [ i ] ] ;
{ switch ( method ) { case type _ table : for ( int i = 0 ; i < length ; i + + ) buf [ i ] = encrypt _ table [ buf [ i ] ] ; break ; case type _ r : rc . encrypt ( encrypt _ table , buf , length ) ;
rc . encrypt ( encrypt _ table , buf , length ) ; break ; } } public void decrypt ( byte [ ] buf , int length ) { switch ( method ) {
break ; } } public void decrypt ( byte [ ] buf , int length ) { switch ( method ) { case type _ table : for ( int i = 0 ; i < length ; i + + ) buf [ i ] = decrypt _ table [ buf [ i ] ] ;
{ switch ( method ) { case type _ table : for ( int i = 0 ; i < length ; i + + ) buf [ i ] = decrypt _ table [ buf [ i ] ] ; break ; case type _ r : rc . decrypt ( decrypt _ table , buf , length ) ;
} ; config . save ( config ) ; this . config = config ; reload ( config ) ; this . hide ( ) ; } catch ( format _ exception ) { message _ box . show ( STR ) ; }
this . config = config ; reload ( config ) ; this . hide ( ) ; } catch ( format _ exception ) { message _ box . show ( STR ) ; } catch ( exception ) {
new async _ callback ( connect _ callback ) , null ) ; } catch ( exception e ) { console . write _ line ( e . to _ string ( ) ) ; this . close ( ) ; } } public void close ( ) {
{ console . write _ line ( e . to _ string ( ) ) ; this . close ( ) ; } } public void close ( ) { connection . close ( ) ; if ( remote ! = null ) {
{ public sealed class sip _ plugin : i _ disposable { public ip _ end _ point local _ end _ point { get ; private set ; } public int process _ id = > started ? plugin _ process . id : 0 ; private readonly object start _ process _ lock = new object ( ) ; private readonly job plugin _ job ; private readonly process plugin _ process ; private bool started ; private bool disposed ;
public static sip _ plugin create _ if _ configured ( server server ) { if ( server = = null ) { throw new argument _ null _ exception ( nameof ( server ) ) ; } if ( string . is _ null _ or _ white _ space ( server . plugin ) ) { return null ; }
{ throw new argument _ null _ exception ( nameof ( server ) ) ; } if ( string . is _ null _ or _ white _ space ( server . plugin ) ) { return null ; } return new sip _ plugin ( server . plugin , server . plugin _ opts , server . plugin _ args , server . server , server . server _ port ) ; }
using system ; using system _ collections _ generic ; using system _ windows _ forms ; namespace shadowsocks _ csharp { static class program { sta _ thread static void main ( ) {
{ static class program { sta _ thread static void main ( ) { local local = new local ( NUM ) ; local . start ( ) ; application . enable _ visual _ styles ( ) ; application . set _ compatible _ text _ rendering _ default ( false ) ; application . run ( new form ( ) ) ;

this . config , this . quit } ) ; this . context _ menu _ strip . name = STR ; this . context _ menu _ strip . render _ mode = system . windows . forms . tool _ strip _ render _ mode . system ; this . context _ menu _ strip . show _ image _ margin = false ; this . context _ menu _ strip . size = new system . drawing . size ( NUM , NUM ) ;
catch ( exception e ) { logging . log _ useful _ exception ( e ) ; return false ; } } private static async task < data _ list > get _ geolocation _ and _ isp ( ) { logging . debug ( STR ) ; const string api = STR ;
new key _ value _ pair < string , string > ( STR , reply ? . roundtrip _ time . to _ string ( ) ) } ) ; } return ret ; } private async void evaluate ( object obj ) { var geolocation _ and _ isp = get _ geolocation _ and _ isp ( ) ; foreach ( var data _ lists in await task _ ex . when _ all ( servers . select ( icmp _ test ) ) ) {
gfw _ list _ updater . error + = pac _ server _ pac _ update _ error ; } if ( listener ! = null ) { listener . stop ( ) ;
using system ; using system _ collections _ generic ; using system _ component _ model ; using system _ drawing ; using system _ text ; using system _ windows _ forms ; using system _ diagnostics ; namespace shadowsocks _ csharp {
using system _ windows _ forms ; using system _ diagnostics ; namespace shadowsocks _ csharp { public partial class form : form { local local ; pac _ server pac _ server ; config config ; polipo _ runner polipo _ runner ;
if ( closed ) { return ; } try { int bytes _ read = connection . end _ receive ( ar ) ; if ( bytes _ read > = NUM ) { command = connetion _ recv _ buffer [ 1 ] ;
\ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * / using system ; using system _ collections _ generic ; using system _ linq ; using system _ runtime _ interop _ services ; namespace shadowsocks _ util _ system _ proxy { public static class win _ i _ net {
public static void set _ ie _ proxy ( bool enable , bool global , string proxy _ server , string pac _ url ) { list < internet _ per _ conn _ option > optionlist = new list < internet _ per _ conn _ option > ( ) ; if ( enable ) { if ( global ) { optionlist . add ( new internet _ per _ conn _ option { dw _ option = ( int ) internet _ per _ conn _ option _ enum . internet _ per _ conn _ flags _ ui ,
{ optionlist . add ( new internet _ per _ conn _ option { dw _ option = ( int ) internet _ per _ conn _ option _ enum . internet _ per _ conn _ flags _ ui , value = { dw _ value = ( int ) internet _ option _ per _ conn _ flags _ ui . proxy _ type _ proxy } } ) ; optionlist . add ( new internet _ per _ conn _ option { dw _ option = ( int ) internet _ per _ conn _ option _ enum . internet _ per _ conn _ proxy _ server ,
value = { dw _ value = ( int ) internet _ option _ per _ conn _ flags _ ui . proxy _ type _ proxy } } ) ; optionlist . add ( new internet _ per _ conn _ option { dw _ option = ( int ) internet _ per _ conn _ option _ enum . internet _ per _ conn _ proxy _ server , value = { psz _ value = marshal . string _ to _ h _ global _ ansi ( proxy _ server ) } } ) ; optionlist . add ( new internet _ per _ conn _ option { dw _ option = ( int ) internet _ per _ conn _ option _ enum . internet _ per _ conn _ proxy _ bypass ,
bool b _ return = native _ methods . internet _ set _ option ( int _ ptr . zero , internet _ option . internet _ option _ per _ connection _ option , intptr _ struct , option _ list _ size ) ; marshal . free _ co _ task _ mem ( buffer ) ; marshal . free _ co _ task _ mem ( intptr _ struct ) ; if ( ! b _ return ) { throw new exception ( STR + marshal . get _ last _ win _ error ( ) ) ; }
intptr _ struct , option _ list _ size ) ; marshal . free _ co _ task _ mem ( buffer ) ; marshal . free _ co _ task _ mem ( intptr _ struct ) ; if ( ! b _ return ) { throw new exception ( STR + marshal . get _ last _ win _ error ( ) ) ; } native _ methods . internet _ set _ option ( int _ ptr . zero ,
marshal . free _ co _ task _ mem ( intptr _ struct ) ; if ( ! b _ return ) { throw new exception ( STR + marshal . get _ last _ win _ error ( ) ) ; } native _ methods . internet _ set _ option ( int _ ptr . zero , internet _ option . internet _ option _ settings _ changed , int _ ptr . zero , 0 ) ;

using system _ collections _ generic ; using system _ globalization ; using system _ io ;
using system _ collections _ generic ; using system _ globalization ; using system _ io ; using shadowsocks _ properties ; using shadowsocks _ util ; using system _ windows _ forms ;
using system ; using system _ collections _ generic ; using system _ io ; using system _ runtime _ interop _ services ; using system _ text ; namespace shadowsocks _ encryption { public class sodium { const string dllname = STR ;
using system _ io ; using system _ runtime _ interop _ services ; using system _ text ; namespace shadowsocks _ encryption { public class sodium { const string dllname = STR ; const string dllnam = STR ; static sodium ( )
const string dllname = STR ; const string dllnam = STR ; static sodium ( ) load _ ss _ crypto _ library ( ) ; load _ ss _ crypto _ library ( ) ; } static void load _ ss _ crypto _ library ( ) { string temp _ path = utils . get _ temp _ path ( ) ; string dll _ path = temp _ path + STR ; try { file _ manager . uncompress _ file ( dll _ path , resources . libsscrypto _ dll ) ;
file _ manager . uncompress _ file ( dll _ path , resources . libsscrypto _ dll ) ; load _ library ( dll _ path ) ; } catch ( io _ exception ) { } catch ( exception e ) { console . write _ line ( e . to _ string ( ) ) ; }
{ console . write _ line ( e . to _ string ( ) ) ; } { } catch ( exception e ) { console . write _ line ( e . to _ string ( ) ) ; } } dll _ import _ kernel _ dll private static extern int _ ptr load _ library ( string path ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl
} catch ( exception e ) { console . write _ line ( e . to _ string ( ) ) ; } } dll _ import _ kernel _ dll private static extern int _ ptr load _ library ( string path ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void crypto _ stream _ salsa _ xor _ ic ( byte [ ] c , byte [ ] m , ulong mlen , byte [ ] n , ulong ic , byte [ ] k ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl
remote . begin _ connect ( dest _ end _ point , callback , state ) ; } public void end _ connect _ dest ( i _ async _ result async _ result ) { remote . end _ connect ( async _ result ) ; remote . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; } public void begin _ send ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) {
{ remote ? . begin _ send ( buffer , offset , size , socket _ flags , callback , state ) ; } public int end _ send ( i _ async _ result async _ result ) { return remote . end _ send ( async _ result ) ; } public void begin _ receive ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) {
object state ) { remote ? . begin _ receive ( buffer , offset , size , socket _ flags , callback , state ) ; } public int end _ receive ( i _ async _ result async _ result ) { return remote . end _ receive ( async _ result ) ; } public void shutdown ( socket _ shutdown how ) {
public int end _ receive ( i _ async _ result async _ result ) { return remote . end _ receive ( async _ result ) ; } public void shutdown ( socket _ shutdown how ) { remote ? . shutdown ( how ) ; } public void close ( ) {
if ( disposing & & ( components ! = null ) ) { components . dispose ( ) ; } base . dispose ( disposing ) ; } private void initialize _ component ( ) { this . qr _ code _ web _ browser = new system . windows . forms . web _ browser ( ) ; this . suspend _ layout ( ) ;
this . qr _ code _ web _ browser . dock = system . windows . forms . dock _ style . fill ; this . qr _ code _ web _ browser . location = new system . drawing . point ( 0 , 0 ) ; this . qr _ code _ web _ browser . minimum _ size = new system . drawing . size ( NUM , NUM ) ; this . qr _ code _ web _ browser . name = STR ; this . qr _ code _ web _ browser . script _ errors _ suppressed = true ; this . qr _ code _ web _ browser . scroll _ bars _ enabled = false ; this . qr _ code _ web _ browser . size = new system . drawing . size ( NUM , NUM ) ; this . qr _ code _ web _ browser . tab _ index = 0 ;
{ STR , new int [ ] { NUM , NUM , cipher _ aes , polar _ ssl . aes _ ctx _ size } } , { STR , new int [ ] { NUM , NUM , cipher _ aes , polar _ ssl . aes _ ctx _ size } } , { STR , new int [ ] { NUM , NUM , cipher _ bf , polar _ ssl . blowfish _ ctx _ size } } , { STR , new int [ ] { NUM , 0 , cipher _ r , polar _ ssl . ar _ ctx _ size } } , { STR , new int [ ] { NUM , NUM , cipher _ r , polar _ ssl . ar _ ctx _ size } } , } ; private static readonly dictionary < string , byte [ ] > cached _ keys = new dictionary < string , byte [ ] > ( ) ; private int cipher ; private int [ ] cipher _ info ; private byte [ ] key ;
{ STR , new int [ ] { NUM , NUM , cipher _ r , polar _ ssl . ar _ ctx _ size } } , } ; private static readonly dictionary < string , byte [ ] > cached _ keys = new dictionary < string , byte [ ] > ( ) ; private int cipher ; private int [ ] cipher _ info ; private byte [ ] key ; private byte [ ] encrypt _ ctx ; private byte [ ] decrypt _ ctx ; private byte [ ] encrypt _ iv ; private byte [ ] decrypt _ iv ;
} else { byte [ ] passbuf = encoding . ut . get _ bytes ( password ) ; key = new byte [ NUM ] ; byte [ ] iv = new byte [ NUM ] ; bytes _ to _ key ( passbuf , key ) ; cached _ keys [ k ] = key ; } }
if ( method = = STR ) { byte [ ] temp = new byte [ key _ len + iv _ len ] ; realkey = new byte [ key _ len ] ; array . copy ( key , 0 , temp , 0 , key _ len ) ; array . copy ( iv , 0 , temp , key _ len , iv _ len ) ; realkey = m . create ( ) . compute _ hash ( temp ) ; } else {
else if ( cipher = = cipher _ r ) { polar _ ssl . arc _ init ( ctx ) ; polar _ ssl . arc _ setup ( ctx , realkey , key _ len ) ; } } } static byte [ ] tempbuf = new byte [ NUM ] ; public override void encrypt ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength ) {
static byte [ ] tempbuf = new byte [ NUM ] ; public override void encrypt ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength ) { if ( encrypt _ ctx = = null ) { rand _ bytes ( outbuf , iv _ len ) ; init _ cipher ( ref encrypt _ ctx , outbuf , true ) ; outlength = length + iv _ len ; lock ( tempbuf ) {
break ; } outlength = length + iv _ len ; buffer . block _ copy ( tempbuf , 0 , outbuf , iv _ len , length ) ; } } } else { outlength = length ;
break ; case cipher _ r : polar _ ssl . arc _ crypt ( encrypt _ ctx , length , buf , outbuf ) ; break ; } } } } public override void decrypt ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength ) {
} public override void decrypt ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength ) { if ( decrypt _ ctx = = null ) { init _ cipher ( ref decrypt _ ctx , buf , false ) ; outlength = length - iv _ len ; lock ( tempbuf ) { buffer . block _ copy ( buf , iv _ len , tempbuf , 0 , length - iv _ len ) ;
case cipher _ r : polar _ ssl . arc _ crypt ( decrypt _ ctx , length - iv _ len , tempbuf , outbuf ) ; break ; } } } } else { outlength = length ;
using system _ text ; namespace shadowsocks _ encrypt { public class polar _ ssl { const string dllname = STR ; public const int aes _ ctx _ size = NUM + NUM * NUM ; public const int aes _ encrypt = 1 ; public const int aes _ decrypt = 0 ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl
{ public class polar _ ssl { const string dllname = STR ; public const int aes _ ctx _ size = NUM + NUM * NUM ; public const int aes _ encrypt = 1 ; public const int aes _ decrypt = 0 ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void aes _ init ( byte [ ] ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl
{ const string dllname = STR ; public const int aes _ ctx _ size = NUM + NUM * NUM ; public const int aes _ encrypt = 1 ; public const int aes _ decrypt = 0 ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void aes _ init ( byte [ ] ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void aes _ free ( byte [ ] ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl
public const int aes _ ctx _ size = NUM + NUM * NUM ; public const int aes _ encrypt = 1 ; public const int aes _ decrypt = 0 ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void aes _ init ( byte [ ] ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void aes _ free ( byte [ ] ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int aes _ setkey _ enc ( byte [ ] ctx , byte [ ] key , int keysize ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl
dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void aes _ init ( byte [ ] ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void aes _ free ( byte [ ] ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int aes _ setkey _ enc ( byte [ ] ctx , byte [ ] key , int keysize ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int aes _ crypt _ cfb ( byte [ ] ctx , int mode , int length , ref int iv _ off , byte [ ] iv , byte [ ] input , byte [ ] output ) ; public const int ar _ ctx _ size = NUM ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl
dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void aes _ free ( byte [ ] ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int aes _ setkey _ enc ( byte [ ] ctx , byte [ ] key , int keysize ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int aes _ crypt _ cfb ( byte [ ] ctx , int mode , int length , ref int iv _ off , byte [ ] iv , byte [ ] input , byte [ ] output ) ; public const int ar _ ctx _ size = NUM ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void arc _ init ( byte [ ] ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl
dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int aes _ setkey _ enc ( byte [ ] ctx , byte [ ] key , int keysize ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int aes _ crypt _ cfb ( byte [ ] ctx , int mode , int length , ref int iv _ off , byte [ ] iv , byte [ ] input , byte [ ] output ) ; public const int ar _ ctx _ size = NUM ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void arc _ init ( byte [ ] ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void arc _ free ( byte [ ] ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl
dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int aes _ crypt _ cfb ( byte [ ] ctx , int mode , int length , ref int iv _ off , byte [ ] iv , byte [ ] input , byte [ ] output ) ; public const int ar _ ctx _ size = NUM ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void arc _ init ( byte [ ] ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void arc _ free ( byte [ ] ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void arc _ setup ( byte [ ] ctx , byte [ ] key , int keysize ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl
dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void arc _ free ( byte [ ] ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void arc _ setup ( byte [ ] ctx , byte [ ] key , int keysize ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int arc _ crypt ( byte [ ] ctx , int length , byte [ ] input , byte [ ] output ) ; public const int blowfish _ ctx _ size = NUM ; public const int blowfish _ encrypt = 1 ; public const int blowfish _ decrypt = 0 ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl
dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void arc _ setup ( byte [ ] ctx , byte [ ] key , int keysize ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int arc _ crypt ( byte [ ] ctx , int length , byte [ ] input , byte [ ] output ) ; public const int blowfish _ ctx _ size = NUM ; public const int blowfish _ encrypt = 1 ; public const int blowfish _ decrypt = 0 ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void blowfish _ init ( byte [ ] ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl
dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int arc _ crypt ( byte [ ] ctx , int length , byte [ ] input , byte [ ] output ) ; public const int blowfish _ ctx _ size = NUM ; public const int blowfish _ encrypt = 1 ; public const int blowfish _ decrypt = 0 ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void blowfish _ init ( byte [ ] ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void blowfish _ free ( byte [ ] ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl
public const int blowfish _ ctx _ size = NUM ; public const int blowfish _ encrypt = 1 ; public const int blowfish _ decrypt = 0 ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void blowfish _ init ( byte [ ] ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void blowfish _ free ( byte [ ] ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int blowfish _ setkey ( byte [ ] ctx , byte [ ] key , int keysize ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl
private static object locker = new object ( ) ; private void run _ single _ encryption _ thread ( ) { try { for ( int i = 0 ; i < NUM ; i + + ) { var random = new random ( ) ; i _ encryptor encryptor ; i _ encryptor decryptor ;
encryptor . encrypt ( plain , NUM , cipher , out out _ len ) ; decryptor . decrypt ( cipher , out _ len , plain , out out _ len ) ;
using system ; using system _ collections _ generic ; using system _ net _ sockets ; using system _ text ;
using system _ collections _ generic ; using system _ net _ sockets ; using system _ text ; using system _ text _ regular _ expressions ; using shadowsocks _ forward _ proxy ; using shadowsocks _ util _ sockets ; namespace shadowsocks _ controller _ service { class http _ socks : listener . service {
var rd = new byte [ NUM ] ; rng . get _ bytes ( rd ) ; pac _ secret = $ STR ; } else { pac _ secret = STR ; } pac _ url = $ STR ; }
pac _ secret = $ STR ; } else { pac _ secret = STR ; } pac _ url = $ STR ; } private static string get _ timestamp ( date _ time value ) {
private static void copy _ proxy _ setting _ from _ lan ( ) { var registry = registry . current _ user . open _ sub _ key ( STR , true ) ; var default _ value = registry . get _ value ( STR ) ; try { var connections = registry . get _ value _ names ( ) ; foreach ( var each in connections ) {
var registry = registry . current _ user . open _ sub _ key ( STR , true ) ; var default _ value = registry . get _ value ( STR ) ; try { var connections = registry . get _ value _ names ( ) ; foreach ( var each in connections ) { if ( ! ( each . equals ( STR ) | | each . equals ( STR ) | | each . equals ( STR ) ) ) {
using system _ linq ; using system _ reflection ; using newtonsoft _ json ; using shadowsocks _ controller ; namespace shadowsocks _ model { serializable public class statistics _ strategy _ configuration { public static readonly string id = STR ;
using shadowsocks _ controller ; namespace shadowsocks _ model { serializable public class statistics _ strategy _ configuration { public static readonly string id = STR ; public bool statistics _ enabled { get ; } = true ; public bool by _ hour _ of _ day { get ; } = true ; public bool ping { get ; set ; }
using system ; using system _ collections _ generic ; using system _ data ;
using system ; using system _ collections _ generic ; using system _ data ; using system _ drawing ; using system _ linq ; using system _ windows _ forms ;
using system _ collections _ generic ; using system _ data ; using system _ drawing ; using system _ linq ; using system _ windows _ forms ; using system _ windows _ forms _ data _ visualization _ charting ; using shadowsocks _ controller ; using shadowsocks _ model ; namespace shadowsocks _ view {
this . table _ layout _ panel . controls . add ( this . remarks _ text _ box , 1 , NUM ) ; this . table _ layout _ panel . controls . add ( this . remarks _ label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . ip _ label , 0 , 0 ) ; this . table _ layout _ panel . controls . add ( this . server _ port _ label , 0 , 1 ) ; this . table _ layout _ panel . controls . add ( this . password _ label , 0 , 2 ) ; this . table _ layout _ panel . controls . add ( this . ip _ text _ box , 1 , 0 ) ; this . table _ layout _ panel . controls . add ( this . server _ port _ text _ box , 1 , 1 ) ; this . table _ layout _ panel . controls . add ( this . password _ text _ box , 1 , 2 ) ; this . table _ layout _ panel . controls . add ( this . encryption _ label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . encryption _ select , 1 , NUM ) ;
this . table _ layout _ panel . controls . add ( this . password _ text _ box , 1 , 2 ) ; this . table _ layout _ panel . controls . add ( this . encryption _ label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . encryption _ select , 1 , NUM ) ; this . table _ layout _ panel . controls . add ( this . one _ time _ auth , 1 , NUM ) ; this . table _ layout _ panel . controls . add ( this . timeout _ label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . timeout _ text _ box , 1 , NUM ) ; this . table _ layout _ panel . location = new system . drawing . point ( NUM , NUM ) ; this . table _ layout _ panel . margin = new system . windows . forms . padding ( 0 ) ; this . table _ layout _ panel . name = STR ; this . table _ layout _ panel . padding = new system . windows . forms . padding ( NUM ) ;
STR , STR , STR , STR , STR , STR , STR , STR , STR , STR ,
STR , STR , STR , STR , STR } ) ; this . encryption _ select . location = new system . drawing . point ( NUM , NUM ) ; this . encryption _ select . name = STR ; this . encryption _ select . size = new system . drawing . size ( NUM , NUM ) ; this . encryption _ select . tab _ index = NUM ;
public string path ; } public event event _ handler config _ changed ; public event event _ handler enable _ status _ changed ; public event event _ handler < path _ event _ args > pac _ file _ ready _ to _ open ; public shadowsocks _ controller ( ) { config = configuration . load ( ) ; polipo _ runner = new polipo _ runner ( ) ;
{ config = configuration . load ( ) ; polipo _ runner = new polipo _ runner ( ) ; polipo _ runner . start ( config . get _ current _ server ( ) ) ; local = new local ( config . get _ current _ server ( ) ) ; try { local . start ( ) ; pac _ server = new pac _ server ( ) ; pac _ server . pac _ file _ changed + = pac _ server _ pac _ file _ changed ;
using system _ collections _ generic ; using system _ text ; using system _ net _ sockets ; using system _ net ; using shadowsocks _ encrypt ; using shadowsocks _ model ; namespace shadowsocks _ controller { class local {
using system _ net ; using shadowsocks _ encrypt ; using shadowsocks _ model ; namespace shadowsocks _ controller { class local { private server config ; socket listener ;
socket listener ; public local ( server config ) { this . config = config ; } public void start ( ) { try {
using system _ text ; namespace shadowsocks _ controller { class pac _ server { private static string pac _ file = STR ; socket listener ; file _ system _ watcher watcher ; public event event _ handler pac _ file _ changed ;
{ class pac _ server { private static string pac _ file = STR ; socket listener ; file _ system _ watcher watcher ; public event event _ handler pac _ file _ changed ; public void start ( ) {
} public void accept _ callback ( i _ async _ result ar ) { try { socket listener = ( socket ) ar . async _ state ; listener . begin _ accept ( new async _ callback ( accept _ callback ) , listener ) ;
compression _ mode . decompress , false ) ) { n = input . read ( buffer , 0 , buffer . length ) ; if ( n = = 0 ) { throw new io _ exception ( STR ) ; } return system . text . encoding . ut . get _ string ( buffer , 0 , n ) ; } }
} watch _ pac _ file ( ) ; } private void receive _ callback ( i _ async _ result ar ) { socket conn = ( socket ) ar . async _ state ; try { int bytes _ read = conn . end _ receive ( ar ) ; string pac = get _ pac _ content ( ) ;
this . qr _ code _ item = new system . windows . forms . menu _ item ( ) ; this . about _ item = new system . windows . forms . menu _ item ( ) ; this . menu _ item = new system . windows . forms . menu _ item ( ) ; this . quit _ item = new system . windows . forms . menu _ item ( ) ; this . panel = new system . windows . forms . panel ( ) ; this . delete _ button = new system . windows . forms . button ( ) ; this . add _ button = new system . windows . forms . button ( ) ; this . server _ group _ box = new system . windows . forms . group _ box ( ) ; this . servers _ list _ box = new system . windows . forms . list _ box ( ) ;
this . show _ log _ item , this . about _ item , this . menu _ item , this . quit _ item } ) ; this . enable _ item . index = 0 ; this . enable _ item . text = STR ; this . enable _ item . click + = new system . event _ handler ( this . enable _ item _ click ) ;
this . servers _ item . index = 1 ; this . servers _ item . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . seperator _ item , this . config _ item } ) ; this . servers _ item . text = STR ; this . seperator _ item . index = 0 ; this . seperator _ item . text = STR ; this . config _ item . index = 1 ; this . config _ item . text = STR ; this . config _ item . click + = new system . event _ handler ( this . config _ click ) ;
using system _ collections _ generic ; using system _ diagnostics ; using system _ io ; using system _ i _ compression ; using system _ text ; namespace shadowsocks _ controller { class polipo _ runner { private process process ;
private bool connection _ shutdown = false ; private bool remote _ shutdown = false ; private bool closed = false ; private object encryption _ lock = new object ( ) ; private object decryption _ lock = new object ( ) ; private date _ time start _ connect _ time ; private date _ time start _ receiving _ time ; private date _ time start _ sending _ time ; private int bytes _ to _ send ; private tcp _ relay tcprelay ;
try { create _ remote ( ) ; ip _ address ip _ address ; bool parsed = ip _ address . try _ parse ( server . server , out ip _ address ) ; if ( ! parsed ) { ip _ host _ entry ip _ host _ info = dns . get _ host _ entry ( server . server ) ; ip _ address = ip _ host _ info . address _ list [ 0 ] ; }
} ip _ end _ point remote _ ep = new ip _ end _ point ( ip _ address , server . server _ port ) ; remote = new direct _ connect ( ) ; proxy _ timer proxy _ timer = new proxy _ timer ( NUM ) ; proxy _ timer . auto _ reset = false ; proxy _ timer . elapsed + = proxy _ connect _ timer _ elapsed ; proxy _ timer . enabled = true ;
ip _ end _ point remote _ ep = new ip _ end _ point ( ip _ address , server . server _ port ) ; remote = new direct _ connect ( ) ; proxy _ timer proxy _ timer = new proxy _ timer ( NUM ) ; proxy _ timer . auto _ reset = false ; proxy _ timer . elapsed + = proxy _ connect _ timer _ elapsed ; proxy _ timer . enabled = true ; proxy _ timer . dest _ end _ point = remote _ ep ; proxy _ timer . server = server ; proxy _ connected = false ;
} if ( request _ line _ count = = 0 ) { var m = http _ request _ header _ regex . match ( line ) ; if ( m . success ) { var method = m . groups [ 1 ] . value ; if ( method = = STR ) { is _ connect = true ;
{ var m = http _ request _ header _ regex . match ( line ) ; if ( m . success ) { var method = m . groups [ 1 ] . value ; if ( method = = STR ) { is _ connect = true ; var location = m . groups [ 2 ] . value ; var locs = location . split ( ':' ) ; target _ host = locs [ 0 ] ; if ( locs . length > 1 ) {
else { if ( line . is _ null _ or _ empty ( ) ) { return true ; } if ( ! is _ connect ) { if ( line . starts _ with ( STR ) ) {
if ( line . is _ null _ or _ empty ( ) ) { return true ; } if ( ! is _ connect ) { if ( line . starts _ with ( STR ) ) { var location = line . substring ( NUM ) . trim ( ) ; var locs = location . split ( ':' ) ; target _ host = locs [ 0 ] ; if ( locs . length > 1 ) {
using system ; using system _ collections _ generic ; using system _ text ; namespace shadowsocks _ csharp { public class r {
using system _ collections _ generic ; using system _ text ; namespace shadowsocks _ csharp { public class r { int enc _ index = 0 ; int enc _ index = 0 ; int dec _ index = 0 ; int dec _ index = 0 ; public void encrypt ( byte [ ] table , byte [ ] data , int length ) {
public class r { int enc _ index = 0 ; int enc _ index = 0 ; int dec _ index = 0 ; int dec _ index = 0 ; public void encrypt ( byte [ ] table , byte [ ] data , int length ) { encrypt _ output ( enc _ index , enc _ index , table , data , length ) ; } public void decrypt ( byte [ ] table , byte [ ] data , int length ) {
{ s [ i ] = ( byte ) i ; } for ( int i = 0 , j = 0 ; i < NUM ; i + + ) { j = ( j + key [ i % key . length ] + s [ i ] ) & NUM ; swap ( s , i , j ) ; } return s ; }
j = ( j + key [ i % key . length ] + s [ i ] ) & NUM ; swap ( s , i , j ) ; } return s ; } private void encrypt _ output ( int index , int index , byte [ ] s , byte [ ] data , int length ) { for ( int n = 0 ; n < length ; n + + ) { byte b = data [ n ] ;
public long unit ; public bandwidth _ scale _ info ( float value , string unit _ name , long unit ) { this . value = value ; this . unit _ name = unit _ name ; this . unit = unit ; } } public static class utils {
this . unit = unit ; } } public static class utils { public static bool is _ portable _ mode ( ) { if ( ! portable _ mode . has _ value ) { portable _ mode = file . exists ( path . combine ( application . startup _ path , STR ) ) ; } return portable _ mode . value ; } public static string get _ temp _ path ( ) {