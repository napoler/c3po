                runKey = Microsoft.Win32.Registry.CurrentUser.OpenSubKey(@"Software\Microsoft\Windows\CurrentVersion\Run", true);
                    runKey.SetValue(Key, path);
                    runKey.DeleteValue(Key);

                runKey = Microsoft.Win32.Registry.CurrentUser.OpenSubKey(@"Software\Microsoft\Windows\CurrentVersion\Run", true);

                    if (item.Equals(Key))

                try\n                {\n                    _pluginProcess.Start();\n                }\n                catch (System.ComponentModel.Win32Exception ex)\n                {\n                    // do not use File.Exists(...), it can not handle the scenarios when the plugin file is in system environment path.\n                    if ((uint)ex.ErrorCode == 0x80004005)   // file not found\n                    {\n                        throw new FileNotFoundException(I18N.GetString("Cannot find the plugin program file"), _pluginProcess.StartInfo.FileName, ex);\n                    }\n                }
﻿using Newtonsoft.Json;\nusing Shadowsocks.Controller;\nusing Shadowsocks.Model;\nusing Shadowsocks.Properties;\nusing System;

                    try\n                    {\n                        process.Start();\n                        process.BeginErrorReadLine();\n                        process.BeginOutputReadLine();\n                        process.WaitForExit();\n                    }\n                    catch (System.ComponentModel.Win32Exception e)\n                    {\n                        // log the arguements\n                        throw new ProxyException(ProxyExceptionType.FailToRun, process.StartInfo.Arguments, e);\n                    }
                        throw new ProxyException(ProxyExceptionType.SysproxyExitError, stderr);
                            throw new ProxyException(ProxyExceptionType.QueryReturnEmpty);

            this.tableLayoutPanel1.Controls.Add(this.PluginArgumentsTextBox, 1, 8);\n            this.tableLayoutPanel1.Controls.Add(this.PluginArgumentsLabel, 0, 8);\n            this.tableLayoutPanel1.Controls.Add(this.RemarksLabel, 0, 10);\n            this.tableLayoutPanel1.Controls.Add(this.UsePluginArgCheckBox, 1, 7);
            this.tableLayoutPanel1.RowCount = 12;\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.Size = new System.Drawing.Size(279, 292);
            this.ServerGroupBox = new System.Windows.Forms.GroupBox();

        public void Start(bool regHotkeys = true)
            if (regHotkeys)\n            {\n                HotkeyReg.RegAllHotkeys();\n            }

            MbedTLS.md5(input, (uint)input.Length, output);
        public extern static void md5(byte[] input, uint ilen, byte[] output);
﻿using Shadowsocks.Encryption;\nusing Shadowsocks.Model;\nusing Shadowsocks.Util;\nusing System;

﻿using System;
        ShadowsocksController controller;\n        public LogForm(ShadowsocksController controller, string filename)\n        {\n            this.controller = controller;
            LogViewerConfig config = controller.GetConfigurationCopy().logViewer;\n            if (config == null)\n                config = new LogViewerConfig();\n            topMostTrigger = config.topMost;\n            wrapTextTrigger = config.wrapText;\n            toolbarTrigger = config.toolbarShown;\n            LogMessageTextBox.BackColor = config.GetBackgroundColor();\n            LogMessageTextBox.ForeColor = config.GetTextColor();\n            LogMessageTextBox.Font = config.GetFont();
                    connection.BeginReceive(_connetionRecvBuffer, 0, RecvSize, SocketFlags.None, new AsyncCallback(ReadAll), null);
                        connection.BeginReceive(_connetionRecvBuffer, 0, RecvSize, SocketFlags.None, new AsyncCallback(ReadAll), null);
            //\n            // modeMenu\n            //\n            this.modeItem.Index = 1;\n            this.modeItem.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {\n            this.PACModeItem,\n            this.globalModeItem});\n            this.modeItem.Text = "Mode";\n            //\n            // PACModeItem\n            //\n            this.PACModeItem.Index = 0;\n            this.PACModeItem.Text = "PAC";\n            this.PACModeItem.Click += new System.EventHandler(this.PACModeItem_Click);\n            //\n            // globalModeItem\n            //\n            this.globalModeItem.Index = 1;\n            this.globalModeItem.Text = "Global";\n            this.globalModeItem.Click += new System.EventHandler(this.GlobalModeItem_Click);
            // menuItem1\n            // \n            this.menuItem1.Index = 3;\n            this.menuItem1.Text = "-";\n            // \n            // AutoStartupItem\n            // \n            this.AutoStartupItem.Index = 4;\n            this.AutoStartupItem.Text = "Start on Boot";\n            this.AutoStartupItem.Click += new System.EventHandler(this.AutoStartupItem_Click);\n            // \n            // ShareOverLANItem\n            // \n            this.ShareOverLANItem.Index = 5;\n            this.ShareOverLANItem.Text = "Share over LAN";\n            this.ShareOverLANItem.Click += new System.EventHandler(this.ShareOverLANItem_Click);
        public static void Enable(bool global)
                if (global)\n                {\n                    registry.SetValue("ProxyEnable", 1);\n                    registry.SetValue("ProxyServer", "127.0.0.1:8123");\n                    registry.SetValue("AutoConfigURL", "");\n                }\n                else\n                {\n                    registry.SetValue("ProxyEnable", 0);\n                    registry.SetValue("ProxyServer", "");\n                    registry.SetValue("AutoConfigURL", "http://127.0.0.1:8093/pac?t=" + GetTimestamp(DateTime.Now));\n                }
        public static void NotifyIE()
            registry.SetValue("ProxyEnable", 0);\n            registry.SetValue("ProxyServer", "");\n            registry.SetValue("AutoConfigURL", "http://127.0.0.1:8090/pac");\n            SystemProxy.NotifyIE();
            registry.SetValue("AutoConfigURL", "");\n            SystemProxy.NotifyIE();


            var serverUrls = ssURL.Split('\r', '\n');
            foreach (string serverUrl in serverUrls)
                if (string.IsNullOrWhiteSpace(serverUrl))
                    continue;
                Uri parsedUrl;\n                try\n                {\n                    parsedUrl = new Uri(serverUrl);\n                }\n                catch (UriFormatException)\n                {
                }\n                Server tmp = new Server\n                {\n                    remarks = parsedUrl.GetComponents(UriComponents.Fragment, UriFormat.Unescaped)\n                };\n                string possiblyUnpaddedBase64 = parsedUrl.GetComponents(UriComponents.UserInfo, UriFormat.Unescaped);\n                bool isOldFormatUrl = possiblyUnpaddedBase64.Length == 0;\n                if (isOldFormatUrl)\n                {\n                    int prefixLength = "ss://".Length;\n                    int indexOfHashOrSlash = serverUrl.LastIndexOfAny(\n                        new[] { '/', '#' },\n                        serverUrl.Length - 1,\n                        serverUrl.Length - prefixLength);\n                    int substringLength = serverUrl.Length - prefixLength;\n                    if (indexOfHashOrSlash >= 0)\n                    {\n                        substringLength = indexOfHashOrSlash - prefixLength;\n                    }\n                    possiblyUnpaddedBase64 = serverUrl.Substring(prefixLength, substringLength).TrimEnd('/');\n                }\n                else\n                {\n                    // Web-safe base64 to normal base64\n                    possiblyUnpaddedBase64 = possiblyUnpaddedBase64.Replace('-', '+').Replace('_', '/');\n                }\n                string base64 = possiblyUnpaddedBase64.PadRight(\n                    possiblyUnpaddedBase64.Length + (4 - possiblyUnpaddedBase64.Length % 4) % 4,\n                    '=');\n                string innerUserInfoOrUrl = Encoding.UTF8.GetString(Convert.FromBase64String(base64));\n                string userInfo;\n                if (isOldFormatUrl)\n                {\n                    Uri innerUrl = new Uri("inner://" + innerUserInfoOrUrl);\n                    userInfo = innerUrl.GetComponents(UriComponents.UserInfo, UriFormat.Unescaped);\n                    tmp.server = innerUrl.GetComponents(UriComponents.Host, UriFormat.Unescaped);\n                    tmp.server_port = innerUrl.Port;\n                }\n                else\n                {\n                    userInfo = innerUserInfoOrUrl;\n                    tmp.server = parsedUrl.GetComponents(UriComponents.Host, UriFormat.Unescaped);\n                    tmp.server_port = parsedUrl.Port;\n                }\n                string[] userInfoParts = userInfo.Split(new[] { ':' }, 2);\n                if (userInfoParts.Length != 2)\n                {\n                    continue;\n                }\n                tmp.method = userInfoParts[0];\n                tmp.password = userInfoParts[1];\n                NameValueCollection queryParameters = HttpUtility.ParseQueryString(parsedUrl.Query);\n                string[] pluginParts = HttpUtility.UrlDecode(queryParameters["plugin"] ?? "").Split(new[] { ';' }, 2);\n                if (pluginParts.Length > 0)\n                {\n                    tmp.plugin = pluginParts[0] ?? "";\n                }\n                if (pluginParts.Length > 1)\n                {\n                    tmp.plugin_opts = pluginParts[1] ?? "";\n                }
            this.tableLayoutPanel1.Controls.Add(this.PluginOptionsLabel, 0, 5);\n            this.tableLayoutPanel1.Controls.Add(this.PluginTextBox, 1, 4);\n            this.tableLayoutPanel1.Controls.Add(this.RemarksTextBox, 1, 7);\n            this.tableLayoutPanel1.Controls.Add(this.RemarksLabel, 0, 7);
            this.tableLayoutPanel1.Controls.Add(this.TimeoutLabel, 0, 8);\n            this.tableLayoutPanel1.Controls.Add(this.TimeoutTextBox, 1, 8);\n            this.tableLayoutPanel1.Controls.Add(this.PluginLabel, 0, 4);\n            this.tableLayoutPanel1.Controls.Add(this.PluginOptionsTextBox, 1, 5);
            this.tableLayoutPanel1.RowCount = 9;\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.Size = new System.Drawing.Size(253, 215);
            //socketsHttpHandler = new SocketsHttpHandler();\n            //httpClient = new HttpClient(socketsHttpHandler);\n            if (File.Exists(DATABASE_PATH) && new FileInfo(DATABASE_PATH).Length > 0)\n            {\n                geositeDB = File.ReadAllBytes(DATABASE_PATH);\n            }\n            else\n            {\n                geositeDB = Resources.dlc_dat;
        /// <summary>\n        /// load new GeoSite data from geositeDB\n        /// </summary>\n        static void LoadGeositeList()\n        {\n            var list = GeositeList.Parser.ParseFrom(geositeDB);
        public static async Task UpdatePACFromGeosite()
            // use System.Net.Http.HttpClient to download GeoSite db.\n            // NASTY workaround: new HttpClient every update\n            // because we can't change proxy on existing socketsHttpHandler instance\n            httpClientHandler = new HttpClientHandler();\n            httpClient = new HttpClient(httpClientHandler);
                httpClientHandler.Proxy = new WebProxy(
            try\n            {\n                // download checksum first\n                var geositeSha256sum = await httpClient.GetStringAsync(geositeSha256sumUrl);\n                geositeSha256sum = geositeSha256sum.Substring(0, 64).ToUpper();\n                logger.Info($"Got Sha256sum: {geositeSha256sum}");\n                // compare downloaded checksum with local geositeDB\n                byte[] localDBHashBytes = mySHA256.ComputeHash(geositeDB);\n                string localDBHash = BitConverter.ToString(localDBHashBytes).Replace("-", String.Empty);\n                logger.Info($"Local Sha256sum: {localDBHash}");\n                // if already latest\n                if (geositeSha256sum == localDBHash)\n                {\n                    logger.Info("Local GeoSite DB is already the latest.");\n                    return;\n                }\n                // not latest. download new DB\n                var downloadedBytes = await httpClient.GetByteArrayAsync(geositeUrl);\n                // verify sha256sum\n                byte[] downloadedDBHashBytes = mySHA256.ComputeHash(downloadedBytes);\n                string downloadedDBHash = BitConverter.ToString(downloadedDBHashBytes).Replace("-", String.Empty);\n                logger.Info($"Actual Sha256sum: {downloadedDBHash}");\n                if (geositeSha256sum != downloadedDBHash)\n                {\n                    logger.Info("Sha256sum mismatch. Updating aborted.");\n                    throw new Exception("Sha256sum mismatch");\n                }\n                else\n                {\n                    logger.Info("Sha256sum verification successful.");\n                }\n                // write to geosite file\n                using (FileStream geositeFileStream = File.Create(DATABASE_PATH))\n                    await geositeFileStream.WriteAsync(downloadedBytes, 0, downloadedBytes.Length);\n                // update stuff\n                geositeDB = downloadedBytes;\n                LoadGeositeList();\n                bool pacFileChanged = MergeAndWritePACFile(group, blacklist);\n                UpdateCompleted?.Invoke(null, new GeositeResultEventArgs(pacFileChanged));\n            }\n            catch (Exception ex)\n            {\n                Error?.Invoke(null, new ErrorEventArgs(ex));\n            }\n            finally\n            {\n                if (httpClientHandler != null)\n                {\n                    httpClientHandler.Dispose();\n                    httpClientHandler = null;\n                }\n                if (httpClient != null)\n                {\n                    httpClient.Dispose();\n                    httpClient = null;\n                }\n            }
        private ShadowsocksController controller;\n        // this is a copy of configuration that we are working on\n        private Configuration modifiedConfiguration;\n        private int oldSelectedIndex = -1;
            loadCurrentConfiguration();
            loadCurrentConfiguration();
            enableItem.Checked = controller.GetConfiguration().enabled;
        private bool saveOldSelectedServer()
            try\n            {\n                if (oldSelectedIndex == -1 || oldSelectedIndex >= modifiedConfiguration.configs.Count)\n                {\n                    return true;\n                }\n                Server server = new Server\n                {\n                    server = IPTextBox.Text,\n                    server_port = int.Parse(ServerPortTextBox.Text),\n                    password = PasswordTextBox.Text,\n                    local_port = int.Parse(ProxyPortTextBox.Text),\n                    method = EncryptionSelect.Text\n                };\n                Configuration.CheckServer(server);\n                modifiedConfiguration.configs[oldSelectedIndex] = server;\n                return true;\n            }\n            catch (FormatException)\n            {\n                MessageBox.Show("illegal port number format");\n            }\n            catch (Exception ex)\n            {\n                MessageBox.Show(ex.Message);\n            }\n            return false;\n        }\n        private void loadSelectedServer()\n        {\n            Server server = modifiedConfiguration.configs[ServersListBox.SelectedIndex];

        private void loadCurrentConfiguration()\n        {\n            modifiedConfiguration = controller.GetConfiguration();\n            ServersListBox.Items.Clear();\n            foreach (Server server in modifiedConfiguration.configs)\n            {\n                ServersListBox.Items.Add(server.server);\n            }\n            ServersListBox.SelectedIndex = modifiedConfiguration.index;\n            oldSelectedIndex = ServersListBox.SelectedIndex;\n            enableItem.Checked = modifiedConfiguration.enabled;\n        }\n        private void ConfigForm_Load(object sender, EventArgs e)
            // TODO\n            Configuration config = controller.GetConfiguration();\n            controller.SaveConfig(config);\n            this.Hide();
            loadCurrentConfiguration();

            this.ProxyPortTextBox = new System.Windows.Forms.TextBox();\n            this.label4 = new System.Windows.Forms.Label();

            this.label5 = new System.Windows.Forms.Label();\n            this.EncryptionSelect = new System.Windows.Forms.ComboBox();



                    using (File.Create(path))
                        //do nothing

        public LineReader(byte[] buffer, WrappedSocket socket, byte[] firstPackge, int index, int length,
            Encoding encoding, string delimiter,
            if (buffer.Length < length)
                throw new ArgumentException("Line buffer length can't less than first package length!", nameof(buffer));
            if (buffer.Length < _delimiterBytes.Length)
                throw new ArgumentException("Too small!", nameof(buffer));
            _lineBuffer = buffer;
                if (buffer == firstPackge)\n                {\n                    _bufferDataIndex = index;\n                }\n                else\n                {\n                    Array.Copy(firstPackge, index, _lineBuffer, 0, length);\n                }
                socket.BeginReceive(_lineBuffer, 0, _lineBuffer.Length, 0, ReceiveCallback, 0);
        public LineReader(int maxLineBytes, WrappedSocket socket, Func<string, object, bool> onLineRead,\n            Action<Exception, object> onException, Action<byte[], int, int, object> onFinish, Encoding encoding,\n            string delimiter, object state)\n            : this(\n                new byte[maxLineBytes], socket, null, 0, 0, onLineRead, onException, onFinish, encoding, delimiter,\n                state)
            byte[] request = null;\n            byte atyp = 0;\n            int port;\n            var dep = destEndPoint as DnsEndPoint;\n            if (dep != null)\n            {\n                // is a domain name, we will leave it to server\n                atyp = 3; // DOMAINNAME\n                var enc = Encoding.UTF8;\n                var hostByteCount = enc.GetByteCount(dep.Host);\n                request = new byte[4 + 1/*length byte*/ + hostByteCount + 2];\n                request[4] = (byte)hostByteCount;\n                enc.GetBytes(dep.Host, 0, dep.Host.Length, request, 5);\n                port = dep.Port;\n            }\n            else\n            {\n                switch (DestEndPoint.AddressFamily)\n                {\n                    case AddressFamily.InterNetwork:\n                        request = new byte[4 + 4 + 2];\n                        atyp = 1; // IP V4 address\n                        break;\n                    case AddressFamily.InterNetworkV6:\n                        request = new byte[4 + 16 + 2];\n                        atyp = 4; // IP V6 address\n                        break;\n                    default:\n                        throw new Exception(I18N.GetString("Proxy request failed"));\n                }\n                port = ((IPEndPoint) DestEndPoint).Port;\n                var addr = ((IPEndPoint)DestEndPoint).Address.GetAddressBytes();\n                Array.Copy(addr, 0, request, 4, request.Length - 4 - 2);\n            }
namespace Shadowsocks.Controller
        public ISet<TCPHandler> Handlers { get; set; }

            if (socket.ProtocolType != ProtocolType.Tcp\n                || (length < 2 || firstPacket[0] != 5))

    class TCPHandler
        class AsyncSession
        class AsyncSession<T> : AsyncSession
        private ShadowsocksController   _controller;\n        private Configuration           _config;\n        private TCPRelay                _tcprelay;\n        private Socket                  _connection;\n        private IEncryptor  _encryptor;\n        private Server      _server;
        private bool        _proxyConnected;\n        private bool        _destConnected;\n        private byte    _command;\n        private byte[]  _firstPacket;\n        private int     _firstPacketLength;\n        private int     _totalRead = 0;\n        private int     _totalWrite = 0;\n        private byte[]  _remoteRecvBuffer = new byte[BufferSize];\n        private byte[]  _remoteSendBuffer = new byte[BufferSize];\n        private byte[]  _connetionRecvBuffer = new byte[BufferSize];\n        private byte[]  _connetionSendBuffer = new byte[BufferSize];\n        private bool    _connectionShutdown = false;\n        private bool    _remoteShutdown = false;\n        private bool    _closed = false;\n        // instance-based lock without static\n        private readonly object  _encryptionLock = new object();\n        private readonly object  _decryptionLock = new object();\n        private readonly object  _closeConnLock = new object();
        public TCPHandler(ShadowsocksController controller, Configuration config, TCPRelay tcprelay, Socket socket)
        }\n        public void CreateRemote()\n        {\n            Server server = _controller.GetAServer(IStrategyCallerType.TCP, (IPEndPoint)_connection.RemoteEndPoint, _destEndPoint);
        private void StartPipe(AsyncSession session)\n        {\n            if (_closed) return;
                session.Remote.BeginReceive(_remoteRecvBuffer, 0, RecvSize, SocketFlags.None, new AsyncCallback(PipeRemoteReceiveCallback), session);\n                SendToServer(_firstPacketLength, session);

            session.Remote.BeginSend(_connetionSendBuffer, 0, bytesToSend, SocketFlags.None, new AsyncCallback(PipeRemoteSendCallback), session);

            if (_closed) return;\n            try\n            {\n                var session = (AsyncSession)ar.AsyncState;\n                session.Remote.EndSend(ar);\n                _connection.BeginReceive(_connetionRecvBuffer, 0, RecvSize, SocketFlags.None, new AsyncCallback(PipeConnectionReceiveCallback), session);


                    _decryptIV = new byte[ivLen];\n                    Array.Copy(iv, _decryptIV, ivLen);\n                }\n            }\n            else if (_cipher == CIPHER_BF)\n            {\n                PolarSSL.blowfish_init(ctx);\n                // PolarSSL takes key length by bit\n                PolarSSL.blowfish_setkey(ctx, realkey, keyLen * 8);\n                if (isCipher)\n                {\n                    _encryptIV = new byte[ivLen];\n                    Array.Copy(iv, _encryptIV, ivLen);\n                }\n                else\n                {




        public class GfwListDownloadCompletedArgs : EventArgs\n        {\n            public string Content;\n        }\n        public event EventHandler<GfwListDownloadCompletedArgs> DownloadCompleted;\n        public event ErrorEventHandler Error;\n        public void Download()\n        {\n            WebClient http = new WebClient();\n            http.Proxy = proxy;\n            http.DownloadStringCompleted += http_DownloadStringCompleted;\n            http.DownloadStringAsync(new Uri(GFWLIST_URL));\n        }\n        protected void ReportError(Exception e)\n        {\n            if (Error != null)\n            {\n                Error(this, new ErrorEventArgs(e));\n            }\n        }\n        private void http_DownloadStringCompleted(object sender, DownloadStringCompletedEventArgs e)
                string response = e.Result;\n                if (DownloadCompleted != null)\n                {\n                    DownloadCompleted(this, new GfwListDownloadCompletedArgs\n                    {\n                        Content = response\n                    });\n                }
                ReportError(ex);\n            }\n        }\n        public class Parser\n        {\n            private string _Content;\n            public string Content\n            {\n                get { return _Content; }\n            }
                this._Content = Encoding.ASCII.GetString(bytes);\n            }\n            public string[] GetValidLines()\n            {\n                string[] lines = Content.Split(new char[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);\n                List<string> valid_lines = new List<string>(lines.Length);\n                foreach (string line in lines)\n                {\n                    if (line.StartsWith("!") || line.StartsWith("["))\n                        continue;\n                    valid_lines.Add(line);\n                }\n                return valid_lines.ToArray();
                List<string> lines = new List<string>(GetValidLines());

            this.LockButton = new System.Windows.Forms.Button();\n            this.panel4 = new System.Windows.Forms.Panel();
            if (controller == null || controller.GetConfiguration().isDefault)\n            {\n                _isFirstRun = true;\n            }\n            else
                BeginInvoke(new MethodInvoker(delegate { this.Hide(); }));
            string path = e.FullPath.ToString();\n            string currentLastWriteTime = File.GetLastWriteTime(e.FullPath).ToString();\n            // if there is no path info stored yet or stored path has different time of write then the one now is inspected\n            if (!fileChangedTime.ContainsKey(path) || fileChangedTime[path].ToString() != currentLastWriteTime)\n            {\n                if (PACFileChanged != null)\n                {\n                    Console.WriteLine("Detected: PAC file '{0}' was {1}.", e.Name, e.ChangeType.ToString().ToLower());\n                    PACFileChanged(this, new EventArgs());\n                }\n                //lastly we update the last write time in the hashtable\n                fileChangedTime[path] = currentLastWriteTime;
            string path = e.FullPath.ToString();\n            string currentLastWriteTime = File.GetLastWriteTime(e.FullPath).ToString();\n            // if there is no path info stored yet or stored path has different time of write then the one now is inspected\n            if (!fileChangedTime.ContainsKey(path) || fileChangedTime[path].ToString() != currentLastWriteTime)\n            {\n                if (UserRuleFileChanged != null)\n                {\n                    Console.WriteLine("Detected: User Rule file '{0}' was {1}.", e.Name, e.ChangeType.ToString().ToLower());\n                    UserRuleFileChanged(this, new EventArgs());\n                }\n                //lastly we update the last write time in the hashtable\n                fileChangedTime[path] = currentLastWriteTime;\n            }\n        }\n        #endregion
                _process.StartInfo.UseShellExecute = true;
                //_process.StartInfo.RedirectStandardOutput = true;\n                //_process.StartInfo.RedirectStandardError = true;

                if (String.IsNullOrEmpty(controller.GetConfiguration().pacUrl))\n                {\n                    UpdateOnlinePACURLItem_Click(sender, e);\n                }\n                if (!String.IsNullOrEmpty(controller.GetConfiguration().pacUrl))\n                {\n                    localPACItem.Checked = false;\n                    onlinePACItem.Checked = true;\n                    controller.UseOnlinePAC(true);\n                }\n                UpdatePACItemsEnabledStatus();


                FileStream _FileStream = new FileStream(fileName, FileMode.Create, FileAccess.Write);
                while ((n = input.Read(buffer, 0, buffer.Length)) > 0)

                if (!File.Exists(LogFilePath))\n                    using (File.Create(LogFilePath)) { }\n                LogFileCreationTime = File.GetCreationTime(LogFilePath);\n                if ((DateTime.Now - LogFileCreationTime).Days >= 1)\n                    RollLogFile();\n                else\n                {\n                    FileStream fs = new FileStream(LogFilePath, FileMode.Append);\n                    StreamWriterWithTimestamp sw = new StreamWriterWithTimestamp(fs);\n                    sw.AutoFlush = true;\n                    Console.SetOut(sw);\n                    Console.SetError(sw);\n                }
            WriteToLogFile("[E] " + o);
            WriteToLogFile(o);
            WriteToLogFile("[D] " + o);
        public void UpdatePACFromGFWList(Configuration config)
            http.Proxy = new WebProxy(IPAddress.Loopback.ToString(), config.localPort);
            ClearLogsButton.Text = I18N.GetString("&Clear Logs");
            ClearLogsMenuItem.Text = I18N.GetString("&Clear Logs");
        private void DoClearLogs()
        private void ClearLogsMenuItem_Click(object sender, EventArgs e)\n        {\n            DoClearLogs();\n        }\n        private void ClearLogsButton_Click(object sender, EventArgs e)\n        {\n            DoClearLogs();
            this.ClearLogsMenuItem = new System.Windows.Forms.MenuItem();
            this.ClearLogsButton = new System.Windows.Forms.Button();
            // ClearLogsMenuItem\n            // \n            this.ClearLogsMenuItem.Index = 0;\n            this.ClearLogsMenuItem.Text = "&Clear Logs";\n            this.ClearLogsMenuItem.Click += new System.EventHandler(this.ClearLogsMenuItem_Click);
        private System.Windows.Forms.Button ClearLogsButton;
        private System.Windows.Forms.MenuItem ClearLogsMenuItem;


                if (targetIndex == -1 || enIndex == targetIndex)
                    // TODO: need fix\n                    //Logging.Debug(remote.LocalEndPoint, remote.DestEndPoint, RecvSize, "TCP Relay");
                        // TODO: need fix\n                        //Logging.Debug(remote.LocalEndPoint, remote.DestEndPoint, RecvSize, "TCP Relay");

                    IPAddress ipAddress;\n                    bool parsed = IPAddress.TryParse(_config.proxyServer, out ipAddress);
                    proxyEP = null;
                proxyTimer.Proxy = remote;\n                proxyTimer.DestHost = server.server;\n                proxyTimer.DestPort = server.server_port;
        public EndPoint ProxyEndPoint { get; } = new FakeEndPoint();\n        public string DestHost { get; private set; }\n        public int DestPort { get; private set; }

        public void BeginConnectDest(string host, int port, AsyncCallback callback, object state)

        string DestHost { get; }\n        int DestPort { get; }
        void BeginConnectDest(string host, int port, AsyncCallback callback, object state);
            QRCode4CS.Options options = new QRCode4CS.Options();\n            options.Text = qrText;\n            QRCode4CS.QRCode qrCoded = null;\n            bool success = false;\n            foreach (var level in new QRErrorCorrectLevel[]{QRErrorCorrectLevel.H, QRErrorCorrectLevel.Q, QRErrorCorrectLevel.M, QRErrorCorrectLevel.L})\n            {\n                for (int i = 3; i < 10; i++)\n                {\n                    try\n                    {\n                        options.TypeNumber = i;\n                        options.CorrectLevel = level;\n                        qrCoded = new QRCode4CS.QRCode(options);\n                        qrCoded.Make();\n                        success = true;\n                        break;\n                    }\n                    catch\n                    {\n                        qrCoded = null;\n                        continue;\n                    }\n                }\n                if (success)\n                    break;\n            }\n            if (qrCoded == null)\n            {\n                return;\n            }\n            int blockSize = Math.Max(200 / qrCoded.GetModuleCount(), 1);
            using (Graphics g = Graphics.FromImage(drawArea))
                g.Clear(Color.White);\n                using (Brush b = new SolidBrush(Color.Black))
                    for (int row = 0; row < qrCoded.GetModuleCount(); row++)
                        for (int col = 0; col < qrCoded.GetModuleCount(); col++)
                            bool isDark = qrCoded.IsDark(row, col);\n                            if (isDark)
                                g.FillRectangle(b, blockSize * row, blockSize * col, blockSize, blockSize);
                config = JsonConvert.DeserializeObject<Configuration>(configContent);

                config = new Configuration
            try
                FontDialog fd = new FontDialog();\n                fd.Font = LogMessageTextBox.Font;\n                if (fd.ShowDialog() == DialogResult.OK)\n                {\n                    LogMessageTextBox.Font = new Font(fd.Font.FontFamily, fd.Font.Size, fd.Font.Style);\n                }\n            }\n            catch (Exception ex)\n            {\n                Logging.LogUsefulException(ex);\n                MessageBox.Show(ex.Message);

                string _serverUrl = serverUrl.Trim();\n                if (!_serverUrl.BeginWith("ss://", StringComparison.InvariantCultureIgnoreCase))
                    parsedUrl = new Uri(decodedServerUrl);
                string userInfo = parsedUrl.GetComponents(UriComponents.UserInfo, UriFormat.Unescaped);\n                tmp.server = parsedUrl.GetComponents(UriComponents.Host, UriFormat.Unescaped);\n                tmp.server_port = parsedUrl.Port;
            this.tableLayoutPanel1.Controls.Add(this.OneTimeAuth, 1, 7);\n            this.tableLayoutPanel1.Controls.Add(this.TimeoutLabel, 0, 6);\n            this.tableLayoutPanel1.Controls.Add(this.TimeoutTextBox, 1, 6);
            this.tableLayoutPanel1.RowCount = 8;\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.Size = new System.Drawing.Size(255, 189);
            this.ProxyPortLabel = new System.Windows.Forms.Label();
            this.ProxyAddrLabel.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));
            // ProxyPortLabel\n            // \n            this.ProxyPortLabel.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));\n            this.ProxyPortLabel.AutoSize = true;\n            this.ProxyPortLabel.Location = new System.Drawing.Point(215, 7);\n            this.ProxyPortLabel.Name = "ProxyPortLabel";\n            this.ProxyPortLabel.Size = new System.Drawing.Size(65, 12);\n            this.ProxyPortLabel.TabIndex = 2;\n            this.ProxyPortLabel.Text = "Proxy Port";
            this.tableLayoutPanel4.ColumnCount = 4;\n            this.tableLayoutPanel4.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());\n            this.tableLayoutPanel4.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle());
            this.ProxyTypeLabel.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));
            this.ProxyTypeComboBox.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));
        private System.Windows.Forms.Label ProxyPortLabel;
        public void UpdateLatency(object sender, SSTCPConnectedEventArgs args)\n        {\n            GetCurrentStrategy()?.UpdateLatency(args.server, args.latency);
                availabilityStatistics.UpdateLatency(args.server, (int)args.latency.TotalMilliseconds);\n            }\n        }\n        public void UpdateInboundCounter(object sender, SSTransmitEventArgs args)\n        {\n            GetCurrentStrategy()?.UpdateLastRead(args.server);\n            Interlocked.Add(ref _inboundCounter, args.length);
                availabilityStatistics.UpdateInboundCounter(args.server, args.length);\n            }\n        }\n        public void UpdateOutboundCounter(object sender, SSTransmitEventArgs args)\n        {\n            GetCurrentStrategy()?.UpdateLastWrite(args.server);\n            Interlocked.Add(ref _outboundCounter, args.length);
                availabilityStatistics.UpdateOutboundCounter(args.server, args.length);
﻿using System;
    internal class TCPRelay : Listener.Service
        public event EventHandler<SSTCPConnectedEventArgs> OnConnected;\n        public event EventHandler<SSTransmitEventArgs> OnInbound;\n        public event EventHandler<SSTransmitEventArgs> OnOutbound;\n        public event EventHandler<SSRelayEventArgs> OnFailed;\n        private static readonly Logger logger = LogManager.GetCurrentClassLogger();\n        private readonly ShadowsocksController _controller;
        private readonly Configuration _config;
            TCPHandler handler = new TCPHandler(_controller, _config, socket);\n            handler.OnConnected += OnConnected;\n            handler.OnInbound += OnInbound;\n            handler.OnOutbound += OnOutbound;\n            handler.OnFailed += OnFailed;\n            handler.OnClosed += (h, arg) =>\n            {\n                lock (Handlers)\n                {\n                    Handlers.Remove(handler);\n                }\n            };
    }\n    public class SSRelayEventArgs : EventArgs\n    {\n        public readonly Server server;\n        public SSRelayEventArgs(Server server)\n        {\n            this.server = server;\n        }\n    }\n    public class SSTransmitEventArgs : SSRelayEventArgs\n    {\n        public readonly long length;\n        public SSTransmitEventArgs(Server server, long length) : base(server)\n        {\n            this.length = length;\n        }\n    }\n    public class SSTCPConnectedEventArgs : SSRelayEventArgs\n    {\n        public readonly TimeSpan latency;\n        public SSTCPConnectedEventArgs(Server server, TimeSpan latency) : base(server)\n        {\n            this.latency = latency;
        public event EventHandler<SSTCPConnectedEventArgs> OnConnected;\n        public event EventHandler<SSTransmitEventArgs> OnInbound;\n        public event EventHandler<SSTransmitEventArgs> OnOutbound;\n        public event EventHandler<SSRelayEventArgs> OnClosed;\n        public event EventHandler<SSRelayEventArgs> OnFailed;\n        private class AsyncSession
        private class AsyncSession<T> : AsyncSession
        private static readonly Logger Logger = LogManager.GetCurrentClassLogger();
        private readonly ShadowsocksController _controller;\n        private readonly ProxyConfig _config;\n        private readonly Socket _connection;
        private readonly byte[] _remoteRecvBuffer = new byte[BufferSize];
        private readonly byte[] _connetionRecvBuffer = new byte[BufferSize];
        private readonly byte[] _remoteSendBuffer = new byte[BufferSize];
        private readonly byte[] _connetionSendBuffer = new byte[BufferSize];
        // TODO: decouple controller\n        public TCPHandler(ShadowsocksController controller, Configuration config, Socket socket)
            _config = config.proxy;
            _server = server;
                if (_closed)\n                {\n                    return;\n                }
            OnClosed?.Invoke(this, new SSRelayEventArgs(_server));
                }\n            }\n            catch (Exception e)\n            {\n                ErrorClose(e);
            if (_closed)\n            {\n                return;\n            }
                    AddressReceiveCallback, null);\n            }\n            catch (Exception e)\n            {\n                ErrorClose(e);\n            }\n        }\n        private void AddressReceiveCallback(IAsyncResult ar)\n        {\n            if (_closed)\n            {\n                return;\n            }
                ErrorClose(e);\n            }\n        }\n        private void ConnectResponseCallback(IAsyncResult ar)
                ErrorClose(e);
            if (_closed)\n            {\n                return;\n            }
                object[] states = (object[])ar.AsyncState;
                Action onSuccess = (Action)states[1];
                    }\n                }\n            }\n            catch (Exception e)\n            {\n                ErrorClose(e);
                    proxyEP = SocketUtil.GetEndPoint(_config.proxyServer, _config.proxyPort);
                AsyncSession session = new AsyncSession(remote);
                ErrorClose(e);
            ProxyTimer timer = (ProxyTimer)sender;
            IProxy proxy = timer.Session.Remote;
                AsyncSession<ProxyTimer> session = (AsyncSession<ProxyTimer>)ar.AsyncState;
                EndPoint destEndPoint = timer.DestEndPoint;\n                Server server = timer.Server;
                IProxy remote = session.Remote;
                if (_config.useAuth)\n                {\n                    auth = new NetworkCredential(_config.authUser, _config.authPwd);
                ErrorClose(e);
            ServerTimer timer = (ServerTimer)sender;
            AsyncSession session = timer.Session;
            OnFailed?.Invoke(this, new SSRelayEventArgs(_server));
            if (_closed)\n            {\n                return;\n            }\n            try\n            {\n                AsyncSession<ServerTimer> session = (AsyncSession<ServerTimer>)ar.AsyncState;
                IProxy remote = session.Remote;
                TimeSpan latency = DateTime.Now - _startConnectTime;\n                OnConnected?.Invoke(this, new SSTCPConnectedEventArgs(_server, latency));
                    OnFailed?.Invoke(this, new SSRelayEventArgs(_server));\n                }\n                ErrorClose(e);
                int size = _connection.Receive(_connetionRecvBuffer, _firstPacketLength, available,
            if (_closed)\n            {\n                return;\n            }
                ErrorClose(e);
            if (_closed)\n            {\n                return;\n            }\n            try\n            {\n                AsyncSession session = (AsyncSession)ar.AsyncState;
                OnInbound?.Invoke(this, new SSTransmitEventArgs(_server, bytesRead));
                ErrorClose(e);
            if (_closed)\n            {\n                return;\n            }
                AsyncSession session = (AsyncSession)ar.AsyncState;\n                IProxy remote = session.Remote;
            OnOutbound?.Invoke(this, new SSTransmitEventArgs(_server, bytesToSend));

            if (_closed)\n            {\n                return;\n            }\n            try\n            {\n                object[] container = (object[])ar.AsyncState;\n                AsyncSession session = (AsyncSession)container[0];\n                int bytesShouldSend = (int)container[1];
                ErrorClose(e);
                object[] container = (object[])ar.AsyncState;\n                AsyncSession session = (AsyncSession)container[0];\n                int bytesShouldSend = (int)container[1];\n                int bytesSent = _connection.EndSend(ar);\n                int bytesRemaining = bytesShouldSend - bytesSent;

            "aes-128-cfb"});

                for (int i = 0; i < 100; i++)\n                {\n                    IEncryptor encryptor;\n                    IEncryptor decryptor;\n                    encryptor = new PolarSSLEncryptor("aes-256-cfb", "barfoo!");\n                    decryptor = new PolarSSLEncryptor("aes-256-cfb", "barfoo!");\n                    RunEncryptionRound(encryptor, decryptor);\n                }\n            }\n            catch\n            {\n                encryptionFailed = true;\n                throw;\n            }\n        }\n        [TestMethod]\n        public void TestRC4Encryption()\n        {\n            // run it once before the multi-threading test to initialize global tables\n            RunSingleRC4EncryptionThread();\n            List<Thread> threads = new List<Thread>();\n            for (int i = 0; i < 10; i++)\n            {\n                Thread t = new Thread(new ThreadStart(RunSingleRC4EncryptionThread));\n                threads.Add(t);\n                t.Start();\n            }\n            foreach (Thread t in threads)\n            {\n                t.Join();\n            }\n            Assert.IsFalse(encryptionFailed);\n        }\n        private void RunSingleRC4EncryptionThread()\n        {\n            try\n            {\n                for (int i = 0; i < 100; i++)\n                {\n                    var random = new Random();\n                    IEncryptor encryptor;\n                    IEncryptor decryptor;\n                    encryptor = new PolarSSLEncryptor("rc4-md5", "barfoo!");\n                    decryptor = new PolarSSLEncryptor("rc4-md5", "barfoo!");\n                    RunEncryptionRound(encryptor, decryptor);\n                }



            this.flowLayoutPanel1.SuspendLayout();


            this.flowLayoutPanel1.ResumeLayout(false);






            this.QRCodeItem = new System.Windows.Forms.MenuItem();





            if (!controller.GetConfiguration().isDefault)\n            {\n                this.Opacity = 0;\n                BeginInvoke(new MethodInvoker(delegate\n                {\n                    this.Hide();\n                }));
                isFirstRun = true;
            string serverStr;\n            // CheckHostName() won't do a real DNS lookup\n            var hostType = Uri.CheckHostName( server );\n            if ( hostType == UriHostNameType.Unknown ) {\n                throw new FormatException("Invalid Server Address.");
            switch ( hostType ) {\n                case UriHostNameType.IPv6:\n                    serverStr = $"[{server}]:{server_port}";\n                    break;\n                default:\n                    // IPv4 and domain name\n                    serverStr = $"{server}:{server_port}";\n                    break;
            return remarks.IsNullOrEmpty()\n                ? serverStr\n                : $"{remarks} ({serverStr})";
            this.ClientSize = new System.Drawing.Size(205, 205);\n            this.Controls.Add(this.pictureBox1);
        private void update_TrafficChart()\n        {\n            List<float> inboundPoints = new List<float>();\n            List<float> outboundPoints = new List<float>();\n            TextAnnotation inboundAnnotation = new TextAnnotation();\n            TextAnnotation outboundAnnotation = new TextAnnotation();\n            Tuple<float, string, long> bandwidthScale;\n            const long minScale = 50;
            long lastInbound, lastOutbound;\n            lock (this)\n            {\n                if (traffic.Count == 0)\n                    return;\n                foreach (var trafficPerSecond in traffic)\n                {\n                    inboundPoints.Add(trafficPerSecond.Item1);\n                    outboundPoints.Add(trafficPerSecond.Item2);\n                    maxSpeed = Math.Max(maxSpeed, Math.Max(trafficPerSecond.Item1, trafficPerSecond.Item2));\n                }\n                lastInbound = traffic.Last().Item1;\n                lastOutbound = traffic.Last().Item2;\n            }\n            if (maxSpeed > 0)\n            {\n                lastMaxSpeed -= lastMaxSpeed / 32;\n                maxSpeed = Math.Max(minScale, Math.Max(maxSpeed, lastMaxSpeed));\n                lastMaxSpeed = maxSpeed;\n            }\n            else\n            {\n                maxSpeed = lastMaxSpeed = minScale;
            if (trafficChart.IsHandleCreated)\n            {\n                trafficChart.Series["Inbound"].Points.DataBindY(inboundPoints);\n                trafficChart.Series["Outbound"].Points.DataBindY(outboundPoints);\n                trafficChart.ChartAreas[0].AxisY.LabelStyle.Format = "{0:0.##} " + bandwidthScale.Item2;\n                trafficChart.ChartAreas[0].AxisY.Maximum = bandwidthScale.Item1;\n                inboundAnnotation.AnchorDataPoint = trafficChart.Series["Inbound"].Points.Last();\n                inboundAnnotation.Text = Utils.FormatBandwidth(lastInbound);\n                outboundAnnotation.AnchorDataPoint = trafficChart.Series["Outbound"].Points.Last();\n                outboundAnnotation.Text = Utils.FormatBandwidth(lastOutbound);\n                trafficChart.Annotations.Clear();\n                trafficChart.Annotations.Add(inboundAnnotation);\n                trafficChart.Annotations.Add(outboundAnnotation);\n            }\n        }\n        private void controller_TrafficChanged(object sender, EventArgs e)\n        {\n            lock (this)\n            {\n                traffic = new ShadowsocksController.QueueLast<Tuple<long, long>>();\n                foreach (var trafficPerSecond in controller.traffic)\n                {\n                    traffic.Enqueue(new Tuple<long, long>(trafficPerSecond.inboundIncreasement, trafficPerSecond.outboundIncreasement));\n                }
            this.PluginTextBox.Margin = new System.Windows.Forms.Padding(4);
            this.RemarksTextBox.Margin = new System.Windows.Forms.Padding(4);
            this.IPTextBox.Margin = new System.Windows.Forms.Padding(4);
            this.ServerPortTextBox.Margin = new System.Windows.Forms.Padding(4);
            this.PasswordTextBox.Margin = new System.Windows.Forms.Padding(4);
            this.PluginOptionsTextBox.Margin = new System.Windows.Forms.Padding(4);
            this.ShowPasswdCheckBox.Margin = new System.Windows.Forms.Padding(4);
            this.PluginArgumentsTextBox.Margin = new System.Windows.Forms.Padding(4);
            this.tableLayoutPanel5.Padding = new System.Windows.Forms.Padding(4);
            this.ProxyPortTextBox.Margin = new System.Windows.Forms.Padding(4);




            this.splitContainer3.Size = new System.Drawing.Size(589, 305);\n            this.splitContainer3.SplitterDistance = 42;\n            this.splitContainer3.SplitterWidth = 1;
            this.label1.Text = "Final Score =";\n            this.CalculatinTip.SetToolTip(this.label1, "(The server with the highest score would be choosen)");
        public TCPRelay(ShadowsocksController controller, Configuration conf)
            TCPHandler handler = new TCPHandler(this, _config);
        private Configuration _config;\n        public TCPHandler(TCPRelay tcprelay, Configuration config)
                            if ( _config.isVerboseLogging ) {
                            if ( _config.isVerboseLogging ) {
                            if ( _config.isVerboseLogging ) {
        void ShowBalloonTip(string title, string content, ToolTipIcon icon, int timeout)\n        {\n            _notifyIcon.BalloonTipTitle = title;\n            _notifyIcon.BalloonTipText = content;\n            _notifyIcon.BalloonTipIcon = icon;\n            _notifyIcon.ShowBalloonTip(timeout);\n        }\n        void controller_UpdatePACFromGFWListError(object sender, ErrorEventArgs e)\n        {\n            ShowBalloonTip(I18N.GetString("Failed to update PAC file"), e.GetException().Message, ToolTipIcon.Error, 5000);
            ShowBalloonTip(I18N.GetString("Shadowsocks"), I18N.GetString("PAC updated"), ToolTipIcon.Info, 1000);
            ShowBalloonTip(String.Format(I18N.GetString("Shadowsocks {0} Update Found"), updateChecker.LatestVersionNumber), I18N.GetString("Click here to download"), ToolTipIcon.Info, 5000);

                if (_config.proxy.useProxy)
                    proxyEP = SocketUtil.GetEndPoint(_config.proxy.proxyServer, _config.proxy.proxyPort);
            _config.proxy.useProxy = false;
            _config.proxy.useProxy = true;\n            _config.proxy.proxyServer = proxy;\n            _config.proxy.proxyPort = port;
            UrlFinder = new Regex("^(?i)ss://([A-Za-z0-9+-/=_]+)(#(.+))?$", RegexOptions.IgnoreCase),
                                      ":(?<port>\\d+?))$", RegexOptions.IgnoreCase);
                    port = int.Parse(ProxyPortTextBox.Text);
            _modifiedConfiguration.proxyType = type;\n            _modifiedConfiguration.proxyServer = proxy;\n            _modifiedConfiguration.proxyPort = port;\n            _modifiedConfiguration.proxyTimeout = timeout;
                Server server = new Server();\n                server.server = IPTextBox.Text.Trim();\n                try\n                {\n                    server.server_port = int.Parse(ServerPortTextBox.Text);\n                }\n                catch (FormatException)\n                {\n                    MessageBox.Show(I18N.GetString("Illegal port number format"));\n                    ServerPortTextBox.Clear();\n                    return false;\n                }\n                server.password = PasswordTextBox.Text;\n                server.method = EncryptionSelect.Text;\n                server.remarks = RemarksTextBox.Text;\n                try\n                {\n                    server.timeout = int.Parse(TimeoutTextBox.Text);\n                }\n                catch (FormatException)\n                {\n                    MessageBox.Show(I18N.GetString("Illegal timeout format"));\n                    TimeoutTextBox.Clear();\n                    return false;\n                }\n                server.auth = OneTimeAuth.Checked;



            this.pictureBox1.Dock = System.Windows.Forms.DockStyle.Fill;\n            this.pictureBox1.Location = new System.Drawing.Point(10, 10);\n            this.pictureBox1.Margin = new System.Windows.Forms.Padding(0);
            this.pictureBox1.Size = new System.Drawing.Size(204, 202);\n            this.pictureBox1.SizeMode = System.Windows.Forms.PictureBoxSizeMode.StretchImage;
            this.ClientSize = new System.Drawing.Size(224, 222);\n            this.Controls.Add(this.panel1);

        public TCPHandler(ShadowsocksController controller, Configuration config, Socket socket)

        public bool AskAddServerBySSURL(string ssURL)
                if (AddServerBySSURL(ssURL))\n                {\n                    MessageBox.Show(I18N.GetString("Successfully imported from {0}", ssURL));\n                    return true;\n                }\n                else\n                {\n                    MessageBox.Show(I18N.GetString("Failed to import. Please check if the link is valid."));\n                }\n            }\n            return false;

                GFWListUpdater.MergeAndWritePACFile(FileManager.NonExclusiveReadAllText(Utils.GetTempPath("gfwlist.txt")));\n            }
                bool pacFileChanged = MergeAndWritePACFile(e.Result);\n                UpdateCompleted?.Invoke(this, new ResultEventArgs(pacFileChanged));
        public const int RecvReserveSize = (RecvSize / IVEncryptor.CRC_BUF_LEN + 1) * IVEncryptor.CRC_BYTES + 16; // reserve for one-time auth\n        public const int BufferSize = RecvSize + RecvReserveSize + 32;
        private byte[] remoteRecvBuffer = new byte[BufferSize];
        private byte[] connetionRecvBuffer = new byte[BufferSize];
                if (Uri.CheckHostName(server.server = IPTextBox.Text.Trim()) == UriHostNameType.Unknown)\n                {\n                    MessageBox.Show(I18N.GetString("Invalid server address"));\n                    IPTextBox.Focus();\n                    return false;\n                }\n                if (!int.TryParse(ServerPortTextBox.Text, out server.server_port))
                    ServerPortTextBox.Focus();
                if (!int.TryParse(TimeoutTextBox.Text, out server.timeout))
                    TimeoutTextBox.Focus();
            if (socket.ProtocolType != ProtocolType.Tcp\n                || (length < 2 || firstPacket[0] != 5))
            else\n            {\n                socket.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n                TCPHandler handler = new TCPHandler(this);\n                handler.connection = socket;\n                handler.controller = _controller;\n                handler.tcprelay = this;\n                handler.Start(firstPacket, length);\n                IList<TCPHandler> handlersToClose = new List<TCPHandler>();\n                lock (Handlers)\n                {\n                    Handlers.Add(handler);\n                    DateTime now = DateTime.Now;\n                    if (now - _lastSweepTime > TimeSpan.FromSeconds(1))\n                    {\n                        _lastSweepTime = now;\n                        foreach (TCPHandler handler1 in Handlers)\n                            if (now - handler1.lastActivity > TimeSpan.FromSeconds(900))\n                                handlersToClose.Add(handler1);\n                    }\n                }\n                foreach (TCPHandler handler1 in handlersToClose)\n                {\n                    Logging.Debug("Closing timed out TCP connection.");\n                    handler1.Close();\n                }\n                return true;\n            }
            _tcprelay = tcprelay;



                else\n                    _closed = true;\n            }\n            try\n            {\n                connection?.Shutdown(SocketShutdown.Both);\n                connection?.Close();\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n            }\n            try\n            {\n                remote?.Shutdown(SocketShutdown.Both);\n                remote?.Close();\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);
                    encryptor?.Dispose();
            if (_closed) return;


            if (_closed) return;


            switch (endPoint.AddressFamily)\n            {\n                case AddressFamily.InterNetwork:\n                    response[3] = 1;\n                    break;\n                case AddressFamily.InterNetworkV6:\n                    response[3] = 4;\n                    break;
            if (_closed) return;


            if (_connected) return;
            strategy?.SetFailure(server);
                Close();
            if (_closed) return;
                Server server = timer.Server;
                    strategy?.SetFailure(server);
            if (_closed) return;
                        if (_closed) return;
                    strategy?.UpdateLastRead(server);
                    -2 * 5 * (Math.Min(2000, status.latency.TotalMilliseconds) / (1 + (now - status.lastTimeDetectLatency).TotalSeconds / 30 / 10) +
            return ssURL\n                .Split('\r', '\n', ' ')\n                .Select(u => ParseURL(u))\n                .Where(s => s != null)\n                .ToList();
            try {\n                using(StreamReader reader = new StreamReader(new FileStream(filename,\n                         FileMode.Open, FileAccess.Read, FileShare.ReadWrite))) {\n                    reader.BaseStream.Seek(lastOffset, SeekOrigin.Begin);\n                    string line = "";\n                    bool changed = false;\n                    while((line = reader.ReadLine()) != null) {\n                        changed = true;\n                        LogMessageTextBox.AppendText(line + Environment.NewLine);\n                    }\n                    if(changed) {\n                        LogMessageTextBox.ScrollToCaret();\n                    }\n                    lastOffset = reader.BaseStream.Position;
            } catch(FileNotFoundException) {
                fs = new FileStream(LogFilePath, FileMode.Append);\n                sw = new StreamWriterWithTimestamp(fs);
            try {\n                Console.WriteLine(o);\n            } catch(ObjectDisposedException) {\n            }







                _runningPort = GetFreePort();
                FileManager.ByteArrayToFile(Utils.GetTempPath(_uniqueConfigFile), Encoding.UTF8.GetBytes(privoxyConfig));\n                _process = new Process\n                {\n                    // Configure the process using the StartInfo properties.\n                    StartInfo =\n                    {\n                        FileName = "ss_privoxy.exe",\n                        Arguments = _uniqueConfigFile,\n                        WorkingDirectory = Utils.GetTempPath(),\n                        WindowStyle = ProcessWindowStyle.Hidden,\n                        UseShellExecute = true,\n                        CreateNoWindow = true\n                    }\n                };




            this.pictureBox1.Location = new System.Drawing.Point(9, 9);
            this.pictureBox1.Size = new System.Drawing.Size(210, 210);\n            this.pictureBox1.SizeMode = System.Windows.Forms.PictureBoxSizeMode.Zoom;

            this.ClientSize = new System.Drawing.Size(338, 274);\n            this.Controls.Add(this.pictureBox1);




            foreach (var kv in _inOutBoundRecords)
                var record = kv.Value;\n                long inboundDelta, outboundDelta;\n                record.GetDelta(out inboundDelta, out outboundDelta);\n                var inboundSpeed = GetSpeedInKiBPerSecond(inboundDelta, _monitorInterval.TotalSeconds);\n                var outboundSpeed = GetSpeedInKiBPerSecond(outboundDelta, _monitorInterval.TotalSeconds);\n                var inR = _inboundSpeedRecords.GetOrAdd(id, (k) => new List<int>());\n                var outR = _outboundSpeedRecords.GetOrAdd(id, (k) => new List<int>());\n                inR.Add(inboundSpeed);\n                outR.Add(outboundSpeed);
            _inOutBoundRecords.AddOrUpdate(server.Identifier(), (k) =>\n            {\n                var r = new InOutBoundRecord();\n                r.UpdateInbound(n);\n                return r;\n            }, (k, v) =>\n            {\n                v.UpdateInbound(n);\n                return v;\n            });
            _inOutBoundRecords.AddOrUpdate(server.Identifier(), (k) =>\n            {\n                var r = new InOutBoundRecord();\n                r.UpdateOutbound(n);\n                return r;\n            }, (k, v) =>\n            {\n                v.UpdateOutbound(n);\n                return v;\n            });
            if (password.IsNullOrEmpty())
            if (server.IsNullOrEmpty())
            if (server.IsNullOrEmpty())
            if (remarks.IsNullOrEmpty())
                if (controller.GetConfigurationCopy().pacUrl.IsNullOrEmpty())
                if (!controller.GetConfigurationCopy().pacUrl.IsNullOrEmpty())

                    md5sum = MbedTLS.MD5(password);
                    md5sum = MbedTLS.MD5(result);
this.ShareOverLANItem.Index = 2;
this.ServersItem.Index = 3;
                            double minX = Int32.MaxValue, minY = Int32.MaxValue, maxX = 0, maxY = 0;
        FileSystemWatcher PACFileWatcher;\n        FileSystemWatcher UserRuleFileWatcher;
            if (PACFileWatcher != null)\n            {\n                PACFileWatcher.Dispose();\n            }\n            PACFileWatcher = new FileSystemWatcher(Directory.GetCurrentDirectory());\n            PACFileWatcher.NotifyFilter = NotifyFilters.LastWrite | NotifyFilters.FileName | NotifyFilters.DirectoryName;\n            PACFileWatcher.Filter = PAC_FILE;\n            PACFileWatcher.Changed += PACFileWatcher_Changed;\n            PACFileWatcher.Created += PACFileWatcher_Changed;\n            PACFileWatcher.Deleted += PACFileWatcher_Changed;\n            PACFileWatcher.Renamed += PACFileWatcher_Changed;\n            PACFileWatcher.EnableRaisingEvents = true;\n        }\n        private void WatchUserRuleFile()\n        {\n            if (UserRuleFileWatcher != null)\n            {\n                UserRuleFileWatcher.Dispose();\n            }\n            UserRuleFileWatcher = new FileSystemWatcher(Directory.GetCurrentDirectory());\n            UserRuleFileWatcher.NotifyFilter = NotifyFilters.LastWrite | NotifyFilters.FileName | NotifyFilters.DirectoryName;\n            UserRuleFileWatcher.Filter = USER_RULE_FILE;\n            UserRuleFileWatcher.Changed += UserRuleFileWatcher_Changed;\n            UserRuleFileWatcher.Created += UserRuleFileWatcher_Changed;\n            UserRuleFileWatcher.Deleted += UserRuleFileWatcher_Changed;\n            UserRuleFileWatcher.Renamed += UserRuleFileWatcher_Changed;\n            UserRuleFileWatcher.EnableRaisingEvents = true;\n        }\n        private void PACFileWatcher_Changed(object sender, FileSystemEventArgs e)
                int targetIndex = -1;\n                for (int i = 0; i < localeNames.Length; i++)
                        if (localeNames[i].Split('-')[0] == localeNoRegion)\n                        {\n                            targetIndex = i;\n                        }
                    string source = translations[enIndex];\n                    string translation = translations[targetIndex];\n                    // source string or translation empty\n                    if (string.IsNullOrWhiteSpace(source) || string.IsNullOrWhiteSpace(translation)) continue;\n                    // line start with comment
                    _strings[source] = translation;
            string i18n;\n            if (!File.Exists(I18N_FILE))\n            {\n                i18n = Resources.i18n_csv;\n                File.WriteAllText(I18N_FILE, i18n, Encoding.UTF8);\n            }\n            else\n            {\n                i18n = File.ReadAllText(I18N_FILE, Encoding.UTF8);\n            }\n            Logging.Info("Current language is: " + CultureInfo.CurrentCulture.Name);\n            Init(i18n, CultureInfo.CurrentCulture.Name);

            public DateTime Timestamp;

                Server legacyServer = ParseLegacyURL(serverUrl);\n                if (legacyServer != null)   //legacy
                    servers.Add(legacyServer);
                else   //SIP002
                    Uri parsedUrl;\n                    try\n                    {\n                        parsedUrl = new Uri(serverUrl);\n                    }\n                    catch (UriFormatException)\n                    {\n                        continue;\n                    }\n                    Server server = new Server\n                    {\n                        remarks = parsedUrl.GetComponents(UriComponents.Fragment, UriFormat.Unescaped),\n                        server = parsedUrl.GetComponents(UriComponents.Host, UriFormat.Unescaped),\n                        server_port = parsedUrl.Port,\n                    };\n                    // parse base64 UserInfo\n                    string rawUserInfo = parsedUrl.GetComponents(UriComponents.UserInfo, UriFormat.Unescaped);\n                    string base64 = rawUserInfo.Replace('-', '+').Replace('_', '/');    // Web-safe base64 to normal base64\n                    string userInfo = "";\n                    try\n                    {\n                        userInfo = Encoding.UTF8.GetString(Convert.FromBase64String(\n                        base64.PadRight(base64.Length + (4 - base64.Length % 4) % 4, '=')));\n                    }\n                    catch (FormatException)\n                    {\n                        continue;\n                    }\n                    string[] userInfoParts = userInfo.Split(new char[] { ':' }, 2);\n                    if (userInfoParts.Length != 2)\n                    {\n                        continue;\n                    }\n                    server.method = userInfoParts[0];\n                    server.password = userInfoParts[1];\n                    NameValueCollection queryParameters = HttpUtility.ParseQueryString(parsedUrl.Query);\n                    string[] pluginParts = HttpUtility.UrlDecode(queryParameters["plugin"] ?? "").Split(new[] { ';' }, 2);\n                    if (pluginParts.Length > 0)\n                    {\n                        server.plugin = pluginParts[0] ?? "";\n                    }\n                    if (pluginParts.Length > 1)\n                    {\n                        server.plugin_opts = pluginParts[1] ?? "";\n                    }\n                    servers.Add(server);




            // I'm tired. just add a big lock\n            // let's optimize for RAM instead of CPU\n            lock(sodiumBuf)
                if (isCipher)\n                {\n                    bytesRemaining = _encryptBytesRemaining;\n                    ic = _encryptIC;\n                    iv = _encryptIV;\n                }\n                else\n                {\n                    bytesRemaining = _decryptBytesRemaining;\n                    ic = _decryptIC;\n                    iv = _decryptIV;\n                }\n                int padding = bytesRemaining;\n                Buffer.BlockCopy(buf, 0, sodiumBuf, padding, length);\n                switch (_cipher)\n                {\n                    case CIPHER_SALSA20:\n                        Sodium.crypto_stream_salsa20_xor_ic(sodiumBuf, sodiumBuf, (ulong)(padding + length), iv, ic, _key);\n                        break;\n                    case CIPHER_CHACHA20:\n                        Sodium.crypto_stream_chacha20_xor_ic(sodiumBuf, sodiumBuf, (ulong)(padding + length), iv, ic, _key);\n                        break;\n                }\n                Buffer.BlockCopy(sodiumBuf, padding, outbuf, 0, length);\n                padding += length;\n                ic += (ulong)padding / SODIUM_BLOCK_SIZE;\n                bytesRemaining = padding % SODIUM_BLOCK_SIZE;\n                if (isCipher)\n                {\n                    _encryptBytesRemaining = bytesRemaining;\n                    _encryptIC = ic;\n                }\n                else\n                {\n                    _decryptBytesRemaining = bytesRemaining;\n                    _decryptIC = ic;\n                }
                    int opcode = IPAddress.NetworkToHostOrder(BitConverter.ToInt32(buf, 0));\n                    if (opcode == 1)\n                    {\n                        await stream.ReadAsync(buf, 0, 4);\n                        int strlen = IPAddress.NetworkToHostOrder(BitConverter.ToInt32(buf, 0));\n                        await stream.ReadAsync(buf, 0, strlen);\n                        string url = Encoding.UTF8.GetString(buf, 0, strlen);\n                        AddUrlRequested?.Invoke(this, new RequestAddUrlEventArgs(url));\n                    }
        }\n        public void Start()\n        {\n            Reload();\n        }\n        protected void ReportError(Exception e)\n        {\n            if (Errored != null)\n            {\n                // translate Microsoft language into human language\n                // i.e. 以一种访问权限不允许的方式做了一个访问套接字的尝试 => Port is already used\n                if (e is SocketException)\n                {\n                    SocketException se = (SocketException)e;\n                    if (se.SocketErrorCode == SocketError.AccessDenied)\n                    {\n                        e = new Exception("Port is already used", e);\n                    }\n                }\n                Errored(this, new ErrorEventArgs(e));\n            }
        protected void Reload()\n        {
            if (local != null)\n            {\n                local.Stop();\n            }
            try\n            {\n                polipoRunner.Start(_config);\n                local = new Local(_config);\n                local.Start();\n                pacServer.Start(_config);\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                ReportError(e);\n            }
                IStrategy strategy = controller.GetCurrentStrategy();\n                if (strategy != null)\n                {\n                    strategy.UpdateLatency(server, latency);\n                }
                    IStrategy strategy = controller.GetCurrentStrategy();\n                    if (strategy != null)\n                    {\n                        strategy.SetFailure(server);\n                    }



                this.SeperatorItem,\n                this.ConfigItem\n            });

            CreateMenuGroup(1, "Mode", new System.Windows.Forms.MenuItem[] {\n                this.PACModeItem,\n                this.globalModeItem\n            }),
            CreateSeperatorItem(3),
            CreateMenuItem(6, "Edit PAC File...", new System.EventHandler(this.EditPACFileItem_Click)),\n            CreateSeperatorItem(7),\n            CreateMenuItem(8, "Show QRCode...", new System.EventHandler(this.QRCodeItem_Click)),\n            CreateMenuItem(9, "Show Logs...", new System.EventHandler(this.ShowLogItem_Click)),\n            CreateMenuItem(10, "About...", new System.EventHandler(this.Config_Click)),\n            CreateSeperatorItem(11),\n            CreateMenuItem(12, "Quit", new System.EventHandler(this.Quit_Click))});
                JsonArray result = (JsonArray)SimpleJson.SimpleJson.DeserializeObject(e.Result);
                foreach (JsonObject release in result)
                    if ((bool)release["prerelease"])
                        continue;\n                    }\n                    foreach (JsonObject asset in (JsonArray)release["assets"])\n                    {\n                        string url = (string)asset["browser_download_url"];\n                        if (IsNewVersion(url))
                            versions.Add(url);

        private const string _userWininetConfigFile = "user-wininet.json";\n        private static string _queryStr;
        private static SysproxyConfig _userSettings = null;
            Read();\n            if (!_userSettings.UserSettingsRecorded)
                ExecSysproxy("query");\n                ParseQueryStr(_queryStr);
                var flags = _userSettings.Flags;\n                var proxy_server = _userSettings.ProxyServer ?? "-";\n                var bypass_list = _userSettings.BypassList ?? "-";\n                var pac_url = _userSettings.PacUrl ?? "-";
                _userSettings.UserSettingsRecorded = false;
            Save();\n            ExecSysproxy(arguments);
        private static void ExecSysproxy(string arguments)
                if (arguments == "query") {\n                    if (stdout.IsNullOrWhiteSpace() || stdout.IsNullOrEmpty()) {\n                        // we cannot get user settings\n                        throw new ProxyException("failed to query wininet settings");\n                    }\n                    _queryStr = stdout;
            }\n        }\n        private static void Save()\n        {\n            try {\n                using (StreamWriter sw = new StreamWriter(File.Open(_userWininetConfigFile, FileMode.Create))) {\n                    string jsonString = JsonConvert.SerializeObject(_userSettings, Formatting.Indented);\n                    sw.Write(jsonString);\n                    sw.Flush();\n                }\n            } catch (IOException e) {\n                Logging.LogUsefulException(e);\n            }\n        }\n        private static void Read()\n        {\n            try {\n                string configContent = File.ReadAllText(_userWininetConfigFile);\n                _userSettings = JsonConvert.DeserializeObject<SysproxyConfig>(configContent);\n            } catch (FileNotFoundException) {\n                _userSettings = new SysproxyConfig();
            string[] userSettingsArr = str.Split(new string[] { "\r\n" }, StringSplitOptions.RemoveEmptyEntries);\n            _userSettings.Flags = userSettingsArr[0];\n            // handle output from WinINET\n            if (userSettingsArr[1] == "(null)") _userSettings.ProxyServer = null;\n            else _userSettings.ProxyServer = userSettingsArr[1];\n            if (userSettingsArr[2] == "(null)") _userSettings.BypassList = null;\n            else _userSettings.BypassList = userSettingsArr[2];\n            if (userSettingsArr[3] == "(null)") _userSettings.PacUrl = null;\n            else _userSettings.PacUrl = userSettingsArr[3];\n            _userSettings.UserSettingsRecorded = true;
﻿using Shadowsocks.Controller;\nusing Shadowsocks.Properties;\nusing System;


        private void OtaUpdateKeyBuffer()\n        {\n            if (_otaChunkKeyBuffer == null)\n            {\n                _otaChunkKeyBuffer = new byte[MAX_IV_LENGTH + 4];\n                Buffer.BlockCopy(_encryptIV, 0, _otaChunkKeyBuffer, 0, ivLen);\n            }\n            byte[] counter_bytes = BitConverter.GetBytes((uint)IPAddress.HostToNetworkOrder((int)_otaChunkCounter));\n            Buffer.BlockCopy(counter_bytes, 0, _otaChunkKeyBuffer, ivLen, 4);\n            _otaChunkCounter++;\n        }\n        private byte[] OtaGenChunkHash(byte[] buf, int offset, int len)
            OtaUpdateKeyBuffer();\n            Sodium.ss_sha1_hmac_ex(_otaChunkKeyBuffer, (uint)_otaChunkKeyBuffer.Length,
                int headLen = OtaGetHeadLen(buf, length);
                byte[] hash = OtaGenHash(buf, headLen);
            byte[] hash = OtaGenHash(buf, length);
                    OtaAuthBuffer4Tcp(buf, ref length);
                    OtaAuthBuffer4Udp(buf, ref length);\n                }\n            }\n        }\n        #endregion\n        protected static void randBytes(byte[] buf, int length)\n        {\n            byte[] temp = new byte[length];\n            RNGCryptoServiceProvider rngServiceProvider = new RNGCryptoServiceProvider();\n            rngServiceProvider.GetBytes(temp);\n            temp.CopyTo(buf, 0);
                outlength = length + ivLen;\n                OtaAuthBuffer(buf, ref length);
namespace shadowsocks_csharp.Properties {\n    using System;
        internal static global::System.Resources.ResourceManager ResourceManager {\n            get {\n                if (object.ReferenceEquals(resourceMan, null)) {
        private bool SaveValidConfiguration()\n        {\n            if (!ValidateAndSaveSelectedServerDetails())\n            {\n                return false;
                return false;
            return true;\n        }\n        private void ConfigForm_KeyDown(object sender, KeyEventArgs e)\n        {\n            // Sometimes the users may hit enter key by mistake, and the form will close without saving entries.\n            if (e.KeyCode == Keys.Enter)\n            {\n                SaveValidConfiguration();\n            }\n        }\n        private void ServersListBox_SelectedIndexChanged(object sender, EventArgs e)\n        {\n            if (!ServersListBox.CanSelect)\n            {\n                return;\n            }\n            if (_lastSelectedIndex == ServersListBox.SelectedIndex)\n            {\n                // we are moving back to oldSelectedIndex or doing a force move\n                return;\n            }\n            if (!ValidateAndSaveSelectedServerDetails())\n            {\n                // why this won't cause stack overflow?\n                ServersListBox.SelectedIndex = _lastSelectedIndex;\n                return;\n            }\n            if (_lastSelectedIndex >= 0)\n            {\n                ServersListBox.Items[_lastSelectedIndex] = _modifiedConfiguration.configs[_lastSelectedIndex].FriendlyName();\n            }\n            UpdateButtons();\n            LoadSelectedServerDetails();\n            _lastSelectedIndex = ServersListBox.SelectedIndex;\n        }\n        private void AddButton_Click(object sender, EventArgs e)\n        {\n            if (!ValidateAndSaveSelectedServerDetails())\n            {\n                return;\n            }\n            Server server = Configuration.GetDefaultServer();\n            _modifiedConfiguration.configs.Add(server);\n            LoadServerNameListToUI(_modifiedConfiguration);\n            ServersListBox.SelectedIndex = _modifiedConfiguration.configs.Count - 1;\n            _lastSelectedIndex = ServersListBox.SelectedIndex;\n        }\n        private void DuplicateButton_Click(object sender, EventArgs e)\n        {\n            if (!ValidateAndSaveSelectedServerDetails())\n            {\n                return;\n            }\n            Server currServer = _modifiedConfiguration.configs[_lastSelectedIndex];\n            var currIndex = _modifiedConfiguration.configs.IndexOf(currServer);\n            _modifiedConfiguration.configs.Insert(currIndex + 1, currServer);\n            LoadServerNameListToUI(_modifiedConfiguration);\n            ServersListBox.SelectedIndex = currIndex + 1;\n            _lastSelectedIndex = ServersListBox.SelectedIndex;\n        }\n        private void DeleteButton_Click(object sender, EventArgs e)\n        {\n            _lastSelectedIndex = ServersListBox.SelectedIndex;\n            if (_lastSelectedIndex >= 0 && _lastSelectedIndex < _modifiedConfiguration.configs.Count)\n            {\n                _modifiedConfiguration.configs.RemoveAt(_lastSelectedIndex);\n            }\n            if (_lastSelectedIndex >= _modifiedConfiguration.configs.Count)\n            {\n                // can be -1\n                _lastSelectedIndex = _modifiedConfiguration.configs.Count - 1;\n            }\n            ServersListBox.SelectedIndex = _lastSelectedIndex;\n            LoadServerNameListToUI(_modifiedConfiguration);\n            ServersListBox.SelectedIndex = _lastSelectedIndex;\n            LoadSelectedServerDetails();\n        }\n        private void OKButton_Click(object sender, EventArgs e)\n        {\n            if (SaveValidConfiguration())\n            {\n                this.Close();\n            }

            _config.GetCurrentServer().bandwidthIn = inboundCounter;
            _config.GetCurrentServer().bandwidthOut = outboundCounter;
            inboundCounter = _config.GetCurrentServer().bandwidthIn;\n            outboundCounter = _config.GetCurrentServer().bandwidthOut;
            this.bindingConfiguration = new System.Windows.Forms.BindingSource(this.components);

            // bindingConfiguration\n            // \n            this.bindingConfiguration.DataSource = typeof(Shadowsocks.Model.StatisticsStrategyConfiguration);
            _configuration = _controller.StatisticsConfiguration

        public static string PAC_FILE = "pac.txt";

        private static string PAC_FILE = PACServer.PAC_FILE;\n        public event EventHandler UpdateCompleted;

                string[] lines = ParseResult(e.Result);\n                JsonArray rules = new JsonArray();\n                rules.AddRange(lines);\n                string abpContent = Utils.UnGzip(Resources.abp_js);\n                abpContent = abpContent.Replace("__RULES__", rules.ToString());\n                File.WriteAllText(PAC_FILE, abpContent, Encoding.UTF8);\n                if (UpdateCompleted != null)
                    UpdateCompleted(this, new EventArgs());
                if (Error != null)\n                {\n                    Error(this, new ErrorEventArgs(ex));\n                }
        public void UpdatePACFromGFWList()
            WebClient http = new WebClient();\n            http.DownloadStringCompleted += http_DownloadStringCompleted;\n            http.DownloadStringAsync(new Uri(GFWLIST_URL));\n        }\n        public string[] ParseResult(string response)\n        {\n            byte[] bytes = Convert.FromBase64String(response);\n            string content = Encoding.ASCII.GetString(bytes);\n            string[] lines = content.Split(new char[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);\n            List<string> valid_lines = new List<string>(lines.Length);\n            foreach (string line in lines)
                if (line.StartsWith("!") || line.StartsWith("["))\n                    continue;\n                valid_lines.Add(line);
            return valid_lines.ToArray();
        private void pacServer_PACUpdateError(object sender, ErrorEventArgs e)
    public class Utils
            temppath = Utils.GetTempPath();
                DateTime now = DateTime.Now;\n                if (now - _lastSweepTime > TimeSpan.FromSeconds(1))\n                {\n                    _lastSweepTime = now;\n                    foreach (Handler handler1 in this.Handlers)\n                    {\n                        if (now - handler1.lastActivity > TimeSpan.FromSeconds(1800))\n                        {\n                            handlersToClose.Add(handler1);\n                        }\n                    }\n                }\n            }\n            foreach (Handler handler1 in handlersToClose)\n            {\n                Logging.Debug("Closing timed out connection");\n                handler1.Close();\n            }\n        return true;


        if (mode.Equals(Mode.BYTE))\n            append8BitBytes(content, bits, encoding);
                throw new WriterException("Invalid mode: " + mode);



using System.Threading.Tasks;\nusing System.Windows.Forms;
        //hardcode\n        //TODO: backup reliable isp&geolocation provider or a local database is required\n        private static async Task<DataList> getGeolocationAndISP()
            var ret = new List<DataList>();\n            foreach (var timestamp in Enumerable.Range(0, Repeat).Select(_ => DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss")))
                //ICMP echo. we can also set options and special bytes\n                var reply = await ping.SendTaskAsync(server.server, Timeout);\n                ret.Add(new List<KeyValuePair<string, string>>
                    new KeyValuePair<string, string>("Timestamp", timestamp),\n                    new KeyValuePair<string, string>("Server", server.FriendlyName()),\n                    new KeyValuePair<string, string>("Status", reply?.Status.ToString()),\n                    new KeyValuePair<string, string>("RoundtripTime", reply?.RoundtripTime.ToString())\n                    //new KeyValuePair<string, string>("data", reply.Buffer.ToString()); // The data of reply\n                });\n            }\n            return ret;\n        }\n        private async void Evaluate(object obj)\n        {\n            var geolocationAndIsp = getGeolocationAndISP();\n            foreach (var dataLists in await TaskEx.WhenAll(_servers.Select(ICMPTest)))\n            {\n                await geolocationAndIsp;\n                foreach (var dataList in dataLists)\n                {\n                    Append(dataList, geolocationAndIsp.Result);
        private static void Append(DataList dataList, IEnumerable<DataUnit> extra)
            public static Asset ParseAsset(JObject assertJObject)\n            {\n                var name = (string) assertJObject["name"];
                        browser_download_url = (string) assertJObject["browser_download_url"],

        #region Traffic Chart\n        Queue<TrafficInfo> trafficInfoQueue = new Queue<TrafficInfo>();\n        const int queueMaxLength = 60;\n        long lastInbound, lastOutbound;\n        long maxSpeed = 0, lastMaxSpeed = 0;\n        const long minScale = 50;\n        BandwidthScaleInfo bandwidthScale;\n        List<float> inboundPoints = new List<float>();\n        List<float> outboundPoints = new List<float>();\n        TextAnnotation inboundAnnotation = new TextAnnotation();\n        TextAnnotation outboundAnnotation = new TextAnnotation();
        private void UpdateTrafficChart()\n        {
                if (trafficInfoQueue.Count == 0)
                inboundPoints.Clear();\n                outboundPoints.Clear();\n                maxSpeed = 0;\n                foreach (var trafficInfo in trafficInfoQueue)\n                {\n                    inboundPoints.Add(trafficInfo.inbound);\n                    outboundPoints.Add(trafficInfo.outbound);\n                    maxSpeed = Math.Max(maxSpeed, Math.Max(trafficInfo.inbound, trafficInfo.outbound));\n                }\n                lastInbound = trafficInfoQueue.Last().inbound;\n                lastOutbound = trafficInfoQueue.Last().outbound;
        public Queue<TrafficPerSecond> trafficPerSecondQueue;

            trafficPerSecondQueue = new Queue<TrafficPerSecond>();
                trafficPerSecondQueue.Enqueue(new TrafficPerSecond());
                previous = trafficPerSecondQueue.Last();\n                current = new TrafficPerSecond();\n                current.inboundCounter = InboundCounter;\n                current.outboundCounter = OutboundCounter;\n                current.inboundIncreasement = current.inboundCounter - previous.inboundCounter;\n                current.outboundIncreasement = current.outboundCounter - previous.outboundCounter;\n                trafficPerSecondQueue.Enqueue(current);\n                if (trafficPerSecondQueue.Count > queueMaxSize)\n                    trafficPerSecondQueue.Dequeue();
        public TCPRelay tcprelay;
        private int _totalRead = 0;\n        private int _totalWrite = 0;\n        private byte[] _remoteRecvBuffer = new byte[BufferSize];\n        private byte[] _remoteSendBuffer = new byte[BufferSize];\n        private byte[] _connetionRecvBuffer = new byte[BufferSize];\n        private byte[] _connetionSendBuffer = new byte[BufferSize];\n        private bool _connectionShutdown = false;\n        private bool _remoteShutdown = false;\n        private bool _closed = false;\n        private object _encryptionLock = new object();\n        private object _decryptionLock = new object();
            toolbarTrigger = !toolbarTrigger;\n            ToolbarFlowLayoutPanel.Visible = toolbarTrigger;\n            ShowToolbarMenuItem.Checked = toolbarTrigger;
        public const int RecvSize = 16384;\n        public const int BufferSize = RecvSize + 32;
        public byte[] remoteRecvBuffer = new byte[RecvSize];\n        // remote send buffer\n        public byte[] remoteSendBuffer = new byte[BufferSize];
        public byte[] connetionRecvBuffer = new byte[RecvSize];\n        // connection send buffer\n        public byte[] connetionSendBuffer = new byte[BufferSize];
                remote.BeginReceive(remoteRecvBuffer, 0, RecvSize, 0,
                connection.BeginReceive(connetionRecvBuffer, 0, RecvSize, 0,
        static byte[] tempbuf = new byte[32768];\n        public override void Encrypt(byte[] buf, int length, byte[] outbuf, out int outlength)
                OpenSSL.RAND_bytes(outbuf, ivLen);\n                InitCipher(ref _encryptCtx, outbuf, true);\n                outlength = length + ivLen;\n                OpenSSL.EVP_CipherUpdate(_encryptCtx, tempbuf, out outlength, buf, length);\n                outlength = length + ivLen;\n                Buffer.BlockCopy(tempbuf, 0, outbuf, ivLen, outlength);
                outlength = length;\n                OpenSSL.EVP_CipherUpdate(_encryptCtx, outbuf, out outlength, buf, length);
        public override void Decrypt(byte[] buf, int length, byte[] outbuf, out int outlength)
                InitCipher(ref _decryptCtx, buf, false);\n                outlength = length - ivLen;\n                Buffer.BlockCopy(buf, ivLen, tempbuf, 0, length - ivLen);\n                OpenSSL.EVP_CipherUpdate(_decryptCtx, outbuf, out outlength, tempbuf, length - ivLen);
                outlength = length;\n                OpenSSL.EVP_CipherUpdate(_decryptCtx, outbuf, out outlength, buf, length);
    public interface IEncryptor : IDisposable
        void Encrypt(byte[] buf, int length, byte[] outbuf, out int outlength);\n        void Decrypt(byte[] buf, int length, byte[] outbuf, out int outlength);
        public override void Encrypt(byte[] buf, int length, byte[] outbuf, out int outlength)
                outbuf[i] = _encryptTable[buf[i]];
            outlength = length;
        public override void Decrypt(byte[] buf, int length, byte[] outbuf, out int outlength)
                outbuf[i] = _decryptTable[buf[i]];
            outlength = length;
    static class AutoStartup
        // Don't use Application.ExecutablePath\n        // see https://stackoverflow.com/questions/12945805/odd-c-sharp-path-issue\n        private static readonly string ExecutablePath = Assembly.GetEntryAssembly().Location;\n        private static string Key = "Shadowsocks_" + Application.StartupPath.GetHashCode();

                    runKey.SetValue(Key, ExecutablePath);
                            runKey.SetValue(Key, ExecutablePath);
        public DateTime lastActivity;\n        private ShadowsocksController   _controller;\n        private Configuration           _config;\n        private TCPRelay                _tcprelay;\n        private Socket                  _connection;\n        private IEncryptor  _encryptor;\n        private Server      _server;
        private const int   MaxRetry = 4;\n        private int         _retryCount = 0;\n        private bool        _proxyConnected;\n        private bool        _destConnected;\n        private byte    _command;\n        private byte[]  _firstPacket;\n        private int     _firstPacketLength;\n        private int     _totalRead = 0;\n        private int     _totalWrite = 0;\n        private byte[]  _remoteRecvBuffer = new byte[BufferSize];\n        private byte[]  _remoteSendBuffer = new byte[BufferSize];\n        private byte[]  _connetionRecvBuffer = new byte[BufferSize];\n        private byte[]  _connetionSendBuffer = new byte[BufferSize];\n        private bool    _connectionShutdown = false;\n        private bool    _remoteShutdown = false;\n        private bool    _closed = false;\n        private object  _encryptionLock = new object();\n        private object  _decryptionLock = new object();
        public TCPHandler(ShadowsocksController controller, Configuration config, TCPRelay tcprelay, Socket socket)\n        {\n            this._controller = controller;\n            this._config = config;
            this._connection = socket;
            lock (this)\n            {
            lock (_tcprelay.Handlers)\n            {\n                _tcprelay.Handlers.Remove(this);\n            }\n            try\n            {\n                _connection?.Shutdown(SocketShutdown.Both);\n                _connection?.Close();
                throw new Exception("Cannot set mbed TLS cipher key");
                throw new Exception("Cannot set mbed TLS cipher IV");
                throw new Exception("Cannot finalize mbed TLS cipher context");
                    ? Resources.zh_TW\n                    : Resources.zh_CN);
                Init(Resources.ja);
        private ShadowsocksController _controller;
        public UDPRelay(ShadowsocksController controller)
            this._controller = controller;
                + "\n" + serverInfo;
            enableItem.Checked = controller.GetConfigurationCopy().enabled;
            ShareOverLANItem.Checked = controller.GetConfigurationCopy().shareOverLan;
            globalModeItem.Checked = controller.GetConfigurationCopy().global;
            int i = 0;\n            foreach (var strategy in controller.GetStrategies())\n            {\n                MenuItem item = new MenuItem(I18N.GetString(strategy.Name));\n                item.Tag = strategy.ID;\n                item.Click += AStrategyItem_Click;\n                items.Add(i, item);\n                i++;\n            }\n            Configuration configuration = controller.GetConfigurationCopy();\n            foreach (var server in configuration.configs)\n            {
                i++;\n            }\n            foreach (MenuItem item in items)\n            {\n                if (item.Tag != null && (item.Tag.ToString() == configuration.index.ToString() || item.Tag.ToString() == configuration.strategy))\n                {\n                    item.Checked = true;\n                }
        private ShadowsocksController _controller;\n        public TCPRelay(ShadowsocksController controller)\n        {\n            this._controller = controller;
        public Configuration GetConfigurationCopy()
            if (config.index < -1)
                config.index = -1;
        private void ResponseCallback(IAsyncResult ar)
                    if (_controller != null)\n                    {\n                        _controller.Stop();\n                        Logging.Info("controller stopped");\n                    }
                if (_controller != null)\n                {\n                    _controller.Start();\n                    Logging.Info("controller started");\n                }
            string tag = string.Empty;\n            string auth = server.auth ? "-auth" : string.Empty;\n            string parts = $"{server.method}{auth}:{server.password}@{server.server}:{server.server_port}";
            if(!server.remarks.IsNullOrEmpty())\n            {\n                tag = $"#{HttpUtility.UrlEncode(server.remarks, Encoding.UTF8)}";\n            }\n            return $"ss://{base64}{tag}";
            var tag = match.Groups[3].Value;
                remarks = HttpUtility.UrlDecode(tag, Encoding.UTF8);


                if (bytesRead > 1)
                if (_encryptCtx.ToInt64() != 0)
                if (_decryptCtx.ToInt64() != 0)
                defConnection[optionsOffset] = (byte)(defConnection[optionsOffset] | 8);\n                savedLegacySetting[optionsOffset] = (byte)(savedLegacySetting[optionsOffset] | 8);
                defConnection[optionsOffset] = (byte)(defConnection[optionsOffset] & ~8);\n                savedLegacySetting[optionsOffset] = (byte)(savedLegacySetting[optionsOffset] & ~8);
            BitConverter.GetBytes(\n                unchecked(BitConverter.ToUInt32(defConnection, versionOffset) + 1))\n                .CopyTo(defConnection, versionOffset);\n            BitConverter.GetBytes(\n                unchecked(BitConverter.ToUInt32(savedLegacySetting, versionOffset) + 1))\n                .CopyTo(savedLegacySetting, versionOffset);
    using Statistics = Dictionary<string, List<StatisticsRecord>>;


        private TimeSpan RecordingInterval => TimeSpan.FromMinutes(_config.DataCollectionMinutes);
                    if (_recorder?.Change(_delayBeforeStart, RecordingInterval) == null)\n                    {\n                        _recorder = new Timer(Run, null, _delayBeforeStart, RecordingInterval);\n                    }\n                    LoadRawStatistics();\n                    if (_speedMonior?.Change(_delayBeforeStart, _monitorInterval) == null)\n                    {\n                        _speedMonior = new Timer(UpdateSpeed, null, _delayBeforeStart, _monitorInterval);\n                    }\n                    if (_writer?.Change(_delayBeforeStart, RecordingInterval) == null)\n                    {\n                        _writer = new Timer(Save, null, _delayBeforeStart, RecordingInterval);
                    _recorder?.Dispose();
            var inboundSpeed = GetSpeedInKiBPerSecond(bytes, _monitorInterval.TotalSeconds);\n            _inboundSpeedRecords.Add(inboundSpeed);
            _outboundSpeedRecords.Add(outboundSpeed);\n            Logging.Debug(\n                $"{_currentServer.FriendlyName()}: current/max inbound {inboundSpeed}/{_inboundSpeedRecords.Max()} KiB/s, current/max outbound {outboundSpeed}/{_outboundSpeedRecords.Max()} KiB/s");\n        }\n        private async Task<ICMPResult> ICMPTest(Server server)
            var result = new ICMPResult(server);\n            try\n            {\n                var IP =\n                    Dns.GetHostAddresses(server.server)\n                        .First(\n                            ip =>\n                                ip.AddressFamily == AddressFamily.InterNetwork ||\n                                ip.AddressFamily == AddressFamily.InterNetworkV6);
                foreach (var _ in Enumerable.Range(0, Repeat))\n                {
                        if (!reply.Status.Equals(IPStatus.Success))\n                        {\n                            result.RoundtripTime.Add((int?) reply.RoundtripTime);\n                        }\n                        else\n                        {\n                            result.RoundtripTime.Add(null);\n                        }
            return result;\n        }\n        private void Reset()\n        {\n            _inboundSpeedRecords = new List<int>();\n            _outboundSpeedRecords = new List<int>();\n            _latencyRecords = new List<int>();\n        }\n        private void Run(object _)\n        {\n            AppendRecord();\n            Reset();
        }\n        private async void AppendRecord()\n        {\n            //todo: option for icmp test\n            var icmpResults = TaskEx.WhenAll(_servers.Select(ICMPTest));\n            var currentServerRecord = new StatisticsRecord(_currentServer.Identifier(),\n                _inboundSpeedRecords, _outboundSpeedRecords, _latencyRecords);\n            foreach (var result in (await icmpResults).Where(result => result != null))\n            {\n                List<StatisticsRecord> records;\n                if (!RawStatistics.TryGetValue(result.Server.Identifier(), out records))\n                {\n                    records = new List<StatisticsRecord>();\n                }\n                if (result.Server.Equals(_currentServer))\n                {\n                    currentServerRecord.setResponse(result.RoundtripTime);\n                    records.Add(currentServerRecord);\n                }\n                else\n                {\n                    records.Add(new StatisticsRecord(result.Server.Identifier(), result.RoundtripTime));\n                }\n                RawStatistics[result.Server.Identifier()] = records;\n            }\n        }\n        private void Save(object _)\n        {\n            try\n            {\n                File.WriteAllText(AvailabilityStatisticsFile,\n                    JsonConvert.SerializeObject(RawStatistics, Formatting.None));\n            }\n            catch (IOException e)\n            {\n                Logging.LogUsefulException(e);\n                _writer.Change(_retryInterval, _writingInterval);\n            }\n        }\n        /*
            _currentServer = _controller.GetCurrentServer();\n            Reset();
            foreach (var serverAndRecords in RawStatistics)\n            {\n                var server = serverAndRecords.Key;\n                var filteredRecords = serverAndRecords.Value.FindAll(IsValidRecord);\n                FilteredStatistics[server] = filteredRecords;
                    if (!File.Exists(path))\n                    {\n                        Console.WriteLine(\n                            $"statistics file does not exist, try to reload {_retryInterval.TotalMinutes} minutes later");\n                        _recorder.Change(_retryInterval, RecordingInterval);
                RawStatistics = JsonConvert.DeserializeObject<Statistics>(File.ReadAllText(path)) ?? RawStatistics;
            return !DateTime.TryParseExact(str, DateTimePattern, null, DateTimeStyles.None, out dateTime)\n                ? UnknownDateTime\n                : dateTime;
            _latencyRecords.Add(latency);
            List<StatisticsRecord> statistics;
            IEnumerable<IGrouping<int, StatisticsRecord>> dataGroups;
        private Statistics _filteredStatistics;\n        private AvailabilityStatistics Service => _controller.availabilityStatistics;
            _filteredStatistics =\n                Service.FilteredStatistics ??\n                Service.RawStatistics ??\n                _filteredStatistics;
            List<StatisticsRecord> records;\n            if (_filteredStatistics == null || !_filteredStatistics.TryGetValue(serverName, out records)) return 0;
            score += averageRecord.PackageLoss*factor ?? 0;
            score += averageRecord.AverageResponse*factor ?? 0;
            score += averageRecord.MinResponse*factor ?? 0;
            score += averageRecord.MaxResponse*factor ?? 0;\n            Logging.Debug($"{JsonConvert.SerializeObject(averageRecord, Formatting.Indented)}");

            this.tableLayoutPanel1.Location = new System.Drawing.Point(12, 31);\n            this.tableLayoutPanel1.Margin = new System.Windows.Forms.Padding(7, 7, 7, 7);
            this.tableLayoutPanel1.Padding = new System.Windows.Forms.Padding(7, 7, 7, 7);
            this.RemarksTextBox.Location = new System.Drawing.Point(110, 194);\n            this.RemarksTextBox.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);
            this.label6.Location = new System.Drawing.Point(27, 197);\n            this.label6.Margin = new System.Windows.Forms.Padding(5, 0, 5, 0);
            this.label1.Location = new System.Drawing.Point(26, 15);\n            this.label1.Margin = new System.Windows.Forms.Padding(5, 0, 5, 0);
            this.label2.Location = new System.Drawing.Point(12, 51);\n            this.label2.Margin = new System.Windows.Forms.Padding(5, 0, 5, 0);
            this.ProxyPortTextBox.Location = new System.Drawing.Point(110, 158);\n            this.ProxyPortTextBox.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);
            this.label4.Location = new System.Drawing.Point(20, 161);\n            this.label4.Margin = new System.Windows.Forms.Padding(5, 0, 5, 0);
            this.label3.Location = new System.Drawing.Point(22, 87);\n            this.label3.Margin = new System.Windows.Forms.Padding(5, 0, 5, 0);
            this.IPTextBox.Location = new System.Drawing.Point(110, 12);\n            this.IPTextBox.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);
            this.ServerPortTextBox.Location = new System.Drawing.Point(110, 48);\n            this.ServerPortTextBox.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);
            this.PasswordTextBox.Location = new System.Drawing.Point(110, 84);\n            this.PasswordTextBox.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);
            this.label5.Location = new System.Drawing.Point(16, 124);\n            this.label5.Margin = new System.Windows.Forms.Padding(5, 0, 5, 0);
            this.EncryptionSelect.Location = new System.Drawing.Point(110, 120);\n            this.EncryptionSelect.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);


            this.panel2.Location = new System.Drawing.Point(246, 263);\n            this.panel2.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);
            this.OKButton.Location = new System.Drawing.Point(6, 6);\n            this.OKButton.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);
            this.MyCancelButton.Location = new System.Drawing.Point(130, 6);\n            this.MyCancelButton.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);
            this.DeleteButton.Location = new System.Drawing.Point(150, 6);\n            this.DeleteButton.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);
            this.AddButton.Location = new System.Drawing.Point(6, 6);\n            this.AddButton.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);
            this.ServerGroupBox.Location = new System.Drawing.Point(334, 18);\n            this.ServerGroupBox.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);
            this.ServerGroupBox.Padding = new System.Windows.Forms.Padding(5, 5, 5, 5);\n            this.ServerGroupBox.Size = new System.Drawing.Size(383, 307);
            this.ServersListBox.ItemHeight = 20;\n            this.ServersListBox.Location = new System.Drawing.Point(18, 18);\n            this.ServersListBox.Margin = new System.Windows.Forms.Padding(5, 5, 5, 5);
            if (!File.Exists(PAC_FILE))
                GeositeUpdater.MergeAndWritePACFile();
            return File.ReadAllText(PAC_FILE, Encoding.UTF8);

                _lastSelectedIndex = (ServersListBox.SelectedIndex = lastIndex);
                _lastSelectedIndex = (ServersListBox.SelectedIndex = _modifiedConfiguration.configs.Count - 1);
                Configuration.AddDefaultServerOrServer(_modifiedConfiguration, currServer, _lastSelectedIndex + 1);
                _lastSelectedIndex = (ServersListBox.SelectedIndex = (_lastSelectedIndex + 1));
            var server = _modifiedConfiguration.configs[_lastSelectedIndex];\n            var newIndex = _lastSelectedIndex + step;\n            _modifiedConfiguration.configs.RemoveAt(_lastSelectedIndex);\n            _modifiedConfiguration.configs.Insert(newIndex, server);
            LoadServerNameListToUI(_modifiedConfiguration);\n            _lastSelectedIndex = newIndex;\n            ServersListBox.SelectedIndex = newIndex;
            lock (ctx)\n            {\n                byte[] realkey;\n                if (_method == "rc4-md5")\n                {\n                    byte[] temp = new byte[keyLen + ivLen];\n                    realkey = new byte[keyLen];\n                    Array.Copy(_key, 0, temp, 0, keyLen);\n                    Array.Copy(iv, 0, temp, keyLen, ivLen);\n                    realkey = MD5.Create().ComputeHash(temp);
                    realkey = _key;\n                }\n                if (_cipher == CIPHER_AES)\n                {\n                    PolarSSL.aes_init(ctx);\n                    // PolarSSL takes key length by bit\n                    // since we'll use CFB mode, here we both do enc, not dec\n                    PolarSSL.aes_setkey_enc(ctx, realkey, keyLen * 8);\n                    if (isCipher)\n                    {\n                        _encryptIV = new byte[ivLen];\n                        Array.Copy(iv, _encryptIV, ivLen);\n                    }\n                    else\n                    {\n                        _decryptIV = new byte[ivLen];\n                        Array.Copy(iv, _decryptIV, ivLen);\n                    }\n                }\n                else if (_cipher == CIPHER_BF)\n                {\n                    PolarSSL.blowfish_init(ctx);\n                    // PolarSSL takes key length by bit\n                    PolarSSL.blowfish_setkey(ctx, realkey, keyLen * 8);\n                    if (isCipher)\n                    {\n                        _encryptIV = new byte[ivLen];\n                        Array.Copy(iv, _encryptIV, ivLen);\n                    }\n                    else\n                    {\n                        _decryptIV = new byte[ivLen];\n                        Array.Copy(iv, _decryptIV, ivLen);\n                    }\n                }\n                else if (_cipher == CIPHER_RC4)\n                {\n                    PolarSSL.arc4_init(ctx);\n                    PolarSSL.arc4_setup(ctx, realkey, keyLen);\n                }
                            PolarSSL.aes_crypt_cfb128(_encryptCtx, PolarSSL.AES_ENCRYPT, length, ref _encryptIVOffset, _encryptIV, buf, outbuf);
                            PolarSSL.blowfish_crypt_cfb64(_encryptCtx, PolarSSL.BLOWFISH_ENCRYPT, length, ref _encryptIVOffset, _encryptIV, buf, outbuf);
                            PolarSSL.arc4_crypt(_encryptCtx, length, buf, outbuf);\n                            break;\n                    }
                            PolarSSL.aes_crypt_cfb128(_decryptCtx, PolarSSL.AES_DECRYPT, length, ref _decryptIVOffset, _decryptIV, buf, outbuf);
                            PolarSSL.blowfish_crypt_cfb64(_decryptCtx, PolarSSL.BLOWFISH_DECRYPT, length, ref _decryptIVOffset, _decryptIV, buf, outbuf);
                            PolarSSL.arc4_crypt(_decryptCtx, length, buf, outbuf);\n                            break;\n                    }
            lock (this)\n            {\n                if (_disposed)\n                {\n                    return;\n                }\n                _disposed = true;\n            }\n            if (disposing)\n            {
                    lock (_encryptCtx)\n                    {\n                        switch (_cipher)\n                        {\n                            case CIPHER_AES:\n                                PolarSSL.aes_free(_encryptCtx);\n                                break;\n                            case CIPHER_BF:\n                                PolarSSL.blowfish_free(_encryptCtx);\n                                break;\n                            case CIPHER_RC4:\n                                PolarSSL.arc4_free(_encryptCtx);\n                                break;\n                        }\n                        _encryptCtx = null;
                    lock (_decryptCtx)\n                    {\n                        switch (_cipher)\n                        {\n                            case CIPHER_AES:\n                                PolarSSL.aes_free(_decryptCtx);\n                                break;\n                            case CIPHER_BF:\n                                PolarSSL.blowfish_free(_decryptCtx);\n                                break;\n                            case CIPHER_RC4:\n                                PolarSSL.arc4_free(_decryptCtx);\n                                break;\n                        }\n                        _decryptCtx = null;\n                    }\n                }
                string pacContent = $"var __PROXY__ = '{proxy}';\n" + _pacDaemon.GetPACContent();\n                string responseHead = \n$@"HTTP/1.1 200 OK\nServer: ShadowsocksWindows/{UpdateChecker.Version}
Content-Length: { Encoding.UTF8.GetBytes(pacContent).Length}
            try
                using (var fs = new FileStream(path, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))\n                using (var sr = new StreamReader(fs, encoding))\n                {\n                    return sr.ReadToEnd();\n                }\n            }\n            catch (Exception ex)\n            {\n                Logging.Error(ex);\n                throw ex;
        const int SODIUM_BLOCK_SIZE = 64;\n        protected int _encryptBytesRemaining;\n        protected int _decryptBytesRemaining;
            // TODO write a unidirection cipher so we don't have to if if if\n            int bytesRemaining;
[assembly: AssemblyTitle("Shadowsocks")]
[assembly: AssemblyProduct("Shadowsocks")]
﻿using shadowsocks_csharp.Properties;\nusing System;
            {\n                string tempPath = Path.GetTempPath();\n                string dllPath = tempPath + "/polarssl.dll";\n                PolipoRunner.UncompressFile(dllPath, Resources.polarssl_dll);\n                LoadLibrary(dllPath);
                TldIndex tldIndex = GetTldIndex();
                    if (!tldIndex.Contains(last_root_domain))
            private TldIndex GetTldIndex()
                TldIndex index = new TldIndex();
                    index.Add(tld);\n                }\n                return index;\n            }\n            private string[] GetBuildIn()\n            {\n                string[] buildin = null;\n                byte[] builtinGZ = Resources.builtin_txt;\n                byte[] buffer = new byte[1024];\n                int n;\n                using (MemoryStream sb = new MemoryStream())\n                {\n                    using (GZipStream input = new GZipStream(new MemoryStream(builtinGZ),\n                        CompressionMode.Decompress, false))\n                    {\n                        while ((n = input.Read(buffer, 0, buffer.Length)) > 0)\n                        {\n                            sb.Write(buffer, 0, n);\n                        }\n                    }\n                    buildin = System.Text.Encoding.UTF8.GetString(sb.ToArray())\n                        .Split(new char[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);\n                }\n                return buildin;\n            }\n            class TldIndex\n            {\n                List<string> patterns = new List<string>();\n                IDictionary<string, string> dic = new Dictionary<string, string>();\n                public void Add(string tld)\n                {\n                    if (string.IsNullOrEmpty(tld))\n                        return;\n                    if (tld.IndexOfAny(new char[] { '*', '?' }) >= 0)\n                    {\n                        patterns.Add("^" + Regex.Escape(tld).Replace("\\*", ".*").Replace("\\?", ".") + "$");\n                    }\n                    else if (!dic.ContainsKey(tld))\n                    {
                    }\n                }\n                public bool Contains(string tld)\n                {\n                    if (dic.ContainsKey(tld))\n                        return true;\n                    foreach(string pattern in patterns)\n                    {\n                        if (Regex.IsMatch(tld, pattern))\n                            return true;\n                    }\n                    return false;\n                }
                    Logging.Info($"HA switching to server: {_currentServer.server.FriendlyName()}");
            Logging.Debug($"latency: {server.FriendlyName()} {latency}");
            Logging.Debug($"last read: {server.FriendlyName()}");
            Logging.Debug($"last write: {server.FriendlyName()}");
            Logging.Debug($"failure: {server.FriendlyName()}");
            catch (Exception e)
                Logging.LogUsefulException(e);
            Console.WriteLine("[D] " + o);
        ShadowsocksController.QueueLast<TrafficInfo> traffic = new ShadowsocksController.QueueLast<TrafficInfo>();
            BandwidthScaleInfo bandwidthScale;
                    inboundPoints.Add(trafficPerSecond.inbound);\n                    outboundPoints.Add(trafficPerSecond.outbound);\n                    maxSpeed = Math.Max(maxSpeed, Math.Max(trafficPerSecond.inbound, trafficPerSecond.outbound));\n                }\n                lastInbound = traffic.Last().inbound;\n                lastOutbound = traffic.Last().outbound;
            inboundPoints = inboundPoints.Select(p => p / bandwidthScale.unit).ToList();\n            outboundPoints = outboundPoints.Select(p => p / bandwidthScale.unit).ToList();
                trafficChart.ChartAreas[0].AxisY.LabelStyle.Format = "{0:0.##} " + bandwidthScale.unit_name;\n                trafficChart.ChartAreas[0].AxisY.Maximum = bandwidthScale.value;
                traffic = new ShadowsocksController.QueueLast<TrafficInfo>();
                    traffic.Enqueue(new TrafficInfo(trafficPerSecond.inboundIncreasement, trafficPerSecond.outboundIncreasement));
                return (bytes / (double)K).ToString("F1") + "KiB";\n            }\n            return bytes.ToString() + "B";
        public static BandwidthScaleInfo GetBandwidthScale(long n)

namespace Shadowsocks.Proxy
    public class Socks5Proxy : IProxy
namespace Shadowsocks.Proxy
    public class HttpProxy : IProxy
namespace Shadowsocks.Proxy
    public interface IProxy
namespace Shadowsocks.Proxy
    public class DirectConnect : IProxy
        public event EventHandler CheckUpdateCompleted;
                if (versions.Count != 0)
                    // sort versions\n                    SortVersions(versions);\n                    NewVersionFound = true;\n                    LatestVersionURL = versions[versions.Count - 1];\n                    LatestVersionNumber = ParseVersionFromURL(LatestVersionURL);
                if (CheckUpdateCompleted != null)
                    CheckUpdateCompleted(this, new EventArgs());
            updateChecker.CheckUpdateCompleted += updateChecker_CheckUpdateCompleted;
            Configuration config = controller.GetConfigurationCopy();\n            if (config.autoCheckUpdate)\n            {\n                _isStartupChecking = true;\n                updateChecker.CheckUpdate(config);\n            }\n            if (config.isDefault)
using Shadowsocks.Encryption.CircularBuffer;
        private ByteCircularBuffer _encCircularBuffer = new ByteCircularBuffer(TCPHandler.BufferSize * 2);\n        private ByteCircularBuffer _decCircularBuffer = new ByteCircularBuffer(TCPHandler.BufferSize * 2);
            this.Close();
            if (!RegisterAllHotkeys(out _)) // declare out as an inline discard variable\n            {\n                MessageBox.Show(I18N.GetString("Register hotkey failed"));
            this.Close();
                if (!TryRegHotkey(tb))\n                {\n                    isSuccess = false;\n                    failureInfo.AppendLine(tb.Text);\n                }\n            }\n            failureInfoStr = failureInfo.ToString();\n            return isSuccess;
            bool regResult = HotKeys.Register(hotkey, callBack);
                HotKeys.Unregister(prevHotKey);
            _modifiedHotkeyConfig.SwitchSystemProxy = SwitchSystemProxyTextBox.Text;\n            _modifiedHotkeyConfig.SwitchSystemProxyMode = SwitchProxyModeTextBox.Text;\n            _modifiedHotkeyConfig.SwitchAllowLan = SwitchAllowLanTextBox.Text;\n            _modifiedHotkeyConfig.ShowLogs = ShowLogsTextBox.Text;\n            _modifiedHotkeyConfig.ServerMoveUp = ServerMoveUpTextBox.Text;\n            _modifiedHotkeyConfig.ServerMoveDown = ServerMoveDownTextBox.Text;\n            _controller.SaveHotkeyConfig(_modifiedHotkeyConfig);
            toolbarTrigger = !toolbarTrigger;\n            ToolbarFlowLayoutPanel.Visible = toolbarTrigger;\n            ShowToolbarMenuItem.Checked = toolbarTrigger;

            ChooseNewServer();

        public static List<Server> GetServers(string ssURL)
            var matches = UrlFinder.Matches(ssURL);\n            if (matches.Count <= 0) return null;\n            List<Server> servers = new List<Server>();\n            foreach (Match match in matches)\n            {\n                Server tmp = new Server();\n                var base64 = match.Groups["base64"].Value;\n                var tag = match.Groups["tag"].Value;\n                if (!tag.IsNullOrEmpty())\n                {\n                    tmp.remarks = HttpUtility.UrlDecode(tag, Encoding.UTF8);\n                }\n                Match details = DetailsParser.Match(Encoding.UTF8.GetString(Convert.FromBase64String(\n                    base64.PadRight(base64.Length + (4 - base64.Length % 4) % 4, '='))));\n                if (!details.Success)\n                    continue;\n                tmp.method = details.Groups["method"].Value;\n                tmp.password = details.Groups["password"].Value;\n                tmp.server = details.Groups["hostname"].Value;\n                tmp.server_port = int.Parse(details.Groups["port"].Value);\n                servers.Add(tmp);\n            }\n            return servers;
        public void Encrypt(byte[] buf, int length)
            for (int i = 0; i < length; i++)
        public void Decrypt(byte[] buf, int length)
            for (int i = 0; i < length; i++)

        private readonly ShadowsocksController _controller;
        private readonly Timer _timer;\n        private Dictionary<string, StatisticsData> _statistics;\n        private const int CachedInterval = 30*60*1000; //choose a new server every 30 minutes\n        private const int RetryInterval = 2*60*1000; //choose a new server every 30 minutes
            var randomIndex = new Random().Next() % servers.Count();
            var servers = _controller.GetCurrentConfiguration().configs;
                if (!_currentServer.Equals(bestResult.server)) //output when enabled
                   LogWhenEnabled($"Switch to server: {bestResult.server.FriendlyName()} by package loss:{1 - bestResult.score}");
        private void LogWhenEnabled(string log)
            if (_controller.GetCurrentStrategy()?.ID == ID) //output when enabled\n            {\n                Console.WriteLine(log);\n            }
        public string ID => "com.shadowsocks.strategy.scbs";\n        public string Name => I18N.GetString("Choose By Total Package Loss");

            Logging.Debug($"failure: {server.FriendlyName()}");
                ShowBalloonTip(\n                    I18N.GetString("Shadowsocks is here"),\n                    I18N.GetString("You can turn on/off Shadowsocks in the context menu"),\n                    ToolTipIcon.Info,\n                    0\n                );
                string errMsg = e.ExceptionObject.ToString();\n                Logging.Error(errMsg);
            if (Interlocked.Increment(ref exited) == 1)\n            {\n                string errorMsg = $"Exception Detail: {Environment.NewLine}{e.Exception}";\n                Logging.Error(errorMsg);\n                MessageBox.Show(\n                    $"{I18N.GetString("Unexpected error, shadowsocks will exit. Please report to")} https://github.com/shadowsocks/shadowsocks-windows/issues {Environment.NewLine}{errorMsg}",\n                    "Shadowsocks UI Error", MessageBoxButtons.OK, MessageBoxIcon.Error);\n                Application.Exit();\n            }
            if (name.IsNullOrEmpty()) throw new ArgumentException(nameof(name));\n            try\n            {\n                RegistryKey userKey = RegistryKey.OpenBaseKey(RegistryHive.CurrentUser,\n                        Environment.Is64BitOperatingSystem ? RegistryView.Registry64 : RegistryView.Registry32)\n                    .OpenSubKey(name, writable);\n                return userKey;\n            }\n            catch (UnauthorizedAccessException uae)\n            {\n                Logging.LogUsefulException(uae);\n                return null;\n            }\n            catch (SecurityException se)\n            {\n                Logging.LogUsefulException(se);\n                return null;\n            }\n            catch (ArgumentException ae)\n            {\n                MessageBox.Show("OpenUserRegKey: " + ae.ToString());\n                return null;\n            }
﻿using System;
using Shadowsocks.Util.SystemProxy;

            if (enabled)\n            {\n                if (global)\n                {\n                    WinINet.SetIEProxy(true, true, "127.0.0.1:" + config.localPort.ToString(), "");
                else\n                {\n                    string pacUrl;\n                    if (config.useOnlinePac && !config.pacUrl.IsNullOrEmpty())\n                        pacUrl = config.pacUrl;\n                    else\n                        pacUrl = $"http://127.0.0.1:{config.localPort}/pac?t={GetTimestamp(DateTime.Now)}";\n                    WinINet.SetIEProxy(true, false, "", pacUrl);
            else\n            {\n                WinINet.SetIEProxy(false, false, "", "");
            var registry = Registry.CurrentUser\n                .OpenSubKey(@"Software\Microsoft\Windows\CurrentVersion\Internet Settings\Connections", true);
                foreach (var each in connections)
                NotifyIE();\n            }\n            catch (IOException e)\n            {

            var registry = Registry.CurrentUser\n                .OpenSubKey(@"Software\Microsoft\Windows\CurrentVersion\Internet Settings\Connections", true);\n            var defConnection = (byte[])registry.GetValue("DefaultConnectionSettings");\n            var savedLegacySetting = (byte[])registry.GetValue("SavedLegacySettings");
                defConnection[8] = (byte)(defConnection[8] | 8);\n                savedLegacySetting[8] = (byte)(savedLegacySetting[8] | 8);
                defConnection[8] = (byte)(defConnection[8] & ~8);\n                savedLegacySetting[8] = (byte)(savedLegacySetting[8] & ~8);
                using (var fs = new FileStream(fileName, FileMode.Create, FileAccess.Write))\n                    fs.Write(content, 0, content.Length);
            catch (Exception ex)
                                  ex.ToString());

            using(var fs = File.Create(fileName))\n            using (var input = new GZipStream(\n                new MemoryStream(content),
                    fs.Write(buffer, 0, n);

            this.ServersListView = new System.Windows.Forms.ListView();\n            this.panel3 = new System.Windows.Forms.Panel();\n            this.AddButton = new System.Windows.Forms.Button();\n            this.DeleteButton = new System.Windows.Forms.Button();\n            this.groupBox1 = new System.Windows.Forms.GroupBox();
            this.panel3.SuspendLayout();\n            this.groupBox1.SuspendLayout();


            this.tableLayoutPanel1.Controls.Add(this.ProxyPortTextBox, 1, 4);\n            this.tableLayoutPanel1.Controls.Add(this.label4, 0, 4);

            this.tableLayoutPanel1.Controls.Add(this.label5, 0, 3);\n            this.tableLayoutPanel1.Controls.Add(this.EncryptionSelect, 1, 3);\n            this.tableLayoutPanel1.Location = new System.Drawing.Point(8, 21);\n            this.tableLayoutPanel1.Margin = new System.Windows.Forms.Padding(5);

            this.panel1.Location = new System.Drawing.Point(275, 247);\n            this.panel1.Margin = new System.Windows.Forms.Padding(0);

            this.splitContainer2.Size = new System.Drawing.Size(1029, 247);\n            this.splitContainer2.SplitterDistance = 365;\n            this.splitContainer2.SplitterWidth = 5;
            this.numericUpDown1.Location = new System.Drawing.Point(76, 189);\n            this.numericUpDown1.Margin = new System.Windows.Forms.Padding(3, 4, 3, 4);
﻿using System;
using System.Net;\nusing System.Net.NetworkInformation;\nusing System.Runtime.InteropServices;
using Shadowsocks.Model;\nusing Shadowsocks.Properties;


                FileManager.UncompressFile(Utils.GetTempPath("ss_privoxy.exe"), Resources.privoxy_exe);\n                FileManager.UncompressFile(Utils.GetTempPath("mgwz.dll"), Resources.mgwz_dll);
                FileManager.ByteArrayToFile(Utils.GetTempPath("privoxy.conf"), Encoding.UTF8.GetBytes(polipoConfig));
                _process.StartInfo.FileName = "ss_privoxy.exe";\n                _process.StartInfo.Arguments = "privoxy.conf";\n                _process.StartInfo.WorkingDirectory = Utils.GetTempPath();
﻿using System;\nusing System.IO;\nusing System.Runtime.InteropServices;\nusing Shadowsocks.Controller;

﻿using System;
            Utils.ReleaseMemory(true);
﻿using System;\nusing System.IO;\nusing System.Runtime.InteropServices;\nusing Shadowsocks.Controller;

            string dllPath = Utils.GetTempPath("libsscrypto.dll");
﻿using System;\nusing System.IO;\nusing System.Runtime.InteropServices;\nusing Shadowsocks.Controller;

            string dllPath = Utils.GetTempPath("libsscrypto.dll");
﻿using System;
using System.Net;\nusing Shadowsocks.Util;
                LogFile = Utils.GetTempPath("shadowsocks.log");
            if (!File.Exists(Utils.GetTempPath("gfwlist.txt")))
            List<string> lines = GFWListUpdater.ParseResult(File.ReadAllText(Utils.GetTempPath("gfwlist.txt")));
using Shadowsocks.Model;





            if (TempPath == null)
                if (File.Exists(Path.Combine(Application.StartupPath, "shadowsocks_portable_mode.txt")))\n                    try\n                    {\n                        Directory.CreateDirectory(Path.Combine(Application.StartupPath, "temp"));\n                    }\n                    catch (Exception e)\n                    {\n                        TempPath = Path.GetTempPath();\n                        Logging.LogUsefulException(e);\n                    }\n                    finally\n                    {\n                        // don't use "/", it will fail when we call explorer /select xxx/temp\xxx.log\n                        TempPath = Path.Combine(Application.StartupPath, "temp");\n                    }\n                else\n                    TempPath = Path.GetTempPath();
            return TempPath;\n        }\n        // return a full path with filename combined which pointed to the temporary directory\n        public static string GetTempPath(string filename)\n        {\n            return Path.Combine(GetTempPath(), filename);
                var inbound = current.inboundCounter = InboundCounter;\n                var outbound = current.outboundCounter = OutboundCounter;\n                current.inboundIncreasement = inbound - previous.inboundCounter;\n                current.outboundIncreasement = outbound - previous.outboundCounter;
                TrafficChanged?.Invoke(this, new EventArgs());
                var session = (AsyncSession) ar.AsyncState;
                    SendToServer(bytesRead, session);
        public Server GetAServer(IStrategyCallerType type, IPEndPoint localIPEndPoint, EndPoint destEndPoint)
                return strategy.GetAServer(type, localIPEndPoint, destEndPoint);
            try\n            {\n                if (Utils.IsPortableMode())
                     * Under PortableMode, we could identify it by the path of ss_privoxy.exe.
                    var path = process.MainModule.FileName;
                else
            }\n            catch (Exception ex)\n            {\n                /*\n                 * Sometimes Process.GetProcessesByName will return some processes that\n                 * are already dead, and that will cause exceptions here.\n                 * We could simply ignore those exceptions.\n                 */\n                Logging.LogUsefulException(ex);
                    PolarSSL.aes_crypt_cfb128(ctx, isCipher ? PolarSSL.AES_ENCRYPT : PolarSSL.AES_DECRYPT, length, ref ivOffset, iv, buf, outbuf);
        public void TestPolarSSLEncryption()
                Thread t = new Thread(new ThreadStart(RunSinglePolarSSLEncryptionThread));
        private bool ValidateAndSaveSelectedServerDetails()
                Server server = GetServerDetailsFromUI();


        private Server GetServerDetailsFromUI()\n        {\n            Server server = new Server();\n            if (Uri.CheckHostName(server.server = IPTextBox.Text.Trim()) == UriHostNameType.Unknown)\n            {\n                MessageBox.Show(I18N.GetString("Invalid server address"));\n                IPTextBox.Focus();\n                return null;\n            }\n            if (!int.TryParse(ServerPortTextBox.Text, out server.server_port))\n            {\n                MessageBox.Show(I18N.GetString("Illegal port number format"));\n                ServerPortTextBox.Focus();\n                return null;\n            }\n            server.password = PasswordTextBox.Text;\n            server.method = EncryptionSelect.Text;\n            server.plugin = PluginTextBox.Text;\n            server.plugin_opts = PluginOptionsTextBox.Text;\n            server.plugin_args = PluginArgumentsTextBox.Text;\n            server.remarks = RemarksTextBox.Text;\n            if (!int.TryParse(TimeoutTextBox.Text, out server.timeout))\n            {\n                MessageBox.Show(I18N.GetString("Illegal timeout format"));\n                TimeoutTextBox.Focus();\n                return null;\n            }\n            return server;\n        }\n        private void LoadSelectedServerDetails()
                SetServerDetailsToUI(server);\n            }\n        }\n        private void SetServerDetailsToUI(Server server)\n        {\n            IPTextBox.Text = server.server;\n            ServerPortTextBox.Text = server.server_port.ToString();\n            PasswordTextBox.Text = server.password;\n            EncryptionSelect.Text = server.method ?? "aes-256-cfb";\n            PluginTextBox.Text = server.plugin;\n            PluginOptionsTextBox.Text = server.plugin_opts;\n            PluginArgumentsTextBox.Text = server.plugin_args;\n            RemarksTextBox.Text = server.remarks;\n            TimeoutTextBox.Text = server.timeout.ToString();\n        }\n        private void LoadServerNameListToUI(Configuration configuration)
            foreach (Server server in configuration.configs)
            LoadServerNameListToUI(_modifiedConfiguration);
            UpdateButtons();\n            LoadSelectedServerDetails();\n            ProxyPortTextBox.Text = _modifiedConfiguration.localPort.ToString();

                if (!ValidateAndSaveSelectedServerDetails())
            if (!ValidateAndSaveSelectedServerDetails())
            UpdateButtons();\n            LoadSelectedServerDetails();
            if (!ValidateAndSaveSelectedServerDetails())
            LoadServerNameListToUI(_modifiedConfiguration);
            if (!ValidateAndSaveSelectedServerDetails())
            LoadServerNameListToUI(_modifiedConfiguration);
            LoadServerNameListToUI(_modifiedConfiguration);
            LoadSelectedServerDetails();
            if (!ValidateAndSaveSelectedServerDetails())
            UpdateButtons();\n        }\n        private void UpdateButtons()\n        {\n            DeleteButton.Enabled = (ServersListBox.Items.Count > 0);\n            MoveUpButton.Enabled = (ServersListBox.SelectedIndex > 0);\n            MoveDownButton.Enabled = (ServersListBox.SelectedIndex < ServersListBox.Items.Count - 1);
            if (!ValidateAndSaveSelectedServerDetails())
        : IVEncryptor, IDisposable


        protected override Dictionary<string, int[]> getCiphers()
            return new Dictionary<string, int[]> {\n                {"aes-128-cfb", new int[]{16, 16, CIPHER_AES, PolarSSL.AES_CTX_SIZE}},\n                {"aes-192-cfb", new int[]{24, 16, CIPHER_AES, PolarSSL.AES_CTX_SIZE}},\n                {"aes-256-cfb", new int[]{32, 16, CIPHER_AES, PolarSSL.AES_CTX_SIZE}},\n                {"rc4", new int[]{16, 0, CIPHER_RC4, PolarSSL.ARC4_CTX_SIZE}},\n                {"rc4-md5", new int[]{16, 16, CIPHER_RC4, PolarSSL.ARC4_CTX_SIZE}},\n            };
        protected override void initCipher(byte[] iv, bool isCipher)
            base.initCipher(iv, isCipher);\n            IntPtr ctx;\n            ctx = Marshal.AllocHGlobal(_cipherInfo[3]);\n            if (isCipher)
                _encryptCtx = ctx;
                _decryptCtx = ctx;


        protected override void cipherUpdate(bool isCipher, int length, byte[] buf, byte[] outbuf)
            // C# could be multi-threaded\n            if (_disposed)
                throw new ObjectDisposedException(this.ToString());\n            }\n            byte[] iv;\n            int ivOffset;\n            if (isCipher)\n            {\n                iv = _encryptIV;\n                ivOffset = _encryptIVOffset;
                iv = _decryptIV;\n                ivOffset = _decryptIVOffset;
            switch (_cipher)
                case CIPHER_AES:\n                    PolarSSL.aes_crypt_cfb128(_encryptCtx, isCipher ? PolarSSL.AES_ENCRYPT : PolarSSL.AES_DECRYPT, length, ref ivOffset, iv, buf, outbuf);\n                    if (isCipher)
                        _encryptIVOffset = ivOffset;
                    else
                        _decryptIVOffset = ivOffset;
                    break;\n                case CIPHER_RC4:\n                    PolarSSL.arc4_crypt(_encryptCtx, length, buf, outbuf);\n                    break;

            }\n            catch (IOException e)\n            {\n                Console.WriteLine(e.ToString());\n            }\n            LoadLibrary(dllPath);\n            try\n            {
            if (File.Exists(PAC_FILE))
                return File.ReadAllText(PAC_FILE, Encoding.UTF8);\n            }\n            else\n            {\n                byte[] pacGZ = Resources.proxy_pac_txt;\n                byte[] buffer = new byte[1024 * 1024];  // builtin pac gzip size: maximum 1M\n                int n;\n                using (GZipStream input = new GZipStream(new MemoryStream(pacGZ),\n                    CompressionMode.Decompress, false))
                    n = input.Read(buffer, 0, buffer.Length);\n                    if (n == 0)\n                    {\n                        throw new IOException("can not decompress pac");\n                    }\n                    return System.Text.Encoding.UTF8.GetString(buffer, 0, n);

            try\n            {\n                local.Start();\n                pacServer = new PACServer();\n                pacServer.Start();\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine(e.ToString());\n            }
            this.aboutItem.Index = 3;
        private static Dictionary<string, int[]> _ciphers = new Dictionary<string, int[]> {
        };\n        public static List<string> SupportedCiphers()\n        {\n            return new List<string>(_ciphers.Keys);\n        }\n        protected override Dictionary<string, int[]> getCiphers()\n        {\n            return _ciphers;
            return _ciphers;\n        }\n        public static List<string> SupportedCiphers()\n        {\n            return new List<string>(_ciphers.Keys);
            if (string.IsNullOrEmpty(method))
                method = "table";
            method = method.ToLowerInvariant();\n            Type t = _registeredEncryptors[method];\n            ConstructorInfo c = t.GetConstructor(_constructorTypes);\n            IEncryptor result = (IEncryptor)c.Invoke(new object[] { method, password });\n            return result;
            this.btnOK.Location = new System.Drawing.Point(416, 9);\n            this.btnOK.Margin = new System.Windows.Forms.Padding(4, 4, 4, 4);
            this.btnCancel.Location = new System.Drawing.Point(254, 9);\n            this.btnCancel.Margin = new System.Windows.Forms.Padding(4, 4, 4, 4);
            this.btnRegisterAll.Location = new System.Drawing.Point(92, 9);\n            this.btnRegisterAll.Margin = new System.Windows.Forms.Padding(4, 4, 4, 4);
﻿using Shadowsocks.Controller;\nusing Shadowsocks.Model;\nusing Shadowsocks.Properties;\nusing System;


﻿using System.Collections.Generic;

        private static void Init(string res, string locale)
            using (TextFieldParser csvParser = new TextFieldParser(new StringReader(res)))
                csvParser.SetDelimiters(",");\n                string[] localeNames = csvParser.ReadFields();\n                int enIndex = 0;\n                int targetIndex = 0;\n                for (int i = 1; i < localeNames.Length; i++)
                    if (localeNames[i] == "en")\n                    {\n                    }\n                    if (localeNames[i] == locale)\n                    {\n                        targetIndex = i;\n                    }\n                }\n                while (!csvParser.EndOfData)\n                {\n                    string[] translations = csvParser.ReadFields();\n                    if (string.IsNullOrWhiteSpace(translations[0])) continue;\n                    if (translations[0].TrimStart(' ')[0] == '#') continue;\n                    _strings[translations[enIndex]] = translations[targetIndex];
            Init(Resources.i18n_csv, CultureInfo.CurrentCulture.IetfLanguageTag);

            I18N.TranslateForm(this);

﻿using System;\nusing System.Reflection;

using System.Windows.Forms;\nusing Newtonsoft.Json;
        private Dictionary<string, List<StatisticsRawData>> _rawStatistics;\n        private int ChoiceKeptMilliseconds\n            => (int) TimeSpan.FromMinutes(_controller.StatisticsConfiguration.ChoiceKeptMinutes).TotalMilliseconds;\n        private const int RetryInterval = 2*60*1000; //retry 2 minutes after failed

                    LogWhenEnabled($"statistics file does not exist, try to reload {RetryInterval/60/1000} minutes later");\n                    _timer.Change(RetryInterval, ChoiceKeptMilliseconds);
                _rawStatistics = (from l in File.ReadAllLines(path)\n                    .Skip(1)\n                    let strings = l.Split(new[] {","}, StringSplitOptions.RemoveEmptyEntries)\n                    let rawData = new StatisticsRawData\n                    {\n                        Timestamp = strings[0],\n                        ServerName = strings[1],\n                        ICMPStatus = strings[2],\n                        RoundtripTime = int.Parse(strings[3]),\n                        Geolocation = 5 > strings.Length ?\n                        null \n                        : strings[4],\n                        ISP = 6 > strings.Length ? null : strings[5]\n                    }\n                    group rawData by rawData.ServerName into server\n                    select new\n                    {\n                        ServerName = server.Key,\n                        data = server.ToList()\n                    }).ToDictionary(server => server.ServerName, server=> server.data);
        private float GetScore(IEnumerable<StatisticsRawData> rawDataList)\n        {\n            var config = _controller.StatisticsConfiguration;\n            if (config.ByIsp)\n            {\n                var current = AvailabilityStatistics.GetGeolocationAndIsp().Result;\n                rawDataList = rawDataList.Where(data => data.Geolocation == current[0].Value || data.Geolocation == AvailabilityStatistics.State.Unknown);\n                rawDataList = rawDataList.Where(data => data.ISP == current[1].Value || data.ISP == AvailabilityStatistics.State.Unknown);\n                if (rawDataList.LongCount() == 0) return 0; \n            }\n            if (config.ByHourOfDay)\n            {\n                var currentHour = DateTime.Now.Hour;\n                rawDataList = rawDataList.Where(data =>\n                {\n                    DateTime dateTime;\n                    DateTime.TryParseExact(data.Timestamp, AvailabilityStatistics.DateTimePattern, null,\n                        DateTimeStyles.None, out dateTime);\n                    var result = dateTime.Hour.Equals(currentHour);\n                    return result;\n                });\n                if (rawDataList.LongCount() == 0) return 0; \n            }\n            var dataList = rawDataList as IList<StatisticsRawData> ?? rawDataList.ToList();\n            var serverName = dataList[0]?.ServerName;\n            var SuccessTimes = (float) dataList.Count(data => data.ICMPStatus.Equals(IPStatus.Success.ToString()));\n            var TimedOutTimes = (float) dataList.Count(data => data.ICMPStatus.Equals(IPStatus.TimedOut.ToString()));\n            var statisticsData = new StatisticsData()\n            {\n                PackageLoss = TimedOutTimes / (SuccessTimes + TimedOutTimes) * 100,\n                AverageResponse = Convert.ToInt32(dataList.Average(data => data.RoundtripTime)),\n                MinResponse = dataList.Min(data => data.RoundtripTime),\n                MaxResponse = dataList.Max(data => data.RoundtripTime)\n            };\n            float factor;\n            float score = 0;\n            if (!config.Calculations.TryGetValue("PackageLoss", out factor)) factor = 0;\n            score += statisticsData.PackageLoss*factor;\n            if (!config.Calculations.TryGetValue("AverageResponse", out factor)) factor = 0;\n            score += statisticsData.AverageResponse*factor;\n            if (!config.Calculations.TryGetValue("MinResponse", out factor)) factor = 0;\n            score += statisticsData.MinResponse*factor;\n            if (!config.Calculations.TryGetValue("MaxResponse", out factor)) factor = 0;\n            score += statisticsData.MaxResponse*factor;\n            Logging.Debug($"{serverName}  {JsonConvert.SerializeObject(statisticsData)}");\n            return score;\n        }\n        class StatisticsRawData\n        {\n            public string Timestamp;\n            public string ServerName;\n            public string ICMPStatus;\n            public int RoundtripTime;\n            public string Geolocation;\n            public string ISP ;
            public float PackageLoss;
            if (_rawStatistics == null || servers.Count == 0)
                                  where _rawStatistics.ContainsKey(name)
                                      score = GetScore(_rawStatistics[name])
        public CalculationControl(string text, float value)
            valueLabel.Text = text;\n            factorNum.Value = (decimal) value;
        public float Factor => (float) factorNum.Value;


            series1.ChartType = System.Windows.Forms.DataVisualization.Charting.SeriesChartType.Bubble;\n            series1.Color = System.Drawing.Color.FromArgb(((int)(((byte)(221)))), ((int)(((byte)(88)))), ((int)(((byte)(0)))));
            series1.Name = "Package Loss";\n            series1.YValuesPerPoint = 4;\n            series2.BorderWidth = 4;
            series2.ChartType = System.Windows.Forms.DataVisualization.Charting.SeriesChartType.Line;\n            series2.Color = System.Drawing.Color.FromArgb(((int)(((byte)(155)))), ((int)(((byte)(77)))), ((int)(((byte)(150)))));
            series2.Name = "Ping";
            this.StatisticsChart.Size = new System.Drawing.Size(1061, 314);

        private const int DelayBeforeStart = 1000;\n        private int _repeat => _config.RepeatTimesNum;\n        private int _interval => (int) TimeSpan.FromMinutes(_config.DataCollectionMinutes).TotalMilliseconds; 
            var temppath = Utils.GetTempPath();
        public AvailabilityStatistics(Configuration config, StatisticsStrategyConfiguration statisticsConfig)
                if (config.StatisticsEnabled)
                    if (_timer?.Change(DelayBeforeStart, _interval) == null)
                        _timer = new Timer(Evaluate, _state, DelayBeforeStart, _interval);
        private async Task<List<DataList>> ICMPTest(Server server)
                var timestamp in Enumerable.Range(0, _repeat).Select(_ => DateTime.Now.ToString(DateTimePattern)))
                    var reply = ping.Send(IP, Timeout);
            try\n            {\n                File.AppendAllLines(AvailabilityStatisticsFile, lines);\n            }\n            catch (IOException e)\n            {\n                Logging.LogUsefulException(e);\n            }
        internal void UpdateConfiguration(Configuration config, StatisticsStrategyConfiguration statisticsConfig)
            Set(statisticsConfig);
        public class State
            RegistryKey ssURLAssociation = null;
                ssURLAssociation = Registry.CurrentUser.CreateSubKey(@"SOFTWARE\Classes\ss", RegistryKeyPermissionCheck.ReadWriteSubTree);\n                if (ssURLAssociation == null)
                    ssURLAssociation.SetValue("", "URL:Shadowsocks");\n                    ssURLAssociation.SetValue("URL Protocol", "");\n                    var shellOpen = ssURLAssociation.CreateSubKey("shell").CreateSubKey("open").CreateSubKey("command");
                    Registry.CurrentUser.DeleteSubKeyTree(@"SOFTWARE\Classes\ss");\n                    logger.Info(@"Successfully removed ss:// association.");
                        ssURLAssociation.Close();\n                        ssURLAssociation.Dispose();
            RegistryKey ssURLAssociation = null;
                ssURLAssociation = Registry.CurrentUser.OpenSubKey(@"SOFTWARE\Classes\ss", true);\n                if (ssURLAssociation == null)
                    //logger.Info(@"ss:// links not associated.");
                var shellOpen = ssURLAssociation.OpenSubKey("shell").OpenSubKey("open").OpenSubKey("command");
                        ssURLAssociation.Close();\n                        ssURLAssociation.Dispose();
[assembly: AssemblyCompany("clowwindy")]
[assembly: AssemblyCopyright("Copyright © clowwindy 2014")]
        public static void ReleaseMemory(bool removePages)
            if (removePages)\n            {\n                // as some users have pointed out\n                // removing pages from working set will cause some IO\n                // which lowered user experience for another group of users\n                //\n                // so we do 2 more things here to satisfy them:\n                // 1. only remove pages once when configuration is changed\n                // 2. add more comments here to tell users that calling\n                //    this function will not be more frequent than\n                //    IM apps writing chat logs, or web browsers writing cache files\n                //    if they're so concerned about their disk, they should\n                //    uninstall all IM apps and web browsers\n                //\n                // please open an issue if you're worried about anything else in your computer\n                // no matter it's GPU performance, monitor contrast, audio fidelity\n                // or anything else in the task manager\n                // we'll do as much as we can to help you\n                //\n                // just kidding\n                SetProcessWorkingSetSize(Process.GetCurrentProcess().Handle,\n                    (UIntPtr)0xFFFFFFFF, (UIntPtr)0xFFFFFFFF);\n            }
            lock (encryptionLock)\n            {\n                lock (decryptionLock)\n                {\n                    ((IDisposable)encryptor).Dispose();\n                }\n            }
                    lock (decryptionLock)\n                    {\n                        if (closed)\n                        {\n                            return;\n                        }\n                        encryptor.Decrypt(remoteRecvBuffer, bytesRead, remoteSendBuffer, out bytesToSend);\n                    }
                    lock (encryptionLock)\n                    {\n                        if (closed)\n                        {\n                            return;\n                        }\n                        encryptor.Encrypt(connetionRecvBuffer, bytesRead, connetionSendBuffer, out bytesToSend);\n                    }
                Console.WriteLine(e);
            using (Mutex mutex = new Mutex(false, $"Global\\Shadowsocks_{Application.StartupPath.GetHashCode()}"))
                MessageBox.Show(\n                    $"{I18N.GetString("Unexpected error, shadowsocks will exit. Please report to")} https://github.com/shadowsocks/shadowsocks-windows/issues {Environment.NewLine}{(e.ExceptionObject?.ToString())}",
                        Logger.Error("socks 5 protocol error");
                Logger.LogUsefulException(e);
                            Logger.Debug("Unsupported CMD=" + _command);
                Logger.LogUsefulException(e);
                        Logger.Info($"connect to {dstAddr}:{dstPort}");
                    Logger.Debug("failed to recv data in Shadowsocks.Controller.TCPHandler.OnAddressFullyRead()");
                Logger.LogUsefulException(e);
                Logger.Debug($"_firstPacketLength = {_firstPacketLength}");
                Logger.LogUsefulException(e);
                            Logger.Error("decryption error");
                    logger.Info(
                logger.Error("Failed to start SIP003 plugin: " + ex.Message);
                logger.LogUsefulException(e);
            logger.Debug($"save statistics to {AvailabilityStatisticsFile}");
                logger.LogUsefulException(e);
                logger.Debug($"loading statistics from {path}");
                    logger.Error($"An exception occured while eveluating {server.FriendlyName()}");\n                    logger.LogUsefulException(e);
                    logger.Error($"An exception occured while eveluating {server.FriendlyName()}");\n                    logger.LogUsefulException(ex);
            logger.Dump("Salt", salt, saltLen);
                    logger.Error($"Invalid chunk length: {chunkLen}");
﻿using NLog;\nusing System;
﻿using NLog;\nusing Shadowsocks.Model;
                    logger.Info($"HA switching to server: {_currentServer.server.FriendlyName()}");
                    logger.Info(Encryption.EncryptorFactory.DumpRegisteredEncryptor());
                logger.Debug("Checking updates...");
                logger.LogUsefulException(ex);
                    logger.Debug("No update is available");
                logger.LogUsefulException(ex);
                logger.Debug($"New version {LatestVersionNumber}{LatestVersionSuffix} found: {LatestVersionLocalName}");
                logger.LogUsefulException(ex);
            logger.Dump("_decNonce before dec", _decNonce, nonceLen);\n            logger.Dump("_sodiumDecSubkey", _sodiumDecSubkey, keyLen);\n            logger.Dump("before cipherDecrypt: cipher", ciphertext, (int) clen);
                logger.Debug(_localEndPoint, _remoteEndPoint, outlen, "UDP Relay");


                logger.Error(errMsg);
                                logger.LogUsefulException(ex);

            catch (Exception)
        public static string GetString(string key, params object[] args)
                ? string.Format(_strings[key], args)\n                : string.Format(key, args);
            return ipProperties.GetActiveTcpListeners().Any(endPoint => endPoint.Port == port);
                throw new Exception(I18N.GetString("Port {0} already in use", _config.localPort));

            IPAddress ipAddress;\n            bool parsed = IPAddress.TryParse(host, out ipAddress);\n            if (parsed)\n            {\n                IPEndPoint ep = new IPEndPoint(ipAddress, port);\n                switch (ep.AddressFamily)\n                {\n                    case AddressFamily.InterNetwork:\n                        request = new byte[4 + 4 + 2];\n                        atyp = 1; // IP V4 address\n                        break;\n                    case AddressFamily.InterNetworkV6:\n                        request = new byte[4 + 16 + 2];\n                        atyp = 4; // IP V6 address\n                        break;\n                    default:\n                        throw new Exception(I18N.GetString("Proxy request faild"));\n                }\n                var addr = ep.Address.GetAddressBytes();\n                Array.Copy(addr, 0, request, 4, request.Length - 4 - 2);\n            }\n            else\n            {\n                // maybe is a domain name, we will leave it to server\n                // need ValidateTcpPort? porttest > 1 && porttest < 65535?\n                atyp = 3; // DOMAINNAME\n                var enc = Encoding.UTF8;\n                var hostByteCount = enc.GetByteCount(host);\n                request = new byte[4 + 1/*length byte*/ + hostByteCount + 2];\n                request[4] = (byte)hostByteCount;\n                enc.GetBytes(host, 0, host.Length, request, 5);\n            }\n            // 构造request包剩余部分
            request[request.Length - 2] = (byte) ((port >> 8) & 0xff);\n            request[request.Length - 1] = (byte) (port & 0xff);
                            if ( controller.GetCurrentConfiguration().isVerboseLogging ) {\n                                Logging.Info( $"connect to {dst_addr}:{dst_port}" );\n                            }
                            if ( controller.GetCurrentConfiguration().isVerboseLogging ) {\n                                Logging.Info( $"connect to {dst_addr}:{dst_port}" );\n                            }
                            if ( controller.GetCurrentConfiguration().isVerboseLogging ) {\n                                Logging.Info( $"connect to [{dst_addr}]:{dst_port}" );\n                            }
            string name = CultureInfo.CurrentCulture.Name;\n            if (name.StartsWith("zh"))
                if (name == "zh" || name == "zh-CN")
                    Init(Resources.cn);\n                }\n                else\n                {\n                    Init(Resources.zh_tw);
            if (userSettingsArr.Length != 4)
            if (logger.IsTraceEnabled)
                var sb = new StringBuilder($"{Environment.NewLine}{tag}: ");\n                for (int i = 0; i < length - 1; i++)\n                {\n                    sb.Append($"0x{arr[i]:X2}, ");\n                }\n                sb.Append($"0x{arr[length - 1]:X2}");\n                sb.Append(Environment.NewLine);\n                logger.Trace(sb.ToString());

            if (logger.IsDebugEnabled)\n            {\n                if (header == null && tailer == null)\n                    logger.Debug($"{local} => {remote} (size={len})");\n                else if (header == null && tailer != null)\n                    logger.Debug($"{local} => {remote} (size={len}), {tailer}");\n                else if (header != null && tailer == null)\n                    logger.Debug($"{header}: {local} => {remote} (size={len})");\n                else\n                    logger.Debug($"{header}: {local} => {remote} (size={len}), {tailer}");\n            }
            if (logger.IsDebugEnabled)\n            {\n                logger.Debug(sock.LocalEndPoint, sock.RemoteEndPoint, len, header, tailer);\n            }
                var configuration = SimpleJson.SimpleJson.DeserializeObject<StatisticsStrategyConfiguration>(content);
            catch (FileNotFoundException)
        protected static bool SerializeValue(IJsonSerializerStrategy jsonSerializerStrategy, object value, int level, StringBuilder builder)
                success = SerializeObject(jsonSerializerStrategy, dict.Keys, dict.Values, level, builder);
                success = SerializeObject(jsonSerializerStrategy, dict.Keys, dict.Values, level, builder);
                success = SerializeArray(jsonSerializerStrategy, (IEnumerable)value, level, builder);
                    SerializeValue(jsonSerializerStrategy, serializedObject, level, builder);
        protected static bool SerializeObject(IJsonSerializerStrategy jsonSerializerStrategy, IEnumerable keys, IEnumerable values, int level, StringBuilder builder)
                    if (!SerializeValue(jsonSerializerStrategy, value, level, builder)) return false;
                if (!SerializeValue(jsonSerializerStrategy, value, level, builder))
            builder.Append("\r\n");\n            FeedIndent(level - 1, builder);\n            builder.Append("}");
        protected static bool SerializeArray(IJsonSerializerStrategy jsonSerializerStrategy, IEnumerable anArray, int level, StringBuilder builder)\n        {\n            builder.Append("[\r\n");\n            level++;
                    builder.Append(",\r\n");\n                FeedIndent(level, builder);\n                if (!SerializeValue(jsonSerializerStrategy, value, level, builder))
            builder.Append("\r\n");\n            FeedIndent(level - 1, builder);\n            builder.Append("]");
            _rng = _rng ?? new RNGCryptoServiceProvider();
            _rng?.Dispose();
            if (_rng == null) Init();
            catch
                List<string> lines = ParseResult(e.Result);
                abpContent = abpContent.Replace("__RULES__", SimpleJson.SimpleJson.SerializeObject(lines));
        public List<string> ParseResult(string response)
            catch (Exception e)
                Logging.LogUsefulException(e);\n                // TODO this should be moved into views\n                MessageBox.Show(I18N.GetString("Failed to update registry"));
            catch (Exception e)
                Logging.LogUsefulException(e);\n                // TODO this should be moved into views\n                MessageBox.Show(I18N.GetString("Failed to update registry"));
        //private Encryptor encryptor;
            //this.encryptor = new Encryptor(config.method, config.password);
            try
                if (enabled)
                    if (global)\n                    {\n                        WinINet.SetIEProxy(true, true, "127.0.0.1:" + config.localPort.ToString(), "");\n                    }\n                    else\n                    {\n                        string pacUrl;\n                        if (config.useOnlinePac && !config.pacUrl.IsNullOrEmpty())\n                            pacUrl = config.pacUrl;\n                        else\n                            pacUrl = $"http://127.0.0.1:{config.localPort}/pac?t={GetTimestamp(DateTime.Now)}";\n                        WinINet.SetIEProxy(true, false, "", pacUrl);\n                    }
                    WinINet.SetIEProxy(false, false, "", "");
            catch (ProxyException ex)
                Logging.LogUsefulException(ex);
            topMostTriggerLock = false;\n            wrapTextTriggerLock = true;\n            LogMessageTextBox.WordWrap = WrapTextMenuItem.Checked = WrapTextCheckBox.Checked = wrapTextTrigger;\n            wrapTextTriggerLock = false;\n            ToolbarFlowLayoutPanel.Visible = ShowToolbarMenuItem.Checked = toolbarTrigger;
            if (_key.Length != keyLen) Array.Resize(ref _key, keyLen);\n            LegacyDeriveKey(passbuf, _key, keyLen);
        public static void LegacyDeriveKey(byte[] password, byte[] key, int keylen)
            byte[] result = new byte[password.Length + MD5_LEN];
            while (i < keylen) {
                    Array.Copy(md5sum, 0, result, 0, MD5_LEN);\n                    Array.Copy(password, 0, result, MD5_LEN, password.Length);
                Array.Copy(md5sum, 0, key, i, Math.Min(MD5_LEN, keylen - i));\n                i += MD5_LEN;
            if (_Masterkey.Length != keyLen) Array.Resize(ref _Masterkey, keyLen);\n            DeriveKey(passbuf, _Masterkey, keyLen);
        public void DeriveKey(byte[] password, byte[] key, int keylen)\n        {\n            StreamEncryptor.LegacyDeriveKey(password, key, keylen);
        public string FriendlyName()
            if (string.IsNullOrEmpty(server))
                return I18N.GetString("New server");


        private AsyncSession _currentRemoteSession;
            public AsyncSession Session;
                proxyTimer.Session = session;
                remote.BeginConnectProxy(proxyEP, new AsyncCallback(ProxyConnectCallback), new AsyncSession<ProxyTimer>(remote, proxyTimer));
            var proxy = ((ProxyTimer)sender).Session.Remote;
            proxy.Close();
                var session = (AsyncSession<ProxyTimer>) ar.AsyncState;\n                ProxyTimer timer = session.State;
                remote.BeginConnectDest(destEndPoint, new AsyncCallback(ConnectCallback), new AsyncSession<ServerTimer>(session, connectTimer));
            session.Remote.Close();
                var session = (AsyncSession<ServerTimer>) ar.AsyncState;\n                ServerTimer timer = session.State;
        private void StartPipe(AsyncSession session)
                session.Remote.BeginReceive(_remoteRecvBuffer, 0, RecvSize, SocketFlags.None, new AsyncCallback(PipeRemoteReceiveCallback), session);
                    new AsyncSession<bool>(session, true) /* to tell the callback this is the first time reading packet, and we haven't found the header yet. */);
                    if (session.State && _config.isVerboseLogging)
                                session.State = false;
                session.Remote.BeginReceive(_remoteRecvBuffer, 0, RecvSize, SocketFlags.None, new AsyncCallback(PipeRemoteReceiveCallback), session);



                    SocketUtil.BeginConnectTcp(remoteEP, ConnectCallback, null);
            SocketUtil.BeginConnectTcp(destEndPoint, callback, state);
            _remote = SocketUtil.EndConnectTcp(asyncResult);

            SocketUtil.BeginConnectTcp(remoteEP, ConnectCallback, st);
        private class TcpUserToken : IAsyncResult
            public AsyncCallback Callback { get; }\n            public SocketAsyncEventArgs Args { get; }\n            public TcpUserToken(AsyncCallback callback, object state, SocketAsyncEventArgs args)
                Callback = callback;\n                AsyncState = state;\n                Args = args;
            public bool IsCompleted { get; } = true;\n            public WaitHandle AsyncWaitHandle { get; } = null;\n            public object AsyncState { get; }\n            public bool CompletedSynchronously { get; } = true;\n        }\n        private static void OnTcpConnectCompleted(object sender, SocketAsyncEventArgs args)\n        {\n            TcpUserToken token = (TcpUserToken) args.UserToken;\n            token.Callback(token);\n        }\n        public static void BeginConnectTcp(EndPoint endPoint, AsyncCallback callback, object state)\n        {\n            var arg = new SocketAsyncEventArgs();\n            arg.RemoteEndPoint = endPoint;\n            arg.Completed += OnTcpConnectCompleted;\n            arg.UserToken = new TcpUserToken(callback, state, arg);\n            Socket.ConnectAsync(SocketType.Stream, ProtocolType.Tcp, arg);\n        }\n        public static Socket EndConnectTcp(IAsyncResult asyncResult)\n        {\n            var tut = asyncResult as TcpUserToken;\n            if (tut == null)
                throw new ArgumentException("Invalid asyncResult.", nameof(asyncResult));
            var arg = tut.Args;\n            if (arg.SocketError != SocketError.Success)
                if (arg.ConnectByNameError != null)\n                {\n                    throw arg.ConnectByNameError;\n                }\n                var ex = new SocketException((int)arg.SocketError);\n                throw ex;
                        var isPreRelease = (bool) release["prerelease"];\n                        if (isPreRelease && !config.checkPreRelease)
                            Asset ass = Asset.ParseAsset(asset);\n                            if (ass != null)
                                ass.prerelease = isPreRelease;\n                                if (ass.IsNewVersion(Version, PreRelease, config.checkPreRelease))\n                                {\n                                    asserts.Add(ass);\n                                }
            public string suffix;\n            public static Asset ParseAsset(JObject aJObject)\n            {\n                var name = (string) aJObject["name"];\n                Match match = Regex.Match(name, @"^Shadowsocks-(?<version>\d+(?:\.\d+)*)(?:|-(?<suffix>.+))\.\w+$",\n                    RegexOptions.IgnoreCase);\n                if (match.Success)\n                {\n                    string version = match.Groups["version"].Value;\n                    var asset = new Asset\n                    {\n                        browser_download_url = (string) aJObject["browser_download_url"],\n                        name = name,\n                        version = version\n                    };\n                    if (match.Groups["suffix"].Success)\n                    {\n                        asset.suffix = match.Groups["suffix"].Value;\n                    }\n                    return asset;\n                }\n                return null;\n            }\n            public bool IsNewVersion(string currentVersion, bool isPreRelease, bool checkPreRelease)\n            {\n                if (prerelease && !checkPreRelease)
                var cmp = CompareVersion(version, currentVersion);\n                if (cmp == 0)\n                {\n                    // If current version is pre-release and we find non-prerelease version online, then the non-prelease version is newer.\n                    return !prerelease && isPreRelease;\n                }\n                return cmp > 0;
                // only switch it off if we have switched it on\n                if (_systemProxyIsDirty)\n                {\n                    SystemProxy.Disable();\n                    _systemProxyIsDirty = false;\n                }
                    if (_controller != null)\n                    {\n                        System.Timers.Timer timer = new System.Timers.Timer(5 * 1000);\n                        timer.Elapsed += Timer_Elapsed;\n                        timer.AutoReset = false;\n                        timer.Enabled = true;\n                        timer.Start();\n                    }
            if (st.innerState.ex == null)
                if (!_established)\n                {\n                    st.innerState.ex = new Exception(I18N.GetString("Proxy request failed"));\n                }\n                // TODO: save last bytes

                    if (!secretMatch)\n                    {\n                        socket.Close(); // Close immediately\n                    }\n                    else\n                    {\n                        SendResponse(firstPacket, length, socket, useSocks);\n                    }
            byte[] cipher = new byte[plain.Length + 16 + IVEncryptor.ONETIMEAUTH_BYTES + IVEncryptor.AUTH_BYTES];
            encryptor.Encrypt(plain, plain.Length, cipher, out outLen, false);
            encryptor.Encrypt(plain, 1000, cipher, out outLen, false);
            encryptor.Encrypt(plain, 12333, cipher, out outLen, false);
        public const int ONETIMEAUTH_BYTES = 10;
        public const int AUTH_BYTES = ONETIMEAUTH_BYTES + CLEN_BYTES;
        protected byte[] genOnetimeAuthHash(byte[] msg, int msg_len)\n        {\n            byte[] auth = new byte[ONETIMEAUTH_BYTES];\n            byte[] hash = new byte[20];\n            byte[] auth_key = new byte[MAX_IV_LENGTH + MAX_KEY_LENGTH];\n            Buffer.BlockCopy(_encryptIV, 0, auth_key, 0, ivLen);\n            Buffer.BlockCopy(_key, 0, auth_key, ivLen, keyLen);\n            Sodium.ss_sha1_hmac_ex(auth_key, (uint)(ivLen + keyLen),\n                msg, 0, (uint)msg_len, hash);\n            Buffer.BlockCopy(hash, 0, auth, 0, ONETIMEAUTH_BYTES);\n            return auth;\n        }\n        protected void updateKeyBuffer()\n        {

        }\n        protected byte[] genHash(byte[] buf, int offset, int len)\n        {\n            byte[] hash = new byte[20];\n            updateKeyBuffer();\n            Sodium.ss_sha1_hmac_ex(_keyBuffer, (uint)_keyBuffer.Length,\n                buf, offset, (uint)len, hash);\n            return hash;\n        }\n        public override void Encrypt(byte[] buf, int length, byte[] outbuf, out int outlength, bool udp)

                if (OnetimeAuth && ivLen > 0)\n                {\n                    byte[] hash = genHash(buf, 0, length);\n                    Buffer.BlockCopy(buf, 0, buf, AUTH_BYTES, length);\n                    byte[] lenBytes = BitConverter.GetBytes((ushort)IPAddress.HostToNetworkOrder((short)length));\n                    Buffer.BlockCopy(lenBytes, 0, buf, 0, CLEN_BYTES);\n                    Buffer.BlockCopy(hash, 0, buf, CLEN_BYTES, ONETIMEAUTH_BYTES);\n                    length += AUTH_BYTES;
                IEncryptor encryptor = EncryptorFactory.GetEncryptor(_server.method, _server.password, _server.one_time_auth);\n                byte[] dataIn = new byte[length - 3 + IVEncryptor.ONETIMEAUTH_BYTES];
                byte[] dataOut = new byte[length - 3 + 16 + IVEncryptor.ONETIMEAUTH_BYTES];
                encryptor.Encrypt(dataIn, length - 3, dataOut, out outlen, true);\n                _remote.SendTo(dataOut, outlen, SocketFlags.None, _remoteEndPoint);


            this.ClientSize = new System.Drawing.Size(282, 206);

            SetConfigToUI(_modifiedHotkeyConfig);\n        }\n        private void SetConfigToUI(HotkeyConfig config)
            if (!RegisterAllHotkeys())
            RegisterAllHotkeys();\n        }\n        private bool RegisterAllHotkeys()

                }\n            }
                _runningPort = GetFreePort(configuration.isIPv6Enabled);
                privoxyConfig = configuration.isIPv6Enabled\n                    ? privoxyConfig.Replace("__PRIVOXY_BIND_IP__", configuration.shareOverLan ? "[::]" : "[::1]")\n                    .Replace("__SOCKS_HOST__", "[::1]")\n                    : privoxyConfig.Replace("__PRIVOXY_BIND_IP__", configuration.shareOverLan ? "0.0.0.0" : "127.0.0.1")\n                    .Replace("__SOCKS_HOST__", "127.0.0.1");
        private int GetFreePort(bool isIPv6 = false)
                TcpListener l = new TcpListener(isIPv6 ? IPAddress.IPv6Loopback : IPAddress.Loopback, 0);
            public EndPoint remoteEndPoint;
                _tcpSocket = new Socket(config.isIPv6Enabled ? AddressFamily.InterNetworkV6 : AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);\n                _udpSocket = new Socket(config.isIPv6Enabled ? AddressFamily.InterNetworkV6 : AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
                    ? new IPEndPoint(config.isIPv6Enabled ? IPAddress.IPv6Any : IPAddress.Any, _config.localPort)\n                    : new IPEndPoint(config.isIPv6Enabled ? IPAddress.IPv6Loopback : IPAddress.Loopback, _config.localPort);
                UDPState udpState = new UDPState(_udpSocket);
                EndPoint remoteEndPoint = new IPEndPoint(GetIPAddress(), 0);
                    EndPoint remoteEndPoint = new IPEndPoint(GetIPAddress(), 0);
            var socket = state.socket;\n            try\n            {\n                int bytesRead = socket.EndReceiveFrom(ar, ref state.remoteEndPoint);
                    if (service.Handle(state.buffer, bytesRead, socket, state))

        public string GetServerURLForCurrentServer()
            _remote?.EndConnect(asyncResult);
            _remote?.BeginSend(buffer, offset, size, socketFlags, callback, state);
            _remote?.BeginReceive(buffer, offset, size, socketFlags, callback, state);
            _remote?.BeginSend(buffer, offset, size, socketFlags, callback, state);
            _remote?.BeginReceive(buffer, offset, size, socketFlags, callback, state);
                _remote?.SendTo(dataOut, outlen, SocketFlags.None, _remoteEndPoint);
                _remote?.BeginReceiveFrom(_buffer, 0, _buffer.Length, 0, ref remoteEndPoint, new AsyncCallback(RecvFromCallback), null);
                    _local?.SendTo(sendBuf, outlen + 3, 0, _localEndPoint);

            // using event to avoid hanging when redirect standard output/error\n            // ref: https://stackoverflow.com/questions/139593/processstartinfo-hanging-on-waitforexit-why\n            // and http://blog.csdn.net/zhangweixing0/article/details/7356841\n            using (AutoResetEvent outputWaitHandle = new AutoResetEvent(false))\n            using (AutoResetEvent errorWaitHandle = new AutoResetEvent(false))
                using (var process = new Process())
                    // Configure the process using the StartInfo properties.\n                    process.StartInfo.FileName = Utils.GetTempPath("sysproxy.exe");\n                    process.StartInfo.Arguments = arguments;\n                    process.StartInfo.WorkingDirectory = Utils.GetTempPath();\n                    process.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;\n                    process.StartInfo.UseShellExecute = false;\n                    process.StartInfo.RedirectStandardError = true;\n                    process.StartInfo.RedirectStandardOutput = true;\n                    // Need to provide encoding info, or output/error strings we got will be wrong.\n                    process.StartInfo.StandardOutputEncoding = Encoding.Unicode;\n                    process.StartInfo.StandardErrorEncoding = Encoding.Unicode;\n                    process.StartInfo.CreateNoWindow = true;\n                    StringBuilder output = new StringBuilder();\n                    StringBuilder error = new StringBuilder();\n                    process.OutputDataReceived += (sender, e) =>
                        if (e.Data == null)\n                        {\n                            outputWaitHandle.Set();\n                        }\n                        else\n                        {\n                            output.AppendLine(e.Data);\n                        }\n                    };\n                    process.ErrorDataReceived += (sender, e) =>\n                    {\n                        if (e.Data == null)\n                        {\n                            errorWaitHandle.Set();\n                        }\n                        else\n                        {\n                            error.AppendLine(e.Data);\n                        }\n                    };\n                    process.Start();\n                    process.BeginErrorReadLine();\n                    process.BeginOutputReadLine();\n                    process.WaitForExit();\n                    var stderr = error.ToString();\n                    var stdout = output.ToString();\n                    var exitCode = process.ExitCode;\n                    if (exitCode != (int)RET_ERRORS.RET_NO_ERROR)\n                    {\n                        throw new ProxyException(stderr);
                    if (arguments == "query") {\n                        if (stdout.IsNullOrWhiteSpace() || stdout.IsNullOrEmpty()) {\n                            // we cannot get user settings\n                            throw new ProxyException("failed to query wininet settings");\n                        }\n                        _queryStr = stdout;\n                    }
                MenuItem item = new MenuItem(strategy.Name);
                item.Tag = i - strategyCount;
            get { return I18N.GetString("Load Balance"); }
            get { return "com.shadowsocks.strategy.balancing"; }\n        }\n        public void ReloadServers()\n        {\n            // do nothing
        /*\n         * TCPRelay will call this when latency of a server detected\n         */\n        void UpdateLatency(Server server, TimeSpan latency);\n        /*\n         * TCPRelay will call this when reading from a server\n         */
            this.RemarksTextBox.Location = new System.Drawing.Point(74, 139);
            this.label6.Location = new System.Drawing.Point(19, 142);
            this.label1.Location = new System.Drawing.Point(17, 11);
            this.label2.Location = new System.Drawing.Point(8, 37);
            this.ProxyPortTextBox.Location = new System.Drawing.Point(74, 113);
            this.label4.Location = new System.Drawing.Point(13, 116);
            this.label3.Location = new System.Drawing.Point(15, 63);
            this.IPTextBox.Location = new System.Drawing.Point(74, 8);
            this.ServerPortTextBox.Location = new System.Drawing.Point(74, 34);
            this.PasswordTextBox.Location = new System.Drawing.Point(74, 60);
            this.label5.Location = new System.Drawing.Point(11, 90);
            this.EncryptionSelect.Location = new System.Drawing.Point(74, 86);
            this.panel2.Location = new System.Drawing.Point(164, 175);
            this.OKButton.Location = new System.Drawing.Point(4, 4);
            this.MyCancelButton.Location = new System.Drawing.Point(87, 4);
            this.ServersItem,\n            this.menuItem1,\n            this.AutoStartupItem,
            this.editPACFileItem,


            this.ShareOverLANItem.Index = 4;
            this.ServersItem.Index = 1;
            this.DeleteButton.Location = new System.Drawing.Point(100, 4);
            this.AddButton.Location = new System.Drawing.Point(4, 4);
            this.ServerGroupBox.Location = new System.Drawing.Point(223, 12);
            this.ServerGroupBox.Size = new System.Drawing.Size(255, 205);
            this.ServersListBox.Location = new System.Drawing.Point(12, 12);
            // \n            // menuItem1\n            // \n            this.menuItem1.Index = 2;\n            this.menuItem1.Text = "-";\n            // 
private void AutoStartupItem_Click(object sender, EventArgs e) {\nAutoStartupItem.Checked = !AutoStartupItem.Checked;\nif (!AutoStartup.Set(AutoStartupItem.Checked)) {


﻿using System;
            this.config = config;\n            try
                WebClient http = CreateWebClient();\n                http.DownloadStringCompleted += http_DownloadStringCompleted;\n                http.DownloadStringAsync(new Uri(UpdateURL));
            catch (Exception ex)
                Logging.LogUsefulException(ex);

                List<Asset> asserts = new List<Asset>();
                        Asset ass = new Asset();\n                        ass.Parse(asset);\n                        if (ass.IsNewVersion(Version))
                            asserts.Add(ass);
                if (asserts.Count != 0)
                    SortByVersions(asserts);\n                    Asset asset = asserts[asserts.Count - 1];
                    LatestVersionURL = asset.browser_download_url;\n                    LatestVersionNumber = asset.version;\n                    LatestVersionName = asset.name;\n                    startDownload();\n                }\n                else if (CheckUpdateCompleted != null)\n                {\n                    CheckUpdateCompleted(this, new EventArgs());\n                }\n            }\n            catch (Exception ex)\n            {\n                Logging.LogUsefulException(ex);\n            }\n        }\n        private void startDownload()\n        {\n            try\n            {\n                string temppath = Utils.GetTempPath();\n                LatestVersionLocalName = Path.Combine(temppath, LatestVersionName);\n                WebClient http = CreateWebClient();\n                http.DownloadFileCompleted += Http_DownloadFileCompleted;\n                http.DownloadFileAsync(new Uri(LatestVersionURL), LatestVersionLocalName);\n            }\n            catch (Exception ex)\n            {\n                Logging.LogUsefulException(ex);\n            }\n        }\n        private void Http_DownloadFileCompleted(object sender, System.ComponentModel.AsyncCompletedEventArgs e)\n        {\n            try\n            {\n                if(e.Error != null)\n                {\n                    Logging.LogUsefulException(e.Error);\n                    return;
                Logging.LogUsefulException(ex);\n            }\n        }\n        private WebClient CreateWebClient()\n        {\n            WebClient http = new WebClient();\n            http.Headers.Add("User-Agent", UserAgent);\n            http.Proxy = new WebProxy(IPAddress.Loopback.ToString(), config.localPort);\n            return http;\n        }\n        private void SortByVersions(List<Asset> asserts)\n        {\n            asserts.Sort(new VersionComparer());\n        }\n        class Asset\n        {\n            public bool prerelease;\n            public string name;\n            public string version;\n            public string browser_download_url;\n            public bool IsNewVersion(string currentVersion)\n            {\n                if (prerelease)\n                {\n                    return false;\n                }\n                if (version == null)\n                {\n                    return false;\n                }\n                return CompareVersion(version, currentVersion) > 0;\n            }\n            public void Parse(JsonObject asset)\n            {\n                name = (string)asset["name"];\n                browser_download_url = (string)asset["browser_download_url"];\n                version = ParseVersionFromURL(browser_download_url);\n                prerelease = browser_download_url.IndexOf("prerelease") >= 0;\n            }\n            private static string ParseVersionFromURL(string url)\n            {\n                Match match = Regex.Match(url, @".*Shadowsocks-win.*?-([\d\.]+)\.\w+", RegexOptions.IgnoreCase);\n                if (match.Success)\n                {\n                    if (match.Groups.Count == 2)\n                    {\n                        return match.Groups[1].Value;\n                    }\n                }\n                return null;\n            }\n            public static int CompareVersion(string l, string r)\n            {\n                var ls = l.Split('.');\n                var rs = r.Split('.');\n                for (int i = 0; i < Math.Max(ls.Length, rs.Length); i++)\n                {\n                    int lp = (i < ls.Length) ? int.Parse(ls[i]) : 0;\n                    int rp = (i < rs.Length) ? int.Parse(rs[i]) : 0;\n                    if (lp != rp)\n                    {\n                        return lp - rp;\n                    }\n                }\n                return 0;\n            }\n        }\n        class VersionComparer : IComparer<Asset>\n        {\n            // Calls CaseInsensitiveComparer.Compare with the parameters reversed. \n            public int Compare(Asset x, Asset y)\n            {\n                return Asset.CompareVersion(x.version, y.version);
        public void SendResponse(byte[] firstPacket, int length, Socket socket, bool useSocks)
                string proxy = GetPACAddress(firstPacket, length, localEndPoint, useSocks);
        private string GetPACAddress(byte[] requestBuf, int length, IPEndPoint localEndPoint, bool useSocks)
            //try\n            //{\n            //    string requestString = Encoding.UTF8.GetString(requestBuf);\n            //    if (requestString.IndexOf("AppleWebKit") >= 0)\n            //    {\n            //        string address = "" + localEndPoint.Address + ":" + config.GetCurrentServer().local_port;\n            //        proxy = "SOCKS5 " + address + "; SOCKS " + address + ";";\n            //    }\n            //}\n            //catch (Exception e)\n            //{\n            //    Console.WriteLine(e);\n            //}\n            return (useSocks ? "SOCKS5 " : "PROXY ") + localEndPoint.Address + ":" + this._config.localPort + ";";
                polipoConfig = polipoConfig.Replace("__POLIPO_BIND_PORT__", _runningPort.ToString());
                        {\n                            pacUrl =\n                                $"http://127.0.0.1:{config.localPort}/pac?t={GetTimestamp(DateTime.Now)}{pacSrv.PacSecret}";\n                        }
            Configuration config = Configuration.Load();\n            List<KeyValuePair<string, string>> serverDatas = config.configs.Select(
                    new KeyValuePair<string, string>(server.GetURL(config.generateLegacyUrl), server.ToString())
            int selectIndex = serverDatas.FindIndex(serverData => serverData.Key.StartsWith(code));
        public string GetURL(bool legacyUrl = false)\n        {\n            string tag = string.Empty;\n            string url = string.Empty;\n            if (legacyUrl && string.IsNullOrWhiteSpace(plugin))\n            {\n                // For backwards compatiblity, if no plugin, use old url format\n                string parts = $"{method}:{password}@{server}:{server_port}";\n                string base64 = Convert.ToBase64String(Encoding.UTF8.GetBytes(parts));\n                url = base64;\n            }\n            else\n            {\n                // SIP002\n                string parts = $"{method}:{password}";\n                string base64 = Convert.ToBase64String(Encoding.UTF8.GetBytes(parts));\n                string websafeBase64 = base64.Replace('+', '-').Replace('/', '_').TrimEnd('=');\n                url = string.Format(\n                    "{0}@{1}:{2}/",\n                    websafeBase64,\n                    FormalHostName,\n                    server_port\n                    );\n                if (!plugin.IsNullOrWhiteSpace())\n                {
                    string pluginQuery = "?plugin=" + HttpUtility.UrlEncode(pluginPart, Encoding.UTF8);\n                    url += pluginQuery;\n                }\n            }\n            if (!remarks.IsNullOrEmpty())\n            {\n                tag = $"#{HttpUtility.UrlEncode(remarks, Encoding.UTF8)}";\n            }\n            return $"ss://{url}{tag}";
        public LineReader(WrappedSocket socket, byte[] firstPackge, int index, int length,
            Encoding encoding, string delimiter, int maxLineBytes,

            if (maxLineBytes < length)
                throw new ArgumentException("Line buffer length can't less than first package length!", nameof(maxLineBytes));
            if (maxLineBytes < _delimiterBytes.Length)
                throw new ArgumentException("Too small!", nameof(maxLineBytes));
            _lineBuffer = new byte[maxLineBytes];
                Array.Copy(firstPackge, index, _lineBuffer, 0, length);
                socket.BeginReceive(_lineBuffer, 0, maxLineBytes, 0, ReceiveCallback, 0);
        public LineReader(WrappedSocket socket, Func<string, object, bool> onLineRead,\n            Action<Exception, object> onException,\n            Action<byte[], int, int, object> onFinish, Encoding encoding, string delimiter, int maxLineBytes,\n            object state)\n            : this(socket, null, 0, 0, onLineRead, onException, onFinish, encoding, delimiter, maxLineBytes, state)
                        Sysproxy.SetIEProxy(true, true, "127.0.0.1:" + config.localPort.ToString(), "");
                ssURLAssociation = Registry.CurrentUser.CreateSubKey(ssURLRegKey, RegistryKeyPermissionCheck.ReadWriteSubTree);

                Configuration config = SimpleJson.SimpleJson.DeserializeObject<Configuration>(configContent, new JsonSerializerStrategy());
            QRCode code = ZXing.QrCode.Internal.Encoder.encode(qrText, ErrorCorrectionLevel.M);\n            ByteMatrix m = code.Matrix;\n            int blockSize = Math.Max(200 / m.Height, 1);\n            Bitmap drawArea = new Bitmap((m.Height * blockSize), (m.Height * blockSize));
                    for (int row = 0; row < m.Height; row++)
                        for (int col = 0; col < m.Height; col++)
                            if (m[row, col] != 0)
            return new MenuItem(I18N.GetString(text), click);
            return new MenuItem(I18N.GetString(text), items);
                    this.SeperatorItem = new MenuItem("-"),
                new MenuItem("-"),
                new MenuItem("-"),
                new MenuItem("-"),
        public static List<string> ParseBase64ToValidList(string response)
                    arguments = $"global {proxyServer} <local>localhost;127.*;10.*;172.16.*;172.17.*;172.18.*;172.19.*;172.20.*;172.21.*;172.22.*;172.23.*;172.24.*;172.25.*;172.26.*;172.27.*;172.28.*;172.29.*;172.30.*;172.31.*;172.32.*;192.168.*";
                    arguments = $"pac {pacURL}";

            this.enableItem.Text = I18N.GetString("Enable");
            this.modeItem.Text = I18N.GetString("Mode");
            this.PACModeItem.Text = I18N.GetString("PAC");
            this.globalModeItem.Text = I18N.GetString("Global");
            this.ServersItem.Text = I18N.GetString("Servers");
            this.ConfigItem.Text = I18N.GetString("Edit Servers...");
            this.AutoStartupItem.Text = I18N.GetString("Start on Boot");
            this.ShareOverLANItem.Text = I18N.GetString("Share over LAN");
            this.editPACFileItem.Text = I18N.GetString("Edit PAC File...");
            this.QRCodeItem.Text = I18N.GetString("Show QRCode...");
            this.ShowLogItem.Text = I18N.GetString("Show Logs...");
            this.aboutItem.Text = I18N.GetString("About...");
            this.quitItem.Text = I18N.GetString("Quit");
            this.RemarksLabel = new System.Windows.Forms.Label();\n            this.IPLabel = new System.Windows.Forms.Label();\n            this.ServerPortLabel = new System.Windows.Forms.Label();
            this.ProxyPortLabel = new System.Windows.Forms.Label();\n            this.PasswordLabel = new System.Windows.Forms.Label();
            this.EncryptionLabel = new System.Windows.Forms.Label();
            this.tableLayoutPanel1.Controls.Add(this.RemarksLabel, 0, 5);\n            this.tableLayoutPanel1.Controls.Add(this.IPLabel, 0, 0);\n            this.tableLayoutPanel1.Controls.Add(this.ServerPortLabel, 0, 1);
            this.tableLayoutPanel1.Controls.Add(this.ProxyPortLabel, 0, 4);\n            this.tableLayoutPanel1.Controls.Add(this.PasswordLabel, 0, 2);
            this.tableLayoutPanel1.Controls.Add(this.EncryptionLabel, 0, 3);
            // RemarksLabel\n            // \n            this.RemarksLabel.Anchor = System.Windows.Forms.AnchorStyles.Right;\n            this.RemarksLabel.AutoSize = true;\n            this.RemarksLabel.Location = new System.Drawing.Point(19, 142);\n            this.RemarksLabel.Name = "RemarksLabel";\n            this.RemarksLabel.Size = new System.Drawing.Size(49, 13);\n            this.RemarksLabel.TabIndex = 9;\n            this.RemarksLabel.Text = "Remarks";\n            // \n            // IPLabel\n            // \n            this.IPLabel.Anchor = System.Windows.Forms.AnchorStyles.Right;\n            this.IPLabel.AutoSize = true;\n            this.IPLabel.Location = new System.Drawing.Point(17, 11);\n            this.IPLabel.Name = "IPLabel";\n            this.IPLabel.Size = new System.Drawing.Size(51, 13);\n            this.IPLabel.TabIndex = 0;\n            this.IPLabel.Text = "Server IP";\n            // \n            // ServerPortLabel\n            // \n            this.ServerPortLabel.Anchor = System.Windows.Forms.AnchorStyles.Right;\n            this.ServerPortLabel.AutoSize = true;\n            this.ServerPortLabel.Location = new System.Drawing.Point(8, 37);\n            this.ServerPortLabel.Name = "ServerPortLabel";\n            this.ServerPortLabel.Size = new System.Drawing.Size(60, 13);\n            this.ServerPortLabel.TabIndex = 1;\n            this.ServerPortLabel.Text = "Server Port";
            // ProxyPortLabel\n            // \n            this.ProxyPortLabel.Anchor = System.Windows.Forms.AnchorStyles.Right;\n            this.ProxyPortLabel.AutoSize = true;\n            this.ProxyPortLabel.Location = new System.Drawing.Point(13, 116);\n            this.ProxyPortLabel.Name = "ProxyPortLabel";\n            this.ProxyPortLabel.Size = new System.Drawing.Size(55, 13);\n            this.ProxyPortLabel.TabIndex = 3;\n            this.ProxyPortLabel.Text = "Proxy Port";\n            // \n            // PasswordLabel\n            // \n            this.PasswordLabel.Anchor = System.Windows.Forms.AnchorStyles.Right;\n            this.PasswordLabel.AutoSize = true;\n            this.PasswordLabel.Location = new System.Drawing.Point(15, 63);\n            this.PasswordLabel.Name = "PasswordLabel";\n            this.PasswordLabel.Size = new System.Drawing.Size(53, 13);\n            this.PasswordLabel.TabIndex = 2;\n            this.PasswordLabel.Text = "Password";
        private System.Windows.Forms.Label IPLabel;\n        private System.Windows.Forms.Label ServerPortLabel;\n        private System.Windows.Forms.Label PasswordLabel;\n        private System.Windows.Forms.Label ProxyPortLabel;
        private System.Windows.Forms.Label EncryptionLabel;
            var currIndex = _modifiedConfiguration.configs.IndexOf( currServer );\n            _modifiedConfiguration.configs.Insert(currIndex + 1, currServer);
            ServersListBox.SelectedIndex = currIndex + 1;
                FileManager.UncompressFile(dllPath, Resources.libsscrypto_dll);\n                LoadLibrary(dllPath);
            catch (IOException)\n            {\n            }\n            catch (Exception e)

        internal static byte[] libsscrypto_dll {
                object obj = ResourceManager.GetObject("libsscrypto_dll", resourceCulture);
                FileManager.UncompressFile(dllPath, Resources.libsscrypto_dll);\n                LoadLibrary(dllPath);
            catch (IOException)\n            {\n            }\n            catch (Exception e)

            topMostTriggerLock = false;\n            wrapTextTriggerLock = true;\n            LogMessageTextBox.WordWrap = WrapTextMenuItem.Checked = WrapTextCheckBox.Checked = wrapTextTrigger;\n            wrapTextTriggerLock = false;\n            ToolbarFlowLayoutPanel.Visible = ShowToolbarMenuItem.Checked = toolbarTrigger;



            if (_keymap.Any(v => v.Value == cb))
                hotkey = _keymap.First(v => v.Value == cb).Key;
            else

            if (!RegisterAllHotkeys(_modifiedHotkeyConfig))
            _modifiedHotkeyConfig = GetConfigFromUI();\n            RegisterAllHotkeys(_modifiedHotkeyConfig);\n        }\n        private bool RegisterAllHotkeys(HotkeyConfig hotkeyConfig)\n        {\n            return\n                TryRegHotkeyFromString(hotkeyConfig.SwitchSystemProxy, "SwitchSystemProxyCallback", SwitchSystemProxyLabel)\n                && TryRegHotkeyFromString(hotkeyConfig.SwitchSystemProxyMode, "SwitchProxyModeCallback", SwitchProxyModeLabel)\n                && TryRegHotkeyFromString(hotkeyConfig.SwitchAllowLan, "SwitchAllowLanCallback", SwitchAllowLanLabel)\n                && TryRegHotkeyFromString(hotkeyConfig.ShowLogs, "ShowLogsCallback", ShowLogsLabel)\n                && TryRegHotkeyFromString(hotkeyConfig.ServerMoveUp, "ServerMoveUpCallback", ServerMoveUpLabel)\n                && TryRegHotkeyFromString(hotkeyConfig.ServerMoveDown, "ServerMoveDownCallback", ServerMoveDownLabel);\n        }\n        private bool TryRegHotkeyFromString(string hotkeyStr, string callbackName, Label indicator = null)\n        {\n            var _callback = HotkeyCallbacks.GetCallback(callbackName);\n            if (_callback == null)\n            {\n                throw new Exception($"{callbackName} not found");\n            }\n            var callback = _callback as HotKeys.HotKeyCallBackHandler;\n            if (hotkeyStr.IsNullOrEmpty())\n            {\n                UnregPrevHotkey(callback);\n                return true;\n            }\n            else\n            {\n                var hotkey = HotKeys.Str2HotKey(hotkeyStr);\n                if (hotkey == null)\n                {\n                    MessageBox.Show(string.Format(I18N.GetString("Cannot parse hotkey: {0}"), hotkeyStr));\n                    return false;\n                }\n                else\n                {\n                    bool regResult = (TryRegHotkey(hotkey, callback));\n                    if (indicator != null)\n                    {\n                        indicator.BackColor = regResult ? Color.Green : Color.Yellow;\n                    }\n                    return regResult;\n                }\n            }\n        }\n        private bool TryRegHotkey(GlobalHotKey.HotKey hotkey, HotKeys.HotKeyCallBackHandler callback)\n        {\n            UnregPrevHotkey(callback);\n            return HotKeys.Register(hotkey, callback);







        public TCPRelay(ShadowsocksController controller, Configuration conf)
        public IProxy remote;
        private bool proxyConnected;\n        private bool destConnected;
                    Logging.Debug(remote.LocalEndPoint, remote.DestEndPoint, RecvSize, "TCP Relay");
                        Logging.Debug(remote.LocalEndPoint, remote.DestEndPoint, RecvSize, "TCP Relay");
                remote = new DirectConnect();\n                ProxyTimer proxyTimer = new ProxyTimer(3000);\n                proxyTimer.AutoReset = false;\n                proxyTimer.Elapsed += proxyConnectTimer_Elapsed;\n                proxyTimer.Enabled = true;\n                proxyTimer.DestEndPoint = remoteEP;\n                proxyTimer.Server = server;\n                proxyConnected = false;\n                // Connect to the proxy server.\n                remote.BeginConnectProxy(remoteEP, new AsyncCallback(ProxyConnectCallback), proxyTimer);\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void proxyConnectTimer_Elapsed(object sender, ElapsedEventArgs e)\n        {\n            if (proxyConnected || destConnected)\n            {\n                return;\n            }\n            var ep = ((ProxyTimer)sender).DestEndPoint;\n            Logging.Info($"Proxy {ep} timed out");\n            remote.Close();\n            RetryConnect();\n        }\n        private void ProxyConnectCallback(IAsyncResult ar)\n        {\n            Server server = null;\n            if (closed)\n            {\n                return;\n            }\n            try\n            {\n                ProxyTimer timer = (ProxyTimer)ar.AsyncState;\n                var destEP = timer.DestEndPoint;\n                server = timer.Server;\n                timer.Elapsed -= proxyConnectTimer_Elapsed;\n                timer.Enabled = false;\n                timer.Dispose();\n                // Complete the connection.\n                remote.EndConnectProxy(ar);\n                proxyConnected = true;\n                Logging.Debug($"Socket connected to proxy {remote.ProxyEndPoint}");
                connectTimer.Elapsed += destConnectTimer_Elapsed;
                destConnected = false;
                remote.BeginConnectDest(destEP, new AsyncCallback(ConnectCallback), connectTimer);\n            }\n            catch (ArgumentException)\n            {\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                RetryConnect();\n            }\n        }\n        private void destConnectTimer_Elapsed(object sender, ElapsedEventArgs e)\n        {\n            if (destConnected)
                timer.Elapsed -= destConnectTimer_Elapsed;
                remote.EndConnectDest(ar);\n                destConnected = true;\n                Logging.Debug($"Socket connected to {remote.DestEndPoint}");
        public int KeySize;\n        public int IvSize;\n        public int Type;\n        public string InnerLibName;\n        // For those who make use of internal crypto method name\n        // e.g. mbed TLS\n        public EncryptorInfo(string innerLibName, int keySize, int ivSize, int type)
            this.KeySize = keySize;\n            this.IvSize = ivSize;\n            this.Type = type;\n            this.InnerLibName = innerLibName;\n        }\n        public EncryptorInfo(int keySize, int ivSize, int type)\n        {\n            this.KeySize = keySize;\n            this.IvSize = ivSize;\n            this.Type = type;\n            this.InnerLibName = string.Empty;
            using (Mutex mutex = new Mutex(false, "Global\\" + Assembly.GetExecutingAssembly().GetType().GUID.ToString()))
                if (!mutex.WaitOne(0, false))\n                {\n                    Process[] oldProcesses = Process.GetProcessesByName("Shadowsocks");\n                    if (oldProcesses.Length > 0)\n                    {\n                        Process oldProcess = oldProcesses[0];\n                    }\n                    MessageBox.Show("Shadowsocks is already running.\n\nFind Shadowsocks icon in your notify tray.");\n                    return;\n                }\n                string tempPath = Path.GetTempPath();\n                string dllPath = tempPath + "/polarssl.dll";\n                try\n                {\n                    FileManager.UncompressFile(dllPath, Resources.polarssl_dll);\n                }\n                catch (IOException e)\n                {\n                    Console.WriteLine(e.ToString());\n                }\n                LoadLibrary(dllPath);\n                try\n                {\n                    FileStream fs = new FileStream("shadowsocks.log", FileMode.Append);\n                    TextWriter tmp = Console.Out;\n                    StreamWriter sw = new StreamWriter(fs);\n                    sw.AutoFlush = true;\n                    Console.SetOut(sw);\n                    Console.SetError(sw);\n                }\n                catch (IOException e)\n                {\n                    Console.WriteLine(e.ToString());\n                }\n                Application.EnableVisualStyles();\n                Application.SetCompatibleTextRenderingDefault(false);\n                ShadowsocksController controller = new ShadowsocksController();\n                // TODO run without a main form to save RAM\n                Application.Run(new ConfigForm(controller));

            series1.Color = System.Drawing.Color.FromArgb(255, 128, 0);
            series2.Color = System.Drawing.Color.FromArgb(128, 128, 255);

        protected uint counter = 0;\n        protected byte[] _keyBuffer = null;

        protected int ss_onetimeauth(byte[] auth, byte[] msg, int msg_len)
            Buffer.BlockCopy(_encryptIV, 0, auth_bytes, 0, ivLen);\n            Buffer.BlockCopy(_key, 0, auth_bytes, ivLen, keyLen);\n            Sodium.crypto_generichash(auth_key, ONETIMEAUTH_KEYBYTES, auth_bytes, (ulong)(ivLen + keyLen), null, 0);
        protected void ss_gen_hash(byte[] buf, ref int offset, ref int len, int buf_size)\n        {\n            int size = len + AUTH_BYTES;
            byte[] tmp = new byte[len];\n            Buffer.BlockCopy(buf, offset, tmp, 0, len);\n            Sodium.crypto_generichash(hash, HASH_BYTES, tmp, (ulong)len, _keyBuffer, (uint)_keyBuffer.Length);\n            Buffer.BlockCopy(buf, offset, buf, offset + AUTH_BYTES, len);\n            Buffer.BlockCopy(hash, 0, buf, offset + CLEN_BYTES, HASH_BYTES);\n            byte[] clen = BitConverter.GetBytes((ushort)IPAddress.HostToNetworkOrder((short)len));\n            Buffer.BlockCopy(clen, 0, buf, offset, CLEN_BYTES);\n            counter++;\n            len += AUTH_BYTES;\n            offset += len;
                        splash.Location = new Point(0, 0);
                        splash.TargetRect = new Rectangle((int)minX, (int)minY, (int)maxX - (int)minX, (int)maxY - (int)minY);\n                        splash.Size = new Size(fullImage.Width, fullImage.Height);
    public class QRCodeSplashForm : PerPixelAlphaForm
            this.Load += QRCodeSplashForm_Load;\n            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.None;\n            this.BackColor = System.Drawing.Color.White;\n            this.ClientSize = new System.Drawing.Size(284, 262);\n            this.ControlBox = false;\n            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.None;\n            this.MaximizeBox = false;\n            this.MinimizeBox = false;\n            this.Name = "QRCodeSplashForm";\n            this.ShowIcon = false;\n            this.ShowInTaskbar = false;\n            this.SizeGripStyle = System.Windows.Forms.SizeGripStyle.Hide;\n            this.StartPosition = System.Windows.Forms.FormStartPosition.Manual;\n            this.TopMost = true;
            SetStyle(ControlStyles.SupportsTransparentBackColor, true);\n            this.BackColor = Color.Transparent;\n            animationStep = 0;\n            flashStep = 0;\n            //codeRectView = new QRRectView();\n            x = 0;\n            y = 0;\n            w = Width;\n            h = Height;\n            //this.Controls.Add(codeRectView);
            timer.Interval = (int)(ANIMATION_TIME * 1000 / ANIMATION_STEPS);
            if (!File.Exists(PAC_FILE))
                File.WriteAllText(PAC_FILE, Resources.proxy_pac_txt);
            return PAC_FILE;
            if (!File.Exists(USER_RULE_FILE))

                return Resources.proxy_pac_txt;
            string geositeUrl = GEOSITE_URL;\n            string group = "geolocation-!cn";\n            bool blacklist = true;\n            if (!string.IsNullOrWhiteSpace(config.geositeGroup))
                group = config.geositeGroup;\n                blacklist = config.geositeBlacklistMode;
            if (!string.IsNullOrWhiteSpace(config.geositeUrl))\n            {\n                logger.Info("Found custom Geosite URL in config file");\n                geositeUrl = config.geositeUrl;\n            }\n            logger.Info($"Checking Geosite from {geositeUrl}");
                    bool pacFileChanged = MergeAndWritePACFile(group, blacklist);
            http.DownloadDataAsync(new Uri(geositeUrl));
        public static bool MergeAndWritePACFile(string group, bool blacklist)
            IList<DomainObject> domains = Geosites[group];\n            string abpContent = MergePACFile(domains, blacklist);
                userruleLines = PreProcessGFWList(userrulesString);
            List<string> gfwLines = GeositeToGFWList(domains, blacklist);
        private static List<string> PreProcessGFWList(string content)
        private static List<string> GeositeToGFWList(IList<DomainObject> domains, bool blacklist)
            return blacklist ? GeositeToGFWListBlack(domains) : GeositeToGFWListWhite(domains);\n        }\n        private static List<string> GeositeToGFWListBlack(IList<DomainObject> domains)\n        {\n            List<string> ret = new List<string>(domains.Count + 100);// 100 overhead
                        ret.Add(domain);
        public PACDaemon(Configuration config)
                GeositeUpdater.MergeAndWritePACFile(config.geositeGroup, config.geositeBlacklistMode);
        public static RegistryKey OpenRegKey( string name, bool writable, RegistryHive hive = RegistryHive.CurrentUser )
                RegistryKey userKey = RegistryKey.OpenBaseKey(hive,
            Interlocked.Add(ref inboundCounter, n);
            Interlocked.Add(ref outboundCounter, n);
            config = Configuration.Load();
            polipoRunner.Start(config.GetCurrentServer());\n            local = new Local(config.GetCurrentServer());
        public void SaveConfig(Configuration newConfig)
            Configuration.Save(newConfig);
            polipoRunner.Start(config.GetCurrentServer());\n            local = new Local(config.GetCurrentServer());
        public Server GetCurrentServer()\n        {\n            return config.GetCurrentServer();\n        }\n        public Configuration GetConfiguration()
            Server server = controller.GetCurrentServer();\n            textBox1.Text = server.server;\n            textBox2.Text = server.server_port.ToString();\n            textBox3.Text = server.password;\n            textBox4.Text = server.local_port.ToString();\n            comboBox1.Text = server.method == null ? "aes-256-cfb" : server.method;\n            enableItem.Checked = controller.GetConfiguration().enabled;
            if (!controller.GetConfiguration().isDefault)
                Server server = new Server
                    method = comboBox1.Text
                            var location = m.Groups[2].Value;\n                            var locs = location.Split(':');\n                            _targetHost = locs[0];\n                            if (locs.Length > 1)
                                if (!int.TryParse(locs[1], out _targetPort))\n                                {\n                                    throw new Exception("Bad http header: " + line);\n                                }\n                            }\n                            else\n                            {\n                                _targetPort = 80;
                            var location = line.Substring(6).Trim();\n                            var locs = location.Split(':');\n                            _targetHost = locs[0];\n                            if (locs.Length > 1)
                                if (!int.TryParse(locs[1], out _targetPort))\n                                {\n                                    throw new Exception("Bad http header: " + line);\n                                }\n                            }\n                            else\n                            {\n                                _targetPort = 80;
                    switch(_command)\n                    {\n                        case CMD_CONNECT:\n                            // +----+-----+-------+------+----------+----------+\n                            // |VER | REP |  RSV  | ATYP | BND.ADDR | BND.PORT |\n                            // +----+-----+-------+------+----------+----------+\n                            // | 1  |  1  | X'00' |  1   | Variable |    2     |\n                            // +----+-----+-------+------+----------+----------+
                            break;\n                        case CMD_UDP_ASSOC:
                            break;\n                        case CMD_BIND:  // not implemented\n                        default:\n                            Logging.Debug("Unsupported CMD=" + _command);\n                            Close();\n                            break;



            catch (ArgumentException ae)\n            {\n                MessageBox.Show("OpenRegKey: " + ae.ToString());
            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);
﻿using System.Runtime.InteropServices;
    internal static class RemoteAccessService
﻿using System;


        public static readonly string PAC_FILE = "pac.txt";\n        public static readonly string USER_RULE_FILE = "user-rule.txt";\n        public static readonly string USER_ABP_FILE = "abp.txt";
                if (File.Exists(PACServer.USER_RULE_FILE))
                    string local = File.ReadAllText(PACServer.USER_RULE_FILE, Encoding.UTF8);
                if (File.Exists(PACServer.USER_ABP_FILE))
                    abpContent = File.ReadAllText(PACServer.USER_ABP_FILE, Encoding.UTF8);
                    string original = File.ReadAllText(PACServer.PAC_FILE, Encoding.UTF8);
                File.WriteAllText(PACServer.PAC_FILE, abpContent, Encoding.UTF8);
                try
                    var reply = await ping.SendTaskAsync(server.server, Timeout);\n                    ret.Add(new List<KeyValuePair<string, string>>\n                    {\n                        new KeyValuePair<string, string>("Timestamp", timestamp),\n                        new KeyValuePair<string, string>("Server", server.FriendlyName()),\n                        new KeyValuePair<string, string>("Status", reply?.Status.ToString()),\n                        new KeyValuePair<string, string>("RoundtripTime", reply?.RoundtripTime.ToString())\n                        //new KeyValuePair<string, string>("data", reply.Buffer.ToString()); // The data of reply\n                    });\n                }\n                catch (PingException e)\n                {\n                    Logging.LogUsefulException(e);\n                }
            if (md5_ret(input, (uint) input.Length, output) != 0)\n                throw new System.Exception("mbedtls: MD5 failure");
        public static extern int md5_ret(byte[] input, uint ilen, byte[] output);
    class Local : Listener.Service

        }\n        public bool GoodForMe(byte[] firstPacket, int length)\n        {\n            return true;\n        }\n        public void Handle(byte[] firstPacket, int length, Socket socket)\n        {\n            socket.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n            Handler handler = new Handler();\n            handler.connection = socket;\n            Server server = _config.GetCurrentServer();\n            handler.encryptor = EncryptorFactory.GetEncryptor(server.method, server.password);\n            handler.server = server;\n            handler.Start(firstPacket, length);
                int bytesRead = _firstPacketLength;
                    if (_firstPacket[0] != 5)
            if (_listener != null)\n            {\n                _listener.Stop();
                Local local = new Local(_config);\n                List<Listener.Service> services = new List<Listener.Service>();\n                services.Add(local);\n                _listener = new Listener(services);\n                _listener.Start(_config);
            this.valueLabel.Size = new System.Drawing.Size(118, 24);
            const string API = "http://ip-api.com/json";\n            const string alternativeAPI = "http://www.telize.com/geoip"; //must be compatible with current API\n            var result = await GetInfoFromAPI(API);\n            if (result != null) return result;\n            result = await GetInfoFromAPI(alternativeAPI);\n            if (result != null) return result;\n            return new DataList
                return null;
            if (!SimpleJson.SimpleJson.TryDeserializeObject(jsonString, out obj)) return null;
            if (country == null || city == null || isp == null) return null;\n            return new DataList {\n                new DataUnit(State.Geolocation, $"{country} {city}"),\n                new DataUnit(State.ISP, isp)\n            };
        private void loadChartData()
            IEnumerable<IGrouping<int, AvailabilityStatistics.RawStatisticsData>> dataGroups;\n            if (allMode.Checked)
                dataGroups = statistics.GroupBy(data => data.Timestamp.DayOfYear);\n                StatisticsChart.ChartAreas["DataArea"].AxisX.LabelStyle.Format = "MM/dd/yyyy";\n                StatisticsChart.ChartAreas["DataArea"].AxisX2.LabelStyle.Format = "MM/dd/yyyy";
            loadChartData();\n        }\n        private void chartModeSelector_Enter(object sender, EventArgs e)\n        {\n        }\n        private void dayMode_CheckedChanged(object sender, EventArgs e)\n        {\n            loadChartData();\n        }\n        private void allMode_CheckedChanged(object sender, EventArgs e)\n        {\n            loadChartData();

            this.chartModeSelector.SuspendLayout();

            this.chartModeSelector.ResumeLayout(false);\n            this.chartModeSelector.PerformLayout();
                    CreateMenuItem("Scan QRCode from Screen...", new EventHandler(this.ScanQRCodeItem_Click)),\n                    CreateMenuItem("Import URL from Clipboard...", new EventHandler(this.ImportURLItem_Click))
                        registry.SetValue("AutoConfigURL", pacUrl);
                if (File.Exists(updateChecker.LatestVersionLocalName))
                    Process.Start("explorer.exe", argument);

        private const string StatisticsFilesName = "shadowsocks.availability.csv";\n        private const string Delimiter = ",";\n        private const int Timeout = 500;\n        private const int Repeat = 4; //repeat times every evaluation\n        private const int Interval = 10*60*1000; //evaluate proxies every 15 minutes\n        private Timer _timer;\n        private State _state;\n        private List<Server> _servers;
            var temppath = Path.GetTempPath();
                    if (_timer?.Change(0, Interval) != null) return true;\n                    _state = new State();\n                    _timer = new Timer(Evaluate, _state, 0, Interval);
            var ping = new Ping();\n            var state = (State) obj;\n            foreach (var server in _servers)
                    var timestamp = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss");
                    //seems no need to use SendPingAsync：\n                    var reply = ping.Send(server.server, Timeout);\n                    state.Data = new List<KeyValuePair<string, string>>\n                    {\n                        new KeyValuePair<string, string>("Timestamp", timestamp),\n                        new KeyValuePair<string, string>("Server", server.FriendlyName()),\n                        new KeyValuePair<string, string>("Status", reply?.Status.ToString()),\n                        new KeyValuePair<string, string>("RoundtripTime", reply?.RoundtripTime.ToString())\n                    };
            var dataLine = string.Join(Delimiter, data.Select(kv => kv.Value).ToArray());
                var headerLine = string.Join(Delimiter, data.Select(kv => kv.Key).ToArray());\n                lines = new[] { headerLine, dataLine };
                lines = new[] { dataLine };
﻿using System;
    internal class TCPRelay : Listener.Service
        private static readonly Logger logger = LogManager.GetCurrentClassLogger();\n        private readonly ShadowsocksController _controller;
        private readonly Configuration _config;
        private class AsyncSession
        private class AsyncSession<T> : AsyncSession
        private static readonly Logger Logger = LogManager.GetCurrentClassLogger();
        private readonly ShadowsocksController _controller;\n        private readonly ProxyConfig _config;\n        private readonly Socket _connection;
        private readonly byte[] _remoteRecvBuffer = new byte[BufferSize];
        private readonly byte[] _connetionRecvBuffer = new byte[BufferSize];
        private readonly byte[] _remoteSendBuffer = new byte[BufferSize];
        private readonly byte[] _connetionSendBuffer = new byte[BufferSize];
            _server = server;
                if (_closed)\n                {\n                    return;\n                }
                }\n            }\n            catch (Exception e)\n            {\n                ErrorClose(e);
            if (_closed)\n            {\n                return;\n            }
                    AddressReceiveCallback, null);\n            }\n            catch (Exception e)\n            {\n                ErrorClose(e);\n            }\n        }\n        private void AddressReceiveCallback(IAsyncResult ar)\n        {\n            if (_closed)\n            {\n                return;\n            }
                ErrorClose(e);\n            }\n        }\n        private void ConnectResponseCallback(IAsyncResult ar)
                ErrorClose(e);
            if (_closed)\n            {\n                return;\n            }
                object[] states = (object[])ar.AsyncState;
                Action onSuccess = (Action)states[1];
                    }\n                }\n            }\n            catch (Exception e)\n            {\n                ErrorClose(e);
                ErrorClose(e);
            ProxyTimer timer = (ProxyTimer)sender;
            IProxy proxy = timer.Session.Remote;
                AsyncSession<ProxyTimer> session = (AsyncSession<ProxyTimer>)ar.AsyncState;
                EndPoint destEndPoint = timer.DestEndPoint;\n                Server server = timer.Server;
                IProxy remote = session.Remote;
                ErrorClose(e);
            ServerTimer timer = (ServerTimer)sender;
            AsyncSession session = timer.Session;
            if (_closed)\n            {\n                return;\n            }\n            try\n            {\n                AsyncSession<ServerTimer> session = (AsyncSession<ServerTimer>)ar.AsyncState;
                IProxy remote = session.Remote;
                TimeSpan latency = DateTime.Now - _startConnectTime;
                ErrorClose(e);
                int size = _connection.Receive(_connetionRecvBuffer, _firstPacketLength, available,
            if (_closed)\n            {\n                return;\n            }
                ErrorClose(e);
            if (_closed)\n            {\n                return;\n            }\n            try\n            {\n                AsyncSession session = (AsyncSession)ar.AsyncState;
                ErrorClose(e);
            if (_closed)\n            {\n                return;\n            }
                AsyncSession session = (AsyncSession)ar.AsyncState;\n                IProxy remote = session.Remote;
                ErrorClose(e);
                object[] container = (object[])ar.AsyncState;\n                AsyncSession session = (AsyncSession)container[0];\n                int bytesShouldSend = (int)container[1];\n                int bytesSent = _connection.EndSend(ar);\n                int bytesRemaining = bytesShouldSend - bytesSent;
        private MenuItem SeperatorItem3;
        private MenuItem SeperatorItem4;
        private MenuItem SeperatorItem2;
            this.PACModeItem = CreateMenuItem(0, "PAC", new System.EventHandler(this.PACModeItem_Click));\n            this.globalModeItem = CreateMenuItem(1, "Global", new System.EventHandler(this.GlobalModeItem_Click));\n            this.SeperatorItem = CreateSeperatorItem(0);\n            this.ConfigItem = CreateMenuItem(1, "Edit Servers...", new System.EventHandler(this.Config_Click));\n            this.enableItem = CreateMenuItem(0, "Enable", new System.EventHandler(this.EnableItem_Click));\n            this.modeItem = CreateMenuGroup(1, "Mode", new System.Windows.Forms.MenuItem[] {\n            this.PACModeItem,\n            this.globalModeItem});\n            this.ServersItem = CreateMenuGroup(2, "Servers", new System.Windows.Forms.MenuItem[] {\n            this.SeperatorItem,\n            this.ConfigItem});\n            this.SeperatorItem2 = CreateSeperatorItem(3);\n            this.AutoStartupItem = CreateMenuItem(4, "Start on Boot", new System.EventHandler(this.AutoStartupItem_Click));\n            this.ShareOverLANItem = CreateMenuItem(5, "Share over LAN", new System.EventHandler(this.ShareOverLANItem_Click));\n            this.editPACFileItem = CreateMenuItem(6, "Edit PAC File...", new System.EventHandler(this.EditPACFileItem_Click));\n            this.SeperatorItem3 = CreateSeperatorItem(7);\n            this.QRCodeItem = CreateMenuItem(8, "Show QRCode...", new System.EventHandler(this.QRCodeItem_Click));\n            this.ShowLogItem = CreateMenuItem(9, "Show Logs...", new System.EventHandler(this.ShowLogItem_Click));\n            this.aboutItem = CreateMenuItem(10, "About...", new System.EventHandler(this.Config_Click));\n            this.SeperatorItem4 = CreateSeperatorItem(11);\n            this.quitItem = CreateMenuItem(12, "Quit", new System.EventHandler(this.Quit_Click));
            this.SeperatorItem2,
            this.SeperatorItem3,
            this.SeperatorItem4,

            IPEndPoint remoteEndPoint = (IPEndPoint)udpState.remoteEndPoint;\n            UDPHandler handler = _cache.get(remoteEndPoint);\n            if (handler == null)\n            {\n                handler = new UDPHandler(socket, _config.GetCurrentServer(), remoteEndPoint);\n                _cache.add(remoteEndPoint, handler);\n            }
        public class UDPHandler
            _modifiedProxyConfig = controller.GetConfigurationCopy().proxy;\n            UseProxyCheckBox.Checked = _modifiedProxyConfig.useProxy;\n            ProxyServerTextBox.Text = _modifiedProxyConfig.proxyServer;\n            ProxyPortTextBox.Text = _modifiedProxyConfig.proxyPort.ToString();\n            ProxyTimeoutTextBox.Text = _modifiedProxyConfig.proxyTimeout.ToString();\n            ProxyTypeComboBox.SelectedIndex = _modifiedProxyConfig.proxyType;
            if (_modifiedProxyConfig.useProxy=UseProxyCheckBox.Checked)
                if (!int.TryParse(ProxyPortTextBox.Text, out _modifiedProxyConfig.proxyPort))
                if (!int.TryParse(ProxyTimeoutTextBox.Text, out _modifiedProxyConfig.proxyTimeout))
                _modifiedProxyConfig.proxyType = ProxyTypeComboBox.SelectedIndex;
                    Configuration.CheckServer(_modifiedProxyConfig.proxyServer = ProxyServerTextBox.Text);\n                    Configuration.CheckPort(_modifiedProxyConfig.proxyPort);\n                    Configuration.CheckTimeout(_modifiedProxyConfig.proxyTimeout, ProxyConfig.MaxProxyTimeoutSec);

            controller.SaveProxy(_modifiedProxyConfig);
                ProxyServerTextBox.Enabled = \n                ProxyPortTextBox.Enabled = \n                ProxyTimeoutTextBox.Enabled = 
                ProxyServerTextBox.Enabled =\n                ProxyPortTextBox.Enabled =\n                ProxyTimeoutTextBox.Enabled =\n                ProxyTypeComboBox.Enabled = false; 
        public int RunningPort => _runningPort;

                // TCP stack please do me a favor\n                TcpListener l = new TcpListener(IPAddress.Loopback, 0);\n                l.Start();\n                var port = ((IPEndPoint)l.LocalEndpoint).Port;\n                l.Stop();\n                return port;

                    using (var sr = new StringReader(local))
                        string rule;\n                        while ((rule = sr.ReadLine()) != null)\n                        {\n                            if (rule == "" || rule[0] == '!' || rule[0] == '[')\n                                continue;\n                            lines.Add(rule);\n                        }
            List<string> valid_lines = new List<string>();\n            using (var sr = new StringReader(content))
                string line;\n                while ((line = sr.ReadLine()) != null)\n                {\n                    if (line == "" || line[0] == '!' || line[0] == '[')\n                        continue;\n                    valid_lines.Add(line);\n                }
﻿using System;



        public int BestLeft
            get
        [JsonIgnore]\n        public int BestTop
            get
                int height = Height;\n                height = (height >= 200) ? height : 200; // set up the minimum size\n                return Screen.PrimaryScreen.WorkingArea.Height - height;
        #endregion
                    controller.EnableProxy(type, proxy, port);
﻿using System;
            this.tableLayoutPanel1.Controls.Add(this.tableLayoutPanel3, 0, 3);
            this.tableLayoutPanel1.Controls.Add(this.tableLayoutPanel2, 0, 2);\n            this.tableLayoutPanel1.Controls.Add(this.tableLayoutPanel4, 0, 1);
            this.tableLayoutPanel1.RowCount = 4;\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.Size = new System.Drawing.Size(395, 123);
            _remote.BeginSend(buffer, offset, size, socketFlags, callback, state);
            _remote.BeginReceive(buffer, offset, size, socketFlags, callback, state);
            _remote.Shutdown(how);
            _remote.Dispose();
        public void EnableProxy(int type, string proxy, int port)
        const string TARGET_MIN_LEVEL_ATTRIBUTE = "minlevel";\n        const string LOGGER_FILE_NAME_ATTRIBUTE = "fileName";

            logLevelElement.SetAttribute(TARGET_MIN_LEVEL_ATTRIBUTE, logLevel.ToString("G"));
﻿using System;





        public Encryptor(string method, string password)
            if (method != null && method.ToLowerInvariant().Equals("rc4")) {\n                Console.WriteLine("init rc4");\n                this.method = TYPE_RC4;\n                rc4 = new RC4();\n                encryptTable = rc4.EncryptInitalize(hash);\n                decryptTable = rc4.EncryptInitalize(hash);\n            } else {\n                Console.WriteLine("init table");\n                this.method = TYPE_TABLE;\n                // TODO endian\n                var a = BitConverter.ToUInt64(hash, 0);\n                for (int i = 0; i < 256; i++)\n                {\n                    encryptTable[i] = (byte)i;\n                }\n                for (int i = 1; i < 1024; i++)\n                {\n                    encryptTable = mergeSort(encryptTable, a, i);\n                }\n                for (int i = 0; i < 256; i++)\n                {\n                    decryptTable[encryptTable[i]] = (byte)i;\n                }
            switch (method)
                case TYPE_TABLE:\n                    for (int i = 0; i < length; i++)\n                        buf[i] = encryptTable[buf[i]];\n                    break;\n                case TYPE_RC4:\n                    rc4.Encrypt(encryptTable, buf, length);\n                    break;
            switch (method)
                case TYPE_TABLE:\n                    for (int i = 0; i < length; i++)\n                        buf[i] = decryptTable[buf[i]];\n                    break;\n                case TYPE_RC4:\n                    rc4.Decrypt(decryptTable, buf, length);\n                    break;
using System.Net;
using System.Timers;\nusing Shadowsocks.Controller.Strategy;

        public ISet<TCPHandler> Handlers
            _controller = controller;\n            Handlers = new HashSet<TCPHandler>();\n            _lastSweepTime = DateTime.Now;
            TCPHandler handler = new TCPHandler(this);
            IList<TCPHandler> handlersToClose = new List<TCPHandler>();\n            lock (Handlers)\n            {\n                Handlers.Add(handler);
                    foreach (TCPHandler handler1 in Handlers)
            foreach (TCPHandler handler1 in handlersToClose)
    class TCPHandler
            encryptor = EncryptorFactory.GetEncryptor(server.method, server.password, server.auth, false);
            _firstPacket = firstPacket;\n            _firstPacketLength = length;\n            HandshakeReceive();\n            lastActivity = DateTime.Now;
                Close();


                    Close();\n                }\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();

                    Logging.Debug("failed to recv data in Shadowsocks.Controller.TCPHandler.handshakeReceive2Callback()");\n                    Close();\n                }\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();
                    Logging.Debug(remote, RecvSize, "TCP Relay");\n                    connection.BeginReceive(connetionRecvBuffer, 0, RecvSize, 0, new AsyncCallback(ReadAll), null);
                        Logging.Debug(remote, RecvSize, "TCP Relay");\n                        connection.BeginReceive(connetionRecvBuffer, 0, RecvSize, 0, new AsyncCallback(ReadAll), null);
                        Close();\n                    }\n                }\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();
            if (retryCount < maxRetry)\n            {\n                Logging.Debug($"Connection failed, retry ({retryCount})");
                Close();
                    lastActivity = DateTime.Now;
                    Logging.Debug(remote, bytesToSend, "TCP Relay", "@PipeRemoteReceiveCallback() (download)");
                        strategy.UpdateLastRead(server);
                    //if (totalRead == 0)\n                    //{\n                    //    // closed before anything received, reports as failure\n                    //    // disable this feature\n                    //    controller.GetCurrentStrategy().SetFailure(this.server);\n                    //}\n                }\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();
                    Logging.Debug(remote, bytesToSend, "TCP Relay", "@PipeConnectionReceiveCallback() (upload)");
                        strategy.UpdateLastWrite(server);
﻿using System;
using Shadowsocks.Model;
﻿using System;

using Shadowsocks.Model;\nusing Shadowsocks.Properties;

using System.Net;\nusing System.Net.Sockets;\nusing System.Runtime.CompilerServices;\nusing Shadowsocks.Controller.Strategy;








                Interlocked.Add(ref _inbound, delta);
                Interlocked.Add(ref _outbound, delta);
                var i = Interlocked.Read(ref _inbound);\n                var il = Interlocked.Exchange(ref _lastInbound, i);\n                inboundDelta = i - il;\n                var o = Interlocked.Read(ref _outbound);\n                var ol = Interlocked.Exchange(ref _lastOutbound, o);\n                outboundDelta = o - ol;
        EndPoint DestEndPoint { get; }
        void BeginConnectDest(EndPoint destEndPoint, AsyncCallback callback, object state);
        public void BeginConnectDest(EndPoint destEndPoint, AsyncCallback callback, object state)\n        {\n            DestEndPoint = destEndPoint;
            int port;\n            var dep = destEndPoint as DnsEndPoint;\n            if (dep != null)\n            {\n                // is a domain name, we will leave it to server\n                atyp = 3; // DOMAINNAME\n                var enc = Encoding.UTF8;\n                var hostByteCount = enc.GetByteCount(dep.Host);\n                request = new byte[4 + 1/*length byte*/ + hostByteCount + 2];\n                request[4] = (byte)hostByteCount;\n                enc.GetBytes(dep.Host, 0, dep.Host.Length, request, 5);\n                port = dep.Port;\n            }\n            else\n            {\n                switch (DestEndPoint.AddressFamily)
                port = ((IPEndPoint) DestEndPoint).Port;\n                var addr = ((IPEndPoint)DestEndPoint).Address.GetAddressBytes();

        public EndPoint DestEndPoint { get; private set; }
        public void BeginConnectDest(EndPoint destEndPoint, AsyncCallback callback, object state)
            EndPoint realEndPoint = DestEndPoint = destEndPoint;\n            /*\n             * On windows vista or later, dual-mode socket is supported, so that\n             * we don't need to resolve a DnsEndPoint manually.\n             * We could just create a dual-mode socket and pass the DnsEndPoint\n             * directly to it's BeginConnect and the system will handle it correctlly\n             * so that we won't worry about async resolving any more.\n             * \n             * see: https://blogs.msdn.microsoft.com/webdev/2013/01/08/dual-mode-sockets-never-create-an-ipv4-socket-again/\n             * \n             * But it seems that we can't use this feature because DnsEndPoint\n             * doesn't have a specific AddressFamily before it has been\n             * resolved (we don't know whether it's ipv4 or ipv6) and we don't have\n             * a dual-mode socket to use on windows xp :(\n             */\n            var dep = realEndPoint as DnsEndPoint;\n            if (dep != null)
                // need to resolve manually\n                // TODO async resolving\n                IPHostEntry ipHostInfo = Dns.GetHostEntry(dep.Host);\n                IPAddress ipAddress = ipHostInfo.AddressList[0];\n                realEndPoint = new IPEndPoint(ipAddress, dep.Port);

                _remote = new Socket(realEndPoint.AddressFamily, SocketType.Stream, ProtocolType.Tcp);
            _remote.BeginConnect(realEndPoint, callback, state);
        public LogForm(ShadowsocksController controller)

using Shadowsocks.Encryption.Exception;\nnamespace Shadowsocks.Encryption.Stream
    public class StreamSodiumEncryptor\n        : StreamEncryptor, IDisposable
        protected override void cipherUpdate(bool isEncrypt, int length, byte[] buf, byte[] outbuf)
            int ret = -1;\n            if (isEncrypt)
                    ret = Sodium.crypto_stream_salsa20_xor_ic(sodiumBuf, sodiumBuf, (ulong)(padding + length), iv, ic, _key);
                    ret = Sodium.crypto_stream_chacha20_xor_ic(sodiumBuf, sodiumBuf, (ulong)(padding + length), iv, ic, _key);
                    ret = Sodium.crypto_stream_chacha20_ietf_xor_ic(sodiumBuf, sodiumBuf, (ulong)(padding + length), iv, (uint)ic, _key);
            if (isEncrypt)
﻿namespace Shadowsocks.Encryption
    public class EncryptorInfo
        public const int MAX_DOMAIN_LEN = 255;\n        public const int ADDR_PORT_LEN = 2;\n        public const int ADDR_ATYP_LEN = 1;\n        public const int ATYP_IPv4 = 0x01;\n        public const int ATYP_DOMAIN = 0x03;\n        public const int ATYP_IPv6 = 0x04;\n        protected EncryptorBase(string method, string password)


    public static class Sodium
        private const string DLLNAME = "libsscrypto.dll";\n        private static bool _initialized = false;\n        private static readonly object _initLock = new object();
            string dllPath = Utils.GetTempPath(DLLNAME);
            catch (System.Exception e)
        private static extern int sodium_init();\n        #region AEAD
        public static extern int sodium_increment(byte[] n, int nlen);
        public static extern int crypto_aead_chacha20poly1305_ietf_encrypt(byte[] c, ref ulong clen_p, byte[] m,\n            ulong mlen, byte[] ad, ulong adlen, byte[] nsec, byte[] npub, byte[] k);
        public static extern int crypto_aead_chacha20poly1305_ietf_decrypt(byte[] m, ref ulong mlen_p,\n            byte[] nsec, byte[] c, ulong clen, byte[] ad, ulong adlen, byte[] npub, byte[] k);\n        #endregion\n        #region Stream\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public static extern int crypto_stream_salsa20_xor_ic(byte[] c, byte[] m, ulong mlen, byte[] n, ulong ic,\n            byte[] k);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public static extern int crypto_stream_chacha20_xor_ic(byte[] c, byte[] m, ulong mlen, byte[] n, ulong ic,\n            byte[] k);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public static extern int crypto_stream_chacha20_ietf_xor_ic(byte[] c, byte[] m, ulong mlen, byte[] n, uint ic,\n            byte[] k);\n        #endregion
            GetBytes(buf, buf.Length);
            catch (System.Exception)
        // TODO: choose a smart number\n        private LRUCache<IPEndPoint, UDPHandler> _cache = new LRUCache<IPEndPoint, UDPHandler>(512);

                IEncryptor encryptor = EncryptorFactory.GetEncryptor(_server.method, _server.password);\n                byte[] dataIn = new byte[length - 3];
                byte[] dataOut = new byte[length - 3 + 16];
                encryptor.EncryptUDP(dataIn, length - 3, dataOut, out outlen);
        // each recv size.\n        public const int RecvSize = 2048;\n        // overhead of one chunk, reserved for AEAD ciphers\n        public const int ChunkOverheadSize = 16 * 2 /* two tags */ + AEADEncryptor.CHUNK_LEN_BYTES;\n        // max chunk size\n        public const uint MaxChunkSize = AEADEncryptor.CHUNK_LEN_MASK + AEADEncryptor.CHUNK_LEN_BYTES + 16 * 2;\n        // In general, the ciphertext length, we should take overhead into account\n        public const int BufferSize = RecvSize + (int)MaxChunkSize + 32 /* max salt len */;
        private bool _proxyConnected;\n        private bool _destConnected;\n        private byte _command;\n        private byte[] _firstPacket;\n        private int _firstPacketLength;\n        private const int CMD_CONNECT = 0x01;\n        private const int CMD_UDP_ASSOC = 0x03;\n        private int _addrBufLength = -1;\n        private int _totalRead = 0;\n        private int _totalWrite = 0;\n        // remote -> local proxy (ciphertext, before decrypt)\n        private byte[] _remoteRecvBuffer = new byte[BufferSize];\n        // client -> local proxy (plaintext, before encrypt)\n        private byte[] _connetionRecvBuffer = new byte[BufferSize];\n        // local proxy -> remote (plaintext, after decrypt)\n        private byte[] _remoteSendBuffer = new byte[BufferSize];\n        // local proxy -> client (ciphertext, before decrypt)\n        private byte[] _connetionSendBuffer = new byte[BufferSize];\n        private bool _connectionShutdown = false;\n        private bool _remoteShutdown = false;\n        private bool _closed = false;
            _encryptor = EncryptorFactory.GetEncryptor(server.method, server.password);
                _connection.BeginReceive(_connetionRecvBuffer, 0, 3 + ADDR_ATYP_LEN + 1, SocketFlags.None,\n                    HandshakeReceive2Callback, null);\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void HandshakeReceive2Callback(IAsyncResult ar)
                    if (_command != CMD_CONNECT && _command != CMD_UDP_ASSOC)
                        if (_command == CMD_CONNECT)
                                ResponseCallback, null);
                        else if (_command == CMD_UDP_ASSOC)
                case ATYP_IPv4: // IPv4 address, 4 bytes\n                    ReadAddress(4 + ADDR_PORT_LEN - 1, onSuccess);
                case ATYP_DOMAIN: // domain name, length + str
                    ReadAddress(len + ADDR_PORT_LEN, onSuccess);
                case ATYP_IPv6: // IPv6 address, 16 bytes\n                    ReadAddress(16 + ADDR_PORT_LEN - 1, onSuccess);
            // drop [ VER | CMD |  RSV  ]\n            Array.Copy(_connetionRecvBuffer, 3, _connetionRecvBuffer, 0, ADDR_ATYP_LEN + 1);
                        case ATYP_IPv4: // IPv4 address, 4 bytes\n                            dstAddr = new IPAddress(_connetionRecvBuffer.Skip(1).Take(4).ToArray()).ToString();\n                            dstPort = (_connetionRecvBuffer[5] << 8) + _connetionRecvBuffer[6];\n                            _addrBufLength = ADDR_ATYP_LEN + 4 + ADDR_PORT_LEN;
                        case ATYP_DOMAIN: // domain name, length + str
                            dstAddr = System.Text.Encoding.UTF8.GetString(_connetionRecvBuffer, 2, len);\n                            dstPort = (_connetionRecvBuffer[len + 2] << 8) + _connetionRecvBuffer[len + 3];\n                            _addrBufLength = ADDR_ATYP_LEN + 1 + len + ADDR_PORT_LEN;
                        case ATYP_IPv6: // IPv6 address, 16 bytes\n                            dstAddr = $"[{new IPAddress(_connetionRecvBuffer.Skip(1).Take(16).ToArray())}]";\n                            dstPort = (_connetionRecvBuffer[17] << 8) + _connetionRecvBuffer[18];\n                            _addrBufLength = ADDR_ATYP_LEN + 16 + ADDR_PORT_LEN;
            byte[] response = new byte[4 + address.Length + ADDR_PORT_LEN];
                    response[3] = ATYP_IPv4;
                    response[3] = ATYP_IPv6;
            _connection.BeginSend(response, 0, response.Length, SocketFlags.None, ReadAll, true);
                    _connection.BeginReceive(_connetionRecvBuffer, 0, RecvSize, SocketFlags.None,\n                        ReadAll, null);
                        _connection.BeginReceive(_connetionRecvBuffer, 0, RecvSize, SocketFlags.None,\n                            ReadAll, null);
                EndPoint proxyEP = null;
                ProxyTimer proxyTimer = new ProxyTimer(_proxyTimeout) { AutoReset = false };\n                proxyTimer.Elapsed += ProxyConnectTimer_Elapsed;
                remote.BeginConnectProxy(proxyEP, ProxyConnectCallback,\n                    new AsyncSession<ProxyTimer>(remote, proxyTimer));\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void ProxyConnectTimer_Elapsed(object sender, ElapsedEventArgs e)\n        {\n            var timer = (ProxyTimer)sender;\n            timer.Elapsed -= ProxyConnectTimer_Elapsed;

                var server = timer.Server;\n                timer.Elapsed -= ProxyConnectTimer_Elapsed;
                ServerTimer connectTimer = new ServerTimer(_serverTimeout) { AutoReset = false };\n                connectTimer.Elapsed += DestConnectTimer_Elapsed;
                remote.BeginConnectDest(destEndPoint, ConnectCallback,\n                    new AsyncSession<ServerTimer>(session, connectTimer));
                    int bytesToSend = -1;
                        try\n                        {\n                            _encryptor.Decrypt(_remoteRecvBuffer, bytesRead, _remoteSendBuffer, out bytesToSend);\n                        }\n                        catch (CryptoErrorException)\n                        {\n                            Logging.Error("decryption error");\n                            Close();\n                            return;\n                        }\n                    }\n                    if (bytesToSend == 0)\n                    {\n                        // need more to decrypt\n                        Logging.Debug("Need more to decrypt");\n                        session.Remote.BeginReceive(_remoteRecvBuffer, 0, RecvSize, SocketFlags.None,\n                            PipeRemoteReceiveCallback, session);\n                        return;\n                    }\n                    Logging.Debug($"start sending {bytesToSend}");\n                    _connection.BeginSend(_remoteSendBuffer, 0, bytesToSend, SocketFlags.None,\n                        PipeConnectionSendCallback, new object[] { session, bytesToSend });
                try\n                {\n                    _encryptor.Encrypt(_connetionRecvBuffer, length, _connetionSendBuffer, out bytesToSend);\n                }\n                catch (CryptoErrorException)\n                {\n                    Logging.Debug("encryption error");\n                    Close();\n                    return;\n                }
            session.Remote.BeginSend(_connetionSendBuffer, 0, bytesToSend, SocketFlags.None,\n                PipeRemoteSendCallback, new object[] { session, bytesToSend });
                var container = (object[])ar.AsyncState;\n                var session = (AsyncSession)container[0];\n                var bytesShouldSend = (int)container[1];\n                int bytesSent = session.Remote.EndSend(ar);\n                int bytesRemaining = bytesShouldSend - bytesSent;\n                if (bytesRemaining > 0)\n                {\n                    Logging.Info("reconstruct _connetionSendBuffer to re-send");\n                    Buffer.BlockCopy(_connetionSendBuffer, bytesSent, _connetionSendBuffer, 0, bytesRemaining);\n                    session.Remote.BeginSend(_connetionSendBuffer, 0, bytesRemaining, SocketFlags.None,\n                        PipeRemoteSendCallback, new object[] { session, bytesRemaining });\n                    return;\n                }\n                _connection.BeginReceive(_connetionRecvBuffer, 0, RecvSize, SocketFlags.None,\n                    PipeConnectionReceiveCallback, session);\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }\n        // In general, we assume there is no delay between local proxy and client, add this for sanity
                var container = (object[])ar.AsyncState;\n                var session = (AsyncSession)container[0];\n                var bytesShouldSend = (int)container[1];\n                var bytesSent = _connection.EndSend(ar);\n                var bytesRemaining = bytesShouldSend - bytesSent;\n                if (bytesRemaining > 0)\n                {\n                    Logging.Info("reconstruct _remoteSendBuffer to re-send");\n                    Buffer.BlockCopy(_remoteSendBuffer, bytesSent, _remoteSendBuffer, 0, bytesRemaining);\n                    _connection.BeginSend(_remoteSendBuffer, 0, bytesRemaining, SocketFlags.None,\n                        PipeConnectionSendCallback, new object[] { session, bytesRemaining });\n                    return;\n                }\n                session.Remote.BeginReceive(_remoteRecvBuffer, 0, RecvSize, SocketFlags.None,\n                    PipeRemoteReceiveCallback, session);
using Shadowsocks.Encryption.Exception;\nnamespace Shadowsocks.Encryption.Stream
    public class StreamMbedTLSEncryptor\n        : StreamEncryptor, IDisposable
        public StreamMbedTLSEncryptor(string method, string password)\n            : base(method, password)
            base.initCipher(iv, isEncrypt);
                isEncrypt ? MbedTLS.MBEDTLS_ENCRYPT : MbedTLS.MBEDTLS_DECRYPT) != 0 )\n                throw new System.Exception("Cannot set mbed TLS cipher key");
                throw new System.Exception("Cannot set mbed TLS cipher IV");
                throw new System.Exception("Cannot finalize mbed TLS cipher context");
        protected override void cipherUpdate(bool isEncrypt, int length, byte[] buf, byte[] outbuf)
            if (MbedTLS.cipher_update(isEncrypt ? _encryptCtx : _decryptCtx,
                throw new CryptoErrorException();
        ~StreamMbedTLSEncryptor()
        private static Dictionary<string, Type> _registeredEncryptors = new Dictionary<string, Type>();\n        private static readonly Type[] ConstructorTypes = {typeof(string), typeof(string)};
            foreach (string method in StreamMbedTLSEncryptor.SupportedCiphers())
                _registeredEncryptors.Add(method, typeof(StreamMbedTLSEncryptor));
            foreach (string method in StreamSodiumEncryptor.SupportedCiphers())
                _registeredEncryptors.Add(method, typeof(StreamSodiumEncryptor));\n            }\n            foreach (string method in AEADMbedTLSEncryptor.SupportedCiphers())\n            {\n                _registeredEncryptors.Add(method, typeof(AEADMbedTLSEncryptor));\n            }\n            foreach (string method in AEADSodiumEncryptor.SupportedCiphers())\n            {\n                _registeredEncryptors.Add(method, typeof(AEADSodiumEncryptor));
        public static IEncryptor GetEncryptor(string method, string password)
            ConstructorInfo c = t.GetConstructor(ConstructorTypes);\n            if (c == null) throw new System.Exception("Invalid ctor");\n            IEncryptor result = (IEncryptor) c.Invoke(new object[] {method, password});
    public static class MbedTLS
        private const string DLLNAME = "libsscrypto.dll";
            string dllPath = Utils.GetTempPath(DLLNAME);
            catch (System.Exception e)
        public static extern int cipher_auth_encrypt(IntPtr ctx,\n            byte[] iv, uint iv_len,\n            IntPtr ad, uint ad_len,\n            byte[] input, uint ilen,\n            byte[] output, ref uint olen,\n            byte[] tag, uint tag_len);
        public static extern int cipher_auth_decrypt(IntPtr ctx,\n            byte[] iv, uint iv_len,\n            IntPtr ad, uint ad_len,\n            byte[] input, uint ilen,\n            byte[] output, ref uint olen,\n            byte[] tag, uint tag_len);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public static extern int hkdf(byte[] salt,\n            int salt_len, byte[] ikm, int ikm_len,\n            byte[] info, int info_len, byte[] okm,\n            int okm_len);\n        #endregion
            if (_currentServer == null)\n            {\n                return null;\n            }\n            return _currentServer.server;
            ServerStatus oldServer = _currentServer;
                if (_currentServer == null || max.score - _currentServer.score > 200)
                    _currentServer = max;\n                    Console.WriteLine("HA switching to server: {0}", _currentServer.server.FriendlyName());


                        new KeyValuePair<string, string>("OutboundSpeed", GetRecentOutboundSpeed(server))

                    Append(dataList, Enumerable.Empty<DataUnit>());






                            PolarSSL.aes_crypt_cfb128(_encryptCtx, PolarSSL.AES_ENCRYPT, length, ref _encryptIVOffset, _encryptIV, buf, tempbuf);
                            PolarSSL.blowfish_crypt_cfb64(_encryptCtx, PolarSSL.BLOWFISH_ENCRYPT, length, ref _encryptIVOffset, _encryptIV, buf, tempbuf);
                        PolarSSL.aes_crypt_cfb128(_encryptCtx, PolarSSL.AES_ENCRYPT, length, ref _encryptIVOffset, _encryptIV, buf, outbuf);
                        PolarSSL.blowfish_crypt_cfb64(_encryptCtx, PolarSSL.BLOWFISH_ENCRYPT, length, ref _encryptIVOffset, _encryptIV, buf, outbuf);
                            PolarSSL.aes_crypt_cfb128(_decryptCtx, PolarSSL.AES_DECRYPT, length - ivLen, ref _decryptIVOffset, _decryptIV, tempbuf, outbuf);
                            PolarSSL.blowfish_crypt_cfb64(_decryptCtx, PolarSSL.BLOWFISH_DECRYPT, length - ivLen, ref _decryptIVOffset, _decryptIV, tempbuf, outbuf);
                        PolarSSL.aes_crypt_cfb128(_decryptCtx, PolarSSL.AES_DECRYPT, length, ref _decryptIVOffset, _decryptIV, buf, outbuf);
                        PolarSSL.blowfish_crypt_cfb64(_decryptCtx, PolarSSL.BLOWFISH_DECRYPT, length, ref _decryptIVOffset, _decryptIV, buf, outbuf);
            this.MyCancelButton.Margin = new System.Windows.Forms.Padding(3, 3, 3, 0);




                IEncryptor encryptor = EncryptorFactory.GetEncryptor(_server.method, _server.password, _server.one_time_auth, true);
                encryptor.Encrypt(dataIn, length - 3, dataOut, out outlen);
        protected void reactBuffer4TCP(byte[] buf, ref int length)
                int headLen = getHeadLen(buf, length);\n                int dataLen = length - headLen;\n                buf[0] |= ONETIMEAUTH_FLAG;\n                byte[] hash = genOnetimeAuthHash(buf, headLen);\n                Buffer.BlockCopy(buf, headLen, buf, headLen + ONETIMEAUTH_BYTES + AUTH_BYTES, dataLen);\n                Buffer.BlockCopy(hash, 0, buf, headLen, ONETIMEAUTH_BYTES);\n                hash = genHash(buf, headLen + ONETIMEAUTH_BYTES + AUTH_BYTES, dataLen);\n                Buffer.BlockCopy(hash, 0, buf, headLen + ONETIMEAUTH_BYTES + CLEN_BYTES, ONETIMEAUTH_BYTES);\n                byte[] lenBytes = BitConverter.GetBytes((ushort)IPAddress.HostToNetworkOrder((short)dataLen));\n                Buffer.BlockCopy(lenBytes, 0, buf, headLen + ONETIMEAUTH_BYTES, CLEN_BYTES);\n                length = headLen + ONETIMEAUTH_BYTES + AUTH_BYTES + dataLen;\n            }\n            else\n            {\n                byte[] hash = genHash(buf, 0, length);\n                Buffer.BlockCopy(buf, 0, buf, AUTH_BYTES, length);\n                byte[] lenBytes = BitConverter.GetBytes((ushort)IPAddress.HostToNetworkOrder((short)length));\n                Buffer.BlockCopy(lenBytes, 0, buf, 0, CLEN_BYTES);\n                Buffer.BlockCopy(hash, 0, buf, CLEN_BYTES, ONETIMEAUTH_BYTES);\n                length += AUTH_BYTES;\n            }\n        }\n        protected void reactBuffer4UDP(byte[] buf, ref int length)\n        {\n            buf[0] |= ONETIMEAUTH_FLAG;\n            byte[] hash = genOnetimeAuthHash(buf, length);\n            Buffer.BlockCopy(hash, 0, buf, length, ONETIMEAUTH_BYTES);\n            length += ONETIMEAUTH_BYTES;\n        }\n        protected void reactBuffer(byte[] buf, ref int length)\n        {\n            if (OnetimeAuth && ivLen > 0)\n            {\n                if (!IsUDP)\n                {\n                    reactBuffer4TCP(buf, ref length);\n                }\n                else\n                {\n                    reactBuffer4UDP(buf, ref length);\n                }\n            }\n        }\n        public override void Encrypt(byte[] buf, int length, byte[] outbuf, out int outlength)\n        {\n            if (!_encryptIVSent)\n            {
                reactBuffer(buf, ref length);\n                _encryptIVSent = true;
                reactBuffer(buf, ref length);
        protected EncryptorBase(string method, string password, bool onetimeauth, bool isudp)
        public abstract void Encrypt(byte[] buf, int length, byte[] outbuf, out int outlength);
        public static IEncryptor GetEncryptor(string method, string password, bool onetimeauth, bool isudp)
            IEncryptor result = (IEncryptor)c.Invoke(new object[] { method, password, onetimeauth, isudp });
            encryptor.Encrypt(plain, plain.Length, cipher, out outLen);
            encryptor.Encrypt(plain, 1000, cipher, out outLen);
            encryptor.Encrypt(plain, 12333, cipher, out outLen);


        private readonly ConcurrentDictionary<string, List<int>> _latencyRecords = new ConcurrentDictionary<string, List<int>>();
        private readonly ConcurrentDictionary<string, long> _inboundCounter = new ConcurrentDictionary<string, long>();\n        private readonly ConcurrentDictionary<string, long> _lastInboundCounter = new ConcurrentDictionary<string, long>();\n        private readonly ConcurrentDictionary<string, List<int>> _inboundSpeedRecords = new ConcurrentDictionary<string, List<int>>();\n        private readonly ConcurrentDictionary<string, long> _outboundCounter = new ConcurrentDictionary<string, long>();\n        private readonly ConcurrentDictionary<string, long> _lastOutboundCounter = new ConcurrentDictionary<string, long>();\n        private readonly ConcurrentDictionary<string, List<int>> _outboundSpeedRecords = new ConcurrentDictionary<string, List<int>>();
        //private Timer _writer; //write RawStatistics to file\n        //private readonly TimeSpan _writingInterval = TimeSpan.FromMinutes(1);



            _inboundSpeedRecords.Clear();\n            _outboundSpeedRecords.Clear();\n            _latencyRecords.Clear();
            var records = new Dictionary<string, StatisticsRecord>();\n            foreach (var server in _controller.GetCurrentConfiguration().configs)\n            {\n                var id = server.Identifier();\n                List<int> inboundSpeedRecords = null;\n                List<int> outboundSpeedRecords = null;\n                List<int> latencyRecords = null;\n                _inboundSpeedRecords.TryGetValue(id, out inboundSpeedRecords);\n                _outboundSpeedRecords.TryGetValue(id, out outboundSpeedRecords);\n                _latencyRecords.TryGetValue(id, out latencyRecords);\n                records.Add(id, new StatisticsRecord(id, inboundSpeedRecords, outboundSpeedRecords, latencyRecords));\n            }\n            if (Config.Ping)\n            {\n                var icmpResults = await TaskEx.WhenAll(_controller.GetCurrentConfiguration().configs.Select(ICMPTest));\n                foreach (var result in icmpResults.Where(result => result != null))\n                {\n                    records[result.Server.Identifier()].SetResponse(result.RoundtripTime);\n                }\n            }\n            foreach (var kv in records.Where(kv => !kv.Value.IsEmptyData()))\n            {\n                AppendRecord(kv.Key, kv.Value);\n            }\n        }\n        private void AppendRecord(string serverIdentifier, StatisticsRecord record)\n        {\n            List<StatisticsRecord> records;\n            if (!RawStatistics.TryGetValue(serverIdentifier, out records))\n            {\n                records = new List<StatisticsRecord>();\n            }\n            records.Add(record);\n            RawStatistics[serverIdentifier] = records;\n        }\n        private void Save()\n        {\n            if (RawStatistics.Count == 0)\n            {

                var content = JsonConvert.SerializeObject(RawStatistics, Formatting.None);\n                File.WriteAllText(AvailabilityStatisticsFile, content);


        public void UpdateLatency(Server server, TimeSpan latency)\n        {\n            if (_config.availabilityStatistics)\n            {\n                new Task(() => availabilityStatistics.UpdateLatency(server, (int) latency.TotalMilliseconds)).Start();\n            }\n        }\n        public void UpdateInboundCounter(Server server, long n)
            if (_config.availabilityStatistics)\n            {\n                new Task(() => availabilityStatistics.UpdateInboundCounter(server, n)).Start();\n            }\n        }\n        public void UpdateOutboundCounter(Server server, long n)
        public string ServerIdentifier { get; set; }
        public StatisticsRecord(string identifier, ICollection<int> inboundSpeedRecords, ICollection<int> outboundSpeedRecords, ICollection<int> latencyRecords)
            ServerIdentifier = identifier;
            ServerIdentifier = identifier;\n            SetResponse(responseRecords);
        public void SetResponse(ICollection<int?> responseRecords)
            PackageLoss = responseRecords.Count(response => response != null)/(float) responseRecords.Count;
        private float? GetScore(string identifier, List<StatisticsRecord> records)
            float? score = null;\n            var averageRecord = new StatisticsRecord(identifier,\n                records.Where(record => record.MaxInboundSpeed != null).Select(record => record.MaxInboundSpeed.Value).ToList(),\n                records.Where(record => record.MaxOutboundSpeed != null).Select(record => record.MaxOutboundSpeed.Value).ToList(),\n                records.Where(record => record.AverageLatency != null).Select(record => record.AverageLatency.Value).ToList());\n            averageRecord.SetResponse(records.Select(record => record.AverageResponse).ToList());\n            foreach (var calculation in config.Calculations)\n            {\n                var name = calculation.Key;\n                var field = typeof (StatisticsRecord).GetField(name);\n                dynamic value = field.GetValue(averageRecord);\n                var factor = calculation.Value;\n                if (value == null || factor.Equals(0)) continue;\n                score = score ?? 0;\n                score += value * factor;\n            }\n            if (score != null)\n            {\n                Logging.Debug($"Highest score: {score} {JsonConvert.SerializeObject(averageRecord, Formatting.Indented)}");\n            }



                    foreach (var line in sr.NonWhiteSpaceLines())
                        if (line[0] == '#')
        private Config config;
        public Local(Config config)\n        {\n            this.config = config;\n            this.encryptor = new Encryptor(config.password);
            IPEndPoint localEndPoint = new IPEndPoint(0, config.local_port);
            IPHostEntry ipHostInfo = Dns.GetHostEntry(config.server);
            IPEndPoint remoteEP = new IPEndPoint(ipAddress, config.server_port);
        void controller_UpdatePACFromGeositeError(object sender, System.IO.ErrorEventArgs e)
        void controller_UpdatePACFromGeositeCompleted(object sender, GeositeResultEventArgs e)
            UpdatePACFromGeositeCompleted?.Invoke(this, e);
            UpdatePACFromGeositeError?.Invoke(this, e);
            try\n            {\n                RegistryKey registry =\n                    Registry.CurrentUser.OpenSubKey("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings",\n                        true);\n                registry.SetValue("ProxyEnable", 0);\n                registry.SetValue("ProxyServer", "");\n                registry.SetValue("AutoConfigURL", "http://127.0.0.1:8090/pac?t=" + GetTimestamp(DateTime.Now));\n                SystemProxy.NotifyIE();\n            }\n            catch (Exception)\n            {\n                MessageBox.Show("can not change registry!");\n                throw;\n            }
            try\n            {\n                RegistryKey registry =\n                    Registry.CurrentUser.OpenSubKey("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings",\n                        true);\n                registry.SetValue("ProxyEnable", 0);\n                registry.SetValue("ProxyServer", "");\n                registry.SetValue("AutoConfigURL", "");\n                SystemProxy.NotifyIE();\n            }\n            catch (Exception)\n            {\n                MessageBox.Show("can not change registry!");\n                throw;\n            }
            if (File.Exists(PACDaemon.PAC_FILE))
                string original = FileManager.NonExclusiveReadAllText(PACDaemon.PAC_FILE, Encoding.UTF8);
            File.WriteAllText(PACDaemon.PAC_FILE, abpContent, Encoding.UTF8);
            string pacFilename = _pacDaemon.TouchPACFile();
            string userRuleFilename = _pacDaemon.TouchUserRuleFile();
                _pacServer = new PACServer(_pacDaemon);\n            }\n            _pacServer.UpdatePACURL(_config);
        public const string RESOURCE_NAME = "pac";

        private PACDaemon _pacDaemon;\n        public PACServer(PACDaemon pacDaemon)
            _pacDaemon = pacDaemon;
        public void UpdatePACURL(Configuration config)
                if (lines.Length < 2)   // need at lease RequestLine + Host
                    return false;\n                }\n                // parse request line\n                string requestLine = lines[0];\n                // GET /pac?t=yyyyMMddHHmmssfff&secret=foobar HTTP/1.1\n                string[] requestItems = requestLine.Split(' ');\n                if (requestItems.Length == 3 && requestItems[0] == "GET")\n                {\n                    int index = requestItems[1].IndexOf('?');\n                    if (index < 0)\n                    {\n                        index = requestItems[1].Length;\n                    }\n                    string resourceString = requestItems[1].Substring(0, index).Remove(0, 1);\n                    if (string.Equals(resourceString, RESOURCE_NAME, StringComparison.OrdinalIgnoreCase))\n                    {\n                        pathMatch = true;\n                        if (!secretMatch)\n                        {\n                            string queryString = requestItems[1].Substring(index);\n                            if (queryString.Contains(PacSecret))\n                            {\n                                secretMatch = true;\n                            }\n                        }\n                    }\n                }\n                // parse request header\n                for (int i = 1; i < lines.Length; i++)\n                {\n                    if (string.IsNullOrEmpty(lines[i]))\n                        continue;\n                    string[] kv = lines[i].Split(new char[] { ':' }, 2);


                string pacContent = _pacDaemon.GetPACContent().Replace("__PROXY__", proxy);

        private Timer _perSecondTimer; //analyze and save cached records to RawStatistics and filter records

                    if (_perSecondTimer == null)\n                    {\n                        _perSecondTimer = new Timer(OperationsPerSecond, new Counter(), _delayBeforeStart, TimeSpan.FromSeconds(1));\n                    }
                    _perSecondTimer?.Dispose();
        private void OperationsPerSecond(object state)\n        {\n            lock(state)\n            {\n                var counter = state as Counter;\n                if (counter.count % _monitorInterval.TotalSeconds == 0)\n                {\n                    UpdateSpeed();\n                }\n                if (counter.count % RecordingInterval.TotalSeconds == 0)\n                {\n                    Run();\n                }\n                counter.count++;\n            }\n        }\n        private void UpdateSpeed()
        private void Run()
            int serverCount = _controller.GetCurrentConfiguration().configs.Count;\n            state.counter = serverCount;\n            bool isPing = Config.Ping;\n            for (int i = 0; i < serverCount; i++)\n            {\n                try\n                {\n                    var server = _controller.GetCurrentConfiguration().configs[i];\n                    var id = server.Identifier();\n                    List<int> inboundSpeedRecords = null;\n                    List<int> outboundSpeedRecords = null;\n                    List<int> latencyRecords = null;\n                    _inboundSpeedRecords.TryGetValue(id, out inboundSpeedRecords);\n                    _outboundSpeedRecords.TryGetValue(id, out outboundSpeedRecords);\n                    _latencyRecords.TryGetValue(id, out latencyRecords);\n                    StatisticsRecord record = new StatisticsRecord(id, inboundSpeedRecords, outboundSpeedRecords, latencyRecords);\n                    /* duplicate server identifier */\n                    if (records.ContainsKey(id))\n                        records[id] = record;\n                    else\n                        records.Add(id, record);\n                    if (isPing)\n                    {\n                        // FIXME: on ping completed, every thing could be asynchrously changed.\n                        // focus on: Config/ RawStatistics\n                        MyPing ping = new MyPing(server, Repeat);\n                        ping.Completed += ping_Completed;\n                        ping.Start(new PingState { state = state, record = record });\n                    }\n                    else if (!record.IsEmptyData())\n                    {\n                        AppendRecord(id, record);\n                    }\n                }\n                catch (Exception e)\n                {\n                    Logging.Debug("config changed asynchrously, just ignore this server");\n                }\n            }\n            if (!isPing)
                var filteredStatistics = new Statistics();
                    filteredStatistics[server] = filteredRecords;\n                }\n                FilteredStatistics = filteredStatistics;
                Console.WriteLine($"failed to load statistics; use runtime statistics, some data may be lost");
            _perSecondTimer.Dispose();
        private string PacSecret\n        {\n            get\n            {\n                if (string.IsNullOrEmpty(_cachedPacSecret))\n                {\n                    var rd = new byte[32];\n                    RNG.GetBytes(rd);\n                    _cachedPacSecret = HttpServerUtility.UrlTokenEncode(rd);\n                }\n                return _cachedPacSecret;\n            }\n        }\n        private string _cachedPacSecret = "";
            _config = config;\n            string usedSecret = _config.secureLocalPac ? $"&secret={PacSecret}" : "";\n            string contentHash = GetHash(_pacDaemon.GetPACContent());\n            PacUrl = $"http://{config.localHost}:{config.localPort}/{RESOURCE_NAME}?hash={contentHash}{usedSecret}";\n            Logging.Debug("Set PAC URL:" + PacUrl);
                return HttpServerUtility.UrlTokenEncode(md5Bytes);
    public static class I18N
        private static Dictionary<string, string> _strings = new Dictionary<string, string>();\n        private static void Init(string res)
            string name = CultureInfo.CurrentCulture.EnglishName;\n            if (name.StartsWith("Chinese", StringComparison.OrdinalIgnoreCase))
                // choose Traditional Chinese only if we get explicit indication\n                Init(name.Contains("Traditional")\n                    ? Resources.zh_tw\n                    : Resources.cn);
            return _strings.ContainsKey(key)\n                ? _strings[key]\n                : key;
                //File.WriteAllText(I18N_FILE, i18n, Encoding.UTF8);
﻿using Shadowsocks.Controller;\nusing Shadowsocks.Model;\nusing Shadowsocks.Properties;\nusing Shadowsocks.Util;\nusing System;
using System.IO;\nusing System.Linq;\nusing System.Text;

                TCPRelay tcpRelay = new TCPRelay(_config);\n                UDPRelay udpRelay = new UDPRelay(_config);
                services.Add(tcpRelay);\n                services.Add(udpRelay);
            bool Handle(byte[] firstPacket, int length, Socket socket, object state);\n        }\n        public class UDPState\n        {\n            public byte[] buffer = new byte[4096];\n            public EndPoint remoteEndPoint = new IPEndPoint(IPAddress.Any, 0);
        Socket _tcpSocket;\n        Socket _udpSocket;
                _tcpSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);\n                _udpSocket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);\n                _tcpSocket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, true);\n                _udpSocket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, true);
                _tcpSocket.Bind(localEndPoint);\n                _udpSocket.Bind(localEndPoint);\n                _tcpSocket.Listen(1024);
                _tcpSocket.BeginAccept(
                    _tcpSocket);\n                UDPState udpState = new UDPState();\n                _udpSocket.BeginReceiveFrom(udpState.buffer, 0, udpState.buffer.Length, 0, ref udpState.remoteEndPoint, new AsyncCallback(RecvFromCallback), udpState);
                _tcpSocket.Close();
            if (_tcpSocket != null)
                _tcpSocket.Close();\n                _tcpSocket = null;\n            }\n            if (_udpSocket != null)\n            {\n                _udpSocket.Close();\n                _udpSocket = null;\n            }\n        }\n        public void RecvFromCallback(IAsyncResult ar)\n        {\n            UDPState state = (UDPState)ar.AsyncState;\n            try\n            {\n                int bytesRead = _udpSocket.EndReceiveFrom(ar, ref state.remoteEndPoint);\n                foreach (Service service in _services)\n                {\n                    if (service.Handle(state.buffer, bytesRead, _udpSocket, state))\n                    {\n                        break;\n                    }\n                }\n            }\n            catch (ObjectDisposedException)\n            {\n            }\n            catch (Exception e)\n            {\n            }\n            finally\n            {\n                try\n                {\n                    _udpSocket.BeginReceiveFrom(state.buffer, 0, state.buffer.Length, 0, ref state.remoteEndPoint, new AsyncCallback(RecvFromCallback), state);\n                }\n                catch (ObjectDisposedException)\n                {\n                    // do nothing\n                }\n                catch (Exception e)\n                {\n                }
                    if (service.Handle(buf, bytesRead, conn, null))
                if (conn.ProtocolType == ProtocolType.Tcp)\n                {\n                    conn.Close();\n                }
    class TCPRelay : Listener.Service
        public TCPRelay(Configuration config)
        public bool Handle(byte[] firstPacket, int length, Socket socket, object state)\n        {\n            if (socket.ProtocolType != ProtocolType.Tcp)\n            {\n                return false;\n            }
        public bool Handle(byte[] firstPacket, int length, Socket socket, object state)
        public bool Handle(byte[] firstPacket, int length, Socket socket, object state)
        void BeginConnectProxy(EndPoint remoteEP, AsyncCallback callback, object state);
        void BeginConnectDest(EndPoint remoteEP, AsyncCallback callback, object state);
        void BeginSend(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,
        void BeginReceive(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,
        public void BeginConnectProxy(EndPoint remoteEP, AsyncCallback callback, object state)

        public void BeginConnectDest(EndPoint remoteEP, AsyncCallback callback, object state)
            _remote.BeginConnect(remoteEP, callback, state);
        public void BeginSend(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,
            _remote.BeginSend(buffer, offset, size, socketFlags, callback, state);
        public void BeginReceive(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback,
            _remote.BeginReceive(buffer, offset, size, socketFlags, callback, state);
                foreach (Process p in existingPolipo.Where(IsChildProcess))
                FileManager.ByteArrayToFile(Utils.GetTempPath(UniqueConfigFile), Encoding.UTF8.GetBytes(polipoConfig));
                _process.StartInfo.Arguments = UniqueConfigFile;
                if (IsPortableMode())
                    appendText.Append(line + Environment.NewLine);\n                LogMessageTextBox.AppendText(appendText.ToString());
                        appendText.Append(line + Environment.NewLine);

                    if (isPortableMode)\n                    {\n                        _tempPath = Directory.CreateDirectory(Path.Combine(Application.StartupPath, "ss_win_temp")).FullName;
                    }\n                    else\n                    {\n                        _tempPath = Directory.CreateDirectory(Path.Combine(Path.GetTempPath(), @"Shadowsocks\ss_win_temp_" + Application.ExecutablePath.GetHashCode())).FullName;\n                    }

        public void SaveServers(List<Server> servers, int localPort, bool portableMode)
            _config.portableMode = portableMode;

        private System.Windows.Forms.CheckBox PortableModeCheckBox;
                _connection.BeginReceive(_connetionRecvBuffer, 0, RecvSize, SocketFlags.None, new AsyncCallback(PipeConnectionReceiveCallback), session);

                _connection.EndSend(ar);
            this.BackColor = System.Drawing.Color.White;
            using (Bitmap fullImage = new Bitmap(Screen.PrimaryScreen.Bounds.Width,
                using (Graphics g = Graphics.FromImage(fullImage))
                                     fullImage.Size,
                for (int i = 0; i < 5; i++)
                    int marginLeft = fullImage.Width * i / 3 / 5;\n                    int marginTop = fullImage.Height * i / 3 / 5;\n                    Rectangle cropRect = new Rectangle(marginLeft, marginTop, fullImage.Width - marginLeft * 2, fullImage.Height - marginTop * 2);\n                    Bitmap target = new Bitmap(cropRect.Width, cropRect.Height);\n                    using (Graphics g = Graphics.FromImage(target))
                        g.DrawImage(fullImage, new Rectangle(0, 0, target.Width, target.Height),\n                                        cropRect,\n                                        GraphicsUnit.Pixel);
                    var reader = new BarcodeReader
                        minX += -margin + marginLeft;\n                        maxX += margin + marginLeft;\n                        minY += -margin + marginTop;\n                        maxY += margin + marginTop;
                        // we need a panel because a window has a minimal size\n                        splash.Panel.Size = new Size((int)maxX - (int)minX, (int)maxY - (int)minY);\n                        splash.Size = splash.Panel.Size;
            }\n            MessageBox.Show(I18N.GetString("Failed to find QRCode"));
        private readonly ShadowsocksController _controller;
        private readonly IEnumerable<TextBox> _allTextBoxes;
            Icon = Icon.FromHandle(Resources.ssw128.GetHicon());
            _allTextBoxes = tableLayoutPanel1.GetChildControls<TextBox>();
            Text = I18N.GetString("Edit Hotkeys...");
            StringBuilder sb = new StringBuilder();
            var tb = (TextBox) sender;\n            var content = tb.Text.TrimEnd();
            var tb = (TextBox) sender;
            HotKeys.HotKeyCallBackHandler callBack;\n            Label lb;\n            PrepareForHotkey(tb, out callBack, out lb);\n            UnregPrevHotkey(callBack);
            Close();
                        MainController.Stop();
                    MainController.Start();
                MainController.Stop();\n                MainController = null;

            var proxy = timer.Session.Remote;
            var session = timer.Session;\n            Server server = timer.Server;
        private class AutoReleaseAsyncResult : IAsyncResult
            public bool IsCompleted { get; } = true;\n            public WaitHandle AsyncWaitHandle { get; } = null;\n            public object AsyncState { get; set; }\n            public bool CompletedSynchronously { get; } = true;\n            public TcpUserToken UserToken { get; set; }\n            ~AutoReleaseAsyncResult()\n            {\n                UserToken.Dispose();\n            }\n        }\n        private class TcpUserToken\n        {\n            public AsyncCallback Callback { get; private set; }\n            public SocketAsyncEventArgs Args { get; private set; }\n            public object AsyncState { get; private set; }
            public void Dispose()\n            {\n                Args?.Dispose();\n                Callback = null;\n                Args = null;\n                AsyncState = null;\n            }
            AutoReleaseAsyncResult r = new AutoReleaseAsyncResult\n            {\n                AsyncState = token.AsyncState,\n                UserToken = token\n            };\n            token.Callback(r);
            var r = asyncResult as AutoReleaseAsyncResult;\n            if (r == null)



            this.tableLayoutPanel1.Margin = new System.Windows.Forms.Padding(5);
            this.tableLayoutPanel1.Padding = new System.Windows.Forms.Padding(5);




            this.Icon = Icon.FromHandle(Resources.ssw128.GetHicon());







            this.Close();
        private void ConfigForm_FormClosed(object sender, FormClosedEventArgs e)
            controller.ConfigChanged -= controller_ConfigChanged;

            Socket listener = (Socket)ar.AsyncState;\n            try\n            {

            Socket listener = (Socket)ar.AsyncState;\n            try\n            {



            this.OKButton.Dock = System.Windows.Forms.DockStyle.Right;\n            this.OKButton.Location = new System.Drawing.Point(3, 3);\n            this.OKButton.Margin = new System.Windows.Forms.Padding(3, 3, 3, 0);
            this.MyCancelButton.Dock = System.Windows.Forms.DockStyle.Right;\n            this.MyCancelButton.Location = new System.Drawing.Point(84, 3);\n            this.MyCancelButton.Margin = new System.Windows.Forms.Padding(3, 3, 0, 0);

            this.DeleteButton.Dock = System.Windows.Forms.DockStyle.Right;\n            this.DeleteButton.Location = new System.Drawing.Point(86, 6);\n            this.DeleteButton.Margin = new System.Windows.Forms.Padding(3, 6, 0, 3);
            this.AddButton.Dock = System.Windows.Forms.DockStyle.Left;\n            this.AddButton.Location = new System.Drawing.Point(0, 6);\n            this.AddButton.Margin = new System.Windows.Forms.Padding(0, 6, 3, 3);
            this.ServerGroupBox.Location = new System.Drawing.Point(178, 0);\n            this.ServerGroupBox.Margin = new System.Windows.Forms.Padding(12, 0, 0, 0);
            this.ServersListBox.IntegralHeight = false;\n            this.ServersListBox.Location = new System.Drawing.Point(0, 0);\n            this.ServersListBox.Margin = new System.Windows.Forms.Padding(0);
            this.ClientSize = new System.Drawing.Size(574, 367);\n            this.Controls.Add(this.tableLayoutPanel2);



using System.Text.RegularExpressions;\nusing Shadowsocks.ForwardProxy;
                        //registry.SetValue("ProxyServer", "");         //Unnecessary
                    if (global)\n                    {\n                        registry.SetValue("ProxyServer", "");\n                    }
﻿using shadowsocks_csharp.Model;\nusing System;
namespace shadowsocks_csharp.Controller
﻿using shadowsocks_csharp.Model;\nusing shadowsocks_csharp.Properties;
namespace shadowsocks_csharp.Controller

namespace shadowsocks_csharp.Controller
    public class SystemProxy
                    Info(e);
                Info(e);
        public interface IService
                foreach (IService service in _services)
            // requested register and not autostartup\n            if (register && !Check())
        public void CheckUpdate(Configuration config)
            http.Proxy = new WebProxy(IPAddress.Loopback.ToString(), config.localPort);

            return new Tuple<float, string, long>(f, unit, scale);
            icon_baseBitmap = null;
                icon_baseBitmap = Resources.ss16;
                icon_baseBitmap = Resources.ss20;
                icon_baseBitmap = Resources.ss24;
            icon_baseBitmap = getTrayIconByState(icon_baseBitmap, enabled, global);\n            icon_base = Icon.FromHandle(icon_baseBitmap.GetHicon());\n            targetIcon = icon_base;\n            icon_in = Icon.FromHandle(AddBitmapOverlay(icon_baseBitmap, Resources.ssIn24).GetHicon());\n            icon_out = Icon.FromHandle(AddBitmapOverlay(icon_baseBitmap, Resources.ssOut24).GetHicon());\n            icon_both = Icon.FromHandle(AddBitmapOverlay(icon_baseBitmap, Resources.ssIn24, Resources.ssOut24).GetHicon());\n            _notifyIcon.Icon = targetIcon;
            foreach (Screen screen in Screen.AllScreens)\n            {\n                using (Bitmap fullImage = new Bitmap(screen.Bounds.Width,\n                                                screen.Bounds.Height))
                    using (Graphics g = Graphics.FromImage(fullImage))
                        g.CopyFromScreen(screen.Bounds.X,\n                                         screen.Bounds.Y,\n                                         0, 0,\n                                         fullImage.Size,\n                                         CopyPixelOperation.SourceCopy);
                    int maxTry = 10;\n                    for (int i = 0; i < maxTry; i++)
                        int marginLeft = fullImage.Width * i / 3 / maxTry;\n                        int marginTop = fullImage.Height * i / 3 / maxTry;\n                        Rectangle cropRect = new Rectangle(marginLeft, marginTop, fullImage.Width - marginLeft * 2, fullImage.Height - marginTop * 2);\n                        Bitmap target = new Bitmap(cropRect.Width, cropRect.Height);\n                        using (Graphics g = Graphics.FromImage(target))
                            g.DrawImage(fullImage, new Rectangle(0, 0, target.Width, target.Height),\n                                            cropRect,\n                                            GraphicsUnit.Pixel);
                        var source = new BitmapLuminanceSource(target);\n                        var bitmap = new BinaryBitmap(new HybridBinarizer(source));\n                        QRCodeReader reader = new QRCodeReader();\n                        var result = reader.decode(bitmap);\n                        if (result != null)
                    return byteArrayWith(buf, length);
                    return byteArrayWith(buf, length);
                    return byteArrayWith(buf, length);
                    return byteArrayWith(buf, length);
        ShadowsocksController controller;\n        public ConfigForm(ShadowsocksController controller)

            this.controller = controller;\n            controller.EnableStatusChanged += controller_EnableStatusChanged;\n            controller.ConfigChanged += controller_ConfigChanged;\n            updateUI();\n        }\n        private void controller_ConfigChanged(object sender, EventArgs e)\n        {\n            updateUI();\n        }\n        private void controller_EnableStatusChanged(object sender, EventArgs e)\n        {\n            updateUI();
        private void updateUI()
            comboBox1.Text = config.method == null ? "aes-256-cfb" : config.method;\n            enableItem.Checked = config.enabled;
            if (!controller.GetConfig().isDefault)
                BeginInvoke(new MethodInvoker(delegate

            updateUI();
            controller.Stop();

            controller.ToggleEnable(enableItem.Checked);
        public void EnableProxy(int type, string proxy, int port, int timeout)

                int port;\n                int timeout;\n                if (!int.TryParse(ProxyPortTextBox.Text, out port))

                if (!int.TryParse(ProxyTimeoutTextBox.Text, out timeout))

                controller.EnableProxy(type, proxy, port, timeout);

                    var method = m.Groups[1].Value;
                        if (!ParseHost(m.Groups[2].Value))
                }\n            }\n            else\n            {
        public void UpdateLatency(object sender, SSTCPConnectedEventArgs args)\n        {\n            GetCurrentStrategy()?.UpdateLatency(args.server, args.latency);
                availabilityStatistics.UpdateLatency(args.server, (int)args.latency.TotalMilliseconds);\n            }\n        }\n        public void UpdateInboundCounter(object sender, SSTransmitEventArgs args)\n        {\n            GetCurrentStrategy()?.UpdateLastRead(args.server);\n            Interlocked.Add(ref _inboundCounter, args.length);
                availabilityStatistics.UpdateInboundCounter(args.server, args.length);\n            }\n        }\n        public void UpdateOutboundCounter(object sender, SSTransmitEventArgs args)\n        {\n            GetCurrentStrategy()?.UpdateLastWrite(args.server);\n            Interlocked.Add(ref _outboundCounter, args.length);
                availabilityStatistics.UpdateOutboundCounter(args.server, args.length);

    public class SSRelayEventArgs : EventArgs
    public class SSTransmitEventArgs : SSRelayEventArgs
        public SSTransmitEventArgs(Server server, long length) : base(server)
    public class SSTCPConnectedEventArgs : SSRelayEventArgs

        public event EventHandler<SSTransmitEventArgs> OnInbound;\n        public event EventHandler<SSTransmitEventArgs> OnOutbound;\n        public event EventHandler<SSRelayEventArgs> OnClosed;\n        public event EventHandler<SSRelayEventArgs> OnFailed;
            OnOutbound?.Invoke(this, new SSTransmitEventArgs(_server, bytesToSend));

        protected byte[] crc_buf;\n        protected int crc_idx = 0;\n        public IVEncryptor(string method, string password, bool onetimeauth)\n            : base(method, password, onetimeauth)
        }\n        static void LoadSSCrypto2Library()\n        {\n            string tempPath = Utils.GetTempPath();\n            string dllPath = tempPath + "/libsscrypto2.dll";\n            try\n            {\n                FileManager.UncompressFile(dllPath, Resources.libsscrypto2_dll);\n                LoadLibrary(dllPath);\n            }\n            catch (IOException)\n            {\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine(e.ToString());\n            }
        protected EncryptorBase(string method, string password, bool onetimeauth)
            this.tableLayoutPanel1.RowCount = 7;\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.Size = new System.Drawing.Size(238, 160);
            this.ServerGroupBox.Size = new System.Drawing.Size(249, 197);\n            this.ServerGroupBox.TabIndex = 0;

        public static IEncryptor GetEncryptor(string method, string password, bool onetimeauth = false)
            IEncryptor result = (IEncryptor)c.Invoke(new object[] { method, password, onetimeauth });
            this.PluginOptionsLabel.Location = new System.Drawing.Point(24, 203);\n            this.PluginOptionsLabel.Margin = new System.Windows.Forms.Padding(4, 0, 4, 0);
            this.PluginTextBox.Location = new System.Drawing.Point(151, 165);\n            this.PluginTextBox.Margin = new System.Windows.Forms.Padding(4, 4, 4, 4);
            this.RemarksTextBox.Location = new System.Drawing.Point(151, 291);\n            this.RemarksTextBox.Margin = new System.Windows.Forms.Padding(4, 4, 4, 4);
            this.IPLabel.Location = new System.Drawing.Point(64, 13);\n            this.IPLabel.Margin = new System.Windows.Forms.Padding(4, 0, 4, 0);
            this.ServerPortLabel.Location = new System.Drawing.Point(48, 46);\n            this.ServerPortLabel.Margin = new System.Windows.Forms.Padding(4, 0, 4, 0);
            this.PasswordLabel.Location = new System.Drawing.Point(72, 79);\n            this.PasswordLabel.Margin = new System.Windows.Forms.Padding(4, 0, 4, 0);
            this.IPTextBox.Location = new System.Drawing.Point(151, 8);\n            this.IPTextBox.Margin = new System.Windows.Forms.Padding(4, 4, 4, 4);
            this.ServerPortTextBox.Location = new System.Drawing.Point(151, 41);\n            this.ServerPortTextBox.Margin = new System.Windows.Forms.Padding(4, 4, 4, 4);
            this.PasswordTextBox.Location = new System.Drawing.Point(151, 74);\n            this.PasswordTextBox.Margin = new System.Windows.Forms.Padding(4, 4, 4, 4);
            this.EncryptionLabel.Location = new System.Drawing.Point(56, 138);\n            this.EncryptionLabel.Margin = new System.Windows.Forms.Padding(4, 0, 4, 0);
            this.EncryptionSelect.ItemHeight = 15;\n            this.EncryptionSelect.Location = new System.Drawing.Point(151, 134);\n            this.EncryptionSelect.Margin = new System.Windows.Forms.Padding(4, 4, 4, 4);
            this.TimeoutLabel.Location = new System.Drawing.Point(40, 329);\n            this.TimeoutLabel.Margin = new System.Windows.Forms.Padding(4, 0, 4, 0);
            this.TimeoutTextBox.Location = new System.Drawing.Point(151, 324);\n            this.TimeoutTextBox.Margin = new System.Windows.Forms.Padding(4, 4, 4, 4);
            this.PluginLabel.Location = new System.Drawing.Point(24, 170);\n            this.PluginLabel.Margin = new System.Windows.Forms.Padding(4, 0, 4, 0);
            this.PluginOptionsTextBox.Location = new System.Drawing.Point(151, 198);\n            this.PluginOptionsTextBox.Margin = new System.Windows.Forms.Padding(4, 4, 4, 4);
            this.ShowPasswdCheckBox.Location = new System.Drawing.Point(151, 107);\n            this.ShowPasswdCheckBox.Margin = new System.Windows.Forms.Padding(4, 4, 4, 4);
            this.PluginArgumentsTextBox.Location = new System.Drawing.Point(151, 258);\n            this.PluginArgumentsTextBox.Margin = new System.Windows.Forms.Padding(4, 4, 4, 4);
            this.PluginArgumentsLabel.Location = new System.Drawing.Point(8, 263);\n            this.PluginArgumentsLabel.Margin = new System.Windows.Forms.Padding(4, 0, 4, 0);
            this.RemarksLabel.Location = new System.Drawing.Point(80, 296);\n            this.RemarksLabel.Margin = new System.Windows.Forms.Padding(4, 0, 4, 0);
            this.NeedPluginArgCheckBox.Location = new System.Drawing.Point(151, 231);\n            this.NeedPluginArgCheckBox.Margin = new System.Windows.Forms.Padding(4, 4, 4, 4);
            this.panel2.Location = new System.Drawing.Point(206, 234);\n            this.panel2.Margin = new System.Windows.Forms.Padding(4, 4, 4, 4);
            this.tableLayoutPanel5.Padding = new System.Windows.Forms.Padding(4, 4, 4, 4);
            this.ProxyPortTextBox.Location = new System.Drawing.Point(103, 8);\n            this.ProxyPortTextBox.Margin = new System.Windows.Forms.Padding(4, 4, 4, 4);
            this.ProxyPortLabel.Location = new System.Drawing.Point(8, 13);\n            this.ProxyPortLabel.Margin = new System.Windows.Forms.Padding(4, 0, 4, 0);
            this.PortableModeCheckBox.Location = new System.Drawing.Point(8, 48);\n            this.PortableModeCheckBox.Margin = new System.Windows.Forms.Padding(4, 4, 4, 4);


namespace Shadowsocks.Test
        public void SendResponse(Socket socket, bool useSocks)

                string proxy = GetPACAddress(localEndPoint, useSocks);\n                string pacContent = GetPACContent().Replace("__PROXY__", proxy);\n                string responseHead = String.Format(@"HTTP/1.1 200 OK
", Encoding.UTF8.GetBytes(pacContent).Length);\n                byte[] response = Encoding.UTF8.GetBytes(responseHead + pacContent);
                    FileManager.UncompressFile(dllPath, Resources.polarssl_dll);
    public struct INTERNET_PER_CONN_OPTION_OptionUnion : IDisposable
    public struct INTERNET_PER_CONN_OPTION_LIST : IDisposable
                FileStream fs = new FileStream(LogFilePath, FileMode.Append);\n                StreamWriterWithTimestamp sw = new StreamWriterWithTimestamp(fs);\n                sw.AutoFlush = true;\n                Console.SetOut(sw);\n                Console.SetError(sw);




        protected Dictionary<string, EncryptorInfo> ciphers;
        protected EncryptorInfo _cipherInfo;
        protected abstract Dictionary<string, EncryptorInfo> getCiphers();
            _cipherInfo = ciphers[_method];\n            _cipherMbedName = _cipherInfo.name;\n            _cipher = _cipherInfo.type;
            keyLen = _cipherInfo.key_size;\n            ivLen = _cipherInfo.iv_size;
        private static Dictionary<string, EncryptorInfo> _ciphers = new Dictionary<string, EncryptorInfo> {\n            { "aes-128-cfb", new EncryptorInfo("AES-128-CFB128", 16, 16, CIPHER_AES) },\n            { "aes-192-cfb", new EncryptorInfo("AES-192-CFB128", 24, 16, CIPHER_AES) },\n            { "aes-256-cfb", new EncryptorInfo("AES-256-CFB128", 32, 16, CIPHER_AES) },\n            { "aes-128-ctr", new EncryptorInfo("AES-128-CTR", 16, 16, CIPHER_AES) },\n            { "aes-192-ctr", new EncryptorInfo("AES-192-CTR", 24, 16, CIPHER_AES) },\n            { "aes-256-ctr", new EncryptorInfo("AES-256-CTR", 32, 16, CIPHER_AES) },\n            { "bf-cfb", new EncryptorInfo("BLOWFISH-CFB64", 16, 8, CIPHER_BLOWFISH) },\n            { "camellia-128-cfb", new EncryptorInfo("CAMELLIA-128-CFB128", 16, 16, CIPHER_CAMELLIA) },\n            { "camellia-192-cfb", new EncryptorInfo("CAMELLIA-192-CFB128", 24, 16, CIPHER_CAMELLIA) },\n            { "camellia-256-cfb", new EncryptorInfo("CAMELLIA-256-CFB128", 32, 16, CIPHER_CAMELLIA) },\n            { "rc4-md5", new EncryptorInfo("ARC4-128", 16, 16, CIPHER_RC4) }
        protected override Dictionary<string, EncryptorInfo> getCiphers()
        private static Dictionary<string, EncryptorInfo> _ciphers = new Dictionary<string, EncryptorInfo> {\n            { "salsa20", new EncryptorInfo("salsa20", 32, 8, CIPHER_SALSA20) },\n            { "chacha20", new EncryptorInfo("chacha20", 32, 8, CIPHER_CHACHA20) },\n            { "chacha20-ietf", new EncryptorInfo("chacha20-ietf", 32, 12, CIPHER_CHACHA20_IETF) }
        protected override Dictionary<string, EncryptorInfo> getCiphers()
            this.AutoSize = true;\n            this.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;\n            this.ClientSize = new System.Drawing.Size(291, 206);\n            this.Controls.Add(this.tableLayoutPanel2);\n            this.Controls.Add(this.tableLayoutPanel1);\n            this.Name = "Form1";\n            this.Text = "Shadowsocks";\n            this.tableLayoutPanel1.ResumeLayout(false);\n            this.tableLayoutPanel1.PerformLayout();\n            this.panel1.ResumeLayout(false);\n            this.tableLayoutPanel2.ResumeLayout(false);\n            this.tableLayoutPanel2.PerformLayout();\n            this.ResumeLayout(false);\n            this.PerformLayout();
        public const int ONETIMEAUTH_KEYBYTES = 32;\n        public const int HASH_BUF_LEN = 128;\n        public const int HASH_BYTES = 4;
        protected byte[] hash_buf;\n        protected int hash_idx = 0;
                hash_buf = new byte[HASH_BUF_LEN];
                        lock (hash_buf)
                            int headLen = ss_headlen(buf, length);
                            ss_onetimeauth(auth, buf, headLen, _encryptIV, ivLen, _key, keyLen);
                            ss_gen_hash(buf, ref buf_offset, ref data_len, hash_buf, ref hash_idx, buf.Length);
                    lock (hash_buf)
                        ss_gen_hash(buf, ref buf_offset, ref length, hash_buf, ref hash_idx, buf.Length);
        public extern static int crypto_generichash(byte[] outbuf, uint outlen,\n            byte[] inbuf, ulong inlen,\n            byte[] key, uint keylen);
        public extern static int crypto_onetimeauth(byte[] outbuf, byte[] inbuf, ulong inlen, byte[] k);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static int crypto_onetimeauth_verify(byte[] h, byte[] inbuf, ulong inlen, byte[] k);

if (!AutoStartup.Set(autoStartup.Checked)) {\nMessageBox.Show("Failed to edit registry");
autoStartup.Checked = AutoStartup.Check();
            Bitmap drawArea = new Bitmap((m.Width * blockSize), (m.Height * blockSize));

         String encoding = DEFAULT_BYTE_MODE_ENCODING;\n         //bool generateECI = !DEFAULT_BYTE_MODE_ENCODING.Equals(encoding);
         Mode mode = Mode.BYTE;











        private void ShowLogForm()\n        {\n            if (logForm != null)\n            {\n                logForm.Activate();
                logForm = new LogForm(controller, Logging.LogFilePath);\n                logForm.Show();\n                logForm.Activate();\n                logForm.FormClosed += logForm_FormClosed;
            logForm = null;\n            Utils.ReleaseMemory(true);

        protected static void bytesToKey(byte[] password, byte[] key)
            try

            return new Sip003Plugin(server.plugin, server.plugin_opts, server.plugin_args, server.server, server.server_port);
        private Sip003Plugin(string plugin, string pluginOpts, string pluginArgs, string serverAddress, int serverPort)
            this.tableLayoutPanel1.RowCount = 11;\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.Size = new System.Drawing.Size(279, 270);





[assembly: AssemblyCompany("")]
// [assembly: AssemblyFileVersion("2.0.0")]
    groupName_ = other.groupName_;\n    domains_ = other.domains_.Clone();
  /// <summary>Field number for the "group_name" field.</summary>\n  public const int GroupNameFieldNumber = 1;\n  private string groupName_ = "";\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n  public string GroupName {\n    get { return groupName_; }
      groupName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");\n    }\n  }\n  /// <summary>Field number for the "domains" field.</summary>\n  public const int DomainsFieldNumber = 2;\n  private static readonly pb::FieldCodec<global::DomainObject> _repeated_domains_codec
  private readonly pbc::RepeatedField<global::DomainObject> domains_ = new pbc::RepeatedField<global::DomainObject>();\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n  public pbc::RepeatedField<global::DomainObject> Domains {\n    get { return domains_; }
    if (GroupName != other.GroupName) return false;\n    if(!domains_.Equals(other.domains_)) return false;
    if (GroupName.Length != 0) hash ^= GroupName.GetHashCode();\n    hash ^= domains_.GetHashCode();
    if (GroupName.Length != 0) {
      output.WriteString(GroupName);\n    }\n    domains_.WriteTo(output, _repeated_domains_codec);
    if (GroupName.Length != 0) {\n      size += 1 + pb::CodedOutputStream.ComputeStringSize(GroupName);\n    }\n    size += domains_.CalculateSize(_repeated_domains_codec);
          GroupName = input.ReadString();
          domains_.AddEntriesFrom(input, _repeated_domains_codec);
  /// <summary>Field number for the "entries" field.</summary>\n  public const int EntriesFieldNumber = 1;\n  private static readonly pb::FieldCodec<global::Geosite> _repeated_entries_codec
  private readonly pbc::RepeatedField<global::Geosite> entries_ = new pbc::RepeatedField<global::Geosite>();\n  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n  public pbc::RepeatedField<global::Geosite> Entries {\n    get { return entries_; }
    if(!entries_.Equals(other.entries_)) return false;
        public static event EventHandler<ResultEventArgs> UpdateCompleted;\n        public class ResultEventArgs : EventArgs\n        {\n            public bool Success;\n            public ResultEventArgs(bool success)\n            {\n                this.Success = success;\n            }\n        }\n        public static event ErrorEventHandler Error;\n        private static readonly string DATABASE_PATH = Utils.GetTempPath("dlc.dat");\n        // temporary workaround\n        private static readonly string GEOSITE_URL = "https://github.com/v2ray/domain-list-community/releases/download/202005010407/dlc.dat";\n        public static readonly Dictionary<string, IList<DomainObject>> Geosites = new Dictionary<string, IList<DomainObject>>();
            LoadGeositeList();\n        }\n        static void LoadGeositeList(byte[] data = null)\n        {\n            data = data ?? File.ReadAllBytes(DATABASE_PATH);\n            var list = GeositeList.Parser.ParseFrom(data);\n            foreach (var item in list.Entries)
                Geosites[item.GroupName.ToLower()] = item.Domains;
                    if (line.StartsWith("http://"))\n                        line = line.Substring(7);\n                    else if (line.StartsWith("https://"))\n                        line = line.Substring(8);\n                    if (line.IndexOf("*") >= 0)
                        while (line.StartsWith("||"))\n                            line = line.Substring(2);
                        line = line.TrimStart('|');
                        line = line.TrimStart('.');
                    int pos = line.IndexOfAny(new char[] { '/'});\n                    if (pos >= 0)\n                        line = line.Substring(0, pos);\n                    if (line.Length > 0)\n                        domains.Add(line);\n                }\n                return RemoveDuplicate(domains.ToArray());
                    if (se.SocketErrorCode == SocketError.AddressAlreadyInUse)
            Dispose(true);\n            GC.SuppressFinalize(this);\n        }\n        ~PolarSSLEncryptor()\n        {\n            Dispose(false);\n        }\n        protected virtual void Dispose(bool disposing)\n        {\n            if (!_disposed)\n            {\n                if (disposing)\n                {\n                }\n                if (_encryptCtx != null)\n                {\n                    switch (_cipher)\n                    {\n                        case CIPHER_AES:\n                            PolarSSL.aes_free(_encryptCtx);\n                            break;\n                        case CIPHER_RC4:\n                            PolarSSL.arc4_free(_encryptCtx);\n                            break;\n                    }\n                }\n                if (_decryptCtx != null)\n                {\n                    switch (_cipher)\n                    {\n                        case CIPHER_AES:\n                            PolarSSL.aes_free(_decryptCtx);\n                            break;\n                        case CIPHER_RC4:\n                            PolarSSL.arc4_free(_decryptCtx);\n                            break;\n                    }\n                }\n                _encryptCtx = null;\n                _decryptCtx = null;\n                _disposed = true;\n            }\n        }\n        #endregion
            Font = SystemFonts.MessageBoxFont;
            ServersListBox.Dock = DockStyle.Fill;\n            tableLayoutPanel5.Dock = DockStyle.Fill;\n            PerformLayout();
            Icon = Icon.FromHandle(Resources.ssw128.GetHicon());
            toolTip1.SetToolTip(PortableModeCheckBox, I18N.GetString("Restart required"));
            Text = I18N.GetString("Edit Servers");
        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        private void UpdateIndexToEnd()\n        {\n            _lastSelectedIndex = (ServersListBox.SelectedIndex = (_modifiedConfiguration.configs.Count - 1));\n        }\n        private bool ValidateAndSaveSelectedServerDetails(bool isSave = false, bool isCopy = false)
                bool verify = GetServerDetailsFromUI(out Server server, isSave, isCopy);\n                if (server != null)\n                {\n                    if (isSave || isCopy)\n                        Configuration.CheckServer(server);\n                    _modifiedConfiguration.configs[_lastSelectedIndex] = server;\n                }\n                return verify;\n            }\n            catch (Exception ex)\n            {\n                MessageBox.Show(ex.Message);\n            }\n            return false;\n        }\n        private bool GetServerDetailsFromUI(out Server server, bool isSave = false, bool isCopy = false)\n        {\n            server = null;\n            bool? checkIP = false;\n            bool? checkPort = false;\n            bool? checkPassword = false;\n            bool? checkTimeout = false;\n            if ((checkIP = CheckIPTextBox(out string address, isSave, isCopy)).GetValueOrDefault(false) && address != null\n                    && (checkPort = CheckServerPortTextBox(out int? addressPort, isSave, isCopy)).GetValueOrDefault(false) && addressPort.HasValue\n                        && (checkPassword = CheckPasswordTextBox(out string serverPassword, isSave, isCopy)).GetValueOrDefault(false) && serverPassword != null\n                            && (checkTimeout = CheckTimeoutTextBox(out int? timeout, isSave, isCopy)).GetValueOrDefault(false) && timeout.HasValue)\n            {\n                server = new Server()\n                {\n                    server = address,\n                    server_port = addressPort.Value,\n                    password = serverPassword,\n                    method = EncryptionSelect.Text,\n                    plugin = PluginTextBox.Text,\n                    plugin_opts = PluginOptionsTextBox.Text,\n                    plugin_args = PluginArgumentsTextBox.Text,\n                    remarks = RemarksTextBox.Text,\n                    timeout = timeout.Value,\n                };
            if (ValidateAndSaveSelectedServerDetails(isSave: true))\n            {\n                Configuration.AddDefaultServerOrServer(_modifiedConfiguration);\n                LoadServerNameListToUI(_modifiedConfiguration);\n                UpdateIndexToEnd();\n            }\n        }\n        private void DuplicateButton_Click(object sender, EventArgs e)\n        {\n            if (ValidateAndSaveSelectedServerDetails(isCopy: true))\n            {\n                Server currServer = _modifiedConfiguration.configs[_lastSelectedIndex];\n                Configuration.AddDefaultServerOrServer(_modifiedConfiguration, currServer);\n                LoadServerNameListToUI(_modifiedConfiguration);\n                UpdateIndexToEnd();\n            }\n        }\n        private void DeleteButton_Click(object sender, EventArgs e)\n        {\n            _modifiedConfiguration.configs.RemoveAt(_lastSelectedIndex);\n            if (_modifiedConfiguration.configs.Count == 0)\n            {\n                Configuration.AddDefaultServerOrServer(_modifiedConfiguration);\n            }
            UpdateIndexToEnd();
        private void UpdateButtons()\n        {\n            DeleteButton.Enabled = (ServersListBox.Items.Count > 0);\n            MoveUpButton.Enabled = (ServersListBox.SelectedIndex > 0);\n            MoveDownButton.Enabled = (ServersListBox.SelectedIndex < ServersListBox.Items.Count - 1);\n        }\n        private void MoveUpButton_Click(object sender, EventArgs e)\n        {\n            if (ServersListBox.SelectedIndex > 0)\n            {\n                MoveConfigItem(-1);  // -1 means move backward\n            }\n        }\n        private void MoveDownButton_Click(object sender, EventArgs e)\n        {\n            if (ServersListBox.SelectedIndex < ServersListBox.Items.Count - 1)\n            {\n                MoveConfigItem(+1);  // +1 means move forward\n            }
        private void OKButton_Click(object sender, EventArgs e)\n        {\n            if (SaveValidConfiguration())\n            {\n                Close();\n            }\n        }\n        private void CancelButton_Click(object sender, EventArgs e)\n        {\n            Close();\n        }\n        private void ApplyButton_Click(object sender, EventArgs e)\n        {\n            SaveValidConfiguration();\n        }\n        private void ConfigForm_Shown(object sender, EventArgs e)\n        {\n            IPTextBox.Focus();\n        }\n        private void ConfigForm_FormClosed(object sender, FormClosedEventArgs e)\n        {\n            controller.ConfigChanged -= Controller_ConfigChanged;
            PasswordTextBox.UseSystemPasswordChar = !ShowPasswdCheckBox.Checked;
            ShowHidePluginArgInput(NeedPluginArgCheckBox.Checked);

        private static readonly string CONFIG_FILE = "gui-config.json";

        public static Server AddDefaultServerOrServer(Configuration config, Server server = null, int? index = null)
                config.configs.Insert(index.GetValueOrDefault(config.configs.Count), server);\n                //if (index.HasValue)\n                //    config.configs.Insert(index.Value, server);\n                //else\n                //    config.configs.Add(server);
        // Add a short delay to avoid raise event twice in a short period
            if (PACFileChanged != null)\n            {\n                Logging.Info($"Detected: PAC file '{e.Name}' was {e.ChangeType.ToString().ToLower()}.");\n                Task.Factory.StartNew(() =>\n                {\n                    ((FileSystemWatcher)sender).EnableRaisingEvents = false;\n                    System.Threading.Thread.Sleep(10);
                    ((FileSystemWatcher)sender).EnableRaisingEvents = true;\n                });
            if (UserRuleFileChanged != null)\n            {\n                Logging.Info($"Detected: User Rule file '{e.Name}' was {e.ChangeType.ToString().ToLower()}.");\n                Task.Factory.StartNew(()=>\n                {\n                    ((FileSystemWatcher)sender).EnableRaisingEvents = false;\n                    System.Threading.Thread.Sleep(10);
                    ((FileSystemWatcher)sender).EnableRaisingEvents = true;\n                });
﻿using Microsoft.Win32;

using System.Net;
using System.Threading;
using System.Windows.Forms;
    internal static class Program
        private static readonly Logger logger = LogManager.GetCurrentClassLogger();
        private static void Main(string[] args)
            ServicePointManager.SecurityProtocol |=\n                SecurityProtocolType.Tls | SecurityProtocolType.Tls11 | SecurityProtocolType.Tls12;
                // TODO: switch to better argv parser when it's getting complicate\n                List<string> alist = Args.ToList();\n                // check --open-url param
                    if (Args.Length <= urlidx)\n                    {\n                        return;\n                    }\n                    // --open-url exist, and no other instance, add it later\n                    if (!pipeExist)\n                    {\n                        addedUrl = Args[urlidx];\n                    }\n                    // has other instance, send url via pipe then exit\n                    else\n                    {\n                        byte[] b = Encoding.UTF8.GetBytes(Args[urlidx]);\n                        byte[] opAddUrl = BitConverter.GetBytes(IPAddress.HostToNetworkOrder(1));\n                        byte[] blen = BitConverter.GetBytes(IPAddress.HostToNetworkOrder(b.Length));\n                        pipe.Write(opAddUrl, 0, 4); // opcode addurl\n                        pipe.Write(blen, 0, 4);\n                        pipe.Write(b, 0, b.Length);\n                        pipe.Close();\n                        return;\n                    }\n                }\n                // has another instance, and no need to communicate with it return
    public class QRCodeSplashForm : Form


            IPTextBox.Text = server.server;\n            ServerPortTextBox.Text = server.server_port.ToString();\n            PasswordTextBox.Text = server.password;\n            ProxyPortTextBox.Text = server.local_port.ToString();\n            EncryptionSelect.Text = server.method == null ? "aes-256-cfb" : server.method;
        private void CinfigForm_Load(object sender, EventArgs e)
        private void ConfigForm_FormClosed(object sender, FormClosedEventArgs e)
            this.EncryptionSelect = new System.Windows.Forms.ComboBox();
            this.IPTextBox = new System.Windows.Forms.TextBox();\n            this.ServerPortTextBox = new System.Windows.Forms.TextBox();\n            this.PasswordTextBox = new System.Windows.Forms.TextBox();\n            this.ProxyPortTextBox = new System.Windows.Forms.TextBox();
            this.OKButton = new System.Windows.Forms.Button();\n            this.MyCancelButton = new System.Windows.Forms.Button();
            this.tableLayoutPanel2 = new System.Windows.Forms.TableLayoutPanel();\n            this.listView1 = new System.Windows.Forms.ListView();\n            this.tableLayoutPanel3 = new System.Windows.Forms.TableLayoutPanel();
            this.tableLayoutPanel1.Controls.Add(this.EncryptionSelect, 1, 4);
            this.tableLayoutPanel1.Controls.Add(this.IPTextBox, 1, 0);\n            this.tableLayoutPanel1.Controls.Add(this.ServerPortTextBox, 1, 1);\n            this.tableLayoutPanel1.Controls.Add(this.PasswordTextBox, 1, 2);\n            this.tableLayoutPanel1.Controls.Add(this.ProxyPortTextBox, 1, 3);\n            this.tableLayoutPanel1.Location = new System.Drawing.Point(246, 10);
            // EncryptionSelect\n            // \n            this.EncryptionSelect.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) \n            | System.Windows.Forms.AnchorStyles.Right)));\n            this.EncryptionSelect.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;\n            this.EncryptionSelect.FormattingEnabled = true;\n            this.EncryptionSelect.ImeMode = System.Windows.Forms.ImeMode.NoControl;\n            this.EncryptionSelect.ItemHeight = 13;\n            this.EncryptionSelect.Items.AddRange(new object[] {
            // OKButton\n            // \n            this.OKButton.DialogResult = System.Windows.Forms.DialogResult.OK;\n            this.OKButton.Location = new System.Drawing.Point(4, 4);\n            this.OKButton.Name = "OKButton";\n            this.OKButton.Size = new System.Drawing.Size(75, 23);\n            this.OKButton.TabIndex = 0;\n            this.OKButton.Text = "OK";\n            this.OKButton.UseVisualStyleBackColor = true;\n            this.OKButton.Click += new System.EventHandler(this.OKButton_Click);\n            // \n            // MyCancelButton\n            // \n            this.MyCancelButton.DialogResult = System.Windows.Forms.DialogResult.Cancel;\n            this.MyCancelButton.Location = new System.Drawing.Point(86, 4);\n            this.MyCancelButton.Name = "MyCancelButton";\n            this.MyCancelButton.Size = new System.Drawing.Size(75, 23);\n            this.MyCancelButton.TabIndex = 1;\n            this.MyCancelButton.Text = "Cancel";\n            this.MyCancelButton.UseVisualStyleBackColor = true;\n            this.MyCancelButton.Click += new System.EventHandler(this.CancelButton_Click);
            this.panel1.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) \n            | System.Windows.Forms.AnchorStyles.Right)));
            this.panel1.Controls.Add(this.MyCancelButton);\n            this.panel1.Controls.Add(this.OKButton);\n            this.panel1.Location = new System.Drawing.Point(311, 205);
            this.aboutItem.Click += new System.EventHandler(this.AboutItem_Click);
            this.ClientSize = new System.Drawing.Size(502, 272);\n            this.Controls.Add(this.tableLayoutPanel3);
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedSingle;
            this.FormClosed += new System.Windows.Forms.FormClosedEventHandler(this.ConfigForm_FormClosed);\n            this.Load += new System.EventHandler(this.CinfigForm_Load);
        private System.Windows.Forms.TextBox IPTextBox;\n        private System.Windows.Forms.TextBox ServerPortTextBox;\n        private System.Windows.Forms.TextBox PasswordTextBox;\n        private System.Windows.Forms.TextBox ProxyPortTextBox;
        private System.Windows.Forms.ComboBox EncryptionSelect;
        private System.Windows.Forms.Button OKButton;\n        private System.Windows.Forms.Button MyCancelButton;






                        registry.SetValue("ProxyServer", "");
                    registry.SetValue("ProxyServer", "");
                server_port = int.Parse(afterAt.Substring(indexLastColon + 1));\n                server = afterAt.Substring(0, indexLastColon);
                method = parts[0];\n                password = parts[1];





                if (config.index == -1 && config.strategy == null)\n                    config.index = 0;





            if (config.index == -1 && config.strategy == null)\n                config.index = 0;













                arguments = global\n                    ? $"global {proxyServer} <local>;localhost;127.*;10.*;172.16.*;172.17.*;172.18.*;172.19.*;172.20.*;172.21.*;172.22.*;172.23.*;172.24.*;172.25.*;172.26.*;172.27.*;172.28.*;172.29.*;172.30.*;172.31.*;172.32.*;192.168.*"\n                    : $"pac {pacURL}";
                // restore user settings\n                var flags = _userSettings[0];\n                var proxy_server = _userSettings[1] ?? "-";\n                var bypass_list = _userSettings[2] ?? "-";\n                var pac_url = _userSettings[3] ?? "-";\n                arguments = $"set {flags} {proxy_server} {bypass_list} {pac_url}";\n                // have to get new settings\n                _userSettingsRecorded = false;
                var stderr = process.StandardError.ReadToEnd();\n                var stdout = process.StandardOutput.ReadToEnd();
                    throw new ProxyException(stderr);
                        Sysproxy.SetIEProxy(true, false, null, pacUrl);
                    Sysproxy.SetIEProxy(false, false, null, null);
                            // we need to drop connections when changing servers\n                            /* if (kv[1].IndexOf("Chrome") >= 0)
                            } */
                SystemProxy.Update(_config, false);
                    SystemProxy.Update(_config, false);
        public static void Update(Configuration config, bool forceDisable)
                if (enabled)
                    if (global)\n                    {\n                        registry.SetValue("ProxyEnable", 1);\n                        registry.SetValue("ProxyServer", "127.0.0.1:" + config.localPort.ToString());\n                        registry.SetValue("AutoConfigURL", "");\n                    }\n                    else\n                    {\n                        registry.SetValue("ProxyEnable", 0);\n                        registry.SetValue("ProxyServer", "");\n                        registry.SetValue("AutoConfigURL", "http://127.0.0.1:" + config.localPort.ToString() + "/pac?t=" + GetTimestamp(DateTime.Now));\n                    }
                    registry.SetValue("AutoConfigURL", "");

                    LogMessageTextBox.AppendText(line + "\r\n");
                    LogMessageTextBox.ScrollToCaret();
        private void OpenLocationMenuItem_Click(object sender, EventArgs e)
        private void ExitMenuItem_Click(object sender, EventArgs e)
            LogMessageTextBox.ScrollToCaret();\n        }\n        private void WrapTextCheckBox_CheckedChanged(object sender, EventArgs e)\n        {\n            LogMessageTextBox.WordWrap = WrapTextCheckBox.Checked;\n            LogMessageTextBox.ScrollToCaret();\n        }\n        private void CleanLogsButton_Click(object sender, EventArgs e)\n        {\n            LogMessageTextBox.Clear();\n        }\n        private void ChangeFontButton_Click(object sender, EventArgs e)\n        {\n            FontDialog fd = new FontDialog();\n            fd.Font = LogMessageTextBox.Font;\n            if (fd.ShowDialog() == DialogResult.OK)\n            {\n                LogMessageTextBox.Font = fd.Font;\n            }\n        }\n        private void TopMostCheckBox_CheckedChanged(object sender, EventArgs e)\n        {\n            this.TopMost = TopMostCheckBox.Checked;
            this.LogMessageTextBox = new System.Windows.Forms.TextBox();
            this.FileMenuItem = new System.Windows.Forms.MenuItem();\n            this.OpenLocationMenuItem = new System.Windows.Forms.MenuItem();\n            this.ExitMenuItem = new System.Windows.Forms.MenuItem();\n            this.panel1 = new System.Windows.Forms.Panel();\n            this.ChangeFontButton = new System.Windows.Forms.Button();\n            this.CleanLogsButton = new System.Windows.Forms.Button();\n            this.WrapTextCheckBox = new System.Windows.Forms.CheckBox();\n            this.tableLayoutPanel1 = new System.Windows.Forms.TableLayoutPanel();\n            this.TopMostCheckBox = new System.Windows.Forms.CheckBox();\n            this.panel1.SuspendLayout();\n            this.tableLayoutPanel1.SuspendLayout();
            this.FileMenuItem});
            this.FileMenuItem.Index = 0;\n            this.FileMenuItem.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {\n            this.OpenLocationMenuItem,\n            this.ExitMenuItem});\n            this.FileMenuItem.Text = "&File";
            this.OpenLocationMenuItem.Index = 0;\n            this.OpenLocationMenuItem.Text = "&Open Location";\n            this.OpenLocationMenuItem.Click += new System.EventHandler(this.OpenLocationMenuItem_Click);
            this.ClientSize = new System.Drawing.Size(547, 353);\n            this.Controls.Add(this.tableLayoutPanel1);

        private System.Windows.Forms.TextBox LogMessageTextBox;
        private System.Windows.Forms.MenuItem FileMenuItem;\n        private System.Windows.Forms.MenuItem OpenLocationMenuItem;\n        private System.Windows.Forms.MenuItem ExitMenuItem;\n        private System.Windows.Forms.Panel panel1;\n        private System.Windows.Forms.CheckBox WrapTextCheckBox;\n        private System.Windows.Forms.Button CleanLogsButton;\n        private System.Windows.Forms.Button ChangeFontButton;\n        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel1;\n        private System.Windows.Forms.CheckBox TopMostCheckBox;
                throw new Exception(I18N.GetString("assertion failure"));
                throw new ArgumentException(I18N.GetString("Port out of range"));
                throw new ArgumentException(I18N.GetString("Password can not be blank"));
                throw new ArgumentException(I18N.GetString("Server IP can not be blank"));
        public event EventHandler<ResultEventArgs> UpdateCompleted;
                    UpdateCompleted(this, new ResultEventArgs(true));
                LogFilePath = Utils.GetTempPath("shadowsocks.log");\n                FileStream fs = new FileStream(LogFilePath, FileMode.Append);
            if (length > 0)\n            {\n                // process first package\n                Array.Copy(firstPackge, index, _lineBuffer, 0, length);\n                _bufferDataLength = length;\n                try\n                {\n                    NewPackageRecv();\n                }\n                catch (Exception ex)\n                {\n                    OnException(ex);\n                    OnFinish();\n                }\n            }\n            else\n            {\n                // start reading\n                socket.BeginReceive(_lineBuffer, 0, maxLineBytes, 0, ReceiveCallback, 0);\n            }\n        }\n        public LineReader(WrappedSocket socket, Func<string, object, bool> onLineRead,\n            Action<Exception, object> onException,\n            Action<byte[], int, int, object> onFinish, Encoding encoding, string delimiter, int maxLineBytes,\n            object state)\n            : this(socket, null, 0, 0, onLineRead, onException, onFinish, encoding, delimiter, maxLineBytes, state)\n        {

                    OnFinish();
                _bufferDataLength += bytesRead;\n                NewPackageRecv();\n            }\n            catch (Exception ex)\n            {\n                OnException(ex);\n                OnFinish();\n            }\n        }\n        private void NewPackageRecv()\n        {\n            int i;\n            while ((i = IndexOf(_lineBuffer, _bufferDataIndex, _bufferDataLength, _delimiterBytes, _delimiterSearchOffsetTable,\n                       _delimiterSearchCharTable)) != -1)\n            {\n                var decodeLen = i - _bufferDataIndex;\n                string line = _encoding.GetString(_lineBuffer, _bufferDataIndex, decodeLen);\n                _bufferDataIndex = i + _delimiterBytes.Length;\n                _bufferDataLength -= decodeLen;\n                _bufferDataLength -= _delimiterBytes.Length;\n                var stop = _onLineRead(line, _state);\n                if (stop)\n                {\n                    OnFinish();
            }\n            if (_bufferDataLength == _lineBuffer.Length)\n            {\n                OnException(new IndexOutOfRangeException("LineBuffer full! Try increace maxLineBytes!"));\n                OnFinish();\n                return;\n            }\n            if (_bufferDataIndex > 0)\n            {\n                Buffer.BlockCopy(_lineBuffer, _bufferDataIndex, _lineBuffer, 0, _bufferDataLength);\n                _bufferDataIndex = 0;\n            }\n            _socket.BeginReceive(_lineBuffer, _bufferDataLength, _lineBuffer.Length - _bufferDataLength, 0, ReceiveCallback, _bufferDataLength);
        private void OnFinish()\n        {\n            _onFinish?.Invoke(_lineBuffer, _bufferDataIndex, _bufferDataLength, _state);
        private static int IndexOf(byte[] haystack, int index, int length, byte[] needle, int[] offsetTable, int[] charTable)


                MessageBox.Show( I18N.GetString( "Failed to update registry" ) );\n            } finally {\n                if ( registry != null ) {\n                    try { registry.Close(); }\n                    catch (Exception e)\n                    { Logging.LogUsefulException(e); }\n                }
            RegistryKey registry = null;\n            try {\n                registry = Utils.OpenUserRegKey( @"Software\Microsoft\Windows\CurrentVersion\Internet Settings\Connections", true );\n                if ( registry == null ) {\n                    Logging.Error( @"Cannot find HKCU\Software\Microsoft\Windows\CurrentVersion\Internet Settings" );\n                    return;\n                }\n                var defaultValue = registry.GetValue( "DefaultConnectionSettings" );
            } catch ( IOException e ) {\n                Logging.LogUsefulException( e );\n            } finally {\n                if ( registry != null ) {\n                    try { registry.Close(); }\n                    catch (Exception e)\n                    { Logging.LogUsefulException(e); }\n                }
            RegistryKey registry = null;\n            try {\n                registry = Utils.OpenUserRegKey( @"Software\Microsoft\Windows\CurrentVersion\Internet Settings\Connections", true );\n                if ( registry == null ) {\n                    Logging.Error( @"Cannot find HKCU\Software\Microsoft\Windows\CurrentVersion\Internet Settings" );\n                    return;\n                }\n                var defConnection = ( byte[] ) registry.GetValue( "DefaultConnectionSettings" );\n                var savedLegacySetting = ( byte[] ) registry.GetValue( "SavedLegacySettings" );\n                const int versionOffset = 4;\n                const int optionsOffset = 8;\n                if ( set ) {\n                    defConnection[ optionsOffset ] = ( byte ) ( defConnection[ optionsOffset ] | 8 );\n                    savedLegacySetting[ optionsOffset ] = ( byte ) ( savedLegacySetting[ optionsOffset ] | 8 );\n                } else {\n                    defConnection[ optionsOffset ] = ( byte ) ( defConnection[ optionsOffset ] & ~8 );\n                    savedLegacySetting[ optionsOffset ] = ( byte ) ( savedLegacySetting[ optionsOffset ] & ~8 );\n                }\n                BitConverter.GetBytes(unchecked( BitConverter.ToUInt32( defConnection, versionOffset ) + 1 ) )\n                            .CopyTo( defConnection, versionOffset );\n                BitConverter.GetBytes(unchecked( BitConverter.ToUInt32( savedLegacySetting, versionOffset ) + 1 ) )\n                            .CopyTo( savedLegacySetting, versionOffset );\n                registry.SetValue( "DefaultConnectionSettings", defConnection );\n                registry.SetValue( "SavedLegacySettings", savedLegacySetting );\n            } catch ( Exception e ) {\n                Logging.LogUsefulException( e );\n            } finally {\n                if (registry != null)\n                {\n                    try { registry.Close(); }\n                    catch (Exception e)\n                    { Logging.LogUsefulException(e); }\n                }

            string pipename = $"Shadowsocks\\{Application.StartupPath.GetHashCode()}";\n            using (NamedPipeClientStream pipe = new NamedPipeClientStream(pipename))
                bool pipeExist = false;\n                try\n                {\n                    pipe.Connect(10);\n                    pipeExist = true;\n                }\n                catch (TimeoutException)\n                {\n                    pipeExist = false;\n                }\n                var alist = Args.ToList();\n                int urlidx = alist.IndexOf("--open-url") + 1;\n                if (urlidx > 0)\n                {\n                    if (Args.Length <= urlidx) return;\n                    if (!pipeExist) return;\n                    byte[] b = Encoding.UTF8.GetBytes(Args[urlidx]);\n                    byte[] blen = BitConverter.GetBytes(IPAddress.HostToNetworkOrder(b.Length));\n                    pipe.Write(blen, 0, 4);\n                    pipe.Write(b, 0, b.Length);\n                    pipe.Close();\n                    return;\n                }\n                else if (pipeExist)
            }\n            Task.Run(() => new PipeServer().Run(pipename));\n            Utils.ReleaseMemory(true);\n            Application.SetUnhandledExceptionMode(UnhandledExceptionMode.CatchException);\n            // handle UI exceptions\n            Application.ThreadException += Application_ThreadException;\n            // handle non-UI exceptions\n            AppDomain.CurrentDomain.UnhandledException += CurrentDomain_UnhandledException;\n            Application.ApplicationExit += Application_ApplicationExit;\n            SystemEvents.PowerModeChanged += SystemEvents_PowerModeChanged;\n            Application.EnableVisualStyles();\n            Application.SetCompatibleTextRenderingDefault(false);\n            AutoStartup.RegisterForRestart(true);\n            Directory.SetCurrentDirectory(Application.StartupPath);
            MainController = new ShadowsocksController();\n            MenuController = new MenuViewController(MainController);\n            HotKeys.Init(MainController);\n            MainController.Start();\n            Application.Run();
            speedSeries.XValueMember = "Timestamp";\n            speedSeries.YValueMembers = "Speed";\n            // might be empty\n            _dataTable.Columns.Add("Package Loss", typeof (int));\n            _dataTable.Columns.Add("Ping", typeof (int));\n            packageLossSeries.XValueMember = "Timestamp";\n            packageLossSeries.YValueMembers = "Package Loss";\n            pingSeries.XValueMember = "Timestamp";\n            pingSeries.YValueMembers = "Ping";
                                Speed = dataGroup.Max(data => data.MaxInboundSpeed) ?? 0,\n                                Ping = (int) (dataGroup.Average(data => data.AverageResponse) ?? 0),\n                                PackageLossPercentage = (dataGroup.Average(data => data.PackageLoss) ?? 0) * 100\n                            };
                _dataTable.Rows.Add(data.Timestamp, data.Speed, data.PackageLossPercentage, data.Ping);
        private void serverSelector_SelectionChangeCommitted(object sender, EventArgs e)


            series1.Color = System.Drawing.Color.DarkGray;
            series1.Name = "Speed";\n            series1.ToolTip = "Max inbound speed\\n#VAL KiB/s";
            series2.ChartType = System.Windows.Forms.DataVisualization.Charting.SeriesChartType.Bubble;\n            series2.Color = System.Drawing.Color.Crimson;\n            series2.CustomProperties = "EmptyPointValue=Zero";
            series2.Name = "Package Loss";\n            series2.ToolTip = "#VAL%";\n            series2.YAxisType = System.Windows.Forms.DataVisualization.Charting.AxisType.Secondary;\n            series2.YValuesPerPoint = 2;\n            series3.BorderWidth = 5;
            series3.ChartType = System.Windows.Forms.DataVisualization.Charting.SeriesChartType.Line;\n            series3.Color = System.Drawing.Color.DodgerBlue;
            series3.MarkerSize = 10;\n            series3.MarkerStyle = System.Windows.Forms.DataVisualization.Charting.MarkerStyle.Circle;\n            series3.Name = "Ping";\n            series3.ToolTip = "#VAL ms";








    public class GeositeResultEventArgs : EventArgs\n    {\n        public bool Success;\n        public GeositeResultEventArgs(bool success)\n        {\n            this.Success = success;\n        }\n    }\n    public static class GeositeUpdater
        public static event EventHandler<GeositeResultEventArgs> UpdateCompleted;
                Console.WriteLine(e);
        private Delegate GetDelegateViaMethodName(string methodname)\n        {
            MethodInfo dynMethod = typeof(HotkeyCallbacks).GetMethod(methodname,
            return dynMethod == null ? null : Delegate.CreateDelegate(typeof(HotKeys.HotKeyCallBackHandler), HotkeyCallbacks.Instance, dynMethod);

namespace Shadowsocks.Controller.Hotkeys
        public static void Init(ShadowsocksController controller)
                            Color flyBlue = Color.FromArgb(192, 192, 192, 192);
                            int alpha = color.A * flyBlue.A / 255;\n                            iconCopy.SetPixel(x, y, Color.FromArgb(alpha, red, green, blue));



        private static extern IntPtr CreateJobObject(IntPtr a, string lpName);
        private static extern bool SetInformationJobObject(IntPtr hJob, JobObjectInfoType infoType, IntPtr lpJobObjectInfo, UInt32 cbJobObjectInfoLength);
        private static extern bool AssignProcessToJobObject(IntPtr job, IntPtr process);
        private static extern bool CloseHandle(IntPtr hObject);
            try\n            {\n                int length = Marshal.SizeOf(typeof(JOBOBJECT_EXTENDED_LIMIT_INFORMATION));\n                extendedInfoPtr = Marshal.AllocHGlobal(length);\n                Marshal.StructureToPtr(extendedInfo, extendedInfoPtr, false);\n                if (!SetInformationJobObject(handle, JobObjectInfoType.ExtendedLimitInformation, extendedInfoPtr,\n                        (uint) length))\n                    throw new Exception(string.Format("Unable to set information.  Error: {0}",\n                        Marshal.GetLastWin32Error()));\n            }\n            finally\n            {\n                if (extendedInfoPtr != IntPtr.Zero)\n                {\n                    Marshal.FreeHGlobal(extendedInfoPtr);\n                    extendedInfoPtr = IntPtr.Zero;\n                }\n            }
            loadConfiguration(modifiedConfiguration);\n            oldSelectedIndex = modifiedConfiguration.index;
            loadSelectedServer();

﻿using System;

                OpenSSL.RAND_bytes(iv, iv.Length);
                int outLen = length + ivLen;
                OpenSSL.EVP_CipherUpdate(_encryptCtx, cipherText, out outLen, buf, length);
                int outLen = length + ivLen;
                OpenSSL.EVP_CipherUpdate(_encryptCtx, cipherText, out outLen, buf, length);

                int outLen = length + ivLen;
                OpenSSL.EVP_CipherUpdate(_decryptCtx, cipherText, out outLen, subset, length - ivLen);
                int outLen = length + ivLen;
                OpenSSL.EVP_CipherUpdate(_decryptCtx, cipherText, out outLen, buf, length);



            else
                byte[] passbuf = Encoding.UTF8.GetBytes(password);\n                _key = new byte[32];\n                byte[] iv = new byte[16];\n                OpenSSL.EVP_BytesToKey(_cipher, OpenSSL.EVP_md5(), IntPtr.Zero, passbuf, passbuf.Length, 1, _key, iv);\n                CachedKeys[k] = _key;

            ctx = OpenSSL.EVP_CIPHER_CTX_new();
            OpenSSL.EVP_CipherInit_ex(ctx, _cipher, IntPtr.Zero, _key, iv, enc);
            privoxyRunner = privoxyRunner ?? new PrivoxyRunner();\n            _pacDaemon = _pacDaemon ?? new PACDaemon();\n            _pacDaemon.PACFileChanged += PacDaemon_PACFileChanged;\n            _pacDaemon.UserRuleFileChanged += PacDaemon_UserRuleFileChanged;\n            _pacServer = _pacServer ?? new PACServer(_pacDaemon);\n            gfwListUpdater = gfwListUpdater ?? new GFWListUpdater();\n            gfwListUpdater.UpdateCompleted += PacServer_PACUpdateCompleted;\n            gfwListUpdater.Error += PacServer_PACUpdateError;
            _listener?.Stop();
                strategy?.ReloadServers();
namespace Shadowsocks.Controller\n{\n    class AutoStartup\n    {\n        public static bool Set(bool enabled)\n        {\n            try\n            {\n                string path = Application.ExecutablePath;\n                RegistryKey runKey = Microsoft.Win32.Registry.CurrentUser.OpenSubKey(@"Software\Microsoft\Windows\CurrentVersion\Run", true);\n                if (enabled)\n                {\n                    runKey.SetValue("Shadowsocks", path);\n                }\n                else\n                {\n                    runKey.DeleteValue("Shadowsocks");\n                }\n                runKey.Close();\n                return true;
                return false;\n            }\n        }\n        public static bool Check()\n        {\n            try\n            {\n                string path = Application.ExecutablePath;\n                RegistryKey runKey = Microsoft.Win32.Registry.CurrentUser.OpenSubKey(@"Software\Microsoft\Windows\CurrentVersion\Run");\n                string[] runList = runKey.GetValueNames();\n                runKey.Close();\n                foreach (string item in runList)\n                {\n                    if (item.Equals("Shadowsocks"))\n                        return true;\n                }\n                return false;\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                return false;\n            }\n        }\n    }


                catch (Exception e)
            string serverStr = $"{FormatHostName(server)}:{server_port}";

        public static void Update(Configuration config, bool forceDisable, PACServer pacSrv, bool noRetry = false)

                if (ex.Type != ProxyExceptionType.Unspecific && !noRetry)
                    var ret = MessageBox.Show(I18N.GetString("Error occured when process proxy setting, do you want reset current setting and retry?"), I18N.GetString("Shadowsocks"), MessageBoxButtons.YesNo, MessageBoxIcon.Warning);\n                    if (ret == DialogResult.Yes)\n                    {\n                        Sysproxy.ResetIEProxy();\n                        Update(config, forceDisable, pacSrv, true);\n                    }\n                }\n                else\n                {\n                    MessageBox.Show(I18N.GetString("Unrecoverable proxy setting error occured, see log for detail"), I18N.GetString("Shadowsocks"), MessageBoxButtons.OK, MessageBoxIcon.Error);
        public static void UpdateIE()

        public static void Enable()\n        {\n            RegistryKey registry = Registry.CurrentUser.OpenSubKey("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings", true);\n            registry.SetValue("ProxyEnable", 1);\n            registry.SetValue("ProxyServer", "127.0.0.1:8123");\n            SystemProxy.UpdateIE();\n        }\n        public static void Disable()
            SystemProxy.UpdateIE();
    using Statistics = Dictionary<string, List<AvailabilityStatistics.RawStatisticsData>>;
        public Statistics RawStatistics { get; private set; }\n        public Statistics FilteredStatistics { get; private set; }\n        private int Repeat => _config.RepeatTimesNum;
                    var reply = await ping.SendTaskAsync(IP, Timeout);
                    Thread.Sleep(Timeout + new Random().Next() % Timeout);

            this.PingCheckBox = new System.Windows.Forms.CheckBox();

        private System.Windows.Forms.CheckBox PingCheckBox;



            UnknownDateTime = new DateTime(1970, 1, 1);\n        }\n        //arguments for ICMP tests\n        private int Repeat => Config.RepeatTimesNum;\n        private const int TimeoutMilliseconds = 500;\n        //records cache for current server in {_monitorInterval} minutes\n        private List<int> _latencyRecords;\n        //speed in KiB/s\n        private long _lastInboundCounter;\n        private List<int> _inboundSpeedRecords;\n        private long _lastOutboundCounter;\n        private List<int> _outboundSpeedRecords;\n        //tasks\n        private readonly TimeSpan _delayBeforeStart = TimeSpan.FromSeconds(1);\n        private readonly TimeSpan _retryInterval = TimeSpan.FromMinutes(2);\n        private Timer _recorder; //analyze and save cached records to RawStatistics and filter records\n        private TimeSpan RecordingInterval => TimeSpan.FromMinutes(Config.DataCollectionMinutes);\n        private Timer _speedMonior;\n        private readonly TimeSpan _monitorInterval = TimeSpan.FromSeconds(1);\n        private Timer _writer; //write RawStatistics to file\n        private readonly TimeSpan _writingInterval = TimeSpan.FromMinutes(1);\n        private ShadowsocksController _controller;\n        private StatisticsStrategyConfiguration Config => _controller.StatisticsConfiguration;\n        private Server CurrentServer => _controller.GetCurrentServer();
        private AvailabilityStatistics()\n        {\n            RawStatistics = new Statistics();\n        }\n        internal void UpdateConfiguration(ShadowsocksController controller)\n        {\n            _controller = controller;\n            Reset();\n            try\n            {\n                if (Config.StatisticsEnabled)\n                {\n                    StartTimerWithoutState(ref _recorder, Run, RecordingInterval);
                    StartTimerWithoutState(ref _speedMonior, UpdateSpeed, _monitorInterval);\n                    StartTimerWithoutState(ref _writer, Save, _writingInterval);
                    _writer?.Dispose();\n                }
            }\n        }\n        private void StartTimerWithoutState(ref Timer timer, TimerCallback callback, TimeSpan interval)\n        {\n            if (timer?.Change(_delayBeforeStart, interval) == null)\n            {\n                timer = new Timer(callback, null, _delayBeforeStart, interval);\n            }\n        }\n        private void UpdateSpeed(object _)
            UpdateRecords();
        private async void UpdateRecords()\n        {\n            var currentServerRecord = new StatisticsRecord(CurrentServer.Identifier(), _inboundSpeedRecords, _outboundSpeedRecords, _latencyRecords);\n            if (!Config.Ping)\n            {\n                AppendRecord(CurrentServer, currentServerRecord);\n                return;\n            }\n            var icmpResults = TaskEx.WhenAll(_controller.GetCurrentConfiguration().configs.Select(ICMPTest));
                if (result.Server.Equals(CurrentServer))
                    AppendRecord(CurrentServer, currentServerRecord);
                    AppendRecord(result.Server, new StatisticsRecord(result.Server.Identifier(), result.RoundtripTime));\n                }\n            }\n        }\n        private void AppendRecord(Server server, StatisticsRecord record)\n        {\n            List<StatisticsRecord> records;\n            if (!RawStatistics.TryGetValue(server.Identifier(), out records))\n            {\n                records = new List<StatisticsRecord>();\n            }\n            records.Add(record);\n            RawStatistics[server.Identifier()] = records;

            if (Config.ByHourOfDay)\n            {
            if (_currentServer == null)

        #region Clean up the content in LogMessageTextBox.\n        private void DoCleanLogs()\n        {\n            LogMessageTextBox.Clear();\n        }\n        private void CleanLogsMenuItem_Click(object sender, EventArgs e)\n        {\n            DoCleanLogs();
            DoCleanLogs();\n        }\n        #endregion\n        #region Change the font settings applied in LogMessageTextBox.\n        private void DoChangeFont()
            if (!TopMostTriggerLock)\n            {\n                TriggerTopMost();\n            }\n        }\n        private void TopMostMenuItem_Click(object sender, EventArgs e)\n        {\n            if (!TopMostTriggerLock)\n            {\n                TriggerTopMost();\n            }\n        }\n        #endregion\n        private bool ShowToolbarTrigger = false;\n        private void ShowToolbarMenuItem_Click(object sender, EventArgs e)\n        {\n            ShowToolbarTrigger = !ShowToolbarTrigger;\n            ToolbarFlowLayoutPanel.Visible = ShowToolbarTrigger;\n            ShowToolbarMenuItem.Checked = ShowToolbarTrigger;
            this.MainMenu = new System.Windows.Forms.MainMenu(this.components);
            this.ViewMenuItem = new System.Windows.Forms.MenuItem();\n            this.CleanLogsMenuItem = new System.Windows.Forms.MenuItem();\n            this.ChangeFontMenuItem = new System.Windows.Forms.MenuItem();\n            this.WrapTextMenuItem = new System.Windows.Forms.MenuItem();\n            this.TopMostMenuItem = new System.Windows.Forms.MenuItem();\n            this.MenuItemSeparater = new System.Windows.Forms.MenuItem();\n            this.ShowToolbarMenuItem = new System.Windows.Forms.MenuItem();\n            this.TopMostCheckBox = new System.Windows.Forms.CheckBox();
            this.ToolbarFlowLayoutPanel = new System.Windows.Forms.FlowLayoutPanel();
            // ViewMenuItem\n            // \n            this.ViewMenuItem.Index = 1;\n            this.ViewMenuItem.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {\n            this.CleanLogsMenuItem,\n            this.ChangeFontMenuItem,\n            this.WrapTextMenuItem,\n            this.TopMostMenuItem,\n            this.MenuItemSeparater,\n            this.ShowToolbarMenuItem});\n            this.ViewMenuItem.Text = "&View";\n            // \n            // CleanLogsMenuItem\n            // \n            this.CleanLogsMenuItem.Index = 0;\n            this.CleanLogsMenuItem.Text = "&Clean logs";\n            this.CleanLogsMenuItem.Click += new System.EventHandler(this.CleanLogsMenuItem_Click);\n            // \n            // ChangeFontMenuItem\n            // \n            this.ChangeFontMenuItem.Index = 1;\n            this.ChangeFontMenuItem.Text = "Change &font";\n            this.ChangeFontMenuItem.Click += new System.EventHandler(this.ChangeFontMenuItem_Click);\n            // \n            // WrapTextMenuItem\n            // \n            this.WrapTextMenuItem.Index = 2;\n            this.WrapTextMenuItem.Text = "&Wrap text";\n            this.WrapTextMenuItem.Click += new System.EventHandler(this.WrapTextMenuItem_Click);\n            // \n            // TopMostMenuItem\n            // \n            this.TopMostMenuItem.Index = 3;\n            this.TopMostMenuItem.Text = "&Top most";\n            this.TopMostMenuItem.Click += new System.EventHandler(this.TopMostMenuItem_Click);\n            // \n            // MenuItemSeparater\n            // \n            this.MenuItemSeparater.Index = 4;\n            this.MenuItemSeparater.Text = "-";\n            // \n            // ShowToolbarMenuItem\n            // \n            this.ShowToolbarMenuItem.Index = 5;\n            this.ShowToolbarMenuItem.Text = "&Show toolbar";\n            this.ShowToolbarMenuItem.Click += new System.EventHandler(this.ShowToolbarMenuItem_Click);\n            // \n            // TopMostCheckBox\n            // \n            this.TopMostCheckBox.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) \n            | System.Windows.Forms.AnchorStyles.Left)));\n            this.TopMostCheckBox.AutoSize = true;\n            this.TopMostCheckBox.Location = new System.Drawing.Point(249, 3);\n            this.TopMostCheckBox.Name = "TopMostCheckBox";\n            this.TopMostCheckBox.Size = new System.Drawing.Size(72, 23);\n            this.TopMostCheckBox.TabIndex = 3;\n            this.TopMostCheckBox.Text = "&Top most";\n            this.TopMostCheckBox.UseVisualStyleBackColor = true;\n            this.TopMostCheckBox.CheckedChanged += new System.EventHandler(this.TopMostCheckBox_CheckedChanged);
            this.ChangeFontButton.AutoSize = true;\n            this.ChangeFontButton.Location = new System.Drawing.Point(84, 3);
            this.CleanLogsButton.AutoSize = true;\n            this.CleanLogsButton.Location = new System.Drawing.Point(3, 3);

            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.Size = new System.Drawing.Size(590, 418);
            // ToolbarFlowLayoutPanel\n            // \n            this.ToolbarFlowLayoutPanel.AutoSize = true;\n            this.ToolbarFlowLayoutPanel.Controls.Add(this.CleanLogsButton);\n            this.ToolbarFlowLayoutPanel.Controls.Add(this.ChangeFontButton);\n            this.ToolbarFlowLayoutPanel.Controls.Add(this.WrapTextCheckBox);\n            this.ToolbarFlowLayoutPanel.Controls.Add(this.TopMostCheckBox);\n            this.ToolbarFlowLayoutPanel.Dock = System.Windows.Forms.DockStyle.Fill;\n            this.ToolbarFlowLayoutPanel.Location = new System.Drawing.Point(3, 3);\n            this.ToolbarFlowLayoutPanel.Name = "ToolbarFlowLayoutPanel";\n            this.ToolbarFlowLayoutPanel.Size = new System.Drawing.Size(584, 29);\n            this.ToolbarFlowLayoutPanel.TabIndex = 2;

        private System.Windows.Forms.MainMenu MainMenu;

        private readonly int _targetPort;
            _targetPort = targetPort;
            new Handler().Start(firstPacket, length, socket, _targetPort);
        private class Handler
            private const int RecvSize = 2048;
                _firstPacket = firstPacket;\n                _firstPacketLength = length;\n                _local = socket;
                    Close();
                        PipeRemoteReceiveCallback, null);
                        PipeConnectionReceiveCallback, null);\n                }\n                catch (Exception e)\n                {\n                    Logging.LogUsefulException(e);\n                    Close();
                    _remote.BeginReceive(remoteRecvBuffer, 0, RecvSize, 0,\n                        PipeRemoteReceiveCallback, null);\n                }\n                catch (Exception e)\n                {\n                    Logging.LogUsefulException(e);\n                    Close();
                    Close();
            if (!CachedKeys.ContainsKey(k))\n            {\n                lock (CachedKeys)\n                {\n                    if (!CachedKeys.ContainsKey(k))\n                    {\n                        byte[] passbuf = Encoding.UTF8.GetBytes(password);\n                        _key = new byte[32];\n                        byte[] iv = new byte[16];\n                        bytesToKey(passbuf, _key);\n                        CachedKeys[k] = _key;\n                    }\n                }\n            }\n            if (_key == null)

namespace Shadowsocks.ForwardProxy
    public class DirectConnect : IForwardProxy
namespace Shadowsocks.ForwardProxy
    public class HttpProxy : IForwardProxy

namespace Shadowsocks.ForwardProxy
    public interface IForwardProxy
namespace Shadowsocks.ForwardProxy
    public class Socks5Proxy : IForwardProxy
            this.components = new System.ComponentModel.Container();\n            System.Windows.Forms.DataVisualization.Charting.ChartArea chartArea2 = new System.Windows.Forms.DataVisualization.Charting.ChartArea();\n            System.Windows.Forms.DataVisualization.Charting.Legend legend2 = new System.Windows.Forms.DataVisualization.Charting.Legend();\n            System.Windows.Forms.DataVisualization.Charting.Series series4 = new System.Windows.Forms.DataVisualization.Charting.Series();\n            System.Windows.Forms.DataVisualization.Charting.Series series5 = new System.Windows.Forms.DataVisualization.Charting.Series();\n            System.Windows.Forms.DataVisualization.Charting.Series series6 = new System.Windows.Forms.DataVisualization.Charting.Series();
            this.byISPCheckBox = new System.Windows.Forms.CheckBox();\n            this.bindingConfiguration = new System.Windows.Forms.BindingSource(this.components);
            this.label9 = new System.Windows.Forms.Label();\n            this.label8 = new System.Windows.Forms.Label();\n            this.dataCollectionMinutesNum = new System.Windows.Forms.NumericUpDown();\n            this.StatisticsEnabledCheckBox = new System.Windows.Forms.CheckBox();\n            this.choiceKeptMinutesNum = new System.Windows.Forms.NumericUpDown();\n            this.byHourOfDayCheckBox = new System.Windows.Forms.CheckBox();\n            this.repeatTimesNum = new System.Windows.Forms.NumericUpDown();
            this.calculationContainer = new System.Windows.Forms.FlowLayoutPanel();\n            this.OKButton = new System.Windows.Forms.Button();\n            this.CancelButton = new System.Windows.Forms.Button();
            ((System.ComponentModel.ISupportInitialize)(this.dataCollectionMinutesNum)).BeginInit();\n            ((System.ComponentModel.ISupportInitialize)(this.choiceKeptMinutesNum)).BeginInit();\n            ((System.ComponentModel.ISupportInitialize)(this.repeatTimesNum)).BeginInit();


            this.splitContainer2.Panel1.Controls.Add(this.label9);\n            this.splitContainer2.Panel1.Controls.Add(this.label8);\n            this.splitContainer2.Panel1.Controls.Add(this.dataCollectionMinutesNum);\n            this.splitContainer2.Panel1.Controls.Add(this.StatisticsEnabledCheckBox);\n            this.splitContainer2.Panel1.Controls.Add(this.choiceKeptMinutesNum);\n            this.splitContainer2.Panel1.Controls.Add(this.byHourOfDayCheckBox);\n            this.splitContainer2.Panel1.Controls.Add(this.repeatTimesNum);
            this.splitContainer2.Panel1.Controls.Add(this.byISPCheckBox);
            // label9\n            // \n            this.label9.AutoSize = true;\n            this.label9.Location = new System.Drawing.Point(7, 181);\n            this.label9.Margin = new System.Windows.Forms.Padding(5, 0, 5, 0);\n            this.label9.Name = "label9";\n            this.label9.Size = new System.Drawing.Size(152, 28);\n            this.label9.TabIndex = 20;\n            this.label9.Text = "Collect Data per";\n            // \n            // label8\n            // \n            this.label8.AutoSize = true;\n            this.label8.Location = new System.Drawing.Point(261, 183);\n            this.label8.Margin = new System.Windows.Forms.Padding(5, 0, 5, 0);\n            this.label8.Name = "label8";\n            this.label8.Size = new System.Drawing.Size(81, 28);\n            this.label8.TabIndex = 19;\n            this.label8.Text = "minutes";\n            // \n            // dataCollectionMinutesNum\n            // \n            this.dataCollectionMinutesNum.DataBindings.Add(new System.Windows.Forms.Binding("Value", this.bindingConfiguration, "DataCollectionMinutes", true));\n            this.dataCollectionMinutesNum.Increment = new decimal(new int[] {
            this.dataCollectionMinutesNum.Location = new System.Drawing.Point(161, 188);\n            this.dataCollectionMinutesNum.Margin = new System.Windows.Forms.Padding(3, 4, 3, 4);\n            this.dataCollectionMinutesNum.Maximum = new decimal(new int[] {\n            120,\n            0,\n            0,\n            0});\n            this.dataCollectionMinutesNum.Minimum = new decimal(new int[] {\n            5,\n            0,\n            0,\n            0});\n            this.dataCollectionMinutesNum.Name = "dataCollectionMinutesNum";\n            this.dataCollectionMinutesNum.Size = new System.Drawing.Size(92, 34);\n            this.dataCollectionMinutesNum.TabIndex = 18;\n            this.dataCollectionMinutesNum.Value = new decimal(new int[] {\n            5,\n            0,\n            0,\n            0});\n            // \n            // StatisticsEnabledCheckBox\n            // \n            this.StatisticsEnabledCheckBox.AutoSize = true;\n            this.StatisticsEnabledCheckBox.DataBindings.Add(new System.Windows.Forms.Binding("Checked", this.bindingConfiguration, "StatisticsEnabled", true));\n            this.StatisticsEnabledCheckBox.Location = new System.Drawing.Point(12, 12);\n            this.StatisticsEnabledCheckBox.Margin = new System.Windows.Forms.Padding(5, 10, 5, 10);\n            this.StatisticsEnabledCheckBox.Name = "StatisticsEnabledCheckBox";\n            this.StatisticsEnabledCheckBox.Size = new System.Drawing.Size(177, 32);\n            this.StatisticsEnabledCheckBox.TabIndex = 17;\n            this.StatisticsEnabledCheckBox.Text = "Enable Statistics";\n            this.StatisticsEnabledCheckBox.UseVisualStyleBackColor = true;\n            // \n            // choiceKeptMinutesNum\n            // \n            this.choiceKeptMinutesNum.DataBindings.Add(new System.Windows.Forms.Binding("Value", this.bindingConfiguration, "ChoiceKeptMinutes", true));\n            this.choiceKeptMinutesNum.Increment = new decimal(new int[] {\n            10,\n            0,\n            0,\n            0});\n            this.choiceKeptMinutesNum.Location = new System.Drawing.Point(161, 139);\n            this.choiceKeptMinutesNum.Margin = new System.Windows.Forms.Padding(3, 4, 3, 4);\n            this.choiceKeptMinutesNum.Maximum = new decimal(new int[] {\n            120,\n            0,\n            0,\n            0});\n            this.choiceKeptMinutesNum.Minimum = new decimal(new int[] {\n            5,\n            0,\n            0,\n            0});\n            this.choiceKeptMinutesNum.Name = "choiceKeptMinutesNum";\n            this.choiceKeptMinutesNum.Size = new System.Drawing.Size(92, 34);\n            this.choiceKeptMinutesNum.TabIndex = 16;\n            this.choiceKeptMinutesNum.Value = new decimal(new int[] {\n            5,\n            0,\n            0,\n            0});\n            // \n            // byHourOfDayCheckBox\n            // \n            this.byHourOfDayCheckBox.AutoSize = true;\n            this.byHourOfDayCheckBox.DataBindings.Add(new System.Windows.Forms.Binding("Checked", this.bindingConfiguration, "ByHourOfDay", true));\n            this.byHourOfDayCheckBox.Location = new System.Drawing.Point(12, 98);\n            this.byHourOfDayCheckBox.Margin = new System.Windows.Forms.Padding(5, 10, 5, 10);\n            this.byHourOfDayCheckBox.Name = "byHourOfDayCheckBox";\n            this.byHourOfDayCheckBox.Size = new System.Drawing.Size(165, 32);\n            this.byHourOfDayCheckBox.TabIndex = 15;\n            this.byHourOfDayCheckBox.Text = "By hour of day";\n            this.byHourOfDayCheckBox.UseVisualStyleBackColor = true;\n            // \n            // repeatTimesNum\n            // \n            this.repeatTimesNum.DataBindings.Add(new System.Windows.Forms.Binding("Value", this.bindingConfiguration, "RepeatTimesNum", true));\n            this.repeatTimesNum.Location = new System.Drawing.Point(72, 223);\n            this.repeatTimesNum.Margin = new System.Windows.Forms.Padding(3, 4, 3, 4);\n            this.repeatTimesNum.Maximum = new decimal(new int[] {\n            10,\n            0,\n            0,\n            0});\n            this.repeatTimesNum.Name = "repeatTimesNum";\n            this.repeatTimesNum.Size = new System.Drawing.Size(91, 34);\n            this.repeatTimesNum.TabIndex = 14;\n            this.repeatTimesNum.Value = new decimal(new int[] {

            ((System.ComponentModel.ISupportInitialize)(this.dataCollectionMinutesNum)).EndInit();\n            ((System.ComponentModel.ISupportInitialize)(this.choiceKeptMinutesNum)).EndInit();\n            ((System.ComponentModel.ISupportInitialize)(this.repeatTimesNum)).EndInit();

        private System.Windows.Forms.CheckBox byISPCheckBox;
        private System.Windows.Forms.FlowLayoutPanel calculationContainer;
        private System.Windows.Forms.NumericUpDown repeatTimesNum;
        private System.Windows.Forms.CheckBox byHourOfDayCheckBox;\n        private System.Windows.Forms.NumericUpDown choiceKeptMinutesNum;\n        private System.Windows.Forms.CheckBox StatisticsEnabledCheckBox;\n        private System.Windows.Forms.Label label9;\n        private System.Windows.Forms.Label label8;\n        private System.Windows.Forms.NumericUpDown dataCollectionMinutesNum;\n        private System.Windows.Forms.BindingSource bindingConfiguration;\n        private System.Windows.Forms.Button CancelButton;\n        private System.Windows.Forms.Button OKButton;
    class StatisticsStrategy : IStrategy
        public class StatisticsData\n        {\n            public int SuccessTimes;\n            public int TimedOutTimes;\n            public int AverageResponse;\n            public int MinResponse;\n            public int MaxResponse;\n        }\n        public StatisticsStrategy(ShadowsocksController controller)
        private void StatisticsStrategyOptionsItem_Click(object sender, EventArgs e)
            var statisticsStrategyOptionsForm = new StatisticsStrategyConfigurationForm(controller);
                if (_controller.GetCurrentStrategy().ID == ID && _currentServer != bestResult.server) //output when enabled\n                {  \n                    Console.WriteLine("Switch to server: {0} by package loss:{1}", bestResult.server.FriendlyName(), 1 - bestResult.score);\n                }
        public string ID
        public string Name
        public Server GetAServer(IStrategyCallerType type, IPEndPoint localIPEndPoint)
            var oldServer = _currentServer;\n            if (oldServer == null)\n            {\n                ChooseNewServer(_controller.GetCurrentConfiguration().configs);\n            }\n            if (oldServer != _currentServer)\n            {\n            }
        public void ReloadServers()
        public void SetFailure(Server server)
        public void UpdateLastRead(Server server)
        public void UpdateLastWrite(Server server)
        public void UpdateLatency(Server server, TimeSpan latency)
            Configuration.AddDefaultServerOrServer(_modifiedConfiguration);
            if (_lastSelectedIndex == -1 || _lastSelectedIndex > _modifiedConfiguration.configs.Count\n                || !ValidateAndSaveSelectedServerDetails())
                RegisterApplicationRestart(cmdline, (int)ApplicationRestartFlags.RESTART_NO_CRASH | (int)ApplicationRestartFlags.RESTART_NO_HANG);\n                Logging.Debug("Register restart after system reboot, command line:" + cmdline);
        static void Main(string[] args)
        private long compare(byte x, byte y, ulong a, int i)\n        {\n            return (long)(a % (ulong)(x + i)) - (long)(a % (ulong)(y + i));
        private byte[] mergeSort(byte[] array, ulong a, int j)
            listener = new Socket(AddressFamily.InterNetwork,
            Local local = new Local(1081);\n            local.Start();
                    strategy?.UpdateLastWrite(server);
        public const string DateTimePattern = "yyyy-MM-dd HH:mm:ss";
        private readonly TimeSpan DelayBeforeStart = TimeSpan.FromSeconds(1);
        private readonly TimeSpan RetryInterval = TimeSpan.FromMinutes(2); //retry 2 minutes after failed\n        private TimeSpan Interval => TimeSpan.FromMinutes(_config.DataCollectionMinutes);
        public AvailabilityStatistics(ShadowsocksController controller)\n        {\n            _controller = controller;\n            _globalConfig = controller.GetCurrentConfiguration();\n            UpdateConfiguration(_globalConfig, controller.StatisticsConfiguration);


            int defaultPort = 8123;\n            try
                IPGlobalProperties properties = IPGlobalProperties.GetIPGlobalProperties();\n                IPEndPoint[] tcpEndPoints = properties.GetActiveTcpListeners();\n                List<int> usedPorts = new List<int>();\n                foreach (IPEndPoint endPoint in IPGlobalProperties.GetIPGlobalProperties().GetActiveTcpListeners())\n                {\n                    usedPorts.Add(endPoint.Port);\n                }\n                for (int port = defaultPort; port < 65535; port++)\n                {\n                    if (!usedPorts.Contains(port))\n                    {\n                        return port;\n                    }\n                }
            catch (Exception e)
                // in case access denied\n                Logging.LogUsefulException(e);\n                return defaultPort;
            SwitchProxyModeTextBox.Text = config.SwitchSystemProxyMode;
            SwitchProxyModeLabel.Text = I18N.GetString("Switch system proxy mode");
        public string SwitchSystemProxyMode;
            SwitchSystemProxyMode = "";
            this.SwitchProxyModeLabel = new System.Windows.Forms.Label();
            this.SwitchProxyModeTextBox = new System.Windows.Forms.TextBox();
            this.tableLayoutPanel1.Controls.Add(this.SwitchProxyModeLabel, 0, 1);\n            this.tableLayoutPanel1.Controls.Add(this.SwitchAllowLanLabel, 0, 2);\n            this.tableLayoutPanel1.Controls.Add(this.ShowLogsLabel, 0, 3);\n            this.tableLayoutPanel1.Controls.Add(this.ServerMoveUpLabel, 0, 4);\n            this.tableLayoutPanel1.Controls.Add(this.ServerMoveDownLabel, 0, 5);\n            this.tableLayoutPanel1.Controls.Add(flowLayoutPanel1, 0, 6);
            this.tableLayoutPanel1.Controls.Add(this.SwitchProxyModeTextBox, 1, 1);\n            this.tableLayoutPanel1.Controls.Add(this.SwitchAllowLanTextBox, 1, 2);\n            this.tableLayoutPanel1.Controls.Add(this.ShowLogsTextBox, 1, 3);\n            this.tableLayoutPanel1.Controls.Add(this.ServerMoveUpTextBox, 1, 4);\n            this.tableLayoutPanel1.Controls.Add(this.ServerMoveDownTextBox, 1, 5);
        private System.Windows.Forms.Label SwitchProxyModeLabel;
        private System.Windows.Forms.TextBox SwitchProxyModeTextBox;
                runKey = Registry.CurrentUser.OpenSubKey(@"Software\Microsoft\Windows\CurrentVersion\Run", true);
                    if (item == Key)
                    else if (item == "Shadowsocks") // Compatibility with older versions





            try\n            {\n                // TODO async resolving\n                IPAddress ipAddress;\n                bool parsed = IPAddress.TryParse(config.server, out ipAddress);\n                if (!parsed)\n                {\n                    IPHostEntry ipHostInfo = Dns.GetHostEntry(config.server);\n                    ipAddress = ipHostInfo.AddressList[0];\n                }\n                IPEndPoint remoteEP = new IPEndPoint(ipAddress, config.server_port);\n                remote = new Socket(ipAddress.AddressFamily,\n                    SocketType.Stream, ProtocolType.Tcp);\n                // Connect to the remote endpoint.\n                remote.BeginConnect(remoteEP,\n                    new AsyncCallback(connectCallback), null);\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine(e.ToString());\n                this.Close();\n            }
            if (remote != null)\n            {\n                remote.Close();\n            }



                using (StreamReader sr = new StreamReader(File.OpenRead(@"config.json")))
                    Config config = SimpleJson.SimpleJson.DeserializeObject<Config>(sr.ReadToEnd());

                using (StreamWriter sw = new StreamWriter(File.Open(@"config.json", FileMode.Create)))
                    string jsonString = SimpleJson.SimpleJson.SerializeObject(new\n                    {\n                        server = config.server,\n                        server_port = config.server_port,\n                        local_port = config.local_port,\n                        password = config.password\n                    });\n                    sw.Write(jsonString);\n                    sw.Flush();
            this.contextMenu1 = new ContextMenu(new MenuItem[] {\n                this.enableItem = CreateMenuItem("Enable", new EventHandler(this.EnableItem_Click)),\n                CreateMenuGroup("Mode", new MenuItem[] {\n                    this.PACModeItem = CreateMenuItem("PAC", new EventHandler(this.PACModeItem_Click)),\n                    this.globalModeItem = CreateMenuItem("Global", new EventHandler(this.GlobalModeItem_Click))
                this.ServersItem = CreateMenuGroup("Servers", new MenuItem[] {
                    this.ConfigItem = CreateMenuItem("Edit Servers...", new EventHandler(this.Config_Click))
                this.AutoStartupItem = CreateMenuItem("Start on Boot", new EventHandler(this.AutoStartupItem_Click)),\n                this.ShareOverLANItem = CreateMenuItem("Share over LAN", new EventHandler(this.ShareOverLANItem_Click)),\n                CreateMenuItem("Edit PAC File...", new EventHandler(this.EditPACFileItem_Click)),
                CreateMenuItem("Show QRCode...", new EventHandler(this.QRCodeItem_Click)),\n                CreateMenuItem("Show Logs...", new EventHandler(this.ShowLogItem_Click)),\n                CreateMenuItem("About...", new EventHandler(this.Config_Click)),
                CreateMenuItem("Quit", new EventHandler(this.Quit_Click))
                Logging.LogUsefulException(e);

            md5(input, (uint)input.Length, output);
        public static extern IntPtr cipher_info_from_string(string cipher_name);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public static extern void cipher_init(IntPtr ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public static extern int cipher_setup(IntPtr ctx, IntPtr cipher_info);\n        // check operation\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public static extern int cipher_setkey(IntPtr ctx, byte[] key, int key_bitlen, int operation);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public static extern int cipher_set_iv(IntPtr ctx, byte[] iv, int iv_len);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public static extern int cipher_reset(IntPtr ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public static extern int cipher_update(IntPtr ctx, byte[] input, int ilen, byte[] output, ref int olen);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public static extern void cipher_free(IntPtr ctx);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public static extern void md5(byte[] input, uint ilen, byte[] output);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public static extern void cipher_set_operation_ex(IntPtr ctx, int operation);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public static extern int cipher_get_size_ex();
        protected Dictionary<string, Dictionary<string, int[]>> ciphers;\n        protected Dictionary<string, int[]> ciphersDetail;

        protected abstract Dictionary<string, Dictionary<string, int[]>> getCiphers();
            ciphersDetail = ciphers[_method];\n            _cipherMbedName = ciphersDetail.Keys.FirstOrDefault();\n            _cipherInfo = ciphers[_method][_cipherMbedName];
            keyLen = _cipherInfo[0];\n            ivLen = _cipherInfo[1];
        private static Dictionary<string, Dictionary<string, int[]>> _ciphers = new Dictionary<string, Dictionary<string, int[]>> {\n            { "salsa20", new Dictionary<string, int[]> { { "salsa20", new int[] { 32, 8, CIPHER_SALSA20 } } } },\n            { "chacha20", new Dictionary<string, int[]> { { "chacha20", new int[] { 32, 8, CIPHER_CHACHA20 } } } },\n            { "chacha20-ietf", new Dictionary<string, int[]> { { "chacha20-ietf", new int[] { 32, 12, CIPHER_CHACHA20_IETF } } } }
        protected override Dictionary<string, Dictionary<string, int[]>> getCiphers()
        public void TestMbedTLSEncryption()
                Thread t = new Thread(new ThreadStart(RunSingleMbedTLSEncryptionThread));
        private void RunSingleMbedTLSEncryptionThread()
                    encryptor = new MbedTLSEncryptor("aes-256-cfb", "barfoo!", false, false);\n                    decryptor = new MbedTLSEncryptor("aes-256-cfb", "barfoo!", false, false);
            if (ret != 0) throw new CryptoErrorException(String.Format("ret is {0}", ret));

        public override void cipherDecrypt(byte[] ciphertext, uint clen, byte[] plaintext, ref uint plen)
            if (ret != 0) throw new CryptoErrorException(String.Format("ret is {0}", ret));

            // XXX: sequence matters, OpenSSL > Sodium > MbedTLS\n            foreach (string method in StreamOpenSSLEncryptor.SupportedCiphers())
                if (!_registeredEncryptors.ContainsKey(method))\n                    _registeredEncryptors.Add(method, typeof(StreamOpenSSLEncryptor));
                if (!_registeredEncryptors.ContainsKey(method))\n                    _registeredEncryptors.Add(method, typeof(StreamSodiumEncryptor));\n            }\n            foreach (string method in StreamMbedTLSEncryptor.SupportedCiphers())\n            {\n                if (!_registeredEncryptors.ContainsKey(method))\n                    _registeredEncryptors.Add(method, typeof(StreamMbedTLSEncryptor));\n            }\n            foreach (string method in AEADOpenSSLEncryptor.SupportedCiphers())\n            {\n                if (!_registeredEncryptors.ContainsKey(method))\n                    _registeredEncryptors.Add(method, typeof(AEADOpenSSLEncryptor));\n            }\n            foreach (string method in AEADSodiumEncryptorSupportedCiphers)\n            {\n                if (!_registeredEncryptors.ContainsKey(method))\n                    _registeredEncryptors.Add(method, typeof(AEADSodiumEncryptor));
                if (!_registeredEncryptors.ContainsKey(method))\n                    _registeredEncryptors.Add(method, typeof(AEADMbedTLSEncryptor));
                    if (ret != 0) throw new CryptoErrorException(String.Format("ret is {0}", ret));
                    break;
        public override void cipherDecrypt(byte[] ciphertext, uint clen, byte[] plaintext, ref uint plen)
                    if (ret != 0) throw new CryptoErrorException(String.Format("ret is {0}", ret));
                    break;
            this.MainMenu = new System.Windows.Forms.MainMenu(this.components);
            this.ViewMenuItem = new System.Windows.Forms.MenuItem();\n            this.CleanLogsMenuItem = new System.Windows.Forms.MenuItem();\n            this.ChangeFontMenuItem = new System.Windows.Forms.MenuItem();\n            this.WrapTextMenuItem = new System.Windows.Forms.MenuItem();\n            this.TopMostMenuItem = new System.Windows.Forms.MenuItem();\n            this.MenuItemSeparater = new System.Windows.Forms.MenuItem();\n            this.ShowToolbarMenuItem = new System.Windows.Forms.MenuItem();\n            this.TopMostCheckBox = new System.Windows.Forms.CheckBox();
            this.ToolbarFlowLayoutPanel = new System.Windows.Forms.FlowLayoutPanel();
            // ViewMenuItem\n            // \n            this.ViewMenuItem.Index = 1;\n            this.ViewMenuItem.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {\n            this.CleanLogsMenuItem,\n            this.ChangeFontMenuItem,\n            this.WrapTextMenuItem,\n            this.TopMostMenuItem,\n            this.MenuItemSeparater,\n            this.ShowToolbarMenuItem});\n            this.ViewMenuItem.Text = "&View";\n            // \n            // CleanLogsMenuItem\n            // \n            this.CleanLogsMenuItem.Index = 0;\n            this.CleanLogsMenuItem.Text = "&Clean logs";\n            this.CleanLogsMenuItem.Click += new System.EventHandler(this.CleanLogsMenuItem_Click);\n            // \n            // ChangeFontMenuItem\n            // \n            this.ChangeFontMenuItem.Index = 1;\n            this.ChangeFontMenuItem.Text = "Change &font";\n            this.ChangeFontMenuItem.Click += new System.EventHandler(this.ChangeFontMenuItem_Click);\n            // \n            // WrapTextMenuItem\n            // \n            this.WrapTextMenuItem.Index = 2;\n            this.WrapTextMenuItem.Text = "&Wrap text";\n            this.WrapTextMenuItem.Click += new System.EventHandler(this.WrapTextMenuItem_Click);\n            // \n            // TopMostMenuItem\n            // \n            this.TopMostMenuItem.Index = 3;\n            this.TopMostMenuItem.Text = "&Top most";\n            this.TopMostMenuItem.Click += new System.EventHandler(this.TopMostMenuItem_Click);\n            // \n            // MenuItemSeparater\n            // \n            this.MenuItemSeparater.Index = 4;\n            this.MenuItemSeparater.Text = "-";\n            // \n            // ShowToolbarMenuItem\n            // \n            this.ShowToolbarMenuItem.Index = 5;\n            this.ShowToolbarMenuItem.Text = "&Show toolbar";\n            this.ShowToolbarMenuItem.Click += new System.EventHandler(this.ShowToolbarMenuItem_Click);\n            // \n            // TopMostCheckBox\n            // \n            this.TopMostCheckBox.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) \n            | System.Windows.Forms.AnchorStyles.Left)));\n            this.TopMostCheckBox.AutoSize = true;\n            this.TopMostCheckBox.Location = new System.Drawing.Point(249, 3);\n            this.TopMostCheckBox.Name = "TopMostCheckBox";\n            this.TopMostCheckBox.Size = new System.Drawing.Size(72, 23);\n            this.TopMostCheckBox.TabIndex = 3;\n            this.TopMostCheckBox.Text = "&Top most";\n            this.TopMostCheckBox.UseVisualStyleBackColor = true;\n            this.TopMostCheckBox.CheckedChanged += new System.EventHandler(this.TopMostCheckBox_CheckedChanged);
            this.ChangeFontButton.AutoSize = true;\n            this.ChangeFontButton.Location = new System.Drawing.Point(84, 3);
            this.CleanLogsButton.AutoSize = true;\n            this.CleanLogsButton.Location = new System.Drawing.Point(3, 3);

            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.Size = new System.Drawing.Size(590, 418);
            // ToolbarFlowLayoutPanel\n            // \n            this.ToolbarFlowLayoutPanel.AutoSize = true;\n            this.ToolbarFlowLayoutPanel.Controls.Add(this.CleanLogsButton);\n            this.ToolbarFlowLayoutPanel.Controls.Add(this.ChangeFontButton);\n            this.ToolbarFlowLayoutPanel.Controls.Add(this.WrapTextCheckBox);\n            this.ToolbarFlowLayoutPanel.Controls.Add(this.TopMostCheckBox);\n            this.ToolbarFlowLayoutPanel.Dock = System.Windows.Forms.DockStyle.Fill;\n            this.ToolbarFlowLayoutPanel.Location = new System.Drawing.Point(3, 3);\n            this.ToolbarFlowLayoutPanel.Name = "ToolbarFlowLayoutPanel";\n            this.ToolbarFlowLayoutPanel.Size = new System.Drawing.Size(584, 29);\n            this.ToolbarFlowLayoutPanel.TabIndex = 2;

        private System.Windows.Forms.MainMenu MainMenu;

        #region Clean up the content in LogMessageTextBox.\n        private void DoCleanLogs()\n        {\n            LogMessageTextBox.Clear();\n        }\n        private void CleanLogsMenuItem_Click(object sender, EventArgs e)\n        {\n            DoCleanLogs();
            DoCleanLogs();\n        }\n        #endregion\n        #region Change the font settings applied in LogMessageTextBox.\n        private void DoChangeFont()
            if (!TopMostTriggerLock)\n            {\n                TriggerTopMost();\n            }\n        }\n        private void TopMostMenuItem_Click(object sender, EventArgs e)\n        {\n            if (!TopMostTriggerLock)\n            {\n                TriggerTopMost();\n            }\n        }\n        #endregion\n        private bool ShowToolbarTrigger = false;\n        private void ShowToolbarMenuItem_Click(object sender, EventArgs e)\n        {\n            ShowToolbarTrigger = !ShowToolbarTrigger;\n            ToolbarFlowLayoutPanel.Visible = ShowToolbarTrigger;\n            ShowToolbarMenuItem.Checked = ShowToolbarTrigger;
                        if (_command == 1)
                            byte[] response = { 5, 0, 0, 1, 0, 0, 0, 0, 0, 0 };\n                            _connection.BeginSend(response, 0, response.Length, SocketFlags.None,\n                                new AsyncCallback(ResponseCallback), null);\n                        }\n                        else if (_command == 3)\n                        {\n                            ReadAddress(HandleUDPAssociate);
        private void ResponseCallback(IAsyncResult ar)\n        {\n            try\n            {\n                _connection.EndSend(ar);\n                ReadAddress(StartConnect);\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void ReadAddress(Action onSuccess)\n        {\n            int atyp = _connetionRecvBuffer[3];\n            switch (atyp)\n            {\n                case 1: // IPv4 address, 4 bytes\n                    ReadAddress(4 + 2 - 1, onSuccess);\n                    break;\n                case 3: // domain name, length + str\n                    int len = _connetionRecvBuffer[4];\n                    ReadAddress(len + 2, onSuccess);\n                    break;\n                case 4: // IPv6 address, 16 bytes\n                    ReadAddress(16 + 2 - 1, onSuccess);\n                    break;\n                default:\n                    Logging.Debug("Unsupported ATYP=" + atyp);\n                    Close();\n                    break;\n            }\n        }\n        private void ReadAddress(int bytesRemain, Action onSuccess)
            _connection.BeginReceive(_connetionRecvBuffer, 2, RecvSize - 2, SocketFlags.None, OnAddressFullyRead, new object[] {bytesRemain, onSuccess});
                var states = (object[]) ar.AsyncState;\n                int bytesRemain = (int)states[0];\n                var onSuccess = (Action) states[1];
            IPAddress addr;\n            IPAddress.TryParse( server, out addr );\n            if ( remarks.IsNullOrEmpty() ) {\n                switch ( addr.AddressFamily ) {\n                    case AddressFamily.InterNetwork:\n                        return $"{server}:{server_port}";\n                    case AddressFamily.InterNetworkV6:\n                        return $"[{server}]:{server_port}";\n                }\n            } else {\n                switch ( addr.AddressFamily ) {\n                    case AddressFamily.InterNetwork:\n                        return $"{remarks} ({server}:{server_port})";\n                    case AddressFamily.InterNetworkV6:\n                        return $"{remarks} ([{server}]:{server_port})";\n                }
            // This should not happen, user should check the input instead of blaming\n            return null;

                    var method = m.Groups["method"].Value;\n                    var path = m.Groups["path"].Value;
                        if (!ParseHost(path))
                    else\n                    {\n                        var targetUrl = new Uri(path);\n                        if (!ParseHost(targetUrl.Authority))\n                        {\n                            throw new Exception("Bad http header: " + line);\n                        }\n                        var newRequestLine = $"{method} {targetUrl.PathAndQuery} {m.Groups["tail"].Value}";\n                        _headers.Enqueue(newRequestLine);\n                    }\n                }\n                else\n                {\n                    throw new FormatException("Not a vaild request line");\n                }\n            }\n            else\n            {\n                // Handle Proxy-x Headers\n                if (!line.StartsWith("Proxy-"))\n                {\n                    _headers.Enqueue(line);\n                }\n                else\n                {\n                    if (line.StartsWith("Proxy-Connection: "))\n                    {\n                        _headers.Enqueue(line.Substring(6));\n                    }\n                }
                if (bytesRead >= 3)\n                {\n                    command = connetionRecvBuffer[1];
                    connection.BeginSend(response, 0, response.Length, 0, new AsyncCallback(StartConnect), null);
            this.PACUrlTextBox.Anchor = System.Windows.Forms.AnchorStyles.Left;\n            this.PACUrlTextBox.Location = new System.Drawing.Point(53, 3);
            this.PACUrlLabel.Location = new System.Drawing.Point(3, 6);\n            this.PACUrlLabel.Margin = new System.Windows.Forms.Padding(3);
            this.ClientSize = new System.Drawing.Size(351, 101);\n            this.Controls.Add(this.tableLayoutPanel1);
         String encoding = hints == null || !hints.ContainsKey(EncodeHintType.CHARACTER_SET) ? null : (String)hints[EncodeHintType.CHARACTER_SET];\n         if (encoding == null)\n         {\n            encoding = DEFAULT_BYTE_MODE_ENCODING;\n         }\n         bool generateECI = !DEFAULT_BYTE_MODE_ENCODING.Equals(encoding);
         Mode mode = chooseMode(content, encoding);

         throw new WriterException("Data too big");
            throw new WriterException("EC bytes mismatch");
            throw new WriterException("RS blocks mismatch");
            throw new WriterException("Total bytes mismatch");
            throw new WriterException(numLetters + " is bigger than " + ((1 << numBits) - 1));
                     throw new WriterException("Invalid mode: " + mode);\n      }\n      internal static void appendNumericBytes(String content, BitArray bits)\n      {\n         int length = content.Length;\n         int i = 0;\n         while (i < length)\n         {\n            int num1 = content[i] - '0';\n            if (i + 2 < length)\n            {\n               // Encode three numeric letters in ten bits.\n               int num2 = content[i + 1] - '0';\n               int num3 = content[i + 2] - '0';\n               bits.appendBits(num1 * 100 + num2 * 10 + num3, 10);\n               i += 3;\n            }\n            else if (i + 1 < length)\n            {\n               // Encode two numeric letters in seven bits.\n               int num2 = content[i + 1] - '0';\n               bits.appendBits(num1 * 10 + num2, 7);\n               i += 2;\n            }\n            else\n            {\n               // Encode one numeric letter in four bits.\n               bits.appendBits(num1, 4);\n               i++;\n            }\n         }\n      }\n      internal static void appendAlphanumericBytes(String content, BitArray bits)\n      {\n         int length = content.Length;\n         int i = 0;\n         while (i < length)\n         {\n            int code1 = getAlphanumericCode(content[i]);\n            if (code1 == -1)\n            {\n               throw new WriterException();\n            }\n            if (i + 1 < length)\n            {\n               int code2 = getAlphanumericCode(content[i + 1]);\n               if (code2 == -1)\n               {\n                  throw new WriterException();\n               }\n               // Encode two alphanumeric letters in 11 bits.\n               bits.appendBits(code1 * 45 + code2, 11);\n               i += 2;\n            }\n            else\n            {\n               // Encode one alphanumeric letter in six bits.\n               bits.appendBits(code1, 6);\n               i++;\n            }\n         }
            throw new WriterException(uee.Message, uee);
            throw new WriterException();
               throw new WriterException();

    class PACServer : Listener.Service

        public PACServer()\n        {\n            this.WatchPacFile();\n        }\n        public bool Handle(byte[] firstPacket, int length, Socket socket)
                string request = Encoding.UTF8.GetString(firstPacket, 0, length);\n                string[] lines = request.Split('\r', '\n');\n                bool hostMatch = false, pathMatch = false;\n                foreach (string line in lines)
                    string[] kv = line.Split(new char[]{':'}, 2);\n                    if (kv.Length == 2)\n                    {\n                        if (kv[0] == "Host")\n                        {\n                            if (kv[1].Trim() == ((IPEndPoint)socket.LocalEndPoint).ToString())\n                            {\n                                hostMatch = true;\n                            }\n                        }\n                    }\n                    else if (kv.Length == 1)\n                    {\n                        if (line.IndexOf("pac") >= 0)\n                        {\n                            pathMatch = true;\n                        }\n                    }
                if (hostMatch && pathMatch)
                    SendResponse(firstPacket, length, socket);\n                    return true;
                return false;
            catch (ArgumentException)
                return false;
        public void SendResponse(byte[] firstPacket, int length, Socket socket)


                IPEndPoint localEndPoint = (IPEndPoint)socket.LocalEndPoint;\n                string proxy = GetPACAddress(firstPacket, length, localEndPoint);
                string text = String.Format(@"HTTP/1.1 200 OK
                byte[] response = System.Text.Encoding.UTF8.GetBytes(text);\n                socket.BeginSend(response, 0, response.Length, 0, new AsyncCallback(SendCallback), socket);\n                Util.Utils.ReleaseMemory();
                socket.Close();
        private string GetPACAddress(byte[] requestBuf, int length, IPEndPoint localEndPoint)
            return "PROXY " + localEndPoint.Address + ":8123;";
        public bool Handle(byte[] firstPacket, int length, Socket socket)\n        {\n            if (length < 2 || firstPacket[0] != 5)\n            {\n                return false;\n            }
        Server server1, server1WithRemark, server1WithPlugin, server1WithPluginAndRemark;\n        string server1CanonUrl, server1WithRemarkCanonUrl, server1WithPluginCanonUrl, server1WithPluginAndRemarkCanonUrl;\n        Server server2, server2WithRemark, server2WithPlugin, server2WithPluginAndRemark;\n        string server2CanonUrl, server2WithRemarkCanonUrl, server2WithPluginCanonUrl, server2WithPluginAndRemarkCanonUrl;\n        [TestInitialize]\n        public void PrepareTestData()\n        {\n            server1 = new Server
            server1CanonUrl = "ss://YmYtY2ZiOnRlc3RAMTkyLjE2OC4xMDAuMTo4ODg4";\n            // server2 has base64 padding\n            server2 = new Server
            server2CanonUrl = "ss://YmYtY2ZiOnRlc3RAMTkyLjE2OC4xLjE6ODM4OA==";\n            server1WithRemark = new Server\n            {\n                server = server1.server,\n                server_port = server1.server_port,\n                password = server1.password,\n                method = server1.method,
            server1WithRemarkCanonUrl = "ss://YmYtY2ZiOnRlc3RAMTkyLjE2OC4xMDAuMTo4ODg4#example-server";\n            server2WithRemark = new Server
            server2WithRemarkCanonUrl = "ss://YmYtY2ZiOnRlc3RAMTkyLjE2OC4xLjE6ODM4OA==#example-server";\n            server1WithPlugin = new Server\n            {\n                server = server1.server,\n                server_port = server1.server_port,\n                password = server1.password,\n                method = server1.method,
            server1WithPluginCanonUrl =
            server2WithPlugin = new Server
            server2WithPluginCanonUrl =
            server1WithPluginAndRemark = new Server\n            {\n                server = server1.server,\n                server_port = server1.server_port,\n                password = server1.password,\n                method = server1.method,\n                plugin = server1WithPlugin.plugin,\n                plugin_opts = server1WithPlugin.plugin_opts,\n                remarks = server1WithRemark.remarks\n            };\n            server1WithPluginAndRemarkCanonUrl =
            server2WithPluginAndRemark = new Server
            server2WithPluginAndRemarkCanonUrl =
        }\n        [TestMethod]\n        public void TestParseUrl_Server1()\n        {\n            RunParseShadowsocksUrlTest(\n                string.Join(\n                    "\r\n",\n                    server1CanonUrl,
                    server1,\n                    server1,\n                    server1WithRemark,\n                    server1WithRemark\n                });\n            RunParseShadowsocksUrlTest(\n                string.Join(\n                    "\r\n",\n                    "ss://YmYtY2ZiOnRlc3Q@192.168.100.1:8888",\n                    "\r\n",\n                    "ss://YmYtY2ZiOnRlc3Q@192.168.100.1:8888/",\n                    "ss://YmYtY2ZiOnRlc3Q@192.168.100.1:8888#example-server",\n                    "ss://YmYtY2ZiOnRlc3Q@192.168.100.1:8888/#example-server",\n                    server1WithPluginCanonUrl,\n                    server1WithPluginAndRemarkCanonUrl,\n                    "ss://YmYtY2ZiOnRlc3Q@192.168.100.1:8888/?plugin=obfs-local%3bobfs%3dhttp%3bobfs-host%3dgoogle.com&unsupported=1#example-server"),\n                new[]\n                {\n                    server1,\n                    server1,\n                    server1WithRemark,\n                    server1WithRemark,\n                    server1WithPlugin,\n                    server1WithPluginAndRemark,\n                    server1WithPluginAndRemark\n                });\n        }\n        [TestMethod]\n        public void TestParseUrl_Server2()\n        {
        public void TestSip003Plugin_NoPlugin()



                RegHotkeyFromString(hotkeyConfig.SwitchSystemProxy, "SwitchSystemProxyCallback", SwitchSystemProxyLabel)\n                && RegHotkeyFromString(hotkeyConfig.SwitchSystemProxyMode, "SwitchProxyModeCallback", SwitchProxyModeLabel)\n                && RegHotkeyFromString(hotkeyConfig.SwitchAllowLan, "SwitchAllowLanCallback", SwitchAllowLanLabel)\n                && RegHotkeyFromString(hotkeyConfig.ShowLogs, "ShowLogsCallback", ShowLogsLabel)\n                && RegHotkeyFromString(hotkeyConfig.ServerMoveUp, "ServerMoveUpCallback", ServerMoveUpLabel)\n                && RegHotkeyFromString(hotkeyConfig.ServerMoveDown, "ServerMoveDownCallback", ServerMoveDownLabel);
        private bool RegHotkeyFromString(string hotkeyStr, string callbackName, Label indicator = null)
                HotKeys.UnregExistingHotkey(callback);\n                if (indicator != null)\n                {\n                    indicator.ResetBackColor();\n                }
                    bool regResult = (HotKeys.RegHotkey(hotkey, callback));

            List<string> ret = new List<string>(domains.Count + 100)// 100 overhead\n            {\n                "/.*/" // match any domain, so all non-cn domain go through proxy\n            }; 
                        ret.Add($"@@{domain}");
                updateChecker.CheckUpdate(config, 3000);
            this.tableLayoutPanel1.Controls.Add(this.EncryptionLabel, 0, 4);\n            this.tableLayoutPanel1.Controls.Add(this.EncryptionSelect, 1, 4);\n            this.tableLayoutPanel1.Controls.Add(this.TimeoutLabel, 0, 9);\n            this.tableLayoutPanel1.Controls.Add(this.TimeoutTextBox, 1, 9);\n            this.tableLayoutPanel1.Controls.Add(this.PluginLabel, 0, 5);\n            this.tableLayoutPanel1.Controls.Add(this.PluginOptionsTextBox, 1, 6);\n            this.tableLayoutPanel1.Controls.Add(this.ShowPasswdCheckBox, 1, 3);
            this.tableLayoutPanel1.RowCount = 10;\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.Size = new System.Drawing.Size(267, 243);
                var configuration = JsonConvert.DeserializeObject<StatisticsStrategyConfiguration>(content);
            catch (FileNotFoundException e)
            this.KeepChoiceForLabel = new System.Windows.Forms.Label();\n            this.MinutesLabel2 = new System.Windows.Forms.Label();
            this.CollectDataPerLabel = new System.Windows.Forms.Label();\n            this.MinutesLabel1 = new System.Windows.Forms.Label();
            this.PackagePerPingLabel = new System.Windows.Forms.Label();
            this.FinalScoreLabel = new System.Windows.Forms.Label();

            this.splitContainer2.Panel1.Controls.Add(this.CollectDataPerLabel);\n            this.splitContainer2.Panel1.Controls.Add(this.MinutesLabel1);
            this.splitContainer2.Panel1.Controls.Add(this.PackagePerPingLabel);\n            this.splitContainer2.Panel1.Controls.Add(this.KeepChoiceForLabel);
            this.splitContainer2.Panel1.Controls.Add(this.MinutesLabel2);
            this.splitContainer3.Panel1.Controls.Add(this.FinalScoreLabel);
            // FinalScoreLabel\n            // \n            this.FinalScoreLabel.AutoSize = true;\n            this.FinalScoreLabel.Location = new System.Drawing.Point(5, 9);\n            this.FinalScoreLabel.Margin = new System.Windows.Forms.Padding(5, 0, 5, 0);\n            this.FinalScoreLabel.Name = "FinalScoreLabel";\n            this.FinalScoreLabel.Size = new System.Drawing.Size(103, 23);\n            this.FinalScoreLabel.TabIndex = 0;\n            this.FinalScoreLabel.Text = "Final Score:";\n            this.CalculatinTip.SetToolTip(this.FinalScoreLabel, "(The server with the highest score would be choosen)");

        private System.Windows.Forms.Label KeepChoiceForLabel;\n        private System.Windows.Forms.Label MinutesLabel2;
        private System.Windows.Forms.Label FinalScoreLabel;
        private System.Windows.Forms.Label PackagePerPingLabel;
        private System.Windows.Forms.Label CollectDataPerLabel;\n        private System.Windows.Forms.Label MinutesLabel1;

                CreateMenuGroup("Help", new MenuItem[] {\n                    CreateMenuItem("Show Logs...", new EventHandler(this.ShowLogItem_Click)),\n                    this.VerboseLoggingToggleItem = CreateMenuItem( "Verbose Logging", new EventHandler(this.VerboseLoggingToggleItem_Click) ),\n                    CreateMenuGroup("Updates...", new MenuItem[] {\n                        CreateMenuItem("Check for Updates...", new EventHandler(this.checkUpdatesItem_Click)),\n                        new MenuItem("-"),\n                        this.autoCheckUpdatesToggleItem = CreateMenuItem("Check for Updates at Startup", new EventHandler(this.autoCheckUpdatesToggleItem_Click)),\n                        this.checkPreReleaseToggleItem = CreateMenuItem("Check Pre-release Version", new EventHandler(this.checkPreReleaseToggleItem_Click)),\n                    }),\n                    CreateMenuItem("About...", new EventHandler(this.AboutItem_Click)),

using Shadowsocks.Controller.Service;


            EnableStatusChanged?.Invoke(this, new EventArgs());
            EnableGlobalChanged?.Invoke(this, new EventArgs());
            ShareOverLANStatusChanged?.Invoke(this, new EventArgs());
            PACFileReadyToOpen?.Invoke(this, new PathEventArgs() { Path = pacFilename });
            UserRuleFileReadyToOpen?.Invoke(this, new PathEventArgs() { Path = userRuleFilename });
            if (availabilityStatistics != null)\n            {\n                availabilityStatistics.UpdateConfiguration(this);\n                _config.availabilityStatistics = enabled;\n                SaveConfig(_config);\n            }
            ConfigChanged?.Invoke(this, new EventArgs());
            ConfigChanged?.Invoke(this, new EventArgs());
            ConfigChanged?.Invoke(this, new EventArgs());
            ConfigChanged?.Invoke(this, new EventArgs());
            ConfigChanged?.Invoke(this, new EventArgs());
            ConfigChanged?.Invoke(this, new EventArgs());
            ConfigChanged?.Invoke(this, new EventArgs());
                List<Listener.IService> services = new List<Listener.IService>\n                {\n                    tcpRelay,\n                    udpRelay,\n                    _pacServer,\n                    new PortForwarder(privoxyRunner.RunningPort)\n                };
                if (e is SocketException se)\n                {
            _trafficThread = new Thread(new ThreadStart(() => TrafficStatistics(queueMaxSize)))\n            {\n                IsBackground = true\n            };
                current = new TrafficPerSecond\n                {\n                    inboundCounter = InboundCounter,\n                    outboundCounter = OutboundCounter\n                };
            // start reading\n            socket.BeginReceive(_lineBuffer, 0, maxLineBytes, 0, ReceiveCallback, 0);
                    OnFinish(length);
                length += bytesRead;\n                int i;\n                while ((i = IndexOf(_lineBuffer, _bufferIndex, length, _delimiterBytes, _delimiterSearchOffsetTable,\n                           _delimiterSearchCharTable)) != -1)\n                {\n                    var decodeLen = i - _bufferIndex;\n                    string line = _encoding.GetString(_lineBuffer, _bufferIndex, decodeLen);\n                    _bufferIndex = i + _delimiterBytes.Length;\n                    length -= decodeLen;\n                    length -= _delimiterBytes.Length;\n                    var stop = _onLineRead(line, _state);\n                    if (stop)\n                    {\n                        OnFinish(length);\n                        return;\n                    }\n                }\n                if (length == _lineBuffer.Length)\n                {\n                    OnException(new IndexOutOfRangeException("LineBuffer full! Try increace maxLineBytes!"));\n                    OnFinish(length);\n                    return;\n                }\n                if (_bufferIndex > 0)\n                {\n                    Buffer.BlockCopy(_lineBuffer, _bufferIndex, _lineBuffer, 0, length);\n                    _bufferIndex = 0;\n                }\n                _socket.BeginReceive(_lineBuffer, length, _lineBuffer.Length - length, 0, ReceiveCallback, length);
                OnFinish(length);\n            }
        private void OnFinish(int length)\n        {\n            _onFinish?.Invoke(_lineBuffer, _bufferIndex, length, _state);
        public static int IndexOf(byte[] haystack, int index, int length, byte[] needle, int[] offsetTable, int[] charTable)
            catch (Exception ex)
            private IPEndPoint _remoteEndPoint;
                // TODO async resolving\n                IPAddress ipAddress;\n                bool parsed = IPAddress.TryParse(server.server, out ipAddress);\n                if (!parsed)\n                {\n                    IPHostEntry ipHostInfo = Dns.GetHostEntry(server.server);\n                    ipAddress = ipHostInfo.AddressList[0];\n                }\n                _remoteEndPoint = new IPEndPoint(ipAddress, server.server_port);\n                _remote = new Socket(_remoteEndPoint.AddressFamily, SocketType.Dgram, ProtocolType.Udp);
                            iconCopy.SetPixel(x, y, Color.FromArgb(color.A, color.R, 0, 0));
                            iconCopy.SetPixel(x, y, Color.FromArgb(color.A, 0, color.G, 0));
                            iconCopy.SetPixel(x, y, Color.FromArgb(color.A, color.R, color.G, 0));

            try {\n                var IP = Dns.GetHostAddresses(server.server).First(ip => (ip.AddressFamily == AddressFamily.InterNetwork || ip.AddressFamily == AddressFamily.InterNetworkV6));\n                var ping = new Ping();\n                foreach (var timestamp in Enumerable.Range(0, Repeat).Select(_ => DateTime.Now.ToString(DateTimePattern)))\n                {\n                    //ICMP echo. we can also set options and special bytes\n                    try\n                    {\n                        var reply = await ping.SendTaskAsync(IP, Timeout);\n                        ret.Add(new List<KeyValuePair<string, string>>
                        Thread.Sleep(Timeout + new Random().Next() % Timeout);\n                        //Do ICMPTest in a random frequency\n                    }\n                    catch (Exception e)\n                    {\n                        Logging.Error($"An exception occured while eveluating {server.FriendlyName()}");\n                        Logging.LogUsefulException(e);\n                    }\n                }\n            }catch(Exception e)\n            {\n                Logging.Error($"An exception occured while eveluating {server.FriendlyName()}");\n                Logging.LogUsefulException(e);
            _remote.BeginConnect(destEndPoint, callback, state);
            _remote.EndConnect(asyncResult);\n            _remote.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);

using Shadowsocks.Util.Sockets;
            _remote?.Dispose();
                _remote.EndConnect(ar);\n                _remote.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);
        private void updateSystemProxy()
            if (config.enabled)
        internal static byte[] proxy_pac_txt {
                object obj = ResourceManager.GetObject("proxy_pac_txt", resourceCulture);\n                return ((byte[])(obj));
                string pac = getPACContent();

            this.contextMenu1 = new System.Windows.Forms.ContextMenu();\n            this.enableItem = new System.Windows.Forms.MenuItem();\n            this.aboutItem = new System.Windows.Forms.MenuItem();\n            this.menuItem3 = new System.Windows.Forms.MenuItem();\n            this.quitItem = new System.Windows.Forms.MenuItem();\n            this.configItem = new System.Windows.Forms.MenuItem();




        private System.Windows.Forms.ContextMenu contextMenu1;\n        private System.Windows.Forms.MenuItem enableItem;\n        private System.Windows.Forms.MenuItem aboutItem;\n        private System.Windows.Forms.MenuItem menuItem3;\n        private System.Windows.Forms.MenuItem quitItem;\n        private System.Windows.Forms.MenuItem configItem;

            this.tableLayoutPanel1.Location = new System.Drawing.Point(19, 19);\n            this.tableLayoutPanel1.Margin = new System.Windows.Forms.Padding(10);
            // ConfigForm

            string origPacUrl = controller.GetConfiguration().pacUrl;\n            string pacUrl = Microsoft.VisualBasic.Interaction.InputBox(\n                I18N.GetString("Please input PAC Url"),\n                I18N.GetString("Update Online PAC URL"),\n                origPacUrl, -1, -1);\n            if (!string.IsNullOrEmpty(pacUrl) && pacUrl != origPacUrl)\n            {\n                controller.SavePACUrl(pacUrl);\n            }
                UpdateCompleted?.Invoke(this, new ResultEventArgs(true));
                Error?.Invoke(this, new ErrorEventArgs(ex));
﻿using System;
using System.Globalization;\nusing System.IO;
            if (CultureInfo.CurrentCulture.IetfLanguageTag.StartsWith("zh", StringComparison.OrdinalIgnoreCase))
                using (var sr = new StringReader(Resources.cn))
                    string line;\n                    while ((line = sr.ReadLine()) != null)
                        if (line[0] == '#')\n                            continue;\n                        var pos = line.IndexOf('=');\n                        if (pos < 1)\n                            continue;\n                        Strings[line.Substring(0, pos)] = line.Substring(pos + 1);
                    if (item.Equals(Key, StringComparison.OrdinalIgnoreCase))
                    else if (item.Equals("Shadowsocks", StringComparison.OrdinalIgnoreCase)) // Compatibility with older versions
                        if (path.Equals(value, StringComparison.OrdinalIgnoreCase))
            object[] state = (object[])ar.AsyncState;\n            Socket conn = (Socket)state[0];\n            byte[] requestBuf = (byte[])state[1];
                string proxy = GetPACAddress(requestBuf, localEndPoint);

        private Configuration _config;
            this._config = config;
                    localEndPoint = new IPEndPoint(IPAddress.Any, _config.localPort);
                    localEndPoint = new IPEndPoint(IPAddress.Loopback, _config.localPort);
                bool parsed = IPAddress.TryParse(server.server, out ipAddress);
                    IPHostEntry ipHostInfo = Dns.GetHostEntry(server.server);
                IPEndPoint remoteEP = new IPEndPoint(ipAddress, server.server_port);



    public sealed class AvailabilityStatistics
        private const int TimeoutMilliseconds = 500;\n        private readonly TimeSpan _delayBeforeStart = TimeSpan.FromSeconds(1);
        private ShadowsocksController _controller;

            return server != _currentServer ? Empty : _outboundSpeed.ToString();
            return server != _currentServer ? Empty : _inboundSpeed.ToString();
            _currentServer = _controller.GetCurrentServer();
        internal void UpdateConfiguration(ShadowsocksController controller)\n        {\n            _controller = controller;
            Set(controller.StatisticsConfiguration);\n            _servers = _controller.GetCurrentConfiguration().configs;\n        }\n        private void FilterRawStatistics()
                availabilityStatistics.UpdateLatency(server, (int)latency.TotalMilliseconds);
                availabilityStatistics.UpdateInboundCounter(server, n);
                availabilityStatistics.UpdateOutboundCounter(server, n);
                KillProcess(_process);
                _inboundSpeedRecords.GetOrAdd(id, (k) =>\n                {\n                    List<int> records = new List<int>();\n                    records.Add(inboundSpeed);\n                    return records;\n                });
                _outboundSpeedRecords.GetOrAdd(id, (k) =>\n                {\n                    List<int> records = new List<int>();\n                    records.Add(outboundSpeed);\n                    return records;\n                });


        }\n        private void UpdateRecords()
                if (Config.Ping)\n                {\n                    MyPing ping = new MyPing(server, Repeat);\n                    ping.Completed += ping_Completed;\n                    ping.Start(new PingState { state = state, record = record });\n                }\n                else if (!record.IsEmptyData())\n                {\n                    AppendRecord(id, record);\n                }\n            }\n            if (!Config.Ping)\n            {\n                Save();\n                FilterRawStatistics();\n            }\n        }\n        private void ping_Completed(object sender, MyPing.CompletedEventArgs e)\n        {\n            PingState pingState = (PingState)e.UserState;\n            UpdateRecordsState state = pingState.state;\n            Server server = e.Server;\n            StatisticsRecord record = pingState.record;\n            record.SetResponse(e.RoundtripTime);\n            if (!record.IsEmptyData())\n            {\n                AppendRecord(server.Identifier(), record);\n            }\n            Logging.Debug($"Ping {server.FriendlyName()} {e.RoundtripTime.Count} times, {(100 - record.PackageLoss * 100)}% packages loss, min {record.MinResponse} ms, max {record.MaxResponse} ms, avg {record.AverageResponse} ms");\n            if (Interlocked.Decrement(ref state.counter) == 0)\n            {\n                Save();\n                FilterRawStatistics();
            try\n            {\n                List<StatisticsRecord> records;\n                lock (RawStatistics)\n                {\n                    if (!RawStatistics.TryGetValue(serverIdentifier, out records))\n                    {\n                        records = new List<StatisticsRecord>();\n                        RawStatistics[serverIdentifier] = records;\n                    }\n                }\n                records.Add(record);\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n            }
                string content;\n#if DEBUG\n                content = JsonConvert.SerializeObject(RawStatistics, Formatting.Indented);\n#else\n                content = JsonConvert.SerializeObject(RawStatistics, Formatting.None);\n#endif

            _latencyRecords.GetOrAdd(server.Identifier(), (k) =>\n            {\n                List<int> records = new List<int>();\n                records.Add(latency);\n                return records;\n            });
            _inboundCounter.AddOrUpdate(server.Identifier(), (k) =>\n            {\n                _lastInboundCounter.GetOrAdd(server.Identifier(), 0);\n                return n;\n            }, (k, v) => (v + n));
            _outboundCounter.AddOrUpdate(server.Identifier(), (k) =>\n            {\n                _lastOutboundCounter.GetOrAdd(server.Identifier(), 0);\n                return n;\n            }, (k, v) => (v + n));\n        }\n        class UpdateRecordsState\n        {\n            public int counter;\n        }\n        class PingState\n        {\n            public UpdateRecordsState state;\n            public StatisticsRecord record;\n        }\n        class MyPing\n        {\n            //arguments for ICMP tests\n            public const int TimeoutMilliseconds = 500;\n            public EventHandler<CompletedEventArgs> Completed;\n            private Server server;\n            private int repeat;\n            private IPAddress ip;\n            private Ping ping;\n            private List<int?> RoundtripTime;\n            public MyPing(Server server, int repeat)\n            {\n                this.server = server;\n                this.repeat = repeat;\n                RoundtripTime = new List<int?>(repeat);\n                ping = new Ping();\n                ping.PingCompleted += Ping_PingCompleted;\n            }\n            public void Start(object userstate)\n            {\n                if (server.server == "")\n                {\n                    FireCompleted(new Exception("Invalid Server"), userstate);\n                    return;\n                }\n                new Task(() => ICMPTest(0, userstate)).Start();\n            }\n            private void ICMPTest(int delay, object userstate)\n            {\n                try\n                {\n                    Logging.Debug($"Ping {server.FriendlyName()}");\n                    if (ip == null)\n                    {\n                        ip = Dns.GetHostAddresses(server.server)\n                                .First(\n                                    ip =>\n                                        ip.AddressFamily == AddressFamily.InterNetwork ||\n                                        ip.AddressFamily == AddressFamily.InterNetworkV6);\n                    }\n                    repeat--;\n                    if (delay > 0)\n                        Thread.Sleep(delay);\n                    ping.SendAsync(ip, TimeoutMilliseconds, userstate);\n                }\n                catch (Exception e)\n                {\n                    Logging.Error($"An exception occured while eveluating {server.FriendlyName()}");\n                    Logging.LogUsefulException(e);\n                    FireCompleted(e, userstate);\n                }\n            }\n            private void Ping_PingCompleted(object sender, PingCompletedEventArgs e)\n            {\n                try\n                {\n                    if (e.Reply.Status == IPStatus.Success)\n                    {\n                        Logging.Debug($"Ping {server.FriendlyName()} {e.Reply.RoundtripTime} ms");\n                        RoundtripTime.Add((int?)e.Reply.RoundtripTime);\n                    }\n                    else\n                    {\n                        Logging.Debug($"Ping {server.FriendlyName()} timeout");\n                        RoundtripTime.Add(null);\n                    }\n                    TestNext(e.UserState);\n                }\n                catch (Exception ex)\n                {\n                    Logging.Error($"An exception occured while eveluating {server.FriendlyName()}");\n                    Logging.LogUsefulException(ex);\n                    FireCompleted(ex, e.UserState);\n                }\n            }\n            private void TestNext(object userstate)\n            {\n                if (repeat > 0)\n                {\n                    //Do ICMPTest in a random frequency\n                    int delay = TimeoutMilliseconds + new Random().Next() % TimeoutMilliseconds;\n                    new Task(() => ICMPTest(delay, userstate)).Start();\n                }\n                else\n                {\n                    FireCompleted(null, userstate);\n                }\n            }\n            private void FireCompleted(Exception error, object userstate)\n            {\n                Completed?.Invoke(this, new CompletedEventArgs\n                {\n                    Error = error,\n                    Server = server,\n                    RoundtripTime = RoundtripTime,\n                    UserState = userstate\n                });\n            }\n            public class CompletedEventArgs : EventArgs\n            {\n                public Exception Error;\n                public Server Server;\n                public List<int?> RoundtripTime;\n                public object UserState;\n            }


                SystemProxy.Update(_config, false, _pacServer);
                    SystemProxy.Update(_config, false, _pacServer);
    public class PACServer : Listener.Service

                    requestBuf
                conn.BeginReceive(requestBuf, 0, requestBuf.Length, 0,
                byte[] buffer = new byte[1024];  // builtin pac gzip size: maximum 100K\n                MemoryStream sb = new MemoryStream();
                    while((n = input.Read(buffer, 0, buffer.Length)) > 0)
                        sb.Write(buffer, 0, n);
                    return System.Text.Encoding.UTF8.GetString(sb.ToArray());
        private const string PROXY_AUTH_TEMPLATE = "Proxy-Authorization: Basic {0}" + HTTP_CRLF;\n        public void BeginConnectDest(EndPoint destEndPoint, AsyncCallback callback, object state, NetworkCredential auth = null)
            String authInfo = "";\n            if (auth != null)\n            {\n                string authKey = Convert.ToBase64String(Encoding.UTF8.GetBytes(auth.UserName + ":" + auth.Password));\n                authInfo = string.Format(PROXY_AUTH_TEMPLATE, authKey);\n            }\n            string request = string.Format(HTTP_CONNECT_TEMPLATE, destEndPoint, authInfo);
                    new AsyncSession<ServerTimer>(session, connectTimer), auth);
                ProxyTypeComboBox.Enabled =\n                UseAuthCheckBox.Enabled =\n                AuthUserTextBox.Enabled =\n                AuthPwdTextBox.Enabled = false;
            if (_modifiedConfiguration == null)\n            {

        public static extern void ss_sha1_hmac_ex(byte[] key, uint keylen,
                if (_disposed) return;
                // free managed objects\n            }\n            // free unmanaged objects\n            if (_encryptCtx != IntPtr.Zero)\n            {\n                MbedTLS.cipher_free(_encryptCtx);\n                Marshal.FreeHGlobal(_encryptCtx);\n                _encryptCtx = IntPtr.Zero;\n            }\n            if (_decryptCtx != IntPtr.Zero)\n            {\n                MbedTLS.cipher_free(_decryptCtx);\n                Marshal.FreeHGlobal(_decryptCtx);\n                _decryptCtx = IntPtr.Zero;
            if (disposed) return;\n            disposed = true;

        private void Close()
            if (handle != IntPtr.Zero)\n            {\n                CloseHandle(handle);\n                handle = IntPtr.Zero;\n            }\n        }\n        ~Job()\n        {\n            Dispose(false);
            var inbound = inboundSpeedRecords?.Where(s => s > 0).ToList();\n            if (inbound != null && inbound.Any())
                AverageInboundSpeed = (int) inbound.Average();\n                MinInboundSpeed = inbound.Min();\n                MaxInboundSpeed = inbound.Max();
            var outbound = outboundSpeedRecords?.Where(s => s > 0).ToList();\n            if (outbound!= null && outbound.Any())
                AverageOutboundSpeed = (int) outbound.Average();\n                MinOutboundSpeed = outbound.Min();\n                MaxOutboundSpeed = outbound.Max();
            var latency = latencyRecords?.Where(s => s > 0).ToList();\n            if (latency!= null && latency.Any())
                AverageLatency = (int) latency.Average();\n                MinLatency = latency.Min();\n                MaxLatency = latency.Max();
                                PackageLossPercentage = (int) (dataGroup.Average(data => data.PackageLoss) ?? 0) * 100
            foreach (var data in finalData.Where(data => data.Speed != 0 || data.PackageLossPercentage != 0 || data.Ping != 0))

using System.Threading;


        private Dictionary<string, List<AvailabilityStatistics.RawStatisticsData>> _filteredStatistics;

            _filteredStatistics = _controller.availabilityStatistics.rawStatistics ?? _filteredStatistics ?? new Dictionary<string, List<AvailabilityStatistics.RawStatisticsData>>();
        private float GetScore(string serverName)
            List<AvailabilityStatistics.RawStatisticsData> dataList;\n            if (_filteredStatistics == null || !_filteredStatistics.TryGetValue(serverName, out dataList)) return 0;
            var statisticsData = new AvailabilityStatistics.StatisticsData()

            if (_filteredStatistics == null || servers.Count == 0)
                                  where _filteredStatistics.ContainsKey(name)
                                      score = GetScore(name)



    using RawStatistics = Dictionary<string, List<AvailabilityStatistics.RawStatisticsData>>;\n    using Statistics = Dictionary<string, List<AvailabilityStatistics.StatisticsData>>;\n    public class AvailabilityStatistics

            foreach (string method in AEADMbedTLSEncryptorSupportedCiphers)
            foreach (string method in AEADSodiumEncryptorSupportedCiphers)
                    new AsyncCallback(ConnectCallback), connectTimer);\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                this.Close();\n            }\n        }\n        private void connectTimer_Elapsed(object sender, ElapsedEventArgs e)\n        {\n            if (connected)\n            {\n                return;\n            }\n            Server server = ((ServerTimer)sender).Server;\n            controller.GetCurrentStrategy().SetFailure(server);\n            Console.WriteLine(String.Format("{0} timed out", server.FriendlyName()));\n            remote.Close();\n            RetryConnect();\n        }\n        private void RetryConnect()\n        {\n            if (retryCount < 4)\n            {\n                Console.WriteLine("Connection failed, retrying");\n                StartConnect();\n                retryCount++;\n            }\n            else\n            {
            Server server = null;\n            if (closed)\n            {\n                return;\n            }\n            try\n            {\n                ServerTimer timer = (ServerTimer)ar.AsyncState;\n                server = timer.Server;\n                timer.Elapsed -= connectTimer_Elapsed;\n                timer.Enabled = false;\n                timer.Dispose();
                controller.GetCurrentStrategy().UpdateLatency(server, latency);
            catch (ArgumentException e)\n            {\n            }\n            catch (Exception e)\n            {\n                if (server != null)\n                {\n                    controller.GetCurrentStrategy().SetFailure(server);\n                }\n                Logging.LogUsefulException(e);\n                RetryConnect();
            var defaultValue = registry.GetValue("DefaultConnectionSettings");\n            try\n            {\n                var connections = registry.GetValueNames();\n                foreach (String each in connections)
                    if (!(each.Equals("DefaultConnectionSettings")\n                        || each.Equals("LAN Connection")\n                        || each.Equals("SavedLegacySettings")))\n                    {\n                        //set all the connections's proxy as the lan\n                        registry.SetValue(each, defaultValue);\n                    }

                using (Graphics g = Graphics.FromImage(image))
                                     image.Size,
                var reader = new BarcodeReader
                if (result != null)
                    Console.WriteLine(result.Text);
            }
            catch (Exception e)
                    password = "barfoo!",\n                    isDefault = true

        private void OKButton_Click(object sender, EventArgs e)
            try\n            {\n                Config config = new Config\n                {\n                    server = textBox1.Text,\n                    server_port = int.Parse(textBox2.Text),\n                    password = textBox3.Text,\n                    local_port = int.Parse(textBox4.Text),\n                    isDefault = false\n                };\n                Config.Save(config);\n                this.config = config;\n                reload(config);\n                this.Hide();\n            }\n            catch (FormatException)\n            {\n                MessageBox.Show("there is format problem");\n            }\n            catch (Exception)\n            {\n                MessageBox.Show("there is some problem with parameters");\n            }
        private void cancelButton_Click(object sender, EventArgs e)
            this.button2.Click += new System.EventHandler(this.cancelButton_Click);
            this.button1.Click += new System.EventHandler(this.OKButton_Click);
            this.contextMenuStrip1.Size = new System.Drawing.Size(111, 76);
            Logging.Info("Current language is: " + locale);\n            Init(i18n, locale);
        private byte[] remoteRecvBuffer = new byte[RecvSize];
        private byte[] remoteSendBuffer = new byte[BufferSize];
        private byte[] connetionRecvBuffer = new byte[RecvSize];
        private byte[] connetionSendBuffer = new byte[BufferSize];

            this.tableLayoutPanel4.RowCount = 2;
            this.tableLayoutPanel4.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel4.Size = new System.Drawing.Size(166, 64);



            private EndPoint _remoteEndPoint;
                _remoteEndPoint = SocketUtil.GetEndPoint(server.server, server.server_port);\n                _remote = SocketUtil.CreateSocket(_remoteEndPoint, ProtocolType.Udp);
            DestEndPoint = destEndPoint;
                _remote = SocketUtil.CreateSocket(destEndPoint);
            _remote.BeginConnect(destEndPoint, callback, state);
                EndPoint proxyEP;

                    proxyEP = SocketUtil.GetEndPoint(_config.proxyServer, _config.proxyPort);
            UpdateTrayIcon();



        private Icon icon, icon_in, icon_out, icon_both, previousIcon;
                newIcon = icon;\n            if (newIcon != this.previousIcon)\n            {\n                this.previousIcon = newIcon;
        private void UpdateTrayIconAndNotifyText()\n        {
            Color colorMask = SelectColorMask(enabled, global);\n            Size iconSize = SelectIconSize();\n            UpdateIconSet(colorMask, iconSize, out icon, out icon_in, out icon_out, out icon_both);\n            previousIcon = icon;\n            _notifyIcon.Icon = previousIcon;
        /// <summary>\n        /// Determine the icon size based on the screen DPI.\n        /// </summary>\n        /// <returns></returns>\n        /// https://stackoverflow.com/a/40851713/2075611\n        private Size SelectIconSize()\n        {\n            Size size = new Size(32, 32);\n            int dpi = ViewUtils.GetScreenDpi();\n            if (dpi < 97)\n            {\n                // dpi = 96;\n                size = new Size(16, 16);\n            }\n            else if (dpi < 121)\n            {\n                // dpi = 120;\n                size = new Size(20, 20);\n            }\n            else if (dpi < 145)\n            {\n                // dpi = 144;\n                size = new Size(24, 24);\n            }\n            else\n            {\n                // dpi = 168;\n                size = new Size(28, 28);\n            }\n            return size;\n        }\n        private Color SelectColorMask(bool isProxyEnabled, bool isGlobalProxy)\n        {\n            Color colorMask = Color.White;\n            Utils.WindowsThemeMode currentWindowsThemeMode = Utils.GetWindows10SystemThemeSetting();\n            if (isProxyEnabled)\n            {\n                if (isGlobalProxy)  // global\n                {\n                    colorMask = colorMaskBlue;\n                }\n                else  // PAC\n                {\n                    if (currentWindowsThemeMode == Utils.WindowsThemeMode.Light)
                        colorMask = colorMaskEclipse;
                }\n            }\n            else  // disabled\n            {\n                if (currentWindowsThemeMode == Utils.WindowsThemeMode.Light)\n                {\n                    colorMask = colorMaskDarkSilver;\n                }\n                else\n                {\n                    colorMask = colorMaskLightSilver;\n                }\n            }\n            return colorMask;\n        }\n        private void UpdateIconSet(Color colorMask, Size size,\n            out Icon icon, out Icon icon_in, out Icon icon_out, out Icon icon_both)\n        {\n            Bitmap iconBitmap;\n            // generate the base icon\n            iconBitmap = ViewUtils.ChangeBitmapColor(Resources.ss32Fill, colorMask);\n            iconBitmap = ViewUtils.AddBitmapOverlay(iconBitmap, Resources.ss32Outline);\n            icon = Icon.FromHandle(ViewUtils.ResizeBitmap(iconBitmap, size.Width, size.Height).GetHicon());\n            icon_in = Icon.FromHandle(ViewUtils.ResizeBitmap(ViewUtils.AddBitmapOverlay(iconBitmap, Resources.ss32In), size.Width, size.Height).GetHicon());\n            icon_out = Icon.FromHandle(ViewUtils.ResizeBitmap(ViewUtils.AddBitmapOverlay(iconBitmap, Resources.ss32In), size.Width, size.Height).GetHicon());\n            icon_both = Icon.FromHandle(ViewUtils.ResizeBitmap(ViewUtils.AddBitmapOverlay(iconBitmap, Resources.ss32In, Resources.ss32Out), size.Width, size.Height).GetHicon());
            WindowsThemeMode themeMode = WindowsThemeMode.Dark;
                RegistryKey reg_ThemesPersonalize = Registry.CurrentUser.OpenSubKey(@"Software\Microsoft\Windows\CurrentVersion\Themes\Personalize", false);
                    if ((int)(reg_ThemesPersonalize.GetValue("SystemUsesLightTheme")) == 0) // 0:dark mode, 1:light mode\n                        themeMode = WindowsThemeMode.Dark;
                        themeMode = WindowsThemeMode.Light;
                    var tempFolder = Configuration.Load().tempFolder;\n                    if (string.IsNullOrWhiteSpace(tempFolder))\n                        // don't use "/", it will fail when we call explorer /select xxx/ss_win_temp\xxx.log\n                        tempFolder = "ss_win_temp";\n                    else if (COMMON_ENV.Contains(tempFolder, StringComparer.OrdinalIgnoreCase))\n                        // add subfolder for these common folders\n                        tempFolder += (@"\Shadowsocks\ss_win_temp_" + Application.ExecutablePath.GetHashCode());\n                    tempFolder = Environment.ExpandEnvironmentVariables(tempFolder);\n                    // If `tempFolder` is an absolute path, `Application.StartupPath` will be ignored.\n                    var tempDirectory = Directory.CreateDirectory(Path.Combine(Application.StartupPath, tempFolder));\n                    _tempPath = tempDirectory.FullName;\n                    File.AppendAllText(Path.Combine(_tempPath, TEMP_LOG), $"[{DateTimeOffset.Now.ToString("u")}] Temp folder used by \"{Application.ExecutablePath}\"{Environment.NewLine}");
            this.Font = SystemFonts.MessageBoxFont;
            this.ServersListBox.Dock = DockStyle.Fill;\n            this.tableLayoutPanel5.Dock = DockStyle.Fill;

            | System.Windows.Forms.AnchorStyles.Left)));
            this.tableLayoutPanel5.Controls.Add(this.TempFolderLabel, 0, 1);\n            this.tableLayoutPanel5.Controls.Add(this.TempFolderTextBox, 1, 1);\n            this.tableLayoutPanel5.Location = new System.Drawing.Point(166, 308);
            this.tableLayoutPanel5.RowCount = 2;
            try\n            {\n                using (StreamWriter sw = new StreamWriter(File.Open(Utils.GetTempPath(_userWininetConfigFile), FileMode.Create)))\n                {
            try\n            {\n                string configContent = File.ReadAllText(Utils.GetTempPath(_userWininetConfigFile));

namespace Shadowsocks.Controller.Service
        private readonly List<ITCPHandlerFactory> _factories = new List<ITCPHandlerFactory>();\n        public ISet<TCPHandler> Handlers { get; } = new HashSet<TCPHandler>();

            TCPHandler handler = null;\n            foreach (var factory in _factories)\n            {\n                if (factory.CanHandle(firstPacket, length))\n                {\n                    handler = factory.NewHandler(_controller, _config, this, socket);\n                    break;\n                }\n            }\n            if (handler == null)\n            {

    interface ITCPHandlerFactory
        bool CanHandle(byte[] firstPacket, int length);\n        TCPHandler NewHandler(ShadowsocksController controller, Configuration config, TCPRelay tcprelay, Socket socket);\n    }\n    abstract class TCPHandler\n    {\n        public abstract void StartHandshake(byte[] firstPacket, int length);\n        protected abstract void OnServerConnected(AsyncSession session);\n        protected class AsyncSession
        protected class AsyncSession<T> : AsyncSession
        private ShadowsocksController _controller;\n        protected Configuration Config { get; }\n        private TCPRelay _tcprelay;\n        protected Socket Connection { get; }\n        private Server _server;
        private bool _proxyConnected;\n        private bool _destConnected;\n        private int _totalRead = 0;\n        private int _totalWrite = 0;\n        protected byte[] RemoteRecvBuffer { get; } = new byte[BufferSize];\n        private readonly byte[] _remoteSendBuffer = new byte[BufferSize];\n        protected byte[] ConnetionRecvBuffer { get; } = new byte[BufferSize];\n        private readonly byte[] _connetionSendBuffer = new byte[BufferSize];\n        private IEncryptor _encryptor;\n        private readonly object _encryptionLock = new object();\n        private readonly object _decryptionLock = new object();\n        private bool _connectionShutdown = false;\n        private bool _remoteShutdown = false;\n        protected bool Closed { get; private set; }= false;\n        private readonly object _closeConnLock = new object();
        public TCPHandler(ShadowsocksController controller, Configuration config, TCPRelay tcprelay, Socket socket, bool autoAppendHeader = true)
            _serverHeaderSent = !autoAppendHeader;\n        }\n        private void CreateRemote()\n        {\n            Server server = _controller.GetAServer(IStrategyCallerType.TCP, (IPEndPoint)Connection.RemoteEndPoint, _destEndPoint);
        protected void StartPipe(AsyncSession session)\n        {\n            if (Closed) return;
                session.Remote.BeginReceive(RemoteRecvBuffer, 0, RecvSize, SocketFlags.None, PipeRemoteReceiveCallback, session);\n                Connection.BeginReceive(ConnetionRecvBuffer, 0, RecvSize, SocketFlags.None, PipeConnectionReceiveCallback, session);
            session.Remote.BeginSend(_connetionSendBuffer, 0, bytesToSend, SocketFlags.None, callback, session);
            if (Closed) return;\n            try\n            {\n                var session = EndSendToServer(ar);\n                Connection.BeginReceive(ConnetionRecvBuffer, 0, RecvSize, SocketFlags.None, PipeConnectionReceiveCallback, session);\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void PipeConnectionSendCallback(IAsyncResult ar)\n        {
                Connection.EndSend(ar);\n                session.Remote.BeginReceive(RemoteRecvBuffer, 0, RecvSize, SocketFlags.None, PipeRemoteReceiveCallback, session);
                //services.Add(new Http2Socks5(_config.localPort));
            int len = Socks5Util.HeaderAddrLength(destEndPoint);\n            byte[] request = new byte[len + 3];\n            Socks5Util.FillHeaderAddr(request, 3, destEndPoint);

            int lpNames = 0;
            // Windows Vista or later:  To determine the required buffer size, call RasEnumEntries\n            // with lprasentryname set to NULL. The variable pointed to by lpcb should be set to zero.\n            // The function will return the required buffer size in lpcb and an error code of ERROR_BUFFER_TOO_SMALL.\n            retval = RasEnumEntries(null, null, null, ref lpSize, out lpNames);
                retval = RasEnumEntries(null, null, names, ref lpSize, out lpNames);
            int strategyCount = 0;
                items.Add(strategyCount, item);\n                strategyCount++;
            items.Add(strategyCount++, new MenuItem("-"));\n            int serverCount = 0;
                    item.Tag = configuration.configs.FindIndex(s => s == server);
                    items.Add(strategyCount + serverCount, item);\n                    serverCount++;
                    this.ConfigItem = CreateMenuItem("Edit Servers...", new EventHandler(this.Config_Click)),\n                    CreateMenuItem("Show QRCode...", new EventHandler(this.QRCodeItem_Click)),\n                    CreateMenuItem("Scan QRCode from Screen...", new EventHandler(this.ScanQRCodeItem_Click))

            while (items[0] != SeperatorItem)\n            {\n                items.RemoveAt(0);\n            }
                items.Add(i, item);\n            }
                    var success = controller.AddServerBySSURL(result.Text);\n                    if (success)\n                    {\n                        ShowConfigForm();\n                        return;\n                    }
            List<string> lines = GFWListUpdater.ParseResult(FileManager.NonExclusiveReadAllText(Utils.GetTempPath("gfwlist.txt")));
                string local = FileManager.NonExclusiveReadAllText(PACServer.USER_RULE_FILE, Encoding.UTF8);
            disableItem.Checked = !controller.GetConfigurationCopy().enabled;
            controller.ToggleEnable(false);\n            Configuration config = controller.GetConfigurationCopy();\n            UpdateSystemProxyItemsEnabledStatus(config);\n        }\n        private void UpdateSystemProxyItemsEnabledStatus(Configuration config)\n        {\n            disableItem.Checked = !config.enabled;\n            if (!config.enabled)\n            {\n                globalModeItem.Checked = false;\n                PACModeItem.Checked = false;\n            }\n            else\n            {\n                globalModeItem.Checked = config.global;\n                PACModeItem.Checked = !config.global;\n            }
                LogFilePath = Path.Combine(temppath, "shadowsocks.log");\n                FileStream fs = new FileStream(LogFilePath, FileMode.Append);

        private MenuItem CreateMenuItem(string text, EventHandler click)

        private MenuItem CreateSeperatorItem()

        private MenuItem CreateMenuGroup(string text, MenuItem[] items)\n        {\n            for (int i = 0; i < items.Length; i++)\n            {\n                items[i].Index = i;\n            }

            this.contextMenu1.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {\n                this.enableItem = CreateMenuItem("Enable", new System.EventHandler(this.EnableItem_Click)),\n                CreateMenuGroup("Mode", new System.Windows.Forms.MenuItem[] {\n                    this.PACModeItem = CreateMenuItem("PAC", new System.EventHandler(this.PACModeItem_Click)),\n                    this.globalModeItem = CreateMenuItem("Global", new System.EventHandler(this.GlobalModeItem_Click))\n                }),\n                this.ServersItem = CreateMenuGroup("Servers", new System.Windows.Forms.MenuItem[] {\n                    this.SeperatorItem = CreateSeperatorItem(),\n                    this.ConfigItem = CreateMenuItem("Edit Servers...", new System.EventHandler(this.Config_Click))\n                }),\n                CreateSeperatorItem(),\n                this.AutoStartupItem = CreateMenuItem("Start on Boot", new System.EventHandler(this.AutoStartupItem_Click)),\n                this.ShareOverLANItem = CreateMenuItem("Share over LAN", new System.EventHandler(this.ShareOverLANItem_Click)),\n                CreateMenuItem("Edit PAC File...", new System.EventHandler(this.EditPACFileItem_Click)),\n                CreateSeperatorItem(),\n                CreateMenuItem("Show QRCode...", new System.EventHandler(this.QRCodeItem_Click)),\n                CreateMenuItem("Show Logs...", new System.EventHandler(this.ShowLogItem_Click)),\n                CreateMenuItem("About...", new System.EventHandler(this.Config_Click)),\n                CreateSeperatorItem(),\n                CreateMenuItem("Quit", new System.EventHandler(this.Quit_Click))

                    /*\n                     * Only the first packet contains the socks5 header, it doesn't make sense to parse every packets. \n                     * Also it's unnecessary to parse these data if we turn off the VerboseLogging.\n                     */\n                    object needToFindHeader = null;\n                    if (ar.AsyncState != null && _config.isVerboseLogging)
                        int atyp = _connetionRecvBuffer[0];\n                        string dst_addr;\n                        int dst_port;\n                        switch (atyp)\n                        {\n                            case 1: // IPv4 address, 4 bytes\n                                dst_addr = new IPAddress(_connetionRecvBuffer.Skip(1).Take(4).ToArray()).ToString();\n                                dst_port = (_connetionRecvBuffer[5] << 8) + _connetionRecvBuffer[6];\n                                Logging.Info($"connect to {dst_addr}:{dst_port}");\n                                break;\n                            case 3: // domain name, length + str\n                                int len = _connetionRecvBuffer[1];\n                                dst_addr = System.Text.Encoding.UTF8.GetString(_connetionRecvBuffer, 2, len);\n                                dst_port = (_connetionRecvBuffer[len + 2] << 8) + _connetionRecvBuffer[len + 3];\n                                Logging.Info($"connect to {dst_addr}:{dst_port}");\n                                break;\n                            case 4: // IPv6 address, 16 bytes\n                                dst_addr = new IPAddress(_connetionRecvBuffer.Skip(1).Take(16).ToArray()).ToString();\n                                dst_port = (_connetionRecvBuffer[17] << 8) + _connetionRecvBuffer[18];\n                                Logging.Info($"connect to [{dst_addr}]:{dst_port}");\n                                break;\n                            default:\n                                needToFindHeader = true; // Still not found, try next packet.\n                                break;\n                        }
        private static readonly Logger logger = LogManager.GetCurrentClassLogger();


        // hidden options\n        public bool isIPv6Enabled = false; // for experimental ipv6 support\n        public bool generateLegacyUrl = false; // for pre-sip002 url compatibility\n        public string geositeUrl; // for custom geosite source (and rule group)\n        public string geositeGroup = "geolocation-!cn";\n        public bool geositeBlacklistMode = true;

        private static readonly NLogConfig.LogLevel verboseLogLevel = NLogConfig.LogLevel.Trace;
        private static readonly NLogConfig.LogLevel verboseLogLevel =  NLogConfig.LogLevel.Debug;


using static Shadowsocks.Controller.HotkeyReg;
                RegHotkeyFromString(hotkeyConfig.SwitchSystemProxy, "SwitchSystemProxyCallback", result => HandleRegResult(hotkeyConfig.SwitchSystemProxy, SwitchSystemProxyLabel, result))\n                && RegHotkeyFromString(hotkeyConfig.SwitchSystemProxyMode, "SwitchSystemProxyModeCallback", result => HandleRegResult(hotkeyConfig.SwitchSystemProxyMode, SwitchProxyModeLabel, result))\n                && RegHotkeyFromString(hotkeyConfig.SwitchAllowLan, "SwitchAllowLanCallback", result => HandleRegResult(hotkeyConfig.SwitchAllowLan, SwitchAllowLanLabel, result))\n                && RegHotkeyFromString(hotkeyConfig.ShowLogs, "ShowLogsCallback", result => HandleRegResult(hotkeyConfig.ShowLogs, ShowLogsLabel, result))\n                && RegHotkeyFromString(hotkeyConfig.ServerMoveUp, "ServerMoveUpCallback", result => HandleRegResult(hotkeyConfig.ServerMoveUp, ServerMoveUpLabel, result))\n                && RegHotkeyFromString(hotkeyConfig.ServerMoveDown, "ServerMoveDownCallback", result => HandleRegResult(hotkeyConfig.ServerMoveDown, ServerMoveDownLabel, result));
        private void HandleRegResult(string hotkeyStr, Label label, RegResult result)
            switch (result)
                case RegResult.ParseError:
                    break;\n                case RegResult.UnregSuccess:\n                    label.ResetBackColor();\n                    break;\n                case RegResult.RegSuccess:\n                    label.BackColor = Color.Green;\n                    break;\n                case RegResult.RegFailure:\n                    label.BackColor = Color.Red;\n                    break;\n                default:\n                    break;
            if (config.isDefault)\n            {\n                _isFirstRun = true;\n                ShowConfigForm();\n            }\n            else if(config.autoCheckUpdate)



            _notifyIcon.BalloonTipTitle = I18N.GetString("Shadowsocks is here");\n            _notifyIcon.BalloonTipText = I18N.GetString("You can turn on/off Shadowsocks in the context menu");\n            _notifyIcon.BalloonTipIcon = ToolTipIcon.Info;\n            _notifyIcon.ShowBalloonTip(0);
            _lastSelectedIndex = _modifiedConfiguration.index;\n            if (_lastSelectedIndex < 0)\n            {\n                _lastSelectedIndex = 0;\n            }\n            ServersListBox.SelectedIndex = _lastSelectedIndex;
            _lastSelectedIndex = ServersListBox.SelectedIndex;\n            if (_lastSelectedIndex >= 0 && _lastSelectedIndex < _modifiedConfiguration.configs.Count)\n            {\n                _modifiedConfiguration.configs.RemoveAt(_lastSelectedIndex);\n            }\n            if (_lastSelectedIndex >= _modifiedConfiguration.configs.Count)

            controller.SelectServerIndex(_modifiedConfiguration.configs.IndexOf(server));

            if (isCipher)
                bytesRemaining = _encryptBytesRemaining;\n                ic = _encryptIC;\n                sodiumBuf = _encryptBuf;\n                iv = _encryptIV;\n            }\n            else\n            {\n                bytesRemaining = _decryptBytesRemaining;\n                ic = _decryptIC;\n                sodiumBuf = _decryptBuf;\n                iv = _decryptIV;\n            }\n            int padding = bytesRemaining;\n            Buffer.BlockCopy(buf, 0, sodiumBuf, padding, length);\n            switch (_cipher)\n            {\n                case CIPHER_SALSA20:\n                    Sodium.crypto_stream_salsa20_xor_ic(sodiumBuf, sodiumBuf, (ulong)(padding + length), iv, ic, _key);\n                    break;\n                case CIPHER_CHACHA20:\n                    Sodium.crypto_stream_chacha20_xor_ic(sodiumBuf, sodiumBuf, (ulong)(padding + length), iv, ic, _key);\n                    break;\n                case CIPHER_CHACHA20_IETF:\n                    Sodium.crypto_stream_chacha20_ietf_xor_ic(sodiumBuf, sodiumBuf, (ulong)(padding + length), iv, (uint)ic, _key);\n                    break;\n            }\n            Buffer.BlockCopy(sodiumBuf, padding, outbuf, 0, length);\n            padding += length;\n            ic += (ulong)padding / SODIUM_BLOCK_SIZE;\n            bytesRemaining = padding % SODIUM_BLOCK_SIZE;\n            if (isCipher)\n            {\n                _encryptBytesRemaining = bytesRemaining;\n                _encryptIC = ic;\n            }\n            else\n            {\n                _decryptBytesRemaining = bytesRemaining;\n                _decryptIC = ic;
﻿using shadowsocks.Model;\nusing shadowsocks.Properties;
namespace shadowsocks.Controller
﻿using shadowsocks.Properties;
namespace shadowsocks.Controller
﻿using shadowsocks.Model;
namespace shadowsocks.Controller
﻿using shadowsocks.Controller;\nusing shadowsocks.Properties;\nusing shadowsocks.View;
namespace shadowsocks
                ServersListBox.Items.Add(string.IsNullOrEmpty(server.server) ? "New server" : server.server + ":" + server.server_port);
            this.ServersItem,\n            this.menuItem4,
            // ServersItem\n            // \n            this.ServersItem.Index = 1;\n            this.ServersItem.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {\n            this.SeperatorItem,\n            this.ConfigItem});\n            this.ServersItem.Text = "&Servers";\n            // \n            // SeperatorItem\n            // \n            this.SeperatorItem.Index = 0;\n            this.SeperatorItem.Text = "-";\n            // \n            // ConfigItem\n            // \n            this.ConfigItem.Index = 1;\n            this.ConfigItem.Text = "Edit Servers...";\n            this.ConfigItem.Click += new System.EventHandler(this.Config_Click);\n            // \n            // menuItem4\n            // \n            this.menuItem4.Index = 2;\n            this.menuItem4.Text = "-";
            this.editPACFileItem.Index = 3;\n            this.editPACFileItem.Text = "Edit &PAC File...";
                services.Add(new PortForwarder(privoxyRunner.RunningPort));
    class PrivoxyRunner
        static PrivoxyRunner()
                Process[] existingPrivoxy = Process.GetProcessesByName("ss_privoxy");\n                foreach (Process p in existingPrivoxy.Where(IsChildProcess))
                string privoxyConfig = Resources.privoxy_conf;
                privoxyConfig = privoxyConfig.Replace("__SOCKS_PORT__", configuration.localPort.ToString());\n                privoxyConfig = privoxyConfig.Replace("__PRIVOXY_BIND_PORT__", _runningPort.ToString());\n                privoxyConfig = privoxyConfig.Replace("__PRIVOXY_BIND_IP__", configuration.shareOverLan ? "0.0.0.0" : "127.0.0.1");\n                FileManager.ByteArrayToFile(Utils.GetTempPath(UniqueConfigFile), Encoding.UTF8.GetBytes(privoxyConfig));
                    // https://docs.microsoft.com/en-us/windows/win32/seccrypto/common-hresult-values\n                    //if ((uint)ex.ErrorCode == 0x80004005)\n                    //  https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-erref/18d8fbe8-a967-4f1c-ae50-99ca8e491d2d\n                    if (ex.NativeErrorCode == 0x00000002)


                JArray result = JArray.Parse(response);
                if (result != null)\n                {\n                    foreach (JObject release in result)\n                    {\n                        if ((bool)release["prerelease"])
                            continue;\n                        }\n                        foreach (JObject asset in (JArray)release["assets"])\n                        {\n                            Asset ass = new Asset();\n                            ass.Parse(asset);\n                            if (ass.IsNewVersion(Version))\n                            {\n                                asserts.Add(ass);\n                            }

using System.Text.RegularExpressions;

﻿using System;
using Shadowsocks.Controller;\nusing Newtonsoft.Json;
    class Encryptor : IDisposable
        public static string[] encryption_names = new string[] {\n            "table",\n            "rc4",\n            "aes-256-cfb",\n            "aes-192-cfb",\n            "aes-128-cfb",\n            "bf-cfb"\n        };
        public string method = "table";\n        public string password;\n        public byte[] key;\n        private RC4 rc4 = null;\n        private Cipher cipher = null;\n        private IntPtr encryptCTX;\n        private IntPtr decryptCTX;\n        private static Dictionary<string, byte[]> cachedKeys = new Dictionary<string, byte[]>();\n        private static Dictionary<string, Cipher> cachedCiphers = new Dictionary<string, Cipher>();\n        public void Dispose()\n        {\n            if (encryptCTX != IntPtr.Zero)\n            {\n                Native.EVP_CIPHER_CTX_cleanup(encryptCTX);\n                Native.OPENSSL_free(encryptCTX);\n                encryptCTX = IntPtr.Zero;\n            }\n            if (decryptCTX != IntPtr.Zero)\n            {\n                Native.EVP_CIPHER_CTX_cleanup(decryptCTX);\n                Native.OPENSSL_free(decryptCTX);\n                decryptCTX = IntPtr.Zero;\n            }\n        }\n        ~Encryptor() {\n            Dispose();\n        }

            }\n            else if (method == "table" || method == "" || method == null)\n            {

            else\n            {\n                initKey(password, method);\n            }\n        }\n        private void initCipher(ref IntPtr ctx, byte[] iv, bool isCipher)\n        {\n            ctx = Native.OPENSSL_malloc(Marshal.SizeOf(typeof(CipherContext.EVP_CIPHER_CTX)));\n            int enc = isCipher ? 1 : 0;\n            Native.EVP_CIPHER_CTX_init(ctx);\n            Native.ExpectSuccess(Native.EVP_CipherInit_ex(\n                ctx, this.cipher.Handle, IntPtr.Zero, null, null, enc));\n            Native.ExpectSuccess(Native.EVP_CIPHER_CTX_set_key_length(ctx, key.Length));\n            Native.ExpectSuccess(Native.EVP_CIPHER_CTX_set_padding(ctx, 1));\n            Native.ExpectSuccess(Native.EVP_CipherInit_ex(\n                ctx, this.cipher.Handle, IntPtr.Zero, key, iv, enc));\n        }\n        private void initKey(string password, string method)\n        {\n            string k = method + ":" + password;\n            if (cachedKeys.ContainsKey(k))\n            {\n                key = cachedKeys[k];\n                cipher = cachedCiphers[k];\n                return;\n            }\n            cipher = Cipher.CreateByName(method);\n            if (cipher == null)\n            {\n                throw new NullReferenceException();\n            }\n            byte[] passbuf = System.Text.Encoding.UTF8.GetBytes(password); ;\n            key =  new byte[cipher.KeyLength];\n            byte[] iv = new byte[cipher.IVLength];\n            Native.EVP_BytesToKey(cipher.Handle, MessageDigest.MD5.Handle, null, passbuf, passbuf.Length, 1, key, iv);\n            cachedKeys[k] = key;\n            cachedCiphers[k] = cipher;\n        }\n        private byte[] sslEncrypt(byte[] buf, int length)\n        {\n            if (encryptCTX == IntPtr.Zero)\n            {\n                int ivLen = cipher.IVLength;\n                byte[] iv = new byte[ivLen];\n                Native.RAND_bytes(iv, iv.Length);\n                initCipher(ref encryptCTX, iv, true);\n                int outLen = length + cipher.BlockSize;\n                byte[] cipherText = new byte[outLen];\n                Native.EVP_CipherUpdate(encryptCTX, cipherText, out outLen, buf, length);\n                byte[] result = new byte[outLen + ivLen];\n                System.Buffer.BlockCopy(iv, 0, result, 0, ivLen);\n                System.Buffer.BlockCopy(cipherText, 0, result, ivLen, outLen);\n                return result;\n            }\n            else\n            {\n                int outLen = length + cipher.BlockSize;\n                byte[] cipherText = new byte[outLen];\n                Native.EVP_CipherUpdate(encryptCTX, cipherText, out outLen, buf, length);\n                byte[] result = new byte[outLen];\n                System.Buffer.BlockCopy(cipherText, 0, result, 0, outLen);\n                return result;\n            }\n        }\n        private byte[] sslDecrypt(byte[] buf, int length)\n        {\n            if (decryptCTX == IntPtr.Zero)\n            {\n                int ivLen = cipher.IVLength;\n                byte[] iv = new byte[ivLen];\n                System.Buffer.BlockCopy(buf, 0, iv, 0, ivLen);\n                initCipher(ref decryptCTX, iv, false);\n                int outLen = length + cipher.BlockSize;\n                outLen -= ivLen;\n                byte[] cipherText = new byte[outLen];\n                byte[] subset = new byte[length - ivLen];\n                System.Buffer.BlockCopy(buf, ivLen, subset, 0, length - ivLen);\n                Native.EVP_CipherUpdate(decryptCTX, cipherText, out outLen, subset, length - ivLen);\n                byte[] result = new byte[outLen];\n                System.Buffer.BlockCopy(cipherText, 0, result, 0, outLen);\n                return result;\n            }\n            else\n            {\n                int outLen = length + cipher.BlockSize;\n                byte[] cipherText = new byte[outLen];\n                Native.EVP_CipherUpdate(decryptCTX, cipherText, out outLen, buf, length);\n                byte[] result = new byte[outLen];\n                System.Buffer.BlockCopy(cipherText, 0, result, 0, outLen);\n                return result;\n            }\n        }\n        public byte[] Encrypt(byte[] buf, int length)
                case "table":
                    return buf;\n                    break;\n                case "rc4":
                    return buf;\n                    break;\n                default:\n                    return sslEncrypt(buf, length);\n            }\n        }\n        public byte[] Decrypt(byte[] buf, int length)
                case "table":
                    return buf;\n                    break;\n                case "rc4":
                    return buf;\n                    break;\n                default:\n                    return sslDecrypt(buf, length);
            catch (Exception ex)
                MessageBox.Show(ex.ToString());
            connection.Shutdown(SocketShutdown.Send);
                remote.Shutdown(SocketShutdown.Send);\n            }\n            encryptor.Dispose();
        public static Sip003Plugin CreateIfConfigured(Server server, bool showPluginOutput)
            return new Sip003Plugin(\n                server.plugin,\n                server.plugin_opts,\n                server.plugin_args,\n                server.server,\n                server.server_port,\n                showPluginOutput);
        private Sip003Plugin(string plugin, string pluginOpts, string pluginArgs, string serverAddress, int serverPort, bool showPluginOutput)


            this.ConfigItem,\n            this.QuitItem});
            // ConfigItem\n            // \n            this.ConfigItem.Name = "ConfigItem";\n            this.ConfigItem.Size = new System.Drawing.Size(127, 22);\n            this.ConfigItem.Text = "Config";\n            this.ConfigItem.Click += new System.EventHandler(this.Config_Click);\n            // \n            // QuitItem\n            // \n            this.QuitItem.Name = "QuitItem";\n            this.QuitItem.Size = new System.Drawing.Size(127, 22);\n            this.QuitItem.Text = "Quit";\n            this.QuitItem.Click += new System.EventHandler(this.Quit_Click);

                if (dataLists == null) continue;\n                foreach (var dataList in dataLists.Where(dataList => dataList != null))

    public partial class ConfigForm : Form
        public ConfigForm()
                    if (command == 1)\n                    {\n                        byte[] response = { 5, 0, 0, 1, 0, 0, 0, 0, 0, 0 };\n                        connection.BeginSend(response, 0, response.Length, 0, new AsyncCallback(StartConnect), null);\n                    }\n                    else if (command == 3)\n                    {\n                        HandleUDPAssociate();\n                    }
        private static void SetIEProxy(bool enable, bool global, string proxyServer, string pacURL, string connName)
                        Value = { dwValue = (int)(INTERNET_OPTION_PER_CONN_FLAGS_UI.PROXY_TYPE_PROXY\n                                                | INTERNET_OPTION_PER_CONN_FLAGS_UI.PROXY_TYPE_DIRECT) }
                        Value = { pszValue = Marshal.StringToHGlobalAuto(proxyServer) }
                        Value = { pszValue = Marshal.StringToHGlobalAuto("<local>") }
//            bReturn = NativeMethods.InternetSetOption(\n//                IntPtr.Zero,\n//                INTERNET_OPTION.INTERNET_OPTION_SETTINGS_CHANGED,\n//                IntPtr.Zero, 0);\n//            if ( ! bReturn )\n//            {\n//                Logging.Error("InternetSetOption:INTERNET_OPTION_SETTINGS_CHANGED");\n//            }\n            bReturn = NativeMethods.InternetSetOption(
                INTERNET_OPTION.INTERNET_OPTION_PROXY_SETTINGS_CHANGED,
            if (!bReturn)\n            {\n                Logging.Error("InternetSetOption:INTERNET_OPTION_PROXY_SETTINGS_CHANGED");\n            }\n            bReturn = NativeMethods.InternetSetOption(
﻿using Microsoft.VisualBasic.FileIO;\nusing Shadowsocks.Properties;\nusing Shadowsocks.Util;\nusing System.Collections.Generic;
using System.Text;




            LoadLibrary(dllPath);
        public extern static int crypto_stream_salsa20_xor_ic(byte[] c, byte[] m, ulong mlen, byte[] n, ulong ic, byte[] k);
        public extern static int crypto_stream_chacha20_xor_ic(byte[] c, byte[] m, ulong mlen, byte[] n, ulong ic, byte[] k);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
            _remote.BeginSend(buffer, offset, size, socketFlags, callback, state);
            _remote.BeginReceive(buffer, offset, size, socketFlags, callback, state);
            _remote.Shutdown(how);
            _remote.Dispose();
            this.QRCodeWebBrowser.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) \n            | System.Windows.Forms.AnchorStyles.Left) \n            | System.Windows.Forms.AnchorStyles.Right)));
            this.AutoSize = true;\n            this.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;\n            this.ClientSize = new System.Drawing.Size(204, 202);
        private IntPtr _encryptCtx = IntPtr.Zero;\n        private IntPtr _decryptCtx = IntPtr.Zero;
        private byte[] _encryptIVOffset;\n        private byte[] _decryptIVOffset;
        private void InitCipher(ref IntPtr ctx, byte[] iv, bool isCipher)\n        {\n            ctx = Marshal.AllocHGlobal(_cipherInfo[3]);\n            byte[] realkey;\n            if (_method == "rc4-md5")\n            {\n                byte[] temp = new byte[keyLen + ivLen];\n                realkey = new byte[keyLen];\n                Array.Copy(_key, 0, temp, 0, keyLen);\n                Array.Copy(iv, 0, temp, keyLen, ivLen);\n                realkey = MD5.Create().ComputeHash(temp);\n            }\n            else\n            {\n                realkey = _key;\n            }\n            if (_cipher == CIPHER_AES)\n            {\n                PolarSSL.aes_init(ctx);\n                // PolarSSL takes key length by bit\n                // since we'll use CFB mode, here we both do enc, not dec\n                PolarSSL.aes_setkey_enc(ctx, realkey, keyLen * 8);\n                if (isCipher)\n                {\n                    _encryptIV = new byte[ivLen];\n                    _encryptIVOffset = new byte[8];\n                    Array.Copy(iv, _encryptIV, ivLen);
                    _decryptIV = new byte[ivLen];\n                    _decryptIVOffset = new byte[8];\n                    Array.Copy(iv, _decryptIV, ivLen);\n                }\n            }\n            else if (_cipher == CIPHER_BF)\n            {\n                PolarSSL.blowfish_init(ctx);\n                // PolarSSL takes key length by bit\n                PolarSSL.blowfish_setkey(ctx, realkey, keyLen * 8);\n                if (isCipher)\n                {\n                    _encryptIV = new byte[ivLen];\n                    _encryptIVOffset = new byte[8];\n                    Array.Copy(iv, _encryptIV, ivLen);\n                }\n                else\n                {\n                    _decryptIV = new byte[ivLen];\n                    _decryptIVOffset = new byte[8];\n                    Array.Copy(iv, _decryptIV, ivLen);\n                }\n            }\n            else if (_cipher == CIPHER_RC4)\n            {\n                PolarSSL.arc4_init(ctx);\n                // PolarSSL RC4 takes key length by byte\n                PolarSSL.arc4_setup(ctx, realkey, keyLen);
            if (_encryptCtx == IntPtr.Zero)
                    if (_disposed)\n                    {\n                        throw new ObjectDisposedException(this.ToString());\n                    }\n                    switch (_cipher)\n                    {\n                        case CIPHER_AES:\n                            PolarSSL.aes_crypt_cfb128(_encryptCtx, PolarSSL.AES_ENCRYPT, length, _encryptIVOffset, _encryptIV, buf, tempbuf);\n                            break;\n                        case CIPHER_BF:\n                            PolarSSL.blowfish_crypt_cfb64(_encryptCtx, PolarSSL.BLOWFISH_ENCRYPT, length, _encryptIVOffset, _encryptIV, buf, tempbuf);\n                            break;\n                        case CIPHER_RC4:\n                            PolarSSL.arc4_crypt(_encryptCtx, length, buf, tempbuf);\n                            break;\n                    }\n                    outlength = length + ivLen;\n                    Buffer.BlockCopy(tempbuf, 0, outbuf, ivLen, length);
                if (_disposed)\n                {\n                    throw new ObjectDisposedException(this.ToString());\n                }\n                switch (_cipher)\n                {\n                    case CIPHER_AES:\n                        PolarSSL.aes_crypt_cfb128(_encryptCtx, PolarSSL.AES_ENCRYPT, length, _encryptIVOffset, _encryptIV, buf, outbuf);\n                        break;\n                    case CIPHER_BF:\n                        PolarSSL.blowfish_crypt_cfb64(_encryptCtx, PolarSSL.BLOWFISH_ENCRYPT, length, _encryptIVOffset, _encryptIV, buf, outbuf);\n                        break;\n                    case CIPHER_RC4:\n                        PolarSSL.arc4_crypt(_encryptCtx, length, buf, outbuf);\n                        break;
            if (_decryptCtx == IntPtr.Zero)
                    if (_disposed)\n                    {\n                        throw new ObjectDisposedException(this.ToString());\n                    }\n                    switch (_cipher)\n                    {\n                        case CIPHER_AES:\n                            PolarSSL.aes_crypt_cfb128(_decryptCtx, PolarSSL.AES_DECRYPT, length - ivLen, _decryptIVOffset, _decryptIV, tempbuf, outbuf);\n                            break;\n                        case CIPHER_BF:\n                            PolarSSL.blowfish_crypt_cfb64(_decryptCtx, PolarSSL.BLOWFISH_DECRYPT, length - ivLen, _decryptIVOffset, _decryptIV, tempbuf, outbuf);\n                            break;\n                        case CIPHER_RC4:\n                            PolarSSL.arc4_crypt(_decryptCtx, length - ivLen, tempbuf, outbuf);\n                            break;
                if (_disposed)\n                {\n                    throw new ObjectDisposedException(this.ToString());\n                }\n                switch (_cipher)\n                {\n                    case CIPHER_AES:\n                        PolarSSL.aes_crypt_cfb128(_decryptCtx, PolarSSL.AES_DECRYPT, length, _decryptIVOffset, _decryptIV, buf, outbuf);\n                        break;\n                    case CIPHER_BF:\n                        PolarSSL.blowfish_crypt_cfb64(_decryptCtx, PolarSSL.BLOWFISH_DECRYPT, length, _decryptIVOffset, _decryptIV, buf, outbuf);\n                        break;\n                    case CIPHER_RC4:\n                        PolarSSL.arc4_crypt(_decryptCtx, length, buf, outbuf);\n                        break;
        public extern static void aes_init(IntPtr ctx);
        public extern static void aes_free(IntPtr ctx);
        public extern static int aes_setkey_enc(IntPtr ctx, byte[] key, int keysize);
        public extern static int aes_crypt_cfb128(IntPtr ctx, int mode, int length, byte[] iv_off, byte[] iv, byte[] input, byte[] output);
        public extern static void arc4_init(IntPtr ctx);
        public extern static void arc4_free(IntPtr ctx);
        public extern static void arc4_setup(IntPtr ctx, byte[] key, int keysize);
        public extern static int arc4_crypt(IntPtr ctx, int length, byte[] input, byte[] output);
        public extern static void blowfish_init(IntPtr ctx);
        public extern static void blowfish_free(IntPtr ctx);
        public extern static int blowfish_setkey(IntPtr ctx, byte[] key, int keysize);
        public extern static int blowfish_crypt_cfb64(IntPtr ctx, int mode, int length, byte[] iv_off, byte[] iv, byte[] input, byte[] output);
                        encryptor = new PolarSSLEncryptor("aes-256-cfb", "barfoo!");\n                        decryptor = new PolarSSLEncryptor("aes-256-cfb", "barfoo!");

using System.Threading.Tasks;

        private static string GetHash(string content)
            var contentBytes = Encoding.ASCII.GetBytes(content);\n            using (var md5 = System.Security.Cryptography.MD5.Create())\n            {\n                var md5Bytes = md5.ComputeHash(contentBytes);\n                return BitConverter.ToString(md5Bytes).Replace("-", "");\n            };
                    switch (each)
                        case "DefaultConnectionSettings":\n                        case "LAN Connection":\n                        case "SavedLegacySettings":\n                            continue;\n                        default:\n                            //set all the connections's proxy as the lan\n                            registry.SetValue(each, defaultValue);\n                            continue;
        public bool StatisticsEnabled { get; set; } = true;\n        public bool ByHourOfDay { get; set; } = true;
        public int ChoiceKeptMinutes { get; set; } = 10;\n        public int DataCollectionMinutes { get; set; } = 10;\n        public int RepeatTimesNum { get; set; } = 4;




            this.tableLayoutPanel1.RowCount = 7;\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle());\n            this.tableLayoutPanel1.Size = new System.Drawing.Size(255, 167);
            "camellia-256-cfb",\n            "aes-128-gcm",\n            "aes-192-gcm",\n            "aes-256-gcm",\n            "chacha20-ietf-poly1305"});
            // TimeoutLabel\n            // \n            this.TimeoutLabel.Anchor = System.Windows.Forms.AnchorStyles.Right;\n            this.TimeoutLabel.AutoSize = true;\n            this.TimeoutLabel.Location = new System.Drawing.Point(6, 144);\n            this.TimeoutLabel.Name = "TimeoutLabel";\n            this.TimeoutLabel.RightToLeft = System.Windows.Forms.RightToLeft.No;\n            this.TimeoutLabel.Size = new System.Drawing.Size(77, 12);\n            this.TimeoutLabel.TabIndex = 10;\n            this.TimeoutLabel.Text = "Timeout(Sec)";\n            // \n            // TimeoutTextBox\n            // \n            this.TimeoutTextBox.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));\n            this.TimeoutTextBox.Location = new System.Drawing.Point(89, 140);\n            this.TimeoutTextBox.MaxLength = 5;\n            this.TimeoutTextBox.Name = "TimeoutTextBox";\n            this.TimeoutTextBox.Size = new System.Drawing.Size(160, 21);\n            this.TimeoutTextBox.TabIndex = 11;
            polipoRunner.Start(_config);\n            local = new Local(_config);
                pacServer.Start(_config);
        private Server _server;\n        private bool _shareOverLAN;
        public Local(Configuration config)\n        {\n            this._server = config.GetCurrentServer();\n            _shareOverLAN = config.shareOverLan;
                _listener = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);\n                _listener.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, true);\n                IPEndPoint localEndPoint = null;\n                if (_shareOverLAN)\n                {\n                    localEndPoint = new IPEndPoint(IPAddress.Any, _server.local_port);\n                }\n                else\n                {\n                    localEndPoint = new IPEndPoint(IPAddress.Loopback, _server.local_port);\n                }
        public void Start(Configuration configuration)
            try\n            {\n                // Create a TCP/IP socket.\n                _listener = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);\n                _listener.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, true);\n                IPEndPoint localEndPoint = null;\n                if (configuration.shareOverLan)\n                {\n                    localEndPoint = new IPEndPoint(IPAddress.Any, PORT);\n                }\n                else\n                {\n                    localEndPoint = new IPEndPoint(IPAddress.Loopback, PORT);\n                }\n                // Bind the socket to the local endpoint and listen for incoming connections.\n                _listener.Bind(localEndPoint);\n                _listener.Listen(100);\n                _listener.BeginAccept(\n                    new AsyncCallback(AcceptCallback),\n                    _listener);\n                WatchPacFile();\n            }\n            catch (SocketException)\n            {\n                _listener.Close();\n                throw;\n            }\n        }\n        public void Stop()\n        {\n            _listener.Close();\n            _listener = null;


                IPEndPoint localEndPoint = (IPEndPoint)conn.LocalEndPoint;\n                string proxy = "PROXY " + localEndPoint.Address + ":8123;";

            this.ServersItem.Index = 2;
            this.menuItem4.Index = 3;
        public void Start(Configuration configuration)
        public TCPHandler(TCPRelay tcprelay, Configuration config)
                IPEndPoint destEP = new IPEndPoint(ipAddress, server.server_port);\n                // Setting up proxy\n                IPEndPoint proxyEP;\n                if (config.useProxy)\n                {\n                    parsed = IPAddress.TryParse(config.proxyServer, out ipAddress);\n                    if (!parsed)\n                    {\n                        IPHostEntry ipHostInfo = Dns.GetHostEntry(config.proxyServer);\n                        ipAddress = ipHostInfo.AddressList[0];\n                    }\n                    remote = new Socks5Proxy();\n                    proxyEP = new IPEndPoint(ipAddress, config.proxyPort);\n                }\n                else\n                {\n                    remote = new DirectConnect();\n                    proxyEP = destEP;\n                }
                proxyTimer.DestEndPoint = destEP;
                remote.BeginConnectProxy(proxyEP, new AsyncCallback(ProxyConnectCallback), proxyTimer);
                            if (!ParseHost(m.Groups[2].Value))
                                throw new Exception("Bad http header: " + line);
                            if (!ParseHost(line.Substring(6).Trim()))
                                throw new Exception("Bad http header: " + line);
        class Context\n        {\n            public int index1 = 0;\n            public int index2 = 0;\n        }\n        private Context enc_ctx = new Context();\n        private Context dec_ctx = new Context();
            EncryptOutput(enc_ctx, table, data, length);
            EncryptOutput(dec_ctx, table, data, length);
        private void EncryptOutput(Context ctx, byte[] s, byte[] data, int length)
                ctx.index1 = (ctx.index1 + 1) & 255;\n                ctx.index2 = (ctx.index2 + s[ctx.index1]) & 255;\n                Swap(s, ctx.index1, ctx.index2);\n                data[n] = (byte)(b ^ s[(s[ctx.index1] + s[ctx.index2]) & 255]);
        private static string _tempPath = null;
            if (_tempPath == null)\n            {\n                try\n                {\n                    Directory.CreateDirectory(Path.Combine(Application.StartupPath, "ss_win_temp"));\n                    // don't use "/", it will fail when we call explorer /select xxx/ss_win_temp\xxx.log\n                    _tempPath = Path.Combine(Application.StartupPath, "ss_win_temp");\n                }\n                catch (Exception e)\n                {\n                    Logging.Error(e);\n                    throw;\n                }\n            }\n            return _tempPath;