file _ stream . write ( content , 0 , content . length ) ; file _ stream . close ( ) ; return true ; } catch ( exception exception ) { console . write _ line ( STR , exception . to _ string ( ) ) ; } return false ;
int bytes _ remain = ( int ) states [ 0 ] ; var on _ success = ( action ) states [ 1 ] ; if ( bytes _ read > = bytes _ remain ) { first _ packet _ length = bytes _ read + 2 ; int atyp = connetion _ recv _ buffer [ 0 ] ; string dst _ addr = STR ; int dst _ port = - 1 ; switch ( atyp ) {
if ( bytes _ read > = bytes _ remain ) { first _ packet _ length = bytes _ read + 2 ; int atyp = connetion _ recv _ buffer [ 0 ] ; string dst _ addr = STR ; int dst _ port = - 1 ; switch ( atyp ) { case atyp _ i _ pv : dst _ addr = new ip _ address ( connetion _ recv _ buffer . skip ( 1 ) . take ( NUM ) . to _ array ( ) ) . to _ string ( ) ;
lock ( close _ conn _ lock ) { if ( closed ) { remote . close ( ) ; return ; } current _ remote _ session = session ; } proxy _ timer proxy _ timer = new proxy _ timer ( proxy _ timeout ) { auto _ reset = false } ;
timer . elapsed - = proxy _ connect _ timer _ elapsed ; timer . enabled = false ; timer . dispose ( ) ; if ( proxy _ connected | | dest _ connected | | closed ) { return ; } var proxy = timer . session . remote ; logger . info ( $ STR ) ; proxy . close ( ) ;
proxy _ timer timer = session . state ; var dest _ end _ point = timer . dest _ end _ point ; var server = timer . server ; timer . elapsed - = proxy _ connect _ timer _ elapsed ; timer . enabled = false ; timer . dispose ( ) ; var remote = session . remote ; remote . end _ connect _ proxy ( ar ) ; proxy _ connected = true ; if ( ! ( remote is direct _ connect ) )
timer . elapsed - = dest _ connect _ timer _ elapsed ; timer . enabled = false ; timer . dispose ( ) ; if ( dest _ connected | | closed ) { return ; } var session = timer . session ; server server = timer . server ; i _ strategy strategy = controller . get _ current _ strategy ( ) ;
server _ timer timer = session . state ; server = timer . server ; timer . elapsed - = dest _ connect _ timer _ elapsed ; timer . enabled = false ; timer . dispose ( ) ; var remote = session . remote ; remote . end _ connect _ dest ( ar ) ; dest _ connected = true ; logger . debug ( $ STR ) ; var latency = date _ time . now - start _ connect _ time ;
int bytes _ read = session . remote . end _ receive ( ar ) ; total _ read + = bytes _ read ; tcprelay . update _ inbound _ counter ( server , bytes _ read ) ; if ( bytes _ read > 0 ) { last _ activity = date _ time . now ; int bytes _ to _ send = - 1 ; lock ( decryption _ lock ) { try
} private void connect _ callback ( i _ async _ result ar ) { server server = null ; if ( closed ) { return ; } try
privoxy _ config = privoxy _ config . replace ( STR , configuration . local _ port . to _ string ( ) ) ; privoxy _ config = privoxy _ config . replace ( STR , running _ port . to _ string ( ) ) ; privoxy _ config = privoxy _ config . replace ( STR , configuration . share _ over _ lan ? STR : STR ) ; file _ manager . byte _ array _ to _ file ( utils . get _ temp _ path ( unique _ config _ file ) , encoding . ut . get _ bytes ( privoxy _ config ) ) ; process = new process ( ) ; process . start _ info . file _ name = STR ; process . start _ info . arguments = unique _ config _ file ; process . start _ info . working _ directory = utils . get _ temp _ path ( ) ; process . start _ info . window _ style = process _ window _ style . hidden ; process . start _ info . use _ shell _ execute = true ;
throw new argument _ exception ( n . get _ string ( STR ) ) ; } private static void check _ server ( string server ) { if ( string . is _ null _ or _ empty ( server ) ) throw new argument _ exception ( n . get _ string ( STR ) ) ; } } }
throw new argument _ exception ( n . get _ string ( STR ) ) ; } } }
{ return n . get _ string ( STR ) ; } if ( string . is _ null _ or _ empty ( remarks ) ) { return server + STR + server _ port ; } else { return remarks + STR + server + STR + server _ port + STR ;
{ return server + STR + server _ port ; } else { return remarks + STR + server + STR + server _ port + STR ; } } public server ( ) {
{ update _ online _ pacurl _ item _ click ( sender , e ) ; } if ( ! string . is _ null _ or _ empty ( controller . get _ configuration _ copy ( ) . pac _ url ) ) { local _ pac _ item . checked = false ; online _ pac _ item . checked = true ; controller . use _ online _ pac ( true ) ; } update _ pac _ items _ enabled _ status ( ) ;
{ local _ pac _ item . checked = false ; online _ pac _ item . checked = true ; controller . use _ online _ pac ( true ) ; } update _ pac _ items _ enabled _ status ( ) ; } } private void update _ online _ pacurl _ item _ click ( object sender , event _ args e ) {
file _ stream fs = new file _ stream ( log _ file , file _ mode . append ) ; stream _ writer _ with _ timestamp sw = new stream _ writer _ with _ timestamp ( fs ) ; sw . auto _ flush = true ; console . set _ out ( sw ) ; console . set _ error ( sw ) ; return true ; } catch ( io _ exception e ) { console . write _ line ( e . to _ string ( ) ) ;
var remote = session . remote ; if ( bytes _ read > 0 ) { * only the first packet contains the socks header , it doesn ' t make sense to parse every packets . * also it ' s unnecessary to parse these data if we turn off the verbose _ logging . * / if ( session . state & & config . is _ verbose _ logging ) { int atyp = connetion _ recv _ buffer [ 0 ] ; string dst _ addr ;
} } private string get _ pac _ content ( ) { if ( file . exists ( pac _ file ) ) { return file . read _ all _ text ( pac _ file , encoding . ut ) ; } else {
item . tag = strategy . id ; item . click + = a _ strategy _ item _ click ; items . add ( i , item ) ; i + + ; } configuration configuration = controller . get _ configuration _ copy ( ) ; foreach ( var server in configuration . configs ) { menu _ item item = new menu _ item ( server . friendly _ name ( ) ) ;
buffer _ data _ length = length ; try { new _ package _ recv ( ) ; } catch ( exception ex ) { on _ exception ( ex ) ; on _ finish ( ) ; }
} internal string touch _ user _ rule _ file ( ) { if ( file . exists ( user _ rule _ file ) ) { return user _ rule _ file ; } else {
} } private void watch _ pac _ file ( ) { pac _ file _ watcher ? . dispose ( ) ; pac _ file _ watcher = new file _ system _ watcher ( directory . get _ current _ directory ( ) ) ; pac _ file _ watcher . notify _ filter = notify _ filters . last _ write | notify _ filters . file _ name | notify _ filters . directory _ name ; pac _ file _ watcher . filter = pac _ file ; pac _ file _ watcher . changed + = pac _ file _ watcher _ changed ; pac _ file _ watcher . created + = pac _ file _ watcher _ changed ;
} file . append _ all _ lines ( availability _ statistics _ file , lines ) ; } internal void update _ configuration ( configuration config ) { set ( config . availability _ statistics ) ; servers = config . configs ; } private class state {
logger . trace ( $ STR ) ; encryptor . addr _ buf _ length = addr _ buf _ length ; } public void start ( byte [ ] first _ packet , int length ) { first _ packet = first _ packet ; first _ packet _ length = length ; handshake _ receive ( ) ; } private void check _ close ( )
int bytes _ remain = ( int ) states [ 0 ] ; var on _ success = ( action ) states [ 1 ] ; if ( bytes _ read > = bytes _ remain ) { first _ packet _ length = bytes _ read + 2 ; int atyp = connetion _ recv _ buffer [ 0 ] ; string dst _ addr = STR ; int dst _ port = - 1 ; switch ( atyp ) {
if ( bytes _ read > = bytes _ remain ) { first _ packet _ length = bytes _ read + 2 ; int atyp = connetion _ recv _ buffer [ 0 ] ; string dst _ addr = STR ; int dst _ port = - 1 ; switch ( atyp ) { case atyp _ i _ pv : dst _ addr = new ip _ address ( connetion _ recv _ buffer . skip ( 1 ) . take ( NUM ) . to _ array ( ) ) . to _ string ( ) ;
timer . elapsed - = proxy _ connect _ timer _ elapsed ; timer . enabled = false ; timer . dispose ( ) ; if ( proxy _ connected | | dest _ connected | | closed ) { return ; } var proxy = timer . session . remote ; logger . info ( $ STR ) ; proxy . close ( ) ;
proxy _ timer timer = session . state ; var dest _ end _ point = timer . dest _ end _ point ; var server = timer . server ; timer . elapsed - = proxy _ connect _ timer _ elapsed ; timer . enabled = false ; timer . dispose ( ) ; var remote = session . remote ; remote . end _ connect _ proxy ( ar ) ; proxy _ connected = true ; if ( ! ( remote is direct _ connect ) )
timer . elapsed - = dest _ connect _ timer _ elapsed ; timer . enabled = false ; timer . dispose ( ) ; if ( dest _ connected | | closed ) { return ; } var session = timer . session ; server server = timer . server ; on _ failed ? . invoke ( this , new ss _ relay _ event _ args ( server ) ) ;
server _ timer timer = session . state ; server = timer . server ; timer . elapsed - = dest _ connect _ timer _ elapsed ; timer . enabled = false ; timer . dispose ( ) ; var remote = session . remote ; remote . end _ connect _ dest ( ar ) ; dest _ connected = true ; logger . debug ( $ STR ) ; var latency = date _ time . now - start _ connect _ time ;
int bytes _ read = session . remote . end _ receive ( ar ) ; total _ read + = bytes _ read ; on _ inbound ? . invoke ( this , new ss _ transmit _ event _ args ( server , bytes _ read ) ) ; if ( bytes _ read > 0 ) { last _ activity = date _ time . now ; int bytes _ to _ send = - 1 ; lock ( decryption _ lock ) { try
this . server = server ; } public void start ( byte [ ] first _ packet , int length ) { this . first _ packet = first _ packet ; this . first _ packet _ length = length ; this . handshake _ receive ( ) ; this . last _ activity = date _ time . now ; } private void check _ close ( )
} private void check _ close ( ) { if ( connection _ shutdown & & remote _ shutdown ) { this . close ( ) ; } } public void close ( ) {
} } public void close ( ) { lock ( relay . handlers ) { logging . debug ( $ STR ) ; relay . handlers . remove ( this ) ; } lock ( this )
} } private void handshake _ send _ callback ( i _ async _ result ar ) { if ( closed ) { return ; } try {
} } private void response _ callback ( i _ async _ result ar ) { try { connection . end _ send ( ar ) ; start _ connect ( ) ; } catch ( exception e )
} } private void connect _ callback ( i _ async _ result ar ) { server server = null ; if ( closed ) { return ; } try
int bytes _ to _ send ; lock ( decryption _ lock ) { if ( closed ) { return ; } encryptor . decrypt ( remote _ recv _ buffer , bytes _ read , remote _ send _ buffer , out bytes _ to _ send ) ; } logging . debug ( $ STR + bytes _ to _ send ) ;
} } else { connection . shutdown ( socket _ shutdown . send ) ; connection _ shutdown = true ; check _ close ( ) ; if ( total _ read = = 0 ) { }
} } else { remote . shutdown ( socket _ shutdown . send ) ; remote _ shutdown = true ; check _ close ( ) ; } } catch ( exception e )
this . server = server ; } public void start ( byte [ ] first _ packet , int length ) { first _ packet = first _ packet ; first _ packet _ length = length ; handshake _ receive ( ) ; }
} else if ( command = = NUM ) { read _ address ( handle _ udp _ associate ) ; } } } else { logging . debug ( STR ) ;
} private void read _ all ( i _ async _ result ar ) { if ( closed ) return ; try { if ( ar . async _ state ! = null ) { connection . end _ send ( ar ) ; connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , socket _ flags . none , new async _ callback ( read _ all ) , null ) ;
} else { int bytes _ read = connection . end _ receive ( ar ) ; if ( bytes _ read > 0 ) { connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , socket _ flags . none , new async _ callback ( read _ all ) , null ) ; }
} else close ( ) ; } } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; }
} catch ( argument _ exception ) { } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; } }
this . my _ cancel _ button . name = STR ; this . my _ cancel _ button . size = new system . drawing . size ( NUM , NUM ) ; this . my _ cancel _ button . tab _ index = NUM ; this . my _ cancel _ button . text = STR ; this . my _ cancel _ button . use _ visual _ style _ back _ color = true ; this . my _ cancel _ button . click + = new system . event _ handler ( this . cancel _ button _ click ) ;
} } }
if ( ! all _ text _ boxes . any ( ) ) throw new exception ( STR ) ; } private void controller _ config _ changed ( object sender , event _ args e ) { load _ current _ configuration ( ) ; } private void load _ current _ configuration ( ) { modified _ config = controller . get _ configuration _ copy ( ) . hotkey ; load _ configuration ( modified _ config ) ;
} private void hotkey _ down ( object sender , key _ event _ args e ) { sb . length = 0 ; if ( e . modifiers ! = 0 ) { if ( e . control ) { sb . append ( STR ) ; }
} private void ok _ button _ click ( object sender , event _ args e ) { foreach ( var tb in all _ text _ boxes ) { if ( tb . text . is _ null _ or _ empty ( ) ) { continue ; } if ( ! try _ reg _ hotkey ( tb ) )
socket conn = listener . end _ accept ( ar ) ; conn . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; listener . begin _ accept ( new async _ callback ( accept _ callback ) , listener ) ; handler handler = new handler ( ) ; handler . connection = conn ; handler . encryptor = encryptor _ factory . get _ encryptor ( server . method , server . password ) ; handler . config = server ; handler . start ( ) ;
socket conn = listener . end _ accept ( ar ) ; listener . begin _ accept ( new async _ callback ( accept _ callback ) , listener ) ; byte [ ] buf = new byte [ NUM ] ; object [ ] state = new object [ ] { conn , buf } ; conn . begin _ receive ( buf , 0 , NUM , 0 ,
buffer . block _ copy ( auth , 0 , buf , head _ len , onetimeauth _ bytes ) ; int buf _ offset = head _ len + onetimeauth _ bytes ; int rc = sodium . ss _ gen _ crc ( buf , ref buf _ offset , ref data _ len , crc _ buf , ref crc _ idx , buf . length ) ; if ( rc ! = 0 ) throw new exception ( STR ) ; length = head _ len + onetimeauth _ bytes + data _ len ; } } cipher _ update ( true , length , buf , tempbuf ) ;
initialize _ component ( ) ; this . servers _ list _ box . dock = dock _ style . fill ; this . table _ layout _ panel . dock = dock _ style . fill ; this . perform _ layout ( ) ; update _ texts ( ) ; setup _ value _ changed _ listeners ( ) ; this . icon = icon . from _ handle ( resources . ssw . get _ hicon ( ) ) ; this . controller = controller ; controller . config _ changed + = controller _ config _ changed ; load _ current _ configuration ( ) ;
update _ texts ( ) ; setup _ value _ changed _ listeners ( ) ; this . icon = icon . from _ handle ( resources . ssw . get _ hicon ( ) ) ; this . controller = controller ; controller . config _ changed + = controller _ config _ changed ; load _ current _ configuration ( ) ; } private void update _ texts ( ) { add _ button . text = n . get _ string ( STR ) ;
this . controller = controller ; controller . config _ changed + = controller _ config _ changed ; load _ current _ configuration ( ) ; } private void update _ texts ( ) { add _ button . text = n . get _ string ( STR ) ; delete _ button . text = n . get _ string ( STR ) ; duplicate _ button . text = n . get _ string ( STR ) ; ip _ label . text = n . get _ string ( STR ) ;
remarks _ label . text = n . get _ string ( STR ) ; timeout _ label . text = n . get _ string ( STR ) ; server _ group _ box . text = n . get _ string ( STR ) ; ok _ button . text = n . get _ string ( STR ) ; my _ cancel _ button . text = n . get _ string ( STR ) ; apply _ button . text = n . get _ string ( STR ) ; move _ up _ button . text = n . get _ string ( STR ) ; move _ down _ button . text = n . get _ string ( STR ) ; this . text = n . get _ string ( STR ) ; }
} private void setup _ value _ changed _ listeners ( ) { ip _ text _ box . text _ changed + = config _ value _ changed ; proxy _ port _ text _ box . text _ changed + = config _ value _ changed ; password _ text _ box . text _ changed + = config _ value _ changed ; encryption _ select . selected _ index _ changed + = config _ value _ changed ; plugin _ text _ box . text _ changed + = config _ value _ changed ; plugin _ arguments _ text _ box . text _ changed + = config _ value _ changed ; plugin _ options _ text _ box . text _ changed + = config _ value _ changed ;
registry . set _ value ( STR , pac _ url ) ; } } else { registry . set _ value ( STR , 0 ) ; if ( global ) { registry . set _ value ( STR , STR ) ; }
registry . set _ value ( STR , STR ) ; } ie _ auto _ detect _ proxy ( false ) ; system _ proxy . notify _ ie ( ) ; copy _ proxy _ setting _ from _ lan ( ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; message _ box . show ( n . get _ string ( STR ) ) ;
} catch ( index _ out _ of _ range _ exception ) { throw new format _ exception ( ) ; } } } }
} update _ system _ proxy ( ) ; } public server get _ current _ server ( ) { return config . get _ current _ server ( ) ; } public configuration get _ configuration ( ) { return configuration . load ( ) ;
int red = color . r * fly _ blue . r / NUM ; int green = color . g * fly _ blue . g / NUM ; int blue = color . b * fly _ blue . b / NUM ; icon _ copy . set _ pixel ( x , y , color . from _ argb ( color . a , red , green , blue ) ) ; } else if ( global ) { color fly _ blue = color . from _ argb ( NUM , NUM , NUM ) ;
public class availability _ statistics { public static readonly string date _ time _ pattern = STR ; private const string statistics _ files _ name = STR ; private const string delimiter = STR ; private const int timeout = NUM ; private const int delay _ before _ start = NUM ; public raw _ statistics raw _ statistics { get ; private set ; } public raw _ statistics filtered _ statistics { get ; private set ; } private int repeat = > config . repeat _ times _ num ;
{ choose _ new _ server ( controller . get _ current _ configuration ( ) . configs ) ; } if ( old _ server ! = current _ server ) { } return current _ server ; } public void reload _ servers ( ) {
this . file _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . open _ location _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . exit _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . panel = new system . windows . forms . panel ( ) ;
private system . windows . forms . menu _ item file _ menu _ item ; private system . windows . forms . menu _ item open _ location _ menu _ item ; private system . windows . forms . menu _ item exit _ menu _ item ; private system . windows . forms . panel panel ; private system . windows . forms . check _ box wrap _ text _ check _ box ; private system . windows . forms . button clean _ logs _ button ; private system . windows . forms . button change _ font _ button ; private system . windows . forms . table _ layout _ panel table _ layout _ panel ; private system . windows . forms . check _ box top _ most _ check _ box ;
} public override bool handle ( byte [ ] first _ packet , int length , socket socket , object state ) { if ( socket . protocol _ type ! = protocol _ type . tcp ) { return false ; } new handler ( ) . start ( first _ packet , length , socket , this . target _ port ) ; return true ; }
return true ; } class handler { private byte [ ] first _ packet ; private int first _ packet _ length ; private socket local ; private wrapped _ socket remote ; private bool closed = false ; private bool local _ shutdown = false ;
} } private void connect _ callback ( i _ async _ result ar ) { if ( closed ) { return ; } try {
local . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , 0 , new async _ callback ( pipe _ connection _ receive _ callback ) , null ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; this . close ( ) ; } } private void pipe _ remote _ receive _ callback ( i _ async _ result ar )
} } private void pipe _ remote _ receive _ callback ( i _ async _ result ar ) { if ( closed ) { return ; } try {
} } public void close ( ) { lock ( lock ) { if ( closed ) { return ; }
return output ; } dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void md ( byte [ ] input , uint ilen , byte [ ] output ) ;
this . file _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . open _ location _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . exit _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . panel = new system . windows . forms . panel ( ) ;
private system . windows . forms . menu _ item file _ menu _ item ; private system . windows . forms . menu _ item open _ location _ menu _ item ; private system . windows . forms . menu _ item exit _ menu _ item ; private system . windows . forms . panel panel ; private system . windows . forms . check _ box wrap _ text _ check _ box ; private system . windows . forms . button clean _ logs _ button ; private system . windows . forms . button change _ font _ button ; private system . windows . forms . table _ layout _ panel table _ layout _ panel ; private system . windows . forms . check _ box top _ most _ check _ box ;
server : shadowsocks content - type : application / x - ns - proxy - autoconfig content - length : { 0 } connection : close STR byte [ ] response = system . text . encoding . ut . get _ bytes ( text ) ; conn . begin _ send ( response , 0 , response . length , 0 , new async _ callback ( send _ callback ) , conn ) ; util . utils . release _ memory ( ) ; } else
} } }
if ( se . socket _ error _ code = = socket _ error . address _ already _ in _ use ) { e = new exception ( n . get _ string ( STR , config . local _ port ) , e ) ; } else if ( se . socket _ error _ code = = socket _ error . access _ denied ) { e = new exception ( n . get _ string ( STR , config . local _ port ) , e ) ; } } logging . log _ useful _ exception ( e ) ;
if ( ! parsed ) { ip _ host _ entry ip _ host _ info = dns . get _ host _ entry ( config . server ) ; ip _ address = ip _ host _ info . address _ list [ 0 ] ; } ip _ end _ point remote _ ep = new ip _ end _ point ( ip _ address , config . server _ port ) ; remote = new socket ( ip _ address . address _ family , socket _ type . stream , protocol _ type . tcp ) ; remote . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; remote . begin _ connect ( remote _ ep ,
ip _ address = ip _ host _ info . address _ list [ 0 ] ; } ip _ end _ point remote _ ep = new ip _ end _ point ( ip _ address , config . server _ port ) ; remote = new socket ( ip _ address . address _ family , socket _ type . stream , protocol _ type . tcp ) ; remote . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; remote . begin _ connect ( remote _ ep , new async _ callback ( connect _ callback ) , null ) ; } catch ( exception e )
} } public void update _ inbound _ counter ( server server , long n ) { interlocked . add ( ref inbound _ counter , n ) ; if ( config . availability _ statistics ) { new task ( ( ) = > availability _ statistics . update _ inbound _ counter ( server , n ) ) . start ( ) ; } }
} } public void update _ outbound _ counter ( server server , long n ) { interlocked . add ( ref outbound _ counter , n ) ; if ( config . availability _ statistics ) { new task ( ( ) = > availability _ statistics . update _ outbound _ counter ( server , n ) ) . start ( ) ; } }
} } protected void reload ( ) { config = configuration . load ( ) ; statistics _ configuration = statistics _ strategy _ configuration . load ( ) ; if ( polipo _ runner = = null ) { polipo _ runner = new polipo _ runner ( ) ; }
byte [ ] input , int ioff , uint ilen , byte [ ] output ) ; } }
start _ pipe ( ) ; } catch ( exception e ) { controller . get _ current _ strategy ( ) . set _ failure ( this . server ) ; logging . log _ useful _ exception ( e ) ; if ( retry _ count < NUM ) { console . write _ line ( STR ) ; start _ connect ( ) ;
if ( reg _ themes _ personalize . get _ value ( STR ) ! = null ) { if ( convert . to _ int ( reg _ themes _ personalize . get _ value ( STR ) . to _ string ( ) ) = = 0 ) regist _ data = windows _ theme _ mode . dark ; else regist _ data = windows _ theme _ mode . light ; } else {
} if ( retval = = error _ success ) { if ( lp _ names = = 0 ) { return 1 ; } all _ conns = new string [ names . length ] ; for ( int i = 0 ; i < names . length ; i + + ) {
byte [ ] plain = new byte [ NUM ] ; byte [ ] cipher = new byte [ plain . length + NUM ] ; byte [ ] plain = new byte [ plain . length + NUM ] ; int out _ len = 0 ; int out _ len = 0 ; random . next _ bytes ( plain ) ; encryptor . encrypt ( plain , plain . length , cipher , out out _ len ) ; decryptor . decrypt ( cipher , out _ len , plain , out out _ len ) ; assert . are _ equal ( plain . length , out _ len ) ;
try { local . start ( ) ; pac _ server = new pac _ server ( ) ; pac _ server . pac _ file _ changed + = pac _ server _ pac _ file _ changed ; pac _ server . start ( ) ; } catch ( exception e ) { console . write _ line ( e . message ) ;
} } } } else { if ( line . is _ null _ or _ empty ( ) ) { return true ; }
} } } } request _ line _ count + + ; return false ; } private void on _ finish ( byte [ ] last _ bytes , int index , int length , object state ) { if ( closed )
