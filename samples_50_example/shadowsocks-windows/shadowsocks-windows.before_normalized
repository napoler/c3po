registry _ key run _ key = microsoft . win . registry . current _ user . open _ sub _ key ( STR , true ) ;
run _ key . set _ value ( STR , path ) ;
run _ key . delete _ value ( STR ) ;
run _ key . close ( ) ;
registry _ key run _ key = microsoft . win . registry . current _ user . open _ sub _ key ( STR ) ;
run _ key . close ( ) ;
if ( item . equals ( STR ) )
if ( ! file . exists ( plugin _ process . start _ info . file _ name ) ) { throw new file _ not _ found _ exception ( n . get _ string ( STR ) , plugin _ process . start _ info . file _ name ) ; }
plugin _ process . start ( ) ;
using system ;
using shadowsocks _ controller ; using shadowsocks _ properties ; using shadowsocks _ model ; using newtonsoft _ json ;
process . start ( ) ; process . begin _ error _ read _ line ( ) ; process . begin _ output _ read _ line ( ) ; process . wait _ for _ exit ( ) ;
throw new proxy _ exception ( stderr ) ;
throw new proxy _ exception ( STR ) ;
color fly _ blue = color . from _ argb ( NUM , NUM , NUM , NUM ) ;
this . table _ layout _ panel . controls . add ( this . plugin _ arguments _ text _ box , 1 , NUM ) ; this . table _ layout _ panel . controls . add ( this . plugin _ arguments _ label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . remarks _ label , 0 , NUM ) ;
this . table _ layout _ panel . row _ count = NUM ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ;  this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ;
this . group _ box = new system . windows . forms . group _ box ( ) ;
config . is _ default = false ;
public void start ( )
hotkey _ reg . reg _ all _ hotkeys ( ) ;
int _ ptr ctx = marshal . alloc _ h _ global ( m _ ctx _ size ) ;
mbed _ tls . md _ init ( ctx ) ; mbed _ tls . md _ starts ( ctx ) ; mbed _ tls . md _ update ( ctx , input , ( uint ) input . length ) ; mbed _ tls . md _ finish ( ctx , output ) ; mbed _ tls . md _ free ( ctx ) ; marshal . free _ h _ global ( ctx ) ;
public extern static void md _ init ( int _ ptr ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void md _ free ( int _ ptr ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void md _ starts ( int _ ptr ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void md _ update ( int _ ptr ctx , byte [ ] input , uint ilen ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void md _ finish ( int _ ptr ctx , byte [ ] output ) ;
using system ; using system _ collections ; using system _ globalization ; using system _ io ;
using shadowsocks _ encryption ; using shadowsocks _ model ; using shadowsocks _ properties ; using shadowsocks _ util ; using system _ threading _ tasks ;
using shadowsocks _ controller ; using shadowsocks _ properties ; using system ;
model . configuration config ; public log _ form ( string filename ) {
config = model . configuration . load ( ) ; if ( config . log _ viewer = = null ) { config . log _ viewer = new model . log _ viewer _ config ( ) ; } else { top _ most _ trigger = config . log _ viewer . top _ most ; wrap _ text _ trigger = config . log _ viewer . wrap _ text ; toolbar _ trigger = config . log _ viewer . toolbar _ shown ; log _ message _ text _ box . font = new font ( config . log _ viewer . font _ name , config . log _ viewer . font _ size ) ; log _ message _ text _ box . back _ color = config . log _ viewer . get _ background _ color ( ) ; log _ message _ text _ box . fore _ color = config . log _ viewer . get _ text _ color ( ) ; }
connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , 0 , new async _ callback ( read _ all ) , null ) ;
connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , 0 , new async _ callback ( read _ all ) , null ) ;
this . auto _ startup _ item . index = NUM ; this . auto _ startup _ item . text = STR ; this . auto _ startup _ item . click + = new system . event _ handler ( this . auto _ startup _ item _ click ) ;    this . share _ over _ lan _ item . index = NUM ; this . share _ over _ lan _ item . text = STR ; this . share _ over _ lan _ item . click + = new system . event _ handler ( this . share _ over _ lan _ item _ click ) ;
this . menu _ item . index = NUM ; this . menu _ item . text = STR ;
public static void enable ( )
registry . set _ value ( STR , 0 ) ; registry . set _ value ( STR , STR ) ; registry . set _ value ( STR , STR + get _ timestamp ( date _ time . now ) ) ;
public static void update _ ie ( )
registry . set _ value ( STR , 1 ) ; registry . set _ value ( STR , STR ) ; system _ proxy . update _ ie ( ) ;
system _ proxy . update _ ie ( ) ;
using system _ text _ regular _ expressions ;
public static readonly regex url _ finder = new regex ( STR , regex _ options . ignore _ case ) , details _ parser = new regex ( STR , regex _ options . ignore _ case ) ;
var matches = url _ finder . matches ( ss _ url ) ; if ( matches . count < = 0 ) return null ;
foreach ( match match in matches )
server tmp = new server ( ) ; var base = match . groups [ STR ] . value ; var tag = match . groups [ STR ] . value ; if ( ! tag . is _ null _ or _ empty ( ) )
tmp . remarks = http _ utility . url _ decode ( tag , encoding . ut ) ;
match details = details _ parser . match ( encoding . ut . get _ string ( convert . from _ base _ string ( base . pad _ right ( base . length + ( NUM - base . length % NUM ) % NUM , '=' ) ) ) ) ; if ( ! details . success )
tmp . method = details . groups [ STR ] . value ; tmp . password = details . groups [ STR ] . value ; tmp . server = details . groups [ STR ] . value ; tmp . server _ port = int . parse ( details . groups [ STR ] . value ) ;
this . table _ layout _ panel . controls . add ( this . remarks _ text _ box , 1 , NUM ) ; this . table _ layout _ panel . controls . add ( this . remarks _ label , 0 , NUM ) ;
this . table _ layout _ panel . controls . add ( this . timeout _ label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . timeout _ text _ box , 1 , NUM ) ;
this . table _ layout _ panel . row _ count = NUM ;   this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ;
if ( ! file . exists ( database _ path ) ) {
static void load _ geosite _ list ( byte [ ] data = null ) { data = data ? ? file . read _ all _ bytes ( database _ path ) ; var list = geosite _ list . parser . parse _ from ( data ) ;
public static void update _ pac _ from _ geosite ( configuration config )
web _ client http = new web _ client ( ) ;
http . proxy = new web _ proxy (
http . download _ data _ completed + = ( o , e ) = > {    try {       file . write _ all _ bytes ( database _ path , e . result ) ; load _ geosite _ list ( ) ; bool pac _ file _ changed = merge _ and _ write _ pac _ file ( group , blacklist ) ; update _ completed ? . invoke ( null , new geosite _ result _ event _ args ( pac _ file _ changed ) ) ; } catch ( exception ex ) { error ? . invoke ( null , new error _ event _ args ( ex ) ) ; } } ; http . download _ data _ async ( new uri ( geosite _ url ) ) ;
shadowsocks _ controller controller ;
update _ ui ( ) ;
update _ ui ( ) ;
update _ ui ( ) ;
private void update _ ui ( )
server server = controller . get _ current _ server ( ) ;
enable _ item . checked = controller . get _ configuration ( ) . enabled ;
private void cinfig _ form _ load ( object sender , event _ args e )
try { server server = new server { server = ip _ text _ box . text , server _ port = int . parse ( server _ port _ text _ box . text ) , password = password _ text _ box . text , local _ port = int . parse ( proxy _ port _ text _ box . text ) , method = encryption _ select . text } ; configuration config = controller . get _ configuration ( ) ; config . configs . clear ( ) ; config . configs . add ( server ) ; config . index = 0 ; controller . save _ config ( config ) ; this . hide ( ) ; } catch ( format _ exception ) { message _ box . show ( STR ) ; } catch ( exception ex ) { message _ box . show ( ex . message ) ; }
update _ ui ( ) ;
this . label = new system . windows . forms . label ( ) ;
this . encryption _ select = new system . windows . forms . combo _ box ( ) ;
this . label = new system . windows . forms . label ( ) ;
this . proxy _ port _ text _ box = new system . windows . forms . text _ box ( ) ;
this . delete _ button = new system . windows . forms . button ( ) ;
this . label . anchor = system . windows . forms . anchor _ styles . right ; this . label . auto _ size = true ; this . label . location = new system . drawing . point ( NUM , NUM ) ; this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ; this . label . tab _ index = 0 ; this . label . text = STR ;    this . label . anchor = system . windows . forms . anchor _ styles . right ; this . label . auto _ size = true ; this . label . location = new system . drawing . point ( NUM , NUM ) ; this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ; this . label . tab _ index = 1 ; this . label . text = STR ;
this . delete _ button . location = new system . drawing . point ( NUM , NUM ) ; this . delete _ button . name = STR ; this . delete _ button . size = new system . drawing . size ( NUM , NUM ) ; this . delete _ button . tab _ index = NUM ; this . delete _ button . text = STR ; this . delete _ button . use _ visual _ style _ back _ color = true ;
try
using ( file . create ( path ) ) {  }
catch ( exception e ) { logging . log _ useful _ exception ( e ) ; } if ( ! file . exists ( path ) ) { console . write _ line ( $ STR ) ; recorder . change ( retry _ interval , recording _ interval ) ; return ; }
public line _ reader ( wrapped _ socket socket , byte [ ] first _ packge , int index , int length ,
encoding encoding , string delimiter , int max _ line _ bytes ,
if ( max _ line _ bytes < length )
throw new argument _ exception ( STR , nameof ( max _ line _ bytes ) ) ;
if ( max _ line _ bytes < delimiter _ bytes . length )
throw new argument _ exception ( STR , nameof ( max _ line _ bytes ) ) ;
line _ buffer = new byte [ max _ line _ bytes ] ;
array . copy ( first _ packge , index , line _ buffer , 0 , length ) ;
socket . begin _ receive ( line _ buffer , 0 , max _ line _ bytes , 0 , receive _ callback , 0 ) ;
public line _ reader ( wrapped _ socket socket , func < string , object , bool > on _ line _ read , action < exception , object > on _ exception , action < byte [ ] , int , int , object > on _ finish , encoding encoding , string delimiter , int max _ line _ bytes , object state ) : this ( socket , null , 0 , 0 , on _ line _ read , on _ exception , on _ finish , encoding , delimiter , max _ line _ bytes , state )
int len = socks _ util . header _ addr _ length ( dest _ end _ point ) ; byte [ ] request = new byte [ len + NUM ] ; socks _ util . fill _ header _ addr ( request , NUM , dest _ end _ point ) ;
namespace shadowsocks _ controller _ service
private readonly list < itcp _ handler _ factory > factories = new list < itcp _ handler _ factory > ( ) ; public i _ set < tcp _ handler > handlers { get ; } = new hash _ set < tcp _ handler > ( ) ;
factories . add ( new socks _ handler _ factory ( ) ) ; factories . add ( new http _ handler _ handler _ factory ( ) ) ;
tcp _ handler handler = null ; foreach ( var factory in factories ) { if ( factory . can _ handle ( first _ packet , length ) ) { handler = factory . new _ handler ( controller , config , this , socket ) ; break ; } } if ( handler = = null ) {
}
interface itcp _ handler _ factory
bool can _ handle ( byte [ ] first _ packet , int length ) ; tcp _ handler new _ handler ( shadowsocks _ controller controller , configuration config , tcp _ relay tcprelay , socket socket ) ; } abstract class tcp _ handler { public abstract void start _ handshake ( byte [ ] first _ packet , int length ) ; protected abstract void on _ server _ connected ( async _ session session ) ; protected class async _ session
protected class async _ session < t > : async _ session
private shadowsocks _ controller controller ; protected configuration config { get ; } private tcp _ relay tcprelay ; protected socket connection { get ; }  private server server ;
private bool proxy _ connected ; private bool dest _ connected ;    private int total _ read = 0 ; private int total _ write = 0 ; protected byte [ ] remote _ recv _ buffer { get ; } = new byte [ buffer _ size ] ; private readonly byte [ ] remote _ send _ buffer = new byte [ buffer _ size ] ; protected byte [ ] connetion _ recv _ buffer { get ; } = new byte [ buffer _ size ] ; private readonly byte [ ] connetion _ send _ buffer = new byte [ buffer _ size ] ; private i _ encryptor encryptor ; private readonly object encryption _ lock = new object ( ) ; private readonly object decryption _ lock = new object ( ) ; private bool connection _ shutdown = false ; private bool remote _ shutdown = false ;    protected bool closed { get ; private set ; } = false ; private readonly object close _ conn _ lock = new object ( ) ;
public tcp _ handler ( shadowsocks _ controller controller , configuration config , tcp _ relay tcprelay , socket socket , bool auto _ append _ header = true )
server _ header _ sent = ! auto _ append _ header ; } private void create _ remote ( ) { server server = controller . get _ a _ server ( i _ strategy _ caller _ type . tcp , ( ip _ end _ point ) connection . remote _ end _ point , dest _ end _ point ) ;
protected void start _ pipe ( async _ session session ) { if ( closed ) return ;
session . remote . begin _ receive ( remote _ recv _ buffer , 0 , recv _ size , socket _ flags . none , pipe _ remote _ receive _ callback , session ) ; connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , socket _ flags . none , pipe _ connection _ receive _ callback , session ) ;
begin _ send _ to _ server ( length , session , pipe _ remote _ send _ callback ) ; } private bool server _ header _ sent ; protected void begin _ send _ to _ server ( int length , async _ session session , async _ callback callback ) { if ( ! server _ header _ sent ) { server _ header _ sent = true ;  int len = socks _ util . header _ addr _ length ( dest _ end _ point ) ; array . copy ( connetion _ recv _ buffer , 0 , connetion _ recv _ buffer , len , length ) ; socks _ util . fill _ header _ addr ( connetion _ recv _ buffer , 0 , dest _ end _ point ) ; length + = len ; }
session . remote . begin _ send ( connetion _ send _ buffer , 0 , bytes _ to _ send , socket _ flags . none , callback , session ) ;
protected async _ session end _ send _ to _ server ( i _ async _ result ar ) { var session = ( async _ session ) ar . async _ state ; session . remote . end _ send ( ar ) ; return session ; }
if ( closed ) return ; try { var session = end _ send _ to _ server ( ar ) ; connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , socket _ flags . none , pipe _ connection _ receive _ callback , session ) ;
services . add ( pac _ server ) ;
polar _ ssl . aes _ setkey _ enc ( ctx , realkey , key _ len * NUM ) ;
polar _ ssl . aes _ setkey _ enc ( ctx , realkey , key _ len * NUM ) ;
gfw _ list _ updater gfwlist _ updater ;
start _ gfw _ list _ updater ( ) ;
if ( gfwlist _ updater ! = null ) { gfwlist _ updater . stop ( ) ; gfwlist _ updater = null ; }
private const int expire _ hours = NUM ;
public bool use _ system _ proxy = true ; public class gfw _ list _ changed _ args : event _ args { public string [ ] gfw _ list { get ; set ; } } public event event _ handler < gfw _ list _ changed _ args > gfw _ list _ changed ; private bool running = false ; private bool closed = false ; private int job _ id = 0 ; date _ time last _ update _ time _ utc ; string last _ update _ md ; private object locker = new object ( ) ; public gfw _ list _ updater ( ) { } ~ gfw _ list _ updater ( ) { stop ( ) ; } public void start ( ) { lock ( locker ) { if ( running ) return ; running = true ; closed = false ; job _ id + + ; new thread ( new parameterized _ thread _ start ( update _ job ) ) . start ( job _ id ) ; } } public void stop ( ) { lock ( locker ) { closed = true ; running = false ; job _ id + + ; } } public void schedule _ update _ time ( int delay _ seconds ) { lock ( locker ) { last _ update _ time _ utc = date _ time . utc _ now . add _ hours ( - 1 * expire _ hours ) . add _ seconds ( delay _ seconds ) ; } } private string download _ gfw _ list _ file ( )
web _ client http = new web _ client ( ) ; http . proxy = use _ system _ proxy ? web _ request . get _ system _ web _ proxy ( ) : proxy ; return http . download _ string ( new uri ( gfwlist _ url ) ) ;
console . write _ line ( ex . to _ string ( ) ) ; } return null ; } private bool is _ expire ( ) { lock ( locker ) { time _ span ts = date _ time . utc _ now - last _ update _ time _ utc ; bool expire = ( ( int ) ts . total _ hours ) > = expire _ hours ; if ( expire ) last _ update _ time _ utc = date _ time . utc _ now ; return expire ; } } private bool is _ job _ stop ( int current _ job _ id ) { lock ( locker ) { if ( ! running | | closed | | current _ job _ id ! = this . job _ id ) return true ; } return false ; } private bool is _ gfw _ list _ changed ( string content ) { byte [ ] input _ bytes = encoding . ut . get _ bytes ( content ) ; byte [ ] md _ bytes = m . create ( ) . compute _ hash ( input _ bytes ) ; string md = STR ; for ( int i = 0 ; i < md _ bytes . length ; i + + ) md + = md _ bytes [ i ] . to _ string ( STR ) . pad _ left ( 2 , '0' ) ; if ( md = = last _ update _ md ) return false ; last _ update _ md = md ; return true ; } private void parse _ gfw _ list ( string response ) { if ( ! is _ gfw _ list _ changed ( response ) ) return ; if ( gfw _ list _ changed ! = null ) { try { parser parser = new parser ( response ) ; gfw _ list _ changed _ args args = new gfw _ list _ changed _ args { gfw _ list = parser . get _ reduced _ domains ( ) } ; gfw _ list _ changed ( this , args ) ; } catch ( exception ex ) { console . write _ line ( ex . to _ string ( ) ) ; } } } private void update _ job ( object state ) { int current _ job _ id = ( int ) state ; int retry _ times = NUM ; while ( ! is _ job _ stop ( current _ job _ id ) ) { if ( is _ expire ( ) ) { string response = download _ gfw _ list _ file ( ) ; if ( response ! = null ) { parse _ gfw _ list ( response ) ; } else if ( retry _ times > 0 ) { schedule _ update _ time ( NUM ) ; retry _ times - - ; } else { retry _ times = NUM ; } } thread . sleep ( NUM ) ; } } class parser { public string content { get ; private set ; }
this . content = encoding . ascii . get _ string ( bytes ) ; } public string [ ] get _ lines ( ) { return content . split ( new char [ ] { '\r' , '\n' } , string _ split _ options . remove _ empty _ entries ) ;
list < string > lines = new list < string > ( get _ lines ( ) ) ;
this . secure _ local _ pac _ url _ toggle _ item = create _ menu _ item ( STR , new event _ handler ( this . secure _ local _ pac _ url _ toggle _ item _ click ) ) ,
this . qr _ code _ item = new system . windows . forms . menu _ item ( ) ;
if ( ! controller . get _ configuration ( ) . is _ default )
begin _ invoke ( new method _ invoker ( delegate { this . hide ( ) ; } ) ) ; } else { is _ first _ run = true ;
if ( pac _ file _ changed ! = null ) { console . write _ line ( STR , e . name , e . change _ type . to _ string ( ) . to _ lower ( ) ) ; pac _ file _ changed ( this , new event _ args ( ) ) ;
if ( user _ rule _ file _ changed ! = null ) { console . write _ line ( STR , e . name , e . change _ type . to _ string ( ) . to _ lower ( ) ) ; user _ rule _ file _ changed ( this , new event _ args ( ) ) ; }   }
process . start _ info . use _ shell _ execute = false ;
process . start _ info . redirect _ standard _ output = true ; process . start _ info . redirect _ standard _ error = true ;
online _ pac _ item . enabled = ! string . is _ null _ or _ empty ( config . pac _ url ) ;
local _ pac _ item . checked = false ; online _ pac _ item . checked = true ; controller . use _ online _ pac ( true ) ;
using system _ collections _ generic ;
using system _ text ;
system . io . file _ stream file _ stream = new system . io . file _ stream ( file _ name , system . io . file _ mode . create , system . io . file _ access . write ) ;
while ( true )
n = input . read ( buffer , 0 , buffer . length ) ; if ( n = = 0 ) { break ; }
file _ stream fs = new file _ stream ( log _ file _ path , file _ mode . append ) ; stream _ writer _ with _ timestamp sw = new stream _ writer _ with _ timestamp ( fs ) ; sw . auto _ flush = true ; console . set _ out ( sw ) ; console . set _ error ( sw ) ;
console . write _ line ( STR + o ) ;
console . write _ line ( o ) ;
console . write _ line ( STR + o ) ;
public void update _ pac _ from _ gfw _ list ( )
http . proxy = new web _ proxy ( ip _ address . loopback . to _ string ( ) , NUM ) ;
clean _ logs _ button . text = n . get _ string ( STR ) ;
clean _ logs _ menu _ item . text = n . get _ string ( STR ) ;
private void do _ clean _ logs ( )
private void clean _ logs _ menu _ item _ click ( object sender , event _ args e ) { do _ clean _ logs ( ) ; } private void clean _ logs _ button _ click ( object sender , event _ args e ) { do _ clean _ logs ( ) ;
this . clean _ logs _ menu _ item = new system . windows . forms . menu _ item ( ) ;
this . clean _ logs _ button = new system . windows . forms . button ( ) ;
this . clean _ logs _ menu _ item . index = 0 ; this . clean _ logs _ menu _ item . text = STR ; this . clean _ logs _ menu _ item . click + = new system . event _ handler ( this . clean _ logs _ menu _ item _ click ) ;
private system . windows . forms . button clean _ logs _ button ;
private system . windows . forms . menu _ item clean _ logs _ menu _ item ;
{
}
if ( target _ index = = - 1 )
logging . debug ( remote . local _ end _ point , remote . dest _ end _ point , recv _ size , STR ) ;
logging . debug ( remote . local _ end _ point , remote . dest _ end _ point , recv _ size , STR ) ;
ip _ address ip _ address ; bool parsed = ip _ address . try _ parse ( server . server , out ip _ address ) ; if ( ! parsed ) { ip _ host _ entry ip _ host _ info = dns . get _ host _ entry ( server . server ) ; ip _ address = ip _ host _ info . address _ list [ 0 ] ; } ip _ end _ point dest _ ep = new ip _ end _ point ( ip _ address , server . server _ port ) ;
parsed = ip _ address . try _ parse ( config . proxy _ server , out ip _ address ) ;
proxy _ ep = dest _ ep ;
proxy _ timer . dest _ end _ point = dest _ ep ;
public end _ point proxy _ end _ point { get ; private set ; } public end _ point dest _ end _ point { get ; private set ; }
proxy _ end _ point = remote _ ep ;
public void begin _ connect _ dest ( end _ point remote _ ep , async _ callback callback , object state )
dest _ end _ point = remote _ ep ;
end _ point dest _ end _ point { get ; }
void begin _ connect _ dest ( end _ point remote _ ep , async _ callback callback , object state ) ;
qr _ code _ cs . qr _ code qr _ coded = new qr _ code _ cs . qr _ code ( NUM , qr _ error _ correct _ level . h ) ; qr _ coded . add _ data ( qr _ text ) ; qr _ coded . make ( ) ; int block _ size = NUM ;
for ( int row = 0 ; row < qr _ coded . get _ module _ count ( ) ; row + + )
for ( int col = 0 ; col < qr _ coded . get _ module _ count ( ) ; col + + )
bool is _ dark = qr _ coded . is _ dark ( row , col ) ; if ( is _ dark )
for ( int y = 0 ; y < block _ size ; y + + )
int my _ col = ( block _ size * ( col - 1 ) ) + ( y + block _ size ) ; for ( int x = 0 ; x < block _ size ; x + + )
draw _ area . set _ pixel ( ( block _ size * ( row - 1 ) ) + ( x + block _ size ) , my _ col , color . black ) ; } } } else { for ( int y = 0 ; y < block _ size ; y + + ) { int my _ col = ( block _ size * ( col - 1 ) ) + ( y + block _ size ) ; for ( int x = 0 ; x < block _ size ; x + + ) { draw _ area . set _ pixel ( ( block _ size * ( row - 1 ) ) + ( x + block _ size ) , my _ col , color . white ) ;
configuration config = json _ convert . deserialize _ object < configuration > ( config _ content ) ;
try { config . n _ log _ config = n _ log _ config . load _ xml ( ) ; switch ( config . n _ log _ config . get _ log _ level ( ) ) { case n _ log _ config . log _ level . fatal : case n _ log _ config . log _ level . error : case n _ log _ config . log _ level . warn : case n _ log _ config . log _ level . info : config . is _ verbose _ logging = false ; break ; case n _ log _ config . log _ level . debug : case n _ log _ config . log _ level . trace : config . is _ verbose _ logging = true ; break ; } } catch ( exception e ) {  logger . error ( e , STR ) ; } return config ;
return new configuration
font _ dialog fd = new font _ dialog ( ) ; fd . font = log _ message _ text _ box . font ; if ( fd . show _ dialog ( ) = = dialog _ result . ok )
log _ message _ text _ box . font = fd . font ;
internal static byte [ ] polipo { get { object obj = resource _ manager . get _ object ( STR , resource _ culture ) ; return ( ( byte [ ] ) ( obj ) ) ; } }
if ( string . is _ null _ or _ white _ space ( server _ url ) )
parsed _ url = new uri ( server _ url ) ;
string possibly _ unpadded _ base = parsed _ url . get _ components ( uri _ components . user _ info , uri _ format . unescaped ) ; bool is _ old _ format _ url = possibly _ unpadded _ base . length = = 0 ; if ( is _ old _ format _ url ) { int prefix _ length = STR . length ; int index _ of _ hash _ or _ slash = server _ url . last _ index _ of _ any ( new [ ] { '/' , '#' } , server _ url . length - 1 , server _ url . length - prefix _ length ) ; int substring _ length = server _ url . length - prefix _ length ; if ( index _ of _ hash _ or _ slash > = 0 ) { substring _ length = index _ of _ hash _ or _ slash - prefix _ length ; } possibly _ unpadded _ base = server _ url . substring ( prefix _ length , substring _ length ) . trim _ end ( '/' ) ; } else {  possibly _ unpadded _ base = possibly _ unpadded _ base . replace ( '-' , '+' ) . replace ( '_' , '/' ) ; } string base = possibly _ unpadded _ base . pad _ right ( possibly _ unpadded _ base . length + ( NUM - possibly _ unpadded _ base . length % NUM ) % NUM , '=' ) ; string inner _ user _ info _ or _ url = encoding . ut . get _ string ( convert . from _ base _ string ( base ) ) ; string user _ info ; if ( is _ old _ format _ url ) { uri inner _ url = new uri ( STR + inner _ user _ info _ or _ url ) ; user _ info = inner _ url . get _ components ( uri _ components . user _ info , uri _ format . unescaped ) ; tmp . server = inner _ url . get _ components ( uri _ components . host , uri _ format . unescaped ) ; tmp . server _ port = inner _ url . port ; } else { user _ info = inner _ user _ info _ or _ url ; tmp . server = parsed _ url . get _ components ( uri _ components . host , uri _ format . unescaped ) ; tmp . server _ port = parsed _ url . port ; }
this . table _ layout _ panel . controls . add ( this . one _ time _ auth , 1 , NUM ) ;
this . table _ layout _ panel . row _ count = NUM ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ;  this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ;
this . proxy _ port _ lable = new system . windows . forms . label ( ) ;
this . proxy _ addr _ label . anchor = system . windows . forms . anchor _ styles . left ;
this . proxy _ port _ lable . anchor = system . windows . forms . anchor _ styles . left ; this . proxy _ port _ lable . auto _ size = true ; this . proxy _ port _ lable . location = new system . drawing . point ( NUM , NUM ) ; this . proxy _ port _ lable . name = STR ; this . proxy _ port _ lable . size = new system . drawing . size ( NUM , NUM ) ; this . proxy _ port _ lable . tab _ index = 2 ; this . proxy _ port _ lable . text = STR ;
this . table _ layout _ panel . column _ count = 2 ;
this . proxy _ type _ label . anchor = system . windows . forms . anchor _ styles . left ;
this . proxy _ type _ combo _ box . dock = system . windows . forms . dock _ style . fill ;
private system . windows . forms . label proxy _ port _ lable ;
public void update _ latency ( server server , time _ span latency ) {
availability _ statistics . update _ latency ( server , ( int ) latency . total _ milliseconds ) ; } } public void update _ inbound _ counter ( server server , long n ) { interlocked . add ( ref inbound _ counter , n ) ;
availability _ statistics . update _ inbound _ counter ( server , n ) ; } } public void update _ outbound _ counter ( server server , long n ) { interlocked . add ( ref outbound _ counter , n ) ;
availability _ statistics . update _ outbound _ counter ( server , n ) ;
using n _ log ; using system ;
class tcp _ relay : listener . service
private static logger logger = log _ manager . get _ current _ class _ logger ( ) ; private shadowsocks _ controller controller ;
private configuration config ;
tcp _ handler handler = new tcp _ handler ( controller , config , this , socket ) ;
public void update _ inbound _ counter ( server server , long n ) { controller . update _ inbound _ counter ( server , n ) ; }     public void update _ outbound _ counter ( server server , long n ) { controller . update _ outbound _ counter ( server , n ) ; } public void update _ latency ( server server , time _ span latency )  { controller . update _ latency ( server , latency ) ;
class async _ session
class async _ session < t > : async _ session
private static logger logger = log _ manager . get _ current _ class _ logger ( ) ;
private shadowsocks _ controller controller ; private configuration config ; private tcp _ relay tcprelay ; private socket connection ;
private byte [ ] remote _ recv _ buffer = new byte [ buffer _ size ] ;
private byte [ ] connetion _ recv _ buffer = new byte [ buffer _ size ] ;
private byte [ ] remote _ send _ buffer = new byte [ buffer _ size ] ;
private byte [ ] connetion _ send _ buffer = new byte [ buffer _ size ] ;
public tcp _ handler ( shadowsocks _ controller controller , configuration config , tcp _ relay tcprelay , socket socket )
config = config ; tcprelay = tcprelay ;
this . server = server ;
if ( closed ) return ;
lock ( tcprelay . handlers ) { tcprelay . handlers . remove ( this ) ; }
} catch ( exception e ) { logger . log _ useful _ exception ( e ) ; close ( ) ;
if ( closed ) return ;
handshake _ receive _ callback , null ) ; } catch ( exception e ) { logger . log _ useful _ exception ( e ) ; close ( ) ; } } private void handshake _ receive _ callback ( i _ async _ result ar ) { if ( closed ) return ;
logger . log _ useful _ exception ( e ) ; close ( ) ; } } private void response _ callback ( i _ async _ result ar )
logger . log _ useful _ exception ( e ) ; close ( ) ;
if ( closed ) return ;
var states = ( object [ ] ) ar . async _ state ;
var on _ success = ( action ) states [ 1 ] ;
} } catch ( exception e ) { logger . log _ useful _ exception ( e ) ; close ( ) ;
proxy _ ep = socket _ util . get _ end _ point ( config . proxy . proxy _ server , config . proxy . proxy _ port ) ;
var session = new async _ session ( remote ) ;
logger . log _ useful _ exception ( e ) ; close ( ) ;
var timer = ( proxy _ timer ) sender ;
var proxy = timer . session . remote ;
var session = ( async _ session < proxy _ timer > ) ar . async _ state ;
var dest _ end _ point = timer . dest _ end _ point ; var server = timer . server ;
var remote = session . remote ;
if ( config . proxy . use _ auth ) { auth = new network _ credential ( config . proxy . auth _ user , config . proxy . auth _ pwd ) ;
logger . log _ useful _ exception ( e ) ; close ( ) ;
var timer = ( server _ timer ) sender ;
var session = timer . session ;
i _ strategy strategy = controller . get _ current _ strategy ( ) ; strategy ? . set _ failure ( server ) ;
if ( closed ) return ; try { var session = ( async _ session < server _ timer > ) ar . async _ state ;
var remote = session . remote ;
var latency = date _ time . now - start _ connect _ time ; i _ strategy strategy = controller . get _ current _ strategy ( ) ; strategy ? . update _ latency ( server , latency ) ; tcprelay . update _ latency ( server , latency ) ;
i _ strategy strategy = controller . get _ current _ strategy ( ) ; strategy ? . set _ failure ( server ) ; } logger . log _ useful _ exception ( e ) ; close ( ) ;
var size = connection . receive ( connetion _ recv _ buffer , first _ packet _ length , available ,
if ( closed ) return ;
logger . log _ useful _ exception ( e ) ; close ( ) ;
if ( closed ) return ; try { var session = ( async _ session ) ar . async _ state ;
tcprelay . update _ inbound _ counter ( server , bytes _ read ) ;
logger . log _ useful _ exception ( e ) ; close ( ) ;
if ( closed ) return ;
var session = ( async _ session ) ar . async _ state ; var remote = session . remote ;
tcprelay . update _ outbound _ counter ( server , bytes _ to _ send ) ;
i _ strategy strategy = controller . get _ current _ strategy ( ) ; strategy ? . update _ last _ write ( server ) ;
if ( closed ) return ; try { var container = ( object [ ] ) ar . async _ state ; var session = ( async _ session ) container [ 0 ] ; var bytes _ should _ send = ( int ) container [ 1 ] ;
logger . log _ useful _ exception ( e ) ; close ( ) ;
var container = ( object [ ] ) ar . async _ state ; var session = ( async _ session ) container [ 0 ] ; var bytes _ should _ send = ( int ) container [ 1 ] ; var bytes _ sent = connection . end _ send ( ar ) ; var bytes _ remaining = bytes _ should _ send - bytes _ sent ;
STR ,
STR , STR } ) ;
private static bool encryption _ failed = false ; private static object locker = new object ( ) ;
for ( int i = 0 ; i < NUM ; i + + ) { var random = new random ( ) ; i _ encryptor encryptor ; i _ encryptor decryptor ; encryptor = new polar _ ssl _ encryptor ( STR , STR ) ; decryptor = new polar _ ssl _ encryptor ( STR , STR ) ; byte [ ] plain = new byte [ NUM ] ; byte [ ] cipher = new byte [ plain . length + NUM ] ; byte [ ] plain = new byte [ plain . length + NUM ] ; int out _ len = 0 ; int out _ len = 0 ; random . next _ bytes ( plain ) ;   encryptor . encrypt ( plain , plain . length , cipher , out out _ len ) ; decryptor . decrypt ( cipher , out _ len , plain , out out _ len ) ; assert . are _ equal ( plain . length , out _ len ) ; for ( int j = 0 ; j < plain . length ; j + + ) { assert . are _ equal ( plain [ j ] , plain [ j ] ) ; } encryptor . encrypt ( plain , NUM , cipher , out out _ len ) ; decryptor . decrypt ( cipher , out _ len , plain , out out _ len ) ; assert . are _ equal ( NUM , out _ len ) ; for ( int j = 0 ; j < out _ len ; j + + ) { assert . are _ equal ( plain [ j ] , plain [ j ] ) ; } encryptor . encrypt ( plain , NUM , cipher , out out _ len ) ; decryptor . decrypt ( cipher , out _ len , plain , out out _ len ) ; assert . are _ equal ( NUM , out _ len ) ; for ( int j = 0 ; j < out _ len ; j + + ) { assert . are _ equal ( plain [ j ] , plain [ j ] ) ; }  }
this . table _ layout _ panel = new system . windows . forms . table _ layout _ panel ( ) ; this . table _ layout _ panel = new system . windows . forms . table _ layout _ panel ( ) ;
this . table _ layout _ panel = new system . windows . forms . table _ layout _ panel ( ) ;
this . table _ layout _ panel = new system . windows . forms . table _ layout _ panel ( ) ;
this . table _ layout _ panel . suspend _ layout ( ) ; this . table _ layout _ panel . suspend _ layout ( ) ; this . table _ layout _ panel . suspend _ layout ( ) ;
this . my _ cancel _ button . dock = system . windows . forms . dock _ style . right ;
this . ok _ button . dock = system . windows . forms . dock _ style . right ;
this . table _ layout _ panel . resume _ layout ( false ) ; this . table _ layout _ panel . resume _ layout ( false ) ; this . table _ layout _ panel . perform _ layout ( ) ; this . table _ layout _ panel . resume _ layout ( false ) ; this . table _ layout _ panel . perform _ layout ( ) ;
this . perform _ layout ( ) ;
private system . windows . forms . table _ layout _ panel table _ layout _ panel ;
private system . windows . forms . table _ layout _ panel table _ layout _ panel ;
private system . windows . forms . table _ layout _ panel table _ layout _ panel ;
private system . windows . forms . table _ layout _ panel table _ layout _ panel ;
this . qr _ code _ item = new system . windows . forms . menu _ item ( ) ;
this . lock _ button = new system . windows . forms . button ( ) ; this . panel = new system . windows . forms . panel ( ) ;
this . panel . suspend _ layout ( ) ;
this . cancel _ button = this . my _ cancel _ button ;
this . controls . add ( this . panel ) ;
this . top _ most = true ;
this . panel . resume _ layout ( false ) ;
if ( controller = = null | | controller . get _ configuration ( ) . is _ default ) { is _ first _ run = true ;
this . opacity = 0 ; begin _ invoke ( new method _ invoker ( delegate { this . hide ( ) ; } ) ) ;
ip _ address addr ; if ( ! ip _ address . try _ parse ( server , out addr ) ) { logging . error ( STR ) ;
if ( remarks . is _ null _ or _ empty ( ) ) { switch ( addr . address _ family ) { case address _ family . inter _ network : return $ STR ; case address _ family . inter _ network : return $ STR ; } } else { switch ( addr . address _ family ) { case address _ family . inter _ network : return $ STR ; case address _ family . inter _ network : return $ STR ; }
return null ;
this . client _ size = new system . drawing . size ( NUM , NUM ) ;
private void controller _ traffic _ changed ( object sender , event _ args e ) {
inbound _ points . clear ( ) ; outbound _ points . clear ( ) ; foreach ( var traffic _ per _ second in controller . traffic ) { inbound _ points . add ( traffic _ per _ second . inbound _ increasement ) ; outbound _ points . add ( traffic _ per _ second . outbound _ increasement ) ; max _ speed = math . max ( max _ speed , math . max ( traffic _ per _ second . inbound _ increasement , traffic _ per _ second . outbound _ increasement ) ) ;
try { if ( traffic _ chart . invoke _ required & & traffic _ chart . is _ handle _ created ) { traffic _ chart . invoke ( new action ( ( ) = > { traffic _ chart . series [ STR ] . points . data _ bind _ y ( inbound _ points ) ; traffic _ chart . series [ STR ] . points . data _ bind _ y ( outbound _ points ) ; traffic _ chart . chart _ areas [ 0 ] . axis _ y . label _ style . format = STR + bandwidth _ scale . item ;  inbound _ annotation . anchor _ data _ point = traffic _ chart . series [ STR ] . points . last ( ) ; inbound _ annotation . text = utils . format _ bandwidth ( controller . traffic . last . inbound _ increasement ) ; outbound _ annotation . anchor _ data _ point = traffic _ chart . series [ STR ] . points . last ( ) ; outbound _ annotation . text = utils . format _ bandwidth ( controller . traffic . last . outbound _ increasement ) ; traffic _ chart . annotations . clear ( ) ; traffic _ chart . annotations . add ( inbound _ annotation ) ; traffic _ chart . annotations . add ( outbound _ annotation ) ; } ) ) ; } } catch ( object _ disposed _ exception ) {
this . plugin _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;
this . remarks _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;
this . ip _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;
this . server _ port _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;
this . password _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;
this . plugin _ options _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;
this . show _ passwd _ check _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;
this . plugin _ arguments _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;
this . table _ layout _ panel . padding = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;
this . proxy _ port _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;
public static readonly date _ time unknown _ date _ time ;
unknown _ date _ time = new date _ time ( NUM , 1 , 1 ) ;
this . all _ mode . checked = true ;
this . all _ mode . tab _ stop = true ;
this . split _ container . size = new system . drawing . size ( NUM , NUM ) ; this . split _ container . splitter _ distance = NUM ; this . split _ container . splitter _ width = NUM ;
this . label . text = STR ;
public tcp _ relay ( shadowsocks _ controller controller )
tcp _ handler handler = new tcp _ handler ( this ) ;
public tcp _ handler ( tcp _ relay tcprelay )
if ( controller . get _ current _ configuration ( ) . is _ verbose _ logging ) {
if ( controller . get _ current _ configuration ( ) . is _ verbose _ logging ) {
if ( controller . get _ current _ configuration ( ) . is _ verbose _ logging ) {
void controller _ update _ pac _ from _ gfw _ list _ error ( object sender , system . io . error _ event _ args e ) { is _ update _ pac _ from _ gfw _ list _ running = false ; notify _ icon . balloon _ tip _ title = n . get _ string ( STR ) ; notify _ icon . balloon _ tip _ text = n . get _ string ( STR ) ; notify _ icon . balloon _ tip _ icon = tool _ tip _ icon . info ; notify _ icon . show _ balloon _ tip ( NUM ) ;
is _ update _ pac _ from _ gfw _ list _ running = false ; notify _ icon . balloon _ tip _ title = n . get _ string ( STR ) ; notify _ icon . balloon _ tip _ text = n . get _ string ( STR ) ; notify _ icon . balloon _ tip _ icon = tool _ tip _ icon . info ; notify _ icon . show _ balloon _ tip ( NUM ) ;
notify _ icon . balloon _ tip _ title = string . format ( n . get _ string ( STR ) , update _ checker . latest _ version _ number ) ; notify _ icon . balloon _ tip _ text = n . get _ string ( STR ) ; notify _ icon . balloon _ tip _ icon = tool _ tip _ icon . info ;
notify _ icon . show _ balloon _ tip ( NUM ) ;
if ( config . use _ proxy )
proxy _ ep = socket _ util . get _ end _ point ( config . proxy _ server , config . proxy _ port ) ;
config . use _ proxy = false ;
config . use _ proxy = true ; config . proxy _ server = proxy ; config . proxy _ port = port ;
url _ finder = new regex ( STR , regex _ options . ignore _ case | regex _ options . compiled ) ,
STR , regex _ options . compiled | regex _ options . ignore _ case ) ;
var type = proxy _ type _ combo _ box . selected _ index ; var proxy = proxy _ server _ text _ box . text ; var port = int . parse ( proxy _ port _ text _ box . text ) ; var timeout = int . parse ( proxy _ timeout _ text _ box . text ) ; configuration . check _ server ( proxy ) ; configuration . check _ port ( port ) ; configuration . check _ timeout ( timeout , proxy _ config . max _ proxy _ timeout _ sec ) ; controller . enable _ proxy ( type , proxy , port ) ;
modified _ configuration . proxy _ type = proxy _ type _ combo _ box . selected _ index ; modified _ configuration . proxy _ server = proxy _ server _ text _ box . text ; var tmp _ proxy _ port = 0 ; int . try _ parse ( proxy _ port _ text _ box . text , out tmp _ proxy _ port ) ; modified _ configuration . proxy _ port = tmp _ proxy _ port ; var tmp _ proxy _ timeout = 0 ; int . try _ parse ( proxy _ timeout _ text _ box . text , out tmp _ proxy _ timeout ) ; modified _ configuration . proxy _ timeout = tmp _ proxy _ timeout ;
server server = new server { server = ip _ text _ box . text . trim ( ) , server _ port = int . parse ( server _ port _ text _ box . text ) , password = password _ text _ box . text , method = encryption _ select . text , remarks = remarks _ text _ box . text , timeout = int . parse ( timeout _ text _ box . text ) , auth = one _ time _ auth . checked } ;
} catch ( format _ exception ) { message _ box . show ( n . get _ string ( STR ) ) ;
this . qr _ code _ web _ browser = new system . windows . forms . web _ browser ( ) ;
this . qr _ code _ web _ browser . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( ( ( system . windows . forms . anchor _ styles . top | system . windows . forms . anchor _ styles . bottom ) | system . windows . forms . anchor _ styles . left ) | system . windows . forms . anchor _ styles . right ) ) ) ; this . qr _ code _ web _ browser . location = new system . drawing . point ( 0 , 0 ) ; this . qr _ code _ web _ browser . margin = new system . windows . forms . padding ( 0 ) ; this . qr _ code _ web _ browser . minimum _ size = new system . drawing . size ( NUM , NUM ) ; this . qr _ code _ web _ browser . name = STR ; this . qr _ code _ web _ browser . script _ errors _ suppressed = true ; this . qr _ code _ web _ browser . scroll _ bars _ enabled = false ; this . qr _ code _ web _ browser . size = new system . drawing . size ( NUM , NUM ) ; this . qr _ code _ web _ browser . tab _ index = 0 ;
this . picture _ box . location = new system . drawing . point ( 0 , 0 ) ;
this . picture _ box . size = new system . drawing . size ( NUM , NUM ) ;
this . auto _ size = true ; this . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . client _ size = new system . drawing . size ( NUM , NUM ) ; this . controls . add ( this . picture _ box ) ; this . controls . add ( this . qr _ code _ web _ browser ) ;
private system . windows . forms . web _ browser qr _ code _ web _ browser ;
public tcp _ handler ( shadowsocks _ controller controller , configuration config , tcp _ relay tcprelay , socket socket )
tcprelay = tcprelay ;
public void ask _ add _ server _ by _ ssurl ( string ss _ url )
add _ server _ by _ ssurl ( ss _ url ) ; }
return ; } list < string > lines = new list < string > ( ) ; if ( file . exists ( pac _ server . user _ rule _ file ) ) { string local = file _ manager . non _ exclusive _ read _ all _ text ( pac _ server . user _ rule _ file , encoding . ut ) ; using ( var sr = new string _ reader ( local ) ) { foreach ( var rule in sr . non _ white _ space _ lines ( ) ) { if ( rule . begin _ with _ any ( ignored _ line _ begins ) ) continue ; lines . add ( rule ) ; } } } lines . add _ range ( gfw _ list _ updater . parse _ result ( file _ manager . non _ exclusive _ read _ all _ text ( utils . get _ temp _ path ( STR ) ) ) ) ; string abp _ content ; if ( file . exists ( pac _ server . user _ abp _ file ) ) { abp _ content = file _ manager . non _ exclusive _ read _ all _ text ( pac _ server . user _ abp _ file , encoding . ut ) ;
abp _ content = utils . un _ gzip ( resources . abp _ js ) ; } abp _ content = abp _ content . replace ( STR , json _ convert . serialize _ object ( lines , formatting . indented ) ) ; if ( file . exists ( pac _ server . pac _ file ) ) { string original = file _ manager . non _ exclusive _ read _ all _ text ( pac _ server . pac _ file , encoding . ut ) ; if ( original = = abp _ content ) { return ; } } file . write _ all _ text ( pac _ server . pac _ file , abp _ content , encoding . ut ) ;
list < string > lines = new list < string > ( ) ; if ( file . exists ( pac _ server . user _ rule _ file ) ) { string local = file _ manager . non _ exclusive _ read _ all _ text ( pac _ server . user _ rule _ file , encoding . ut ) ; using ( var sr = new string _ reader ( local ) ) { foreach ( var rule in sr . non _ white _ space _ lines ( ) ) { if ( rule . begin _ with _ any ( ignored _ line _ begins ) ) continue ; lines . add ( rule ) ; } } } lines . add _ range ( parse _ result ( e . result ) ) ; string abp _ content ; if ( file . exists ( pac _ server . user _ abp _ file ) ) { abp _ content = file _ manager . non _ exclusive _ read _ all _ text ( pac _ server . user _ abp _ file , encoding . ut ) ; } else { abp _ content = utils . un _ gzip ( resources . abp _ js ) ; } abp _ content = abp _ content . replace ( STR , json _ convert . serialize _ object ( lines , formatting . indented ) ) ; if ( file . exists ( pac _ server . pac _ file ) ) { string original = file _ manager . non _ exclusive _ read _ all _ text ( pac _ server . pac _ file , encoding . ut ) ; if ( original = = abp _ content ) { update _ completed ( this , new result _ event _ args ( false ) ) ; return ; } } file . write _ all _ text ( pac _ server . pac _ file , abp _ content , encoding . ut ) ; update _ completed ? . invoke ( this , new result _ event _ args ( true ) ) ;
public const int buffer _ size = recv _ size + ( recv _ size / iv _ encryptor . crc _ buf _ len + 1 ) * iv _ encryptor . crc _ bytes + NUM ;
private byte [ ] remote _ recv _ buffer = new byte [ recv _ size ] ;
private byte [ ] connetion _ recv _ buffer = new byte [ recv _ size ] ;
server . server = ip _ text _ box . text . trim ( ) ; try {   server . server _ port = int . parse ( server _ port _ text _ box . text ) ; } catch ( format _ exception )
server _ port _ text _ box . clear ( ) ;
try { server . timeout = int . parse ( timeout _ text _ box . text ) ; } catch ( format _ exception )
timeout _ text _ box . clear ( ) ;
if ( socket . protocol _ type ! = protocol _ type . tcp ) {
} if ( length < 2 | | first _ packet [ 0 ] ! = NUM ) { return false ; } socket . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; tcp _ handler handler = new tcp _ handler ( this ) ; handler . connection = socket ; handler . controller = controller ; handler . tcprelay = this ; handler . start ( first _ packet , length ) ; i _ list < tcp _ handler > handlers _ to _ close = new list < tcp _ handler > ( ) ; lock ( handlers ) { handlers . add ( handler ) ; date _ time now = date _ time . now ; if ( now - last _ sweep _ time > time _ span . from _ seconds ( 1 ) ) { last _ sweep _ time = now ; foreach ( tcp _ handler handler in handlers ) { if ( now - handler . last _ activity > time _ span . from _ seconds ( NUM ) ) { handlers _ to _ close . add ( handler ) ; } } } } foreach ( tcp _ handler handler in handlers _ to _ close ) { logging . debug ( STR ) ; handler . close ( ) ; } return true ;
this . tcprelay = tcprelay ;
{
}
{
} closed = true ; } if ( connection ! = null ) { try { connection . shutdown ( socket _ shutdown . both ) ; connection . close ( ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; } } if ( remote ! = null ) { try { remote . shutdown ( socket _ shutdown . both ) ; remote . close ( ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; }
if ( encryptor ! = null ) { ( ( i _ disposable ) encryptor ) . dispose ( ) ; }
if ( closed ) { return ; }
{
}
if ( closed ) { return ; }
{
}
if ( end _ point . address _ family = = address _ family . inter _ network ) { response [ NUM ] = 1 ; } else if ( end _ point . address _ family = = address _ family . inter _ network ) { response [ NUM ] = NUM ;
if ( closed ) { return ; }
{
}
if ( connected ) { return ; }
if ( strategy ! = null ) { strategy . set _ failure ( server ) ; }
{ close ( ) ; }
server server = null ; if ( closed ) { return ; }
server = timer . server ;
if ( strategy ! = null ) { strategy . set _ failure ( server ) ; }
if ( closed ) { return ; }
if ( closed ) { return ; }
if ( strategy ! = null ) { strategy . update _ last _ read ( server ) ; }
- 2 * NUM * ( math . min ( NUM , status . latency . total _ milliseconds ) / ( 1 + ( now - status . last _ time _ detect _ latency ) . total _ seconds / NUM / 2 ) +
var server _ urls = ss _ url . split ( '\r' , '\n' , ' ' ) ; list < server > servers = new list < server > ( ) ; foreach ( string server _ url in server _ urls ) { string server _ url = server _ url . trim ( ) ; if ( ! server _ url . begin _ with ( STR , string _ comparison . invariant _ culture _ ignore _ case ) ) { continue ; } server legacy _ server = parse _ legacy _ url ( server _ url ) ; if ( legacy _ server ! = null ) { servers . add ( legacy _ server ) ; } else { uri parsed _ url ; try { parsed _ url = new uri ( server _ url ) ; } catch ( uri _ format _ exception ) { continue ; } server server = new server { remarks = parsed _ url . get _ components ( uri _ components . fragment , uri _ format . unescaped ) , server = parsed _ url . idn _ host , server _ port = parsed _ url . port , } ;  string raw _ user _ info = parsed _ url . get _ components ( uri _ components . user _ info , uri _ format . unescaped ) ; string base = raw _ user _ info . replace ( '-' , '+' ) . replace ( '_' , '/' ) ; string user _ info = STR ; try { user _ info = encoding . ut . get _ string ( convert . from _ base _ string ( base . pad _ right ( base . length + ( NUM - base . length % NUM ) % NUM , '=' ) ) ) ; } catch ( format _ exception ) { continue ; } string [ ] user _ info _ parts = user _ info . split ( new char [ ] { ':' } , 2 ) ; if ( user _ info _ parts . length ! = 2 ) { continue ; } server . method = user _ info _ parts [ 0 ] ; server . password = user _ info _ parts [ 1 ] ; name _ value _ collection query _ parameters = http _ utility . parse _ query _ string ( parsed _ url . query ) ; string [ ] plugin _ parts = ( query _ parameters [ STR ] ? ? STR ) . split ( new [ ] { ';' } , 2 ) ; if ( plugin _ parts . length > 0 ) { server . plugin = plugin _ parts [ 0 ] ? ? STR ; } if ( plugin _ parts . length > 1 ) { server . plugin _ opts = plugin _ parts [ 1 ] ? ? STR ; } servers . add ( server ) ; } } return servers ;
using ( stream _ reader reader = new stream _ reader ( new file _ stream ( filename , file _ mode . open , file _ access . read , file _ share . read _ write ) ) ) { reader . base _ stream . seek ( last _ offset , seek _ origin . begin ) ; string line = STR ; bool changed = false ; while ( ( line = reader . read _ line ( ) ) ! = null ) { changed = true ; log _ message _ text _ box . append _ text ( line + environment . new _ line ) ;
if ( changed ) { log _ message _ text _ box . scroll _ to _ caret ( ) ; } last _ offset = reader . base _ stream . position ;
file _ stream fs = new file _ stream ( log _ file _ path , file _ mode . append ) ; stream _ writer _ with _ timestamp sw = new stream _ writer _ with _ timestamp ( fs ) ;
console . write _ line ( o ) ;
update _ system _ proxy ( ) ;
update _ system _ proxy ( ) ;
update _ system _ proxy ( ) ;
update _ system _ proxy ( ) ;
using system _ collections _ generic ; using system _ component _ model ;
using system _ net _ network _ information ;
using system _ runtime _ interop _ services ;
running _ port = this . get _ free _ port ( ) ;
file _ manager . byte _ array _ to _ file ( utils . get _ temp _ path ( unique _ config _ file ) , encoding . ut . get _ bytes ( privoxy _ config ) ) ; process = new process ( ) ;   process . start _ info . file _ name = STR ; process . start _ info . arguments = unique _ config _ file ; process . start _ info . working _ directory = utils . get _ temp _ path ( ) ; process . start _ info . window _ style = process _ window _ style . hidden ; process . start _ info . use _ shell _ execute = true ; process . start _ info . create _ no _ window = true ;
refresh _ tray _ area ( ) ;
refresh _ tray _ area ( ) ;
this . panel = new system . windows . forms . panel ( ) ;
this . panel . suspend _ layout ( ) ;
this . picture _ box . dock = system . windows . forms . dock _ style . fill ; this . picture _ box . location = new system . drawing . point ( NUM , NUM ) ;
this . picture _ box . size = new system . drawing . size ( NUM , NUM ) ; this . picture _ box . size _ mode = system . windows . forms . picture _ box _ size _ mode . stretch _ image ;
this . panel . controls . add ( this . picture _ box ) ; this . panel . dock = system . windows . forms . dock _ style . fill ; this . panel . location = new system . drawing . point ( 0 , 0 ) ; this . panel . margin = new system . windows . forms . padding ( 0 ) ; this . panel . name = STR ; this . panel . padding = new system . windows . forms . padding ( NUM ) ; this . panel . size = new system . drawing . size ( NUM , NUM ) ; this . panel . tab _ index = 2 ;
this . client _ size = new system . drawing . size ( NUM , NUM ) ; this . controls . add ( this . panel ) ;
this . panel . resume _ layout ( false ) ;
private system . windows . forms . panel panel ;
private readonly concurrent _ dictionary < string , long > inbound _ counter = new concurrent _ dictionary < string , long > ( ) ; private readonly concurrent _ dictionary < string , long > last _ inbound _ counter = new concurrent _ dictionary < string , long > ( ) ;
private readonly concurrent _ dictionary < string , long > outbound _ counter = new concurrent _ dictionary < string , long > ( ) ; private readonly concurrent _ dictionary < string , long > last _ outbound _ counter = new concurrent _ dictionary < string , long > ( ) ;
foreach ( var kv in last _ inbound _ counter )
var last _ inbound = kv . value ; var inbound = inbound _ counter [ id ] ; var bytes = inbound - last _ inbound ; last _ inbound _ counter [ id ] = inbound ; var inbound _ speed = get _ speed _ in _ ki _ b _ per _ second ( bytes , monitor _ interval . total _ seconds ) ; inbound _ speed _ records . get _ or _ add ( id , ( k ) = > { list < int > records = new list < int > ( ) ; records . add ( inbound _ speed ) ; return records ; } ) ; var last _ outbound = last _ outbound _ counter [ id ] ; var outbound = outbound _ counter [ id ] ; bytes = outbound - last _ outbound ; last _ outbound _ counter [ id ] = outbound ; var outbound _ speed = get _ speed _ in _ ki _ b _ per _ second ( bytes , monitor _ interval . total _ seconds ) ; outbound _ speed _ records . get _ or _ add ( id , ( k ) = > { list < int > records = new list < int > ( ) ; records . add ( outbound _ speed ) ; return records ; } ) ;
inbound _ counter . add _ or _ update ( server . identifier ( ) , ( k ) = > { last _ inbound _ counter . get _ or _ add ( server . identifier ( ) , 0 ) ; return n ; } , ( k , v ) = > ( v + n ) ) ;
outbound _ counter . add _ or _ update ( server . identifier ( ) , ( k ) = > { last _ outbound _ counter . get _ or _ add ( server . identifier ( ) , 0 ) ; return n ; } , ( k , v ) = > ( v + n ) ) ;
if ( string . is _ null _ or _ empty ( password ) )
if ( string . is _ null _ or _ empty ( server ) )
if ( string . is _ null _ or _ empty ( server ) )
if ( string . is _ null _ or _ empty ( remarks ) )
if ( string . is _ null _ or _ empty ( controller . get _ configuration _ copy ( ) . pac _ url ) )
if ( ! string . is _ null _ or _ empty ( controller . get _ configuration _ copy ( ) . pac _ url ) )
m md = m . create ( ) ;
md _ sum = md . compute _ hash ( password ) ;
md _ sum = md . compute _ hash ( result ) ;
this . share _ over _ lan _ item . index = 1 ;
this . servers _ item . index = 2 ;
float min _ x = int . max _ value , min _ y = int . max _ value , max _ x = 0 , max _ y = 0 ;
file _ system _ watcher watcher ;
if ( watcher ! = null ) { watcher . dispose ( ) ; } watcher = new file _ system _ watcher ( directory . get _ current _ directory ( ) ) ; watcher . notify _ filter = notify _ filters . last _ write | notify _ filters . file _ name | notify _ filters . directory _ name ; watcher . filter = pac _ file ; watcher . changed + = watcher _ changed ; watcher . created + = watcher _ changed ; watcher . deleted + = watcher _ changed ; watcher . renamed + = watcher _ changed ; watcher . enable _ raising _ events = true ; } private void watcher _ changed ( object sender , file _ system _ event _ args e )
int target _ index = 0 ; for ( int i = 1 ; i < locale _ names . length ; i + + )
} if ( locale _ names [ i ] = = locale ) { target _ index = i ;
if ( string . is _ null _ or _ white _ space ( translations [ 0 ] ) ) continue ;
strings [ translations [ en _ index ] ] = translations [ target _ index ] ;
init ( resources . n _ csv , culture _ info . current _ culture . ietf _ language _ tag ) ;
( ( system . component _ model . i _ support _ initialize ) ( this . binding _ configuration ) ) . begin _ init ( ) ;
public string timestamp ;
int prefix _ length = STR . length ;
int index _ of _ hash _ or _ slash = server _ url . index _ of _ any ( new [ ] { '@' , '/' , '#' } , prefix _ length , server _ url . length - prefix _ length ) ; string web _ safe _ base _ str = index _ of _ hash _ or _ slash = = - 1 ? server _ url . substring ( prefix _ length ) : server _ url . substring ( prefix _ length , index _ of _ hash _ or _ slash - prefix _ length ) ; string base _ str = web _ safe _ base _ str . replace ( '-' , '+' ) . replace ( '_' , '/' ) ; string base = base _ str . pad _ right ( base _ str . length + ( NUM - base _ str . length % NUM ) % NUM , '=' ) ; string decoded _ base = encoding . ut . get _ string ( convert . from _ base _ string ( base ) ) ; string decoded _ server _ url = server _ url . replace ( web _ safe _ base _ str , decoded _ base ) ; uri parsed _ url ; try
parsed _ url = new uri ( decoded _ server _ url ) ;
catch ( uri _ format _ exception )
continue ;
server tmp = new server { remarks = parsed _ url . get _ components ( uri _ components . fragment , uri _ format . unescaped ) } ; string user _ info = parsed _ url . get _ components ( uri _ components . user _ info , uri _ format . unescaped ) ; tmp . server = parsed _ url . get _ components ( uri _ components . host , uri _ format . unescaped ) ; tmp . server _ port = parsed _ url . port ; string [ ] user _ info _ parts = user _ info . split ( new [ ] { ':' } , 2 ) ; if ( user _ info _ parts . length ! = 2 ) { continue ; } tmp . method = user _ info _ parts [ 0 ] ; tmp . password = user _ info _ parts [ 1 ] ; name _ value _ collection query _ parameters = http _ utility . parse _ query _ string ( parsed _ url . query ) ; string [ ] plugin _ parts = http _ utility . url _ decode ( query _ parameters [ STR ] ? ? STR ) . split ( new [ ] { ';' } , 2 ) ; if ( plugin _ parts . length > 0 ) { tmp . plugin = plugin _ parts [ 0 ] ? ? STR ; } if ( plugin _ parts . length > 1 ) { tmp . plugin _ opts = plugin _ parts [ 1 ] ? ? STR ; } servers . add ( tmp ) ;
protected byte [ ] encrypt _ buf ; protected byte [ ] decrypt _ buf ;
encrypt _ buf = new byte [ max _ input _ size + sodium _ block _ size ] ; decrypt _ buf = new byte [ max _ input _ size + sodium _ block _ size ] ;
byte [ ] sodium _ buf ;
if ( is _ cipher )
bytes _ remaining = encrypt _ bytes _ remaining ; ic = encrypt _ ic ; sodium _ buf = encrypt _ buf ; iv = encrypt _ iv ; } else { bytes _ remaining = decrypt _ bytes _ remaining ; ic = decrypt _ ic ; sodium _ buf = decrypt _ buf ; iv = decrypt _ iv ; } int padding = bytes _ remaining ; buffer . block _ copy ( buf , 0 , sodium _ buf , padding , length ) ; switch ( cipher ) { case cipher _ sals : sodium . crypto _ stream _ salsa _ xor _ ic ( sodium _ buf , sodium _ buf , ( ulong ) ( padding + length ) , iv , ic , key ) ; break ; case cipher _ chach : sodium . crypto _ stream _ chacha _ xor _ ic ( sodium _ buf , sodium _ buf , ( ulong ) ( padding + length ) , iv , ic , key ) ; break ; } buffer . block _ copy ( sodium _ buf , padding , outbuf , 0 , length ) ; padding + = length ; ic + = ( ulong ) padding / sodium _ block _ size ; bytes _ remaining = padding % sodium _ block _ size ; if ( is _ cipher ) { encrypt _ bytes _ remaining = bytes _ remaining ; encrypt _ ic = ic ; } else { decrypt _ bytes _ remaining = bytes _ remaining ; decrypt _ ic = ic ;
int strlen = ip _ address . network _ to _ host _ order ( bit _ converter . to _ int ( buf , 0 ) ) ; await stream . read _ async ( buf , 0 , strlen ) ; string url = encoding . ut . get _ string ( buf , 0 , strlen ) ; console . write _ line ( url ) ;
polipo _ runner = new polipo _ runner ( ) ; polipo _ runner . start ( config ) ; local = new local ( config ) ; try { local . start ( ) ; } catch ( exception e ) { console . write _ line ( e ) ; } try {    pac _ server = new pac _ server ( ) ; pac _ server . pac _ file _ changed + = pac _ server _ pac _ file _ changed ; pac _ server . start ( config ) ; } catch ( exception e ) { console . write _ line ( e ) ; } update _ system _ proxy ( ) ; start _ releasing _ memory ( ) ;
protected void save _ config ( configuration new _ config ) { configuration . save ( new _ config ) ;
local . stop ( ) ;
polipo _ runner . start ( config ) ; local = new local ( config ) ; local . start ( ) ; pac _ server . start ( config ) ;
controller . get _ current _ strategy ( ) . update _ latency ( server , latency ) ;
controller . get _ current _ strategy ( ) . set _ failure ( server ) ;
private menu _ item seperator _ item ; private menu _ item edit _ pac _ file _ item ; private menu _ item qr _ code _ item ; private menu _ item show _ log _ item ; private menu _ item about _ item ;
private menu _ item seperator _ item ; private menu _ item quit _ item ; private menu _ item seperator _ item ; private menu _ item mode _ item ;
this . mode _ item = create _ menu _ group ( 1 , STR , new system . windows . forms . menu _ item [ ] { this . pac _ mode _ item , this . global _ mode _ item } ) ;
this . seperator _ item , this . config _ item } ) ; this . seperator _ item = create _ seperator _ item ( NUM ) ;
this . edit _ pac _ file _ item = create _ menu _ item ( NUM , STR , new system . event _ handler ( this . edit _ pac _ file _ item _ click ) ) ; this . seperator _ item = create _ seperator _ item ( NUM ) ; this . qr _ code _ item = create _ menu _ item ( NUM , STR , new system . event _ handler ( this . qr _ code _ item _ click ) ) ; this . show _ log _ item = create _ menu _ item ( NUM , STR , new system . event _ handler ( this . show _ log _ item _ click ) ) ; this . about _ item = create _ menu _ item ( NUM , STR , new system . event _ handler ( this . config _ click ) ) ; this . seperator _ item = create _ seperator _ item ( NUM ) ; this . quit _ item = create _ menu _ item ( NUM , STR , new system . event _ handler ( this . quit _ click ) ) ;
this . mode _ item ,
this . seperator _ item ,
this . edit _ pac _ file _ item , this . seperator _ item , this . qr _ code _ item , this . show _ log _ item , this . about _ item , this . seperator _ item , this . quit _ item } ) ;
xml _ document xml _ doc = new xml _ document ( ) ; xml _ doc . load _ xml ( response ) ; xml _ node _ list elements = xml _ doc . get _ elements _ by _ tag _ name ( STR ) ;
foreach ( xml _ node el in elements )
foreach ( xml _ attribute attr in el . attributes )
if ( attr . name = = STR )
if ( is _ new _ version ( attr . value ) ) { versions . add ( attr . value ) ; }
using system _ text ;
private static bool user _ settings _ recorded = false ;
private static string [ ] user _ settings = new string [ NUM ] ;
string str ; if ( user _ settings _ recorded = = false )
exec _ sysproxy ( STR , out str ) ; parse _ query _ str ( str ) ; user _ settings _ recorded = true ;
var flags = user _ settings [ 0 ] ; var proxy _ server = user _ settings [ 1 ] ? ? STR ; var bypass _ list = user _ settings [ 2 ] ? ? STR ; var pac _ url = user _ settings [ NUM ] ? ? STR ;
user _ settings _ recorded = false ;
exec _ sysproxy ( arguments , out str ) ;
private static void exec _ sysproxy ( string arguments , out string query _ str )
if ( arguments = = STR & & stdout . is _ null _ or _ white _ space ( ) ) {  throw new proxy _ exception ( STR ) ;
query _ str = stdout ;
user _ settings = str . split ( new string [ ] { STR } , string _ split _ options . remove _ empty _ entries ) ; for ( var i = 0 ; i < NUM ; i + + ) {  if ( user _ settings [ i ] = = STR ) user _ settings [ i ] = null ; }
using system ;
using system _ io ; using system _ reflection ; using system _ runtime _ interop _ services ;
dll _ import _ kernel _ dll private static extern int _ ptr load _ library ( string path ) ;
protected void update _ key _ buffer ( ) { if ( key _ buffer = = null ) { key _ buffer = new byte [ max _ iv _ length + NUM ] ; buffer . block _ copy ( encrypt _ iv , 0 , key _ buffer , 0 , iv _ len ) ; } byte [ ] counter _ bytes = bit _ converter . get _ bytes ( ( uint ) ip _ address . host _ to _ network _ order ( ( int ) counter ) ) ; buffer . block _ copy ( counter _ bytes , 0 , key _ buffer , iv _ len , NUM ) ; counter + + ; } protected byte [ ] gen _ hash ( byte [ ] buf , int offset , int len )
update _ key _ buffer ( ) ; sodium . ss _ sha _ hmac _ ex ( key _ buffer , ( uint ) key _ buffer . length ,
int head _ len = get _ head _ len ( buf , length ) ;
byte [ ] hash = gen _ onetime _ auth _ hash ( buf , head _ len ) ;
byte [ ] hash = gen _ onetime _ auth _ hash ( buf , length ) ;
react _ buffer _ tcp ( buf , ref length ) ;
react _ buffer _ udp ( buf , ref length ) ; } }
react _ buffer ( buf , ref length ) ;
namespace shadowsocks _ csharp _ properties {
internal static global :: system . resources . resource _ manager resource _ manager { get { if ( ( resource _ man = = null ) ) {
private void config _ form _ key _ down ( object sender , key _ event _ args e ) {  if ( e . key _ code = = keys . enter ) { server server = controller . get _ current _ server ( ) ; if ( ! validate _ and _ save _ selected _ server _ details ( ) ) { return ; } if ( modified _ configuration . configs . count = = 0 ) { message _ box . show ( n . get _ string ( STR ) ) ; return ; } int local _ port = int . parse ( proxy _ port _ text _ box . text ) ; configuration . check _ local _ port ( local _ port ) ; modified _ configuration . local _ port = local _ port ; modified _ configuration . portable _ mode = portable _ mode _ check _ box . checked ; controller . save _ servers ( modified _ configuration . configs , modified _ configuration . local _ port , modified _ configuration . portable _ mode ) ; controller . select _ server _ index ( modified _ configuration . configs . index _ of ( server ) ) ; } } private void servers _ list _ box _ selected _ index _ changed ( object sender , event _ args e ) { if ( ! servers _ list _ box . can _ select ) { return ; } if ( last _ selected _ index = = servers _ list _ box . selected _ index ) {  return ; } if ( ! validate _ and _ save _ selected _ server _ details ( ) ) {  servers _ list _ box . selected _ index = last _ selected _ index ; return ; } if ( last _ selected _ index > = 0 ) { servers _ list _ box . items [ last _ selected _ index ] = modified _ configuration . configs [ last _ selected _ index ] . friendly _ name ( ) ; } update _ buttons ( ) ; load _ selected _ server _ details ( ) ; last _ selected _ index = servers _ list _ box . selected _ index ; } private void add _ button _ click ( object sender , event _ args e ) { if ( ! validate _ and _ save _ selected _ server _ details ( ) ) { return ; } server server = configuration . get _ default _ server ( ) ; modified _ configuration . configs . add ( server ) ; load _ server _ name _ list _ to _ ui ( modified _ configuration ) ; servers _ list _ box . selected _ index = modified _ configuration . configs . count - 1 ; last _ selected _ index = servers _ list _ box . selected _ index ; } private void duplicate _ button _ click ( object sender , event _ args e ) { if ( ! validate _ and _ save _ selected _ server _ details ( ) ) { return ; } server curr _ server = modified _ configuration . configs [ last _ selected _ index ] ; var curr _ index = modified _ configuration . configs . index _ of ( curr _ server ) ; modified _ configuration . configs . insert ( curr _ index + 1 , curr _ server ) ; load _ server _ name _ list _ to _ ui ( modified _ configuration ) ; servers _ list _ box . selected _ index = curr _ index + 1 ; last _ selected _ index = servers _ list _ box . selected _ index ; } private void delete _ button _ click ( object sender , event _ args e ) { last _ selected _ index = servers _ list _ box . selected _ index ; if ( last _ selected _ index > = 0 & & last _ selected _ index < modified _ configuration . configs . count ) { modified _ configuration . configs . remove _ at ( last _ selected _ index ) ; } if ( last _ selected _ index > = modified _ configuration . configs . count ) {  last _ selected _ index = modified _ configuration . configs . count - 1 ; } servers _ list _ box . selected _ index = last _ selected _ index ; load _ server _ name _ list _ to _ ui ( modified _ configuration ) ; servers _ list _ box . selected _ index = last _ selected _ index ; load _ selected _ server _ details ( ) ; } private void ok _ button _ click ( object sender , event _ args e ) { if ( ! validate _ and _ save _ selected _ server _ details ( ) ) { return ;
return ;
this . close ( ) ;
this . apply _ button . dock = system . windows . forms . dock _ style . right ;
config . bandwidth _ in = inbound _ counter ;
config . bandwidth _ out = outbound _ counter ;
inbound _ counter = config . bandwidth _ in ; outbound _ counter = config . bandwidth _ out ;
this . cancel _ button = new system . windows . forms . button ( ) ;
( ( system . component _ model . i _ support _ initialize ) ( this . binding _ configuration ) ) . begin _ init ( ) ;
this . cancel _ button . location = new system . drawing . point ( NUM , NUM ) ; this . cancel _ button . name = STR ; this . cancel _ button . size = new system . drawing . size ( NUM , NUM ) ; this . cancel _ button . tab _ index = NUM ; this . cancel _ button . text = STR ; this . cancel _ button . use _ visual _ style _ back _ color = true ; this . cancel _ button . click + = new system . event _ handler ( this . cancel _ button _ click ) ;
configuration = controller . get _ configuration _ copy ( ) ? . statistics _ strategy _ configuration
using system _ text _ regular _ expressions ;
private static string pac _ file = STR ;
public event event _ handler update _ pac _ from _ gfw _ list _ completed ; public event error _ event _ handler update _ pac _ from _ gfw _ list _ error ;
public i _ web _ proxy proxy = null ; public class gfw _ list _ download _ completed _ args : event _ args { public string content ; } public event event _ handler < gfw _ list _ download _ completed _ args > download _ completed ;
public void download ( ) { web _ client http = new web _ client ( ) ; http . proxy = proxy ; http . download _ string _ completed + = http _ download _ string _ completed ; http . download _ string _ async ( new uri ( gfwlist _ url ) ) ; } protected void report _ error ( exception e ) { if ( error ! = null ) { error ( this , new error _ event _ args ( e ) ) ; } }
string response = e . result ; if ( download _ completed ! = null )
download _ completed ( this , new gfw _ list _ download _ completed _ args { content = response } ) ;
report _ error ( ex ) ;
public class parser
private string content ; public string content
get { return content ; }
public parser ( string response ) { byte [ ] bytes = convert . from _ base _ string ( response ) ; this . content = encoding . ascii . get _ string ( bytes ) ; } public string [ ] get _ valid _ lines ( ) { string [ ] lines = content . split ( new char [ ] { '\r' , '\n' } , string _ split _ options . remove _ empty _ entries ) ; list < string > valid _ lines = new list < string > ( lines . length ) ; foreach ( string line in lines ) { if ( line . starts _ with ( STR ) | | line . starts _ with ( STR ) ) continue ; valid _ lines . add ( line ) ; } return valid _ lines . to _ array ( ) ; }
private void pac _ server _ update _ pac _ from _ gfw _ list _ error ( object sender , error _ event _ args e )
public class util
temppath = path . get _ temp _ path ( ) ;
} return true ;
if ( STR . equals ( encoding ) ) {  return is _ only _ double _ byte _ kanji ( content ) ? mode . kanji : mode . byte ; } bool has _ numeric = false ; bool has _ alphanumeric = false ; for ( int i = 0 ; i < content . length ; + + i ) { char c = content [ i ] ; if ( c > = '0' & & c < = '9' ) { has _ numeric = true ; } else if ( get _ alphanumeric _ code ( c ) ! = - 1 ) { has _ alphanumeric = true ; } else { return mode . byte ; } } if ( has _ alphanumeric ) { return mode . alphanumeric ; } if ( has _ numeric ) { return mode . numeric ; }
} private static bool is _ only _ double _ byte _ kanji ( string content ) { byte [ ] bytes ; try { bytes = encoding . get _ encoding ( STR ) . get _ bytes ( content ) ; } catch ( exception ) { return false ; } int length = bytes . length ; if ( length % 2 ! = 0 ) { return false ; } for ( int i = 0 ; i < length ; i + = 2 ) { int byte = bytes [ i ] & 0 xff ; if ( ( byte < 0 | | byte > 0 f ) & & ( byte < 0 x | | byte > 0 xeb ) ) { return false ; } } return true ;
if ( mode . equals ( mode . numeric ) ) append _ numeric _ bytes ( content , bits ) ; else if ( mode . equals ( mode . alphanumeric ) ) append _ alphanumeric _ bytes ( content , bits ) ;
if ( mode . equals ( mode . byte ) ) append _ bit _ bytes ( content , bits , encoding ) ; else if ( mode . equals ( mode . kanji ) ) append _ kanji _ bytes ( content , bits ) ; else throw new writer _ exception ( STR + mode ) ;
public int get _ next _ set ( int from ) { if ( from > = size ) { return size ; } int bits _ offset = from > > NUM ; int current _ bits = bits [ bits _ offset ] ;  current _ bits & = ~ ( ( 1 < < ( from & 0 f ) ) - 1 ) ; while ( current _ bits = = 0 ) { if ( + + bits _ offset = = bits . length ) { return size ; } current _ bits = bits [ bits _ offset ] ; } int result = ( bits _ offset < < NUM ) + number _ of _ trailing _ zeros ( current _ bits ) ; return result > size ? size : result ; }      public int get _ next _ unset ( int from ) { if ( from > = size ) { return size ; } int bits _ offset = from > > NUM ; int current _ bits = ~ bits [ bits _ offset ] ;  current _ bits & = ~ ( ( 1 < < ( from & 0 f ) ) - 1 ) ; while ( current _ bits = = 0 ) { if ( + + bits _ offset = = bits . length ) { return size ; } current _ bits = ~ bits [ bits _ offset ] ; } int result = ( bits _ offset < < NUM ) + number _ of _ trailing _ zeros ( current _ bits ) ; return result > size ? size : result ; }
public void set _ range ( int start , int end ) { if ( end < start ) { throw new argument _ exception ( ) ; } if ( end = = start ) { return ; } end - - ; int first _ int = start > > NUM ; int last _ int = end > > NUM ; for ( int i = first _ int ; i < = last _ int ; i + + ) { int first _ bit = i > first _ int ? 0 : start & 0 f ; int last _ bit = i < last _ int ? NUM : end & 0 f ; int mask ; if ( first _ bit = = 0 & & last _ bit = = NUM ) { mask = - 1 ; } else { mask = 0 ; for ( int j = first _ bit ; j < = last _ bit ; j + + ) { mask | = 1 < < j ; } } bits [ i ] | = mask ; } }
}             public bool is _ range ( int start , int end , bool value ) { if ( end < start ) { throw new system . argument _ exception ( ) ; } if ( end = = start ) { return true ; } end - - ; int first _ int = start > > NUM ; int last _ int = end > > NUM ; for ( int i = first _ int ; i < = last _ int ; i + + ) { int first _ bit = i > first _ int ? 0 : start & 0 f ; int last _ bit = i < last _ int ? NUM : end & 0 f ; int mask ; if ( first _ bit = = 0 & & last _ bit = = NUM ) { mask = - 1 ; } else { mask = 0 ; for ( int j = first _ bit ; j < = last _ bit ; j + + ) { mask | = 1 < < j ; } }   if ( ( bits [ i ] & mask ) ! = ( value ? mask : 0 ) ) { return false ; } } return true ;
using system _ threading ;
private void evaluate ( object obj )
var state = ( state ) obj ; foreach ( var server in servers )
logging . debug ( STR + server . friendly _ name ( ) ) ; foreach ( var in enumerable . range ( 0 , repeat ) )
var timestamp = date _ time . now . to _ string ( STR ) ;   var reply = ping . send ( server . server , timeout ) ; state . data = new list < key _ value _ pair < string , string > > { new key _ value _ pair < string , string > ( STR , timestamp ) , new key _ value _ pair < string , string > ( STR , server . friendly _ name ( ) ) , new key _ value _ pair < string , string > ( STR , reply ? . status . to _ string ( ) ) , new key _ value _ pair < string , string > ( STR , reply ? . roundtrip _ time . to _ string ( ) ) } ;  append ( state . data ) ;
private static void append ( list < key _ value _ pair < string , string > > data )
public static asset parse _ asset ( j _ object aj _ object ) { var name = ( string ) aj _ object [ STR ] ;
browser _ download _ url = ( string ) aj _ object [ STR ] ,
struct traffic _ info { public long inbound ; public long outbound ; public traffic _ info ( long inbound , long outbound ) { this . inbound = inbound ; this . outbound = outbound ; } }
long last _ max _ speed ; shadowsocks _ controller . queue _ last < traffic _ info > traffic = new shadowsocks _ controller . queue _ last < traffic _ info > ( ) ;
private void update _ traffic _ chart ( ) { list < float > inbound _ points = new list < float > ( ) ; list < float > outbound _ points = new list < float > ( ) ; text _ annotation inbound _ annotation = new text _ annotation ( ) ; text _ annotation outbound _ annotation = new text _ annotation ( ) ; bandwidth _ scale _ info bandwidth _ scale ; const long min _ scale = NUM ; long max _ speed = 0 ; long last _ inbound , last _ outbound ;
if ( traffic . count = = 0 )
foreach ( var traffic _ per _ second in traffic ) { inbound _ points . add ( traffic _ per _ second . inbound ) ; outbound _ points . add ( traffic _ per _ second . outbound ) ; max _ speed = math . max ( max _ speed , math . max ( traffic _ per _ second . inbound , traffic _ per _ second . outbound ) ) ; } last _ inbound = traffic . last ( ) . inbound ; last _ outbound = traffic . last ( ) . outbound ;
public queue _ last < traffic _ per _ second > traffic ;
} public class queue _ last < t > : queue < t > { public t last { get ; private set ; } public new void enqueue ( t item ) { last = item ; base . enqueue ( item ) ; }
traffic = new queue _ last < traffic _ per _ second > ( ) ;
traffic . enqueue ( new traffic _ per _ second ( ) ) ;
traffic _ per _ second previous = traffic . last ; traffic _ per _ second current = new traffic _ per _ second ( ) ; var inbound = current . inbound _ counter = inbound _ counter ; var outbound = current . outbound _ counter = outbound _ counter ; current . inbound _ increasement = inbound - previous . inbound _ counter ; current . outbound _ increasement = outbound - previous . outbound _ counter ; traffic . enqueue ( current ) ; if ( traffic . count > queue _ max _ size ) traffic . dequeue ( ) ;
public tcp _ relay relay ;
public const int recv _ size = NUM ; public const int recv _ reserve _ size = iv _ encryptor . onetimeauth _ bytes + iv _ encryptor . auth _ bytes ; public const int buffer _ size = recv _ size + recv _ reserve _ size + NUM ; private int total _ read = 0 ; private int total _ write = 0 ;  private byte [ ] remote _ recv _ buffer = new byte [ buffer _ size ] ;  private byte [ ] remote _ send _ buffer = new byte [ buffer _ size ] ;  private byte [ ] connetion _ recv _ buffer = new byte [ buffer _ size ] ;  private byte [ ] connetion _ send _ buffer = new byte [ buffer _ size ] ;  private bool connection _ shutdown = false ; private bool remote _ shutdown = false ; private bool closed = false ; private object encryption _ lock = new object ( ) ; private object decryption _ lock = new object ( ) ;
show _ toolbar _ trigger = ! show _ toolbar _ trigger ; toolbar _ flow _ layout _ panel . visible = show _ toolbar _ trigger ; show _ toolbar _ menu _ item . checked = show _ toolbar _ trigger ;
public const int buffer _ size = NUM ;
public byte [ ] remote _ buffer = new byte [ buffer _ size ] ;
public byte [ ] connetion _ buffer = new byte [ buffer _ size ] ;
remote . begin _ receive ( remote _ buffer , 0 , buffer _ size , 0 ,
connection . begin _ receive ( connetion _ buffer , 0 , buffer _ size , 0 ,
public override byte [ ] encrypt ( byte [ ] buf , int length )
byte [ ] iv = new byte [ iv _ len ] ; open _ ssl . rand _ bytes ( iv , iv . length ) ; init _ cipher ( ref encrypt _ ctx , iv , true ) ; int out _ len = length + iv _ len ; byte [ ] cipher _ text = new byte [ out _ len ] ; open _ ssl . evp _ cipher _ update ( encrypt _ ctx , cipher _ text , out out _ len , buf , length ) ; byte [ ] result = new byte [ out _ len + iv _ len ] ; buffer . block _ copy ( iv , 0 , result , 0 , iv _ len ) ; buffer . block _ copy ( cipher _ text , 0 , result , iv _ len , out _ len ) ; return result ;
int out _ len = length + iv _ len ; byte [ ] cipher _ text = new byte [ out _ len ] ; open _ ssl . evp _ cipher _ update ( encrypt _ ctx , cipher _ text , out out _ len , buf , length ) ; byte [ ] result = new byte [ out _ len ] ; buffer . block _ copy ( cipher _ text , 0 , result , 0 , out _ len ) ; return result ;
public override byte [ ] decrypt ( byte [ ] buf , int length )
byte [ ] iv = new byte [ iv _ len ] ; buffer . block _ copy ( buf , 0 , iv , 0 , iv _ len ) ; init _ cipher ( ref decrypt _ ctx , iv , false ) ; int out _ len = length + iv _ len ; out _ len - = iv _ len ; byte [ ] cipher _ text = new byte [ out _ len ] ; byte [ ] subset = new byte [ length - iv _ len ] ; buffer . block _ copy ( buf , iv _ len , subset , 0 , length - iv _ len ) ; open _ ssl . evp _ cipher _ update ( decrypt _ ctx , cipher _ text , out out _ len , subset , length - iv _ len ) ; byte [ ] result = new byte [ out _ len ] ; buffer . block _ copy ( cipher _ text , 0 , result , 0 , out _ len ) ; return result ;
int out _ len = length + iv _ len ; byte [ ] cipher _ text = new byte [ out _ len ] ; open _ ssl . evp _ cipher _ update ( decrypt _ ctx , cipher _ text , out out _ len , buf , length ) ; byte [ ] result = new byte [ out _ len ] ; buffer . block _ copy ( cipher _ text , 0 , result , 0 , out _ len ) ; return result ;
public interface i _ encryptor
byte [ ] encrypt ( byte [ ] buf , int length ) ; byte [ ] decrypt ( byte [ ] buf , int length ) ;
public override byte [ ] encrypt ( byte [ ] buf , int length )
result [ i ] = encrypt _ table [ buf [ i ] ] ;
return result ;
public override byte [ ] decrypt ( byte [ ] buf , int length )
result [ i ] = decrypt _ table [ buf [ i ] ] ;
return result ;
class auto _ startup
static string key = STR + application . startup _ path . get _ hash _ code ( ) ;
string path = application . executable _ path ;
run _ key . set _ value ( key , path ) ;
run _ key . set _ value ( key , path ) ;
public i _ encryptor encryptor ; public server server ;
public socket connection ; public shadowsocks _ controller controller ; public tcp _ relay tcprelay ; public date _ time last _ activity ; private const int max _ retry = NUM ; private int retry _ count = 0 ; private bool proxy _ connected ; private bool dest _ connected ; private byte command ; private byte [ ] first _ packet ; private int first _ packet _ length ; private int total _ read = 0 ; private int total _ write = 0 ; private byte [ ] remote _ recv _ buffer = new byte [ buffer _ size ] ; private byte [ ] remote _ send _ buffer = new byte [ buffer _ size ] ; private byte [ ] connetion _ recv _ buffer = new byte [ buffer _ size ] ; private byte [ ] connetion _ send _ buffer = new byte [ buffer _ size ] ; private bool connection _ shutdown = false ; private bool remote _ shutdown = false ; private bool closed = false ; private object encryption _ lock = new object ( ) ; private object decryption _ lock = new object ( ) ;
private int bytes _ to _ send ; private tcp _ relay tcprelay ; private configuration config ; public tcp _ handler ( tcp _ relay tcprelay , configuration config ) {
this . config = config ;
lock ( tcprelay . handlers ) { tcprelay . handlers . remove ( this ) ; } lock ( this ) {
try { connection ? . shutdown ( socket _ shutdown . both ) ; connection ? . close ( ) ;
throw new exception ( ) ;
throw new exception ( ) ;
throw new exception ( ) ;
? resources . zh _ tw : resources . cn ) ;
init ( resources . jp ) ;
private configuration config ;
public udp _ relay ( configuration config )
this . config = config ;
+ STR + config . get _ current _ server ( ) . friendly _ name ( ) ;
enable _ item . checked = controller . get _ configuration ( ) . enabled ;
share _ over _ lan _ item . checked = controller . get _ configuration ( ) . share _ over _ lan ;
global _ mode _ item . checked = controller . get _ configuration ( ) . global ;
configuration configuration = controller . get _ configuration ( ) ; for ( int i = 0 ; i < configuration . configs . count ; i + + ) { server server = configuration . configs [ i ] ;
} if ( configuration . index > = 0 & & configuration . index < configuration . configs . count ) { items [ configuration . index ] . checked = true ;
private configuration config ; public tcp _ relay ( configuration config ) { this . config = config ;
public configuration get _ configuration ( )
if ( config . index < 0 )
config . index = 0 ;
private void start _ connect ( i _ async _ result ar )
controller ? . stop ( ) ;
controller ? . start ( ) ;
string parts = server . method ; if ( server . auth ) parts + = STR ; parts + = STR + server . password + STR + server . server + STR + server . server _ port ;
return STR + base ;
var tag = match . groups [ 2 ] . value ;
remarks = tag . substring ( 1 ) . trim ( ) ;
logging . debug ( remote . local _ end _ point , remote . dest _ end _ point , recv _ size , STR ) ;
logging . debug ( remote . local _ end _ point , remote . dest _ end _ point , recv _ size , STR ) ;
if ( bytes _ read > 0 )
if ( encrypt _ ctx ! = int _ ptr . zero )
if ( decrypt _ ctx ! = int _ ptr . zero )
def _ connection [ NUM ] = ( byte ) ( def _ connection [ NUM ] | NUM ) ; saved _ legacy _ setting [ NUM ] = ( byte ) ( saved _ legacy _ setting [ NUM ] | NUM ) ;
def _ connection [ NUM ] = ( byte ) ( def _ connection [ NUM ] & ~ NUM ) ; saved _ legacy _ setting [ NUM ] = ( byte ) ( saved _ legacy _ setting [ NUM ] & ~ NUM ) ;
bit _ converter . get _ bytes ( unchecked ( bit _ converter . to _ u _ int ( def _ connection , NUM ) + 1 ) ) . copy _ to ( def _ connection , NUM ) ; bit _ converter . get _ bytes ( unchecked ( bit _ converter . to _ u _ int ( saved _ legacy _ setting , NUM ) + 1 ) ) . copy _ to ( saved _ legacy _ setting , NUM ) ;
using data _ unit = key _ value _ pair < string , string > ; using data _ list = list < key _ value _ pair < string , string > > ; using statistics = dictionary < string , list < availability _ statistics . raw _ statistics _ data > > ;
private availability _ statistics ( ) { } public const string date _ time _ pattern = STR ; private const string statistics _ files _ name = STR ; private const string delimiter = STR ; private const int timeout _ milliseconds = NUM ; private readonly time _ span delay _ before _ start = time _ span . from _ seconds ( 1 ) ;
public static readonly date _ time unknown _ date _ time = new date _ time ( NUM , 1 , 1 ) ;
private readonly time _ span retry _ interval = time _ span . from _ minutes ( 2 ) ; private time _ span interval = > time _ span . from _ minutes ( config . data _ collection _ minutes ) ; private timer timer ; private timer speed _ monior ; private state state ; private list < server > servers ; private statistics _ strategy _ configuration config ; private const string empty = STR ; public static string availability _ statistics _ file ;  private int inbound _ speed = 0 ; private int outbound _ speed = 0 ; private int? latency = 0 ; private server current _ server ; private configuration global _ config ; private shadowsocks _ controller controller ; private long last _ inbound _ counter = 0 ; private long last _ outbound _ counter = 0 ; private readonly time _ span monitor _ interval = time _ span . from _ seconds ( 1 ) ;  static availability _ statistics ( ) { availability _ statistics _ file = utils . get _ temp _ path ( statistics _ files _ name ) ; }
if ( timer ? . change ( delay _ before _ start , interval ) = = null ) { state = new state ( ) ; timer = new timer ( run , state , delay _ before _ start , interval ) ;
timer ? . dispose ( ) ;
var inbound _ speed = get _ speed _ in _ ki _ b _ per _ second ( bytes , monitor _ interval . total _ seconds ) ;
if ( inbound _ speed > inbound _ speed ) { inbound _ speed = inbound _ speed ; } if ( outbound _ speed > outbound _ speed ) { outbound _ speed = outbound _ speed ; } logging . debug ( $ STR ) ; } private async task < list < data _ list > > icmp _ test ( server server )
var ret = new list < data _ list > ( ) ; try { var ip = dns . get _ host _ addresses ( server . server ) . first ( ip = > ( ip . address _ family = = address _ family . inter _ network | | ip . address _ family = = address _ family . inter _ network ) ) ;
foreach ( var timestamp in enumerable . range ( 0 , repeat ) . select ( = > date _ time . now . to _ string ( date _ time _ pattern ) ) ) {
ret . add ( new list < key _ value _ pair < string , string > > { new key _ value _ pair < string , string > ( STR , timestamp ) , new key _ value _ pair < string , string > ( STR , server . friendly _ name ( ) ) , new key _ value _ pair < string , string > ( STR , reply ? . status . to _ string ( ) ) , new key _ value _ pair < string , string > ( STR , reply ? . roundtrip _ time . to _ string ( ) ) , new key _ value _ pair < string , string > ( STR , get _ recent _ latency ( server ) ) , new key _ value _ pair < string , string > ( STR , get _ recent _ inbound _ speed ( server ) ) , new key _ value _ pair < string , string > ( STR , get _ recent _ outbound _ speed ( server ) )  } ) ; thread . sleep ( timeout _ milliseconds + new random ( ) . next ( ) % timeout _ milliseconds ) ;
return ret ; } private string get _ recent _ outbound _ speed ( server server ) { return server ! = current _ server ? empty : outbound _ speed . to _ string ( ) ; } private string get _ recent _ inbound _ speed ( server server ) { return server ! = current _ server ? empty : inbound _ speed . to _ string ( ) ; } private string get _ recent _ latency ( server server ) { if ( server ! = current _ server ) return empty ; return latency = = null ? empty : latency . to _ string ( ) ; } private void reset _ speed ( ) { current _ server = controller . get _ current _ server ( ) ; latency = null ; inbound _ speed = 0 ; outbound _ speed = 0 ; } private void run ( object obj ) { if ( speed _ monior ? . change ( delay _ before _ start , monitor _ interval ) = = null ) { speed _ monior = new timer ( update _ speed , null , delay _ before _ start , monitor _ interval ) ; } load _ raw _ statistics ( ) ;
evaluate ( ) ; reset _ speed ( ) ; } private async void evaluate ( ) { foreach ( var data _ lists in await task _ ex . when _ all ( servers . select ( icmp _ test ) ) ) { if ( data _ lists = = null ) continue ; foreach ( var data _ list in data _ lists . where ( data _ list = > data _ list ! = null ) ) { append ( data _ list , enumerable . empty < data _ unit > ( ) ) ; }  } }
reset _ speed ( ) ;
foreach ( i _ enumerable < raw _ statistics _ data > raw _ data in raw _ statistics . values ) { var filtered _ data = raw _ data ; if ( config . by _ hour _ of _ day ) { var current _ hour = date _ time . now . hour ; filtered _ data = filtered _ data . where ( data = > data . timestamp ! = unknown _ date _ time & & data . timestamp . hour . equals ( current _ hour ) ) ; if ( filtered _ data . long _ count ( ) = = 0 ) return ; } var data _ list = filtered _ data as list < raw _ statistics _ data > ? ? filtered _ data . to _ list ( ) ; var server _ name = data _ list [ 0 ] . server _ name ; filtered _ statistics [ server _ name ] = data _ list ;
if ( ! file . exists ( path ) ) { console . write _ line ( $ STR ) ; timer . change ( retry _ interval , interval ) ;
raw _ statistics = ( from l in file . read _ all _ lines ( path ) . skip ( 1 ) let strings = l . split ( new [ ] { STR } , string _ split _ options . remove _ empty _ entries ) let raw _ data = new raw _ statistics _ data { timestamp = parse _ exact _ or _ unknown ( strings [ 0 ] ) , server _ name = strings [ 1 ] , icmp _ status = strings [ 2 ] , roundtrip _ time = int . parse ( strings [ NUM ] ) } group raw _ data by raw _ data . server _ name into server select new { server _ name = server . key , data = server . to _ list ( ) } ) . to _ dictionary ( server = > server . server _ name , server = > server . data ) ;
return ! date _ time . try _ parse _ exact ( str , date _ time _ pattern , null , date _ time _ styles . none , out date _ time ) ? unknown _ date _ time : date _ time ; } public class state { public data _ list data _ list = new data _ list ( ) ; public const string unknown = STR ; }  public class raw _ statistics _ data { public date _ time timestamp ; public string server _ name ; public string icmp _ status ; public int roundtrip _ time ; } public class statistics _ data { public float package _ loss ; public int average _ response ; public int min _ response ; public int max _ response ;
latency = latency ;
list < availability _ statistics . raw _ statistics _ data > statistics ;
i _ enumerable < i _ grouping < int , availability _ statistics . raw _ statistics _ data > > data _ groups ;
private dictionary < string , list < availability _ statistics . raw _ statistics _ data > > filtered _ statistics ;
filtered _ statistics = controller . availability _ statistics . raw _ statistics ? ? filtered _ statistics ? ? new dictionary < string , list < availability _ statistics . raw _ statistics _ data > > ( ) ;
list < availability _ statistics . raw _ statistics _ data > data _ list ; if ( filtered _ statistics = = null | | ! filtered _ statistics . try _ get _ value ( server _ name , out data _ list ) ) return 0 ; var success _ times = ( float ) data _ list . count ( data = > data . icmp _ status . equals ( ip _ status . success . to _ string ( ) ) ) ; var timed _ out _ times = ( float ) data _ list . count ( data = > data . icmp _ status . equals ( ip _ status . timed _ out . to _ string ( ) ) ) ; var statistics _ data = new availability _ statistics . statistics _ data { package _ loss = timed _ out _ times / ( success _ times + timed _ out _ times ) * NUM , average _ response = convert . to _ int ( data _ list . average ( data = > data . roundtrip _ time ) ) , min _ response = data _ list . min ( data = > data . roundtrip _ time ) , max _ response = data _ list . max ( data = > data . roundtrip _ time ) } ;
score + = statistics _ data . package _ loss * factor ;
score + = statistics _ data . average _ response * factor ;
score + = statistics _ data . min _ response * factor ;
score + = statistics _ data . max _ response * factor ; logging . debug ( $ STR ) ;
this . qr _ code _ item = new system . windows . forms . menu _ item ( ) ;
this . table _ layout _ panel . location = new system . drawing . point ( NUM , NUM ) ; this . table _ layout _ panel . margin = new system . windows . forms . padding ( NUM ) ;
this . table _ layout _ panel . padding = new system . windows . forms . padding ( NUM ) ;
this . remarks _ text _ box . location = new system . drawing . point ( NUM , NUM ) ;
this . label . location = new system . drawing . point ( NUM , NUM ) ;
this . label . location = new system . drawing . point ( NUM , NUM ) ;
this . label . location = new system . drawing . point ( NUM , NUM ) ;
this . proxy _ port _ text _ box . location = new system . drawing . point ( NUM , NUM ) ;
this . label . location = new system . drawing . point ( NUM , NUM ) ;
this . label . location = new system . drawing . point ( NUM , NUM ) ;
this . ip _ text _ box . location = new system . drawing . point ( NUM , NUM ) ;
this . server _ port _ text _ box . location = new system . drawing . point ( NUM , NUM ) ;
this . password _ text _ box . location = new system . drawing . point ( NUM , NUM ) ;
this . label . location = new system . drawing . point ( NUM , NUM ) ;
this . encryption _ select . location = new system . drawing . point ( NUM , NUM ) ;
this . notify _ icon . icon = ( ( system . drawing . icon ) ( resources . get _ object ( STR ) ) ) ;
this . notify _ icon . visible = true ;
this . panel . location = new system . drawing . point ( NUM , NUM ) ;
this . ok _ button . location = new system . drawing . point ( NUM , NUM ) ;
this . my _ cancel _ button . location = new system . drawing . point ( NUM , NUM ) ;
this . delete _ button . location = new system . drawing . point ( NUM , NUM ) ;
this . add _ button . location = new system . drawing . point ( NUM , NUM ) ;
this . server _ group _ box . location = new system . drawing . point ( NUM , NUM ) ;
this . server _ group _ box . size = new system . drawing . size ( NUM , NUM ) ;
this . servers _ list _ box . location = new system . drawing . point ( NUM , NUM ) ;
if ( file . exists ( pac _ file ) )
return file . read _ all _ text ( pac _ file , encoding . ut ) ;
else { return resources . default _ abp _ rule + resources . abp _ js ; }
handler . receive ( ) ;
update _ index _ to _ end ( ) ;
update _ index _ to _ end ( ) ;
configuration . add _ default _ server _ or _ server ( modified _ configuration , curr _ server ) ;
update _ index _ to _ end ( ) ;
int index = servers _ list _ box . selected _ index ; server server = modified _ configuration . configs [ index ] ; object item = servers _ list _ box . items [ index ] ; modified _ configuration . configs . remove ( server ) ; modified _ configuration . configs . insert ( index + step , server ) ; modified _ configuration . index + = step ;
servers _ list _ box . enabled = false ; last _ selected _ index = index + step ; servers _ list _ box . items . remove ( item ) ; servers _ list _ box . items . insert ( index + step , item ) ; servers _ list _ box . enabled = true ; servers _ list _ box . selected _ index = index + step ;
byte [ ] realkey ; if ( method = = STR ) { byte [ ] temp = new byte [ key _ len + iv _ len ] ; realkey = new byte [ key _ len ] ; array . copy ( key , 0 , temp , 0 , key _ len ) ; array . copy ( iv , 0 , temp , key _ len , iv _ len ) ; realkey = m . create ( ) . compute _ hash ( temp ) ; } else { realkey = key ; } if ( cipher = = cipher _ aes ) { polar _ ssl . aes _ init ( ctx ) ;   polar _ ssl . aes _ setkey _ enc ( ctx , realkey , key _ len * NUM ) ; if ( is _ cipher ) { encrypt _ iv = new byte [ iv _ len ] ; array . copy ( iv , encrypt _ iv , iv _ len ) ;
decrypt _ iv = new byte [ iv _ len ] ; array . copy ( iv , decrypt _ iv , iv _ len ) ; } } else if ( cipher = = cipher _ bf ) { polar _ ssl . blowfish _ init ( ctx ) ;  polar _ ssl . blowfish _ setkey ( ctx , realkey , key _ len * NUM ) ; if ( is _ cipher ) { encrypt _ iv = new byte [ iv _ len ] ; array . copy ( iv , encrypt _ iv , iv _ len ) ; } else { decrypt _ iv = new byte [ iv _ len ] ; array . copy ( iv , decrypt _ iv , iv _ len ) ; } } else if ( cipher = = cipher _ r ) { polar _ ssl . arc _ init ( ctx ) ; polar _ ssl . arc _ setup ( ctx , realkey , key _ len ) ;
polar _ ssl . aes _ crypt _ cfb ( encrypt _ ctx , polar _ ssl . aes _ encrypt , length , ref encrypt _ iv _ offset , encrypt _ iv , buf , tempbuf ) ;
polar _ ssl . blowfish _ crypt _ cfb ( encrypt _ ctx , polar _ ssl . blowfish _ encrypt , length , ref encrypt _ iv _ offset , encrypt _ iv , buf , tempbuf ) ;
polar _ ssl . arc _ crypt ( encrypt _ ctx , length , buf , tempbuf ) ; break ; } outlength = length + iv _ len ; buffer . block _ copy ( tempbuf , 0 , outbuf , iv _ len , outlength ) ; } } else { outlength = length ; switch ( cipher ) { case cipher _ aes : polar _ ssl . aes _ crypt _ cfb ( encrypt _ ctx , polar _ ssl . aes _ encrypt , length , ref encrypt _ iv _ offset , encrypt _ iv , buf , outbuf ) ; break ; case cipher _ bf : polar _ ssl . blowfish _ crypt _ cfb ( encrypt _ ctx , polar _ ssl . blowfish _ encrypt , length , ref encrypt _ iv _ offset , encrypt _ iv , buf , outbuf ) ; break ; case cipher _ r : polar _ ssl . arc _ crypt ( encrypt _ ctx , length , buf , outbuf ) ; break ;
polar _ ssl . aes _ crypt _ cfb ( decrypt _ ctx , polar _ ssl . aes _ decrypt , length - iv _ len , ref decrypt _ iv _ offset , decrypt _ iv , tempbuf , outbuf ) ;
polar _ ssl . blowfish _ crypt _ cfb ( decrypt _ ctx , polar _ ssl . blowfish _ decrypt , length - iv _ len , ref decrypt _ iv _ offset , decrypt _ iv , tempbuf , outbuf ) ;
polar _ ssl . arc _ crypt ( decrypt _ ctx , length - iv _ len , tempbuf , outbuf ) ; break ; } } } else { outlength = length ; switch ( cipher ) { case cipher _ aes : polar _ ssl . aes _ crypt _ cfb ( decrypt _ ctx , polar _ ssl . aes _ decrypt , length , ref decrypt _ iv _ offset , decrypt _ iv , buf , outbuf ) ; break ; case cipher _ bf : polar _ ssl . blowfish _ crypt _ cfb ( decrypt _ ctx , polar _ ssl . blowfish _ decrypt , length , ref decrypt _ iv _ offset , decrypt _ iv , buf , outbuf ) ; break ; case cipher _ r : polar _ ssl . arc _ crypt ( decrypt _ ctx , length , buf , outbuf ) ; break ;
if ( ! disposed ) { if ( disposing ) {  }
switch ( cipher ) { case cipher _ aes : polar _ ssl . aes _ free ( encrypt _ ctx ) ; break ; case cipher _ bf : polar _ ssl . blowfish _ free ( encrypt _ ctx ) ; break ; case cipher _ r : polar _ ssl . arc _ free ( encrypt _ ctx ) ; break ;
switch ( cipher ) { case cipher _ aes : polar _ ssl . aes _ free ( decrypt _ ctx ) ; break ; case cipher _ bf : polar _ ssl . blowfish _ free ( decrypt _ ctx ) ; break ; case cipher _ r : polar _ ssl . arc _ free ( decrypt _ ctx ) ; break ; }  } encrypt _ ctx = null ; decrypt _ ctx = null ; disposed = true ;
string pac _ content = $ STR + pac _ daemon . get _ pac _ content ( ) ;  string response _ head = string . format ( @ STR server : shadowsocks
content - length : { 0 }
using ( var fs = new file _ stream ( path , file _ mode . open , file _ access . read , file _ share . read _ write ) ) using ( var sr = new stream _ reader ( fs , encoding ) )
return sr . read _ to _ end ( ) ;
protected uint encrypt _ bytes _ remaining ; protected uint decrypt _ bytes _ remaining ;
uint bytes _ remaining ;
assembly _ assembly _ title _ shadowsocks _ csharp
assembly _ assembly _ product _ shadowsocks _ csharp
using system ;
{
i _ dictionary < string , string > tld _ dic = get _ tld _ dictionary ( ) ;
if ( ! tld _ dic . contains _ key ( last _ root _ domain ) )
private i _ dictionary < string , string > get _ tld _ dictionary ( )
i _ dictionary < string , string > dic = new dictionary < string , string > ( tlds . length ) ;
if ( ! dic . contains _ key ( tld ) )
} return dic ;
console . write _ line ( STR , current _ server . server . friendly _ name ( ) ) ;
logging . debug ( string . format ( STR , server . friendly _ name ( ) , latency ) ) ;
logging . debug ( string . format ( STR , server . friendly _ name ( ) ) ) ;
logging . debug ( string . format ( STR , server . friendly _ name ( ) ) ) ;
logging . debug ( string . format ( STR , server . friendly _ name ( ) ) ) ;
catch ( exception exception )
console . write _ line ( STR , exception . to _ string ( ) ) ;
console . write _ line ( o ) ;
public shadowsocks _ controller . queue _ last < tuple < long , long > > traffic = new shadowsocks _ controller . queue _ last < tuple < long , long > > ( ) ;
tuple < float , string , long > bandwidth _ scale ;
inbound _ points . add ( traffic _ per _ second . item ) ; outbound _ points . add ( traffic _ per _ second . item ) ; max _ speed = math . max ( max _ speed , math . max ( traffic _ per _ second . item , traffic _ per _ second . item ) ) ; } last _ inbound = traffic . last ( ) . item ; last _ outbound = traffic . last ( ) . item ;
inbound _ points = inbound _ points . select ( p = > p / bandwidth _ scale . item ) . to _ list ( ) ; outbound _ points = outbound _ points . select ( p = > p / bandwidth _ scale . item ) . to _ list ( ) ;
traffic _ chart . chart _ areas [ 0 ] . axis _ y . label _ style . format = STR + bandwidth _ scale . item ; traffic _ chart . chart _ areas [ 0 ] . axis _ y . maximum = bandwidth _ scale . item ;
traffic = new shadowsocks _ controller . queue _ last < tuple < long , long > > ( ) ;
traffic . enqueue ( new tuple < long , long > ( traffic _ per _ second . inbound _ increasement , traffic _ per _ second . outbound _ increasement ) ) ;
return ( bytes / ( double ) k ) . to _ string ( STR ) + STR ; } return bytes . to _ string ( ) ;
public static tuple < float , string , long > get _ bandwidth _ scale ( long n )
using shadowsocks _ forward _ proxy ;
namespace shadowsocks _ forward _ proxy
public class socks _ proxy : i _ forward _ proxy
namespace shadowsocks _ forward _ proxy
public class http _ proxy : i _ forward _ proxy
namespace shadowsocks _ forward _ proxy
public interface i _ forward _ proxy
namespace shadowsocks _ forward _ proxy
public class direct _ connect : i _ forward _ proxy
public event event _ handler new _ version _ found ;
if ( versions . count = = 0 )
return ;
sort _ versions ( versions ) ; latest _ version _ url = versions [ versions . count - 1 ] ; latest _ version _ number = parse _ version _ from _ url ( latest _ version _ url ) ; if ( new _ version _ found ! = null )
new _ version _ found ( this , new event _ args ( ) ) ;
update _ checker . new _ version _ found + = update _ checker _ new _ version _ found ;
update _ checker . check _ update ( controller . get _ configuration _ copy ( ) ) ; if ( controller . get _ configuration _ copy ( ) . is _ default )
using cyotek _ collections _ generic ;
private circular _ buffer < byte > enc _ circular _ buffer = new circular _ buffer < byte > ( tcp _ handler . buffer _ size * 2 , false ) ; private circular _ buffer < byte > dec _ circular _ buffer = new circular _ buffer < byte > ( tcp _ handler . buffer _ size * 2 , false ) ;
close ( ) ;
foreach ( var tb in all _ text _ boxes ) { if ( tb . text . is _ null _ or _ empty ( ) ) { continue ; } if ( ! try _ reg _ hotkey ( tb ) ) { message _ box . show ( n . get _ string ( STR ) ) ; return ; }
close ( ) ;
try _ reg _ hotkey ( tb ) ; }
bool reg _ result = hot _ keys . regist ( hotkey , call _ back ) ;
hot _ keys . un _ regist ( prev _ hot _ key ) ;
modified _ config . switch _ system _ proxy = switch _ system _ proxy _ text _ box . text ; modified _ config . switch _ system _ proxy _ mode = switch _ proxy _ mode _ text _ box . text ; modified _ config . switch _ allow _ lan = switch _ allow _ lan _ text _ box . text ; modified _ config . show _ logs = show _ logs _ text _ box . text ; modified _ config . server _ move _ up = server _ move _ up _ text _ box . text ; modified _ config . server _ move _ down = server _ move _ down _ text _ box . text ; controller . save _ hotkey _ config ( modified _ config ) ;
show _ toolbar _ trigger = ! show _ toolbar _ trigger ; toolbar _ flow _ layout _ panel . visible = show _ toolbar _ trigger ; show _ toolbar _ menu _ item . checked = show _ toolbar _ trigger ;
* if last failure is > NUM min * and ( last write > last read ) and ( now - last read < NUM s ) * choose the lowest latency * /
current _ server = controller . get _ current _ configuration ( ) . configs [ 0 ] ;
using shadowsocks _ controller _ strategy ; using simple _ json ; using newtonsoft _ json ;
public server ( string ss _ url ) : this ( )
var match = url _ finder . match ( ss _ url ) ; if ( ! match . success ) throw new format _ exception ( ) ; var base = match . groups [ 1 ] . value ; var tag = match . groups [ NUM ] . value ; if ( ! tag . is _ null _ or _ empty ( ) )   remarks = http _ utility . url _ decode ( tag , encoding . ut ) ; match = details _ parser . match ( encoding . ut . get _ string ( convert . from _ base _ string ( base . pad _ right ( base . length + ( NUM - base . length % NUM ) % NUM , '=' ) ) ) ) ; method = match . groups [ STR ] . value ; password = match . groups [ STR ] . value ; server = match . groups [ STR ] . value ; server _ port = int . parse ( match . groups [ STR ] . value ) ;
public void encrypt ( byte [ ] buf )
for ( int i = 0 ; i < buf . length ; i + + )
public void decrypt ( byte [ ] buf )
for ( int i = 0 ; i < buf . length ; i + + )
using system _ text ; using shadowsocks _ model ; using system _ io ;
private shadowsocks _ controller controller ;
private timer timer ; private dictionary < string , statistics _ data > statistics ; private static readonly int cached _ interval = NUM * NUM * NUM ;
int random _ index = new random ( ) . next ( ) % servers . count ( ) ;
list < server > servers = controller . get _ current _ configuration ( ) . configs ;
if ( controller . get _ current _ strategy ( ) . id = = id & & current _ server ! = best _ result . server )
console . write _ line ( STR , best _ result . server . friendly _ name ( ) , 1 - best _ result . score ) ;
public string id
get { return STR ; }
public string name { get { return n . get _ string ( STR ) ; } }
if ( old _ server ! = current _ server ) { }
logging . debug ( string . format ( STR , server . friendly _ name ( ) ) ) ;
show _ first _ time _ balloon ( ) ;
logging . error ( e . exception _ object ? . to _ string ( ) ) ;
string error _ msg = $ STR ; logging . error ( error _ msg ) ; message _ box . show ( $ STR unexpected error , shadowsocks will exit . please report to STR , STR , message _ box _ buttons . ok , message _ box _ icon . error ) ; application . exit ( ) ;
registry _ key user _ key = registry _ key . open _ remote _ base _ key ( registry _ hive . current _ user , STR , environment . is _ bit _ operating _ system ? registry _ view . registry : registry _ view . registry ) . open _ sub _ key ( name , writable ) ; return user _ key ;
using system _ windows _ forms ; using microsoft _ win ; using system ; using system _ runtime _ interop _ services ; using system _ io ;
using shadowsocks _ util ;
dll _ import _ wininet _ dll public static extern bool internet _ set _ option ( int _ ptr h _ internet , int dw _ option , int _ ptr lp _ buffer , int dw _ buffer _ length ) ; public const int internet _ option _ settings _ changed = NUM ; public const int internet _ option _ refresh = NUM ; static bool settings _ return , refresh _ return ; public static void notify _ ie ( ) {   settings _ return = internet _ set _ option ( int _ ptr . zero , internet _ option _ settings _ changed , int _ ptr . zero , 0 ) ; refresh _ return = internet _ set _ option ( int _ ptr . zero , internet _ option _ refresh , int _ ptr . zero , 0 ) ; } private static readonly date _ time unix _ epoch = new date _ time ( NUM , 1 , 1 , 0 , 0 , 0 , date _ time _ kind . utc ) ; public static long to _ unix _ epoch _ milliseconds ( this date _ time dt ) = > ( long ) ( dt - unix _ epoch ) . total _ milliseconds ;
registry _ key registry = null ; try { registry = utils . open _ user _ reg _ key ( STR , true ) ; if ( registry = = null ) { logging . error ( STR ) ; return ;
if ( enabled ) { if ( global ) { registry . set _ value ( STR , 1 ) ; registry . set _ value ( STR , STR + config . local _ port . to _ string ( ) ) ; registry . set _ value ( STR , STR ) ; } else { string pac _ url ; if ( config . use _ online _ pac & & ! config . pac _ url . is _ null _ or _ empty ( ) ) pac _ url = config . pac _ url ; else pac _ url = $ STR ; registry . set _ value ( STR , 0 ) ; var read _ proxy _ server = registry . get _ value ( STR ) ; registry . set _ value ( STR , STR ) ; registry . set _ value ( STR , pac _ url ) ; } } else { registry . set _ value ( STR , 0 ) ; registry . set _ value ( STR , STR ) ; registry . set _ value ( STR , STR ) ; }  ie _ auto _ detect _ proxy ( ! enabled ) ; notify _ ie ( ) ;  copy _ proxy _ setting _ from _ lan ( ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ;  message _ box . show ( n . get _ string ( STR ) ) ; } finally { if ( registry ! = null ) { try { registry . close ( ) ; registry . dispose ( ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; }
} private static void copy _ proxy _ setting _ from _ lan ( ) { registry _ key registry = null ; try { registry = utils . open _ user _ reg _ key ( STR , true ) ; if ( registry = = null ) { logging . error ( STR ) ; return ; } var default _ value = registry . get _ value ( STR ) ; var connections = registry . get _ value _ names ( ) ; foreach ( var each in connections ) { switch ( each . to _ upper _ invariant ( ) ) { case STR : case STR : case STR : continue ; default :  registry . set _ value ( each , default _ value ) ; continue ; } } notify _ ie ( ) ; } catch ( io _ exception e ) { logging . log _ useful _ exception ( e ) ; } finally { if ( registry ! = null ) { try { registry . close ( ) ; registry . dispose ( ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; } } } }     private static void ie _ auto _ detect _ proxy ( bool set ) { registry _ key registry = null ; try { registry = utils . open _ user _ reg _ key ( STR , true ) ; if ( registry = = null ) { logging . error ( STR ) ; return ; } var def _ connection = ( byte [ ] ) registry . get _ value ( STR ) ; var saved _ legacy _ setting = ( byte [ ] ) registry . get _ value ( STR ) ; const int version _ offset = NUM ; const int options _ offset = NUM ; if ( set ) { def _ connection [ options _ offset ] = ( byte ) ( def _ connection [ options _ offset ] | NUM ) ; saved _ legacy _ setting [ options _ offset ] = ( byte ) ( saved _ legacy _ setting [ options _ offset ] | NUM ) ; } else { def _ connection [ options _ offset ] = ( byte ) ( def _ connection [ options _ offset ] & ~ NUM ) ; saved _ legacy _ setting [ options _ offset ] = ( byte ) ( saved _ legacy _ setting [ options _ offset ] & ~ NUM ) ; } bit _ converter . get _ bytes ( unchecked ( bit _ converter . to _ u _ int ( def _ connection , version _ offset ) + 1 ) ) . copy _ to ( def _ connection , version _ offset ) ; bit _ converter . get _ bytes ( unchecked ( bit _ converter . to _ u _ int ( saved _ legacy _ setting , version _ offset ) + 1 ) ) . copy _ to ( saved _ legacy _ setting , version _ offset ) ; registry . set _ value ( STR , def _ connection ) ; registry . set _ value ( STR , saved _ legacy _ setting ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; } finally { if ( registry ! = null ) { try { registry . close ( ) ; registry . dispose ( ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; } }
registry _ key registry = registry . current _ user . open _ sub _ key ( STR , true ) ;
foreach ( string each in connections )
system _ proxy . notify _ ie ( ) ; } catch ( io _ exception e ) {
} private static string get _ timestamp ( date _ time value ) { return value . to _ string ( STR ) ;
registry _ key registry = registry . current _ user . open _ sub _ key ( STR , true ) ; byte [ ] def _ connection = ( byte [ ] ) registry . get _ value ( STR ) ; byte [ ] saved _ legacy _ setting = ( byte [ ] ) registry . get _ value ( STR ) ;
def _ connection [ NUM ] = convert . to _ byte ( def _ connection [ NUM ] & NUM ) ; saved _ legacy _ setting [ NUM ] = convert . to _ byte ( saved _ legacy _ setting [ NUM ] & NUM ) ;
def _ connection [ NUM ] = convert . to _ byte ( def _ connection [ NUM ] & ~ NUM ) ; saved _ legacy _ setting [ NUM ] = convert . to _ byte ( saved _ legacy _ setting [ NUM ] & ~ NUM ) ;
file _ stream file _ stream = new file _ stream ( file _ name , file _ mode . create , file _ access . write ) ; file _ stream . write ( content , 0 , content . length ) ; file _ stream . close ( ) ;
catch ( exception exception )
exception . to _ string ( ) ) ;
file _ stream destination _ file = file . create ( file _ name ) ;
using ( g _ zip _ stream input = new g _ zip _ stream ( new memory _ stream ( content ) ,
destination _ file . write ( buffer , 0 , n ) ;
destination _ file . close ( ) ;
this . table _ layout _ panel = new system . windows . forms . table _ layout _ panel ( ) ; this . list _ view = new system . windows . forms . list _ view ( ) ; this . table _ layout _ panel = new system . windows . forms . table _ layout _ panel ( ) ;
this . table _ layout _ panel . suspend _ layout ( ) ; this . table _ layout _ panel . suspend _ layout ( ) ;
this . table _ layout _ panel . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( ( system . windows . forms . anchor _ styles . top | system . windows . forms . anchor _ styles . left ) | system . windows . forms . anchor _ styles . right ) ) ) ;
this . table _ layout _ panel . controls . add ( this . label , 0 , NUM ) ;
this . table _ layout _ panel . controls . add ( this . encryption _ select , 1 , NUM ) ;
this . table _ layout _ panel . controls . add ( this . label , 0 , NUM ) ;
this . table _ layout _ panel . controls . add ( this . proxy _ port _ text _ box , 1 , NUM ) ; this . table _ layout _ panel . location = new system . drawing . point ( NUM , NUM ) ; this . table _ layout _ panel . margin = new system . windows . forms . padding ( NUM ) ;
this . panel . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( ( system . windows . forms . anchor _ styles . top | system . windows . forms . anchor _ styles . bottom ) | system . windows . forms . anchor _ styles . right ) ) ) ;
this . panel . location = new system . drawing . point ( NUM , NUM ) ;
( ( system . component _ model . i _ support _ initialize ) ( this . numeric _ up _ down ) ) . begin _ init ( ) ;
this . split _ container . size = new system . drawing . size ( NUM , NUM ) ; this . split _ container . splitter _ distance = NUM ;
this . numeric _ up _ down . location = new system . drawing . point ( NUM , NUM ) ;
using shadowsocks _ model ; using shadowsocks _ properties ; using system ;
using system _ i _ compression ;
using system _ net _ network _ information ; using system _ net ; using system _ runtime _ interop _ services ;
private static string temppath ;
temppath = utils . get _ temp _ path ( ) ;
file _ manager . uncompress _ file ( temppath + STR , resources . privoxy _ exe ) ; file _ manager . uncompress _ file ( temppath + STR , resources . mgwz _ dll ) ;
file _ manager . byte _ array _ to _ file ( temppath + STR , system . text . encoding . ut . get _ bytes ( polipo _ config ) ) ; if ( ! ( temppath . ends _ with ( STR ) | | temppath . ends _ with ( STR ) ) ) { temppath = temppath + STR ; }
process . start _ info . file _ name = temppath + STR ; process . start _ info . arguments = STR + temppath + STR ;
using shadowsocks _ controller ;
using system ; using system _ collections _ generic ; using system _ io ; using system _ runtime _ interop _ services ; using system _ text ;
using shadowsocks _ controller ; using shadowsocks _ properties ; using shadowsocks _ view ; using system ; using system _ collections _ generic ;
util . utils . release _ memory ( true ) ;
using shadowsocks _ controller ;
using system ; using system _ collections _ generic ; using system _ io ; using system _ runtime _ interop _ services ; using system _ text ;
string temp _ path = utils . get _ temp _ path ( ) ; string dll _ path = temp _ path + STR ;
using shadowsocks _ controller ;
using system ; using system _ collections _ generic ; using system _ io ; using system _ runtime _ interop _ services ; using system _ text ;
string temp _ path = utils . get _ temp _ path ( ) ; string dll _ path = temp _ path + STR ;
using shadowsocks _ util ; using system ; using system _ collections _ generic ;
using system _ text ;
string temppath = utils . get _ temp _ path ( ) ; log _ file = path . combine ( temppath , STR ) ;
if ( ! file . exists ( utils . get _ temp _ path ( ) + STR ) )
list < string > lines = gfw _ list _ updater . parse _ result ( file . read _ all _ text ( utils . get _ temp _ path ( ) + STR ) ) ;
using system _ net ; using system _ io ;
using simple _ json ;
using shadowsocks _ model ;
using system _ collections ;
using system _ reflection ; using system _ text ;
using system _ io ;
if ( file . exists ( application . startup _ path + STR ) )
try { directory . create _ directory ( application . startup _ path + STR ) ; } catch ( exception e ) {  logging . log _ useful _ exception ( e ) ; }    return application . startup _ path + STR ;
return path . get _ temp _ path ( ) ;
current . inbound _ counter = inbound _ counter ; current . outbound _ counter = outbound _ counter ; current . inbound _ increasement = inbound _ counter - previous . inbound _ counter ; current . outbound _ increasement = outbound _ counter - previous . outbound _ counter ;
if ( traffic _ changed ! = null ) { traffic _ changed ( this , new event _ args ( ) ) ; }
total _ write + = bytes _ read ; var session = ( async _ session < bool > ) ar . async _ state ;
* only the first packet contains the socks header , it doesn ' t make sense to parse every packets . * also it ' s unnecessary to parse these data if we turn off the verbose _ logging . * / if ( session . state & & config . is _ verbose _ logging ) { int atyp = connetion _ recv _ buffer [ 0 ] ; string dst _ addr ; int dst _ port ; switch ( atyp ) { case 1 : dst _ addr = new ip _ address ( connetion _ recv _ buffer . skip ( 1 ) . take ( NUM ) . to _ array ( ) ) . to _ string ( ) ; dst _ port = ( connetion _ recv _ buffer [ NUM ] < < NUM ) + connetion _ recv _ buffer [ NUM ] ; logging . info ( $ STR ) ; session . state = false ; break ; case NUM : int len = connetion _ recv _ buffer [ 1 ] ; dst _ addr = system . text . encoding . ut . get _ string ( connetion _ recv _ buffer , 2 , len ) ; dst _ port = ( connetion _ recv _ buffer [ len + 2 ] < < NUM ) + connetion _ recv _ buffer [ len + NUM ] ; logging . info ( $ STR ) ; session . state = false ; break ; case NUM : dst _ addr = new ip _ address ( connetion _ recv _ buffer . skip ( 1 ) . take ( NUM ) . to _ array ( ) ) . to _ string ( ) ; dst _ port = ( connetion _ recv _ buffer [ NUM ] < < NUM ) + connetion _ recv _ buffer [ NUM ] ; logging . info ( $ STR ) ; session . state = false ; break ; } } int bytes _ to _ send ; lock ( encryption _ lock ) { encryptor . encrypt ( connetion _ recv _ buffer , bytes _ read , connetion _ send _ buffer , out bytes _ to _ send ) ; } tcprelay . update _ outbound _ counter ( server , bytes _ to _ send ) ; start _ sending _ time = date _ time . now ; remote . begin _ send ( connetion _ send _ buffer , 0 , bytes _ to _ send , socket _ flags . none , new async _ callback ( pipe _ remote _ send _ callback ) , session ) ; i _ strategy strategy = controller . get _ current _ strategy ( ) ; strategy ? . update _ last _ write ( server ) ;
public server get _ a _ server ( i _ strategy _ caller _ type type , ip _ end _ point local _ ip _ end _ point )
return strategy . get _ a _ server ( type , local _ ip _ end _ point ) ;
if ( utils . is _ portable _ mode ( ) ) {  * under portable _ mode , we could identify it by the path of ss _ privoxy . exe . * / try
* sometimes process . get _ processes _ by _ name will return some processes that * are already dead , and that will cause exceptions here . * we could simply ignore those exceptions .
string path = process . main _ module . file _ name ;
catch ( exception ex ) { logging . log _ useful _ exception ( ex ) ; return false ; } } else { try
catch ( win _ exception ex ) { if ( ( uint ) ex . error _ code ! = 0 ) { throw ; } }
polar _ ssl . aes _ crypt _ cfb ( encrypt _ ctx , is _ cipher ? polar _ ssl . aes _ encrypt : polar _ ssl . aes _ decrypt , length , ref iv _ offset , iv , buf , outbuf ) ;
public void test _ encryption ( )
thread t = new thread ( new thread _ start ( run _ single _ encryption _ thread ) ) ;
private void show _ window ( ) { this . opacity = 1 ; this . show ( ) ; ip _ text _ box . focus ( ) ; } private bool save _ old _ selected _ server ( )
server server = new server ( ) ; if ( uri . check _ host _ name ( server . server = ip _ text _ box . text . trim ( ) ) = = uri _ host _ name _ type . unknown ) { message _ box . show ( n . get _ string ( STR ) ) ; ip _ text _ box . focus ( ) ; return false ; } if ( ! int . try _ parse ( server _ port _ text _ box . text , out server . server _ port ) ) { message _ box . show ( n . get _ string ( STR ) ) ; server _ port _ text _ box . focus ( ) ; return false ; } server . password = password _ text _ box . text ; server . method = encryption _ select . text ; server . plugin = plugin _ text _ box . text ; server . plugin _ opts = plugin _ options _ text _ box . text ; server . plugin _ args = plugin _ arguments _ text _ box . text ; server . remarks = remarks _ text _ box . text ; if ( ! int . try _ parse ( timeout _ text _ box . text , out server . timeout ) ) { message _ box . show ( n . get _ string ( STR ) ) ; timeout _ text _ box . focus ( ) ; return false ; } int local _ port = int . parse ( proxy _ port _ text _ box . text ) ;
configuration . check _ local _ port ( local _ port ) ;
modified _ configuration . local _ port = local _ port ; modified _ configuration . portable _ mode = portable _ mode _ check _ box . checked ;
private void load _ selected _ server ( )
ip _ text _ box . text = server . server ; server _ port _ text _ box . text = server . server _ port . to _ string ( ) ; password _ text _ box . text = server . password ; proxy _ port _ text _ box . text = modified _ configuration . local _ port . to _ string ( ) ; encryption _ select . text = server . method ? ? STR ; plugin _ text _ box . text = server . plugin ; plugin _ options _ text _ box . text = server . plugin _ opts ; plugin _ arguments _ text _ box . text = server . plugin _ args ; remarks _ text _ box . text = server . remarks ; timeout _ text _ box . text = server . timeout . to _ string ( ) ; } } private void load _ configuration ( configuration configuration )
foreach ( server server in modified _ configuration . configs )
load _ configuration ( modified _ configuration ) ;
update _ move _ up _ and _ down _ button ( ) ; load _ selected _ server ( ) ;
} private void config _ form _ load ( object sender , event _ args e ) {
if ( ! save _ old _ selected _ server ( ) )
if ( ! save _ old _ selected _ server ( ) )
update _ move _ up _ and _ down _ button ( ) ; load _ selected _ server ( ) ;
if ( ! save _ old _ selected _ server ( ) )
load _ configuration ( modified _ configuration ) ;
if ( ! save _ old _ selected _ server ( ) )
load _ configuration ( modified _ configuration ) ;
load _ configuration ( modified _ configuration ) ;
load _ selected _ server ( ) ;
if ( ! save _ old _ selected _ server ( ) )
update _ move _ up _ and _ down _ button ( ) ; } private void update _ move _ up _ and _ down _ button ( ) { if ( servers _ list _ box . selected _ index = = 0 ) { move _ up _ button . enabled = false ; } else { move _ up _ button . enabled = true ; } if ( servers _ list _ box . selected _ index = = servers _ list _ box . items . count - 1 ) { move _ down _ button . enabled = false ; } else { move _ down _ button . enabled = true ; }
if ( ! save _ old _ selected _ server ( ) )
: encryptor _ base , i _ disposable
static dictionary < string , int [ ] > ciphers = new dictionary < string , int [ ] > { { STR , new int [ ] { NUM , NUM , cipher _ aes , polar _ ssl . aes _ ctx _ size } } , { STR , new int [ ] { NUM , NUM , cipher _ aes , polar _ ssl . aes _ ctx _ size } } , { STR , new int [ ] { NUM , NUM , cipher _ aes , polar _ ssl . aes _ ctx _ size } } , { STR , new int [ ] { NUM , 0 , cipher _ r , polar _ ssl . ar _ ctx _ size } } , { STR , new int [ ] { NUM , NUM , cipher _ r , polar _ ssl . ar _ ctx _ size } } , } ; private static readonly dictionary < string , byte [ ] > cached _ keys = new dictionary < string , byte [ ] > ( ) ; private int cipher ; private int [ ] cipher _ info ; private byte [ ] key ;
private byte [ ] encrypt _ iv ; private byte [ ] decrypt _ iv ; private int encrypt _ iv _ offset = 0 ; private int decrypt _ iv _ offset = 0 ; private string method ; private int key _ len ; private int iv _ len ;
private static void rand _ bytes ( byte [ ] buf , int length )
byte [ ] temp = new byte [ length ] ; new random ( ) . next _ bytes ( temp ) ; temp . copy _ to ( buf , 0 ) ;
private void bytes _ to _ key ( byte [ ] password , byte [ ] key )
byte [ ] result = new byte [ password . length + NUM ] ; int i = 0 ; byte [ ] md _ sum = null ; while ( i < key . length )
m md = m . create ( ) ; if ( i = = 0 ) { md _ sum = md . compute _ hash ( password ) ; } else { md _ sum . copy _ to ( result , 0 ) ; password . copy _ to ( result , md _ sum . length ) ; md _ sum = md . compute _ hash ( result ) ; } md _ sum . copy _ to ( key , i ) ; i + = md _ sum . length ; } } private void init _ key ( string method , string password ) { method = method . to _ lower ( ) ; method = method ; string k = method + STR + password ; cipher _ info = ciphers [ method ] ; cipher = cipher _ info [ 2 ] ; if ( cipher = = 0 ) { throw new exception ( STR ) ; } key _ len = ciphers [ method ] [ 0 ] ; iv _ len = ciphers [ method ] [ 1 ] ; if ( cached _ keys . contains _ key ( k ) ) { key = cached _ keys [ k ] ;
byte [ ] passbuf = encoding . ut . get _ bytes ( password ) ; key = new byte [ NUM ] ; byte [ ] iv = new byte [ NUM ] ; bytes _ to _ key ( passbuf , key ) ; cached _ keys [ k ] = key ;
} private void init _ cipher ( ref int _ ptr ctx , byte [ ] iv , bool is _ cipher ) { ctx = marshal . alloc _ h _ global ( cipher _ info [ NUM ] ) ;
if ( is _ cipher ) { encrypt _ iv = new byte [ iv _ len ] ; array . copy ( iv , encrypt _ iv , iv _ len ) ; } else { decrypt _ iv = new byte [ iv _ len ] ; array . copy ( iv , decrypt _ iv , iv _ len ) ; }
static byte [ ] tempbuf = new byte [ NUM ] ; public override void encrypt ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength )
if ( encrypt _ ctx = = int _ ptr . zero )
rand _ bytes ( outbuf , iv _ len ) ; init _ cipher ( ref encrypt _ ctx , outbuf , true ) ; outlength = length + iv _ len ; lock ( tempbuf ) {  if ( disposed ) { throw new object _ disposed _ exception ( this . to _ string ( ) ) ; }   switch ( cipher ) { case cipher _ aes : polar _ ssl . aes _ crypt _ cfb ( encrypt _ ctx , polar _ ssl . aes _ encrypt , length , ref encrypt _ iv _ offset , encrypt _ iv , buf , tempbuf ) ; break ; case cipher _ r : polar _ ssl . arc _ crypt ( encrypt _ ctx , length , buf , tempbuf ) ; break ; } outlength = length + iv _ len ; buffer . block _ copy ( tempbuf , 0 , outbuf , iv _ len , length ) ; }
outlength = length ; if ( disposed ) { throw new object _ disposed _ exception ( this . to _ string ( ) ) ; } switch ( cipher ) { case cipher _ aes : polar _ ssl . aes _ crypt _ cfb ( encrypt _ ctx , polar _ ssl . aes _ encrypt , length , ref encrypt _ iv _ offset , encrypt _ iv , buf , outbuf ) ; break ; case cipher _ r : polar _ ssl . arc _ crypt ( encrypt _ ctx , length , buf , outbuf ) ; break ; }
} public override void decrypt ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength ) { if ( decrypt _ ctx = = int _ ptr . zero )
init _ cipher ( ref decrypt _ ctx , buf , false ) ; outlength = length - iv _ len ; lock ( tempbuf ) {  buffer . block _ copy ( buf , iv _ len , tempbuf , 0 , length - iv _ len ) ; if ( disposed )
throw new object _ disposed _ exception ( this . to _ string ( ) ) ;
switch ( cipher )
case cipher _ aes : polar _ ssl . aes _ crypt _ cfb ( decrypt _ ctx , polar _ ssl . aes _ decrypt , length - iv _ len , ref decrypt _ iv _ offset , decrypt _ iv , tempbuf , outbuf ) ; break ; case cipher _ r : polar _ ssl . arc _ crypt ( decrypt _ ctx , length - iv _ len , tempbuf , outbuf ) ; break ;
} } else { outlength = length ; if ( disposed ) { throw new object _ disposed _ exception ( this . to _ string ( ) ) ; } switch ( cipher ) { case cipher _ aes : polar _ ssl . aes _ crypt _ cfb ( decrypt _ ctx , polar _ ssl . aes _ decrypt , length , ref decrypt _ iv _ offset , decrypt _ iv , buf , outbuf ) ; break ; case cipher _ r : polar _ ssl . arc _ crypt ( decrypt _ ctx , length , buf , outbuf ) ; break ; }
string temp _ path = path . get _ temp _ path ( ) ; string dll _ path = temp _ path + STR ;
load _ library ( dll _ path ) ;
byte [ ] pac _ gz = resources . proxy _ pac _ txt ; byte [ ] buffer = new byte [ NUM * NUM ] ; int n ; using ( g _ zip _ stream input = new g _ zip _ stream ( new memory _ stream ( pac _ gz ) , compression _ mode . decompress , false ) )
n = input . read ( buffer , 0 , buffer . length ) ; if ( n = = 0 )
throw new io _ exception ( STR ) ;
return system . text . encoding . ut . get _ string ( buffer , 0 , n ) ;
local . start ( ) ; pac _ server = new pac _ server ( ) ; pac _ server . start ( ) ;
this . about _ item . index = 2 ;
protected override dictionary < string , int [ ] > get _ ciphers ( ) { return new dictionary < string , int [ ] > {
} ;
return new dictionary < string , int [ ] > { { STR , new int [ ] { NUM , NUM , cipher _ sals , polar _ ssl . aes _ ctx _ size } } , { STR , new int [ ] { NUM , NUM , cipher _ chach , polar _ ssl . aes _ ctx _ size } } , } ; ;
if ( string . is _ null _ or _ empty ( method ) | | method . to _ lower _ invariant ( ) = = STR )
return new table _ encryptor ( method , password ) ;
return new sodium _ encryptor ( method , password ) ;
this . btn _ ok . location = new system . drawing . point ( NUM , NUM ) ;
this . btn _ cancel . location = new system . drawing . point ( NUM , NUM ) ;
this . btn _ register _ all . location = new system . drawing . point ( NUM , NUM ) ;
using system ; using system _ collections _ generic ;
using system _ linq ;
using shadowsocks _ controller ; using shadowsocks _ model ; using shadowsocks _ properties ;
using system ; using system _ collections _ generic ;
using shadowsocks _ properties ;
private static void init ( string res )
using ( var sr = new string _ reader ( res ) )
foreach ( var line in sr . non _ white _ space _ lines ( ) )
if ( line [ 0 ] = = '#' ) continue ; var pos = line . index _ of ( '=' ) ; if ( pos < 1 ) continue ; strings [ line . substring ( 0 , pos ) ] = line . substring ( pos + 1 ) ;
string name = culture _ info . current _ culture . english _ name ; if ( name . starts _ with ( STR , string _ comparison . ordinal _ ignore _ case ) ) {  init ( name . contains ( STR ) ? resources . zh _ tw : resources . zh _ cn ) ; } else if ( name . starts _ with ( STR , string _ comparison . ordinal _ ignore _ case ) ) { init ( resources . ja ) ; }
using shadowsocks _ controller ; using shadowsocks _ model ; using shadowsocks _ properties ;
add _ button . text = n . get _ string ( STR ) ; delete _ button . text = n . get _ string ( STR ) ; duplicate _ button . text = n . get _ string ( STR ) ; ip _ label . text = n . get _ string ( STR ) ; server _ port _ label . text = n . get _ string ( STR ) ; password _ label . text = n . get _ string ( STR ) ; show _ passwd _ check _ box . text = n . get _ string ( STR ) ; encryption _ label . text = n . get _ string ( STR ) ; plugin _ label . text = n . get _ string ( STR ) ; plugin _ options _ label . text = n . get _ string ( STR ) ; plugin _ arguments _ label . text = n . get _ string ( STR ) ; need _ plugin _ arg _ check _ box . text = n . get _ string ( STR ) ; proxy _ port _ label . text = n . get _ string ( STR ) ; portable _ mode _ check _ box . text = n . get _ string ( STR ) ;
remarks _ label . text = n . get _ string ( STR ) ; timeout _ label . text = n . get _ string ( STR ) ; server _ group _ box . text = n . get _ string ( STR ) ; ok _ button . text = n . get _ string ( STR ) ; my _ cancel _ button . text = n . get _ string ( STR ) ; apply _ button . text = n . get _ string ( STR ) ; move _ up _ button . text = n . get _ string ( STR ) ; move _ down _ button . text = n . get _ string ( STR ) ; text = n . get _ string ( STR ) ;
using system _ reflection ;
public static hotkey _ callbacks instance { get ; private set ; }
using system _ threading ;
private dictionary < string , statistics _ data > statistics ; private const int cached _ interval = NUM * NUM * NUM ; private const int retry _ interval = 2 * NUM * NUM ;
return a dict : { ' server _ friendly _ name ' : statistics _ data , ' server _ friendly _ name ' : . . . } * /
log _ when _ enabled ( $ STR ) ; timer . change ( retry _ interval , cached _ interval ) ;
statistics = ( from l in file . read _ all _ lines ( path ) . skip ( 1 ) let strings = l . split ( new [ ] { STR } , string _ split _ options . remove _ empty _ entries ) let raw _ data = new {  server _ name = strings [ 1 ] ,     ip _ status = strings [ 2 ] , roundtrip _ time = int . parse ( strings [ NUM ] ) } group raw _ data by raw _ data . server _ name into server select new { server _ name = server . key , data = new statistics _ data { success _ times = server . count ( data = > ip _ status . success . to _ string ( ) . equals ( data . ip _ status ) ) , timed _ out _ times = server . count ( data = > ip _ status . timed _ out . to _ string ( ) . equals ( data . ip _ status ) ) , average _ response = convert . to _ int ( server . average ( data = > data . roundtrip _ time ) ) , min _ response = server . min ( data = > data . roundtrip _ time ) , max _ response = server . max ( data = > data . roundtrip _ time ) } } ) . to _ dictionary ( server = > server . server _ name , server = > server . data ) ;
private static double get _ score ( statistics _ data data ) { return ( double ) data . success _ times / ( data . success _ times + data . timed _ out _ times ) ;
public int success _ times ; public int timed _ out _ times ;
if ( statistics = = null | | servers . count = = 0 )
where statistics . contains _ key ( name )
score = get _ score ( statistics [ name ] )
public calculation _ control ( string value )
value _ label . text = value ;
public float factor = > float . parse ( factor _ num . text ) ;
system . windows . forms . data _ visualization . charting . series series = new system . windows . forms . data _ visualization . charting . series ( ) ;
this . binding _ configuration = new system . windows . forms . binding _ source ( this . components ) ;
series . chart _ type = system . windows . forms . data _ visualization . charting . series _ chart _ type . area ; series . color = system . drawing . color . from _ argb ( ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) , ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) , ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) ) ;
series . name = STR ;
series . chart _ type = system . windows . forms . data _ visualization . charting . series _ chart _ type . bubble ; series . color = system . drawing . color . from _ argb ( ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) , ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) , ( ( int ) ( ( ( byte ) ( 0 ) ) ) ) ) ;
series . name = STR ; series . y _ values _ per _ point = NUM ; series . border _ width = NUM ; series . chart _ area = STR ; series . chart _ type = system . windows . forms . data _ visualization . charting . series _ chart _ type . line ; series . color = system . drawing . color . from _ argb ( ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) , ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) , ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) ) ; series . legend = STR ; series . name = STR ;
this . statistics _ chart . series . add ( series ) ; this . statistics _ chart . size = new system . drawing . size ( NUM , NUM ) ;
using simple _ json = simple _ json . simple _ json ;
private const int repeat = NUM ; private const int interval = NUM * NUM * NUM ; private const int delay _ before _ start = 1 * NUM ;
string temppath = utils . get _ temp _ path ( ) ;
public bool set ( bool enabled )
if ( enabled )
if ( timer ? . change ( 0 , interval ) = = null )
timer = new timer ( evaluate , state , 0 , interval ) ;
private static async task < list < data _ list > > icmp _ test ( server server )
var timestamp in enumerable . range ( 0 , repeat ) . select ( = > date _ time . now . to _ string ( STR ) ) )
var reply = await ping . send _ task _ async ( server . server , timeout ) ;
file . append _ all _ lines ( availability _ statistics _ file , lines ) ;
internal void update _ configuration ( configuration config )
set ( config . availability _ statistics ) ;
private class state
registry _ key run _ key = null ;
registry _ key hkcr = registry _ key . open _ base _ key ( registry _ hive . classes _ root , environment . is _ bit _ operating _ system ? registry _ view . registry : registry _ view . registry ) ; run _ key = hkcr . create _ sub _ key ( STR , registry _ key _ permission _ check . read _ write _ sub _ tree ) ; if ( run _ key = = null )
run _ key . set _ value ( STR , STR ) ; run _ key . set _ value ( STR , STR ) ; var shell _ open = run _ key . create _ sub _ key ( STR ) . create _ sub _ key ( STR ) . create _ sub _ key ( STR ) ;
hkcr . delete _ sub _ key _ tree ( STR ) ;
run _ key . close ( ) ; run _ key . dispose ( ) ;
registry _ key run _ key = null ;
run _ key = utils . open _ reg _ key ( STR , true , registry _ hive . classes _ root ) ; if ( run _ key = = null )
logger . error ( STR ) ;
var shell _ open = run _ key . open _ sub _ key ( STR ) . open _ sub _ key ( STR ) . open _ sub _ key ( STR ) ;
run _ key . close ( ) ; run _ key . dispose ( ) ;
assembly _ assembly _ company
assembly _ assembly _ copyright _ copyright
public static void release _ memory ( )
set _ process _ working _ set _ size ( process . get _ current _ process ( ) . handle , ( u _ int _ ptr ) 0 xffffffff , ( u _ int _ ptr ) 0 xffffffff ) ;
( ( i _ disposable ) encryptor ) . dispose ( ) ;
encryptor . decrypt ( remote _ recv _ buffer , bytes _ read , remote _ send _ buffer , out bytes _ to _ send ) ;
encryptor . encrypt ( connetion _ recv _ buffer , bytes _ read , connetion _ send _ buffer , out bytes _ to _ send ) ;
console . write _ line ( e . message ) ;
using ( mutex mutex = new mutex ( false , STR + application . startup _ path . get _ hash _ code ( ) ) )
message _ box . show ( n . get _ string ( STR ) + STR + environment . new _ line + ( e . exception _ object ? . to _ string ( ) ) ,
logging . error ( STR ) ;
logging . log _ useful _ exception ( e ) ;
logging . debug ( STR + command ) ;
logging . log _ useful _ exception ( e ) ;
logging . info ( $ STR ) ;
logging . debug ( STR ) ;
logging . log _ useful _ exception ( e ) ;
logging . debug ( $ STR ) ;
logging . log _ useful _ exception ( e ) ;
logging . error ( STR ) ;
logging . info (
logging . error ( STR + ex . message ) ;
logging . log _ useful _ exception ( e ) ;
logging . debug ( $ STR ) ;
logging . log _ useful _ exception ( e ) ;
logging . debug ( $ STR ) ;
logging . error ( $ STR ) ; logging . log _ useful _ exception ( e ) ;
logging . error ( $ STR ) ; logging . log _ useful _ exception ( ex ) ;
logging . dump ( STR , salt , salt _ len ) ;
logging . error ( $ STR ) ;
using system ;
using shadowsocks _ model ;
logging . info ( $ STR ) ;
logging . info ( encryption . encryptor _ factory . dump _ registered _ encryptor ( ) ) ;
logging . debug ( STR ) ;
logging . log _ useful _ exception ( ex ) ;
logging . debug ( STR ) ;
logging . log _ useful _ exception ( ex ) ;
logging . debug ( $ STR ) ;
logging . log _ useful _ exception ( ex ) ;
logging . dump ( STR , dec _ nonce , nonce _ len ) ; logging . dump ( STR , sodium _ dec _ subkey , key _ len ) ; logging . dump ( STR , ciphertext , ( int ) clen ) ;
logging . debug ( local _ end _ point , remote _ end _ point , outlen , STR ) ;
logging . open _ log _ file ( ) ;
logging . open _ log _ file ( ) ;
logging . error ( err _ msg ) ;
logging . log _ useful _ exception ( ex ) ;
socket conn = listener . end _ accept ( ar ) ;
catch ( exception e )
public static string get _ string ( string key )
? strings [ key ] : key ;
ip _ end _ point [ ] ip _ end _ points = ip _ properties . get _ active _ tcp _ listeners ( ) ; foreach ( ip _ end _ point end _ point in ip _ end _ points ) { if ( end _ point . port = = port ) { return true ; } } return false ;
throw new exception ( n . get _ string ( STR ) ) ;
ip _ address ip _ address ; bool parsed = ip _ address . try _ parse ( host , out ip _ address ) ; if ( ! parsed ) { ip _ host _ entry ip _ host _ info = dns . get _ host _ entry ( host ) ; ip _ address = ip _ host _ info . address _ list [ 0 ] ; } ip _ end _ point ep = new ip _ end _ point ( ip _ address , port ) ;
switch ( ep . address _ family ) { case address _ family . inter _ network : request = new byte [ NUM + NUM + 2 ] ; atyp = 1 ; break ; case address _ family . inter _ network : request = new byte [ NUM + NUM + 2 ] ; atyp = NUM ; break ;      } if ( request = = null ) {        throw new exception ( n . get _ string ( STR ) ) ; }  var addr = ep . address . get _ address _ bytes ( ) ;
array . copy ( addr , 0 , request , NUM , request . length - NUM - 2 ) ; request [ request . length - 2 ] = ( byte ) ( ( ep . port > > NUM ) & 0 xff ) ; request [ request . length - 1 ] = ( byte ) ( ep . port & 0 xff ) ;
logging . debug ( $ STR ) ;
logging . debug ( $ STR ) ;
logging . debug ( $ STR ) ;
if ( culture _ info . current _ culture . ietf _ language _ tag . starts _ with ( STR , string _ comparison . ordinal _ ignore _ case ) )
using ( var sr = new string _ reader ( resources . cn ) )
foreach ( var line in sr . non _ white _ space _ lines ( ) ) { if ( line [ 0 ] = = '#' ) continue ; var pos = line . index _ of ( '=' ) ; if ( pos < 1 ) continue ; strings [ line . substring ( 0 , pos ) ] = line . substring ( pos + 1 ) ; }
if ( user _ settings _ arr . length = = 1 )
var sb = new string _ builder ( $ STR ) ; for ( int i = 0 ; i < length - 1 ; i + + )
sb . append ( $ STR ) ;
sb . append ( $ STR ) ; sb . append ( environment . new _ line ) ; logger . debug ( sb . to _ string ( ) ) ;
if ( header = = null & & tailer = = null ) logger . debug ( $ STR ) ; else if ( header = = null & & tailer ! = null ) logger . debug ( $ STR ) ; else if ( header ! = null & & tailer = = null ) logger . debug ( $ STR ) ; else logger . debug ( $ STR ) ;
logger . debug ( sock . local _ end _ point , sock . remote _ end _ point , len , header , tailer ) ;
var configuration = json _ convert . deserialize _ object < statistics _ strategy _ configuration > ( content ) ;
catch ( file _ not _ found _ exception e )
protected static bool serialize _ value ( i _ json _ serializer _ strategy json _ serializer _ strategy , object value , string _ builder builder )
success = serialize _ object ( json _ serializer _ strategy , dict . keys , dict . values , builder ) ;
success = serialize _ object ( json _ serializer _ strategy , dict . keys , dict . values , builder ) ;
success = serialize _ array ( json _ serializer _ strategy , ( i _ enumerable ) value , builder ) ;
serialize _ value ( json _ serializer _ strategy , serialized _ object , builder ) ;
protected static bool serialize _ object ( i _ json _ serializer _ strategy json _ serializer _ strategy , i _ enumerable keys , i _ enumerable values , string _ builder builder )
if ( ! serialize _ value ( json _ serializer _ strategy , value , builder ) ) return false ;
if ( ! serialize _ value ( json _ serializer _ strategy , value , builder ) )
builder . append ( STR ) ;
protected static bool serialize _ array ( i _ json _ serializer _ strategy json _ serializer _ strategy , i _ enumerable an _ array , string _ builder builder ) { builder . append ( STR ) ;
builder . append ( STR ) ; if ( ! serialize _ value ( json _ serializer _ strategy , value , builder ) )
builder . append ( STR ) ;
if ( rng = = null ) rng = new rng _ crypto _ service _ provider ( ) ;
if ( rng = = null ) return ; rng . dispose ( ) ;
if ( rng = = null ) reload ( ) ;
catch ( system . exception )
string [ ] lines = parse _ result ( e . result ) ; json _ array rules = new json _ array ( ) ; rules . add _ range ( lines ) ;
abp _ content = abp _ content . replace ( STR , rules . to _ string ( ) ) ;
public string [ ] parse _ result ( string response )
catch ( exception )
message _ box . show ( STR ) ; throw ;
catch ( exception )
message _ box . show ( STR ) ; throw ;
private encryptor encryptor ;
this . encryptor = new encryptor ( config . method , config . password ) ;
if ( enabled )
if ( global )
win _ i _ net . set _ ie _ proxy ( true , true , STR + config . local _ port . to _ string ( ) , STR ) ;
string pac _ url ; if ( config . use _ online _ pac & & ! config . pac _ url . is _ null _ or _ empty ( ) ) pac _ url = config . pac _ url ; else pac _ url = $ STR ; win _ i _ net . set _ ie _ proxy ( true , false , STR , pac _ url ) ;
else
win _ i _ net . set _ ie _ proxy ( false , false , STR , STR ) ;
log _ message _ text _ box . word _ wrap = wrap _ text _ check _ box . checked = wrap _ text _ menu _ item . checked = wrap _ text _ trigger ; toolbar _ flow _ layout _ panel . visible = toolbar _ trigger ;
if ( key . length < key _ len ) array . resize ( ref key , key _ len ) ; legacy _ derive _ key ( passbuf , key ) ;
public static void legacy _ derive _ key ( byte [ ] password , byte [ ] key )
byte [ ] result = new byte [ password . length + NUM ] ;
while ( i < key . length ) {
md _ sum . copy _ to ( result , 0 ) ; password . copy _ to ( result , md _ sum . length ) ;
md _ sum . copy _ to ( key , i ) ; i + = md _ sum . length ;
if ( masterkey . length < key _ len ) array . resize ( ref masterkey , key _ len ) ; derive _ key ( passbuf , masterkey ) ;
public void derive _ key ( byte [ ] password , byte [ ] key ) { stream _ encryptor . legacy _ derive _ key ( password , key ) ;
public string friendly _ name
get
if ( string . is _ null _ or _ empty ( server ) ) { return n . get _ string ( STR ) ; } return string . is _ null _ or _ empty ( remarks ) ? server + STR + server _ port : server + STR + server _ port + STR + remarks + STR ;
string temppath = path . get _ temp _ path ( ) ;
file _ manager . uncompress _ file ( temppath + STR , resources . polipo _ exe ) ;
public i _ proxy remote ;
public i _ proxy proxy ;
proxy _ timer . proxy = remote ;
remote . begin _ connect _ proxy ( proxy _ ep , new async _ callback ( proxy _ connect _ callback ) , proxy _ timer ) ;
var proxy = ( ( proxy _ timer ) sender ) . proxy ;
remote ? . close ( ) ;
proxy _ timer timer = ( proxy _ timer ) ar . async _ state ;
remote . begin _ connect _ dest ( dest _ end _ point , new async _ callback ( connect _ callback ) , connect _ timer ) ;
remote ? . close ( ) ;
server _ timer timer = ( server _ timer ) ar . async _ state ;
private void start _ pipe ( )
remote ? . begin _ receive ( remote _ recv _ buffer , 0 , recv _ size , socket _ flags . none , new async _ callback ( pipe _ remote _ receive _ callback ) , null ) ;
true
object need _ to _ find _ header = null ; if ( ar . async _ state ! = null & & config . is _ verbose _ logging )
break ; default : need _ to _ find _ header = true ;
remote ? . begin _ receive ( remote _ recv _ buffer , 0 , recv _ size , socket _ flags . none , new async _ callback ( pipe _ remote _ receive _ callback ) , null ) ;
const int cipher _ bf = NUM ;
{ STR , new int [ ] { NUM , NUM , cipher _ bf , polar _ ssl . blowfish _ ctx _ size } } ,
remote = socket _ util . create _ socket ( remote _ ep ) ; remote . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ;
remote . begin _ connect ( remote _ ep , new async _ callback ( connect _ callback ) , null ) ;
if ( remote = = null ) { remote = socket _ util . create _ socket ( dest _ end _ point ) ; remote . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; } remote . begin _ connect ( dest _ end _ point , callback , state ) ;
remote ? . end _ connect ( async _ result ) ;
remote = socket _ util . create _ socket ( remote _ ep ) ; remote . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ;
remote . begin _ connect ( remote _ ep , connect _ callback , st ) ;
public static socket create _ socket ( end _ point end _ point , protocol _ type protocol _ type = protocol _ type . tcp )
socket _ type socket _ type ; switch ( protocol _ type )
case protocol _ type . tcp : socket _ type = socket _ type . stream ; break ; case protocol _ type . udp : socket _ type = socket _ type . dgram ; break ; default : throw new not _ supported _ exception ( STR + protocol _ type + STR ) ;
if ( end _ point is dns _ end _ point )
var socket = new socket ( address _ family . inter _ network , socket _ type , protocol _ type ) ; socket . set _ socket _ option ( socket _ option _ level . i _ pv , ( socket _ option _ name ) NUM , false ) ; return socket ;
else
return new socket ( end _ point . address _ family , socket _ type , protocol _ type ) ;
if ( ( bool ) release [ STR ] )
asset ass = new asset ( ) ; ass . parse ( asset ) ; if ( ass . is _ new _ version ( version ) )
asserts . add ( ass ) ;
public bool is _ new _ version ( string current _ version ) { if ( prerelease )
return compare _ version ( version , current _ version ) > 0 ; } public void parse ( j _ object asset ) { name = ( string ) asset [ STR ] ; browser _ download _ url = ( string ) asset [ STR ] ; version = parse _ version _ from _ url ( browser _ download _ url ) ; prerelease = browser _ download _ url . index _ of ( STR , string _ comparison . ordinal ) > = 0 ; } private static string parse _ version _ from _ url ( string url ) { match match = regex . match ( url , STR , regex _ options . ignore _ case ) ; if ( match . success ) { if ( match . groups . count = = 2 ) { return match . groups [ 1 ] . value ; } } return null ;
system _ proxy . disable ( ) ;
controller ? . start ( ) ;
if ( ! established )
st . inner _ state . ex = new exception ( n . get _ string ( STR ) ) ;
st . inner _ state . callback ? . invoke ( st ) ;
send _ response ( first _ packet , length , socket , use _ socks ) ;
byte [ ] cipher = new byte [ plain . length + NUM ] ;
encryptor . encrypt ( plain , plain . length , cipher , out out _ len ) ;
encryptor . encrypt ( plain , NUM , cipher , out out _ len ) ;
encryptor . encrypt ( plain , NUM , cipher , out out _ len ) ;
public const int onetimeauth _ bytes = NUM ; public const int onetimeauth _ keybytes = NUM ; public const int hash _ bytes = NUM ;
public const int auth _ bytes = hash _ bytes + clen _ bytes ;
protected int ss _ onetimeauth ( byte [ ] auth , byte [ ] msg , int msg _ len ) { byte [ ] auth _ key = new byte [ onetimeauth _ keybytes ] ; byte [ ] auth _ bytes = new byte [ max _ iv _ length + max _ key _ length ] ; buffer . block _ copy ( encrypt _ iv , 0 , auth _ bytes , 0 , iv _ len ) ; buffer . block _ copy ( key , 0 , auth _ bytes , iv _ len , key _ len ) ; sodium . crypto _ generichash ( auth _ key , onetimeauth _ keybytes , auth _ bytes , ( ulong ) ( iv _ len + key _ len ) , null , 0 ) ; return sodium . crypto _ onetimeauth ( auth , msg , ( ulong ) msg _ len , auth _ key ) ; } protected void ss _ gen _ hash ( byte [ ] buf , ref int offset , ref int len , int buf _ size ) { int size = len + auth _ bytes ; if ( buf _ size < ( size + offset ) ) throw new exception ( STR ) ;
byte [ ] hash = new byte [ hash _ bytes ] ; byte [ ] tmp = new byte [ len ] ; buffer . block _ copy ( buf , offset , tmp , 0 , len ) ; sodium . crypto _ generichash ( hash , hash _ bytes , tmp , ( ulong ) len , key _ buffer , ( uint ) key _ buffer . length ) ; buffer . block _ copy ( buf , offset , buf , offset + auth _ bytes , len ) ; buffer . block _ copy ( hash , 0 , buf , offset + clen _ bytes , hash _ bytes ) ; byte [ ] clen = bit _ converter . get _ bytes ( ( ushort ) ip _ address . host _ to _ network _ order ( ( short ) len ) ) ; buffer . block _ copy ( clen , 0 , buf , offset , clen _ bytes ) ;
len + = auth _ bytes ; offset + = len ; } public override void encrypt ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength )
if ( onetime _ auth ) { int head _ len = ss _ headlen ( buf , length ) ; int len = length - head _ len ; buffer . block _ copy ( buf , head _ len , buf , head _ len + onetimeauth _ bytes , len ) ; buf [ 0 ] | = onetimeauth _ flag ; byte [ ] auth = new byte [ onetimeauth _ bytes ] ; ss _ onetimeauth ( auth , buf , head _ len ) ; buffer . block _ copy ( auth , 0 , buf , head _ len , onetimeauth _ bytes ) ; int offset = head _ len + onetimeauth _ bytes ; ss _ gen _ hash ( buf , ref offset , ref len , buf . length ) ; length = head _ len + onetimeauth _ bytes + len ; }
if ( onetime _ auth ) { int offset = 0 ; ss _ gen _ hash ( buf , ref offset , ref length , buf . length ) ;
i _ encryptor encryptor = encryptor _ factory . get _ encryptor ( server . method , server . password ) ; byte [ ] data _ in = new byte [ length - NUM ] ;
byte [ ] data _ out = new byte [ length - NUM + NUM ] ;
encryptor . encrypt ( data _ in , data _ in . length , data _ out , out outlen ) ; remote . send _ to ( data _ out , remote _ end _ point ) ;
this . table _ layout _ panel = new system . windows . forms . table _ layout _ panel ( ) ;
this . table _ layout _ panel . suspend _ layout ( ) ;
this . client _ size = new system . drawing . size ( NUM , NUM ) ; this . controls . add ( this . table _ layout _ panel ) ;
this . table _ layout _ panel . resume _ layout ( false ) ; this . table _ layout _ panel . perform _ layout ( ) ;
load _ configuration ( modified _ hotkey _ config ) ; } private void load _ configuration ( hotkey _ config config )
if ( ! register _ all _ hotkeys ( out ) )
register _ all _ hotkeys ( out ) ; } private bool register _ all _ hotkeys ( out string failure _ info _ str )
string _ builder failure _ info = new string _ builder ( ) ;
failure _ info . append _ line ( tb . text ) ; } } failure _ info _ str = failure _ info . to _ string ( ) ;
running _ port = get _ free _ port ( ) ;
privoxy _ config = privoxy _ config . replace ( STR , configuration . share _ over _ lan ? STR : STR ) ;
private int get _ free _ port ( )
tcp _ listener l = new tcp _ listener ( ip _ address . loopback , 0 ) ;
public end _ point remote _ end _ point = new ip _ end _ point ( ip _ address . any , 0 ) ;
tcp _ socket = new socket ( address _ family . inter _ network , socket _ type . stream , protocol _ type . tcp ) ; udp _ socket = new socket ( address _ family . inter _ network , socket _ type . dgram , protocol _ type . udp ) ;
? new ip _ end _ point ( ip _ address . any , config . local _ port ) : new ip _ end _ point ( ip _ address . loopback , config . local _ port ) ;
udp _ state udp _ state = new udp _ state ( ) ; udp _ state . socket = udp _ socket ;
end _ point remote _ end _ point = new ip _ end _ point ( ip _ address . any , 0 ) ;
end _ point remote _ end _ point = new ip _ end _ point ( ip _ address . any , 0 ) ;
try { int bytes _ read = udp _ socket . end _ receive _ from ( ar , ref state . remote _ end _ point ) ;
if ( service . handle ( state . buffer , bytes _ read , udp _ socket , state ) )
public void save _ config ( configuration new _ config ) { configuration . save ( new _ config ) ;  config = configuration . load ( ) ; pac _ server . stop ( ) ; local . stop ( ) ;     polipo _ runner . stop ( ) ; polipo _ runner . start ( config ) ; local = new local ( config ) ; local . start ( ) ; pac _ server . start ( config ) ; if ( config _ changed ! = null ) { config _ changed ( this , new event _ args ( ) ) ; } }
public string get _ qr _ code _ for _ current _ server ( )
remote . end _ connect ( async _ result ) ;
remote . begin _ send ( buffer , offset , size , socket _ flags , callback , state ) ;
remote . begin _ receive ( buffer , offset , size , socket _ flags , callback , state ) ;
remote . begin _ send ( buffer , offset , size , socket _ flags , callback , state ) ;
remote . begin _ receive ( buffer , offset , size , socket _ flags , callback , state ) ;
remote . send _ to ( data _ out , outlen , socket _ flags . none , remote _ end _ point ) ;
remote . begin _ receive _ from ( buffer , 0 , buffer . length , 0 , ref remote _ end _ point , new async _ callback ( recv _ from _ callback ) , null ) ;
local . send _ to ( send _ buf , outlen + NUM , 0 , local _ end _ point ) ;
using system _ text ;
using ( var process = new process ( ) )
process . start _ info . file _ name = utils . get _ temp _ path ( STR ) ; process . start _ info . arguments = arguments ; process . start _ info . working _ directory = utils . get _ temp _ path ( ) ; process . start _ info . window _ style = process _ window _ style . hidden ; process . start _ info . use _ shell _ execute = false ; process . start _ info . redirect _ standard _ error = true ; process . start _ info . redirect _ standard _ output = true ;  process . start _ info . standard _ output _ encoding = encoding . unicode ; process . start _ info . standard _ error _ encoding = encoding . unicode ; process . start _ info . create _ no _ window = true ; process . start ( ) ; var stderr = process . standard _ error . read _ to _ end ( ) ; var stdout = process . standard _ output . read _ to _ end ( ) ; process . wait _ for _ exit ( ) ; var exit _ code = process . exit _ code ; if ( exit _ code ! = ( int ) ret _ errors . ret _ no _ error )
throw new proxy _ exception ( stderr ) ; } if ( arguments = = STR ) { if ( stdout . is _ null _ or _ white _ space ( ) | | stdout . is _ null _ or _ empty ( ) )
throw new proxy _ exception ( STR ) ;
query _ str = stdout ;
menu _ item item = new menu _ item ( n . get _ string ( strategy . name ) ) ;
item . tag = i ;
get { return STR ; }
get { return STR ; }
void update _ latency ( server server ) ;
this . remarks _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . remarks _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;
this . label . location = new system . drawing . point ( NUM , NUM ) ; this . label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ;
this . label . location = new system . drawing . point ( NUM , NUM ) ; this . label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ;
this . label . location = new system . drawing . point ( NUM , NUM ) ; this . label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ;
this . proxy _ port _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . proxy _ port _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;
this . label . location = new system . drawing . point ( NUM , NUM ) ; this . label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ;
this . label . location = new system . drawing . point ( NUM , NUM ) ; this . label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ;
this . ip _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . ip _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;
this . server _ port _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . server _ port _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;
this . password _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . password _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;
this . label . location = new system . drawing . point ( NUM , NUM ) ; this . label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ;
this . encryption _ select . location = new system . drawing . point ( NUM , NUM ) ; this . encryption _ select . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;
this . panel . location = new system . drawing . point ( NUM , NUM ) ; this . panel . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;
this . ok _ button . location = new system . drawing . point ( NUM , NUM ) ; this . ok _ button . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;
this . my _ cancel _ button . location = new system . drawing . point ( NUM , NUM ) ; this . my _ cancel _ button . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;
this . auto _ startup ,
this . servers _ item ,
this . edit _ pac _ file _ item ,
this . context _ menu . popup + = new system . event _ handler ( this . context _ menu _ popup ) ;
this . share _ over _ lan _ item . index = 2 ;
this . servers _ item . index = NUM ;
this . delete _ button . location = new system . drawing . point ( NUM , NUM ) ; this . delete _ button . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;
this . add _ button . location = new system . drawing . point ( NUM , NUM ) ; this . add _ button . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;
this . server _ group _ box . location = new system . drawing . point ( NUM , NUM ) ; this . server _ group _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;
this . server _ group _ box . padding = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . server _ group _ box . size = new system . drawing . size ( NUM , NUM ) ;
this . servers _ list _ box . item _ height = NUM ; this . servers _ list _ box . location = new system . drawing . point ( NUM , NUM ) ; this . servers _ list _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;
this . auto _ startup . index = 1 ; this . auto _ startup . text = STR ; this . auto _ startup . click + = new system . event _ handler ( this . auto _ startup _ click ) ;
private void auto _ startup _ click ( object sender , event _ args e ) { auto _ startup . checked = ! auto _ startup . checked ; if ( ! auto _ startup . set ( auto _ startup . checked ) ) {
private void context _ menu _ popup ( object sender , event _ args e ) { auto _ startup . checked = auto _ startup . check ( ) ; }
system . diagnostics . process . start ( update _ checker . latest _ version _ url ) ;
using shadowsocks _ model ; using system ;
web _ client http = new web _ client ( ) ; http . headers . add ( STR , STR ) ; http . proxy = new web _ proxy ( ip _ address . loopback . to _ string ( ) , config . local _ port ) ; http . download _ string _ completed + = http _ download _ string _ completed ; http . download _ string _ async ( new uri ( update _ url ) ) ; } public static int compare _ version ( string l , string r ) { var ls = l . split ( '.' ) ; var rs = r . split ( '.' ) ; for ( int i = 0 ; i < math . max ( ls . length , rs . length ) ; i + + )
int lp = ( i < ls . length ) ? int . parse ( ls [ i ] ) : 0 ; int rp = ( i < rs . length ) ? int . parse ( rs [ i ] ) : 0 ; if ( lp ! = rp ) { return lp - rp ; }
return 0 ; } public class version _ comparer : i _ comparer < string > {  public int compare ( string x , string y )
return compare _ version ( parse _ version _ from _ url ( x ) , parse _ version _ from _ url ( y ) ) ;
} private static string parse _ version _ from _ url ( string url ) { match match = regex . match ( url , STR , regex _ options . ignore _ case ) ; if ( match . success ) { if ( match . groups . count = = 2 ) { return match . groups [ 1 ] . value ; } } return null ; } private void sort _ versions ( list < string > versions ) { versions . sort ( new version _ comparer ( ) ) ; } private bool is _ new _ version ( string url ) { if ( url . index _ of ( STR ) > = 0 ) { return false ; } string version = parse _ version _ from _ url ( url ) ; if ( version = = null ) { return false ; } string current _ version = version ; return compare _ version ( version , current _ version ) > 0 ;
list < string > versions = new list < string > ( ) ;
string url = ( string ) asset [ STR ] ; if ( is _ new _ version ( url ) )
versions . add ( url ) ;
if ( versions . count ! = 0 )
sort _ versions ( versions ) ;
latest _ version _ url = versions [ versions . count - 1 ] ; latest _ version _ number = parse _ version _ from _ url ( latest _ version _ url ) ;
logging . debug ( ex . to _ string ( ) ) ; return ;
public void send _ response ( byte [ ] first _ packet , int length , socket socket )
string proxy = get _ pac _ address ( first _ packet , length , local _ end _ point ) ;
private string get _ pac _ address ( byte [ ] request _ buf , int length , ip _ end _ point local _ end _ point )
return STR + local _ end _ point . address + STR + this . config . local _ port + STR ;
polipo _ config = polipo _ config . replace ( STR , this . get _ free _ port ( ) . to _ string ( ) ) ;
pac _ url = $ STR ;
var servers = configuration . load ( ) ; var server _ datas = servers . configs . select (
new key _ value _ pair < string , string > ( server . url , server . to _ string ( ) )
var select _ index = server _ datas . find _ index ( server _ data = > server _ data . key . starts _ with ( code ) ) ;
public string url { get { string tag = string . empty ; string url = string . empty ; if ( string . is _ null _ or _ white _ space ( plugin ) ) {  string parts = $ STR ; string base = convert . to _ base _ string ( encoding . ut . get _ bytes ( parts ) ) ; url = base ; } else {  string parts = $ STR ; string base = convert . to _ base _ string ( encoding . ut . get _ bytes ( parts ) ) ; string websafe _ base = base . replace ( '+' , '-' ) . replace ( '/' , '_' ) . trim _ end ( '=' ) ;
url = string . format ( STR , websafe _ base , formal _ host _ name , server _ port , http _ utility . url _ encode ( plugin _ part , encoding . ut ) ) ; } if ( ! remarks . is _ null _ or _ empty ( ) ) { tag = $ STR ; } return $ STR ; }
public line _ reader ( byte [ ] buffer , wrapped _ socket socket , byte [ ] first _ packge , int index , int length ,
encoding encoding , string delimiter ,
if ( buffer = = null ) { throw new argument _ null _ exception ( nameof ( buffer ) ) ; }
if ( buffer . length < length )
throw new argument _ exception ( STR , nameof ( buffer ) ) ;
if ( buffer . length < delimiter _ bytes . length )
throw new argument _ exception ( STR , nameof ( buffer ) ) ;
line _ buffer = buffer ;
if ( buffer = = first _ packge ) { buffer _ data _ index = index ; } else { array . copy ( first _ packge , index , line _ buffer , 0 , length ) ; }
socket . begin _ receive ( line _ buffer , 0 , line _ buffer . length , 0 , receive _ callback , 0 ) ;
public line _ reader ( int max _ line _ bytes , wrapped _ socket socket , func < string , object , bool > on _ line _ read , action < exception , object > on _ exception , action < byte [ ] , int , int , object > on _ finish , encoding encoding , string delimiter , object state ) : this ( new byte [ max _ line _ bytes ] , socket , null , 0 , 0 , on _ line _ read , on _ exception , on _ finish , encoding , delimiter , state )
win _ i _ net . set _ ie _ proxy ( true , true , STR + config . local _ port . to _ string ( ) , STR ) ;
ss _ url _ association = registry . current _ user . create _ sub _ key ( STR , registry _ key _ permission _ check . read _ write _ sub _ tree ) ;
var json = STR ; var result = simple _ json . simple _ json . deserialize _ object < list < int > > ( json ) ;
configuration config = simple _ json . simple _ json . deserialize _ object < configuration > ( config _ content ) ;
qr _ code _ cs . options options = new qr _ code _ cs . options ( ) ; options . text = qr _ text ; qr _ code _ cs . qr _ code qr _ coded = null ; bool success = false ; foreach ( var level in new qr _ error _ correct _ level [ ] { qr _ error _ correct _ level . h , qr _ error _ correct _ level . q , qr _ error _ correct _ level . m , qr _ error _ correct _ level . l } ) { for ( int i = NUM ; i < NUM ; i + + ) { try { options . type _ number = i ; options . correct _ level = level ; qr _ coded = new qr _ code _ cs . qr _ code ( options ) ; qr _ coded . make ( ) ; success = true ; break ; } catch { qr _ coded = null ; continue ; } } if ( success ) break ; } if ( qr _ coded = = null ) { return ; } int block _ size = math . max ( NUM / qr _ coded . get _ module _ count ( ) , 1 ) ; bitmap draw _ area = new bitmap ( ( qr _ coded . get _ module _ count ( ) * block _ size ) , ( qr _ coded . get _ module _ count ( ) * block _ size ) ) ;
for ( int row = 0 ; row < qr _ coded . get _ module _ count ( ) ; row + + )
for ( int col = 0 ; col < qr _ coded . get _ module _ count ( ) ; col + + )
if ( qr _ coded . is _ dark ( row , col ) )
menu _ item result = new menu _ item ( n . get _ string ( text ) , click ) ; return result ; } private menu _ item create _ seperator _ item ( ) { menu _ item result = new menu _ item ( STR ) ; return result ;
for ( int i = 0 ; i < items . length ; i + + ) { items [ i ] . index = i ; } menu _ item result = new menu _ item ( n . get _ string ( text ) , items ) ; return result ;
this . seperator _ item = create _ seperator _ item ( ) ,
create _ seperator _ item ( ) ,
create _ seperator _ item ( ) ,
create _ seperator _ item ( ) ,
public static list < string > parse _ result ( string response )
arguments = STR + proxy _ server ;
arguments = STR + pac _ url ;
load _ tray _ icon ( ) ; this . controller = controller ;
this . enable _ item . text = STR ;
this . mode _ item . text = STR ;
this . pac _ mode _ item . text = STR ;
this . global _ mode _ item . text = STR ;
this . servers _ item . text = STR ;
this . config _ item . text = STR ;
this . auto _ startup _ item . text = STR ;
this . share _ over _ lan _ item . text = STR ;
this . edit _ pac _ file _ item . text = STR ;
this . qr _ code _ item . text = STR ;
this . show _ log _ item . text = STR ;
this . about _ item . text = STR ;
this . quit _ item . text = STR ;
this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ;
this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ;
this . label = new system . windows . forms . label ( ) ;
this . table _ layout _ panel . controls . add ( this . label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , 0 ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , 1 ) ;
this . table _ layout _ panel . controls . add ( this . label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , 2 ) ;
this . table _ layout _ panel . controls . add ( this . label , 0 , NUM ) ;
this . label . anchor = system . windows . forms . anchor _ styles . right ; this . label . auto _ size = true ; this . label . location = new system . drawing . point ( NUM , NUM ) ; this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ; this . label . tab _ index = NUM ; this . label . text = STR ;    this . label . anchor = system . windows . forms . anchor _ styles . right ; this . label . auto _ size = true ; this . label . location = new system . drawing . point ( NUM , NUM ) ; this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ; this . label . tab _ index = 0 ; this . label . text = STR ;    this . label . anchor = system . windows . forms . anchor _ styles . right ; this . label . auto _ size = true ; this . label . location = new system . drawing . point ( NUM , NUM ) ; this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ; this . label . tab _ index = 1 ; this . label . text = STR ;
this . label . anchor = system . windows . forms . anchor _ styles . right ; this . label . auto _ size = true ; this . label . location = new system . drawing . point ( NUM , NUM ) ; this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ; this . label . tab _ index = NUM ; this . label . text = STR ;    this . label . anchor = system . windows . forms . anchor _ styles . right ; this . label . auto _ size = true ; this . label . location = new system . drawing . point ( NUM , NUM ) ; this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ; this . label . tab _ index = 2 ; this . label . text = STR ;
private system . windows . forms . label label ; private system . windows . forms . label label ; private system . windows . forms . label label ; private system . windows . forms . label label ;
private system . windows . forms . label label ;
modified _ configuration . configs . add ( curr _ server ) ;
servers _ list _ box . selected _ index = modified _ configuration . configs . count - 1 ;
file _ manager . uncompress _ file ( dll _ path , resources . polarssl _ dll ) ;
catch ( io _ exception e )
load _ library ( dll _ path ) ;
internal static byte [ ] libsodium _ dll {
object obj = resource _ manager . get _ object ( STR , resource _ culture ) ; return ( ( byte [ ] ) ( obj ) ) ; } }    internal static byte [ ] polarssl _ dll { get { object obj = resource _ manager . get _ object ( STR , resource _ culture ) ;
file _ manager . uncompress _ file ( dll _ path , resources . libsodium _ dll ) ;
catch ( io _ exception e )
load _ library ( dll _ path ) ;
log _ message _ text _ box . word _ wrap = wrap _ text _ check _ box . checked = wrap _ text _ menu _ item . checked = wrap _ text _ trigger ; toolbar _ flow _ layout _ panel . visible = toolbar _ trigger ;
headers . enqueue ( line ) ;
headers . enqueue ( STR ) ;
} if ( ! line . starts _ with ( STR ) ) { headers . enqueue ( line ) ;
try
var key = keymap . first ( x = > x . value = = cb ) . key ; hotkey = key ;
catch ( invalid _ operation _ exception )
private void text _ box _ text _ changed ( object sender , event _ args e ) { var tb = ( text _ box ) sender ; if ( tb . text = = STR ) {  unreg _ hotkey ( tb ) ; } } private void unreg _ hotkey ( text _ box tb ) { hot _ keys . hot _ key _ call _ back _ handler call _ back ; label lb ; prepare _ for _ hotkey ( tb , out call _ back , out lb ) ; unreg _ prev _ hotkey ( call _ back ) ; }
if ( ! register _ all _ hotkeys ( ) )
register _ all _ hotkeys ( ) ; } private bool register _ all _ hotkeys ( ) {        bool is _ success = true ; foreach ( var tb in all _ text _ boxes ) { if ( tb . text . is _ null _ or _ empty ( ) )  { continue ; } if ( ! try _ reg _ hotkey ( tb ) )  { is _ success = false ; } } return is _ success ; } private bool try _ reg _ hotkey ( text _ box tb ) { var hotkey = hot _ keys . str _ hot _ key ( tb . text ) ; if ( hotkey = = null ) { message _ box . show ( string . format ( n . get _ string ( STR ) , tb . text ) ) ; tb . clear ( ) ; return false ; } hot _ keys . hot _ key _ call _ back _ handler call _ back ; label lb ; prepare _ for _ hotkey ( tb , out call _ back , out lb ) ; unreg _ prev _ hotkey ( call _ back ) ;          bool reg _ result = hot _ keys . register ( hotkey , call _ back ) ; lb . back _ color = reg _ result ? color . green : color . yellow ; return reg _ result ;
private void prepare _ for _ hotkey ( text _ box tb , out hot _ keys . hot _ key _ call _ back _ handler cb , out label lb ) {  * xxx : the label _ name , text _ box _ name and callback _ name * must follow this rule to make use of reflection * * < base _ name > < control - type - name > * / if ( tb = = null ) throw new argument _ null _ exception ( nameof ( tb ) ) ; var pos = tb . name . last _ index _ of ( STR , string _ comparison . ordinal _ ignore _ case ) ; var raw _ name = tb . name . substring ( 0 , pos ) ; var label _ name = raw _ name + STR ; var callback _ name = raw _ name + STR ; var callback = hotkey _ callbacks . get _ callback ( callback _ name ) ; if ( callback = = null ) { throw new exception ( $ STR ) ; } cb = callback as hot _ keys . hot _ key _ call _ back _ handler ; var label = get _ field _ via _ name ( get _ type ( ) , label _ name , this ) ; if ( label = = null ) { throw new exception ( $ STR ) ; } lb = label as label ; }        private static object get _ field _ via _ name ( type type , string name , object obj ) { if ( type = = null ) throw new argument _ null _ exception ( nameof ( type ) ) ; if ( name . is _ null _ or _ empty ( ) ) throw new argument _ exception ( nameof ( name ) ) ;  field _ info fi = type . get _ field ( name , binding _ flags . non _ public | binding _ flags . instance | binding _ flags . ignore _ case | binding _ flags . static ) ; return fi = = null ? null : fi . get _ value ( obj ) ; }
this . switch _ system _ proxy _ text _ box . text _ changed + = new system . event _ handler ( this . text _ box _ text _ changed ) ;
this . switch _ proxy _ mode _ text _ box . text _ changed + = new system . event _ handler ( this . text _ box _ text _ changed ) ;
this . switch _ allow _ lan _ text _ box . text _ changed + = new system . event _ handler ( this . text _ box _ text _ changed ) ;
this . show _ logs _ text _ box . text _ changed + = new system . event _ handler ( this . text _ box _ text _ changed ) ;
this . server _ move _ up _ text _ box . text _ changed + = new system . event _ handler ( this . text _ box _ text _ changed ) ;
this . server _ move _ down _ text _ box . text _ changed + = new system . event _ handler ( this . text _ box _ text _ changed ) ;
public tcp _ relay ( shadowsocks _ controller controller )
public socket remote ;
private bool connected ;
logging . debug ( remote , recv _ size , STR ) ;
logging . debug ( remote , recv _ size , STR ) ;
remote = new socket ( ip _ address . address _ family , socket _ type . stream , protocol _ type . tcp ) ; remote . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ;
connect _ timer . elapsed + = connect _ timer _ elapsed ;
connected = false ;
remote . begin _ connect ( remote _ ep , new async _ callback ( connect _ callback ) , connect _ timer ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; } } private void connect _ timer _ elapsed ( object sender , elapsed _ event _ args e ) { if ( connected )
timer . elapsed - = connect _ timer _ elapsed ;
remote . end _ connect ( ar ) ; connected = true ; logging . debug ( $ STR ) ;
public string name ; public int key _ size ; public int iv _ size ; public int type ; public encryptor _ info ( string name , int key _ size , int iv _ size , int type )
this . name = name ; this . key _ size = key _ size ; this . iv _ size = iv _ size ; this . type = type ;
string temp _ path = path . get _ temp _ path ( ) ; string dll _ path = temp _ path + STR ; try
file _ manager . uncompress _ file ( dll _ path , resources . polarssl _ dll ) ;
catch ( io _ exception e ) { console . write _ line ( e . to _ string ( ) ) ; } load _ library ( dll _ path ) ; try { file _ stream fs = new file _ stream ( STR , file _ mode . append ) ; text _ writer tmp = console . out ; stream _ writer sw = new stream _ writer ( fs ) ; sw . auto _ flush = true ; console . set _ out ( sw ) ; console . set _ error ( sw ) ; } catch ( io _ exception e ) { console . write _ line ( e . to _ string ( ) ) ; } application . enable _ visual _ styles ( ) ; application . set _ compatible _ text _ rendering _ default ( false ) ; shadowsocks _ controller controller = new shadowsocks _ controller ( ) ;  application . run ( new config _ form ( controller ) ) ;
series . color = system . drawing . color . from _ argb ( ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) , ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) , ( ( int ) ( ( ( byte ) ( 0 ) ) ) ) ) ;
series . color = system . drawing . color . from _ argb ( ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) , ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) , ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) ) ;
public const int hash _ buf _ len = NUM ;
protected byte [ ] hash _ buf ; protected int hash _ idx = 0 ;
if ( onetime _ auth ) { hash _ buf = new byte [ hash _ buf _ len ] ; }
protected int ss _ onetimeauth ( byte [ ] auth , byte [ ] msg , int msg _ len , byte [ ] iv , int iv _ len , byte [ ] key , int key _ len )
buffer . block _ copy ( iv , 0 , auth _ bytes , 0 , iv _ len ) ; buffer . block _ copy ( key , 0 , auth _ bytes , iv _ len , key _ len ) ; sodium . crypto _ generichash ( auth _ key , onetimeauth _ keybytes , auth _ bytes , ( ulong ) ( iv _ len + key _ len ) , null , 0 ) ;
protected void ss _ gen _ hash ( byte [ ] in _ buf , ref int in _ offset , ref int in _ len , byte [ ] hash _ buf , ref int hash _ idx , int buf _ size ) { int i , j ; int offset = in _ offset ; int blen = in _ len ; int cidx = hash _ idx ; int size = ( blen / hash _ buf _ len + 1 ) * hash _ bytes + blen ;
for ( i = 0 , j = offset ; i < blen ; i + + , j + + ) { if ( cidx = = hash _ buf _ len ) { sodium . crypto _ generichash ( hash , hash _ bytes , hash _ buf , hash _ buf _ len , null , 0 ) ; buffer . block _ copy ( in _ buf , j , in _ buf , j + hash _ bytes , blen - i ) ; buffer . block _ copy ( hash , 0 , in _ buf , j , hash _ bytes ) ; j + = hash _ bytes ; cidx = 0 ; } hash _ buf [ cidx ] = in _ buf [ j ] ; cidx + + ; } in _ offset = j ; in _ len = j - offset ; hash _ idx = cidx ;
splash . location = new point ( ( int ) min _ x , ( int ) min _ y ) ;
splash . panel . size = new size ( ( int ) max _ x - ( int ) min _ x , ( int ) max _ y - ( int ) min _ y ) ; splash . size = splash . panel . size ;
public partial class qr _ code _ splash _ form : form
initialize _ component ( ) ;
step = 0 ;
timer . interval = NUM ;
if ( file . exists ( pac _ file ) )
return pac _ file ;
else { file _ manager . uncompress _ file ( pac _ file , resources . proxy _ pac _ txt ) ; return pac _ file ; }
if ( file . exists ( user _ rule _ file ) ) { return user _ rule _ file ; } else
return user _ rule _ file ;
return utils . un _ gzip ( resources . proxy _ pac _ txt ) ;
string gfw _ list _ url = geosite _ url ; if ( ! string . is _ null _ or _ white _ space ( config . gfw _ list _ url ) )
logger . info ( STR ) ; gfw _ list _ url = config . gfw _ list _ url ;
logger . info ( $ STR ) ;
bool pac _ file _ changed = merge _ and _ write _ pac _ file ( ) ;
http . download _ data _ async ( new uri ( gfw _ list _ url ) ) ;
public static bool merge _ and _ write _ pac _ file ( )
return merge _ and _ write _ pac _ file ( geosites [ STR ] ) ; } private static bool merge _ and _ write _ pac _ file ( i _ list < domain _ object > domains ) { string abp _ content = merge _ pac _ file ( domains ) ;
userrule _ lines = parse _ to _ valid _ list ( userrules _ string ) ;
list < string > gfw _ lines = parse _ to _ valid _ list ( domains ) ;
private static list < string > parse _ to _ valid _ list ( string content )
private static list < string > parse _ to _ valid _ list ( i _ list < domain _ object > domains )
list < string > ret = new list < string > ( domains . count + NUM ) { STR } ;
ret . add ( $ STR ) ;
public pac _ daemon ( )
geosite _ updater . merge _ and _ write _ pac _ file ( ) ;
public static registry _ key open _ user _ reg _ key ( string name , bool writable )
registry _ key user _ key = registry _ key . open _ base _ key ( registry _ hive . current _ user ,
inbound _ counter + = n ;
outbound _ counter + = n ;
config = config . load ( ) ;
polipo _ runner . start ( config ) ; local = new local ( config ) ;
public void save _ config ( config new _ config )
config . save ( new _ config ) ;
polipo _ runner . start ( config ) ; local = new local ( config ) ;
public config get _ config ( )
config config = controller . get _ config ( ) ; text _ box . text = config . server ; text _ box . text = config . server _ port . to _ string ( ) ; text _ box . text = config . password ; text _ box . text = config . local _ port . to _ string ( ) ; combo _ box . text = config . method = = null ? STR : config . method ; enable _ item . checked = config . enabled ;
if ( ! controller . get _ config ( ) . is _ default )
config config = new config
method = combo _ box . text , is _ default = false
if ( ! parse _ host ( m . groups [ 2 ] . value ) )
throw new exception ( STR + line ) ;
if ( ! parse _ host ( line . substring ( NUM ) . trim ( ) ) )
throw new exception ( STR + line ) ;
if ( command ! = cmd _ connect & & command ! = cmd _ udp _ assoc ) { logging . debug ( STR + command ) ; close ( ) ; } else { if ( command = = cmd _ connect ) {
} else if ( command = = cmd _ udp _ assoc ) {
}
using system _ collections _ generic ;
using system _ linq ;
using system _ security ;
catch ( unauthorized _ access _ exception uae ) { logging . log _ useful _ exception ( uae ) ;
catch ( security _ exception se ) { logging . log _ useful _ exception ( se ) ; return null ; } catch ( argument _ exception ae ) { message _ box . show ( STR + ae . to _ string ( ) ) ;
using system ; using system _ collections _ generic ; using system _ linq ; using system _ runtime _ interop _ services ; using system _ text ; using system _ threading _ tasks ;
public static class ras
using shadowsocks _ model ; using shadowsocks _ properties ; using shadowsocks _ util ; using system ;
using system _ collections _ generic ; using system _ diagnostics ;
using system _ i _ compression ;
public static string pac _ file = STR ; public static string user _ rule _ file = STR ; public static string user _ abp _ file = STR ;
if ( file . exists ( user _ rule _ file ) )
string local = file . read _ all _ text ( user _ rule _ file , encoding . ut ) ;
if ( file . exists ( user _ abp _ file ) )
abp _ content = file . read _ all _ text ( user _ abp _ file , encoding . ut ) ;
string original = file . read _ all _ text ( pac _ file , encoding . ut ) ;
file . write _ all _ text ( pac _ file , abp _ content , encoding . ut ) ;
var reply = await ping . send _ task _ async ( server . server , timeout ) ; ret . add ( new list < key _ value _ pair < string , string > >
new key _ value _ pair < string , string > ( STR , timestamp ) , new key _ value _ pair < string , string > ( STR , server . friendly _ name ( ) ) , new key _ value _ pair < string , string > ( STR , reply ? . status . to _ string ( ) ) , new key _ value _ pair < string , string > ( STR , reply ? . roundtrip _ time . to _ string ( ) )  } ) ;
md ( input , ( uint ) input . length , output ) ;
public static extern void md ( byte [ ] input , uint ilen , byte [ ] output ) ;
class local
private bool share _ over _ lan ;  socket listener ;
share _ over _ lan = config . share _ over _ lan ;  } public void start ( ) { try {  listener = new socket ( address _ family . inter _ network , socket _ type . stream , protocol _ type . tcp ) ; listener . set _ socket _ option ( socket _ option _ level . socket , socket _ option _ name . reuse _ address , true ) ; ip _ end _ point local _ end _ point = null ; if ( share _ over _ lan ) { local _ end _ point = new ip _ end _ point ( ip _ address . any , config . local _ port ) ; } else { local _ end _ point = new ip _ end _ point ( ip _ address . loopback , config . local _ port ) ; }  listener . bind ( local _ end _ point ) ; listener . listen ( NUM ) ;  console . write _ line ( STR ) ; listener . begin _ accept ( new async _ callback ( accept _ callback ) , listener ) ; } catch ( socket _ exception ) { listener . close ( ) ; throw ; } } public void stop ( ) { listener . close ( ) ; } public void accept _ callback ( i _ async _ result ar ) { socket listener = ( socket ) ar . async _ state ; try { socket conn = listener . end _ accept ( ar ) ; conn . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; handler handler = new handler ( ) ; handler . connection = conn ; server server = config . get _ current _ server ( ) ; handler . encryptor = encryptor _ factory . get _ encryptor ( server . method , server . password ) ; handler . server = server ; handler . start ( ) ; } catch {  } finally { try { listener . begin _ accept ( new async _ callback ( accept _ callback ) , listener ) ; } catch {  } }
connection . begin _ receive ( connetion _ recv _ buffer , 0 , NUM , 0 , new async _ callback ( handshake _ receive _ callback ) , null ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; this . close ( ) ; } } private void handshake _ receive _ callback ( i _ async _ result ar ) { if ( closed ) { return ; } try { int bytes _ read = connection . end _ receive ( ar ) ;
if ( connetion _ recv _ buffer [ 0 ] ! = NUM )
if ( local ! = null ) { local . stop ( ) ;
local = new local ( config ) ; local . start ( ) ;
this . value _ label . size = new system . drawing . size ( 0 , NUM ) ;
const string api = STR ; var ret = new data _ list
return ret ;
if ( ! simple _ json . simple _ json . try _ deserialize _ object ( json _ string , out obj ) ) return ret ;
string region _ name = obj [ STR ] ; if ( country = = null | | city = = null | | isp = = null | | region _ name = = null ) return ret ; ret [ 0 ] = new data _ unit ( state . geolocation , $ STR ) ; ret [ 1 ] = new data _ unit ( state . isp , isp ) ; return ret ;
private void load _ chart _ data ( string server _ name )
foreach ( var data in statistics )
data _ table . rows . add ( data . timestamp , ( float ) new random ( ) . next ( ) % NUM , new random ( ) . next ( ) % NUM ) ;
load _ chart _ data ( servers [ server _ selector . selected _ index ] ) ;
this . server _ selector = new system . windows . forms . combo _ box ( ) ;
this . group _ box . suspend _ layout ( ) ;
this . server _ selector . formatting _ enabled = true ; this . server _ selector . location = new system . drawing . point ( NUM , NUM ) ; this . server _ selector . name = STR ; this . server _ selector . size = new system . drawing . size ( NUM , NUM ) ; this . server _ selector . tab _ index = NUM ; this . server _ selector . selected _ index _ changed + = new system . event _ handler ( this . server _ selector _ selected _ index _ changed ) ;
this . group _ box . resume _ layout ( false ) ; this . group _ box . perform _ layout ( ) ;
create _ menu _ item ( STR , new event _ handler ( this . scan _ qr _ code _ item _ click ) )
registry . set _ value ( STR , STR + config . local _ port . to _ string ( ) + STR + get _ timestamp ( date _ time . now ) ) ;
if ( system . io . file . exists ( update _ checker . latest _ version _ local _ name ) )
system . diagnostics . process . start ( STR , argument ) ;
using system _ reflection ;
private static readonly string statistics _ files _ name = STR ; private static readonly string delimiter = STR ; private static readonly int timeout = NUM ; private static readonly int repeat = NUM ; private static readonly int interval = NUM * NUM * NUM ; private timer timer = null ; private state state = null ; private list < server > servers ;
string temppath = path . get _ temp _ path ( ) ;
if ( timer ? . change ( 0 , interval ) = = null ) { state = new state ( ) ; timer = new timer ( evaluate , state , 0 , interval ) ; }
ping ping = new ping ( ) ; state state = ( state ) obj ; foreach ( var server in servers )
string timestamp = date _ time . now . to _ string ( STR ) ;
ping _ reply reply = ping . send ( server . server , timeout ) ; state . data = new list < key _ value _ pair < string , string > > ( ) ; state . data . add ( new key _ value _ pair < string , string > ( STR , timestamp ) ) ; state . data . add ( new key _ value _ pair < string , string > ( STR , server . friendly _ name ( ) ) ) ; state . data . add ( new key _ value _ pair < string , string > ( STR , reply . status . to _ string ( ) ) ) ; state . data . add ( new key _ value _ pair < string , string > ( STR , reply . roundtrip _ time . to _ string ( ) ) ) ;
string data _ line = string . join ( delimiter , data . select ( kv = > kv . value ) . to _ array ( ) ) ;
string header _ line = string . join ( delimiter , data . select ( kv = > kv . key ) . to _ array ( ) ) ; lines = new string [ ] { header _ line , data _ line } ;
lines = new string [ ] { data _ line } ;
using n _ log ; using system ;
class tcp _ relay : listener . service
private static logger logger = log _ manager . get _ current _ class _ logger ( ) ; private shadowsocks _ controller controller ;
private configuration config ;
class async _ session
class async _ session < t > : async _ session
private static logger logger = log _ manager . get _ current _ class _ logger ( ) ;
private shadowsocks _ controller controller ; private proxy _ config config ; private socket connection ;
private byte [ ] remote _ recv _ buffer = new byte [ buffer _ size ] ;
private byte [ ] connetion _ recv _ buffer = new byte [ buffer _ size ] ;
private byte [ ] remote _ send _ buffer = new byte [ buffer _ size ] ;
private byte [ ] connetion _ send _ buffer = new byte [ buffer _ size ] ;
this . server = server ;
if ( closed ) return ;
} catch ( exception e ) { logger . log _ useful _ exception ( e ) ; close ( ) ;
if ( closed ) return ;
handshake _ receive _ callback , null ) ; } catch ( exception e ) { logger . log _ useful _ exception ( e ) ; close ( ) ; } } private void handshake _ receive _ callback ( i _ async _ result ar ) { if ( closed ) return ;
logger . log _ useful _ exception ( e ) ; close ( ) ; } } private void response _ callback ( i _ async _ result ar )
logger . log _ useful _ exception ( e ) ; close ( ) ;
if ( closed ) return ;
var states = ( object [ ] ) ar . async _ state ;
var on _ success = ( action ) states [ 1 ] ;
} } catch ( exception e ) { logger . log _ useful _ exception ( e ) ; close ( ) ;
logger . log _ useful _ exception ( e ) ; close ( ) ;
var timer = ( proxy _ timer ) sender ;
var proxy = timer . session . remote ;
var session = ( async _ session < proxy _ timer > ) ar . async _ state ;
var dest _ end _ point = timer . dest _ end _ point ; var server = timer . server ;
var remote = session . remote ;
logger . log _ useful _ exception ( e ) ; close ( ) ;
var timer = ( server _ timer ) sender ;
var session = timer . session ;
if ( closed ) return ; try { var session = ( async _ session < server _ timer > ) ar . async _ state ;
var remote = session . remote ;
var latency = date _ time . now - start _ connect _ time ;
logger . log _ useful _ exception ( e ) ; close ( ) ;
var size = connection . receive ( connetion _ recv _ buffer , first _ packet _ length , available ,
if ( closed ) return ;
logger . log _ useful _ exception ( e ) ; close ( ) ;
if ( closed ) return ; try { var session = ( async _ session ) ar . async _ state ;
logger . log _ useful _ exception ( e ) ; close ( ) ;
if ( closed ) return ;
var session = ( async _ session ) ar . async _ state ; var remote = session . remote ;
logger . log _ useful _ exception ( e ) ; close ( ) ;
var container = ( object [ ] ) ar . async _ state ; var session = ( async _ session ) container [ 0 ] ; var bytes _ should _ send = ( int ) container [ 1 ] ; var bytes _ sent = connection . end _ send ( ar ) ; var bytes _ remaining = bytes _ should _ send - bytes _ sent ;
private menu _ item menu _ item ;
private menu _ item menu _ item ;
private menu _ item menu _ item ;
this . enable _ item = new system . windows . forms . menu _ item ( ) ; this . mode _ item = new system . windows . forms . menu _ item ( ) ; this . pac _ mode _ item = new system . windows . forms . menu _ item ( ) ; this . global _ mode _ item = new system . windows . forms . menu _ item ( ) ; this . auto _ startup _ item = new system . windows . forms . menu _ item ( ) ; this . share _ over _ lan _ item = new system . windows . forms . menu _ item ( ) ; this . servers _ item = new system . windows . forms . menu _ item ( ) ; this . seperator _ item = new system . windows . forms . menu _ item ( ) ; this . config _ item = new system . windows . forms . menu _ item ( ) ; this . menu _ item = new system . windows . forms . menu _ item ( ) ; this . edit _ pac _ file _ item = new system . windows . forms . menu _ item ( ) ; this . qr _ code _ item = new system . windows . forms . menu _ item ( ) ; this . show _ log _ item = new system . windows . forms . menu _ item ( ) ; this . about _ item = new system . windows . forms . menu _ item ( ) ; this . menu _ item = new system . windows . forms . menu _ item ( ) ; this . quit _ item = new system . windows . forms . menu _ item ( ) ; this . menu _ item = new system . windows . forms . menu _ item ( ) ;
this . menu _ item ,
this . menu _ item ,
this . menu _ item ,
this . enable _ item . index = 0 ; this . enable _ item . text = n . get _ string ( STR ) ; this . enable _ item . click + = new system . event _ handler ( this . enable _ item _ click ) ;    this . mode _ item . index = 1 ; this . mode _ item . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . pac _ mode _ item , this . global _ mode _ item } ) ; this . mode _ item . text = n . get _ string ( STR ) ;    this . pac _ mode _ item . index = 0 ; this . pac _ mode _ item . text = n . get _ string ( STR ) ; this . pac _ mode _ item . click + = new system . event _ handler ( this . pac _ mode _ item _ click ) ;    this . global _ mode _ item . index = 1 ; this . global _ mode _ item . text = n . get _ string ( STR ) ; this . global _ mode _ item . click + = new system . event _ handler ( this . global _ mode _ item _ click ) ;    this . servers _ item . index = 2 ; this . servers _ item . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . seperator _ item , this . config _ item } ) ; this . servers _ item . text = n . get _ string ( STR ) ;    this . seperator _ item . index = 0 ; this . seperator _ item . text = STR ;    this . config _ item . index = 1 ; this . config _ item . text = n . get _ string ( STR ) ; this . config _ item . click + = new system . event _ handler ( this . config _ click ) ;    this . menu _ item . index = NUM ; this . menu _ item . text = STR ;    this . auto _ startup _ item . index = NUM ; this . auto _ startup _ item . text = n . get _ string ( STR ) ; this . auto _ startup _ item . click + = new system . event _ handler ( this . auto _ startup _ item _ click ) ;    this . share _ over _ lan _ item . index = NUM ; this . share _ over _ lan _ item . text = n . get _ string ( STR ) ; this . share _ over _ lan _ item . click + = new system . event _ handler ( this . share _ over _ lan _ item _ click ) ;    this . edit _ pac _ file _ item . index = NUM ; this . edit _ pac _ file _ item . text = n . get _ string ( STR ) ; this . edit _ pac _ file _ item . click + = new system . event _ handler ( this . edit _ pac _ file _ item _ click ) ;    this . menu _ item . index = NUM ; this . menu _ item . text = STR ;    this . qr _ code _ item . index = NUM ; this . qr _ code _ item . text = n . get _ string ( STR ) ; this . qr _ code _ item . click + = new system . event _ handler ( this . qr _ code _ item _ click ) ;    this . show _ log _ item . index = NUM ; this . show _ log _ item . text = n . get _ string ( STR ) ; this . show _ log _ item . click + = new system . event _ handler ( this . show _ log _ item _ click ) ;    this . about _ item . index = NUM ; this . about _ item . text = n . get _ string ( STR ) ; this . about _ item . click + = new system . event _ handler ( this . about _ item _ click ) ;    this . menu _ item . index = NUM ; this . menu _ item . text = STR ;    this . quit _ item . index = NUM ; this . quit _ item . text = n . get _ string ( STR ) ; this . quit _ item . click + = new system . event _ handler ( this . quit _ click ) ;
udp _ handler handler = new udp _ handler ( socket , config . get _ current _ server ( ) , ( ip _ end _ point ) udp _ state . remote _ end _ point ) ;
class udp _ handler
modified _ configuration = controller . get _ configuration _ copy ( ) . proxy ; use _ proxy _ check _ box . checked = modified _ configuration . use _ proxy ; proxy _ server _ text _ box . text = modified _ configuration . proxy _ server ; proxy _ port _ text _ box . text = modified _ configuration . proxy _ port . to _ string ( ) ; proxy _ timeout _ text _ box . text = modified _ configuration . proxy _ timeout . to _ string ( ) ; proxy _ type _ combo _ box . selected _ index = modified _ configuration . proxy _ type ;
if ( use _ proxy _ check _ box . checked )
int port ; int timeout ; if ( ! int . try _ parse ( proxy _ port _ text _ box . text , out port ) )
if ( ! int . try _ parse ( proxy _ timeout _ text _ box . text , out timeout ) )
var type = proxy _ type _ combo _ box . selected _ index ; var proxy = proxy _ server _ text _ box . text ;
configuration . check _ server ( proxy ) ; configuration . check _ port ( port ) ; configuration . check _ timeout ( timeout , proxy _ config . max _ proxy _ timeout _ sec ) ;
controller . enable _ proxy ( type , proxy , port , timeout ) ;
else { controller . disable _ proxy ( ) ; }
proxy _ server _ text _ box . enabled = true ; proxy _ port _ text _ box . enabled = true ; proxy _ timeout _ text _ box . enabled = true ;
proxy _ server _ text _ box . enabled = false ; proxy _ port _ text _ box . enabled = false ; proxy _ timeout _ text _ box . enabled = false ; proxy _ type _ combo _ box . enabled = false ;
public int running _ port { get { return running _ port ; } }
server server = configuration . get _ current _ server ( ) ;
ip _ global _ properties properties = ip _ global _ properties . get _ ip _ global _ properties ( ) ; ip _ end _ point [ ] tcp _ end _ points = properties . get _ active _ tcp _ listeners ( ) ; list < int > used _ ports = new list < int > ( ) ; foreach ( ip _ end _ point end _ point in ip _ global _ properties . get _ ip _ global _ properties ( ) . get _ active _ tcp _ listeners ( ) ) { used _ ports . add ( end _ point . port ) ; } for ( int port = default _ port ; port < = NUM ; port + + ) { if ( ! used _ ports . contains ( port ) ) { return port ; } }
throw new exception ( STR ) ;
string [ ] rules = local . split ( new char [ ] { '\r' , '\n' } , string _ split _ options . remove _ empty _ entries ) ; foreach ( string rule in rules )
if ( rule [ 0 ] = = '!' | | rule [ 0 ] = = '[' ) continue ; lines . add ( rule ) ;
string [ ] lines = content . split ( new char [ ] { '\r' , '\n' } , string _ split _ options . remove _ empty _ entries ) ; list < string > valid _ lines = new list < string > ( lines . length ) ; foreach ( string line in lines )
if ( line [ 0 ] = = '!' | | line [ 0 ] = = '[' ) continue ; valid _ lines . add ( line ) ;
using shadowsocks _ view ; using system ;
public string font _ name ; public float font _ size ; public string bg _ color ; public string text _ color ;
font _ name = STR ; font _ size = NUM ; bg _ color = STR ; text _ color = STR ;
width = NUM ; height = NUM ; left = get _ best _ left ( ) ; top = get _ best _ top ( ) ; maximized = true ;
public int get _ best _ left ( )
width = ( width > = NUM ) ? width : NUM ; return screen . primary _ screen . working _ area . width - width ; } public int get _ best _ top ( ) { height = ( height > = NUM ) ? height : NUM ; return screen . primary _ screen . working _ area . height - height ; } public font get _ font ( ) { try
public void set _ font ( font font )
font _ name = font . name ; font _ size = font . size ; } public color get _ background _ color ( ) { try
return color _ translator . from _ html ( bg _ color ) ; } catch ( exception ) { return color _ translator . from _ html ( STR ) ;
public void set _ background _ color ( color color ) { bg _ color = color _ translator . to _ html ( color ) ; } public color get _ text _ color ( ) { try { return color _ translator . from _ html ( text _ color ) ; } catch ( exception ) { return color _ translator . from _ html ( STR ) ; } } public void set _ text _ color ( color color ) { text _ color = color _ translator . to _ html ( color ) ; }
controller . enable _ proxy ( proxy , port ) ;
using shadowsocks _ view ; using system ; using system _ drawing ; using system _ windows _ forms ;
this . table _ layout _ panel . controls . add ( this . table _ layout _ panel , 0 , 2 ) ;
this . table _ layout _ panel . controls . add ( this . table _ layout _ panel , 0 , 1 ) ;
this . table _ layout _ panel . row _ count = NUM ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ;  this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ;
remote ? . begin _ send ( buffer , offset , size , socket _ flags , callback , state ) ;
remote ? . begin _ receive ( buffer , offset , size , socket _ flags , callback , state ) ;
remote ? . shutdown ( how ) ;
remote ? . dispose ( ) ;
public void enable _ proxy ( string proxy , int port )
const string min _ level _ attribute = STR ; const string file _ name _ attribute = STR ;
xml _ element log _ file _ name _ element ;
log _ level _ element . set _ attribute ( min _ level _ attribute , log _ level . to _ string ( STR ) ) ;
using shadowsocks _ controller ; using shadowsocks _ model ; using shadowsocks _ properties ; using system ;
using system _ text ;
this . panel = new system . windows . forms . panel ( ) ; this . button = new system . windows . forms . button ( ) ; this . button = new system . windows . forms . button ( ) ;
this . context _ menu _ strip . suspend _ layout ( ) ;
this . context _ menu _ strip . resume _ layout ( false ) ;
private system . windows . forms . panel panel ; private system . windows . forms . button button ; private system . windows . forms . button button ;
public encryptor ( string password )
var a = bit _ converter . to _ u _ int ( hash , 0 ) ; for ( int i = 0 ; i < NUM ; i + + ) { encrypt _ table [ i ] = ( byte ) i ; } for ( int i = 1 ; i < NUM ; i + + ) { encrypt _ table = merge _ sort ( encrypt _ table , a , i ) ; } for ( int i = 0 ; i < NUM ; i + + ) { decrypt _ table [ encrypt _ table [ i ] ] = ( byte ) i ;
for ( int i = 0 ; i < length ; i + + )
buf [ i ] = encrypt _ table [ buf [ i ] ] ;
for ( int i = 0 ; i < length ; i + + )
buf [ i ] = decrypt _ table [ buf [ i ] ] ;
using system _ text ;
using system _ net ;
using shadowsocks _ controller _ strategy ; using system _ timers ;
public i _ set < handler > handlers
this . controller = controller ; this . handlers = new hash _ set < handler > ( ) ; this . last _ sweep _ time = date _ time . now ;
handler handler = new handler ( ) ;
i _ list < handler > handlers _ to _ close = new list < handler > ( ) ; lock ( this . handlers ) { this . handlers . add ( handler ) ; logging . debug ( $ STR ) ;
foreach ( handler handler in this . handlers )
foreach ( handler handler in handlers _ to _ close )
class handler
this . encryptor = encryptor _ factory . get _ encryptor ( server . method , server . password , server . auth , false ) ;
this . first _ packet = first _ packet ; this . first _ packet _ length = length ; this . handshake _ receive ( ) ; this . last _ activity = date _ time . now ;
this . close ( ) ;
logging . debug ( $ STR ) ;
logging . debug ( $ STR + response . length ) ;
this . close ( ) ; } } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; this . close ( ) ;
logging . debug ( $ STR + response . length ) ;
logging . error ( STR ) ; this . close ( ) ; } } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; this . close ( ) ;
logging . debug ( $ STR + recv _ size ) ; connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , 0 , new async _ callback ( read _ all ) , null ) ;
logging . debug ( $ STR + recv _ size ) ; connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , 0 , new async _ callback ( read _ all ) , null ) ;
this . close ( ) ; } } } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; this . close ( ) ;
if ( retry _ count < NUM ) { logging . debug ( STR ) ;
this . close ( ) ;
this . last _ activity = date _ time . now ;
logging . debug ( $ STR + bytes _ to _ send ) ;
strategy . update _ last _ read ( this . server ) ;
if ( total _ read = = 0 ) {    } } } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; this . close ( ) ;
logging . debug ( $ STR + bytes _ to _ send ) ;
strategy . update _ last _ write ( this . server ) ;
using shadowsocks _ model ; using system ;
using system _ text ;
using system _ io ; using shadowsocks _ model ; using system ;
using system _ net _ sockets ;
using system _ net ;
using shadowsocks _ properties ;
using system _ text ;
using system _ net _ sockets ; using system _ net ; using system _ runtime _ compiler _ services ; using shadowsocks _ controller _ strategy ;
using system _ collections _ generic ;
using system _ text ;
using system _ collections _ generic ; using system _ component _ model ; using system _ data ;
using system _ linq ; using system _ text ;
using system _ collections _ generic ;
using system _ text ;
private spin _ lock lock = new spin _ lock ( ) ;
bool lock _ taken = false ; try { lock . enter ( ref lock _ taken ) ; interlocked . add ( ref inbound , delta ) ; } finally { if ( lock _ taken ) { lock . exit ( false ) ; } }
bool lock _ taken = false ; try { lock . enter ( ref lock _ taken ) ; interlocked . add ( ref outbound , delta ) ; } finally { if ( lock _ taken ) { lock . exit ( false ) ; } }
bool lock _ taken = false ; try { lock . enter ( ref lock _ taken ) ; var i = interlocked . read ( ref inbound ) ; var il = interlocked . exchange ( ref last _ inbound , i ) ; inbound _ delta = i - il ; var o = interlocked . read ( ref outbound ) ; var ol = interlocked . exchange ( ref last _ outbound , o ) ; outbound _ delta = o - ol ; } finally { if ( lock _ taken ) { lock . exit ( false ) ; } }
string dest _ host { get ; } int dest _ port { get ; }
void begin _ connect _ dest ( string host , int port , async _ callback callback , object state ) ;
public void begin _ connect _ dest ( string host , int port , async _ callback callback , object state ) { dest _ host = host ; dest _ port = port ;
ip _ address ip _ address ; bool parsed = ip _ address . try _ parse ( host , out ip _ address ) ; if ( parsed ) { ip _ end _ point ep = new ip _ end _ point ( ip _ address , port ) ; switch ( ep . address _ family )
var addr = ep . address . get _ address _ bytes ( ) ;
} else {   atyp = NUM ; var enc = encoding . ut ; var host _ byte _ count = enc . get _ byte _ count ( host ) ; request = new byte [ NUM + 1 request [ NUM ] = ( byte ) host _ byte _ count ; enc . get _ bytes ( host , 0 , host . length , request , NUM ) ;
public string dest _ host { get ; private set ; } public int dest _ port { get ; private set ; }
public void begin _ connect _ dest ( string host , int port , async _ callback callback , object state )
ip _ address ip _ address ; bool parsed = ip _ address . try _ parse ( host , out ip _ address ) ; if ( ! parsed )
ip _ host _ entry ip _ host _ info = dns . get _ host _ entry ( host ) ; ip _ address = ip _ host _ info . address _ list [ 0 ] ;
ip _ end _ point remote _ ep = new ip _ end _ point ( ip _ address , port ) ; dest _ host = host ; dest _ port = port ;
remote = new socket ( remote _ ep . address _ family , socket _ type . stream , protocol _ type . tcp ) ;
remote . begin _ connect ( remote _ ep , callback , state ) ;
public log _ form ( shadowsocks _ controller controller , string filename = null )
this . filename = filename ;
namespace shadowsocks _ encryption
public class sodium _ encryptor : iv _ encryptor , i _ disposable
protected override void cipher _ update ( bool is _ cipher , int length , byte [ ] buf , byte [ ] outbuf )
if ( is _ cipher )
sodium . crypto _ stream _ salsa _ xor _ ic ( sodium _ buf , sodium _ buf , ( ulong ) ( padding + length ) , iv , ic , key ) ;
sodium . crypto _ stream _ chacha _ xor _ ic ( sodium _ buf , sodium _ buf , ( ulong ) ( padding + length ) , iv , ic , key ) ;
sodium . crypto _ stream _ chacha _ ietf _ xor _ ic ( sodium _ buf , sodium _ buf , ( ulong ) ( padding + length ) , iv , ( uint ) ic , key ) ;
if ( is _ cipher )
using system _ text ; namespace shadowsocks _ encryption
public struct encryptor _ info
protected encryptor _ base ( string method , string password , bool onetimeauth , bool isudp )
onetime _ auth = onetimeauth ; is _ udp = isudp ;
protected bool onetime _ auth ; protected bool is _ udp ; protected byte [ ] get _ password _ hash ( ) { byte [ ] input _ bytes = encoding . ut . get _ bytes ( password ) ; byte [ ] hash = mbed _ tls . m ( input _ bytes ) ; return hash ; }
public class sodium
const string dllname = STR ;
string dll _ path = utils . get _ temp _ path ( STR ) ;
catch ( exception e )
public static extern int crypto _ stream _ salsa _ xor _ ic ( byte [ ] c , byte [ ] m , ulong mlen , byte [ ] n , ulong ic , byte [ ] k ) ;
public static extern int crypto _ stream _ chacha _ xor _ ic ( byte [ ] c , byte [ ] m , ulong mlen , byte [ ] n , ulong ic , byte [ ] k ) ;
public static extern int crypto _ stream _ chacha _ ietf _ xor _ ic ( byte [ ] c , byte [ ] m , ulong mlen , byte [ ] n , uint ic , byte [ ] k ) ;
public static extern void ss _ sha _ hmac _ ex ( byte [ ] key , uint keylen , byte [ ] input , int ioff , uint ilen , byte [ ] output ) ;
rng . get _ bytes ( buf ) ;
catch ( exception )
private lru _ cache < ip _ end _ point , udp _ handler > cache ;
this . cache = new lru _ cache < ip _ end _ point , udp _ handler > ( NUM ) ;
i _ encryptor encryptor = encryptor _ factory . get _ encryptor ( server . method , server . password , server . auth , true ) ; byte [ ] data _ in = new byte [ length - NUM + iv _ encryptor . onetimeauth _ bytes ] ;
byte [ ] data _ out = new byte [ length - NUM + NUM + iv _ encryptor . onetimeauth _ bytes ] ;
encryptor . encrypt ( data _ in , length - NUM , data _ out , out outlen ) ;
public static readonly int recv _ size = NUM ; public static readonly int recv _ reserve _ size = iv _ encryptor . onetimeauth _ bytes + iv _ encryptor . auth _ bytes ; public static readonly int buffer _ size = recv _ size + recv _ reserve _ size + NUM ;
private bool proxy _ connected ; private bool dest _ connected ; private byte command ; private byte [ ] first _ packet ; private int first _ packet _ length ;    private int total _ read = 0 ; private int total _ write = 0 ;  private byte [ ] remote _ recv _ buffer = new byte [ buffer _ size ] ;    private byte [ ] remote _ send _ buffer = new byte [ buffer _ size ] ; private byte [ ] connetion _ recv _ buffer = new byte [ buffer _ size ] ; private byte [ ] connetion _ send _ buffer = new byte [ buffer _ size ] ; private bool connection _ shutdown = false ; private bool remote _ shutdown = false ; private bool closed = false ;
lock ( encryption _ lock ) { lock ( decryption _ lock ) { encryptor = encryptor _ factory . get _ encryptor ( server . method , server . password , server . auth , false ) ; } }
connection . begin _ receive ( connetion _ recv _ buffer , 0 , NUM + 2 , socket _ flags . none , new async _ callback ( handshake _ receive _ callback ) , null ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; } } private void handshake _ receive _ callback ( i _ async _ result ar )
if ( command ! = 1 & & command ! = NUM )
if ( command = = 1 )
new async _ callback ( response _ callback ) , null ) ;
else if ( command = = NUM )
case 1 : read _ address ( NUM + 2 - 1 , on _ success ) ;
case NUM :
read _ address ( len + 2 , on _ success ) ;
case NUM : read _ address ( NUM + 2 - 1 , on _ success ) ;
array . copy ( connetion _ recv _ buffer , NUM , connetion _ recv _ buffer , 0 , 2 ) ;
case 1 : dst _ addr = new ip _ address ( connetion _ recv _ buffer . skip ( 1 ) . take ( NUM ) . to _ array ( ) ) . to _ string ( ) ; dst _ port = ( connetion _ recv _ buffer [ NUM ] < < NUM ) + connetion _ recv _ buffer [ NUM ] ;
case NUM :
dst _ addr = system . text . encoding . ut . get _ string ( connetion _ recv _ buffer , 2 , len ) ; dst _ port = ( connetion _ recv _ buffer [ len + 2 ] < < NUM ) + connetion _ recv _ buffer [ len + NUM ] ;
case NUM : dst _ addr = $ STR ; dst _ port = ( connetion _ recv _ buffer [ NUM ] < < NUM ) + connetion _ recv _ buffer [ NUM ] ;
byte [ ] response = new byte [ NUM + address . length + 2 ] ;
response [ NUM ] = 1 ;
response [ NUM ] = NUM ;
connection . begin _ send ( response , 0 , response . length , socket _ flags . none , new async _ callback ( read _ all ) , true ) ;
connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , socket _ flags . none , new async _ callback ( read _ all ) , null ) ;
connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , socket _ flags . none , new async _ callback ( read _ all ) , null ) ;
end _ point proxy _ ep ;
proxy _ timer proxy _ timer = new proxy _ timer ( proxy _ timeout ) ; proxy _ timer . auto _ reset = false ; proxy _ timer . elapsed + = proxy _ connect _ timer _ elapsed ;
remote . begin _ connect _ proxy ( proxy _ ep , new async _ callback ( proxy _ connect _ callback ) , new async _ session < proxy _ timer > ( remote , proxy _ timer ) ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; } } private void proxy _ connect _ timer _ elapsed ( object sender , elapsed _ event _ args e ) { var timer = ( proxy _ timer ) sender ; timer . elapsed - = proxy _ connect _ timer _ elapsed ;
server server = null ;
server = timer . server ; timer . elapsed - = proxy _ connect _ timer _ elapsed ;
server _ timer connect _ timer = new server _ timer ( server _ timeout ) ; connect _ timer . auto _ reset = false ; connect _ timer . elapsed + = dest _ connect _ timer _ elapsed ;
remote . begin _ connect _ dest ( dest _ end _ point , new async _ callback ( connect _ callback ) , new async _ session < server _ timer > ( session , connect _ timer ) ) ;
int bytes _ to _ send ;
encryptor . decrypt ( remote _ recv _ buffer , bytes _ read , remote _ send _ buffer , out bytes _ to _ send ) ; } connection . begin _ send ( remote _ send _ buffer , 0 , bytes _ to _ send , socket _ flags . none , new async _ callback ( pipe _ connection _ send _ callback ) , session ) ;
encryptor . encrypt ( connetion _ recv _ buffer , length , connetion _ send _ buffer , out bytes _ to _ send ) ;
session . remote . begin _ send ( connetion _ send _ buffer , 0 , bytes _ to _ send , socket _ flags . none , new async _ callback ( pipe _ remote _ send _ callback ) , session ) ;
var session = ( async _ session ) ar . async _ state ; session . remote . end _ send ( ar ) ; connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , socket _ flags . none , new async _ callback ( pipe _ connection _ receive _ callback ) , session ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; } }
var session = ( async _ session ) ar . async _ state ; connection . end _ send ( ar ) ; session . remote . begin _ receive ( remote _ recv _ buffer , 0 , recv _ size , socket _ flags . none , new async _ callback ( pipe _ remote _ receive _ callback ) , session ) ;
namespace shadowsocks _ encryption
public class mbed _ tls _ encryptor : iv _ encryptor , i _ disposable
public mbed _ tls _ encryptor ( string method , string password , bool onetimeauth , bool isudp ) : base ( method , password , onetimeauth , isudp )
base . init _ cipher ( iv , is _ cipher ) ;
is _ cipher ? mbed _ tls . mbedtls _ encrypt : mbed _ tls . mbedtls _ decrypt ) ! = 0 ) throw new exception ( STR ) ;
throw new exception ( STR ) ;
throw new exception ( STR ) ;
protected override void cipher _ update ( bool is _ cipher , int length , byte [ ] buf , byte [ ] outbuf )
if ( mbed _ tls . cipher _ update ( is _ cipher ? encrypt _ ctx : decrypt _ ctx ,
throw new exception ( STR ) ;
~ mbed _ tls _ encryptor ( )
private static dictionary < string , type > registered _ encryptors ; private static type [ ] constructor _ types = new type [ ] { typeof ( string ) , typeof ( string ) , typeof ( bool ) , typeof ( bool ) } ;
registered _ encryptors = new dictionary < string , type > ( ) ; foreach ( string method in mbed _ tls _ encryptor . supported _ ciphers ( ) )
registered _ encryptors . add ( method , typeof ( mbed _ tls _ encryptor ) ) ;
foreach ( string method in sodium _ encryptor . supported _ ciphers ( ) )
registered _ encryptors . add ( method , typeof ( sodium _ encryptor ) ) ;
public static i _ encryptor get _ encryptor ( string method , string password , bool onetimeauth , bool isudp )
constructor _ info c = t . get _ constructor ( constructor _ types ) ; i _ encryptor result = ( i _ encryptor ) c . invoke ( new object [ ] { method , password , onetimeauth , isudp } ) ;
public class mbed _ tls
const string dllname = STR ;
string dll _ path = utils . get _ temp _ path ( STR ) ;
catch ( exception e )
public static extern void md ( byte [ ] input , uint ilen , byte [ ] output ) ;
public static extern int cipher _ get _ size _ ex ( ) ;
return current _ server ;
server old _ server = current _ server ;
current _ server = max . server ; if ( current _ server ! = old _ server )
console . write _ line ( STR , current _ server . friendly _ name ( ) ) ;
logging . debug ( string . format ( STR , current _ server . friendly _ name ( ) ) ) ;
this . password _ text _ box . password _ char = '*' ;
new key _ value _ pair < string , string > ( STR , get _ recent _ outbound _ speed ( server ) ) , new key _ value _ pair < string , string > ( STR , reply ? . status . to _ string ( ) ) , new key _ value _ pair < string , string > ( STR , reply ? . roundtrip _ time . to _ string ( ) )
var geolocation _ and _ isp = get _ geolocation _ and _ isp ( ) ;
append ( data _ list , geolocation _ and _ isp . result ) ;
public const string geolocation = STR ; public const string isp = STR ;
public string geolocation ; public string isp ;
encrypt _ iv _ offset = new byte [ NUM ] ;
decrypt _ iv _ offset = new byte [ NUM ] ;
encrypt _ iv _ offset = new byte [ NUM ] ;
decrypt _ iv _ offset = new byte [ NUM ] ;
polar _ ssl . aes _ crypt _ cfb ( encrypt _ ctx , polar _ ssl . aes _ encrypt , length , encrypt _ iv _ offset , encrypt _ iv , buf , tempbuf ) ;
polar _ ssl . blowfish _ crypt _ cfb ( encrypt _ ctx , polar _ ssl . blowfish _ encrypt , length , encrypt _ iv _ offset , encrypt _ iv , buf , tempbuf ) ;
polar _ ssl . aes _ crypt _ cfb ( encrypt _ ctx , polar _ ssl . aes _ encrypt , length , encrypt _ iv _ offset , encrypt _ iv , buf , outbuf ) ;
polar _ ssl . blowfish _ crypt _ cfb ( encrypt _ ctx , polar _ ssl . blowfish _ encrypt , length , encrypt _ iv _ offset , encrypt _ iv , buf , outbuf ) ;
polar _ ssl . aes _ crypt _ cfb ( decrypt _ ctx , polar _ ssl . aes _ decrypt , length - iv _ len , decrypt _ iv _ offset , decrypt _ iv , tempbuf , outbuf ) ;
polar _ ssl . blowfish _ crypt _ cfb ( decrypt _ ctx , polar _ ssl . blowfish _ decrypt , length - iv _ len , decrypt _ iv _ offset , decrypt _ iv , tempbuf , outbuf ) ;
polar _ ssl . aes _ crypt _ cfb ( decrypt _ ctx , polar _ ssl . aes _ decrypt , length , decrypt _ iv _ offset , decrypt _ iv , buf , outbuf ) ;
polar _ ssl . blowfish _ crypt _ cfb ( decrypt _ ctx , polar _ ssl . blowfish _ decrypt , length , decrypt _ iv _ offset , decrypt _ iv , buf , outbuf ) ;
this . my _ cancel _ button . margin = new system . windows . forms . padding ( NUM , NUM , 0 , 0 ) ;
using system _ collections _ generic ; using system _ component _ model ;
using system _ text ;
using system _ diagnostics ; using microsoft _ win ;
using system _ threading _ tasks ;
i _ encryptor encryptor = encryptor _ factory . get _ encryptor ( server . method , server . password , server . one _ time _ auth ) ;
encryptor . encrypt ( data _ in , length - NUM , data _ out , out outlen , true ) ;
public override void encrypt ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength , bool udp )
encrypt _ iv _ sent = true ;
if ( onetime _ auth & & iv _ len > 0 ) { if ( ! udp ) { int head _ len = get _ head _ len ( buf , length ) ; int data _ len = length - head _ len ; buf [ 0 ] | = onetimeauth _ flag ; byte [ ] hash = gen _ onetime _ auth _ hash ( buf , head _ len ) ; buffer . block _ copy ( buf , head _ len , buf , head _ len + onetimeauth _ bytes + auth _ bytes , data _ len ) ; buffer . block _ copy ( hash , 0 , buf , head _ len , onetimeauth _ bytes ) ; hash = gen _ hash ( buf , head _ len + onetimeauth _ bytes + auth _ bytes , data _ len ) ; buffer . block _ copy ( hash , 0 , buf , head _ len + onetimeauth _ bytes + clen _ bytes , onetimeauth _ bytes ) ; byte [ ] len _ bytes = bit _ converter . get _ bytes ( ( ushort ) ip _ address . host _ to _ network _ order ( ( short ) data _ len ) ) ; buffer . block _ copy ( len _ bytes , 0 , buf , head _ len + onetimeauth _ bytes , clen _ bytes ) ; length = head _ len + onetimeauth _ bytes + auth _ bytes + data _ len ; } else { buf [ 0 ] | = onetimeauth _ flag ; byte [ ] hash = gen _ onetime _ auth _ hash ( buf , length ) ; buffer . block _ copy ( hash , 0 , buf , length , onetimeauth _ bytes ) ; length + = onetimeauth _ bytes ; } }
if ( onetime _ auth & & iv _ len > 0 ) { byte [ ] hash = gen _ hash ( buf , 0 , length ) ; buffer . block _ copy ( buf , 0 , buf , auth _ bytes , length ) ; byte [ ] len _ bytes = bit _ converter . get _ bytes ( ( ushort ) ip _ address . host _ to _ network _ order ( ( short ) length ) ) ; buffer . block _ copy ( len _ bytes , 0 , buf , 0 , clen _ bytes ) ; buffer . block _ copy ( hash , 0 , buf , clen _ bytes , onetimeauth _ bytes ) ; length + = auth _ bytes ; }
protected encryptor _ base ( string method , string password , bool onetimeauth )
public abstract void encrypt ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength , bool udp ) ;
public static i _ encryptor get _ encryptor ( string method , string password , bool onetimeauth )
i _ encryptor result = ( i _ encryptor ) c . invoke ( new object [ ] { method , password , onetimeauth } ) ;
encryptor . encrypt ( plain , plain . length , cipher , out out _ len , false ) ;
encryptor . encrypt ( plain , NUM , cipher , out out _ len , false ) ;
encryptor . encrypt ( plain , NUM , cipher , out out _ len , false ) ;
this . button = new system . windows . forms . button ( ) ;
this . button . dialog _ result = system . windows . forms . dialog _ result . cancel ; this . button . location = new system . drawing . point ( NUM , NUM ) ; this . button . name = STR ; this . button . size = new system . drawing . size ( NUM , NUM ) ; this . button . tab _ index = 1 ; this . button . text = STR ; this . button . use _ visual _ style _ back _ color = true ;
private list < int > latency _ records ;
private long last _ inbound _ counter ; private list < int > inbound _ speed _ records ; private long last _ outbound _ counter ; private list < int > outbound _ speed _ records ;
private timer writer ; private readonly time _ span writing _ interval = time _ span . from _ minutes ( 1 ) ;
private server current _ server = > controller . get _ current _ server ( ) ;
start _ timer _ without _ state ( ref writer , save , writing _ interval ) ;
writer ? . dispose ( ) ;
inbound _ speed _ records = new list < int > ( ) ; outbound _ speed _ records = new list < int > ( ) ; latency _ records = new list < int > ( ) ;
var current _ server _ record = new statistics _ record ( current _ server . identifier ( ) , inbound _ speed _ records , outbound _ speed _ records , latency _ records ) ; if ( ! config . ping ) { append _ record ( current _ server , current _ server _ record ) ;
var icmp _ results = task _ ex . when _ all ( controller . get _ current _ configuration ( ) . configs . select ( icmp _ test ) ) ; foreach ( var result in ( await icmp _ results ) . where ( result = > result ! = null ) ) { if ( result . server . equals ( current _ server ) ) { current _ server _ record . set _ response ( result . roundtrip _ time ) ; append _ record ( current _ server , current _ server _ record ) ; } else { append _ record ( result . server , new statistics _ record ( result . server . identifier ( ) , result . roundtrip _ time ) ) ; } } } private void append _ record ( server server , statistics _ record record ) { list < statistics _ record > records ; if ( ! raw _ statistics . try _ get _ value ( server . identifier ( ) , out records ) ) { records = new list < statistics _ record > ( ) ; } records . add ( record ) ; raw _ statistics [ server . identifier ( ) ] = records ; } private void save ( object ) {
file . write _ all _ text ( availability _ statistics _ file , json _ convert . serialize _ object ( raw _ statistics , formatting . none ) ) ;
writer . change ( retry _ interval , writing _ interval ) ;
writer . dispose ( ) ;
public void update _ inbound _ counter ( long n )
} public void update _ outbound _ counter ( long n )
public string server _ name { get ; set ; }
public statistics _ record ( string identifier , i _ enumerable < int > inbound _ speed _ records , i _ enumerable < int > outbound _ speed _ records , i _ enumerable < int > latency _ records )
server _ name = identifier ;
server _ name = identifier ; set _ response ( response _ records ) ;
public void set _ response ( i _ enumerable < int? > response _ records )
package _ loss = response _ records . count ( response = > response ! = null ) / ( float ) response _ records . count ( ) ;
private float get _ score ( string server _ name )
list < statistics _ record > records ; if ( filtered _ statistics = = null | | ! filtered _ statistics . try _ get _ value ( server _ name , out records ) ) return 0 ; float factor ; float score = 0 ; var average _ record = new statistics _ record ( server _ name , records . find _ all ( record = > record . max _ inbound _ speed ! = null ) . select ( record = > record . max _ inbound _ speed . value ) , records . find _ all ( record = > record . max _ outbound _ speed ! = null ) . select ( record = > record . max _ outbound _ speed . value ) , records . find _ all ( record = > record . average _ latency ! = null ) . select ( record = > record . average _ latency . value ) ) ; average _ record . set _ response ( records . select ( record = > record . average _ response ) ) ; if ( ! config . calculations . try _ get _ value ( STR , out factor ) ) factor = 0 ; score + = average _ record . package _ loss * factor ? ? 0 ; if ( ! config . calculations . try _ get _ value ( STR , out factor ) ) factor = 0 ; score + = average _ record . average _ response * factor ? ? 0 ; if ( ! config . calculations . try _ get _ value ( STR , out factor ) ) factor = 0 ; score + = average _ record . min _ response * factor ? ? 0 ; if ( ! config . calculations . try _ get _ value ( STR , out factor ) ) factor = 0 ; score + = average _ record . max _ response * factor ? ? 0 ; logging . debug ( $ STR ) ;
this . binding _ configuration = new system . windows . forms . binding _ source ( this . components ) ;
this . servers _ list _ box . item _ height = NUM ;
this . label . anchor = system . windows . forms . anchor _ styles . right ; this . label . auto _ size = true ; this . label . location = new system . drawing . point ( NUM , NUM ) ; this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ; this . label . tab _ index = NUM ; this . label . text = STR ;    this . remark _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . remark _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . remark _ text _ box . name = STR ; this . remark _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . remark _ text _ box . tab _ index = NUM ; this . remark _ text _ box . word _ wrap = false ;
string line ; while ( ( line = sr . read _ line ( ) ) ! = null )
if ( line . begin _ with ( '#' ) )
private int port ;
public local ( int port ) { this . port = port ; this . encryptor = new encryptor ( STR ) ;
ip _ end _ point local _ end _ point = new ip _ end _ point ( 0 , port ) ;
ip _ host _ entry ip _ host _ info = dns . get _ host _ entry ( STR ) ;
ip _ end _ point remote _ ep = new ip _ end _ point ( ip _ address , NUM ) ;
void controller _ update _ pac _ from _ gfw _ list _ error ( object sender , system . io . error _ event _ args e )
void controller _ update _ pac _ from _ gfw _ list _ completed ( object sender , geosite _ result _ event _ args e )
update _ pac _ from _ gfw _ list _ completed ? . invoke ( this , e ) ;
update _ pac _ from _ gfw _ list _ error ? . invoke ( this , e ) ;
registry _ key registry = registry . current _ user . open _ sub _ key ( STR , true ) ; registry . set _ value ( STR , 0 ) ; registry . set _ value ( STR , STR ) ; registry . set _ value ( STR , STR + get _ timestamp ( date _ time . now ) ) ; system _ proxy . notify _ ie ( ) ;
registry _ key registry = registry . current _ user . open _ sub _ key ( STR , true ) ; registry . set _ value ( STR , 0 ) ; registry . set _ value ( STR , STR ) ; registry . set _ value ( STR , STR ) ; system _ proxy . notify _ ie ( ) ;
if ( file . exists ( pac _ server . pac _ file ) )
string original = file _ manager . non _ exclusive _ read _ all _ text ( pac _ server . pac _ file , encoding . ut ) ;
file . write _ all _ text ( pac _ server . pac _ file , abp _ content , encoding . ut ) ;
string pac _ filename = pac _ server . touch _ pac _ file ( ) ;
string user _ rule _ filename = pac _ server . touch _ user _ rule _ file ( ) ;
pac _ server = new pac _ server ( ) ; pac _ server . pac _ file _ changed + = pac _ server _ pac _ file _ changed ; pac _ server . user _ rule _ file _ changed + = pac _ server _ user _ rule _ file _ changed ; } pac _ server . update _ configuration ( config ) ;
public const string pac _ file = STR ; public const string user _ rule _ file = STR ; public const string user _ abp _ file = STR ;
file _ system _ watcher pac _ file _ watcher ; file _ system _ watcher user _ rule _ file _ watcher ;
public event event _ handler pac _ file _ changed ; public event event _ handler user _ rule _ file _ changed ; public pac _ server ( )
this . watch _ pac _ file ( ) ; this . watch _ user _ rule _ file ( ) ;
public void update _ configuration ( configuration config )
foreach ( string line in lines )
string [ ] kv = line . split ( new char [ ] { ':' } , 2 ) ;
} else if ( kv . length = = 1 ) { if ( line . index _ of ( STR , string _ comparison . ordinal ) > = 0 ) { path _ match = true ; } if ( ! secret _ match ) { if ( line . index _ of ( pac _ secret , string _ comparison . ordinal ) > = 0 ) { secret _ match = true ; } }
public string touch _ pac _ file ( ) { if ( file . exists ( pac _ file ) ) { return pac _ file ; } else { file _ manager . uncompress _ file ( pac _ file , resources . proxy _ pac _ txt ) ; return pac _ file ; } } internal string touch _ user _ rule _ file ( ) { if ( file . exists ( user _ rule _ file ) ) { return user _ rule _ file ; } else { file . write _ all _ text ( user _ rule _ file , resources . user _ rule ) ; return user _ rule _ file ; } } private string get _ pac _ content ( ) { if ( file . exists ( pac _ file ) ) { return file . read _ all _ text ( pac _ file , encoding . ut ) ; } else { return utils . un _ gzip ( resources . proxy _ pac _ txt ) ; } }
string pac _ content = get _ pac _ content ( ) . replace ( STR , proxy ) ;
private timer recorder ;
private timer speed _ monior ;
start _ timer _ without _ state ( ref recorder , run , recording _ interval ) ;
start _ timer _ without _ state ( ref speed _ monior , update _ speed , monitor _ interval ) ;
recorder ? . dispose ( ) ; speed _ monior ? . dispose ( ) ;
private void start _ timer _ without _ state ( ref timer timer , timer _ callback callback , time _ span interval ) { if ( timer ? . change ( delay _ before _ start , interval ) = = null ) { timer = new timer ( callback , null , delay _ before _ start , interval ) ; } } private void update _ speed ( object )
private void run ( object )
state . counter = controller . get _ current _ configuration ( ) . configs . count ; foreach ( var server in controller . get _ current _ configuration ( ) . configs ) {  var id = server . identifier ( ) ; list < int > inbound _ speed _ records = null ; list < int > outbound _ speed _ records = null ; list < int > latency _ records = null ; inbound _ speed _ records . try _ get _ value ( id , out inbound _ speed _ records ) ; outbound _ speed _ records . try _ get _ value ( id , out outbound _ speed _ records ) ; latency _ records . try _ get _ value ( id , out latency _ records ) ; statistics _ record record = new statistics _ record ( id , inbound _ speed _ records , outbound _ speed _ records , latency _ records ) ;  if ( records . contains _ key ( id ) ) records [ id ] = record ; else records . add ( id , record ) ; if ( config . ping ) {   my _ ping ping = new my _ ping ( server , repeat ) ; ping . completed + = ping _ completed ; ping . start ( new ping _ state { state = state , record = record } ) ; } else if ( ! record . is _ empty _ data ( ) ) { append _ record ( id , record ) ; } } if ( ! config . ping )
if ( filtered _ statistics = = null ) { filtered _ statistics = new statistics ( ) ; }
filtered _ statistics [ server ] = filtered _ records ; }
console . write _ line ( $ STR ) ; recorder . change ( retry _ interval , recording _ interval ) ;
recorder . dispose ( ) ; speed _ monior . dispose ( ) ;
private string pac _ secret { get ; set ; } = STR ;
this . config = config ; if ( config . secure _ local _ pac ) { var rd = new byte [ NUM ] ; rng . get _ bytes ( rd ) ; pac _ secret = $ STR ; } else { pac _ secret = STR ; } pac _ url = $ STR ;
return bit _ converter . to _ string ( md _ bytes ) . replace ( STR , STR ) ;
public class n
protected static dictionary < string , string > strings ; static void init ( string res )
strings = new dictionary < string , string > ( ) ; string name = culture _ info . current _ culture . name ; if ( name . starts _ with ( STR ) )
if ( name = = STR | | name = = STR ) { init ( resources . cn ) ; } else { init ( resources . zh _ tw ) ; }
if ( strings . contains _ key ( key ) ) { return strings [ key ] ; } else { return key ; }
file . write _ all _ text ( n _ file , n , encoding . ut ) ;
using system ;
using system _ drawing _ imaging ;
using shadowsocks _ controller ; using shadowsocks _ model ; using shadowsocks _ properties ; using shadowsocks _ util ; using system _ linq ; using microsoft _ win ; using system _ windows _ interop ;
local local = new local ( config ) ;
services . add ( local ) ;
bool handle ( byte [ ] first _ packet , int length , socket socket ) ;
socket socket ;
socket = new socket ( address _ family . inter _ network , socket _ type . stream , protocol _ type . tcp ) ; socket . set _ socket _ option ( socket _ option _ level . socket , socket _ option _ name . reuse _ address , true ) ;
socket . bind ( local _ end _ point ) ; socket . listen ( NUM ) ;
socket . begin _ accept (
socket ) ;
socket . close ( ) ;
if ( socket ! = null )
socket . close ( ) ; socket = null ;
if ( service . handle ( buf , bytes _ read , conn ) )
conn . close ( ) ;
class local : listener . service
public local ( configuration config )
public bool handle ( byte [ ] first _ packet , int length , socket socket ) {
public bool handle ( byte [ ] first _ packet , int length , socket socket )
public bool handle ( byte [ ] first _ packet , int length , socket socket )
i _ async _ result begin _ connect _ proxy ( end _ point remote _ ep , async _ callback callback , object state ) ;
i _ async _ result begin _ connect _ dest ( end _ point remote _ ep , async _ callback callback , object state ) ;
i _ async _ result begin _ send ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback ,
i _ async _ result begin _ receive ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback ,
public i _ async _ result begin _ connect _ proxy ( end _ point remote _ ep , async _ callback callback , object state )
return r ;
public i _ async _ result begin _ connect _ dest ( end _ point remote _ ep , async _ callback callback , object state )
return remote . begin _ connect ( remote _ ep , callback , state ) ;
public i _ async _ result begin _ send ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback ,
return remote . begin _ send ( buffer , offset , size , socket _ flags , callback , state ) ;
public i _ async _ result begin _ receive ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback ,
return remote . begin _ receive ( buffer , offset , size , socket _ flags , callback , state ) ;
foreach ( process p in existing _ polipo )
file _ manager . byte _ array _ to _ file ( utils . get _ temp _ path ( STR ) , encoding . ut . get _ bytes ( polipo _ config ) ) ;
process . start _ info . arguments = STR ;
if ( file . exists ( path . combine ( application . startup _ path , STR ) ) )
log _ message _ text _ box . append _ text ( line + environment . new _ line ) ;
log _ message _ text _ box . append _ text ( line + environment . new _ line ) ;
private const string temp _ log = STR ; private static readonly string [ ] common _ env = { STR , STR , STR , STR , STR , STR , STR , STR , STR , STR , STR , STR , STR , STR , } ;
var temp _ folder = configuration . load ( ) . temp _ folder ; if ( string . is _ null _ or _ white _ space ( temp _ folder ) )
temp _ folder = STR ; else if ( common _ env . contains ( temp _ folder , string _ comparer . ordinal _ ignore _ case ) )  temp _ folder + = ( STR + application . executable _ path . get _ hash _ code ( ) ) ; temp _ folder = environment . expand _ environment _ variables ( temp _ folder ) ;  var temp _ directory = directory . create _ directory ( path . combine ( application . startup _ path , temp _ folder ) ) ; temp _ path = temp _ directory . full _ name ; file . append _ all _ text ( path . combine ( temp _ path , temp _ log ) , $ STR u STR ) ;
configuration . check _ temp _ folder ( temp _ folder _ text _ box . text ) ;
public void save _ servers ( list < server > servers , int local _ port )
configuration . save ( config ) ; } public void save _ temp _ folder ( string temp _ folder ) { config . temp _ folder = temp _ folder ;
private system . windows . forms . label temp _ folder _ label ;
private system . windows . forms . text _ box temp _ folder _ text _ box ;
connection ? . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , socket _ flags . none , new async _ callback ( pipe _ connection _ receive _ callback ) , session ) ;
if ( closed ) return ;
connection ? . end _ send ( ar ) ;
this . back _ color = system . drawing . color . crimson ;
using ( bitmap image = new bitmap ( screen . primary _ screen . bounds . width ,
using ( graphics g = graphics . from _ image ( image ) )
image . size ,
var reader = new barcode _ reader
try _ harder = true , possible _ formats = new list < barcode _ format >
barcode _ format . qr _ code
} ; var result = reader . decode ( image ) ; if ( result ! = null ) { var success = controller . add _ server _ by _ ssurl ( result . text ) ; if ( success )
min _ x - = margin ; max _ x + = margin ; min _ y - = margin ; max _ y + = margin ; qr _ code _ splash _ form splash = new qr _ code _ splash _ form ( ) ; splash . form _ closed + = splash _ form _ closed ;
splash . size = new size ( ( int ) max _ x - ( int ) min _ x , ( int ) max _ y - ( int ) min _ y ) ;
message _ box . show ( n . get _ string ( STR ) ) ; }
private shadowsocks _ controller controller ;
private string _ builder sb = new string _ builder ( ) ; private i _ enumerable < text _ box > all _ text _ boxes ; private label lb = null ; private hot _ keys . hot _ key _ call _ back _ handler call _ back = null ;
this . icon = icon . from _ handle ( resources . ssw . get _ hicon ( ) ) ;
all _ text _ boxes = hot _ keys . get _ child _ controls < text _ box > ( this . table _ layout _ panel ) ;
this . text = n . get _ string ( STR ) ;
sb . length = 0 ;
text _ box tb = sender as text _ box ; string content = tb . text . trim _ end ( ) ;
text _ box tb = sender as text _ box ;
prepare _ for _ hotkey ( tb , out call _ back , out lb ) ; unreg _ prev _ hotkey ( call _ back ) ;
this . close ( ) ;
controller . stop ( ) ;
controller . start ( ) ;
controller . stop ( ) ; controller = null ;
load _ library ( dll _ path ) ;
var proxy = ( ( proxy _ timer ) sender ) . session . remote ;
var session = ( ( server _ timer ) sender ) . session ; server server = ( ( server _ timer ) sender ) . server ;
private class tcp _ user _ token : i _ async _ result
public async _ callback callback { get ; } public socket _ async _ event _ args args { get ; }
public bool is _ completed { get ; } = true ; public wait _ handle async _ wait _ handle { get ; } = null ; public object async _ state { get ; } public bool completed _ synchronously { get ; } = true ;
token . callback ( token ) ;
var tut = async _ result as tcp _ user _ token ; if ( tut = = null )
this . notify _ icon = new system . windows . forms . notify _ icon ( this . components ) ;
this . context _ menu = new system . windows . forms . context _ menu ( ) ; this . enable _ item = new system . windows . forms . menu _ item ( ) ; this . auto _ startup _ item = new system . windows . forms . menu _ item ( ) ; this . share _ over _ lan _ item = new system . windows . forms . menu _ item ( ) ; this . servers _ item = new system . windows . forms . menu _ item ( ) ; this . seperator _ item = new system . windows . forms . menu _ item ( ) ; this . config _ item = new system . windows . forms . menu _ item ( ) ; this . menu _ item = new system . windows . forms . menu _ item ( ) ; this . edit _ pac _ file _ item = new system . windows . forms . menu _ item ( ) ; this . qr _ code _ item = new system . windows . forms . menu _ item ( ) ; this . show _ log _ item = new system . windows . forms . menu _ item ( ) ; this . about _ item = new system . windows . forms . menu _ item ( ) ; this . menu _ item = new system . windows . forms . menu _ item ( ) ; this . quit _ item = new system . windows . forms . menu _ item ( ) ;
this . menu _ item = new system . windows . forms . menu _ item ( ) ;
this . table _ layout _ panel . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;
this . table _ layout _ panel . padding = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;
private system . windows . forms . notify _ icon notify _ icon ;
private system . windows . forms . context _ menu context _ menu ; private system . windows . forms . menu _ item enable _ item ; private system . windows . forms . menu _ item about _ item ; private system . windows . forms . menu _ item menu _ item ; private system . windows . forms . menu _ item quit _ item ; private system . windows . forms . menu _ item config _ item ; private system . windows . forms . menu _ item edit _ pac _ file _ item ;
private system . windows . forms . menu _ item servers _ item ; private system . windows . forms . menu _ item seperator _ item ; private system . windows . forms . menu _ item menu _ item ;
private system . windows . forms . menu _ item qr _ code _ item ; private system . windows . forms . menu _ item show _ log _ item ; private system . windows . forms . menu _ item share _ over _ lan _ item ; private system . windows . forms . menu _ item auto _ startup _ item ; private system . windows . forms . menu _ item menu _ item ;
load _ tray _ icon ( ) ; notify _ icon . context _ menu = context _ menu ;
controller . enable _ status _ changed + = controller _ enable _ status _ changed ;
controller . pac _ file _ ready _ to _ open + = controller _ pac _ file _ ready _ to _ open ; controller . share _ over _ lan _ status _ changed + = controller _ share _ over _ lan _ status _ changed ; this . update _ checker = new update _ checker ( ) ; update _ checker . new _ version _ found + = update _ checker _ new _ version _ found ;
} private void load _ tray _ icon ( ) { int dpi ; graphics graphics = this . create _ graphics ( ) ; dpi = ( int ) graphics . dpi _ x ; graphics . dispose ( ) ; bitmap icon = null ; if ( dpi < NUM ) {  icon = resources . ss ; } else if ( dpi < NUM ) {  icon = resources . ss ; } else { icon = resources . ss ; } notify _ icon . icon = icon . from _ handle ( icon . get _ hicon ( ) ) ; notify _ icon . visible = true ; this . icon = icon . from _ handle ( resources . ssw . get _ hicon ( ) ) ;
} private void controller _ enable _ status _ changed ( object sender , event _ args e ) { enable _ item . checked = controller . get _ configuration ( ) . enabled ; } void controller _ share _ over _ lan _ status _ changed ( object sender , event _ args e ) { share _ over _ lan _ item . checked = controller . get _ configuration ( ) . share _ over _ lan ; } void controller _ pac _ file _ ready _ to _ open ( object sender , shadowsocks _ controller . path _ event _ args e ) { string argument = STR + e . path ; system . diagnostics . process . start ( STR , argument ) ; } void update _ checker _ new _ version _ found ( object sender , event _ args e ) { notify _ icon . balloon _ tip _ title = STR + update _ checker . latest _ version _ number + STR ; notify _ icon . balloon _ tip _ text = STR ; notify _ icon . balloon _ tip _ icon = tool _ tip _ icon . info ; notify _ icon . balloon _ tip _ clicked + = notify _ icon _ balloon _ tip _ clicked ; notify _ icon . show _ balloon _ tip ( NUM ) ; is _ first _ run = false ;
update _ servers _ menu ( ) ; enable _ item . checked = modified _ configuration . enabled ; share _ over _ lan _ item . checked = modified _ configuration . share _ over _ lan ; auto _ startup _ item . checked = auto _ startup . check ( ) ; } private void update _ servers _ menu ( ) { var items = servers _ item . menu _ items ; items . clear ( ) ; configuration configuration = controller . get _ configuration ( ) ; for ( int i = 0 ; i < configuration . configs . count ; i + + ) { server server = configuration . configs [ i ] ; menu _ item item = new menu _ item ( string . is _ null _ or _ empty ( server . remarks ) ? server . server + STR + server . server _ port : server . server + STR + server . server _ port + STR + server . remarks + STR ) ; item . tag = i ; item . click + = a _ server _ item _ click ; items . add ( item ) ; } items . add ( seperator _ item ) ; items . add ( config _ item ) ; if ( configuration . index > = 0 & & configuration . index < configuration . configs . count ) { items [ configuration . index ] . checked = true ; }
if ( ! controller . get _ configuration ( ) . is _ default ) { this . opacity = 0 ; begin _ invoke ( new method _ invoker ( delegate { this . hide ( ) ; } ) ) ; } else { is _ first _ run = true ; } update _ checker . check _ update ( ) ;
show _ first _ time _ balloon ( ) ;
this . hide ( ) ; load _ current _ configuration ( ) ; show _ first _ time _ balloon ( ) ; } private void config _ form _ form _ closed ( object sender , form _ closed _ event _ args e ) { controller . stop ( ) ; } private void about _ item _ click ( object sender , event _ args e ) { process . start ( STR ) ; } private void notify _ icon _ double _ click ( object sender , event _ args e ) { show _ window ( ) ; } private void enable _ item _ click ( object sender , event _ args e ) { enable _ item . checked = ! enable _ item . checked ; controller . toggle _ enable ( enable _ item . checked ) ; } private void share _ over _ lan _ item _ click ( object sender , event _ args e ) { share _ over _ lan _ item . checked = ! share _ over _ lan _ item . checked ; controller . toggle _ share _ over _ lan ( share _ over _ lan _ item . checked ) ; } private void edit _ pac _ file _ item _ click ( object sender , event _ args e ) { controller . touch _ pac _ file ( ) ; } private void a _ server _ item _ click ( object sender , event _ args e ) { menu _ item item = ( menu _ item ) sender ; controller . select _ server _ index ( ( int ) item . tag ) ; } private void show _ log _ item _ click ( object sender , event _ args e ) { string argument = logging . log _ file ; system . diagnostics . process . start ( STR , argument ) ;
private void qr _ code _ item _ click ( object sender , event _ args e )
qr _ code _ form qr _ code _ form = new qr _ code _ form ( controller . get _ qr _ code _ for _ current _ server ( ) ) ; qr _ code _ form . icon = this . icon ; qr _ code _ form . show ( ) ;
private void auto _ startup _ item _ click ( object sender , event _ args e ) { auto _ startup _ item . checked = ! auto _ startup _ item . checked ; if ( ! auto _ startup . set ( auto _ startup _ item . checked ) ) { message _ box . show ( STR ) ; } }
try { socket listener = ( socket ) ar . async _ state ;
listener . begin _ accept ( new async _ callback ( accept _ callback ) , listener ) ;
try { socket listener = ( socket ) ar . async _ state ;
listener . begin _ accept ( new async _ callback ( accept _ callback ) , listener ) ;
this . panel = new system . windows . forms . panel ( ) ; this . panel = new system . windows . forms . panel ( ) ;
this . panel . suspend _ layout ( ) ; this . panel . suspend _ layout ( ) ;
this . ok _ button . location = new system . drawing . point ( NUM , NUM ) ;
this . my _ cancel _ button . location = new system . drawing . point ( NUM , NUM ) ;
this . panel . auto _ size = true ; this . panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . panel . controls . add ( this . my _ cancel _ button ) ; this . panel . controls . add ( this . ok _ button ) ; this . panel . location = new system . drawing . point ( NUM , NUM ) ; this . panel . margin = new system . windows . forms . padding ( 0 ) ; this . panel . name = STR ; this . panel . size = new system . drawing . size ( NUM , NUM ) ; this . panel . tab _ index = 1 ;    this . panel . auto _ size = true ; this . panel . controls . add ( this . delete _ button ) ; this . panel . controls . add ( this . add _ button ) ; this . panel . location = new system . drawing . point ( NUM , NUM ) ; this . panel . margin = new system . windows . forms . padding ( 0 ) ; this . panel . name = STR ; this . panel . size = new system . drawing . size ( NUM , NUM ) ; this . panel . tab _ index = NUM ;
this . delete _ button . location = new system . drawing . point ( NUM , NUM ) ;
this . add _ button . location = new system . drawing . point ( NUM , NUM ) ;
this . server _ group _ box . location = new system . drawing . point ( NUM , NUM ) ;
this . servers _ list _ box . location = new system . drawing . point ( NUM , NUM ) ;
this . client _ size = new system . drawing . size ( NUM , NUM ) ; this . controls . add ( this . servers _ list _ box ) ; this . controls . add ( this . server _ group _ box ) ; this . controls . add ( this . panel ) ; this . controls . add ( this . panel ) ;
this . panel . resume _ layout ( false ) ; this . panel . resume _ layout ( false ) ;
private system . windows . forms . panel panel ; private system . windows . forms . panel panel ;
using system _ linq ;
using system _ threading _ tasks ;
registry . set _ value ( STR , STR ) ;
registry . set _ value ( STR , STR ) ;
using system ;
namespace shadowsocks _ csharp
using shadowsocks _ csharp _ properties ;
namespace shadowsocks _ csharp
private bool byte _ array _ to _ file ( string file _ name , byte [ ] content ) { try { system . io . file _ stream file _ stream = new system . io . file _ stream ( file _ name , system . io . file _ mode . create , system . io . file _ access . write ) ; file _ stream . write ( content , 0 , content . length ) ; file _ stream . close ( ) ; return true ; } catch ( exception exception ) { console . write _ line ( STR , exception . to _ string ( ) ) ; } return false ; } public static void uncompress _ file ( string file _ name , byte [ ] content ) { file _ stream destination _ file = file . create ( file _ name ) ;   byte [ ] buffer = new byte [ NUM ] ; int n ; using ( g _ zip _ stream input = new g _ zip _ stream ( new memory _ stream ( content ) , compression _ mode . decompress , false ) ) { while ( true ) { n = input . read ( buffer , 0 , buffer . length ) ; if ( n = = 0 ) { break ; } destination _ file . write ( buffer , 0 , n ) ; } } destination _ file . close ( ) ; }
namespace shadowsocks _ csharp
class system _ proxy
console . write _ line ( e ) ;
console . write _ line ( e ) ;
public interface service
foreach ( service service in services )
if ( regist & & ! check ( ) )
public void check _ update ( )
http . proxy = new web _ proxy ( ip _ address . loopback . to _ string ( ) , NUM ) ;
this . table _ layout _ panel . controls . add ( this . log _ message _ text _ box , 0 , 1 ) ;
return $ STR ;
bitmap icon = null ;
icon = resources . ss ;
icon = resources . ss ;
icon = resources . ss ;
icon = get _ tray _ icon _ by _ state ( icon , enabled , global ) ; notify _ icon . icon = icon . from _ handle ( icon . get _ hicon ( ) ) ;
using ( bitmap full _ image = new bitmap ( screen . primary _ screen . bounds . width , screen . primary _ screen . bounds . height ) ) { using ( graphics g = graphics . from _ image ( full _ image ) )
g . copy _ from _ screen ( screen . primary _ screen . bounds . x , screen . primary _ screen . bounds . y , 0 , 0 , full _ image . size , copy _ pixel _ operation . source _ copy ) ; } for ( int i = 0 ; i < NUM ; i + + ) { int margin _ left = full _ image . width * i / NUM / NUM ; int margin _ top = full _ image . height * i / NUM / NUM ; rectangle crop _ rect = new rectangle ( margin _ left , margin _ top , full _ image . width - margin _ left * 2 , full _ image . height - margin _ top * 2 ) ; bitmap target = new bitmap ( crop _ rect . width , crop _ rect . height ) ; using ( graphics g = graphics . from _ image ( target ) )
g . draw _ image ( full _ image , new rectangle ( 0 , 0 , target . width , target . height ) , crop _ rect , graphics _ unit . pixel ) ;
var source = new bitmap _ luminance _ source ( target ) ; var bitmap = new binary _ bitmap ( new hybrid _ binarizer ( source ) ) ; qr _ code _ reader reader = new qr _ code _ reader ( ) ; var result = reader . decode ( bitmap ) ; if ( result ! = null )
var success = controller . add _ server _ by _ ssurl ( result . text ) ; qr _ code _ splash _ form splash = new qr _ code _ splash _ form ( ) ; if ( success )
splash . form _ closed + = splash _ form _ closed ;
else if ( result . text . starts _ with ( STR ) | | result . text . starts _ with ( STR ) )
return buf ;
return buf ;
return buf ;
return buf ;
local local ; pac _ server pac _ server ; config config ; polipo _ runner polipo _ runner ; public config _ form ( )
config = config . load ( ) ;
enable _ item . checked = config . enabled ; config _ to _ text _ box ( ) ;
private void config _ to _ text _ box ( )
combo _ box . text = config . method = = null ? STR : config . method ;
if ( ! config . is _ default )
reload ( config ) ; begin _ invoke ( new method _ invoker ( delegate
pac _ server = new pac _ server ( ) ; pac _ server . start ( ) ; update _ system _ proxy ( ) ; } private void reload ( config config ) { if ( local ! = null ) { local . stop ( ) ; if ( polipo _ runner ! = null ) { polipo _ runner . stop ( ) ; } } if ( polipo _ runner = = null ) { polipo _ runner = new polipo _ runner ( ) ; } polipo _ runner . start ( config ) ; local = new local ( config ) ; local . start ( ) ;
config _ to _ text _ box ( ) ;
if ( local ! = null ) local . stop ( ) ; if ( polipo _ runner ! = null ) polipo _ runner . stop ( ) ; if ( config . enabled ) { system _ proxy . disable ( ) ; }
private void update _ system _ proxy ( ) { if ( config . enabled ) { system _ proxy . enable ( ) ; } else { system _ proxy . disable ( ) ; } }
config . enabled = enable _ item . checked ; config . save ( config ) ; update _ system _ proxy ( ) ;
public void enable _ proxy ( int type , string proxy , int port )
var type = proxy _ type _ combo _ box . selected _ index ; var proxy = proxy _ server _ text _ box . text ; var port = 0 ; var timeout = NUM ;
try { port = int . parse ( proxy _ port _ text _ box . text ) ; } catch ( format _ exception )
proxy _ port _ text _ box . clear ( ) ;
try { timeout = int . parse ( proxy _ timeout _ text _ box . text ) ; } catch ( format _ exception )
proxy _ timeout _ text _ box . clear ( ) ;
controller . enable _ proxy ( type , proxy , port ) ;
modified _ configuration . use _ proxy = use _ proxy _ check _ box . checked ; modified _ configuration . proxy _ type = type ; modified _ configuration . proxy _ server = proxy ; modified _ configuration . proxy _ port = port ; modified _ configuration . proxy _ timeout = timeout ; controller . save _ proxy _ config ( modified _ configuration ) ;
var method = m . groups [ STR ] . value ; var path = m . groups [ STR ] . value ;
if ( ! parse _ host ( path ) )
else { var target _ url = new uri ( path ) ; if ( ! parse _ host ( target _ url . authority ) ) { throw new exception ( STR + line ) ; } var new _ request _ line = $ STR tail STR ; headers . enqueue ( new _ request _ line ) ; } } else { throw new format _ exception ( STR ) ; } } else {  if ( ! line . starts _ with ( STR ) ) { headers . enqueue ( line ) ; } else { if ( line . starts _ with ( STR ) ) { headers . enqueue ( line . substring ( NUM ) ) ; } }
public void update _ latency ( server server , time _ span latency ) {
availability _ statistics . update _ latency ( server , ( int ) latency . total _ milliseconds ) ; } } public void update _ inbound _ counter ( server server , long n ) { interlocked . add ( ref inbound _ counter , n ) ;
availability _ statistics . update _ inbound _ counter ( server , n ) ; } } public void update _ outbound _ counter ( server server , long n ) { interlocked . add ( ref outbound _ counter , n ) ;
availability _ statistics . update _ outbound _ counter ( server , n ) ;
public void update _ inbound _ counter ( server server , long n ) { controller . update _ inbound _ counter ( server , n ) ; } public void update _ outbound _ counter ( server server , long n ) { controller . update _ outbound _ counter ( server , n ) ; } public void update _ latency ( server server , time _ span latency ) { i _ strategy strategy = controller . get _ current _ strategy ( ) ; strategy ? . update _ latency ( server , latency ) ; controller . update _ latency ( server , latency ) ; }
class ss _ relay _ event _ args : event _ args
class ss _ inbound _ event _ args : ss _ relay _ event _ args
public ss _ inbound _ event _ args ( server server , long length ) : base ( server )
class ss _ outbound _ event _ args : ss _ relay _ event _ args { public readonly long length ; public ss _ outbound _ event _ args ( server server , long length ) : base ( server ) { this . length = length ; } } class sstcp _ connected _ event _ args : ss _ relay _ event _ args
} } class sstcp _ closed _ event _ args : ss _ relay _ event _ args { public readonly tcp _ handler handler ; public sstcp _ closed _ event _ args ( server server , tcp _ handler handler ) : base ( server ) { this . handler = handler ;
public event event _ handler < ss _ inbound _ event _ args > on _ inbound ; public event event _ handler < ss _ outbound _ event _ args > on _ outbound ; public event event _ handler < sstcp _ closed _ event _ args > on _ closed ;
on _ outbound ? . invoke ( this , new ss _ outbound _ event _ args ( server , bytes _ to _ send ) ) ;
i _ strategy strategy = controller . get _ current _ strategy ( ) ; strategy ? . update _ last _ write ( server ) ;
public iv _ encryptor ( string method , string password ) : base ( method , password )
load _ library ( dll _ path ) ;
protected encryptor _ base ( string method , string password )
this . table _ layout _ panel . row _ count = NUM ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ;  this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ;
this . server _ group _ box . size = new system . drawing . size ( NUM , NUM ) ; this . server _ group _ box . tab _ index = NUM ;
this . servers _ list _ box . item _ height = NUM ;
public static i _ encryptor get _ encryptor ( string method , string password )
i _ encryptor result = ( i _ encryptor ) c . invoke ( new object [ ] { method , password } ) ;
this . plugin _ options _ label . location = new system . drawing . point ( NUM , NUM ) ;
this . plugin _ text _ box . location = new system . drawing . point ( NUM , NUM ) ;
this . remarks _ text _ box . location = new system . drawing . point ( NUM , NUM ) ;
this . ip _ label . location = new system . drawing . point ( NUM , NUM ) ;
this . server _ port _ label . location = new system . drawing . point ( NUM , NUM ) ;
this . password _ label . location = new system . drawing . point ( NUM , NUM ) ;
this . ip _ text _ box . location = new system . drawing . point ( NUM , NUM ) ;
this . server _ port _ text _ box . location = new system . drawing . point ( NUM , NUM ) ;
this . password _ text _ box . location = new system . drawing . point ( NUM , NUM ) ;
this . encryption _ label . location = new system . drawing . point ( NUM , NUM ) ;
this . encryption _ select . item _ height = NUM ; this . encryption _ select . items . add _ range ( new object [ ] { STR , STR , STR , STR , STR , STR , STR , STR , STR , STR , STR , STR , STR , STR , STR , STR , STR , STR , STR } ) ; this . encryption _ select . location = new system . drawing . point ( NUM , NUM ) ;
this . timeout _ label . location = new system . drawing . point ( NUM , NUM ) ;
this . timeout _ text _ box . location = new system . drawing . point ( NUM , NUM ) ;
this . plugin _ label . location = new system . drawing . point ( NUM , NUM ) ;
this . plugin _ options _ text _ box . location = new system . drawing . point ( NUM , NUM ) ;
this . show _ passwd _ check _ box . location = new system . drawing . point ( NUM , NUM ) ;
this . plugin _ arguments _ text _ box . location = new system . drawing . point ( NUM , NUM ) ;
this . plugin _ arguments _ label . location = new system . drawing . point ( NUM , NUM ) ;
this . remarks _ label . location = new system . drawing . point ( NUM , NUM ) ;
this . need _ plugin _ arg _ check _ box . location = new system . drawing . point ( NUM , NUM ) ;
this . panel . location = new system . drawing . point ( NUM , NUM ) ;
this . table _ layout _ panel . padding = new system . windows . forms . padding ( NUM ) ;
this . proxy _ port _ text _ box . location = new system . drawing . point ( NUM , NUM ) ;
this . proxy _ port _ label . location = new system . drawing . point ( NUM , NUM ) ;
this . portable _ mode _ check _ box . location = new system . drawing . point ( NUM , NUM ) ;
using shadowsocks _ encryption ;
using shadowsocks _ encryption _ stream ; using shadowsocks _ model ; using shadowsocks _ controller _ service ;
using system _ net ; namespace test
public void send _ response ( byte [ ] first _ packet , int length , socket socket , bool use _ socks )
string pac = get _ pac _ content ( ) ;
string proxy = get _ pac _ address ( first _ packet , length , local _ end _ point , use _ socks ) ; pac = pac . replace ( STR , proxy ) ; string text = string . format ( @ STR
STR byte [ ] response = encoding . ut . get _ bytes ( text ) ;
file _ manager . uncompress _ file ( dll _ path , resources . libeay _ dll ) ;
public struct internet _ per _ conn _ option _ option _ union
public struct internet _ per _ conn _ option _ list
if ( ! file . exists ( log _ file _ path ) ) using ( file . create ( log _ file _ path ) ) { } log _ file _ creation _ time = file . get _ creation _ time ( log _ file _ path ) ; if ( ( date _ time . now - log _ file _ creation _ time ) . days > = 1 ) roll _ log _ file ( ) ; else { file _ stream fs = new file _ stream ( log _ file _ path , file _ mode . append ) ; stream _ writer _ with _ timestamp sw = new stream _ writer _ with _ timestamp ( fs ) ; sw . auto _ flush = true ; console . set _ out ( sw ) ; console . set _ error ( sw ) ; }
private static void roll _ log _ file ( ) { console . out . close ( ) ; console . error . close ( ) ; memory _ stream ms = new memory _ stream ( ) ; stream _ writer _ with _ timestamp sw = new stream _ writer _ with _ timestamp ( ms ) ; sw . auto _ flush = true ; console . set _ out ( sw ) ; console . set _ error ( sw ) ; byte [ ] log _ contents = file . read _ all _ bytes ( log _ file _ path ) ; string datestr = date _ time . now . add _ days ( - 1 ) . to _ string ( STR ) ; string filepath = utils . get _ temp _ path ( $ STR ) ; file _ manager . compress _ file ( filepath , log _ contents ) ; file . delete ( log _ file _ path ) ; file _ stream fs = new file _ stream ( log _ file _ path , file _ mode . create _ new ) ; log _ file _ creation _ time = date _ time . now ; ms . copy _ to ( fs ) ; stream _ writer _ with _ timestamp sw = new stream _ writer _ with _ timestamp ( fs ) ; sw . auto _ flush = true ; console . set _ out ( sw ) ; console . set _ error ( sw ) ; }
if ( ( date _ time . now - log _ file _ creation _ time ) . days > = 1 ) roll _ log _ file ( ) ;
private update _ checker update _ checker ;
private bool is _ first _ run ;
protected dictionary < string , dictionary < string , int [ ] > > ciphers ; protected dictionary < string , int [ ] > ciphers _ detail ;
protected int [ ] cipher _ info ;
protected abstract dictionary < string , dictionary < string , int [ ] > > get _ ciphers ( ) ;
ciphers _ detail = ciphers [ method ] ; cipher _ mbed _ name = ciphers _ detail . keys . first _ or _ default ( ) ; cipher _ info = ciphers [ method ] [ cipher _ mbed _ name ] ; cipher = cipher _ info [ 2 ] ;
key _ len = cipher _ info [ 0 ] ; iv _ len = cipher _ info [ 1 ] ;
private static dictionary < string , dictionary < string , int [ ] > > ciphers = new dictionary < string , dictionary < string , int [ ] > > { { STR , new dictionary < string , int [ ] > { { STR , new int [ ] { NUM , NUM , cipher _ aes } } } } , { STR , new dictionary < string , int [ ] > { { STR , new int [ ] { NUM , NUM , cipher _ aes } } } } , { STR , new dictionary < string , int [ ] > { { STR , new int [ ] { NUM , NUM , cipher _ aes } } } } , { STR , new dictionary < string , int [ ] > { { STR , new int [ ] { NUM , NUM , cipher _ aes } } } } , { STR , new dictionary < string , int [ ] > { { STR , new int [ ] { NUM , NUM , cipher _ aes } } } } , { STR , new dictionary < string , int [ ] > { { STR , new int [ ] { NUM , NUM , cipher _ aes } } } } , { STR , new dictionary < string , int [ ] > { { STR , new int [ ] { NUM , NUM , cipher _ blowfish } } } } , { STR , new dictionary < string , int [ ] > { { STR , new int [ ] { NUM , NUM , cipher _ camellia } } } } , { STR , new dictionary < string , int [ ] > { { STR , new int [ ] { NUM , NUM , cipher _ camellia } } } } , { STR , new dictionary < string , int [ ] > { { STR , new int [ ] { NUM , NUM , cipher _ camellia } } } } , { STR , new dictionary < string , int [ ] > { { STR , new int [ ] { NUM , NUM , cipher _ r } } } }
protected override dictionary < string , dictionary < string , int [ ] > > get _ ciphers ( )
private static dictionary < string , dictionary < string , int [ ] > > ciphers = new dictionary < string , dictionary < string , int [ ] > > { { STR , new dictionary < string , int [ ] > { { STR , new int [ ] { NUM , NUM , cipher _ sals } } } } , { STR , new dictionary < string , int [ ] > { { STR , new int [ ] { NUM , NUM , cipher _ chach } } } } , { STR , new dictionary < string , int [ ] > { { STR , new int [ ] { NUM , NUM , cipher _ chach _ ietf } } } }
protected override dictionary < string , dictionary < string , int [ ] > > get _ ciphers ( )
this . text = STR ;
public const int crc _ buf _ len = NUM ; public const int crc _ bytes = 2 ;
protected byte [ ] crc _ buf ; protected int crc _ idx = 0 ;
crc _ buf = new byte [ crc _ buf _ len ] ;
lock ( crc _ buf )
int head _ len = get _ ss _ head _ length ( buf , length ) ;
sodium . ss _ onetimeauth ( auth , buf , head _ len , encrypt _ iv , iv _ len , key , key _ len ) ;
int rc = sodium . ss _ gen _ crc ( buf , ref buf _ offset , ref data _ len , crc _ buf , ref crc _ idx , buf . length ) ; if ( rc ! = 0 ) throw new exception ( STR ) ;
lock ( crc _ buf )
int rc = sodium . ss _ gen _ crc ( buf , ref buf _ offset , ref length , crc _ buf , ref crc _ idx , buf . length ) ; if ( rc ! = 0 ) throw new exception ( STR ) ;
public extern static int ss _ gen _ crc ( byte [ ] buf , ref int buf _ offset , ref int data _ len , byte [ ] crc _ buf , ref int crc _ idx , int buf _ size ) ;
public extern static int ss _ onetimeauth ( byte [ ] auth , byte [ ] msg , int msg _ len , byte [ ] iv , int iv _ len , byte [ ] key , int key _ len ) ;
private bool set _ auto _ startup ( bool enabled ) { try { string path = application . executable _ path ; registry _ key run _ key = registry . current _ user . open _ sub _ key ( STR , true ) ; if ( enabled ) { run _ key . set _ value ( STR , path ) ; } else { run _ key . delete _ value ( STR ) ; } run _ key . close ( ) ; return true ; } catch ( exception e ) { return false ; } } private bool check _ auto _ startup ( ) { try { string path = application . executable _ path ; registry _ key run _ key = registry . current _ user . open _ sub _ key ( STR ) ; string [ ] run _ list = run _ key . get _ value _ names ( ) ; run _ key . close ( ) ; foreach ( string item in run _ list ) { if ( item . equals ( STR ) ) return true ; } return false ; } catch ( exception e ) { return false ; } }
if ( ! set _ auto _ startup ( auto _ startup . checked ) ) {
auto _ startup . checked = check _ auto _ startup ( ) ;
bitmap draw _ area = new bitmap ( ( m . height * block _ size ) , ( m . height * block _ size ) ) ;
return encode ( content , ec _ level , null ) ; }        public static qr _ code encode ( string content , error _ correction _ level ec _ level , i _ dictionary < encode _ hint _ type , object > hints ) {
string encoding = hints = = null | | ! hints . contains _ key ( encode _ hint _ type . character _ set ) ? null : ( string ) hints [ encode _ hint _ type . character _ set ] ; if ( encoding = = null ) { encoding = default _ byte _ mode _ encoding ; } bool generate _ eci = ! default _ byte _ mode _ encoding . equals ( encoding ) ;
mode mode = choose _ mode ( content , encoding ) ;
if ( mode . equals ( mode . numeric ) ) append _ numeric _ bytes ( content , bits ) ; else if ( mode . equals ( mode . alphanumeric ) ) append _ alphanumeric _ bytes ( content , bits ) ; else
else if ( mode . equals ( mode . kanji ) ) append _ kanji _ bytes ( content , bits ) ;
} internal static void append _ numeric _ bytes ( string content , bit _ array bits ) { int length = content . length ; int i = 0 ; while ( i < length ) { int num = content [ i ] - '0' ; if ( i + 2 < length ) {  int num = content [ i + 1 ] - '0' ; int num = content [ i + 2 ] - '0' ; bits . append _ bits ( num * NUM + num * NUM + num , NUM ) ; i + = NUM ; } else if ( i + 1 < length ) {  int num = content [ i + 1 ] - '0' ; bits . append _ bits ( num * NUM + num , NUM ) ; i + = 2 ; } else {  bits . append _ bits ( num , NUM ) ; i + + ; } } } internal static void append _ alphanumeric _ bytes ( string content , bit _ array bits ) { int length = content . length ; int i = 0 ; while ( i < length ) { int code = get _ alphanumeric _ code ( content [ i ] ) ; if ( code = = - 1 ) { throw new exception ( ) ; } if ( i + 1 < length ) { int code = get _ alphanumeric _ code ( content [ i + 1 ] ) ; if ( code = = - 1 ) { throw new exception ( ) ; }  bits . append _ bits ( code * NUM + code , NUM ) ; i + = 2 ; } else {  bits . append _ bits ( code , NUM ) ; i + + ; } }
public static version get _ provisional _ version _ for _ dimension ( int dimension ) { if ( dimension % NUM ! = 1 ) { return null ; } try { return get _ version _ for _ number ( ( dimension - NUM ) > > 2 ) ; } catch ( argument _ exception ) { return null ; } }
} internal static version decode _ version _ information ( int version _ bits ) { int best _ difference = int . max _ value ; int best _ version = 0 ; for ( int i = 0 ; i < version _ decode _ info . length ; i + + ) { int target _ version = version _ decode _ info [ i ] ;  if ( target _ version = = version _ bits ) { return get _ version _ for _ number ( i + NUM ) ; }   int bits _ difference = format _ information . num _ bits _ differing ( version _ bits , target _ version ) ; if ( bits _ difference < best _ difference ) { best _ version = i + NUM ; best _ difference = bits _ difference ; } }   if ( best _ difference < = NUM ) { return get _ version _ for _ number ( best _ version ) ; }  return null ; }  internal bit _ matrix build _ function _ pattern ( ) { int dimension = dimension _ for _ version ; bit _ matrix bit _ matrix = new bit _ matrix ( dimension ) ;  bit _ matrix . set _ region ( 0 , 0 , NUM , NUM ) ;  bit _ matrix . set _ region ( dimension - NUM , 0 , NUM , NUM ) ;  bit _ matrix . set _ region ( 0 , dimension - NUM , NUM , NUM ) ;  int max = alignment _ pattern _ centers . length ; for ( int x = 0 ; x < max ; x + + ) { int i = alignment _ pattern _ centers [ x ] - 2 ; for ( int y = 0 ; y < max ; y + + ) { if ( ( x = = 0 & & ( y = = 0 | | y = = max - 1 ) ) | | ( x = = max - 1 & & y = = 0 ) ) {  continue ; } bit _ matrix . set _ region ( alignment _ pattern _ centers [ y ] - 2 , i , NUM , NUM ) ; } }  bit _ matrix . set _ region ( NUM , NUM , 1 , dimension - NUM ) ;  bit _ matrix . set _ region ( NUM , NUM , dimension - NUM , 1 ) ; if ( version _ number > NUM ) {  bit _ matrix . set _ region ( dimension - NUM , 0 , NUM , NUM ) ;  bit _ matrix . set _ region ( 0 , dimension - NUM , NUM , NUM ) ; } return bit _ matrix ;
public int size { get { return size ; } }
override public string to _ string ( ) { return STR + primitive . to _ string ( STR ) + ',' + size + ')' ; }
set { if ( value ) bits [ i > > NUM ] | = 1 < < ( i & 0 f ) ; }
} public bit _ array ( int size ) { if ( size < 1 ) { throw new argument _ exception ( STR ) ; } this . size = size ; this . bits = make _ array ( size ) ; }  private bit _ array ( int [ ] bits , int size ) { this . bits = bits ; this . size = size ;
public void reverse ( ) { var new _ bits = new int [ bits . length ] ;  var len = ( ( size - 1 ) > > NUM ) ; var old _ bits _ len = len + 1 ; for ( var i = 0 ; i < old _ bits _ len ; i + + ) { var x = ( long ) bits [ i ] ; x = ( ( x > > 1 ) & 0 u ) | ( ( x & 0 u ) < < 1 ) ; x = ( ( x > > 2 ) & 0 u ) | ( ( x & 0 u ) < < 2 ) ; x = ( ( x > > NUM ) & 0 fu ) | ( ( x & 0 fu ) < < NUM ) ; x = ( ( x > > NUM ) & 0 ff _ ffu ) | ( ( x & 0 ff _ ffu ) < < NUM ) ; x = ( ( x > > NUM ) & 0 ffffu ) | ( ( x & 0 ffffu ) < < NUM ) ; new _ bits [ len - i ] = ( int ) x ; }  if ( size ! = old _ bits _ len * NUM ) { var left _ offset = old _ bits _ len * NUM - size ; var mask = 1 ; for ( var i = 0 ; i < NUM - left _ offset ; i + + ) mask = ( mask < < 1 ) | 1 ; var current _ int = ( new _ bits [ 0 ] > > left _ offset ) & mask ; for ( var i = 1 ; i < old _ bits _ len ; i + + ) { var next _ int = new _ bits [ i ] ; current _ int | = next _ int < < ( NUM - left _ offset ) ; new _ bits [ i - 1 ] = current _ int ; current _ int = ( next _ int > > left _ offset ) & mask ; } new _ bits [ old _ bits _ len - 1 ] = current _ int ; } bits = new _ bits ; }
public override bool equals ( object o ) { var other = o as bit _ array ; if ( other = = null ) return false ; if ( size ! = other . size ) return false ; for ( var index = 0 ; index < size ; index + + ) { if ( bits [ index ] ! = other . bits [ index ] ) return false ; } return true ; }       public override int get _ hash _ code ( ) { var hash = size ; foreach ( var bit in bits ) { hash = NUM * hash + bit . get _ hash _ code ( ) ; } return hash ; }       public override string to _ string ( ) { var result = new system . text . string _ builder ( size ) ; for ( int i = 0 ; i < size ; i + + ) { if ( ( i & 0 ) = = 0 ) { result . append ( ' ' ) ; } result . append ( this [ i ] ? 'X' : '.' ) ; } return result . to _ string ( ) ; }       public object clone ( ) { return new bit _ array ( ( int [ ] ) bits . clone ( ) , size ) ; }
private void show _ log _ forms ( ) { if ( log _ forms . count = = 0 ) { log _ form f = new log _ form ( controller , logging . log _ file _ path ) ; f . show ( ) ; f . activate ( ) ; f . form _ closed + = log _ form _ form _ closed ; log _ forms . add ( f ) ; log _ forms _ visible = true ;
log _ forms _ visible = ! log _ forms _ visible ; foreach ( log _ form f in log _ forms ) { f . visible = log _ forms _ visible ; }
log _ forms . remove ( ( log _ form ) sender ) ;
byte [ ] iv = new byte [ NUM ] ;
protected void bytes _ to _ key ( byte [ ] password , byte [ ] key )
if ( ! file . exists ( nlog _ config _ file _ name ) )
log _ manager . load _ configuration ( nlog _ config _ file _ name ) ;
return new sip _ plugin ( server . plugin , server . plugin _ opts , server . server , server . server _ port ) ;
private sip _ plugin ( string plugin , string plugin _ opts , string server _ address , int server _ port )
this . table _ layout _ panel . row _ count = NUM ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ;  this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ;
private system . windows . forms . label proxy _ port _ label ;
private system . windows . forms . text _ box proxy _ port _ text _ box ;
this . servers _ list _ view = new system . windows . forms . list _ view ( ) ;
this . controls . add ( this . servers _ list _ view ) ;
private system . windows . forms . list _ view servers _ list _ view ;
assembly _ assembly _ company _ clowwindy
assembly _ assembly _ file _ version
country _ code = other . country _ code ; domain = other . domain . clone ( ) ;
public const int country _ code _ field _ number = 1 ; private string country _ code = STR ; global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute public string country _ code { get { return country _ code ; }
country _ code = pb : : proto _ preconditions . check _ not _ null ( value , STR ) ; } }  public const int domain _ field _ number = 2 ; private static readonly pb : : field _ codec < global :: domain _ object > repeated _ domain _ codec
private readonly pbc : : repeated _ field < global :: domain _ object > domain = new pbc : : repeated _ field < global :: domain _ object > ( ) ; global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute public pbc : : repeated _ field < global :: domain _ object > domain { get { return domain ; }
if ( country _ code ! = other . country _ code ) return false ; if ( ! domain . equals ( other . domain ) ) return false ;
if ( country _ code . length ! = 0 ) hash ^ = country _ code . get _ hash _ code ( ) ; hash ^ = domain . get _ hash _ code ( ) ;
if ( country _ code . length ! = 0 ) {
output . write _ string ( country _ code ) ; } domain . write _ to ( output , repeated _ domain _ codec ) ;
if ( country _ code . length ! = 0 ) { size + = 1 + pb : : coded _ output _ stream . compute _ string _ size ( country _ code ) ; } size + = domain . calculate _ size ( repeated _ domain _ codec ) ;
country _ code = input . read _ string ( ) ;
domain . add _ entries _ from ( input , repeated _ domain _ codec ) ;
public const int entry _ field _ number = 1 ; private static readonly pb : : field _ codec < global :: geosite > repeated _ entry _ codec
private readonly pbc : : repeated _ field < global :: geosite > entry = new pbc : : repeated _ field < global :: geosite > ( ) ; global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute public pbc : : repeated _ field < global :: geosite > entry { get { return entry ; }
if ( ! entry . equals ( other . entry ) ) return false ;
private static readonly string database _ path = utils . get _ temp _ path ( STR ) ; public static readonly geosite _ list list ; public static readonly dictionary < string , list < domain _ object > > geosites = new dictionary < string , list < domain _ object > > ( ) ;
list = geosite _ list . parser . parse _ from ( file . read _ all _ bytes ( database _ path ) ) ; foreach ( var item in list . entry )
geosites [ item . country _ code ] = item . domain . to _ list ( ) ;
else if ( line . index _ of ( STR ) > = 0 )
line = line . substring ( 2 ) ;
line = line . substring ( 1 ) ;
line = line . substring ( 1 ) ;
domains . add ( line ) ; } return domains . to _ array ( ) ;
if ( se . socket _ error _ code = = socket _ error . access _ denied )
}
this . font = system _ fonts . message _ box _ font ;
this . servers _ list _ box . dock = dock _ style . fill ; this . table _ layout _ panel . dock = dock _ style . fill ; this . perform _ layout ( ) ;
this . icon = icon . from _ handle ( resources . ssw . get _ hicon ( ) ) ;
tool _ tip . set _ tool _ tip ( this . portable _ mode _ check _ box , n . get _ string ( STR ) ) ;
this . text = n . get _ string ( STR ) ;
private bool validate _ and _ save _ selected _ server _ details ( )
server server = get _ server _ details _ from _ ui ( ) ; if ( server = = null ) { return false ; } configuration . check _ server ( server ) ; modified _ configuration . configs [ last _ selected _ index ] = server ;
if ( ! validate _ and _ save _ selected _ server _ details ( ) ) { return ; } configuration . add _ default _ server _ or _ server ( modified _ configuration ) ;
servers _ list _ box . selected _ index = modified _ configuration . configs . count - 1 ; last _ selected _ index = servers _ list _ box . selected _ index ; } private void duplicate _ button _ click ( object sender , event _ args e ) { if ( last _ selected _ index = = - 1 | | last _ selected _ index > modified _ configuration . configs . count | | ! validate _ and _ save _ selected _ server _ details ( ) ) { return ; } server curr _ server = modified _ configuration . configs [ last _ selected _ index ] ; var curr _ index = modified _ configuration . configs . index _ of ( curr _ server ) ; modified _ configuration . configs . insert ( curr _ index + 1 , curr _ server ) ; load _ server _ name _ list _ to _ ui ( modified _ configuration ) ; servers _ list _ box . selected _ index = curr _ index + 1 ; last _ selected _ index = servers _ list _ box . selected _ index ; } private void delete _ button _ click ( object sender , event _ args e ) { last _ selected _ index = servers _ list _ box . selected _ index ; if ( last _ selected _ index > = 0 & & last _ selected _ index < modified _ configuration . configs . count ) { modified _ configuration . configs . remove _ at ( last _ selected _ index ) ; } if ( modified _ configuration . configs . count = = 0 ) { configuration . add _ default _ server _ or _ server ( modified _ configuration ) ; } if ( last _ selected _ index > = modified _ configuration . configs . count ) {  last _ selected _ index = modified _ configuration . configs . count - 1 ; } servers _ list _ box . selected _ index = last _ selected _ index ; load _ server _ name _ list _ to _ ui ( modified _ configuration ) ; servers _ list _ box . selected _ index = last _ selected _ index ;
private void ok _ button _ click ( object sender , event _ args e ) { if ( save _ valid _ configuration ( ) ) { this . close ( ) ; } } private void cancel _ button _ click ( object sender , event _ args e ) { this . close ( ) ; } private void apply _ button _ click ( object sender , event _ args e ) { save _ valid _ configuration ( ) ; } private void config _ form _ shown ( object sender , event _ args e ) { ip _ text _ box . focus ( ) ; } private void config _ form _ form _ closed ( object sender , form _ closed _ event _ args e ) { controller . config _ changed - = controller _ config _ changed ;
private void update _ buttons ( ) { delete _ button . enabled = ( servers _ list _ box . items . count > 0 ) ; move _ up _ button . enabled = ( servers _ list _ box . selected _ index > 0 ) ; move _ down _ button . enabled = ( servers _ list _ box . selected _ index < servers _ list _ box . items . count - 1 ) ; } private void move _ up _ button _ click ( object sender , event _ args e ) { if ( ! validate _ and _ save _ selected _ server _ details ( ) ) { return ; } if ( servers _ list _ box . selected _ index > 0 )  { move _ config _ item ( - 1 ) ; } } private void move _ down _ button _ click ( object sender , event _ args e ) { if ( ! validate _ and _ save _ selected _ server _ details ( ) ) { return ; } if ( servers _ list _ box . selected _ index < servers _ list _ box . items . count - 1 ) { move _ config _ item ( + 1 ) ; }
this . password _ text _ box . use _ system _ password _ char = ! this . show _ passwd _ check _ box . checked ;
show _ hide _ plugin _ arg _ input ( this . need _ plugin _ arg _ check _ box . checked ) ;
using newtonsoft _ json ;
private static string config _ file = STR ;
check _ server ( server . server ) ;
public static server add _ default _ server _ or _ server ( configuration config , server server = null )
config . configs . add ( server ) ;
private static hashtable file _ changed _ time = new hashtable ( ) ;
string path = e . full _ path . to _ string ( ) ; string current _ last _ write _ time = file . get _ last _ write _ time ( e . full _ path ) . to _ string ( culture _ info . invariant _ culture ) ;  if ( ! file _ changed _ time . contains _ key ( path ) | | file _ changed _ time [ path ] . to _ string ( ) ! = current _ last _ write _ time ) { if ( pac _ file _ changed ! = null ) { logging . info ( $ STR ) ;
}  file _ changed _ time [ path ] = current _ last _ write _ time ;
string path = e . full _ path . to _ string ( ) ; string current _ last _ write _ time = file . get _ last _ write _ time ( e . full _ path ) . to _ string ( culture _ info . invariant _ culture ) ;  if ( ! file _ changed _ time . contains _ key ( path ) | | file _ changed _ time [ path ] . to _ string ( ) ! = current _ last _ write _ time ) { if ( user _ rule _ file _ changed ! = null ) { logging . info ( $ STR ) ;
}  file _ changed _ time [ path ] = current _ last _ write _ time ;
using system ; using system _ diagnostics ; using system _ io ; using system _ threading ; using system _ windows _ forms ;
using microsoft _ win ;
using system _ i _ pipes ;
using system _ net ;
using system _ collections _ generic ;
static class program
private static logger logger = log _ manager . get _ current _ class _ logger ( ) ;
static void main ( string [ ] args )
system . net . service _ point _ manager . security _ protocol | = system . net . security _ protocol _ type . tls | system . net . security _ protocol _ type . tls | system . net . security _ protocol _ type . tls ;
var alist = args . to _ list ( ) ;
if ( args . length < = urlidx ) return ; if ( ! pipe _ exist ) return ; byte [ ] b = encoding . ut . get _ bytes ( args [ urlidx ] ) ; byte [ ] op _ add _ url = bit _ converter . get _ bytes ( ip _ address . host _ to _ network _ order ( 1 ) ) ; byte [ ] blen = bit _ converter . get _ bytes ( ip _ address . host _ to _ network _ order ( b . length ) ) ; pipe . write ( op _ add _ url , 0 , NUM ) ; pipe . write ( blen , 0 , NUM ) ; pipe . write ( b , 0 , b . length ) ; pipe . close ( ) ; return ; }
public class qr _ code _ splash _ form : per _ pixel _ alpha _ form
public class error _ event _ args : event _ args { public string error ; }
public event event _ handler < error _ event _ args > local _ fail _ to _ start ;
text _ box . text = server . server ; text _ box . text = server . server _ port . to _ string ( ) ; text _ box . text = server . password ; text _ box . text = server . local _ port . to _ string ( ) ; combo _ box . text = server . method = = null ? STR : server . method ;
private void form _ load ( object sender , event _ args e )
private void form _ form _ closed ( object sender , form _ closed _ event _ args e )
this . combo _ box = new system . windows . forms . combo _ box ( ) ;
this . text _ box = new system . windows . forms . text _ box ( ) ; this . text _ box = new system . windows . forms . text _ box ( ) ; this . text _ box = new system . windows . forms . text _ box ( ) ; this . text _ box = new system . windows . forms . text _ box ( ) ;
this . button = new system . windows . forms . button ( ) ; this . button = new system . windows . forms . button ( ) ;
this . edit _ pac _ file _ item = new system . windows . forms . menu _ item ( ) ;
this . table _ layout _ panel . controls . add ( this . combo _ box , 1 , NUM ) ;
this . table _ layout _ panel . controls . add ( this . text _ box , 1 , 0 ) ; this . table _ layout _ panel . controls . add ( this . text _ box , 1 , 1 ) ; this . table _ layout _ panel . controls . add ( this . text _ box , 1 , 2 ) ; this . table _ layout _ panel . controls . add ( this . text _ box , 1 , NUM ) ; this . table _ layout _ panel . location = new system . drawing . point ( NUM , NUM ) ;
this . combo _ box . drop _ down _ style = system . windows . forms . combo _ box _ style . drop _ down _ list ; this . combo _ box . formatting _ enabled = true ; this . combo _ box . ime _ mode = system . windows . forms . ime _ mode . no _ control ; this . combo _ box . item _ height = NUM ; this . combo _ box . items . add _ range ( new object [ ] {
this . button . dialog _ result = system . windows . forms . dialog _ result . ok ; this . button . location = new system . drawing . point ( NUM , NUM ) ; this . button . name = STR ; this . button . size = new system . drawing . size ( NUM , NUM ) ; this . button . tab _ index = 0 ; this . button . text = STR ; this . button . use _ visual _ style _ back _ color = true ; this . button . click + = new system . event _ handler ( this . ok _ button _ click ) ;    this . button . dialog _ result = system . windows . forms . dialog _ result . cancel ; this . button . location = new system . drawing . point ( NUM , NUM ) ; this . button . name = STR ; this . button . size = new system . drawing . size ( NUM , NUM ) ; this . button . tab _ index = 1 ; this . button . text = STR ; this . button . use _ visual _ style _ back _ color = true ; this . button . click + = new system . event _ handler ( this . cancel _ button _ click ) ;
this . panel . anchor = system . windows . forms . anchor _ styles . top ;
this . panel . controls . add ( this . button ) ; this . panel . controls . add ( this . button ) ; this . panel . location = new system . drawing . point ( NUM , NUM ) ;
this . about _ item . click + = new system . event _ handler ( this . about _ tool _ strip _ menu _ item _ click ) ;
this . cancel _ button = this . button ; this . client _ size = new system . drawing . size ( NUM , NUM ) ;
this . controls . add ( this . table _ layout _ panel ) ; this . controls . add ( this . panel ) ;
this . form _ closed + = new system . windows . forms . form _ closed _ event _ handler ( this . form _ form _ closed ) ; this . load + = new system . event _ handler ( this . form _ load ) ;
private system . windows . forms . text _ box text _ box ; private system . windows . forms . text _ box text _ box ; private system . windows . forms . text _ box text _ box ; private system . windows . forms . text _ box text _ box ;
private system . windows . forms . combo _ box combo _ box ;
private system . windows . forms . button button ; private system . windows . forms . button button ;
using system _ threading ;
using system _ i _ compression ; using system _ security _ cryptography ; using system _ text _ regular _ expressions ; using shadowsocks _ model ; using shadowsocks _ properties ;
using system _ collections ;
using system _ text _ regular _ expressions ;
animation _ step = 0 ;
timer . interval = NUM ;
if ( read _ proxy _ server ! = null & & read _ proxy _ server . equals ( STR + config . local _ port . to _ string ( ) ) ) registry . set _ value ( STR , STR ) ;
if ( global ) { registry . set _ value ( STR , STR ) ; }
this . server _ port = int . parse ( after _ at . substring ( index _ last _ colon + 1 ) ) ; this . server = after _ at . substring ( 0 , index _ last _ colon ) ;
this . method = parts [ 0 ] ; this . password = parts [ 1 ] ;
{
}
{
}
{
} if ( config . index = = - 1 ) { if ( config . strategy = = null ) { config . index = 0 ; } }
{
}
{
}
{
} if ( config . index = = - 1 ) { if ( config . strategy = = null ) { config . index = 0 ; } }
{
}
{
}
{
}
{
}
{
}
using system _ collections _ generic ;
using system _ linq ;
using system _ threading _ tasks ;
if ( global ) { arguments = $ STR ; } else { arguments = $ STR ; }
arguments = STR ;
var error = process . standard _ error . read _ to _ end ( ) ;
throw new proxy _ exception ( error ) ;
sysproxy . set _ ie _ proxy ( true , false , STR , pac _ url ) ;
sysproxy . set _ ie _ proxy ( false , false , STR , STR ) ;
if ( kv [ 1 ] . index _ of ( STR ) > = 0 )
}
system _ proxy . enable ( config . global ) ;
system _ proxy . disable ( ) ;
public static void enable ( bool global )
if ( global )
registry . set _ value ( STR , 1 ) ; registry . set _ value ( STR , STR ) ; registry . set _ value ( STR , STR ) ;
registry . set _ value ( STR , STR + get _ timestamp ( date _ time . now ) ) ;
copy _ proxy _ setting _ from _ lan ( ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ;  message _ box . show ( n . get _ string ( STR ) ) ; } } public static void disable ( ) { try { registry _ key registry = registry . current _ user . open _ sub _ key ( STR , true ) ; registry . set _ value ( STR , 0 ) ; registry . set _ value ( STR , STR ) ; registry . set _ value ( STR , STR ) ; system _ proxy . notify _ ie ( ) ;
text _ box . append _ text ( line + STR ) ;
text _ box . scroll _ to _ caret ( ) ;
private void menu _ item _ click ( object sender , event _ args e )
private void menu _ item _ click ( object sender , event _ args e ) { } private void menu _ item _ click ( object sender , event _ args e )
text _ box . scroll _ to _ caret ( ) ;
this . text _ box = new system . windows . forms . text _ box ( ) ;
this . menu _ item = new system . windows . forms . menu _ item ( ) ; this . menu _ item = new system . windows . forms . menu _ item ( ) ; this . menu _ item = new system . windows . forms . menu _ item ( ) ;
this . menu _ item } ) ;
this . menu _ item . index = 0 ; this . menu _ item . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . menu _ item , this . menu _ item } ) ; this . menu _ item . text = STR ;
this . menu _ item . index = 0 ; this . menu _ item . text = STR ; this . menu _ item . click + = new system . event _ handler ( this . menu _ item _ click ) ;
this . client _ size = new system . drawing . size ( NUM , NUM ) ; this . controls . add ( this . text _ box ) ;
this . perform _ layout ( ) ;
private system . windows . forms . text _ box text _ box ;
private system . windows . forms . menu _ item menu _ item ; private system . windows . forms . menu _ item menu _ item ; private system . windows . forms . menu _ item menu _ item ;
throw new exception ( STR ) ;
throw new argument _ exception ( STR ) ;
throw new argument _ exception ( STR ) ;
throw new argument _ exception ( STR ) ;
public event event _ handler update _ completed ;
update _ completed ( this , new event _ args ( ) ) ;
log _ file = utils . get _ temp _ path ( STR ) ; file _ stream fs = new file _ stream ( log _ file , file _ mode . append ) ;
socket . begin _ receive ( line _ buffer , 0 , max _ line _ bytes , 0 , receive _ callback , 0 ) ;
int length = ( int ) ar . async _ state ;
on _ finish ( length ) ;
length + = bytes _ read ; int i ; while ( ( i = index _ of ( line _ buffer , buffer _ index , length , delimiter _ bytes , delimiter _ search _ offset _ table , delimiter _ search _ char _ table ) ) ! = - 1 ) { var decode _ len = i - buffer _ index ; string line = encoding . get _ string ( line _ buffer , buffer _ index , decode _ len ) ; buffer _ index = i + delimiter _ bytes . length ; length - = decode _ len ; length - = delimiter _ bytes . length ; var stop = on _ line _ read ( line , state ) ; if ( stop ) { on _ finish ( length ) ; return ; } } if ( length = = line _ buffer . length ) { on _ exception ( new index _ out _ of _ range _ exception ( STR ) ) ; on _ finish ( length ) ;
if ( buffer _ index > 0 ) { buffer . block _ copy ( line _ buffer , buffer _ index , line _ buffer , 0 , length ) ; buffer _ index = 0 ; } socket . begin _ receive ( line _ buffer , length , line _ buffer . length - length , 0 , receive _ callback , length ) ; } catch ( exception ex ) { on _ exception ( ex ) ; on _ finish ( length ) ; }
private void on _ finish ( int length ) { on _ finish ? . invoke ( line _ buffer , buffer _ index , length , state ) ;
public static int index _ of ( byte [ ] haystack , int index , int length , byte [ ] needle , int [ ] offset _ table , int [ ] char _ table )
using system _ collections _ generic ;
using system _ text ;
message _ box . show ( n . get _ string ( STR ) ) ;
var registry = registry . current _ user . open _ sub _ key ( STR , true ) ; var default _ value = registry . get _ value ( STR ) ; try {
} catch ( io _ exception e ) { logging . log _ useful _ exception ( e ) ;
var registry = registry . current _ user . open _ sub _ key ( STR , true ) ; var def _ connection = ( byte [ ] ) registry . get _ value ( STR ) ; var saved _ legacy _ setting = ( byte [ ] ) registry . get _ value ( STR ) ; const int version _ offset = NUM ; const int options _ offset = NUM ; if ( set ) { def _ connection [ options _ offset ] = ( byte ) ( def _ connection [ options _ offset ] | NUM ) ; saved _ legacy _ setting [ options _ offset ] = ( byte ) ( saved _ legacy _ setting [ options _ offset ] | NUM ) ;
else { def _ connection [ options _ offset ] = ( byte ) ( def _ connection [ options _ offset ] & ~ NUM ) ; saved _ legacy _ setting [ options _ offset ] = ( byte ) ( saved _ legacy _ setting [ options _ offset ] & ~ NUM ) ; } bit _ converter . get _ bytes ( unchecked ( bit _ converter . to _ u _ int ( def _ connection , version _ offset ) + 1 ) ) . copy _ to ( def _ connection , version _ offset ) ; bit _ converter . get _ bytes ( unchecked ( bit _ converter . to _ u _ int ( saved _ legacy _ setting , version _ offset ) + 1 ) ) . copy _ to ( saved _ legacy _ setting , version _ offset ) ; registry . set _ value ( STR , def _ connection ) ; registry . set _ value ( STR , saved _ legacy _ setting ) ;
utils . release _ memory ( true ) ; using ( mutex mutex = new mutex ( false , $ STR ) )
application . set _ unhandled _ exception _ mode ( unhandled _ exception _ mode . catch _ exception ) ;  application . thread _ exception + = application _ thread _ exception ;  app _ domain . current _ domain . unhandled _ exception + = current _ domain _ unhandled _ exception ; application . application _ exit + = application _ application _ exit ; system _ events . power _ mode _ changed + = system _ events _ power _ mode _ changed ; application . enable _ visual _ styles ( ) ; application . set _ compatible _ text _ rendering _ default ( false ) ; auto _ startup . register _ for _ restart ( true ) ; if ( ! mutex . wait _ one ( 0 , false ) )
directory . set _ current _ directory ( application . startup _ path ) ;
main _ controller = new shadowsocks _ controller ( ) ; menu _ controller = new menu _ view _ controller ( main _ controller ) ; hot _ keys . init ( main _ controller ) ; main _ controller . start ( ) ; application . run ( ) ; }
statistics _ chart . series [ STR ] . x _ value _ member = STR ; statistics _ chart . series [ STR ] . y _ value _ members = STR ; if ( configuration . ping ) { data _ table . columns . add ( STR , typeof ( int ) ) ; data _ table . columns . add ( STR , typeof ( int ) ) ; statistics _ chart . series [ STR ] . x _ value _ member = STR ; statistics _ chart . series [ STR ] . y _ value _ members = STR ; statistics _ chart . series [ STR ] . x _ value _ member = STR ; statistics _ chart . series [ STR ] . y _ value _ members = STR ; }
ping = ( int ) data _ group . average ( data = > data . average _ response ) , package _ loss = data _ group . average ( data = > data . package _ loss ) } ;
data _ table . rows . add ( data . timestamp , data . package _ loss , data . ping ) ;
private void server _ selector _ selected _ index _ changed ( object sender , event _ args e )
} private void chart _ mode _ selector _ enter ( object sender , event _ args e ) {
( ( system . component _ model . i _ support _ initialize ) ( this . binding _ configuration ) ) . begin _ init ( ) ;
series . chart _ type = system . windows . forms . data _ visualization . charting . series _ chart _ type . bubble ; series . color = system . drawing . color . from _ argb ( ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) , ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) , ( ( int ) ( ( ( byte ) ( 0 ) ) ) ) ) ;
series . name = STR ; series . x _ value _ type = system . windows . forms . data _ visualization . charting . chart _ value _ type . date _ time ; series . y _ values _ per _ point = 2 ; series . border _ width = NUM ;
series . chart _ type = system . windows . forms . data _ visualization . charting . series _ chart _ type . line ; series . color = system . drawing . color . from _ argb ( ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) , ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) , ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) ) ;
series . name = STR ; series . x _ value _ type = system . windows . forms . data _ visualization . charting . chart _ value _ type . date _ time ;
series . chart _ type = system . windows . forms . data _ visualization . charting . series _ chart _ type . area ;
series . name = STR ;
this . statistics _ chart . click + = new system . event _ handler ( this . statistics _ chart _ click ) ;
( ( system . component _ model . i _ support _ initialize ) ( this . binding _ configuration ) ) . end _ init ( ) ;
public static readonly mode terminator = new mode ( new int [ ] { 0 , 0 , 0 } , 0 , STR ) ;    public static readonly mode numeric = new mode ( new int [ ] { NUM , NUM , NUM } , 0 , STR ) ;    public static readonly mode alphanumeric = new mode ( new int [ ] { NUM , NUM , NUM } , 0 , STR ) ;    public static readonly mode structured _ append = new mode ( new int [ ] { 0 , 0 , 0 } , 0 , STR ) ;
public static readonly mode eci = new mode ( null , 0 , STR ) ;    public static readonly mode kanji = new mode ( new int [ ] { NUM , NUM , NUM } , 0 , STR ) ;    public static readonly mode fn _ first _ position = new mode ( null , 0 , STR ) ;    public static readonly mode fn _ second _ position = new mode ( null , 0 , STR ) ;  public static readonly mode hanzi = new mode ( new int [ ] { NUM , NUM , NUM } , 0 d , STR ) ;
case 0 : return terminator ; case 0 : return numeric ; case 0 : return alphanumeric ; case 0 : return structured _ append ;
case 0 : return fn _ first _ position ; case 0 : return eci ; case 0 : return kanji ; case 0 : return fn _ second _ position ; case 0 xd :  return hanzi ;
public static generic _ gf aztec _ data = new generic _ gf ( 0 , NUM , 1 ) ; public static generic _ gf aztec _ data = new generic _ gf ( 0 , NUM , 1 ) ; public static generic _ gf aztec _ data = new generic _ gf ( 0 , NUM , 1 ) ; public static generic _ gf aztec _ param = new generic _ gf ( 0 , NUM , 1 ) ;
public static generic _ gf data _ matrix _ field = new generic _ gf ( 0 d , NUM , 1 ) ; public static generic _ gf aztec _ data = data _ matrix _ field ; public static generic _ gf maxicode _ field = aztec _ data ;
static class geosite _ updater
public static event event _ handler < result _ event _ args > update _ completed ; public class result _ event _ args : event _ args { public bool success ; public result _ event _ args ( bool success ) { this . success = success ; } }
console . write _ line ( e . message ) ;
private delegate get _ delegate _ via _ method _ name ( type type , string methodname ) { if ( type = = null ) throw new argument _ null _ exception ( nameof ( type ) ) ;
type delegate _ type = type . get _ type ( STR ) . get _ nested _ type ( STR ) ; method _ info dyn _ method = type . get _ method ( methodname ,
return dyn _ method = = null ? null : delegate . create _ delegate ( delegate _ type , this , dyn _ method ) ;
using shadowsocks _ util ;
namespace shadowsocks _ util
public static void init ( )
color fly _ blue = color . from _ argb ( NUM , NUM , NUM ) ;
icon _ copy . set _ pixel ( x , y , color . from _ argb ( color . a , red , green , blue ) ) ;
privoxy _ runner . stop ( ) ;
privoxy _ runner . start ( config ) ;
services . add ( new port _ forwarder ( privoxy _ runner . running _ port ) ) ;
static extern int _ ptr create _ job _ object ( int _ ptr a , string lp _ name ) ;
static extern bool set _ information _ job _ object ( int _ ptr h _ job , job _ object _ info _ type info _ type , int _ ptr lp _ job _ object _ info , u _ int cb _ job _ object _ info _ length ) ;
static extern bool assign _ process _ to _ job _ object ( int _ ptr job , int _ ptr process ) ;
static extern bool close _ handle ( int _ ptr h _ object ) ;
int length = marshal . size _ of ( typeof ( jobobject _ extended _ limit _ information ) ) ; int _ ptr extended _ info _ ptr = marshal . alloc _ h _ global ( length ) ; marshal . structure _ to _ ptr ( extended _ info , extended _ info _ ptr , false ) ; if ( ! set _ information _ job _ object ( handle , job _ object _ info _ type . extended _ limit _ information , extended _ info _ ptr , ( uint ) length ) ) throw new exception ( string . format ( STR , marshal . get _ last _ win _ error ( ) ) ) ;
servers _ list _ box . items . clear ( ) ; foreach ( server server in modified _ configuration . configs ) { servers _ list _ box . items . add ( server . server ) ; }
old _ selected _ index = servers _ list _ box . selected _ index ;
STR , STR ,
using open _ ss _ core ; using open _ ss _ crypto ; using system ;
int iv _ len = cipher . iv _ length ;
native . rand _ bytes ( iv , iv . length ) ;
int out _ len = length + cipher . block _ size ;
native . evp _ cipher _ update ( encrypt _ ctx , cipher _ text , out out _ len , buf , length ) ;
int out _ len = length + cipher . block _ size ;
native . evp _ cipher _ update ( encrypt _ ctx , cipher _ text , out out _ len , buf , length ) ;
int iv _ len = cipher . iv _ length ;
int out _ len = length + cipher . block _ size ;
native . evp _ cipher _ update ( decrypt _ ctx , cipher _ text , out out _ len , subset , length - iv _ len ) ;
int out _ len = length + cipher . block _ size ;
native . evp _ cipher _ update ( decrypt _ ctx , cipher _ text , out out _ len , buf , length ) ;
private static readonly dictionary < string , cipher > cached _ ciphers = new dictionary < string , cipher > ( ) ;
private cipher cipher ;
cipher = cached _ ciphers [ k ] ; return ;
cipher = cipher . create _ by _ name ( method ) ; if ( cipher = = null )
throw new null _ reference _ exception ( ) ;
byte [ ] passbuf = encoding . ut . get _ bytes ( password ) ; key = new byte [ cipher . key _ length ] ; byte [ ] iv = new byte [ cipher . iv _ length ] ; native . evp _ bytes _ to _ key ( cipher . handle , message _ digest . m . handle , null , passbuf , passbuf . length , 1 , key , iv ) ; cached _ keys [ k ] = key ; cached _ ciphers [ k ] = cipher ;
ctx = native . openssl _ malloc ( marshal . size _ of ( typeof ( cipher _ context . evp _ cipher _ ctx ) ) ) ;
native . evp _ cipher _ ctx _ init ( ctx ) ; native . expect _ success ( native . evp _ cipher _ init _ ex ( ctx , cipher . handle , int _ ptr . zero , null , null , enc ) ) ; native . expect _ success ( native . evp _ cipher _ ctx _ set _ key _ length ( ctx , key . length ) ) ; native . expect _ success ( native . evp _ cipher _ ctx _ set _ padding ( ctx , 1 ) ) ; native . expect _ success ( native . evp _ cipher _ init _ ex ( ctx , cipher . handle , int _ ptr . zero , key , iv , enc ) ) ;
if ( privoxy _ runner = = null ) { privoxy _ runner = new privoxy _ runner ( ) ; } if ( pac _ daemon = = null ) { pac _ daemon = new pac _ daemon ( ) ; pac _ daemon . pac _ file _ changed + = pac _ daemon _ pac _ file _ changed ; pac _ daemon . user _ rule _ file _ changed + = pac _ daemon _ user _ rule _ file _ changed ; } if ( pac _ server = = null ) { pac _ server = new pac _ server ( pac _ daemon ) ; } if ( gfw _ list _ updater = = null ) { gfw _ list _ updater = new gfw _ list _ updater ( ) ; gfw _ list _ updater . update _ completed + = pac _ server _ pac _ update _ completed ; gfw _ list _ updater . error + = pac _ server _ pac _ update _ error ; }
if ( listener ! = null ) { listener . stop ( ) ; }
if ( strategy ! = null ) { strategy . reload _ servers ( ) ; }
namespace shadowsocks _ controller { class auto _ startup { public static bool set ( bool enabled ) { try { string path = application . executable _ path ; registry _ key run _ key = microsoft . win . registry . current _ user . open _ sub _ key ( STR , true ) ; if ( enabled ) {  run _ key . set _ value ( STR , path ) ;   } else { run _ key . delete _ value ( STR ) ; } run _ key . close ( ) ; return true ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; return false ; } } public static bool check ( ) { try { string path = application . executable _ path ; registry _ key run _ key = microsoft . win . registry . current _ user . open _ sub _ key ( STR ) ; string [ ] run _ list = run _ key . get _ value _ names ( ) ; run _ key . close ( ) ; foreach ( string item in run _ list ) { if ( item . equals ( STR ) ) return true ; } return false ;
return false ;
} } }
create _ menu _ item ( STR , new event _ handler ( this . edit _ pac _ file _ item _ click ) ) , create _ menu _ item ( STR , new event _ handler ( this . update _ pac _ from _ gfw _ list _ item _ click ) ) ,
catch ( invalid _ operation _ exception )
string server _ str ;  var host _ type = uri . check _ host _ name ( server ) ; switch ( host _ type ) { case uri _ host _ name _ type . i _ pv : server _ str = $ STR ; break ; default :  server _ str = $ STR ; break ; }
private static bool failed = false ;
public static void update ( configuration config , bool force _ disable , pac _ server pac _ srv )
if ( failed ) return ;
switch ( ex . type )
case proxy _ exception _ type . fail _ to _ run : message _ box . show ( n . get _ string ( STR ) , n . get _ string ( STR ) ) ; break ; case proxy _ exception _ type . query _ return _ malformed : case proxy _ exception _ type . query _ return _ empty : message _ box . show ( n . get _ string ( STR ) , n . get _ string ( STR ) ) ; break ; case proxy _ exception _ type . sysproxy _ exit _ error : message _ box . show ( n . get _ string ( STR ) + ex . message , n . get _ string ( STR ) ) ; break ;
public void enable ( )
registry _ key registry = registry . current _ user . open _ sub _ key ( STR , true ) ; registry . set _ value ( STR , 1 ) ; registry . set _ value ( STR , STR ) ;
public void disable ( )
settings _ return = internet _ set _ option ( int _ ptr . zero , internet _ option _ settings _ changed , int _ ptr . zero , 0 ) ; refresh _ return = internet _ set _ option ( int _ ptr . zero , internet _ option _ refresh , int _ ptr . zero , 0 ) ;
using raw _ statistics = dictionary < string , list < availability _ statistics . raw _ statistics _ data > > ; using statistics = dictionary < string , list < availability _ statistics . statistics _ data > > ;
public raw _ statistics raw _ statistics { get ; private set ; } public raw _ statistics filtered _ statistics { get ; private set ; } private int repeat = > config . repeat _ times _ num ;
var reply = ping . send ( ip , timeout ) ;
thread . sleep ( new random ( ) . next ( ) % timeout ) ;
logging . debug ( remote , bytes _ to _ send , STR , STR ) ;
this . by _ isp _ check _ box = new system . windows . forms . check _ box ( ) ;
this . label = new system . windows . forms . label ( ) ;
private system . windows . forms . check _ box by _ isp _ check _ box ;
private system . windows . forms . label label ;
private const int timeout _ milliseconds = NUM ; public static readonly date _ time unknown _ date _ time = new date _ time ( NUM , 1 , 1 ) ;
private readonly time _ span delay _ before _ start = time _ span . from _ seconds ( 1 ) ; private readonly time _ span monitor _ interval = time _ span . from _ seconds ( 1 ) ; private readonly time _ span retry _ interval = time _ span . from _ minutes ( 2 ) ; private readonly time _ span writing _ interval = time _ span . from _ minutes ( 1 ) ; private statistics _ strategy _ configuration config ; private shadowsocks _ controller controller ; private server current _ server ;  private list < int > inbound _ speed _ records ; private long last _ inbound _ counter ; private long last _ outbound _ counter ; private list < int > latency _ records ; private list < int > outbound _ speed _ records ; private timer recorder ; private list < server > servers ; private timer speed _ monior ; private timer writer ;
} private availability _ statistics ( ) { raw _ statistics = new statistics ( ) ; }
private int repeat = > config . repeat _ times _ num ; private time _ span recording _ interval = > time _ span . from _ minutes ( config . data _ collection _ minutes ) ; public bool set ( statistics _ strategy _ configuration config ) { config = config ; try { if ( config . statistics _ enabled ) { if ( recorder ? . change ( delay _ before _ start , recording _ interval ) = = null ) { recorder = new timer ( run , null , delay _ before _ start , recording _ interval ) ; }
if ( speed _ monior ? . change ( delay _ before _ start , monitor _ interval ) = = null ) { speed _ monior = new timer ( update _ speed , null , delay _ before _ start , monitor _ interval ) ; } if ( writer ? . change ( delay _ before _ start , recording _ interval ) = = null ) { writer = new timer ( save , null , delay _ before _ start , recording _ interval ) ; }
} return true ;
return false ; } } private void update _ speed ( object state )
append _ record ( ) ;
private async void append _ record ( ) {  var icmp _ results = task _ ex . when _ all ( servers . select ( icmp _ test ) ) ; var current _ server _ record = new statistics _ record ( current _ server . identifier ( ) , inbound _ speed _ records , outbound _ speed _ records , latency _ records ) ;
list < statistics _ record > records ; if ( ! raw _ statistics . try _ get _ value ( result . server . identifier ( ) , out records ) ) { records = new list < statistics _ record > ( ) ; } if ( result . server . equals ( current _ server ) )
records . add ( current _ server _ record ) ;
records . add ( new statistics _ record ( result . server . identifier ( ) , result . roundtrip _ time ) ) ; } raw _ statistics [ result . server . identifier ( ) ] = records ; }
private static void append ( data _ list data _ list , i _ enumerable < data _ unit > extra ) { var data = data _ list . concat ( extra ) ; var data _ line = string . join ( delimiter , data . select ( kv = > kv . value ) . to _ array ( ) ) ; string [ ] lines ; if ( ! file . exists ( availability _ statistics _ file ) ) { var header _ line = string . join ( delimiter , data . select ( kv = > kv . key ) . to _ array ( ) ) ; lines = new [ ] { header _ line , data _ line } ; } else { lines = new [ ] { data _ line } ; } try { file . append _ all _ lines ( availability _ statistics _ file , lines ) ; } catch ( io _ exception e ) { logging . log _ useful _ exception ( e ) ; } } * / internal void update _ configuration ( shadowsocks _ controller controller ) { controller = controller ; current _ server = controller . get _ current _ server ( ) ; reset ( ) ; set ( controller . statistics _ configuration ) ; servers = controller . get _ current _ configuration ( ) . configs ; }
if ( config . by _ hour _ of _ day ) { var current _ hour = date _ time . now . hour ;
var old _ server = current _ server ; if ( old _ server = = null )
} if ( old _ server ! = current _ server ) {
private void wrap _ text _ check _ box _ checked _ changed ( object sender , event _ args e ) { log _ message _ text _ box . word _ wrap = wrap _ text _ check _ box . checked ; log _ message _ text _ box . scroll _ to _ caret ( ) ;
log _ message _ text _ box . clear ( ) ; } private void change _ font _ button _ click ( object sender , event _ args e )
this . top _ most = top _ most _ check _ box . checked ;
this . context _ menu _ strip = new system . windows . forms . context _ menu _ strip ( this . components ) ; this . main _ menu = new system . windows . forms . main _ menu ( this . components ) ;
this . panel = new system . windows . forms . panel ( ) ;
this . top _ most _ check _ box = new system . windows . forms . check _ box ( ) ; this . panel . suspend _ layout ( ) ;
this . panel . controls . add ( this . top _ most _ check _ box ) ; this . panel . controls . add ( this . change _ font _ button ) ; this . panel . controls . add ( this . clean _ logs _ button ) ; this . panel . controls . add ( this . wrap _ text _ check _ box ) ; this . panel . dock = system . windows . forms . dock _ style . fill ; this . panel . location = new system . drawing . point ( NUM , NUM ) ; this . panel . name = STR ; this . panel . size = new system . drawing . size ( NUM , NUM ) ; this . panel . tab _ index = 1 ;
this . change _ font _ button . location = new system . drawing . point ( NUM , NUM ) ;
this . clean _ logs _ button . location = new system . drawing . point ( NUM , NUM ) ;
this . table _ layout _ panel . controls . add ( this . panel , 0 , 0 ) ;
this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ;
this . top _ most _ check _ box . auto _ size = true ; this . top _ most _ check _ box . location = new system . drawing . point ( NUM , NUM ) ; this . top _ most _ check _ box . name = STR ; this . top _ most _ check _ box . size = new system . drawing . size ( NUM , NUM ) ; this . top _ most _ check _ box . tab _ index = NUM ; this . top _ most _ check _ box . text = STR ; this . top _ most _ check _ box . use _ visual _ style _ back _ color = true ; this . top _ most _ check _ box . checked _ changed + = new system . event _ handler ( this . top _ most _ check _ box _ checked _ changed ) ;
this . panel . resume _ layout ( false ) ; this . panel . perform _ layout ( ) ;
private system . windows . forms . context _ menu _ strip context _ menu _ strip ; private system . windows . forms . main _ menu main _ menu ;
private system . windows . forms . panel panel ;
int target _ port ;
this . target _ port = target _ port ;
new handler ( ) . start ( first _ packet , length , socket , this . target _ port ) ;
class handler
public const int recv _ size = NUM ;
this . first _ packet = first _ packet ; this . first _ packet _ length = length ; this . local = socket ;
this . close ( ) ;
new async _ callback ( pipe _ remote _ receive _ callback ) , null ) ;
new async _ callback ( pipe _ connection _ receive _ callback ) , null ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; this . close ( ) ;
remote . begin _ receive ( this . remote _ recv _ buffer , 0 , recv _ size , 0 , new async _ callback ( pipe _ remote _ receive _ callback ) , null ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; this . close ( ) ;
this . close ( ) ;
if ( cached _ keys . contains _ key ( k ) ) {
} else { byte [ ] passbuf = encoding . ut . get _ bytes ( password ) ; key = new byte [ NUM ] ; byte [ ] iv = new byte [ NUM ] ; bytes _ to _ key ( passbuf , key ) ; cached _ keys [ k ] = key ; }
namespace shadowsocks _ proxy
public class direct _ connect : i _ proxy
namespace shadowsocks _ proxy
public class http _ proxy : i _ proxy
using shadowsocks _ proxy ;
namespace shadowsocks _ proxy
public interface i _ proxy
namespace shadowsocks _ proxy
public class socks _ proxy : i _ proxy
system . windows . forms . data _ visualization . charting . chart _ area chart _ area = new system . windows . forms . data _ visualization . charting . chart _ area ( ) ; system . windows . forms . data _ visualization . charting . legend legend = new system . windows . forms . data _ visualization . charting . legend ( ) ; system . windows . forms . data _ visualization . charting . series series = new system . windows . forms . data _ visualization . charting . series ( ) ; system . windows . forms . data _ visualization . charting . series series = new system . windows . forms . data _ visualization . charting . series ( ) ; system . windows . forms . data _ visualization . charting . series series = new system . windows . forms . data _ visualization . charting . series ( ) ;
this . check _ box = new system . windows . forms . check _ box ( ) ;
this . numeric _ up _ down = new system . windows . forms . numeric _ up _ down ( ) ; this . check _ box = new system . windows . forms . check _ box ( ) ; this . numeric _ up _ down = new system . windows . forms . numeric _ up _ down ( ) ;
this . flow _ layout _ panel = new system . windows . forms . flow _ layout _ panel ( ) ; this . panel = new system . windows . forms . panel ( ) ; this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ; this . text _ box = new system . windows . forms . text _ box ( ) ; this . combo _ box = new system . windows . forms . combo _ box ( ) ;
( ( system . component _ model . i _ support _ initialize ) ( this . numeric _ up _ down ) ) . begin _ init ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . numeric _ up _ down ) ) . begin _ init ( ) ;
this . flow _ layout _ panel . suspend _ layout ( ) ; this . panel . suspend _ layout ( ) ;
this . split _ container . panel . paint + = new system . windows . forms . paint _ event _ handler ( this . split _ container _ panel _ paint ) ;
this . split _ container . panel . controls . add ( this . numeric _ up _ down ) ; this . split _ container . panel . controls . add ( this . check _ box ) ; this . split _ container . panel . controls . add ( this . numeric _ up _ down ) ;
this . split _ container . panel . controls . add ( this . check _ box ) ;
this . numeric _ up _ down . location = new system . drawing . point ( NUM , NUM ) ; this . numeric _ up _ down . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . numeric _ up _ down . maximum = new decimal ( new int [ ] { NUM , 0 , 0 , 0 } ) ; this . numeric _ up _ down . name = STR ; this . numeric _ up _ down . size = new system . drawing . size ( NUM , NUM ) ; this . numeric _ up _ down . tab _ index = NUM ;    this . check _ box . auto _ size = true ; this . check _ box . location = new system . drawing . point ( NUM , NUM ) ; this . check _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . check _ box . name = STR ; this . check _ box . size = new system . drawing . size ( NUM , NUM ) ; this . check _ box . tab _ index = NUM ; this . check _ box . text = STR ; this . check _ box . use _ visual _ style _ back _ color = true ;    this . numeric _ up _ down . location = new system . drawing . point ( NUM , NUM ) ; this . numeric _ up _ down . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . numeric _ up _ down . maximum = new decimal ( new int [ ] {
this . numeric _ up _ down . name = STR ; this . numeric _ up _ down . size = new system . drawing . size ( NUM , NUM ) ; this . numeric _ up _ down . tab _ index = NUM ; this . numeric _ up _ down . value = new decimal ( new int [ ] {
this . load + = new system . event _ handler ( this . statistics _ strategy _ options _ form _ load ) ;
( ( system . component _ model . i _ support _ initialize ) ( this . numeric _ up _ down ) ) . end _ init ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . numeric _ up _ down ) ) . end _ init ( ) ;
this . flow _ layout _ panel . resume _ layout ( false ) ; this . flow _ layout _ panel . perform _ layout ( ) ; this . panel . resume _ layout ( false ) ; this . panel . perform _ layout ( ) ;
private system . windows . forms . check _ box check _ box ;
private system . windows . forms . flow _ layout _ panel flow _ layout _ panel ;
private system . windows . forms . panel panel ; private system . windows . forms . label label ; private system . windows . forms . label label ; private system . windows . forms . text _ box text _ box ; private system . windows . forms . combo _ box combo _ box ; private system . windows . forms . numeric _ up _ down numeric _ up _ down ;
private system . windows . forms . check _ box check _ box ; private system . windows . forms . numeric _ up _ down numeric _ up _ down ;
class simply _ choose _ by _ statistics _ strategy : i _ strategy
public simply _ choose _ by _ statistics _ strategy ( shadowsocks _ controller controller )
private static void statistics _ strategy _ options _ item _ click ( object sender , event _ args e )
var statistics _ strategy _ options _ form = new statistics _ strategy _ options _ form ( ) ;
logging . debug ( string . format ( STR , best _ result . server . friendly _ name ( ) , best _ result . score ) ) ;
string i _ strategy . id
string i _ strategy . name
server i _ strategy . get _ a _ server ( i _ strategy _ caller _ type type , ip _ end _ point local _ ip _ end _ point )
console . write _ line ( STR , current _ server . friendly _ name ( ) ) ;
void i _ strategy . reload _ servers ( )
void i _ strategy . set _ failure ( server server )
void i _ strategy . update _ last _ read ( server server )
void i _ strategy . update _ last _ write ( server server )
void i _ strategy . update _ latency ( server server , time _ span latency )
server server = configuration . get _ default _ server ( ) ; modified _ configuration . configs . add ( server ) ;
if ( ! validate _ and _ save _ selected _ server _ details ( ) )
register _ application _ restart ( null , ( int ) application _ restart _ flags . restart _ no _ crash | ( int ) application _ restart _ flags . restart _ no _ hang ) ; logging . debug ( STR ) ;
static void main ( )
private int compare ( byte x , byte y , u _ int a , int i ) { return ( int ) ( a % ( u _ int ) ( x + i ) ) - ( int ) ( a % ( u _ int ) ( y + i ) ) ;
private byte [ ] merge _ sort ( byte [ ] array , u _ int a , int j )
socket listener = new socket ( address _ family . inter _ network ,
new local ( NUM ) . start ( ) ;
if ( strategy ! = null ) { strategy . update _ last _ write ( server ) ; }
public static readonly string date _ time _ pattern = STR ;
private const int delay _ before _ start = NUM ;
private const int retry _ interval = 2 * NUM * NUM ; private int interval = > ( int ) time _ span . from _ minutes ( config . data _ collection _ minutes ) . total _ milliseconds ;
public availability _ statistics ( configuration config , statistics _ strategy _ configuration statistics _ config ) { update _ configuration ( config , statistics _ config ) ;
await geolocation _ and _ isp ;
process . kill ( ) ;
ip _ global _ properties properties = ip _ global _ properties . get _ ip _ global _ properties ( ) ; ip _ end _ point [ ] tcp _ end _ points = properties . get _ active _ tcp _ listeners ( ) ; list < int > used _ ports = new list < int > ( ) ; foreach ( ip _ end _ point end _ point in ip _ global _ properties . get _ ip _ global _ properties ( ) . get _ active _ tcp _ listeners ( ) )
used _ ports . add ( end _ point . port ) ;
for ( int port = NUM ; port < NUM ; port + + )
if ( ! used _ ports . contains ( port ) ) { return port ; }
change _ to _ pac _ text _ box . text = config . change _ to _ pac ; change _ to _ global _ text _ box . text = config . change _ to _ global ;
change _ to _ pac _ label . text = n . get _ string ( STR ) ; change _ to _ global _ label . text = n . get _ string ( STR ) ;
public string change _ to _ pac ; public string change _ to _ global ;
change _ to _ pac = STR ; change _ to _ global = STR ;
this . change _ to _ pac _ label = new system . windows . forms . label ( ) ; this . change _ to _ global _ label = new system . windows . forms . label ( ) ;
this . change _ to _ pac _ text _ box = new system . windows . forms . text _ box ( ) ; this . change _ to _ global _ text _ box = new system . windows . forms . text _ box ( ) ;
this . table _ layout _ panel . controls . add ( this . change _ to _ pac _ label , 0 , 1 ) ; this . table _ layout _ panel . controls . add ( this . change _ to _ global _ label , 0 , 2 ) ; this . table _ layout _ panel . controls . add ( this . switch _ allow _ lan _ label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . show _ logs _ label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . server _ move _ up _ label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . server _ move _ down _ label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( flow _ layout _ panel , 0 , NUM ) ;
this . table _ layout _ panel . controls . add ( this . change _ to _ pac _ text _ box , 1 , 1 ) ; this . table _ layout _ panel . controls . add ( this . change _ to _ global _ text _ box , 1 , 2 ) ; this . table _ layout _ panel . controls . add ( this . switch _ allow _ lan _ text _ box , 1 , NUM ) ; this . table _ layout _ panel . controls . add ( this . show _ logs _ text _ box , 1 , NUM ) ; this . table _ layout _ panel . controls . add ( this . server _ move _ up _ text _ box , 1 , NUM ) ; this . table _ layout _ panel . controls . add ( this . server _ move _ down _ text _ box , 1 , NUM ) ;
private system . windows . forms . label change _ to _ pac _ label ; private system . windows . forms . label change _ to _ global _ label ;
private system . windows . forms . text _ box change _ to _ global _ text _ box ; private system . windows . forms . text _ box change _ to _ pac _ text _ box ;
run _ key = microsoft . win . registry . current _ user . open _ sub _ key ( STR , true ) ;
if ( item . equals ( key ) )
else if ( item . equals ( STR ) )
dll _ import _ kernel _ dll _ char _ set _ char _ set _ unicode private static extern int _ ptr create _ job _ object ( int _ ptr a , string lp _ name ) ; dll _ import _ kernel _ dll _ set _ last _ error _ true private static extern bool set _ information _ job _ object ( int _ ptr h _ job , job _ object _ info _ type info _ type , int _ ptr lp _ job _ object _ info , u _ int cb _ job _ object _ info _ length ) ; dll _ import _ kernel _ dll _ set _ last _ error _ true private static extern bool assign _ process _ to _ job _ object ( int _ ptr job , int _ ptr process ) ; dll _ import _ kernel _ dll _ set _ last _ error _ true return _ marshal _ as _ unmanaged _ type _ bool private static extern bool close _ handle ( int _ ptr h _ object ) ;
private bool disposed ;
this . tool _ strip _ separator = new system . windows . forms . tool _ strip _ separator ( ) ;
this . tool _ strip _ separator . name = STR ; this . tool _ strip _ separator . size = new system . drawing . size ( NUM , NUM ) ;
this . form _ closed + = new system . windows . forms . form _ closed _ event _ handler ( this . form _ form _ closed ) ;
ip _ host _ entry ip _ host _ info = dns . get _ host _ entry ( config . server ) ; ip _ address ip _ address = ip _ host _ info . address _ list [ 0 ] ;  ip _ end _ point remote _ ep = new ip _ end _ point ( ip _ address , config . server _ port ) ; remote = new socket ( ip _ address . address _ family , socket _ type . stream , protocol _ type . tcp ) ;  remote . begin _ connect ( remote _ ep , new async _ callback ( connect _ callback ) , null ) ;
remote . close ( ) ;
using system _ runtime _ serialization _ json ;
non _ serialized
data _ contract _ json _ serializer ser = new data _ contract _ json _ serializer ( typeof ( config ) ) ;
using ( file _ stream fs = file . open _ read ( STR ) )
config config = ser . read _ object ( fs ) as config ;
data _ contract _ json _ serializer ser = new data _ contract _ json _ serializer ( typeof ( config ) ) ;
using ( file _ stream fs = file . open ( STR , file _ mode . create ) )
ser . write _ object ( fs , config ) ;
this . context _ menu = new system . windows . forms . context _ menu ( new system . windows . forms . menu _ item [ ] { this . enable _ item = create _ menu _ item ( STR , new system . event _ handler ( this . enable _ item _ click ) ) , create _ menu _ group ( STR , new system . windows . forms . menu _ item [ ] { this . pac _ mode _ item = create _ menu _ item ( STR , new system . event _ handler ( this . pac _ mode _ item _ click ) ) , this . global _ mode _ item = create _ menu _ item ( STR , new system . event _ handler ( this . global _ mode _ item _ click ) )
this . servers _ item = create _ menu _ group ( STR , new system . windows . forms . menu _ item [ ] {
this . config _ item = create _ menu _ item ( STR , new system . event _ handler ( this . config _ click ) )
this . auto _ startup _ item = create _ menu _ item ( STR , new system . event _ handler ( this . auto _ startup _ item _ click ) ) , this . share _ over _ lan _ item = create _ menu _ item ( STR , new system . event _ handler ( this . share _ over _ lan _ item _ click ) ) , create _ menu _ item ( STR , new system . event _ handler ( this . edit _ pac _ file _ item _ click ) ) ,
create _ menu _ item ( STR , new system . event _ handler ( this . qr _ code _ item _ click ) ) , create _ menu _ item ( STR , new system . event _ handler ( this . show _ log _ item _ click ) ) , create _ menu _ item ( STR , new system . event _ handler ( this . config _ click ) ) ,
create _ menu _ item ( STR , new system . event _ handler ( this . quit _ click ) )
console . write _ line ( e . to _ string ( ) ) ;
dll _ import _ kernel _ dll private static extern int _ ptr load _ library ( string path ) ; public const int m _ ctx _ size = NUM ;
mbed _ tls . md ( input , ( uint ) input . length , output ) ;
public extern static void md ( byte [ ] input , uint ilen , byte [ ] output ) ;
protected dictionary < string , int [ ] > ciphers ;
protected int encrypt _ iv _ offset = 0 ; protected int decrypt _ iv _ offset = 0 ;
protected abstract dictionary < string , int [ ] > get _ ciphers ( ) ;
cipher _ info = ciphers [ method ] ;
key _ len = ciphers [ method ] [ 0 ] ; iv _ len = ciphers [ method ] [ 1 ] ;
private static dictionary < string , int [ ] > ciphers = new dictionary < string , int [ ] > { { STR , new int [ ] { NUM , NUM , cipher _ sals , polar _ ssl . aes _ ctx _ size } } , { STR , new int [ ] { NUM , NUM , cipher _ chach , polar _ ssl . aes _ ctx _ size } } , { STR , new int [ ] { NUM , NUM , cipher _ chach _ ietf , polar _ ssl . aes _ ctx _ size } } ,
protected override dictionary < string , int [ ] > get _ ciphers ( )
public void test _ polar _ ssl _ encryption ( )
thread t = new thread ( new thread _ start ( run _ single _ polar _ ssl _ encryption _ thread ) ) ;
private void run _ single _ polar _ ssl _ encryption _ thread ( )
encryptor = new polar _ ssl _ encryptor ( STR , STR , false , false ) ; decryptor = new polar _ ssl _ encryptor ( STR , STR , false , false ) ;
if ( ret ! = 0 ) throw new crypto _ error _ exception ( ) ;
return ret ;
public override int cipher _ decrypt ( byte [ ] ciphertext , uint clen , byte [ ] plaintext , ref uint plen )
if ( ret ! = 0 ) throw new crypto _ error _ exception ( ) ;
return ret ;
foreach ( string method in stream _ mbed _ tls _ encryptor . supported _ ciphers ( ) )
registered _ encryptors . add ( method , typeof ( stream _ mbed _ tls _ encryptor ) ) ;
registered _ encryptors . add ( method , typeof ( stream _ sodium _ encryptor ) ) ;
registered _ encryptors . add ( method , typeof ( aead _ mbed _ tls _ encryptor ) ) ; } foreach ( string method in aead _ sodium _ encryptor _ supported _ ciphers ) { registered _ encryptors . add ( method , typeof ( aead _ sodium _ encryptor ) ) ;
if ( ret ! = 0 ) throw new crypto _ error _ exception ( ) ;
return ret ;
public override int cipher _ decrypt ( byte [ ] ciphertext , uint clen , byte [ ] plaintext , ref uint plen )
if ( ret ! = 0 ) throw new crypto _ error _ exception ( ) ;
return ret ;
this . context _ menu _ strip = new system . windows . forms . context _ menu _ strip ( this . components ) ; this . main _ menu = new system . windows . forms . main _ menu ( this . components ) ;
this . panel = new system . windows . forms . panel ( ) ;
this . top _ most _ check _ box = new system . windows . forms . check _ box ( ) ; this . panel . suspend _ layout ( ) ;
this . panel . controls . add ( this . top _ most _ check _ box ) ; this . panel . controls . add ( this . change _ font _ button ) ; this . panel . controls . add ( this . clean _ logs _ button ) ; this . panel . controls . add ( this . wrap _ text _ check _ box ) ; this . panel . dock = system . windows . forms . dock _ style . fill ; this . panel . location = new system . drawing . point ( NUM , NUM ) ; this . panel . name = STR ; this . panel . size = new system . drawing . size ( NUM , NUM ) ; this . panel . tab _ index = 1 ;
this . change _ font _ button . location = new system . drawing . point ( NUM , NUM ) ;
this . clean _ logs _ button . location = new system . drawing . point ( NUM , NUM ) ;
this . table _ layout _ panel . controls . add ( this . panel , 0 , 0 ) ;
this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ;
this . top _ most _ check _ box . auto _ size = true ; this . top _ most _ check _ box . location = new system . drawing . point ( NUM , NUM ) ; this . top _ most _ check _ box . name = STR ; this . top _ most _ check _ box . size = new system . drawing . size ( NUM , NUM ) ; this . top _ most _ check _ box . tab _ index = NUM ; this . top _ most _ check _ box . text = STR ; this . top _ most _ check _ box . use _ visual _ style _ back _ color = true ; this . top _ most _ check _ box . checked _ changed + = new system . event _ handler ( this . top _ most _ check _ box _ checked _ changed ) ;
this . panel . resume _ layout ( false ) ; this . panel . perform _ layout ( ) ;
private system . windows . forms . context _ menu _ strip context _ menu _ strip ; private system . windows . forms . main _ menu main _ menu ;
private system . windows . forms . panel panel ;
private void wrap _ text _ check _ box _ checked _ changed ( object sender , event _ args e ) { log _ message _ text _ box . word _ wrap = wrap _ text _ check _ box . checked ; log _ message _ text _ box . scroll _ to _ caret ( ) ;
log _ message _ text _ box . clear ( ) ; } private void change _ font _ button _ click ( object sender , event _ args e )
this . top _ most = top _ most _ check _ box . checked ;
int atyp = connetion _ recv _ buffer [ NUM ] ; switch ( atyp )
case 1 : read _ address ( NUM + 2 - 1 ) ; break ; case NUM : int len = connetion _ recv _ buffer [ NUM ] ; read _ address ( len + 2 ) ; break ; case NUM : read _ address ( NUM + 2 - 1 ) ; break ; default : logging . debug ( STR + atyp ) ; close ( ) ; break ;
private void read _ address ( int bytes _ remain )
connection . begin _ receive ( connetion _ recv _ buffer , 2 , recv _ size - 2 , socket _ flags . none , on _ address _ fully _ read , bytes _ remain ) ;
int bytes _ remain = ( int ) ar . async _ state ;
if ( remarks . is _ null _ or _ empty ( ) ) { return server + STR + server _ port ;
else { return remarks + STR + server + STR + server _ port + STR ; }
if ( ! line . starts _ with ( STR ) ) { headers . enqueue ( line ) ; }
var method = m . groups [ 1 ] . value ;
if ( ! parse _ host ( m . groups [ 2 ] . value ) )
} } else {
if ( bytes _ read > 0 ) {
connection . begin _ send ( response , 0 , response . length , 0 , new async _ callback ( start _ pipe ) , null ) ;
this . pac _ url _ text _ box . location = new system . drawing . point ( NUM , NUM ) ;
this . pac _ url _ label . location = new system . drawing . point ( NUM , NUM ) ;
this . client _ size = new system . drawing . size ( NUM , NUM ) ; this . controls . add ( this . cancel _ button ) ; this . controls . add ( this . ok _ button ) ; this . controls . add ( this . pac _ url _ text _ box ) ; this . controls . add ( this . pac _ url _ label ) ;
string encoding = default _ byte _ mode _ encoding ;
mode mode = mode . byte ;
if ( mode = = mode . byte & & generate _ eci ) { character _ set _ eci eci = character _ set _ eci . get _ character _ set _ eci _ by _ name ( encoding ) ; if ( eci ! = null ) { var eci _ is _ explicit _ disabled = ( hints ! = null & & hints . contains _ key ( encode _ hint _ type . disable _ eci ) ? ( bool ) hints [ encode _ hint _ type . disable _ eci ] : false ) ; if ( ! eci _ is _ explicit _ disabled ) { append _ eci ( eci , header _ bits ) ; } } } * * /
throw new exception ( STR ) ;
throw new exception ( STR ) ;
throw new exception ( STR ) ;
throw new exception ( STR ) ;
throw new exception ( num _ letters + STR + ( ( 1 < < num _ bits ) - 1 ) ) ;
throw new exception ( STR + mode ) ;
throw new exception ( uee . message , uee ) ;
throw new exception ( ) ;
throw new exception ( ) ;
pac _ server . start ( config ) ;
class pac _ server
private static configuration config ; socket listener ;
public void start ( configuration configuration )
config = configuration ;  listener = new socket ( address _ family . inter _ network , socket _ type . stream , protocol _ type . tcp ) ; listener . set _ socket _ option ( socket _ option _ level . socket , socket _ option _ name . reuse _ address , true ) ; ip _ end _ point local _ end _ point = null ; if ( configuration . share _ over _ lan )
local _ end _ point = new ip _ end _ point ( ip _ address . any , port ) ;
else
local _ end _ point = new ip _ end _ point ( ip _ address . loopback , port ) ;
listener . bind ( local _ end _ point ) ; listener . listen ( NUM ) ; listener . begin _ accept ( new async _ callback ( accept _ callback ) , listener ) ; watch _ pac _ file ( ) ;
catch ( socket _ exception )
listener . close ( ) ; throw ; } } public void stop ( ) { if ( listener ! = null ) { listener . close ( ) ; listener = null ;
private void receive _ callback ( i _ async _ result ar )
object [ ] state = ( object [ ] ) ar . async _ state ; socket conn = ( socket ) state [ 0 ] ; byte [ ] request _ buf = ( byte [ ] ) state [ 1 ] ;
int bytes _ read = conn . end _ receive ( ar ) ;
ip _ end _ point local _ end _ point = ( ip _ end _ point ) conn . local _ end _ point ; string proxy = get _ pac _ address ( request _ buf , local _ end _ point ) ;
if ( bytes _ read > 0 ) { string text = string . format ( @ STR
byte [ ] response = system . text . encoding . ut . get _ bytes ( text ) ; conn . begin _ send ( response , 0 , response . length , 0 , new async _ callback ( send _ callback ) , conn ) ; util . utils . release _ memory ( ) ; } else { conn . close ( ) ; }
conn . close ( ) ;
private string get _ pac _ address ( byte [ ] request _ buf , ip _ end _ point local _ end _ point )
string proxy = STR + local _ end _ point . address + STR ;              return proxy ;
public bool good _ for _ me ( byte [ ] first _ packet , int length ) { return true ; } public void handle ( byte [ ] first _ packet , int length , socket socket ) {
test _ method public void parse _ and _ generate _ shadowsocks _ url ( ) { var server = new server
var server _ canon _ url = STR ; var server = new server
var server _ canon _ url = STR ; var server _ with _ remark = new server { server = server . server , server _ port = server . server _ port , password = server . password , method = server . method ,
var server _ with _ remark _ canon _ url = STR ; var server _ with _ remark = new server
var server _ with _ remark _ canon _ url = STR ; var server _ with _ plugin = new server { server = server . server , server _ port = server . server _ port , password = server . password , method = server . method ,
var server _ with _ plugin _ canon _ url =
var server _ with _ plugin = new server
var server _ with _ plugin _ canon _ url =
var server _ with _ plugin _ and _ remark = new server { server = server . server , server _ port = server . server _ port , password = server . password , method = server . method , plugin = server _ with _ plugin . plugin , plugin _ opts = server _ with _ plugin . plugin _ opts , remarks = server _ with _ remark . remarks } ; var server _ with _ plugin _ and _ remark _ canon _ url =
var server _ with _ plugin _ and _ remark = new server
var server _ with _ plugin _ and _ remark _ canon _ url =
run _ parse _ shadowsocks _ url _ test ( string . join ( STR , server _ canon _ url ,
server , server , server _ with _ remark , server _ with _ remark } ) ;
public void sip _ plugin _ support ( )
string fake _ plugin = STR ;
private readonly i _ enumerable < text _ box > all _ text _ boxes ;
all _ text _ boxes = table _ layout _ panel . get _ child _ controls < text _ box > ( ) ; if ( ! all _ text _ boxes . any ( ) ) throw new exception ( STR ) ;
try _ reg _ hotkey _ from _ string ( hotkey _ config . switch _ system _ proxy , STR , switch _ system _ proxy _ label ) & & try _ reg _ hotkey _ from _ string ( hotkey _ config . switch _ system _ proxy _ mode , STR , switch _ proxy _ mode _ label ) & & try _ reg _ hotkey _ from _ string ( hotkey _ config . switch _ allow _ lan , STR , switch _ allow _ lan _ label ) & & try _ reg _ hotkey _ from _ string ( hotkey _ config . show _ logs , STR , show _ logs _ label ) & & try _ reg _ hotkey _ from _ string ( hotkey _ config . server _ move _ up , STR , server _ move _ up _ label ) & & try _ reg _ hotkey _ from _ string ( hotkey _ config . server _ move _ down , STR , server _ move _ down _ label ) ;
private bool try _ reg _ hotkey _ from _ string ( string hotkey _ str , string callback _ name , label indicator = null )
unreg _ prev _ hotkey ( callback ) ;
bool reg _ result = ( try _ reg _ hotkey ( hotkey , callback ) ) ;
private bool try _ reg _ hotkey ( global _ hot _ key . hot _ key hotkey , hot _ keys . hot _ key _ call _ back _ handler callback ) { unreg _ prev _ hotkey ( callback ) ; return hot _ keys . register ( hotkey , callback ) ; } private static void unreg _ prev _ hotkey ( hot _ keys . hot _ key _ call _ back _ handler cb ) { global _ hot _ key . hot _ key prev _ hot _ key ; if ( hot _ keys . is _ callback _ exists ( cb , out prev _ hot _ key ) ) {  hot _ keys . unregister ( prev _ hot _ key ) ; } }
list < string > ret = new list < string > ( domains . count + NUM ) ;
ret . add ( domain ) ;
update _ checker . check _ update ( config ) ;
this . table _ layout _ panel . controls . add ( this . encryption _ label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . encryption _ select , 1 , NUM ) ; this . table _ layout _ panel . controls . add ( this . timeout _ label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . timeout _ text _ box , 1 , NUM ) ; this . table _ layout _ panel . controls . add ( this . plugin _ label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . plugin _ options _ text _ box , 1 , NUM ) ;
this . table _ layout _ panel . row _ count = NUM ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ;  this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ;
var configuration = simple _ json . simple _ json . deserialize _ object < statistics _ strategy _ configuration > ( content ) ;
catch ( file _ not _ found _ exception )
this . binding _ configuration = new system . windows . forms . binding _ source ( this . components ) ; this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ;
this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ;
this . label = new system . windows . forms . label ( ) ;
this . label = new system . windows . forms . label ( ) ;
( ( system . component _ model . i _ support _ initialize ) ( this . binding _ configuration ) ) . begin _ init ( ) ;
this . split _ container . panel . controls . add ( this . label ) ; this . split _ container . panel . controls . add ( this . label ) ;
this . split _ container . panel . controls . add ( this . label ) ; this . split _ container . panel . controls . add ( this . label ) ;
this . split _ container . panel . controls . add ( this . label ) ;
this . split _ container . panel . controls . add ( this . label ) ;
this . label . auto _ size = true ; this . label . location = new system . drawing . point ( NUM , NUM ) ; this . label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ; this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ; this . label . tab _ index = 0 ; this . label . text = STR ; this . calculatin _ tip . set _ tool _ tip ( this . label , STR ) ;
( ( system . component _ model . i _ support _ initialize ) ( this . binding _ configuration ) ) . end _ init ( ) ;
private system . windows . forms . label label ; private system . windows . forms . label label ;
private system . windows . forms . label label ;
private system . windows . forms . label label ;
private system . windows . forms . label label ; private system . windows . forms . label label ;
create _ menu _ item ( STR , new event _ handler ( this . show _ log _ item _ click ) ) , this . verbose _ logging _ toggle _ item = create _ menu _ item ( STR , new event _ handler ( this . verbose _ logging _ toggle _ item _ click ) ) ,
create _ menu _ group ( STR , new menu _ item [ ] { create _ menu _ item ( STR , new event _ handler ( this . check _ updates _ item _ click ) ) , new menu _ item ( STR ) , this . auto _ check _ updates _ toggle _ item = create _ menu _ item ( STR , new event _ handler ( this . auto _ check _ updates _ toggle _ item _ click ) ) , this . check _ pre _ release _ toggle _ item = create _ menu _ item ( STR , new event _ handler ( this . check _ pre _ release _ toggle _ item _ click ) ) ,
create _ menu _ item ( STR , new event _ handler ( this . about _ item _ click ) ) ,
using newtonsoft _ json ;
using shadowsocks _ properties ;
using system _ linq ; using shadowsocks _ controller _ service ; using shadowsocks _ proxy ;
if ( enable _ status _ changed ! = null ) { enable _ status _ changed ( this , new event _ args ( ) ) ; }
if ( enable _ global _ changed ! = null ) { enable _ global _ changed ( this , new event _ args ( ) ) ; }
if ( share _ over _ lan _ status _ changed ! = null ) { share _ over _ lan _ status _ changed ( this , new event _ args ( ) ) ; }
if ( pac _ file _ ready _ to _ open ! = null ) { pac _ file _ ready _ to _ open ( this , new path _ event _ args ( ) { path = pac _ filename } ) ; }
if ( user _ rule _ file _ ready _ to _ open ! = null ) { user _ rule _ file _ ready _ to _ open ( this , new path _ event _ args ( ) { path = user _ rule _ filename } ) ; }
if ( availability _ statistics = = null ) return ; availability _ statistics . update _ configuration ( this ) ; config . availability _ statistics = enabled ; save _ config ( config ) ;
if ( config _ changed ! = null ) { config _ changed ( this , new event _ args ( ) ) ; }
if ( config _ changed ! = null ) { config _ changed ( this , new event _ args ( ) ) ; }
if ( config _ changed ! = null ) { config _ changed ( this , new event _ args ( ) ) ; }
if ( config _ changed ! = null ) { config _ changed ( this , new event _ args ( ) ) ; }
if ( config _ changed ! = null ) { config _ changed ( this , new event _ args ( ) ) ; }
if ( config _ changed ! = null ) { config _ changed ( this , new event _ args ( ) ) ; }
if ( config _ changed ! = null ) { config _ changed ( this , new event _ args ( ) ) ; }
list < listener . i _ service > services = new list < listener . i _ service > ( ) ; services . add ( tcp _ relay ) ; services . add ( udp _ relay ) ; services . add ( pac _ server ) ; services . add ( new port _ forwarder ( privoxy _ runner . running _ port ) ) ;
if ( e is socket _ exception ) { socket _ exception se = ( socket _ exception ) e ;
traffic _ thread = new thread ( new thread _ start ( ( ) = > traffic _ statistics ( queue _ max _ size ) ) ) ; traffic _ thread . is _ background = true ;
current = new traffic _ per _ second ( ) ; current . inbound _ counter = inbound _ counter ; current . outbound _ counter = outbound _ counter ;
if ( length > 0 ) {  array . copy ( first _ packge , index , line _ buffer , 0 , length ) ; buffer _ data _ length = length ; try { new _ package _ recv ( ) ; } catch ( exception ex ) { on _ exception ( ex ) ; on _ finish ( ) ; } } else {  socket . begin _ receive ( line _ buffer , 0 , max _ line _ bytes , 0 , receive _ callback , 0 ) ; } } public line _ reader ( wrapped _ socket socket , func < string , object , bool > on _ line _ read , action < exception , object > on _ exception , action < byte [ ] , int , int , object > on _ finish , encoding encoding , string delimiter , int max _ line _ bytes , object state ) : this ( socket , null , 0 , 0 , on _ line _ read , on _ exception , on _ finish , encoding , delimiter , max _ line _ bytes , state ) {
on _ finish ( ) ;
buffer _ data _ length + = bytes _ read ; new _ package _ recv ( ) ;
on _ finish ( ) ; } } private void new _ package _ recv ( ) { int i ; while ( ( i = index _ of ( line _ buffer , buffer _ data _ index , buffer _ data _ length , delimiter _ bytes , delimiter _ search _ offset _ table , delimiter _ search _ char _ table ) ) ! = - 1 ) { var decode _ len = i - buffer _ data _ index ; string line = encoding . get _ string ( line _ buffer , buffer _ data _ index , decode _ len ) ; buffer _ data _ index = i + delimiter _ bytes . length ; buffer _ data _ length - = decode _ len ; buffer _ data _ length - = delimiter _ bytes . length ; var stop = on _ line _ read ( line , state ) ; if ( stop ) { on _ finish ( ) ; return ; } } if ( buffer _ data _ length = = line _ buffer . length ) { on _ exception ( new index _ out _ of _ range _ exception ( STR ) ) ; on _ finish ( ) ; return ; } if ( buffer _ data _ index > 0 ) { buffer . block _ copy ( line _ buffer , buffer _ data _ index , line _ buffer , 0 , buffer _ data _ length ) ; buffer _ data _ index = 0 ; } socket . begin _ receive ( line _ buffer , buffer _ data _ length , line _ buffer . length - buffer _ data _ length , 0 , receive _ callback , buffer _ data _ length ) ;
private void on _ finish ( ) { on _ finish ? . invoke ( line _ buffer , buffer _ data _ index , buffer _ data _ length , state ) ;
private static int index _ of ( byte [ ] haystack , int index , int length , byte [ ] needle , int [ ] offset _ table , int [ ] char _ table )
catch ( exception )
private end _ point remote _ end _ point ;
remote _ end _ point = socket _ util . get _ end _ point ( server . server , server . server _ port ) ; remote = socket _ util . create _ socket ( remote _ end _ point , protocol _ type . udp ) ;
icon _ copy . set _ pixel ( x , y , color . from _ argb ( color . a , NUM , NUM , NUM ) ) ;
icon _ copy . set _ pixel ( x , y , color . from _ argb ( color . a , NUM , NUM , NUM ) ) ;
icon _ copy . set _ pixel ( x , y , color . from _ argb ( color . a , NUM , NUM , NUM ) ) ;
var ip = dns . get _ host _ addresses ( server . server ) . first ( ip = > ( ip . address _ family = = address _ family . inter _ network | | ip . address _ family = = address _ family . inter _ network ) ) ; var ping = new ping ( ) ;
foreach ( var timestamp in enumerable . range ( 0 , repeat ) . select ( = > date _ time . now . to _ string ( date _ time _ pattern ) ) ) {  try { var reply = await ping . send _ task _ async ( ip , timeout ) ; ret . add ( new list < key _ value _ pair < string , string > >
thread . sleep ( timeout + new random ( ) . next ( ) % timeout ) ;  } catch ( exception e ) { logging . error ( $ STR ) ; logging . log _ useful _ exception ( e ) ; }
socket _ util . begin _ connect _ tcp ( dest _ end _ point , callback , state ) ;
remote = socket _ util . end _ connect _ tcp ( async _ result ) ;
using system _ collections _ generic ; using system _ linq ;
using shadowsocks _ util ;
remote ? . close ( ) ;
remote = socket _ util . end _ connect _ tcp ( ar ) ;
private void enable _ item _ click ( object sender , event _ args e )
enable _ item . checked = ! enable _ item . checked ; if ( enable _ item . checked )
internal static string proxy _ pac {
return resource _ manager . get _ string ( STR , resource _ culture ) ;
string pac = resources . proxy _ pac ;
this . context _ menu _ strip = new system . windows . forms . context _ menu _ strip ( this . components ) ; this . config _ item = new system . windows . forms . tool _ strip _ menu _ item ( ) ; this . about _ tool _ strip _ menu _ item = new system . windows . forms . tool _ strip _ menu _ item ( ) ; this . tool _ strip _ separator = new system . windows . forms . tool _ strip _ separator ( ) ; this . quit _ item = new system . windows . forms . tool _ strip _ menu _ item ( ) ;
this . enable _ item = new system . windows . forms . tool _ strip _ menu _ item ( ) ;
this . context _ menu _ strip . suspend _ layout ( ) ;
this . notify _ icon . context _ menu _ strip = this . context _ menu _ strip ;
this . context _ menu _ strip . items . add _ range ( new system . windows . forms . tool _ strip _ item [ ] { this . enable _ item , this . config _ item , this . about _ tool _ strip _ menu _ item , this . tool _ strip _ separator , this . quit _ item } ) ; this . context _ menu _ strip . name = STR ; this . context _ menu _ strip . render _ mode = system . windows . forms . tool _ strip _ render _ mode . system ; this . context _ menu _ strip . size = new system . drawing . size ( NUM , NUM ) ;    this . config _ item . name = STR ; this . config _ item . size = new system . drawing . size ( NUM , NUM ) ; this . config _ item . text = STR ; this . config _ item . click + = new system . event _ handler ( this . config _ click ) ;    this . about _ tool _ strip _ menu _ item . name = STR ; this . about _ tool _ strip _ menu _ item . size = new system . drawing . size ( NUM , NUM ) ; this . about _ tool _ strip _ menu _ item . text = STR ; this . about _ tool _ strip _ menu _ item . click + = new system . event _ handler ( this . about _ tool _ strip _ menu _ item _ click ) ;    this . tool _ strip _ separator . name = STR ; this . tool _ strip _ separator . size = new system . drawing . size ( NUM , NUM ) ;    this . quit _ item . name = STR ; this . quit _ item . size = new system . drawing . size ( NUM , NUM ) ; this . quit _ item . text = STR ; this . quit _ item . click + = new system . event _ handler ( this . quit _ click ) ;
private system . windows . forms . context _ menu _ strip context _ menu _ strip ; private system . windows . forms . tool _ strip _ menu _ item config _ item ; private system . windows . forms . tool _ strip _ menu _ item quit _ item ; private system . windows . forms . tool _ strip _ menu _ item about _ tool _ strip _ menu _ item ; private system . windows . forms . tool _ strip _ separator tool _ strip _ separator ;
private system . windows . forms . tool _ strip _ menu _ item enable _ item ;
this . config _ item = new system . windows . forms . menu _ item ( ) ;
this . table _ layout _ panel . location = new system . drawing . point ( NUM , NUM ) ;
this . config _ item . index = 1 ; this . config _ item . text = STR ; this . config _ item . click + = new system . event _ handler ( this . config _ click ) ;
private void show _ pac _ url _ form ( ) { if ( pac _ url _ form ! = null ) { pac _ url _ form . activate ( ) ; } else { pac _ url _ form = new pac _ url _ form ( controller ) ; pac _ url _ form . show ( ) ; pac _ url _ form . form _ closed + = pac _ url _ form _ form _ closed ; } } private void pac _ url _ form _ form _ closed ( object sender , form _ closed _ event _ args e ) { pac _ url _ form = null ; util . utils . release _ memory ( ) ; show _ first _ time _ balloon ( ) ; }
show _ pac _ url _ form ( ) ;
if ( update _ completed ! = null ) { update _ completed ( this , new result _ event _ args ( true ) ) ; }
if ( error ! = null ) { error ( this , new error _ event _ args ( ex ) ) ; }
using shadowsocks _ properties ; using system ;
using system _ text ; using system _ text _ regular _ expressions ;
if ( system . globalization . culture _ info . current _ culture . ietf _ language _ tag . to _ lower _ invariant ( ) . starts _ with ( STR ) )
string [ ] lines = regex . split ( resources . cn , STR ) ; foreach ( string line in lines )
if ( line . starts _ with ( STR ) )
continue ; } string [ ] kv = regex . split ( line , STR ) ; if ( kv . length = = 2 ) { strings [ kv [ 0 ] ] = kv [ 1 ] ;
if ( item = = key )
else if ( item = = STR )
if ( path . equals ( value , string _ comparison . invariant _ culture _ ignore _ case ) )
socket conn = ( socket ) ar . async _ state ;
string proxy = STR + local _ end _ point . address + STR ;
local _ port = int . parse ( proxy _ port _ text _ box . text ) ,
private server server ;
this . server = config . get _ current _ server ( ) ;
local _ end _ point = new ip _ end _ point ( ip _ address . any , server . local _ port ) ;
local _ end _ point = new ip _ end _ point ( ip _ address . loopback , server . local _ port ) ;
bool parsed = ip _ address . try _ parse ( config . server , out ip _ address ) ;
ip _ host _ entry ip _ host _ info = dns . get _ host _ entry ( config . server ) ;
ip _ end _ point remote _ ep = new ip _ end _ point ( ip _ address , config . server _ port ) ;
using system _ collections ;
using system _ net _ http ;
using newtonsoft _ json ; using newtonsoft _ json _ linq ;
public class availability _ statistics
private const int timeout = NUM ; private readonly time _ span delay _ before _ start = time _ span . from _ seconds ( 1 ) ;
private readonly shadowsocks _ controller controller ;
public availability _ statistics ( shadowsocks _ controller controller ) { controller = controller ; global _ config = controller . get _ current _ configuration ( ) ; update _ configuration ( global _ config , controller . statistics _ configuration ) ; }
if ( server ! = current _ server ) return empty ; return outbound _ speed . to _ string ( ) ;
if ( server ! = current _ server ) return empty ; return inbound _ speed . to _ string ( ) ;
current _ server = global _ config . get _ current _ server ( ) ;
internal void update _ configuration ( configuration config , statistics _ strategy _ configuration statistics _ config ) { set ( statistics _ config ) ; servers = config . configs ;
} private async void filter _ raw _ statistics ( )
new task ( ( ) = > availability _ statistics . update _ latency ( server , ( int ) latency . total _ milliseconds ) ) . start ( ) ;
new task ( ( ) = > availability _ statistics . update _ inbound _ counter ( server , n ) ) . start ( ) ;
new task ( ( ) = > availability _ statistics . update _ outbound _ counter ( server , n ) ) . start ( ) ;
try { process . kill ( ) ; process . wait _ for _ exit ( ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; }
inbound _ speed _ records . get _ or _ add ( id , new list < int > { inbound _ speed } ) . add ( inbound _ speed ) ;
outbound _ speed _ records . get _ or _ add ( id , new list < int > { outbound _ speed } ) . add ( outbound _ speed ) ;
} private async task < icmp _ result > icmp _ test ( server server ) { logging . debug ( STR + server . friendly _ name ( ) ) ; if ( server . server = = STR ) return null ; var result = new icmp _ result ( server ) ; try { var ip = dns . get _ host _ addresses ( server . server ) . first ( ip = > ip . address _ family = = address _ family . inter _ network | | ip . address _ family = = address _ family . inter _ network ) ; var ping = new ping ( ) ; foreach ( var in enumerable . range ( 0 , repeat ) ) { try { var reply = await ping . send _ task _ async ( ip , timeout _ milliseconds ) ; if ( reply . status . equals ( ip _ status . success ) ) { result . roundtrip _ time . add ( ( int? ) reply . roundtrip _ time ) ; } else { result . roundtrip _ time . add ( null ) ; }  thread . sleep ( timeout _ milliseconds + new random ( ) . next ( ) % timeout _ milliseconds ) ; } catch ( exception e ) { logging . error ( $ STR ) ; logging . log _ useful _ exception ( e ) ; } } } catch ( exception e ) { logging . error ( $ STR ) ; logging . log _ useful _ exception ( e ) ; } return result ;
save ( ) ;
filter _ raw _ statistics ( ) ; } private async void update _ records ( )
} if ( config . ping ) {    var icmp _ results = await task _ ex . when _ all ( controller . get _ current _ configuration ( ) . configs . select ( icmp _ test ) ) ; foreach ( var result in icmp _ results . where ( result = > result ! = null ) ) { records [ result . server . identifier ( ) ] . set _ response ( result . roundtrip _ time ) ; } } foreach ( var kv in records . where ( kv = > ! kv . value . is _ empty _ data ( ) ) ) { append _ record ( kv . key , kv . value ) ;
list < statistics _ record > records ;   if ( ! raw _ statistics . try _ get _ value ( server _ identifier , out records ) ) { records = new list < statistics _ record > ( ) ;   } records . add ( record ) ; raw _ statistics [ server _ identifier ] = records ;
var content = json _ convert . serialize _ object ( raw _ statistics , formatting . none ) ;
} private class icmp _ result { internal readonly list < int? > roundtrip _ time = new list < int? > ( ) ; internal readonly server server ; internal icmp _ result ( server server ) { server = server ; }
list < int > records ; latency _ records . try _ get _ value ( server . identifier ( ) , out records ) ; if ( records = = null ) { records = new list < int > ( ) ; } records . add ( latency ) ; latency _ records [ server . identifier ( ) ] = records ;
long count ; if ( inbound _ counter . try _ get _ value ( server . identifier ( ) , out count ) ) { count + = n ; } else { count = n ; last _ inbound _ counter [ server . identifier ( ) ] = 0 ; } inbound _ counter [ server . identifier ( ) ] = count ;
long count ; if ( outbound _ counter . try _ get _ value ( server . identifier ( ) , out count ) ) { count + = n ;  } else { count = n ; last _ outbound _ counter [ server . identifier ( ) ] = 0 ; } outbound _ counter [ server . identifier ( ) ] = count ;
logging . open _ log _ file ( ) ;
logging . open _ log _ file ( ) ;
system _ proxy . update ( config , false ) ;
system _ proxy . update ( config , false ) ;
class pac _ server : listener . service
byte [ ] buf = new byte [ NUM ] ;
buf
conn . begin _ receive ( buf , 0 , NUM , 0 ,
byte [ ] buffer = new byte [ NUM * NUM ] ;
n = input . read ( buffer , 0 , buffer . length ) ; if ( n = = 0 )
throw new io _ exception ( STR ) ;
return system . text . encoding . ut . get _ string ( buffer , 0 , n ) ;
public void begin _ connect _ dest ( end _ point dest _ end _ point , async _ callback callback , object state )
string request = string . format ( http _ connect _ template , dest _ end _ point ) ;
new async _ session < server _ timer > ( session , connect _ timer ) ) ;
proxy _ type _ combo _ box . enabled = false ;
if ( modified _ configuration = = null )
var conf = controller . get _ configuration _ copy ( ) . proxy ; if ( conf = = null ) conf = new proxy _ config ( ) ; conf . use _ proxy = use _ proxy _ check _ box . checked ; conf . proxy _ server = proxy _ server _ text _ box . text ; int tmp _ proxy _ port ; int . try _ parse ( proxy _ port _ text _ box . text , out tmp _ proxy _ port ) ; conf . proxy _ port = tmp _ proxy _ port ; controller . save _ proxy _ config ( conf ) ;
public extern static void ss _ sha _ hmac _ ex ( byte [ ] key , uint keylen ,
if ( disposed ) { return ; }
if ( encrypt _ ctx ! = int _ ptr . zero ) { mbed _ tls . cipher _ free ( encrypt _ ctx ) ; marshal . free _ h _ global ( encrypt _ ctx ) ; encrypt _ ctx = int _ ptr . zero ; } if ( decrypt _ ctx ! = int _ ptr . zero ) { mbed _ tls . cipher _ free ( decrypt _ ctx ) ; marshal . free _ h _ global ( decrypt _ ctx ) ; decrypt _ ctx = int _ ptr . zero ; }
if ( disposed ) return ;
disposed = true ;
public void close ( )
close _ handle ( handle ) ; handle = int _ ptr . zero ;
if ( inbound _ speed _ records ! = null & & inbound _ speed _ records . any ( ) )
average _ inbound _ speed = ( int ) inbound _ speed _ records . average ( ) ; min _ inbound _ speed = inbound _ speed _ records . min ( ) ; max _ inbound _ speed = inbound _ speed _ records . max ( ) ;
if ( outbound _ speed _ records ! = null & & outbound _ speed _ records . any ( ) )
average _ outbound _ speed = ( int ) outbound _ speed _ records . average ( ) ; min _ outbound _ speed = outbound _ speed _ records . min ( ) ; max _ outbound _ speed = outbound _ speed _ records . max ( ) ;
if ( latency _ records ! = null & & latency _ records . any ( ) )
average _ latency = ( int ) latency _ records . average ( ) ; min _ latency = latency _ records . min ( ) ; max _ latency = latency _ records . max ( ) ;
package _ loss _ percentage = ( data _ group . average ( data = > data . package _ loss ) ? ? 0 ) * NUM
foreach ( var data in final _ data )
using system _ text ; using shadowsocks _ model ; using system _ io ;
using system _ windows _ forms ;
using timer = system . threading . timer ;
using data _ unit = key _ value _ pair < string , string > ; using data _ list = list < key _ value _ pair < string , string > > ;
private dictionary < string , list < statistics _ raw _ data > > raw _ statistics ;
private const int retry _ interval = 2 * NUM * NUM ;
try { var path = availability _ statistics . availability _ statistics _ file ; logging . debug ( $ STR ) ; if ( ! file . exists ( path ) ) { log _ when _ enabled ( $ STR ) ; timer . change ( retry _ interval , choice _ kept _ milliseconds ) ; return ; } raw _ statistics = ( from l in file . read _ all _ lines ( path ) . skip ( 1 ) let strings = l . split ( new [ ] { STR } , string _ split _ options . remove _ empty _ entries ) let raw _ data = new statistics _ raw _ data { timestamp = strings [ 0 ] , server _ name = strings [ 1 ] , icmp _ status = strings [ 2 ] , roundtrip _ time = int . parse ( strings [ NUM ] ) , geolocation = NUM > strings . length ? null : strings [ NUM ] , isp = NUM > strings . length ? null : strings [ NUM ] } group raw _ data by raw _ data . server _ name into server select new { server _ name = server . key , data = server . to _ list ( ) } ) . to _ dictionary ( server = > server . server _ name , server = > server . data ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; }
private float get _ score ( i _ enumerable < statistics _ raw _ data > raw _ data _ list )
if ( config . by _ isp ) { var current = availability _ statistics . get _ geolocation _ and _ isp ( ) . result ; raw _ data _ list = raw _ data _ list . where ( data = > data . geolocation = = current [ 0 ] . value | | data . geolocation = = availability _ statistics . state . unknown ) ; raw _ data _ list = raw _ data _ list . where ( data = > data . isp = = current [ 1 ] . value | | data . isp = = availability _ statistics . state . unknown ) ; if ( raw _ data _ list . long _ count ( ) = = 0 ) return 0 ; } if ( config . by _ hour _ of _ day ) { var current _ hour = date _ time . now . hour ; raw _ data _ list = raw _ data _ list . where ( data = > { date _ time date _ time ; date _ time . try _ parse _ exact ( data . timestamp , availability _ statistics . date _ time _ pattern , null , date _ time _ styles . none , out date _ time ) ; var result = date _ time . hour . equals ( current _ hour ) ; return result ; } ) ; if ( raw _ data _ list . long _ count ( ) = = 0 ) return 0 ; } var data _ list = raw _ data _ list as i _ list < statistics _ raw _ data > ? ? raw _ data _ list . to _ list ( ) ; var server _ name = data _ list [ 0 ] ? . server _ name ;
var statistics _ data = new statistics _ data ( )
class statistics _ raw _ data { public string timestamp ; public string server _ name ; public string icmp _ status ; public int roundtrip _ time ; public string geolocation ; public string isp ; } public class statistics _ data { public float package _ loss ; public int average _ response ; public int min _ response ; public int max _ response ; }
if ( raw _ statistics = = null | | servers . count = = 0 )
where raw _ statistics . contains _ key ( name )
score = get _ score ( raw _ statistics [ name ] )
using simple _ json ;
using system _ windows _ forms ;
using timer = system . threading . timer ;
internal class availability _ statistics
this . binding _ configuration = new system . windows . forms . binding _ source ( this . components ) ;
foreach ( string method in aead _ mbed _ tls _ encryptor . supported _ ciphers ( ) )
foreach ( string method in aead _ sodium _ encryptor . supported _ ciphers ( ) )
new async _ callback ( connect _ callback ) , null ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ;
if ( closed ) { return ; } try {
controller . get _ current _ strategy ( ) . update _ latency ( this . server , latency ) ;
catch ( exception e ) { controller . get _ current _ strategy ( ) . set _ failure ( this . server ) ; logging . log _ useful _ exception ( e ) ; if ( retry _ count < NUM ) { console . write _ line ( STR ) ; start _ connect ( ) ; retry _ count + + ; } else { this . close ( ) ; }
var defulat _ value = registry . get _ value ( STR ) ; var connections = registry . get _ value _ names ( ) ; foreach ( string each in connections ) { if ( ! ( each . equals ( STR ) | | each . equals ( STR ) | | each . equals ( STR ) ) )
registry . set _ value ( each , defulat _ value ) ;
notify _ ie ( ) ;
using ( graphics g = graphics . from _ image ( bmp _ screen _ capture ) )
bmp _ screen _ capture . size ,
result _ points . clear ( ) ;
var result = barcode _ reader . decode ( image ) ; var timer _ start = date _ time . now . ticks ; var timer _ stop = date _ time . now . ticks ; if ( result = = null )
txt _ decoder _ content . text = STR ;
lab _ duration . text = new time _ span ( timer _ stop - timer _ start ) . milliseconds . to _ string ( STR ) ; } } * * /
catch ( io _ exception )
password = STR
reload ( config ) ;
private void button _ click ( object sender , event _ args e )
reload ( config . load ( ) ) ;
private void button _ click ( object sender , event _ args e )
this . button . click + = new system . event _ handler ( this . button _ click ) ;
this . button . click + = new system . event _ handler ( this . button _ click ) ;
this . context _ menu _ strip . show _ image _ margin = false ; this . context _ menu _ strip . size = new system . drawing . size ( NUM , NUM ) ;
logging . info ( STR + culture _ info . current _ culture . name ) ; init ( n , culture _ info . current _ culture . name ) ;
public byte [ ] remote _ recv _ buffer = new byte [ recv _ size ] ;
public byte [ ] remote _ send _ buffer = new byte [ buffer _ size ] ;
public byte [ ] connetion _ recv _ buffer = new byte [ recv _ size ] ;
public byte [ ] connetion _ send _ buffer = new byte [ buffer _ size ] ;
public string _ builder sb = new string _ builder ( ) ;
this . table _ layout _ panel . row _ count = 1 ;
this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ;
config . get _ current _ server ( ) . bandwidth _ in = inbound _ counter ;
config . get _ current _ server ( ) . bandwidth _ out = outbound _ counter ;
inbound _ counter = config . get _ current _ server ( ) . bandwidth _ in ; outbound _ counter = config . get _ current _ server ( ) . bandwidth _ out ;
private ip _ end _ point remote _ end _ point ;
ip _ address ip _ address ; bool parsed = ip _ address . try _ parse ( server . server , out ip _ address ) ; if ( ! parsed ) { ip _ host _ entry ip _ host _ info = dns . get _ host _ entry ( server . server ) ; ip _ address = ip _ host _ info . address _ list [ 0 ] ; } remote _ end _ point = new ip _ end _ point ( ip _ address , server . server _ port ) ; remote = new socket ( remote _ end _ point . address _ family , socket _ type . dgram , protocol _ type . udp ) ;
end _ point real _ end _ point = dest _ end _ point = dest _ end _ point ;  * on windows vista or later , dual - mode socket is supported , so that * we don ' t need to resolve a dns _ end _ point manually . * we could just create a dual - mode socket and pass the dns _ end _ point * directly to it ' s begin _ connect and the system will handle it correctlly * so that we won ' t worry about async resolving any more . * * see : https : * * but it seems that we can ' t use this feature because dns _ end _ point * doesn ' t have a specific address _ family before it has been * resolved ( we don ' t know whether it ' s ipv or ipv ) and we don ' t have * a dual - mode socket to use on windows xp : ( * / var dep = real _ end _ point as dns _ end _ point ; if ( dep ! = null ) {   ip _ host _ entry ip _ host _ info = dns . get _ host _ entry ( dep . host ) ; ip _ address ip _ address = ip _ host _ info . address _ list [ 0 ] ; real _ end _ point = new ip _ end _ point ( ip _ address , dep . port ) ; }
remote = new socket ( real _ end _ point . address _ family , socket _ type . stream , protocol _ type . tcp ) ;
remote . begin _ connect ( real _ end _ point , callback , state ) ;
ip _ end _ point proxy _ ep ;
ip _ address ip _ address ; bool parsed = ip _ address . try _ parse ( config . proxy _ server , out ip _ address ) ; if ( ! parsed ) {  * todo really necessary to resolve a proxy ' s address ? maybe from local hosts ? * also we may simplify it by using dual - mode socket with * the approach described in direct _ connect . begin _ connect _ dest * / ip _ host _ entry ip _ host _ info = dns . get _ host _ entry ( config . proxy _ server ) ; ip _ address = ip _ host _ info . address _ list [ 0 ] ; }
proxy _ ep = new ip _ end _ point ( ip _ address , config . proxy _ port ) ;
load _ tray _ icon ( ) ;
notify _ icon . text = n . get _ string ( STR ) ;
load _ tray _ icon ( ) ;
this . password _ text _ box . use _ system _ password _ char = true ;
private bitmap icon _ base _ bitmap ; private icon icon _ base , icon _ in , icon _ out , icon _ both , target _ icon ; private context _ menu context _ menu ;
new _ icon = icon _ base ; if ( new _ icon ! = this . target _ icon ) { this . target _ icon = new _ icon ;
private void update _ tray _ icon ( ) { int dpi ; graphics graphics = graphics . from _ hwnd ( int _ ptr . zero ) ; dpi = ( int ) graphics . dpi _ x ; graphics . dispose ( ) ; icon _ base _ bitmap = null ; if ( dpi < NUM ) {  icon _ base _ bitmap = resources . ss ; } else if ( dpi < NUM ) {  icon _ base _ bitmap = resources . ss ; } else { icon _ base _ bitmap = resources . ss ; }
current _ windows _ theme _ mode = utils . get _ windows _ system _ theme _ setting ( ) ; if ( current _ windows _ theme _ mode = = utils . windows _ theme _ mode . light ) if ( ! global | | ! enabled ) icon _ base _ bitmap = get _ dark _ tray _ icon ( icon _ base _ bitmap ) ; icon _ base _ bitmap = get _ tray _ icon _ by _ state ( icon _ base _ bitmap , enabled , global ) ; icon _ base = icon . from _ handle ( icon _ base _ bitmap . get _ hicon ( ) ) ; target _ icon = icon _ base ; icon _ in = icon . from _ handle ( add _ bitmap _ overlay ( icon _ base _ bitmap , resources . ss _ in ) . get _ hicon ( ) ) ; icon _ out = icon . from _ handle ( add _ bitmap _ overlay ( icon _ base _ bitmap , resources . ss _ out ) . get _ hicon ( ) ) ; icon _ both = icon . from _ handle ( add _ bitmap _ overlay ( icon _ base _ bitmap , resources . ss _ in , resources . ss _ out ) . get _ hicon ( ) ) ; notify _ icon . icon = target _ icon ;
private bitmap get _ dark _ tray _ icon ( bitmap origin _ icon ) { bitmap icon _ copy = new bitmap ( origin _ icon ) ; for ( int x = 0 ; x < icon _ copy . width ; x + + )  { for ( int y = 0 ; y < icon _ copy . height ; y + + ) { color color = origin _ icon . get _ pixel ( x , y ) ; if ( color . a ! = 0 )
color fly _ blue = color . from _ argb ( NUM , 0 , 0 , 0 ) ;  int red = color . r * fly _ blue . r / NUM ; int green = color . g * fly _ blue . g / NUM ; int blue = color . b * fly _ blue . b / NUM ; int alpha = color . a ; icon _ copy . set _ pixel ( x , y , color . from _ argb ( alpha , red , green , blue ) ) ;
else { icon _ copy . set _ pixel ( x , y , color . from _ argb ( color . a , color . r , color . g , color . b ) ) ; } } } return icon _ copy ; } private bitmap get _ tray _ icon _ by _ state ( bitmap origin _ icon , bool enabled , bool global ) { bitmap icon _ copy = new bitmap ( origin _ icon ) ; for ( int x = 0 ; x < icon _ copy . width ; x + + ) { for ( int y = 0 ; y < icon _ copy . height ; y + + ) { color color = origin _ icon . get _ pixel ( x , y ) ; if ( color . a ! = 0 ) { if ( ! enabled ) {  color fly _ blue ; if ( current _ windows _ theme _ mode = = utils . windows _ theme _ mode . light ) fly _ blue = color . from _ argb ( NUM , NUM , NUM , NUM ) ; else fly _ blue = color . from _ argb ( NUM , NUM , NUM , NUM ) ; int red = color . r * fly _ blue . r / NUM ; int green = color . g * fly _ blue . g / NUM ; int blue = color . b * fly _ blue . b / NUM ; int alpha = color . a * fly _ blue . a / NUM ; icon _ copy . set _ pixel ( x , y , color . from _ argb ( alpha , red , green , blue ) ) ; } else if ( global ) { color fly _ blue = color . from _ argb ( NUM , NUM , NUM ) ;  int red = color . r * fly _ blue . r / NUM ; int green = color . g * fly _ blue . g / NUM ; int blue = color . b * fly _ blue . b / NUM ; icon _ copy . set _ pixel ( x , y , color . from _ argb ( color . a , red , green , blue ) ) ; } } else { icon _ copy . set _ pixel ( x , y , color . from _ argb ( color . a , color . r , color . g , color . b ) ) ; } } } return icon _ copy ; } private bitmap add _ bitmap _ overlay ( bitmap original , params bitmap [ ] overlays )  { bitmap bitmap = new bitmap ( original . width , original . height , pixel _ format . format _ bpp _ argb ) ; graphics canvas = graphics . from _ image ( bitmap ) ; canvas . draw _ image ( original , new point ( 0 , 0 ) ) ; foreach ( bitmap overlay in overlays ) { canvas . draw _ image ( new bitmap ( overlay , original . size ) , new point ( 0 , 0 ) ) ; } canvas . save ( ) ; return bitmap ;
windows _ theme _ mode regist _ data = windows _ theme _ mode . dark ;
registry _ key reg _ hkcu = registry . current _ user ; registry _ key reg _ themes _ personalize = reg _ hkcu . open _ sub _ key ( STR , false ) ;
if ( convert . to _ int ( reg _ themes _ personalize . get _ value ( STR ) . to _ string ( ) ) = = 0 ) regist _ data = windows _ theme _ mode . dark ;
regist _ data = windows _ theme _ mode . light ;
directory . create _ directory ( path . combine ( application . startup _ path , STR ) ) ;  temp _ path = path . combine ( application . startup _ path , STR ) ;
this . font = system . drawing . system _ fonts . message _ box _ font ;
this . servers _ list _ box . dock = system . windows . forms . dock _ style . fill ;
this . remarks _ label = new system . windows . forms . label ( ) ;
| system . windows . forms . anchor _ styles . right ) ) ) ;
this . table _ layout _ panel . location = new system . drawing . point ( NUM , NUM ) ;
this . table _ layout _ panel . row _ count = 1 ;
try { using ( stream _ writer sw = new stream _ writer ( file . open ( user _ wininet _ config _ file , file _ mode . create ) ) ) {
try { string config _ content = file . read _ all _ text ( user _ wininet _ config _ file ) ;
using system _ linq ;
namespace shadowsocks _ controller
public i _ set < tcp _ handler > handlers { get ; set ; }
handlers = new hash _ set < tcp _ handler > ( ) ;
if ( socket . protocol _ type ! = protocol _ type . tcp | | ( length < 2 | | first _ packet [ 0 ] ! = NUM ) )
tcp _ handler handler = new tcp _ handler ( controller , config , this , socket ) ;
class tcp _ handler
class async _ session
class async _ session < t > : async _ session
private shadowsocks _ controller controller ; private configuration config ; private tcp _ relay tcprelay ; private socket connection ; private i _ encryptor encryptor ; private server server ;
private bool proxy _ connected ; private bool dest _ connected ; private byte command ; private byte [ ] first _ packet ; private int first _ packet _ length ; private int total _ read = 0 ; private int total _ write = 0 ;    private byte [ ] remote _ recv _ buffer = new byte [ buffer _ size ] ; private byte [ ] remote _ send _ buffer = new byte [ buffer _ size ] ; private byte [ ] connetion _ recv _ buffer = new byte [ buffer _ size ] ; private byte [ ] connetion _ send _ buffer = new byte [ buffer _ size ] ; private bool connection _ shutdown = false ; private bool remote _ shutdown = false ; private bool closed = false ;  private readonly object encryption _ lock = new object ( ) ; private readonly object decryption _ lock = new object ( ) ; private readonly object close _ conn _ lock = new object ( ) ;
public tcp _ handler ( shadowsocks _ controller controller , configuration config , tcp _ relay tcprelay , socket socket )
} public void create _ remote ( ) { server server = controller . get _ a _ server ( i _ strategy _ caller _ type . tcp , ( ip _ end _ point ) connection . remote _ end _ point , dest _ end _ point ) ;
private void start _ pipe ( async _ session session ) { if ( closed ) return ;
session . remote . begin _ receive ( remote _ recv _ buffer , 0 , recv _ size , socket _ flags . none , new async _ callback ( pipe _ remote _ receive _ callback ) , session ) ; send _ to _ server ( first _ packet _ length , session ) ;
session . remote . begin _ send ( connetion _ send _ buffer , 0 , bytes _ to _ send , socket _ flags . none , new async _ callback ( pipe _ remote _ send _ callback ) , session ) ;
if ( closed ) return ;
session . remote . end _ send ( ar ) ; connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , socket _ flags . none , new async _ callback ( pipe _ connection _ receive _ callback ) , session ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; } } private void pipe _ connection _ send _ callback ( i _ async _ result ar ) { try { var session = ( async _ session ) ar . async _ state ; connection . end _ send ( ar ) ; session . remote . begin _ receive ( remote _ recv _ buffer , 0 , recv _ size , socket _ flags . none , new async _ callback ( pipe _ remote _ receive _ callback ) , session ) ;
services . add ( pac _ server ) ; services . add ( new http _ socks ( config . local _ port ) ) ;
byte [ ] request = null ; byte atyp = 0 ; int port ; var dep = dest _ end _ point as dns _ end _ point ; if ( dep ! = null ) {  atyp = NUM ; var enc = encoding . ut ; var host _ byte _ count = enc . get _ byte _ count ( dep . host ) ; request = new byte [ NUM + 1 request [ NUM ] = ( byte ) host _ byte _ count ; enc . get _ bytes ( dep . host , 0 , dep . host . length , request , NUM ) ; port = dep . port ; } else { switch ( dest _ end _ point . address _ family ) { case address _ family . inter _ network : request = new byte [ NUM + NUM + 2 ] ; atyp = 1 ; break ; case address _ family . inter _ network : request = new byte [ NUM + NUM + 2 ] ; atyp = NUM ; break ; default : throw new exception ( n . get _ string ( STR ) ) ; } port = ( ( ip _ end _ point ) dest _ end _ point ) . port ; var addr = ( ( ip _ end _ point ) dest _ end _ point ) . address . get _ address _ bytes ( ) ; array . copy ( addr , 0 , request , NUM , request . length - NUM - 2 ) ; }
request [ NUM ] = atyp ; request [ request . length - 2 ] = ( byte ) ( ( port > > NUM ) & 0 xff ) ; request [ request . length - 1 ] = ( byte ) ( port & 0 xff ) ;
int lp _ names = 1 ;
lp _ size = lp _ names * entry _ name _ size ; names = new ras _ entry _ name [ lp _ names ] ; names [ 0 ] . dw _ size = entry _ name _ size ; retval = ras . ras _ enum _ entries ( null , null , names , ref lp _ size , out lp _ names ) ;
retval = ras . ras _ enum _ entries ( null , null , names , ref lp _ size , out lp _ names ) ;
int i = 0 ;
items . add ( i , item ) ; i + + ;
items . add ( i + + , new menu _ item ( STR ) ) ; int strategy _ count = i ;
item . tag = i - strategy _ count ;
items . add ( i , item ) ; i + + ;
this . config _ item = create _ menu _ item ( STR , new event _ handler ( this . config _ click ) )
create _ menu _ item ( STR , new event _ handler ( this . qr _ code _ item _ click ) ) , create _ menu _ item ( STR , new event _ handler ( this . scan _ qr _ code _ item _ click ) ) ,
items . clear ( ) ;
items . add ( item ) ; } items . add ( seperator _ item ) ; items . add ( config _ item ) ;
console . write _ line ( result . text ) ;
list < string > lines = gfw _ list _ updater . parse _ result ( file . read _ all _ text ( utils . get _ temp _ path ( STR ) ) ) ;
string local = file . read _ all _ text ( pac _ server . user _ rule _ file , encoding . ut ) ;
enable _ item . checked = controller . get _ configuration _ copy ( ) . enabled ; mode _ item . enabled = enable _ item . checked ;
controller . toggle _ enable ( ! enable _ item . checked ) ;
log _ file = path . combine ( temppath , STR ) ; file _ stream fs = new file _ stream ( log _ file , file _ mode . append ) ;
local = new local ( config ) ; local . start ( ) ;
private menu _ item create _ menu _ item ( int index , string text , event _ handler click )
result . index = index ;
private menu _ item create _ seperator _ item ( int index )
result . index = index ;
private menu _ item create _ menu _ group ( int index , string text , menu _ item [ ] items ) {
result . index = index ;
this . pac _ mode _ item = create _ menu _ item ( 0 , STR , new system . event _ handler ( this . pac _ mode _ item _ click ) ) ; this . global _ mode _ item = create _ menu _ item ( 1 , STR , new system . event _ handler ( this . global _ mode _ item _ click ) ) ; this . seperator _ item = create _ seperator _ item ( 0 ) ; this . config _ item = create _ menu _ item ( 1 , STR , new system . event _ handler ( this . config _ click ) ) ; this . enable _ item = create _ menu _ item ( 0 , STR , new system . event _ handler ( this . enable _ item _ click ) ) ; this . servers _ item = create _ menu _ group ( 2 , STR , new system . windows . forms . menu _ item [ ] { this . seperator _ item , this . config _ item
this . auto _ startup _ item = create _ menu _ item ( NUM , STR , new system . event _ handler ( this . auto _ startup _ item _ click ) ) ; this . share _ over _ lan _ item = create _ menu _ item ( NUM , STR , new system . event _ handler ( this . share _ over _ lan _ item _ click ) ) ; this . context _ menu . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . enable _ item , create _ menu _ group ( 1 , STR , new system . windows . forms . menu _ item [ ] { this . pac _ mode _ item , this . global _ mode _ item } ) , this . servers _ item , create _ seperator _ item ( NUM ) , this . auto _ startup _ item , this . share _ over _ lan _ item , create _ menu _ item ( NUM , STR , new system . event _ handler ( this . edit _ pac _ file _ item _ click ) ) , create _ seperator _ item ( NUM ) , create _ menu _ item ( NUM , STR , new system . event _ handler ( this . qr _ code _ item _ click ) ) , create _ menu _ item ( NUM , STR , new system . event _ handler ( this . show _ log _ item _ click ) ) , create _ menu _ item ( NUM , STR , new system . event _ handler ( this . config _ click ) ) , create _ seperator _ item ( NUM ) , create _ menu _ item ( NUM , STR , new system . event _ handler ( this . quit _ click ) ) } ) ;
int atyp = connetion _ recv _ buffer [ 0 ] ; string dst _ addr ; int dst _ port ; switch ( atyp )
case 1 : dst _ addr = new ip _ address ( connetion _ recv _ buffer . skip ( 1 ) . take ( NUM ) . to _ array ( ) ) . to _ string ( ) ; dst _ port = ( connetion _ recv _ buffer [ NUM ] < < NUM ) + connetion _ recv _ buffer [ NUM ] ; if ( config . is _ verbose _ logging ) { logging . info ( $ STR ) ; } break ; case NUM : int len = connetion _ recv _ buffer [ 1 ] ; dst _ addr = system . text . encoding . ut . get _ string ( connetion _ recv _ buffer , 2 , len ) ; dst _ port = ( connetion _ recv _ buffer [ len + 2 ] < < NUM ) + connetion _ recv _ buffer [ len + NUM ] ; if ( config . is _ verbose _ logging ) { logging . info ( $ STR ) ; } break ; case NUM : dst _ addr = new ip _ address ( connetion _ recv _ buffer . skip ( 1 ) . take ( NUM ) . to _ array ( ) ) . to _ string ( ) ; dst _ port = ( connetion _ recv _ buffer [ NUM ] < < NUM ) + connetion _ recv _ buffer [ NUM ] ; if ( config . is _ verbose _ logging ) { logging . info ( $ STR ) ; } break ;
private static logger logger = log _ manager . get _ current _ class _ logger ( ) ;
public bool is _ i _ pv _ enabled = false ;
public string geosite _ url ; public string geosite _ group = STR ; public bool geosite _ blacklist _ mode = true ;
public bool generate _ legacy _ url = false ;
private static readonly n _ log _ config . log _ level verbose _ log _ level =
n _ log _ config . log _ level . trace ;
n _ log _ config . log _ level . debug ;
using system _ reflection ;
using shadowsocks _ controller _ hotkeys ;
using shadowsocks _ util ;
reg _ hotkey _ from _ string ( hotkey _ config . switch _ system _ proxy , STR , switch _ system _ proxy _ label ) & & reg _ hotkey _ from _ string ( hotkey _ config . switch _ system _ proxy _ mode , STR , switch _ proxy _ mode _ label ) & & reg _ hotkey _ from _ string ( hotkey _ config . switch _ allow _ lan , STR , switch _ allow _ lan _ label ) & & reg _ hotkey _ from _ string ( hotkey _ config . show _ logs , STR , show _ logs _ label ) & & reg _ hotkey _ from _ string ( hotkey _ config . server _ move _ up , STR , server _ move _ up _ label ) & & reg _ hotkey _ from _ string ( hotkey _ config . server _ move _ down , STR , server _ move _ down _ label ) ;
private bool reg _ hotkey _ from _ string ( string hotkey _ str , string callback _ name , label indicator = null )
var callback = hotkey _ callbacks . get _ callback ( callback _ name ) ; if ( callback = = null )
throw new exception ( $ STR ) ; } var callback = callback as hot _ keys . hot _ key _ call _ back _ handler ; if ( hotkey _ str . is _ null _ or _ empty ( ) ) { hot _ keys . unreg _ existing _ hotkey ( callback ) ; if ( indicator ! = null ) { indicator . reset _ back _ color ( ) ; } return true ; } else { var hotkey = hot _ keys . str _ hot _ key ( hotkey _ str ) ; if ( hotkey = = null ) {
return false ; } else { bool reg _ result = ( hot _ keys . reg _ hotkey ( hotkey , callback ) ) ; if ( indicator ! = null ) { indicator . back _ color = reg _ result ? color . green : color . yellow ; } return reg _ result ; }
if ( config . auto _ check _ update )
} if ( config . is _ default ) { is _ first _ run = true ; show _ config _ form ( ) ;
is _ first _ run = false ;
is _ first _ run = false ;
if ( is _ first _ run ) { notify _ icon . balloon _ tip _ title = n . get _ string ( STR ) ; notify _ icon . balloon _ tip _ text = n . get _ string ( STR ) ; notify _ icon . balloon _ tip _ icon = tool _ tip _ icon . info ; notify _ icon . show _ balloon _ tip ( 0 ) ; is _ first _ run = false ; }
old _ selected _ index = modified _ configuration . index ; if ( old _ selected _ index < 0 ) { old _ selected _ index = 0 ; } servers _ list _ box . selected _ index = old _ selected _ index ;
old _ selected _ index = servers _ list _ box . selected _ index ; if ( old _ selected _ index > = 0 & & old _ selected _ index < modified _ configuration . configs . count ) { modified _ configuration . configs . remove _ at ( old _ selected _ index ) ; } if ( old _ selected _ index > = modified _ configuration . configs . count )
int index = modified _ configuration . index ;
controller . select _ server _ index ( index ) ;
static byte [ ] sodium _ buf = new byte [ max _ input _ size + sodium _ block _ size ] ;
lock ( sodium _ buf )
if ( is _ cipher ) { bytes _ remaining = encrypt _ bytes _ remaining ; ic = encrypt _ ic ;  iv = encrypt _ iv ; } else { bytes _ remaining = decrypt _ bytes _ remaining ; ic = decrypt _ ic ;  iv = decrypt _ iv ; } int padding = bytes _ remaining ; buffer . block _ copy ( buf , 0 , sodium _ buf , padding , length ) ; switch ( cipher ) { case cipher _ sals : sodium . crypto _ stream _ salsa _ xor _ ic ( sodium _ buf , sodium _ buf , ( ulong ) ( padding + length ) , iv , ic , key ) ; break ; case cipher _ chach : sodium . crypto _ stream _ chacha _ xor _ ic ( sodium _ buf , sodium _ buf , ( ulong ) ( padding + length ) , iv , ic , key ) ; break ; case cipher _ chach _ ietf : sodium . crypto _ stream _ chacha _ ietf _ xor _ ic ( sodium _ buf , sodium _ buf , ( ulong ) ( padding + length ) , iv , ( uint ) ic , key ) ; break ; } buffer . block _ copy ( sodium _ buf , padding , outbuf , 0 , length ) ; padding + = length ; ic + = ( ulong ) padding / sodium _ block _ size ; bytes _ remaining = padding % sodium _ block _ size ; if ( is _ cipher ) { encrypt _ bytes _ remaining = bytes _ remaining ; encrypt _ ic = ic ; } else { decrypt _ bytes _ remaining = bytes _ remaining ; decrypt _ ic = ic ; }
using shadowsocks _ csharp _ model ; using shadowsocks _ csharp _ properties ;
namespace shadowsocks _ csharp _ controller
using shadowsocks _ csharp _ properties ;
namespace shadowsocks _ csharp _ controller
using shadowsocks _ csharp _ model ;
namespace shadowsocks _ csharp _ controller
using shadowsocks _ csharp _ controller ; using shadowsocks _ csharp _ properties ; using shadowsocks _ csharp _ view ;
namespace shadowsocks _ csharp
servers _ list _ box . items . add ( string . is _ null _ or _ empty ( server . server ) ? STR : server . server ) ;
this . config _ item ,
this . config _ item . index = 1 ; this . config _ item . text = STR ; this . config _ item . click + = new system . event _ handler ( this . config _ click ) ;
this . edit _ pac _ file _ item . index = 2 ; this . edit _ pac _ file _ item . text = STR ;
services . add ( new port _ forwarder ( polipo _ runner . running _ port ) ) ;
class polipo _ runner
static polipo _ runner ( )
process [ ] existing _ polipo = process . get _ processes _ by _ name ( STR ) ; foreach ( process p in existing _ polipo . where ( is _ child _ process ) )
string polipo _ config = resources . privoxy _ conf ;
polipo _ config = polipo _ config . replace ( STR , configuration . local _ port . to _ string ( ) ) ; polipo _ config = polipo _ config . replace ( STR , running _ port . to _ string ( ) ) ; polipo _ config = polipo _ config . replace ( STR , configuration . share _ over _ lan ? STR : STR ) ; file _ manager . byte _ array _ to _ file ( utils . get _ temp _ path ( unique _ config _ file ) , encoding . ut . get _ bytes ( polipo _ config ) ) ;
if ( ( uint ) ex . error _ code = = 0 )
using system _ windows _ forms _ data _ visualization _ charting ;
using simple _ json ; using system _ net _ network _ information ;
json _ array result = ( json _ array ) simple _ json . simple _ json . deserialize _ object ( e . result ) ;
foreach ( json _ object release in result ) { if ( ( bool ) release [ STR ] ) { continue ; } foreach ( json _ object asset in ( json _ array ) release [ STR ] ) { asset ass = new asset ( ) ; ass . parse ( asset ) ; if ( ass . is _ new _ version ( version ) )
asserts . add ( ass ) ;
using system _ collections _ generic ;
using system _ io ; using system _ diagnostics ; using simple _ json ;
using system _ text _ regular _ expressions ;
using shadowsocks _ controller ; using system ;
using system _ text ; using system _ windows _ forms ; using simple _ json ;
class encryptor
public const int type _ table = 1 ; public const int type _ r = 2 ;
public int method = type _ table ; public r rc = null ;
this . method = type _ r ;
} else {
this . method = type _ table ;
} public void encrypt ( byte [ ] buf , int length )
case type _ table :
break ; case type _ r :
break ;   } } public void decrypt ( byte [ ] buf , int length )
case type _ table :
break ; case type _ r :
break ;
catch ( exception )
message _ box . show ( STR ) ;
connection . close ( ) ;
remote . close ( ) ; }
public static sip _ plugin create _ if _ configured ( server server )
return new sip _ plugin ( server . plugin , server . plugin _ opts , server . plugin _ args , server . server , server . server _ port ) ;
private sip _ plugin ( string plugin , string plugin _ opts , string plugin _ args , string server _ address , int server _ port )
local local = new local ( NUM ) ; local . start ( ) ;
local . stop ( ) ;
this . config , this . quit } ) ;
this . config . name = STR ; this . config . size = new system . drawing . size ( NUM , NUM ) ; this . config . text = STR ; this . config . click + = new system . event _ handler ( this . config _ click ) ;    this . quit . name = STR ; this . quit . size = new system . drawing . size ( NUM , NUM ) ; this . quit . text = STR ; this . quit . click + = new system . event _ handler ( this . quit _ click ) ;
var json _ string = await new http _ client ( ) . get _ string _ async ( api ) ;
await geolocation _ and _ isp ; foreach ( var data _ list in data _ lists )
} if ( availability _ statics = = null ) { availability _ statics = new availability _ statistics ( ) ; availability _ statics . update _ configuration ( config ) ;
public partial class form : form
public form ( )
byte [ ] response = { NUM , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 } ; connection . begin _ send ( response , 0 , response . length , 0 , new async _ callback ( start _ connect ) , null ) ;
public static void set _ ie _ proxy ( bool enable , bool global , string proxy _ server , string pac _ url )
value = { dw _ value = ( int ) internet _ option _ per _ conn _ flags _ ui . proxy _ type _ proxy }
value = { psz _ value = marshal . string _ to _ h _ global _ ansi ( proxy _ server ) }
value = { psz _ value = marshal . string _ to _ h _ global _ ansi ( STR ) }
native _ methods . internet _ set _ option (
internet _ option . internet _ option _ settings _ changed ,
native _ methods . internet _ set _ option (
using system _ collections _ generic ;
using shadowsocks _ properties ; using shadowsocks _ util ;
using microsoft _ visual _ basic _ file _ io ; using system _ text ;
const string dllnam = STR ;
{ load _ ss _ crypto _ library ( ) ; load _ ss _ crypto _ library ( ) ; } static void load _ ss _ crypto _ library ( )
load _ library ( dll _ path ) ;
} static void load _ ss _ crypto _ library ( ) { string temp _ path = utils . get _ temp _ path ( ) ; string dll _ path = temp _ path + STR ; try { file _ manager . uncompress _ file ( dll _ path , resources . libsscrypto _ dll ) ; load _ library ( dll _ path ) ; } catch ( io _ exception ) { } catch ( exception e ) { console . write _ line ( e . to _ string ( ) ) ; }
public extern static void crypto _ stream _ salsa _ xor _ ic ( byte [ ] c , byte [ ] m , ulong mlen , byte [ ] n , ulong ic , byte [ ] k ) ;
public extern static void crypto _ stream _ chacha _ xor _ ic ( byte [ ] c , byte [ ] m , ulong mlen , byte [ ] n , ulong ic , byte [ ] k ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl
remote ? . begin _ send ( buffer , offset , size , socket _ flags , callback , state ) ;
remote ? . begin _ receive ( buffer , offset , size , socket _ flags , callback , state ) ;
remote ? . shutdown ( how ) ;
remote ? . dispose ( ) ;
this . qr _ code _ web _ browser . dock = system . windows . forms . dock _ style . fill ;
this . client _ size = new system . drawing . size ( NUM , NUM ) ;
private byte [ ] encrypt _ ctx ; private byte [ ] decrypt _ ctx ;
private int encrypt _ iv _ offset ; private int decrypt _ iv _ offset ;
private void init _ cipher ( ref byte [ ] ctx , byte [ ] iv , bool is _ cipher ) { ctx = new byte [ cipher _ info [ NUM ] ] ; lock ( ctx ) {  byte [ ] realkey ; if ( method = = STR ) { byte [ ] temp = new byte [ key _ len + iv _ len ] ; realkey = new byte [ key _ len ] ; array . copy ( key , 0 , temp , 0 , key _ len ) ; array . copy ( iv , 0 , temp , key _ len , iv _ len ) ; realkey = m . create ( ) . compute _ hash ( temp ) ;
realkey = key ; } if ( cipher = = cipher _ aes ) { polar _ ssl . aes _ init ( ctx ) ;   polar _ ssl . aes _ setkey _ enc ( ctx , realkey , key _ len * NUM ) ; if ( is _ cipher ) { encrypt _ iv = new byte [ iv _ len ] ; array . copy ( iv , encrypt _ iv , iv _ len ) ; } else { decrypt _ iv = new byte [ iv _ len ] ;  array . copy ( iv , decrypt _ iv , iv _ len ) ; } } else if ( cipher = = cipher _ bf ) { polar _ ssl . blowfish _ init ( ctx ) ;  polar _ ssl . blowfish _ setkey ( ctx , realkey , key _ len * NUM ) ; if ( is _ cipher ) { encrypt _ iv = new byte [ iv _ len ] ;  array . copy ( iv , encrypt _ iv , iv _ len ) ; } else { decrypt _ iv = new byte [ iv _ len ] ;  array . copy ( iv , decrypt _ iv , iv _ len ) ; } } else if ( cipher = = cipher _ r ) { polar _ ssl . arc _ init ( ctx ) ;  polar _ ssl . arc _ setup ( ctx , realkey , key _ len ) ; }
if ( encrypt _ ctx = = null )
lock ( encrypt _ ctx ) { if ( disposed ) { throw new object _ disposed _ exception ( this . to _ string ( ) ) ; } switch ( cipher ) { case cipher _ aes : polar _ ssl . aes _ crypt _ cfb ( encrypt _ ctx , polar _ ssl . aes _ encrypt , length , ref encrypt _ iv _ offset , encrypt _ iv , buf , tempbuf ) ; break ; case cipher _ bf : polar _ ssl . blowfish _ crypt _ cfb ( encrypt _ ctx , polar _ ssl . blowfish _ encrypt , length , ref encrypt _ iv _ offset , encrypt _ iv , buf , tempbuf ) ; break ; case cipher _ r : polar _ ssl . arc _ crypt ( encrypt _ ctx , length , buf , tempbuf ) ; break ; } outlength = length + iv _ len ; buffer . block _ copy ( tempbuf , 0 , outbuf , iv _ len , length ) ; }
lock ( encrypt _ ctx ) { if ( disposed ) { throw new object _ disposed _ exception ( this . to _ string ( ) ) ; } switch ( cipher ) { case cipher _ aes : polar _ ssl . aes _ crypt _ cfb ( encrypt _ ctx , polar _ ssl . aes _ encrypt , length , ref encrypt _ iv _ offset , encrypt _ iv , buf , outbuf ) ; break ; case cipher _ bf : polar _ ssl . blowfish _ crypt _ cfb ( encrypt _ ctx , polar _ ssl . blowfish _ encrypt , length , ref encrypt _ iv _ offset , encrypt _ iv , buf , outbuf ) ; break ; case cipher _ r : polar _ ssl . arc _ crypt ( encrypt _ ctx , length , buf , outbuf ) ; break ; }
if ( decrypt _ ctx = = null )
lock ( decrypt _ ctx ) { if ( disposed ) { throw new object _ disposed _ exception ( this . to _ string ( ) ) ; } switch ( cipher ) { case cipher _ aes : polar _ ssl . aes _ crypt _ cfb ( decrypt _ ctx , polar _ ssl . aes _ decrypt , length - iv _ len , ref decrypt _ iv _ offset , decrypt _ iv , tempbuf , outbuf ) ; break ; case cipher _ bf : polar _ ssl . blowfish _ crypt _ cfb ( decrypt _ ctx , polar _ ssl . blowfish _ decrypt , length - iv _ len , ref decrypt _ iv _ offset , decrypt _ iv , tempbuf , outbuf ) ; break ; case cipher _ r : polar _ ssl . arc _ crypt ( decrypt _ ctx , length - iv _ len , tempbuf , outbuf ) ; break ; }
lock ( decrypt _ ctx ) { if ( disposed ) { throw new object _ disposed _ exception ( this . to _ string ( ) ) ; } switch ( cipher ) { case cipher _ aes : polar _ ssl . aes _ crypt _ cfb ( decrypt _ ctx , polar _ ssl . aes _ decrypt , length , ref decrypt _ iv _ offset , decrypt _ iv , buf , outbuf ) ; break ; case cipher _ bf : polar _ ssl . blowfish _ crypt _ cfb ( decrypt _ ctx , polar _ ssl . blowfish _ decrypt , length , ref decrypt _ iv _ offset , decrypt _ iv , buf , outbuf ) ; break ; case cipher _ r : polar _ ssl . arc _ crypt ( decrypt _ ctx , length , buf , outbuf ) ; break ; }
public extern static void aes _ init ( byte [ ] ctx ) ;
public extern static void aes _ free ( byte [ ] ctx ) ;
public extern static int aes _ setkey _ enc ( byte [ ] ctx , byte [ ] key , int keysize ) ;
public extern static int aes _ crypt _ cfb ( byte [ ] ctx , int mode , int length , ref int iv _ off , byte [ ] iv , byte [ ] input , byte [ ] output ) ;
public extern static void arc _ init ( byte [ ] ctx ) ;
public extern static void arc _ free ( byte [ ] ctx ) ;
public extern static void arc _ setup ( byte [ ] ctx , byte [ ] key , int keysize ) ;
public extern static int arc _ crypt ( byte [ ] ctx , int length , byte [ ] input , byte [ ] output ) ;
public extern static void blowfish _ init ( byte [ ] ctx ) ;
public extern static void blowfish _ free ( byte [ ] ctx ) ;
public extern static int blowfish _ setkey ( byte [ ] ctx , byte [ ] key , int keysize ) ;
public extern static int blowfish _ crypt _ cfb ( byte [ ] ctx , int mode , int length , ref int iv _ off , byte [ ] iv , byte [ ] input , byte [ ] output ) ;
lock ( locker ) { encryptor = new polar _ ssl _ encryptor ( STR , STR ) ; decryptor = new polar _ ssl _ encryptor ( STR , STR ) ; }
assert . are _ equal ( NUM , out _ len ) ; for ( int j = 0 ; j < plain . length ; j + + ) { assert . are _ equal ( plain [ j ] , plain [ j ] ) ; }
using system _ text _ regular _ expressions ; using shadowsocks _ forward _ proxy ;
private readonly byte _ search . search _ target connect _ search = new byte _ search . search _ target ( encoding . ut . get _ bytes ( STR ) ) ; private readonly int socks _ port ; public http _ socks ( int socks _ port ) { socks _ port = socks _ port ; }
private static string get _ timestamp ( date _ time value )
return value . to _ string ( STR ) ;
if ( ! ( each . equals ( STR ) | | each . equals ( STR ) | | each . equals ( STR ) ) )
registry . set _ value ( each , default _ value ) ;
public bool statistics _ enabled { get ; } = true ; public bool by _ hour _ of _ day { get ; } = true ;
public int choice _ kept _ minutes { get ; } = NUM ; public int data _ collection _ minutes { get ; } = NUM ; public int repeat _ times _ num { get ; } = NUM ;
using system _ drawing ;
using system _ windows _ forms _ data _ visualization _ charting ;
using statistics = dictionary < string , list < statistics _ record > > ;
this . table _ layout _ panel . controls . add ( this . one _ time _ auth , 1 , NUM ) ;
this . table _ layout _ panel . row _ count = NUM ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ;
STR } ) ;
this . one _ time _ auth . auto _ size = true ; this . one _ time _ auth . location = new system . drawing . point ( NUM , NUM ) ; this . one _ time _ auth . name = STR ; this . one _ time _ auth . size = new system . drawing . size ( NUM , NUM ) ; this . one _ time _ auth . tab _ index = NUM ; this . one _ time _ auth . text = STR ; this . one _ time _ auth . use _ visual _ style _ back _ color = true ;
polipo _ runner . start ( config . get _ current _ server ( ) ) ; local = new local ( config . get _ current _ server ( ) ) ;
pac _ server . start ( ) ;
private server config ;
public local ( server config ) { this . config = config ;
listener = new socket ( address _ family . inter _ network , socket _ type . stream , protocol _ type . tcp ) ; ip _ end _ point local _ end _ point = new ip _ end _ point ( 0 , config . local _ port ) ;
public void start ( )
listener = new socket ( address _ family . inter _ network , socket _ type . stream , protocol _ type . tcp ) ; ip _ end _ point local _ end _ point = new ip _ end _ point ( 0 , NUM ) ;  listener . bind ( local _ end _ point ) ; listener . listen ( NUM ) ; listener . begin _ accept ( new async _ callback ( accept _ callback ) , listener ) ; watch _ pac _ file ( ) ;
socket conn = listener . end _ accept ( ar ) ;
watch _ pac _ file ( ) ;
string proxy = STR ;
this . show _ log _ item = new system . windows . forms . menu _ item ( ) ;
this . servers _ item . index = 1 ;
this . menu _ item . index = 2 ;
public void start ( server config )
public tcp _ handler ( tcp _ relay tcprelay )
ip _ end _ point remote _ ep = new ip _ end _ point ( ip _ address , server . server _ port ) ; remote = new direct _ connect ( ) ;
proxy _ timer . dest _ end _ point = remote _ ep ;
remote . begin _ connect _ proxy ( remote _ ep , new async _ callback ( proxy _ connect _ callback ) , proxy _ timer ) ;
var location = m . groups [ 2 ] . value ; var locs = location . split ( ':' ) ; target _ host = locs [ 0 ] ; if ( locs . length > 1 )
if ( ! int . try _ parse ( locs [ 1 ] , out target _ port ) ) { throw new exception ( STR + line ) ; } } else { target _ port = NUM ;
var location = line . substring ( NUM ) . trim ( ) ; var locs = location . split ( ':' ) ; target _ host = locs [ 0 ] ; if ( locs . length > 1 )
if ( ! int . try _ parse ( locs [ 1 ] , out target _ port ) ) { throw new exception ( STR + line ) ; } } else { target _ port = NUM ;
int enc _ index = 0 ; int enc _ index = 0 ; int dec _ index = 0 ; int dec _ index = 0 ;
encrypt _ output ( enc _ index , enc _ index , table , data , length ) ;
encrypt _ output ( dec _ index , dec _ index , table , data , length ) ;
private void encrypt _ output ( int index , int index , byte [ ] s , byte [ ] data , int length )
index = ( index + 1 ) & NUM ; index = ( index + s [ index ] ) & NUM ; swap ( s , index , index ) ; data [ n ] = ( byte ) ( b ^ s [ ( s [ index ] + s [ index ] ) & NUM ] ) ;
private static bool? portable _ mode ; private static string temp _ path = null ; public static bool is _ portable _ mode ( ) { if ( ! portable _ mode . has _ value ) { portable _ mode = file . exists ( path . combine ( application . startup _ path , STR ) ) ; } return portable _ mode . value ; }
if ( temp _ path = = null ) { if ( is _ portable _ mode ( ) ) try { directory . create _ directory ( path . combine ( application . startup _ path , STR ) ) ;   } catch ( exception e ) { temp _ path = path . get _ temp _ path ( ) ; logging . log _ useful _ exception ( e ) ; } finally {  temp _ path = path . combine ( application . startup _ path , STR ) ; } else temp _ path = path . get _ temp _ path ( ) ; } return temp _ path ;