run _ key = microsoft . win . registry . current _ user . open _ sub _ key ( STR , true ) ;
run _ key . set _ value ( key , path ) ;
run _ key . delete _ value ( key ) ;

run _ key = microsoft . win . registry . current _ user . open _ sub _ key ( STR , true ) ;

if ( item . equals ( key ) )

try { plugin _ process . start ( ) ; } catch ( system . component _ model . win _ exception ex ) {  if ( ( uint ) ex . error _ code = = 0 ) { throw new file _ not _ found _ exception ( n . get _ string ( STR ) , plugin _ process . start _ info . file _ name , ex ) ; } }
using newtonsoft _ json ; using shadowsocks _ controller ; using shadowsocks _ model ; using shadowsocks _ properties ; using system ;

try { process . start ( ) ; process . begin _ error _ read _ line ( ) ; process . begin _ output _ read _ line ( ) ; process . wait _ for _ exit ( ) ; } catch ( system . component _ model . win _ exception e ) {  throw new proxy _ exception ( proxy _ exception _ type . fail _ to _ run , process . start _ info . arguments , e ) ; }
throw new proxy _ exception ( proxy _ exception _ type . sysproxy _ exit _ error , stderr ) ;
throw new proxy _ exception ( proxy _ exception _ type . query _ return _ empty ) ;

this . table _ layout _ panel . controls . add ( this . plugin _ arguments _ text _ box , 1 , NUM ) ; this . table _ layout _ panel . controls . add ( this . plugin _ arguments _ label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . remarks _ label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . use _ plugin _ arg _ check _ box , 1 , NUM ) ;
this . table _ layout _ panel . row _ count = NUM ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ;
this . server _ group _ box = new system . windows . forms . group _ box ( ) ;

public void start ( bool reg _ hotkeys = true )
if ( reg _ hotkeys ) { hotkey _ reg . reg _ all _ hotkeys ( ) ; }

mbed _ tls . md ( input , ( uint ) input . length , output ) ;
public extern static void md ( byte [ ] input , uint ilen , byte [ ] output ) ;
using shadowsocks _ encryption ; using shadowsocks _ model ; using shadowsocks _ util ; using system ;

using system ;
shadowsocks _ controller controller ; public log _ form ( shadowsocks _ controller controller , string filename ) { this . controller = controller ;
log _ viewer _ config config = controller . get _ configuration _ copy ( ) . log _ viewer ; if ( config = = null ) config = new log _ viewer _ config ( ) ; top _ most _ trigger = config . top _ most ; wrap _ text _ trigger = config . wrap _ text ; toolbar _ trigger = config . toolbar _ shown ; log _ message _ text _ box . back _ color = config . get _ background _ color ( ) ; log _ message _ text _ box . fore _ color = config . get _ text _ color ( ) ; log _ message _ text _ box . font = config . get _ font ( ) ;
connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , socket _ flags . none , new async _ callback ( read _ all ) , null ) ;
connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , socket _ flags . none , new async _ callback ( read _ all ) , null ) ;
this . mode _ item . index = 1 ; this . mode _ item . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . pac _ mode _ item , this . global _ mode _ item } ) ; this . mode _ item . text = STR ;    this . pac _ mode _ item . index = 0 ; this . pac _ mode _ item . text = STR ; this . pac _ mode _ item . click + = new system . event _ handler ( this . pac _ mode _ item _ click ) ;    this . global _ mode _ item . index = 1 ; this . global _ mode _ item . text = STR ; this . global _ mode _ item . click + = new system . event _ handler ( this . global _ mode _ item _ click ) ;
this . menu _ item . index = NUM ; this . menu _ item . text = STR ;    this . auto _ startup _ item . index = NUM ; this . auto _ startup _ item . text = STR ; this . auto _ startup _ item . click + = new system . event _ handler ( this . auto _ startup _ item _ click ) ;    this . share _ over _ lan _ item . index = NUM ; this . share _ over _ lan _ item . text = STR ; this . share _ over _ lan _ item . click + = new system . event _ handler ( this . share _ over _ lan _ item _ click ) ;
public static void enable ( bool global )
if ( global ) { registry . set _ value ( STR , 1 ) ; registry . set _ value ( STR , STR ) ; registry . set _ value ( STR , STR ) ; } else { registry . set _ value ( STR , 0 ) ; registry . set _ value ( STR , STR ) ; registry . set _ value ( STR , STR + get _ timestamp ( date _ time . now ) ) ; }
public static void notify _ ie ( )
registry . set _ value ( STR , 0 ) ; registry . set _ value ( STR , STR ) ; registry . set _ value ( STR , STR ) ; system _ proxy . notify _ ie ( ) ;
registry . set _ value ( STR , STR ) ; system _ proxy . notify _ ie ( ) ;


var server _ urls = ss _ url . split ( '\r' , '\n' ) ;
foreach ( string server _ url in server _ urls )
if ( string . is _ null _ or _ white _ space ( server _ url ) )
continue ;
uri parsed _ url ; try { parsed _ url = new uri ( server _ url ) ; } catch ( uri _ format _ exception ) {
} server tmp = new server { remarks = parsed _ url . get _ components ( uri _ components . fragment , uri _ format . unescaped ) } ; string possibly _ unpadded _ base = parsed _ url . get _ components ( uri _ components . user _ info , uri _ format . unescaped ) ; bool is _ old _ format _ url = possibly _ unpadded _ base . length = = 0 ; if ( is _ old _ format _ url ) { int prefix _ length = STR . length ; int index _ of _ hash _ or _ slash = server _ url . last _ index _ of _ any ( new [ ] { '/' , '#' } , server _ url . length - 1 , server _ url . length - prefix _ length ) ; int substring _ length = server _ url . length - prefix _ length ; if ( index _ of _ hash _ or _ slash > = 0 ) { substring _ length = index _ of _ hash _ or _ slash - prefix _ length ; } possibly _ unpadded _ base = server _ url . substring ( prefix _ length , substring _ length ) . trim _ end ( '/' ) ; } else {  possibly _ unpadded _ base = possibly _ unpadded _ base . replace ( '-' , '+' ) . replace ( '_' , '/' ) ; } string base = possibly _ unpadded _ base . pad _ right ( possibly _ unpadded _ base . length + ( NUM - possibly _ unpadded _ base . length % NUM ) % NUM , '=' ) ; string inner _ user _ info _ or _ url = encoding . ut . get _ string ( convert . from _ base _ string ( base ) ) ; string user _ info ; if ( is _ old _ format _ url ) { uri inner _ url = new uri ( STR + inner _ user _ info _ or _ url ) ; user _ info = inner _ url . get _ components ( uri _ components . user _ info , uri _ format . unescaped ) ; tmp . server = inner _ url . get _ components ( uri _ components . host , uri _ format . unescaped ) ; tmp . server _ port = inner _ url . port ; } else { user _ info = inner _ user _ info _ or _ url ; tmp . server = parsed _ url . get _ components ( uri _ components . host , uri _ format . unescaped ) ; tmp . server _ port = parsed _ url . port ; } string [ ] user _ info _ parts = user _ info . split ( new [ ] { ':' } , 2 ) ; if ( user _ info _ parts . length ! = 2 ) { continue ; } tmp . method = user _ info _ parts [ 0 ] ; tmp . password = user _ info _ parts [ 1 ] ; name _ value _ collection query _ parameters = http _ utility . parse _ query _ string ( parsed _ url . query ) ; string [ ] plugin _ parts = http _ utility . url _ decode ( query _ parameters [ STR ] ? ? STR ) . split ( new [ ] { ';' } , 2 ) ; if ( plugin _ parts . length > 0 ) { tmp . plugin = plugin _ parts [ 0 ] ? ? STR ; } if ( plugin _ parts . length > 1 ) { tmp . plugin _ opts = plugin _ parts [ 1 ] ? ? STR ; }
this . table _ layout _ panel . controls . add ( this . plugin _ options _ label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . plugin _ text _ box , 1 , NUM ) ; this . table _ layout _ panel . controls . add ( this . remarks _ text _ box , 1 , NUM ) ; this . table _ layout _ panel . controls . add ( this . remarks _ label , 0 , NUM ) ;
this . table _ layout _ panel . controls . add ( this . timeout _ label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . timeout _ text _ box , 1 , NUM ) ; this . table _ layout _ panel . controls . add ( this . plugin _ label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . plugin _ options _ text _ box , 1 , NUM ) ;
this . table _ layout _ panel . row _ count = NUM ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ;
if ( file . exists ( database _ path ) & & new file _ info ( database _ path ) . length > 0 ) { geosite _ db = file . read _ all _ bytes ( database _ path ) ; } else { geosite _ db = resources . dlc _ dat ;
static void load _ geosite _ list ( ) { var list = geosite _ list . parser . parse _ from ( geosite _ db ) ;
public static async task update _ pac _ from _ geosite ( )
http _ client _ handler = new http _ client _ handler ( ) ; http _ client = new http _ client ( http _ client _ handler ) ;
http _ client _ handler . proxy = new web _ proxy (
try {  var geosite _ sha _ sum = await http _ client . get _ string _ async ( geosite _ sha _ sum _ url ) ; geosite _ sha _ sum = geosite _ sha _ sum . substring ( 0 , NUM ) . to _ upper ( ) ; logger . info ( $ STR ) ;  byte [ ] local _ db _ hash _ bytes = my _ sh . compute _ hash ( geosite _ db ) ; string local _ db _ hash = bit _ converter . to _ string ( local _ db _ hash _ bytes ) . replace ( STR , string . empty ) ; logger . info ( $ STR ) ;  if ( geosite _ sha _ sum = = local _ db _ hash ) { logger . info ( STR ) ; return ; }  var downloaded _ bytes = await http _ client . get _ byte _ array _ async ( geosite _ url ) ;  byte [ ] downloaded _ db _ hash _ bytes = my _ sh . compute _ hash ( downloaded _ bytes ) ; string downloaded _ db _ hash = bit _ converter . to _ string ( downloaded _ db _ hash _ bytes ) . replace ( STR , string . empty ) ; logger . info ( $ STR ) ; if ( geosite _ sha _ sum ! = downloaded _ db _ hash ) { logger . info ( STR ) ; throw new exception ( STR ) ; } else { logger . info ( STR ) ; }  using ( file _ stream geosite _ file _ stream = file . create ( database _ path ) ) await geosite _ file _ stream . write _ async ( downloaded _ bytes , 0 , downloaded _ bytes . length ) ;  geosite _ db = downloaded _ bytes ; load _ geosite _ list ( ) ; bool pac _ file _ changed = merge _ and _ write _ pac _ file ( group , blacklist ) ; update _ completed ? . invoke ( null , new geosite _ result _ event _ args ( pac _ file _ changed ) ) ; } catch ( exception ex ) { error ? . invoke ( null , new error _ event _ args ( ex ) ) ; } finally { if ( http _ client _ handler ! = null ) { http _ client _ handler . dispose ( ) ; http _ client _ handler = null ; } if ( http _ client ! = null ) { http _ client . dispose ( ) ; http _ client = null ; } }
private shadowsocks _ controller controller ;  private configuration modified _ configuration ; private int old _ selected _ index = - 1 ;
load _ current _ configuration ( ) ;
load _ current _ configuration ( ) ;
enable _ item . checked = controller . get _ configuration ( ) . enabled ;
private bool save _ old _ selected _ server ( )
try { if ( old _ selected _ index = = - 1 | | old _ selected _ index > = modified _ configuration . configs . count ) { return true ; } server server = new server { server = ip _ text _ box . text , server _ port = int . parse ( server _ port _ text _ box . text ) , password = password _ text _ box . text , local _ port = int . parse ( proxy _ port _ text _ box . text ) , method = encryption _ select . text } ; configuration . check _ server ( server ) ; modified _ configuration . configs [ old _ selected _ index ] = server ; return true ; } catch ( format _ exception ) { message _ box . show ( STR ) ; } catch ( exception ex ) { message _ box . show ( ex . message ) ; } return false ; } private void load _ selected _ server ( ) { server server = modified _ configuration . configs [ servers _ list _ box . selected _ index ] ;

private void load _ current _ configuration ( ) { modified _ configuration = controller . get _ configuration ( ) ; servers _ list _ box . items . clear ( ) ; foreach ( server server in modified _ configuration . configs ) { servers _ list _ box . items . add ( server . server ) ; } servers _ list _ box . selected _ index = modified _ configuration . index ; old _ selected _ index = servers _ list _ box . selected _ index ; enable _ item . checked = modified _ configuration . enabled ; } private void config _ form _ load ( object sender , event _ args e )
configuration config = controller . get _ configuration ( ) ;    controller . save _ config ( config ) ; this . hide ( ) ;
load _ current _ configuration ( ) ;

this . proxy _ port _ text _ box = new system . windows . forms . text _ box ( ) ; this . label = new system . windows . forms . label ( ) ;

this . label = new system . windows . forms . label ( ) ; this . encryption _ select = new system . windows . forms . combo _ box ( ) ;



using ( file . create ( path ) )


public line _ reader ( byte [ ] buffer , wrapped _ socket socket , byte [ ] first _ packge , int index , int length ,
encoding encoding , string delimiter ,
if ( buffer . length < length )
throw new argument _ exception ( STR , nameof ( buffer ) ) ;
if ( buffer . length < delimiter _ bytes . length )
throw new argument _ exception ( STR , nameof ( buffer ) ) ;
line _ buffer = buffer ;
if ( buffer = = first _ packge ) { buffer _ data _ index = index ; } else { array . copy ( first _ packge , index , line _ buffer , 0 , length ) ; }
socket . begin _ receive ( line _ buffer , 0 , line _ buffer . length , 0 , receive _ callback , 0 ) ;
public line _ reader ( int max _ line _ bytes , wrapped _ socket socket , func < string , object , bool > on _ line _ read , action < exception , object > on _ exception , action < byte [ ] , int , int , object > on _ finish , encoding encoding , string delimiter , object state ) : this ( new byte [ max _ line _ bytes ] , socket , null , 0 , 0 , on _ line _ read , on _ exception , on _ finish , encoding , delimiter , state )
byte [ ] request = null ; byte atyp = 0 ; int port ; var dep = dest _ end _ point as dns _ end _ point ; if ( dep ! = null ) {  atyp = NUM ; var enc = encoding . ut ; var host _ byte _ count = enc . get _ byte _ count ( dep . host ) ; request = new byte [ NUM + 1 request [ NUM ] = ( byte ) host _ byte _ count ; enc . get _ bytes ( dep . host , 0 , dep . host . length , request , NUM ) ; port = dep . port ; } else { switch ( dest _ end _ point . address _ family ) { case address _ family . inter _ network : request = new byte [ NUM + NUM + 2 ] ; atyp = 1 ; break ; case address _ family . inter _ network : request = new byte [ NUM + NUM + 2 ] ; atyp = NUM ; break ; default : throw new exception ( n . get _ string ( STR ) ) ; } port = ( ( ip _ end _ point ) dest _ end _ point ) . port ; var addr = ( ( ip _ end _ point ) dest _ end _ point ) . address . get _ address _ bytes ( ) ; array . copy ( addr , 0 , request , NUM , request . length - NUM - 2 ) ; }
namespace shadowsocks _ controller
public i _ set < tcp _ handler > handlers { get ; set ; }

if ( socket . protocol _ type ! = protocol _ type . tcp | | ( length < 2 | | first _ packet [ 0 ] ! = NUM ) )

class tcp _ handler
class async _ session
class async _ session < t > : async _ session
private shadowsocks _ controller controller ; private configuration config ; private tcp _ relay tcprelay ; private socket connection ; private i _ encryptor encryptor ; private server server ;
private bool proxy _ connected ; private bool dest _ connected ; private byte command ; private byte [ ] first _ packet ; private int first _ packet _ length ; private int total _ read = 0 ; private int total _ write = 0 ;    private byte [ ] remote _ recv _ buffer = new byte [ buffer _ size ] ; private byte [ ] remote _ send _ buffer = new byte [ buffer _ size ] ; private byte [ ] connetion _ recv _ buffer = new byte [ buffer _ size ] ; private byte [ ] connetion _ send _ buffer = new byte [ buffer _ size ] ; private bool connection _ shutdown = false ; private bool remote _ shutdown = false ; private bool closed = false ;  private readonly object encryption _ lock = new object ( ) ; private readonly object decryption _ lock = new object ( ) ; private readonly object close _ conn _ lock = new object ( ) ;
public tcp _ handler ( shadowsocks _ controller controller , configuration config , tcp _ relay tcprelay , socket socket )
} public void create _ remote ( ) { server server = controller . get _ a _ server ( i _ strategy _ caller _ type . tcp , ( ip _ end _ point ) connection . remote _ end _ point , dest _ end _ point ) ;
private void start _ pipe ( async _ session session ) { if ( closed ) return ;
session . remote . begin _ receive ( remote _ recv _ buffer , 0 , recv _ size , socket _ flags . none , new async _ callback ( pipe _ remote _ receive _ callback ) , session ) ; send _ to _ server ( first _ packet _ length , session ) ;

session . remote . begin _ send ( connetion _ send _ buffer , 0 , bytes _ to _ send , socket _ flags . none , new async _ callback ( pipe _ remote _ send _ callback ) , session ) ;

if ( closed ) return ; try { var session = ( async _ session ) ar . async _ state ; session . remote . end _ send ( ar ) ; connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , socket _ flags . none , new async _ callback ( pipe _ connection _ receive _ callback ) , session ) ;


decrypt _ iv = new byte [ iv _ len ] ; array . copy ( iv , decrypt _ iv , iv _ len ) ; } } else if ( cipher = = cipher _ bf ) { polar _ ssl . blowfish _ init ( ctx ) ;  polar _ ssl . blowfish _ setkey ( ctx , realkey , key _ len * NUM ) ; if ( is _ cipher ) { encrypt _ iv = new byte [ iv _ len ] ; array . copy ( iv , encrypt _ iv , iv _ len ) ; } else {




public class gfw _ list _ download _ completed _ args : event _ args { public string content ; } public event event _ handler < gfw _ list _ download _ completed _ args > download _ completed ; public event error _ event _ handler error ; public void download ( ) { web _ client http = new web _ client ( ) ; http . proxy = proxy ; http . download _ string _ completed + = http _ download _ string _ completed ; http . download _ string _ async ( new uri ( gfwlist _ url ) ) ; } protected void report _ error ( exception e ) { if ( error ! = null ) { error ( this , new error _ event _ args ( e ) ) ; } } private void http _ download _ string _ completed ( object sender , download _ string _ completed _ event _ args e )
string response = e . result ; if ( download _ completed ! = null ) { download _ completed ( this , new gfw _ list _ download _ completed _ args { content = response } ) ; }
report _ error ( ex ) ; } }       public class parser { private string content ; public string content { get { return content ; } }
this . content = encoding . ascii . get _ string ( bytes ) ; } public string [ ] get _ valid _ lines ( ) { string [ ] lines = content . split ( new char [ ] { '\r' , '\n' } , string _ split _ options . remove _ empty _ entries ) ; list < string > valid _ lines = new list < string > ( lines . length ) ; foreach ( string line in lines ) { if ( line . starts _ with ( STR ) | | line . starts _ with ( STR ) ) continue ; valid _ lines . add ( line ) ; } return valid _ lines . to _ array ( ) ;
list < string > lines = new list < string > ( get _ valid _ lines ( ) ) ;

this . lock _ button = new system . windows . forms . button ( ) ; this . panel = new system . windows . forms . panel ( ) ;
if ( controller = = null | | controller . get _ configuration ( ) . is _ default ) { is _ first _ run = true ; } else
begin _ invoke ( new method _ invoker ( delegate { this . hide ( ) ; } ) ) ;
string path = e . full _ path . to _ string ( ) ; string current _ last _ write _ time = file . get _ last _ write _ time ( e . full _ path ) . to _ string ( ) ;  if ( ! file _ changed _ time . contains _ key ( path ) | | file _ changed _ time [ path ] . to _ string ( ) ! = current _ last _ write _ time ) { if ( pac _ file _ changed ! = null ) { console . write _ line ( STR , e . name , e . change _ type . to _ string ( ) . to _ lower ( ) ) ; pac _ file _ changed ( this , new event _ args ( ) ) ; }  file _ changed _ time [ path ] = current _ last _ write _ time ;
string path = e . full _ path . to _ string ( ) ; string current _ last _ write _ time = file . get _ last _ write _ time ( e . full _ path ) . to _ string ( ) ;  if ( ! file _ changed _ time . contains _ key ( path ) | | file _ changed _ time [ path ] . to _ string ( ) ! = current _ last _ write _ time ) { if ( user _ rule _ file _ changed ! = null ) { console . write _ line ( STR , e . name , e . change _ type . to _ string ( ) . to _ lower ( ) ) ; user _ rule _ file _ changed ( this , new event _ args ( ) ) ; }  file _ changed _ time [ path ] = current _ last _ write _ time ; } }
process . start _ info . use _ shell _ execute = true ;


if ( string . is _ null _ or _ empty ( controller . get _ configuration ( ) . pac _ url ) ) { update _ online _ pacurl _ item _ click ( sender , e ) ; } if ( ! string . is _ null _ or _ empty ( controller . get _ configuration ( ) . pac _ url ) ) { local _ pac _ item . checked = false ; online _ pac _ item . checked = true ; controller . use _ online _ pac ( true ) ; } update _ pac _ items _ enabled _ status ( ) ;


file _ stream file _ stream = new file _ stream ( file _ name , file _ mode . create , file _ access . write ) ;
while ( ( n = input . read ( buffer , 0 , buffer . length ) ) > 0 )

if ( ! file . exists ( log _ file _ path ) ) using ( file . create ( log _ file _ path ) ) { } log _ file _ creation _ time = file . get _ creation _ time ( log _ file _ path ) ; if ( ( date _ time . now - log _ file _ creation _ time ) . days > = 1 ) roll _ log _ file ( ) ; else { file _ stream fs = new file _ stream ( log _ file _ path , file _ mode . append ) ; stream _ writer _ with _ timestamp sw = new stream _ writer _ with _ timestamp ( fs ) ; sw . auto _ flush = true ; console . set _ out ( sw ) ; console . set _ error ( sw ) ; }
write _ to _ log _ file ( STR + o ) ;
write _ to _ log _ file ( o ) ;
write _ to _ log _ file ( STR + o ) ;
public void update _ pac _ from _ gfw _ list ( configuration config )
http . proxy = new web _ proxy ( ip _ address . loopback . to _ string ( ) , config . local _ port ) ;
clear _ logs _ button . text = n . get _ string ( STR ) ;
clear _ logs _ menu _ item . text = n . get _ string ( STR ) ;
private void do _ clear _ logs ( )
private void clear _ logs _ menu _ item _ click ( object sender , event _ args e ) { do _ clear _ logs ( ) ; } private void clear _ logs _ button _ click ( object sender , event _ args e ) { do _ clear _ logs ( ) ;
this . clear _ logs _ menu _ item = new system . windows . forms . menu _ item ( ) ;
this . clear _ logs _ button = new system . windows . forms . button ( ) ;
this . clear _ logs _ menu _ item . index = 0 ; this . clear _ logs _ menu _ item . text = STR ; this . clear _ logs _ menu _ item . click + = new system . event _ handler ( this . clear _ logs _ menu _ item _ click ) ;
private system . windows . forms . button clear _ logs _ button ;
private system . windows . forms . menu _ item clear _ logs _ menu _ item ;


if ( target _ index = = - 1 | | en _ index = = target _ index )



ip _ address ip _ address ; bool parsed = ip _ address . try _ parse ( config . proxy _ server , out ip _ address ) ;
proxy _ ep = null ;
proxy _ timer . proxy = remote ; proxy _ timer . dest _ host = server . server ; proxy _ timer . dest _ port = server . server _ port ;
public end _ point proxy _ end _ point { get ; } = new fake _ end _ point ( ) ; public string dest _ host { get ; private set ; } public int dest _ port { get ; private set ; }

public void begin _ connect _ dest ( string host , int port , async _ callback callback , object state )

string dest _ host { get ; } int dest _ port { get ; }
void begin _ connect _ dest ( string host , int port , async _ callback callback , object state ) ;
qr _ code _ cs . options options = new qr _ code _ cs . options ( ) ; options . text = qr _ text ; qr _ code _ cs . qr _ code qr _ coded = null ; bool success = false ; foreach ( var level in new qr _ error _ correct _ level [ ] { qr _ error _ correct _ level . h , qr _ error _ correct _ level . q , qr _ error _ correct _ level . m , qr _ error _ correct _ level . l } ) { for ( int i = NUM ; i < NUM ; i + + ) { try { options . type _ number = i ; options . correct _ level = level ; qr _ coded = new qr _ code _ cs . qr _ code ( options ) ; qr _ coded . make ( ) ; success = true ; break ; } catch { qr _ coded = null ; continue ; } } if ( success ) break ; } if ( qr _ coded = = null ) { return ; } int block _ size = math . max ( NUM / qr _ coded . get _ module _ count ( ) , 1 ) ;
using ( graphics g = graphics . from _ image ( draw _ area ) )
g . clear ( color . white ) ; using ( brush b = new solid _ brush ( color . black ) )
for ( int row = 0 ; row < qr _ coded . get _ module _ count ( ) ; row + + )
for ( int col = 0 ; col < qr _ coded . get _ module _ count ( ) ; col + + )
bool is _ dark = qr _ coded . is _ dark ( row , col ) ; if ( is _ dark )
g . fill _ rectangle ( b , block _ size * row , block _ size * col , block _ size , block _ size ) ;
config = json _ convert . deserialize _ object < configuration > ( config _ content ) ;

config = new configuration
try
font _ dialog fd = new font _ dialog ( ) ; fd . font = log _ message _ text _ box . font ; if ( fd . show _ dialog ( ) = = dialog _ result . ok ) { log _ message _ text _ box . font = new font ( fd . font . font _ family , fd . font . size , fd . font . style ) ; } } catch ( exception ex ) { logging . log _ useful _ exception ( ex ) ; message _ box . show ( ex . message ) ;

string server _ url = server _ url . trim ( ) ; if ( ! server _ url . begin _ with ( STR , string _ comparison . invariant _ culture _ ignore _ case ) )
parsed _ url = new uri ( decoded _ server _ url ) ;
string user _ info = parsed _ url . get _ components ( uri _ components . user _ info , uri _ format . unescaped ) ; tmp . server = parsed _ url . get _ components ( uri _ components . host , uri _ format . unescaped ) ; tmp . server _ port = parsed _ url . port ;
this . table _ layout _ panel . controls . add ( this . one _ time _ auth , 1 , NUM ) ; this . table _ layout _ panel . controls . add ( this . timeout _ label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . timeout _ text _ box , 1 , NUM ) ;
this . table _ layout _ panel . row _ count = NUM ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ;
this . proxy _ port _ label = new system . windows . forms . label ( ) ;
this . proxy _ addr _ label . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ;
this . proxy _ port _ label . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . proxy _ port _ label . auto _ size = true ; this . proxy _ port _ label . location = new system . drawing . point ( NUM , NUM ) ; this . proxy _ port _ label . name = STR ; this . proxy _ port _ label . size = new system . drawing . size ( NUM , NUM ) ; this . proxy _ port _ label . tab _ index = 2 ; this . proxy _ port _ label . text = STR ;
this . table _ layout _ panel . column _ count = NUM ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ;
this . proxy _ type _ label . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ;
this . proxy _ type _ combo _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ;
private system . windows . forms . label proxy _ port _ label ;
public void update _ latency ( object sender , sstcp _ connected _ event _ args args ) { get _ current _ strategy ( ) ? . update _ latency ( args . server , args . latency ) ;
availability _ statistics . update _ latency ( args . server , ( int ) args . latency . total _ milliseconds ) ; } } public void update _ inbound _ counter ( object sender , ss _ transmit _ event _ args args ) { get _ current _ strategy ( ) ? . update _ last _ read ( args . server ) ; interlocked . add ( ref inbound _ counter , args . length ) ;
availability _ statistics . update _ inbound _ counter ( args . server , args . length ) ; } } public void update _ outbound _ counter ( object sender , ss _ transmit _ event _ args args ) { get _ current _ strategy ( ) ? . update _ last _ write ( args . server ) ; interlocked . add ( ref outbound _ counter , args . length ) ;
availability _ statistics . update _ outbound _ counter ( args . server , args . length ) ;
using system ;
internal class tcp _ relay : listener . service
public event event _ handler < sstcp _ connected _ event _ args > on _ connected ; public event event _ handler < ss _ transmit _ event _ args > on _ inbound ; public event event _ handler < ss _ transmit _ event _ args > on _ outbound ; public event event _ handler < ss _ relay _ event _ args > on _ failed ; private static readonly logger logger = log _ manager . get _ current _ class _ logger ( ) ; private readonly shadowsocks _ controller controller ;
private readonly configuration config ;
tcp _ handler handler = new tcp _ handler ( controller , config , socket ) ; handler . on _ connected + = on _ connected ; handler . on _ inbound + = on _ inbound ; handler . on _ outbound + = on _ outbound ; handler . on _ failed + = on _ failed ; handler . on _ closed + = ( h , arg ) = > { lock ( handlers ) { handlers . remove ( handler ) ; } } ;
} public class ss _ relay _ event _ args : event _ args { public readonly server server ; public ss _ relay _ event _ args ( server server ) { this . server = server ; } } public class ss _ transmit _ event _ args : ss _ relay _ event _ args { public readonly long length ; public ss _ transmit _ event _ args ( server server , long length ) : base ( server ) { this . length = length ; } } public class sstcp _ connected _ event _ args : ss _ relay _ event _ args { public readonly time _ span latency ; public sstcp _ connected _ event _ args ( server server , time _ span latency ) : base ( server ) { this . latency = latency ;
public event event _ handler < sstcp _ connected _ event _ args > on _ connected ; public event event _ handler < ss _ transmit _ event _ args > on _ inbound ; public event event _ handler < ss _ transmit _ event _ args > on _ outbound ; public event event _ handler < ss _ relay _ event _ args > on _ closed ; public event event _ handler < ss _ relay _ event _ args > on _ failed ; private class async _ session
private class async _ session < t > : async _ session
private static readonly logger logger = log _ manager . get _ current _ class _ logger ( ) ;
private readonly shadowsocks _ controller controller ; private readonly proxy _ config config ; private readonly socket connection ;
private readonly byte [ ] remote _ recv _ buffer = new byte [ buffer _ size ] ;
private readonly byte [ ] connetion _ recv _ buffer = new byte [ buffer _ size ] ;
private readonly byte [ ] remote _ send _ buffer = new byte [ buffer _ size ] ;
private readonly byte [ ] connetion _ send _ buffer = new byte [ buffer _ size ] ;
public tcp _ handler ( shadowsocks _ controller controller , configuration config , socket socket )
config = config . proxy ;
server = server ;
if ( closed ) { return ; }
on _ closed ? . invoke ( this , new ss _ relay _ event _ args ( server ) ) ;
} } catch ( exception e ) { error _ close ( e ) ;
if ( closed ) { return ; }
address _ receive _ callback , null ) ; } catch ( exception e ) {  error _ close ( e ) ; } } private void address _ receive _ callback ( i _ async _ result ar ) { if ( closed ) { return ; }
error _ close ( e ) ; } } private void connect _ response _ callback ( i _ async _ result ar )
error _ close ( e ) ;
if ( closed ) { return ; }
object [ ] states = ( object [ ] ) ar . async _ state ;
action on _ success = ( action ) states [ 1 ] ;
} } } catch ( exception e ) { error _ close ( e ) ;
proxy _ ep = socket _ util . get _ end _ point ( config . proxy _ server , config . proxy _ port ) ;
async _ session session = new async _ session ( remote ) ;
error _ close ( e ) ;
proxy _ timer timer = ( proxy _ timer ) sender ;
i _ proxy proxy = timer . session . remote ;
async _ session < proxy _ timer > session = ( async _ session < proxy _ timer > ) ar . async _ state ;
end _ point dest _ end _ point = timer . dest _ end _ point ; server server = timer . server ;
i _ proxy remote = session . remote ;
if ( config . use _ auth ) { auth = new network _ credential ( config . auth _ user , config . auth _ pwd ) ;
error _ close ( e ) ;
server _ timer timer = ( server _ timer ) sender ;
async _ session session = timer . session ;
on _ failed ? . invoke ( this , new ss _ relay _ event _ args ( server ) ) ;
if ( closed ) { return ; } try { async _ session < server _ timer > session = ( async _ session < server _ timer > ) ar . async _ state ;
i _ proxy remote = session . remote ;
time _ span latency = date _ time . now - start _ connect _ time ; on _ connected ? . invoke ( this , new sstcp _ connected _ event _ args ( server , latency ) ) ;
on _ failed ? . invoke ( this , new ss _ relay _ event _ args ( server ) ) ; } error _ close ( e ) ;
int size = connection . receive ( connetion _ recv _ buffer , first _ packet _ length , available ,
if ( closed ) { return ; }
error _ close ( e ) ;
if ( closed ) { return ; } try { async _ session session = ( async _ session ) ar . async _ state ;
on _ inbound ? . invoke ( this , new ss _ transmit _ event _ args ( server , bytes _ read ) ) ;
error _ close ( e ) ;
if ( closed ) { return ; }
async _ session session = ( async _ session ) ar . async _ state ; i _ proxy remote = session . remote ;
on _ outbound ? . invoke ( this , new ss _ transmit _ event _ args ( server , bytes _ to _ send ) ) ;

if ( closed ) { return ; } try { object [ ] container = ( object [ ] ) ar . async _ state ; async _ session session = ( async _ session ) container [ 0 ] ; int bytes _ should _ send = ( int ) container [ 1 ] ;
error _ close ( e ) ;
object [ ] container = ( object [ ] ) ar . async _ state ; async _ session session = ( async _ session ) container [ 0 ] ; int bytes _ should _ send = ( int ) container [ 1 ] ; int bytes _ sent = connection . end _ send ( ar ) ; int bytes _ remaining = bytes _ should _ send - bytes _ sent ;

STR } ) ;

for ( int i = 0 ; i < NUM ; i + + ) {  i _ encryptor encryptor ; i _ encryptor decryptor ; encryptor = new polar _ ssl _ encryptor ( STR , STR ) ; decryptor = new polar _ ssl _ encryptor ( STR , STR ) ;  run _ encryption _ round ( encryptor , decryptor ) ; } } catch { encryption _ failed = true ; throw ; } } test _ method public void test _ r _ encryption ( ) {  run _ single _ r _ encryption _ thread ( ) ; list < thread > threads = new list < thread > ( ) ; for ( int i = 0 ; i < NUM ; i + + ) { thread t = new thread ( new thread _ start ( run _ single _ r _ encryption _ thread ) ) ; threads . add ( t ) ; t . start ( ) ; }    foreach ( thread t in threads ) { t . join ( ) ; } assert . is _ false ( encryption _ failed ) ; } private void run _ single _ r _ encryption _ thread ( ) { try { for ( int i = 0 ; i < NUM ; i + + ) { var random = new random ( ) ; i _ encryptor encryptor ; i _ encryptor decryptor ; encryptor = new polar _ ssl _ encryptor ( STR , STR ) ; decryptor = new polar _ ssl _ encryptor ( STR , STR ) ; run _ encryption _ round ( encryptor , decryptor ) ; }



this . flow _ layout _ panel . suspend _ layout ( ) ;


this . flow _ layout _ panel . resume _ layout ( false ) ;






this . qr _ code _ item = new system . windows . forms . menu _ item ( ) ;





if ( ! controller . get _ configuration ( ) . is _ default ) { this . opacity = 0 ; begin _ invoke ( new method _ invoker ( delegate { this . hide ( ) ; } ) ) ;
is _ first _ run = true ;
string server _ str ;  var host _ type = uri . check _ host _ name ( server ) ; if ( host _ type = = uri _ host _ name _ type . unknown ) { throw new format _ exception ( STR ) ;
switch ( host _ type ) { case uri _ host _ name _ type . i _ pv : server _ str = $ STR ; break ; default :  server _ str = $ STR ; break ;
return remarks . is _ null _ or _ empty ( ) ? server _ str : $ STR ;
this . client _ size = new system . drawing . size ( NUM , NUM ) ; this . controls . add ( this . picture _ box ) ;
private void update _ traffic _ chart ( ) { list < float > inbound _ points = new list < float > ( ) ; list < float > outbound _ points = new list < float > ( ) ; text _ annotation inbound _ annotation = new text _ annotation ( ) ; text _ annotation outbound _ annotation = new text _ annotation ( ) ; tuple < float , string , long > bandwidth _ scale ; const long min _ scale = NUM ;
long last _ inbound , last _ outbound ; lock ( this ) { if ( traffic . count = = 0 ) return ; foreach ( var traffic _ per _ second in traffic ) { inbound _ points . add ( traffic _ per _ second . item ) ; outbound _ points . add ( traffic _ per _ second . item ) ; max _ speed = math . max ( max _ speed , math . max ( traffic _ per _ second . item , traffic _ per _ second . item ) ) ; } last _ inbound = traffic . last ( ) . item ; last _ outbound = traffic . last ( ) . item ; } if ( max _ speed > 0 ) { last _ max _ speed - = last _ max _ speed / NUM ; max _ speed = math . max ( min _ scale , math . max ( max _ speed , last _ max _ speed ) ) ; last _ max _ speed = max _ speed ; } else { max _ speed = last _ max _ speed = min _ scale ;
if ( traffic _ chart . is _ handle _ created ) { traffic _ chart . series [ STR ] . points . data _ bind _ y ( inbound _ points ) ; traffic _ chart . series [ STR ] . points . data _ bind _ y ( outbound _ points ) ; traffic _ chart . chart _ areas [ 0 ] . axis _ y . label _ style . format = STR + bandwidth _ scale . item ; traffic _ chart . chart _ areas [ 0 ] . axis _ y . maximum = bandwidth _ scale . item ; inbound _ annotation . anchor _ data _ point = traffic _ chart . series [ STR ] . points . last ( ) ; inbound _ annotation . text = utils . format _ bandwidth ( last _ inbound ) ; outbound _ annotation . anchor _ data _ point = traffic _ chart . series [ STR ] . points . last ( ) ; outbound _ annotation . text = utils . format _ bandwidth ( last _ outbound ) ; traffic _ chart . annotations . clear ( ) ; traffic _ chart . annotations . add ( inbound _ annotation ) ; traffic _ chart . annotations . add ( outbound _ annotation ) ;  } } private void controller _ traffic _ changed ( object sender , event _ args e ) { lock ( this ) { traffic = new shadowsocks _ controller . queue _ last < tuple < long , long > > ( ) ; foreach ( var traffic _ per _ second in controller . traffic ) { traffic . enqueue ( new tuple < long , long > ( traffic _ per _ second . inbound _ increasement , traffic _ per _ second . outbound _ increasement ) ) ; }
this . plugin _ text _ box . margin = new system . windows . forms . padding ( NUM ) ;
this . remarks _ text _ box . margin = new system . windows . forms . padding ( NUM ) ;
this . ip _ text _ box . margin = new system . windows . forms . padding ( NUM ) ;
this . server _ port _ text _ box . margin = new system . windows . forms . padding ( NUM ) ;
this . password _ text _ box . margin = new system . windows . forms . padding ( NUM ) ;
this . plugin _ options _ text _ box . margin = new system . windows . forms . padding ( NUM ) ;
this . show _ passwd _ check _ box . margin = new system . windows . forms . padding ( NUM ) ;
this . plugin _ arguments _ text _ box . margin = new system . windows . forms . padding ( NUM ) ;
this . table _ layout _ panel . padding = new system . windows . forms . padding ( NUM ) ;
this . proxy _ port _ text _ box . margin = new system . windows . forms . padding ( NUM ) ;




this . split _ container . size = new system . drawing . size ( NUM , NUM ) ; this . split _ container . splitter _ distance = NUM ; this . split _ container . splitter _ width = 1 ;
this . label . text = STR ; this . calculatin _ tip . set _ tool _ tip ( this . label , STR ) ;
public tcp _ relay ( shadowsocks _ controller controller , configuration conf )
tcp _ handler handler = new tcp _ handler ( this , config ) ;
private configuration config ; public tcp _ handler ( tcp _ relay tcprelay , configuration config )
if ( config . is _ verbose _ logging ) {
if ( config . is _ verbose _ logging ) {
if ( config . is _ verbose _ logging ) {
void show _ balloon _ tip ( string title , string content , tool _ tip _ icon icon , int timeout ) { notify _ icon . balloon _ tip _ title = title ; notify _ icon . balloon _ tip _ text = content ; notify _ icon . balloon _ tip _ icon = icon ; notify _ icon . show _ balloon _ tip ( timeout ) ; } void controller _ update _ pac _ from _ gfw _ list _ error ( object sender , error _ event _ args e ) { show _ balloon _ tip ( n . get _ string ( STR ) , e . get _ exception ( ) . message , tool _ tip _ icon . error , NUM ) ;
show _ balloon _ tip ( n . get _ string ( STR ) , n . get _ string ( STR ) , tool _ tip _ icon . info , NUM ) ;
show _ balloon _ tip ( string . format ( n . get _ string ( STR ) , update _ checker . latest _ version _ number ) , n . get _ string ( STR ) , tool _ tip _ icon . info , NUM ) ;

if ( config . proxy . use _ proxy )
proxy _ ep = socket _ util . get _ end _ point ( config . proxy . proxy _ server , config . proxy . proxy _ port ) ;
config . proxy . use _ proxy = false ;
config . proxy . use _ proxy = true ; config . proxy . proxy _ server = proxy ; config . proxy . proxy _ port = port ;
url _ finder = new regex ( STR , regex _ options . ignore _ case ) ,
STR , regex _ options . ignore _ case ) ;
port = int . parse ( proxy _ port _ text _ box . text ) ;
modified _ configuration . proxy _ type = type ; modified _ configuration . proxy _ server = proxy ; modified _ configuration . proxy _ port = port ; modified _ configuration . proxy _ timeout = timeout ;
server server = new server ( ) ; server . server = ip _ text _ box . text . trim ( ) ; try { server . server _ port = int . parse ( server _ port _ text _ box . text ) ; } catch ( format _ exception ) { message _ box . show ( n . get _ string ( STR ) ) ; server _ port _ text _ box . clear ( ) ; return false ; } server . password = password _ text _ box . text ; server . method = encryption _ select . text ; server . remarks = remarks _ text _ box . text ; try { server . timeout = int . parse ( timeout _ text _ box . text ) ; } catch ( format _ exception ) { message _ box . show ( n . get _ string ( STR ) ) ; timeout _ text _ box . clear ( ) ; return false ; } server . auth = one _ time _ auth . checked ;



this . picture _ box . dock = system . windows . forms . dock _ style . fill ; this . picture _ box . location = new system . drawing . point ( NUM , NUM ) ; this . picture _ box . margin = new system . windows . forms . padding ( 0 ) ;
this . picture _ box . size = new system . drawing . size ( NUM , NUM ) ; this . picture _ box . size _ mode = system . windows . forms . picture _ box _ size _ mode . stretch _ image ;
this . client _ size = new system . drawing . size ( NUM , NUM ) ; this . controls . add ( this . panel ) ;

public tcp _ handler ( shadowsocks _ controller controller , configuration config , socket socket )

public bool ask _ add _ server _ by _ ssurl ( string ss _ url )
if ( add _ server _ by _ ssurl ( ss _ url ) ) { message _ box . show ( n . get _ string ( STR , ss _ url ) ) ; return true ; } else { message _ box . show ( n . get _ string ( STR ) ) ; } } return false ;

gfw _ list _ updater . merge _ and _ write _ pac _ file ( file _ manager . non _ exclusive _ read _ all _ text ( utils . get _ temp _ path ( STR ) ) ) ; }
bool pac _ file _ changed = merge _ and _ write _ pac _ file ( e . result ) ; update _ completed ? . invoke ( this , new result _ event _ args ( pac _ file _ changed ) ) ;
public const int recv _ reserve _ size = ( recv _ size / iv _ encryptor . crc _ buf _ len + 1 ) * iv _ encryptor . crc _ bytes + NUM ; public const int buffer _ size = recv _ size + recv _ reserve _ size + NUM ;
private byte [ ] remote _ recv _ buffer = new byte [ buffer _ size ] ;
private byte [ ] connetion _ recv _ buffer = new byte [ buffer _ size ] ;
if ( uri . check _ host _ name ( server . server = ip _ text _ box . text . trim ( ) ) = = uri _ host _ name _ type . unknown ) { message _ box . show ( n . get _ string ( STR ) ) ; ip _ text _ box . focus ( ) ; return false ; } if ( ! int . try _ parse ( server _ port _ text _ box . text , out server . server _ port ) )
server _ port _ text _ box . focus ( ) ;
if ( ! int . try _ parse ( timeout _ text _ box . text , out server . timeout ) )
timeout _ text _ box . focus ( ) ;
if ( socket . protocol _ type ! = protocol _ type . tcp | | ( length < 2 | | first _ packet [ 0 ] ! = NUM ) )
else {   socket . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; tcp _ handler handler = new tcp _ handler ( this ) ; handler . connection = socket ; handler . controller = controller ; handler . tcprelay = this ; handler . start ( first _ packet , length ) ; i _ list < tcp _ handler > handlers _ to _ close = new list < tcp _ handler > ( ) ; lock ( handlers ) { handlers . add ( handler ) ; date _ time now = date _ time . now ; if ( now - last _ sweep _ time > time _ span . from _ seconds ( 1 ) ) { last _ sweep _ time = now ; foreach ( tcp _ handler handler in handlers )  if ( now - handler . last _ activity > time _ span . from _ seconds ( NUM ) )  handlers _ to _ close . add ( handler ) ;   } } foreach ( tcp _ handler handler in handlers _ to _ close ) { logging . debug ( STR ) ; handler . close ( ) ; } return true ; }
tcprelay = tcprelay ;



else closed = true ; }   try { connection ? . shutdown ( socket _ shutdown . both ) ; connection ? . close ( ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; }    try { remote ? . shutdown ( socket _ shutdown . both ) ; remote ? . close ( ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ;
encryptor ? . dispose ( ) ;
if ( closed ) return ;


if ( closed ) return ;


switch ( end _ point . address _ family ) { case address _ family . inter _ network : response [ NUM ] = 1 ; break ; case address _ family . inter _ network : response [ NUM ] = NUM ; break ;
if ( closed ) return ;


if ( connected ) return ;
strategy ? . set _ failure ( server ) ;
close ( ) ;
if ( closed ) return ;
server server = timer . server ;
strategy ? . set _ failure ( server ) ;
if ( closed ) return ;
if ( closed ) return ;
strategy ? . update _ last _ read ( server ) ;
- 2 * NUM * ( math . min ( NUM , status . latency . total _ milliseconds ) / ( 1 + ( now - status . last _ time _ detect _ latency ) . total _ seconds / NUM / NUM ) +
return ss _ url . split ( '\r' , '\n' , ' ' ) . select ( u = > parse _ url ( u ) ) . where ( s = > s ! = null ) . to _ list ( ) ;
try { using ( stream _ reader reader = new stream _ reader ( new file _ stream ( filename ,  file _ mode . open , file _ access . read , file _ share . read _ write ) ) ) { reader . base _ stream . seek ( last _ offset , seek _ origin . begin ) ; string line = STR ; bool changed = false ;  while ( ( line = reader . read _ line ( ) ) ! = null ) { changed = true ; log _ message _ text _ box . append _ text ( line + environment . new _ line ) ; } if ( changed ) { log _ message _ text _ box . scroll _ to _ caret ( ) ; } last _ offset = reader . base _ stream . position ;
} catch ( file _ not _ found _ exception ) {
fs = new file _ stream ( log _ file _ path , file _ mode . append ) ; sw = new stream _ writer _ with _ timestamp ( fs ) ;
try { console . write _ line ( o ) ; } catch ( object _ disposed _ exception ) { }







running _ port = get _ free _ port ( ) ;
file _ manager . byte _ array _ to _ file ( utils . get _ temp _ path ( unique _ config _ file ) , encoding . ut . get _ bytes ( privoxy _ config ) ) ; process = new process {  start _ info = { file _ name = STR , arguments = unique _ config _ file , working _ directory = utils . get _ temp _ path ( ) , window _ style = process _ window _ style . hidden , use _ shell _ execute = true , create _ no _ window = true } } ;




this . picture _ box . location = new system . drawing . point ( NUM , NUM ) ;
this . picture _ box . size = new system . drawing . size ( NUM , NUM ) ; this . picture _ box . size _ mode = system . windows . forms . picture _ box _ size _ mode . zoom ;

this . client _ size = new system . drawing . size ( NUM , NUM ) ; this . controls . add ( this . picture _ box ) ;




foreach ( var kv in in _ out _ bound _ records )
var record = kv . value ; long inbound _ delta , outbound _ delta ; record . get _ delta ( out inbound _ delta , out outbound _ delta ) ; var inbound _ speed = get _ speed _ in _ ki _ b _ per _ second ( inbound _ delta , monitor _ interval . total _ seconds ) ; var outbound _ speed = get _ speed _ in _ ki _ b _ per _ second ( outbound _ delta , monitor _ interval . total _ seconds ) ; var in _ r = inbound _ speed _ records . get _ or _ add ( id , ( k ) = > new list < int > ( ) ) ; var out _ r = outbound _ speed _ records . get _ or _ add ( id , ( k ) = > new list < int > ( ) ) ; in _ r . add ( inbound _ speed ) ; out _ r . add ( outbound _ speed ) ;
in _ out _ bound _ records . add _ or _ update ( server . identifier ( ) , ( k ) = > { var r = new in _ out _ bound _ record ( ) ; r . update _ inbound ( n ) ; return r ; } , ( k , v ) = > { v . update _ inbound ( n ) ; return v ; } ) ;
in _ out _ bound _ records . add _ or _ update ( server . identifier ( ) , ( k ) = > { var r = new in _ out _ bound _ record ( ) ; r . update _ outbound ( n ) ; return r ; } , ( k , v ) = > { v . update _ outbound ( n ) ; return v ; } ) ;
if ( password . is _ null _ or _ empty ( ) )
if ( server . is _ null _ or _ empty ( ) )
if ( server . is _ null _ or _ empty ( ) )
if ( remarks . is _ null _ or _ empty ( ) )
if ( controller . get _ configuration _ copy ( ) . pac _ url . is _ null _ or _ empty ( ) )
if ( ! controller . get _ configuration _ copy ( ) . pac _ url . is _ null _ or _ empty ( ) )

md _ sum = mbed _ tls . m ( password ) ;
md _ sum = mbed _ tls . m ( result ) ;
this . share _ over _ lan _ item . index = 2 ;
this . servers _ item . index = NUM ;
double min _ x = int . max _ value , min _ y = int . max _ value , max _ x = 0 , max _ y = 0 ;
file _ system _ watcher pac _ file _ watcher ; file _ system _ watcher user _ rule _ file _ watcher ;
if ( pac _ file _ watcher ! = null ) { pac _ file _ watcher . dispose ( ) ; } pac _ file _ watcher = new file _ system _ watcher ( directory . get _ current _ directory ( ) ) ; pac _ file _ watcher . notify _ filter = notify _ filters . last _ write | notify _ filters . file _ name | notify _ filters . directory _ name ; pac _ file _ watcher . filter = pac _ file ; pac _ file _ watcher . changed + = pac _ file _ watcher _ changed ; pac _ file _ watcher . created + = pac _ file _ watcher _ changed ; pac _ file _ watcher . deleted + = pac _ file _ watcher _ changed ; pac _ file _ watcher . renamed + = pac _ file _ watcher _ changed ; pac _ file _ watcher . enable _ raising _ events = true ; } private void watch _ user _ rule _ file ( ) { if ( user _ rule _ file _ watcher ! = null ) { user _ rule _ file _ watcher . dispose ( ) ; } user _ rule _ file _ watcher = new file _ system _ watcher ( directory . get _ current _ directory ( ) ) ; user _ rule _ file _ watcher . notify _ filter = notify _ filters . last _ write | notify _ filters . file _ name | notify _ filters . directory _ name ; user _ rule _ file _ watcher . filter = user _ rule _ file ; user _ rule _ file _ watcher . changed + = user _ rule _ file _ watcher _ changed ; user _ rule _ file _ watcher . created + = user _ rule _ file _ watcher _ changed ; user _ rule _ file _ watcher . deleted + = user _ rule _ file _ watcher _ changed ; user _ rule _ file _ watcher . renamed + = user _ rule _ file _ watcher _ changed ; user _ rule _ file _ watcher . enable _ raising _ events = true ; } private void pac _ file _ watcher _ changed ( object sender , file _ system _ event _ args e )
int target _ index = - 1 ; for ( int i = 0 ; i < locale _ names . length ; i + + )
if ( locale _ names [ i ] . split ( '-' ) [ 0 ] = = locale _ no _ region ) { target _ index = i ; }
string source = translations [ en _ index ] ; string translation = translations [ target _ index ] ;  if ( string . is _ null _ or _ white _ space ( source ) | | string . is _ null _ or _ white _ space ( translation ) ) continue ;
strings [ source ] = translation ;
string n ; if ( ! file . exists ( n _ file ) ) { n = resources . n _ csv ; file . write _ all _ text ( n _ file , n , encoding . ut ) ; } else { n = file . read _ all _ text ( n _ file , encoding . ut ) ; } logging . info ( STR + culture _ info . current _ culture . name ) ; init ( n , culture _ info . current _ culture . name ) ;

public date _ time timestamp ;

server legacy _ server = parse _ legacy _ url ( server _ url ) ; if ( legacy _ server ! = null )
servers . add ( legacy _ server ) ;
else
uri parsed _ url ; try { parsed _ url = new uri ( server _ url ) ; } catch ( uri _ format _ exception ) { continue ; } server server = new server { remarks = parsed _ url . get _ components ( uri _ components . fragment , uri _ format . unescaped ) , server = parsed _ url . get _ components ( uri _ components . host , uri _ format . unescaped ) , server _ port = parsed _ url . port , } ;  string raw _ user _ info = parsed _ url . get _ components ( uri _ components . user _ info , uri _ format . unescaped ) ; string base = raw _ user _ info . replace ( '-' , '+' ) . replace ( '_' , '/' ) ; string user _ info = STR ; try { user _ info = encoding . ut . get _ string ( convert . from _ base _ string ( base . pad _ right ( base . length + ( NUM - base . length % NUM ) % NUM , '=' ) ) ) ; } catch ( format _ exception ) { continue ; } string [ ] user _ info _ parts = user _ info . split ( new char [ ] { ':' } , 2 ) ; if ( user _ info _ parts . length ! = 2 ) { continue ; } server . method = user _ info _ parts [ 0 ] ; server . password = user _ info _ parts [ 1 ] ; name _ value _ collection query _ parameters = http _ utility . parse _ query _ string ( parsed _ url . query ) ; string [ ] plugin _ parts = http _ utility . url _ decode ( query _ parameters [ STR ] ? ? STR ) . split ( new [ ] { ';' } , 2 ) ; if ( plugin _ parts . length > 0 ) { server . plugin = plugin _ parts [ 0 ] ? ? STR ; } if ( plugin _ parts . length > 1 ) { server . plugin _ opts = plugin _ parts [ 1 ] ? ? STR ; } servers . add ( server ) ;




lock ( sodium _ buf )
if ( is _ cipher ) { bytes _ remaining = encrypt _ bytes _ remaining ; ic = encrypt _ ic ;  iv = encrypt _ iv ; } else { bytes _ remaining = decrypt _ bytes _ remaining ; ic = decrypt _ ic ;  iv = decrypt _ iv ; } int padding = bytes _ remaining ; buffer . block _ copy ( buf , 0 , sodium _ buf , padding , length ) ; switch ( cipher ) { case cipher _ sals : sodium . crypto _ stream _ salsa _ xor _ ic ( sodium _ buf , sodium _ buf , ( ulong ) ( padding + length ) , iv , ic , key ) ; break ; case cipher _ chach : sodium . crypto _ stream _ chacha _ xor _ ic ( sodium _ buf , sodium _ buf , ( ulong ) ( padding + length ) , iv , ic , key ) ; break ; } buffer . block _ copy ( sodium _ buf , padding , outbuf , 0 , length ) ; padding + = length ; ic + = ( ulong ) padding / sodium _ block _ size ; bytes _ remaining = padding % sodium _ block _ size ; if ( is _ cipher ) { encrypt _ bytes _ remaining = bytes _ remaining ; encrypt _ ic = ic ; } else { decrypt _ bytes _ remaining = bytes _ remaining ; decrypt _ ic = ic ; }
int opcode = ip _ address . network _ to _ host _ order ( bit _ converter . to _ int ( buf , 0 ) ) ; if ( opcode = = 1 ) { await stream . read _ async ( buf , 0 , NUM ) ; int strlen = ip _ address . network _ to _ host _ order ( bit _ converter . to _ int ( buf , 0 ) ) ; await stream . read _ async ( buf , 0 , strlen ) ; string url = encoding . ut . get _ string ( buf , 0 , strlen ) ; add _ url _ requested ? . invoke ( this , new request _ add _ url _ event _ args ( url ) ) ; }
} public void start ( ) { reload ( ) ; } protected void report _ error ( exception e ) { if ( errored ! = null ) {   if ( e is socket _ exception ) { socket _ exception se = ( socket _ exception ) e ; if ( se . socket _ error _ code = = socket _ error . access _ denied ) { e = new exception ( STR , e ) ; } } errored ( this , new error _ event _ args ( e ) ) ; }
protected void reload ( ) {
if ( local ! = null ) { local . stop ( ) ; }
try { polipo _ runner . start ( config ) ; local = new local ( config ) ; local . start ( ) ; pac _ server . start ( config ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; report _ error ( e ) ; }
i _ strategy strategy = controller . get _ current _ strategy ( ) ; if ( strategy ! = null ) { strategy . update _ latency ( server , latency ) ; }
i _ strategy strategy = controller . get _ current _ strategy ( ) ; if ( strategy ! = null ) { strategy . set _ failure ( server ) ; }



this . seperator _ item , this . config _ item } ) ;

create _ menu _ group ( 1 , STR , new system . windows . forms . menu _ item [ ] { this . pac _ mode _ item , this . global _ mode _ item } ) ,
create _ seperator _ item ( NUM ) ,
create _ menu _ item ( NUM , STR , new system . event _ handler ( this . edit _ pac _ file _ item _ click ) ) , create _ seperator _ item ( NUM ) , create _ menu _ item ( NUM , STR , new system . event _ handler ( this . qr _ code _ item _ click ) ) , create _ menu _ item ( NUM , STR , new system . event _ handler ( this . show _ log _ item _ click ) ) , create _ menu _ item ( NUM , STR , new system . event _ handler ( this . config _ click ) ) , create _ seperator _ item ( NUM ) , create _ menu _ item ( NUM , STR , new system . event _ handler ( this . quit _ click ) ) } ) ;
json _ array result = ( json _ array ) simple _ json . simple _ json . deserialize _ object ( e . result ) ;
foreach ( json _ object release in result )
if ( ( bool ) release [ STR ] )
continue ; } foreach ( json _ object asset in ( json _ array ) release [ STR ] ) { string url = ( string ) asset [ STR ] ; if ( is _ new _ version ( url ) )
versions . add ( url ) ;

private const string user _ wininet _ config _ file = STR ; private static string query _ str ;
private static sysproxy _ config user _ settings = null ;
read ( ) ; if ( ! user _ settings . user _ settings _ recorded )
exec _ sysproxy ( STR ) ; parse _ query _ str ( query _ str ) ;
var flags = user _ settings . flags ; var proxy _ server = user _ settings . proxy _ server ? ? STR ; var bypass _ list = user _ settings . bypass _ list ? ? STR ; var pac _ url = user _ settings . pac _ url ? ? STR ;
user _ settings . user _ settings _ recorded = false ;
save ( ) ; exec _ sysproxy ( arguments ) ;
private static void exec _ sysproxy ( string arguments )
if ( arguments = = STR ) { if ( stdout . is _ null _ or _ white _ space ( ) | | stdout . is _ null _ or _ empty ( ) ) {  throw new proxy _ exception ( STR ) ; } query _ str = stdout ;
} } private static void save ( ) { try { using ( stream _ writer sw = new stream _ writer ( file . open ( user _ wininet _ config _ file , file _ mode . create ) ) ) { string json _ string = json _ convert . serialize _ object ( user _ settings , formatting . indented ) ; sw . write ( json _ string ) ; sw . flush ( ) ; } } catch ( io _ exception e ) { logging . log _ useful _ exception ( e ) ; } } private static void read ( ) { try { string config _ content = file . read _ all _ text ( user _ wininet _ config _ file ) ; user _ settings = json _ convert . deserialize _ object < sysproxy _ config > ( config _ content ) ; } catch ( file _ not _ found _ exception ) { user _ settings = new sysproxy _ config ( ) ;
string [ ] user _ settings _ arr = str . split ( new string [ ] { STR } , string _ split _ options . remove _ empty _ entries ) ; user _ settings . flags = user _ settings _ arr [ 0 ] ;  if ( user _ settings _ arr [ 1 ] = = STR ) user _ settings . proxy _ server = null ; else user _ settings . proxy _ server = user _ settings _ arr [ 1 ] ; if ( user _ settings _ arr [ 2 ] = = STR ) user _ settings . bypass _ list = null ; else user _ settings . bypass _ list = user _ settings _ arr [ 2 ] ; if ( user _ settings _ arr [ NUM ] = = STR ) user _ settings . pac _ url = null ; else user _ settings . pac _ url = user _ settings _ arr [ NUM ] ; user _ settings . user _ settings _ recorded = true ;
using shadowsocks _ controller ; using shadowsocks _ properties ; using system ;


private void ota _ update _ key _ buffer ( ) { if ( ota _ chunk _ key _ buffer = = null ) { ota _ chunk _ key _ buffer = new byte [ max _ iv _ length + NUM ] ; buffer . block _ copy ( encrypt _ iv , 0 , ota _ chunk _ key _ buffer , 0 , iv _ len ) ; } byte [ ] counter _ bytes = bit _ converter . get _ bytes ( ( uint ) ip _ address . host _ to _ network _ order ( ( int ) ota _ chunk _ counter ) ) ; buffer . block _ copy ( counter _ bytes , 0 , ota _ chunk _ key _ buffer , iv _ len , NUM ) ; ota _ chunk _ counter + + ; } private byte [ ] ota _ gen _ chunk _ hash ( byte [ ] buf , int offset , int len )
ota _ update _ key _ buffer ( ) ; sodium . ss _ sha _ hmac _ ex ( ota _ chunk _ key _ buffer , ( uint ) ota _ chunk _ key _ buffer . length ,
int head _ len = ota _ get _ head _ len ( buf , length ) ;
byte [ ] hash = ota _ gen _ hash ( buf , head _ len ) ;
byte [ ] hash = ota _ gen _ hash ( buf , length ) ;
ota _ auth _ buffer _ tcp ( buf , ref length ) ;
ota _ auth _ buffer _ udp ( buf , ref length ) ; } } }  protected static void rand _ bytes ( byte [ ] buf , int length ) { byte [ ] temp = new byte [ length ] ; rng _ crypto _ service _ provider rng _ service _ provider = new rng _ crypto _ service _ provider ( ) ; rng _ service _ provider . get _ bytes ( temp ) ; temp . copy _ to ( buf , 0 ) ;
outlength = length + iv _ len ; ota _ auth _ buffer ( buf , ref length ) ;
namespace shadowsocks _ csharp _ properties { using system ;
internal static global :: system . resources . resource _ manager resource _ manager { get { if ( object . reference _ equals ( resource _ man , null ) ) {
private bool save _ valid _ configuration ( ) { if ( ! validate _ and _ save _ selected _ server _ details ( ) ) { return false ;
return false ;
return true ; } private void config _ form _ key _ down ( object sender , key _ event _ args e ) {  if ( e . key _ code = = keys . enter ) { save _ valid _ configuration ( ) ; } } private void servers _ list _ box _ selected _ index _ changed ( object sender , event _ args e ) { if ( ! servers _ list _ box . can _ select ) { return ; } if ( last _ selected _ index = = servers _ list _ box . selected _ index ) {  return ; } if ( ! validate _ and _ save _ selected _ server _ details ( ) ) {  servers _ list _ box . selected _ index = last _ selected _ index ; return ; } if ( last _ selected _ index > = 0 ) { servers _ list _ box . items [ last _ selected _ index ] = modified _ configuration . configs [ last _ selected _ index ] . friendly _ name ( ) ; } update _ buttons ( ) ; load _ selected _ server _ details ( ) ; last _ selected _ index = servers _ list _ box . selected _ index ; } private void add _ button _ click ( object sender , event _ args e ) { if ( ! validate _ and _ save _ selected _ server _ details ( ) ) { return ; } server server = configuration . get _ default _ server ( ) ; modified _ configuration . configs . add ( server ) ; load _ server _ name _ list _ to _ ui ( modified _ configuration ) ; servers _ list _ box . selected _ index = modified _ configuration . configs . count - 1 ; last _ selected _ index = servers _ list _ box . selected _ index ; } private void duplicate _ button _ click ( object sender , event _ args e ) { if ( ! validate _ and _ save _ selected _ server _ details ( ) ) { return ; } server curr _ server = modified _ configuration . configs [ last _ selected _ index ] ; var curr _ index = modified _ configuration . configs . index _ of ( curr _ server ) ; modified _ configuration . configs . insert ( curr _ index + 1 , curr _ server ) ; load _ server _ name _ list _ to _ ui ( modified _ configuration ) ; servers _ list _ box . selected _ index = curr _ index + 1 ; last _ selected _ index = servers _ list _ box . selected _ index ; } private void delete _ button _ click ( object sender , event _ args e ) { last _ selected _ index = servers _ list _ box . selected _ index ; if ( last _ selected _ index > = 0 & & last _ selected _ index < modified _ configuration . configs . count ) { modified _ configuration . configs . remove _ at ( last _ selected _ index ) ; } if ( last _ selected _ index > = modified _ configuration . configs . count ) {  last _ selected _ index = modified _ configuration . configs . count - 1 ; } servers _ list _ box . selected _ index = last _ selected _ index ; load _ server _ name _ list _ to _ ui ( modified _ configuration ) ; servers _ list _ box . selected _ index = last _ selected _ index ; load _ selected _ server _ details ( ) ; } private void ok _ button _ click ( object sender , event _ args e ) { if ( save _ valid _ configuration ( ) ) { this . close ( ) ; }

config . get _ current _ server ( ) . bandwidth _ in = inbound _ counter ;
config . get _ current _ server ( ) . bandwidth _ out = outbound _ counter ;
inbound _ counter = config . get _ current _ server ( ) . bandwidth _ in ; outbound _ counter = config . get _ current _ server ( ) . bandwidth _ out ;
this . binding _ configuration = new system . windows . forms . binding _ source ( this . components ) ;

this . binding _ configuration . data _ source = typeof ( shadowsocks . model . statistics _ strategy _ configuration ) ;
configuration = controller . statistics _ configuration

public static string pac _ file = STR ;

private static string pac _ file = pac _ server . pac _ file ; public event event _ handler update _ completed ;

string [ ] lines = parse _ result ( e . result ) ; json _ array rules = new json _ array ( ) ; rules . add _ range ( lines ) ; string abp _ content = utils . un _ gzip ( resources . abp _ js ) ; abp _ content = abp _ content . replace ( STR , rules . to _ string ( ) ) ; file . write _ all _ text ( pac _ file , abp _ content , encoding . ut ) ; if ( update _ completed ! = null )
update _ completed ( this , new event _ args ( ) ) ;
if ( error ! = null ) { error ( this , new error _ event _ args ( ex ) ) ; }
public void update _ pac _ from _ gfw _ list ( )
web _ client http = new web _ client ( ) ; http . download _ string _ completed + = http _ download _ string _ completed ; http . download _ string _ async ( new uri ( gfwlist _ url ) ) ; } public string [ ] parse _ result ( string response ) { byte [ ] bytes = convert . from _ base _ string ( response ) ; string content = encoding . ascii . get _ string ( bytes ) ; string [ ] lines = content . split ( new char [ ] { '\r' , '\n' } , string _ split _ options . remove _ empty _ entries ) ; list < string > valid _ lines = new list < string > ( lines . length ) ; foreach ( string line in lines )
if ( line . starts _ with ( STR ) | | line . starts _ with ( STR ) ) continue ; valid _ lines . add ( line ) ;
return valid _ lines . to _ array ( ) ;
private void pac _ server _ pac _ update _ error ( object sender , error _ event _ args e )
public class utils
temppath = utils . get _ temp _ path ( ) ;
date _ time now = date _ time . now ; if ( now - last _ sweep _ time > time _ span . from _ seconds ( 1 ) ) { last _ sweep _ time = now ; foreach ( handler handler in this . handlers ) { if ( now - handler . last _ activity > time _ span . from _ seconds ( NUM ) ) { handlers _ to _ close . add ( handler ) ; } } } } foreach ( handler handler in handlers _ to _ close ) { logging . debug ( STR ) ; handler . close ( ) ; } return true ;


if ( mode . equals ( mode . byte ) ) append _ bit _ bytes ( content , bits , encoding ) ;
throw new writer _ exception ( STR + mode ) ;



using system _ threading _ tasks ; using system _ windows _ forms ;
private static async task < data _ list > get _ geolocation _ and _ isp ( )
var ret = new list < data _ list > ( ) ; foreach ( var timestamp in enumerable . range ( 0 , repeat ) . select ( = > date _ time . now . to _ string ( STR ) ) )
var reply = await ping . send _ task _ async ( server . server , timeout ) ; ret . add ( new list < key _ value _ pair < string , string > >
new key _ value _ pair < string , string > ( STR , timestamp ) , new key _ value _ pair < string , string > ( STR , server . friendly _ name ( ) ) , new key _ value _ pair < string , string > ( STR , reply ? . status . to _ string ( ) ) , new key _ value _ pair < string , string > ( STR , reply ? . roundtrip _ time . to _ string ( ) )   } ) ; } return ret ; } private async void evaluate ( object obj ) { var geolocation _ and _ isp = get _ geolocation _ and _ isp ( ) ; foreach ( var data _ lists in await task _ ex . when _ all ( servers . select ( icmp _ test ) ) ) { await geolocation _ and _ isp ; foreach ( var data _ list in data _ lists ) { append ( data _ list , geolocation _ and _ isp . result ) ;
private static void append ( data _ list data _ list , i _ enumerable < data _ unit > extra )
public static asset parse _ asset ( j _ object assert _ j _ object ) { var name = ( string ) assert _ j _ object [ STR ] ;
browser _ download _ url = ( string ) assert _ j _ object [ STR ] ,

queue < traffic _ info > traffic _ info _ queue = new queue < traffic _ info > ( ) ; const int queue _ max _ length = NUM ; long last _ inbound , last _ outbound ; long max _ speed = 0 , last _ max _ speed = 0 ; const long min _ scale = NUM ; bandwidth _ scale _ info bandwidth _ scale ; list < float > inbound _ points = new list < float > ( ) ; list < float > outbound _ points = new list < float > ( ) ; text _ annotation inbound _ annotation = new text _ annotation ( ) ; text _ annotation outbound _ annotation = new text _ annotation ( ) ;
private void update _ traffic _ chart ( ) {
if ( traffic _ info _ queue . count = = 0 )
inbound _ points . clear ( ) ; outbound _ points . clear ( ) ; max _ speed = 0 ; foreach ( var traffic _ info in traffic _ info _ queue ) { inbound _ points . add ( traffic _ info . inbound ) ; outbound _ points . add ( traffic _ info . outbound ) ; max _ speed = math . max ( max _ speed , math . max ( traffic _ info . inbound , traffic _ info . outbound ) ) ; } last _ inbound = traffic _ info _ queue . last ( ) . inbound ; last _ outbound = traffic _ info _ queue . last ( ) . outbound ;
public queue < traffic _ per _ second > traffic _ per _ second _ queue ;

traffic _ per _ second _ queue = new queue < traffic _ per _ second > ( ) ;
traffic _ per _ second _ queue . enqueue ( new traffic _ per _ second ( ) ) ;
previous = traffic _ per _ second _ queue . last ( ) ; current = new traffic _ per _ second ( ) ; current . inbound _ counter = inbound _ counter ; current . outbound _ counter = outbound _ counter ; current . inbound _ increasement = current . inbound _ counter - previous . inbound _ counter ; current . outbound _ increasement = current . outbound _ counter - previous . outbound _ counter ; traffic _ per _ second _ queue . enqueue ( current ) ; if ( traffic _ per _ second _ queue . count > queue _ max _ size ) traffic _ per _ second _ queue . dequeue ( ) ;
public tcp _ relay tcprelay ;
private int total _ read = 0 ; private int total _ write = 0 ;  private byte [ ] remote _ recv _ buffer = new byte [ buffer _ size ] ;  private byte [ ] remote _ send _ buffer = new byte [ buffer _ size ] ;  private byte [ ] connetion _ recv _ buffer = new byte [ buffer _ size ] ;  private byte [ ] connetion _ send _ buffer = new byte [ buffer _ size ] ;  private bool connection _ shutdown = false ; private bool remote _ shutdown = false ; private bool closed = false ; private object encryption _ lock = new object ( ) ; private object decryption _ lock = new object ( ) ;
toolbar _ trigger = ! toolbar _ trigger ; toolbar _ flow _ layout _ panel . visible = toolbar _ trigger ; show _ toolbar _ menu _ item . checked = toolbar _ trigger ;
public const int recv _ size = NUM ; public const int buffer _ size = recv _ size + NUM ;
public byte [ ] remote _ recv _ buffer = new byte [ recv _ size ] ;  public byte [ ] remote _ send _ buffer = new byte [ buffer _ size ] ;
public byte [ ] connetion _ recv _ buffer = new byte [ recv _ size ] ;  public byte [ ] connetion _ send _ buffer = new byte [ buffer _ size ] ;
remote . begin _ receive ( remote _ recv _ buffer , 0 , recv _ size , 0 ,
connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , 0 ,
static byte [ ] tempbuf = new byte [ NUM ] ; public override void encrypt ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength )
open _ ssl . rand _ bytes ( outbuf , iv _ len ) ; init _ cipher ( ref encrypt _ ctx , outbuf , true ) ; outlength = length + iv _ len ; open _ ssl . evp _ cipher _ update ( encrypt _ ctx , tempbuf , out outlength , buf , length ) ; outlength = length + iv _ len ; buffer . block _ copy ( tempbuf , 0 , outbuf , iv _ len , outlength ) ;
outlength = length ; open _ ssl . evp _ cipher _ update ( encrypt _ ctx , outbuf , out outlength , buf , length ) ;
public override void decrypt ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength )
init _ cipher ( ref decrypt _ ctx , buf , false ) ; outlength = length - iv _ len ; buffer . block _ copy ( buf , iv _ len , tempbuf , 0 , length - iv _ len ) ; open _ ssl . evp _ cipher _ update ( decrypt _ ctx , outbuf , out outlength , tempbuf , length - iv _ len ) ;
outlength = length ; open _ ssl . evp _ cipher _ update ( decrypt _ ctx , outbuf , out outlength , buf , length ) ;
public interface i _ encryptor : i _ disposable
void encrypt ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength ) ; void decrypt ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength ) ;
public override void encrypt ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength )
outbuf [ i ] = encrypt _ table [ buf [ i ] ] ;
outlength = length ;
public override void decrypt ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength )
outbuf [ i ] = decrypt _ table [ buf [ i ] ] ;
outlength = length ;
static class auto _ startup
private static readonly string executable _ path = assembly . get _ entry _ assembly ( ) . location ; private static string key = STR + application . startup _ path . get _ hash _ code ( ) ;

run _ key . set _ value ( key , executable _ path ) ;
run _ key . set _ value ( key , executable _ path ) ;
public date _ time last _ activity ; private shadowsocks _ controller controller ; private configuration config ; private tcp _ relay tcprelay ; private socket connection ; private i _ encryptor encryptor ; private server server ;
private const int max _ retry = NUM ; private int retry _ count = 0 ; private bool proxy _ connected ; private bool dest _ connected ; private byte command ; private byte [ ] first _ packet ; private int first _ packet _ length ; private int total _ read = 0 ; private int total _ write = 0 ; private byte [ ] remote _ recv _ buffer = new byte [ buffer _ size ] ; private byte [ ] remote _ send _ buffer = new byte [ buffer _ size ] ; private byte [ ] connetion _ recv _ buffer = new byte [ buffer _ size ] ; private byte [ ] connetion _ send _ buffer = new byte [ buffer _ size ] ; private bool connection _ shutdown = false ; private bool remote _ shutdown = false ; private bool closed = false ; private object encryption _ lock = new object ( ) ; private object decryption _ lock = new object ( ) ;
public tcp _ handler ( shadowsocks _ controller controller , configuration config , tcp _ relay tcprelay , socket socket ) { this . controller = controller ; this . config = config ;
this . connection = socket ;
lock ( this ) {
lock ( tcprelay . handlers ) { tcprelay . handlers . remove ( this ) ; } try { connection ? . shutdown ( socket _ shutdown . both ) ; connection ? . close ( ) ;
throw new exception ( STR ) ;
throw new exception ( STR ) ;
throw new exception ( STR ) ;
? resources . zh _ tw : resources . zh _ cn ) ;
init ( resources . ja ) ;
private shadowsocks _ controller controller ;
public udp _ relay ( shadowsocks _ controller controller )
this . controller = controller ;
+ STR + server _ info ;
enable _ item . checked = controller . get _ configuration _ copy ( ) . enabled ;
share _ over _ lan _ item . checked = controller . get _ configuration _ copy ( ) . share _ over _ lan ;
global _ mode _ item . checked = controller . get _ configuration _ copy ( ) . global ;
int i = 0 ; foreach ( var strategy in controller . get _ strategies ( ) ) { menu _ item item = new menu _ item ( n . get _ string ( strategy . name ) ) ; item . tag = strategy . id ; item . click + = a _ strategy _ item _ click ; items . add ( i , item ) ; i + + ; } configuration configuration = controller . get _ configuration _ copy ( ) ; foreach ( var server in configuration . configs ) {
i + + ; } foreach ( menu _ item item in items ) { if ( item . tag ! = null & & ( item . tag . to _ string ( ) = = configuration . index . to _ string ( ) | | item . tag . to _ string ( ) = = configuration . strategy ) ) { item . checked = true ; }
private shadowsocks _ controller controller ; public tcp _ relay ( shadowsocks _ controller controller ) { this . controller = controller ;
public configuration get _ configuration _ copy ( )
if ( config . index < - 1 )
config . index = - 1 ;
private void response _ callback ( i _ async _ result ar )
if ( controller ! = null ) { controller . stop ( ) ; logging . info ( STR ) ; }
if ( controller ! = null ) { controller . start ( ) ; logging . info ( STR ) ; }
string tag = string . empty ; string auth = server . auth ? STR : string . empty ; string parts = $ STR ;
if ( ! server . remarks . is _ null _ or _ empty ( ) ) { tag = $ STR ; } return $ STR ;
var tag = match . groups [ NUM ] . value ;
remarks = http _ utility . url _ decode ( tag , encoding . ut ) ;


if ( bytes _ read > 1 )
if ( encrypt _ ctx . to _ int ( ) ! = 0 )
if ( decrypt _ ctx . to _ int ( ) ! = 0 )
def _ connection [ options _ offset ] = ( byte ) ( def _ connection [ options _ offset ] | NUM ) ; saved _ legacy _ setting [ options _ offset ] = ( byte ) ( saved _ legacy _ setting [ options _ offset ] | NUM ) ;
def _ connection [ options _ offset ] = ( byte ) ( def _ connection [ options _ offset ] & ~ NUM ) ; saved _ legacy _ setting [ options _ offset ] = ( byte ) ( saved _ legacy _ setting [ options _ offset ] & ~ NUM ) ;
bit _ converter . get _ bytes ( unchecked ( bit _ converter . to _ u _ int ( def _ connection , version _ offset ) + 1 ) ) . copy _ to ( def _ connection , version _ offset ) ; bit _ converter . get _ bytes ( unchecked ( bit _ converter . to _ u _ int ( saved _ legacy _ setting , version _ offset ) + 1 ) ) . copy _ to ( saved _ legacy _ setting , version _ offset ) ;
using statistics = dictionary < string , list < statistics _ record > > ;


private time _ span recording _ interval = > time _ span . from _ minutes ( config . data _ collection _ minutes ) ;
if ( recorder ? . change ( delay _ before _ start , recording _ interval ) = = null ) { recorder = new timer ( run , null , delay _ before _ start , recording _ interval ) ; } load _ raw _ statistics ( ) ; if ( speed _ monior ? . change ( delay _ before _ start , monitor _ interval ) = = null ) { speed _ monior = new timer ( update _ speed , null , delay _ before _ start , monitor _ interval ) ; } if ( writer ? . change ( delay _ before _ start , recording _ interval ) = = null ) { writer = new timer ( save , null , delay _ before _ start , recording _ interval ) ;
recorder ? . dispose ( ) ;
var inbound _ speed = get _ speed _ in _ ki _ b _ per _ second ( bytes , monitor _ interval . total _ seconds ) ; inbound _ speed _ records . add ( inbound _ speed ) ;
outbound _ speed _ records . add ( outbound _ speed ) ; logging . debug ( $ STR ) ; } private async task < icmp _ result > icmp _ test ( server server )
var result = new icmp _ result ( server ) ; try { var ip = dns . get _ host _ addresses ( server . server ) . first ( ip = > ip . address _ family = = address _ family . inter _ network | | ip . address _ family = = address _ family . inter _ network ) ;
foreach ( var in enumerable . range ( 0 , repeat ) ) {
if ( ! reply . status . equals ( ip _ status . success ) ) { result . roundtrip _ time . add ( ( int? ) reply . roundtrip _ time ) ; } else { result . roundtrip _ time . add ( null ) ; }
return result ; } private void reset ( ) {  inbound _ speed _ records = new list < int > ( ) ; outbound _ speed _ records = new list < int > ( ) ; latency _ records = new list < int > ( ) ; } private void run ( object ) { append _ record ( ) ; reset ( ) ;
} private async void append _ record ( ) {  var icmp _ results = task _ ex . when _ all ( servers . select ( icmp _ test ) ) ; var current _ server _ record = new statistics _ record ( current _ server . identifier ( ) , inbound _ speed _ records , outbound _ speed _ records , latency _ records ) ; foreach ( var result in ( await icmp _ results ) . where ( result = > result ! = null ) ) { list < statistics _ record > records ; if ( ! raw _ statistics . try _ get _ value ( result . server . identifier ( ) , out records ) ) { records = new list < statistics _ record > ( ) ; } if ( result . server . equals ( current _ server ) ) { current _ server _ record . set _ response ( result . roundtrip _ time ) ; records . add ( current _ server _ record ) ; } else { records . add ( new statistics _ record ( result . server . identifier ( ) , result . roundtrip _ time ) ) ; } raw _ statistics [ result . server . identifier ( ) ] = records ; } } private void save ( object ) { try { file . write _ all _ text ( availability _ statistics _ file , json _ convert . serialize _ object ( raw _ statistics , formatting . none ) ) ; } catch ( io _ exception e ) { logging . log _ useful _ exception ( e ) ; writer . change ( retry _ interval , writing _ interval ) ; } }
current _ server = controller . get _ current _ server ( ) ; reset ( ) ;
foreach ( var server _ and _ records in raw _ statistics ) { var server = server _ and _ records . key ; var filtered _ records = server _ and _ records . value . find _ all ( is _ valid _ record ) ; filtered _ statistics [ server ] = filtered _ records ;
if ( ! file . exists ( path ) ) { console . write _ line ( $ STR ) ; recorder . change ( retry _ interval , recording _ interval ) ;
raw _ statistics = json _ convert . deserialize _ object < statistics > ( file . read _ all _ text ( path ) ) ? ? raw _ statistics ;
return ! date _ time . try _ parse _ exact ( str , date _ time _ pattern , null , date _ time _ styles . none , out date _ time ) ? unknown _ date _ time : date _ time ;
latency _ records . add ( latency ) ;
list < statistics _ record > statistics ;
i _ enumerable < i _ grouping < int , statistics _ record > > data _ groups ;
private statistics filtered _ statistics ; private availability _ statistics service = > controller . availability _ statistics ;
filtered _ statistics = service . filtered _ statistics ? ? service . raw _ statistics ? ? filtered _ statistics ;
list < statistics _ record > records ; if ( filtered _ statistics = = null | | ! filtered _ statistics . try _ get _ value ( server _ name , out records ) ) return 0 ;
score + = average _ record . package _ loss * factor ? ? 0 ;
score + = average _ record . average _ response * factor ? ? 0 ;
score + = average _ record . min _ response * factor ? ? 0 ;
score + = average _ record . max _ response * factor ? ? 0 ; logging . debug ( $ STR ) ;

this . table _ layout _ panel . location = new system . drawing . point ( NUM , NUM ) ; this . table _ layout _ panel . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;
this . table _ layout _ panel . padding = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;
this . remarks _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . remarks _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;
this . label . location = new system . drawing . point ( NUM , NUM ) ; this . label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ;
this . label . location = new system . drawing . point ( NUM , NUM ) ; this . label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ;
this . label . location = new system . drawing . point ( NUM , NUM ) ; this . label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ;
this . proxy _ port _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . proxy _ port _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;
this . label . location = new system . drawing . point ( NUM , NUM ) ; this . label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ;
this . label . location = new system . drawing . point ( NUM , NUM ) ; this . label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ;
this . ip _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . ip _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;
this . server _ port _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . server _ port _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;
this . password _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . password _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;
this . label . location = new system . drawing . point ( NUM , NUM ) ; this . label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ;
this . encryption _ select . location = new system . drawing . point ( NUM , NUM ) ; this . encryption _ select . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;


this . panel . location = new system . drawing . point ( NUM , NUM ) ; this . panel . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;
this . ok _ button . location = new system . drawing . point ( NUM , NUM ) ; this . ok _ button . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;
this . my _ cancel _ button . location = new system . drawing . point ( NUM , NUM ) ; this . my _ cancel _ button . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;
this . delete _ button . location = new system . drawing . point ( NUM , NUM ) ; this . delete _ button . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;
this . add _ button . location = new system . drawing . point ( NUM , NUM ) ; this . add _ button . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;
this . server _ group _ box . location = new system . drawing . point ( NUM , NUM ) ; this . server _ group _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;
this . server _ group _ box . padding = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . server _ group _ box . size = new system . drawing . size ( NUM , NUM ) ;
this . servers _ list _ box . item _ height = NUM ; this . servers _ list _ box . location = new system . drawing . point ( NUM , NUM ) ; this . servers _ list _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;
if ( ! file . exists ( pac _ file ) )
geosite _ updater . merge _ and _ write _ pac _ file ( ) ;
return file . read _ all _ text ( pac _ file , encoding . ut ) ;

last _ selected _ index = ( servers _ list _ box . selected _ index = last _ index ) ;
last _ selected _ index = ( servers _ list _ box . selected _ index = modified _ configuration . configs . count - 1 ) ;
configuration . add _ default _ server _ or _ server ( modified _ configuration , curr _ server , last _ selected _ index + 1 ) ;
last _ selected _ index = ( servers _ list _ box . selected _ index = ( last _ selected _ index + 1 ) ) ;
var server = modified _ configuration . configs [ last _ selected _ index ] ; var new _ index = last _ selected _ index + step ; modified _ configuration . configs . remove _ at ( last _ selected _ index ) ; modified _ configuration . configs . insert ( new _ index , server ) ;
load _ server _ name _ list _ to _ ui ( modified _ configuration ) ; last _ selected _ index = new _ index ; servers _ list _ box . selected _ index = new _ index ;
lock ( ctx ) { byte [ ] realkey ; if ( method = = STR ) { byte [ ] temp = new byte [ key _ len + iv _ len ] ; realkey = new byte [ key _ len ] ; array . copy ( key , 0 , temp , 0 , key _ len ) ; array . copy ( iv , 0 , temp , key _ len , iv _ len ) ; realkey = m . create ( ) . compute _ hash ( temp ) ;
realkey = key ; } if ( cipher = = cipher _ aes ) { polar _ ssl . aes _ init ( ctx ) ;   polar _ ssl . aes _ setkey _ enc ( ctx , realkey , key _ len * NUM ) ; if ( is _ cipher ) { encrypt _ iv = new byte [ iv _ len ] ; array . copy ( iv , encrypt _ iv , iv _ len ) ; } else { decrypt _ iv = new byte [ iv _ len ] ; array . copy ( iv , decrypt _ iv , iv _ len ) ; } } else if ( cipher = = cipher _ bf ) { polar _ ssl . blowfish _ init ( ctx ) ;  polar _ ssl . blowfish _ setkey ( ctx , realkey , key _ len * NUM ) ; if ( is _ cipher ) { encrypt _ iv = new byte [ iv _ len ] ; array . copy ( iv , encrypt _ iv , iv _ len ) ; } else { decrypt _ iv = new byte [ iv _ len ] ; array . copy ( iv , decrypt _ iv , iv _ len ) ; } } else if ( cipher = = cipher _ r ) { polar _ ssl . arc _ init ( ctx ) ; polar _ ssl . arc _ setup ( ctx , realkey , key _ len ) ; }
polar _ ssl . aes _ crypt _ cfb ( encrypt _ ctx , polar _ ssl . aes _ encrypt , length , ref encrypt _ iv _ offset , encrypt _ iv , buf , outbuf ) ;
polar _ ssl . blowfish _ crypt _ cfb ( encrypt _ ctx , polar _ ssl . blowfish _ encrypt , length , ref encrypt _ iv _ offset , encrypt _ iv , buf , outbuf ) ;
polar _ ssl . arc _ crypt ( encrypt _ ctx , length , buf , outbuf ) ; break ; }
polar _ ssl . aes _ crypt _ cfb ( decrypt _ ctx , polar _ ssl . aes _ decrypt , length , ref decrypt _ iv _ offset , decrypt _ iv , buf , outbuf ) ;
polar _ ssl . blowfish _ crypt _ cfb ( decrypt _ ctx , polar _ ssl . blowfish _ decrypt , length , ref decrypt _ iv _ offset , decrypt _ iv , buf , outbuf ) ;
polar _ ssl . arc _ crypt ( decrypt _ ctx , length , buf , outbuf ) ; break ; }
lock ( this ) { if ( disposed ) { return ; } disposed = true ; } if ( disposing ) {
lock ( encrypt _ ctx ) { switch ( cipher ) { case cipher _ aes : polar _ ssl . aes _ free ( encrypt _ ctx ) ; break ; case cipher _ bf : polar _ ssl . blowfish _ free ( encrypt _ ctx ) ; break ; case cipher _ r : polar _ ssl . arc _ free ( encrypt _ ctx ) ; break ; } encrypt _ ctx = null ;
lock ( decrypt _ ctx ) { switch ( cipher ) { case cipher _ aes : polar _ ssl . aes _ free ( decrypt _ ctx ) ; break ; case cipher _ bf : polar _ ssl . blowfish _ free ( decrypt _ ctx ) ; break ; case cipher _ r : polar _ ssl . arc _ free ( decrypt _ ctx ) ; break ; } decrypt _ ctx = null ; } }
string pac _ content = $ STR + pac _ daemon . get _ pac _ content ( ) ; string response _ head = $ @ STR server : shadowsocks _ windows / { update _ checker . version }
content - length : { encoding . ut . get _ bytes ( pac _ content ) . length }
try
using ( var fs = new file _ stream ( path , file _ mode . open , file _ access . read , file _ share . read _ write ) ) using ( var sr = new stream _ reader ( fs , encoding ) ) { return sr . read _ to _ end ( ) ; } } catch ( exception ex ) { logging . error ( ex ) ; throw ex ;
const int sodium _ block _ size = NUM ; protected int encrypt _ bytes _ remaining ; protected int decrypt _ bytes _ remaining ;
int bytes _ remaining ;
assembly _ assembly _ title _ shadowsocks
assembly _ assembly _ product _ shadowsocks
using shadowsocks _ csharp _ properties ; using system ;
{ string temp _ path = path . get _ temp _ path ( ) ; string dll _ path = temp _ path + STR ; polipo _ runner . uncompress _ file ( dll _ path , resources . polarssl _ dll ) ; load _ library ( dll _ path ) ;
tld _ index tld _ index = get _ tld _ index ( ) ;
if ( ! tld _ index . contains ( last _ root _ domain ) )
private tld _ index get _ tld _ index ( )
tld _ index index = new tld _ index ( ) ;
index . add ( tld ) ; } return index ; } private string [ ] get _ build _ in ( ) { string [ ] buildin = null ; byte [ ] builtin _ gz = resources . builtin _ txt ; byte [ ] buffer = new byte [ NUM ] ; int n ; using ( memory _ stream sb = new memory _ stream ( ) ) { using ( g _ zip _ stream input = new g _ zip _ stream ( new memory _ stream ( builtin _ gz ) , compression _ mode . decompress , false ) ) { while ( ( n = input . read ( buffer , 0 , buffer . length ) ) > 0 ) { sb . write ( buffer , 0 , n ) ; } } buildin = system . text . encoding . ut . get _ string ( sb . to _ array ( ) ) . split ( new char [ ] { '\r' , '\n' } , string _ split _ options . remove _ empty _ entries ) ; } return buildin ; } class tld _ index { list < string > patterns = new list < string > ( ) ; i _ dictionary < string , string > dic = new dictionary < string , string > ( ) ; public void add ( string tld ) { if ( string . is _ null _ or _ empty ( tld ) ) return ; if ( tld . index _ of _ any ( new char [ ] { '*' , '?' } ) > = 0 ) { patterns . add ( STR + regex . escape ( tld ) . replace ( STR , STR ) . replace ( STR , STR ) + STR ) ; } else if ( ! dic . contains _ key ( tld ) ) {
} } public bool contains ( string tld ) { if ( dic . contains _ key ( tld ) ) return true ; foreach ( string pattern in patterns ) { if ( regex . is _ match ( tld , pattern ) ) return true ; } return false ; }
logging . info ( $ STR ) ;
logging . debug ( $ STR ) ;
logging . debug ( $ STR ) ;
logging . debug ( $ STR ) ;
logging . debug ( $ STR ) ;
catch ( exception e )
logging . log _ useful _ exception ( e ) ;
console . write _ line ( STR + o ) ;
shadowsocks _ controller . queue _ last < traffic _ info > traffic = new shadowsocks _ controller . queue _ last < traffic _ info > ( ) ;
bandwidth _ scale _ info bandwidth _ scale ;
inbound _ points . add ( traffic _ per _ second . inbound ) ; outbound _ points . add ( traffic _ per _ second . outbound ) ; max _ speed = math . max ( max _ speed , math . max ( traffic _ per _ second . inbound , traffic _ per _ second . outbound ) ) ; } last _ inbound = traffic . last ( ) . inbound ; last _ outbound = traffic . last ( ) . outbound ;
inbound _ points = inbound _ points . select ( p = > p / bandwidth _ scale . unit ) . to _ list ( ) ; outbound _ points = outbound _ points . select ( p = > p / bandwidth _ scale . unit ) . to _ list ( ) ;
traffic _ chart . chart _ areas [ 0 ] . axis _ y . label _ style . format = STR + bandwidth _ scale . unit _ name ; traffic _ chart . chart _ areas [ 0 ] . axis _ y . maximum = bandwidth _ scale . value ;
traffic = new shadowsocks _ controller . queue _ last < traffic _ info > ( ) ;
traffic . enqueue ( new traffic _ info ( traffic _ per _ second . inbound _ increasement , traffic _ per _ second . outbound _ increasement ) ) ;
return ( bytes / ( double ) k ) . to _ string ( STR ) + STR ; } return bytes . to _ string ( ) + STR ;
public static bandwidth _ scale _ info get _ bandwidth _ scale ( long n )

namespace shadowsocks _ proxy
public class socks _ proxy : i _ proxy
namespace shadowsocks _ proxy
public class http _ proxy : i _ proxy
namespace shadowsocks _ proxy
public interface i _ proxy
namespace shadowsocks _ proxy
public class direct _ connect : i _ proxy
public event event _ handler check _ update _ completed ;
if ( versions . count ! = 0 )
sort _ versions ( versions ) ; new _ version _ found = true ; latest _ version _ url = versions [ versions . count - 1 ] ; latest _ version _ number = parse _ version _ from _ url ( latest _ version _ url ) ;
if ( check _ update _ completed ! = null )
check _ update _ completed ( this , new event _ args ( ) ) ;
update _ checker . check _ update _ completed + = update _ checker _ check _ update _ completed ;
configuration config = controller . get _ configuration _ copy ( ) ; if ( config . auto _ check _ update ) { is _ startup _ checking = true ; update _ checker . check _ update ( config ) ; } if ( config . is _ default )
using shadowsocks _ encryption _ circular _ buffer ;
private byte _ circular _ buffer enc _ circular _ buffer = new byte _ circular _ buffer ( tcp _ handler . buffer _ size * 2 ) ; private byte _ circular _ buffer dec _ circular _ buffer = new byte _ circular _ buffer ( tcp _ handler . buffer _ size * 2 ) ;
this . close ( ) ;
if ( ! register _ all _ hotkeys ( out ) ) { message _ box . show ( n . get _ string ( STR ) ) ;
this . close ( ) ;
if ( ! try _ reg _ hotkey ( tb ) ) { is _ success = false ; failure _ info . append _ line ( tb . text ) ; } } failure _ info _ str = failure _ info . to _ string ( ) ; return is _ success ;
bool reg _ result = hot _ keys . register ( hotkey , call _ back ) ;
hot _ keys . unregister ( prev _ hot _ key ) ;
modified _ hotkey _ config . switch _ system _ proxy = switch _ system _ proxy _ text _ box . text ; modified _ hotkey _ config . switch _ system _ proxy _ mode = switch _ proxy _ mode _ text _ box . text ; modified _ hotkey _ config . switch _ allow _ lan = switch _ allow _ lan _ text _ box . text ; modified _ hotkey _ config . show _ logs = show _ logs _ text _ box . text ; modified _ hotkey _ config . server _ move _ up = server _ move _ up _ text _ box . text ; modified _ hotkey _ config . server _ move _ down = server _ move _ down _ text _ box . text ; controller . save _ hotkey _ config ( modified _ hotkey _ config ) ;
toolbar _ trigger = ! toolbar _ trigger ; toolbar _ flow _ layout _ panel . visible = toolbar _ trigger ; show _ toolbar _ menu _ item . checked = toolbar _ trigger ;

choose _ new _ server ( ) ;

public static list < server > get _ servers ( string ss _ url )
var matches = url _ finder . matches ( ss _ url ) ; if ( matches . count < = 0 ) return null ; list < server > servers = new list < server > ( ) ; foreach ( match match in matches ) { server tmp = new server ( ) ; var base = match . groups [ STR ] . value ; var tag = match . groups [ STR ] . value ; if ( ! tag . is _ null _ or _ empty ( ) ) { tmp . remarks = http _ utility . url _ decode ( tag , encoding . ut ) ; } match details = details _ parser . match ( encoding . ut . get _ string ( convert . from _ base _ string ( base . pad _ right ( base . length + ( NUM - base . length % NUM ) % NUM , '=' ) ) ) ) ; if ( ! details . success ) continue ; tmp . method = details . groups [ STR ] . value ; tmp . password = details . groups [ STR ] . value ; tmp . server = details . groups [ STR ] . value ; tmp . server _ port = int . parse ( details . groups [ STR ] . value ) ; servers . add ( tmp ) ; } return servers ;
public void encrypt ( byte [ ] buf , int length )
for ( int i = 0 ; i < length ; i + + )
public void decrypt ( byte [ ] buf , int length )
for ( int i = 0 ; i < length ; i + + )

private readonly shadowsocks _ controller controller ;
private readonly timer timer ; private dictionary < string , statistics _ data > statistics ; private const int cached _ interval = NUM * NUM * NUM ; private const int retry _ interval = 2 * NUM * NUM ;
var random _ index = new random ( ) . next ( ) % servers . count ( ) ;
var servers = controller . get _ current _ configuration ( ) . configs ;
if ( ! current _ server . equals ( best _ result . server ) )
log _ when _ enabled ( $ STR ) ;
private void log _ when _ enabled ( string log )
if ( controller . get _ current _ strategy ( ) ? . id = = id ) { console . write _ line ( log ) ; }
public string id = > STR ; public string name = > n . get _ string ( STR ) ;

logging . debug ( $ STR ) ;
show _ balloon _ tip ( n . get _ string ( STR ) , n . get _ string ( STR ) , tool _ tip _ icon . info , 0 ) ;
string err _ msg = e . exception _ object . to _ string ( ) ; logging . error ( err _ msg ) ;
if ( interlocked . increment ( ref exited ) = = 1 ) { string error _ msg = $ STR ; logging . error ( error _ msg ) ; message _ box . show ( $ STR unexpected error , shadowsocks will exit . please report to STR , STR , message _ box _ buttons . ok , message _ box _ icon . error ) ; application . exit ( ) ; }
if ( name . is _ null _ or _ empty ( ) ) throw new argument _ exception ( nameof ( name ) ) ; try { registry _ key user _ key = registry _ key . open _ base _ key ( registry _ hive . current _ user , environment . is _ bit _ operating _ system ? registry _ view . registry : registry _ view . registry ) . open _ sub _ key ( name , writable ) ; return user _ key ; } catch ( unauthorized _ access _ exception uae ) { logging . log _ useful _ exception ( uae ) ; return null ; } catch ( security _ exception se ) { logging . log _ useful _ exception ( se ) ; return null ; } catch ( argument _ exception ae ) { message _ box . show ( STR + ae . to _ string ( ) ) ; return null ; }
using system ;
using shadowsocks _ util _ system _ proxy ;

if ( enabled ) { if ( global ) { win _ i _ net . set _ ie _ proxy ( true , true , STR + config . local _ port . to _ string ( ) , STR ) ;
else { string pac _ url ; if ( config . use _ online _ pac & & ! config . pac _ url . is _ null _ or _ empty ( ) ) pac _ url = config . pac _ url ; else pac _ url = $ STR ; win _ i _ net . set _ ie _ proxy ( true , false , STR , pac _ url ) ;
else { win _ i _ net . set _ ie _ proxy ( false , false , STR , STR ) ;
var registry = registry . current _ user . open _ sub _ key ( STR , true ) ;
foreach ( var each in connections )
notify _ ie ( ) ; } catch ( io _ exception e ) {

var registry = registry . current _ user . open _ sub _ key ( STR , true ) ; var def _ connection = ( byte [ ] ) registry . get _ value ( STR ) ; var saved _ legacy _ setting = ( byte [ ] ) registry . get _ value ( STR ) ;
def _ connection [ NUM ] = ( byte ) ( def _ connection [ NUM ] | NUM ) ; saved _ legacy _ setting [ NUM ] = ( byte ) ( saved _ legacy _ setting [ NUM ] | NUM ) ;
def _ connection [ NUM ] = ( byte ) ( def _ connection [ NUM ] & ~ NUM ) ; saved _ legacy _ setting [ NUM ] = ( byte ) ( saved _ legacy _ setting [ NUM ] & ~ NUM ) ;
using ( var fs = new file _ stream ( file _ name , file _ mode . create , file _ access . write ) ) fs . write ( content , 0 , content . length ) ;
catch ( exception ex )
ex . to _ string ( ) ) ;

using ( var fs = file . create ( file _ name ) ) using ( var input = new g _ zip _ stream ( new memory _ stream ( content ) ,
fs . write ( buffer , 0 , n ) ;

this . servers _ list _ view = new system . windows . forms . list _ view ( ) ; this . panel = new system . windows . forms . panel ( ) ; this . add _ button = new system . windows . forms . button ( ) ; this . delete _ button = new system . windows . forms . button ( ) ; this . group _ box = new system . windows . forms . group _ box ( ) ;
this . panel . suspend _ layout ( ) ; this . group _ box . suspend _ layout ( ) ;


this . table _ layout _ panel . controls . add ( this . proxy _ port _ text _ box , 1 , NUM ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , NUM ) ;

this . table _ layout _ panel . controls . add ( this . label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . encryption _ select , 1 , NUM ) ; this . table _ layout _ panel . location = new system . drawing . point ( NUM , NUM ) ; this . table _ layout _ panel . margin = new system . windows . forms . padding ( NUM ) ;

this . panel . location = new system . drawing . point ( NUM , NUM ) ; this . panel . margin = new system . windows . forms . padding ( 0 ) ;

this . split _ container . size = new system . drawing . size ( NUM , NUM ) ; this . split _ container . splitter _ distance = NUM ; this . split _ container . splitter _ width = NUM ;
this . numeric _ up _ down . location = new system . drawing . point ( NUM , NUM ) ; this . numeric _ up _ down . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;
using system ;
using system _ net ; using system _ net _ network _ information ; using system _ runtime _ interop _ services ;
using shadowsocks _ model ; using shadowsocks _ properties ;


file _ manager . uncompress _ file ( utils . get _ temp _ path ( STR ) , resources . privoxy _ exe ) ; file _ manager . uncompress _ file ( utils . get _ temp _ path ( STR ) , resources . mgwz _ dll ) ;
file _ manager . byte _ array _ to _ file ( utils . get _ temp _ path ( STR ) , encoding . ut . get _ bytes ( polipo _ config ) ) ;
process . start _ info . file _ name = STR ; process . start _ info . arguments = STR ; process . start _ info . working _ directory = utils . get _ temp _ path ( ) ;
using system ; using system _ io ; using system _ runtime _ interop _ services ; using shadowsocks _ controller ;

using system ;
utils . release _ memory ( true ) ;
using system ; using system _ io ; using system _ runtime _ interop _ services ; using shadowsocks _ controller ;

string dll _ path = utils . get _ temp _ path ( STR ) ;
using system ; using system _ io ; using system _ runtime _ interop _ services ; using shadowsocks _ controller ;

string dll _ path = utils . get _ temp _ path ( STR ) ;
using system ;
using system _ net ; using shadowsocks _ util ;
log _ file = utils . get _ temp _ path ( STR ) ;
if ( ! file . exists ( utils . get _ temp _ path ( STR ) ) )
list < string > lines = gfw _ list _ updater . parse _ result ( file . read _ all _ text ( utils . get _ temp _ path ( STR ) ) ) ;
using shadowsocks _ model ;





if ( temp _ path = = null )
if ( file . exists ( path . combine ( application . startup _ path , STR ) ) ) try { directory . create _ directory ( path . combine ( application . startup _ path , STR ) ) ; } catch ( exception e ) { temp _ path = path . get _ temp _ path ( ) ; logging . log _ useful _ exception ( e ) ; } finally {  temp _ path = path . combine ( application . startup _ path , STR ) ; } else temp _ path = path . get _ temp _ path ( ) ;
return temp _ path ; }  public static string get _ temp _ path ( string filename ) { return path . combine ( get _ temp _ path ( ) , filename ) ;
var inbound = current . inbound _ counter = inbound _ counter ; var outbound = current . outbound _ counter = outbound _ counter ; current . inbound _ increasement = inbound - previous . inbound _ counter ; current . outbound _ increasement = outbound - previous . outbound _ counter ;
traffic _ changed ? . invoke ( this , new event _ args ( ) ) ;
var session = ( async _ session ) ar . async _ state ;
send _ to _ server ( bytes _ read , session ) ;
public server get _ a _ server ( i _ strategy _ caller _ type type , ip _ end _ point local _ ip _ end _ point , end _ point dest _ end _ point )
return strategy . get _ a _ server ( type , local _ ip _ end _ point , dest _ end _ point ) ;
try { if ( utils . is _ portable _ mode ( ) )
* under portable _ mode , we could identify it by the path of ss _ privoxy . exe .
var path = process . main _ module . file _ name ;
else
} catch ( exception ex ) {  * sometimes process . get _ processes _ by _ name will return some processes that * are already dead , and that will cause exceptions here . * we could simply ignore those exceptions . * / logging . log _ useful _ exception ( ex ) ;
polar _ ssl . aes _ crypt _ cfb ( ctx , is _ cipher ? polar _ ssl . aes _ encrypt : polar _ ssl . aes _ decrypt , length , ref iv _ offset , iv , buf , outbuf ) ;
public void test _ polar _ ssl _ encryption ( )
thread t = new thread ( new thread _ start ( run _ single _ polar _ ssl _ encryption _ thread ) ) ;
private bool validate _ and _ save _ selected _ server _ details ( )
server server = get _ server _ details _ from _ ui ( ) ;


private server get _ server _ details _ from _ ui ( ) { server server = new server ( ) ; if ( uri . check _ host _ name ( server . server = ip _ text _ box . text . trim ( ) ) = = uri _ host _ name _ type . unknown ) { message _ box . show ( n . get _ string ( STR ) ) ; ip _ text _ box . focus ( ) ; return null ; } if ( ! int . try _ parse ( server _ port _ text _ box . text , out server . server _ port ) ) { message _ box . show ( n . get _ string ( STR ) ) ; server _ port _ text _ box . focus ( ) ; return null ; } server . password = password _ text _ box . text ; server . method = encryption _ select . text ; server . plugin = plugin _ text _ box . text ; server . plugin _ opts = plugin _ options _ text _ box . text ; server . plugin _ args = plugin _ arguments _ text _ box . text ; server . remarks = remarks _ text _ box . text ; if ( ! int . try _ parse ( timeout _ text _ box . text , out server . timeout ) ) { message _ box . show ( n . get _ string ( STR ) ) ; timeout _ text _ box . focus ( ) ; return null ; } return server ; } private void load _ selected _ server _ details ( )
set _ server _ details _ to _ ui ( server ) ; } } private void set _ server _ details _ to _ ui ( server server ) { ip _ text _ box . text = server . server ; server _ port _ text _ box . text = server . server _ port . to _ string ( ) ; password _ text _ box . text = server . password ;  encryption _ select . text = server . method ? ? STR ; plugin _ text _ box . text = server . plugin ; plugin _ options _ text _ box . text = server . plugin _ opts ; plugin _ arguments _ text _ box . text = server . plugin _ args ; remarks _ text _ box . text = server . remarks ; timeout _ text _ box . text = server . timeout . to _ string ( ) ; } private void load _ server _ name _ list _ to _ ui ( configuration configuration )
foreach ( server server in configuration . configs )
load _ server _ name _ list _ to _ ui ( modified _ configuration ) ;
update _ buttons ( ) ; load _ selected _ server _ details ( ) ; proxy _ port _ text _ box . text = modified _ configuration . local _ port . to _ string ( ) ;

if ( ! validate _ and _ save _ selected _ server _ details ( ) )
if ( ! validate _ and _ save _ selected _ server _ details ( ) )
update _ buttons ( ) ; load _ selected _ server _ details ( ) ;
if ( ! validate _ and _ save _ selected _ server _ details ( ) )
load _ server _ name _ list _ to _ ui ( modified _ configuration ) ;
if ( ! validate _ and _ save _ selected _ server _ details ( ) )
load _ server _ name _ list _ to _ ui ( modified _ configuration ) ;
load _ server _ name _ list _ to _ ui ( modified _ configuration ) ;
load _ selected _ server _ details ( ) ;
if ( ! validate _ and _ save _ selected _ server _ details ( ) )
update _ buttons ( ) ; } private void update _ buttons ( ) { delete _ button . enabled = ( servers _ list _ box . items . count > 0 ) ; move _ up _ button . enabled = ( servers _ list _ box . selected _ index > 0 ) ; move _ down _ button . enabled = ( servers _ list _ box . selected _ index < servers _ list _ box . items . count - 1 ) ;
if ( ! validate _ and _ save _ selected _ server _ details ( ) )
: iv _ encryptor , i _ disposable


protected override dictionary < string , int [ ] > get _ ciphers ( )
return new dictionary < string , int [ ] > { { STR , new int [ ] { NUM , NUM , cipher _ aes , polar _ ssl . aes _ ctx _ size } } , { STR , new int [ ] { NUM , NUM , cipher _ aes , polar _ ssl . aes _ ctx _ size } } , { STR , new int [ ] { NUM , NUM , cipher _ aes , polar _ ssl . aes _ ctx _ size } } , { STR , new int [ ] { NUM , 0 , cipher _ r , polar _ ssl . ar _ ctx _ size } } , { STR , new int [ ] { NUM , NUM , cipher _ r , polar _ ssl . ar _ ctx _ size } } , } ;
protected override void init _ cipher ( byte [ ] iv , bool is _ cipher )
base . init _ cipher ( iv , is _ cipher ) ; int _ ptr ctx ; ctx = marshal . alloc _ h _ global ( cipher _ info [ NUM ] ) ; if ( is _ cipher )
encrypt _ ctx = ctx ;
decrypt _ ctx = ctx ;


protected override void cipher _ update ( bool is _ cipher , int length , byte [ ] buf , byte [ ] outbuf )
if ( disposed )
throw new object _ disposed _ exception ( this . to _ string ( ) ) ; } byte [ ] iv ; int iv _ offset ; if ( is _ cipher ) { iv = encrypt _ iv ; iv _ offset = encrypt _ iv _ offset ;
iv = decrypt _ iv ; iv _ offset = decrypt _ iv _ offset ;
switch ( cipher )
case cipher _ aes : polar _ ssl . aes _ crypt _ cfb ( encrypt _ ctx , is _ cipher ? polar _ ssl . aes _ encrypt : polar _ ssl . aes _ decrypt , length , ref iv _ offset , iv , buf , outbuf ) ; if ( is _ cipher )
encrypt _ iv _ offset = iv _ offset ;
else
decrypt _ iv _ offset = iv _ offset ;
break ; case cipher _ r : polar _ ssl . arc _ crypt ( encrypt _ ctx , length , buf , outbuf ) ; break ;

} catch ( io _ exception e ) { console . write _ line ( e . to _ string ( ) ) ; } load _ library ( dll _ path ) ; try {
if ( file . exists ( pac _ file ) )
return file . read _ all _ text ( pac _ file , encoding . ut ) ; } else { byte [ ] pac _ gz = resources . proxy _ pac _ txt ; byte [ ] buffer = new byte [ NUM * NUM ] ; int n ; using ( g _ zip _ stream input = new g _ zip _ stream ( new memory _ stream ( pac _ gz ) , compression _ mode . decompress , false ) )
n = input . read ( buffer , 0 , buffer . length ) ; if ( n = = 0 ) { throw new io _ exception ( STR ) ; } return system . text . encoding . ut . get _ string ( buffer , 0 , n ) ;

try { local . start ( ) ; pac _ server = new pac _ server ( ) ; pac _ server . start ( ) ; } catch ( exception e ) { console . write _ line ( e . to _ string ( ) ) ; }
this . about _ item . index = NUM ;
private static dictionary < string , int [ ] > ciphers = new dictionary < string , int [ ] > {
} ; public static list < string > supported _ ciphers ( ) { return new list < string > ( ciphers . keys ) ; } protected override dictionary < string , int [ ] > get _ ciphers ( ) { return ciphers ;
return ciphers ; } public static list < string > supported _ ciphers ( ) { return new list < string > ( ciphers . keys ) ;
if ( string . is _ null _ or _ empty ( method ) )
method = STR ;
method = method . to _ lower _ invariant ( ) ; type t = registered _ encryptors [ method ] ; constructor _ info c = t . get _ constructor ( constructor _ types ) ; i _ encryptor result = ( i _ encryptor ) c . invoke ( new object [ ] { method , password } ) ; return result ;
this . btn _ ok . location = new system . drawing . point ( NUM , NUM ) ; this . btn _ ok . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;
this . btn _ cancel . location = new system . drawing . point ( NUM , NUM ) ; this . btn _ cancel . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;
this . btn _ register _ all . location = new system . drawing . point ( NUM , NUM ) ; this . btn _ register _ all . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;
using shadowsocks _ controller ; using shadowsocks _ model ; using shadowsocks _ properties ; using system ;


using system _ collections _ generic ;

private static void init ( string res , string locale )
using ( text _ field _ parser csv _ parser = new text _ field _ parser ( new string _ reader ( res ) ) )
csv _ parser . set _ delimiters ( STR ) ; string [ ] locale _ names = csv _ parser . read _ fields ( ) ; int en _ index = 0 ; int target _ index = 0 ; for ( int i = 1 ; i < locale _ names . length ; i + + )
if ( locale _ names [ i ] = = STR ) { } if ( locale _ names [ i ] = = locale ) { target _ index = i ; } } while ( ! csv _ parser . end _ of _ data ) { string [ ] translations = csv _ parser . read _ fields ( ) ; if ( string . is _ null _ or _ white _ space ( translations [ 0 ] ) ) continue ; if ( translations [ 0 ] . trim _ start ( ' ' ) [ 0 ] = = '#' ) continue ; strings [ translations [ en _ index ] ] = translations [ target _ index ] ;
init ( resources . n _ csv , culture _ info . current _ culture . ietf _ language _ tag ) ;

n . translate _ form ( this ) ;

using system ; using system _ reflection ;

using system _ windows _ forms ; using newtonsoft _ json ;
private dictionary < string , list < statistics _ raw _ data > > raw _ statistics ; private int choice _ kept _ milliseconds = > ( int ) time _ span . from _ minutes ( controller . statistics _ configuration . choice _ kept _ minutes ) . total _ milliseconds ; private const int retry _ interval = 2 * NUM * NUM ;

log _ when _ enabled ( $ STR ) ; timer . change ( retry _ interval , choice _ kept _ milliseconds ) ;
raw _ statistics = ( from l in file . read _ all _ lines ( path ) . skip ( 1 ) let strings = l . split ( new [ ] { STR } , string _ split _ options . remove _ empty _ entries ) let raw _ data = new statistics _ raw _ data { timestamp = strings [ 0 ] , server _ name = strings [ 1 ] , icmp _ status = strings [ 2 ] , roundtrip _ time = int . parse ( strings [ NUM ] ) , geolocation = NUM > strings . length ? null : strings [ NUM ] , isp = NUM > strings . length ? null : strings [ NUM ] } group raw _ data by raw _ data . server _ name into server select new { server _ name = server . key , data = server . to _ list ( ) } ) . to _ dictionary ( server = > server . server _ name , server = > server . data ) ;
private float get _ score ( i _ enumerable < statistics _ raw _ data > raw _ data _ list ) { var config = controller . statistics _ configuration ; if ( config . by _ isp ) { var current = availability _ statistics . get _ geolocation _ and _ isp ( ) . result ; raw _ data _ list = raw _ data _ list . where ( data = > data . geolocation = = current [ 0 ] . value | | data . geolocation = = availability _ statistics . state . unknown ) ; raw _ data _ list = raw _ data _ list . where ( data = > data . isp = = current [ 1 ] . value | | data . isp = = availability _ statistics . state . unknown ) ; if ( raw _ data _ list . long _ count ( ) = = 0 ) return 0 ; } if ( config . by _ hour _ of _ day ) { var current _ hour = date _ time . now . hour ; raw _ data _ list = raw _ data _ list . where ( data = > { date _ time date _ time ; date _ time . try _ parse _ exact ( data . timestamp , availability _ statistics . date _ time _ pattern , null , date _ time _ styles . none , out date _ time ) ; var result = date _ time . hour . equals ( current _ hour ) ; return result ; } ) ; if ( raw _ data _ list . long _ count ( ) = = 0 ) return 0 ; } var data _ list = raw _ data _ list as i _ list < statistics _ raw _ data > ? ? raw _ data _ list . to _ list ( ) ; var server _ name = data _ list [ 0 ] ? . server _ name ; var success _ times = ( float ) data _ list . count ( data = > data . icmp _ status . equals ( ip _ status . success . to _ string ( ) ) ) ; var timed _ out _ times = ( float ) data _ list . count ( data = > data . icmp _ status . equals ( ip _ status . timed _ out . to _ string ( ) ) ) ; var statistics _ data = new statistics _ data ( ) { package _ loss = timed _ out _ times / ( success _ times + timed _ out _ times ) * NUM , average _ response = convert . to _ int ( data _ list . average ( data = > data . roundtrip _ time ) ) , min _ response = data _ list . min ( data = > data . roundtrip _ time ) , max _ response = data _ list . max ( data = > data . roundtrip _ time ) } ; float factor ; float score = 0 ; if ( ! config . calculations . try _ get _ value ( STR , out factor ) ) factor = 0 ; score + = statistics _ data . package _ loss * factor ; if ( ! config . calculations . try _ get _ value ( STR , out factor ) ) factor = 0 ; score + = statistics _ data . average _ response * factor ; if ( ! config . calculations . try _ get _ value ( STR , out factor ) ) factor = 0 ; score + = statistics _ data . min _ response * factor ; if ( ! config . calculations . try _ get _ value ( STR , out factor ) ) factor = 0 ; score + = statistics _ data . max _ response * factor ; logging . debug ( $ STR ) ; return score ; } class statistics _ raw _ data { public string timestamp ; public string server _ name ; public string icmp _ status ; public int roundtrip _ time ; public string geolocation ; public string isp ;
public float package _ loss ;
if ( raw _ statistics = = null | | servers . count = = 0 )
where raw _ statistics . contains _ key ( name )
score = get _ score ( raw _ statistics [ name ] )
public calculation _ control ( string text , float value )
value _ label . text = text ; factor _ num . value = ( decimal ) value ;
public float factor = > ( float ) factor _ num . value ;


series . chart _ type = system . windows . forms . data _ visualization . charting . series _ chart _ type . bubble ; series . color = system . drawing . color . from _ argb ( ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) , ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) , ( ( int ) ( ( ( byte ) ( 0 ) ) ) ) ) ;
series . name = STR ; series . y _ values _ per _ point = NUM ; series . border _ width = NUM ;
series . chart _ type = system . windows . forms . data _ visualization . charting . series _ chart _ type . line ; series . color = system . drawing . color . from _ argb ( ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) , ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) , ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) ) ;
series . name = STR ;
this . statistics _ chart . size = new system . drawing . size ( NUM , NUM ) ;

private const int delay _ before _ start = NUM ; private int repeat = > config . repeat _ times _ num ; private int interval = > ( int ) time _ span . from _ minutes ( config . data _ collection _ minutes ) . total _ milliseconds ;
var temppath = utils . get _ temp _ path ( ) ;
public availability _ statistics ( configuration config , statistics _ strategy _ configuration statistics _ config )
if ( config . statistics _ enabled )
if ( timer ? . change ( delay _ before _ start , interval ) = = null )
timer = new timer ( evaluate , state , delay _ before _ start , interval ) ;
private async task < list < data _ list > > icmp _ test ( server server )
var timestamp in enumerable . range ( 0 , repeat ) . select ( = > date _ time . now . to _ string ( date _ time _ pattern ) ) )
var reply = ping . send ( ip , timeout ) ;
try { file . append _ all _ lines ( availability _ statistics _ file , lines ) ; } catch ( io _ exception e ) { logging . log _ useful _ exception ( e ) ; }
internal void update _ configuration ( configuration config , statistics _ strategy _ configuration statistics _ config )
set ( statistics _ config ) ;
public class state
registry _ key ss _ url _ association = null ;
ss _ url _ association = registry . current _ user . create _ sub _ key ( STR , registry _ key _ permission _ check . read _ write _ sub _ tree ) ; if ( ss _ url _ association = = null )
ss _ url _ association . set _ value ( STR , STR ) ; ss _ url _ association . set _ value ( STR , STR ) ; var shell _ open = ss _ url _ association . create _ sub _ key ( STR ) . create _ sub _ key ( STR ) . create _ sub _ key ( STR ) ;
registry . current _ user . delete _ sub _ key _ tree ( STR ) ; logger . info ( STR ) ;
ss _ url _ association . close ( ) ; ss _ url _ association . dispose ( ) ;
registry _ key ss _ url _ association = null ;
ss _ url _ association = registry . current _ user . open _ sub _ key ( STR , true ) ; if ( ss _ url _ association = = null )

var shell _ open = ss _ url _ association . open _ sub _ key ( STR ) . open _ sub _ key ( STR ) . open _ sub _ key ( STR ) ;
ss _ url _ association . close ( ) ; ss _ url _ association . dispose ( ) ;
assembly _ assembly _ company _ clowwindy
assembly _ assembly _ copyright _ copyright _ clowwindy
public static void release _ memory ( bool remove _ pages )
if ( remove _ pages ) {                   set _ process _ working _ set _ size ( process . get _ current _ process ( ) . handle , ( u _ int _ ptr ) 0 xffffffff , ( u _ int _ ptr ) 0 xffffffff ) ; }
lock ( encryption _ lock ) { lock ( decryption _ lock ) { ( ( i _ disposable ) encryptor ) . dispose ( ) ; } }
lock ( decryption _ lock ) { if ( closed ) { return ; } encryptor . decrypt ( remote _ recv _ buffer , bytes _ read , remote _ send _ buffer , out bytes _ to _ send ) ; }
lock ( encryption _ lock ) { if ( closed ) { return ; } encryptor . encrypt ( connetion _ recv _ buffer , bytes _ read , connetion _ send _ buffer , out bytes _ to _ send ) ; }
console . write _ line ( e ) ;
using ( mutex mutex = new mutex ( false , $ STR ) )
message _ box . show ( $ STR unexpected error , shadowsocks will exit . please report to STR ,
logger . error ( STR ) ;
logger . log _ useful _ exception ( e ) ;
logger . debug ( STR + command ) ;
logger . log _ useful _ exception ( e ) ;
logger . info ( $ STR ) ;
logger . debug ( STR ) ;
logger . log _ useful _ exception ( e ) ;
logger . debug ( $ STR ) ;
logger . log _ useful _ exception ( e ) ;
logger . error ( STR ) ;
logger . info (
logger . error ( STR + ex . message ) ;
logger . log _ useful _ exception ( e ) ;
logger . debug ( $ STR ) ;
logger . log _ useful _ exception ( e ) ;
logger . debug ( $ STR ) ;
logger . error ( $ STR ) ; logger . log _ useful _ exception ( e ) ;
logger . error ( $ STR ) ; logger . log _ useful _ exception ( ex ) ;
logger . dump ( STR , salt , salt _ len ) ;
logger . error ( $ STR ) ;
using n _ log ; using system ;
using n _ log ; using shadowsocks _ model ;
logger . info ( $ STR ) ;
logger . info ( encryption . encryptor _ factory . dump _ registered _ encryptor ( ) ) ;
logger . debug ( STR ) ;
logger . log _ useful _ exception ( ex ) ;
logger . debug ( STR ) ;
logger . log _ useful _ exception ( ex ) ;
logger . debug ( $ STR ) ;
logger . log _ useful _ exception ( ex ) ;
logger . dump ( STR , dec _ nonce , nonce _ len ) ; logger . dump ( STR , sodium _ dec _ subkey , key _ len ) ; logger . dump ( STR , ciphertext , ( int ) clen ) ;
logger . debug ( local _ end _ point , remote _ end _ point , outlen , STR ) ;


logger . error ( err _ msg ) ;
logger . log _ useful _ exception ( ex ) ;

catch ( exception )
public static string get _ string ( string key , params object [ ] args )
? string . format ( strings [ key ] , args ) : string . format ( key , args ) ;
return ip _ properties . get _ active _ tcp _ listeners ( ) . any ( end _ point = > end _ point . port = = port ) ;
throw new exception ( n . get _ string ( STR , config . local _ port ) ) ;

ip _ address ip _ address ; bool parsed = ip _ address . try _ parse ( host , out ip _ address ) ; if ( parsed ) { ip _ end _ point ep = new ip _ end _ point ( ip _ address , port ) ; switch ( ep . address _ family ) { case address _ family . inter _ network : request = new byte [ NUM + NUM + 2 ] ; atyp = 1 ; break ; case address _ family . inter _ network : request = new byte [ NUM + NUM + 2 ] ; atyp = NUM ; break ; default : throw new exception ( n . get _ string ( STR ) ) ; } var addr = ep . address . get _ address _ bytes ( ) ; array . copy ( addr , 0 , request , NUM , request . length - NUM - 2 ) ; } else {   atyp = NUM ; var enc = encoding . ut ; var host _ byte _ count = enc . get _ byte _ count ( host ) ; request = new byte [ NUM + 1 request [ NUM ] = ( byte ) host _ byte _ count ; enc . get _ bytes ( host , 0 , host . length , request , NUM ) ; }
request [ request . length - 2 ] = ( byte ) ( ( port > > NUM ) & 0 xff ) ; request [ request . length - 1 ] = ( byte ) ( port & 0 xff ) ;
if ( controller . get _ current _ configuration ( ) . is _ verbose _ logging ) { logging . info ( $ STR ) ; }
if ( controller . get _ current _ configuration ( ) . is _ verbose _ logging ) { logging . info ( $ STR ) ; }
if ( controller . get _ current _ configuration ( ) . is _ verbose _ logging ) { logging . info ( $ STR ) ; }
string name = culture _ info . current _ culture . name ; if ( name . starts _ with ( STR ) )
if ( name = = STR | | name = = STR )
init ( resources . cn ) ; } else { init ( resources . zh _ tw ) ;
if ( user _ settings _ arr . length ! = NUM )
if ( logger . is _ trace _ enabled )
var sb = new string _ builder ( $ STR ) ; for ( int i = 0 ; i < length - 1 ; i + + ) { sb . append ( $ STR ) ; } sb . append ( $ STR ) ; sb . append ( environment . new _ line ) ; logger . trace ( sb . to _ string ( ) ) ;

if ( logger . is _ debug _ enabled ) { if ( header = = null & & tailer = = null ) logger . debug ( $ STR ) ; else if ( header = = null & & tailer ! = null ) logger . debug ( $ STR ) ; else if ( header ! = null & & tailer = = null ) logger . debug ( $ STR ) ; else logger . debug ( $ STR ) ; }
if ( logger . is _ debug _ enabled ) { logger . debug ( sock . local _ end _ point , sock . remote _ end _ point , len , header , tailer ) ; }
var configuration = simple _ json . simple _ json . deserialize _ object < statistics _ strategy _ configuration > ( content ) ;
catch ( file _ not _ found _ exception )
protected static bool serialize _ value ( i _ json _ serializer _ strategy json _ serializer _ strategy , object value , int level , string _ builder builder )
success = serialize _ object ( json _ serializer _ strategy , dict . keys , dict . values , level , builder ) ;
success = serialize _ object ( json _ serializer _ strategy , dict . keys , dict . values , level , builder ) ;
success = serialize _ array ( json _ serializer _ strategy , ( i _ enumerable ) value , level , builder ) ;
serialize _ value ( json _ serializer _ strategy , serialized _ object , level , builder ) ;
protected static bool serialize _ object ( i _ json _ serializer _ strategy json _ serializer _ strategy , i _ enumerable keys , i _ enumerable values , int level , string _ builder builder )
if ( ! serialize _ value ( json _ serializer _ strategy , value , level , builder ) ) return false ;
if ( ! serialize _ value ( json _ serializer _ strategy , value , level , builder ) )
builder . append ( STR ) ; feed _ indent ( level - 1 , builder ) ; builder . append ( STR ) ;
protected static bool serialize _ array ( i _ json _ serializer _ strategy json _ serializer _ strategy , i _ enumerable an _ array , int level , string _ builder builder ) { builder . append ( STR ) ; level + + ;
builder . append ( STR ) ; feed _ indent ( level , builder ) ; if ( ! serialize _ value ( json _ serializer _ strategy , value , level , builder ) )
builder . append ( STR ) ; feed _ indent ( level - 1 , builder ) ; builder . append ( STR ) ;
rng = rng ? ? new rng _ crypto _ service _ provider ( ) ;
rng ? . dispose ( ) ;
if ( rng = = null ) init ( ) ;
catch
list < string > lines = parse _ result ( e . result ) ;
abp _ content = abp _ content . replace ( STR , simple _ json . simple _ json . serialize _ object ( lines ) ) ;
public list < string > parse _ result ( string response )
catch ( exception e )
logging . log _ useful _ exception ( e ) ;  message _ box . show ( n . get _ string ( STR ) ) ;
catch ( exception e )
logging . log _ useful _ exception ( e ) ;  message _ box . show ( n . get _ string ( STR ) ) ;


try
if ( enabled )
if ( global ) { win _ i _ net . set _ ie _ proxy ( true , true , STR + config . local _ port . to _ string ( ) , STR ) ; } else { string pac _ url ; if ( config . use _ online _ pac & & ! config . pac _ url . is _ null _ or _ empty ( ) ) pac _ url = config . pac _ url ; else pac _ url = $ STR ; win _ i _ net . set _ ie _ proxy ( true , false , STR , pac _ url ) ; }
win _ i _ net . set _ ie _ proxy ( false , false , STR , STR ) ;
catch ( proxy _ exception ex )
logging . log _ useful _ exception ( ex ) ;
top _ most _ trigger _ lock = false ; wrap _ text _ trigger _ lock = true ; log _ message _ text _ box . word _ wrap = wrap _ text _ menu _ item . checked = wrap _ text _ check _ box . checked = wrap _ text _ trigger ; wrap _ text _ trigger _ lock = false ; toolbar _ flow _ layout _ panel . visible = show _ toolbar _ menu _ item . checked = toolbar _ trigger ;
if ( key . length ! = key _ len ) array . resize ( ref key , key _ len ) ; legacy _ derive _ key ( passbuf , key , key _ len ) ;
public static void legacy _ derive _ key ( byte [ ] password , byte [ ] key , int keylen )
byte [ ] result = new byte [ password . length + m _ len ] ;
while ( i < keylen ) {
array . copy ( md _ sum , 0 , result , 0 , m _ len ) ; array . copy ( password , 0 , result , m _ len , password . length ) ;
array . copy ( md _ sum , 0 , key , i , math . min ( m _ len , keylen - i ) ) ; i + = m _ len ;
if ( masterkey . length ! = key _ len ) array . resize ( ref masterkey , key _ len ) ; derive _ key ( passbuf , masterkey , key _ len ) ;
public void derive _ key ( byte [ ] password , byte [ ] key , int keylen ) { stream _ encryptor . legacy _ derive _ key ( password , key , keylen ) ;
public string friendly _ name ( )
if ( string . is _ null _ or _ empty ( server ) )
return n . get _ string ( STR ) ;


private async _ session current _ remote _ session ;
public async _ session session ;
proxy _ timer . session = session ;
remote . begin _ connect _ proxy ( proxy _ ep , new async _ callback ( proxy _ connect _ callback ) , new async _ session < proxy _ timer > ( remote , proxy _ timer ) ) ;
var proxy = ( ( proxy _ timer ) sender ) . session . remote ;
proxy . close ( ) ;
var session = ( async _ session < proxy _ timer > ) ar . async _ state ; proxy _ timer timer = session . state ;
remote . begin _ connect _ dest ( dest _ end _ point , new async _ callback ( connect _ callback ) , new async _ session < server _ timer > ( session , connect _ timer ) ) ;
session . remote . close ( ) ;
var session = ( async _ session < server _ timer > ) ar . async _ state ; server _ timer timer = session . state ;
private void start _ pipe ( async _ session session )
session . remote . begin _ receive ( remote _ recv _ buffer , 0 , recv _ size , socket _ flags . none , new async _ callback ( pipe _ remote _ receive _ callback ) , session ) ;
new async _ session < bool > ( session , true )
if ( session . state & & config . is _ verbose _ logging )
session . state = false ;
session . remote . begin _ receive ( remote _ recv _ buffer , 0 , recv _ size , socket _ flags . none , new async _ callback ( pipe _ remote _ receive _ callback ) , session ) ;



socket _ util . begin _ connect _ tcp ( remote _ ep , connect _ callback , null ) ;
socket _ util . begin _ connect _ tcp ( dest _ end _ point , callback , state ) ;
remote = socket _ util . end _ connect _ tcp ( async _ result ) ;

socket _ util . begin _ connect _ tcp ( remote _ ep , connect _ callback , st ) ;
private class tcp _ user _ token : i _ async _ result
public async _ callback callback { get ; } public socket _ async _ event _ args args { get ; } public tcp _ user _ token ( async _ callback callback , object state , socket _ async _ event _ args args )
callback = callback ; async _ state = state ; args = args ;
public bool is _ completed { get ; } = true ; public wait _ handle async _ wait _ handle { get ; } = null ; public object async _ state { get ; } public bool completed _ synchronously { get ; } = true ; } private static void on _ tcp _ connect _ completed ( object sender , socket _ async _ event _ args args ) { tcp _ user _ token token = ( tcp _ user _ token ) args . user _ token ; token . callback ( token ) ; } public static void begin _ connect _ tcp ( end _ point end _ point , async _ callback callback , object state ) { var arg = new socket _ async _ event _ args ( ) ; arg . remote _ end _ point = end _ point ; arg . completed + = on _ tcp _ connect _ completed ; arg . user _ token = new tcp _ user _ token ( callback , state , arg ) ; socket . connect _ async ( socket _ type . stream , protocol _ type . tcp , arg ) ; } public static socket end _ connect _ tcp ( i _ async _ result async _ result ) { var tut = async _ result as tcp _ user _ token ; if ( tut = = null )
throw new argument _ exception ( STR , nameof ( async _ result ) ) ;
var arg = tut . args ; if ( arg . socket _ error ! = socket _ error . success )
if ( arg . connect _ by _ name _ error ! = null ) { throw arg . connect _ by _ name _ error ; } var ex = new socket _ exception ( ( int ) arg . socket _ error ) ; throw ex ;
var is _ pre _ release = ( bool ) release [ STR ] ; if ( is _ pre _ release & & ! config . check _ pre _ release )
asset ass = asset . parse _ asset ( asset ) ; if ( ass ! = null )
ass . prerelease = is _ pre _ release ; if ( ass . is _ new _ version ( version , pre _ release , config . check _ pre _ release ) ) { asserts . add ( ass ) ; }
public string suffix ; public static asset parse _ asset ( j _ object aj _ object ) { var name = ( string ) aj _ object [ STR ] ; match match = regex . match ( name , STR , regex _ options . ignore _ case ) ; if ( match . success ) { string version = match . groups [ STR ] . value ; var asset = new asset { browser _ download _ url = ( string ) aj _ object [ STR ] , name = name , version = version } ; if ( match . groups [ STR ] . success ) { asset . suffix = match . groups [ STR ] . value ; } return asset ; } return null ; } public bool is _ new _ version ( string current _ version , bool is _ pre _ release , bool check _ pre _ release ) { if ( prerelease & & ! check _ pre _ release )
var cmp = compare _ version ( version , current _ version ) ; if ( cmp = = 0 ) {  return ! prerelease & & is _ pre _ release ; } return cmp > 0 ;
if ( system _ proxy _ is _ dirty ) { system _ proxy . disable ( ) ; system _ proxy _ is _ dirty = false ; }
if ( controller ! = null ) { system . timers . timer timer = new system . timers . timer ( NUM * NUM ) ; timer . elapsed + = timer _ elapsed ; timer . auto _ reset = false ; timer . enabled = true ; timer . start ( ) ; }
if ( st . inner _ state . ex = = null )
if ( ! established ) { st . inner _ state . ex = new exception ( n . get _ string ( STR ) ) ; }

if ( ! secret _ match ) { socket . close ( ) ; } else { send _ response ( first _ packet , length , socket , use _ socks ) ; }
byte [ ] cipher = new byte [ plain . length + NUM + iv _ encryptor . onetimeauth _ bytes + iv _ encryptor . auth _ bytes ] ;
encryptor . encrypt ( plain , plain . length , cipher , out out _ len , false ) ;
encryptor . encrypt ( plain , NUM , cipher , out out _ len , false ) ;
encryptor . encrypt ( plain , NUM , cipher , out out _ len , false ) ;
public const int onetimeauth _ bytes = NUM ;
public const int auth _ bytes = onetimeauth _ bytes + clen _ bytes ;
protected byte [ ] gen _ onetime _ auth _ hash ( byte [ ] msg , int msg _ len ) { byte [ ] auth = new byte [ onetimeauth _ bytes ] ; byte [ ] hash = new byte [ NUM ] ; byte [ ] auth _ key = new byte [ max _ iv _ length + max _ key _ length ] ; buffer . block _ copy ( encrypt _ iv , 0 , auth _ key , 0 , iv _ len ) ; buffer . block _ copy ( key , 0 , auth _ key , iv _ len , key _ len ) ; sodium . ss _ sha _ hmac _ ex ( auth _ key , ( uint ) ( iv _ len + key _ len ) , msg , 0 , ( uint ) msg _ len , hash ) ; buffer . block _ copy ( hash , 0 , auth , 0 , onetimeauth _ bytes ) ; return auth ; } protected void update _ key _ buffer ( ) {

} protected byte [ ] gen _ hash ( byte [ ] buf , int offset , int len ) { byte [ ] hash = new byte [ NUM ] ; update _ key _ buffer ( ) ; sodium . ss _ sha _ hmac _ ex ( key _ buffer , ( uint ) key _ buffer . length , buf , offset , ( uint ) len , hash ) ; return hash ; } public override void encrypt ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength , bool udp )

if ( onetime _ auth & & iv _ len > 0 ) { byte [ ] hash = gen _ hash ( buf , 0 , length ) ; buffer . block _ copy ( buf , 0 , buf , auth _ bytes , length ) ; byte [ ] len _ bytes = bit _ converter . get _ bytes ( ( ushort ) ip _ address . host _ to _ network _ order ( ( short ) length ) ) ; buffer . block _ copy ( len _ bytes , 0 , buf , 0 , clen _ bytes ) ; buffer . block _ copy ( hash , 0 , buf , clen _ bytes , onetimeauth _ bytes ) ; length + = auth _ bytes ;
i _ encryptor encryptor = encryptor _ factory . get _ encryptor ( server . method , server . password , server . one _ time _ auth ) ; byte [ ] data _ in = new byte [ length - NUM + iv _ encryptor . onetimeauth _ bytes ] ;
byte [ ] data _ out = new byte [ length - NUM + NUM + iv _ encryptor . onetimeauth _ bytes ] ;
encryptor . encrypt ( data _ in , length - NUM , data _ out , out outlen , true ) ; remote . send _ to ( data _ out , outlen , socket _ flags . none , remote _ end _ point ) ;


this . client _ size = new system . drawing . size ( NUM , NUM ) ;

set _ config _ to _ ui ( modified _ hotkey _ config ) ; } private void set _ config _ to _ ui ( hotkey _ config config )
if ( ! register _ all _ hotkeys ( ) )
register _ all _ hotkeys ( ) ; } private bool register _ all _ hotkeys ( )

} }
running _ port = get _ free _ port ( configuration . is _ i _ pv _ enabled ) ;
privoxy _ config = configuration . is _ i _ pv _ enabled ? privoxy _ config . replace ( STR , configuration . share _ over _ lan ? STR : STR ) . replace ( STR , STR ) : privoxy _ config . replace ( STR , configuration . share _ over _ lan ? STR : STR ) . replace ( STR , STR ) ;
private int get _ free _ port ( bool is _ i _ pv = false )
tcp _ listener l = new tcp _ listener ( is _ i _ pv ? ip _ address . i _ pv _ loopback : ip _ address . loopback , 0 ) ;
public end _ point remote _ end _ point ;
tcp _ socket = new socket ( config . is _ i _ pv _ enabled ? address _ family . inter _ network : address _ family . inter _ network , socket _ type . stream , protocol _ type . tcp ) ; udp _ socket = new socket ( config . is _ i _ pv _ enabled ? address _ family . inter _ network : address _ family . inter _ network , socket _ type . dgram , protocol _ type . udp ) ;
? new ip _ end _ point ( config . is _ i _ pv _ enabled ? ip _ address . i _ pv _ any : ip _ address . any , config . local _ port ) : new ip _ end _ point ( config . is _ i _ pv _ enabled ? ip _ address . i _ pv _ loopback : ip _ address . loopback , config . local _ port ) ;
udp _ state udp _ state = new udp _ state ( udp _ socket ) ;
end _ point remote _ end _ point = new ip _ end _ point ( get _ ip _ address ( ) , 0 ) ;
end _ point remote _ end _ point = new ip _ end _ point ( get _ ip _ address ( ) , 0 ) ;
var socket = state . socket ; try { int bytes _ read = socket . end _ receive _ from ( ar , ref state . remote _ end _ point ) ;
if ( service . handle ( state . buffer , bytes _ read , socket , state ) )

public string get _ server _ url _ for _ current _ server ( )
remote ? . end _ connect ( async _ result ) ;
remote ? . begin _ send ( buffer , offset , size , socket _ flags , callback , state ) ;
remote ? . begin _ receive ( buffer , offset , size , socket _ flags , callback , state ) ;
remote ? . begin _ send ( buffer , offset , size , socket _ flags , callback , state ) ;
remote ? . begin _ receive ( buffer , offset , size , socket _ flags , callback , state ) ;
remote ? . send _ to ( data _ out , outlen , socket _ flags . none , remote _ end _ point ) ;
remote ? . begin _ receive _ from ( buffer , 0 , buffer . length , 0 , ref remote _ end _ point , new async _ callback ( recv _ from _ callback ) , null ) ;
local ? . send _ to ( send _ buf , outlen + NUM , 0 , local _ end _ point ) ;

using ( auto _ reset _ event output _ wait _ handle = new auto _ reset _ event ( false ) ) using ( auto _ reset _ event error _ wait _ handle = new auto _ reset _ event ( false ) )
using ( var process = new process ( ) )
process . start _ info . file _ name = utils . get _ temp _ path ( STR ) ; process . start _ info . arguments = arguments ; process . start _ info . working _ directory = utils . get _ temp _ path ( ) ; process . start _ info . window _ style = process _ window _ style . hidden ; process . start _ info . use _ shell _ execute = false ; process . start _ info . redirect _ standard _ error = true ; process . start _ info . redirect _ standard _ output = true ;  process . start _ info . standard _ output _ encoding = encoding . unicode ; process . start _ info . standard _ error _ encoding = encoding . unicode ; process . start _ info . create _ no _ window = true ; string _ builder output = new string _ builder ( ) ; string _ builder error = new string _ builder ( ) ; process . output _ data _ received + = ( sender , e ) = >
if ( e . data = = null ) { output _ wait _ handle . set ( ) ; } else { output . append _ line ( e . data ) ; } } ; process . error _ data _ received + = ( sender , e ) = > { if ( e . data = = null ) { error _ wait _ handle . set ( ) ; } else { error . append _ line ( e . data ) ; } } ; process . start ( ) ; process . begin _ error _ read _ line ( ) ; process . begin _ output _ read _ line ( ) ; process . wait _ for _ exit ( ) ; var stderr = error . to _ string ( ) ; var stdout = output . to _ string ( ) ; var exit _ code = process . exit _ code ; if ( exit _ code ! = ( int ) ret _ errors . ret _ no _ error ) { throw new proxy _ exception ( stderr ) ;
if ( arguments = = STR ) { if ( stdout . is _ null _ or _ white _ space ( ) | | stdout . is _ null _ or _ empty ( ) ) {  throw new proxy _ exception ( STR ) ; } query _ str = stdout ; }
menu _ item item = new menu _ item ( strategy . name ) ;
item . tag = i - strategy _ count ;
get { return n . get _ string ( STR ) ; }
get { return STR ; } } public void reload _ servers ( ) {
* tcp _ relay will call this when latency of a server detected * / void update _ latency ( server server , time _ span latency ) ;  * tcp _ relay will call this when reading from a server * /
this . remarks _ text _ box . location = new system . drawing . point ( NUM , NUM ) ;
this . label . location = new system . drawing . point ( NUM , NUM ) ;
this . label . location = new system . drawing . point ( NUM , NUM ) ;
this . label . location = new system . drawing . point ( NUM , NUM ) ;
this . proxy _ port _ text _ box . location = new system . drawing . point ( NUM , NUM ) ;
this . label . location = new system . drawing . point ( NUM , NUM ) ;
this . label . location = new system . drawing . point ( NUM , NUM ) ;
this . ip _ text _ box . location = new system . drawing . point ( NUM , NUM ) ;
this . server _ port _ text _ box . location = new system . drawing . point ( NUM , NUM ) ;
this . password _ text _ box . location = new system . drawing . point ( NUM , NUM ) ;
this . label . location = new system . drawing . point ( NUM , NUM ) ;
this . encryption _ select . location = new system . drawing . point ( NUM , NUM ) ;
this . panel . location = new system . drawing . point ( NUM , NUM ) ;
this . ok _ button . location = new system . drawing . point ( NUM , NUM ) ;
this . my _ cancel _ button . location = new system . drawing . point ( NUM , NUM ) ;
this . servers _ item , this . menu _ item , this . auto _ startup _ item ,
this . edit _ pac _ file _ item ,


this . share _ over _ lan _ item . index = NUM ;
this . servers _ item . index = 1 ;
this . delete _ button . location = new system . drawing . point ( NUM , NUM ) ;
this . add _ button . location = new system . drawing . point ( NUM , NUM ) ;
this . server _ group _ box . location = new system . drawing . point ( NUM , NUM ) ;
this . server _ group _ box . size = new system . drawing . size ( NUM , NUM ) ;
this . servers _ list _ box . location = new system . drawing . point ( NUM , NUM ) ;
this . menu _ item . index = 2 ; this . menu _ item . text = STR ;
private void auto _ startup _ item _ click ( object sender , event _ args e ) { auto _ startup _ item . checked = ! auto _ startup _ item . checked ; if ( ! auto _ startup . set ( auto _ startup _ item . checked ) ) {


using system ;
this . config = config ; try
web _ client http = create _ web _ client ( ) ; http . download _ string _ completed + = http _ download _ string _ completed ; http . download _ string _ async ( new uri ( update _ url ) ) ;
catch ( exception ex )
logging . log _ useful _ exception ( ex ) ;

list < asset > asserts = new list < asset > ( ) ;
asset ass = new asset ( ) ; ass . parse ( asset ) ; if ( ass . is _ new _ version ( version ) )
asserts . add ( ass ) ;
if ( asserts . count ! = 0 )
sort _ by _ versions ( asserts ) ; asset asset = asserts [ asserts . count - 1 ] ;
latest _ version _ url = asset . browser _ download _ url ; latest _ version _ number = asset . version ; latest _ version _ name = asset . name ; start _ download ( ) ; } else if ( check _ update _ completed ! = null ) { check _ update _ completed ( this , new event _ args ( ) ) ; } } catch ( exception ex ) { logging . log _ useful _ exception ( ex ) ; } } private void start _ download ( ) { try { string temppath = utils . get _ temp _ path ( ) ; latest _ version _ local _ name = path . combine ( temppath , latest _ version _ name ) ; web _ client http = create _ web _ client ( ) ; http . download _ file _ completed + = http _ download _ file _ completed ; http . download _ file _ async ( new uri ( latest _ version _ url ) , latest _ version _ local _ name ) ; } catch ( exception ex ) { logging . log _ useful _ exception ( ex ) ; } } private void http _ download _ file _ completed ( object sender , system . component _ model . async _ completed _ event _ args e ) { try { if ( e . error ! = null ) { logging . log _ useful _ exception ( e . error ) ; return ;
logging . log _ useful _ exception ( ex ) ; } } private web _ client create _ web _ client ( ) { web _ client http = new web _ client ( ) ; http . headers . add ( STR , user _ agent ) ; http . proxy = new web _ proxy ( ip _ address . loopback . to _ string ( ) , config . local _ port ) ; return http ; } private void sort _ by _ versions ( list < asset > asserts ) { asserts . sort ( new version _ comparer ( ) ) ; } class asset { public bool prerelease ; public string name ; public string version ; public string browser _ download _ url ; public bool is _ new _ version ( string current _ version ) { if ( prerelease ) { return false ; } if ( version = = null ) { return false ; } return compare _ version ( version , current _ version ) > 0 ; } public void parse ( json _ object asset ) { name = ( string ) asset [ STR ] ; browser _ download _ url = ( string ) asset [ STR ] ; version = parse _ version _ from _ url ( browser _ download _ url ) ; prerelease = browser _ download _ url . index _ of ( STR ) > = 0 ; } private static string parse _ version _ from _ url ( string url ) { match match = regex . match ( url , STR , regex _ options . ignore _ case ) ; if ( match . success ) { if ( match . groups . count = = 2 ) { return match . groups [ 1 ] . value ; } } return null ; } public static int compare _ version ( string l , string r ) { var ls = l . split ( '.' ) ; var rs = r . split ( '.' ) ; for ( int i = 0 ; i < math . max ( ls . length , rs . length ) ; i + + ) { int lp = ( i < ls . length ) ? int . parse ( ls [ i ] ) : 0 ; int rp = ( i < rs . length ) ? int . parse ( rs [ i ] ) : 0 ; if ( lp ! = rp ) { return lp - rp ; } } return 0 ; } } class version _ comparer : i _ comparer < asset > {  public int compare ( asset x , asset y ) { return asset . compare _ version ( x . version , y . version ) ;
public void send _ response ( byte [ ] first _ packet , int length , socket socket , bool use _ socks )
string proxy = get _ pac _ address ( first _ packet , length , local _ end _ point , use _ socks ) ;
private string get _ pac _ address ( byte [ ] request _ buf , int length , ip _ end _ point local _ end _ point , bool use _ socks )
return ( use _ socks ? STR : STR ) + local _ end _ point . address + STR + this . config . local _ port + STR ;
polipo _ config = polipo _ config . replace ( STR , running _ port . to _ string ( ) ) ;
{ pac _ url = $ STR ; }
configuration config = configuration . load ( ) ; list < key _ value _ pair < string , string > > server _ datas = config . configs . select (
new key _ value _ pair < string , string > ( server . get _ url ( config . generate _ legacy _ url ) , server . to _ string ( ) )
int select _ index = server _ datas . find _ index ( server _ data = > server _ data . key . starts _ with ( code ) ) ;
public string get _ url ( bool legacy _ url = false ) { string tag = string . empty ; string url = string . empty ; if ( legacy _ url & & string . is _ null _ or _ white _ space ( plugin ) ) {  string parts = $ STR ; string base = convert . to _ base _ string ( encoding . ut . get _ bytes ( parts ) ) ; url = base ; } else {  string parts = $ STR ; string base = convert . to _ base _ string ( encoding . ut . get _ bytes ( parts ) ) ; string websafe _ base = base . replace ( '+' , '-' ) . replace ( '/' , '_' ) . trim _ end ( '=' ) ; url = string . format ( STR , websafe _ base , formal _ host _ name , server _ port ) ; if ( ! plugin . is _ null _ or _ white _ space ( ) ) {
string plugin _ query = STR + http _ utility . url _ encode ( plugin _ part , encoding . ut ) ; url + = plugin _ query ; } } if ( ! remarks . is _ null _ or _ empty ( ) ) { tag = $ STR ; } return $ STR ;
public line _ reader ( wrapped _ socket socket , byte [ ] first _ packge , int index , int length ,
encoding encoding , string delimiter , int max _ line _ bytes ,

if ( max _ line _ bytes < length )
throw new argument _ exception ( STR , nameof ( max _ line _ bytes ) ) ;
if ( max _ line _ bytes < delimiter _ bytes . length )
throw new argument _ exception ( STR , nameof ( max _ line _ bytes ) ) ;
line _ buffer = new byte [ max _ line _ bytes ] ;
array . copy ( first _ packge , index , line _ buffer , 0 , length ) ;
socket . begin _ receive ( line _ buffer , 0 , max _ line _ bytes , 0 , receive _ callback , 0 ) ;
public line _ reader ( wrapped _ socket socket , func < string , object , bool > on _ line _ read , action < exception , object > on _ exception , action < byte [ ] , int , int , object > on _ finish , encoding encoding , string delimiter , int max _ line _ bytes , object state ) : this ( socket , null , 0 , 0 , on _ line _ read , on _ exception , on _ finish , encoding , delimiter , max _ line _ bytes , state )
sysproxy . set _ ie _ proxy ( true , true , STR + config . local _ port . to _ string ( ) , STR ) ;
ss _ url _ association = registry . current _ user . create _ sub _ key ( ss _ url _ reg _ key , registry _ key _ permission _ check . read _ write _ sub _ tree ) ;

configuration config = simple _ json . simple _ json . deserialize _ object < configuration > ( config _ content , new json _ serializer _ strategy ( ) ) ;
qr _ code code = z _ xing . qr _ code . internal . encoder . encode ( qr _ text , error _ correction _ level . m ) ; byte _ matrix m = code . matrix ; int block _ size = math . max ( NUM / m . height , 1 ) ; bitmap draw _ area = new bitmap ( ( m . height * block _ size ) , ( m . height * block _ size ) ) ;
for ( int row = 0 ; row < m . height ; row + + )
for ( int col = 0 ; col < m . height ; col + + )
if ( m [ row , col ] ! = 0 )
return new menu _ item ( n . get _ string ( text ) , click ) ;
return new menu _ item ( n . get _ string ( text ) , items ) ;
this . seperator _ item = new menu _ item ( STR ) ,
new menu _ item ( STR ) ,
new menu _ item ( STR ) ,
new menu _ item ( STR ) ,
public static list < string > parse _ base _ to _ valid _ list ( string response )
arguments = $ STR ;
arguments = $ STR ;

this . enable _ item . text = n . get _ string ( STR ) ;
this . mode _ item . text = n . get _ string ( STR ) ;
this . pac _ mode _ item . text = n . get _ string ( STR ) ;
this . global _ mode _ item . text = n . get _ string ( STR ) ;
this . servers _ item . text = n . get _ string ( STR ) ;
this . config _ item . text = n . get _ string ( STR ) ;
this . auto _ startup _ item . text = n . get _ string ( STR ) ;
this . share _ over _ lan _ item . text = n . get _ string ( STR ) ;
this . edit _ pac _ file _ item . text = n . get _ string ( STR ) ;
this . qr _ code _ item . text = n . get _ string ( STR ) ;
this . show _ log _ item . text = n . get _ string ( STR ) ;
this . about _ item . text = n . get _ string ( STR ) ;
this . quit _ item . text = n . get _ string ( STR ) ;
this . remarks _ label = new system . windows . forms . label ( ) ; this . ip _ label = new system . windows . forms . label ( ) ; this . server _ port _ label = new system . windows . forms . label ( ) ;
this . proxy _ port _ label = new system . windows . forms . label ( ) ; this . password _ label = new system . windows . forms . label ( ) ;
this . encryption _ label = new system . windows . forms . label ( ) ;
this . table _ layout _ panel . controls . add ( this . remarks _ label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . ip _ label , 0 , 0 ) ; this . table _ layout _ panel . controls . add ( this . server _ port _ label , 0 , 1 ) ;
this . table _ layout _ panel . controls . add ( this . proxy _ port _ label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . password _ label , 0 , 2 ) ;
this . table _ layout _ panel . controls . add ( this . encryption _ label , 0 , NUM ) ;
this . remarks _ label . anchor = system . windows . forms . anchor _ styles . right ; this . remarks _ label . auto _ size = true ; this . remarks _ label . location = new system . drawing . point ( NUM , NUM ) ; this . remarks _ label . name = STR ; this . remarks _ label . size = new system . drawing . size ( NUM , NUM ) ; this . remarks _ label . tab _ index = NUM ; this . remarks _ label . text = STR ;    this . ip _ label . anchor = system . windows . forms . anchor _ styles . right ; this . ip _ label . auto _ size = true ; this . ip _ label . location = new system . drawing . point ( NUM , NUM ) ; this . ip _ label . name = STR ; this . ip _ label . size = new system . drawing . size ( NUM , NUM ) ; this . ip _ label . tab _ index = 0 ; this . ip _ label . text = STR ;    this . server _ port _ label . anchor = system . windows . forms . anchor _ styles . right ; this . server _ port _ label . auto _ size = true ; this . server _ port _ label . location = new system . drawing . point ( NUM , NUM ) ; this . server _ port _ label . name = STR ; this . server _ port _ label . size = new system . drawing . size ( NUM , NUM ) ; this . server _ port _ label . tab _ index = 1 ; this . server _ port _ label . text = STR ;
this . proxy _ port _ label . anchor = system . windows . forms . anchor _ styles . right ; this . proxy _ port _ label . auto _ size = true ; this . proxy _ port _ label . location = new system . drawing . point ( NUM , NUM ) ; this . proxy _ port _ label . name = STR ; this . proxy _ port _ label . size = new system . drawing . size ( NUM , NUM ) ; this . proxy _ port _ label . tab _ index = NUM ; this . proxy _ port _ label . text = STR ;    this . password _ label . anchor = system . windows . forms . anchor _ styles . right ; this . password _ label . auto _ size = true ; this . password _ label . location = new system . drawing . point ( NUM , NUM ) ; this . password _ label . name = STR ; this . password _ label . size = new system . drawing . size ( NUM , NUM ) ; this . password _ label . tab _ index = 2 ; this . password _ label . text = STR ;
private system . windows . forms . label ip _ label ; private system . windows . forms . label server _ port _ label ; private system . windows . forms . label password _ label ; private system . windows . forms . label proxy _ port _ label ;
private system . windows . forms . label encryption _ label ;
var curr _ index = modified _ configuration . configs . index _ of ( curr _ server ) ; modified _ configuration . configs . insert ( curr _ index + 1 , curr _ server ) ;
servers _ list _ box . selected _ index = curr _ index + 1 ;
file _ manager . uncompress _ file ( dll _ path , resources . libsscrypto _ dll ) ; load _ library ( dll _ path ) ;
catch ( io _ exception ) { } catch ( exception e )

internal static byte [ ] libsscrypto _ dll {
object obj = resource _ manager . get _ object ( STR , resource _ culture ) ;
file _ manager . uncompress _ file ( dll _ path , resources . libsscrypto _ dll ) ; load _ library ( dll _ path ) ;
catch ( io _ exception ) { } catch ( exception e )

top _ most _ trigger _ lock = false ; wrap _ text _ trigger _ lock = true ; log _ message _ text _ box . word _ wrap = wrap _ text _ menu _ item . checked = wrap _ text _ check _ box . checked = wrap _ text _ trigger ; wrap _ text _ trigger _ lock = false ; toolbar _ flow _ layout _ panel . visible = show _ toolbar _ menu _ item . checked = toolbar _ trigger ;



if ( keymap . any ( v = > v . value = = cb ) )
hotkey = keymap . first ( v = > v . value = = cb ) . key ;
else

if ( ! register _ all _ hotkeys ( modified _ hotkey _ config ) )
modified _ hotkey _ config = get _ config _ from _ ui ( ) ; register _ all _ hotkeys ( modified _ hotkey _ config ) ; } private bool register _ all _ hotkeys ( hotkey _ config hotkey _ config ) { return try _ reg _ hotkey _ from _ string ( hotkey _ config . switch _ system _ proxy , STR , switch _ system _ proxy _ label ) & & try _ reg _ hotkey _ from _ string ( hotkey _ config . switch _ system _ proxy _ mode , STR , switch _ proxy _ mode _ label ) & & try _ reg _ hotkey _ from _ string ( hotkey _ config . switch _ allow _ lan , STR , switch _ allow _ lan _ label ) & & try _ reg _ hotkey _ from _ string ( hotkey _ config . show _ logs , STR , show _ logs _ label ) & & try _ reg _ hotkey _ from _ string ( hotkey _ config . server _ move _ up , STR , server _ move _ up _ label ) & & try _ reg _ hotkey _ from _ string ( hotkey _ config . server _ move _ down , STR , server _ move _ down _ label ) ; } private bool try _ reg _ hotkey _ from _ string ( string hotkey _ str , string callback _ name , label indicator = null ) { var callback = hotkey _ callbacks . get _ callback ( callback _ name ) ; if ( callback = = null ) { throw new exception ( $ STR ) ; } var callback = callback as hot _ keys . hot _ key _ call _ back _ handler ; if ( hotkey _ str . is _ null _ or _ empty ( ) ) {   unreg _ prev _ hotkey ( callback ) ; return true ; } else { var hotkey = hot _ keys . str _ hot _ key ( hotkey _ str ) ; if ( hotkey = = null ) {  message _ box . show ( string . format ( n . get _ string ( STR ) , hotkey _ str ) ) ; return false ; } else { bool reg _ result = ( try _ reg _ hotkey ( hotkey , callback ) ) ; if ( indicator ! = null ) { indicator . back _ color = reg _ result ? color . green : color . yellow ; } return reg _ result ; } } } private bool try _ reg _ hotkey ( global _ hot _ key . hot _ key hotkey , hot _ keys . hot _ key _ call _ back _ handler callback ) { unreg _ prev _ hotkey ( callback ) ; return hot _ keys . register ( hotkey , callback ) ;







public tcp _ relay ( shadowsocks _ controller controller , configuration conf )
public i _ proxy remote ;
private bool proxy _ connected ; private bool dest _ connected ;
logging . debug ( remote . local _ end _ point , remote . dest _ end _ point , recv _ size , STR ) ;
logging . debug ( remote . local _ end _ point , remote . dest _ end _ point , recv _ size , STR ) ;
remote = new direct _ connect ( ) ; proxy _ timer proxy _ timer = new proxy _ timer ( NUM ) ; proxy _ timer . auto _ reset = false ; proxy _ timer . elapsed + = proxy _ connect _ timer _ elapsed ; proxy _ timer . enabled = true ; proxy _ timer . dest _ end _ point = remote _ ep ; proxy _ timer . server = server ; proxy _ connected = false ;  remote . begin _ connect _ proxy ( remote _ ep , new async _ callback ( proxy _ connect _ callback ) , proxy _ timer ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; } } private void proxy _ connect _ timer _ elapsed ( object sender , elapsed _ event _ args e ) { if ( proxy _ connected | | dest _ connected ) { return ; } var ep = ( ( proxy _ timer ) sender ) . dest _ end _ point ; logging . info ( $ STR ) ; remote . close ( ) ; retry _ connect ( ) ; } private void proxy _ connect _ callback ( i _ async _ result ar ) { server server = null ; if ( closed ) { return ; } try { proxy _ timer timer = ( proxy _ timer ) ar . async _ state ; var dest _ ep = timer . dest _ end _ point ; server = timer . server ; timer . elapsed - = proxy _ connect _ timer _ elapsed ; timer . enabled = false ; timer . dispose ( ) ;  remote . end _ connect _ proxy ( ar ) ; proxy _ connected = true ; logging . debug ( $ STR ) ;
connect _ timer . elapsed + = dest _ connect _ timer _ elapsed ;
dest _ connected = false ;
remote . begin _ connect _ dest ( dest _ ep , new async _ callback ( connect _ callback ) , connect _ timer ) ; } catch ( argument _ exception ) { } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; retry _ connect ( ) ; } } private void dest _ connect _ timer _ elapsed ( object sender , elapsed _ event _ args e ) { if ( dest _ connected )
timer . elapsed - = dest _ connect _ timer _ elapsed ;
remote . end _ connect _ dest ( ar ) ; dest _ connected = true ; logging . debug ( $ STR ) ;
public int key _ size ; public int iv _ size ; public int type ; public string inner _ lib _ name ;   public encryptor _ info ( string inner _ lib _ name , int key _ size , int iv _ size , int type )
this . key _ size = key _ size ; this . iv _ size = iv _ size ; this . type = type ; this . inner _ lib _ name = inner _ lib _ name ; } public encryptor _ info ( int key _ size , int iv _ size , int type ) { this . key _ size = key _ size ; this . iv _ size = iv _ size ; this . type = type ; this . inner _ lib _ name = string . empty ;
using ( mutex mutex = new mutex ( false , STR + assembly . get _ executing _ assembly ( ) . get _ type ( ) . guid . to _ string ( ) ) )
if ( ! mutex . wait _ one ( 0 , false ) ) { process [ ] old _ processes = process . get _ processes _ by _ name ( STR ) ; if ( old _ processes . length > 0 ) { process old _ process = old _ processes [ 0 ] ; } message _ box . show ( STR ) ; return ; } string temp _ path = path . get _ temp _ path ( ) ; string dll _ path = temp _ path + STR ; try { file _ manager . uncompress _ file ( dll _ path , resources . polarssl _ dll ) ; } catch ( io _ exception e ) { console . write _ line ( e . to _ string ( ) ) ; } load _ library ( dll _ path ) ; try { file _ stream fs = new file _ stream ( STR , file _ mode . append ) ; text _ writer tmp = console . out ; stream _ writer sw = new stream _ writer ( fs ) ; sw . auto _ flush = true ; console . set _ out ( sw ) ; console . set _ error ( sw ) ; } catch ( io _ exception e ) { console . write _ line ( e . to _ string ( ) ) ; } application . enable _ visual _ styles ( ) ; application . set _ compatible _ text _ rendering _ default ( false ) ; shadowsocks _ controller controller = new shadowsocks _ controller ( ) ;  application . run ( new config _ form ( controller ) ) ;

series . color = system . drawing . color . from _ argb ( NUM , NUM , 0 ) ;
series . color = system . drawing . color . from _ argb ( NUM , NUM , NUM ) ;

protected uint counter = 0 ; protected byte [ ] key _ buffer = null ;

protected int ss _ onetimeauth ( byte [ ] auth , byte [ ] msg , int msg _ len )
buffer . block _ copy ( encrypt _ iv , 0 , auth _ bytes , 0 , iv _ len ) ; buffer . block _ copy ( key , 0 , auth _ bytes , iv _ len , key _ len ) ; sodium . crypto _ generichash ( auth _ key , onetimeauth _ keybytes , auth _ bytes , ( ulong ) ( iv _ len + key _ len ) , null , 0 ) ;
protected void ss _ gen _ hash ( byte [ ] buf , ref int offset , ref int len , int buf _ size ) { int size = len + auth _ bytes ;
byte [ ] tmp = new byte [ len ] ; buffer . block _ copy ( buf , offset , tmp , 0 , len ) ; sodium . crypto _ generichash ( hash , hash _ bytes , tmp , ( ulong ) len , key _ buffer , ( uint ) key _ buffer . length ) ; buffer . block _ copy ( buf , offset , buf , offset + auth _ bytes , len ) ; buffer . block _ copy ( hash , 0 , buf , offset + clen _ bytes , hash _ bytes ) ; byte [ ] clen = bit _ converter . get _ bytes ( ( ushort ) ip _ address . host _ to _ network _ order ( ( short ) len ) ) ; buffer . block _ copy ( clen , 0 , buf , offset , clen _ bytes ) ; counter + + ; len + = auth _ bytes ; offset + = len ;
splash . location = new point ( 0 , 0 ) ;
splash . target _ rect = new rectangle ( ( int ) min _ x , ( int ) min _ y , ( int ) max _ x - ( int ) min _ x , ( int ) max _ y - ( int ) min _ y ) ; splash . size = new size ( full _ image . width , full _ image . height ) ;
public class qr _ code _ splash _ form : per _ pixel _ alpha _ form
this . load + = qr _ code _ splash _ form _ load ; this . auto _ scale _ mode = system . windows . forms . auto _ scale _ mode . none ; this . back _ color = system . drawing . color . white ; this . client _ size = new system . drawing . size ( NUM , NUM ) ; this . control _ box = false ; this . form _ border _ style = system . windows . forms . form _ border _ style . none ; this . maximize _ box = false ; this . minimize _ box = false ; this . name = STR ; this . show _ icon = false ; this . show _ in _ taskbar = false ; this . size _ grip _ style = system . windows . forms . size _ grip _ style . hide ; this . start _ position = system . windows . forms . form _ start _ position . manual ; this . top _ most = true ;
set _ style ( control _ styles . supports _ transparent _ back _ color , true ) ; this . back _ color = color . transparent ; animation _ step = 0 ; flash _ step = 0 ;  x = 0 ; y = 0 ; w = width ; h = height ;
timer . interval = ( int ) ( animation _ time * NUM / animation _ steps ) ;
if ( ! file . exists ( pac _ file ) )
file . write _ all _ text ( pac _ file , resources . proxy _ pac _ txt ) ;
return pac _ file ;
if ( ! file . exists ( user _ rule _ file ) )

return resources . proxy _ pac _ txt ;
string geosite _ url = geosite _ url ; string group = STR ; bool blacklist = true ; if ( ! string . is _ null _ or _ white _ space ( config . geosite _ group ) )
group = config . geosite _ group ; blacklist = config . geosite _ blacklist _ mode ;
if ( ! string . is _ null _ or _ white _ space ( config . geosite _ url ) ) { logger . info ( STR ) ; geosite _ url = config . geosite _ url ; } logger . info ( $ STR ) ;
bool pac _ file _ changed = merge _ and _ write _ pac _ file ( group , blacklist ) ;
http . download _ data _ async ( new uri ( geosite _ url ) ) ;
public static bool merge _ and _ write _ pac _ file ( string group , bool blacklist )
i _ list < domain _ object > domains = geosites [ group ] ; string abp _ content = merge _ pac _ file ( domains , blacklist ) ;
userrule _ lines = pre _ process _ gfw _ list ( userrules _ string ) ;
list < string > gfw _ lines = geosite _ to _ gfw _ list ( domains , blacklist ) ;
private static list < string > pre _ process _ gfw _ list ( string content )
private static list < string > geosite _ to _ gfw _ list ( i _ list < domain _ object > domains , bool blacklist )
return blacklist ? geosite _ to _ gfw _ list _ black ( domains ) : geosite _ to _ gfw _ list _ white ( domains ) ; } private static list < string > geosite _ to _ gfw _ list _ black ( i _ list < domain _ object > domains ) { list < string > ret = new list < string > ( domains . count + NUM ) ;
ret . add ( domain ) ;
public pac _ daemon ( configuration config )
geosite _ updater . merge _ and _ write _ pac _ file ( config . geosite _ group , config . geosite _ blacklist _ mode ) ;
public static registry _ key open _ reg _ key ( string name , bool writable , registry _ hive hive = registry _ hive . current _ user )
registry _ key user _ key = registry _ key . open _ base _ key ( hive ,
interlocked . add ( ref inbound _ counter , n ) ;
interlocked . add ( ref outbound _ counter , n ) ;
config = configuration . load ( ) ;
polipo _ runner . start ( config . get _ current _ server ( ) ) ; local = new local ( config . get _ current _ server ( ) ) ;
public void save _ config ( configuration new _ config )
configuration . save ( new _ config ) ;
polipo _ runner . start ( config . get _ current _ server ( ) ) ; local = new local ( config . get _ current _ server ( ) ) ;
public server get _ current _ server ( ) { return config . get _ current _ server ( ) ; } public configuration get _ configuration ( )
server server = controller . get _ current _ server ( ) ; text _ box . text = server . server ; text _ box . text = server . server _ port . to _ string ( ) ; text _ box . text = server . password ; text _ box . text = server . local _ port . to _ string ( ) ; combo _ box . text = server . method = = null ? STR : server . method ; enable _ item . checked = controller . get _ configuration ( ) . enabled ;
if ( ! controller . get _ configuration ( ) . is _ default )
server server = new server
method = combo _ box . text
var location = m . groups [ 2 ] . value ; var locs = location . split ( ':' ) ; target _ host = locs [ 0 ] ; if ( locs . length > 1 )
if ( ! int . try _ parse ( locs [ 1 ] , out target _ port ) ) { throw new exception ( STR + line ) ; } } else { target _ port = NUM ;
var location = line . substring ( NUM ) . trim ( ) ; var locs = location . split ( ':' ) ; target _ host = locs [ 0 ] ; if ( locs . length > 1 )
if ( ! int . try _ parse ( locs [ 1 ] , out target _ port ) ) { throw new exception ( STR + line ) ; } } else { target _ port = NUM ;
switch ( command ) { case cmd _ connect :
break ; case cmd _ udp _ assoc :
break ; case cmd _ bind : default : logging . debug ( STR + command ) ; close ( ) ; break ;



catch ( argument _ exception ae ) { message _ box . show ( STR + ae . to _ string ( ) ) ;
catch ( exception e ) { logging . log _ useful _ exception ( e ) ;
using system _ runtime _ interop _ services ;
internal static class remote _ access _ service
using system ;


public static readonly string pac _ file = STR ; public static readonly string user _ rule _ file = STR ; public static readonly string user _ abp _ file = STR ;
if ( file . exists ( pac _ server . user _ rule _ file ) )
string local = file . read _ all _ text ( pac _ server . user _ rule _ file , encoding . ut ) ;
if ( file . exists ( pac _ server . user _ abp _ file ) )
abp _ content = file . read _ all _ text ( pac _ server . user _ abp _ file , encoding . ut ) ;
string original = file . read _ all _ text ( pac _ server . pac _ file , encoding . ut ) ;
file . write _ all _ text ( pac _ server . pac _ file , abp _ content , encoding . ut ) ;
try
var reply = await ping . send _ task _ async ( server . server , timeout ) ; ret . add ( new list < key _ value _ pair < string , string > > { new key _ value _ pair < string , string > ( STR , timestamp ) , new key _ value _ pair < string , string > ( STR , server . friendly _ name ( ) ) , new key _ value _ pair < string , string > ( STR , reply ? . status . to _ string ( ) ) , new key _ value _ pair < string , string > ( STR , reply ? . roundtrip _ time . to _ string ( ) )  } ) ; } catch ( ping _ exception e ) { logging . log _ useful _ exception ( e ) ; }
if ( md _ ret ( input , ( uint ) input . length , output ) ! = 0 ) throw new system . exception ( STR ) ;
public static extern int md _ ret ( byte [ ] input , uint ilen , byte [ ] output ) ;
class local : listener . service

} public bool good _ for _ me ( byte [ ] first _ packet , int length ) { return true ; } public void handle ( byte [ ] first _ packet , int length , socket socket ) {     socket . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; handler handler = new handler ( ) ; handler . connection = socket ; server server = config . get _ current _ server ( ) ; handler . encryptor = encryptor _ factory . get _ encryptor ( server . method , server . password ) ; handler . server = server ; handler . start ( first _ packet , length ) ;
int bytes _ read = first _ packet _ length ;
if ( first _ packet [ 0 ] ! = NUM )
if ( listener ! = null ) { listener . stop ( ) ;
local local = new local ( config ) ; list < listener . service > services = new list < listener . service > ( ) ; services . add ( local ) ; listener = new listener ( services ) ; listener . start ( config ) ;
this . value _ label . size = new system . drawing . size ( NUM , NUM ) ;
const string api = STR ; const string alternative _ api = STR ; var result = await get _ info _ from _ api ( api ) ; if ( result ! = null ) return result ; result = await get _ info _ from _ api ( alternative _ api ) ; if ( result ! = null ) return result ; return new data _ list
return null ;
if ( ! simple _ json . simple _ json . try _ deserialize _ object ( json _ string , out obj ) ) return null ;
if ( country = = null | | city = = null | | isp = = null ) return null ; return new data _ list { new data _ unit ( state . geolocation , $ STR ) , new data _ unit ( state . isp , isp ) } ;
private void load _ chart _ data ( )
i _ enumerable < i _ grouping < int , availability _ statistics . raw _ statistics _ data > > data _ groups ; if ( all _ mode . checked )
data _ groups = statistics . group _ by ( data = > data . timestamp . day _ of _ year ) ; statistics _ chart . chart _ areas [ STR ] . axis _ x . label _ style . format = STR ; statistics _ chart . chart _ areas [ STR ] . axis . label _ style . format = STR ;
load _ chart _ data ( ) ; } private void chart _ mode _ selector _ enter ( object sender , event _ args e ) { } private void day _ mode _ checked _ changed ( object sender , event _ args e ) { load _ chart _ data ( ) ; } private void all _ mode _ checked _ changed ( object sender , event _ args e ) { load _ chart _ data ( ) ;

this . chart _ mode _ selector . suspend _ layout ( ) ;

this . chart _ mode _ selector . resume _ layout ( false ) ; this . chart _ mode _ selector . perform _ layout ( ) ;
create _ menu _ item ( STR , new event _ handler ( this . scan _ qr _ code _ item _ click ) ) , create _ menu _ item ( STR , new event _ handler ( this . import _ url _ item _ click ) )
registry . set _ value ( STR , pac _ url ) ;
if ( file . exists ( update _ checker . latest _ version _ local _ name ) )
process . start ( STR , argument ) ;

private const string statistics _ files _ name = STR ; private const string delimiter = STR ; private const int timeout = NUM ; private const int repeat = NUM ; private const int interval = NUM * NUM * NUM ; private timer timer ; private state state ; private list < server > servers ;
var temppath = path . get _ temp _ path ( ) ;
if ( timer ? . change ( 0 , interval ) ! = null ) return true ; state = new state ( ) ; timer = new timer ( evaluate , state , 0 , interval ) ;
var ping = new ping ( ) ; var state = ( state ) obj ; foreach ( var server in servers )
var timestamp = date _ time . now . to _ string ( STR ) ;
var reply = ping . send ( server . server , timeout ) ; state . data = new list < key _ value _ pair < string , string > > { new key _ value _ pair < string , string > ( STR , timestamp ) , new key _ value _ pair < string , string > ( STR , server . friendly _ name ( ) ) , new key _ value _ pair < string , string > ( STR , reply ? . status . to _ string ( ) ) , new key _ value _ pair < string , string > ( STR , reply ? . roundtrip _ time . to _ string ( ) ) } ;
var data _ line = string . join ( delimiter , data . select ( kv = > kv . value ) . to _ array ( ) ) ;
var header _ line = string . join ( delimiter , data . select ( kv = > kv . key ) . to _ array ( ) ) ; lines = new [ ] { header _ line , data _ line } ;
lines = new [ ] { data _ line } ;
using system ;
internal class tcp _ relay : listener . service
private static readonly logger logger = log _ manager . get _ current _ class _ logger ( ) ; private readonly shadowsocks _ controller controller ;
private readonly configuration config ;
private class async _ session
private class async _ session < t > : async _ session
private static readonly logger logger = log _ manager . get _ current _ class _ logger ( ) ;
private readonly shadowsocks _ controller controller ; private readonly proxy _ config config ; private readonly socket connection ;
private readonly byte [ ] remote _ recv _ buffer = new byte [ buffer _ size ] ;
private readonly byte [ ] connetion _ recv _ buffer = new byte [ buffer _ size ] ;
private readonly byte [ ] remote _ send _ buffer = new byte [ buffer _ size ] ;
private readonly byte [ ] connetion _ send _ buffer = new byte [ buffer _ size ] ;
server = server ;
if ( closed ) { return ; }
} } catch ( exception e ) { error _ close ( e ) ;
if ( closed ) { return ; }
address _ receive _ callback , null ) ; } catch ( exception e ) {  error _ close ( e ) ; } } private void address _ receive _ callback ( i _ async _ result ar ) { if ( closed ) { return ; }
error _ close ( e ) ; } } private void connect _ response _ callback ( i _ async _ result ar )
error _ close ( e ) ;
if ( closed ) { return ; }
object [ ] states = ( object [ ] ) ar . async _ state ;
action on _ success = ( action ) states [ 1 ] ;
} } } catch ( exception e ) { error _ close ( e ) ;
error _ close ( e ) ;
proxy _ timer timer = ( proxy _ timer ) sender ;
i _ proxy proxy = timer . session . remote ;
async _ session < proxy _ timer > session = ( async _ session < proxy _ timer > ) ar . async _ state ;
end _ point dest _ end _ point = timer . dest _ end _ point ; server server = timer . server ;
i _ proxy remote = session . remote ;
error _ close ( e ) ;
server _ timer timer = ( server _ timer ) sender ;
async _ session session = timer . session ;
if ( closed ) { return ; } try { async _ session < server _ timer > session = ( async _ session < server _ timer > ) ar . async _ state ;
i _ proxy remote = session . remote ;
time _ span latency = date _ time . now - start _ connect _ time ;
error _ close ( e ) ;
int size = connection . receive ( connetion _ recv _ buffer , first _ packet _ length , available ,
if ( closed ) { return ; }
error _ close ( e ) ;
if ( closed ) { return ; } try { async _ session session = ( async _ session ) ar . async _ state ;
error _ close ( e ) ;
if ( closed ) { return ; }
async _ session session = ( async _ session ) ar . async _ state ; i _ proxy remote = session . remote ;
error _ close ( e ) ;
object [ ] container = ( object [ ] ) ar . async _ state ; async _ session session = ( async _ session ) container [ 0 ] ; int bytes _ should _ send = ( int ) container [ 1 ] ; int bytes _ sent = connection . end _ send ( ar ) ; int bytes _ remaining = bytes _ should _ send - bytes _ sent ;
private menu _ item seperator _ item ;
private menu _ item seperator _ item ;
private menu _ item seperator _ item ;
this . pac _ mode _ item = create _ menu _ item ( 0 , STR , new system . event _ handler ( this . pac _ mode _ item _ click ) ) ; this . global _ mode _ item = create _ menu _ item ( 1 , STR , new system . event _ handler ( this . global _ mode _ item _ click ) ) ; this . seperator _ item = create _ seperator _ item ( 0 ) ; this . config _ item = create _ menu _ item ( 1 , STR , new system . event _ handler ( this . config _ click ) ) ; this . enable _ item = create _ menu _ item ( 0 , STR , new system . event _ handler ( this . enable _ item _ click ) ) ; this . mode _ item = create _ menu _ group ( 1 , STR , new system . windows . forms . menu _ item [ ] { this . pac _ mode _ item , this . global _ mode _ item } ) ; this . servers _ item = create _ menu _ group ( 2 , STR , new system . windows . forms . menu _ item [ ] { this . seperator _ item , this . config _ item } ) ; this . seperator _ item = create _ seperator _ item ( NUM ) ; this . auto _ startup _ item = create _ menu _ item ( NUM , STR , new system . event _ handler ( this . auto _ startup _ item _ click ) ) ; this . share _ over _ lan _ item = create _ menu _ item ( NUM , STR , new system . event _ handler ( this . share _ over _ lan _ item _ click ) ) ; this . edit _ pac _ file _ item = create _ menu _ item ( NUM , STR , new system . event _ handler ( this . edit _ pac _ file _ item _ click ) ) ; this . seperator _ item = create _ seperator _ item ( NUM ) ; this . qr _ code _ item = create _ menu _ item ( NUM , STR , new system . event _ handler ( this . qr _ code _ item _ click ) ) ; this . show _ log _ item = create _ menu _ item ( NUM , STR , new system . event _ handler ( this . show _ log _ item _ click ) ) ; this . about _ item = create _ menu _ item ( NUM , STR , new system . event _ handler ( this . config _ click ) ) ; this . seperator _ item = create _ seperator _ item ( NUM ) ; this . quit _ item = create _ menu _ item ( NUM , STR , new system . event _ handler ( this . quit _ click ) ) ;
this . seperator _ item ,
this . seperator _ item ,
this . seperator _ item ,

ip _ end _ point remote _ end _ point = ( ip _ end _ point ) udp _ state . remote _ end _ point ; udp _ handler handler = cache . get ( remote _ end _ point ) ; if ( handler = = null ) { handler = new udp _ handler ( socket , config . get _ current _ server ( ) , remote _ end _ point ) ; cache . add ( remote _ end _ point , handler ) ; }
public class udp _ handler
modified _ proxy _ config = controller . get _ configuration _ copy ( ) . proxy ; use _ proxy _ check _ box . checked = modified _ proxy _ config . use _ proxy ; proxy _ server _ text _ box . text = modified _ proxy _ config . proxy _ server ; proxy _ port _ text _ box . text = modified _ proxy _ config . proxy _ port . to _ string ( ) ; proxy _ timeout _ text _ box . text = modified _ proxy _ config . proxy _ timeout . to _ string ( ) ; proxy _ type _ combo _ box . selected _ index = modified _ proxy _ config . proxy _ type ;
if ( modified _ proxy _ config . use _ proxy = use _ proxy _ check _ box . checked )
if ( ! int . try _ parse ( proxy _ port _ text _ box . text , out modified _ proxy _ config . proxy _ port ) )
if ( ! int . try _ parse ( proxy _ timeout _ text _ box . text , out modified _ proxy _ config . proxy _ timeout ) )
modified _ proxy _ config . proxy _ type = proxy _ type _ combo _ box . selected _ index ;
configuration . check _ server ( modified _ proxy _ config . proxy _ server = proxy _ server _ text _ box . text ) ; configuration . check _ port ( modified _ proxy _ config . proxy _ port ) ; configuration . check _ timeout ( modified _ proxy _ config . proxy _ timeout , proxy _ config . max _ proxy _ timeout _ sec ) ;

controller . save _ proxy ( modified _ proxy _ config ) ;
proxy _ server _ text _ box . enabled = proxy _ port _ text _ box . enabled = proxy _ timeout _ text _ box . enabled =
proxy _ server _ text _ box . enabled = proxy _ port _ text _ box . enabled = proxy _ timeout _ text _ box . enabled = proxy _ type _ combo _ box . enabled = false ;
public int running _ port = > running _ port ;

tcp _ listener l = new tcp _ listener ( ip _ address . loopback , 0 ) ; l . start ( ) ; var port = ( ( ip _ end _ point ) l . local _ endpoint ) . port ; l . stop ( ) ; return port ;

using ( var sr = new string _ reader ( local ) )
string rule ; while ( ( rule = sr . read _ line ( ) ) ! = null ) { if ( rule = = STR | | rule [ 0 ] = = '!' | | rule [ 0 ] = = '[' ) continue ; lines . add ( rule ) ; }
list < string > valid _ lines = new list < string > ( ) ; using ( var sr = new string _ reader ( content ) )
string line ; while ( ( line = sr . read _ line ( ) ) ! = null ) { if ( line = = STR | | line [ 0 ] = = '!' | | line [ 0 ] = = '[' ) continue ; valid _ lines . add ( line ) ; }
using system ;



public int best _ left
get
json _ ignore public int best _ top
get
int height = height ; height = ( height > = NUM ) ? height : NUM ; return screen . primary _ screen . working _ area . height - height ;

controller . enable _ proxy ( type , proxy , port ) ;
using system ;
this . table _ layout _ panel . controls . add ( this . table _ layout _ panel , 0 , NUM ) ;
this . table _ layout _ panel . controls . add ( this . table _ layout _ panel , 0 , 2 ) ; this . table _ layout _ panel . controls . add ( this . table _ layout _ panel , 0 , 1 ) ;
this . table _ layout _ panel . row _ count = NUM ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ;
remote . begin _ send ( buffer , offset , size , socket _ flags , callback , state ) ;
remote . begin _ receive ( buffer , offset , size , socket _ flags , callback , state ) ;
remote . shutdown ( how ) ;
remote . dispose ( ) ;
public void enable _ proxy ( int type , string proxy , int port )
const string target _ min _ level _ attribute = STR ; const string logger _ file _ name _ attribute = STR ;

log _ level _ element . set _ attribute ( target _ min _ level _ attribute , log _ level . to _ string ( STR ) ) ;
using system ;





public encryptor ( string method , string password )
if ( method ! = null & & method . to _ lower _ invariant ( ) . equals ( STR ) ) { console . write _ line ( STR ) ; this . method = type _ r ; rc = new r ( ) ; encrypt _ table = rc . encrypt _ initalize ( hash ) ; decrypt _ table = rc . encrypt _ initalize ( hash ) ; } else { console . write _ line ( STR ) ; this . method = type _ table ;  var a = bit _ converter . to _ u _ int ( hash , 0 ) ; for ( int i = 0 ; i < NUM ; i + + ) { encrypt _ table [ i ] = ( byte ) i ; } for ( int i = 1 ; i < NUM ; i + + ) { encrypt _ table = merge _ sort ( encrypt _ table , a , i ) ; } for ( int i = 0 ; i < NUM ; i + + ) { decrypt _ table [ encrypt _ table [ i ] ] = ( byte ) i ; }
switch ( method )
case type _ table : for ( int i = 0 ; i < length ; i + + ) buf [ i ] = encrypt _ table [ buf [ i ] ] ; break ; case type _ r : rc . encrypt ( encrypt _ table , buf , length ) ; break ;
switch ( method )
case type _ table : for ( int i = 0 ; i < length ; i + + ) buf [ i ] = decrypt _ table [ buf [ i ] ] ; break ; case type _ r : rc . decrypt ( decrypt _ table , buf , length ) ; break ;
using system _ net ;
using system _ timers ; using shadowsocks _ controller _ strategy ;

public i _ set < tcp _ handler > handlers
controller = controller ; handlers = new hash _ set < tcp _ handler > ( ) ; last _ sweep _ time = date _ time . now ;
tcp _ handler handler = new tcp _ handler ( this ) ;
i _ list < tcp _ handler > handlers _ to _ close = new list < tcp _ handler > ( ) ; lock ( handlers ) { handlers . add ( handler ) ;
foreach ( tcp _ handler handler in handlers )
foreach ( tcp _ handler handler in handlers _ to _ close )
class tcp _ handler
encryptor = encryptor _ factory . get _ encryptor ( server . method , server . password , server . auth , false ) ;
first _ packet = first _ packet ; first _ packet _ length = length ; handshake _ receive ( ) ; last _ activity = date _ time . now ;
close ( ) ;


close ( ) ; } } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ;

logging . debug ( STR ) ; close ( ) ; } } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ;
logging . debug ( remote , recv _ size , STR ) ; connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , 0 , new async _ callback ( read _ all ) , null ) ;
logging . debug ( remote , recv _ size , STR ) ; connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , 0 , new async _ callback ( read _ all ) , null ) ;
close ( ) ; } } } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ;
if ( retry _ count < max _ retry ) { logging . debug ( $ STR ) ;
close ( ) ;
last _ activity = date _ time . now ;
logging . debug ( remote , bytes _ to _ send , STR , STR ) ;
strategy . update _ last _ read ( server ) ;
} } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ;
logging . debug ( remote , bytes _ to _ send , STR , STR ) ;
strategy . update _ last _ write ( server ) ;
using system ;
using shadowsocks _ model ;
using system ;

using shadowsocks _ model ; using shadowsocks _ properties ;

using system _ net ; using system _ net _ sockets ; using system _ runtime _ compiler _ services ; using shadowsocks _ controller _ strategy ;








interlocked . add ( ref inbound , delta ) ;
interlocked . add ( ref outbound , delta ) ;
var i = interlocked . read ( ref inbound ) ; var il = interlocked . exchange ( ref last _ inbound , i ) ; inbound _ delta = i - il ; var o = interlocked . read ( ref outbound ) ; var ol = interlocked . exchange ( ref last _ outbound , o ) ; outbound _ delta = o - ol ;
end _ point dest _ end _ point { get ; }
void begin _ connect _ dest ( end _ point dest _ end _ point , async _ callback callback , object state ) ;
public void begin _ connect _ dest ( end _ point dest _ end _ point , async _ callback callback , object state ) { dest _ end _ point = dest _ end _ point ;
int port ; var dep = dest _ end _ point as dns _ end _ point ; if ( dep ! = null ) {  atyp = NUM ; var enc = encoding . ut ; var host _ byte _ count = enc . get _ byte _ count ( dep . host ) ; request = new byte [ NUM + 1 request [ NUM ] = ( byte ) host _ byte _ count ; enc . get _ bytes ( dep . host , 0 , dep . host . length , request , NUM ) ; port = dep . port ; } else { switch ( dest _ end _ point . address _ family )
port = ( ( ip _ end _ point ) dest _ end _ point ) . port ; var addr = ( ( ip _ end _ point ) dest _ end _ point ) . address . get _ address _ bytes ( ) ;

public end _ point dest _ end _ point { get ; private set ; }
public void begin _ connect _ dest ( end _ point dest _ end _ point , async _ callback callback , object state )
end _ point real _ end _ point = dest _ end _ point = dest _ end _ point ;  * on windows vista or later , dual - mode socket is supported , so that * we don ' t need to resolve a dns _ end _ point manually . * we could just create a dual - mode socket and pass the dns _ end _ point * directly to it ' s begin _ connect and the system will handle it correctlly * so that we won ' t worry about async resolving any more . * * see : https : * * but it seems that we can ' t use this feature because dns _ end _ point * doesn ' t have a specific address _ family before it has been * resolved ( we don ' t know whether it ' s ipv or ipv ) and we don ' t have * a dual - mode socket to use on windows xp : ( * / var dep = real _ end _ point as dns _ end _ point ; if ( dep ! = null )
ip _ host _ entry ip _ host _ info = dns . get _ host _ entry ( dep . host ) ; ip _ address ip _ address = ip _ host _ info . address _ list [ 0 ] ; real _ end _ point = new ip _ end _ point ( ip _ address , dep . port ) ;

remote = new socket ( real _ end _ point . address _ family , socket _ type . stream , protocol _ type . tcp ) ;
remote . begin _ connect ( real _ end _ point , callback , state ) ;
public log _ form ( shadowsocks _ controller controller )

using shadowsocks _ encryption _ exception ; namespace shadowsocks _ encryption _ stream
public class stream _ sodium _ encryptor : stream _ encryptor , i _ disposable
protected override void cipher _ update ( bool is _ encrypt , int length , byte [ ] buf , byte [ ] outbuf )
int ret = - 1 ; if ( is _ encrypt )
ret = sodium . crypto _ stream _ salsa _ xor _ ic ( sodium _ buf , sodium _ buf , ( ulong ) ( padding + length ) , iv , ic , key ) ;
ret = sodium . crypto _ stream _ chacha _ xor _ ic ( sodium _ buf , sodium _ buf , ( ulong ) ( padding + length ) , iv , ic , key ) ;
ret = sodium . crypto _ stream _ chacha _ ietf _ xor _ ic ( sodium _ buf , sodium _ buf , ( ulong ) ( padding + length ) , iv , ( uint ) ic , key ) ;
if ( is _ encrypt )
namespace shadowsocks _ encryption
public class encryptor _ info
public const int max _ domain _ len = NUM ; public const int addr _ port _ len = 2 ; public const int addr _ atyp _ len = 1 ; public const int atyp _ i _ pv = 0 ; public const int atyp _ domain = 0 ; public const int atyp _ i _ pv = 0 ; protected encryptor _ base ( string method , string password )


public static class sodium
private const string dllname = STR ; private static bool initialized = false ; private static readonly object init _ lock = new object ( ) ;
string dll _ path = utils . get _ temp _ path ( dllname ) ;
catch ( system . exception e )
private static extern int sodium _ init ( ) ;
public static extern int sodium _ increment ( byte [ ] n , int nlen ) ;
public static extern int crypto _ aead _ chacha _ poly _ ietf _ encrypt ( byte [ ] c , ref ulong clen _ p , byte [ ] m , ulong mlen , byte [ ] ad , ulong adlen , byte [ ] nsec , byte [ ] npub , byte [ ] k ) ;
public static extern int crypto _ aead _ chacha _ poly _ ietf _ decrypt ( byte [ ] m , ref ulong mlen _ p , byte [ ] nsec , byte [ ] c , ulong clen , byte [ ] ad , ulong adlen , byte [ ] npub , byte [ ] k ) ;   dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern int crypto _ stream _ salsa _ xor _ ic ( byte [ ] c , byte [ ] m , ulong mlen , byte [ ] n , ulong ic , byte [ ] k ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern int crypto _ stream _ chacha _ xor _ ic ( byte [ ] c , byte [ ] m , ulong mlen , byte [ ] n , ulong ic , byte [ ] k ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern int crypto _ stream _ chacha _ ietf _ xor _ ic ( byte [ ] c , byte [ ] m , ulong mlen , byte [ ] n , uint ic , byte [ ] k ) ;
get _ bytes ( buf , buf . length ) ;
catch ( system . exception )
private lru _ cache < ip _ end _ point , udp _ handler > cache = new lru _ cache < ip _ end _ point , udp _ handler > ( NUM ) ;

i _ encryptor encryptor = encryptor _ factory . get _ encryptor ( server . method , server . password ) ; byte [ ] data _ in = new byte [ length - NUM ] ;
byte [ ] data _ out = new byte [ length - NUM + NUM ] ;
encryptor . encrypt _ udp ( data _ in , length - NUM , data _ out , out outlen ) ;
public const int recv _ size = NUM ;  public const int chunk _ overhead _ size = NUM * 2  public const uint max _ chunk _ size = aead _ encryptor . chunk _ len _ mask + aead _ encryptor . chunk _ len _ bytes + NUM * 2 ;  public const int buffer _ size = recv _ size + ( int ) max _ chunk _ size + NUM
private bool proxy _ connected ; private bool dest _ connected ; private byte command ; private byte [ ] first _ packet ; private int first _ packet _ length ; private const int cmd _ connect = 0 ; private const int cmd _ udp _ assoc = 0 ; private int addr _ buf _ length = - 1 ; private int total _ read = 0 ; private int total _ write = 0 ;  private byte [ ] remote _ recv _ buffer = new byte [ buffer _ size ] ;  private byte [ ] connetion _ recv _ buffer = new byte [ buffer _ size ] ;  private byte [ ] remote _ send _ buffer = new byte [ buffer _ size ] ;  private byte [ ] connetion _ send _ buffer = new byte [ buffer _ size ] ; private bool connection _ shutdown = false ; private bool remote _ shutdown = false ; private bool closed = false ;
encryptor = encryptor _ factory . get _ encryptor ( server . method , server . password ) ;
connection . begin _ receive ( connetion _ recv _ buffer , 0 , NUM + addr _ atyp _ len + 1 , socket _ flags . none , handshake _ receive _ callback , null ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; } } private void handshake _ receive _ callback ( i _ async _ result ar )
if ( command ! = cmd _ connect & & command ! = cmd _ udp _ assoc )
if ( command = = cmd _ connect )
response _ callback , null ) ;
else if ( command = = cmd _ udp _ assoc )
case atyp _ i _ pv : read _ address ( NUM + addr _ port _ len - 1 , on _ success ) ;
case atyp _ domain :
read _ address ( len + addr _ port _ len , on _ success ) ;
case atyp _ i _ pv : read _ address ( NUM + addr _ port _ len - 1 , on _ success ) ;
array . copy ( connetion _ recv _ buffer , NUM , connetion _ recv _ buffer , 0 , addr _ atyp _ len + 1 ) ;
case atyp _ i _ pv : dst _ addr = new ip _ address ( connetion _ recv _ buffer . skip ( 1 ) . take ( NUM ) . to _ array ( ) ) . to _ string ( ) ; dst _ port = ( connetion _ recv _ buffer [ NUM ] < < NUM ) + connetion _ recv _ buffer [ NUM ] ; addr _ buf _ length = addr _ atyp _ len + NUM + addr _ port _ len ;
case atyp _ domain :
dst _ addr = system . text . encoding . ut . get _ string ( connetion _ recv _ buffer , 2 , len ) ; dst _ port = ( connetion _ recv _ buffer [ len + 2 ] < < NUM ) + connetion _ recv _ buffer [ len + NUM ] ; addr _ buf _ length = addr _ atyp _ len + 1 + len + addr _ port _ len ;
case atyp _ i _ pv : dst _ addr = $ STR ; dst _ port = ( connetion _ recv _ buffer [ NUM ] < < NUM ) + connetion _ recv _ buffer [ NUM ] ; addr _ buf _ length = addr _ atyp _ len + NUM + addr _ port _ len ;
byte [ ] response = new byte [ NUM + address . length + addr _ port _ len ] ;
response [ NUM ] = atyp _ i _ pv ;
response [ NUM ] = atyp _ i _ pv ;
connection . begin _ send ( response , 0 , response . length , socket _ flags . none , read _ all , true ) ;
connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , socket _ flags . none , read _ all , null ) ;
connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , socket _ flags . none , read _ all , null ) ;
end _ point proxy _ ep = null ;
proxy _ timer proxy _ timer = new proxy _ timer ( proxy _ timeout ) { auto _ reset = false } ; proxy _ timer . elapsed + = proxy _ connect _ timer _ elapsed ;
remote . begin _ connect _ proxy ( proxy _ ep , proxy _ connect _ callback , new async _ session < proxy _ timer > ( remote , proxy _ timer ) ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; } } private void proxy _ connect _ timer _ elapsed ( object sender , elapsed _ event _ args e ) { var timer = ( proxy _ timer ) sender ; timer . elapsed - = proxy _ connect _ timer _ elapsed ;

var server = timer . server ; timer . elapsed - = proxy _ connect _ timer _ elapsed ;
server _ timer connect _ timer = new server _ timer ( server _ timeout ) { auto _ reset = false } ; connect _ timer . elapsed + = dest _ connect _ timer _ elapsed ;
remote . begin _ connect _ dest ( dest _ end _ point , connect _ callback , new async _ session < server _ timer > ( session , connect _ timer ) ) ;
int bytes _ to _ send = - 1 ;
try { encryptor . decrypt ( remote _ recv _ buffer , bytes _ read , remote _ send _ buffer , out bytes _ to _ send ) ; } catch ( crypto _ error _ exception ) { logging . error ( STR ) ; close ( ) ; return ; } } if ( bytes _ to _ send = = 0 ) {  logging . debug ( STR ) ; session . remote . begin _ receive ( remote _ recv _ buffer , 0 , recv _ size , socket _ flags . none , pipe _ remote _ receive _ callback , session ) ; return ; } logging . debug ( $ STR ) ; connection . begin _ send ( remote _ send _ buffer , 0 , bytes _ to _ send , socket _ flags . none , pipe _ connection _ send _ callback , new object [ ] { session , bytes _ to _ send } ) ;
try { encryptor . encrypt ( connetion _ recv _ buffer , length , connetion _ send _ buffer , out bytes _ to _ send ) ; } catch ( crypto _ error _ exception ) { logging . debug ( STR ) ; close ( ) ; return ; }
session . remote . begin _ send ( connetion _ send _ buffer , 0 , bytes _ to _ send , socket _ flags . none , pipe _ remote _ send _ callback , new object [ ] { session , bytes _ to _ send } ) ;
var container = ( object [ ] ) ar . async _ state ; var session = ( async _ session ) container [ 0 ] ; var bytes _ should _ send = ( int ) container [ 1 ] ; int bytes _ sent = session . remote . end _ send ( ar ) ; int bytes _ remaining = bytes _ should _ send - bytes _ sent ; if ( bytes _ remaining > 0 ) { logging . info ( STR ) ; buffer . block _ copy ( connetion _ send _ buffer , bytes _ sent , connetion _ send _ buffer , 0 , bytes _ remaining ) ; session . remote . begin _ send ( connetion _ send _ buffer , 0 , bytes _ remaining , socket _ flags . none , pipe _ remote _ send _ callback , new object [ ] { session , bytes _ remaining } ) ; return ; } connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , socket _ flags . none , pipe _ connection _ receive _ callback , session ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; } }
var container = ( object [ ] ) ar . async _ state ; var session = ( async _ session ) container [ 0 ] ; var bytes _ should _ send = ( int ) container [ 1 ] ; var bytes _ sent = connection . end _ send ( ar ) ; var bytes _ remaining = bytes _ should _ send - bytes _ sent ; if ( bytes _ remaining > 0 ) { logging . info ( STR ) ; buffer . block _ copy ( remote _ send _ buffer , bytes _ sent , remote _ send _ buffer , 0 , bytes _ remaining ) ; connection . begin _ send ( remote _ send _ buffer , 0 , bytes _ remaining , socket _ flags . none , pipe _ connection _ send _ callback , new object [ ] { session , bytes _ remaining } ) ; return ; } session . remote . begin _ receive ( remote _ recv _ buffer , 0 , recv _ size , socket _ flags . none , pipe _ remote _ receive _ callback , session ) ;
using shadowsocks _ encryption _ exception ; namespace shadowsocks _ encryption _ stream
public class stream _ mbed _ tls _ encryptor : stream _ encryptor , i _ disposable
public stream _ mbed _ tls _ encryptor ( string method , string password ) : base ( method , password )
base . init _ cipher ( iv , is _ encrypt ) ;
is _ encrypt ? mbed _ tls . mbedtls _ encrypt : mbed _ tls . mbedtls _ decrypt ) ! = 0 ) throw new system . exception ( STR ) ;
throw new system . exception ( STR ) ;
throw new system . exception ( STR ) ;
protected override void cipher _ update ( bool is _ encrypt , int length , byte [ ] buf , byte [ ] outbuf )
if ( mbed _ tls . cipher _ update ( is _ encrypt ? encrypt _ ctx : decrypt _ ctx ,
throw new crypto _ error _ exception ( ) ;
~ stream _ mbed _ tls _ encryptor ( )
private static dictionary < string , type > registered _ encryptors = new dictionary < string , type > ( ) ; private static readonly type [ ] constructor _ types = { typeof ( string ) , typeof ( string ) } ;
foreach ( string method in stream _ mbed _ tls _ encryptor . supported _ ciphers ( ) )
registered _ encryptors . add ( method , typeof ( stream _ mbed _ tls _ encryptor ) ) ;
foreach ( string method in stream _ sodium _ encryptor . supported _ ciphers ( ) )
registered _ encryptors . add ( method , typeof ( stream _ sodium _ encryptor ) ) ; } foreach ( string method in aead _ mbed _ tls _ encryptor . supported _ ciphers ( ) ) { registered _ encryptors . add ( method , typeof ( aead _ mbed _ tls _ encryptor ) ) ; } foreach ( string method in aead _ sodium _ encryptor . supported _ ciphers ( ) ) { registered _ encryptors . add ( method , typeof ( aead _ sodium _ encryptor ) ) ;
public static i _ encryptor get _ encryptor ( string method , string password )
constructor _ info c = t . get _ constructor ( constructor _ types ) ; if ( c = = null ) throw new system . exception ( STR ) ; i _ encryptor result = ( i _ encryptor ) c . invoke ( new object [ ] { method , password } ) ;
public static class mbed _ tls
private const string dllname = STR ;
string dll _ path = utils . get _ temp _ path ( dllname ) ;
catch ( system . exception e )
public static extern int cipher _ auth _ encrypt ( int _ ptr ctx , byte [ ] iv , uint iv _ len , int _ ptr ad , uint ad _ len , byte [ ] input , uint ilen , byte [ ] output , ref uint olen , byte [ ] tag , uint tag _ len ) ;
public static extern int cipher _ auth _ decrypt ( int _ ptr ctx , byte [ ] iv , uint iv _ len , int _ ptr ad , uint ad _ len , byte [ ] input , uint ilen , byte [ ] output , ref uint olen , byte [ ] tag , uint tag _ len ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern int hkdf ( byte [ ] salt , int salt _ len , byte [ ] ikm , int ikm _ len , byte [ ] info , int info _ len , byte [ ] okm , int okm _ len ) ;
if ( current _ server = = null ) { return null ; } return current _ server . server ;
server _ status old _ server = current _ server ;
if ( current _ server = = null | | max . score - current _ server . score > NUM )
current _ server = max ; console . write _ line ( STR , current _ server . server . friendly _ name ( ) ) ;


new key _ value _ pair < string , string > ( STR , get _ recent _ outbound _ speed ( server ) )

append ( data _ list , enumerable . empty < data _ unit > ( ) ) ;






polar _ ssl . aes _ crypt _ cfb ( encrypt _ ctx , polar _ ssl . aes _ encrypt , length , ref encrypt _ iv _ offset , encrypt _ iv , buf , tempbuf ) ;
polar _ ssl . blowfish _ crypt _ cfb ( encrypt _ ctx , polar _ ssl . blowfish _ encrypt , length , ref encrypt _ iv _ offset , encrypt _ iv , buf , tempbuf ) ;
polar _ ssl . aes _ crypt _ cfb ( encrypt _ ctx , polar _ ssl . aes _ encrypt , length , ref encrypt _ iv _ offset , encrypt _ iv , buf , outbuf ) ;
polar _ ssl . blowfish _ crypt _ cfb ( encrypt _ ctx , polar _ ssl . blowfish _ encrypt , length , ref encrypt _ iv _ offset , encrypt _ iv , buf , outbuf ) ;
polar _ ssl . aes _ crypt _ cfb ( decrypt _ ctx , polar _ ssl . aes _ decrypt , length - iv _ len , ref decrypt _ iv _ offset , decrypt _ iv , tempbuf , outbuf ) ;
polar _ ssl . blowfish _ crypt _ cfb ( decrypt _ ctx , polar _ ssl . blowfish _ decrypt , length - iv _ len , ref decrypt _ iv _ offset , decrypt _ iv , tempbuf , outbuf ) ;
polar _ ssl . aes _ crypt _ cfb ( decrypt _ ctx , polar _ ssl . aes _ decrypt , length , ref decrypt _ iv _ offset , decrypt _ iv , buf , outbuf ) ;
polar _ ssl . blowfish _ crypt _ cfb ( decrypt _ ctx , polar _ ssl . blowfish _ decrypt , length , ref decrypt _ iv _ offset , decrypt _ iv , buf , outbuf ) ;
this . my _ cancel _ button . margin = new system . windows . forms . padding ( NUM , NUM , NUM , 0 ) ;




i _ encryptor encryptor = encryptor _ factory . get _ encryptor ( server . method , server . password , server . one _ time _ auth , true ) ;
encryptor . encrypt ( data _ in , length - NUM , data _ out , out outlen ) ;
protected void react _ buffer _ tcp ( byte [ ] buf , ref int length )
int head _ len = get _ head _ len ( buf , length ) ; int data _ len = length - head _ len ; buf [ 0 ] | = onetimeauth _ flag ; byte [ ] hash = gen _ onetime _ auth _ hash ( buf , head _ len ) ; buffer . block _ copy ( buf , head _ len , buf , head _ len + onetimeauth _ bytes + auth _ bytes , data _ len ) ; buffer . block _ copy ( hash , 0 , buf , head _ len , onetimeauth _ bytes ) ; hash = gen _ hash ( buf , head _ len + onetimeauth _ bytes + auth _ bytes , data _ len ) ; buffer . block _ copy ( hash , 0 , buf , head _ len + onetimeauth _ bytes + clen _ bytes , onetimeauth _ bytes ) ; byte [ ] len _ bytes = bit _ converter . get _ bytes ( ( ushort ) ip _ address . host _ to _ network _ order ( ( short ) data _ len ) ) ; buffer . block _ copy ( len _ bytes , 0 , buf , head _ len + onetimeauth _ bytes , clen _ bytes ) ; length = head _ len + onetimeauth _ bytes + auth _ bytes + data _ len ; } else { byte [ ] hash = gen _ hash ( buf , 0 , length ) ; buffer . block _ copy ( buf , 0 , buf , auth _ bytes , length ) ; byte [ ] len _ bytes = bit _ converter . get _ bytes ( ( ushort ) ip _ address . host _ to _ network _ order ( ( short ) length ) ) ; buffer . block _ copy ( len _ bytes , 0 , buf , 0 , clen _ bytes ) ; buffer . block _ copy ( hash , 0 , buf , clen _ bytes , onetimeauth _ bytes ) ; length + = auth _ bytes ; } } protected void react _ buffer _ udp ( byte [ ] buf , ref int length ) { buf [ 0 ] | = onetimeauth _ flag ; byte [ ] hash = gen _ onetime _ auth _ hash ( buf , length ) ; buffer . block _ copy ( hash , 0 , buf , length , onetimeauth _ bytes ) ; length + = onetimeauth _ bytes ; } protected void react _ buffer ( byte [ ] buf , ref int length ) { if ( onetime _ auth & & iv _ len > 0 ) { if ( ! is _ udp ) { react _ buffer _ tcp ( buf , ref length ) ; } else { react _ buffer _ udp ( buf , ref length ) ; } } } public override void encrypt ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength ) { if ( ! encrypt _ iv _ sent ) {
react _ buffer ( buf , ref length ) ; encrypt _ iv _ sent = true ;
react _ buffer ( buf , ref length ) ;
protected encryptor _ base ( string method , string password , bool onetimeauth , bool isudp )
public abstract void encrypt ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength ) ;
public static i _ encryptor get _ encryptor ( string method , string password , bool onetimeauth , bool isudp )
i _ encryptor result = ( i _ encryptor ) c . invoke ( new object [ ] { method , password , onetimeauth , isudp } ) ;
encryptor . encrypt ( plain , plain . length , cipher , out out _ len ) ;
encryptor . encrypt ( plain , NUM , cipher , out out _ len ) ;
encryptor . encrypt ( plain , NUM , cipher , out out _ len ) ;


private readonly concurrent _ dictionary < string , list < int > > latency _ records = new concurrent _ dictionary < string , list < int > > ( ) ;
private readonly concurrent _ dictionary < string , long > inbound _ counter = new concurrent _ dictionary < string , long > ( ) ; private readonly concurrent _ dictionary < string , long > last _ inbound _ counter = new concurrent _ dictionary < string , long > ( ) ; private readonly concurrent _ dictionary < string , list < int > > inbound _ speed _ records = new concurrent _ dictionary < string , list < int > > ( ) ; private readonly concurrent _ dictionary < string , long > outbound _ counter = new concurrent _ dictionary < string , long > ( ) ; private readonly concurrent _ dictionary < string , long > last _ outbound _ counter = new concurrent _ dictionary < string , long > ( ) ; private readonly concurrent _ dictionary < string , list < int > > outbound _ speed _ records = new concurrent _ dictionary < string , list < int > > ( ) ;




inbound _ speed _ records . clear ( ) ; outbound _ speed _ records . clear ( ) ; latency _ records . clear ( ) ;
var records = new dictionary < string , statistics _ record > ( ) ; foreach ( var server in controller . get _ current _ configuration ( ) . configs ) { var id = server . identifier ( ) ; list < int > inbound _ speed _ records = null ; list < int > outbound _ speed _ records = null ; list < int > latency _ records = null ; inbound _ speed _ records . try _ get _ value ( id , out inbound _ speed _ records ) ; outbound _ speed _ records . try _ get _ value ( id , out outbound _ speed _ records ) ; latency _ records . try _ get _ value ( id , out latency _ records ) ; records . add ( id , new statistics _ record ( id , inbound _ speed _ records , outbound _ speed _ records , latency _ records ) ) ; } if ( config . ping ) { var icmp _ results = await task _ ex . when _ all ( controller . get _ current _ configuration ( ) . configs . select ( icmp _ test ) ) ; foreach ( var result in icmp _ results . where ( result = > result ! = null ) ) { records [ result . server . identifier ( ) ] . set _ response ( result . roundtrip _ time ) ; } } foreach ( var kv in records . where ( kv = > ! kv . value . is _ empty _ data ( ) ) ) { append _ record ( kv . key , kv . value ) ; } } private void append _ record ( string server _ identifier , statistics _ record record ) { list < statistics _ record > records ; if ( ! raw _ statistics . try _ get _ value ( server _ identifier , out records ) ) { records = new list < statistics _ record > ( ) ; } records . add ( record ) ; raw _ statistics [ server _ identifier ] = records ; } private void save ( ) { if ( raw _ statistics . count = = 0 ) {

var content = json _ convert . serialize _ object ( raw _ statistics , formatting . none ) ; file . write _ all _ text ( availability _ statistics _ file , content ) ;


public void update _ latency ( server server , time _ span latency ) { if ( config . availability _ statistics ) { new task ( ( ) = > availability _ statistics . update _ latency ( server , ( int ) latency . total _ milliseconds ) ) . start ( ) ; } } public void update _ inbound _ counter ( server server , long n )
if ( config . availability _ statistics ) { new task ( ( ) = > availability _ statistics . update _ inbound _ counter ( server , n ) ) . start ( ) ; } } public void update _ outbound _ counter ( server server , long n )
public string server _ identifier { get ; set ; }
public statistics _ record ( string identifier , i _ collection < int > inbound _ speed _ records , i _ collection < int > outbound _ speed _ records , i _ collection < int > latency _ records )
server _ identifier = identifier ;
server _ identifier = identifier ; set _ response ( response _ records ) ;
public void set _ response ( i _ collection < int? > response _ records )
package _ loss = response _ records . count ( response = > response ! = null ) / ( float ) response _ records . count ;
private float? get _ score ( string identifier , list < statistics _ record > records )
float? score = null ; var average _ record = new statistics _ record ( identifier , records . where ( record = > record . max _ inbound _ speed ! = null ) . select ( record = > record . max _ inbound _ speed . value ) . to _ list ( ) , records . where ( record = > record . max _ outbound _ speed ! = null ) . select ( record = > record . max _ outbound _ speed . value ) . to _ list ( ) , records . where ( record = > record . average _ latency ! = null ) . select ( record = > record . average _ latency . value ) . to _ list ( ) ) ; average _ record . set _ response ( records . select ( record = > record . average _ response ) . to _ list ( ) ) ; foreach ( var calculation in config . calculations ) { var name = calculation . key ; var field = typeof ( statistics _ record ) . get _ field ( name ) ; dynamic value = field . get _ value ( average _ record ) ; var factor = calculation . value ; if ( value = = null | | factor . equals ( 0 ) ) continue ; score = score ? ? 0 ; score + = value * factor ; } if ( score ! = null ) { logging . debug ( $ STR ) ; }



foreach ( var line in sr . non _ white _ space _ lines ( ) )
if ( line [ 0 ] = = '#' )
private config config ;
public local ( config config ) { this . config = config ; this . encryptor = new encryptor ( config . password ) ;
ip _ end _ point local _ end _ point = new ip _ end _ point ( 0 , config . local _ port ) ;
ip _ host _ entry ip _ host _ info = dns . get _ host _ entry ( config . server ) ;
ip _ end _ point remote _ ep = new ip _ end _ point ( ip _ address , config . server _ port ) ;
void controller _ update _ pac _ from _ geosite _ error ( object sender , system . io . error _ event _ args e )
void controller _ update _ pac _ from _ geosite _ completed ( object sender , geosite _ result _ event _ args e )
update _ pac _ from _ geosite _ completed ? . invoke ( this , e ) ;
update _ pac _ from _ geosite _ error ? . invoke ( this , e ) ;
try { registry _ key registry = registry . current _ user . open _ sub _ key ( STR , true ) ; registry . set _ value ( STR , 0 ) ; registry . set _ value ( STR , STR ) ; registry . set _ value ( STR , STR + get _ timestamp ( date _ time . now ) ) ; system _ proxy . notify _ ie ( ) ; } catch ( exception ) { message _ box . show ( STR ) ; throw ; }
try { registry _ key registry = registry . current _ user . open _ sub _ key ( STR , true ) ; registry . set _ value ( STR , 0 ) ; registry . set _ value ( STR , STR ) ; registry . set _ value ( STR , STR ) ; system _ proxy . notify _ ie ( ) ; } catch ( exception ) { message _ box . show ( STR ) ; throw ; }
if ( file . exists ( pac _ daemon . pac _ file ) )
string original = file _ manager . non _ exclusive _ read _ all _ text ( pac _ daemon . pac _ file , encoding . ut ) ;
file . write _ all _ text ( pac _ daemon . pac _ file , abp _ content , encoding . ut ) ;
string pac _ filename = pac _ daemon . touch _ pac _ file ( ) ;
string user _ rule _ filename = pac _ daemon . touch _ user _ rule _ file ( ) ;
pac _ server = new pac _ server ( pac _ daemon ) ; } pac _ server . update _ pacurl ( config ) ;
public const string resource _ name = STR ;

private pac _ daemon pac _ daemon ; public pac _ server ( pac _ daemon pac _ daemon )
pac _ daemon = pac _ daemon ;
public void update _ pacurl ( configuration config )
if ( lines . length < 2 )
return false ; }  string request _ line = lines [ 0 ] ;  string [ ] request _ items = request _ line . split ( ' ' ) ; if ( request _ items . length = = NUM & & request _ items [ 0 ] = = STR ) { int index = request _ items [ 1 ] . index _ of ( '?' ) ; if ( index < 0 ) { index = request _ items [ 1 ] . length ; } string resource _ string = request _ items [ 1 ] . substring ( 0 , index ) . remove ( 0 , 1 ) ; if ( string . equals ( resource _ string , resource _ name , string _ comparison . ordinal _ ignore _ case ) ) { path _ match = true ; if ( ! secret _ match ) { string query _ string = request _ items [ 1 ] . substring ( index ) ; if ( query _ string . contains ( pac _ secret ) ) { secret _ match = true ; } } } }  for ( int i = 1 ; i < lines . length ; i + + ) { if ( string . is _ null _ or _ empty ( lines [ i ] ) ) continue ; string [ ] kv = lines [ i ] . split ( new char [ ] { ':' } , 2 ) ;


string pac _ content = pac _ daemon . get _ pac _ content ( ) . replace ( STR , proxy ) ;

private timer per _ second _ timer ;

if ( per _ second _ timer = = null ) { per _ second _ timer = new timer ( operations _ per _ second , new counter ( ) , delay _ before _ start , time _ span . from _ seconds ( 1 ) ) ; }
per _ second _ timer ? . dispose ( ) ;
private void operations _ per _ second ( object state ) { lock ( state ) { var counter = state as counter ; if ( counter . count % monitor _ interval . total _ seconds = = 0 ) { update _ speed ( ) ; } if ( counter . count % recording _ interval . total _ seconds = = 0 ) { run ( ) ; } counter . count + + ; } } private void update _ speed ( )
private void run ( )
int server _ count = controller . get _ current _ configuration ( ) . configs . count ; state . counter = server _ count ; bool is _ ping = config . ping ; for ( int i = 0 ; i < server _ count ; i + + ) { try { var server = controller . get _ current _ configuration ( ) . configs [ i ] ; var id = server . identifier ( ) ; list < int > inbound _ speed _ records = null ; list < int > outbound _ speed _ records = null ; list < int > latency _ records = null ; inbound _ speed _ records . try _ get _ value ( id , out inbound _ speed _ records ) ; outbound _ speed _ records . try _ get _ value ( id , out outbound _ speed _ records ) ; latency _ records . try _ get _ value ( id , out latency _ records ) ; statistics _ record record = new statistics _ record ( id , inbound _ speed _ records , outbound _ speed _ records , latency _ records ) ;  if ( records . contains _ key ( id ) ) records [ id ] = record ; else records . add ( id , record ) ; if ( is _ ping ) {   my _ ping ping = new my _ ping ( server , repeat ) ; ping . completed + = ping _ completed ; ping . start ( new ping _ state { state = state , record = record } ) ; } else if ( ! record . is _ empty _ data ( ) ) { append _ record ( id , record ) ; } } catch ( exception e ) { logging . debug ( STR ) ; } } if ( ! is _ ping )
var filtered _ statistics = new statistics ( ) ;
filtered _ statistics [ server ] = filtered _ records ; } filtered _ statistics = filtered _ statistics ;
console . write _ line ( $ STR ) ;
per _ second _ timer . dispose ( ) ;
private string pac _ secret { get { if ( string . is _ null _ or _ empty ( cached _ pac _ secret ) ) { var rd = new byte [ NUM ] ; rng . get _ bytes ( rd ) ; cached _ pac _ secret = http _ server _ utility . url _ token _ encode ( rd ) ; } return cached _ pac _ secret ; } } private string cached _ pac _ secret = STR ;
config = config ; string used _ secret = config . secure _ local _ pac ? $ STR : STR ; string content _ hash = get _ hash ( pac _ daemon . get _ pac _ content ( ) ) ; pac _ url = $ STR ; logging . debug ( STR + pac _ url ) ;
return http _ server _ utility . url _ token _ encode ( md _ bytes ) ;
public static class n
private static dictionary < string , string > strings = new dictionary < string , string > ( ) ; private static void init ( string res )
string name = culture _ info . current _ culture . english _ name ; if ( name . starts _ with ( STR , string _ comparison . ordinal _ ignore _ case ) )
init ( name . contains ( STR ) ? resources . zh _ tw : resources . cn ) ;
return strings . contains _ key ( key ) ? strings [ key ] : key ;

using shadowsocks _ controller ; using shadowsocks _ model ; using shadowsocks _ properties ; using shadowsocks _ util ; using system ;
using system _ io ; using system _ linq ; using system _ text ;

tcp _ relay tcp _ relay = new tcp _ relay ( config ) ; udp _ relay udp _ relay = new udp _ relay ( config ) ;
services . add ( tcp _ relay ) ; services . add ( udp _ relay ) ;
bool handle ( byte [ ] first _ packet , int length , socket socket , object state ) ; } public class udp _ state { public byte [ ] buffer = new byte [ NUM ] ; public end _ point remote _ end _ point = new ip _ end _ point ( ip _ address . any , 0 ) ;
socket tcp _ socket ; socket udp _ socket ;
tcp _ socket = new socket ( address _ family . inter _ network , socket _ type . stream , protocol _ type . tcp ) ; udp _ socket = new socket ( address _ family . inter _ network , socket _ type . dgram , protocol _ type . udp ) ; tcp _ socket . set _ socket _ option ( socket _ option _ level . socket , socket _ option _ name . reuse _ address , true ) ; udp _ socket . set _ socket _ option ( socket _ option _ level . socket , socket _ option _ name . reuse _ address , true ) ;
tcp _ socket . bind ( local _ end _ point ) ; udp _ socket . bind ( local _ end _ point ) ; tcp _ socket . listen ( NUM ) ;
tcp _ socket . begin _ accept (
tcp _ socket ) ; udp _ state udp _ state = new udp _ state ( ) ; udp _ socket . begin _ receive _ from ( udp _ state . buffer , 0 , udp _ state . buffer . length , 0 , ref udp _ state . remote _ end _ point , new async _ callback ( recv _ from _ callback ) , udp _ state ) ;
tcp _ socket . close ( ) ;
if ( tcp _ socket ! = null )
tcp _ socket . close ( ) ; tcp _ socket = null ; } if ( udp _ socket ! = null ) { udp _ socket . close ( ) ; udp _ socket = null ; } } public void recv _ from _ callback ( i _ async _ result ar ) { udp _ state state = ( udp _ state ) ar . async _ state ; try { int bytes _ read = udp _ socket . end _ receive _ from ( ar , ref state . remote _ end _ point ) ; foreach ( service service in services ) { if ( service . handle ( state . buffer , bytes _ read , udp _ socket , state ) ) { break ; } } } catch ( object _ disposed _ exception ) { } catch ( exception e ) { } finally { try { udp _ socket . begin _ receive _ from ( state . buffer , 0 , state . buffer . length , 0 , ref state . remote _ end _ point , new async _ callback ( recv _ from _ callback ) , state ) ; } catch ( object _ disposed _ exception ) {  } catch ( exception e ) { }
if ( service . handle ( buf , bytes _ read , conn , null ) )
if ( conn . protocol _ type = = protocol _ type . tcp ) { conn . close ( ) ; }
class tcp _ relay : listener . service
public tcp _ relay ( configuration config )
public bool handle ( byte [ ] first _ packet , int length , socket socket , object state ) { if ( socket . protocol _ type ! = protocol _ type . tcp ) { return false ; }
public bool handle ( byte [ ] first _ packet , int length , socket socket , object state )
public bool handle ( byte [ ] first _ packet , int length , socket socket , object state )
void begin _ connect _ proxy ( end _ point remote _ ep , async _ callback callback , object state ) ;
void begin _ connect _ dest ( end _ point remote _ ep , async _ callback callback , object state ) ;
void begin _ send ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback ,
void begin _ receive ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback ,
public void begin _ connect _ proxy ( end _ point remote _ ep , async _ callback callback , object state )

public void begin _ connect _ dest ( end _ point remote _ ep , async _ callback callback , object state )
remote . begin _ connect ( remote _ ep , callback , state ) ;
public void begin _ send ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback ,
remote . begin _ send ( buffer , offset , size , socket _ flags , callback , state ) ;
public void begin _ receive ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback ,
remote . begin _ receive ( buffer , offset , size , socket _ flags , callback , state ) ;
foreach ( process p in existing _ polipo . where ( is _ child _ process ) )
file _ manager . byte _ array _ to _ file ( utils . get _ temp _ path ( unique _ config _ file ) , encoding . ut . get _ bytes ( polipo _ config ) ) ;
process . start _ info . arguments = unique _ config _ file ;
if ( is _ portable _ mode ( ) )
append _ text . append ( line + environment . new _ line ) ; log _ message _ text _ box . append _ text ( append _ text . to _ string ( ) ) ;
append _ text . append ( line + environment . new _ line ) ;

if ( is _ portable _ mode ) { temp _ path = directory . create _ directory ( path . combine ( application . startup _ path , STR ) ) . full _ name ;
} else { temp _ path = directory . create _ directory ( path . combine ( path . get _ temp _ path ( ) , STR + application . executable _ path . get _ hash _ code ( ) ) ) . full _ name ; }

public void save _ servers ( list < server > servers , int local _ port , bool portable _ mode )
config . portable _ mode = portable _ mode ;

private system . windows . forms . check _ box portable _ mode _ check _ box ;
connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , socket _ flags . none , new async _ callback ( pipe _ connection _ receive _ callback ) , session ) ;

connection . end _ send ( ar ) ;
this . back _ color = system . drawing . color . white ;
using ( bitmap full _ image = new bitmap ( screen . primary _ screen . bounds . width ,
using ( graphics g = graphics . from _ image ( full _ image ) )
full _ image . size ,
for ( int i = 0 ; i < NUM ; i + + )
int margin _ left = full _ image . width * i / NUM / NUM ; int margin _ top = full _ image . height * i / NUM / NUM ; rectangle crop _ rect = new rectangle ( margin _ left , margin _ top , full _ image . width - margin _ left * 2 , full _ image . height - margin _ top * 2 ) ; bitmap target = new bitmap ( crop _ rect . width , crop _ rect . height ) ; using ( graphics g = graphics . from _ image ( target ) )
g . draw _ image ( full _ image , new rectangle ( 0 , 0 , target . width , target . height ) , crop _ rect , graphics _ unit . pixel ) ;
var reader = new barcode _ reader
min _ x + = - margin + margin _ left ; max _ x + = margin + margin _ left ; min _ y + = - margin + margin _ top ; max _ y + = margin + margin _ top ;
splash . panel . size = new size ( ( int ) max _ x - ( int ) min _ x , ( int ) max _ y - ( int ) min _ y ) ; splash . size = splash . panel . size ;
} message _ box . show ( n . get _ string ( STR ) ) ;
private readonly shadowsocks _ controller controller ;
private readonly i _ enumerable < text _ box > all _ text _ boxes ;
icon = icon . from _ handle ( resources . ssw . get _ hicon ( ) ) ;
all _ text _ boxes = table _ layout _ panel . get _ child _ controls < text _ box > ( ) ;
text = n . get _ string ( STR ) ;
string _ builder sb = new string _ builder ( ) ;
var tb = ( text _ box ) sender ; var content = tb . text . trim _ end ( ) ;
var tb = ( text _ box ) sender ;
hot _ keys . hot _ key _ call _ back _ handler call _ back ; label lb ; prepare _ for _ hotkey ( tb , out call _ back , out lb ) ; unreg _ prev _ hotkey ( call _ back ) ;
close ( ) ;
main _ controller . stop ( ) ;
main _ controller . start ( ) ;
main _ controller . stop ( ) ; main _ controller = null ;

var proxy = timer . session . remote ;
var session = timer . session ; server server = timer . server ;
private class auto _ release _ async _ result : i _ async _ result
public bool is _ completed { get ; } = true ; public wait _ handle async _ wait _ handle { get ; } = null ; public object async _ state { get ; set ; } public bool completed _ synchronously { get ; } = true ; public tcp _ user _ token user _ token { get ; set ; } ~ auto _ release _ async _ result ( ) { user _ token . dispose ( ) ; } } private class tcp _ user _ token { public async _ callback callback { get ; private set ; } public socket _ async _ event _ args args { get ; private set ; } public object async _ state { get ; private set ; }
public void dispose ( ) { args ? . dispose ( ) ; callback = null ; args = null ; async _ state = null ; }
auto _ release _ async _ result r = new auto _ release _ async _ result { async _ state = token . async _ state , user _ token = token } ; token . callback ( r ) ;
var r = async _ result as auto _ release _ async _ result ; if ( r = = null )



this . table _ layout _ panel . margin = new system . windows . forms . padding ( NUM ) ;
this . table _ layout _ panel . padding = new system . windows . forms . padding ( NUM ) ;




this . icon = icon . from _ handle ( resources . ssw . get _ hicon ( ) ) ;







this . close ( ) ;
private void config _ form _ form _ closed ( object sender , form _ closed _ event _ args e )
controller . config _ changed - = controller _ config _ changed ;

socket listener = ( socket ) ar . async _ state ; try {

socket listener = ( socket ) ar . async _ state ; try {



this . ok _ button . dock = system . windows . forms . dock _ style . right ; this . ok _ button . location = new system . drawing . point ( NUM , NUM ) ; this . ok _ button . margin = new system . windows . forms . padding ( NUM , NUM , NUM , 0 ) ;
this . my _ cancel _ button . dock = system . windows . forms . dock _ style . right ; this . my _ cancel _ button . location = new system . drawing . point ( NUM , NUM ) ; this . my _ cancel _ button . margin = new system . windows . forms . padding ( NUM , NUM , 0 , 0 ) ;

this . delete _ button . dock = system . windows . forms . dock _ style . right ; this . delete _ button . location = new system . drawing . point ( NUM , NUM ) ; this . delete _ button . margin = new system . windows . forms . padding ( NUM , NUM , 0 , NUM ) ;
this . add _ button . dock = system . windows . forms . dock _ style . left ; this . add _ button . location = new system . drawing . point ( 0 , NUM ) ; this . add _ button . margin = new system . windows . forms . padding ( 0 , NUM , NUM , NUM ) ;
this . server _ group _ box . location = new system . drawing . point ( NUM , 0 ) ; this . server _ group _ box . margin = new system . windows . forms . padding ( NUM , 0 , 0 , 0 ) ;
this . servers _ list _ box . integral _ height = false ; this . servers _ list _ box . location = new system . drawing . point ( 0 , 0 ) ; this . servers _ list _ box . margin = new system . windows . forms . padding ( 0 ) ;
this . client _ size = new system . drawing . size ( NUM , NUM ) ; this . controls . add ( this . table _ layout _ panel ) ;



using system _ text _ regular _ expressions ; using shadowsocks _ forward _ proxy ;

if ( global ) { registry . set _ value ( STR , STR ) ; }
using shadowsocks _ csharp _ model ; using system ;
namespace shadowsocks _ csharp _ controller
using shadowsocks _ csharp _ model ; using shadowsocks _ csharp _ properties ;
namespace shadowsocks _ csharp _ controller

namespace shadowsocks _ csharp _ controller
public class system _ proxy
info ( e ) ;
info ( e ) ;
public interface i _ service
foreach ( i _ service service in services )
if ( register & & ! check ( ) )
public void check _ update ( configuration config )
http . proxy = new web _ proxy ( ip _ address . loopback . to _ string ( ) , config . local _ port ) ;

return new tuple < float , string , long > ( f , unit , scale ) ;
icon _ base _ bitmap = null ;
icon _ base _ bitmap = resources . ss ;
icon _ base _ bitmap = resources . ss ;
icon _ base _ bitmap = resources . ss ;
icon _ base _ bitmap = get _ tray _ icon _ by _ state ( icon _ base _ bitmap , enabled , global ) ; icon _ base = icon . from _ handle ( icon _ base _ bitmap . get _ hicon ( ) ) ; target _ icon = icon _ base ; icon _ in = icon . from _ handle ( add _ bitmap _ overlay ( icon _ base _ bitmap , resources . ss _ in ) . get _ hicon ( ) ) ; icon _ out = icon . from _ handle ( add _ bitmap _ overlay ( icon _ base _ bitmap , resources . ss _ out ) . get _ hicon ( ) ) ; icon _ both = icon . from _ handle ( add _ bitmap _ overlay ( icon _ base _ bitmap , resources . ss _ in , resources . ss _ out ) . get _ hicon ( ) ) ; notify _ icon . icon = target _ icon ;
foreach ( screen screen in screen . all _ screens ) { using ( bitmap full _ image = new bitmap ( screen . bounds . width , screen . bounds . height ) )
using ( graphics g = graphics . from _ image ( full _ image ) )
g . copy _ from _ screen ( screen . bounds . x , screen . bounds . y , 0 , 0 , full _ image . size , copy _ pixel _ operation . source _ copy ) ;
int max _ try = NUM ; for ( int i = 0 ; i < max _ try ; i + + )
int margin _ left = full _ image . width * i / NUM / max _ try ; int margin _ top = full _ image . height * i / NUM / max _ try ; rectangle crop _ rect = new rectangle ( margin _ left , margin _ top , full _ image . width - margin _ left * 2 , full _ image . height - margin _ top * 2 ) ; bitmap target = new bitmap ( crop _ rect . width , crop _ rect . height ) ; using ( graphics g = graphics . from _ image ( target ) )
g . draw _ image ( full _ image , new rectangle ( 0 , 0 , target . width , target . height ) , crop _ rect , graphics _ unit . pixel ) ;
var source = new bitmap _ luminance _ source ( target ) ; var bitmap = new binary _ bitmap ( new hybrid _ binarizer ( source ) ) ; qr _ code _ reader reader = new qr _ code _ reader ( ) ; var result = reader . decode ( bitmap ) ; if ( result ! = null )
return byte _ array _ with ( buf , length ) ;
return byte _ array _ with ( buf , length ) ;
return byte _ array _ with ( buf , length ) ;
return byte _ array _ with ( buf , length ) ;
shadowsocks _ controller controller ; public config _ form ( shadowsocks _ controller controller )

this . controller = controller ; controller . enable _ status _ changed + = controller _ enable _ status _ changed ; controller . config _ changed + = controller _ config _ changed ; update _ ui ( ) ; } private void controller _ config _ changed ( object sender , event _ args e ) { update _ ui ( ) ; } private void controller _ enable _ status _ changed ( object sender , event _ args e ) { update _ ui ( ) ;
private void update _ ui ( )
combo _ box . text = config . method = = null ? STR : config . method ; enable _ item . checked = config . enabled ;
if ( ! controller . get _ config ( ) . is _ default )
begin _ invoke ( new method _ invoker ( delegate

update _ ui ( ) ;
controller . stop ( ) ;

controller . toggle _ enable ( enable _ item . checked ) ;
public void enable _ proxy ( int type , string proxy , int port , int timeout )

int port ; int timeout ; if ( ! int . try _ parse ( proxy _ port _ text _ box . text , out port ) )

if ( ! int . try _ parse ( proxy _ timeout _ text _ box . text , out timeout ) )

controller . enable _ proxy ( type , proxy , port , timeout ) ;

var method = m . groups [ 1 ] . value ;
if ( ! parse _ host ( m . groups [ 2 ] . value ) )
} } else {
public void update _ latency ( object sender , sstcp _ connected _ event _ args args ) { get _ current _ strategy ( ) ? . update _ latency ( args . server , args . latency ) ;
availability _ statistics . update _ latency ( args . server , ( int ) args . latency . total _ milliseconds ) ; } } public void update _ inbound _ counter ( object sender , ss _ transmit _ event _ args args ) { get _ current _ strategy ( ) ? . update _ last _ read ( args . server ) ; interlocked . add ( ref inbound _ counter , args . length ) ;
availability _ statistics . update _ inbound _ counter ( args . server , args . length ) ; } } public void update _ outbound _ counter ( object sender , ss _ transmit _ event _ args args ) { get _ current _ strategy ( ) ? . update _ last _ write ( args . server ) ; interlocked . add ( ref outbound _ counter , args . length ) ;
availability _ statistics . update _ outbound _ counter ( args . server , args . length ) ;

public class ss _ relay _ event _ args : event _ args
public class ss _ transmit _ event _ args : ss _ relay _ event _ args
public ss _ transmit _ event _ args ( server server , long length ) : base ( server )
public class sstcp _ connected _ event _ args : ss _ relay _ event _ args

public event event _ handler < ss _ transmit _ event _ args > on _ inbound ; public event event _ handler < ss _ transmit _ event _ args > on _ outbound ; public event event _ handler < ss _ relay _ event _ args > on _ closed ; public event event _ handler < ss _ relay _ event _ args > on _ failed ;
on _ outbound ? . invoke ( this , new ss _ transmit _ event _ args ( server , bytes _ to _ send ) ) ;

protected byte [ ] crc _ buf ; protected int crc _ idx = 0 ; public iv _ encryptor ( string method , string password , bool onetimeauth ) : base ( method , password , onetimeauth )
} static void load _ ss _ crypto _ library ( ) { string temp _ path = utils . get _ temp _ path ( ) ; string dll _ path = temp _ path + STR ; try { file _ manager . uncompress _ file ( dll _ path , resources . libsscrypto _ dll ) ; load _ library ( dll _ path ) ; } catch ( io _ exception ) { } catch ( exception e ) { console . write _ line ( e . to _ string ( ) ) ; }
protected encryptor _ base ( string method , string password , bool onetimeauth )
this . table _ layout _ panel . row _ count = NUM ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ;
this . server _ group _ box . size = new system . drawing . size ( NUM , NUM ) ; this . server _ group _ box . tab _ index = 0 ;

public static i _ encryptor get _ encryptor ( string method , string password , bool onetimeauth = false )
i _ encryptor result = ( i _ encryptor ) c . invoke ( new object [ ] { method , password , onetimeauth } ) ;
this . plugin _ options _ label . location = new system . drawing . point ( NUM , NUM ) ; this . plugin _ options _ label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ;
this . plugin _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . plugin _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;
this . remarks _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . remarks _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;
this . ip _ label . location = new system . drawing . point ( NUM , NUM ) ; this . ip _ label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ;
this . server _ port _ label . location = new system . drawing . point ( NUM , NUM ) ; this . server _ port _ label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ;
this . password _ label . location = new system . drawing . point ( NUM , NUM ) ; this . password _ label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ;
this . ip _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . ip _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;
this . server _ port _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . server _ port _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;
this . password _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . password _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;
this . encryption _ label . location = new system . drawing . point ( NUM , NUM ) ; this . encryption _ label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ;
this . encryption _ select . item _ height = NUM ; this . encryption _ select . location = new system . drawing . point ( NUM , NUM ) ; this . encryption _ select . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;
this . timeout _ label . location = new system . drawing . point ( NUM , NUM ) ; this . timeout _ label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ;
this . timeout _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . timeout _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;
this . plugin _ label . location = new system . drawing . point ( NUM , NUM ) ; this . plugin _ label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ;
this . plugin _ options _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . plugin _ options _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;
this . show _ passwd _ check _ box . location = new system . drawing . point ( NUM , NUM ) ; this . show _ passwd _ check _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;
this . plugin _ arguments _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . plugin _ arguments _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;
this . plugin _ arguments _ label . location = new system . drawing . point ( NUM , NUM ) ; this . plugin _ arguments _ label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ;
this . remarks _ label . location = new system . drawing . point ( NUM , NUM ) ; this . remarks _ label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ;
this . need _ plugin _ arg _ check _ box . location = new system . drawing . point ( NUM , NUM ) ; this . need _ plugin _ arg _ check _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;
this . panel . location = new system . drawing . point ( NUM , NUM ) ; this . panel . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;
this . table _ layout _ panel . padding = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;
this . proxy _ port _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . proxy _ port _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;
this . proxy _ port _ label . location = new system . drawing . point ( NUM , NUM ) ; this . proxy _ port _ label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ;
this . portable _ mode _ check _ box . location = new system . drawing . point ( NUM , NUM ) ; this . portable _ mode _ check _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;


namespace shadowsocks _ test
public void send _ response ( socket socket , bool use _ socks )

string proxy = get _ pac _ address ( local _ end _ point , use _ socks ) ; string pac _ content = get _ pac _ content ( ) . replace ( STR , proxy ) ; string response _ head = string . format ( @ STR
STR byte [ ] response = encoding . ut . get _ bytes ( response _ head + pac _ content ) ;
file _ manager . uncompress _ file ( dll _ path , resources . polarssl _ dll ) ;
public struct internet _ per _ conn _ option _ option _ union : i _ disposable
public struct internet _ per _ conn _ option _ list : i _ disposable
file _ stream fs = new file _ stream ( log _ file _ path , file _ mode . append ) ; stream _ writer _ with _ timestamp sw = new stream _ writer _ with _ timestamp ( fs ) ; sw . auto _ flush = true ; console . set _ out ( sw ) ; console . set _ error ( sw ) ;




protected dictionary < string , encryptor _ info > ciphers ;
protected encryptor _ info cipher _ info ;
protected abstract dictionary < string , encryptor _ info > get _ ciphers ( ) ;
cipher _ info = ciphers [ method ] ; cipher _ mbed _ name = cipher _ info . name ; cipher = cipher _ info . type ;
key _ len = cipher _ info . key _ size ; iv _ len = cipher _ info . iv _ size ;
private static dictionary < string , encryptor _ info > ciphers = new dictionary < string , encryptor _ info > { { STR , new encryptor _ info ( STR , NUM , NUM , cipher _ aes ) } , { STR , new encryptor _ info ( STR , NUM , NUM , cipher _ aes ) } , { STR , new encryptor _ info ( STR , NUM , NUM , cipher _ aes ) } , { STR , new encryptor _ info ( STR , NUM , NUM , cipher _ aes ) } , { STR , new encryptor _ info ( STR , NUM , NUM , cipher _ aes ) } , { STR , new encryptor _ info ( STR , NUM , NUM , cipher _ aes ) } , { STR , new encryptor _ info ( STR , NUM , NUM , cipher _ blowfish ) } , { STR , new encryptor _ info ( STR , NUM , NUM , cipher _ camellia ) } , { STR , new encryptor _ info ( STR , NUM , NUM , cipher _ camellia ) } , { STR , new encryptor _ info ( STR , NUM , NUM , cipher _ camellia ) } , { STR , new encryptor _ info ( STR , NUM , NUM , cipher _ r ) }
protected override dictionary < string , encryptor _ info > get _ ciphers ( )
private static dictionary < string , encryptor _ info > ciphers = new dictionary < string , encryptor _ info > { { STR , new encryptor _ info ( STR , NUM , NUM , cipher _ sals ) } , { STR , new encryptor _ info ( STR , NUM , NUM , cipher _ chach ) } , { STR , new encryptor _ info ( STR , NUM , NUM , cipher _ chach _ ietf ) }
protected override dictionary < string , encryptor _ info > get _ ciphers ( )
this . auto _ size = true ; this . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . client _ size = new system . drawing . size ( NUM , NUM ) ; this . controls . add ( this . table _ layout _ panel ) ; this . controls . add ( this . table _ layout _ panel ) ; this . name = STR ; this . text = STR ; this . table _ layout _ panel . resume _ layout ( false ) ; this . table _ layout _ panel . perform _ layout ( ) ; this . panel . resume _ layout ( false ) ; this . table _ layout _ panel . resume _ layout ( false ) ; this . table _ layout _ panel . perform _ layout ( ) ; this . resume _ layout ( false ) ; this . perform _ layout ( ) ;
public const int onetimeauth _ keybytes = NUM ; public const int hash _ buf _ len = NUM ; public const int hash _ bytes = NUM ;
protected byte [ ] hash _ buf ; protected int hash _ idx = 0 ;
hash _ buf = new byte [ hash _ buf _ len ] ;
lock ( hash _ buf )
int head _ len = ss _ headlen ( buf , length ) ;
ss _ onetimeauth ( auth , buf , head _ len , encrypt _ iv , iv _ len , key , key _ len ) ;
ss _ gen _ hash ( buf , ref buf _ offset , ref data _ len , hash _ buf , ref hash _ idx , buf . length ) ;
lock ( hash _ buf )
ss _ gen _ hash ( buf , ref buf _ offset , ref length , hash _ buf , ref hash _ idx , buf . length ) ;
public extern static int crypto _ generichash ( byte [ ] outbuf , uint outlen , byte [ ] inbuf , ulong inlen , byte [ ] key , uint keylen ) ;
public extern static int crypto _ onetimeauth ( byte [ ] outbuf , byte [ ] inbuf , ulong inlen , byte [ ] k ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int crypto _ onetimeauth _ verify ( byte [ ] h , byte [ ] inbuf , ulong inlen , byte [ ] k ) ;

if ( ! auto _ startup . set ( auto _ startup . checked ) ) { message _ box . show ( STR ) ;
auto _ startup . checked = auto _ startup . check ( ) ;
bitmap draw _ area = new bitmap ( ( m . width * block _ size ) , ( m . height * block _ size ) ) ;

string encoding = default _ byte _ mode _ encoding ;
mode mode = mode . byte ;











private void show _ log _ form ( ) { if ( log _ form ! = null ) { log _ form . activate ( ) ;
log _ form = new log _ form ( controller , logging . log _ file _ path ) ; log _ form . show ( ) ; log _ form . activate ( ) ; log _ form . form _ closed + = log _ form _ form _ closed ;
log _ form = null ; utils . release _ memory ( true ) ;

protected static void bytes _ to _ key ( byte [ ] password , byte [ ] key )
try

return new sip _ plugin ( server . plugin , server . plugin _ opts , server . plugin _ args , server . server , server . server _ port ) ;
private sip _ plugin ( string plugin , string plugin _ opts , string plugin _ args , string server _ address , int server _ port )
this . table _ layout _ panel . row _ count = NUM ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ;





assembly _ assembly _ company

group _ name = other . group _ name ; domains = other . domains . clone ( ) ;
public const int group _ name _ field _ number = 1 ; private string group _ name = STR ; global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute public string group _ name { get { return group _ name ; }
group _ name = pb : : proto _ preconditions . check _ not _ null ( value , STR ) ; } }  public const int domains _ field _ number = 2 ; private static readonly pb : : field _ codec < global :: domain _ object > repeated _ domains _ codec
private readonly pbc : : repeated _ field < global :: domain _ object > domains = new pbc : : repeated _ field < global :: domain _ object > ( ) ; global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute public pbc : : repeated _ field < global :: domain _ object > domains { get { return domains ; }
if ( group _ name ! = other . group _ name ) return false ; if ( ! domains . equals ( other . domains ) ) return false ;
if ( group _ name . length ! = 0 ) hash ^ = group _ name . get _ hash _ code ( ) ; hash ^ = domains . get _ hash _ code ( ) ;
if ( group _ name . length ! = 0 ) {
output . write _ string ( group _ name ) ; } domains . write _ to ( output , repeated _ domains _ codec ) ;
if ( group _ name . length ! = 0 ) { size + = 1 + pb : : coded _ output _ stream . compute _ string _ size ( group _ name ) ; } size + = domains . calculate _ size ( repeated _ domains _ codec ) ;
group _ name = input . read _ string ( ) ;
domains . add _ entries _ from ( input , repeated _ domains _ codec ) ;
public const int entries _ field _ number = 1 ; private static readonly pb : : field _ codec < global :: geosite > repeated _ entries _ codec
private readonly pbc : : repeated _ field < global :: geosite > entries = new pbc : : repeated _ field < global :: geosite > ( ) ; global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute public pbc : : repeated _ field < global :: geosite > entries { get { return entries ; }
if ( ! entries . equals ( other . entries ) ) return false ;
public static event event _ handler < result _ event _ args > update _ completed ; public class result _ event _ args : event _ args { public bool success ; public result _ event _ args ( bool success ) { this . success = success ; } } public static event error _ event _ handler error ; private static readonly string database _ path = utils . get _ temp _ path ( STR ) ;  private static readonly string geosite _ url = STR ; public static readonly dictionary < string , i _ list < domain _ object > > geosites = new dictionary < string , i _ list < domain _ object > > ( ) ;
load _ geosite _ list ( ) ; } static void load _ geosite _ list ( byte [ ] data = null ) { data = data ? ? file . read _ all _ bytes ( database _ path ) ; var list = geosite _ list . parser . parse _ from ( data ) ; foreach ( var item in list . entries )
geosites [ item . group _ name . to _ lower ( ) ] = item . domains ;
if ( line . starts _ with ( STR ) ) line = line . substring ( NUM ) ; else if ( line . starts _ with ( STR ) ) line = line . substring ( NUM ) ; if ( line . index _ of ( STR ) > = 0 )
while ( line . starts _ with ( STR ) ) line = line . substring ( 2 ) ;
line = line . trim _ start ( '|' ) ;
line = line . trim _ start ( '.' ) ;
int pos = line . index _ of _ any ( new char [ ] { '/' } ) ; if ( pos > = 0 ) line = line . substring ( 0 , pos ) ; if ( line . length > 0 ) domains . add ( line ) ; } return remove _ duplicate ( domains . to _ array ( ) ) ;
if ( se . socket _ error _ code = = socket _ error . address _ already _ in _ use )
dispose ( true ) ; gc . suppress _ finalize ( this ) ; } ~ polar _ ssl _ encryptor ( ) { dispose ( false ) ; } protected virtual void dispose ( bool disposing ) { if ( ! disposed ) { if ( disposing ) { } if ( encrypt _ ctx ! = null ) { switch ( cipher ) { case cipher _ aes : polar _ ssl . aes _ free ( encrypt _ ctx ) ; break ; case cipher _ r : polar _ ssl . arc _ free ( encrypt _ ctx ) ; break ; } } if ( decrypt _ ctx ! = null ) { switch ( cipher ) { case cipher _ aes : polar _ ssl . aes _ free ( decrypt _ ctx ) ; break ; case cipher _ r : polar _ ssl . arc _ free ( decrypt _ ctx ) ; break ; } } encrypt _ ctx = null ; decrypt _ ctx = null ; disposed = true ; } }
font = system _ fonts . message _ box _ font ;
servers _ list _ box . dock = dock _ style . fill ; table _ layout _ panel . dock = dock _ style . fill ; perform _ layout ( ) ;
icon = icon . from _ handle ( resources . ssw . get _ hicon ( ) ) ;
tool _ tip . set _ tool _ tip ( portable _ mode _ check _ box , n . get _ string ( STR ) ) ;
text = n . get _ string ( STR ) ;
method _ impl _ method _ impl _ options _ aggressive _ inlining private void update _ index _ to _ end ( ) { last _ selected _ index = ( servers _ list _ box . selected _ index = ( modified _ configuration . configs . count - 1 ) ) ; } private bool validate _ and _ save _ selected _ server _ details ( bool is _ save = false , bool is _ copy = false )
bool verify = get _ server _ details _ from _ ui ( out server server , is _ save , is _ copy ) ; if ( server ! = null ) {  if ( is _ save | | is _ copy ) configuration . check _ server ( server ) ; modified _ configuration . configs [ last _ selected _ index ] = server ; } return verify ; } catch ( exception ex ) { message _ box . show ( ex . message ) ; } return false ; } private bool get _ server _ details _ from _ ui ( out server server , bool is _ save = false , bool is _ copy = false ) { server = null ; bool? check _ ip = false ; bool? check _ port = false ; bool? check _ password = false ; bool? check _ timeout = false ; if ( ( check _ ip = check _ ip _ text _ box ( out string address , is _ save , is _ copy ) ) . get _ value _ or _ default ( false ) & & address ! = null & & ( check _ port = check _ server _ port _ text _ box ( out int? address _ port , is _ save , is _ copy ) ) . get _ value _ or _ default ( false ) & & address _ port . has _ value & & ( check _ password = check _ password _ text _ box ( out string server _ password , is _ save , is _ copy ) ) . get _ value _ or _ default ( false ) & & server _ password ! = null & & ( check _ timeout = check _ timeout _ text _ box ( out int? timeout , is _ save , is _ copy ) ) . get _ value _ or _ default ( false ) & & timeout . has _ value ) { server = new server ( ) { server = address , server _ port = address _ port . value , password = server _ password , method = encryption _ select . text , plugin = plugin _ text _ box . text , plugin _ opts = plugin _ options _ text _ box . text , plugin _ args = plugin _ arguments _ text _ box . text , remarks = remarks _ text _ box . text , timeout = timeout . value , } ;
if ( validate _ and _ save _ selected _ server _ details ( is _ save : true ) ) { configuration . add _ default _ server _ or _ server ( modified _ configuration ) ; load _ server _ name _ list _ to _ ui ( modified _ configuration ) ; update _ index _ to _ end ( ) ; } } private void duplicate _ button _ click ( object sender , event _ args e ) { if ( validate _ and _ save _ selected _ server _ details ( is _ copy : true ) ) { server curr _ server = modified _ configuration . configs [ last _ selected _ index ] ; configuration . add _ default _ server _ or _ server ( modified _ configuration , curr _ server ) ; load _ server _ name _ list _ to _ ui ( modified _ configuration ) ; update _ index _ to _ end ( ) ; } } private void delete _ button _ click ( object sender , event _ args e ) { modified _ configuration . configs . remove _ at ( last _ selected _ index ) ; if ( modified _ configuration . configs . count = = 0 ) { configuration . add _ default _ server _ or _ server ( modified _ configuration ) ; }
update _ index _ to _ end ( ) ;
private void update _ buttons ( ) { delete _ button . enabled = ( servers _ list _ box . items . count > 0 ) ; move _ up _ button . enabled = ( servers _ list _ box . selected _ index > 0 ) ; move _ down _ button . enabled = ( servers _ list _ box . selected _ index < servers _ list _ box . items . count - 1 ) ; } private void move _ up _ button _ click ( object sender , event _ args e ) { if ( servers _ list _ box . selected _ index > 0 ) { move _ config _ item ( - 1 ) ; } } private void move _ down _ button _ click ( object sender , event _ args e ) {   if ( servers _ list _ box . selected _ index < servers _ list _ box . items . count - 1 ) { move _ config _ item ( + 1 ) ; }
private void ok _ button _ click ( object sender , event _ args e ) { if ( save _ valid _ configuration ( ) ) { close ( ) ; } } private void cancel _ button _ click ( object sender , event _ args e ) { close ( ) ; }    private void apply _ button _ click ( object sender , event _ args e ) { save _ valid _ configuration ( ) ; } private void config _ form _ shown ( object sender , event _ args e ) { ip _ text _ box . focus ( ) ; } private void config _ form _ form _ closed ( object sender , form _ closed _ event _ args e ) { controller . config _ changed - = controller _ config _ changed ;
password _ text _ box . use _ system _ password _ char = ! show _ passwd _ check _ box . checked ;
show _ hide _ plugin _ arg _ input ( need _ plugin _ arg _ check _ box . checked ) ;

private static readonly string config _ file = STR ;

public static server add _ default _ server _ or _ server ( configuration config , server server = null , int? index = null )
config . configs . insert ( index . get _ value _ or _ default ( config . configs . count ) , server ) ;

if ( pac _ file _ changed ! = null ) { logging . info ( $ STR ) ; task . factory . start _ new ( ( ) = > { ( ( file _ system _ watcher ) sender ) . enable _ raising _ events = false ; system . threading . thread . sleep ( NUM ) ;
( ( file _ system _ watcher ) sender ) . enable _ raising _ events = true ; } ) ;
if ( user _ rule _ file _ changed ! = null ) { logging . info ( $ STR ) ; task . factory . start _ new ( ( ) = > { ( ( file _ system _ watcher ) sender ) . enable _ raising _ events = false ; system . threading . thread . sleep ( NUM ) ;
( ( file _ system _ watcher ) sender ) . enable _ raising _ events = true ; } ) ;
using microsoft _ win ;

using system _ net ;
using system _ threading ;
using system _ windows _ forms ;
internal static class program
private static readonly logger logger = log _ manager . get _ current _ class _ logger ( ) ;
private static void main ( string [ ] args )
service _ point _ manager . security _ protocol | = security _ protocol _ type . tls | security _ protocol _ type . tls | security _ protocol _ type . tls ;
list < string > alist = args . to _ list ( ) ;
if ( args . length < = urlidx ) { return ; }  if ( ! pipe _ exist ) { added _ url = args [ urlidx ] ; }  else { byte [ ] b = encoding . ut . get _ bytes ( args [ urlidx ] ) ; byte [ ] op _ add _ url = bit _ converter . get _ bytes ( ip _ address . host _ to _ network _ order ( 1 ) ) ; byte [ ] blen = bit _ converter . get _ bytes ( ip _ address . host _ to _ network _ order ( b . length ) ) ; pipe . write ( op _ add _ url , 0 , NUM ) ; pipe . write ( blen , 0 , NUM ) ; pipe . write ( b , 0 , b . length ) ; pipe . close ( ) ; return ; } }
public class qr _ code _ splash _ form : form


ip _ text _ box . text = server . server ; server _ port _ text _ box . text = server . server _ port . to _ string ( ) ; password _ text _ box . text = server . password ; proxy _ port _ text _ box . text = server . local _ port . to _ string ( ) ; encryption _ select . text = server . method = = null ? STR : server . method ;
private void cinfig _ form _ load ( object sender , event _ args e )
private void config _ form _ form _ closed ( object sender , form _ closed _ event _ args e )
this . encryption _ select = new system . windows . forms . combo _ box ( ) ;
this . ip _ text _ box = new system . windows . forms . text _ box ( ) ; this . server _ port _ text _ box = new system . windows . forms . text _ box ( ) ; this . password _ text _ box = new system . windows . forms . text _ box ( ) ; this . proxy _ port _ text _ box = new system . windows . forms . text _ box ( ) ;
this . ok _ button = new system . windows . forms . button ( ) ; this . my _ cancel _ button = new system . windows . forms . button ( ) ;
this . table _ layout _ panel = new system . windows . forms . table _ layout _ panel ( ) ; this . list _ view = new system . windows . forms . list _ view ( ) ; this . table _ layout _ panel = new system . windows . forms . table _ layout _ panel ( ) ;
this . table _ layout _ panel . controls . add ( this . encryption _ select , 1 , NUM ) ;
this . table _ layout _ panel . controls . add ( this . ip _ text _ box , 1 , 0 ) ; this . table _ layout _ panel . controls . add ( this . server _ port _ text _ box , 1 , 1 ) ; this . table _ layout _ panel . controls . add ( this . password _ text _ box , 1 , 2 ) ; this . table _ layout _ panel . controls . add ( this . proxy _ port _ text _ box , 1 , NUM ) ; this . table _ layout _ panel . location = new system . drawing . point ( NUM , NUM ) ;
this . encryption _ select . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( ( system . windows . forms . anchor _ styles . top | system . windows . forms . anchor _ styles . left ) | system . windows . forms . anchor _ styles . right ) ) ) ; this . encryption _ select . drop _ down _ style = system . windows . forms . combo _ box _ style . drop _ down _ list ; this . encryption _ select . formatting _ enabled = true ; this . encryption _ select . ime _ mode = system . windows . forms . ime _ mode . no _ control ; this . encryption _ select . item _ height = NUM ; this . encryption _ select . items . add _ range ( new object [ ] {
this . ok _ button . dialog _ result = system . windows . forms . dialog _ result . ok ; this . ok _ button . location = new system . drawing . point ( NUM , NUM ) ; this . ok _ button . name = STR ; this . ok _ button . size = new system . drawing . size ( NUM , NUM ) ; this . ok _ button . tab _ index = 0 ; this . ok _ button . text = STR ; this . ok _ button . use _ visual _ style _ back _ color = true ; this . ok _ button . click + = new system . event _ handler ( this . ok _ button _ click ) ;    this . my _ cancel _ button . dialog _ result = system . windows . forms . dialog _ result . cancel ; this . my _ cancel _ button . location = new system . drawing . point ( NUM , NUM ) ; this . my _ cancel _ button . name = STR ; this . my _ cancel _ button . size = new system . drawing . size ( NUM , NUM ) ; this . my _ cancel _ button . tab _ index = 1 ; this . my _ cancel _ button . text = STR ; this . my _ cancel _ button . use _ visual _ style _ back _ color = true ; this . my _ cancel _ button . click + = new system . event _ handler ( this . cancel _ button _ click ) ;
this . panel . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( ( system . windows . forms . anchor _ styles . top | system . windows . forms . anchor _ styles . bottom ) | system . windows . forms . anchor _ styles . right ) ) ) ;
this . panel . controls . add ( this . my _ cancel _ button ) ; this . panel . controls . add ( this . ok _ button ) ; this . panel . location = new system . drawing . point ( NUM , NUM ) ;
this . about _ item . click + = new system . event _ handler ( this . about _ item _ click ) ;
this . client _ size = new system . drawing . size ( NUM , NUM ) ; this . controls . add ( this . table _ layout _ panel ) ;
this . form _ border _ style = system . windows . forms . form _ border _ style . fixed _ single ;
this . form _ closed + = new system . windows . forms . form _ closed _ event _ handler ( this . config _ form _ form _ closed ) ; this . load + = new system . event _ handler ( this . cinfig _ form _ load ) ;
private system . windows . forms . text _ box ip _ text _ box ; private system . windows . forms . text _ box server _ port _ text _ box ; private system . windows . forms . text _ box password _ text _ box ; private system . windows . forms . text _ box proxy _ port _ text _ box ;
private system . windows . forms . combo _ box encryption _ select ;
private system . windows . forms . button ok _ button ; private system . windows . forms . button my _ cancel _ button ;






registry . set _ value ( STR , STR ) ;
registry . set _ value ( STR , STR ) ;
server _ port = int . parse ( after _ at . substring ( index _ last _ colon + 1 ) ) ; server = after _ at . substring ( 0 , index _ last _ colon ) ;
method = parts [ 0 ] ; password = parts [ 1 ] ;





if ( config . index = = - 1 & & config . strategy = = null ) config . index = 0 ;





if ( config . index = = - 1 & & config . strategy = = null ) config . index = 0 ;













arguments = global ? $ STR : $ STR ;
var flags = user _ settings [ 0 ] ; var proxy _ server = user _ settings [ 1 ] ? ? STR ; var bypass _ list = user _ settings [ 2 ] ? ? STR ; var pac _ url = user _ settings [ NUM ] ? ? STR ; arguments = $ STR ;  user _ settings _ recorded = false ;
var stderr = process . standard _ error . read _ to _ end ( ) ; var stdout = process . standard _ output . read _ to _ end ( ) ;
throw new proxy _ exception ( stderr ) ;
sysproxy . set _ ie _ proxy ( true , false , null , pac _ url ) ;
sysproxy . set _ ie _ proxy ( false , false , null , null ) ;

} * /
system _ proxy . update ( config , false ) ;
system _ proxy . update ( config , false ) ;
public static void update ( configuration config , bool force _ disable )
if ( enabled )
if ( global ) { registry . set _ value ( STR , 1 ) ; registry . set _ value ( STR , STR + config . local _ port . to _ string ( ) ) ; registry . set _ value ( STR , STR ) ; } else { registry . set _ value ( STR , 0 ) ; registry . set _ value ( STR , STR ) ; registry . set _ value ( STR , STR + config . local _ port . to _ string ( ) + STR + get _ timestamp ( date _ time . now ) ) ; }
registry . set _ value ( STR , STR ) ;

log _ message _ text _ box . append _ text ( line + STR ) ;
log _ message _ text _ box . scroll _ to _ caret ( ) ;
private void open _ location _ menu _ item _ click ( object sender , event _ args e )
private void exit _ menu _ item _ click ( object sender , event _ args e )
log _ message _ text _ box . scroll _ to _ caret ( ) ; } private void wrap _ text _ check _ box _ checked _ changed ( object sender , event _ args e ) { log _ message _ text _ box . word _ wrap = wrap _ text _ check _ box . checked ; log _ message _ text _ box . scroll _ to _ caret ( ) ; } private void clean _ logs _ button _ click ( object sender , event _ args e ) { log _ message _ text _ box . clear ( ) ; } private void change _ font _ button _ click ( object sender , event _ args e ) { font _ dialog fd = new font _ dialog ( ) ; fd . font = log _ message _ text _ box . font ; if ( fd . show _ dialog ( ) = = dialog _ result . ok ) { log _ message _ text _ box . font = fd . font ; } } private void top _ most _ check _ box _ checked _ changed ( object sender , event _ args e ) { this . top _ most = top _ most _ check _ box . checked ;
this . log _ message _ text _ box = new system . windows . forms . text _ box ( ) ;
this . file _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . open _ location _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . exit _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . panel = new system . windows . forms . panel ( ) ; this . change _ font _ button = new system . windows . forms . button ( ) ; this . clean _ logs _ button = new system . windows . forms . button ( ) ; this . wrap _ text _ check _ box = new system . windows . forms . check _ box ( ) ; this . table _ layout _ panel = new system . windows . forms . table _ layout _ panel ( ) ; this . top _ most _ check _ box = new system . windows . forms . check _ box ( ) ; this . panel . suspend _ layout ( ) ; this . table _ layout _ panel . suspend _ layout ( ) ;
this . file _ menu _ item } ) ;
this . file _ menu _ item . index = 0 ; this . file _ menu _ item . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . open _ location _ menu _ item , this . exit _ menu _ item } ) ; this . file _ menu _ item . text = STR ;
this . open _ location _ menu _ item . index = 0 ; this . open _ location _ menu _ item . text = STR ; this . open _ location _ menu _ item . click + = new system . event _ handler ( this . open _ location _ menu _ item _ click ) ;
this . client _ size = new system . drawing . size ( NUM , NUM ) ; this . controls . add ( this . table _ layout _ panel ) ;

private system . windows . forms . text _ box log _ message _ text _ box ;
private system . windows . forms . menu _ item file _ menu _ item ; private system . windows . forms . menu _ item open _ location _ menu _ item ; private system . windows . forms . menu _ item exit _ menu _ item ; private system . windows . forms . panel panel ; private system . windows . forms . check _ box wrap _ text _ check _ box ; private system . windows . forms . button clean _ logs _ button ; private system . windows . forms . button change _ font _ button ; private system . windows . forms . table _ layout _ panel table _ layout _ panel ; private system . windows . forms . check _ box top _ most _ check _ box ;
throw new exception ( n . get _ string ( STR ) ) ;
throw new argument _ exception ( n . get _ string ( STR ) ) ;
throw new argument _ exception ( n . get _ string ( STR ) ) ;
throw new argument _ exception ( n . get _ string ( STR ) ) ;
public event event _ handler < result _ event _ args > update _ completed ;
update _ completed ( this , new result _ event _ args ( true ) ) ;
log _ file _ path = utils . get _ temp _ path ( STR ) ; file _ stream fs = new file _ stream ( log _ file _ path , file _ mode . append ) ;
if ( length > 0 ) {  array . copy ( first _ packge , index , line _ buffer , 0 , length ) ; buffer _ data _ length = length ; try { new _ package _ recv ( ) ; } catch ( exception ex ) { on _ exception ( ex ) ; on _ finish ( ) ; } } else {  socket . begin _ receive ( line _ buffer , 0 , max _ line _ bytes , 0 , receive _ callback , 0 ) ; } } public line _ reader ( wrapped _ socket socket , func < string , object , bool > on _ line _ read , action < exception , object > on _ exception , action < byte [ ] , int , int , object > on _ finish , encoding encoding , string delimiter , int max _ line _ bytes , object state ) : this ( socket , null , 0 , 0 , on _ line _ read , on _ exception , on _ finish , encoding , delimiter , max _ line _ bytes , state ) {

on _ finish ( ) ;
buffer _ data _ length + = bytes _ read ; new _ package _ recv ( ) ; } catch ( exception ex ) { on _ exception ( ex ) ; on _ finish ( ) ; } } private void new _ package _ recv ( ) { int i ; while ( ( i = index _ of ( line _ buffer , buffer _ data _ index , buffer _ data _ length , delimiter _ bytes , delimiter _ search _ offset _ table , delimiter _ search _ char _ table ) ) ! = - 1 ) { var decode _ len = i - buffer _ data _ index ; string line = encoding . get _ string ( line _ buffer , buffer _ data _ index , decode _ len ) ; buffer _ data _ index = i + delimiter _ bytes . length ; buffer _ data _ length - = decode _ len ; buffer _ data _ length - = delimiter _ bytes . length ; var stop = on _ line _ read ( line , state ) ; if ( stop ) { on _ finish ( ) ;
} if ( buffer _ data _ length = = line _ buffer . length ) {  on _ exception ( new index _ out _ of _ range _ exception ( STR ) ) ; on _ finish ( ) ; return ; } if ( buffer _ data _ index > 0 ) { buffer . block _ copy ( line _ buffer , buffer _ data _ index , line _ buffer , 0 , buffer _ data _ length ) ; buffer _ data _ index = 0 ; } socket . begin _ receive ( line _ buffer , buffer _ data _ length , line _ buffer . length - buffer _ data _ length , 0 , receive _ callback , buffer _ data _ length ) ;
private void on _ finish ( ) { on _ finish ? . invoke ( line _ buffer , buffer _ data _ index , buffer _ data _ length , state ) ;
private static int index _ of ( byte [ ] haystack , int index , int length , byte [ ] needle , int [ ] offset _ table , int [ ] char _ table )


message _ box . show ( n . get _ string ( STR ) ) ; } finally { if ( registry ! = null ) { try { registry . close ( ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; } }
registry _ key registry = null ; try { registry = utils . open _ user _ reg _ key ( STR , true ) ; if ( registry = = null ) { logging . error ( STR ) ; return ; } var default _ value = registry . get _ value ( STR ) ;
} catch ( io _ exception e ) { logging . log _ useful _ exception ( e ) ; } finally { if ( registry ! = null ) { try { registry . close ( ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; } }
registry _ key registry = null ; try { registry = utils . open _ user _ reg _ key ( STR , true ) ; if ( registry = = null ) { logging . error ( STR ) ; return ; } var def _ connection = ( byte [ ] ) registry . get _ value ( STR ) ; var saved _ legacy _ setting = ( byte [ ] ) registry . get _ value ( STR ) ; const int version _ offset = NUM ; const int options _ offset = NUM ;  if ( set ) { def _ connection [ options _ offset ] = ( byte ) ( def _ connection [ options _ offset ] | NUM ) ; saved _ legacy _ setting [ options _ offset ] = ( byte ) ( saved _ legacy _ setting [ options _ offset ] | NUM ) ; } else { def _ connection [ options _ offset ] = ( byte ) ( def _ connection [ options _ offset ] & ~ NUM ) ; saved _ legacy _ setting [ options _ offset ] = ( byte ) ( saved _ legacy _ setting [ options _ offset ] & ~ NUM ) ; } bit _ converter . get _ bytes ( unchecked ( bit _ converter . to _ u _ int ( def _ connection , version _ offset ) + 1 ) ) . copy _ to ( def _ connection , version _ offset ) ; bit _ converter . get _ bytes ( unchecked ( bit _ converter . to _ u _ int ( saved _ legacy _ setting , version _ offset ) + 1 ) ) . copy _ to ( saved _ legacy _ setting , version _ offset ) ; registry . set _ value ( STR , def _ connection ) ; registry . set _ value ( STR , saved _ legacy _ setting ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; } finally { if ( registry ! = null ) { try { registry . close ( ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; } }

string pipename = $ STR ; using ( named _ pipe _ client _ stream pipe = new named _ pipe _ client _ stream ( pipename ) )
bool pipe _ exist = false ; try { pipe . connect ( NUM ) ; pipe _ exist = true ; } catch ( timeout _ exception ) { pipe _ exist = false ; } var alist = args . to _ list ( ) ; int urlidx = alist . index _ of ( STR ) + 1 ; if ( urlidx > 0 ) { if ( args . length < = urlidx ) return ; if ( ! pipe _ exist ) return ; byte [ ] b = encoding . ut . get _ bytes ( args [ urlidx ] ) ; byte [ ] blen = bit _ converter . get _ bytes ( ip _ address . host _ to _ network _ order ( b . length ) ) ; pipe . write ( blen , 0 , NUM ) ; pipe . write ( b , 0 , b . length ) ; pipe . close ( ) ; return ; } else if ( pipe _ exist )
} task . run ( ( ) = > new pipe _ server ( ) . run ( pipename ) ) ; utils . release _ memory ( true ) ; application . set _ unhandled _ exception _ mode ( unhandled _ exception _ mode . catch _ exception ) ;  application . thread _ exception + = application _ thread _ exception ;  app _ domain . current _ domain . unhandled _ exception + = current _ domain _ unhandled _ exception ; application . application _ exit + = application _ application _ exit ; system _ events . power _ mode _ changed + = system _ events _ power _ mode _ changed ; application . enable _ visual _ styles ( ) ; application . set _ compatible _ text _ rendering _ default ( false ) ; auto _ startup . register _ for _ restart ( true ) ; directory . set _ current _ directory ( application . startup _ path ) ;
main _ controller = new shadowsocks _ controller ( ) ; menu _ controller = new menu _ view _ controller ( main _ controller ) ; hot _ keys . init ( main _ controller ) ; main _ controller . start ( ) ; application . run ( ) ;
speed _ series . x _ value _ member = STR ; speed _ series . y _ value _ members = STR ;  data _ table . columns . add ( STR , typeof ( int ) ) ; data _ table . columns . add ( STR , typeof ( int ) ) ; package _ loss _ series . x _ value _ member = STR ; package _ loss _ series . y _ value _ members = STR ; ping _ series . x _ value _ member = STR ; ping _ series . y _ value _ members = STR ;
speed = data _ group . max ( data = > data . max _ inbound _ speed ) ? ? 0 , ping = ( int ) ( data _ group . average ( data = > data . average _ response ) ? ? 0 ) , package _ loss _ percentage = ( data _ group . average ( data = > data . package _ loss ) ? ? 0 ) * NUM } ;
data _ table . rows . add ( data . timestamp , data . speed , data . package _ loss _ percentage , data . ping ) ;
private void server _ selector _ selection _ change _ committed ( object sender , event _ args e )


series . color = system . drawing . color . dark _ gray ;
series . name = STR ; series . tool _ tip = STR ;
series . chart _ type = system . windows . forms . data _ visualization . charting . series _ chart _ type . bubble ; series . color = system . drawing . color . crimson ; series . custom _ properties = STR ;
series . name = STR ; series . tool _ tip = STR ; series . y _ axis _ type = system . windows . forms . data _ visualization . charting . axis _ type . secondary ; series . y _ values _ per _ point = 2 ; series . border _ width = NUM ;
series . chart _ type = system . windows . forms . data _ visualization . charting . series _ chart _ type . line ; series . color = system . drawing . color . dodger _ blue ;
series . marker _ size = NUM ; series . marker _ style = system . windows . forms . data _ visualization . charting . marker _ style . circle ; series . name = STR ; series . tool _ tip = STR ;








public class geosite _ result _ event _ args : event _ args { public bool success ; public geosite _ result _ event _ args ( bool success ) { this . success = success ; } } public static class geosite _ updater
public static event event _ handler < geosite _ result _ event _ args > update _ completed ;
console . write _ line ( e ) ;
private delegate get _ delegate _ via _ method _ name ( string methodname ) {
method _ info dyn _ method = typeof ( hotkey _ callbacks ) . get _ method ( methodname ,
return dyn _ method = = null ? null : delegate . create _ delegate ( typeof ( hot _ keys . hot _ key _ call _ back _ handler ) , hotkey _ callbacks . instance , dyn _ method ) ;

namespace shadowsocks _ controller _ hotkeys
public static void init ( shadowsocks _ controller controller )
color fly _ blue = color . from _ argb ( NUM , NUM , NUM , NUM ) ;
int alpha = color . a * fly _ blue . a / NUM ; icon _ copy . set _ pixel ( x , y , color . from _ argb ( alpha , red , green , blue ) ) ;



private static extern int _ ptr create _ job _ object ( int _ ptr a , string lp _ name ) ;
private static extern bool set _ information _ job _ object ( int _ ptr h _ job , job _ object _ info _ type info _ type , int _ ptr lp _ job _ object _ info , u _ int cb _ job _ object _ info _ length ) ;
private static extern bool assign _ process _ to _ job _ object ( int _ ptr job , int _ ptr process ) ;
private static extern bool close _ handle ( int _ ptr h _ object ) ;
try { int length = marshal . size _ of ( typeof ( jobobject _ extended _ limit _ information ) ) ; extended _ info _ ptr = marshal . alloc _ h _ global ( length ) ; marshal . structure _ to _ ptr ( extended _ info , extended _ info _ ptr , false ) ; if ( ! set _ information _ job _ object ( handle , job _ object _ info _ type . extended _ limit _ information , extended _ info _ ptr , ( uint ) length ) ) throw new exception ( string . format ( STR , marshal . get _ last _ win _ error ( ) ) ) ; } finally { if ( extended _ info _ ptr ! = int _ ptr . zero ) { marshal . free _ h _ global ( extended _ info _ ptr ) ; extended _ info _ ptr = int _ ptr . zero ; } }
load _ configuration ( modified _ configuration ) ; old _ selected _ index = modified _ configuration . index ;
load _ selected _ server ( ) ;

using system ;

open _ ssl . rand _ bytes ( iv , iv . length ) ;
int out _ len = length + iv _ len ;
open _ ssl . evp _ cipher _ update ( encrypt _ ctx , cipher _ text , out out _ len , buf , length ) ;
int out _ len = length + iv _ len ;
open _ ssl . evp _ cipher _ update ( encrypt _ ctx , cipher _ text , out out _ len , buf , length ) ;

int out _ len = length + iv _ len ;
open _ ssl . evp _ cipher _ update ( decrypt _ ctx , cipher _ text , out out _ len , subset , length - iv _ len ) ;
int out _ len = length + iv _ len ;
open _ ssl . evp _ cipher _ update ( decrypt _ ctx , cipher _ text , out out _ len , buf , length ) ;



else
byte [ ] passbuf = encoding . ut . get _ bytes ( password ) ; key = new byte [ NUM ] ; byte [ ] iv = new byte [ NUM ] ; open _ ssl . evp _ bytes _ to _ key ( cipher , open _ ssl . evp _ md ( ) , int _ ptr . zero , passbuf , passbuf . length , 1 , key , iv ) ; cached _ keys [ k ] = key ;

ctx = open _ ssl . evp _ cipher _ ctx _ new ( ) ;
open _ ssl . evp _ cipher _ init _ ex ( ctx , cipher , int _ ptr . zero , key , iv , enc ) ;
privoxy _ runner = privoxy _ runner ? ? new privoxy _ runner ( ) ; pac _ daemon = pac _ daemon ? ? new pac _ daemon ( ) ; pac _ daemon . pac _ file _ changed + = pac _ daemon _ pac _ file _ changed ; pac _ daemon . user _ rule _ file _ changed + = pac _ daemon _ user _ rule _ file _ changed ;       pac _ server = pac _ server ? ? new pac _ server ( pac _ daemon ) ; gfw _ list _ updater = gfw _ list _ updater ? ? new gfw _ list _ updater ( ) ; gfw _ list _ updater . update _ completed + = pac _ server _ pac _ update _ completed ; gfw _ list _ updater . error + = pac _ server _ pac _ update _ error ;
listener ? . stop ( ) ;
strategy ? . reload _ servers ( ) ;
namespace shadowsocks _ controller { class auto _ startup { public static bool set ( bool enabled ) { try { string path = application . executable _ path ; registry _ key run _ key = microsoft . win . registry . current _ user . open _ sub _ key ( STR , true ) ; if ( enabled ) { run _ key . set _ value ( STR , path ) ; } else { run _ key . delete _ value ( STR ) ; } run _ key . close ( ) ; return true ;
return false ; } } public static bool check ( ) { try { string path = application . executable _ path ; registry _ key run _ key = microsoft . win . registry . current _ user . open _ sub _ key ( STR ) ; string [ ] run _ list = run _ key . get _ value _ names ( ) ; run _ key . close ( ) ; foreach ( string item in run _ list ) { if ( item . equals ( STR ) ) return true ; } return false ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; return false ; } } }


catch ( exception e )
string server _ str = $ STR ;

public static void update ( configuration config , bool force _ disable , pac _ server pac _ srv , bool no _ retry = false )

if ( ex . type ! = proxy _ exception _ type . unspecific & & ! no _ retry )
var ret = message _ box . show ( n . get _ string ( STR ) , n . get _ string ( STR ) , message _ box _ buttons . yes _ no , message _ box _ icon . warning ) ; if ( ret = = dialog _ result . yes ) { sysproxy . reset _ ie _ proxy ( ) ; update ( config , force _ disable , pac _ srv , true ) ; } } else { message _ box . show ( n . get _ string ( STR ) , n . get _ string ( STR ) , message _ box _ buttons . ok , message _ box _ icon . error ) ;
public static void update _ ie ( )

public static void enable ( ) { registry _ key registry = registry . current _ user . open _ sub _ key ( STR , true ) ; registry . set _ value ( STR , 1 ) ; registry . set _ value ( STR , STR ) ; system _ proxy . update _ ie ( ) ; } public static void disable ( )
system _ proxy . update _ ie ( ) ;
using statistics = dictionary < string , list < availability _ statistics . raw _ statistics _ data > > ;
public statistics raw _ statistics { get ; private set ; } public statistics filtered _ statistics { get ; private set ; } private int repeat = > config . repeat _ times _ num ;
var reply = await ping . send _ task _ async ( ip , timeout ) ;
thread . sleep ( timeout + new random ( ) . next ( ) % timeout ) ;

this . ping _ check _ box = new system . windows . forms . check _ box ( ) ;

private system . windows . forms . check _ box ping _ check _ box ;



unknown _ date _ time = new date _ time ( NUM , 1 , 1 ) ; }  private int repeat = > config . repeat _ times _ num ; private const int timeout _ milliseconds = NUM ;  private list < int > latency _ records ;  private long last _ inbound _ counter ; private list < int > inbound _ speed _ records ; private long last _ outbound _ counter ; private list < int > outbound _ speed _ records ;  private readonly time _ span delay _ before _ start = time _ span . from _ seconds ( 1 ) ; private readonly time _ span retry _ interval = time _ span . from _ minutes ( 2 ) ; private timer recorder ; private time _ span recording _ interval = > time _ span . from _ minutes ( config . data _ collection _ minutes ) ; private timer speed _ monior ; private readonly time _ span monitor _ interval = time _ span . from _ seconds ( 1 ) ; private timer writer ; private readonly time _ span writing _ interval = time _ span . from _ minutes ( 1 ) ; private shadowsocks _ controller controller ; private statistics _ strategy _ configuration config = > controller . statistics _ configuration ; private server current _ server = > controller . get _ current _ server ( ) ;
private availability _ statistics ( ) { raw _ statistics = new statistics ( ) ; } internal void update _ configuration ( shadowsocks _ controller controller ) { controller = controller ; reset ( ) ; try { if ( config . statistics _ enabled ) { start _ timer _ without _ state ( ref recorder , run , recording _ interval ) ;
start _ timer _ without _ state ( ref speed _ monior , update _ speed , monitor _ interval ) ; start _ timer _ without _ state ( ref writer , save , writing _ interval ) ;
writer ? . dispose ( ) ; }
} } private void start _ timer _ without _ state ( ref timer timer , timer _ callback callback , time _ span interval ) { if ( timer ? . change ( delay _ before _ start , interval ) = = null ) { timer = new timer ( callback , null , delay _ before _ start , interval ) ; } } private void update _ speed ( object )
update _ records ( ) ;
private async void update _ records ( ) { var current _ server _ record = new statistics _ record ( current _ server . identifier ( ) , inbound _ speed _ records , outbound _ speed _ records , latency _ records ) ; if ( ! config . ping ) { append _ record ( current _ server , current _ server _ record ) ; return ; } var icmp _ results = task _ ex . when _ all ( controller . get _ current _ configuration ( ) . configs . select ( icmp _ test ) ) ;
if ( result . server . equals ( current _ server ) )
append _ record ( current _ server , current _ server _ record ) ;
append _ record ( result . server , new statistics _ record ( result . server . identifier ( ) , result . roundtrip _ time ) ) ; } } } private void append _ record ( server server , statistics _ record record ) { list < statistics _ record > records ; if ( ! raw _ statistics . try _ get _ value ( server . identifier ( ) , out records ) ) { records = new list < statistics _ record > ( ) ; } records . add ( record ) ; raw _ statistics [ server . identifier ( ) ] = records ;

if ( config . by _ hour _ of _ day ) {
if ( current _ server = = null )

private void do _ clean _ logs ( ) { log _ message _ text _ box . clear ( ) ; } private void clean _ logs _ menu _ item _ click ( object sender , event _ args e ) { do _ clean _ logs ( ) ;
do _ clean _ logs ( ) ; }   private void do _ change _ font ( )
if ( ! top _ most _ trigger _ lock ) { trigger _ top _ most ( ) ; } } private void top _ most _ menu _ item _ click ( object sender , event _ args e ) { if ( ! top _ most _ trigger _ lock ) { trigger _ top _ most ( ) ; } }  private bool show _ toolbar _ trigger = false ; private void show _ toolbar _ menu _ item _ click ( object sender , event _ args e ) { show _ toolbar _ trigger = ! show _ toolbar _ trigger ; toolbar _ flow _ layout _ panel . visible = show _ toolbar _ trigger ; show _ toolbar _ menu _ item . checked = show _ toolbar _ trigger ;
this . main _ menu = new system . windows . forms . main _ menu ( this . components ) ;
this . view _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . clean _ logs _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . change _ font _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . wrap _ text _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . top _ most _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . menu _ item _ separater = new system . windows . forms . menu _ item ( ) ; this . show _ toolbar _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . top _ most _ check _ box = new system . windows . forms . check _ box ( ) ;
this . toolbar _ flow _ layout _ panel = new system . windows . forms . flow _ layout _ panel ( ) ;
this . view _ menu _ item . index = 1 ; this . view _ menu _ item . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . clean _ logs _ menu _ item , this . change _ font _ menu _ item , this . wrap _ text _ menu _ item , this . top _ most _ menu _ item , this . menu _ item _ separater , this . show _ toolbar _ menu _ item } ) ; this . view _ menu _ item . text = STR ;    this . clean _ logs _ menu _ item . index = 0 ; this . clean _ logs _ menu _ item . text = STR ; this . clean _ logs _ menu _ item . click + = new system . event _ handler ( this . clean _ logs _ menu _ item _ click ) ;    this . change _ font _ menu _ item . index = 1 ; this . change _ font _ menu _ item . text = STR ; this . change _ font _ menu _ item . click + = new system . event _ handler ( this . change _ font _ menu _ item _ click ) ;    this . wrap _ text _ menu _ item . index = 2 ; this . wrap _ text _ menu _ item . text = STR ; this . wrap _ text _ menu _ item . click + = new system . event _ handler ( this . wrap _ text _ menu _ item _ click ) ;    this . top _ most _ menu _ item . index = NUM ; this . top _ most _ menu _ item . text = STR ; this . top _ most _ menu _ item . click + = new system . event _ handler ( this . top _ most _ menu _ item _ click ) ;    this . menu _ item _ separater . index = NUM ; this . menu _ item _ separater . text = STR ;    this . show _ toolbar _ menu _ item . index = NUM ; this . show _ toolbar _ menu _ item . text = STR ; this . show _ toolbar _ menu _ item . click + = new system . event _ handler ( this . show _ toolbar _ menu _ item _ click ) ;    this . top _ most _ check _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( ( system . windows . forms . anchor _ styles . top | system . windows . forms . anchor _ styles . bottom ) | system . windows . forms . anchor _ styles . left ) ) ) ; this . top _ most _ check _ box . auto _ size = true ; this . top _ most _ check _ box . location = new system . drawing . point ( NUM , NUM ) ; this . top _ most _ check _ box . name = STR ; this . top _ most _ check _ box . size = new system . drawing . size ( NUM , NUM ) ; this . top _ most _ check _ box . tab _ index = NUM ; this . top _ most _ check _ box . text = STR ; this . top _ most _ check _ box . use _ visual _ style _ back _ color = true ; this . top _ most _ check _ box . checked _ changed + = new system . event _ handler ( this . top _ most _ check _ box _ checked _ changed ) ;
this . change _ font _ button . auto _ size = true ; this . change _ font _ button . location = new system . drawing . point ( NUM , NUM ) ;
this . clean _ logs _ button . auto _ size = true ; this . clean _ logs _ button . location = new system . drawing . point ( NUM , NUM ) ;

this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ;
this . toolbar _ flow _ layout _ panel . auto _ size = true ; this . toolbar _ flow _ layout _ panel . controls . add ( this . clean _ logs _ button ) ; this . toolbar _ flow _ layout _ panel . controls . add ( this . change _ font _ button ) ; this . toolbar _ flow _ layout _ panel . controls . add ( this . wrap _ text _ check _ box ) ; this . toolbar _ flow _ layout _ panel . controls . add ( this . top _ most _ check _ box ) ; this . toolbar _ flow _ layout _ panel . dock = system . windows . forms . dock _ style . fill ; this . toolbar _ flow _ layout _ panel . location = new system . drawing . point ( NUM , NUM ) ; this . toolbar _ flow _ layout _ panel . name = STR ; this . toolbar _ flow _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ; this . toolbar _ flow _ layout _ panel . tab _ index = 2 ;

private system . windows . forms . main _ menu main _ menu ;

private readonly int target _ port ;
target _ port = target _ port ;
new handler ( ) . start ( first _ packet , length , socket , target _ port ) ;
private class handler
private const int recv _ size = NUM ;
first _ packet = first _ packet ; first _ packet _ length = length ; local = socket ;
close ( ) ;
pipe _ remote _ receive _ callback , null ) ;
pipe _ connection _ receive _ callback , null ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ;
remote . begin _ receive ( remote _ recv _ buffer , 0 , recv _ size , 0 , pipe _ remote _ receive _ callback , null ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ;
close ( ) ;
if ( ! cached _ keys . contains _ key ( k ) ) { lock ( cached _ keys ) { if ( ! cached _ keys . contains _ key ( k ) ) { byte [ ] passbuf = encoding . ut . get _ bytes ( password ) ; key = new byte [ NUM ] ; byte [ ] iv = new byte [ NUM ] ; bytes _ to _ key ( passbuf , key ) ; cached _ keys [ k ] = key ; } } } if ( key = = null )

namespace shadowsocks _ forward _ proxy
public class direct _ connect : i _ forward _ proxy
namespace shadowsocks _ forward _ proxy
public class http _ proxy : i _ forward _ proxy

namespace shadowsocks _ forward _ proxy
public interface i _ forward _ proxy
namespace shadowsocks _ forward _ proxy
public class socks _ proxy : i _ forward _ proxy
this . components = new system . component _ model . container ( ) ; system . windows . forms . data _ visualization . charting . chart _ area chart _ area = new system . windows . forms . data _ visualization . charting . chart _ area ( ) ; system . windows . forms . data _ visualization . charting . legend legend = new system . windows . forms . data _ visualization . charting . legend ( ) ; system . windows . forms . data _ visualization . charting . series series = new system . windows . forms . data _ visualization . charting . series ( ) ; system . windows . forms . data _ visualization . charting . series series = new system . windows . forms . data _ visualization . charting . series ( ) ; system . windows . forms . data _ visualization . charting . series series = new system . windows . forms . data _ visualization . charting . series ( ) ;
this . by _ isp _ check _ box = new system . windows . forms . check _ box ( ) ; this . binding _ configuration = new system . windows . forms . binding _ source ( this . components ) ;
this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ; this . data _ collection _ minutes _ num = new system . windows . forms . numeric _ up _ down ( ) ; this . statistics _ enabled _ check _ box = new system . windows . forms . check _ box ( ) ; this . choice _ kept _ minutes _ num = new system . windows . forms . numeric _ up _ down ( ) ; this . by _ hour _ of _ day _ check _ box = new system . windows . forms . check _ box ( ) ; this . repeat _ times _ num = new system . windows . forms . numeric _ up _ down ( ) ;
this . calculation _ container = new system . windows . forms . flow _ layout _ panel ( ) ; this . ok _ button = new system . windows . forms . button ( ) ; this . cancel _ button = new system . windows . forms . button ( ) ;
( ( system . component _ model . i _ support _ initialize ) ( this . data _ collection _ minutes _ num ) ) . begin _ init ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . choice _ kept _ minutes _ num ) ) . begin _ init ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . repeat _ times _ num ) ) . begin _ init ( ) ;


this . split _ container . panel . controls . add ( this . label ) ; this . split _ container . panel . controls . add ( this . label ) ; this . split _ container . panel . controls . add ( this . data _ collection _ minutes _ num ) ; this . split _ container . panel . controls . add ( this . statistics _ enabled _ check _ box ) ; this . split _ container . panel . controls . add ( this . choice _ kept _ minutes _ num ) ; this . split _ container . panel . controls . add ( this . by _ hour _ of _ day _ check _ box ) ; this . split _ container . panel . controls . add ( this . repeat _ times _ num ) ;
this . split _ container . panel . controls . add ( this . by _ isp _ check _ box ) ;
this . label . auto _ size = true ; this . label . location = new system . drawing . point ( NUM , NUM ) ; this . label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ; this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ; this . label . tab _ index = NUM ; this . label . text = STR ;     this . label . auto _ size = true ; this . label . location = new system . drawing . point ( NUM , NUM ) ; this . label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ; this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ; this . label . tab _ index = NUM ; this . label . text = STR ;    this . data _ collection _ minutes _ num . data _ bindings . add ( new system . windows . forms . binding ( STR , this . binding _ configuration , STR , true ) ) ; this . data _ collection _ minutes _ num . increment = new decimal ( new int [ ] {
this . data _ collection _ minutes _ num . location = new system . drawing . point ( NUM , NUM ) ; this . data _ collection _ minutes _ num . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . data _ collection _ minutes _ num . maximum = new decimal ( new int [ ] { NUM , 0 , 0 , 0 } ) ; this . data _ collection _ minutes _ num . minimum = new decimal ( new int [ ] { NUM , 0 , 0 , 0 } ) ; this . data _ collection _ minutes _ num . name = STR ; this . data _ collection _ minutes _ num . size = new system . drawing . size ( NUM , NUM ) ; this . data _ collection _ minutes _ num . tab _ index = NUM ; this . data _ collection _ minutes _ num . value = new decimal ( new int [ ] { NUM , 0 , 0 , 0 } ) ;    this . statistics _ enabled _ check _ box . auto _ size = true ; this . statistics _ enabled _ check _ box . data _ bindings . add ( new system . windows . forms . binding ( STR , this . binding _ configuration , STR , true ) ) ; this . statistics _ enabled _ check _ box . location = new system . drawing . point ( NUM , NUM ) ; this . statistics _ enabled _ check _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . statistics _ enabled _ check _ box . name = STR ; this . statistics _ enabled _ check _ box . size = new system . drawing . size ( NUM , NUM ) ; this . statistics _ enabled _ check _ box . tab _ index = NUM ; this . statistics _ enabled _ check _ box . text = STR ; this . statistics _ enabled _ check _ box . use _ visual _ style _ back _ color = true ;    this . choice _ kept _ minutes _ num . data _ bindings . add ( new system . windows . forms . binding ( STR , this . binding _ configuration , STR , true ) ) ; this . choice _ kept _ minutes _ num . increment = new decimal ( new int [ ] { NUM , 0 , 0 , 0 } ) ; this . choice _ kept _ minutes _ num . location = new system . drawing . point ( NUM , NUM ) ; this . choice _ kept _ minutes _ num . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . choice _ kept _ minutes _ num . maximum = new decimal ( new int [ ] { NUM , 0 , 0 , 0 } ) ; this . choice _ kept _ minutes _ num . minimum = new decimal ( new int [ ] { NUM , 0 , 0 , 0 } ) ; this . choice _ kept _ minutes _ num . name = STR ; this . choice _ kept _ minutes _ num . size = new system . drawing . size ( NUM , NUM ) ; this . choice _ kept _ minutes _ num . tab _ index = NUM ; this . choice _ kept _ minutes _ num . value = new decimal ( new int [ ] { NUM , 0 , 0 , 0 } ) ;    this . by _ hour _ of _ day _ check _ box . auto _ size = true ; this . by _ hour _ of _ day _ check _ box . data _ bindings . add ( new system . windows . forms . binding ( STR , this . binding _ configuration , STR , true ) ) ; this . by _ hour _ of _ day _ check _ box . location = new system . drawing . point ( NUM , NUM ) ; this . by _ hour _ of _ day _ check _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . by _ hour _ of _ day _ check _ box . name = STR ; this . by _ hour _ of _ day _ check _ box . size = new system . drawing . size ( NUM , NUM ) ; this . by _ hour _ of _ day _ check _ box . tab _ index = NUM ; this . by _ hour _ of _ day _ check _ box . text = STR ; this . by _ hour _ of _ day _ check _ box . use _ visual _ style _ back _ color = true ;    this . repeat _ times _ num . data _ bindings . add ( new system . windows . forms . binding ( STR , this . binding _ configuration , STR , true ) ) ; this . repeat _ times _ num . location = new system . drawing . point ( NUM , NUM ) ; this . repeat _ times _ num . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . repeat _ times _ num . maximum = new decimal ( new int [ ] { NUM , 0 , 0 , 0 } ) ; this . repeat _ times _ num . name = STR ; this . repeat _ times _ num . size = new system . drawing . size ( NUM , NUM ) ; this . repeat _ times _ num . tab _ index = NUM ; this . repeat _ times _ num . value = new decimal ( new int [ ] {

( ( system . component _ model . i _ support _ initialize ) ( this . data _ collection _ minutes _ num ) ) . end _ init ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . choice _ kept _ minutes _ num ) ) . end _ init ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . repeat _ times _ num ) ) . end _ init ( ) ;

private system . windows . forms . check _ box by _ isp _ check _ box ;
private system . windows . forms . flow _ layout _ panel calculation _ container ;
private system . windows . forms . numeric _ up _ down repeat _ times _ num ;
private system . windows . forms . check _ box by _ hour _ of _ day _ check _ box ; private system . windows . forms . numeric _ up _ down choice _ kept _ minutes _ num ; private system . windows . forms . check _ box statistics _ enabled _ check _ box ; private system . windows . forms . label label ; private system . windows . forms . label label ; private system . windows . forms . numeric _ up _ down data _ collection _ minutes _ num ; private system . windows . forms . binding _ source binding _ configuration ; private system . windows . forms . button cancel _ button ; private system . windows . forms . button ok _ button ;
class statistics _ strategy : i _ strategy
public class statistics _ data { public int success _ times ; public int timed _ out _ times ; public int average _ response ; public int min _ response ; public int max _ response ; } public statistics _ strategy ( shadowsocks _ controller controller )
private void statistics _ strategy _ options _ item _ click ( object sender , event _ args e )
var statistics _ strategy _ options _ form = new statistics _ strategy _ configuration _ form ( controller ) ;
if ( controller . get _ current _ strategy ( ) . id = = id & & current _ server ! = best _ result . server ) { console . write _ line ( STR , best _ result . server . friendly _ name ( ) , 1 - best _ result . score ) ; }
public string id
public string name
public server get _ a _ server ( i _ strategy _ caller _ type type , ip _ end _ point local _ ip _ end _ point )
var old _ server = current _ server ; if ( old _ server = = null ) { choose _ new _ server ( controller . get _ current _ configuration ( ) . configs ) ; } if ( old _ server ! = current _ server ) { }
public void reload _ servers ( )
public void set _ failure ( server server )
public void update _ last _ read ( server server )
public void update _ last _ write ( server server )
public void update _ latency ( server server , time _ span latency )
configuration . add _ default _ server _ or _ server ( modified _ configuration ) ;
if ( last _ selected _ index = = - 1 | | last _ selected _ index > modified _ configuration . configs . count | | ! validate _ and _ save _ selected _ server _ details ( ) )
register _ application _ restart ( cmdline , ( int ) application _ restart _ flags . restart _ no _ crash | ( int ) application _ restart _ flags . restart _ no _ hang ) ; logging . debug ( STR + cmdline ) ;
static void main ( string [ ] args )
private long compare ( byte x , byte y , ulong a , int i ) { return ( long ) ( a % ( ulong ) ( x + i ) ) - ( long ) ( a % ( ulong ) ( y + i ) ) ;
private byte [ ] merge _ sort ( byte [ ] array , ulong a , int j )
listener = new socket ( address _ family . inter _ network ,
local local = new local ( NUM ) ; local . start ( ) ;
strategy ? . update _ last _ write ( server ) ;
public const string date _ time _ pattern = STR ;
private readonly time _ span delay _ before _ start = time _ span . from _ seconds ( 1 ) ;
private readonly time _ span retry _ interval = time _ span . from _ minutes ( 2 ) ; private time _ span interval = > time _ span . from _ minutes ( config . data _ collection _ minutes ) ;
public availability _ statistics ( shadowsocks _ controller controller ) { controller = controller ; global _ config = controller . get _ current _ configuration ( ) ; update _ configuration ( global _ config , controller . statistics _ configuration ) ;


int default _ port = NUM ; try
ip _ global _ properties properties = ip _ global _ properties . get _ ip _ global _ properties ( ) ; ip _ end _ point [ ] tcp _ end _ points = properties . get _ active _ tcp _ listeners ( ) ; list < int > used _ ports = new list < int > ( ) ; foreach ( ip _ end _ point end _ point in ip _ global _ properties . get _ ip _ global _ properties ( ) . get _ active _ tcp _ listeners ( ) ) { used _ ports . add ( end _ point . port ) ; } for ( int port = default _ port ; port < NUM ; port + + ) { if ( ! used _ ports . contains ( port ) ) { return port ; } }
catch ( exception e )
logging . log _ useful _ exception ( e ) ; return default _ port ;
switch _ proxy _ mode _ text _ box . text = config . switch _ system _ proxy _ mode ;
switch _ proxy _ mode _ label . text = n . get _ string ( STR ) ;
public string switch _ system _ proxy _ mode ;
switch _ system _ proxy _ mode = STR ;
this . switch _ proxy _ mode _ label = new system . windows . forms . label ( ) ;
this . switch _ proxy _ mode _ text _ box = new system . windows . forms . text _ box ( ) ;
this . table _ layout _ panel . controls . add ( this . switch _ proxy _ mode _ label , 0 , 1 ) ; this . table _ layout _ panel . controls . add ( this . switch _ allow _ lan _ label , 0 , 2 ) ; this . table _ layout _ panel . controls . add ( this . show _ logs _ label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . server _ move _ up _ label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . server _ move _ down _ label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( flow _ layout _ panel , 0 , NUM ) ;
this . table _ layout _ panel . controls . add ( this . switch _ proxy _ mode _ text _ box , 1 , 1 ) ; this . table _ layout _ panel . controls . add ( this . switch _ allow _ lan _ text _ box , 1 , 2 ) ; this . table _ layout _ panel . controls . add ( this . show _ logs _ text _ box , 1 , NUM ) ; this . table _ layout _ panel . controls . add ( this . server _ move _ up _ text _ box , 1 , NUM ) ; this . table _ layout _ panel . controls . add ( this . server _ move _ down _ text _ box , 1 , NUM ) ;
private system . windows . forms . label switch _ proxy _ mode _ label ;
private system . windows . forms . text _ box switch _ proxy _ mode _ text _ box ;
run _ key = registry . current _ user . open _ sub _ key ( STR , true ) ;
if ( item = = key )
else if ( item = = STR )





try {  ip _ address ip _ address ; bool parsed = ip _ address . try _ parse ( config . server , out ip _ address ) ; if ( ! parsed ) { ip _ host _ entry ip _ host _ info = dns . get _ host _ entry ( config . server ) ; ip _ address = ip _ host _ info . address _ list [ 0 ] ; } ip _ end _ point remote _ ep = new ip _ end _ point ( ip _ address , config . server _ port ) ; remote = new socket ( ip _ address . address _ family , socket _ type . stream , protocol _ type . tcp ) ;  remote . begin _ connect ( remote _ ep , new async _ callback ( connect _ callback ) , null ) ; } catch ( exception e ) { console . write _ line ( e . to _ string ( ) ) ; this . close ( ) ; }
if ( remote ! = null ) { remote . close ( ) ; }



using ( stream _ reader sr = new stream _ reader ( file . open _ read ( STR ) ) )
config config = simple _ json . simple _ json . deserialize _ object < config > ( sr . read _ to _ end ( ) ) ;

using ( stream _ writer sw = new stream _ writer ( file . open ( STR , file _ mode . create ) ) )
string json _ string = simple _ json . simple _ json . serialize _ object ( new { server = config . server , server _ port = config . server _ port , local _ port = config . local _ port , password = config . password } ) ; sw . write ( json _ string ) ; sw . flush ( ) ;
this . context _ menu = new context _ menu ( new menu _ item [ ] { this . enable _ item = create _ menu _ item ( STR , new event _ handler ( this . enable _ item _ click ) ) , create _ menu _ group ( STR , new menu _ item [ ] { this . pac _ mode _ item = create _ menu _ item ( STR , new event _ handler ( this . pac _ mode _ item _ click ) ) , this . global _ mode _ item = create _ menu _ item ( STR , new event _ handler ( this . global _ mode _ item _ click ) )
this . servers _ item = create _ menu _ group ( STR , new menu _ item [ ] {
this . config _ item = create _ menu _ item ( STR , new event _ handler ( this . config _ click ) )
this . auto _ startup _ item = create _ menu _ item ( STR , new event _ handler ( this . auto _ startup _ item _ click ) ) , this . share _ over _ lan _ item = create _ menu _ item ( STR , new event _ handler ( this . share _ over _ lan _ item _ click ) ) , create _ menu _ item ( STR , new event _ handler ( this . edit _ pac _ file _ item _ click ) ) ,
create _ menu _ item ( STR , new event _ handler ( this . qr _ code _ item _ click ) ) , create _ menu _ item ( STR , new event _ handler ( this . show _ log _ item _ click ) ) , create _ menu _ item ( STR , new event _ handler ( this . config _ click ) ) ,
create _ menu _ item ( STR , new event _ handler ( this . quit _ click ) )
logging . log _ useful _ exception ( e ) ;

md ( input , ( uint ) input . length , output ) ;
public static extern int _ ptr cipher _ info _ from _ string ( string cipher _ name ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern void cipher _ init ( int _ ptr ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern int cipher _ setup ( int _ ptr ctx , int _ ptr cipher _ info ) ;  dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern int cipher _ setkey ( int _ ptr ctx , byte [ ] key , int key _ bitlen , int operation ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern int cipher _ set _ iv ( int _ ptr ctx , byte [ ] iv , int iv _ len ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern int cipher _ reset ( int _ ptr ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern int cipher _ update ( int _ ptr ctx , byte [ ] input , int ilen , byte [ ] output , ref int olen ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern void cipher _ free ( int _ ptr ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern void md ( byte [ ] input , uint ilen , byte [ ] output ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern void cipher _ set _ operation _ ex ( int _ ptr ctx , int operation ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern int cipher _ get _ size _ ex ( ) ;
protected dictionary < string , dictionary < string , int [ ] > > ciphers ; protected dictionary < string , int [ ] > ciphers _ detail ;

protected abstract dictionary < string , dictionary < string , int [ ] > > get _ ciphers ( ) ;
ciphers _ detail = ciphers [ method ] ; cipher _ mbed _ name = ciphers _ detail . keys . first _ or _ default ( ) ; cipher _ info = ciphers [ method ] [ cipher _ mbed _ name ] ;
key _ len = cipher _ info [ 0 ] ; iv _ len = cipher _ info [ 1 ] ;
private static dictionary < string , dictionary < string , int [ ] > > ciphers = new dictionary < string , dictionary < string , int [ ] > > { { STR , new dictionary < string , int [ ] > { { STR , new int [ ] { NUM , NUM , cipher _ sals } } } } , { STR , new dictionary < string , int [ ] > { { STR , new int [ ] { NUM , NUM , cipher _ chach } } } } , { STR , new dictionary < string , int [ ] > { { STR , new int [ ] { NUM , NUM , cipher _ chach _ ietf } } } }
protected override dictionary < string , dictionary < string , int [ ] > > get _ ciphers ( )
public void test _ mbed _ tls _ encryption ( )
thread t = new thread ( new thread _ start ( run _ single _ mbed _ tls _ encryption _ thread ) ) ;
private void run _ single _ mbed _ tls _ encryption _ thread ( )
encryptor = new mbed _ tls _ encryptor ( STR , STR , false , false ) ; decryptor = new mbed _ tls _ encryptor ( STR , STR , false , false ) ;
if ( ret ! = 0 ) throw new crypto _ error _ exception ( string . format ( STR , ret ) ) ;

public override void cipher _ decrypt ( byte [ ] ciphertext , uint clen , byte [ ] plaintext , ref uint plen )
if ( ret ! = 0 ) throw new crypto _ error _ exception ( string . format ( STR , ret ) ) ;

foreach ( string method in stream _ open _ ssl _ encryptor . supported _ ciphers ( ) )
if ( ! registered _ encryptors . contains _ key ( method ) ) registered _ encryptors . add ( method , typeof ( stream _ open _ ssl _ encryptor ) ) ;
if ( ! registered _ encryptors . contains _ key ( method ) ) registered _ encryptors . add ( method , typeof ( stream _ sodium _ encryptor ) ) ; } foreach ( string method in stream _ mbed _ tls _ encryptor . supported _ ciphers ( ) ) { if ( ! registered _ encryptors . contains _ key ( method ) ) registered _ encryptors . add ( method , typeof ( stream _ mbed _ tls _ encryptor ) ) ; } foreach ( string method in aead _ open _ ssl _ encryptor . supported _ ciphers ( ) ) { if ( ! registered _ encryptors . contains _ key ( method ) ) registered _ encryptors . add ( method , typeof ( aead _ open _ ssl _ encryptor ) ) ; } foreach ( string method in aead _ sodium _ encryptor _ supported _ ciphers ) { if ( ! registered _ encryptors . contains _ key ( method ) ) registered _ encryptors . add ( method , typeof ( aead _ sodium _ encryptor ) ) ;
if ( ! registered _ encryptors . contains _ key ( method ) ) registered _ encryptors . add ( method , typeof ( aead _ mbed _ tls _ encryptor ) ) ;
if ( ret ! = 0 ) throw new crypto _ error _ exception ( string . format ( STR , ret ) ) ;
break ;
public override void cipher _ decrypt ( byte [ ] ciphertext , uint clen , byte [ ] plaintext , ref uint plen )
if ( ret ! = 0 ) throw new crypto _ error _ exception ( string . format ( STR , ret ) ) ;
break ;
this . main _ menu = new system . windows . forms . main _ menu ( this . components ) ;
this . view _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . clean _ logs _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . change _ font _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . wrap _ text _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . top _ most _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . menu _ item _ separater = new system . windows . forms . menu _ item ( ) ; this . show _ toolbar _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . top _ most _ check _ box = new system . windows . forms . check _ box ( ) ;
this . toolbar _ flow _ layout _ panel = new system . windows . forms . flow _ layout _ panel ( ) ;
this . view _ menu _ item . index = 1 ; this . view _ menu _ item . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . clean _ logs _ menu _ item , this . change _ font _ menu _ item , this . wrap _ text _ menu _ item , this . top _ most _ menu _ item , this . menu _ item _ separater , this . show _ toolbar _ menu _ item } ) ; this . view _ menu _ item . text = STR ;    this . clean _ logs _ menu _ item . index = 0 ; this . clean _ logs _ menu _ item . text = STR ; this . clean _ logs _ menu _ item . click + = new system . event _ handler ( this . clean _ logs _ menu _ item _ click ) ;    this . change _ font _ menu _ item . index = 1 ; this . change _ font _ menu _ item . text = STR ; this . change _ font _ menu _ item . click + = new system . event _ handler ( this . change _ font _ menu _ item _ click ) ;    this . wrap _ text _ menu _ item . index = 2 ; this . wrap _ text _ menu _ item . text = STR ; this . wrap _ text _ menu _ item . click + = new system . event _ handler ( this . wrap _ text _ menu _ item _ click ) ;    this . top _ most _ menu _ item . index = NUM ; this . top _ most _ menu _ item . text = STR ; this . top _ most _ menu _ item . click + = new system . event _ handler ( this . top _ most _ menu _ item _ click ) ;    this . menu _ item _ separater . index = NUM ; this . menu _ item _ separater . text = STR ;    this . show _ toolbar _ menu _ item . index = NUM ; this . show _ toolbar _ menu _ item . text = STR ; this . show _ toolbar _ menu _ item . click + = new system . event _ handler ( this . show _ toolbar _ menu _ item _ click ) ;    this . top _ most _ check _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( ( system . windows . forms . anchor _ styles . top | system . windows . forms . anchor _ styles . bottom ) | system . windows . forms . anchor _ styles . left ) ) ) ; this . top _ most _ check _ box . auto _ size = true ; this . top _ most _ check _ box . location = new system . drawing . point ( NUM , NUM ) ; this . top _ most _ check _ box . name = STR ; this . top _ most _ check _ box . size = new system . drawing . size ( NUM , NUM ) ; this . top _ most _ check _ box . tab _ index = NUM ; this . top _ most _ check _ box . text = STR ; this . top _ most _ check _ box . use _ visual _ style _ back _ color = true ; this . top _ most _ check _ box . checked _ changed + = new system . event _ handler ( this . top _ most _ check _ box _ checked _ changed ) ;
this . change _ font _ button . auto _ size = true ; this . change _ font _ button . location = new system . drawing . point ( NUM , NUM ) ;
this . clean _ logs _ button . auto _ size = true ; this . clean _ logs _ button . location = new system . drawing . point ( NUM , NUM ) ;

this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ;
this . toolbar _ flow _ layout _ panel . auto _ size = true ; this . toolbar _ flow _ layout _ panel . controls . add ( this . clean _ logs _ button ) ; this . toolbar _ flow _ layout _ panel . controls . add ( this . change _ font _ button ) ; this . toolbar _ flow _ layout _ panel . controls . add ( this . wrap _ text _ check _ box ) ; this . toolbar _ flow _ layout _ panel . controls . add ( this . top _ most _ check _ box ) ; this . toolbar _ flow _ layout _ panel . dock = system . windows . forms . dock _ style . fill ; this . toolbar _ flow _ layout _ panel . location = new system . drawing . point ( NUM , NUM ) ; this . toolbar _ flow _ layout _ panel . name = STR ; this . toolbar _ flow _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ; this . toolbar _ flow _ layout _ panel . tab _ index = 2 ;

private system . windows . forms . main _ menu main _ menu ;

private void do _ clean _ logs ( ) { log _ message _ text _ box . clear ( ) ; } private void clean _ logs _ menu _ item _ click ( object sender , event _ args e ) { do _ clean _ logs ( ) ;
do _ clean _ logs ( ) ; }   private void do _ change _ font ( )
if ( ! top _ most _ trigger _ lock ) { trigger _ top _ most ( ) ; } } private void top _ most _ menu _ item _ click ( object sender , event _ args e ) { if ( ! top _ most _ trigger _ lock ) { trigger _ top _ most ( ) ; } }  private bool show _ toolbar _ trigger = false ; private void show _ toolbar _ menu _ item _ click ( object sender , event _ args e ) { show _ toolbar _ trigger = ! show _ toolbar _ trigger ; toolbar _ flow _ layout _ panel . visible = show _ toolbar _ trigger ; show _ toolbar _ menu _ item . checked = show _ toolbar _ trigger ;
if ( command = = 1 )
byte [ ] response = { NUM , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 } ; connection . begin _ send ( response , 0 , response . length , socket _ flags . none , new async _ callback ( response _ callback ) , null ) ; } else if ( command = = NUM ) { read _ address ( handle _ udp _ associate ) ;
private void response _ callback ( i _ async _ result ar ) { try { connection . end _ send ( ar ) ; read _ address ( start _ connect ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; } } private void read _ address ( action on _ success ) { int atyp = connetion _ recv _ buffer [ NUM ] ; switch ( atyp ) { case 1 : read _ address ( NUM + 2 - 1 , on _ success ) ; break ; case NUM : int len = connetion _ recv _ buffer [ NUM ] ; read _ address ( len + 2 , on _ success ) ; break ; case NUM : read _ address ( NUM + 2 - 1 , on _ success ) ; break ; default : logging . debug ( STR + atyp ) ; close ( ) ; break ; } } private void read _ address ( int bytes _ remain , action on _ success )
connection . begin _ receive ( connetion _ recv _ buffer , 2 , recv _ size - 2 , socket _ flags . none , on _ address _ fully _ read , new object [ ] { bytes _ remain , on _ success } ) ;
var states = ( object [ ] ) ar . async _ state ; int bytes _ remain = ( int ) states [ 0 ] ; var on _ success = ( action ) states [ 1 ] ;
ip _ address addr ; ip _ address . try _ parse ( server , out addr ) ; if ( remarks . is _ null _ or _ empty ( ) ) { switch ( addr . address _ family ) { case address _ family . inter _ network : return $ STR ; case address _ family . inter _ network : return $ STR ; } } else { switch ( addr . address _ family ) { case address _ family . inter _ network : return $ STR ; case address _ family . inter _ network : return $ STR ; }
return null ;

var method = m . groups [ STR ] . value ; var path = m . groups [ STR ] . value ;
if ( ! parse _ host ( path ) )
else { var target _ url = new uri ( path ) ; if ( ! parse _ host ( target _ url . authority ) ) { throw new exception ( STR + line ) ; } var new _ request _ line = $ STR tail STR ; headers . enqueue ( new _ request _ line ) ; } } else { throw new format _ exception ( STR ) ; } } else {  if ( ! line . starts _ with ( STR ) ) { headers . enqueue ( line ) ; } else { if ( line . starts _ with ( STR ) ) { headers . enqueue ( line . substring ( NUM ) ) ; } }
if ( bytes _ read > = NUM ) { command = connetion _ recv _ buffer [ 1 ] ;
connection . begin _ send ( response , 0 , response . length , 0 , new async _ callback ( start _ connect ) , null ) ;
this . pac _ url _ text _ box . anchor = system . windows . forms . anchor _ styles . left ; this . pac _ url _ text _ box . location = new system . drawing . point ( NUM , NUM ) ;
this . pac _ url _ label . location = new system . drawing . point ( NUM , NUM ) ; this . pac _ url _ label . margin = new system . windows . forms . padding ( NUM ) ;
this . client _ size = new system . drawing . size ( NUM , NUM ) ; this . controls . add ( this . table _ layout _ panel ) ;
string encoding = hints = = null | | ! hints . contains _ key ( encode _ hint _ type . character _ set ) ? null : ( string ) hints [ encode _ hint _ type . character _ set ] ; if ( encoding = = null ) { encoding = default _ byte _ mode _ encoding ; } bool generate _ eci = ! default _ byte _ mode _ encoding . equals ( encoding ) ;
mode mode = choose _ mode ( content , encoding ) ;

throw new writer _ exception ( STR ) ;
throw new writer _ exception ( STR ) ;
throw new writer _ exception ( STR ) ;
throw new writer _ exception ( STR ) ;
throw new writer _ exception ( num _ letters + STR + ( ( 1 < < num _ bits ) - 1 ) ) ;
throw new writer _ exception ( STR + mode ) ; } internal static void append _ numeric _ bytes ( string content , bit _ array bits ) { int length = content . length ; int i = 0 ; while ( i < length ) { int num = content [ i ] - '0' ; if ( i + 2 < length ) {  int num = content [ i + 1 ] - '0' ; int num = content [ i + 2 ] - '0' ; bits . append _ bits ( num * NUM + num * NUM + num , NUM ) ; i + = NUM ; } else if ( i + 1 < length ) {  int num = content [ i + 1 ] - '0' ; bits . append _ bits ( num * NUM + num , NUM ) ; i + = 2 ; } else {  bits . append _ bits ( num , NUM ) ; i + + ; } } } internal static void append _ alphanumeric _ bytes ( string content , bit _ array bits ) { int length = content . length ; int i = 0 ; while ( i < length ) { int code = get _ alphanumeric _ code ( content [ i ] ) ; if ( code = = - 1 ) { throw new writer _ exception ( ) ; } if ( i + 1 < length ) { int code = get _ alphanumeric _ code ( content [ i + 1 ] ) ; if ( code = = - 1 ) { throw new writer _ exception ( ) ; }  bits . append _ bits ( code * NUM + code , NUM ) ; i + = 2 ; } else {  bits . append _ bits ( code , NUM ) ; i + + ; } }
throw new writer _ exception ( uee . message , uee ) ;
throw new writer _ exception ( ) ;
throw new writer _ exception ( ) ;

class pac _ server : listener . service

public pac _ server ( ) { this . watch _ pac _ file ( ) ; } public bool handle ( byte [ ] first _ packet , int length , socket socket )
string request = encoding . ut . get _ string ( first _ packet , 0 , length ) ; string [ ] lines = request . split ( '\r' , '\n' ) ; bool host _ match = false , path _ match = false ; foreach ( string line in lines )
string [ ] kv = line . split ( new char [ ] { ':' } , 2 ) ; if ( kv . length = = 2 ) { if ( kv [ 0 ] = = STR ) { if ( kv [ 1 ] . trim ( ) = = ( ( ip _ end _ point ) socket . local _ end _ point ) . to _ string ( ) ) { host _ match = true ; } } } else if ( kv . length = = 1 ) { if ( line . index _ of ( STR ) > = 0 ) { path _ match = true ; } }
if ( host _ match & & path _ match )
send _ response ( first _ packet , length , socket ) ; return true ;
return false ;
catch ( argument _ exception )
return false ;
public void send _ response ( byte [ ] first _ packet , int length , socket socket )


ip _ end _ point local _ end _ point = ( ip _ end _ point ) socket . local _ end _ point ; string proxy = get _ pac _ address ( first _ packet , length , local _ end _ point ) ;
string text = string . format ( @ STR
byte [ ] response = system . text . encoding . ut . get _ bytes ( text ) ; socket . begin _ send ( response , 0 , response . length , 0 , new async _ callback ( send _ callback ) , socket ) ; util . utils . release _ memory ( ) ;
socket . close ( ) ;
private string get _ pac _ address ( byte [ ] request _ buf , int length , ip _ end _ point local _ end _ point )
return STR + local _ end _ point . address + STR ;
public bool handle ( byte [ ] first _ packet , int length , socket socket ) { if ( length < 2 | | first _ packet [ 0 ] ! = NUM ) { return false ; }
server server , server _ with _ remark , server _ with _ plugin , server _ with _ plugin _ and _ remark ; string server _ canon _ url , server _ with _ remark _ canon _ url , server _ with _ plugin _ canon _ url , server _ with _ plugin _ and _ remark _ canon _ url ; server server , server _ with _ remark , server _ with _ plugin , server _ with _ plugin _ and _ remark ; string server _ canon _ url , server _ with _ remark _ canon _ url , server _ with _ plugin _ canon _ url , server _ with _ plugin _ and _ remark _ canon _ url ; test _ initialize public void prepare _ test _ data ( ) { server = new server
server _ canon _ url = STR ;  server = new server
server _ canon _ url = STR ; server _ with _ remark = new server { server = server . server , server _ port = server . server _ port , password = server . password , method = server . method ,
server _ with _ remark _ canon _ url = STR ; server _ with _ remark = new server
server _ with _ remark _ canon _ url = STR ; server _ with _ plugin = new server { server = server . server , server _ port = server . server _ port , password = server . password , method = server . method ,
server _ with _ plugin _ canon _ url =
server _ with _ plugin = new server
server _ with _ plugin _ canon _ url =
server _ with _ plugin _ and _ remark = new server { server = server . server , server _ port = server . server _ port , password = server . password , method = server . method , plugin = server _ with _ plugin . plugin , plugin _ opts = server _ with _ plugin . plugin _ opts , remarks = server _ with _ remark . remarks } ; server _ with _ plugin _ and _ remark _ canon _ url =
server _ with _ plugin _ and _ remark = new server
server _ with _ plugin _ and _ remark _ canon _ url =
} test _ method public void test _ parse _ url _ server ( ) { run _ parse _ shadowsocks _ url _ test ( string . join ( STR , server _ canon _ url ,
server , server , server _ with _ remark , server _ with _ remark } ) ; run _ parse _ shadowsocks _ url _ test ( string . join ( STR , STR , STR , STR , STR , STR , server _ with _ plugin _ canon _ url , server _ with _ plugin _ and _ remark _ canon _ url , STR ) , new [ ] { server , server , server _ with _ remark , server _ with _ remark , server _ with _ plugin , server _ with _ plugin _ and _ remark , server _ with _ plugin _ and _ remark } ) ; } test _ method public void test _ parse _ url _ server ( ) {
public void test _ sip _ plugin _ no _ plugin ( )



reg _ hotkey _ from _ string ( hotkey _ config . switch _ system _ proxy , STR , switch _ system _ proxy _ label ) & & reg _ hotkey _ from _ string ( hotkey _ config . switch _ system _ proxy _ mode , STR , switch _ proxy _ mode _ label ) & & reg _ hotkey _ from _ string ( hotkey _ config . switch _ allow _ lan , STR , switch _ allow _ lan _ label ) & & reg _ hotkey _ from _ string ( hotkey _ config . show _ logs , STR , show _ logs _ label ) & & reg _ hotkey _ from _ string ( hotkey _ config . server _ move _ up , STR , server _ move _ up _ label ) & & reg _ hotkey _ from _ string ( hotkey _ config . server _ move _ down , STR , server _ move _ down _ label ) ;
private bool reg _ hotkey _ from _ string ( string hotkey _ str , string callback _ name , label indicator = null )
hot _ keys . unreg _ existing _ hotkey ( callback ) ; if ( indicator ! = null ) { indicator . reset _ back _ color ( ) ; }
bool reg _ result = ( hot _ keys . reg _ hotkey ( hotkey , callback ) ) ;

list < string > ret = new list < string > ( domains . count + NUM ) { STR } ;
ret . add ( $ STR ) ;
update _ checker . check _ update ( config , NUM ) ;
this . table _ layout _ panel . controls . add ( this . encryption _ label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . encryption _ select , 1 , NUM ) ; this . table _ layout _ panel . controls . add ( this . timeout _ label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . timeout _ text _ box , 1 , NUM ) ; this . table _ layout _ panel . controls . add ( this . plugin _ label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . plugin _ options _ text _ box , 1 , NUM ) ; this . table _ layout _ panel . controls . add ( this . show _ passwd _ check _ box , 1 , NUM ) ;
this . table _ layout _ panel . row _ count = NUM ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ;
var configuration = json _ convert . deserialize _ object < statistics _ strategy _ configuration > ( content ) ;
catch ( file _ not _ found _ exception e )
this . keep _ choice _ for _ label = new system . windows . forms . label ( ) ; this . minutes _ label = new system . windows . forms . label ( ) ;
this . collect _ data _ per _ label = new system . windows . forms . label ( ) ; this . minutes _ label = new system . windows . forms . label ( ) ;
this . package _ per _ ping _ label = new system . windows . forms . label ( ) ;
this . final _ score _ label = new system . windows . forms . label ( ) ;

this . split _ container . panel . controls . add ( this . collect _ data _ per _ label ) ; this . split _ container . panel . controls . add ( this . minutes _ label ) ;
this . split _ container . panel . controls . add ( this . package _ per _ ping _ label ) ; this . split _ container . panel . controls . add ( this . keep _ choice _ for _ label ) ;
this . split _ container . panel . controls . add ( this . minutes _ label ) ;
this . split _ container . panel . controls . add ( this . final _ score _ label ) ;
this . final _ score _ label . auto _ size = true ; this . final _ score _ label . location = new system . drawing . point ( NUM , NUM ) ; this . final _ score _ label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ; this . final _ score _ label . name = STR ; this . final _ score _ label . size = new system . drawing . size ( NUM , NUM ) ; this . final _ score _ label . tab _ index = 0 ; this . final _ score _ label . text = STR ; this . calculatin _ tip . set _ tool _ tip ( this . final _ score _ label , STR ) ;

private system . windows . forms . label keep _ choice _ for _ label ; private system . windows . forms . label minutes _ label ;
private system . windows . forms . label final _ score _ label ;
private system . windows . forms . label package _ per _ ping _ label ;
private system . windows . forms . label collect _ data _ per _ label ; private system . windows . forms . label minutes _ label ;

create _ menu _ group ( STR , new menu _ item [ ] { create _ menu _ item ( STR , new event _ handler ( this . show _ log _ item _ click ) ) , this . verbose _ logging _ toggle _ item = create _ menu _ item ( STR , new event _ handler ( this . verbose _ logging _ toggle _ item _ click ) ) , create _ menu _ group ( STR , new menu _ item [ ] { create _ menu _ item ( STR , new event _ handler ( this . check _ updates _ item _ click ) ) , new menu _ item ( STR ) , this . auto _ check _ updates _ toggle _ item = create _ menu _ item ( STR , new event _ handler ( this . auto _ check _ updates _ toggle _ item _ click ) ) , this . check _ pre _ release _ toggle _ item = create _ menu _ item ( STR , new event _ handler ( this . check _ pre _ release _ toggle _ item _ click ) ) , } ) , create _ menu _ item ( STR , new event _ handler ( this . about _ item _ click ) ) ,

using shadowsocks _ controller _ service ;


enable _ status _ changed ? . invoke ( this , new event _ args ( ) ) ;
enable _ global _ changed ? . invoke ( this , new event _ args ( ) ) ;
share _ over _ lan _ status _ changed ? . invoke ( this , new event _ args ( ) ) ;
pac _ file _ ready _ to _ open ? . invoke ( this , new path _ event _ args ( ) { path = pac _ filename } ) ;
user _ rule _ file _ ready _ to _ open ? . invoke ( this , new path _ event _ args ( ) { path = user _ rule _ filename } ) ;
if ( availability _ statistics ! = null ) { availability _ statistics . update _ configuration ( this ) ; config . availability _ statistics = enabled ; save _ config ( config ) ; }
config _ changed ? . invoke ( this , new event _ args ( ) ) ;
config _ changed ? . invoke ( this , new event _ args ( ) ) ;
config _ changed ? . invoke ( this , new event _ args ( ) ) ;
config _ changed ? . invoke ( this , new event _ args ( ) ) ;
config _ changed ? . invoke ( this , new event _ args ( ) ) ;
config _ changed ? . invoke ( this , new event _ args ( ) ) ;
config _ changed ? . invoke ( this , new event _ args ( ) ) ;
list < listener . i _ service > services = new list < listener . i _ service > { tcp _ relay , udp _ relay , pac _ server , new port _ forwarder ( privoxy _ runner . running _ port ) } ;
if ( e is socket _ exception se ) {
traffic _ thread = new thread ( new thread _ start ( ( ) = > traffic _ statistics ( queue _ max _ size ) ) ) { is _ background = true } ;
current = new traffic _ per _ second { inbound _ counter = inbound _ counter , outbound _ counter = outbound _ counter } ;
socket . begin _ receive ( line _ buffer , 0 , max _ line _ bytes , 0 , receive _ callback , 0 ) ;
on _ finish ( length ) ;
length + = bytes _ read ; int i ; while ( ( i = index _ of ( line _ buffer , buffer _ index , length , delimiter _ bytes , delimiter _ search _ offset _ table , delimiter _ search _ char _ table ) ) ! = - 1 ) { var decode _ len = i - buffer _ index ; string line = encoding . get _ string ( line _ buffer , buffer _ index , decode _ len ) ; buffer _ index = i + delimiter _ bytes . length ; length - = decode _ len ; length - = delimiter _ bytes . length ; var stop = on _ line _ read ( line , state ) ; if ( stop ) { on _ finish ( length ) ; return ; } } if ( length = = line _ buffer . length ) { on _ exception ( new index _ out _ of _ range _ exception ( STR ) ) ; on _ finish ( length ) ; return ; } if ( buffer _ index > 0 ) { buffer . block _ copy ( line _ buffer , buffer _ index , line _ buffer , 0 , length ) ; buffer _ index = 0 ; } socket . begin _ receive ( line _ buffer , length , line _ buffer . length - length , 0 , receive _ callback , length ) ;
on _ finish ( length ) ; }
private void on _ finish ( int length ) { on _ finish ? . invoke ( line _ buffer , buffer _ index , length , state ) ;
public static int index _ of ( byte [ ] haystack , int index , int length , byte [ ] needle , int [ ] offset _ table , int [ ] char _ table )
catch ( exception ex )
private ip _ end _ point remote _ end _ point ;
ip _ address ip _ address ; bool parsed = ip _ address . try _ parse ( server . server , out ip _ address ) ; if ( ! parsed ) { ip _ host _ entry ip _ host _ info = dns . get _ host _ entry ( server . server ) ; ip _ address = ip _ host _ info . address _ list [ 0 ] ; } remote _ end _ point = new ip _ end _ point ( ip _ address , server . server _ port ) ; remote = new socket ( remote _ end _ point . address _ family , socket _ type . dgram , protocol _ type . udp ) ;
icon _ copy . set _ pixel ( x , y , color . from _ argb ( color . a , color . r , 0 , 0 ) ) ;
icon _ copy . set _ pixel ( x , y , color . from _ argb ( color . a , 0 , color . g , 0 ) ) ;
icon _ copy . set _ pixel ( x , y , color . from _ argb ( color . a , color . r , color . g , 0 ) ) ;

try { var ip = dns . get _ host _ addresses ( server . server ) . first ( ip = > ( ip . address _ family = = address _ family . inter _ network | | ip . address _ family = = address _ family . inter _ network ) ) ; var ping = new ping ( ) ; foreach ( var timestamp in enumerable . range ( 0 , repeat ) . select ( = > date _ time . now . to _ string ( date _ time _ pattern ) ) ) {  try { var reply = await ping . send _ task _ async ( ip , timeout ) ; ret . add ( new list < key _ value _ pair < string , string > >
thread . sleep ( timeout + new random ( ) . next ( ) % timeout ) ;  } catch ( exception e ) { logging . error ( $ STR ) ; logging . log _ useful _ exception ( e ) ; } } } catch ( exception e ) { logging . error ( $ STR ) ; logging . log _ useful _ exception ( e ) ;
remote . begin _ connect ( dest _ end _ point , callback , state ) ;
remote . end _ connect ( async _ result ) ; remote . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ;

using shadowsocks _ util _ sockets ;
remote ? . dispose ( ) ;
remote . end _ connect ( ar ) ; remote . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ;
private void update _ system _ proxy ( )
if ( config . enabled )
internal static byte [ ] proxy _ pac _ txt {
object obj = resource _ manager . get _ object ( STR , resource _ culture ) ; return ( ( byte [ ] ) ( obj ) ) ;
string pac = get _ pac _ content ( ) ;

this . context _ menu = new system . windows . forms . context _ menu ( ) ; this . enable _ item = new system . windows . forms . menu _ item ( ) ; this . about _ item = new system . windows . forms . menu _ item ( ) ; this . menu _ item = new system . windows . forms . menu _ item ( ) ; this . quit _ item = new system . windows . forms . menu _ item ( ) ; this . config _ item = new system . windows . forms . menu _ item ( ) ;




private system . windows . forms . context _ menu context _ menu ; private system . windows . forms . menu _ item enable _ item ; private system . windows . forms . menu _ item about _ item ; private system . windows . forms . menu _ item menu _ item ; private system . windows . forms . menu _ item quit _ item ; private system . windows . forms . menu _ item config _ item ;

this . table _ layout _ panel . location = new system . drawing . point ( NUM , NUM ) ; this . table _ layout _ panel . margin = new system . windows . forms . padding ( NUM ) ;


string orig _ pac _ url = controller . get _ configuration ( ) . pac _ url ; string pac _ url = microsoft . visual _ basic . interaction . input _ box ( n . get _ string ( STR ) , n . get _ string ( STR ) , orig _ pac _ url , - 1 , - 1 ) ; if ( ! string . is _ null _ or _ empty ( pac _ url ) & & pac _ url ! = orig _ pac _ url ) { controller . save _ pac _ url ( pac _ url ) ; }
update _ completed ? . invoke ( this , new result _ event _ args ( true ) ) ;
error ? . invoke ( this , new error _ event _ args ( ex ) ) ;
using system ;
using system _ globalization ; using system _ io ;
if ( culture _ info . current _ culture . ietf _ language _ tag . starts _ with ( STR , string _ comparison . ordinal _ ignore _ case ) )
using ( var sr = new string _ reader ( resources . cn ) )
string line ; while ( ( line = sr . read _ line ( ) ) ! = null )
if ( line [ 0 ] = = '#' ) continue ; var pos = line . index _ of ( '=' ) ; if ( pos < 1 ) continue ; strings [ line . substring ( 0 , pos ) ] = line . substring ( pos + 1 ) ;
if ( item . equals ( key , string _ comparison . ordinal _ ignore _ case ) )
else if ( item . equals ( STR , string _ comparison . ordinal _ ignore _ case ) )
if ( path . equals ( value , string _ comparison . ordinal _ ignore _ case ) )
object [ ] state = ( object [ ] ) ar . async _ state ; socket conn = ( socket ) state [ 0 ] ; byte [ ] request _ buf = ( byte [ ] ) state [ 1 ] ;
string proxy = get _ pac _ address ( request _ buf , local _ end _ point ) ;

private configuration config ;
this . config = config ;
local _ end _ point = new ip _ end _ point ( ip _ address . any , config . local _ port ) ;
local _ end _ point = new ip _ end _ point ( ip _ address . loopback , config . local _ port ) ;
bool parsed = ip _ address . try _ parse ( server . server , out ip _ address ) ;
ip _ host _ entry ip _ host _ info = dns . get _ host _ entry ( server . server ) ;
ip _ end _ point remote _ ep = new ip _ end _ point ( ip _ address , server . server _ port ) ;



public sealed class availability _ statistics
private const int timeout _ milliseconds = NUM ; private readonly time _ span delay _ before _ start = time _ span . from _ seconds ( 1 ) ;
private shadowsocks _ controller controller ;

return server ! = current _ server ? empty : outbound _ speed . to _ string ( ) ;
return server ! = current _ server ? empty : inbound _ speed . to _ string ( ) ;
current _ server = controller . get _ current _ server ( ) ;
internal void update _ configuration ( shadowsocks _ controller controller ) { controller = controller ;
set ( controller . statistics _ configuration ) ; servers = controller . get _ current _ configuration ( ) . configs ; } private void filter _ raw _ statistics ( )
availability _ statistics . update _ latency ( server , ( int ) latency . total _ milliseconds ) ;
availability _ statistics . update _ inbound _ counter ( server , n ) ;
availability _ statistics . update _ outbound _ counter ( server , n ) ;
kill _ process ( process ) ;
inbound _ speed _ records . get _ or _ add ( id , ( k ) = > { list < int > records = new list < int > ( ) ; records . add ( inbound _ speed ) ; return records ; } ) ;
outbound _ speed _ records . get _ or _ add ( id , ( k ) = > { list < int > records = new list < int > ( ) ; records . add ( outbound _ speed ) ; return records ; } ) ;


} private void update _ records ( )
if ( config . ping ) { my _ ping ping = new my _ ping ( server , repeat ) ; ping . completed + = ping _ completed ; ping . start ( new ping _ state { state = state , record = record } ) ; } else if ( ! record . is _ empty _ data ( ) ) { append _ record ( id , record ) ; } } if ( ! config . ping ) { save ( ) ; filter _ raw _ statistics ( ) ; } } private void ping _ completed ( object sender , my _ ping . completed _ event _ args e ) { ping _ state ping _ state = ( ping _ state ) e . user _ state ; update _ records _ state state = ping _ state . state ; server server = e . server ; statistics _ record record = ping _ state . record ; record . set _ response ( e . roundtrip _ time ) ; if ( ! record . is _ empty _ data ( ) ) { append _ record ( server . identifier ( ) , record ) ; } logging . debug ( $ STR ) ; if ( interlocked . decrement ( ref state . counter ) = = 0 ) { save ( ) ; filter _ raw _ statistics ( ) ;
try { list < statistics _ record > records ; lock ( raw _ statistics ) { if ( ! raw _ statistics . try _ get _ value ( server _ identifier , out records ) ) { records = new list < statistics _ record > ( ) ; raw _ statistics [ server _ identifier ] = records ; } } records . add ( record ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; }
string content ;  content = json _ convert . serialize _ object ( raw _ statistics , formatting . indented ) ;  content = json _ convert . serialize _ object ( raw _ statistics , formatting . none ) ;

latency _ records . get _ or _ add ( server . identifier ( ) , ( k ) = > {  list < int > records = new list < int > ( ) ; records . add ( latency ) ; return records ; } ) ;
inbound _ counter . add _ or _ update ( server . identifier ( ) , ( k ) = > { last _ inbound _ counter . get _ or _ add ( server . identifier ( ) , 0 ) ; return n ; } , ( k , v ) = > ( v + n ) ) ;
outbound _ counter . add _ or _ update ( server . identifier ( ) , ( k ) = > { last _ outbound _ counter . get _ or _ add ( server . identifier ( ) , 0 ) ; return n ; } , ( k , v ) = > ( v + n ) ) ; } class update _ records _ state { public int counter ; } class ping _ state { public update _ records _ state state ; public statistics _ record record ; } class my _ ping {  public const int timeout _ milliseconds = NUM ; public event _ handler < completed _ event _ args > completed ; private server server ; private int repeat ; private ip _ address ip ; private ping ping ; private list < int? > roundtrip _ time ; public my _ ping ( server server , int repeat ) { this . server = server ; this . repeat = repeat ; roundtrip _ time = new list < int? > ( repeat ) ; ping = new ping ( ) ; ping . ping _ completed + = ping _ ping _ completed ; } public void start ( object userstate ) { if ( server . server = = STR ) { fire _ completed ( new exception ( STR ) , userstate ) ; return ; } new task ( ( ) = > icmp _ test ( 0 , userstate ) ) . start ( ) ; } private void icmp _ test ( int delay , object userstate ) { try { logging . debug ( $ STR ) ; if ( ip = = null ) { ip = dns . get _ host _ addresses ( server . server ) . first ( ip = > ip . address _ family = = address _ family . inter _ network | | ip . address _ family = = address _ family . inter _ network ) ; } repeat - - ; if ( delay > 0 ) thread . sleep ( delay ) ; ping . send _ async ( ip , timeout _ milliseconds , userstate ) ; } catch ( exception e ) { logging . error ( $ STR ) ; logging . log _ useful _ exception ( e ) ; fire _ completed ( e , userstate ) ; } } private void ping _ ping _ completed ( object sender , ping _ completed _ event _ args e ) { try { if ( e . reply . status = = ip _ status . success ) { logging . debug ( $ STR ) ; roundtrip _ time . add ( ( int? ) e . reply . roundtrip _ time ) ; } else { logging . debug ( $ STR ) ; roundtrip _ time . add ( null ) ; } test _ next ( e . user _ state ) ; } catch ( exception ex ) { logging . error ( $ STR ) ; logging . log _ useful _ exception ( ex ) ; fire _ completed ( ex , e . user _ state ) ; } } private void test _ next ( object userstate ) { if ( repeat > 0 ) {  int delay = timeout _ milliseconds + new random ( ) . next ( ) % timeout _ milliseconds ; new task ( ( ) = > icmp _ test ( delay , userstate ) ) . start ( ) ; } else { fire _ completed ( null , userstate ) ; } } private void fire _ completed ( exception error , object userstate ) { completed ? . invoke ( this , new completed _ event _ args { error = error , server = server , roundtrip _ time = roundtrip _ time , user _ state = userstate } ) ; } public class completed _ event _ args : event _ args { public exception error ; public server server ; public list < int? > roundtrip _ time ; public object user _ state ; }


system _ proxy . update ( config , false , pac _ server ) ;
system _ proxy . update ( config , false , pac _ server ) ;
public class pac _ server : listener . service

request _ buf
conn . begin _ receive ( request _ buf , 0 , request _ buf . length , 0 ,
byte [ ] buffer = new byte [ NUM ] ; memory _ stream sb = new memory _ stream ( ) ;
while ( ( n = input . read ( buffer , 0 , buffer . length ) ) > 0 )
sb . write ( buffer , 0 , n ) ;
return system . text . encoding . ut . get _ string ( sb . to _ array ( ) ) ;
private const string proxy _ auth _ template = STR + http _ crlf ; public void begin _ connect _ dest ( end _ point dest _ end _ point , async _ callback callback , object state , network _ credential auth = null )
string auth _ info = STR ; if ( auth ! = null ) { string auth _ key = convert . to _ base _ string ( encoding . ut . get _ bytes ( auth . user _ name + STR + auth . password ) ) ; auth _ info = string . format ( proxy _ auth _ template , auth _ key ) ; } string request = string . format ( http _ connect _ template , dest _ end _ point , auth _ info ) ;
new async _ session < server _ timer > ( session , connect _ timer ) , auth ) ;
proxy _ type _ combo _ box . enabled = use _ auth _ check _ box . enabled = auth _ user _ text _ box . enabled = auth _ pwd _ text _ box . enabled = false ;
if ( modified _ configuration = = null ) {

public static extern void ss _ sha _ hmac _ ex ( byte [ ] key , uint keylen ,
if ( disposed ) return ;
}  if ( encrypt _ ctx ! = int _ ptr . zero ) { mbed _ tls . cipher _ free ( encrypt _ ctx ) ; marshal . free _ h _ global ( encrypt _ ctx ) ; encrypt _ ctx = int _ ptr . zero ; } if ( decrypt _ ctx ! = int _ ptr . zero ) { mbed _ tls . cipher _ free ( decrypt _ ctx ) ; marshal . free _ h _ global ( decrypt _ ctx ) ; decrypt _ ctx = int _ ptr . zero ;
if ( disposed ) return ; disposed = true ;

private void close ( )
if ( handle ! = int _ ptr . zero ) { close _ handle ( handle ) ; handle = int _ ptr . zero ; } } ~ job ( ) { dispose ( false ) ;
var inbound = inbound _ speed _ records ? . where ( s = > s > 0 ) . to _ list ( ) ; if ( inbound ! = null & & inbound . any ( ) )
average _ inbound _ speed = ( int ) inbound . average ( ) ; min _ inbound _ speed = inbound . min ( ) ; max _ inbound _ speed = inbound . max ( ) ;
var outbound = outbound _ speed _ records ? . where ( s = > s > 0 ) . to _ list ( ) ; if ( outbound ! = null & & outbound . any ( ) )
average _ outbound _ speed = ( int ) outbound . average ( ) ; min _ outbound _ speed = outbound . min ( ) ; max _ outbound _ speed = outbound . max ( ) ;
var latency = latency _ records ? . where ( s = > s > 0 ) . to _ list ( ) ; if ( latency ! = null & & latency . any ( ) )
average _ latency = ( int ) latency . average ( ) ; min _ latency = latency . min ( ) ; max _ latency = latency . max ( ) ;
package _ loss _ percentage = ( int ) ( data _ group . average ( data = > data . package _ loss ) ? ? 0 ) * NUM
foreach ( var data in final _ data . where ( data = > data . speed ! = 0 | | data . package _ loss _ percentage ! = 0 | | data . ping ! = 0 ) )

using system _ threading ;


private dictionary < string , list < availability _ statistics . raw _ statistics _ data > > filtered _ statistics ;

filtered _ statistics = controller . availability _ statistics . raw _ statistics ? ? filtered _ statistics ? ? new dictionary < string , list < availability _ statistics . raw _ statistics _ data > > ( ) ;
private float get _ score ( string server _ name )
list < availability _ statistics . raw _ statistics _ data > data _ list ; if ( filtered _ statistics = = null | | ! filtered _ statistics . try _ get _ value ( server _ name , out data _ list ) ) return 0 ;
var statistics _ data = new availability _ statistics . statistics _ data ( )

if ( filtered _ statistics = = null | | servers . count = = 0 )
where filtered _ statistics . contains _ key ( name )
score = get _ score ( name )



using raw _ statistics = dictionary < string , list < availability _ statistics . raw _ statistics _ data > > ; using statistics = dictionary < string , list < availability _ statistics . statistics _ data > > ; public class availability _ statistics

foreach ( string method in aead _ mbed _ tls _ encryptor _ supported _ ciphers )
foreach ( string method in aead _ sodium _ encryptor _ supported _ ciphers )
new async _ callback ( connect _ callback ) , connect _ timer ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; this . close ( ) ; } } private void connect _ timer _ elapsed ( object sender , elapsed _ event _ args e ) { if ( connected ) { return ; } server server = ( ( server _ timer ) sender ) . server ; controller . get _ current _ strategy ( ) . set _ failure ( server ) ; console . write _ line ( string . format ( STR , server . friendly _ name ( ) ) ) ; remote . close ( ) ; retry _ connect ( ) ; } private void retry _ connect ( ) { if ( retry _ count < NUM ) { console . write _ line ( STR ) ; start _ connect ( ) ; retry _ count + + ; } else {
server server = null ; if ( closed ) { return ; } try { server _ timer timer = ( server _ timer ) ar . async _ state ; server = timer . server ; timer . elapsed - = connect _ timer _ elapsed ; timer . enabled = false ; timer . dispose ( ) ;
controller . get _ current _ strategy ( ) . update _ latency ( server , latency ) ;
catch ( argument _ exception e ) { } catch ( exception e ) {         if ( server ! = null ) { controller . get _ current _ strategy ( ) . set _ failure ( server ) ; } logging . log _ useful _ exception ( e ) ; retry _ connect ( ) ;
var default _ value = registry . get _ value ( STR ) ; try { var connections = registry . get _ value _ names ( ) ; foreach ( string each in connections )
if ( ! ( each . equals ( STR ) | | each . equals ( STR ) | | each . equals ( STR ) ) ) {  registry . set _ value ( each , default _ value ) ; }

using ( graphics g = graphics . from _ image ( image ) )
image . size ,
var reader = new barcode _ reader
if ( result ! = null )
console . write _ line ( result . text ) ;
}
catch ( exception e )
password = STR , is _ default = true

private void ok _ button _ click ( object sender , event _ args e )
try { config config = new config { server = text _ box . text , server _ port = int . parse ( text _ box . text ) , password = text _ box . text , local _ port = int . parse ( text _ box . text ) , is _ default = false } ; config . save ( config ) ; this . config = config ; reload ( config ) ; this . hide ( ) ; } catch ( format _ exception ) { message _ box . show ( STR ) ; } catch ( exception ) { message _ box . show ( STR ) ; }
private void cancel _ button _ click ( object sender , event _ args e )
this . button . click + = new system . event _ handler ( this . cancel _ button _ click ) ;
this . button . click + = new system . event _ handler ( this . ok _ button _ click ) ;
this . context _ menu _ strip . size = new system . drawing . size ( NUM , NUM ) ;
logging . info ( STR + locale ) ; init ( n , locale ) ;
private byte [ ] remote _ recv _ buffer = new byte [ recv _ size ] ;
private byte [ ] remote _ send _ buffer = new byte [ buffer _ size ] ;
private byte [ ] connetion _ recv _ buffer = new byte [ recv _ size ] ;
private byte [ ] connetion _ send _ buffer = new byte [ buffer _ size ] ;

this . table _ layout _ panel . row _ count = 2 ;
this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ;



private end _ point remote _ end _ point ;
remote _ end _ point = socket _ util . get _ end _ point ( server . server , server . server _ port ) ; remote = socket _ util . create _ socket ( remote _ end _ point , protocol _ type . udp ) ;
dest _ end _ point = dest _ end _ point ;
remote = socket _ util . create _ socket ( dest _ end _ point ) ;
remote . begin _ connect ( dest _ end _ point , callback , state ) ;
end _ point proxy _ ep ;

proxy _ ep = socket _ util . get _ end _ point ( config . proxy _ server , config . proxy _ port ) ;
update _ tray _ icon ( ) ;



private icon icon , icon _ in , icon _ out , icon _ both , previous _ icon ;
new _ icon = icon ; if ( new _ icon ! = this . previous _ icon ) { this . previous _ icon = new _ icon ;
private void update _ tray _ icon _ and _ notify _ text ( ) {
color color _ mask = select _ color _ mask ( enabled , global ) ; size icon _ size = select _ icon _ size ( ) ; update _ icon _ set ( color _ mask , icon _ size , out icon , out icon _ in , out icon _ out , out icon _ both ) ; previous _ icon = icon ; notify _ icon . icon = previous _ icon ;
private size select _ icon _ size ( ) { size size = new size ( NUM , NUM ) ; int dpi = view _ utils . get _ screen _ dpi ( ) ; if ( dpi < NUM ) {  size = new size ( NUM , NUM ) ; } else if ( dpi < NUM ) {  size = new size ( NUM , NUM ) ; } else if ( dpi < NUM ) {  size = new size ( NUM , NUM ) ; } else {  size = new size ( NUM , NUM ) ; } return size ; } private color select _ color _ mask ( bool is _ proxy _ enabled , bool is _ global _ proxy ) { color color _ mask = color . white ; utils . windows _ theme _ mode current _ windows _ theme _ mode = utils . get _ windows _ system _ theme _ setting ( ) ; if ( is _ proxy _ enabled ) { if ( is _ global _ proxy ) { color _ mask = color _ mask _ blue ; } else { if ( current _ windows _ theme _ mode = = utils . windows _ theme _ mode . light )
color _ mask = color _ mask _ eclipse ;
} } else {     if ( current _ windows _ theme _ mode = = utils . windows _ theme _ mode . light ) { color _ mask = color _ mask _ dark _ silver ; } else {  color _ mask = color _ mask _ light _ silver ; } } return color _ mask ; } private void update _ icon _ set ( color color _ mask , size size , out icon icon , out icon icon _ in , out icon icon _ out , out icon icon _ both ) { bitmap icon _ bitmap ;  icon _ bitmap = view _ utils . change _ bitmap _ color ( resources . ss _ fill , color _ mask ) ; icon _ bitmap = view _ utils . add _ bitmap _ overlay ( icon _ bitmap , resources . ss _ outline ) ; icon = icon . from _ handle ( view _ utils . resize _ bitmap ( icon _ bitmap , size . width , size . height ) . get _ hicon ( ) ) ; icon _ in = icon . from _ handle ( view _ utils . resize _ bitmap ( view _ utils . add _ bitmap _ overlay ( icon _ bitmap , resources . ss _ in ) , size . width , size . height ) . get _ hicon ( ) ) ; icon _ out = icon . from _ handle ( view _ utils . resize _ bitmap ( view _ utils . add _ bitmap _ overlay ( icon _ bitmap , resources . ss _ in ) , size . width , size . height ) . get _ hicon ( ) ) ; icon _ both = icon . from _ handle ( view _ utils . resize _ bitmap ( view _ utils . add _ bitmap _ overlay ( icon _ bitmap , resources . ss _ in , resources . ss _ out ) , size . width , size . height ) . get _ hicon ( ) ) ;
windows _ theme _ mode theme _ mode = windows _ theme _ mode . dark ;
registry _ key reg _ themes _ personalize = registry . current _ user . open _ sub _ key ( STR , false ) ;
if ( ( int ) ( reg _ themes _ personalize . get _ value ( STR ) ) = = 0 ) theme _ mode = windows _ theme _ mode . dark ;
theme _ mode = windows _ theme _ mode . light ;
var temp _ folder = configuration . load ( ) . temp _ folder ; if ( string . is _ null _ or _ white _ space ( temp _ folder ) )  temp _ folder = STR ; else if ( common _ env . contains ( temp _ folder , string _ comparer . ordinal _ ignore _ case ) )  temp _ folder + = ( STR + application . executable _ path . get _ hash _ code ( ) ) ; temp _ folder = environment . expand _ environment _ variables ( temp _ folder ) ;  var temp _ directory = directory . create _ directory ( path . combine ( application . startup _ path , temp _ folder ) ) ; temp _ path = temp _ directory . full _ name ; file . append _ all _ text ( path . combine ( temp _ path , temp _ log ) , $ STR u STR ) ;
this . font = system _ fonts . message _ box _ font ;
this . servers _ list _ box . dock = dock _ style . fill ; this . table _ layout _ panel . dock = dock _ style . fill ;

| system . windows . forms . anchor _ styles . left ) ) ) ;
this . table _ layout _ panel . controls . add ( this . temp _ folder _ label , 0 , 1 ) ; this . table _ layout _ panel . controls . add ( this . temp _ folder _ text _ box , 1 , 1 ) ; this . table _ layout _ panel . location = new system . drawing . point ( NUM , NUM ) ;
this . table _ layout _ panel . row _ count = 2 ;
try { using ( stream _ writer sw = new stream _ writer ( file . open ( utils . get _ temp _ path ( user _ wininet _ config _ file ) , file _ mode . create ) ) ) {
try { string config _ content = file . read _ all _ text ( utils . get _ temp _ path ( user _ wininet _ config _ file ) ) ;

namespace shadowsocks _ controller _ service
private readonly list < itcp _ handler _ factory > factories = new list < itcp _ handler _ factory > ( ) ; public i _ set < tcp _ handler > handlers { get ; } = new hash _ set < tcp _ handler > ( ) ;

tcp _ handler handler = null ; foreach ( var factory in factories ) { if ( factory . can _ handle ( first _ packet , length ) ) { handler = factory . new _ handler ( controller , config , this , socket ) ; break ; } } if ( handler = = null ) {

interface itcp _ handler _ factory
bool can _ handle ( byte [ ] first _ packet , int length ) ; tcp _ handler new _ handler ( shadowsocks _ controller controller , configuration config , tcp _ relay tcprelay , socket socket ) ; } abstract class tcp _ handler { public abstract void start _ handshake ( byte [ ] first _ packet , int length ) ; protected abstract void on _ server _ connected ( async _ session session ) ; protected class async _ session
protected class async _ session < t > : async _ session
private shadowsocks _ controller controller ; protected configuration config { get ; } private tcp _ relay tcprelay ;  protected socket connection { get ; } private server server ;
private bool proxy _ connected ; private bool dest _ connected ;    private int total _ read = 0 ; private int total _ write = 0 ; protected byte [ ] remote _ recv _ buffer { get ; } = new byte [ buffer _ size ] ; private readonly byte [ ] remote _ send _ buffer = new byte [ buffer _ size ] ; protected byte [ ] connetion _ recv _ buffer { get ; } = new byte [ buffer _ size ] ; private readonly byte [ ] connetion _ send _ buffer = new byte [ buffer _ size ] ; private i _ encryptor encryptor ; private readonly object encryption _ lock = new object ( ) ; private readonly object decryption _ lock = new object ( ) ; private bool connection _ shutdown = false ; private bool remote _ shutdown = false ;    protected bool closed { get ; private set ; } = false ; private readonly object close _ conn _ lock = new object ( ) ;
public tcp _ handler ( shadowsocks _ controller controller , configuration config , tcp _ relay tcprelay , socket socket , bool auto _ append _ header = true )
server _ header _ sent = ! auto _ append _ header ; } private void create _ remote ( ) { server server = controller . get _ a _ server ( i _ strategy _ caller _ type . tcp , ( ip _ end _ point ) connection . remote _ end _ point , dest _ end _ point ) ;
protected void start _ pipe ( async _ session session ) { if ( closed ) return ;
session . remote . begin _ receive ( remote _ recv _ buffer , 0 , recv _ size , socket _ flags . none , pipe _ remote _ receive _ callback , session ) ; connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , socket _ flags . none , pipe _ connection _ receive _ callback , session ) ;
session . remote . begin _ send ( connetion _ send _ buffer , 0 , bytes _ to _ send , socket _ flags . none , callback , session ) ;
if ( closed ) return ; try { var session = end _ send _ to _ server ( ar ) ; connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , socket _ flags . none , pipe _ connection _ receive _ callback , session ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; } } private void pipe _ connection _ send _ callback ( i _ async _ result ar ) {
connection . end _ send ( ar ) ; session . remote . begin _ receive ( remote _ recv _ buffer , 0 , recv _ size , socket _ flags . none , pipe _ remote _ receive _ callback , session ) ;

int len = socks _ util . header _ addr _ length ( dest _ end _ point ) ; byte [ ] request = new byte [ len + NUM ] ; socks _ util . fill _ header _ addr ( request , NUM , dest _ end _ point ) ;

int lp _ names = 0 ;
retval = ras _ enum _ entries ( null , null , null , ref lp _ size , out lp _ names ) ;
retval = ras _ enum _ entries ( null , null , names , ref lp _ size , out lp _ names ) ;
int strategy _ count = 0 ;
items . add ( strategy _ count , item ) ; strategy _ count + + ;
items . add ( strategy _ count + + , new menu _ item ( STR ) ) ; int server _ count = 0 ;
item . tag = configuration . configs . find _ index ( s = > s = = server ) ;
items . add ( strategy _ count + server _ count , item ) ; server _ count + + ;
this . config _ item = create _ menu _ item ( STR , new event _ handler ( this . config _ click ) ) , create _ menu _ item ( STR , new event _ handler ( this . qr _ code _ item _ click ) ) , create _ menu _ item ( STR , new event _ handler ( this . scan _ qr _ code _ item _ click ) )

while ( items [ 0 ] ! = seperator _ item ) { items . remove _ at ( 0 ) ; }
items . add ( i , item ) ; }
var success = controller . add _ server _ by _ ssurl ( result . text ) ; if ( success ) { show _ config _ form ( ) ; return ; }
list < string > lines = gfw _ list _ updater . parse _ result ( file _ manager . non _ exclusive _ read _ all _ text ( utils . get _ temp _ path ( STR ) ) ) ;
string local = file _ manager . non _ exclusive _ read _ all _ text ( pac _ server . user _ rule _ file , encoding . ut ) ;
disable _ item . checked = ! controller . get _ configuration _ copy ( ) . enabled ;
controller . toggle _ enable ( false ) ; configuration config = controller . get _ configuration _ copy ( ) ; update _ system _ proxy _ items _ enabled _ status ( config ) ; } private void update _ system _ proxy _ items _ enabled _ status ( configuration config ) { disable _ item . checked = ! config . enabled ; if ( ! config . enabled ) { global _ mode _ item . checked = false ; pac _ mode _ item . checked = false ; } else { global _ mode _ item . checked = config . global ; pac _ mode _ item . checked = ! config . global ; }
log _ file _ path = path . combine ( temppath , STR ) ; file _ stream fs = new file _ stream ( log _ file _ path , file _ mode . append ) ;

private menu _ item create _ menu _ item ( string text , event _ handler click )

private menu _ item create _ seperator _ item ( )

private menu _ item create _ menu _ group ( string text , menu _ item [ ] items ) { for ( int i = 0 ; i < items . length ; i + + ) { items [ i ] . index = i ; }

this . context _ menu . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . enable _ item = create _ menu _ item ( STR , new system . event _ handler ( this . enable _ item _ click ) ) , create _ menu _ group ( STR , new system . windows . forms . menu _ item [ ] { this . pac _ mode _ item = create _ menu _ item ( STR , new system . event _ handler ( this . pac _ mode _ item _ click ) ) , this . global _ mode _ item = create _ menu _ item ( STR , new system . event _ handler ( this . global _ mode _ item _ click ) ) } ) , this . servers _ item = create _ menu _ group ( STR , new system . windows . forms . menu _ item [ ] { this . seperator _ item = create _ seperator _ item ( ) , this . config _ item = create _ menu _ item ( STR , new system . event _ handler ( this . config _ click ) ) } ) , create _ seperator _ item ( ) , this . auto _ startup _ item = create _ menu _ item ( STR , new system . event _ handler ( this . auto _ startup _ item _ click ) ) , this . share _ over _ lan _ item = create _ menu _ item ( STR , new system . event _ handler ( this . share _ over _ lan _ item _ click ) ) , create _ menu _ item ( STR , new system . event _ handler ( this . edit _ pac _ file _ item _ click ) ) , create _ seperator _ item ( ) , create _ menu _ item ( STR , new system . event _ handler ( this . qr _ code _ item _ click ) ) , create _ menu _ item ( STR , new system . event _ handler ( this . show _ log _ item _ click ) ) , create _ menu _ item ( STR , new system . event _ handler ( this . config _ click ) ) , create _ seperator _ item ( ) , create _ menu _ item ( STR , new system . event _ handler ( this . quit _ click ) )

* only the first packet contains the socks header , it doesn ' t make sense to parse every packets . * also it ' s unnecessary to parse these data if we turn off the verbose _ logging . * / object need _ to _ find _ header = null ; if ( ar . async _ state ! = null & & config . is _ verbose _ logging )
int atyp = connetion _ recv _ buffer [ 0 ] ; string dst _ addr ; int dst _ port ; switch ( atyp ) { case 1 : dst _ addr = new ip _ address ( connetion _ recv _ buffer . skip ( 1 ) . take ( NUM ) . to _ array ( ) ) . to _ string ( ) ; dst _ port = ( connetion _ recv _ buffer [ NUM ] < < NUM ) + connetion _ recv _ buffer [ NUM ] ;  logging . info ( $ STR ) ;  break ; case NUM : int len = connetion _ recv _ buffer [ 1 ] ; dst _ addr = system . text . encoding . ut . get _ string ( connetion _ recv _ buffer , 2 , len ) ; dst _ port = ( connetion _ recv _ buffer [ len + 2 ] < < NUM ) + connetion _ recv _ buffer [ len + NUM ] ;  logging . info ( $ STR ) ;  break ; case NUM : dst _ addr = new ip _ address ( connetion _ recv _ buffer . skip ( 1 ) . take ( NUM ) . to _ array ( ) ) . to _ string ( ) ; dst _ port = ( connetion _ recv _ buffer [ NUM ] < < NUM ) + connetion _ recv _ buffer [ NUM ] ;  logging . info ( $ STR ) ;  break ; default : need _ to _ find _ header = true ; break ; }
private static readonly logger logger = log _ manager . get _ current _ class _ logger ( ) ;


public bool is _ i _ pv _ enabled = false ; public bool generate _ legacy _ url = false ; public string geosite _ url ; public string geosite _ group = STR ; public bool geosite _ blacklist _ mode = true ;

private static readonly n _ log _ config . log _ level verbose _ log _ level = n _ log _ config . log _ level . trace ;
private static readonly n _ log _ config . log _ level verbose _ log _ level = n _ log _ config . log _ level . debug ;


using static shadowsocks . controller . hotkey _ reg ;
reg _ hotkey _ from _ string ( hotkey _ config . switch _ system _ proxy , STR , result = > handle _ reg _ result ( hotkey _ config . switch _ system _ proxy , switch _ system _ proxy _ label , result ) ) & & reg _ hotkey _ from _ string ( hotkey _ config . switch _ system _ proxy _ mode , STR , result = > handle _ reg _ result ( hotkey _ config . switch _ system _ proxy _ mode , switch _ proxy _ mode _ label , result ) ) & & reg _ hotkey _ from _ string ( hotkey _ config . switch _ allow _ lan , STR , result = > handle _ reg _ result ( hotkey _ config . switch _ allow _ lan , switch _ allow _ lan _ label , result ) ) & & reg _ hotkey _ from _ string ( hotkey _ config . show _ logs , STR , result = > handle _ reg _ result ( hotkey _ config . show _ logs , show _ logs _ label , result ) ) & & reg _ hotkey _ from _ string ( hotkey _ config . server _ move _ up , STR , result = > handle _ reg _ result ( hotkey _ config . server _ move _ up , server _ move _ up _ label , result ) ) & & reg _ hotkey _ from _ string ( hotkey _ config . server _ move _ down , STR , result = > handle _ reg _ result ( hotkey _ config . server _ move _ down , server _ move _ down _ label , result ) ) ;
private void handle _ reg _ result ( string hotkey _ str , label label , reg _ result result )
switch ( result )
case reg _ result . parse _ error :
break ; case reg _ result . unreg _ success : label . reset _ back _ color ( ) ; break ; case reg _ result . reg _ success : label . back _ color = color . green ; break ; case reg _ result . reg _ failure : label . back _ color = color . red ; break ; default : break ;
if ( config . is _ default ) { is _ first _ run = true ; show _ config _ form ( ) ; } else if ( config . auto _ check _ update )



notify _ icon . balloon _ tip _ title = n . get _ string ( STR ) ; notify _ icon . balloon _ tip _ text = n . get _ string ( STR ) ; notify _ icon . balloon _ tip _ icon = tool _ tip _ icon . info ; notify _ icon . show _ balloon _ tip ( 0 ) ;
last _ selected _ index = modified _ configuration . index ; if ( last _ selected _ index < 0 ) { last _ selected _ index = 0 ; } servers _ list _ box . selected _ index = last _ selected _ index ;
last _ selected _ index = servers _ list _ box . selected _ index ; if ( last _ selected _ index > = 0 & & last _ selected _ index < modified _ configuration . configs . count ) { modified _ configuration . configs . remove _ at ( last _ selected _ index ) ; } if ( last _ selected _ index > = modified _ configuration . configs . count )

controller . select _ server _ index ( modified _ configuration . configs . index _ of ( server ) ) ;

if ( is _ cipher )
bytes _ remaining = encrypt _ bytes _ remaining ; ic = encrypt _ ic ; sodium _ buf = encrypt _ buf ; iv = encrypt _ iv ; } else { bytes _ remaining = decrypt _ bytes _ remaining ; ic = decrypt _ ic ; sodium _ buf = decrypt _ buf ; iv = decrypt _ iv ; } int padding = bytes _ remaining ; buffer . block _ copy ( buf , 0 , sodium _ buf , padding , length ) ; switch ( cipher ) { case cipher _ sals : sodium . crypto _ stream _ salsa _ xor _ ic ( sodium _ buf , sodium _ buf , ( ulong ) ( padding + length ) , iv , ic , key ) ; break ; case cipher _ chach : sodium . crypto _ stream _ chacha _ xor _ ic ( sodium _ buf , sodium _ buf , ( ulong ) ( padding + length ) , iv , ic , key ) ; break ; case cipher _ chach _ ietf : sodium . crypto _ stream _ chacha _ ietf _ xor _ ic ( sodium _ buf , sodium _ buf , ( ulong ) ( padding + length ) , iv , ( uint ) ic , key ) ; break ; } buffer . block _ copy ( sodium _ buf , padding , outbuf , 0 , length ) ; padding + = length ; ic + = ( ulong ) padding / sodium _ block _ size ; bytes _ remaining = padding % sodium _ block _ size ; if ( is _ cipher ) { encrypt _ bytes _ remaining = bytes _ remaining ; encrypt _ ic = ic ; } else { decrypt _ bytes _ remaining = bytes _ remaining ; decrypt _ ic = ic ;
using shadowsocks _ model ; using shadowsocks _ properties ;
namespace shadowsocks _ controller
using shadowsocks _ properties ;
namespace shadowsocks _ controller
using shadowsocks _ model ;
namespace shadowsocks _ controller
using shadowsocks _ controller ; using shadowsocks _ properties ; using shadowsocks _ view ;
namespace shadowsocks
servers _ list _ box . items . add ( string . is _ null _ or _ empty ( server . server ) ? STR : server . server + STR + server . server _ port ) ;
this . servers _ item , this . menu _ item ,
this . servers _ item . index = 1 ; this . servers _ item . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . seperator _ item , this . config _ item } ) ; this . servers _ item . text = STR ;    this . seperator _ item . index = 0 ; this . seperator _ item . text = STR ;    this . config _ item . index = 1 ; this . config _ item . text = STR ; this . config _ item . click + = new system . event _ handler ( this . config _ click ) ;    this . menu _ item . index = 2 ; this . menu _ item . text = STR ;
this . edit _ pac _ file _ item . index = NUM ; this . edit _ pac _ file _ item . text = STR ;
services . add ( new port _ forwarder ( privoxy _ runner . running _ port ) ) ;
class privoxy _ runner
static privoxy _ runner ( )
process [ ] existing _ privoxy = process . get _ processes _ by _ name ( STR ) ; foreach ( process p in existing _ privoxy . where ( is _ child _ process ) )
string privoxy _ config = resources . privoxy _ conf ;
privoxy _ config = privoxy _ config . replace ( STR , configuration . local _ port . to _ string ( ) ) ; privoxy _ config = privoxy _ config . replace ( STR , running _ port . to _ string ( ) ) ; privoxy _ config = privoxy _ config . replace ( STR , configuration . share _ over _ lan ? STR : STR ) ; file _ manager . byte _ array _ to _ file ( utils . get _ temp _ path ( unique _ config _ file ) , encoding . ut . get _ bytes ( privoxy _ config ) ) ;
if ( ex . native _ error _ code = = 0 )


j _ array result = j _ array . parse ( response ) ;
if ( result ! = null ) { foreach ( j _ object release in result ) { if ( ( bool ) release [ STR ] )
continue ; } foreach ( j _ object asset in ( j _ array ) release [ STR ] ) { asset ass = new asset ( ) ; ass . parse ( asset ) ; if ( ass . is _ new _ version ( version ) ) { asserts . add ( ass ) ; }

using system _ text _ regular _ expressions ;

using system ;
using shadowsocks _ controller ; using newtonsoft _ json ;
class encryptor : i _ disposable
public static string [ ] encryption _ names = new string [ ] { STR , STR , STR , STR , STR , STR } ;
public string method = STR ; public string password ; public byte [ ] key ; private r rc = null ; private cipher cipher = null ; private int _ ptr encrypt _ ctx ; private int _ ptr decrypt _ ctx ; private static dictionary < string , byte [ ] > cached _ keys = new dictionary < string , byte [ ] > ( ) ; private static dictionary < string , cipher > cached _ ciphers = new dictionary < string , cipher > ( ) ; public void dispose ( ) { if ( encrypt _ ctx ! = int _ ptr . zero ) { native . evp _ cipher _ ctx _ cleanup ( encrypt _ ctx ) ; native . openssl _ free ( encrypt _ ctx ) ; encrypt _ ctx = int _ ptr . zero ; } if ( decrypt _ ctx ! = int _ ptr . zero ) { native . evp _ cipher _ ctx _ cleanup ( decrypt _ ctx ) ; native . openssl _ free ( decrypt _ ctx ) ; decrypt _ ctx = int _ ptr . zero ; } } ~ encryptor ( ) { dispose ( ) ; }

} else if ( method = = STR | | method = = STR | | method = = null ) {

else { init _ key ( password , method ) ; } } private void init _ cipher ( ref int _ ptr ctx , byte [ ] iv , bool is _ cipher ) { ctx = native . openssl _ malloc ( marshal . size _ of ( typeof ( cipher _ context . evp _ cipher _ ctx ) ) ) ; int enc = is _ cipher ? 1 : 0 ; native . evp _ cipher _ ctx _ init ( ctx ) ; native . expect _ success ( native . evp _ cipher _ init _ ex ( ctx , this . cipher . handle , int _ ptr . zero , null , null , enc ) ) ; native . expect _ success ( native . evp _ cipher _ ctx _ set _ key _ length ( ctx , key . length ) ) ; native . expect _ success ( native . evp _ cipher _ ctx _ set _ padding ( ctx , 1 ) ) ; native . expect _ success ( native . evp _ cipher _ init _ ex ( ctx , this . cipher . handle , int _ ptr . zero , key , iv , enc ) ) ; } private void init _ key ( string password , string method ) { string k = method + STR + password ; if ( cached _ keys . contains _ key ( k ) ) { key = cached _ keys [ k ] ; cipher = cached _ ciphers [ k ] ; return ; } cipher = cipher . create _ by _ name ( method ) ; if ( cipher = = null ) { throw new null _ reference _ exception ( ) ; } byte [ ] passbuf = system . text . encoding . ut . get _ bytes ( password ) ; ; key = new byte [ cipher . key _ length ] ; byte [ ] iv = new byte [ cipher . iv _ length ] ; native . evp _ bytes _ to _ key ( cipher . handle , message _ digest . m . handle , null , passbuf , passbuf . length , 1 , key , iv ) ; cached _ keys [ k ] = key ; cached _ ciphers [ k ] = cipher ; } private byte [ ] ssl _ encrypt ( byte [ ] buf , int length ) { if ( encrypt _ ctx = = int _ ptr . zero ) { int iv _ len = cipher . iv _ length ; byte [ ] iv = new byte [ iv _ len ] ; native . rand _ bytes ( iv , iv . length ) ; init _ cipher ( ref encrypt _ ctx , iv , true ) ; int out _ len = length + cipher . block _ size ; byte [ ] cipher _ text = new byte [ out _ len ] ; native . evp _ cipher _ update ( encrypt _ ctx , cipher _ text , out out _ len , buf , length ) ; byte [ ] result = new byte [ out _ len + iv _ len ] ; system . buffer . block _ copy ( iv , 0 , result , 0 , iv _ len ) ; system . buffer . block _ copy ( cipher _ text , 0 , result , iv _ len , out _ len ) ; return result ; } else { int out _ len = length + cipher . block _ size ; byte [ ] cipher _ text = new byte [ out _ len ] ; native . evp _ cipher _ update ( encrypt _ ctx , cipher _ text , out out _ len , buf , length ) ; byte [ ] result = new byte [ out _ len ] ; system . buffer . block _ copy ( cipher _ text , 0 , result , 0 , out _ len ) ; return result ; } } private byte [ ] ssl _ decrypt ( byte [ ] buf , int length ) { if ( decrypt _ ctx = = int _ ptr . zero ) { int iv _ len = cipher . iv _ length ; byte [ ] iv = new byte [ iv _ len ] ; system . buffer . block _ copy ( buf , 0 , iv , 0 , iv _ len ) ; init _ cipher ( ref decrypt _ ctx , iv , false ) ; int out _ len = length + cipher . block _ size ; out _ len - = iv _ len ; byte [ ] cipher _ text = new byte [ out _ len ] ; byte [ ] subset = new byte [ length - iv _ len ] ; system . buffer . block _ copy ( buf , iv _ len , subset , 0 , length - iv _ len ) ; native . evp _ cipher _ update ( decrypt _ ctx , cipher _ text , out out _ len , subset , length - iv _ len ) ; byte [ ] result = new byte [ out _ len ] ; system . buffer . block _ copy ( cipher _ text , 0 , result , 0 , out _ len ) ; return result ; } else { int out _ len = length + cipher . block _ size ; byte [ ] cipher _ text = new byte [ out _ len ] ; native . evp _ cipher _ update ( decrypt _ ctx , cipher _ text , out out _ len , buf , length ) ; byte [ ] result = new byte [ out _ len ] ; system . buffer . block _ copy ( cipher _ text , 0 , result , 0 , out _ len ) ; return result ; } } public byte [ ] encrypt ( byte [ ] buf , int length )
case STR :
return buf ; break ; case STR :
return buf ; break ; default : return ssl _ encrypt ( buf , length ) ; } } public byte [ ] decrypt ( byte [ ] buf , int length )
case STR :
return buf ; break ; case STR :
return buf ; break ; default : return ssl _ decrypt ( buf , length ) ;
catch ( exception ex )
message _ box . show ( ex . to _ string ( ) ) ;
connection . shutdown ( socket _ shutdown . send ) ;
remote . shutdown ( socket _ shutdown . send ) ; } encryptor . dispose ( ) ;
public static sip _ plugin create _ if _ configured ( server server , bool show _ plugin _ output )
return new sip _ plugin ( server . plugin , server . plugin _ opts , server . plugin _ args , server . server , server . server _ port , show _ plugin _ output ) ;
private sip _ plugin ( string plugin , string plugin _ opts , string plugin _ args , string server _ address , int server _ port , bool show _ plugin _ output )


this . config _ item , this . quit _ item } ) ;
this . config _ item . name = STR ; this . config _ item . size = new system . drawing . size ( NUM , NUM ) ; this . config _ item . text = STR ; this . config _ item . click + = new system . event _ handler ( this . config _ click ) ;    this . quit _ item . name = STR ; this . quit _ item . size = new system . drawing . size ( NUM , NUM ) ; this . quit _ item . text = STR ; this . quit _ item . click + = new system . event _ handler ( this . quit _ click ) ;

if ( data _ lists = = null ) continue ; foreach ( var data _ list in data _ lists . where ( data _ list = > data _ list ! = null ) )

public partial class config _ form : form
public config _ form ( )
if ( command = = 1 ) { byte [ ] response = { NUM , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 } ; connection . begin _ send ( response , 0 , response . length , 0 , new async _ callback ( start _ connect ) , null ) ; } else if ( command = = NUM ) { handle _ udp _ associate ( ) ; }
private static void set _ ie _ proxy ( bool enable , bool global , string proxy _ server , string pac _ url , string conn _ name )
value = { dw _ value = ( int ) ( internet _ option _ per _ conn _ flags _ ui . proxy _ type _ proxy | internet _ option _ per _ conn _ flags _ ui . proxy _ type _ direct ) }
value = { psz _ value = marshal . string _ to _ h _ global _ auto ( proxy _ server ) }
value = { psz _ value = marshal . string _ to _ h _ global _ auto ( STR ) }
b _ return = native _ methods . internet _ set _ option (
internet _ option . internet _ option _ proxy _ settings _ changed ,
if ( ! b _ return ) { logging . error ( STR ) ; } b _ return = native _ methods . internet _ set _ option (
using microsoft _ visual _ basic _ file _ io ; using shadowsocks _ properties ; using shadowsocks _ util ; using system _ collections _ generic ;
using system _ text ;




load _ library ( dll _ path ) ;
public extern static int crypto _ stream _ salsa _ xor _ ic ( byte [ ] c , byte [ ] m , ulong mlen , byte [ ] n , ulong ic , byte [ ] k ) ;
public extern static int crypto _ stream _ chacha _ xor _ ic ( byte [ ] c , byte [ ] m , ulong mlen , byte [ ] n , ulong ic , byte [ ] k ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl
remote . begin _ send ( buffer , offset , size , socket _ flags , callback , state ) ;
remote . begin _ receive ( buffer , offset , size , socket _ flags , callback , state ) ;
remote . shutdown ( how ) ;
remote . dispose ( ) ;
this . qr _ code _ web _ browser . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( ( ( system . windows . forms . anchor _ styles . top | system . windows . forms . anchor _ styles . bottom ) | system . windows . forms . anchor _ styles . left ) | system . windows . forms . anchor _ styles . right ) ) ) ;
this . auto _ size = true ; this . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . client _ size = new system . drawing . size ( NUM , NUM ) ;
private int _ ptr encrypt _ ctx = int _ ptr . zero ; private int _ ptr decrypt _ ctx = int _ ptr . zero ;
private byte [ ] encrypt _ iv _ offset ; private byte [ ] decrypt _ iv _ offset ;
private void init _ cipher ( ref int _ ptr ctx , byte [ ] iv , bool is _ cipher ) { ctx = marshal . alloc _ h _ global ( cipher _ info [ NUM ] ) ; byte [ ] realkey ; if ( method = = STR ) { byte [ ] temp = new byte [ key _ len + iv _ len ] ; realkey = new byte [ key _ len ] ; array . copy ( key , 0 , temp , 0 , key _ len ) ; array . copy ( iv , 0 , temp , key _ len , iv _ len ) ; realkey = m . create ( ) . compute _ hash ( temp ) ; } else { realkey = key ; } if ( cipher = = cipher _ aes ) { polar _ ssl . aes _ init ( ctx ) ;   polar _ ssl . aes _ setkey _ enc ( ctx , realkey , key _ len * NUM ) ; if ( is _ cipher ) { encrypt _ iv = new byte [ iv _ len ] ; encrypt _ iv _ offset = new byte [ NUM ] ; array . copy ( iv , encrypt _ iv , iv _ len ) ;
decrypt _ iv = new byte [ iv _ len ] ; decrypt _ iv _ offset = new byte [ NUM ] ; array . copy ( iv , decrypt _ iv , iv _ len ) ; } } else if ( cipher = = cipher _ bf ) { polar _ ssl . blowfish _ init ( ctx ) ;  polar _ ssl . blowfish _ setkey ( ctx , realkey , key _ len * NUM ) ; if ( is _ cipher ) { encrypt _ iv = new byte [ iv _ len ] ; encrypt _ iv _ offset = new byte [ NUM ] ; array . copy ( iv , encrypt _ iv , iv _ len ) ; } else { decrypt _ iv = new byte [ iv _ len ] ; decrypt _ iv _ offset = new byte [ NUM ] ; array . copy ( iv , decrypt _ iv , iv _ len ) ; } } else if ( cipher = = cipher _ r ) { polar _ ssl . arc _ init ( ctx ) ;  polar _ ssl . arc _ setup ( ctx , realkey , key _ len ) ;
if ( encrypt _ ctx = = int _ ptr . zero )
if ( disposed ) { throw new object _ disposed _ exception ( this . to _ string ( ) ) ; } switch ( cipher ) { case cipher _ aes : polar _ ssl . aes _ crypt _ cfb ( encrypt _ ctx , polar _ ssl . aes _ encrypt , length , encrypt _ iv _ offset , encrypt _ iv , buf , tempbuf ) ; break ; case cipher _ bf : polar _ ssl . blowfish _ crypt _ cfb ( encrypt _ ctx , polar _ ssl . blowfish _ encrypt , length , encrypt _ iv _ offset , encrypt _ iv , buf , tempbuf ) ; break ; case cipher _ r : polar _ ssl . arc _ crypt ( encrypt _ ctx , length , buf , tempbuf ) ; break ; } outlength = length + iv _ len ; buffer . block _ copy ( tempbuf , 0 , outbuf , iv _ len , length ) ;
if ( disposed ) { throw new object _ disposed _ exception ( this . to _ string ( ) ) ; } switch ( cipher ) { case cipher _ aes : polar _ ssl . aes _ crypt _ cfb ( encrypt _ ctx , polar _ ssl . aes _ encrypt , length , encrypt _ iv _ offset , encrypt _ iv , buf , outbuf ) ; break ; case cipher _ bf : polar _ ssl . blowfish _ crypt _ cfb ( encrypt _ ctx , polar _ ssl . blowfish _ encrypt , length , encrypt _ iv _ offset , encrypt _ iv , buf , outbuf ) ; break ; case cipher _ r : polar _ ssl . arc _ crypt ( encrypt _ ctx , length , buf , outbuf ) ; break ;
if ( decrypt _ ctx = = int _ ptr . zero )
if ( disposed ) { throw new object _ disposed _ exception ( this . to _ string ( ) ) ; } switch ( cipher ) { case cipher _ aes : polar _ ssl . aes _ crypt _ cfb ( decrypt _ ctx , polar _ ssl . aes _ decrypt , length - iv _ len , decrypt _ iv _ offset , decrypt _ iv , tempbuf , outbuf ) ; break ; case cipher _ bf : polar _ ssl . blowfish _ crypt _ cfb ( decrypt _ ctx , polar _ ssl . blowfish _ decrypt , length - iv _ len , decrypt _ iv _ offset , decrypt _ iv , tempbuf , outbuf ) ; break ; case cipher _ r : polar _ ssl . arc _ crypt ( decrypt _ ctx , length - iv _ len , tempbuf , outbuf ) ; break ;
if ( disposed ) { throw new object _ disposed _ exception ( this . to _ string ( ) ) ; } switch ( cipher ) { case cipher _ aes : polar _ ssl . aes _ crypt _ cfb ( decrypt _ ctx , polar _ ssl . aes _ decrypt , length , decrypt _ iv _ offset , decrypt _ iv , buf , outbuf ) ; break ; case cipher _ bf : polar _ ssl . blowfish _ crypt _ cfb ( decrypt _ ctx , polar _ ssl . blowfish _ decrypt , length , decrypt _ iv _ offset , decrypt _ iv , buf , outbuf ) ; break ; case cipher _ r : polar _ ssl . arc _ crypt ( decrypt _ ctx , length , buf , outbuf ) ; break ;
public extern static void aes _ init ( int _ ptr ctx ) ;
public extern static void aes _ free ( int _ ptr ctx ) ;
public extern static int aes _ setkey _ enc ( int _ ptr ctx , byte [ ] key , int keysize ) ;
public extern static int aes _ crypt _ cfb ( int _ ptr ctx , int mode , int length , byte [ ] iv _ off , byte [ ] iv , byte [ ] input , byte [ ] output ) ;
public extern static void arc _ init ( int _ ptr ctx ) ;
public extern static void arc _ free ( int _ ptr ctx ) ;
public extern static void arc _ setup ( int _ ptr ctx , byte [ ] key , int keysize ) ;
public extern static int arc _ crypt ( int _ ptr ctx , int length , byte [ ] input , byte [ ] output ) ;
public extern static void blowfish _ init ( int _ ptr ctx ) ;
public extern static void blowfish _ free ( int _ ptr ctx ) ;
public extern static int blowfish _ setkey ( int _ ptr ctx , byte [ ] key , int keysize ) ;
public extern static int blowfish _ crypt _ cfb ( int _ ptr ctx , int mode , int length , byte [ ] iv _ off , byte [ ] iv , byte [ ] input , byte [ ] output ) ;
encryptor = new polar _ ssl _ encryptor ( STR , STR ) ; decryptor = new polar _ ssl _ encryptor ( STR , STR ) ;

using system _ threading _ tasks ;

private static string get _ hash ( string content )
var content _ bytes = encoding . ascii . get _ bytes ( content ) ; using ( var md = system . security . cryptography . m . create ( ) ) { var md _ bytes = md . compute _ hash ( content _ bytes ) ; return bit _ converter . to _ string ( md _ bytes ) . replace ( STR , STR ) ; } ;
switch ( each )
case STR : case STR : case STR : continue ; default :  registry . set _ value ( each , default _ value ) ; continue ;
public bool statistics _ enabled { get ; set ; } = true ; public bool by _ hour _ of _ day { get ; set ; } = true ;
public int choice _ kept _ minutes { get ; set ; } = NUM ; public int data _ collection _ minutes { get ; set ; } = NUM ; public int repeat _ times _ num { get ; set ; } = NUM ;




this . table _ layout _ panel . row _ count = NUM ;  this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ;
STR , STR , STR , STR , STR } ) ;
this . timeout _ label . anchor = system . windows . forms . anchor _ styles . right ; this . timeout _ label . auto _ size = true ; this . timeout _ label . location = new system . drawing . point ( NUM , NUM ) ; this . timeout _ label . name = STR ; this . timeout _ label . right _ to _ left = system . windows . forms . right _ to _ left . no ; this . timeout _ label . size = new system . drawing . size ( NUM , NUM ) ; this . timeout _ label . tab _ index = NUM ; this . timeout _ label . text = STR ;    this . timeout _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . timeout _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . timeout _ text _ box . max _ length = NUM ; this . timeout _ text _ box . name = STR ; this . timeout _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . timeout _ text _ box . tab _ index = NUM ;
polipo _ runner . start ( config ) ; local = new local ( config ) ;
pac _ server . start ( config ) ;
private server server ; private bool share _ over _ lan ;
public local ( configuration config ) { this . server = config . get _ current _ server ( ) ; share _ over _ lan = config . share _ over _ lan ;
listener = new socket ( address _ family . inter _ network , socket _ type . stream , protocol _ type . tcp ) ; listener . set _ socket _ option ( socket _ option _ level . socket , socket _ option _ name . reuse _ address , true ) ; ip _ end _ point local _ end _ point = null ; if ( share _ over _ lan ) { local _ end _ point = new ip _ end _ point ( ip _ address . any , server . local _ port ) ; } else { local _ end _ point = new ip _ end _ point ( ip _ address . loopback , server . local _ port ) ; }
public void start ( configuration configuration )
try {  listener = new socket ( address _ family . inter _ network , socket _ type . stream , protocol _ type . tcp ) ; listener . set _ socket _ option ( socket _ option _ level . socket , socket _ option _ name . reuse _ address , true ) ; ip _ end _ point local _ end _ point = null ; if ( configuration . share _ over _ lan ) { local _ end _ point = new ip _ end _ point ( ip _ address . any , port ) ; } else { local _ end _ point = new ip _ end _ point ( ip _ address . loopback , port ) ; }  listener . bind ( local _ end _ point ) ; listener . listen ( NUM ) ; listener . begin _ accept ( new async _ callback ( accept _ callback ) , listener ) ; watch _ pac _ file ( ) ; } catch ( socket _ exception ) { listener . close ( ) ; throw ; } } public void stop ( ) { listener . close ( ) ; listener = null ;


ip _ end _ point local _ end _ point = ( ip _ end _ point ) conn . local _ end _ point ; string proxy = STR + local _ end _ point . address + STR ;

this . servers _ item . index = 2 ;
this . menu _ item . index = NUM ;
public void start ( configuration configuration )
public tcp _ handler ( tcp _ relay tcprelay , configuration config )
ip _ end _ point dest _ ep = new ip _ end _ point ( ip _ address , server . server _ port ) ;  ip _ end _ point proxy _ ep ; if ( config . use _ proxy ) { parsed = ip _ address . try _ parse ( config . proxy _ server , out ip _ address ) ; if ( ! parsed ) { ip _ host _ entry ip _ host _ info = dns . get _ host _ entry ( config . proxy _ server ) ; ip _ address = ip _ host _ info . address _ list [ 0 ] ; } remote = new socks _ proxy ( ) ; proxy _ ep = new ip _ end _ point ( ip _ address , config . proxy _ port ) ; } else { remote = new direct _ connect ( ) ; proxy _ ep = dest _ ep ; }
proxy _ timer . dest _ end _ point = dest _ ep ;
remote . begin _ connect _ proxy ( proxy _ ep , new async _ callback ( proxy _ connect _ callback ) , proxy _ timer ) ;
if ( ! parse _ host ( m . groups [ 2 ] . value ) )
throw new exception ( STR + line ) ;
if ( ! parse _ host ( line . substring ( NUM ) . trim ( ) ) )
throw new exception ( STR + line ) ;
class context { public int index = 0 ; public int index = 0 ; } private context enc _ ctx = new context ( ) ; private context dec _ ctx = new context ( ) ;
encrypt _ output ( enc _ ctx , table , data , length ) ;
encrypt _ output ( dec _ ctx , table , data , length ) ;
private void encrypt _ output ( context ctx , byte [ ] s , byte [ ] data , int length )
ctx . index = ( ctx . index + 1 ) & NUM ; ctx . index = ( ctx . index + s [ ctx . index ] ) & NUM ; swap ( s , ctx . index , ctx . index ) ; data [ n ] = ( byte ) ( b ^ s [ ( s [ ctx . index ] + s [ ctx . index ] ) & NUM ] ) ;
private static string temp _ path = null ;
if ( temp _ path = = null ) {  try { directory . create _ directory ( path . combine ( application . startup _ path , STR ) ) ;  temp _ path = path . combine ( application . startup _ path , STR ) ; } catch ( exception e ) { logging . error ( e ) ; throw ; }        } return temp _ path ;