                _FileStream.Write(content, 0, content.Length);\n                _FileStream.Close();\n                return true;\n            }\n            catch (Exception _Exception)\n            {\n                Console.WriteLine("Exception caught in process: {0}",\n                                  _Exception.ToString());\n            }\n            return false;
                int bytesRemain = (int)states[0];\n                var onSuccess = (Action)states[1];\n                if (bytesRead >= bytesRemain)\n                {\n                    _firstPacketLength = bytesRead + 2;\n                    int atyp = _connetionRecvBuffer[0];\n                    string dstAddr = "Unknown";\n                    int dstPort = -1;\n                    switch (atyp)\n                    {
                if (bytesRead >= bytesRemain)\n                {\n                    _firstPacketLength = bytesRead + 2;\n                    int atyp = _connetionRecvBuffer[0];\n                    string dstAddr = "Unknown";\n                    int dstPort = -1;\n                    switch (atyp)\n                    {\n                        case ATYP_IPv4: // IPv4 address, 4 bytes\n                            dstAddr = new IPAddress(_connetionRecvBuffer.Skip(1).Take(4).ToArray()).ToString();
                lock (_closeConnLock)\n                {\n                    if (_closed)\n                    {\n                        remote.Close();\n                        return;\n                    }\n                    _currentRemoteSession = session;\n                }\n                ProxyTimer proxyTimer = new ProxyTimer(_proxyTimeout) { AutoReset = false };
            timer.Elapsed -= ProxyConnectTimer_Elapsed;\n            timer.Enabled = false;\n            timer.Dispose();\n            if (_proxyConnected || _destConnected || _closed)\n            {\n                return;\n            }\n            var proxy = timer.Session.Remote;\n            Logger.Info($"Proxy {proxy.ProxyEndPoint} timed out");\n            proxy.Close();
                ProxyTimer timer = session.State;\n                var destEndPoint = timer.DestEndPoint;\n                var server = timer.Server;\n                timer.Elapsed -= ProxyConnectTimer_Elapsed;\n                timer.Enabled = false;\n                timer.Dispose();\n                var remote = session.Remote;\n                // Complete the connection.\n                remote.EndConnectProxy(ar);\n                _proxyConnected = true;
            timer.Elapsed -= DestConnectTimer_Elapsed;\n            timer.Enabled = false;\n            timer.Dispose();\n            if (_destConnected || _closed)\n            {\n                return;\n            }\n            var session = timer.Session;\n            Server server = timer.Server;\n            IStrategy strategy = _controller.GetCurrentStrategy();
                ServerTimer timer = session.State;\n                _server = timer.Server;\n                timer.Elapsed -= DestConnectTimer_Elapsed;\n                timer.Enabled = false;\n                timer.Dispose();\n                var remote = session.Remote;\n                // Complete the connection.\n                remote.EndConnectDest(ar);\n                _destConnected = true;\n                Logger.Debug($"Socket connected to ss server: {_server.FriendlyName()}");\n                var latency = DateTime.Now - _startConnectTime;
                int bytesRead = session.Remote.EndReceive(ar);\n                _totalRead += bytesRead;\n                _tcprelay.UpdateInboundCounter(_server, bytesRead);\n                if (bytesRead > 0)\n                {\n                    lastActivity = DateTime.Now;\n                    int bytesToSend = -1;\n                    lock (_decryptionLock)\n                    {\n                        try
        }\n        private void ConnectCallback(IAsyncResult ar)\n        {\n            Server server = null;\n            if (_closed)\n            {\n                return;\n            }\n            try
                privoxyConfig = privoxyConfig.Replace("__SOCKS_PORT__", configuration.localPort.ToString());\n                privoxyConfig = privoxyConfig.Replace("__PRIVOXY_BIND_PORT__", _runningPort.ToString());\n                privoxyConfig = privoxyConfig.Replace("__PRIVOXY_BIND_IP__", configuration.shareOverLan ? "0.0.0.0" : "127.0.0.1");\n                FileManager.ByteArrayToFile(Utils.GetTempPath(UniqueConfigFile), Encoding.UTF8.GetBytes(privoxyConfig));\n                _process = new Process();\n                // Configure the process using the StartInfo properties.\n                _process.StartInfo.FileName = "ss_privoxy.exe";\n                _process.StartInfo.Arguments = UniqueConfigFile;\n                _process.StartInfo.WorkingDirectory = Utils.GetTempPath();\n                _process.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;
                throw new ArgumentException(I18N.GetString("Password can not be blank"));\n        }\n        private static void CheckServer(string server)\n        {\n            if (string.IsNullOrEmpty(server))\n                throw new ArgumentException(I18N.GetString("Server IP can not be blank"));\n        }\n    }\n}
                throw new ArgumentException(I18N.GetString("Server IP can not be blank"));\n        }\n    }\n}
            {\n                return I18N.GetString("New server");\n            }\n            if (string.IsNullOrEmpty(remarks))\n            {\n                return server + ":" + server_port;\n            }\n            else\n            {\n                return remarks + " (" + server + ":" + server_port + ")";
            {\n                return server + ":" + server_port;\n            }\n            else\n            {\n                return remarks + " (" + server + ":" + server_port + ")";\n            }\n        }\n        public Server()\n        {
                {\n                    UpdateOnlinePACURLItem_Click(sender, e);\n                }\n                if (!String.IsNullOrEmpty(controller.GetConfigurationCopy().pacUrl))\n                {\n                    localPACItem.Checked = false;\n                    onlinePACItem.Checked = true;\n                    controller.UseOnlinePAC(true);\n                }\n                UpdatePACItemsEnabledStatus();
                {\n                    localPACItem.Checked = false;\n                    onlinePACItem.Checked = true;\n                    controller.UseOnlinePAC(true);\n                }\n                UpdatePACItemsEnabledStatus();\n            }\n        }\n        private void UpdateOnlinePACURLItem_Click(object sender, EventArgs e)\n        {
                FileStream fs = new FileStream(LogFile, FileMode.Append);\n                StreamWriterWithTimestamp sw = new StreamWriterWithTimestamp(fs);\n                sw.AutoFlush = true;\n                Console.SetOut(sw);\n                Console.SetError(sw);\n                return true;\n            }\n            catch (IOException e)\n            {\n                Console.WriteLine(e.ToString());
                var remote = session.Remote;\n                if (bytesRead > 0)\n                {\n                    /*\n                     * Only the first packet contains the socks5 header, it doesn't make sense to parse every packets. \n                     * Also it's unnecessary to parse these data if we turn off the VerboseLogging.\n                     */\n                    if (session.State && _config.isVerboseLogging)\n                    {\n                        int atyp = _connetionRecvBuffer[0];
            }\n        }\n        private string GetPACContent()\n        {\n            if (File.Exists(PAC_FILE))\n            {\n                return File.ReadAllText(PAC_FILE, Encoding.UTF8);\n            }\n            else\n            {
                item.Tag = strategy.ID;\n                item.Click += AStrategyItem_Click;\n                items.Add(i, item);\n                i++;\n            }\n            Configuration configuration = controller.GetConfigurationCopy();\n            foreach (var server in configuration.configs)\n            {\n                MenuItem item = new MenuItem(server.FriendlyName());
                _bufferDataLength = length;\n                try\n                {\n                    NewPackageRecv();\n                }\n                catch (Exception ex)\n                {\n                    OnException(ex);\n                    OnFinish();\n                }
        }\n        internal string TouchUserRuleFile()\n        {\n            if (File.Exists(USER_RULE_FILE))\n            {\n                return USER_RULE_FILE;\n            }\n            else\n            {
            }\n        }\n        private void WatchPacFile()\n        {\n            PACFileWatcher?.Dispose();\n            PACFileWatcher = new FileSystemWatcher(Directory.GetCurrentDirectory());\n            PACFileWatcher.NotifyFilter = NotifyFilters.LastWrite | NotifyFilters.FileName | NotifyFilters.DirectoryName;\n            PACFileWatcher.Filter = PAC_FILE;\n            PACFileWatcher.Changed += PACFileWatcher_Changed;\n            PACFileWatcher.Created += PACFileWatcher_Changed;
            }\n            File.AppendAllLines(AvailabilityStatisticsFile, lines);\n        }
            /* prepare address buffer length for AEAD */\n            Logger.Trace($"_addrBufLength={_addrBufLength}");\n            _encryptor.AddrBufLength = _addrBufLength;\n        }\n        public void Start(byte[] firstPacket, int length)\n        {\n            _firstPacket = firstPacket;\n            _firstPacketLength = length;\n            HandshakeReceive();\n        }
                int bytesRemain = (int)states[0];\n                var onSuccess = (Action)states[1];\n                if (bytesRead >= bytesRemain)\n                {\n                    _firstPacketLength = bytesRead + 2;\n                    int atyp = _connetionRecvBuffer[0];\n                    string dstAddr = "Unknown";\n                    int dstPort = -1;\n                    switch (atyp)\n                    {
                if (bytesRead >= bytesRemain)\n                {\n                    _firstPacketLength = bytesRead + 2;\n                    int atyp = _connetionRecvBuffer[0];\n                    string dstAddr = "Unknown";\n                    int dstPort = -1;\n                    switch (atyp)\n                    {\n                        case ATYP_IPv4: // IPv4 address, 4 bytes\n                            dstAddr = new IPAddress(_connetionRecvBuffer.Skip(1).Take(4).ToArray()).ToString();
            timer.Elapsed -= ProxyConnectTimer_Elapsed;\n            timer.Enabled = false;\n            timer.Dispose();\n            if (_proxyConnected || _destConnected || _closed)\n            {\n                return;\n            }\n            var proxy = timer.Session.Remote;\n            Logger.Info($"Proxy {proxy.ProxyEndPoint} timed out");\n            proxy.Close();
                ProxyTimer timer = session.State;\n                var destEndPoint = timer.DestEndPoint;\n                var server = timer.Server;\n                timer.Elapsed -= ProxyConnectTimer_Elapsed;\n                timer.Enabled = false;\n                timer.Dispose();\n                var remote = session.Remote;\n                // Complete the connection.\n                remote.EndConnectProxy(ar);\n                _proxyConnected = true;
            timer.Elapsed -= DestConnectTimer_Elapsed;\n            timer.Enabled = false;\n            timer.Dispose();\n            if (_destConnected || _closed)\n            {\n                return;\n            }\n            var session = timer.Session;\n            Server server = timer.Server;\n            OnFailed?.Invoke(this, new SSRelayEventArgs(_server));
                ServerTimer timer = session.State;\n                _server = timer.Server;\n                timer.Elapsed -= DestConnectTimer_Elapsed;\n                timer.Enabled = false;\n                timer.Dispose();\n                var remote = session.Remote;\n                // Complete the connection.\n                remote.EndConnectDest(ar);\n                _destConnected = true;\n                Logger.Debug($"Socket connected to ss server: {_server.FriendlyName()}");\n                var latency = DateTime.Now - _startConnectTime;
                int bytesRead = session.Remote.EndReceive(ar);\n                _totalRead += bytesRead;\n                OnInbound?.Invoke(this, new SSTransmitEventArgs(_server, bytesRead));\n                if (bytesRead > 0)\n                {\n                    lastActivity = DateTime.Now;\n                    int bytesToSend = -1;\n                    lock (_decryptionLock)\n                    {\n                        try
            this.server = server;\n        }\n        public void Start(byte[] firstPacket, int length)\n        {\n            this._firstPacket = firstPacket;\n            this._firstPacketLength = length;\n            this.HandshakeReceive();\n            this.lastActivity = DateTime.Now;\n        }\n        private void CheckClose()
        }\n        private void CheckClose()\n        {\n            if (connectionShutdown && remoteShutdown)\n            {\n                this.Close();\n            }\n        }\n        public void Close()\n        {
            }\n        }\n        public void Close()\n        {\n            lock (relay.Handlers)\n            {\n                Logging.Debug($"TCP connections: {relay.Handlers.Count}");\n                relay.Handlers.Remove(this);\n            }\n            lock (this)
            }\n        }\n        private void HandshakeSendCallback(IAsyncResult ar)\n        {\n            if (closed)\n            {\n                return;\n            }\n            try\n            {
            }\n        }\n        private void ResponseCallback(IAsyncResult ar)\n        {\n            try\n            {\n                connection.EndSend(ar);\n                StartConnect();\n            }\n            catch (Exception e)
            }\n        }\n        private void ConnectCallback(IAsyncResult ar)\n        {\n            Server server = null;\n            if (closed)\n            {\n                return;\n            }\n            try
                    int bytesToSend;\n                    lock (decryptionLock)\n                    {\n                        if (closed)\n                        {\n                            return;\n                        }\n                        encryptor.Decrypt(remoteRecvBuffer, bytesRead, remoteSendBuffer, out bytesToSend);\n                    }\n                    Logging.Debug($"======Send Local Port, size:" + bytesToSend);
                    }\n                }\n                else\n                {\n                    connection.Shutdown(SocketShutdown.Send);\n                    connectionShutdown = true;\n                    CheckClose();\n                    if (totalRead == 0)\n                    {\n                        // closed before anything received, reports as failure
                    }\n                }\n                else\n                {\n                    remote.Shutdown(SocketShutdown.Send);\n                    remoteShutdown = true;\n                    CheckClose();\n                }\n            }\n            catch (Exception e)
            this._server = server;\n        }\n        public void Start(byte[] firstPacket, int length)\n        {\n            _firstPacket = firstPacket;\n            _firstPacketLength = length;\n            HandshakeReceive();\n        }
                        }\n                        else if (_command == 3)\n                        {\n                            ReadAddress(HandleUDPAssociate);\n                        }\n                    }\n                }\n                else\n                {\n                    Logging.Debug("failed to recv data in Shadowsocks.Controller.TCPHandler.handshakeReceive2Callback()");
        }\n        private void ReadAll(IAsyncResult ar)\n        {\n            if (_closed) return;\n            try\n            {\n                if (ar.AsyncState != null)\n                {\n                    _connection.EndSend(ar);\n                    _connection.BeginReceive(_connetionRecvBuffer, 0, RecvSize, SocketFlags.None, new AsyncCallback(ReadAll), null);
                }\n                else\n                {\n                    int bytesRead = _connection.EndReceive(ar);\n                    if (bytesRead > 0)\n                    {\n                        _connection.BeginReceive(_connetionRecvBuffer, 0, RecvSize, SocketFlags.None, new AsyncCallback(ReadAll), null);\n                    }
                    }\n                    else\n                        Close();\n                }\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }
            }\n            catch (ArgumentException)\n            {\n            }\n            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n                Close();\n            }\n        }
            this.MyCancelButton.Name = "MyCancelButton";\n            this.MyCancelButton.Size = new System.Drawing.Size(75, 23);\n            this.MyCancelButton.TabIndex = 18;\n            this.MyCancelButton.Text = "Cancel";\n            this.MyCancelButton.UseVisualStyleBackColor = true;\n            this.MyCancelButton.Click += new System.EventHandler(this.CancelButton_Click);
        }\n    }\n}
            if (!_allTextBoxes.Any()) throw new Exception("Cannot get all textboxes");\n        }\n        private void controller_ConfigChanged(object sender, EventArgs e)\n        {\n            LoadCurrentConfiguration();\n        }\n        private void LoadCurrentConfiguration()\n        {\n            _modifiedConfig = _controller.GetConfigurationCopy().hotkey;\n            LoadConfiguration(_modifiedConfig);
        }\n        /// <summary>\n        /// Capture hotkey - Press key\n        /// </summary>\n        private void HotkeyDown(object sender, KeyEventArgs e)\n        {\n            _sb.Length = 0;\n            //Combination key only\n            if (e.Modifiers != 0)\n            {\n                // XXX: Hotkey parsing depends on the sequence, more specifically, ModifierKeysConverter.\n                // Windows key is reserved by operating system, we deny this key.\n                if (e.Control)
        }\n        private void OKButton_Click(object sender, EventArgs e)\n        {\n            // try to register, notify to change settings if failed\n            foreach (var tb in _allTextBoxes)\n            {\n                if (tb.Text.IsNullOrEmpty())\n                {\n                    continue;\n                }
                Socket conn = listener.EndAccept(ar);\n                conn.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n                listener.BeginAccept(\n                    new AsyncCallback(AcceptCallback),\n                    listener);\n                Handler handler = new Handler();\n                handler.connection = conn;\n                handler.encryptor = EncryptorFactory.GetEncryptor(_server.method, _server.password);\n                handler.config = _server;\n                handler.Start();
                Socket conn = listener.EndAccept(ar);\n                listener.BeginAccept(\n                    new AsyncCallback(AcceptCallback),\n                    listener);\n                byte[] buf = new byte[2048];\n                object[] state = new object[] {\n                    conn,\n                    buf\n                };\n                conn.BeginReceive(buf, 0, 1024, 0,
                            Buffer.BlockCopy(auth, 0, buf, headLen, ONETIMEAUTH_BYTES);\n                            int buf_offset = headLen + ONETIMEAUTH_BYTES;\n                            int rc = Sodium.ss_gen_crc(buf, ref buf_offset, ref data_len, crc_buf, ref crc_idx, buf.Length);\n                            if (rc != 0)\n                                throw new Exception("failed to generate crc");\n                            length = headLen + ONETIMEAUTH_BYTES + data_len;\n                        }\n                    }\n                    cipherUpdate(true, length, buf, tempbuf);
            InitializeComponent();\n            // a dirty hack\n            this.ServersListBox.Dock = DockStyle.Fill;\n            this.tableLayoutPanel5.Dock = DockStyle.Fill;\n            this.PerformLayout();\n            UpdateTexts();\n            SetupValueChangedListeners();\n            this.Icon = Icon.FromHandle(Resources.ssw128.GetHicon());\n            this.controller = controller;
            UpdateTexts();\n            SetupValueChangedListeners();\n            this.Icon = Icon.FromHandle(Resources.ssw128.GetHicon());\n            this.controller = controller;
            this.controller = controller;
            RemarksLabel.Text = I18N.GetString("Remarks");\n            TimeoutLabel.Text = I18N.GetString("Timeout(Sec)");\n            ServerGroupBox.Text = I18N.GetString("Server");\n            OKButton.Text = I18N.GetString("OK");\n            MyCancelButton.Text = I18N.GetString("Cancel");\n            ApplyButton.Text = I18N.GetString("Apply");\n            MoveUpButton.Text = I18N.GetString("Move &Up");\n            MoveDownButton.Text = I18N.GetString("Move D&own");\n            this.Text = I18N.GetString("Edit Servers");\n        }
        }\n        private void SetupValueChangedListeners()\n        {\n            IPTextBox.TextChanged += ConfigValueChanged;\n            ProxyPortTextBox.TextChanged += ConfigValueChanged;\n            PasswordTextBox.TextChanged += ConfigValueChanged;\n            EncryptionSelect.SelectedIndexChanged += ConfigValueChanged;\n            PluginTextBox.TextChanged += ConfigValueChanged;\n            PluginArgumentsTextBox.TextChanged += ConfigValueChanged;\n            PluginOptionsTextBox.TextChanged += ConfigValueChanged;
                        registry.SetValue("AutoConfigURL", pacUrl);\n                    }\n                }\n                else\n                {\n                    registry.SetValue("ProxyEnable", 0);\n                    if (global)\n                    {\n                        registry.SetValue("ProxyServer", "");\n                    }
                    registry.SetValue("AutoConfigURL", "");\n                }\n                //Set AutoDetectProxy Off\n                IEAutoDetectProxy(false);\n                SystemProxy.NotifyIE();\n                //Must Notify IE first, or the connections do not chanage\n                CopyProxySettingFromLan();\n            }\n            catch (Exception e)\n            {
                //TODO: read one_time_auth\n            }\n            catch (IndexOutOfRangeException)\n            {\n                throw new FormatException();\n            }\n        }\n    }\n}
            }\n            UpdateSystemProxy();\n        }\n        public Server GetCurrentServer()\n        {\n            return _config.GetCurrentServer();\n        }\n        // always return copy\n        public Configuration GetConfiguration()\n        {
                            // Multiply with flyBlue\n                            int red = color.R * flyBlue.R / 255;\n                            int green = color.G * flyBlue.G / 255;\n                            int blue = color.B * flyBlue.B / 255;\n                            iconCopy.SetPixel(x, y, Color.FromArgb(color.A, red, green, blue));\n                        }\n                        else if (global)\n                        {\n                            Color flyBlue = Color.FromArgb(25, 125, 191);
    public class AvailabilityStatistics\n    {\n        public static readonly string DateTimePattern = "yyyy-MM-dd HH:mm:ss";\n        private const string StatisticsFilesName = "shadowsocks.availability.csv";\n        private const string Delimiter = ",";\n        private const int Timeout = 500;\n        private const int DelayBeforeStart = 1000;\n        public RawStatistics rawStatistics { get; private set; }\n        public RawStatistics filteredStatistics { get; private set; }\n        private int _repeat => _config.RepeatTimesNum;
            {\n                ChooseNewServer(_controller.GetCurrentConfiguration().configs);\n            }\n            if (oldServer != _currentServer)\n            {\n            }\n            return _currentServer;  //current server cached for CachedInterval\n        }\n        public void ReloadServers()\n        {
            this.FileMenuItem = new System.Windows.Forms.MenuItem();\n            this.OpenLocationMenuItem = new System.Windows.Forms.MenuItem();\n            this.ExitMenuItem = new System.Windows.Forms.MenuItem();\n            this.panel1 = new System.Windows.Forms.Panel();
        private System.Windows.Forms.MenuItem FileMenuItem;\n        private System.Windows.Forms.MenuItem OpenLocationMenuItem;\n        private System.Windows.Forms.MenuItem ExitMenuItem;\n        private System.Windows.Forms.Panel panel1;\n        private System.Windows.Forms.CheckBox WrapTextCheckBox;\n        private System.Windows.Forms.Button CleanLogsButton;\n        private System.Windows.Forms.Button ChangeFontButton;\n        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel1;\n        private System.Windows.Forms.CheckBox TopMostCheckBox;
        }\n        public override bool Handle(byte[] firstPacket, int length, Socket socket, object state)\n        {\n            if (socket.ProtocolType != ProtocolType.Tcp)\n            {\n                return false;\n            }\n            new Handler().Start(firstPacket, length, socket, this._targetPort);\n            return true;\n        }
            return true;\n        }\n        class Handler\n        {\n            private byte[] _firstPacket;\n            private int _firstPacketLength;\n            private Socket _local;\n            private WrappedSocket _remote;\n            private bool _closed = false;\n            private bool _localShutdown = false;
                }\n            }\n            private void ConnectCallback(IAsyncResult ar)\n            {\n                if (_closed)\n                {\n                    return;\n                }\n                try\n                {
                    _local.BeginReceive(connetionRecvBuffer, 0, RecvSize, 0,\n                        new AsyncCallback(PipeConnectionReceiveCallback), null);\n                }\n                catch (Exception e)\n                {\n                    Logging.LogUsefulException(e);\n                    this.Close();\n                }\n            }\n            private void PipeRemoteReceiveCallback(IAsyncResult ar)
                }\n            }\n            private void PipeRemoteReceiveCallback(IAsyncResult ar)\n            {\n                if (_closed)\n                {\n                    return;\n                }\n                try\n                {
                }\n            }\n            public void Close()\n            {\n                lock (_Lock)\n                {\n                    if (_closed)\n                    {\n                        return;\n                    }
            return output;\n        }\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public extern static void md5(byte[] input, uint ilen, byte[] output);
            this.FileMenuItem = new System.Windows.Forms.MenuItem();\n            this.OpenLocationMenuItem = new System.Windows.Forms.MenuItem();\n            this.ExitMenuItem = new System.Windows.Forms.MenuItem();\n            this.panel1 = new System.Windows.Forms.Panel();
        private System.Windows.Forms.MenuItem FileMenuItem;\n        private System.Windows.Forms.MenuItem OpenLocationMenuItem;\n        private System.Windows.Forms.MenuItem ExitMenuItem;\n        private System.Windows.Forms.Panel panel1;\n        private System.Windows.Forms.CheckBox WrapTextCheckBox;\n        private System.Windows.Forms.Button CleanLogsButton;\n        private System.Windows.Forms.Button ChangeFontButton;\n        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel1;\n        private System.Windows.Forms.CheckBox TopMostCheckBox;
Server: Shadowsocks\nContent-Type: application/x-ns-proxy-autoconfig\nContent-Length: {0}\nConnection: Close\n", System.Text.Encoding.UTF8.GetBytes(pac).Length) + pac;\n                    byte[] response = System.Text.Encoding.UTF8.GetBytes(text);\n                    conn.BeginSend(response, 0, response.Length, 0, new AsyncCallback(SendCallback), conn);\n                    Util.Utils.ReleaseMemory();\n                }\n                else
        }\n    }\n}
                    if (se.SocketErrorCode == SocketError.AddressAlreadyInUse)\n                    {\n                        e = new Exception(I18N.GetString("Port {0} already in use", _config.localPort), e);\n                    }\n                    else if (se.SocketErrorCode == SocketError.AccessDenied)\n                    {\n                        e = new Exception(I18N.GetString("Port {0} is reserved by system", _config.localPort), e);\n                    }\n                }\n                Logging.LogUsefulException(e);
                if (!parsed)\n                {\n                    IPHostEntry ipHostInfo = Dns.GetHostEntry(config.server);\n                    ipAddress = ipHostInfo.AddressList[0];\n                }\n                IPEndPoint remoteEP = new IPEndPoint(ipAddress, config.server_port);\n                remote = new Socket(ipAddress.AddressFamily,\n                    SocketType.Stream, ProtocolType.Tcp);\n                remote.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n                // Connect to the remote endpoint.
                    ipAddress = ipHostInfo.AddressList[0];\n                }\n                IPEndPoint remoteEP = new IPEndPoint(ipAddress, config.server_port);\n                remote = new Socket(ipAddress.AddressFamily,\n                    SocketType.Stream, ProtocolType.Tcp);\n                remote.SetSocketOption(SocketOptionLevel.Tcp, SocketOptionName.NoDelay, true);\n                // Connect to the remote endpoint.\n                remote.BeginConnect(remoteEP,\n                    new AsyncCallback(ConnectCallback), null);\n            }
            }\n        }\n        public void UpdateInboundCounter(Server server, long n)\n        {\n            Interlocked.Add(ref inboundCounter, n);\n            if (_config.availabilityStatistics)\n            {\n                new Task(() => availabilityStatistics.UpdateInboundCounter(server, n)).Start();\n            }\n        }
            }\n        }\n        public void UpdateOutboundCounter(Server server, long n)\n        {\n            Interlocked.Add(ref outboundCounter, n);\n            if (_config.availabilityStatistics)\n            {\n                new Task(() => availabilityStatistics.UpdateOutboundCounter(server, n)).Start();\n            }\n        }
            }\n        }\n        protected void Reload()\n        {\n            // some logic in configuration updated the config when saving, we need to read it again\n            _config = Configuration.Load();\n            StatisticsConfiguration = StatisticsStrategyConfiguration.Load();\n            if (polipoRunner == null)\n            {\n                polipoRunner = new PolipoRunner();
            byte[] input, int ioff, uint ilen,\n            byte[] output);\n    }\n}
                StartPipe();\n            }\n            catch (Exception e)\n            {\n                controller.GetCurrentStrategy().SetFailure(this.server);\n                Logging.LogUsefulException(e);\n                if (retryCount < 3)\n                {\n                    Console.WriteLine("Connection failed, retrying");\n                    StartConnect();
                if (reg_ThemesPersonalize.GetValue("SystemUsesLightTheme") != null)\n                {\n                    if (Convert.ToInt32(reg_ThemesPersonalize.GetValue("SystemUsesLightTheme").ToString()) == 0) // 0:dark mode, 1:light mode\n                        registData = WindowsThemeMode.Dark;\n                    else\n                        registData = WindowsThemeMode.Light;\n                    //Console.WriteLine(registData);\n                }\n                else\n                {
            }\n            if (retval == ERROR_SUCCESS)\n            {\n                if (lpNames == 0)\n                {\n                    // no entries found.\n                    return 1;\n                }\n                allConns = new string[names.Length];\n                for (int i = 0; i < names.Length; i++)
                        byte[] plain = new byte[16384];\n                        byte[] cipher = new byte[plain.Length + 16];\n                        byte[] plain2 = new byte[plain.Length + 16];\n                        int outLen = 0;\n                        int outLen2 = 0;\n                        random.NextBytes(plain);\n                        //lock (locker)\n                        //{\n                            encryptor.Encrypt(plain, plain.Length, cipher, out outLen);\n                            decryptor.Decrypt(cipher, outLen, plain2, out outLen2);
            try\n            {\n                local.Start();\n                pacServer = new PACServer();\n                pacServer.PACFileChanged += pacServer_PACFileChanged;\n                pacServer.Start();\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine(e.Message);
                            }\n                        }\n                    }\n                }\n                else\n                {\n                    if (line.IsNullOrEmpty())\n                    {\n                        return true;\n                    }
                            }\n                        }\n                    }\n                }\n                _requestLineCount++;\n                return false;\n            }\n            private void OnFinish(byte[] lastBytes, int index, int length, object state)\n            {\n                if (_closed)
