if ( enabled ) { run _ key . set _ value ( key , path ) ; } else { run _ key . delete _ value ( key ) ; } return true ;
} else { run _ key . delete _ value ( key ) ; } return true ; } catch ( exception e ) {
} return true ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; return false ; } finally
return true ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; return false ; } finally { if ( run _ key ! = null )
string [ ] run _ list = run _ key . get _ value _ names ( ) ; foreach ( string item in run _ list ) { if ( item . equals ( key ) ) return true ; else if ( item . equals ( STR ) ) { string value = convert . to _ string ( run _ key . get _ value ( item ) ) ; if ( path . equals ( value , string _ comparison . invariant _ culture _ ignore _ case ) )
foreach ( string item in run _ list ) { if ( item . equals ( key ) ) return true ; else if ( item . equals ( STR ) ) { string value = convert . to _ string ( run _ key . get _ value ( item ) ) ; if ( path . equals ( value , string _ comparison . invariant _ culture _ ignore _ case ) ) { run _ key . delete _ value ( item ) ;
return true ; else if ( item . equals ( STR ) ) { string value = convert . to _ string ( run _ key . get _ value ( item ) ) ; if ( path . equals ( value , string _ comparison . invariant _ culture _ ignore _ case ) ) { run _ key . delete _ value ( item ) ; run _ key . set _ value ( key , path ) ; return true ; }
var local _ port = get _ next _ free _ tcp _ port ( ) ; local _ end _ point = new ip _ end _ point ( ip _ address . loopback , local _ port ) ; plugin _ process . start _ info . environment [ STR ] = local _ end _ point . address . to _ string ( ) ; plugin _ process . start _ info . environment [ STR ] = local _ end _ point . port . to _ string ( ) ; plugin _ process . start _ info . arguments = expand _ environment _ variables ( plugin _ process . start _ info . arguments , plugin _ process . start _ info . environment _ variables ) ; try { plugin _ process . start ( ) ; } catch ( system . component _ model . win _ exception ex )
plugin _ job . add _ process ( plugin _ process . handle ) ; started = true ; } return true ; } public string expand _ environment _ variables ( string name , string _ dictionary environment _ variables = null ) { if ( environment _ variables ! = null ) { foreach ( string key in environment _ variables . keys )
using system _ diagnostics ; using system _ io ; using system _ text ; using system _ threading ; namespace shadowsocks _ util _ system _ proxy {
namespace shadowsocks _ util _ system _ proxy { public static class sysproxy { private const string user _ wininet _ config _ file = STR ; private static string query _ str ; private static sysproxy _ config user _ settings = null ; enum ret _ errors : int { ret _ no _ error = 0 ,
var stderr = error . to _ string ( ) ; var stdout = output . to _ string ( ) ; var exit _ code = process . exit _ code ; if ( exit _ code ! = ( int ) ret _ errors . ret _ no _ error ) { throw new proxy _ exception ( proxy _ exception _ type . sysproxy _ exit _ error , stderr ) ; } if ( arguments = = STR ) { if ( stdout . is _ null _ or _ white _ space ( ) | | stdout . is _ null _ or _ empty ( ) )
} if ( arguments = = STR ) { if ( stdout . is _ null _ or _ white _ space ( ) | | stdout . is _ null _ or _ empty ( ) ) { throw new proxy _ exception ( proxy _ exception _ type . query _ return _ empty ) ; } query _ str = stdout ; } }
} query _ str = stdout ; } } } } private static void save ( ) { try {
color fly _ blue ; if ( current _ windows _ theme _ mode = = utils . windows _ theme _ mode . light ) fly _ blue = color . from _ argb ( NUM , NUM , NUM , NUM ) ; else fly _ blue = color . from _ argb ( NUM , NUM , NUM , NUM ) ; int red = color . r * fly _ blue . r / NUM ; int green = color . g * fly _ blue . g / NUM ; int blue = color . b * fly _ blue . b / NUM ; int alpha = color . a * fly _ blue . a / NUM ; icon _ copy . set _ pixel ( x , y , color . from _ argb ( alpha , red , green , blue ) ) ;
this . table _ layout _ panel . location = new system . drawing . point ( NUM , NUM ) ; this . table _ layout _ panel . margin = new system . windows . forms . padding ( 0 ) ; this . table _ layout _ panel . name = STR ; this . table _ layout _ panel . padding = new system . windows . forms . padding ( NUM ) ; this . table _ layout _ panel . row _ count = NUM ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ;
this . table _ layout _ panel . tab _ index = 0 ; this . plugin _ options _ label . anchor = system . windows . forms . anchor _ styles . right ; this . plugin _ options _ label . auto _ size = true ; this . plugin _ options _ label . location = new system . drawing . point ( NUM , NUM ) ; this . plugin _ options _ label . name = STR ; this . plugin _ options _ label . size = new system . drawing . size ( NUM , NUM ) ; this . plugin _ options _ label . tab _ index = NUM ; this . plugin _ options _ label . text = STR ; this . tool _ tip . set _ tool _ tip ( this . plugin _ options _ label , STR ) ; this . plugin _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ;
this . servers _ list _ box = new system . windows . forms . list _ box ( ) ; this . table _ layout _ panel . suspend _ layout ( ) ; this . panel . suspend _ layout ( ) ; this . panel . suspend _ layout ( ) ; this . server _ group _ box . suspend _ layout ( ) ; this . suspend _ layout ( ) ; this . table _ layout _ panel . auto _ size = true ; this . table _ layout _ panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . table _ layout _ panel . column _ count = 2 ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ;
using ( stream _ writer sw = new stream _ writer ( file . open ( config _ file , file _ mode . create ) ) ) { string json _ string = simple _ json . simple _ json . serialize _ object ( config ) ; sw . write ( json _ string ) ; sw . flush ( ) ; } } catch ( io _ exception e ) { console . error . write _ line ( e ) ;
{ reload ( ) ; if ( reg _ hotkeys ) { hotkey _ reg . reg _ all _ hotkeys ( ) ; } } protected void report _ error ( exception e ) { if ( errored ! = null )
} protected void report _ error ( exception e ) { if ( errored ! = null ) { errored ( this , new error _ event _ args ( e ) ) ; } } public server get _ current _ server ( ) {
byte [ ] output = new byte [ NUM ] ; mbed _ tls . md ( input , ( uint ) input . length , output ) ; return output ; }
return output ; } dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void md ( byte [ ] input , uint ilen , byte [ ] output ) ;
} }
using system _ net ; using system _ net _ sockets ; using system _ text ; using system _ web ; namespace shadowsocks _ controller
using system _ web ; namespace shadowsocks _ controller { public class pac _ server : listener . service { public const string resource _ name = STR ; private string pac _ secret { get {
using system _ collections _ generic ; using system _ component _ model ; using system _ data ; using system _ drawing ; using system _ io ; using system _ linq ; using system _ text ; using system _ windows _ forms ; using shadowsocks _ controller ; using shadowsocks _ properties ;
this . filename = filename ; initialize _ component ( ) ; this . icon = icon . from _ handle ( resources . ssw . get _ hicon ( ) ) ; log _ viewer _ config config = controller . get _ configuration _ copy ( ) . log _ viewer ; if ( config = = null ) config = new log _ viewer _ config ( ) ; top _ most _ trigger = config . top _ most ; wrap _ text _ trigger = config . wrap _ text ; toolbar _ trigger = config . toolbar _ shown ; log _ message _ text _ box . back _ color = config . get _ background _ color ( ) ;
update _ texts ( ) ; } private void update _ texts ( ) { file _ menu _ item . text = n . get _ string ( STR ) ; open _ location _ menu _ item . text = n . get _ string ( STR ) ; exit _ menu _ item . text = n . get _ string ( STR ) ; clean _ logs _ button . text = n . get _ string ( STR ) ; change _ font _ button . text = n . get _ string ( STR ) ; wrap _ text _ check _ box . text = n . get _ string ( STR ) ;
} else { int bytes _ read = connection . end _ receive ( ar ) ; if ( bytes _ read > 0 ) { logging . debug ( remote , recv _ size , STR ) ; connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , socket _ flags . none , new async _ callback ( read _ all ) , null ) ; } else
} else close ( ) ; } } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; }
this . servers _ item . index = 2 ; this . servers _ item . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . seperator _ item , this . config _ item } ) ; this . servers _ item . text = STR ; this . seperator _ item . index = 0 ; this . seperator _ item . text = STR ; this . config _ item . index = 1 ; this . config _ item . text = STR ; this . config _ item . click + = new system . event _ handler ( this . config _ click ) ;
this . edit _ pac _ file _ item . index = NUM ; this . edit _ pac _ file _ item . text = STR ; this . edit _ pac _ file _ item . click + = new system . event _ handler ( this . edit _ pac _ file _ item _ click ) ; this . menu _ item . index = NUM ; this . menu _ item . text = STR ; this . qr _ code _ item . index = NUM ; this . qr _ code _ item . text = STR ; this . qr _ code _ item . click + = new system . event _ handler ( this . qr _ code _ item _ click ) ; this . show _ log _ item . index = NUM ; this . show _ log _ item . text = STR ;
{ try { registry _ key registry = registry . current _ user . open _ sub _ key ( STR , true ) ; if ( global ) { registry . set _ value ( STR , 1 ) ; registry . set _ value ( STR , STR ) ;
system _ proxy . notify _ ie ( ) ; copy _ proxy _ setting _ from _ lan ( ) ; } catch ( exception ) { message _ box . show ( STR ) ; throw ; } } public static void disable ( )
{ settings _ return = internet _ set _ option ( int _ ptr . zero , internet _ option _ settings _ changed , int _ ptr . zero , 0 ) ; refresh _ return = internet _ set _ option ( int _ ptr . zero , internet _ option _ refresh , int _ ptr . zero , 0 ) ; } public static void enable ( ) { registry _ key registry = registry . current _ user . open _ sub _ key ( STR , true ) ; registry . set _ value ( STR , 0 ) ; registry . set _ value ( STR , STR ) ; registry . set _ value ( STR , STR ) ;
} public static void disable ( ) { registry _ key registry = registry . current _ user . open _ sub _ key ( STR , true ) ; registry . set _ value ( STR , 0 ) ; registry . set _ value ( STR , STR ) ; registry . set _ value ( STR , STR ) ; system _ proxy . notify _ ie ( ) ; }
} } }
using system _ web ; using shadowsocks _ controller ; namespace shadowsocks _ model { serializable public class server {
private const int default _ server _ timeout _ sec = NUM ; public const int max _ server _ timeout _ sec = NUM ; public string server ; public int server _ port ; public string password ; public string method ; public string plugin ; public string plugin _ opts ; public string remarks ; public int timeout ;
list < server > servers = new list < server > ( ) ; foreach ( string server _ url in server _ urls ) { if ( string . is _ null _ or _ white _ space ( server _ url ) ) { continue ;
{ if ( string . is _ null _ or _ white _ space ( server _ url ) ) { continue ; } uri parsed _ url ;
{ continue ; } uri parsed _ url ; try { parsed _ url = new uri ( server _ url ) ; } catch ( uri _ format _ exception ) {
} uri parsed _ url ; try { parsed _ url = new uri ( server _ url ) ; } catch ( uri _ format _ exception ) {
continue ; } server tmp = new server { remarks = parsed _ url . get _ components ( uri _ components . fragment , uri _ format . unescaped ) } ; string possibly _ unpadded _ base = parsed _ url . get _ components ( uri _ components . user _ info , uri _ format . unescaped ) ; bool is _ old _ format _ url = possibly _ unpadded _ base . length = = 0 ; if ( is _ old _ format _ url ) {
servers . add ( tmp ) ; } return servers ; } public string identifier ( ) { return server + ':' + server _ port ; } } }
this . table _ layout _ panel . controls . add ( this . ip _ label , 0 , 0 ) ; this . table _ layout _ panel . controls . add ( this . server _ port _ label , 0 , 1 ) ; this . table _ layout _ panel . controls . add ( this . password _ label , 0 , 2 ) ; this . table _ layout _ panel . controls . add ( this . ip _ text _ box , 1 , 0 ) ; this . table _ layout _ panel . controls . add ( this . server _ port _ text _ box , 1 , 1 ) ; this . table _ layout _ panel . controls . add ( this . password _ text _ box , 1 , 2 ) ; this . table _ layout _ panel . controls . add ( this . encryption _ label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . encryption _ select , 1 , NUM ) ; this . table _ layout _ panel . controls . add ( this . timeout _ label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . timeout _ text _ box , 1 , NUM ) ;
this . table _ layout _ panel . location = new system . drawing . point ( NUM , NUM ) ; this . table _ layout _ panel . margin = new system . windows . forms . padding ( 0 ) ; this . table _ layout _ panel . name = STR ; this . table _ layout _ panel . padding = new system . windows . forms . padding ( NUM ) ; this . table _ layout _ panel . row _ count = NUM ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ;
this . table _ layout _ panel . tab _ index = 0 ; this . plugin _ options _ label . anchor = system . windows . forms . anchor _ styles . right ; this . plugin _ options _ label . auto _ size = true ; this . plugin _ options _ label . location = new system . drawing . point ( NUM , NUM ) ; this . plugin _ options _ label . name = STR ; this . plugin _ options _ label . size = new system . drawing . size ( NUM , NUM ) ; this . plugin _ options _ label . tab _ index = NUM ; this . plugin _ options _ label . text = STR ; this . plugin _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . plugin _ text _ box . location = new system . drawing . point ( NUM , NUM ) ;
file . write _ all _ bytes ( database _ path , resources . dlc _ dat ) ; } load _ geosite _ list ( ) ; } static void load _ geosite _ list ( ) { var list = geosite _ list . parser . parse _ from ( geosite _ db ) ; foreach ( var item in list . entries ) {
foreach ( var item in list . entries ) { geosites [ item . group _ name . to _ lower ( ) ] = item . domains ; } } public static void reset _ event ( ) { update _ completed = null ; error = null ; }
{ string geosite _ url = geosite _ url ; string geosite _ sha _ sum _ url = geosite _ sh _ sum _ url ; sh my _ sh = sh . create ( ) ; var config = program . main _ controller . get _ current _ configuration ( ) ; string group = config . geosite _ group ; bool blacklist = config . geosite _ blacklist _ mode ; if ( ! string . is _ null _ or _ white _ space ( config . geosite _ url ) ) { logger . info ( STR ) ;
if ( config . enabled ) { http _ client _ handler . proxy = new web _ proxy ( config . is _ i _ pv _ enabled ? $ STR : ip _ address . loopback . to _ string ( ) , config . local _ port ) ; } try {
config . is _ i _ pv _ enabled ? $ STR : ip _ address . loopback . to _ string ( ) , config . local _ port ) ; } try { var geosite _ sha _ sum = await http _ client . get _ string _ async ( geosite _ sha _ sum _ url ) ; geosite _ sha _ sum = geosite _ sha _ sum . substring ( 0 , NUM ) . to _ upper ( ) ; logger . info ( $ STR ) ;
} public static bool merge _ and _ write _ pac _ file ( string group , bool blacklist ) { i _ list < domain _ object > domains = geosites [ group ] ; string abp _ content = merge _ pac _ file ( domains , blacklist ) ; if ( file . exists ( pac _ daemon . pac _ file ) ) { string original = file _ manager . non _ exclusive _ read _ all _ text ( pac _ daemon . pac _ file , encoding . ut ) ; if ( original = = abp _ content ) {
public config _ form ( shadowsocks _ controller controller ) { initialize _ component ( ) ; notify _ icon . context _ menu = context _ menu ; this . controller = controller ; controller . enable _ status _ changed + = controller _ enable _ status _ changed ; controller . config _ changed + = controller _ config _ changed ; controller . pac _ file _ ready _ to _ open + = controller _ pac _ file _ ready _ to _ open ; load _ current _ configuration ( ) ; }
} private void controller _ config _ changed ( object sender , event _ args e ) { load _ current _ configuration ( ) ; } private void controller _ enable _ status _ changed ( object sender , event _ args e ) { enable _ item . checked = controller . get _ configuration ( ) . enabled ; } void controller _ pac _ file _ ready _ to _ open ( object sender , shadowsocks _ controller . path _ event _ args e )
} private void controller _ enable _ status _ changed ( object sender , event _ args e ) { enable _ item . checked = controller . get _ configuration ( ) . enabled ; } void controller _ pac _ file _ ready _ to _ open ( object sender , shadowsocks _ controller . path _ event _ args e ) { string argument = STR + e . path ; system . diagnostics . process . start ( STR , argument ) ; }
} void controller _ pac _ file _ ready _ to _ open ( object sender , shadowsocks _ controller . path _ event _ args e ) { string argument = STR + e . path ; system . diagnostics . process . start ( STR , argument ) ; } private void show _ window ( ) { this . opacity = 1 ; this . show ( ) ;
{ try { if ( old _ selected _ index = = - 1 | | old _ selected _ index > = modified _ configuration . configs . count ) { return true ; } server server = new server { server = ip _ text _ box . text ,
ip _ text _ box . text = server . server ; server _ port _ text _ box . text = server . server _ port . to _ string ( ) ; password _ text _ box . text = server . password ; proxy _ port _ text _ box . text = server . local _ port . to _ string ( ) ; encryption _ select . text = server . method = = null ? STR : server . method ; } private void load _ current _ configuration ( ) { modified _ configuration = controller . get _ configuration ( ) ;
} private void load _ current _ configuration ( ) { modified _ configuration = controller . get _ configuration ( ) ; servers _ list _ box . items . clear ( ) ; foreach ( server server in modified _ configuration . configs ) { servers _ list _ box . items . add ( server . server ) ; } servers _ list _ box . selected _ index = modified _ configuration . index ;
{ if ( ! controller . get _ configuration ( ) . is _ default ) { this . opacity = 0 ; begin _ invoke ( new method _ invoker ( delegate { this . hide ( ) ; } ) ) ; } }
} private void cancel _ button _ click ( object sender , event _ args e ) { this . hide ( ) ; load _ current _ configuration ( ) ; } private void config _ form _ form _ closed ( object sender , form _ closed _ event _ args e ) { controller . stop ( ) ; }
} private void config _ form _ form _ closed ( object sender , form _ closed _ event _ args e ) { controller . stop ( ) ; } private void about _ item _ click ( object sender , event _ args e ) { process . start ( STR ) ; } private void notify _ icon _ double _ click ( object sender , event _ args e )
this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ; this . proxy _ port _ text _ box = new system . windows . forms . text _ box ( ) ; this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ; this . ip _ text _ box = new system . windows . forms . text _ box ( ) ; this . server _ port _ text _ box = new system . windows . forms . text _ box ( ) ; this . password _ text _ box = new system . windows . forms . text _ box ( ) ;
this . label = new system . windows . forms . label ( ) ; this . ip _ text _ box = new system . windows . forms . text _ box ( ) ; this . server _ port _ text _ box = new system . windows . forms . text _ box ( ) ; this . password _ text _ box = new system . windows . forms . text _ box ( ) ; this . label = new system . windows . forms . label ( ) ; this . encryption _ select = new system . windows . forms . combo _ box ( ) ; this . notify _ icon = new system . windows . forms . notify _ icon ( this . components ) ; this . panel = new system . windows . forms . panel ( ) ;
this . ip _ text _ box = new system . windows . forms . text _ box ( ) ; this . server _ port _ text _ box = new system . windows . forms . text _ box ( ) ; this . password _ text _ box = new system . windows . forms . text _ box ( ) ; this . label = new system . windows . forms . label ( ) ; this . encryption _ select = new system . windows . forms . combo _ box ( ) ; this . notify _ icon = new system . windows . forms . notify _ icon ( this . components ) ; this . panel = new system . windows . forms . panel ( ) ; this . ok _ button = new system . windows . forms . button ( ) ; this . my _ cancel _ button = new system . windows . forms . button ( ) ;
this . notify _ icon = new system . windows . forms . notify _ icon ( this . components ) ; this . panel = new system . windows . forms . panel ( ) ; this . ok _ button = new system . windows . forms . button ( ) ; this . my _ cancel _ button = new system . windows . forms . button ( ) ; this . panel = new system . windows . forms . panel ( ) ; this . context _ menu = new system . windows . forms . context _ menu ( ) ; this . enable _ item = new system . windows . forms . menu _ item ( ) ; this . config _ item = new system . windows . forms . menu _ item ( ) ; this . edit _ pac _ file _ item = new system . windows . forms . menu _ item ( ) ; this . about _ item = new system . windows . forms . menu _ item ( ) ;
this . group _ box = new system . windows . forms . group _ box ( ) ; this . servers _ list _ box = new system . windows . forms . list _ box ( ) ; this . table _ layout _ panel . suspend _ layout ( ) ; this . panel . suspend _ layout ( ) ; this . panel . suspend _ layout ( ) ; this . group _ box . suspend _ layout ( ) ; this . suspend _ layout ( ) ; this . table _ layout _ panel . auto _ size = true ; this . table _ layout _ panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . table _ layout _ panel . column _ count = 2 ;
this . encryption _ select . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( ( system . windows . forms . anchor _ styles . top | system . windows . forms . anchor _ styles . left ) | system . windows . forms . anchor _ styles . right ) ) ) ; this . encryption _ select . drop _ down _ style = system . windows . forms . combo _ box _ style . drop _ down _ list ; this . encryption _ select . formatting _ enabled = true ; this . encryption _ select . ime _ mode = system . windows . forms . ime _ mode . no _ control ; this . encryption _ select . item _ height = NUM ; this . encryption _ select . items . add _ range ( new object [ ] { STR , STR , STR ,
this . group _ box . controls . add ( this . table _ layout _ panel ) ; this . group _ box . location = new system . drawing . point ( NUM , NUM ) ; this . group _ box . name = STR ; this . group _ box . size = new system . drawing . size ( NUM , NUM ) ; this . group _ box . tab _ index = NUM ; this . group _ box . tab _ stop = false ; this . group _ box . text = STR ; this . servers _ list _ box . formatting _ enabled = true ; this . servers _ list _ box . items . add _ range ( new object [ ] { STR ,
{ }
}
} raw _ statistics = json _ convert . deserialize _ object < statistics > ( file . read _ all _ text ( path ) ) ? ? raw _ statistics ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; console . write _ line ( $ STR ) ; recorder . change ( retry _ interval , recording _ interval ) ; } }
func < string , object , bool > on _ line _ read , action < exception , object > on _ exception , action < byte [ ] , int , int , object > on _ finish , encoding encoding , string delimiter , object state ) { if ( buffer = = null ) { throw new argument _ null _ exception ( nameof ( buffer ) ) ; } if ( socket = = null )
object state ) { if ( buffer = = null ) { throw new argument _ null _ exception ( nameof ( buffer ) ) ; } if ( socket = = null ) { throw new argument _ null _ exception ( nameof ( socket ) ) ; }
{ throw new argument _ exception ( STR , nameof ( buffer ) ) ; } if ( length > 0 ) { if ( first _ packge = = null ) { throw new argument _ null _ exception ( nameof ( first _ packge ) ) ; } }
} if ( length > 0 ) { if ( first _ packge = = null ) { throw new argument _ null _ exception ( nameof ( first _ packge ) ) ; } } socket = socket ; on _ line _ read = on _ line _ read ;
{ throw new argument _ exception ( STR , nameof ( buffer ) ) ; } delimiter _ search = new byte _ search . search _ target ( delimiter _ bytes ) ; line _ buffer = buffer ; if ( length > 0 ) { if ( buffer = = first _ packge ) { buffer _ data _ index = index ;
} delimiter _ search = new byte _ search . search _ target ( delimiter _ bytes ) ; line _ buffer = buffer ; if ( length > 0 ) { if ( buffer = = first _ packge ) { buffer _ data _ index = index ; } else
if ( length > 0 ) { if ( buffer = = first _ packge ) { buffer _ data _ index = index ; } else { array . copy ( first _ packge , index , line _ buffer , 0 , length ) ; }
buffer _ data _ length = length ; try { new _ package _ recv ( ) ; } catch ( exception ex ) { on _ exception ( ex ) ; on _ finish ( ) ; }
} } public line _ reader ( int max _ line _ bytes , wrapped _ socket socket , func < string , object , bool > on _ line _ read , action < exception , object > on _ exception , action < byte [ ] , int , int , object > on _ finish , encoding encoding , string delimiter , object state ) : this ( new byte [ max _ line _ bytes ] , socket , null , 0 , 0 , on _ line _ read , on _ exception , on _ finish , encoding , delimiter , state )
{ } private void receive _ callback ( i _ async _ result ar ) { try { var bytes _ read = socket . end _ receive ( ar ) ; if ( bytes _ read = = 0 ) { on _ finish ( ) ;
request [ 0 ] = NUM ; request [ 1 ] = 1 ; request [ 2 ] = 0 ; request [ NUM ] = atyp ; request [ request . length - 2 ] = ( byte ) ( ( port > > NUM ) & 0 xff ) ; request [ request . length - 1 ] = ( byte ) ( port & 0 xff ) ; var st = new socks _ state ( ) ; st . callback = callback ; st . async _ state = state ; remote . begin _ send ( request , 0 , request . length , 0 , socks _ request _ send _ callback , st ) ;
{ class tcp _ relay : listener . service { private shadowsocks _ controller controller ; private date _ time last _ sweep _ time ; private configuration config ; public i _ set < tcp _ handler > handlers { get ; set ; } public tcp _ relay ( shadowsocks _ controller controller , configuration conf )
public tcp _ relay ( shadowsocks _ controller controller , configuration conf ) { controller = controller ; config = conf ; handlers = new hash _ set < tcp _ handler > ( ) ; last _ sweep _ time = date _ time . now ; } public override bool handle ( byte [ ] first _ packet , int length , socket socket , object state )
} public override bool handle ( byte [ ] first _ packet , int length , socket socket , object state ) { if ( socket . protocol _ type ! = protocol _ type . tcp | | ( length < 2 | | first _ packet [ 0 ] ! = NUM ) )
return false ; socket . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; tcp _ handler handler = new tcp _ handler ( controller , config , this , socket ) ; i _ list < tcp _ handler > handlers _ to _ close = new list < tcp _ handler > ( ) ; lock ( handlers ) { handlers . add ( handler ) ; date _ time now = date _ time . now ; if ( now - last _ sweep _ time > time _ span . from _ seconds ( 1 ) )
socket . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; tcp _ handler handler = new tcp _ handler ( controller , config , this , socket ) ; i _ list < tcp _ handler > handlers _ to _ close = new list < tcp _ handler > ( ) ; lock ( handlers ) { handlers . add ( handler ) ; date _ time now = date _ time . now ; if ( now - last _ sweep _ time > time _ span . from _ seconds ( 1 ) ) { last _ sweep _ time = now ;
{ class async _ session
{ public i _ forward _ proxy remote { get ; } public async _ session ( i _ forward _ proxy remote ) { remote = remote ; } } class async _ session < t > : async _ session { public t state { get ; set ; }
{ public t state { get ; set ; } public async _ session ( i _ forward _ proxy remote , t state ) : base ( remote ) { state = state ; } public async _ session ( async _ session session , t state ) : base ( session . remote ) { state = state ; }
private async _ session current _ remote _ session ; private bool proxy _ connected ; private bool dest _ connected ; private byte command ; private byte [ ] first _ packet ; private int first _ packet _ length ; private int total _ read = 0 ; private int total _ write = 0 ; private byte [ ] remote _ recv _ buffer = new byte [ buffer _ size ] ; private byte [ ] remote _ send _ buffer = new byte [ buffer _ size ] ;
private date _ time start _ connect _ time ; private date _ time start _ receiving _ time ; private date _ time start _ sending _ time ; private end _ point dest _ end _ point = null ; public tcp _ handler ( shadowsocks _ controller controller , configuration config , tcp _ relay tcprelay , socket socket ) { controller = controller ; config = config ; tcprelay = tcprelay ; connection = socket ;
{ controller = controller ; config = config ; tcprelay = tcprelay ; connection = socket ; proxy _ timeout = config . proxy . proxy _ timeout * NUM ; server _ timeout = config . get _ current _ server ( ) . timeout * NUM ; last _ activity = date _ time . now ; } public void create _ remote ( )
if ( server = = null | | server . server = = STR ) throw new argument _ exception ( STR ) ; lock ( encryption _ lock ) { lock ( decryption _ lock ) { encryptor = encryptor _ factory . get _ encryptor ( server . method , server . password , server . auth , false ) ; } } this . server = server ;
try { start _ receiving _ time = date _ time . now ; session . remote . begin _ receive ( remote _ recv _ buffer , 0 , recv _ size , socket _ flags . none , new async _ callback ( pipe _ remote _ receive _ callback ) , session ) ; send _ to _ server ( first _ packet _ length , session ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ;
} catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; } } private void pipe _ remote _ receive _ callback ( i _ async _ result ar ) { if ( closed ) return ;
total _ write + = length ; int bytes _ to _ send ; lock ( encryption _ lock ) { encryptor . encrypt ( connetion _ recv _ buffer , length , connetion _ send _ buffer , out bytes _ to _ send ) ; } tcprelay . update _ outbound _ counter ( server , bytes _ to _ send ) ; start _ sending _ time = date _ time . now ; session . remote . begin _ send ( connetion _ send _ buffer , 0 , bytes _ to _ send , socket _ flags . none , new async _ callback ( pipe _ remote _ send _ callback ) , session ) ; i _ strategy strategy = controller . get _ current _ strategy ( ) ;
i _ strategy strategy = controller . get _ current _ strategy ( ) ; strategy ? . update _ last _ write ( server ) ; } private void pipe _ remote _ send _ callback ( i _ async _ result ar )
private void pipe _ remote _ send _ callback ( i _ async _ result ar ) { if ( closed ) return ; try { var session = ( async _ session ) ar . async _ state ; session . remote . end _ send ( ar ) ; connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , socket _ flags . none , new async _ callback ( pipe _ connection _ receive _ callback ) , session ) ; } catch ( exception e )
} catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; } } private void pipe _ connection _ send _ callback ( i _ async _ result ar ) { try
services . add ( tcp _ relay ) ; services . add ( udp _ relay ) ; services . add ( pac _ server ) ; services . add ( new http _ socks ( config . local _ port ) ) ; listener = new listener ( services ) ; listener . start ( config ) ; } catch ( exception e ) { if ( e is socket _ exception )
encrypt _ iv = new byte [ iv _ len ] ; array . copy ( iv , encrypt _ iv , iv _ len ) ; } else { decrypt _ iv = new byte [ iv _ len ] ; array . copy ( iv , decrypt _ iv , iv _ len ) ; } } else if ( cipher = = cipher _ bf )
decrypt _ iv = new byte [ iv _ len ] ; array . copy ( iv , decrypt _ iv , iv _ len ) ; } } else if ( cipher = = cipher _ r ) { polar _ ssl . arc _ init ( ctx ) ; polar _ ssl . arc _ setup ( ctx , realkey , key _ len ) ; } }
public event event _ handler pac _ file _ changed ; public event event _ handler update _ pac _ from _ gfw _ list _ completed ; public event error _ event _ handler update _ pac _ from _ gfw _ list _ error ; public void start ( configuration configuration ) { try { config = configuration ; listener = new socket ( address _ family . inter _ network , socket _ type . stream , protocol _ type . tcp ) ; listener . set _ socket _ option ( socket _ option _ level . socket , socket _ option _ name . reuse _ address , true ) ;
} catch ( socket _ exception ) { listener . close ( ) ; throw ; } } public void stop ( ) {
if ( listener ! = null ) { listener . close ( ) ; listener = null ; } } public string touch _ pac _ file ( ) { if ( file . exists ( pac _ file ) ) {
public i _ web _ proxy proxy = null ; public class gfw _ list _ download _ completed _ args : event _ args { public string content ; } public event event _ handler < gfw _ list _ download _ completed _ args > download _ completed ; public event error _ event _ handler error ; public void download ( ) { web _ client http = new web _ client ( ) ;
{ try { string response = e . result ; if ( download _ completed ! = null ) { download _ completed ( this , new gfw _ list _ download _ completed _ args { content = response } ) ;
} catch ( exception ex ) { report _ error ( ex ) ; } } public class parser { private string content ; public string content
public parser ( string response ) { byte [ ] bytes = convert . from _ base _ string ( response ) ; this . content = encoding . ascii . get _ string ( bytes ) ; } public string [ ] get _ valid _ lines ( ) { string [ ] lines = content . split ( new char [ ] { '\r' , '\n' } , string _ split _ options . remove _ empty _ entries ) ; list < string > valid _ lines = new list < string > ( lines . length ) ; foreach ( string line in lines )
} public string [ ] get _ domains ( ) { list < string > lines = new list < string > ( get _ valid _ lines ( ) ) ; lines . add _ range ( get _ build _ in ( ) ) ; list < string > domains = new list < string > ( lines . count ) ; for ( int i = 0 ; i < lines . count ; i + + ) { string line = lines [ i ] ; if ( line . index _ of ( STR ) > = 0 )
lines . add _ range ( get _ build _ in ( ) ) ; list < string > domains = new list < string > ( lines . count ) ; for ( int i = 0 ; i < lines . count ; i + + ) { string line = lines [ i ] ; if ( line . index _ of ( STR ) > = 0 ) continue ; if ( line . starts _ with ( STR ) ) line = line . substring ( NUM ) ; else if ( line . starts _ with ( STR ) )

this . table _ layout _ panel . suspend _ layout ( ) ; this . panel . suspend _ layout ( ) ; this . panel . suspend _ layout ( ) ; this . server _ group _ box . suspend _ layout ( ) ; this . panel . suspend _ layout ( ) ; this . suspend _ layout ( ) ; this . table _ layout _ panel . auto _ size = true ; this . table _ layout _ panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . table _ layout _ panel . column _ count = 2 ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ;
{ this . opacity = 0 ; begin _ invoke ( new method _ invoker ( delegate { this . hide ( ) ; } ) ) ;
} } private void servers _ list _ box _ selected _ index _ changed ( object sender , event _ args e ) { if ( old _ selected _ index = = servers _ list _ box . selected _ index ) { return ; } if ( ! save _ old _ selected _ server ( ) ) {
} } private void user _ rule _ file _ watcher _ changed ( object sender , file _ system _ event _ args e ) { string path = e . full _ path . to _ string ( ) ; string current _ last _ write _ time = file . get _ last _ write _ time ( e . full _ path ) . to _ string ( ) ; if ( ! file _ changed _ time . contains _ key ( path ) | | file _ changed _ time [ path ] . to _ string ( ) ! = current _ last _ write _ time ) { if ( user _ rule _ file _ changed ! = null ) {
private string get _ pac _ address ( byte [ ] request _ buf , int length , ip _ end _ point local _ end _ point , bool use _ socks ) { return ( use _ socks ? STR : STR ) + local _ end _ point . address + STR + this . config . local _ port + STR ; } } }
process . start _ info . create _ no _ window = true ; process . start ( ) ; } } public void stop ( ) { if ( process ! = null ) {
process . start ( ) ; } } public void stop ( ) { if ( process ! = null ) { try { process . kill ( ) ;
online _ pac _ item . checked = online _ pac _ item . enabled & & config . use _ online _ pac ; local _ pac _ item . checked = ! online _ pac _ item . checked ; update _ pac _ items _ enabled _ status ( ) ;
} } private void update _ online _ pacurl _ item _ click ( object sender , event _ args e ) { string orig _ pac _ url = controller . get _ configuration ( ) . pac _ url ; string pac _ url = microsoft . visual _ basic . interaction . input _ box ( n . get _ string ( STR ) , n . get _ string ( STR ) , orig _ pac _ url , - 1 , - 1 ) ; if ( ! string . is _ null _ or _ empty ( pac _ url ) & & pac _ url ! = orig _ pac _ url )
using system _ io ; using system _ i _ compression ; namespace shadowsocks _ controller { public class file _ manager { public static bool byte _ array _ to _ file ( string file _ name , byte [ ] content ) { try
namespace shadowsocks _ controller { public class file _ manager { public static bool byte _ array _ to _ file ( string file _ name , byte [ ] content ) { try { file _ stream file _ stream = new file _ stream ( file _ name , file _ mode . create , file _ access . write ) ;
file _ stream . write ( content , 0 , content . length ) ; file _ stream . close ( ) ; return true ; } catch ( exception exception ) { console . write _ line ( STR , exception . to _ string ( ) ) ; } return false ;
{ destination _ file . write ( buffer , 0 , n ) ; } } destination _ file . close ( ) ;
destination _ file . write ( buffer , 0 , n ) ; } } destination _ file . close ( ) ; } public static void compress _ file ( string file _ name , byte [ ] content ) { file _ stream destination _ file = file . create ( file _ name ) ; memory _ stream ms = new memory _ stream ( content ) ; byte [ ] buffer = new byte [ NUM ] ;
return true ; } catch ( io _ exception e ) { console . write _ line ( e . to _ string ( ) ) ; return false ; } } private static void roll _ log _ file ( ) {
} public static void info ( object o ) { write _ to _ log _ file ( o ) ; } public static void debug ( object o ) { write _ to _ log _ file ( STR + o ) ; } public static void debug ( end _ point local , end _ point remote , int len , string header = null , string tailer = null )
} public static void debug ( object o ) { write _ to _ log _ file ( STR + o ) ; } public static void debug ( end _ point local , end _ point remote , int len , string header = null , string tailer = null ) { if ( header = = null & & tailer = = null ) debug ( $ STR ) ; else if ( header = = null & & tailer ! = null )
} public static void debug ( end _ point local , end _ point remote , int len , string header = null , string tailer = null ) { if ( header = = null & & tailer = = null ) debug ( $ STR ) ; else if ( header = = null & & tailer ! = null ) debug ( $ STR ) ; else if ( header ! = null & & tailer = = null ) debug ( $ STR ) ; else
{ web _ client http = new web _ client ( ) ; http . proxy = new web _ proxy ( ip _ address . loopback . to _ string ( ) , config . local _ port ) ; http . download _ string _ completed + = http _ download _ string _ completed ; http . download _ string _ async ( new uri ( gfwlist _ url ) ) ; } public list < string > parse _ result ( string response ) { byte [ ] bytes = convert . from _ base _ string ( response ) ; string content = encoding . ascii . get _ string ( bytes ) ;
http . download _ string _ completed + = http _ download _ string _ completed ; http . download _ string _ async ( new uri ( gfwlist _ url ) ) ; } public list < string > parse _ result ( string response ) { byte [ ] bytes = convert . from _ base _ string ( response ) ; string content = encoding . ascii . get _ string ( bytes ) ; string [ ] lines = content . split ( new char [ ] { '\r' , '\n' } , string _ split _ options . remove _ empty _ entries ) ; list < string > valid _ lines = new list < string > ( lines . length ) ; foreach ( string line in lines )
change _ font _ button . text = n . get _ string ( STR ) ; wrap _ text _ check _ box . text = n . get _ string ( STR ) ; top _ most _ check _ box . text = n . get _ string ( STR ) ; view _ menu _ item . text = n . get _ string ( STR ) ; clear _ logs _ menu _ item . text = n . get _ string ( STR ) ; change _ font _ menu _ item . text = n . get _ string ( STR ) ; wrap _ text _ menu _ item . text = n . get _ string ( STR ) ; top _ most _ menu _ item . text = n . get _ string ( STR ) ; show _ toolbar _ menu _ item . text = n . get _ string ( STR ) ; text = n . get _ string ( STR ) ;
change _ font _ menu _ item . text = n . get _ string ( STR ) ; wrap _ text _ menu _ item . text = n . get _ string ( STR ) ; top _ most _ menu _ item . text = n . get _ string ( STR ) ; show _ toolbar _ menu _ item . text = n . get _ string ( STR ) ; text = n . get _ string ( STR ) ; traffic _ chart . series [ STR ] . legend _ text = n . get _ string ( STR ) ; traffic _ chart . series [ STR ] . legend _ text = n . get _ string ( STR ) ; } private void timer _ tick ( object sender , event _ args e ) {
{ logging . clear ( ) ; last _ offset = 0 ; log _ message _ text _ box . clear ( ) ; } private void clear _ logs _ menu _ item _ click ( object sender , event _ args e ) { do _ clear _ logs ( ) ; } private void clear _ logs _ button _ click ( object sender , event _ args e )
} private void do _ change _ font ( ) { try { font _ dialog fd = new font _ dialog ( ) ; fd . font = log _ message _ text _ box . font ; if ( fd . show _ dialog ( ) = = dialog _ result . ok ) { log _ message _ text _ box . font = new font ( fd . font . font _ family , fd . font . size , fd . font . style ) ;
this . change _ font _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . wrap _ text _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . top _ most _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . menu _ item _ separater = new system . windows . forms . menu _ item ( ) ; this . show _ toolbar _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . top _ most _ check _ box = new system . windows . forms . check _ box ( ) ; this . change _ font _ button = new system . windows . forms . button ( ) ; this . clear _ logs _ button = new system . windows . forms . button ( ) ;

this . change _ font _ menu _ item . index = 1 ; this . change _ font _ menu _ item . text = STR ; this . change _ font _ menu _ item . click + = new system . event _ handler ( this . change _ font _ menu _ item _ click ) ; this . wrap _ text _ menu _ item . index = 2 ; this . wrap _ text _ menu _ item . text = STR ; this . wrap _ text _ menu _ item . click + = new system . event _ handler ( this . wrap _ text _ menu _ item _ click ) ; this . top _ most _ menu _ item . index = NUM ; this . top _ most _ menu _ item . text = STR ; this . top _ most _ menu _ item . click + = new system . event _ handler ( this . top _ most _ menu _ item _ click ) ; this . menu _ item _ separater . index = NUM ;
private system . windows . forms . button change _ font _ button ; private system . windows . forms . table _ layout _ panel table _ layout _ panel ; private system . windows . forms . check _ box top _ most _ check _ box ; private system . windows . forms . menu _ item view _ menu _ item ; private system . windows . forms . menu _ item clear _ logs _ menu _ item ; private system . windows . forms . menu _ item change _ font _ menu _ item ; private system . windows . forms . menu _ item wrap _ text _ menu _ item ; private system . windows . forms . menu _ item top _ most _ menu _ item ; private system . windows . forms . flow _ layout _ panel toolbar _ flow _ layout _ panel ; private system . windows . forms . menu _ item menu _ item _ separater ;
private system . windows . forms . menu _ item change _ font _ menu _ item ; private system . windows . forms . menu _ item wrap _ text _ menu _ item ; private system . windows . forms . menu _ item top _ most _ menu _ item ; private system . windows . forms . flow _ layout _ panel toolbar _ flow _ layout _ panel ; private system . windows . forms . menu _ item menu _ item _ separater ; private system . windows . forms . menu _ item show _ toolbar _ menu _ item ; private system . windows . forms . split _ container split _ container ; private system . windows . forms . data _ visualization . charting . chart traffic _ chart ; } }
target _ index = i ; } logging . info ( $ STR ) ; } if ( target _ index = = - 1 | | en _ index = = target _ index ) { logging . info ( $ STR ) ; return ; }
} logging . info ( $ STR ) ; } if ( target _ index = = - 1 | | en _ index = = target _ index ) { logging . info ( $ STR ) ; return ; } while ( ! csv _ parser . end _ of _ data ) {
{ logging . info ( $ STR ) ; return ; } while ( ! csv _ parser . end _ of _ data ) { string [ ] translations = csv _ parser . read _ fields ( ) ; string source = translations [ en _ index ] ; string translation = translations [ target _ index ] ; if ( string . is _ null _ or _ white _ space ( source ) | | string . is _ null _ or _ white _ space ( translation ) ) continue ;
connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , socket _ flags . none , new async _ callback ( read _ all ) , null ) ; } else { int bytes _ read = connection . end _ receive ( ar ) ; if ( bytes _ read > 0 ) { connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , socket _ flags . none , new async _ callback ( read _ all ) , null ) ; }
connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , socket _ flags . none , new async _ callback ( read _ all ) , null ) ; } else close ( ) ; } } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ;
ip _ end _ point proxy _ ep ; if ( config . use _ proxy ) { ip _ address ip _ address ; bool parsed = ip _ address . try _ parse ( config . proxy _ server , out ip _ address ) ; if ( ! parsed ) { ip _ host _ entry ip _ host _ info = dns . get _ host _ entry ( config . proxy _ server ) ; ip _ address = ip _ host _ info . address _ list [ 0 ] ;
if ( ! parsed ) { ip _ host _ entry ip _ host _ info = dns . get _ host _ entry ( config . proxy _ server ) ; ip _ address = ip _ host _ info . address _ list [ 0 ] ; } remote = new socks _ proxy ( ) ; proxy _ ep = new ip _ end _ point ( ip _ address , config . proxy _ port ) ; } else {
} proxy _ timer proxy _ timer = new proxy _ timer ( NUM ) ; proxy _ timer . auto _ reset = false ; proxy _ timer . elapsed + = proxy _ connect _ timer _ elapsed ; proxy _ timer . enabled = true ; proxy _ timer . proxy = remote ; proxy _ timer . dest _ host = server . server ; proxy _ timer . dest _ port = server . server _ port ; proxy _ timer . server = server ;
proxy _ timer . server = server ; proxy _ connected = false ; remote . begin _ connect _ proxy ( proxy _ ep , new async _ callback ( proxy _ connect _ callback ) , proxy _ timer ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; } }
public void begin _ connect _ proxy ( end _ point remote _ ep , async _ callback callback , object state ) { var r = new fake _ async _ result ( state ) ; callback ? . invoke ( r ) ; } public void end _ connect _ proxy ( i _ async _ result async _ result ) { } public void begin _ connect _ dest ( string host , int port , async _ callback callback , object state )
var r = new fake _ async _ result ( state ) ; callback ? . invoke ( r ) ; } public void end _ connect _ proxy ( i _ async _ result async _ result ) { } public void begin _ connect _ dest ( string host , int port , async _ callback callback , object state ) { ip _ address ip _ address ; bool parsed = ip _ address . try _ parse ( host , out ip _ address ) ;
{ ip _ address ip _ address ; bool parsed = ip _ address . try _ parse ( host , out ip _ address ) ; if ( ! parsed ) { ip _ host _ entry ip _ host _ info = dns . get _ host _ entry ( host ) ; ip _ address = ip _ host _ info . address _ list [ 0 ] ; } ip _ end _ point remote _ ep = new ip _ end _ point ( ip _ address , port ) ; dest _ host = host ;
remote . begin _ connect ( remote _ ep , callback , state ) ; } public void end _ connect _ dest ( i _ async _ result async _ result ) { remote ? . end _ connect ( async _ result ) ; } public void begin _ send ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) { remote ? . begin _ send ( buffer , offset , size , socket _ flags , callback , state ) ;
void begin _ connect _ proxy ( end _ point remote _ ep , async _ callback callback , object state ) ; void end _ connect _ proxy ( i _ async _ result async _ result ) ; void begin _ connect _ dest ( string host , int port , async _ callback callback , object state ) ; void end _ connect _ dest ( i _ async _ result async _ result ) ; void begin _ send ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) ; int end _ send ( i _ async _ result async _ result ) ; void begin _ receive ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) ; int end _ receive ( i _ async _ result async _ result ) ;
void end _ connect _ dest ( i _ async _ result async _ result ) ; void begin _ send ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) ; int end _ send ( i _ async _ result async _ result ) ; void begin _ receive ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) ; int end _ receive ( i _ async _ result async _ result ) ; void shutdown ( socket _ shutdown how ) ; void close ( ) ; }
bitmap draw _ area = new bitmap ( ( qr _ coded . get _ module _ count ( ) * block _ size ) , ( qr _ coded . get _ module _ count ( ) * block _ size ) ) ; using ( graphics g = graphics . from _ image ( draw _ area ) ) { g . clear ( color . white ) ; using ( brush b = new solid _ brush ( color . black ) ) { for ( int row = 0 ; row < qr _ coded . get _ module _ count ( ) ; row + + )
{ g . clear ( color . white ) ; using ( brush b = new solid _ brush ( color . black ) ) { for ( int row = 0 ; row < qr _ coded . get _ module _ count ( ) ; row + + ) { for ( int col = 0 ; col < qr _ coded . get _ module _ count ( ) ; col + + )
{ for ( int row = 0 ; row < qr _ coded . get _ module _ count ( ) ; row + + ) { for ( int col = 0 ; col < qr _ coded . get _ module _ count ( ) ; col + + ) { bool is _ dark = qr _ coded . is _ dark ( row , col ) ; if ( is _ dark ) {
{ for ( int col = 0 ; col < qr _ coded . get _ module _ count ( ) ; col + + ) { bool is _ dark = qr _ coded . is _ dark ( row , col ) ; if ( is _ dark ) { g . fill _ rectangle ( b , block _ size * row , block _ size * col , block _ size , block _ size ) ;
{ bool is _ dark = qr _ coded . is _ dark ( row , col ) ; if ( is _ dark ) { g . fill _ rectangle ( b , block _ size * row , block _ size * col , block _ size , block _ size ) ;
{ g . fill _ rectangle ( b , block _ size * row , block _ size * col , block _ size , block _ size ) ;
} } } } } picture _ box . image = draw _ area ; } private void qr _ code _ form _ load ( object sender , event _ args e ) { gen _ qr ( code ) ;
config . is _ default = false ; if ( update _ checker . asset . compare _ version ( update _ checker . version , config . version ? ? STR ) > 0 ) { config . updated = true ; } if ( config . configs = = null ) config . configs = new list < server > ( ) ; if ( config . configs . count = = 0 ) config . configs . add ( get _ default _ server ( ) ) ; if ( config . local _ port = = 0 )
} catch ( exception e ) { if ( ! ( e is file _ not _ found _ exception ) ) logger . log _ useful _ exception ( e ) ; config = new configuration { index = 0 , is _ default = true , local _ port = NUM ,
{ index = 0 , is _ default = true , local _ port = NUM , auto _ check _ update = true , configs = new list < server > ( ) { get _ default _ server ( ) } , log _ viewer = new log _ viewer _ config ( ) ,
{ font _ dialog fd = new font _ dialog ( ) ; fd . font = log _ message _ text _ box . font ; if ( fd . show _ dialog ( ) = = dialog _ result . ok ) { log _ message _ text _ box . font = new font ( fd . font . font _ family , fd . font . size , fd . font . style ) ; } } catch ( exception ex ) {
} } private void top _ most _ check _ box _ checked _ changed ( object sender , event _ args e ) { this . top _ most = top _ most _ check _ box . checked ; } } }
internal static string polipo _ config { get { return resource _ manager . get _ string ( STR , resource _ culture ) ; } } internal static byte [ ] polipo _ exe { get { object obj = resource _ manager . get _ object ( STR , resource _ culture ) ; return ( ( byte [ ] ) ( obj ) ) ; }
{ continue ; } int index _ of _ hash _ or _ slash = server _ url . index _ of _ any ( new [ ] { '@' , '/' , '#' } , prefix _ length , server _ url . length - prefix _ length ) ; string web _ safe _ base _ str = index _ of _ hash _ or _ slash = = - 1 ? server _ url . substring ( prefix _ length ) : server _ url . substring ( prefix _ length , index _ of _ hash _ or _ slash - prefix _ length ) ; string base _ str = web _ safe _ base _ str . replace ( '-' , '+' ) . replace ( '_' , '/' ) ; string base = base _ str . pad _ right ( base _ str . length + ( NUM - base _ str . length % NUM ) % NUM , '=' ) ;
} catch ( uri _ format _ exception ) { continue ; } server tmp = new server { remarks = parsed _ url . get _ components ( uri _ components . fragment , uri _ format . unescaped ) } ; string user _ info = parsed _ url . get _ components ( uri _ components . user _ info , uri _ format . unescaped ) ;
string [ ] user _ info _ parts = user _ info . split ( new [ ] { ':' } , 2 ) ; if ( user _ info _ parts . length ! = 2 ) { continue ; } tmp . method = user _ info _ parts [ 0 ] ; tmp . password = user _ info _ parts [ 1 ] ; name _ value _ collection query _ parameters = http _ utility . parse _ query _ string ( parsed _ url . query ) ; string [ ] plugin _ parts = http _ utility . url _ decode ( query _ parameters [ STR ] ? ? STR ) . split ( new [ ] { ';' } , 2 ) ; if ( plugin _ parts . length > 0 )
this . table _ layout _ panel . location = new system . drawing . point ( NUM , NUM ) ; this . table _ layout _ panel . margin = new system . windows . forms . padding ( 0 ) ; this . table _ layout _ panel . name = STR ; this . table _ layout _ panel . padding = new system . windows . forms . padding ( NUM ) ; this . table _ layout _ panel . row _ count = NUM ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ;
this . table _ layout _ panel . tab _ index = 0 ; this . remarks _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . remarks _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . remarks _ text _ box . max _ length = NUM ; this . remarks _ text _ box . name = STR ; this . remarks _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . remarks _ text _ box . tab _ index = NUM ; this . remarks _ text _ box . word _ wrap = false ; this . remarks _ label . anchor = system . windows . forms . anchor _ styles . right ; this . remarks _ label . auto _ size = true ;
this . proxy _ port _ text _ box = new system . windows . forms . text _ box ( ) ; this . table _ layout _ panel = new system . windows . forms . table _ layout _ panel ( ) ; this . proxy _ type _ label = new system . windows . forms . label ( ) ; this . proxy _ type _ combo _ box = new system . windows . forms . combo _ box ( ) ; this . proxy _ timeout _ text _ box = new system . windows . forms . text _ box ( ) ; this . proxy _ timeout _ label = new system . windows . forms . label ( ) ;
this . proxy _ addr _ label . auto _ size = true ; this . proxy _ addr _ label . location = new system . drawing . point ( NUM , NUM ) ; this . proxy _ addr _ label . name = STR ; this . proxy _ addr _ label . size = new system . drawing . size ( NUM , NUM ) ; this . proxy _ addr _ label . tab _ index = 0 ; this . proxy _ addr _ label . text = STR ; this . proxy _ server _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . proxy _ server _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . proxy _ server _ text _ box . max _ length = NUM ; this . proxy _ server _ text _ box . name = STR ;
this . proxy _ port _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . proxy _ port _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . proxy _ port _ text _ box . max _ length = NUM ; this . proxy _ port _ text _ box . name = STR ; this . proxy _ port _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . proxy _ port _ text _ box . tab _ index = NUM ; this . proxy _ port _ text _ box . word _ wrap = false ; this . table _ layout _ panel . auto _ size = true ; this . table _ layout _ panel . column _ count = NUM ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ;
this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . controls . add ( this . proxy _ type _ label , 0 , 0 ) ; this . table _ layout _ panel . controls . add ( this . proxy _ type _ combo _ box , 1 , 0 ) ; this . table _ layout _ panel . controls . add ( this . proxy _ timeout _ text _ box , NUM , 0 ) ; this . table _ layout _ panel . controls . add ( this . proxy _ timeout _ label , 2 , 0 ) ; this . table _ layout _ panel . location = new system . drawing . point ( NUM , NUM ) ; this . table _ layout _ panel . name = STR ; this . table _ layout _ panel . row _ count = 1 ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ;
this . proxy _ type _ label . auto _ size = true ; this . proxy _ type _ label . location = new system . drawing . point ( NUM , NUM ) ; this . proxy _ type _ label . name = STR ; this . proxy _ type _ label . size = new system . drawing . size ( NUM , NUM ) ; this . proxy _ type _ label . tab _ index = 1 ; this . proxy _ type _ label . text = STR ; this . proxy _ type _ combo _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . proxy _ type _ combo _ box . drop _ down _ style = system . windows . forms . combo _ box _ style . drop _ down _ list ; this . proxy _ type _ combo _ box . formatting _ enabled = true ; this . proxy _ type _ combo _ box . items . add _ range ( new object [ ] {
this . proxy _ type _ combo _ box . drop _ down _ style = system . windows . forms . combo _ box _ style . drop _ down _ list ; this . proxy _ type _ combo _ box . formatting _ enabled = true ; this . proxy _ type _ combo _ box . items . add _ range ( new object [ ] { STR , STR } ) ; this . proxy _ type _ combo _ box . location = new system . drawing . point ( NUM , NUM ) ; this . proxy _ type _ combo _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . proxy _ type _ combo _ box . name = STR ; this . proxy _ type _ combo _ box . size = new system . drawing . size ( NUM , NUM ) ; this . proxy _ type _ combo _ box . tab _ index = 2 ;
private system . windows . forms . text _ box proxy _ port _ text _ box ; private system . windows . forms . table _ layout _ panel table _ layout _ panel ; private system . windows . forms . button my _ cancel _ button ; private system . windows . forms . button ok _ button ; private system . windows . forms . table _ layout _ panel table _ layout _ panel ; private system . windows . forms . label proxy _ type _ label ; private system . windows . forms . combo _ box proxy _ type _ combo _ box ; private system . windows . forms . text _ box proxy _ timeout _ text _ box ; private system . windows . forms . label proxy _ timeout _ label ; }
if ( config . availability _ statistics ) { availability _ statistics . update _ latency ( args . server , ( int ) args . latency . total _ milliseconds ) ; } } public void update _ inbound _ counter ( object sender , ss _ transmit _ event _ args args ) { get _ current _ strategy ( ) ? . update _ last _ read ( args . server ) ; interlocked . add ( ref inbound _ counter , args . length ) ; if ( config . availability _ statistics )
if ( config . availability _ statistics ) { availability _ statistics . update _ inbound _ counter ( args . server , args . length ) ; } } public void update _ outbound _ counter ( object sender , ss _ transmit _ event _ args args ) { get _ current _ strategy ( ) ? . update _ last _ write ( args . server ) ; interlocked . add ( ref outbound _ counter , args . length ) ; if ( config . availability _ statistics )
if ( config . availability _ statistics ) { availability _ statistics . update _ outbound _ counter ( args . server , args . length ) ; } } protected void reload ( ) { encryption . rng . reload ( ) ; config = configuration . load ( ) ; n _ log _ config . load _ configuration ( ) ;
} } protected void reload ( ) { encryption . rng . reload ( ) ; config = configuration . load ( ) ; n _ log _ config . load _ configuration ( ) ; statistics _ configuration = statistics _ strategy _ configuration . load ( ) ; privoxy _ runner = privoxy _ runner ? ? new privoxy _ runner ( ) ; pac _ daemon = pac _ daemon ? ? new pac _ daemon ( config ) ;
using system _ collections _ generic ; using system _ linq ; using system _ net ; using system _ net _ sockets ; using system _ timers ; using n _ log ; using shadowsocks _ controller _ strategy ; using shadowsocks _ encryption ; using shadowsocks _ encryption _ aead ; using shadowsocks _ encryption _ exception ;
{ public event event _ handler < sstcp _ connected _ event _ args > on _ connected ; public event event _ handler < ss _ transmit _ event _ args > on _ inbound ; public event event _ handler < ss _ transmit _ event _ args > on _ outbound ; public event event _ handler < ss _ relay _ event _ args > on _ failed ; private static readonly logger logger = log _ manager . get _ current _ class _ logger ( ) ; private readonly shadowsocks _ controller controller ; private date _ time last _ sweep _ time ;
private date _ time last _ sweep _ time ; private readonly configuration config ; public i _ set < tcp _ handler > handlers { get ; set ; } public tcp _ relay ( shadowsocks _ controller controller , configuration conf ) { controller = controller ; config = conf ; handlers = new hash _ set < tcp _ handler > ( ) ; last _ sweep _ time = date _ time . now ; }
public i _ set < tcp _ handler > handlers { get ; set ; } public tcp _ relay ( shadowsocks _ controller controller , configuration conf ) { controller = controller ; config = conf ; handlers = new hash _ set < tcp _ handler > ( ) ; last _ sweep _ time = date _ time . now ; } public override bool handle ( byte [ ] first _ packet , int length , socket socket , object state ) {
i _ list < tcp _ handler > handlers _ to _ close = new list < tcp _ handler > ( ) ; lock ( handlers ) { handlers . add ( handler ) ; date _ time now = date _ time . now ; if ( now - last _ sweep _ time > time _ span . from _ seconds ( 1 ) ) { last _ sweep _ time = now ; foreach ( tcp _ handler handler in handlers ) {
} } internal class tcp _ handler { public event event _ handler < sstcp _ connected _ event _ args > on _ connected ; public event event _ handler < ss _ transmit _ event _ args > on _ inbound ; public event event _ handler < ss _ transmit _ event _ args > on _ outbound ; public event event _ handler < ss _ relay _ event _ args > on _ closed ; public event event _ handler < ss _ relay _ event _ args > on _ failed ; private class async _ session
{ public i _ proxy remote { get ; } public async _ session ( i _ proxy remote ) { remote = remote ; } } private class async _ session < t > : async _ session { public t state { get ; set ; }
{ public t state { get ; set ; } public async _ session ( i _ proxy remote , t state ) : base ( remote ) { state = state ; } public async _ session ( async _ session session , t state ) : base ( session . remote ) { state = state ; }
private readonly int server _ timeout ; private readonly int proxy _ timeout ; public const int recv _ size = NUM ; public const int chunk _ overhead _ size = NUM * 2 public const uint max _ chunk _ size = aead _ encryptor . chunk _ len _ mask + aead _ encryptor . chunk _ len _ bytes + NUM * 2 ; public const int buffer _ size = recv _ size + ( int ) max _ chunk _ size + NUM public date _ time last _ activity ; private readonly shadowsocks _ controller controller ; private readonly proxy _ config config ; private readonly socket connection ;
private i _ encryptor encryptor ; private server server ; private async _ session current _ remote _ session ; private bool proxy _ connected ; private bool dest _ connected ; private byte command ; private byte [ ] first _ packet ; private int first _ packet _ length ; private const int cmd _ connect = 0 ; private const int cmd _ bind = 0 ;
private readonly byte [ ] connetion _ recv _ buffer = new byte [ buffer _ size ] ; private readonly byte [ ] remote _ send _ buffer = new byte [ buffer _ size ] ; private readonly byte [ ] connetion _ send _ buffer = new byte [ buffer _ size ] ; private bool connection _ shutdown = false ; private bool remote _ shutdown = false ; private bool closed = false ; private readonly object encryption _ lock = new object ( ) ; private readonly object decryption _ lock = new object ( ) ; private readonly object close _ conn _ lock = new object ( ) ; private date _ time start _ connect _ time ;
private readonly byte [ ] remote _ send _ buffer = new byte [ buffer _ size ] ; private readonly byte [ ] connetion _ send _ buffer = new byte [ buffer _ size ] ; private bool connection _ shutdown = false ; private bool remote _ shutdown = false ; private bool closed = false ; private readonly object encryption _ lock = new object ( ) ; private readonly object decryption _ lock = new object ( ) ; private readonly object close _ conn _ lock = new object ( ) ; private date _ time start _ connect _ time ; private date _ time start _ receiving _ time ;
private readonly byte [ ] connetion _ send _ buffer = new byte [ buffer _ size ] ; private bool connection _ shutdown = false ; private bool remote _ shutdown = false ; private bool closed = false ; private readonly object encryption _ lock = new object ( ) ; private readonly object decryption _ lock = new object ( ) ; private readonly object close _ conn _ lock = new object ( ) ; private date _ time start _ connect _ time ; private date _ time start _ receiving _ time ; private date _ time start _ sending _ time ;
private bool connection _ shutdown = false ; private bool remote _ shutdown = false ; private bool closed = false ; private readonly object encryption _ lock = new object ( ) ; private readonly object decryption _ lock = new object ( ) ; private readonly object close _ conn _ lock = new object ( ) ; private date _ time start _ connect _ time ; private date _ time start _ receiving _ time ; private date _ time start _ sending _ time ; private end _ point dest _ end _ point = null ;
{ controller = controller ; config = config . proxy ; connection = socket ; proxy _ timeout = config . proxy . proxy _ timeout * NUM ; server _ timeout = config . get _ current _ server ( ) . timeout * NUM ; last _ activity = date _ time . now ; }
connection = socket ; proxy _ timeout = config . proxy . proxy _ timeout * NUM ; server _ timeout = config . get _ current _ server ( ) . timeout * NUM ; last _ activity = date _ time . now ; } public void create _ remote ( ) { server server = controller . get _ a _ server ( i _ strategy _ caller _ type . tcp , ( ip _ end _ point ) connection . remote _ end _ point , dest _ end _ point ) ; if ( server = = null | | server . server = = STR )
logger . trace ( $ STR ) ; encryptor . addr _ buf _ length = addr _ buf _ length ; } public void start ( byte [ ] first _ packet , int length ) { first _ packet = first _ packet ; first _ packet _ length = length ; handshake _ receive ( ) ; } private void check _ close ( )
closed = true ; } on _ closed ? . invoke ( this , new ss _ relay _ event _ args ( server ) ) ; try { connection . shutdown ( socket _ shutdown . both ) ;
try { connection . shutdown ( socket _ shutdown . both ) ; connection . close ( ) ; } catch ( exception e ) { logger . log _ useful _ exception ( e ) ; } if ( current _ remote _ session ! = null )
} } private void handshake _ send _ callback ( i _ async _ result ar ) { if ( closed ) { return ; } try
try { connection . end _ send ( ar ) ; connection . begin _ receive ( connetion _ recv _ buffer , 0 , NUM + addr _ atyp _ len + 1 , socket _ flags . none , address _ receive _ callback , null ) ; } catch ( exception e ) { error _ close ( e ) ; }
try { int bytes _ read = connection . end _ receive ( ar ) ; if ( bytes _ read > = NUM ) { command = connetion _ recv _ buffer [ 1 ] ; switch ( command ) { case cmd _ connect : byte [ ] response = { NUM , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 } ;
{ try { connection . end _ send ( ar ) ; read _ address ( start _ connect ) ; } catch ( exception e ) { error _ close ( e ) ;
} } private void read _ address ( action on _ success ) { int atyp = connetion _ recv _ buffer [ NUM ] ; switch ( atyp ) { case atyp _ i _ pv : read _ address ( NUM + addr _ port _ len - 1 , on _ success ) ; break ;
try { int bytes _ read = connection . end _ receive ( ar ) ; object [ ] states = ( object [ ] ) ar . async _ state ; int bytes _ remain = ( int ) states [ 0 ] ; action on _ success = ( action ) states [ 1 ] ; if ( bytes _ read > = bytes _ remain ) { first _ packet _ length = bytes _ read + 2 ; int atyp = connetion _ recv _ buffer [ 0 ] ;
int bytes _ remain = ( int ) states [ 0 ] ; action on _ success = ( action ) states [ 1 ] ; if ( bytes _ read > = bytes _ remain ) { first _ packet _ length = bytes _ read + 2 ; int atyp = connetion _ recv _ buffer [ 0 ] ; string dst _ addr = STR ; int dst _ port = - 1 ; switch ( atyp ) {
if ( bytes _ read > = bytes _ remain ) { first _ packet _ length = bytes _ read + 2 ; int atyp = connetion _ recv _ buffer [ 0 ] ; string dst _ addr = STR ; int dst _ port = - 1 ; switch ( atyp ) { case atyp _ i _ pv : dst _ addr = new ip _ address ( connetion _ recv _ buffer . skip ( 1 ) . take ( NUM ) . to _ array ( ) ) . to _ string ( ) ;
} } private class proxy _ timer : timer { public async _ session session ; public end _ point dest _ end _ point ; public server server ; public proxy _ timer ( int p ) : base ( p ) { }
} else { remote = new direct _ connect ( ) ; } async _ session session = new async _ session ( remote ) ; lock ( close _ conn _ lock ) { if ( closed ) {
lock ( close _ conn _ lock ) { if ( closed ) { remote . close ( ) ; return ; } current _ remote _ session = session ; } proxy _ timer proxy _ timer = new proxy _ timer ( proxy _ timeout ) { auto _ reset = false } ;
} } private void proxy _ connect _ timer _ elapsed ( object sender , elapsed _ event _ args e ) { proxy _ timer timer = ( proxy _ timer ) sender ; timer . elapsed - = proxy _ connect _ timer _ elapsed ; timer . enabled = false ; timer . dispose ( ) ; if ( proxy _ connected | | dest _ connected | | closed ) {
timer . elapsed - = proxy _ connect _ timer _ elapsed ; timer . enabled = false ; timer . dispose ( ) ; if ( proxy _ connected | | dest _ connected | | closed ) { return ; } i _ proxy proxy = timer . session . remote ; logger . info ( $ STR ) ; proxy . close ( ) ;
logger . info ( $ STR ) ; proxy . close ( ) ; close ( ) ; } private void proxy _ connect _ callback ( i _ async _ result ar ) { if ( closed ) { return ; }
proxy _ timer timer = session . state ; end _ point dest _ end _ point = timer . dest _ end _ point ; server server = timer . server ; timer . elapsed - = proxy _ connect _ timer _ elapsed ; timer . enabled = false ; timer . dispose ( ) ; i _ proxy remote = session . remote ; remote . end _ connect _ proxy ( ar ) ; proxy _ connected = true ; if ( ! ( remote is direct _ connect ) )
timer . elapsed - = proxy _ connect _ timer _ elapsed ; timer . enabled = false ; timer . dispose ( ) ; i _ proxy remote = session . remote ; remote . end _ connect _ proxy ( ar ) ; proxy _ connected = true ; if ( ! ( remote is direct _ connect ) ) { logger . debug ( $ STR ) ; }
remote . end _ connect _ proxy ( ar ) ; proxy _ connected = true ; if ( ! ( remote is direct _ connect ) ) { logger . debug ( $ STR ) ; } start _ connect _ time = date _ time . now ; server _ timer connect _ timer = new server _ timer ( server _ timeout ) { auto _ reset = false } ; connect _ timer . elapsed + = dest _ connect _ timer _ elapsed ; connect _ timer . enabled = true ;
} remote . begin _ connect _ dest ( dest _ end _ point , connect _ callback , new async _ session < server _ timer > ( session , connect _ timer ) , auth ) ; } catch ( argument _ exception ) { } catch ( exception e ) { error _ close ( e ) ;
} } private void dest _ connect _ timer _ elapsed ( object sender , elapsed _ event _ args e ) { server _ timer timer = ( server _ timer ) sender ; timer . elapsed - = dest _ connect _ timer _ elapsed ; timer . enabled = false ; timer . dispose ( ) ; if ( dest _ connected | | closed ) {
timer . elapsed - = dest _ connect _ timer _ elapsed ; timer . enabled = false ; timer . dispose ( ) ; if ( dest _ connected | | closed ) { return ; } async _ session session = timer . session ; server server = timer . server ; on _ failed ? . invoke ( this , new ss _ relay _ event _ args ( server ) ) ;
server server = timer . server ; on _ failed ? . invoke ( this , new ss _ relay _ event _ args ( server ) ) ; logger . info ( $ STR ) ; session . remote . close ( ) ; close ( ) ; } private void connect _ callback ( i _ async _ result ar ) {
logger . info ( $ STR ) ; session . remote . close ( ) ; close ( ) ; } private void connect _ callback ( i _ async _ result ar ) { if ( closed ) { return ; }
server _ timer timer = session . state ; server = timer . server ; timer . elapsed - = dest _ connect _ timer _ elapsed ; timer . enabled = false ; timer . dispose ( ) ; i _ proxy remote = session . remote ; remote . end _ connect _ dest ( ar ) ; dest _ connected = true ; logger . debug ( $ STR ) ; time _ span latency = date _ time . now - start _ connect _ time ;
remote . end _ connect _ dest ( ar ) ; dest _ connected = true ; logger . debug ( $ STR ) ; time _ span latency = date _ time . now - start _ connect _ time ; on _ connected ? . invoke ( this , new sstcp _ connected _ event _ args ( server , latency ) ) ; start _ pipe ( session ) ;
start _ pipe ( session ) ; } catch ( argument _ exception ) { } catch ( exception e ) { if ( server ! = null ) { on _ failed ? . invoke ( this , new ss _ relay _ event _ args ( server ) ) ;
} } private void try _ read _ available _ data ( ) { int available = math . min ( connection . available , recv _ size - first _ packet _ length ) ; if ( available > 0 ) { int size = connection . receive ( connetion _ recv _ buffer , first _ packet _ length , available , socket _ flags . none ) ; first _ packet _ length + = size ;
socket _ flags . none ) ; first _ packet _ length + = size ; } } private void start _ pipe ( async _ session session ) { if ( closed ) { return ; }
try { start _ receiving _ time = date _ time . now ; session . remote . begin _ receive ( remote _ recv _ buffer , 0 , recv _ size , socket _ flags . none , pipe _ remote _ receive _ callback , session ) ; try _ read _ available _ data ( ) ; logger . trace ( $ STR ) ; send _ to _ server ( first _ packet _ length , session ) ; } catch ( exception e )
} } private void pipe _ remote _ receive _ callback ( i _ async _ result ar ) { if ( closed ) { return ; } try {
int bytes _ read = session . remote . end _ receive ( ar ) ; total _ read + = bytes _ read ; on _ inbound ? . invoke ( this , new ss _ transmit _ event _ args ( server , bytes _ read ) ) ; if ( bytes _ read > 0 ) { last _ activity = date _ time . now ; int bytes _ to _ send = - 1 ; lock ( decryption _ lock ) { try
if ( bytes _ read > 0 ) { last _ activity = date _ time . now ; int bytes _ to _ send = - 1 ; lock ( decryption _ lock ) { try { encryptor . decrypt ( remote _ recv _ buffer , bytes _ read , remote _ send _ buffer , out bytes _ to _ send ) ; }
} } private void pipe _ connection _ receive _ callback ( i _ async _ result ar ) { if ( closed ) { return ; } try
try { int bytes _ read = connection . end _ receive ( ar ) ; async _ session session = ( async _ session ) ar . async _ state ; i _ proxy remote = session . remote ; if ( bytes _ read > 0 ) { send _ to _ server ( bytes _ read , session ) ; } else
if ( bytes _ read > 0 ) { send _ to _ server ( bytes _ read , session ) ; } else { remote . shutdown ( socket _ shutdown . send ) ; remote _ shutdown = true ; check _ close ( ) ; }
start _ sending _ time = date _ time . now ; session . remote . begin _ send ( connetion _ send _ buffer , 0 , bytes _ to _ send , socket _ flags . none , pipe _ remote _ send _ callback , new object [ ] { session , bytes _ to _ send } ) ; } private void pipe _ remote _ send _ callback ( i _ async _ result ar ) { if ( closed ) {
} private void pipe _ remote _ send _ callback ( i _ async _ result ar ) { if ( closed ) { return ; } try { object [ ] container = ( object [ ] ) ar . async _ state ;
int bytes _ sent = session . remote . end _ send ( ar ) ; if ( bytes _ sent > 0 ) { last _ activity = date _ time . now ; } int bytes _ remaining = bytes _ should _ send - bytes _ sent ; if ( bytes _ remaining > 0 ) { logger . info ( STR ) ; buffer . block _ copy ( connetion _ send _ buffer , bytes _ sent , connetion _ send _ buffer , 0 , bytes _ remaining ) ;
} } private void pipe _ connection _ send _ callback ( i _ async _ result ar ) { try { object [ ] container = ( object [ ] ) ar . async _ state ; async _ session session = ( async _ session ) container [ 0 ] ; int bytes _ should _ send = ( int ) container [ 1 ] ; int bytes _ sent = connection . end _ send ( ar ) ;
if ( bytes _ remaining > 0 ) { logger . info ( STR ) ; buffer . block _ copy ( remote _ send _ buffer , bytes _ sent , remote _ send _ buffer , 0 , bytes _ remaining ) ; connection . begin _ send ( remote _ send _ buffer , 0 , bytes _ remaining , socket _ flags . none , pipe _ connection _ send _ callback , new object [ ] { session , bytes _ remaining } ) ; return ; } session . remote . begin _ receive ( remote _ recv _ buffer , 0 , recv _ size , socket _ flags . none , pipe _ remote _ receive _ callback , session ) ;
STR , STR , STR , STR , STR , STR } ) ;

private void run _ single _ polar _ ssl _ encryption _ thread ( ) { try { for ( int i = 0 ; i < NUM ; i + + ) { i _ encryptor encryptor ; i _ encryptor decryptor ; encryptor = new polar _ ssl _ encryptor ( STR , STR ) ; decryptor = new polar _ ssl _ encryptor ( STR , STR ) ;
} catch { encryption _ failed = true ; throw ; } } test _ method public void test _ sodium _ encryption ( ) {
this . my _ cancel _ button = new system . windows . forms . button ( ) ; this . ok _ button = new system . windows . forms . button ( ) ; this . use _ proxy _ check _ box = new system . windows . forms . check _ box ( ) ; this . proxy _ addr _ label = new system . windows . forms . label ( ) ; this . proxy _ server _ text _ box = new system . windows . forms . text _ box ( ) ; this . proxy _ port _ label = new system . windows . forms . label ( ) ; this . proxy _ port _ text _ box = new system . windows . forms . text _ box ( ) ; this . proxy _ type _ label = new system . windows . forms . label ( ) ;
this . proxy _ addr _ label = new system . windows . forms . label ( ) ; this . proxy _ server _ text _ box = new system . windows . forms . text _ box ( ) ; this . proxy _ port _ label = new system . windows . forms . label ( ) ; this . proxy _ port _ text _ box = new system . windows . forms . text _ box ( ) ; this . proxy _ type _ label = new system . windows . forms . label ( ) ; this . proxy _ type _ combo _ box = new system . windows . forms . combo _ box ( ) ; this . proxy _ timeout _ text _ box = new system . windows . forms . text _ box ( ) ; this . proxy _ timeout _ label = new system . windows . forms . label ( ) ; this . table _ layout _ panel = new system . windows . forms . table _ layout _ panel ( ) ;
this . proxy _ type _ label = new system . windows . forms . label ( ) ; this . proxy _ type _ combo _ box = new system . windows . forms . combo _ box ( ) ; this . proxy _ timeout _ text _ box = new system . windows . forms . text _ box ( ) ; this . proxy _ timeout _ label = new system . windows . forms . label ( ) ; this . table _ layout _ panel = new system . windows . forms . table _ layout _ panel ( ) ; this . proxy _ notification _ label = new system . windows . forms . label ( ) ; this . flow _ layout _ panel = new system . windows . forms . flow _ layout _ panel ( ) ; this . table _ layout _ panel . suspend _ layout ( ) ; this . flow _ layout _ panel . suspend _ layout ( ) ;
this . suspend _ layout ( ) ; this . my _ cancel _ button . dialog _ result = system . windows . forms . dialog _ result . cancel ;
this . my _ cancel _ button . location = new system . drawing . point ( NUM , NUM ) ; this . my _ cancel _ button . margin = new system . windows . forms . padding ( NUM , NUM , 0 , 0 ) ; this . my _ cancel _ button . name = STR ; this . my _ cancel _ button . size = new system . drawing . size ( NUM , NUM ) ; this . my _ cancel _ button . tab _ index = NUM ; this . my _ cancel _ button . text = STR ; this . my _ cancel _ button . use _ visual _ style _ back _ color = true ; this . my _ cancel _ button . click + = new system . event _ handler ( this . cancel _ button _ click ) ; this . ok _ button . dialog _ result = system . windows . forms . dialog _ result . ok ;
this . ok _ button . location = new system . drawing . point ( NUM , NUM ) ; this . ok _ button . margin = new system . windows . forms . padding ( NUM , NUM , NUM , 0 ) ; this . ok _ button . name = STR ; this . ok _ button . size = new system . drawing . size ( NUM , NUM ) ; this . ok _ button . tab _ index = NUM ; this . ok _ button . text = STR ; this . ok _ button . use _ visual _ style _ back _ color = true ; this . ok _ button . click + = new system . event _ handler ( this . ok _ button _ click ) ; this . use _ proxy _ check _ box . auto _ size = true ; this . table _ layout _ panel . set _ column _ span ( this . use _ proxy _ check _ box , 2 ) ;
this . resume _ layout ( false ) ; } private system . windows . forms . check _ box use _ proxy _ check _ box ; private system . windows . forms . label proxy _ addr _ label ; private system . windows . forms . text _ box proxy _ server _ text _ box ; private system . windows . forms . label proxy _ port _ label ; private system . windows . forms . text _ box proxy _ port _ text _ box ;
} private system . windows . forms . check _ box use _ proxy _ check _ box ; private system . windows . forms . label proxy _ addr _ label ; private system . windows . forms . text _ box proxy _ server _ text _ box ; private system . windows . forms . label proxy _ port _ label ; private system . windows . forms . text _ box proxy _ port _ text _ box ; private system . windows . forms . button my _ cancel _ button ;
private system . windows . forms . check _ box use _ proxy _ check _ box ; private system . windows . forms . label proxy _ addr _ label ; private system . windows . forms . text _ box proxy _ server _ text _ box ; private system . windows . forms . label proxy _ port _ label ; private system . windows . forms . text _ box proxy _ port _ text _ box ; private system . windows . forms . button my _ cancel _ button ; private system . windows . forms . button ok _ button ;
private system . windows . forms . label proxy _ addr _ label ; private system . windows . forms . text _ box proxy _ server _ text _ box ; private system . windows . forms . label proxy _ port _ label ; private system . windows . forms . text _ box proxy _ port _ text _ box ; private system . windows . forms . button my _ cancel _ button ; private system . windows . forms . button ok _ button ; private system . windows . forms . label proxy _ type _ label ; private system . windows . forms . combo _ box proxy _ type _ combo _ box ;
private system . windows . forms . button my _ cancel _ button ; private system . windows . forms . button ok _ button ; private system . windows . forms . label proxy _ type _ label ; private system . windows . forms . combo _ box proxy _ type _ combo _ box ; private system . windows . forms . text _ box proxy _ timeout _ text _ box ; private system . windows . forms . label proxy _ timeout _ label ; private system . windows . forms . table _ layout _ panel table _ layout _ panel ; private system . windows . forms . label proxy _ notification _ label ; private system . windows . forms . flow _ layout _ panel flow _ layout _ panel ;
private system . windows . forms . label proxy _ type _ label ; private system . windows . forms . combo _ box proxy _ type _ combo _ box ; private system . windows . forms . text _ box proxy _ timeout _ text _ box ; private system . windows . forms . label proxy _ timeout _ label ; private system . windows . forms . table _ layout _ panel table _ layout _ panel ; private system . windows . forms . label proxy _ notification _ label ; private system . windows . forms . flow _ layout _ panel flow _ layout _ panel ; } }
this . about _ item = new system . windows . forms . menu _ item ( ) ; this . menu _ item = new system . windows . forms . menu _ item ( ) ; this . quit _ item = new system . windows . forms . menu _ item ( ) ; this . panel = new system . windows . forms . panel ( ) ; this . delete _ button = new system . windows . forms . button ( ) ; this . add _ button = new system . windows . forms . button ( ) ; this . server _ group _ box = new system . windows . forms . group _ box ( ) ; this . servers _ list _ box = new system . windows . forms . list _ box ( ) ; this . qr _ code _ item = new system . windows . forms . menu _ item ( ) ;
this . table _ layout _ panel . suspend _ layout ( ) ; this . panel . suspend _ layout ( ) ; this . panel . suspend _ layout ( ) ; this . server _ group _ box . suspend _ layout ( ) ; this . suspend _ layout ( ) ; this . table _ layout _ panel . auto _ size = true ; this . table _ layout _ panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . table _ layout _ panel . column _ count = 2 ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ;
this . suspend _ layout ( ) ; this . table _ layout _ panel . auto _ size = true ; this . table _ layout _ panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . table _ layout _ panel . column _ count = 2 ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . controls . add ( this . remarks _ text _ box , 1 , NUM ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , 0 ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , 1 ) ;
this . client _ size = new system . drawing . size ( NUM , NUM ) ; this . controls . add ( this . servers _ list _ box ) ; this . controls . add ( this . server _ group _ box ) ; this . controls . add ( this . panel ) ; this . controls . add ( this . panel ) ; this . controls . add ( this . panel ) ; this . form _ border _ style = system . windows . forms . form _ border _ style . fixed _ single ; this . icon = ( ( system . drawing . icon ) ( resources . get _ object ( STR ) ) ) ; this . maximize _ box = false ;
this . controls . add ( this . servers _ list _ box ) ; this . controls . add ( this . server _ group _ box ) ; this . controls . add ( this . panel ) ; this . controls . add ( this . panel ) ; this . controls . add ( this . panel ) ; this . form _ border _ style = system . windows . forms . form _ border _ style . fixed _ single ; this . icon = ( ( system . drawing . icon ) ( resources . get _ object ( STR ) ) ) ; this . maximize _ box = false ; this . name = STR ; this . start _ position = system . windows . forms . form _ start _ position . center _ screen ;
this . form _ closed + = new system . windows . forms . form _ closed _ event _ handler ( this . config _ form _ form _ closed ) ; this . load + = new system . event _ handler ( this . config _ form _ load ) ; this . shown + = new system . event _ handler ( this . config _ form _ shown ) ; this . table _ layout _ panel . resume _ layout ( false ) ; this . table _ layout _ panel . perform _ layout ( ) ; this . panel . resume _ layout ( false ) ; this . panel . resume _ layout ( false ) ; this . server _ group _ box . resume _ layout ( false ) ; this . server _ group _ box . perform _ layout ( ) ;
this . resume _ layout ( false ) ; this . perform _ layout ( ) ; } private system . windows . forms . table _ layout _ panel table _ layout _ panel ; private system . windows . forms . label label ; private system . windows . forms . label label ; private system . windows . forms . label label ; private system . windows . forms . label label ; private system . windows . forms . text _ box ip _ text _ box ; private system . windows . forms . text _ box server _ port _ text _ box ;
} else { is _ first _ run = true ; } } private void servers _ list _ box _ selected _ index _ changed ( object sender , event _ args e ) {
} } private void servers _ list _ box _ selected _ index _ changed ( object sender , event _ args e ) { if ( old _ selected _ index = = servers _ list _ box . selected _ index ) { return ; } if ( ! save _ old _ selected _ server ( ) ) {
} switch ( host _ type ) { case uri _ host _ name _ type . i _ pv : server _ str = $ STR ; break ; default : server _ str = $ STR ; break ;
} return remarks . is _ null _ or _ empty ( ) ? server _ str : $ STR ; } public server ( ) { server = STR ; server _ port = NUM ;
} public server ( ) { server = STR ; server _ port = NUM ; method = STR ; password = STR ; remarks = STR ; auth = false ; }
this . controls . add ( this . qr _ code _ web _ browser ) ; this . form _ border _ style = system . windows . forms . form _ border _ style . fixed _ single ; this . icon = ( ( system . drawing . icon ) ( resources . get _ object ( STR ) ) ) ; this . maximize _ box = false ; this . name = STR ; this . start _ position = system . windows . forms . form _ start _ position . center _ screen ; this . text = STR ; this . load + = new system . event _ handler ( this . qr _ code _ form _ load ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . picture _ box ) ) . end _ init ( ) ; this . resume _ layout ( false ) ;
long max _ speed = 0 ; long last _ inbound , last _ outbound ; lock ( this ) { if ( traffic . count = = 0 ) return ; foreach ( var traffic _ per _ second in traffic ) { inbound _ points . add ( traffic _ per _ second . item ) ; outbound _ points . add ( traffic _ per _ second . item ) ;
} bandwidth _ scale = utils . get _ bandwidth _ scale ( max _ speed ) ; inbound _ points = inbound _ points . select ( p = > p / bandwidth _ scale . item ) . to _ list ( ) ; outbound _ points = outbound _ points . select ( p = > p / bandwidth _ scale . item ) . to _ list ( ) ; if ( traffic _ chart . is _ handle _ created ) { traffic _ chart . series [ STR ] . points . data _ bind _ y ( inbound _ points ) ; traffic _ chart . series [ STR ] . points . data _ bind _ y ( outbound _ points ) ; traffic _ chart . chart _ areas [ 0 ] . axis _ y . label _ style . format = STR + bandwidth _ scale . item ; traffic _ chart . chart _ areas [ 0 ] . axis _ y . maximum = bandwidth _ scale . item ;
} } private void update _ texts ( ) { file _ menu _ item . text = n . get _ string ( STR ) ; open _ location _ menu _ item . text = n . get _ string ( STR ) ; exit _ menu _ item . text = n . get _ string ( STR ) ; clean _ logs _ button . text = n . get _ string ( STR ) ; change _ font _ button . text = n . get _ string ( STR ) ; wrap _ text _ check _ box . text = n . get _ string ( STR ) ;
this . plugin _ text _ box . max _ length = NUM ; this . plugin _ text _ box . name = STR ; this . plugin _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . plugin _ text _ box . tab _ index = NUM ; this . plugin _ text _ box . word _ wrap = false ; this . remarks _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . remarks _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . remarks _ text _ box . margin = new system . windows . forms . padding ( NUM ) ; this . remarks _ text _ box . max _ length = NUM ; this . remarks _ text _ box . name = STR ;
this . remarks _ text _ box . max _ length = NUM ; this . remarks _ text _ box . name = STR ; this . remarks _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . remarks _ text _ box . tab _ index = NUM ; this . remarks _ text _ box . word _ wrap = false ; this . ip _ label . anchor = system . windows . forms . anchor _ styles . right ; this . ip _ label . auto _ size = true ; this . ip _ label . location = new system . drawing . point ( NUM , NUM ) ; this . ip _ label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ; this . ip _ label . name = STR ;
this . ip _ text _ box . max _ length = NUM ; this . ip _ text _ box . name = STR ; this . ip _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . ip _ text _ box . tab _ index = 0 ; this . ip _ text _ box . word _ wrap = false ; this . server _ port _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . server _ port _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . server _ port _ text _ box . margin = new system . windows . forms . padding ( NUM ) ; this . server _ port _ text _ box . max _ length = NUM ; this . server _ port _ text _ box . name = STR ;
this . server _ port _ text _ box . max _ length = NUM ; this . server _ port _ text _ box . name = STR ; this . server _ port _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . server _ port _ text _ box . tab _ index = 1 ; this . server _ port _ text _ box . word _ wrap = false ; this . password _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . password _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . password _ text _ box . margin = new system . windows . forms . padding ( NUM ) ; this . password _ text _ box . max _ length = NUM ; this . password _ text _ box . name = STR ;
this . password _ text _ box . max _ length = NUM ; this . password _ text _ box . name = STR ; this . password _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . password _ text _ box . tab _ index = 2 ; this . password _ text _ box . use _ system _ password _ char = true ; this . password _ text _ box . word _ wrap = false ; this . encryption _ label . anchor = system . windows . forms . anchor _ styles . right ; this . encryption _ label . auto _ size = true ; this . encryption _ label . location = new system . drawing . point ( NUM , NUM ) ; this . encryption _ label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ;
this . plugin _ options _ text _ box . max _ length = NUM ; this . plugin _ options _ text _ box . name = STR ; this . plugin _ options _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . plugin _ options _ text _ box . tab _ index = NUM ; this . plugin _ options _ text _ box . word _ wrap = false ; this . show _ passwd _ check _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( ( system . windows . forms . anchor _ styles . top | system . windows . forms . anchor _ styles . bottom ) | system . windows . forms . anchor _ styles . left ) ) ) ; this . show _ passwd _ check _ box . auto _ size = true ; this . show _ passwd _ check _ box . location = new system . drawing . point ( NUM , NUM ) ; this . show _ passwd _ check _ box . margin = new system . windows . forms . padding ( NUM ) ;
this . show _ passwd _ check _ box . name = STR ; this . show _ passwd _ check _ box . size = new system . drawing . size ( NUM , NUM ) ; this . show _ passwd _ check _ box . tab _ index = NUM ; this . show _ passwd _ check _ box . text = STR ; this . show _ passwd _ check _ box . text _ align = system . drawing . content _ alignment . middle _ center ; this . show _ passwd _ check _ box . use _ visual _ style _ back _ color = true ; this . show _ passwd _ check _ box . checked _ changed + = new system . event _ handler ( this . show _ passwd _ check _ box _ checked _ changed ) ; this . plugin _ arguments _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . plugin _ arguments _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . plugin _ arguments _ text _ box . margin = new system . windows . forms . padding ( NUM ) ;
this . plugin _ arguments _ text _ box . max _ length = NUM ; this . plugin _ arguments _ text _ box . name = STR ; this . plugin _ arguments _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . plugin _ arguments _ text _ box . tab _ index = NUM ; this . plugin _ arguments _ text _ box . word _ wrap = false ; this . plugin _ arguments _ label . anchor = system . windows . forms . anchor _ styles . right ; this . plugin _ arguments _ label . auto _ size = true ; this . plugin _ arguments _ label . location = new system . drawing . point ( NUM , NUM ) ; this . plugin _ arguments _ label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ; this . plugin _ arguments _ label . name = STR ;
this . table _ layout _ panel . row _ count = 2 ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ; this . table _ layout _ panel . tab _ index = NUM ; this . proxy _ port _ text _ box . anchor = system . windows . forms . anchor _ styles . left ; this . proxy _ port _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . proxy _ port _ text _ box . margin = new system . windows . forms . padding ( NUM ) ; this . proxy _ port _ text _ box . max _ length = NUM ; this . proxy _ port _ text _ box . name = STR ;
this . proxy _ port _ text _ box . max _ length = NUM ; this . proxy _ port _ text _ box . name = STR ; this . proxy _ port _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . proxy _ port _ text _ box . tab _ index = NUM ; this . proxy _ port _ text _ box . word _ wrap = false ; this . proxy _ port _ label . anchor = system . windows . forms . anchor _ styles . right ; this . proxy _ port _ label . auto _ size = true ; this . proxy _ port _ label . location = new system . drawing . point ( NUM , NUM ) ; this . proxy _ port _ label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ; this . proxy _ port _ label . name = STR ;
private const string statistics _ files _ name = STR ; public static string availability _ statistics _ file ; static availability _ statistics ( ) { availability _ statistics _ file = utils . get _ temp _ path ( statistics _ files _ name ) ; } private int repeat = > config . repeat _ times _ num ; public const int timeout _ milliseconds = NUM ; private list < int > latency _ records ;
} private int repeat = > config . repeat _ times _ num ; public const int timeout _ milliseconds = NUM ; private list < int > latency _ records ; private long last _ inbound _ counter ; private list < int > inbound _ speed _ records ; private long last _ outbound _ counter ; private list < int > outbound _ speed _ records ; private readonly time _ span delay _ before _ start = time _ span . from _ seconds ( 1 ) ; private readonly time _ span retry _ interval = time _ span . from _ minutes ( 2 ) ;
this . all _ mode . location = new system . drawing . point ( NUM , NUM ) ; this . all _ mode . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . all _ mode . name = STR ; this . all _ mode . size = new system . drawing . size ( NUM , NUM ) ; this . all _ mode . tab _ index = 1 ; this . all _ mode . text = STR ; this . all _ mode . use _ visual _ style _ back _ color = true ; this . all _ mode . checked _ changed + = new system . event _ handler ( this . all _ mode _ checked _ changed ) ; this . day _ mode . auto _ size = true ;
this . all _ mode . text = STR ; this . all _ mode . use _ visual _ style _ back _ color = true ; this . all _ mode . checked _ changed + = new system . event _ handler ( this . all _ mode _ checked _ changed ) ; this . day _ mode . auto _ size = true ; this . day _ mode . checked = true ; this . day _ mode . location = new system . drawing . point ( NUM , NUM ) ; this . day _ mode . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . day _ mode . name = STR ; this . day _ mode . size = new system . drawing . size ( NUM , NUM ) ; this . day _ mode . tab _ index = 0 ;
this . split _ container . tab _ index = NUM ; this . label . auto _ size = true ; this . label . location = new system . drawing . point ( NUM , NUM ) ; this . label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ; this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ; this . label . tab _ index = 0 ; this . label . text = STR ; this . calculatin _ tip . set _ tool _ tip ( this . label , STR ) ; this . calculation _ container . auto _ scroll = true ;
this . calculation _ container . auto _ scroll = true ; this . calculation _ container . dock = system . windows . forms . dock _ style . fill ; this . calculation _ container . location = new system . drawing . point ( 0 , 0 ) ; this . calculation _ container . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . calculation _ container . name = STR ; this . calculation _ container . size = new system . drawing . size ( NUM , NUM ) ; this . calculation _ container . tab _ index = 1 ; this . server _ selector . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . bottom | system . windows . forms . anchor _ styles . right ) ) ) ; this . server _ selector . formatting _ enabled = true ; this . server _ selector . location = new system . drawing . point ( NUM , NUM ) ;
{ controller = controller ; config = conf ; handlers = new hash _ set < tcp _ handler > ( ) ; last _ sweep _ time = date _ time . now ; } public bool handle ( byte [ ] first _ packet , int length , socket socket , object state ) { if ( socket . protocol _ type ! = protocol _ type . tcp | | ( length < 2 | | first _ packet [ 0 ] ! = NUM ) )
handler . connection = socket ; handler . controller = controller ; handler . tcprelay = this ; handler . start ( first _ packet , length ) ; i _ list < tcp _ handler > handlers _ to _ close = new list < tcp _ handler > ( ) ; lock ( handlers ) { handlers . add ( handler ) ; date _ time now = date _ time . now ; if ( now - last _ sweep _ time > time _ span . from _ seconds ( 1 ) )
{ tcprelay = tcprelay ; config = config ; } public void create _ remote ( ) { server server = controller . get _ a _ server ( i _ strategy _ caller _ type . tcp , ( ip _ end _ point ) connection . remote _ end _ point ) ; if ( server = = null | | server . server = = STR ) throw new argument _ exception ( STR ) ; encryptor = encryptor _ factory . get _ encryptor ( server . method , server . password , server . auth , false ) ;
logging . info ( $ STR ) ; } break ; case NUM : int len = connetion _ recv _ buffer [ 1 ] ; dst _ addr = system . text . encoding . ut . get _ string ( connetion _ recv _ buffer , 2 , len ) ; dst _ port = ( connetion _ recv _ buffer [ len + 2 ] < < NUM ) + connetion _ recv _ buffer [ len + NUM ] ; if ( config . is _ verbose _ logging ) { logging . info ( $ STR ) ; }
logging . info ( $ STR ) ; } break ; case NUM : dst _ addr = new ip _ address ( connetion _ recv _ buffer . skip ( 1 ) . take ( NUM ) . to _ array ( ) ) . to _ string ( ) ; dst _ port = ( connetion _ recv _ buffer [ NUM ] < < NUM ) + connetion _ recv _ buffer [ NUM ] ; if ( config . is _ verbose _ logging ) { logging . info ( $ STR ) ; } break ;
logging . info ( $ STR ) ; } break ; } int bytes _ to _ send ; lock ( encryption _ lock ) { if ( closed ) return ; encryptor . encrypt ( connetion _ recv _ buffer , bytes _ read , connetion _ send _ buffer , out bytes _ to _ send ) ; }
logging . log _ useful _ exception ( e . get _ exception ( ) ) ; } void controller _ update _ pac _ from _ gfw _ list _ completed ( object sender , event _ args e ) { show _ balloon _ tip ( n . get _ string ( STR ) , n . get _ string ( STR ) , tool _ tip _ icon . info , NUM ) ;
} void update _ checker _ new _ version _ found ( object sender , event _ args e ) { show _ balloon _ tip ( string . format ( n . get _ string ( STR ) , update _ checker . latest _ version _ number ) , n . get _ string ( STR ) , tool _ tip _ icon . info , NUM ) ; notify _ icon . balloon _ tip _ clicked + = notify _ icon _ balloon _ tip _ clicked ; is _ first _ run = false ;
notify _ icon . balloon _ tip _ clicked + = notify _ icon _ balloon _ tip _ clicked ; is _ first _ run = false ; } void notify _ icon _ balloon _ tip _ clicked ( object sender , event _ args e ) { system . diagnostics . process . start ( update _ checker . latest _ version _ url ) ; notify _ icon . balloon _ tip _ clicked - = notify _ icon _ balloon _ tip _ clicked ; } private void load _ current _ configuration ( )
is _ first _ run = false ; } void notify _ icon _ balloon _ tip _ clicked ( object sender , event _ args e ) { system . diagnostics . process . start ( update _ checker . latest _ version _ url ) ; notify _ icon . balloon _ tip _ clicked - = notify _ icon _ balloon _ tip _ clicked ; } private void load _ current _ configuration ( ) { configuration config = controller . get _ configuration ( ) ;
{ remote = new socks _ proxy ( ) ; proxy _ ep = socket _ util . get _ end _ point ( config . proxy . proxy _ server , config . proxy . proxy _ port ) ; } else { remote = new direct _ connect ( ) ; proxy _ ep = null ; } var session = new async _ session ( remote ) ;
} else { remote = new direct _ connect ( ) ; proxy _ ep = null ; } var session = new async _ session ( remote ) ; current _ remote _ session = session ; proxy _ timer proxy _ timer = new proxy _ timer ( NUM ) ; proxy _ timer . auto _ reset = false ;
save _ config ( config ) ; } public void enable _ proxy ( string proxy , int port ) { config . proxy . use _ proxy = true ; config . proxy . proxy _ server = proxy ; config . proxy . proxy _ port = port ; save _ config ( config ) ; } public void toggle _ verbose _ logging ( bool enabled )
save _ config ( config ) ; } public void toggle _ verbose _ logging ( bool enabled ) { config . is _ verbose _ logging = enabled ; save _ config ( config ) ; if ( verbose _ logging _ status _ changed ! = null ) { verbose _ logging _ status _ changed ( this , new event _ args ( ) ) ; } }
details _ parser = new regex ( STR + STR , regex _ options . ignore _ case ) ; private const int default _ server _ timeout _ sec = NUM ; public const int max _ server _ timeout _ sec = NUM ; public string server ; public int server _ port ; public string password ; public string method ; public string remarks ; public bool auth ;
private const int default _ server _ timeout _ sec = NUM ; public const int max _ server _ timeout _ sec = NUM ; public string server ; public int server _ port ; public string password ; public string method ; public string remarks ; public bool auth ; public int timeout ; public override int get _ hash _ code ( )
} catch ( format _ exception ) { message _ box . show ( n . get _ string ( STR ) ) ; proxy _ port _ text _ box . clear ( ) ; return ; } try { timeout = int . parse ( proxy _ timeout _ text _ box . text ) ;
controller . save _ proxy _ config ( modified _ configuration ) ; this . close ( ) ; } private void cancel _ button _ click ( object sender , event _ args e ) { this . close ( ) ; } private void proxy _ form _ form _ closed ( object sender , form _ closed _ event _ args e ) { controller . config _ changed - = controller _ config _ changed ;
int local _ port = int . parse ( proxy _ port _ text _ box . text ) ; configuration . check _ server ( server ) ; configuration . check _ local _ port ( local _ port ) ; modified _ configuration . configs [ last _ selected _ index ] = server ; modified _ configuration . local _ port = local _ port ; return true ;
} catch ( exception ex ) { message _ box . show ( ex . message ) ; } return false ; } private void load _ selected _ server ( ) { if ( servers _ list _ box . selected _ index > = 0 & & servers _ list _ box . selected _ index < modified _ configuration . configs . count )
this . picture _ box = new system . windows . forms . picture _ box ( ) ; this . panel = new system . windows . forms . panel ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . picture _ box ) ) . begin _ init ( ) ; this . panel . suspend _ layout ( ) ; this . suspend _ layout ( ) ;
this . picture _ box . dock = system . windows . forms . dock _ style . fill ; this . picture _ box . location = new system . drawing . point ( NUM , NUM ) ; this . picture _ box . margin = new system . windows . forms . padding ( 0 ) ; this . picture _ box . name = STR ; this . picture _ box . size = new system . drawing . size ( NUM , NUM ) ; this . picture _ box . size _ mode = system . windows . forms . picture _ box _ size _ mode . stretch _ image ; this . picture _ box . tab _ index = 1 ; this . picture _ box . tab _ stop = false ; this . panel . controls . add ( this . picture _ box ) ;
this . picture _ box . name = STR ; this . picture _ box . size = new system . drawing . size ( NUM , NUM ) ; this . picture _ box . size _ mode = system . windows . forms . picture _ box _ size _ mode . stretch _ image ; this . picture _ box . tab _ index = 1 ; this . picture _ box . tab _ stop = false ; this . panel . controls . add ( this . picture _ box ) ; this . panel . dock = system . windows . forms . dock _ style . fill ; this . panel . location = new system . drawing . point ( 0 , 0 ) ; this . panel . margin = new system . windows . forms . padding ( 0 ) ; this . panel . name = STR ;
this . picture _ box . tab _ index = 1 ; this . picture _ box . tab _ stop = false ; this . panel . controls . add ( this . picture _ box ) ; this . panel . dock = system . windows . forms . dock _ style . fill ; this . panel . location = new system . drawing . point ( 0 , 0 ) ; this . panel . margin = new system . windows . forms . padding ( 0 ) ; this . panel . name = STR ; this . panel . padding = new system . windows . forms . padding ( NUM ) ; this . panel . size = new system . drawing . size ( NUM , NUM ) ; this . panel . tab _ index = 2 ;
this . form _ border _ style = system . windows . forms . form _ border _ style . fixed _ single ; this . maximize _ box = false ; this . minimize _ box = false ; this . name = STR ; this . start _ position = system . windows . forms . form _ start _ position . center _ screen ; this . text = STR ; this . load + = new system . event _ handler ( this . qr _ code _ form _ load ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . picture _ box ) ) . end _ init ( ) ; this . panel . resume _ layout ( false ) ; this . resume _ layout ( false ) ;
private system . windows . forms . picture _ box picture _ box ; private system . windows . forms . panel panel ; } }
{ controller = controller ; config = config ; connection = socket ; proxy _ timeout = config . proxy . proxy _ timeout * NUM ; server _ timeout = config . get _ current _ server ( ) . timeout * NUM ; last _ activity = date _ time . now ; } public void create _ remote ( )
connection = socket ; proxy _ timeout = config . proxy . proxy _ timeout * NUM ; server _ timeout = config . get _ current _ server ( ) . timeout * NUM ; last _ activity = date _ time . now ; } public void create _ remote ( ) { server server = controller . get _ a _ server ( i _ strategy _ caller _ type . tcp , ( ip _ end _ point ) connection . remote _ end _ point , dest _ end _ point ) ; if ( server = = null | | server . server = = STR )
{ var dr = message _ box . show ( n . get _ string ( STR , ss _ url ) , n . get _ string ( STR ) , message _ box _ buttons . yes _ no ) ; if ( dr = = dialog _ result . yes ) { if ( add _ server _ by _ ssurl ( ss _ url ) ) { message _ box . show ( n . get _ string ( STR , ss _ url ) ) ; return true ; } else
} public bool add _ server _ by _ ssurl ( string ss _ url ) { try { if ( ss _ url . is _ null _ or _ empty ( ) | | ss _ url . is _ white _ space ( ) ) return false ; var servers = server . get _ servers ( ss _ url ) ; if ( servers = = null | | servers . count = = 0 ) return false ;
} else { gfw _ list _ updater . merge _ and _ write _ pac _ file ( file _ manager . non _ exclusive _ read _ all _ text ( utils . get _ temp _ path ( STR ) ) ) ; }
} public void copy _ pac _ url ( ) { clipboard . set _ data _ object ( pac _ server . pac _ url ) ; } private void start _ releasing _ memory ( ) { ram _ thread = new thread ( new thread _ start ( release _ memory ) ) ; ram _ thread . is _ background = true ; ram _ thread . start ( ) ;
} catch ( exception ex ) { error ? . invoke ( this , new error _ event _ args ( ex ) ) ; } } public static bool merge _ and _ write _ pac _ file ( string gfw _ list _ result ) { list < string > lines = new list < string > ( ) ; if ( file . exists ( pac _ server . user _ rule _ file ) )
private int total _ read = 0 ; private int total _ write = 0 ; private byte [ ] remote _ recv _ buffer = new byte [ buffer _ size ] ; private byte [ ] remote _ send _ buffer = new byte [ buffer _ size ] ; private byte [ ] connetion _ recv _ buffer = new byte [ buffer _ size ] ; private byte [ ] connetion _ send _ buffer = new byte [ buffer _ size ] ; private bool connection _ shutdown = false ; private bool remote _ shutdown = false ; private bool closed = false ; private object encryption _ lock = new object ( ) ;
private byte [ ] remote _ send _ buffer = new byte [ buffer _ size ] ; private byte [ ] connetion _ recv _ buffer = new byte [ buffer _ size ] ; private byte [ ] connetion _ send _ buffer = new byte [ buffer _ size ] ; private bool connection _ shutdown = false ; private bool remote _ shutdown = false ; private bool closed = false ; private object encryption _ lock = new object ( ) ; private object decryption _ lock = new object ( ) ; private date _ time start _ connect _ time ; public void create _ remote ( )
private byte [ ] connetion _ send _ buffer = new byte [ buffer _ size ] ; private bool connection _ shutdown = false ; private bool remote _ shutdown = false ; private bool closed = false ; private object encryption _ lock = new object ( ) ; private object decryption _ lock = new object ( ) ; private date _ time start _ connect _ time ; public void create _ remote ( ) { server server = controller . get _ a _ server ( i _ strategy _ caller _ type . tcp , ( ip _ end _ point ) connection . remote _ end _ point ) ;
{ message _ box . show ( n . get _ string ( STR ) ) ; server _ port _ text _ box . focus ( ) ; return false ; } server . password = password _ text _ box . text ; server . method = encryption _ select . text ; server . remarks = remarks _ text _ box . text ; if ( ! int . try _ parse ( timeout _ text _ box . text , out server . timeout ) )
return false ; } server . password = password _ text _ box . text ; server . method = encryption _ select . text ; server . remarks = remarks _ text _ box . text ; if ( ! int . try _ parse ( timeout _ text _ box . text , out server . timeout ) )
{ message _ box . show ( n . get _ string ( STR ) ) ; timeout _ text _ box . focus ( ) ; return false ; } server . auth = one _ time _ auth . checked ; int local _ port = int . parse ( proxy _ port _ text _ box . text ) ; configuration . check _ server ( server ) ; configuration . check _ local _ port ( local _ port ) ; modified _ configuration . configs [ last _ selected _ index ] = server ;
return false ; } server . auth = one _ time _ auth . checked ; int local _ port = int . parse ( proxy _ port _ text _ box . text ) ; configuration . check _ server ( server ) ; configuration . check _ local _ port ( local _ port ) ; modified _ configuration . configs [ last _ selected _ index ] = server ; modified _ configuration . local _ port = local _ port ; return true ; }
return false ; else { socket . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; tcp _ handler handler = new tcp _ handler ( this ) ; handler . connection = socket ; handler . controller = controller ; handler . tcprelay = this ; handler . start ( first _ packet , length ) ; i _ list < tcp _ handler > handlers _ to _ close = new list < tcp _ handler > ( ) ;
} public void update _ inbound _ counter ( server server , long n ) { controller . update _ inbound _ counter ( server , n ) ; } public void update _ outbound _ counter ( server server , long n ) { controller . update _ outbound _ counter ( server , n ) ; } public void update _ latency ( server server , time _ span latency )
} public void create _ remote ( ) { server server = controller . get _ a _ server ( i _ strategy _ caller _ type . tcp , ( ip _ end _ point ) connection . remote _ end _ point ) ; if ( server = = null | | server . server = = STR ) throw new argument _ exception ( STR ) ; encryptor = encryptor _ factory . get _ encryptor ( server . method , server . password , server . auth , false ) ; this . server = server ;
throw new argument _ exception ( STR ) ; encryptor = encryptor _ factory . get _ encryptor ( server . method , server . password , server . auth , false ) ; this . server = server ; } public void start ( byte [ ] first _ packet , int length ) { first _ packet = first _ packet ; first _ packet _ length = length ; handshake _ receive ( ) ;
encryptor = encryptor _ factory . get _ encryptor ( server . method , server . password , server . auth , false ) ; this . server = server ; } public void start ( byte [ ] first _ packet , int length ) { first _ packet = first _ packet ; first _ packet _ length = length ; handshake _ receive ( ) ; last _ activity = date _ time . now ; }
return ; else closed = true ; } try { connection ? . shutdown ( socket _ shutdown . both ) ; connection ? . close ( ) ; } catch ( exception e )
} lock ( encryption _ lock ) { lock ( decryption _ lock ) { encryptor ? . dispose ( ) ;
} } } private void handshake _ receive ( ) { if ( closed ) return ;
try { int bytes _ read = first _ packet _ length ; if ( bytes _ read > 1 ) { byte [ ] response = { NUM , 0 } ; if ( first _ packet [ 0 ] ! = NUM ) { response = new byte [ ] { 0 , NUM } ; logging . error ( STR ) ;
close ( ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; } } private void handshake _ send _ callback ( i _ async _ result ar )
} catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; } } private void handshake _ send _ callback ( i _ async _ result ar ) { if ( closed ) return ;
try { connection . end _ send ( ar ) ; connection . begin _ receive ( connetion _ recv _ buffer , 0 , NUM , 0 , new async _ callback ( handshake _ receive _ callback ) , null ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; }
handle _ udp _ associate ( ) ; } else { logging . debug ( STR ) ; close ( ) ; } } catch ( exception e )
} else { logging . debug ( STR ) ; close ( ) ; } } catch ( exception e ) { logging . log _ useful _ exception ( e ) ;
} address . copy _ to ( response , NUM ) ; response [ response . length - 1 ] = ( byte ) ( port & 0 xff ) ; response [ response . length - 2 ] = ( byte ) ( ( port > > NUM ) & 0 xff ) ; connection . begin _ send ( response , 0 , response . length , 0 , new async _ callback ( read _ all ) , true ) ; } private void read _ all ( i _ async _ result ar ) { if ( closed ) return ;
try { if ( ar . async _ state ! = null ) { connection . end _ send ( ar ) ; logging . debug ( remote , recv _ size , STR ) ; connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , 0 , new async _ callback ( read _ all ) , null ) ; } else {
close ( ) ; } } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; } }
} } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; } } private void response _ callback ( i _ async _ result ar ) {
server server = ( ( server _ timer ) sender ) . server ; i _ strategy strategy = controller . get _ current _ strategy ( ) ; strategy ? . set _ failure ( server ) ; logging . info ( $ STR ) ; remote . close ( ) ; retry _ connect ( ) ;
logging . info ( $ STR ) ; remote . close ( ) ; retry _ connect ( ) ; } private void retry _ connect ( ) { if ( retry _ count < max _ retry ) { logging . debug ( $ STR ) ; start _ connect ( ) ;
} private void connect _ callback ( i _ async _ result ar ) { if ( closed ) return ; try
try { server _ timer timer = ( server _ timer ) ar . async _ state ; server server = timer . server ; timer . elapsed - = connect _ timer _ elapsed ; timer . enabled = false ; timer . dispose ( ) ; remote . end _ connect ( ar ) ; connected = true ; var latency = date _ time . now - start _ connect _ time ;
timer . elapsed - = connect _ timer _ elapsed ; timer . enabled = false ; timer . dispose ( ) ; remote . end _ connect ( ar ) ; connected = true ; var latency = date _ time . now - start _ connect _ time ; i _ strategy strategy = controller . get _ current _ strategy ( ) ; strategy ? . update _ latency ( server , latency ) ; tcprelay . update _ latency ( server , latency ) ; start _ pipe ( ) ;
} logging . log _ useful _ exception ( e ) ; retry _ connect ( ) ; } } private void start _ pipe ( ) { if ( closed ) return ;
try { start _ receiving _ time = date _ time . now ; remote . begin _ receive ( remote _ recv _ buffer , 0 , recv _ size , 0 , new async _ callback ( pipe _ remote _ receive _ callback ) , null ) ; connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , 0 , new async _ callback ( pipe _ connection _ receive _ callback ) , null ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ;
encryptor . decrypt ( remote _ recv _ buffer , bytes _ read , remote _ send _ buffer , out bytes _ to _ send ) ; } connection . begin _ send ( remote _ send _ buffer , 0 , bytes _ to _ send , 0 , new async _ callback ( pipe _ connection _ send _ callback ) , null ) ; i _ strategy strategy = controller . get _ current _ strategy ( ) ; strategy ? . update _ last _ read ( server ) ; }
} else { connection . shutdown ( socket _ shutdown . send ) ; connection _ shutdown = true ; check _ close ( ) ; } } catch ( exception e ) {

} public string identifier ( ) { return server + ':' + server _ port ; } } }
} } catch ( file _ not _ found _ exception ) { } this . text = n . get _ string ( STR ) + $ STR ;
} this . text = n . get _ string ( STR ) + $ STR ; } private void log _ form _ load ( object sender , event _ args e ) { init _ content ( ) ; timer = new timer ( ) ; timer . interval = NUM ; timer . tick + = timer _ tick ;
sw . auto _ flush = true ; console . set _ out ( sw ) ; console . set _ error ( sw ) ; return true ; } catch ( io _ exception e ) { console . write _ line ( e . to _ string ( ) ) ; return false ; }
} public static void error ( object o ) { write _ to _ log _ file ( STR + o ) ; } public static void info ( object o ) { write _ to _ log _ file ( o ) ; } public static void clear ( ) {
save _ config ( config ) ; if ( enable _ status _ changed ! = null ) { enable _ status _ changed ( this , new event _ args ( ) ) ; } } public void toggle _ global ( bool global ) { config . global = global ;
save _ config ( config ) ; if ( enable _ global _ changed ! = null ) { enable _ global _ changed ( this , new event _ args ( ) ) ; } } public void toggle _ share _ over _ lan ( bool enabled ) { config . share _ over _ lan = enabled ; save _ config ( config ) ;
save _ config ( config ) ; if ( config _ changed ! = null ) { config _ changed ( this , new event _ args ( ) ) ; } } public void use _ online _ pac ( bool use _ online _ pac ) { config . use _ online _ pac = use _ online _ pac ;
save _ config ( config ) ; if ( config _ changed ! = null ) { config _ changed ( this , new event _ args ( ) ) ; } } public void toggle _ checking _ update ( bool enabled ) { config . auto _ check _ update = enabled ; configuration . save ( config ) ;
using system _ diagnostics ; using system _ io ; using system _ linq ; using system _ net ; using system _ net _ sockets ; using system _ text ; using system _ windows _ forms ; using shadowsocks _ model ;
using system _ net _ sockets ; using system _ text ; using system _ windows _ forms ; using shadowsocks _ model ; using shadowsocks _ properties ; using shadowsocks _ util ; using shadowsocks _ util _ process _ management ; namespace shadowsocks _ controller {
using system _ text ; using system _ windows _ forms ; using shadowsocks _ model ; using shadowsocks _ properties ; using shadowsocks _ util ; using shadowsocks _ util _ process _ management ; namespace shadowsocks _ controller { class privoxy _ runner {
privoxy _ config = privoxy _ config . replace ( STR , configuration . local _ port . to _ string ( ) ) ; privoxy _ config = privoxy _ config . replace ( STR , running _ port . to _ string ( ) ) ; privoxy _ config = privoxy _ config . replace ( STR , configuration . share _ over _ lan ? STR : STR ) ; file _ manager . byte _ array _ to _ file ( utils . get _ temp _ path ( unique _ config _ file ) , encoding . ut . get _ bytes ( privoxy _ config ) ) ; process = new process { start _ info = { file _ name = STR , arguments = unique _ config _ file ,
process . start ( ) ; * add this process to job obj associated with this ss process , so that * when ss exit unexpectedly , this process will be forced killed by system . * / privoxy _ job . add _ process ( process . handle ) ; } } public void stop ( ) {
} public void stop ( ) { if ( process ! = null ) { kill _ process ( process ) ; process . dispose ( ) ; process = null ; }
} private static void kill _ process ( process p ) { try { p . close _ main _ window ( ) ; p . wait _ for _ exit ( NUM ) ; if ( ! p . has _ exited ) { p . kill ( ) ;
( ( system . component _ model . i _ support _ initialize ) ( this . picture _ box ) ) . begin _ init ( ) ; this . suspend _ layout ( ) ; this . picture _ box . location = new system . drawing . point ( NUM , NUM ) ; this . picture _ box . margin = new system . windows . forms . padding ( 0 ) ; this . picture _ box . name = STR ; this . picture _ box . size = new system . drawing . size ( NUM , NUM ) ; this . picture _ box . size _ mode = system . windows . forms . picture _ box _ size _ mode . zoom ; this . picture _ box . tab _ index = 1 ;
this . suspend _ layout ( ) ; this . picture _ box . location = new system . drawing . point ( NUM , NUM ) ; this . picture _ box . margin = new system . windows . forms . padding ( 0 ) ; this . picture _ box . name = STR ; this . picture _ box . size = new system . drawing . size ( NUM , NUM ) ; this . picture _ box . size _ mode = system . windows . forms . picture _ box _ size _ mode . zoom ; this . picture _ box . tab _ index = 1 ; this . picture _ box . tab _ stop = false ;
this . picture _ box . margin = new system . windows . forms . padding ( 0 ) ; this . picture _ box . name = STR ; this . picture _ box . size = new system . drawing . size ( NUM , NUM ) ; this . picture _ box . size _ mode = system . windows . forms . picture _ box _ size _ mode . zoom ; this . picture _ box . tab _ index = 1 ; this . picture _ box . tab _ stop = false ;
this . picture _ box . tab _ index = 1 ; this . picture _ box . tab _ stop = false ;
this . back _ color = system . drawing . color . white ; this . client _ size = new system . drawing . size ( NUM , NUM ) ; this . controls . add ( this . picture _ box ) ; this . form _ border _ style = system . windows . forms . form _ border _ style . fixed _ single ; this . maximize _ box = false ; this . minimize _ box = false ; this . name = STR ; this . padding = new system . windows . forms . padding ( NUM ) ; this . start _ position = system . windows . forms . form _ start _ position . center _ screen ; this . text = STR ;
this . form _ border _ style = system . windows . forms . form _ border _ style . fixed _ single ; this . maximize _ box = false ; this . minimize _ box = false ; this . name = STR ; this . padding = new system . windows . forms . padding ( NUM ) ; this . start _ position = system . windows . forms . form _ start _ position . center _ screen ; this . text = STR ; this . load + = new system . event _ handler ( this . qr _ code _ form _ load ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . picture _ box ) ) . end _ init ( ) ;
this . resume _ layout ( false ) ; } private system . windows . forms . picture _ box picture _ box ; } }
} }
private readonly concurrent _ dictionary < string , list < int > > inbound _ speed _ records = new concurrent _ dictionary < string , list < int > > ( ) ; private readonly concurrent _ dictionary < string , list < int > > outbound _ speed _ records = new concurrent _ dictionary < string , list < int > > ( ) ; private readonly concurrent _ dictionary < string , in _ out _ bound _ record > in _ out _ bound _ records = new concurrent _ dictionary < string , in _ out _ bound _ record > ( ) ; private class in _ out _ bound _ record { private long inbound ; private long last _ inbound ; private long outbound ;
private readonly concurrent _ dictionary < string , list < int > > outbound _ speed _ records = new concurrent _ dictionary < string , list < int > > ( ) ; private readonly concurrent _ dictionary < string , in _ out _ bound _ record > in _ out _ bound _ records = new concurrent _ dictionary < string , in _ out _ bound _ record > ( ) ; private class in _ out _ bound _ record { private long inbound ; private long last _ inbound ; private long outbound ; private long last _ outbound ; private spin _ lock lock = new spin _ lock ( ) ; public void update _ inbound ( long delta )
{ var id = kv . key ; var record = kv . value ; long inbound _ delta , outbound _ delta ; record . get _ delta ( out inbound _ delta , out outbound _ delta ) ; var inbound _ speed = get _ speed _ in _ ki _ b _ per _ second ( inbound _ delta , monitor _ interval . total _ seconds ) ; var outbound _ speed = get _ speed _ in _ ki _ b _ per _ second ( outbound _ delta , monitor _ interval . total _ seconds ) ; var in _ r = inbound _ speed _ records . get _ or _ add ( id , ( k ) = > new list < int > ( ) ) ; var out _ r = outbound _ speed _ records . get _ or _ add ( id , ( k ) = > new list < int > ( ) ) ; in _ r . add ( inbound _ speed ) ;
logging . debug ( $ STR ) ; } } private void reset ( ) { inbound _ speed _ records . clear ( ) ; outbound _ speed _ records . clear ( ) ; latency _ records . clear ( ) ; }
} public void update _ outbound _ counter ( server server , long n ) { in _ out _ bound _ records . add _ or _ update ( server . identifier ( ) , ( k ) = > { var r = new in _ out _ bound _ record ( ) ; r . update _ outbound ( n ) ; return r ; } , ( k , v ) = > {
} class update _ records _ state { public int counter ; } class ping _ state { public update _ records _ state state ; public statistics _ record record ; }
throw new argument _ exception ( n . get _ string ( STR ) ) ; } private static void check _ server ( string server ) { if ( server . is _ null _ or _ empty ( ) ) throw new argument _ exception ( n . get _ string ( STR ) ) ; } } }
throw new argument _ exception ( n . get _ string ( STR ) ) ; } } }
{ return n . get _ string ( STR ) ; } if ( remarks . is _ null _ or _ empty ( ) ) { return server + STR + server _ port ; } else { return remarks + STR + server + STR + server _ port + STR ;
{ return server + STR + server _ port ; } else { return remarks + STR + server + STR + server _ port + STR ; } } public server ( ) {
{ update _ online _ pacurl _ item _ click ( sender , e ) ; } if ( ! controller . get _ configuration _ copy ( ) . pac _ url . is _ null _ or _ empty ( ) ) { local _ pac _ item . checked = false ; online _ pac _ item . checked = true ; controller . use _ online _ pac ( true ) ; } update _ pac _ items _ enabled _ status ( ) ;
{ local _ pac _ item . checked = false ; online _ pac _ item . checked = true ; controller . use _ online _ pac ( true ) ; } update _ pac _ items _ enabled _ status ( ) ; } } private void update _ online _ pacurl _ item _ click ( object sender , event _ args e ) {
if ( i = = 0 ) { md _ sum = mbed _ tls . m ( password ) ; } else { md _ sum . copy _ to ( result , 0 ) ; password . copy _ to ( result , md _ sum . length ) ; md _ sum = mbed _ tls . m ( result ) ; }
} else { md _ sum . copy _ to ( result , 0 ) ; password . copy _ to ( result , md _ sum . length ) ; md _ sum = mbed _ tls . m ( result ) ; } md _ sum . copy _ to ( key , i ) ; i + = md _ sum . length ; }
} md _ sum . copy _ to ( key , i ) ; i + = md _ sum . length ; } } protected static void rand _ bytes ( byte [ ] buf , int length ) { byte [ ] temp = new byte [ length ] ; rng _ crypto _ service _ provider rng _ service _ provider = new rng _ crypto _ service _ provider ( ) ; rng _ service _ provider . get _ bytes ( temp ) ;
this . share _ over _ lan _ item . text = STR ; this . share _ over _ lan _ item . click + = new system . event _ handler ( this . share _ over _ lan _ item _ click ) ; this . servers _ item . index = NUM ; this . servers _ item . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . seperator _ item , this . config _ item } ) ; this . servers _ item . text = STR ; this . seperator _ item . index = 0 ; this . seperator _ item . text = STR ; this . config _ item . index = 1 ;
this . servers _ item . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . seperator _ item , this . config _ item } ) ; this . servers _ item . text = STR ; this . seperator _ item . index = 0 ; this . seperator _ item . text = STR ; this . config _ item . index = 1 ; this . config _ item . text = STR ; this . config _ item . click + = new system . event _ handler ( this . config _ click ) ; this . menu _ item . index = NUM ;
foreach ( result _ point point in result . result _ points ) { min _ x = math . min ( min _ x , point . x ) ; min _ y = math . min ( min _ y , point . y ) ; max _ x = math . max ( max _ x , point . x ) ; max _ y = math . max ( max _ y , point . y ) ; } min _ x / = image _ scale ; min _ y / = image _ scale ; max _ x / = image _ scale ;
private configuration config ; public event event _ handler pac _ file _ changed ; public event event _ handler user _ rule _ file _ changed ; public pac _ server ( ) { this . watch _ pac _ file ( ) ; this . watch _ user _ rule _ file ( ) ; } public void update _ configuration ( configuration config ) {
{ if ( pac _ file _ changed ! = null ) { console . write _ line ( STR , e . name , e . change _ type . to _ string ( ) . to _ lower ( ) ) ; pac _ file _ changed ( this , new event _ args ( ) ) ; } } private void user _ rule _ file _ watcher _ changed ( object sender , file _ system _ event _ args e ) { if ( user _ rule _ file _ changed ! = null )
{ if ( locale _ names [ i ] = = STR ) en _ index = i ; if ( locale _ names [ i ] = = locale ) target _ index = i ; } if ( target _ index = = - 1 ) { string locale _ no _ region = locale . split ( '-' ) [ 0 ] ; for ( int i = 0 ; i < locale _ names . length ; i + + )
} } if ( target _ index = = - 1 ) { logging . info ( $ STR ) ; return ; } while ( ! csv _ parser . end _ of _ data ) { string [ ] translations = csv _ parser . read _ fields ( ) ;
if ( translations [ 0 ] . trim _ start ( ' ' ) [ 0 ] = = '#' ) continue ; strings [ source ] = translation ; } } } static n ( ) { string n ; if ( ! file . exists ( n _ file ) ) {
} } } static n ( ) { string n ; if ( ! file . exists ( n _ file ) ) { n = resources . n _ csv ; file . write _ all _ text ( n _ file , n , encoding . ut ) ;
} public static string get _ string ( string key , params object [ ] args ) { return string . format ( strings . try _ get _ value ( key , out var value ) ? value : key , args ) ; } public static void translate _ form ( form c ) { c . text = get _ string ( c . text ) ; foreach ( var item in view _ utils . get _ child _ controls < control > ( c ) ) {
this . group _ box . suspend _ layout ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . begin _ init ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . suspend _ layout ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . begin _ init ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . suspend _ layout ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . data _ collection _ minutes _ num ) ) . begin _ init ( ) ;
public string server _ name ; public string icmp _ status ; public int roundtrip _ time ; public string geolocation ; public string isp ; } public class statistics _ data { public float package _ loss ; public int average _ response ;
var server _ urls = ss _ url . split ( '\r' , '\n' ) ; list < server > servers = new list < server > ( ) ; foreach ( string server _ url in server _ urls ) { string server _ url = server _ url . trim ( ) ; if ( ! server _ url . begin _ with ( STR , string _ comparison . invariant _ culture _ ignore _ case ) ) { continue ; } server legacy _ server = parse _ legacy _ url ( server _ url ) ;
{ servers . add ( legacy _ server ) ; } else { uri parsed _ url ; try { parsed _ url = new uri ( server _ url ) ; }
} else { uri parsed _ url ; try { parsed _ url = new uri ( server _ url ) ; } catch ( uri _ format _ exception ) {
{ uri parsed _ url ; try { parsed _ url = new uri ( server _ url ) ; } catch ( uri _ format _ exception ) { continue ; }
}
} return servers ; } public string identifier ( ) { return server + ':' + server _ port ; } } }
public sodium _ encryptor ( string method , string password ) : base ( method , password ) { init _ key ( method , password ) ; } private static dictionary < string , int [ ] > ciphers = new dictionary < string , int [ ] > { { STR , new int [ ] { NUM , NUM , cipher _ sals , polar _ ssl . aes _ ctx _ size } } , { STR , new int [ ] { NUM , NUM , cipher _ chach , polar _ ssl . aes _ ctx _ size } } ,
} private static dictionary < string , int [ ] > ciphers = new dictionary < string , int [ ] > { { STR , new int [ ] { NUM , NUM , cipher _ sals , polar _ ssl . aes _ ctx _ size } } , { STR , new int [ ] { NUM , NUM , cipher _ chach , polar _ ssl . aes _ ctx _ size } } , } ; protected override dictionary < string , int [ ] > get _ ciphers ( ) { return ciphers ; } public static list < string > supported _ ciphers ( )
byte [ ] iv ; lock ( sodium _ buf ) { if ( is _ cipher ) { bytes _ remaining = encrypt _ bytes _ remaining ; ic = encrypt _ ic ; iv = encrypt _ iv ; }
{ if ( is _ cipher ) { bytes _ remaining = encrypt _ bytes _ remaining ; ic = encrypt _ ic ; iv = encrypt _ iv ; } else { bytes _ remaining = decrypt _ bytes _ remaining ;
} } public override void dispose ( ) { } } }
stream . close ( ) ; } } } } }
} public server get _ current _ server ( ) { return config . get _ current _ server ( ) ; } public configuration get _ configuration ( ) { return configuration . load ( ) ; } public void save _ servers ( list < server > servers )
config = configuration . load ( ) ; if ( polipo _ runner = = null ) { polipo _ runner = new polipo _ runner ( ) ; } if ( pac _ server = = null ) { pac _ server = new pac _ server ( ) ; pac _ server . pac _ file _ changed + = pac _ server _ pac _ file _ changed ; }
polipo _ runner . stop ( ) ; try { polipo _ runner . start ( config ) ; local = new local ( config ) ; local . start ( ) ; pac _ server . start ( config ) ; } catch ( exception e ) {
if ( config _ changed ! = null ) { config _ changed ( this , new event _ args ( ) ) ; } update _ system _ proxy ( ) ; util . util . release _ memory ( ) ; } protected void save _ config ( configuration new _ config ) { configuration . save ( new _ config ) ;
start _ pipe ( ) ; } catch ( argument _ exception e ) { } catch ( exception e ) { if ( server ! = null ) { i _ strategy strategy = controller . get _ current _ strategy ( ) ;
} logging . log _ useful _ exception ( e ) ; retry _ connect ( ) ; } } private void start _ pipe ( ) { if ( closed ) { return ;
private menu _ item servers _ item ;

this . servers _ item = create _ menu _ group ( 2 , STR , new system . windows . forms . menu _ item [ ] { this . seperator _ item , this . config _ item } ) ; this . auto _ startup _ item = create _ menu _ item ( NUM , STR , new system . event _ handler ( this . auto _ startup _ item _ click ) ) ; this . share _ over _ lan _ item = create _ menu _ item ( NUM , STR , new system . event _ handler ( this . share _ over _ lan _ item _ click ) ) ;
this . auto _ startup _ item = create _ menu _ item ( NUM , STR , new system . event _ handler ( this . auto _ startup _ item _ click ) ) ; this . share _ over _ lan _ item = create _ menu _ item ( NUM , STR , new system . event _ handler ( this . share _ over _ lan _ item _ click ) ) ; this . context _ menu . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] {
this . context _ menu . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . enable _ item , create _ menu _ group ( 1 , STR , new system . windows . forms . menu _ item [ ] { this . pac _ mode _ item , this . global _ mode _ item } ) , this . servers _ item , create _ seperator _ item ( NUM ) , this . auto _ startup _ item ,
this . servers _ item , create _ seperator _ item ( NUM ) , this . auto _ startup _ item , this . share _ over _ lan _ item , create _ menu _ item ( NUM , STR , new system . event _ handler ( this . edit _ pac _ file _ item _ click ) ) , create _ seperator _ item ( NUM ) , create _ menu _ item ( NUM , STR , new system . event _ handler ( this . qr _ code _ item _ click ) ) , create _ menu _ item ( NUM , STR , new system . event _ handler ( this . show _ log _ item _ click ) ) , create _ menu _ item ( NUM , STR , new system . event _ handler ( this . config _ click ) ) , create _ seperator _ item ( NUM ) ,
this . auto _ startup _ item , this . share _ over _ lan _ item , create _ menu _ item ( NUM , STR , new system . event _ handler ( this . edit _ pac _ file _ item _ click ) ) , create _ seperator _ item ( NUM ) , create _ menu _ item ( NUM , STR , new system . event _ handler ( this . qr _ code _ item _ click ) ) , create _ menu _ item ( NUM , STR , new system . event _ handler ( this . show _ log _ item _ click ) ) , create _ menu _ item ( NUM , STR , new system . event _ handler ( this . config _ click ) ) , create _ seperator _ item ( NUM ) , create _ menu _ item ( NUM , STR , new system . event _ handler ( this . quit _ click ) ) } ) ; }
} private void controller _ config _ changed ( object sender , event _ args e ) { load _ current _ configuration ( ) ; update _ tray _ icon ( ) ; } private void controller _ enable _ status _ changed ( object sender , event _ args e ) { enable _ item . checked = controller . get _ configuration ( ) . enabled ; }
list < string > versions = new list < string > ( ) ; foreach ( json _ object release in result ) { if ( ( bool ) release [ STR ] ) { continue ; } foreach ( json _ object asset in ( json _ array ) release [ STR ] ) { string url = ( string ) asset [ STR ] ;
{ if ( ( bool ) release [ STR ] ) { continue ; } foreach ( json _ object asset in ( json _ array ) release [ STR ] ) { string url = ( string ) asset [ STR ] ; if ( is _ new _ version ( url ) )
{ continue ; } foreach ( json _ object asset in ( json _ array ) release [ STR ] ) { string url = ( string ) asset [ STR ] ; if ( is _ new _ version ( url ) ) { versions . add ( url ) ;
{ versions . add ( url ) ; } } } if ( versions . count = = 0 )
} } } if ( versions . count = = 0 ) { return ; } sort _ versions ( versions ) ; latest _ version _ url = versions [ versions . count - 1 ] ; latest _ version _ number = parse _ version _ from _ url ( latest _ version _ url ) ;
using shadowsocks _ controller ; using shadowsocks _ properties ; using shadowsocks _ model ; using system _ text ; using newtonsoft _ json ; namespace shadowsocks _ util _ system _ proxy { public static class sysproxy { private const string user _ wininet _ config _ file = STR ;
private static sysproxy _ config user _ settings = null ; enum ret _ errors : int { ret _ no _ error = 0 , invalid _ format = 1 , no _ permission = 2 , syscall _ failed = NUM , no _ memory = NUM , invaild _ option _ count = NUM , } ;
enum ret _ errors : int { ret _ no _ error = 0 , invalid _ format = 1 , no _ permission = 2 , syscall _ failed = NUM , no _ memory = NUM , invaild _ option _ count = NUM , } ; static sysproxy ( )
{ exec _ sysproxy ( STR ) ; parse _ query _ str ( query _ str ) ; } string arguments ; if ( enable ) {
} string arguments ; if ( enable ) { arguments = global ? $ STR : $ STR ; } else {
arguments = $ STR ; user _ settings . user _ settings _ recorded = false ; } save ( ) ; exec _ sysproxy ( arguments ) ; } private static void exec _ sysproxy ( string arguments ) { using ( var process = new process ( ) )
} save ( ) ; exec _ sysproxy ( arguments ) ; } private static void exec _ sysproxy ( string arguments ) { using ( var process = new process ( ) ) { process . start _ info . file _ name = utils . get _ temp _ path ( STR ) ;
} private static void exec _ sysproxy ( string arguments ) { using ( var process = new process ( ) ) { process . start _ info . file _ name = utils . get _ temp _ path ( STR ) ; process . start _ info . arguments = arguments ; process . start _ info . working _ directory = utils . get _ temp _ path ( ) ; process . start _ info . window _ style = process _ window _ style . hidden ; process . start _ info . use _ shell _ execute = false ;
{ using ( var process = new process ( ) ) { process . start _ info . file _ name = utils . get _ temp _ path ( STR ) ; process . start _ info . arguments = arguments ; process . start _ info . working _ directory = utils . get _ temp _ path ( ) ; process . start _ info . window _ style = process _ window _ style . hidden ; process . start _ info . use _ shell _ execute = false ; process . start _ info . redirect _ standard _ error = true ; process . start _ info . redirect _ standard _ output = true ;
} } } private static void save ( ) { try { using ( stream _ writer sw = new stream _ writer ( file . open ( user _ wininet _ config _ file , file _ mode . create ) ) ) { string json _ string = json _ convert . serialize _ object ( user _ settings , formatting . indented ) ; sw . write ( json _ string ) ; sw . flush ( ) ;
} } private static void parse _ query _ str ( string str ) { string [ ] user _ settings _ arr = str . split ( new string [ ] { STR } , string _ split _ options . remove _ empty _ entries ) ; user _ settings . flags = user _ settings _ arr [ 0 ] ; if ( user _ settings _ arr [ 1 ] = = STR ) user _ settings . proxy _ server = null ; else user _ settings . proxy _ server = user _ settings _ arr [ 1 ] ; if ( user _ settings _ arr [ 2 ] = = STR ) user _ settings . bypass _ list = null ; else user _ settings . bypass _ list = user _ settings _ arr [ 2 ] ;
} } }
using system _ collections _ generic ; using system _ io ; using system _ runtime _ interop _ services ; using system _ text ; namespace shadowsocks _ encrypt { public class polar _ ssl { const string dllname = STR ; public const int aes _ ctx _ size = NUM + NUM * NUM ;
using system _ threading ; using system _ windows _ forms ; namespace shadowsocks { static class program { sta _ thread static void main ( )
sta _ thread static void main ( ) { using ( mutex mutex = new mutex ( false , STR + STR ) ) { if ( ! mutex . wait _ one ( 0 , false ) ) { process [ ] old _ processes = process . get _ processes _ by _ name ( STR ) ; if ( old _ processes . length > 0 ) {
{ byte [ ] hash = new byte [ NUM ] ; ota _ update _ key _ buffer ( ) ; sodium . ss _ sha _ hmac _ ex ( ota _ chunk _ key _ buffer , ( uint ) ota _ chunk _ key _ buffer . length , buf , offset , ( uint ) len , hash ) ; return hash ; } private void ota _ auth _ buffer _ tcp ( byte [ ] buf , ref int length ) { if ( ! encrypt _ iv _ sent )
buf , offset , ( uint ) len , hash ) ; return hash ; } private void ota _ auth _ buffer _ tcp ( byte [ ] buf , ref int length ) { if ( ! encrypt _ iv _ sent ) { int head _ len = ota _ get _ head _ len ( buf , length ) ; int data _ len = length - head _ len ; buf [ 0 ] | = onetimeauth _ flag ;
int data _ len = length - head _ len ; buf [ 0 ] | = onetimeauth _ flag ; byte [ ] hash = ota _ gen _ hash ( buf , head _ len ) ; buffer . block _ copy ( buf , head _ len , buf , head _ len + onetimeauth _ bytes + auth _ bytes , data _ len ) ; buffer . block _ copy ( hash , 0 , buf , head _ len , onetimeauth _ bytes ) ; hash = ota _ gen _ chunk _ hash ( buf , head _ len + onetimeauth _ bytes + auth _ bytes , data _ len ) ; buffer . block _ copy ( hash , 0 , buf , head _ len + onetimeauth _ bytes + clen _ bytes , onetimeauth _ bytes ) ; byte [ ] len _ bytes = bit _ converter . get _ bytes ( ( ushort ) ip _ address . host _ to _ network _ order ( ( short ) data _ len ) ) ; buffer . block _ copy ( len _ bytes , 0 , buf , head _ len + onetimeauth _ bytes , clen _ bytes ) ; length = head _ len + onetimeauth _ bytes + auth _ bytes + data _ len ;
buffer . block _ copy ( buf , head _ len , buf , head _ len + onetimeauth _ bytes + auth _ bytes , data _ len ) ; buffer . block _ copy ( hash , 0 , buf , head _ len , onetimeauth _ bytes ) ; hash = ota _ gen _ chunk _ hash ( buf , head _ len + onetimeauth _ bytes + auth _ bytes , data _ len ) ; buffer . block _ copy ( hash , 0 , buf , head _ len + onetimeauth _ bytes + clen _ bytes , onetimeauth _ bytes ) ; byte [ ] len _ bytes = bit _ converter . get _ bytes ( ( ushort ) ip _ address . host _ to _ network _ order ( ( short ) data _ len ) ) ; buffer . block _ copy ( len _ bytes , 0 , buf , head _ len + onetimeauth _ bytes , clen _ bytes ) ; length = head _ len + onetimeauth _ bytes + auth _ bytes + data _ len ; } else {
buffer . block _ copy ( hash , 0 , buf , length , onetimeauth _ bytes ) ; length + = onetimeauth _ bytes ; } private void ota _ auth _ buffer ( byte [ ] buf , ref int length ) { if ( onetime _ auth & & iv _ len > 0 ) { if ( ! is _ udp ) { ota _ auth _ buffer _ tcp ( buf , ref length ) ;
} else { ota _ auth _ buffer _ udp ( buf , ref length ) ; } } } protected static void rand _ bytes ( byte [ ] buf , int length ) { byte [ ] temp = new byte [ length ] ;
} public override void encrypt ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength ) { if ( ! encrypt _ iv _ sent ) { rand _ bytes ( outbuf , iv _ len ) ; init _ cipher ( outbuf , true ) ; outlength = length + iv _ len ; ota _ auth _ buffer ( buf , ref length ) ;
encrypt _ iv _ sent = true ; lock ( tempbuf ) { cipher _ update ( true , length , buf , tempbuf ) ; outlength = length + iv _ len ; buffer . block _ copy ( tempbuf , 0 , outbuf , iv _ len , length ) ; } } else {
global _ system _ code _ dom _ compiler _ generated _ code _ attribute _ system _ resources _ tools _ strongly _ typed _ resource _ builder global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute global _ system _ runtime _ compiler _ services _ compiler _ generated _ attribute internal class resources { private static global :: system . resources . resource _ manager resource _ man ; private static global :: system . globalization . culture _ info resource _ culture ; global _ system _ diagnostics _ code _ analysis _ suppress _ message _ attribute _ microsoft _ performance _ c _ avoid _ uncalled _ private _ code internal resources ( ) {
global :: system . resources . resource _ manager temp = new global :: system . resources . resource _ manager ( STR , typeof ( resources ) . assembly ) ; resource _ man = temp ; } return resource _ man ; } } global _ system _ component _ model _ editor _ browsable _ attribute _ global _ system _ component _ model _ editor _ browsable _ state _ advanced internal static global :: system . globalization . culture _ info culture { get {
} if ( modified _ configuration . configs . count = = 0 ) { message _ box . show ( n . get _ string ( STR ) ) ; return false ; } int local _ port = int . parse ( proxy _ port _ text _ box . text ) ; configuration . check _ local _ port ( local _ port ) ; modified _ configuration . local _ port = local _ port ; modified _ configuration . portable _ mode = portable _ mode _ check _ box . checked ;
} int local _ port = int . parse ( proxy _ port _ text _ box . text ) ; configuration . check _ local _ port ( local _ port ) ; modified _ configuration . local _ port = local _ port ; modified _ configuration . portable _ mode = portable _ mode _ check _ box . checked ; controller . save _ servers ( modified _ configuration . configs , modified _ configuration . local _ port , modified _ configuration . portable _ mode ) ; controller . select _ server _ index ( servers _ list _ box . selected _ index ) ; return true ; } private void config _ form _ key _ down ( object sender , key _ event _ args e )
} private void cancel _ button _ click ( object sender , event _ args e ) { this . close ( ) ; } private void config _ form _ shown ( object sender , event _ args e ) { ip _ text _ box . focus ( ) ; } private void config _ form _ form _ closed ( object sender , form _ closed _ event _ args e )
this . apply _ button . location = new system . drawing . point ( NUM , NUM ) ; this . apply _ button . margin = new system . windows . forms . padding ( NUM , NUM , 0 , 0 ) ; this . apply _ button . name = STR ; this . apply _ button . size = new system . drawing . size ( NUM , NUM ) ; this . apply _ button . tab _ index = NUM ; this . apply _ button . text = STR ; this . apply _ button . use _ visual _ style _ back _ color = true ; this . apply _ button . click + = new system . event _ handler ( this . apply _ button _ click ) ; this . delete _ button . dock = system . windows . forms . dock _ style . right ; this . delete _ button . location = new system . drawing . point ( NUM , NUM ) ;
} public void update _ outbound _ counter ( long n ) { interlocked . add ( ref outbound _ counter , n ) ; config . get _ current _ server ( ) . bandwidth _ out = outbound _ counter ; } protected void reload ( ) { config = configuration . load ( ) ; inbound _ counter = config . get _ current _ server ( ) . bandwidth _ in ;
} protected void reload ( ) { config = configuration . load ( ) ; inbound _ counter = config . get _ current _ server ( ) . bandwidth _ in ; outbound _ counter = config . get _ current _ server ( ) . bandwidth _ out ; statistics _ configuration = statistics _ strategy _ configuration . load ( ) ; if ( polipo _ runner = = null ) { polipo _ runner = new polipo _ runner ( ) ;
statistics _ configuration = statistics _ strategy _ configuration . load ( ) ; if ( polipo _ runner = = null ) { polipo _ runner = new polipo _ runner ( ) ; } if ( pac _ server = = null ) { pac _ server = new pac _ server ( ) ; pac _ server . pac _ file _ changed + = pac _ server _ pac _ file _ changed ; pac _ server . user _ rule _ file _ changed + = pac _ server _ user _ rule _ file _ changed ;
( ( system . component _ model . i _ support _ initialize ) ( this . statistics _ chart ) ) . begin _ init ( ) ; this . group _ box . suspend _ layout ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . begin _ init ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . suspend _ layout ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . begin _ init ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . panel . suspend _ layout ( ) ;
this . group _ box . suspend _ layout ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . begin _ init ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . suspend _ layout ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . begin _ init ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . suspend _ layout ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . data _ collection _ minutes _ num ) ) . begin _ init ( ) ;

? ? new statistics _ strategy _ configuration ( ) ; if ( configuration . calculations = = null ) { configuration = new statistics _ strategy _ configuration ( ) ; } } private void init _ data ( ) { binding _ configuration . add ( configuration ) ; foreach ( var kv in configuration . calculations )
namespace shadowsocks _ controller { class pac _ server { private static int port = NUM ; public static string pac _ file = STR ; private static configuration config ; socket listener ; file _ system _ watcher watcher ; public event event _ handler pac _ file _ changed ;
private static configuration config ; socket listener ; file _ system _ watcher watcher ; public event event _ handler pac _ file _ changed ; public void start ( configuration configuration ) { try {
public void start ( configuration configuration ) { try { config = configuration ; listener = new socket ( address _ family . inter _ network , socket _ type . stream , protocol _ type . tcp ) ; listener . set _ socket _ option ( socket _ option _ level . socket , socket _ option _ name . reuse _ address , true ) ; ip _ end _ point local _ end _ point = null ; if ( configuration . share _ over _ lan ) {
public event error _ event _ handler error ;
private void http _ download _ string _ completed ( object sender , download _ string _ completed _ event _ args e ) { try { string [ ] lines = parse _ result ( e . result ) ; json _ array rules = new json _ array ( ) ; rules . add _ range ( lines ) ; string abp _ content = utils . un _ gzip ( resources . abp _ js ) ; abp _ content = abp _ content . replace ( STR , rules . to _ string ( ) ) ; file . write _ all _ text ( pac _ file , abp _ content , encoding . ut ) ;
{ update _ completed ( this , new event _ args ( ) ) ; } } catch ( exception ex ) {
} } catch ( exception ex ) { if ( error ! = null ) { error ( this , new error _ event _ args ( ex ) ) ; } }
} } public void update _ pac _ from _ gfw _ list ( ) { web _ client http = new web _ client ( ) ; http . download _ string _ completed + = http _ download _ string _ completed ; http . download _ string _ async ( new uri ( gfwlist _ url ) ) ; } public string [ ] parse _ result ( string response ) {
{ web _ client http = new web _ client ( ) ; http . download _ string _ completed + = http _ download _ string _ completed ; http . download _ string _ async ( new uri ( gfwlist _ url ) ) ; } public string [ ] parse _ result ( string response ) { byte [ ] bytes = convert . from _ base _ string ( response ) ; string content = encoding . ascii . get _ string ( bytes ) ; string [ ] lines = content . split ( new char [ ] { '\r' , '\n' } , string _ split _ options . remove _ empty _ entries ) ;
{ if ( line . starts _ with ( STR ) | | line . starts _ with ( STR ) ) continue ; valid _ lines . add ( line ) ; } return valid _ lines . to _ array ( ) ;
} return valid _ lines . to _ array ( ) ;
} } }
{ if ( update _ pac _ from _ gfw _ list _ error ! = null ) update _ pac _ from _ gfw _ list _ error ( this , e ) ; } private void start _ releasing _ memory ( ) { ram _ thread = new thread ( new thread _ start ( release _ memory ) ) ; ram _ thread . is _ background = true ; ram _ thread . start ( ) ; }
{ public static void release _ memory ( ) { gc . collect ( gc . max _ generation ) ; gc . wait _ for _ pending _ finalizers ( ) ; set _ process _ working _ set _ size ( process . get _ current _ process ( ) . handle , ( u _ int _ ptr ) 0 xffffffff , ( u _ int _ ptr ) 0 xffffffff ) ; } public static string un _ gzip ( byte [ ] buf ) {
try { file _ manager . uncompress _ file ( temppath + STR , resources . privoxy _ exe ) ; file _ manager . uncompress _ file ( temppath + STR , resources . mgwz _ dll ) ; } catch ( io _ exception e ) { logging . log _ useful _ exception ( e ) ; } }
} } class handler { public i _ encryptor encryptor ; public server server ; public socket remote ; public socket connection ; public shadowsocks _ controller controller ; public tcp _ relay relay ;
return mode . byte ;
} private static int choose _ mask _ pattern ( bit _ array bits , error _ correction _ level ec _ level , version version , byte _ matrix matrix ) { int min _ penalty = int . max _ value ; int best _ mask _ pattern = - 1 ; for ( int mask _ pattern = 0 ; mask _ pattern < qr _ code . num _ mask _ patterns ; mask _ pattern + + ) {
else throw new writer _ exception ( STR + mode ) ; } internal static void append _ numeric _ bytes ( string content , bit _ array bits )
} internal static void append _ numeric _ bytes ( string content , bit _ array bits ) { int length = content . length ; int i = 0 ; while ( i < length ) { int num = content [ i ] - '0' ; if ( i + 2 < length ) {
public void set _ bulk ( int i , int new _ bits ) { bits [ i > > NUM ] = new _ bits ; }
public void clear ( ) { int max = bits . length ; for ( int i = 0 ; i < max ; i + + ) { bits [ i ] = 0 ; }
} public void append _ bit ( bool bit ) { ensure _ capacity ( size + 1 ) ; if ( bit ) { bits [ size > > NUM ] | = 1 < < ( size & 0 f ) ; } size + + ; }
using shadowsocks _ model ; using simple _ json = simple _ json . simple _ json ; using timer = system . threading . timer ; namespace shadowsocks _ controller { using data _ unit = key _ value _ pair < string , string > ; using data _ list = list < key _ value _ pair < string , string > > ; class availability _ statistics { private const string statistics _ files _ name = STR ;
{ logging . debug ( STR ) ; const string api = STR ; var json _ string = await new http _ client ( ) . get _ string _ async ( api ) ; var ret = new data _ list { new data _ unit ( state . geolocation , state . unknown ) , new data _ unit ( state . isp , state . unknown ) , } ; dynamic obj ;
{ var reply = await ping . send _ task _ async ( server . server , timeout ) ; ret . add ( new list < key _ value _ pair < string , string > > { new key _ value _ pair < string , string > ( STR , timestamp ) , new key _ value _ pair < string , string > ( STR , server . friendly _ name ( ) ) , new key _ value _ pair < string , string > ( STR , reply ? . status . to _ string ( ) ) , new key _ value _ pair < string , string > ( STR , reply ? . roundtrip _ time . to _ string ( ) )
{ new key _ value _ pair < string , string > ( STR , timestamp ) , new key _ value _ pair < string , string > ( STR , server . friendly _ name ( ) ) , new key _ value _ pair < string , string > ( STR , reply ? . status . to _ string ( ) ) , new key _ value _ pair < string , string > ( STR , reply ? . roundtrip _ time . to _ string ( ) ) } ) ; } return ret ; } private async void evaluate ( object obj )
} } } private static void append ( data _ list data _ list , i _ enumerable < data _ unit > extra ) { var data = data _ list . concat ( extra ) ; var data _ line = string . join ( delimiter , data . select ( kv = > kv . value ) . to _ array ( ) ) ; string [ ] lines ; if ( ! file . exists ( availability _ statistics _ file ) ) {
{ var data = data _ list . concat ( extra ) ; var data _ line = string . join ( delimiter , data . select ( kv = > kv . value ) . to _ array ( ) ) ; string [ ] lines ; if ( ! file . exists ( availability _ statistics _ file ) ) { var header _ line = string . join ( delimiter , data . select ( kv = > kv . key ) . to _ array ( ) ) ; lines = new [ ] { header _ line , data _ line } ; } else
match match = regex . match ( name , STR , regex _ options . ignore _ case ) ; if ( match . success ) { string version = match . groups [ STR ] . value ; var asset = new asset { browser _ download _ url = ( string ) assert _ j _ object [ STR ] , name = name , version = version
name = name , version = version } ; if ( match . groups [ STR ] . success ) { asset . suffix = match . groups [ STR ] . value ; } return asset ; } return null ;
public partial class log _ form : form { long last _ offset ; string filename ; timer timer ; const int back _ offset = NUM ; shadowsocks _ controller controller ; private static readonly object lock = new object ( ) ; queue < traffic _ info > traffic _ info _ queue = new queue < traffic _ info > ( ) ; const int queue _ max _ length = NUM ;
public log _ form ( shadowsocks _ controller controller , string filename ) { this . controller = controller ; this . filename = filename ; initialize _ component ( ) ; icon = icon . from _ handle ( resources . ssw . get _ hicon ( ) ) ; log _ viewer _ config config = controller . get _ configuration _ copy ( ) . log _ viewer ; top _ most _ trigger = config . top _ most ; wrap _ text _ trigger = config . wrap _ text ; toolbar _ trigger = config . toolbar _ shown ;
lock ( lock ) { if ( traffic _ info _ queue . count = = 0 ) return ; inbound _ points . clear ( ) ; outbound _ points . clear ( ) ; max _ speed = 0 ; foreach ( var traffic _ info in traffic _ info _ queue ) { inbound _ points . add ( traffic _ info . inbound ) ;
return ; inbound _ points . clear ( ) ; outbound _ points . clear ( ) ; max _ speed = 0 ; foreach ( var traffic _ info in traffic _ info _ queue ) { inbound _ points . add ( traffic _ info . inbound ) ; outbound _ points . add ( traffic _ info . outbound ) ; max _ speed = math . max ( max _ speed , math . max ( traffic _ info . inbound , traffic _ info . outbound ) ) ; }
} if ( max _ speed > 0 ) { last _ max _ speed - = last _ max _ speed / NUM ; max _ speed = math . max ( min _ scale , math . max ( max _ speed , last _ max _ speed ) ) ; last _ max _ speed = max _ speed ; } else { max _ speed = last _ max _ speed = min _ scale ;
private bool stopped = false ; private bool system _ proxy _ is _ dirty = false ; public class path _ event _ args : event _ args { public string path ;
} public class traffic _ per _ second { public long inbound _ counter ; public long outbound _ counter ; public long inbound _ increasement ; public long outbound _ increasement ; } public event event _ handler config _ changed ; public event event _ handler enable _ status _ changed ;
for ( int i = 0 ; i < queue _ max _ size ; i + + ) { traffic _ per _ second _ queue . enqueue ( new traffic _ per _ second ( ) ) ; } traffic _ thread = new thread ( new thread _ start ( ( ) = > traffic _ statistics ( queue _ max _ size ) ) ) ; traffic _ thread . is _ background = true ; traffic _ thread . start ( ) ; } private void traffic _ statistics ( int queue _ max _ size ) {
} traffic _ thread = new thread ( new thread _ start ( ( ) = > traffic _ statistics ( queue _ max _ size ) ) ) ; traffic _ thread . is _ background = true ; traffic _ thread . start ( ) ; } private void traffic _ statistics ( int queue _ max _ size ) { traffic _ per _ second previous , current ; while ( true ) {
traffic _ changed ? . invoke ( this , new event _ args ( ) ) ; thread . sleep ( NUM ) ; } } } }
public date _ time last _ activity ; private const int max _ retry = NUM ; private int retry _ count = 0 ; private bool connected ; private byte command ; private byte [ ] first _ packet ; private int first _ packet _ length ; private int total _ read = 0 ; private int total _ write = 0 ; private byte [ ] remote _ recv _ buffer = new byte [ buffer _ size ] ;
private date _ time start _ connect _ time ; private date _ time start _ receiving _ time ; private date _ time start _ sending _ time ; private int bytes _ to _ send ; private tcp _ relay tcprelay ; public tcp _ handler ( tcp _ relay tcprelay ) { this . tcprelay = tcprelay ; } public void create _ remote ( )
} } }
public byte [ ] remote _ recv _ buffer = new byte [ recv _ size ] ; public byte [ ] remote _ send _ buffer = new byte [ buffer _ size ] ; public byte [ ] connetion _ recv _ buffer = new byte [ recv _ size ] ; public byte [ ] connetion _ send _ buffer = new byte [ buffer _ size ] ; public string _ builder sb = new string _ builder ( ) ; public void start ( ) { try
public byte [ ] connetion _ recv _ buffer = new byte [ recv _ size ] ; public byte [ ] connetion _ send _ buffer = new byte [ buffer _ size ] ; public string _ builder sb = new string _ builder ( ) ; public void start ( ) { try { ip _ address ip _ address ; bool parsed = ip _ address . try _ parse ( config . server , out ip _ address ) ;
public string _ builder sb = new string _ builder ( ) ; public void start ( ) { try { ip _ address ip _ address ; bool parsed = ip _ address . try _ parse ( config . server , out ip _ address ) ; if ( ! parsed ) { ip _ host _ entry ip _ host _ info = dns . get _ host _ entry ( config . server ) ;
new async _ callback ( pipe _ remote _ receive _ callback ) , null ) ; connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , 0 , new async _ callback ( pipe _ connection _ receive _ callback ) , null ) ; } catch ( exception e ) { console . write _ line ( e . to _ string ( ) ) ; this . close ( ) ; } }
new async _ callback ( pipe _ connection _ receive _ callback ) , null ) ; } catch ( exception e ) { console . write _ line ( e . to _ string ( ) ) ; this . close ( ) ; } } private void pipe _ remote _ receive _ callback ( i _ async _ result ar ) {
{ if ( encrypt _ ctx = = int _ ptr . zero ) { open _ ssl . rand _ bytes ( outbuf , iv _ len ) ; init _ cipher ( ref encrypt _ ctx , outbuf , true ) ; outlength = length + iv _ len ; open _ ssl . evp _ cipher _ update ( encrypt _ ctx , tempbuf , out outlength , buf , length ) ; outlength = length + iv _ len ; buffer . block _ copy ( tempbuf , 0 , outbuf , iv _ len , outlength ) ;
} else { outlength = length ; open _ ssl . evp _ cipher _ update ( encrypt _ ctx , outbuf , out outlength , buf , length ) ;
} } public override void decrypt ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength ) { if ( decrypt _ ctx = = int _ ptr . zero ) { init _ cipher ( ref decrypt _ ctx , buf , false ) ; outlength = length - iv _ len ; buffer . block _ copy ( buf , iv _ len , tempbuf , 0 , length - iv _ len ) ; open _ ssl . evp _ cipher _ update ( decrypt _ ctx , outbuf , out outlength , tempbuf , length - iv _ len ) ;
{ if ( decrypt _ ctx = = int _ ptr . zero ) { init _ cipher ( ref decrypt _ ctx , buf , false ) ; outlength = length - iv _ len ; buffer . block _ copy ( buf , iv _ len , tempbuf , 0 , length - iv _ len ) ; open _ ssl . evp _ cipher _ update ( decrypt _ ctx , outbuf , out outlength , tempbuf , length - iv _ len ) ;
} else { outlength = length ; open _ ssl . evp _ cipher _ update ( decrypt _ ctx , outbuf , out outlength , buf , length ) ;
} } private static readonly dictionary < string , byte [ ] > cached _ keys = new dictionary < string , byte [ ] > ( ) ; private byte [ ] key ; private int _ ptr encrypt _ ctx ; private int _ ptr decrypt _ ctx ; private int _ ptr cipher ; private string method ; private int key _ len ; private int iv _ len ;
{ void encrypt ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength ) ; void decrypt ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength ) ; } }
} }
{ byte [ ] result = new byte [ length ] ; for ( int i = 0 ; i < length ; i + + ) { outbuf [ i ] = encrypt _ table [ buf [ i ] ] ; } outlength = length ; } public override void decrypt ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength ) {
} outlength = length ; } public override void decrypt ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength ) { byte [ ] result = new byte [ length ] ; for ( int i = 0 ; i < length ; i + + ) { outbuf [ i ] = decrypt _ table [ buf [ i ] ] ; }
} public override void decrypt ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength ) { byte [ ] result = new byte [ length ] ; for ( int i = 0 ; i < length ; i + + ) { outbuf [ i ] = decrypt _ table [ buf [ i ] ] ; } outlength = length ; }
{ byte [ ] result = new byte [ length ] ; for ( int i = 0 ; i < length ; i + + ) { outbuf [ i ] = decrypt _ table [ buf [ i ] ] ; } outlength = length ; } private readonly byte [ ] encrypt _ table = new byte [ NUM ] ; private readonly byte [ ] decrypt _ table = new byte [ NUM ] ;
} outlength = length ; } private readonly byte [ ] encrypt _ table = new byte [ NUM ] ; private readonly byte [ ] decrypt _ table = new byte [ NUM ] ; private static long compare ( byte x , byte y , ulong a , int i ) { return ( long ) ( a % ( ulong ) ( x + i ) ) - ( long ) ( a % ( ulong ) ( y + i ) ) ; } private byte [ ] merge _ sort ( byte [ ] array , ulong a , int j )
} private readonly byte [ ] encrypt _ table = new byte [ NUM ] ; private readonly byte [ ] decrypt _ table = new byte [ NUM ] ; private static long compare ( byte x , byte y , ulong a , int i ) { return ( long ) ( a % ( ulong ) ( x + i ) ) - ( long ) ( a % ( ulong ) ( y + i ) ) ; } private byte [ ] merge _ sort ( byte [ ] array , ulong a , int j ) { if ( array . length = = 1 )
{ private static readonly string executable _ path = assembly . get _ entry _ assembly ( ) . location ; private static string key = STR + application . startup _ path . get _ hash _ code ( ) ; public static bool set ( bool enabled ) { registry _ key run _ key = null ; try {
public static bool set ( bool enabled ) { registry _ key run _ key = null ; try { run _ key = utils . open _ reg _ key ( STR , true ) ; if ( run _ key = = null ) { logging . error ( STR ) ; return false ;
run _ key = utils . open _ reg _ key ( STR , true ) ; if ( run _ key = = null ) { logging . error ( STR ) ; return false ; } if ( enabled ) { run _ key . set _ value ( key , executable _ path ) ; } else
} else { run _ key . delete _ value ( key ) ; } return true ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ;
return true ; } } } return false ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; return false ;
private async _ session current _ remote _ session ; private const int max _ retry = NUM ; private int retry _ count = 0 ; private bool proxy _ connected ; private bool dest _ connected ; private byte command ; private byte [ ] first _ packet ; private int first _ packet _ length ; private int total _ read = 0 ; private int total _ write = 0 ;
private date _ time start _ connect _ time ; private date _ time start _ receiving _ time ; private date _ time start _ sending _ time ; public tcp _ handler ( shadowsocks _ controller controller , configuration config , tcp _ relay tcprelay , socket socket ) { this . controller = controller ; this . config = config ;
this . tcprelay = tcprelay ; this . connection = socket ; } public void create _ remote ( ) { server server = controller . get _ a _ server ( i _ strategy _ caller _ type . tcp , ( ip _ end _ point ) connection . remote _ end _ point ) ; if ( server = = null | | server . server = = STR ) throw new argument _ exception ( STR ) ; lock ( encryption _ lock ) {
} public void create _ remote ( ) { server server = controller . get _ a _ server ( i _ strategy _ caller _ type . tcp , ( ip _ end _ point ) connection . remote _ end _ point ) ; if ( server = = null | | server . server = = STR ) throw new argument _ exception ( STR ) ; lock ( encryption _ lock ) { lock ( decryption _ lock ) {
if ( closed ) return ; closed = true ; } lock ( tcprelay . handlers ) { tcprelay . handlers . remove ( this ) ; } try { connection ? . shutdown ( socket _ shutdown . both ) ;
} catch ( exception e ) { logging . log _ useful _ exception ( e ) ; } try { var remote = current _ remote _ session ? . remote ; remote ? . shutdown ( socket _ shutdown . both ) ; remote ? . close ( ) ;
if ( mbed _ tls . cipher _ set _ iv ( ctx , iv , iv _ len ) ! = 0 ) throw new exception ( STR ) ; if ( mbed _ tls . cipher _ reset ( ctx ) ! = 0 ) throw new exception ( STR ) ; } protected override void cipher _ update ( bool is _ cipher , int length , byte [ ] buf , byte [ ] outbuf ) { if ( disposed ) { throw new object _ disposed _ exception ( this . to _ string ( ) ) ;
if ( mbed _ tls . cipher _ reset ( ctx ) ! = 0 ) throw new exception ( STR ) ; } protected override void cipher _ update ( bool is _ cipher , int length , byte [ ] buf , byte [ ] outbuf ) { if ( disposed ) { throw new object _ disposed _ exception ( this . to _ string ( ) ) ; } int _ ptr ctx ;
} protected override void cipher _ update ( bool is _ cipher , int length , byte [ ] buf , byte [ ] outbuf ) { if ( disposed ) { throw new object _ disposed _ exception ( this . to _ string ( ) ) ; } int _ ptr ctx ; if ( is _ cipher ) {
} else if ( name . starts _ with ( STR , string _ comparison . ordinal _ ignore _ case ) ) { init ( resources . ja ) ; } } public static string get _ string ( string key ) { return strings . contains _ key ( key ) ? strings [ key ]
} } public static string get _ string ( string key ) { return strings . contains _ key ( key ) ? strings [ key ] : key ; } } }
private lru _ cache < ip _ end _ point , udp _ handler > cache ; public udp _ relay ( shadowsocks _ controller controller ) { this . controller = controller ; this . cache = new lru _ cache < ip _ end _ point , udp _ handler > ( NUM ) ; } public bool handle ( byte [ ] first _ packet , int length , socket socket , object state ) { if ( socket . protocol _ type ! = protocol _ type . udp ) {
{ this . controller = controller ; this . cache = new lru _ cache < ip _ end _ point , udp _ handler > ( NUM ) ; } public bool handle ( byte [ ] first _ packet , int length , socket socket , object state ) { if ( socket . protocol _ type ! = protocol _ type . udp ) { return false ; }
this . cache = new lru _ cache < ip _ end _ point , udp _ handler > ( NUM ) ; } public bool handle ( byte [ ] first _ packet , int length , socket socket , object state ) { if ( socket . protocol _ type ! = protocol _ type . udp ) { return false ; } if ( length < NUM ) {
notify _ icon . text = text . substring ( 0 , math . min ( NUM , text . length ) ) ; } private menu _ item create _ menu _ item ( string text , event _ handler click ) { return new menu _ item ( n . get _ string ( text ) , click ) ; } private menu _ item create _ menu _ group ( string text , menu _ item [ ] items ) { return new menu _ item ( n . get _ string ( text ) , items ) ; }
mode _ item . enabled = enable _ item . checked ; } void controller _ share _ over _ lan _ status _ changed ( object sender , event _ args e ) { share _ over _ lan _ item . checked = controller . get _ configuration _ copy ( ) . share _ over _ lan ; } void controller _ enable _ global _ changed ( object sender , event _ args e ) { global _ mode _ item . checked = controller . get _ configuration _ copy ( ) . global ; pac _ mode _ item . checked = ! global _ mode _ item . checked ;
} void controller _ enable _ global _ changed ( object sender , event _ args e ) { global _ mode _ item . checked = controller . get _ configuration _ copy ( ) . global ; pac _ mode _ item . checked = ! global _ mode _ item . checked ; } void controller _ file _ ready _ to _ open ( object sender , shadowsocks _ controller . path _ event _ args e ) { string argument = STR + e . path ; system . diagnostics . process . start ( STR , argument ) ;
pac _ mode _ item . checked = ! global _ mode _ item . checked ; } void controller _ file _ ready _ to _ open ( object sender , shadowsocks _ controller . path _ event _ args e ) { string argument = STR + e . path ; system . diagnostics . process . start ( STR , argument ) ; } void show _ balloon _ tip ( string title , string content , tool _ tip _ icon icon , int timeout ) { notify _ icon . balloon _ tip _ title = title ;
menu _ item item = new menu _ item ( server . friendly _ name ( ) ) ; item . tag = i ; item . click + = a _ server _ item _ click ; items . add ( i , item ) ; i + + ; } foreach ( menu _ item item in items ) { if ( item . tag ! = null & & ( item . tag . to _ string ( ) = = configuration . index . to _ string ( ) | | item . tag . to _ string ( ) = = configuration . strategy ) ) {
} } private void show _ config _ form ( ) { if ( config _ form ! = null ) { config _ form . activate ( ) ; } else {
} public bool handle ( byte [ ] first _ packet , int length , socket socket , object state ) { if ( socket . protocol _ type ! = protocol _ type . tcp ) { return false ; } if ( length < 2 | | first _ packet [ 0 ] ! = NUM ) { return false ;
{ return configuration . load ( ) ; } public configuration get _ current _ configuration ( ) { return config ; } public i _ list < i _ strategy > get _ strategies ( ) { return strategy _ manager . get _ strategies ( ) ;
{ config . index = - 1 ; } config . is _ default = false ; try { using ( stream _ writer sw = new stream _ writer ( file . open ( config _ file , file _ mode . create ) ) ) { string json _ string = simple _ json . simple _ json . serialize _ object ( config ) ; sw . write ( json _ string ) ;
} config . is _ default = false ; try { using ( stream _ writer sw = new stream _ writer ( file . open ( config _ file , file _ mode . create ) ) ) { string json _ string = simple _ json . simple _ json . serialize _ object ( config ) ; sw . write ( json _ string ) ; sw . flush ( ) ; }
{ try { connection . end _ send ( ar ) ; start _ connect ( ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; this . close ( ) ;
logging . info ( STR ) ; break ; } } private static void timer _ elapsed ( object sender , system . timers . elapsed _ event _ args e ) { try { if ( controller ! = null ) {
} catch ( exception ex ) { logging . log _ useful _ exception ( ex ) ; } finally { try { system . timers . timer timer = ( system . timers . timer ) sender ;
string base = convert . to _ base _ string ( encoding . ut . get _ bytes ( parts ) ) ; if ( ! server . remarks . is _ null _ or _ empty ( ) ) { tag = $ STR ; } return $ STR ; } public void update _ pac _ from _ gfw _ list ( ) {
} public void update _ pac _ from _ gfw _ list ( ) { if ( gfw _ list _ updater ! = null ) { gfw _ list _ updater . update _ pac _ from _ gfw _ list ( config ) ; } } public void update _ statistics _ configuration ( bool enabled ) {
if ( ! tag . is _ null _ or _ empty ( ) ) remarks = http _ utility . url _ decode ( tag , encoding . ut ) ; match = details _ parser . match ( encoding . ut . get _ string ( convert . from _ base _ string ( base . pad _ right ( base . length + ( NUM - base . length % NUM ) % NUM , '=' ) ) ) ) ; method = match . groups [ STR ] . value ; auth = match . groups [ STR ] . success ; password = match . groups [ STR ] . value ; server = match . groups [ STR ] . value ; server _ port = int . parse ( match . groups [ STR ] . value ) ; }
match = details _ parser . match ( encoding . ut . get _ string ( convert . from _ base _ string ( base . pad _ right ( base . length + ( NUM - base . length % NUM ) % NUM , '=' ) ) ) ) ; method = match . groups [ STR ] . value ; auth = match . groups [ STR ] . success ; password = match . groups [ STR ] . value ; server = match . groups [ STR ] . value ; server _ port = int . parse ( match . groups [ STR ] . value ) ; } public string identifier ( ) {
connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , socket _ flags . none , new async _ callback ( read _ all ) , null ) ; } else { int bytes _ read = connection . end _ receive ( ar ) ; if ( bytes _ read > 0 ) { connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , socket _ flags . none , new async _ callback ( read _ all ) , null ) ; }
connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , socket _ flags . none , new async _ callback ( read _ all ) , null ) ; } else close ( ) ; } } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ;
{ byte [ ] response = { NUM , 0 } ; if ( connetion _ recv _ buffer [ 0 ] ! = NUM ) { response = new byte [ ] { 0 , NUM } ; } connection . begin _ send ( response , 0 , response . length , 0 , new async _ callback ( handshake _ send _ callback ) , null ) ; } else {
{ open _ ssl . evp _ cipher _ ctx _ cleanup ( encrypt _ ctx ) ; open _ ssl . evp _ cipher _ ctx _ free ( encrypt _ ctx ) ; encrypt _ ctx = int _ ptr . zero ; } if ( decrypt _ ctx . to _ int ( ) ! = 0 ) { open _ ssl . evp _ cipher _ ctx _ cleanup ( decrypt _ ctx ) ; open _ ssl . evp _ cipher _ ctx _ free ( decrypt _ ctx ) ; decrypt _ ctx = int _ ptr . zero ;
{ open _ ssl . evp _ cipher _ ctx _ cleanup ( decrypt _ ctx ) ; open _ ssl . evp _ cipher _ ctx _ free ( decrypt _ ctx ) ; decrypt _ ctx = int _ ptr . zero ; } disposed = true ; } } } }
} else { def _ connection [ options _ offset ] = ( byte ) ( def _ connection [ options _ offset ] & ~ NUM ) ; saved _ legacy _ setting [ options _ offset ] = ( byte ) ( saved _ legacy _ setting [ options _ offset ] & ~ NUM ) ; } bit _ converter . get _ bytes ( unchecked ( bit _ converter . to _ u _ int ( def _ connection , version _ offset ) + 1 ) ) . copy _ to ( def _ connection , version _ offset ) ; bit _ converter . get _ bytes (
} bit _ converter . get _ bytes ( unchecked ( bit _ converter . to _ u _ int ( def _ connection , version _ offset ) + 1 ) ) . copy _ to ( def _ connection , version _ offset ) ; bit _ converter . get _ bytes ( unchecked ( bit _ converter . to _ u _ int ( saved _ legacy _ setting , version _ offset ) + 1 ) ) . copy _ to ( saved _ legacy _ setting , version _ offset ) ; registry . set _ value ( STR , def _ connection ) ;
registry . set _ value ( STR , def _ connection ) ; registry . set _ value ( STR , saved _ legacy _ setting ) ; } } }
public sealed class availability _ statistics { public const string date _ time _ pattern = STR ; private const string statistics _ files _ name = STR ; private const int timeout _ milliseconds = NUM ; public static readonly date _ time unknown _ date _ time = new date _ time ( NUM , 1 , 1 ) ; public static string availability _ statistics _ file ; private readonly time _ span delay _ before _ start = time _ span . from _ seconds ( 1 ) ; private readonly time _ span monitor _ interval = time _ span . from _ seconds ( 1 ) ; private readonly time _ span retry _ interval = time _ span . from _ minutes ( 2 ) ;
public statistics raw _ statistics { get ; private set ; } public statistics filtered _ statistics { get ; private set ; } private int repeat = > config . repeat _ times _ num ; private time _ span recording _ interval = > time _ span . from _ minutes ( config . data _ collection _ minutes ) ;
private int repeat = > config . repeat _ times _ num ; private time _ span recording _ interval = > time _ span . from _ minutes ( config . data _ collection _ minutes ) ;
public bool set ( statistics _ strategy _ configuration config ) { config = config ; try { if ( config . statistics _ enabled ) { if ( recorder ? . change ( delay _ before _ start , recording _ interval ) = = null ) { recorder = new timer ( run , null , delay _ before _ start , recording _ interval ) ;
} } else { recorder ? . dispose ( ) ; speed _ monior ? . dispose ( ) ; } return true ; } catch ( exception e )
speed _ monior ? . dispose ( ) ; } return true ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; return false ; } }
bytes = controller . outbound _ counter - last _ outbound _ counter ; last _ outbound _ counter = controller . outbound _ counter ; var outbound _ speed = get _ speed _ in _ ki _ b _ per _ second ( bytes , monitor _ interval . total _ seconds ) ; outbound _ speed _ records . add ( outbound _ speed ) ; logging . debug ( $ STR ) ; } private async task < icmp _ result > icmp _ test ( server server )
{ logging . debug ( STR + server . friendly _ name ( ) ) ; if ( server . server = = STR ) return null ; var result = new icmp _ result ( server ) ; try { var ip = dns . get _ host _ addresses ( server . server ) . first ( ip = >
var ping = new ping ( ) ; foreach ( var in enumerable . range ( 0 , repeat ) ) { try { var reply = await ping . send _ task _ async ( ip , timeout _ milliseconds ) ; if ( ! reply . status . equals ( ip _ status . success ) ) { result . roundtrip _ time . add ( ( int? ) reply . roundtrip _ time ) ; }
try { var reply = await ping . send _ task _ async ( ip , timeout _ milliseconds ) ; if ( ! reply . status . equals ( ip _ status . success ) ) { result . roundtrip _ time . add ( ( int? ) reply . roundtrip _ time ) ; } else { result . roundtrip _ time . add ( null ) ;
thread . sleep ( timeout _ milliseconds + new random ( ) . next ( ) % timeout _ milliseconds ) ; } catch ( exception e ) { logging . error ( $ STR ) ; logging . log _ useful _ exception ( e ) ; } } } catch ( exception e )
filter _ raw _ statistics ( ) ; } private async void append _ record ( ) { var icmp _ results = task _ ex . when _ all ( servers . select ( icmp _ test ) ) ; var current _ server _ record = new statistics _ record ( current _ server . identifier ( ) , inbound _ speed _ records , outbound _ speed _ records , latency _ records ) ; foreach ( var result in ( await icmp _ results ) . where ( result = > result ! = null ) ) { list < statistics _ record > records ;
private static void append ( data _ list data _ list , i _ enumerable < data _ unit > extra ) { var data = data _ list . concat ( extra ) ; var data _ line = string . join ( delimiter , data . select ( kv = > kv . value ) . to _ array ( ) ) ; string [ ] lines ; if ( ! file . exists ( availability _ statistics _ file ) ) { var header _ line = string . join ( delimiter , data . select ( kv = > kv . key ) . to _ array ( ) ) ; lines = new [ ] { header _ line , data _ line } ; }
set ( controller . statistics _ configuration ) ; servers = controller . get _ current _ configuration ( ) . configs ; } private bool is _ valid _ record ( statistics _ record record ) { if ( config . by _ hour _ of _ day ) { var current _ hour = date _ time . now . hour ; if ( record . timestamp = = unknown _ date _ time ) return false ; if ( ! record . timestamp . hour . equals ( date _ time . now . hour ) ) return false ;
} } private void load _ raw _ statistics ( ) { try { var path = availability _ statistics _ file ; logging . debug ( $ STR ) ; if ( ! file . exists ( path ) ) {
return ; } } raw _ statistics = json _ convert . deserialize _ object < statistics > ( file . read _ all _ text ( path ) ) ? ? raw _ statistics ;
} catch ( exception e ) { logging . log _ useful _ exception ( e ) ; } } private date _ time parse _ exact _ or _ unknown ( string str ) { date _ time date _ time ; return ! date _ time . try _ parse _ exact ( str , date _ time _ pattern , null , date _ time _ styles . none , out date _ time )
} public void update _ latency ( int latency ) { latency _ records . add ( latency ) ; } private static int get _ speed _ in _ ki _ b _ per _ second ( long bytes , double seconds ) { var result = ( int ) ( bytes / seconds ) / NUM ; return result ; }
} private static int get _ speed _ in _ ki _ b _ per _ second ( long bytes , double seconds ) { var result = ( int ) ( bytes / seconds ) / NUM ; return result ; } private class icmp _ result { internal readonly list < int? > roundtrip _ time = new list < int? > ( ) ; internal readonly server server ;
if ( ! controller . availability _ statistics . filtered _ statistics . try _ get _ value ( server _ name , out statistics ) ) return ; i _ enumerable < i _ grouping < int , statistics _ record > > data _ groups ; if ( all _ mode . checked ) { data _ groups = statistics . group _ by ( data = > data . timestamp . day _ of _ year ) ; statistics _ chart . chart _ areas [ STR ] . axis _ x . label _ style . format = STR ; statistics _ chart . chart _ areas [ STR ] . axis . label _ style . format = STR ; } else {
if ( all _ mode . checked ) { data _ groups = statistics . group _ by ( data = > data . timestamp . day _ of _ year ) ; statistics _ chart . chart _ areas [ STR ] . axis _ x . label _ style . format = STR ; statistics _ chart . chart _ areas [ STR ] . axis . label _ style . format = STR ; } else { data _ groups = statistics . group _ by ( data = > data . timestamp . hour ) ; statistics _ chart . chart _ areas [ STR ] . axis _ x . label _ style . format = STR ;
private int choice _ kept _ milliseconds = > ( int ) time _ span . from _ minutes ( controller . statistics _ configuration . choice _ kept _ minutes ) . total _ milliseconds ; public statistics _ strategy ( shadowsocks _ controller controller ) { controller = controller ; var servers = controller . get _ current _ configuration ( ) . configs ; var random _ index = new random ( ) . next ( ) % servers . count ( ) ; current _ server = servers [ random _ index ] ; timer = new timer ( reload _ statistics _ and _ choose _ a _ server ) ; }
} private float get _ score ( string server _ name ) { var config = controller . statistics _ configuration ; list < statistics _ record > records ; if ( filtered _ statistics = = null | | ! filtered _ statistics . try _ get _ value ( server _ name , out records ) ) return 0 ;
float factor ; float score = 0 ; var average _ record = new statistics _ record ( server _ name , records . find _ all ( record = > record . max _ inbound _ speed ! = null ) . select ( record = > record . max _ inbound _ speed . value ) , records . find _ all ( record = > record . max _ outbound _ speed ! = null ) . select ( record = > record . max _ outbound _ speed . value ) , records . find _ all ( record = > record . average _ latency ! = null ) . select ( record = > record . average _ latency . value ) ) ; average _ record . set _ response ( records . select ( record = > record . average _ response ) ) ; if ( ! config . calculations . try _ get _ value ( STR , out factor ) ) factor = 0 ; score + = average _ record . package _ loss * factor ? ? 0 ; if ( ! config . calculations . try _ get _ value ( STR , out factor ) ) factor = 0 ;
if ( ! config . calculations . try _ get _ value ( STR , out factor ) ) factor = 0 ; score + = average _ record . average _ response * factor ? ? 0 ; if ( ! config . calculations . try _ get _ value ( STR , out factor ) ) factor = 0 ; score + = average _ record . min _ response * factor ? ? 0 ; if ( ! config . calculations . try _ get _ value ( STR , out factor ) ) factor = 0 ; score + = average _ record . max _ response * factor ? ? 0 ; logging . debug ( $ STR ) ; return score ; } private void choose _ new _ server ( list < server > servers )
if ( ! config . calculations . try _ get _ value ( STR , out factor ) ) factor = 0 ; score + = average _ record . min _ response * factor ? ? 0 ; if ( ! config . calculations . try _ get _ value ( STR , out factor ) ) factor = 0 ; score + = average _ record . max _ response * factor ? ? 0 ; logging . debug ( $ STR ) ; return score ; } private void choose _ new _ server ( list < server > servers ) { if ( filtered _ statistics = = null | | servers . count = = 0 )
if ( ! config . calculations . try _ get _ value ( STR , out factor ) ) factor = 0 ; score + = average _ record . max _ response * factor ? ? 0 ; logging . debug ( $ STR ) ; return score ; } private void choose _ new _ server ( list < server > servers ) { if ( filtered _ statistics = = null | | servers . count = = 0 ) { return ;
return score ; } private void choose _ new _ server ( list < server > servers ) { if ( filtered _ statistics = = null | | servers . count = = 0 ) { return ; } try {
this . table _ layout _ panel . suspend _ layout ( ) ; this . panel . suspend _ layout ( ) ; this . panel . suspend _ layout ( ) ; this . server _ group _ box . suspend _ layout ( ) ; this . suspend _ layout ( ) ; this . table _ layout _ panel . auto _ size = true ; this . table _ layout _ panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . table _ layout _ panel . column _ count = 2 ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ;
this . table _ layout _ panel . name = STR ; this . table _ layout _ panel . padding = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . table _ layout _ panel . row _ count = NUM ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ;
this . table _ layout _ panel . row _ count = NUM ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ; this . table _ layout _ panel . tab _ index = 0 ; this . remarks _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ;
this . remarks _ text _ box . name = STR ; this . remarks _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . remarks _ text _ box . tab _ index = NUM ; this . remarks _ text _ box . word _ wrap = false ; this . label . anchor = system . windows . forms . anchor _ styles . right ; this . label . auto _ size = true ; this . label . location = new system . drawing . point ( NUM , NUM ) ; this . label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ; this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ;
this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ; this . label . tab _ index = NUM ; this . label . text = STR ; this . label . anchor = system . windows . forms . anchor _ styles . right ; this . label . auto _ size = true ; this . label . location = new system . drawing . point ( NUM , NUM ) ; this . label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ; this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ;
this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ; this . label . tab _ index = 0 ; this . label . text = STR ; this . label . anchor = system . windows . forms . anchor _ styles . right ; this . label . auto _ size = true ; this . label . location = new system . drawing . point ( NUM , NUM ) ; this . label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ; this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ;
this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ; this . label . tab _ index = 1 ; this . label . text = STR ; this . proxy _ port _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . proxy _ port _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . proxy _ port _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . proxy _ port _ text _ box . name = STR ; this . proxy _ port _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . proxy _ port _ text _ box . tab _ index = NUM ;
this . proxy _ port _ text _ box . name = STR ; this . proxy _ port _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . proxy _ port _ text _ box . tab _ index = NUM ; this . proxy _ port _ text _ box . word _ wrap = false ; this . label . anchor = system . windows . forms . anchor _ styles . right ; this . label . auto _ size = true ; this . label . location = new system . drawing . point ( NUM , NUM ) ; this . label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ; this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ;
this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ; this . label . tab _ index = NUM ; this . label . text = STR ; this . label . anchor = system . windows . forms . anchor _ styles . right ; this . label . auto _ size = true ; this . label . location = new system . drawing . point ( NUM , NUM ) ; this . label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ; this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ;
this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ; this . label . tab _ index = 2 ; this . label . text = STR ; this . ip _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . ip _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . ip _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . ip _ text _ box . name = STR ; this . ip _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . ip _ text _ box . tab _ index = 0 ;
this . ip _ text _ box . name = STR ; this . ip _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . ip _ text _ box . tab _ index = 0 ; this . ip _ text _ box . word _ wrap = false ; this . server _ port _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . server _ port _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . server _ port _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . server _ port _ text _ box . name = STR ; this . server _ port _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . server _ port _ text _ box . tab _ index = 1 ;
this . server _ port _ text _ box . name = STR ; this . server _ port _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . server _ port _ text _ box . tab _ index = 1 ; this . server _ port _ text _ box . word _ wrap = false ; this . password _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . password _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . password _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . password _ text _ box . name = STR ; this . password _ text _ box . password _ char = '*' ; this . password _ text _ box . size = new system . drawing . size ( NUM , NUM ) ;
this . password _ text _ box . name = STR ; this . password _ text _ box . password _ char = '*' ; this . password _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . password _ text _ box . tab _ index = 2 ; this . password _ text _ box . word _ wrap = false ; this . label . anchor = system . windows . forms . anchor _ styles . right ; this . label . auto _ size = true ; this . label . location = new system . drawing . point ( NUM , NUM ) ; this . label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ; this . label . name = STR ;
this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ; this . label . tab _ index = NUM ; this . label . text = STR ; this . encryption _ select . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( ( system . windows . forms . anchor _ styles . top | system . windows . forms . anchor _ styles . left ) | system . windows . forms . anchor _ styles . right ) ) ) ; this . encryption _ select . drop _ down _ style = system . windows . forms . combo _ box _ style . drop _ down _ list ; this . encryption _ select . formatting _ enabled = true ; this . encryption _ select . ime _ mode = system . windows . forms . ime _ mode . no _ control ; this . encryption _ select . item _ height = NUM ;
this . encryption _ select . name = STR ; this . encryption _ select . size = new system . drawing . size ( NUM , NUM ) ; this . encryption _ select . tab _ index = NUM ; this . notify _ icon . text = STR ; this . notify _ icon . double _ click + = new system . event _ handler ( this . notify _ icon _ double _ click ) ; this . panel . anchor = system . windows . forms . anchor _ styles . top ; this . panel . auto _ size = true ; this . panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ;
this . notify _ icon . text = STR ; this . notify _ icon . double _ click + = new system . event _ handler ( this . notify _ icon _ double _ click ) ; this . panel . anchor = system . windows . forms . anchor _ styles . top ; this . panel . auto _ size = true ; this . panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . panel . location = new system . drawing . point ( NUM , NUM ) ; this . panel . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . panel . name = STR ; this . panel . size = new system . drawing . size ( 0 , 0 ) ;
this . notify _ icon . double _ click + = new system . event _ handler ( this . notify _ icon _ double _ click ) ; this . panel . anchor = system . windows . forms . anchor _ styles . top ; this . panel . auto _ size = true ; this . panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . panel . location = new system . drawing . point ( NUM , NUM ) ; this . panel . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . panel . name = STR ; this . panel . size = new system . drawing . size ( 0 , 0 ) ; this . panel . tab _ index = 1 ; this . ok _ button . dialog _ result = system . windows . forms . dialog _ result . ok ;
this . panel . name = STR ; this . panel . size = new system . drawing . size ( 0 , 0 ) ; this . panel . tab _ index = 1 ; this . ok _ button . dialog _ result = system . windows . forms . dialog _ result . ok ; this . ok _ button . location = new system . drawing . point ( NUM , NUM ) ; this . ok _ button . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . ok _ button . name = STR ; this . ok _ button . size = new system . drawing . size ( NUM , NUM ) ; this . ok _ button . tab _ index = NUM ; this . ok _ button . text = STR ;
this . ok _ button . name = STR ; this . ok _ button . size = new system . drawing . size ( NUM , NUM ) ; this . ok _ button . tab _ index = NUM ; this . ok _ button . text = STR ; this . ok _ button . use _ visual _ style _ back _ color = true ; this . ok _ button . click + = new system . event _ handler ( this . ok _ button _ click ) ; this . my _ cancel _ button . dialog _ result = system . windows . forms . dialog _ result . cancel ; this . my _ cancel _ button . location = new system . drawing . point ( NUM , NUM ) ; this . my _ cancel _ button . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . my _ cancel _ button . name = STR ;
this . my _ cancel _ button . name = STR ; this . my _ cancel _ button . size = new system . drawing . size ( NUM , NUM ) ; this . my _ cancel _ button . tab _ index = NUM ; this . my _ cancel _ button . text = STR ; this . my _ cancel _ button . use _ visual _ style _ back _ color = true ; this . my _ cancel _ button . click + = new system . event _ handler ( this . cancel _ button _ click ) ; this . panel . auto _ size = true ; this . panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . panel . controls . add ( this . my _ cancel _ button ) ; this . panel . controls . add ( this . ok _ button ) ;
this . delete _ button . name = STR ; this . delete _ button . size = new system . drawing . size ( NUM , NUM ) ; this . delete _ button . tab _ index = NUM ; this . delete _ button . text = STR ; this . delete _ button . use _ visual _ style _ back _ color = true ; this . delete _ button . click + = new system . event _ handler ( this . delete _ button _ click ) ; this . add _ button . location = new system . drawing . point ( NUM , NUM ) ; this . add _ button . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . add _ button . name = STR ; this . add _ button . size = new system . drawing . size ( NUM , NUM ) ;
this . add _ button . name = STR ; this . add _ button . size = new system . drawing . size ( NUM , NUM ) ; this . add _ button . tab _ index = NUM ; this . add _ button . text = STR ; this . add _ button . use _ visual _ style _ back _ color = true ; this . add _ button . click + = new system . event _ handler ( this . add _ button _ click ) ; this . server _ group _ box . controls . add ( this . table _ layout _ panel ) ; this . server _ group _ box . location = new system . drawing . point ( NUM , NUM ) ; this . server _ group _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . server _ group _ box . name = STR ;
this . server _ group _ box . name = STR ; this . server _ group _ box . padding = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . server _ group _ box . size = new system . drawing . size ( NUM , NUM ) ; this . server _ group _ box . tab _ index = NUM ; this . server _ group _ box . tab _ stop = false ; this . server _ group _ box . text = STR ; this . servers _ list _ box . formatting _ enabled = true ; this . servers _ list _ box . item _ height = NUM ; this . servers _ list _ box . location = new system . drawing . point ( NUM , NUM ) ; this . servers _ list _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;
this . server _ group _ box . tab _ index = NUM ; this . server _ group _ box . tab _ stop = false ; this . server _ group _ box . text = STR ; this . servers _ list _ box . formatting _ enabled = true ; this . servers _ list _ box . item _ height = NUM ; this . servers _ list _ box . location = new system . drawing . point ( NUM , NUM ) ; this . servers _ list _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . servers _ list _ box . name = STR ; this . servers _ list _ box . size = new system . drawing . size ( NUM , NUM ) ; this . servers _ list _ box . tab _ index = NUM ;
this . servers _ list _ box . name = STR ; this . servers _ list _ box . size = new system . drawing . size ( NUM , NUM ) ; this . servers _ list _ box . tab _ index = NUM ; this . servers _ list _ box . selected _ index _ changed + = new system . event _ handler ( this . servers _ list _ box _ selected _ index _ changed ) ; this . accept _ button = this . ok _ button ; this . auto _ scale _ mode = system . windows . forms . auto _ scale _ mode . dpi ; this . auto _ size = true ; this . cancel _ button = this . my _ cancel _ button ; this . client _ size = new system . drawing . size ( NUM , NUM ) ; this . controls . add ( this . servers _ list _ box ) ;
{ geosite _ updater . merge _ and _ write _ pac _ file ( ) ; } return file . read _ all _ text ( pac _ file , encoding . ut ) ; } private void watch _ pac _ file ( )
} return file . read _ all _ text ( pac _ file , encoding . ut ) ; } private void watch _ pac _ file ( ) { pac _ file _ watcher ? . dispose ( ) ;
} private void watch _ pac _ file ( ) { pac _ file _ watcher ? . dispose ( ) ; pac _ file _ watcher = new file _ system _ watcher ( directory . get _ current _ directory ( ) ) ; pac _ file _ watcher . notify _ filter = notify _ filters . last _ write | notify _ filters . file _ name | notify _ filters . directory _ name ; pac _ file _ watcher . filter = pac _ file ; pac _ file _ watcher . changed + = pac _ file _ watcher _ changed ; pac _ file _ watcher . created + = pac _ file _ watcher _ changed ; pac _ file _ watcher . deleted + = pac _ file _ watcher _ changed ;
return true ; } public class udp _ handler { private socket local ; private socket remote ; private server server ; private byte [ ] buffer = new byte [ NUM ] ; private ip _ end _ point local _ end _ point ; private ip _ end _ point remote _ end _ point ;
servers _ list _ box . selected _ index _ changed + = servers _ list _ box _ selected _ index _ changed ; return true ; } else return false ; } private bool? check _ ip _ text _ box ( out string address , bool is _ save , bool is _ copy ) { address = null ; string out _ address ;
} } private void duplicate _ button _ click ( object sender , event _ args e ) { if ( validate _ and _ save _ selected _ server _ details ( is _ copy : true ) ) { server curr _ server = modified _ configuration . configs [ last _ selected _ index ] ; configuration . add _ default _ server _ or _ server ( modified _ configuration , curr _ server , last _ selected _ index + 1 ) ; load _ server _ name _ list _ to _ ui ( modified _ configuration ) ; last _ selected _ index = ( servers _ list _ box . selected _ index = ( last _ selected _ index + 1 ) ) ;
load _ server _ name _ list _ to _ ui ( modified _ configuration ) ; last _ selected _ index = ( servers _ list _ box . selected _ index = ( last _ selected _ index + 1 ) ) ; } } private void delete _ button _ click ( object sender , event _ args e ) { modified _ configuration . configs . remove _ at ( last _ selected _ index ) ; if ( modified _ configuration . configs . count = = 0 ) { configuration . add _ default _ server _ or _ server ( modified _ configuration ) ;
} } private void delete _ button _ click ( object sender , event _ args e ) { modified _ configuration . configs . remove _ at ( last _ selected _ index ) ; if ( modified _ configuration . configs . count = = 0 ) { configuration . add _ default _ server _ or _ server ( modified _ configuration ) ; } load _ server _ name _ list _ to _ ui ( modified _ configuration ) ;
servers _ list _ box . begin _ update ( ) ; load _ server _ name _ list _ to _ ui ( modified _ configuration ) ; last _ selected _ index = new _ index ; servers _ list _ box . selected _ index = new _ index ;
servers _ list _ box . end _ update ( ) ; update _ buttons ( ) ; } private void ok _ button _ click ( object sender , event _ args e ) { if ( save _ valid _ configuration ( ) ) { close ( ) ; } }
} else { realkey = key ; } if ( cipher = = cipher _ aes ) { polar _ ssl . aes _ init ( ctx ) ; polar _ ssl . aes _ setkey _ enc ( ctx , realkey , key _ len * NUM ) ; if ( is _ cipher )
} } static byte [ ] tempbuf = new byte [ NUM ] ; public override void encrypt ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength ) { if ( encrypt _ ctx = = null ) { rand _ bytes ( outbuf , iv _ len ) ; init _ cipher ( ref encrypt _ ctx , outbuf , true ) ; outlength = length + iv _ len ;
break ; case cipher _ bf : polar _ ssl . blowfish _ crypt _ cfb ( encrypt _ ctx , polar _ ssl . blowfish _ encrypt , length , ref encrypt _ iv _ offset , encrypt _ iv , buf , outbuf ) ; break ; case cipher _ r : polar _ ssl . arc _ crypt ( encrypt _ ctx , length , buf , outbuf ) ; break ; }
break ; case cipher _ r : polar _ ssl . arc _ crypt ( encrypt _ ctx , length , buf , outbuf ) ; break ; }
} } } public override void decrypt ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength ) { if ( decrypt _ ctx = = null ) { init _ cipher ( ref decrypt _ ctx , buf , false ) ; outlength = length - iv _ len ; lock ( tempbuf )
break ; case cipher _ bf : polar _ ssl . blowfish _ crypt _ cfb ( decrypt _ ctx , polar _ ssl . blowfish _ decrypt , length , ref decrypt _ iv _ offset , decrypt _ iv , buf , outbuf ) ; break ; case cipher _ r : polar _ ssl . arc _ crypt ( decrypt _ ctx , length , buf , outbuf ) ; break ; }
break ; case cipher _ r : polar _ ssl . arc _ crypt ( decrypt _ ctx , length , buf , outbuf ) ; break ; }
} } } private bool disposed ; public override void dispose ( ) { dispose ( true ) ; gc . suppress _ finalize ( this ) ; } ~ polar _ ssl _ encryptor ( )
if ( encrypt _ ctx ! = null ) { lock ( encrypt _ ctx ) { switch ( cipher ) { case cipher _ aes : polar _ ssl . aes _ free ( encrypt _ ctx ) ; break ; case cipher _ bf :
} } if ( decrypt _ ctx ! = null ) { lock ( decrypt _ ctx ) { switch ( cipher ) { case cipher _ aes : polar _ ssl . aes _ free ( decrypt _ ctx ) ;
} } } }
content - type : application / x - ns - proxy - autoconfig content - length : { encoding . ut . get _ bytes ( pac _ content ) . length } connection : close STR byte [ ] response = encoding . ut . get _ bytes ( response _ head + pac _ content ) ; socket . begin _ send ( response , 0 , response . length , 0 , new async _ callback ( send _ callback ) , socket ) ; utils . release _ memory ( true ) ; } catch ( exception e ) {
connection : close STR byte [ ] response = encoding . ut . get _ bytes ( response _ head + pac _ content ) ; socket . begin _ send ( response , 0 , response . length , 0 , new async _ callback ( send _ callback ) , socket ) ; utils . release _ memory ( true ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; socket . close ( ) ;
{ using ( var fs = new file _ stream ( path , file _ mode . open , file _ access . read , file _ share . read _ write ) ) using ( var sr = new stream _ reader ( fs , encoding ) ) { return sr . read _ to _ end ( ) ; } } catch ( exception ex ) { logging . error ( ex ) ;
} } } }
protected ulong encrypt _ ic ; protected ulong decrypt _ ic ; protected byte [ ] encrypt _ buf ; protected byte [ ] decrypt _ buf ; public sodium _ encryptor ( string method , string password ) : base ( method , password ) { init _ key ( method , password ) ; encrypt _ buf = new byte [ max _ input _ size + sodium _ block _ size ] ; decrypt _ buf = new byte [ max _ input _ size + sodium _ block _ size ] ;
ulong ic ; byte [ ] sodium _ buf ; byte [ ] iv ; if ( is _ cipher ) { bytes _ remaining = encrypt _ bytes _ remaining ; ic = encrypt _ ic ; sodium _ buf = encrypt _ buf ; iv = encrypt _ iv ; }
assembly _ assembly _ description assembly _ assembly _ configuration assembly _ assembly _ company _ clowwindy assembly _ assembly _ product _ shadowsocks assembly _ assembly _ copyright _ copyright _ clowwindy assembly _ assembly _ trademark assembly _ assembly _ culture assembly _ com _ visible _ false assembly _ guid _ bbd _ dcf assembly _ assembly _ version
assembly _ assembly _ copyright _ copyright _ clowwindy assembly _ assembly _ trademark assembly _ assembly _ culture assembly _ com _ visible _ false assembly _ guid _ bbd _ dcf assembly _ assembly _ version assembly _ assembly _ file _ version
using system _ collections _ generic ; using system _ io ; using system _ runtime _ interop _ services ; using system _ windows _ forms ; namespace shadowsocks _ csharp { static class program { dll _ import _ kernel _ dll private static extern int _ ptr load _ library ( string path ) ;
file _ stream fs = new file _ stream ( STR , file _ mode . append ) ; text _ writer tmp = console . out ; stream _ writer sw = new stream _ writer ( fs ) ; sw . auto _ flush = true ; console . set _ out ( sw ) ; console . set _ error ( sw ) ; } catch ( io _ exception e ) { console . write _ line ( e . to _ string ( ) ) ;
foreach ( string domain in domains ) { string last _ root _ domain = null ; int pos ; pos = domain . last _ index _ of ( '.' ) ; last _ root _ domain = domain . substring ( pos + 1 ) ; if ( ! tld _ index . contains ( last _ root _ domain ) ) continue ; while ( pos > 0 ) {
continue ; while ( pos > 0 ) { pos = domain . last _ index _ of ( '.' , pos - 1 ) ; last _ root _ domain = domain . substring ( pos + 1 ) ; if ( tld _ index . contains ( last _ root _ domain ) ) continue ; else break ; }
{ string [ ] tlds = get _ tlds ( ) ; tld _ index index = new tld _ index ( ) ; foreach ( string tld in tlds ) { index . add ( tld ) ; } return index ; } private string [ ] get _ build _ in ( )
foreach ( string tld in tlds ) { index . add ( tld ) ; } return index ; } private string [ ] get _ build _ in ( ) { string [ ] buildin = null ; byte [ ] builtin _ gz = resources . builtin _ txt ;
dic . add ( tld , tld ) ; } } public bool contains ( string tld ) { if ( dic . contains _ key ( tld ) ) return true ; foreach ( string pattern in patterns ) { if ( regex . is _ match ( tld , pattern ) )
} } } }
} } } public void update _ latency ( model . server server , time _ span latency ) { logging . debug ( $ STR ) ; server _ status status ; if ( server _ status . try _ get _ value ( server , out status ) ) { status . latency = latency ;
server _ status status ; if ( server _ status . try _ get _ value ( server , out status ) ) { status . latency = latency ; status . last _ time _ detect _ latency = date _ time . now ; } } public void update _ last _ read ( model . server server ) { logging . debug ( $ STR ) ;
server _ status status ; if ( server _ status . try _ get _ value ( server , out status ) ) { status . last _ read = date _ time . now ; } } public void update _ last _ write ( model . server server ) { logging . debug ( $ STR ) ; server _ status status ;
server _ status status ; if ( server _ status . try _ get _ value ( server , out status ) ) { status . last _ write = date _ time . now ; } } public void set _ failure ( model . server server ) { logging . debug ( $ STR ) ; server _ status status ;
server _ status status ; if ( server _ status . try _ get _ value ( server , out status ) ) { status . last _ failure = date _ time . now ; } } } }
{ logging . log _ useful _ exception ( e ) ; } return false ; } public static void uncompress _ file ( string file _ name , byte [ ] content ) { file _ stream destination _ file = file . create ( file _ name ) ;
} return false ; } public static void uncompress _ file ( string file _ name , byte [ ] content ) { file _ stream destination _ file = file . create ( file _ name ) ; byte [ ] buffer = new byte [ NUM ] ; int n ; using ( g _ zip _ stream input = new g _ zip _ stream ( new memory _ stream ( content ) , compression _ mode . decompress , false ) )
} public static void log _ useful _ exception ( exception e ) { if ( e is socket _ exception ) { socket _ exception se = ( socket _ exception ) e ; if ( se . socket _ error _ code = = socket _ error . connection _ aborted ) { } else if ( se . socket _ error _ code = = socket _ error . connection _ reset )
public log _ form ( shadowsocks _ controller controller , string filename ) { this . controller = controller ; this . filename = filename ; initialize _ component ( ) ; icon = icon . from _ handle ( resources . ssw . get _ hicon ( ) ) ; log _ viewer _ config config = controller . get _ configuration _ copy ( ) . log _ viewer ; top _ most _ trigger = config . top _ most ; wrap _ text _ trigger = config . wrap _ text ; toolbar _ trigger = config . toolbar _ shown ;
const long min _ scale = NUM ; long max _ speed = 0 ; long last _ inbound , last _ outbound ; lock ( this ) { if ( traffic . count = = 0 ) return ; foreach ( var traffic _ per _ second in traffic ) { inbound _ points . add ( traffic _ per _ second . inbound ) ;
} if ( max _ speed > 0 ) { last _ max _ speed - = last _ max _ speed / NUM ; max _ speed = math . max ( min _ scale , math . max ( max _ speed , last _ max _ speed ) ) ; last _ max _ speed = max _ speed ; } else { max _ speed = last _ max _ speed = min _ scale ;
if ( traffic _ chart . is _ handle _ created ) { traffic _ chart . series [ STR ] . points . data _ bind _ y ( inbound _ points ) ; traffic _ chart . series [ STR ] . points . data _ bind _ y ( outbound _ points ) ; traffic _ chart . chart _ areas [ 0 ] . axis _ y . label _ style . format = STR + bandwidth _ scale . unit _ name ; traffic _ chart . chart _ areas [ 0 ] . axis _ y . maximum = bandwidth _ scale . value ; inbound _ annotation . anchor _ data _ point = traffic _ chart . series [ STR ] . points . last ( ) ; inbound _ annotation . text = utils . format _ bandwidth ( last _ inbound ) ; outbound _ annotation . anchor _ data _ point = traffic _ chart . series [ STR ] . points . last ( ) ; outbound _ annotation . text = utils . format _ bandwidth ( last _ outbound ) ;
inbound _ annotation . anchor _ data _ point = traffic _ chart . series [ STR ] . points . last ( ) ; inbound _ annotation . text = utils . format _ bandwidth ( last _ inbound ) ; outbound _ annotation . anchor _ data _ point = traffic _ chart . series [ STR ] . points . last ( ) ; outbound _ annotation . text = utils . format _ bandwidth ( last _ outbound ) ; traffic _ chart . annotations . clear ( ) ; traffic _ chart . annotations . add ( inbound _ annotation ) ; traffic _ chart . annotations . add ( outbound _ annotation ) ; } } private void controller _ traffic _ changed ( object sender , event _ args e )
foreach ( var traffic _ per _ second in controller . traffic ) { traffic . enqueue ( new traffic _ info ( traffic _ per _ second . inbound _ increasement , traffic _ per _ second . outbound _ increasement ) ) ; } } } private void update _ texts ( ) { file _ menu _ item . text = n . get _ string ( STR ) ; open _ location _ menu _ item . text = n . get _ string ( STR ) ;
} } } private void update _ texts ( ) { file _ menu _ item . text = n . get _ string ( STR ) ; open _ location _ menu _ item . text = n . get _ string ( STR ) ; exit _ menu _ item . text = n . get _ string ( STR ) ; clean _ logs _ button . text = n . get _ string ( STR ) ; change _ font _ button . text = n . get _ string ( STR ) ;
} public static bandwidth _ scale _ info get _ bandwidth _ scale ( long n ) { long scale = 1 ; float f = n ; string unit = STR ; if ( f > NUM ) { f = f / NUM ; scale < < = NUM ;
{ long scale = 1 ; float f = n ; string unit = STR ; if ( f > NUM ) { f = f / NUM ; scale < < = NUM ; unit = STR ; }
using shadowsocks _ model ; using shadowsocks _ proxy ; using shadowsocks _ util _ sockets ; namespace shadowsocks _ controller { class tcp _ relay : listener . service { private shadowsocks _ controller controller ; private date _ time last _ sweep _ time ; private configuration config ;
{ public class socks _ proxy : i _ proxy { private class fake _ async _ result : i _ async _ result { public readonly socks _ state inner _ state ; private readonly i _ async _ result r ; public fake _ async _ result ( i _ async _ result orig , socks _ state state ) { r = orig ;
{ private class fake _ async _ result : i _ async _ result { public readonly socks _ state inner _ state ; private readonly i _ async _ result r ; public fake _ async _ result ( i _ async _ result orig , socks _ state state ) { r = orig ; inner _ state = state ; }
{ public class http _ proxy : i _ proxy { private class fake _ async _ result : i _ async _ result { public readonly http _ state inner _ state ; private readonly i _ async _ result r ; public fake _ async _ result ( i _ async _ result orig , http _ state state ) { r = orig ;
{ private class fake _ async _ result : i _ async _ result { public readonly http _ state inner _ state ; private readonly i _ async _ result r ; public fake _ async _ result ( i _ async _ result orig , http _ state state ) { r = orig ; inner _ state = state ; }
{ public interface i _ proxy { end _ point local _ end _ point { get ; } end _ point proxy _ end _ point { get ; } end _ point dest _ end _ point { get ; } void begin _ connect _ proxy ( end _ point remote _ ep , async _ callback callback , object state ) ; void end _ connect _ proxy ( i _ async _ result async _ result ) ; void begin _ connect _ dest ( end _ point dest _ end _ point , async _ callback callback , object state ) ; void end _ connect _ dest ( i _ async _ result async _ result ) ;
{ end _ point local _ end _ point { get ; } end _ point proxy _ end _ point { get ; } end _ point dest _ end _ point { get ; } void begin _ connect _ proxy ( end _ point remote _ ep , async _ callback callback , object state ) ; void end _ connect _ proxy ( i _ async _ result async _ result ) ; void begin _ connect _ dest ( end _ point dest _ end _ point , async _ callback callback , object state ) ; void end _ connect _ dest ( i _ async _ result async _ result ) ; void begin _ send ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) ;
{ public class direct _ connect : i _ proxy { private class fake _ async _ result : i _ async _ result { public fake _ async _ result ( object state ) { async _ state = state ; } public bool is _ completed { get ; } = true ;
{ private class fake _ async _ result : i _ async _ result { public fake _ async _ result ( object state ) { async _ state = state ; } public bool is _ completed { get ; } = true ; public wait _ handle async _ wait _ handle { get ; } = null ; public object async _ state { get ; }
public const string version = STR ; public void check _ update ( configuration config ) { web _ client http = new web _ client ( ) ; http . headers . add ( STR , STR ) ; http . proxy = new web _ proxy ( ip _ address . loopback . to _ string ( ) , config . local _ port ) ; http . download _ string _ completed + = http _ download _ string _ completed ; http . download _ string _ async ( new uri ( update _ url ) ) ; } public static int compare _ version ( string l , string r )
{ sort _ versions ( versions ) ; new _ version _ found = true ; latest _ version _ url = versions [ versions . count - 1 ] ; latest _ version _ number = parse _ version _ from _ url ( latest _ version _ url ) ; } if ( check _ update _ completed ! = null )
} if ( check _ update _ completed ! = null ) { check _ update _ completed ( this , new event _ args ( ) ) ; } }
{ check _ update _ completed ( this , new event _ args ( ) ) ; } } catch ( exception ex ) { logging . debug ( ex . to _ string ( ) ) ; return ; } }
} } catch ( exception ex ) { logging . debug ( ex . to _ string ( ) ) ; return ; } } } }
load _ current _ configuration ( ) ; configuration config = controller . get _ configuration _ copy ( ) ; if ( config . auto _ check _ update ) { is _ startup _ checking = true ; update _ checker . check _ update ( config ) ; } if ( config . is _ default )

using shadowsocks _ controller ; namespace shadowsocks _ encryption _ stream { public abstract class stream _ encryptor : encryptor _ base { protected static byte [ ] udp _ tmp _ buf = new byte [ NUM ] ; private byte _ circular _ buffer enc _ circular _ buffer = new byte _ circular _ buffer ( tcp _ handler . buffer _ size * 2 ) ; private byte _ circular _ buffer dec _ circular _ buffer = new byte _ circular _ buffer ( tcp _ handler . buffer _ size * 2 ) ; protected dictionary < string , encryptor _ info > ciphers ;
protected dictionary < string , encryptor _ info > ciphers ; protected byte [ ] encrypt _ iv ; protected byte [ ] decrypt _ iv ; protected bool decrypt _ iv _ received ; protected bool encrypt _ iv _ sent ; protected string method ; protected int cipher ; protected string inner _ lib _ name ; protected encryptor _ info cipher _ info ; protected static byte [ ] key = null ;
} private void ok _ button _ click ( object sender , event _ args e ) { if ( ! register _ all _ hotkeys ( out ) ) { message _ box . show ( n . get _ string ( STR ) ) ;
} save _ config ( ) ; this . close ( ) ; } private void register _ all _ button _ click ( object sender , event _ args e ) { register _ all _ hotkeys ( out ) ; } private bool register _ all _ hotkeys ( out string failure _ info _ str ) {
} private void register _ all _ button _ click ( object sender , event _ args e ) { register _ all _ hotkeys ( out ) ; } private bool register _ all _ hotkeys ( out string failure _ info _ str ) { bool is _ success = true ; string _ builder failure _ info = new string _ builder ( ) ; foreach ( var tb in all _ text _ boxes )
} private bool try _ reg _ hotkey ( text _ box tb ) { var hotkey = hot _ keys . str _ hot _ key ( tb . text ) ; if ( hotkey = = null ) { message _ box . show ( string . format ( n . get _ string ( STR ) , tb . text ) ) ; tb . clear ( ) ; return false ; }
lb . back _ color = reg _ result ? color . green : color . yellow ; return reg _ result ; } private static void unreg _ prev _ hotkey ( hot _ keys . hot _ key _ call _ back _ handler cb ) { global _ hot _ key . hot _ key prev _ hot _ key ; if ( hot _ keys . is _ callback _ exists ( cb , out prev _ hot _ key ) ) { hot _ keys . unregister ( prev _ hot _ key ) ; }
} } private void save _ config ( ) { modified _ hotkey _ config . switch _ system _ proxy = switch _ system _ proxy _ text _ box . text ; modified _ hotkey _ config . switch _ system _ proxy _ mode = switch _ proxy _ mode _ text _ box . text ; modified _ hotkey _ config . switch _ allow _ lan = switch _ allow _ lan _ text _ box . text ; modified _ hotkey _ config . show _ logs = show _ logs _ text _ box . text ; modified _ hotkey _ config . server _ move _ up = server _ move _ up _ text _ box . text ; modified _ hotkey _ config . server _ move _ down = server _ move _ down _ text _ box . text ;
} private void prepare _ for _ hotkey ( text _ box tb , out hot _ keys . hot _ key _ call _ back _ handler cb , out label lb ) { * xxx : the label _ name , text _ box _ name and callback _ name * must follow this rule to make use of reflection * * < base _ name > < control - type - name > * / if ( tb = = null ) throw new argument _ null _ exception ( nameof ( tb ) ) ;
} } }
public high _ availability _ strategy ( shadowsocks _ controller controller ) { controller = controller ; random = new random ( ) ; server _ status = new dictionary < server , server _ status > ( ) ; } public string name { get { return n . get _ string ( STR ) ; } }
} public server get _ a _ server ( i _ strategy _ caller _ type type , system . net . ip _ end _ point local _ ip _ end _ point ) { choose _ new _ server ( ) ; return current _ server ; } * once failed , try after NUM min * and ( last write - last read ) < NUM s * and ( now - last read ) < NUM s * and latency < NUM ms , try after NUM s
namespace shadowsocks _ model { serializable public class statistics _ strategy _ configuration { public static readonly string id = STR ; private bool statistics _ enabled = true ; private bool by _ isp = false ; private bool by _ hour _ of _ day = false ; private int choice _ kept _ minutes = NUM ;
{ var matches = url _ finder . matches ( ss _ url ) ; if ( matches . count < = 0 ) return null ; list < server > servers = new list < server > ( ) ; foreach ( match match in matches ) { server tmp = new server ( ) ; var base = match . groups [ STR ] . value ; var tag = match . groups [ STR ] . value ; if ( ! tag . is _ null _ or _ empty ( ) )
} public string identifier ( ) { return server + ':' + server _ port ; } } }
{ for ( int i = 0 ; i < length ; i + + ) { buf [ i ] = encrypt _ table [ buf [ i ] ] ; } } public void decrypt ( byte [ ] buf , int length ) { for ( int i = 0 ; i < length ; i + + ) {
{ buf [ i ] = encrypt _ table [ buf [ i ] ] ; } } public void decrypt ( byte [ ] buf , int length ) { for ( int i = 0 ; i < length ; i + + ) { buf [ i ] = decrypt _ table [ buf [ i ] ] ; }
{ for ( int i = 0 ; i < length ; i + + ) { buf [ i ] = decrypt _ table [ buf [ i ] ] ; } } } }
{ buf [ i ] = decrypt _ table [ buf [ i ] ] ; } } } }
using system _ net _ network _ information ; using system _ threading ; using shadowsocks _ model ; namespace shadowsocks _ controller _ strategy { class simply _ choose _ by _ statistics _ strategy : i _ strategy { private readonly shadowsocks _ controller controller ; private server current _ server ; private readonly timer timer ;
private server current _ server ; private readonly timer timer ; private dictionary < string , statistics _ data > statistics ; private const int cached _ interval = NUM * NUM * NUM ; private const int retry _ interval = 2 * NUM * NUM ; public simply _ choose _ by _ statistics _ strategy ( shadowsocks _ controller controller ) { controller = controller ; var servers = controller . get _ current _ configuration ( ) . configs ; var random _ index = new random ( ) . next ( ) % servers . count ( ) ;
public simply _ choose _ by _ statistics _ strategy ( shadowsocks _ controller controller ) { controller = controller ; var servers = controller . get _ current _ configuration ( ) . configs ; var random _ index = new random ( ) . next ( ) % servers . count ( ) ; current _ server = servers [ random _ index ] ; timer = new timer ( reload _ statistics _ and _ choose _ a _ server ) ; } private void reload _ statistics _ and _ choose _ a _ server ( object obj ) {
current _ server = servers [ random _ index ] ; timer = new timer ( reload _ statistics _ and _ choose _ a _ server ) ; } private void reload _ statistics _ and _ choose _ a _ server ( object obj ) { logging . debug ( STR ) ; var servers = controller . get _ current _ configuration ( ) . configs ; load _ statistics ( ) ; choose _ new _ server ( servers ) ; }
load _ statistics ( ) ; choose _ new _ server ( servers ) ; } return a dict : { ' server _ friendly _ name ' : statistics _ data , ' server _ friendly _ name ' : . . . } * / private void load _ statistics ( )
{ log _ when _ enabled ( $ STR ) ; } current _ server = best _ result . server ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; } }
} current _ server = best _ result . server ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; } } private void log _ when _ enabled ( string log ) {
{ if ( controller . get _ current _ strategy ( ) ? . id = = id ) { console . write _ line ( log ) ; } } public string id = > STR ; public string name = > n . get _ string ( STR ) ;
} public string id = > STR ; public string name = > n . get _ string ( STR ) ; public server get _ a _ server ( i _ strategy _ caller _ type type , ip _ end _ point local _ ip _ end _ point ) { var old _ server = current _ server ;
public server get _ a _ server ( i _ strategy _ caller _ type type , ip _ end _ point local _ ip _ end _ point ) { var old _ server = current _ server ; if ( old _ server = = null ) { choose _ new _ server ( controller . get _ current _ configuration ( ) . configs ) ; }
return current _ server ; } public void reload _ servers ( ) { choose _ new _ server ( controller . get _ current _ configuration ( ) . configs ) ; timer ? . change ( 0 , cached _ interval ) ; } public void set _ failure ( server server ) { logging . debug ( $ STR ) ;
} public void update _ last _ read ( server server ) { } public void update _ last _ write ( server server ) { } public void update _ latency ( server server , time _ span latency ) { }
is _ first _ run = false ; } if ( updated ) { show _ balloon _ tip ( n . get _ string ( STR ) , n . get _ string ( STR ) , tool _ tip _ icon . info , 0 ) ;
message _ box . show ( $ STR unexpected error , shadowsocks will exit . please report to STR , STR , message _ box _ buttons . ok , message _ box _ icon . error ) ; application . exit ( ) ; } } private static void application _ thread _ exception ( object sender , thread _ exception _ event _ args e ) { if ( interlocked . increment ( ref exited ) = = 1 ) {
} private static void system _ events _ power _ mode _ changed ( object sender , power _ mode _ changed _ event _ args e ) { switch ( e . mode ) { case power _ modes . resume : logging . info ( STR ) ; if ( controller ! = null ) { system . timers . timer timer = new system . timers . timer ( NUM * NUM ) ;
} public static bool is _ win _ vista _ or _ higher ( ) { return environment . os _ version . version . major > NUM ; } dll _ import _ kernel _ dll return _ marshal _ as _ unmanaged _ type _ bool private static extern bool set _ process _ working _ set _ size ( int _ ptr process , u _ int _ ptr minimum _ working _ set _ size , u _ int _ ptr maximum _ working _ set _ size ) ; } }
using shadowsocks _ model ; using shadowsocks _ util _ system _ proxy ; namespace shadowsocks _ controller { public static class system _ proxy {
namespace shadowsocks _ controller { public static class system _ proxy {
private static string get _ timestamp ( date _ time value ) { return value . to _ string ( STR ) ; } public static void update ( configuration config , bool force _ disable ) { bool global = config . global ; bool enabled = config . enabled ; if ( force _ disable ) {
} else { string pac _ url ; if ( config . use _ online _ pac & & ! config . pac _ url . is _ null _ or _ empty ( ) ) pac _ url = config . pac _ url ; else pac _ url = $ STR ; win _ i _ net . set _ ie _ proxy ( true , false , STR , pac _ url ) ;
} } else { win _ i _ net . set _ ie _ proxy ( false , false , STR , STR ) ;
} } } }
var default _ value = registry . get _ value ( STR ) ; try { var connections = registry . get _ value _ names ( ) ; foreach ( var each in connections ) { if ( ! ( each . equals ( STR ) | | each . equals ( STR ) | | each . equals ( STR ) ) ) {
{ if ( ! ( each . equals ( STR ) | | each . equals ( STR ) | | each . equals ( STR ) ) ) { registry . set _ value ( each , default _ value ) ; } } notify _ ie ( ) ; }
logging . log _ useful _ exception ( e ) ; } } private static void ie _ auto _ detect _ proxy ( bool set ) { var registry = registry . current _ user
} private static void ie _ auto _ detect _ proxy ( bool set ) { var registry = registry . current _ user . open _ sub _ key ( STR , true ) ; var def _ connection = ( byte [ ] ) registry . get _ value ( STR ) ; var saved _ legacy _ setting = ( byte [ ] ) registry . get _ value ( STR ) ;
if ( set ) { def _ connection [ NUM ] = ( byte ) ( def _ connection [ NUM ] | NUM ) ; saved _ legacy _ setting [ NUM ] = ( byte ) ( saved _ legacy _ setting [ NUM ] | NUM ) ; } else { def _ connection [ NUM ] = ( byte ) ( def _ connection [ NUM ] & ~ NUM ) ; saved _ legacy _ setting [ NUM ] = ( byte ) ( saved _ legacy _ setting [ NUM ] & ~ NUM ) ; }
} else { def _ connection [ NUM ] = ( byte ) ( def _ connection [ NUM ] & ~ NUM ) ; saved _ legacy _ setting [ NUM ] = ( byte ) ( saved _ legacy _ setting [ NUM ] & ~ NUM ) ; } bit _ converter . get _ bytes ( unchecked ( bit _ converter . to _ u _ int ( def _ connection , NUM ) + 1 ) ) . copy _ to ( def _ connection , NUM ) ; bit _ converter . get _ bytes ( unchecked ( bit _ converter . to _ u _ int ( saved _ legacy _ setting , NUM ) + 1 ) ) . copy _ to ( saved _ legacy _ setting , NUM ) ; registry . set _ value ( STR , def _ connection ) ; registry . set _ value ( STR , saved _ legacy _ setting ) ;
} bit _ converter . get _ bytes ( unchecked ( bit _ converter . to _ u _ int ( def _ connection , NUM ) + 1 ) ) . copy _ to ( def _ connection , NUM ) ; bit _ converter . get _ bytes ( unchecked ( bit _ converter . to _ u _ int ( saved _ legacy _ setting , NUM ) + 1 ) ) . copy _ to ( saved _ legacy _ setting , NUM ) ; registry . set _ value ( STR , def _ connection ) ; registry . set _ value ( STR , saved _ legacy _ setting ) ; } } }
return true ; } catch ( exception ex ) { console . write _ line ( STR , ex . to _ string ( ) ) ; } return false ; } public static void uncompress _ file ( string file _ name , byte [ ] content )
{ console . write _ line ( STR , ex . to _ string ( ) ) ; } return false ; } public static void uncompress _ file ( string file _ name , byte [ ] content ) { byte [ ] buffer = new byte [ NUM ] ;
} return false ; } public static void uncompress _ file ( string file _ name , byte [ ] content ) { byte [ ] buffer = new byte [ NUM ] ; int n ; using ( var fs = file . create ( file _ name ) ) using ( var input = new g _ zip _ stream (
byte [ ] buffer = new byte [ NUM ] ; int n ; using ( var fs = file . create ( file _ name ) ) using ( var input = new g _ zip _ stream ( new memory _ stream ( content ) , compression _ mode . decompress , false ) ) { while ( ( n = input . read ( buffer , 0 , buffer . length ) ) > 0 ) {
compression _ mode . decompress , false ) ) { while ( ( n = input . read ( buffer , 0 , buffer . length ) ) > 0 ) { fs . write ( buffer , 0 , n ) ; } } } }
} } } } }
} } }
this . table _ layout _ panel . suspend _ layout ( ) ; this . panel . suspend _ layout ( ) ; this . panel . suspend _ layout ( ) ; this . group _ box . suspend _ layout ( ) ; this . suspend _ layout ( ) ; this . table _ layout _ panel . auto _ size = true ; this . table _ layout _ panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . table _ layout _ panel . column _ count = 2 ;
this . suspend _ layout ( ) ; this . table _ layout _ panel . auto _ size = true ; this . table _ layout _ panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . table _ layout _ panel . column _ count = 2 ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , 0 ) ;
this . table _ layout _ panel . auto _ size = true ; this . table _ layout _ panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . table _ layout _ panel . column _ count = 2 ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , 0 ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , 1 ) ; this . table _ layout _ panel . controls . add ( this . proxy _ port _ text _ box , 1 , NUM ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , NUM ) ;
this . table _ layout _ panel . controls . add ( this . label , 0 , 0 ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , 1 ) ; this . table _ layout _ panel . controls . add ( this . proxy _ port _ text _ box , 1 , NUM ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , 2 ) ; this . table _ layout _ panel . controls . add ( this . ip _ text _ box , 1 , 0 ) ; this . table _ layout _ panel . controls . add ( this . server _ port _ text _ box , 1 , 1 ) ; this . table _ layout _ panel . controls . add ( this . password _ text _ box , 1 , 2 ) ;
this . table _ layout _ panel . controls . add ( this . label , 0 , 2 ) ; this . table _ layout _ panel . controls . add ( this . ip _ text _ box , 1 , 0 ) ; this . table _ layout _ panel . controls . add ( this . server _ port _ text _ box , 1 , 1 ) ; this . table _ layout _ panel . controls . add ( this . password _ text _ box , 1 , 2 ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . encryption _ select , 1 , NUM ) ; this . table _ layout _ panel . location = new system . drawing . point ( NUM , NUM ) ; this . table _ layout _ panel . margin = new system . windows . forms . padding ( NUM ) ; this . table _ layout _ panel . name = STR ;
this . table _ layout _ panel . controls . add ( this . ip _ text _ box , 1 , 0 ) ; this . table _ layout _ panel . controls . add ( this . server _ port _ text _ box , 1 , 1 ) ; this . table _ layout _ panel . controls . add ( this . password _ text _ box , 1 , 2 ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . encryption _ select , 1 , NUM ) ; this . table _ layout _ panel . location = new system . drawing . point ( NUM , NUM ) ; this . table _ layout _ panel . margin = new system . windows . forms . padding ( NUM ) ; this . table _ layout _ panel . name = STR ; this . table _ layout _ panel . padding = new system . windows . forms . padding ( NUM ) ; this . table _ layout _ panel . row _ count = NUM ;
this . table _ layout _ panel . name = STR ; this . table _ layout _ panel . padding = new system . windows . forms . padding ( NUM ) ; this . table _ layout _ panel . row _ count = NUM ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ; this . table _ layout _ panel . tab _ index = 0 ;
this . panel . auto _ size = true ; this . panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . panel . controls . add ( this . my _ cancel _ button ) ; this . panel . controls . add ( this . ok _ button ) ; this . panel . location = new system . drawing . point ( NUM , NUM ) ; this . panel . margin = new system . windows . forms . padding ( 0 ) ; this . panel . name = STR ; this . panel . size = new system . drawing . size ( NUM , NUM ) ; this . panel . tab _ index = 1 ; this . context _ menu . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] {
this . panel . name = STR ; this . panel . size = new system . drawing . size ( NUM , NUM ) ; this . panel . tab _ index = 1 ; this . context _ menu . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . enable _ item , this . config _ item , this . edit _ pac _ file _ item , this . about _ item , this . menu _ item , this . quit _ item } ) ;
this . suspend _ layout ( ) ; this . statistics _ chart . back _ color = system . drawing . color . transparent ; chart _ area . axis _ x . major _ grid . enabled = false ; chart _ area . axis _ y . major _ grid . enabled = false ; chart _ area . axis . major _ grid . enabled = false ; chart _ area . back _ color = system . drawing . color . transparent ; chart _ area . name = STR ; this . statistics _ chart . chart _ areas . add ( chart _ area ) ; this . statistics _ chart . dock = system . windows . forms . dock _ style . fill ; legend . back _ color = system . drawing . color . transparent ;
this . split _ container . tab _ index = NUM ; this . numeric _ up _ down . location = new system . drawing . point ( NUM , NUM ) ; this . numeric _ up _ down . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . numeric _ up _ down . maximum = new decimal ( new int [ ] { NUM , 0 , 0 , 0 } ) ; this . numeric _ up _ down . name = STR ; this . numeric _ up _ down . size = new system . drawing . size ( NUM , NUM ) ;
this . numeric _ up _ down . maximum = new decimal ( new int [ ] { NUM , 0 , 0 , 0 } ) ; this . numeric _ up _ down . name = STR ; this . numeric _ up _ down . size = new system . drawing . size ( NUM , NUM ) ; this . numeric _ up _ down . tab _ index = NUM ; this . numeric _ up _ down . value = new decimal ( new int [ ] { NUM ,
using system _ collections _ generic ; using system _ diagnostics ; using system _ io ; using system _ net ; using system _ net _ network _ information ; using system _ runtime _ interop _ services ; using system _ text ; using shadowsocks _ model ; using shadowsocks _ properties ;
using system _ text ; using shadowsocks _ model ; using shadowsocks _ properties ; using shadowsocks _ util ; namespace shadowsocks _ controller { class polipo _ runner
using shadowsocks _ util ; namespace shadowsocks _ controller { class polipo _ runner { private process process ; private int running _ port ; static polipo _ runner ( ) {
private int running _ port ; static polipo _ runner ( ) { try { file _ manager . uncompress _ file ( utils . get _ temp _ path ( STR ) , resources . privoxy _ exe ) ; file _ manager . uncompress _ file ( utils . get _ temp _ path ( STR ) , resources . mgwz _ dll ) ; } catch ( io _ exception e )
try { file _ manager . uncompress _ file ( utils . get _ temp _ path ( STR ) , resources . privoxy _ exe ) ; file _ manager . uncompress _ file ( utils . get _ temp _ path ( STR ) , resources . mgwz _ dll ) ; } catch ( io _ exception e ) { logging . log _ useful _ exception ( e ) ; } }
} catch ( io _ exception e ) { logging . log _ useful _ exception ( e ) ; } } public int running _ port { get {
process = new process ( ) ; process . start _ info . file _ name = STR ; process . start _ info . arguments = STR ; process . start _ info . working _ directory = utils . get _ temp _ path ( ) ; process . start _ info . window _ style = process _ window _ style . hidden ; process . start _ info . use _ shell _ execute = true ; process . start _ info . create _ no _ window = true ; process . start ( ) ;
process . start _ info . window _ style = process _ window _ style . hidden ; process . start _ info . use _ shell _ execute = true ; process . start _ info . create _ no _ window = true ; process . start ( ) ; } refresh _ tray _ area ( ) ; } public void stop ( ) { if ( process ! = null )
using shadowsocks _ properties ; using shadowsocks _ util ; namespace shadowsocks _ encryption { public class polar _ ssl
namespace shadowsocks _ encryption { public class polar _ ssl { const string dllname = STR ; public const int aes _ ctx _ size = NUM + NUM * NUM ; public const int aes _ encrypt = 1 ; public const int aes _ decrypt = 0 ; static polar _ ssl ( ) {
using system _ diagnostics ; using system _ io ; using system _ threading ; using system _ windows _ forms ; using shadowsocks _ controller ; using shadowsocks _ util ; using shadowsocks _ view ; namespace shadowsocks { static class program
using ( mutex mutex = new mutex ( false , STR + application . startup _ path . get _ hash _ code ( ) ) ) { application . enable _ visual _ styles ( ) ; application . set _ compatible _ text _ rendering _ default ( false ) ; if ( ! mutex . wait _ one ( 0 , false ) ) { process [ ] old _ processes = process . get _ processes _ by _ name ( STR ) ; if ( old _ processes . length > 0 ) { process old _ process = old _ processes [ 0 ] ;
using shadowsocks _ properties ; using shadowsocks _ util ; namespace shadowsocks _ encryption { public class sodium
namespace shadowsocks _ encryption { public class sodium { const string dllname = STR ; static sodium ( ) { string dll _ path = utils . get _ temp _ path ( STR ) ;
try { file _ manager . uncompress _ file ( dll _ path , resources . libsscrypto _ dll ) ; } catch ( io _ exception ) { } catch ( exception e ) { logging . log _ useful _ exception ( e ) ;
using shadowsocks _ properties ; using shadowsocks _ util ; namespace shadowsocks _ encryption { public class mbed _ tls
namespace shadowsocks _ encryption { public class mbed _ tls { const string dllname = STR ; static mbed _ tls ( ) { string dll _ path = utils . get _ temp _ path ( STR ) ;
try { file _ manager . uncompress _ file ( dll _ path , resources . libsscrypto _ dll ) ; } catch ( io _ exception ex ) { } catch ( exception e ) { console . write _ line ( e . to _ string ( ) ) ;
using system _ io ; using system _ net _ sockets ; using system _ net ; using shadowsocks _ util ; namespace shadowsocks _ controller { public class logging { public static string log _ file ;
namespace shadowsocks _ controller { public class logging { public static string log _ file ; public static bool open _ log _ file ( ) { try { log _ file = utils . get _ temp _ path ( STR ) ;
file _ stream fs = new file _ stream ( log _ file , file _ mode . append ) ; stream _ writer _ with _ timestamp sw = new stream _ writer _ with _ timestamp ( fs ) ; sw . auto _ flush = true ; console . set _ out ( sw ) ; console . set _ error ( sw ) ; return true ; } catch ( io _ exception e ) { console . write _ line ( e . to _ string ( ) ) ;
{ update _ pac _ from _ gfw _ list ( ) ; return ; } list < string > lines = gfw _ list _ updater . parse _ result ( file . read _ all _ text ( utils . get _ temp _ path ( STR ) ) ) ; if ( file . exists ( pac _ server . user _ rule _ file ) ) { string local = file . read _ all _ text ( pac _ server . user _ rule _ file , encoding . ut ) ; string [ ] rules = local . split ( new char [ ] { '\r' , '\n' } , string _ split _ options . remove _ empty _ entries ) ; foreach ( string rule in rules )
if ( file . exists ( pac _ server . user _ rule _ file ) ) { string local = file . read _ all _ text ( pac _ server . user _ rule _ file , encoding . ut ) ; string [ ] rules = local . split ( new char [ ] { '\r' , '\n' } , string _ split _ options . remove _ empty _ entries ) ; foreach ( string rule in rules ) { if ( rule . starts _ with ( STR ) | | rule . starts _ with ( STR ) ) continue ; lines . add ( rule ) ; }
using shadowsocks _ properties ; using shadowsocks _ util ; namespace shadowsocks _ controller { public class gfw _ list _ updater { private const string gfwlist _ url = STR ; private static string pac _ file = pac _ server . pac _ file ;
using shadowsocks _ util ; namespace shadowsocks _ controller { public class gfw _ list _ updater { private const string gfwlist _ url = STR ; private static string pac _ file = pac _ server . pac _ file ; private static string user _ rule _ file = pac _ server . user _ rule _ file ; private static string user _ abp _ file = pac _ server . user _ abp _ file ;
namespace shadowsocks _ controller { public class gfw _ list _ updater { private const string gfwlist _ url = STR ; private static string pac _ file = pac _ server . pac _ file ; private static string user _ rule _ file = pac _ server . user _ rule _ file ; private static string user _ abp _ file = pac _ server . user _ abp _ file ; public event event _ handler < result _ event _ args > update _ completed ; public event error _ event _ handler error ;
using system _ collections _ generic ; using system _ net ; using system _ text _ regular _ expressions ; using simple _ json ; using shadowsocks _ model ; using shadowsocks _ util ; namespace shadowsocks _ controller
using system _ text _ regular _ expressions ; using simple _ json ; using shadowsocks _ model ; using shadowsocks _ util ; namespace shadowsocks _ controller { public class update _ checker { private const string update _ url = STR ;
using simple _ json ; using shadowsocks _ model ; using shadowsocks _ util ; namespace shadowsocks _ controller { public class update _ checker { private const string update _ url = STR ; private const string user _ agent = STR ; private configuration config ;
{ if ( file . exists ( path . combine ( application . startup _ path , STR ) ) ) try { directory . create _ directory ( path . combine ( application . startup _ path , STR ) ) ; } catch ( exception e ) { temp _ path = path . get _ temp _ path ( ) ; logging . log _ useful _ exception ( e ) ;
} return temp _ path ; } public static string get _ temp _ path ( string filename ) { return path . combine ( get _ temp _ path ( ) , filename ) ; } public static void release _ memory ( bool remove _ pages ) {
} public static void release _ memory ( bool remove _ pages ) { gc . collect ( gc . max _ generation ) ; gc . wait _ for _ pending _ finalizers ( ) ; if ( remove _ pages ) { set _ process _ working _ set _ size ( process . get _ current _ process ( ) . handle , ( u _ int _ ptr ) 0 xffffffff , ( u _ int _ ptr ) 0 xffffffff ) ; }
traffic . enqueue ( current ) ; if ( traffic . count > queue _ max _ size ) traffic . dequeue ( ) ; traffic _ changed ? . invoke ( this , new event _ args ( ) ) ; thread . sleep ( NUM ) ; }
thread . sleep ( NUM ) ; } } } }
var remote = session . remote ; if ( bytes _ read > 0 ) { send _ to _ server ( bytes _ read , session ) ;
} else { remote . shutdown ( socket _ shutdown . send ) ; remote _ shutdown = true ; check _ close ( ) ; } } catch ( exception e ) {
{ i _ strategy strategy = get _ current _ strategy ( ) ; if ( strategy ! = null ) { return strategy . get _ a _ server ( type , local _ ip _ end _ point , dest _ end _ point ) ; } if ( config . index < 0 ) { config . index = 0 ; }
} if ( config . index < 0 ) { config . index = 0 ; } return get _ current _ server ( ) ; } public void save _ servers ( list < server > servers , int local _ port ) { config . configs = servers ;
{ * under portable _ mode , we could identify it by the path of ss _ privoxy . exe . * / var path = process . main _ module . file _ name ; return utils . get _ temp _ path ( STR ) . equals ( path ) ; } else
* / var path = process . main _ module . file _ name ; return utils . get _ temp _ path ( STR ) . equals ( path ) ; } else
return utils . get _ temp _ path ( STR ) . equals ( path ) ; } else
{ var cmd = process . get _ command _ line ( ) ; return cmd . contains ( unique _ config _ file ) ; } } catch ( exception ex ) { * sometimes process . get _ processes _ by _ name will return some processes that * are already dead , and that will cause exceptions here . * we could simply ignore those exceptions .
return false ; } } private int get _ free _ port ( ) { int default _ port = NUM ; try { ip _ global _ properties properties = ip _ global _ properties . get _ ip _ global _ properties ( ) ; ip _ end _ point [ ] tcp _ end _ points = properties . get _ active _ tcp _ listeners ( ) ;
if ( is _ cipher ) { encrypt _ iv _ offset = iv _ offset ; } else { decrypt _ iv _ offset = iv _ offset ; } break ; case cipher _ r :
{ run _ single _ polar _ ssl _ encryption _ thread ( ) ; list < thread > threads = new list < thread > ( ) ; for ( int i = 0 ; i < NUM ; i + + ) { thread t = new thread ( new thread _ start ( run _ single _ polar _ ssl _ encryption _ thread ) ) ; threads . add ( t ) ; t . start ( ) ; } foreach ( thread t in threads )
threads . add ( t ) ; t . start ( ) ; } foreach ( thread t in threads ) { t . join ( ) ; } assert . is _ false ( encryption _ failed ) ; } private static bool encryption _ failed = false ;
{ try { if ( last _ selected _ index = = - 1 | | last _ selected _ index > = modified _ configuration . configs . count ) { return true ; } server server = get _ server _ details _ from _ ui ( ) ;
configuration . check _ server ( server ) ; modified _ configuration . configs [ last _ selected _ index ] = server ; return true ; } catch ( exception ex ) { message _ box . show ( ex . message ) ;
modified _ configuration . configs [ last _ selected _ index ] = server ; return true ; } catch ( exception ex ) { message _ box . show ( ex . message ) ; } return false ;
return true ; } catch ( exception ex ) { message _ box . show ( ex . message ) ; } return false ; } private server get _ server _ details _ from _ ui ( ) {
{ if ( servers _ list _ box . selected _ index > = 0 & & servers _ list _ box . selected _ index < modified _ configuration . configs . count ) { server server = modified _ configuration . configs [ servers _ list _ box . selected _ index ] ; set _ server _ details _ to _ ui ( server ) ; } } private void set _ server _ details _ to _ ui ( server server ) { ip _ text _ box . text = server . server ;
{ servers _ list _ box . items . clear ( ) ; foreach ( server server in configuration . configs ) { servers _ list _ box . items . add ( server . friendly _ name ( ) ) ; } } private void load _ current _ configuration ( ) { modified _ configuration = controller . get _ configuration _ copy ( ) ;
{ servers _ list _ box . items . add ( server . friendly _ name ( ) ) ; } } private void load _ current _ configuration ( ) { modified _ configuration = controller . get _ configuration _ copy ( ) ; load _ server _ name _ list _ to _ ui ( modified _ configuration ) ; last _ selected _ index = modified _ configuration . index ; if ( last _ selected _ index < 0 | | last _ selected _ index > = servers _ list _ box . items . count )
last _ selected _ index = modified _ configuration . index ; if ( last _ selected _ index < 0 | | last _ selected _ index > = servers _ list _ box . items . count ) { last _ selected _ index = 0 ; } servers _ list _ box . selected _ index = last _ selected _ index ; update _ buttons ( ) ; load _ selected _ server _ details ( ) ; proxy _ port _ text _ box . text = modified _ configuration . local _ port . to _ string ( ) ;
portable _ mode _ check _ box . checked = modified _ configuration . portable _ mode ; } private void config _ form _ key _ down ( object sender , key _ event _ args e ) { if ( e . key _ code = = keys . enter ) { server server = controller . get _ current _ server ( ) ;
} private void config _ form _ key _ down ( object sender , key _ event _ args e ) { if ( e . key _ code = = keys . enter ) { server server = controller . get _ current _ server ( ) ; if ( ! validate _ and _ save _ selected _ server _ details ( ) ) { return ; }
{ return ; } if ( modified _ configuration . configs . count = = 0 ) { message _ box . show ( n . get _ string ( STR ) ) ; return ; } int local _ port = int . parse ( proxy _ port _ text _ box . text ) ; configuration . check _ local _ port ( local _ port ) ;
{ servers _ list _ box . selected _ index = last _ selected _ index ; return ; } if ( last _ selected _ index > = 0 ) { servers _ list _ box . items [ last _ selected _ index ] = modified _ configuration . configs [ last _ selected _ index ] . friendly _ name ( ) ; } update _ buttons ( ) ; load _ selected _ server _ details ( ) ;
last _ selected _ index = servers _ list _ box . selected _ index ; } private void add _ button _ click ( object sender , event _ args e ) { if ( ! validate _ and _ save _ selected _ server _ details ( ) ) { return ; } server server = configuration . get _ default _ server ( ) ; modified _ configuration . configs . add ( server ) ;
{ return ; } server server = configuration . get _ default _ server ( ) ; modified _ configuration . configs . add ( server ) ; load _ server _ name _ list _ to _ ui ( modified _ configuration ) ; servers _ list _ box . selected _ index = modified _ configuration . configs . count - 1 ; last _ selected _ index = servers _ list _ box . selected _ index ; } private void duplicate _ button _ click ( object sender , event _ args e )
servers _ list _ box . selected _ index = modified _ configuration . configs . count - 1 ; last _ selected _ index = servers _ list _ box . selected _ index ; } private void duplicate _ button _ click ( object sender , event _ args e ) { if ( ! validate _ and _ save _ selected _ server _ details ( ) ) { return ; } server curr _ server = modified _ configuration . configs [ last _ selected _ index ] ;
{ return ; } server curr _ server = modified _ configuration . configs [ last _ selected _ index ] ; var curr _ index = modified _ configuration . configs . index _ of ( curr _ server ) ; modified _ configuration . configs . insert ( curr _ index + 1 , curr _ server ) ; load _ server _ name _ list _ to _ ui ( modified _ configuration ) ; servers _ list _ box . selected _ index = curr _ index + 1 ; last _ selected _ index = servers _ list _ box . selected _ index ; }
servers _ list _ box . selected _ index = curr _ index + 1 ; last _ selected _ index = servers _ list _ box . selected _ index ; } private void delete _ button _ click ( object sender , event _ args e ) { last _ selected _ index = servers _ list _ box . selected _ index ; if ( last _ selected _ index > = 0 & & last _ selected _ index < modified _ configuration . configs . count ) { modified _ configuration . configs . remove _ at ( last _ selected _ index ) ; }
servers _ list _ box . selected _ index = last _ selected _ index ; load _ selected _ server _ details ( ) ; } private void ok _ button _ click ( object sender , event _ args e ) { if ( ! validate _ and _ save _ selected _ server _ details ( ) ) { return ; } if ( modified _ configuration . configs . count = = 0 )
} private void ok _ button _ click ( object sender , event _ args e ) { if ( ! validate _ and _ save _ selected _ server _ details ( ) ) { return ; } if ( modified _ configuration . configs . count = = 0 ) { message _ box . show ( n . get _ string ( STR ) ) ;
{ return ; } if ( modified _ configuration . configs . count = = 0 ) { message _ box . show ( n . get _ string ( STR ) ) ; return ; } int local _ port = int . parse ( proxy _ port _ text _ box . text ) ; configuration . check _ local _ port ( local _ port ) ;
} private void move _ up _ button _ click ( object sender , event _ args e ) { if ( ! validate _ and _ save _ selected _ server _ details ( ) ) { return ; } if ( servers _ list _ box . selected _ index > 0 ) { move _ config _ item ( - 1 ) ;
{ return ; } if ( servers _ list _ box . selected _ index > 0 ) { move _ config _ item ( - 1 ) ; } } private void move _ down _ button _ click ( object sender , event _ args e ) {
{ const int cipher _ aes = 1 ; const int cipher _ r = 2 ;
private int _ ptr encrypt _ ctx = int _ ptr . zero ; private int _ ptr decrypt _ ctx = int _ ptr . zero ; public polar _ ssl _ encryptor ( string method , string password )
public polar _ ssl _ encryptor ( string method , string password ) : base ( method , password ) { init _ key ( method , password ) ; } protected override dictionary < string , int [ ] > get _ ciphers ( ) { return new dictionary < string , int [ ] > { { STR , new int [ ] { NUM , NUM , cipher _ aes , polar _ ssl . aes _ ctx _ size } } , { STR , new int [ ] { NUM , NUM , cipher _ aes , polar _ ssl . aes _ ctx _ size } } ,
{ return new dictionary < string , int [ ] > { { STR , new int [ ] { NUM , NUM , cipher _ aes , polar _ ssl . aes _ ctx _ size } } , { STR , new int [ ] { NUM , NUM , cipher _ aes , polar _ ssl . aes _ ctx _ size } } , { STR , new int [ ] { NUM , NUM , cipher _ aes , polar _ ssl . aes _ ctx _ size } } , { STR , new int [ ] { NUM , 0 , cipher _ r , polar _ ssl . ar _ ctx _ size } } , { STR , new int [ ] { NUM , NUM , cipher _ r , polar _ ssl . ar _ ctx _ size } } , } ;
} protected override void init _ cipher ( byte [ ] iv , bool is _ cipher ) { base . init _ cipher ( iv , is _ cipher ) ; int _ ptr ctx ; ctx = marshal . alloc _ h _ global ( cipher _ info [ NUM ] ) ; if ( is _ cipher ) { encrypt _ ctx = ctx ;
{ base . init _ cipher ( iv , is _ cipher ) ; int _ ptr ctx ; ctx = marshal . alloc _ h _ global ( cipher _ info [ NUM ] ) ; if ( is _ cipher ) { encrypt _ ctx = ctx ;
{ encrypt _ ctx = ctx ;
} else { decrypt _ ctx = ctx ; }
} byte [ ] realkey ; if ( method = = STR ) { byte [ ] temp = new byte [ key _ len + iv _ len ] ; realkey = new byte [ key _ len ] ;
byte [ ] realkey ; if ( method = = STR ) { byte [ ] temp = new byte [ key _ len + iv _ len ] ; realkey = new byte [ key _ len ] ; array . copy ( key , 0 , temp , 0 , key _ len ) ; array . copy ( iv , 0 , temp , key _ len , iv _ len ) ; realkey = m . create ( ) . compute _ hash ( temp ) ; } else
} else if ( cipher = = cipher _ r ) { polar _ ssl . arc _ init ( ctx ) ; polar _ ssl . arc _ setup ( ctx , realkey , key _ len ) ; } } protected override void cipher _ update ( bool is _ cipher , int length , byte [ ] buf , byte [ ] outbuf )
{ if ( disposed ) { throw new object _ disposed _ exception ( this . to _ string ( ) ) ; } byte [ ] iv ; int iv _ offset ; if ( is _ cipher ) {
{ throw new object _ disposed _ exception ( this . to _ string ( ) ) ; } byte [ ] iv ; int iv _ offset ; if ( is _ cipher ) { iv = encrypt _ iv ; iv _ offset = encrypt _ iv _ offset ;
} else { iv = decrypt _ iv ; iv _ offset = decrypt _ iv _ offset ;
} switch ( cipher ) { case cipher _ aes : polar _ ssl . aes _ crypt _ cfb ( encrypt _ ctx , is _ cipher ? polar _ ssl . aes _ encrypt : polar _ ssl . aes _ decrypt , length , ref iv _ offset , iv , buf , outbuf ) ; if ( is _ cipher )
{ case cipher _ aes : polar _ ssl . aes _ crypt _ cfb ( encrypt _ ctx , is _ cipher ? polar _ ssl . aes _ encrypt : polar _ ssl . aes _ decrypt , length , ref iv _ offset , iv , buf , outbuf ) ; if ( is _ cipher )
{ encrypt _ iv _ offset = iv _ offset ; } else { decrypt _ iv _ offset = iv _ offset ;
} else { decrypt _ iv _ offset = iv _ offset ;
{ decrypt _ iv _ offset = iv _ offset ; } break ;
} break ; case cipher _ r : polar _ ssl . arc _ crypt ( encrypt _ ctx , length , buf , outbuf ) ; break ;
} } private bool disposed ; public override void dispose ( ) { dispose ( true ) ; gc . suppress _ finalize ( this ) ; } ~ polar _ ssl _ encryptor ( ) {
file _ manager . uncompress _ file ( dll _ path , resources . polarssl _ dll ) ; } catch ( io _ exception e ) { console . write _ line ( e . to _ string ( ) ) ; } load _ library ( dll _ path ) ; try { file _ stream fs = new file _ stream ( STR , file _ mode . append ) ;
file _ stream fs = new file _ stream ( STR , file _ mode . append ) ; text _ writer tmp = console . out ; stream _ writer sw = new stream _ writer ( fs ) ; sw . auto _ flush = true ; console . set _ out ( sw ) ; console . set _ error ( sw ) ; } catch ( io _ exception e ) { console . write _ line ( e . to _ string ( ) ) ;
{ return file . read _ all _ text ( pac _ file , encoding . ut ) ; } else { byte [ ] pac _ gz = resources . proxy _ pac _ txt ; byte [ ] buffer = new byte [ NUM * NUM ] ; int n ; using ( g _ zip _ stream input = new g _ zip _ stream ( new memory _ stream ( pac _ gz ) , compression _ mode . decompress , false ) )
{ n = input . read ( buffer , 0 , buffer . length ) ; if ( n = = 0 ) { throw new io _ exception ( STR ) ; } return system . text . encoding . ut . get _ string ( buffer , 0 , n ) ; } }
} } } private void receive _ callback ( i _ async _ result ar ) { socket conn = ( socket ) ar . async _ state ; try { int bytes _ read = conn . end _ receive ( ar ) ;
} } private void receive _ callback ( i _ async _ result ar ) { socket conn = ( socket ) ar . async _ state ; try { int bytes _ read = conn . end _ receive ( ar ) ; string pac = get _ pac _ content ( ) ; string proxy = STR ;
update _ system _ proxy ( ) ; } public void save _ config ( config new _ config ) { config . save ( new _ config ) ; config = new _ config ; local . stop ( ) ; polipo _ runner . stop ( ) ; polipo _ runner . start ( config ) ; local = new local ( config ) ;
this . about _ item . text = STR ; this . about _ item . click + = new system . event _ handler ( this . about _ tool _ strip _ menu _ item _ click ) ; this . menu _ item . index = NUM ; this . menu _ item . text = STR ; this . quit _ item . index = NUM ; this . quit _ item . text = STR ; this . quit _ item . click + = new system . event _ handler ( this . quit _ click ) ; this . edit _ pac _ file _ item . index = 2 ; this . edit _ pac _ file _ item . text = STR ; this . edit _ pac _ file _ item . click + = new system . event _ handler ( this . edit _ pac _ file _ item _ click ) ;
{ STR , new int [ ] { NUM , NUM , cipher _ aes , polar _ ssl . aes _ ctx _ size } } , { STR , new int [ ] { NUM , NUM , cipher _ aes , polar _ ssl . aes _ ctx _ size } } , { STR , new int [ ] { NUM , NUM , cipher _ aes , polar _ ssl . aes _ ctx _ size } } , { STR , new int [ ] { NUM , 0 , cipher _ r , polar _ ssl . ar _ ctx _ size } } , { STR , new int [ ] { NUM , NUM , cipher _ r , polar _ ssl . ar _ ctx _ size } } , } ; public static list < string > supported _ ciphers ( ) { return new list < string > ( ciphers . keys ) ; }
} protected override void init _ cipher ( byte [ ] iv , bool is _ cipher ) { base . init _ cipher ( iv , is _ cipher ) ; int _ ptr ctx ; ctx = marshal . alloc _ h _ global ( cipher _ info [ NUM ] ) ; if ( is _ cipher ) { encrypt _ ctx = ctx ; }
} protected override void cipher _ update ( bool is _ cipher , int length , byte [ ] buf , byte [ ] outbuf ) { int bytes _ remaining ; ulong ic ; byte [ ] sodium _ buf ; byte [ ] iv ; if ( is _ cipher ) { bytes _ remaining = encrypt _ bytes _ remaining ;
{ method = STR ; } method = method . to _ lower _ invariant ( ) ; type t = registered _ encryptors [ method ] ; constructor _ info c = t . get _ constructor ( constructor _ types ) ; i _ encryptor result = ( i _ encryptor ) c . invoke ( new object [ ] { method , password } ) ; return result ; }
} method = method . to _ lower _ invariant ( ) ; type t = registered _ encryptors [ method ] ; constructor _ info c = t . get _ constructor ( constructor _ types ) ; i _ encryptor result = ( i _ encryptor ) c . invoke ( new object [ ] { method , password } ) ; return result ; } } }
} } }
this . btn _ ok . name = STR ; this . btn _ ok . size = new system . drawing . size ( NUM , NUM ) ; this . btn _ ok . tab _ index = 0 ; this . btn _ ok . text = STR ; this . btn _ ok . use _ visual _ style _ back _ color = true ; this . btn _ ok . click + = new system . event _ handler ( this . ok _ button _ click ) ; this . btn _ cancel . dialog _ result = system . windows . forms . dialog _ result . cancel ; this . btn _ cancel . location = new system . drawing . point ( NUM , NUM ) ; this . btn _ cancel . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . btn _ cancel . name = STR ;
this . btn _ cancel . name = STR ; this . btn _ cancel . size = new system . drawing . size ( NUM , NUM ) ; this . btn _ cancel . tab _ index = 1 ; this . btn _ cancel . text = STR ; this . btn _ cancel . use _ visual _ style _ back _ color = true ; this . btn _ cancel . click + = new system . event _ handler ( this . cancel _ button _ click ) ; this . btn _ register _ all . dialog _ result = system . windows . forms . dialog _ result . cancel ; this . btn _ register _ all . location = new system . drawing . point ( NUM , NUM ) ; this . btn _ register _ all . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . btn _ register _ all . name = STR ;
this . btn _ register _ all . name = STR ; this . btn _ register _ all . size = new system . drawing . size ( NUM , NUM ) ; this . btn _ register _ all . tab _ index = 2 ; this . btn _ register _ all . text = STR ; this . btn _ register _ all . use _ visual _ style _ back _ color = true ; this . btn _ register _ all . click + = new system . event _ handler ( this . register _ all _ button _ click ) ; this . table _ layout _ panel . column _ count = 2 ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . controls . add ( this . reg _ hotkeys _ at _ startup _ label , 0 , NUM ) ;
using system _ drawing ; using system _ text ; using system _ windows _ forms ; using static shadowsocks . controller . hotkey _ reg ; namespace shadowsocks _ view {
using system _ text ; using system _ windows _ forms ; using static shadowsocks . controller . hotkey _ reg ; namespace shadowsocks _ view { public partial class hotkey _ settings _ form : form {
using static shadowsocks . controller . hotkey _ reg ; namespace shadowsocks _ view { public partial class hotkey _ settings _ form : form { private readonly shadowsocks _ controller controller ; private hotkey _ config modified _ hotkey _ config ; public hotkey _ settings _ form ( shadowsocks _ controller controller ) { initialize _ component ( ) ;
using system _ globalization ; using system _ io ; using shadowsocks _ properties ; using shadowsocks _ util ; using system _ windows _ forms ; using microsoft _ visual _ basic _ file _ io ; namespace shadowsocks _ controller { public static class n
public static class n { private static dictionary < string , string > strings = new dictionary < string , string > ( ) ; private static void init ( string res , string locale ) { using ( text _ field _ parser csv _ parser = new text _ field _ parser ( new string _ reader ( res ) ) ) { csv _ parser . set _ delimiters ( STR ) ; string [ ] locale _ names = csv _ parser . read _ fields ( ) ; int en _ index = 0 ;
{ using ( text _ field _ parser csv _ parser = new text _ field _ parser ( new string _ reader ( res ) ) ) { csv _ parser . set _ delimiters ( STR ) ; string [ ] locale _ names = csv _ parser . read _ fields ( ) ; int en _ index = 0 ; int target _ index = 0 ; for ( int i = 1 ; i < locale _ names . length ; i + + ) {
{ csv _ parser . set _ delimiters ( STR ) ; string [ ] locale _ names = csv _ parser . read _ fields ( ) ; int en _ index = 0 ; int target _ index = 0 ; for ( int i = 1 ; i < locale _ names . length ; i + + ) { if ( locale _ names [ i ] = = STR ) {
{ if ( locale _ names [ i ] = = STR ) { } if ( locale _ names [ i ] = = locale ) { target _ index = i ; } } while ( ! csv _ parser . end _ of _ data )
} } } static n ( ) { init ( resources . n _ csv , culture _ info . current _ culture . ietf _ language _ tag ) ;
} public static string get _ string ( string key , params object [ ] args ) { return string . format ( strings . try _ get _ value ( key , out var value ) ? value : key , args ) ; } public static void translate _ form ( form c ) { c . text = get _ string ( c . text ) ; foreach ( var item in view _ utils . get _ child _ controls < control > ( c ) ) {
namespace shadowsocks _ view { public partial class config _ form : form { private shadowsocks _ controller controller ; private configuration modified _ configuration ; private int last _ selected _ index = - 1 ; private bool is _ change = false ; public config _ form ( shadowsocks _ controller controller ) {
tool _ tip . set _ tool _ tip ( portable _ mode _ check _ box , n . get _ string ( STR ) ) ;
} private void setup _ value _ changed _ listeners ( ) { ip _ text _ box . text _ changed + = config _ value _ changed ; proxy _ port _ text _ box . text _ changed + = config _ value _ changed ; password _ text _ box . text _ changed + = config _ value _ changed ; encryption _ select . selected _ index _ changed + = config _ value _ changed ; plugin _ text _ box . text _ changed + = config _ value _ changed ; plugin _ arguments _ text _ box . text _ changed + = config _ value _ changed ; plugin _ options _ text _ box . text _ changed + = config _ value _ changed ;
using shadowsocks _ view ; namespace shadowsocks _ controller _ hotkeys { public class hotkey _ callbacks { public static void init _ instance ( shadowsocks _ controller controller ) { if ( instance ! = null ) {
public static void init _ instance ( shadowsocks _ controller controller ) { if ( instance ! = null ) { return ; } instance = new hotkey _ callbacks ( controller ) ; } public static delegate get _ callback ( string methodname ) {
using shadowsocks _ model ; using timer = system . threading . timer ; namespace shadowsocks _ controller _ strategy { using data _ unit = key _ value _ pair < string , string > ; using data _ list = list < key _ value _ pair < string , string > > ; class statistics _ strategy : i _ strategy { private readonly shadowsocks _ controller controller ; private server current _ server ;
public statistics _ strategy ( shadowsocks _ controller controller ) { controller = controller ; var servers = controller . get _ current _ configuration ( ) . configs ; var random _ index = new random ( ) . next ( ) % servers . count ( ) ; current _ server = servers [ random _ index ] ; timer = new timer ( reload _ statistics _ and _ choose _ a _ server ) ; } private void reload _ statistics _ and _ choose _ a _ server ( object obj ) {
private void load _ statistics ( ) { try { var path = availability _ statistics . availability _ statistics _ file ; logging . debug ( $ STR ) ; if ( ! file . exists ( path ) ) { log _ when _ enabled ( $ STR ) ; timer . change ( retry _ interval , choice _ kept _ milliseconds ) ;
return ; } raw _ statistics = ( from l in file . read _ all _ lines ( path ) . skip ( 1 ) let strings = l . split ( new [ ] { STR } , string _ split _ options . remove _ empty _ entries ) let raw _ data = new statistics _ raw _ data { timestamp = strings [ 0 ] , server _ name = strings [ 1 ] , icmp _ status = strings [ 2 ] ,
} catch ( exception e ) { logging . log _ useful _ exception ( e ) ; } } private float get _ score ( i _ enumerable < statistics _ raw _ data > raw _ data _ list ) { var config = controller . statistics _ configuration ; if ( config . by _ isp )
} public class statistics _ data { public float package _ loss ; public int average _ response ; public int min _ response ; public int max _ response ; }
public int average _ response ; public int min _ response ; public int max _ response ; } private void choose _ new _ server ( list < server > servers ) { if ( raw _ statistics = = null | | servers . count = = 0 ) { return ; }
{ return ; } try { var best _ result = ( from server in servers let name = server . friendly _ name ( ) where raw _ statistics . contains _ key ( name ) select new {
select new { server , score = get _ score ( raw _ statistics [ name ] ) } ) . aggregate ( ( result , result ) = > result . score > result . score ? result : result ) ; if ( ! current _ server . equals ( best _ result . server ) ) { log _ when _ enabled ( $ STR ) ; }
} ) . aggregate ( ( result , result ) = > result . score > result . score ? result : result ) ; if ( ! current _ server . equals ( best _ result . server ) ) { log _ when _ enabled ( $ STR ) ; } current _ server = best _ result . server ; } catch ( exception e ) {
{ initialize _ component ( ) ; value _ label . text = text ; factor _ num . value = ( decimal ) value ; } public string value = > value _ label . text ; public float factor = > ( float ) factor _ num . value ; } }
} public string value = > value _ label . text ; public float factor = > ( float ) factor _ num . value ; } }
} }
this . statistics _ chart = new system . windows . forms . data _ visualization . charting . chart ( ) ; this . by _ isp _ check _ box = new system . windows . forms . check _ box ( ) ; this . binding _ configuration = new system . windows . forms . binding _ source ( this . components ) ; this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ; this . group _ box = new system . windows . forms . group _ box ( ) ; this . radio _ button = new system . windows . forms . radio _ button ( ) ; this . radio _ button = new system . windows . forms . radio _ button ( ) ; this . split _ container = new system . windows . forms . split _ container ( ) ;
( ( system . component _ model . i _ support _ initialize ) ( this . statistics _ chart ) ) . begin _ init ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . binding _ configuration ) ) . begin _ init ( ) ; this . group _ box . suspend _ layout ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . begin _ init ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . suspend _ layout ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . begin _ init ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . panel . suspend _ layout ( ) ;
series . legend = STR ; series . name = STR ; series . y _ values _ per _ point = NUM ; series . border _ width = NUM ; series . chart _ area = STR ; series . chart _ type = system . windows . forms . data _ visualization . charting . series _ chart _ type . line ; series . color = system . drawing . color . from _ argb ( ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) , ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) , ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) ) ; series . legend = STR ; series . name = STR ;
series . chart _ area = STR ; series . chart _ type = system . windows . forms . data _ visualization . charting . series _ chart _ type . line ; series . color = system . drawing . color . from _ argb ( ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) , ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) , ( ( int ) ( ( ( byte ) ( NUM ) ) ) ) ) ; series . legend = STR ; series . name = STR ;
series . legend = STR ; series . name = STR ; this . statistics _ chart . series . add ( series ) ;
this . statistics _ chart . series . add ( series ) ; this . statistics _ chart . series . add ( series ) ; this . statistics _ chart . size = new system . drawing . size ( NUM , NUM ) ; this . statistics _ chart . tab _ index = 2 ; this . by _ isp _ check _ box . auto _ size = true ; this . by _ isp _ check _ box . data _ bindings . add ( new system . windows . forms . binding ( STR , this . binding _ configuration , STR , true ) ) ; this . by _ isp _ check _ box . location = new system . drawing . point ( NUM , NUM ) ; this . by _ isp _ check _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . by _ isp _ check _ box . name = STR ;
this . statistics _ chart . tab _ index = 2 ; this . by _ isp _ check _ box . auto _ size = true ; this . by _ isp _ check _ box . data _ bindings . add ( new system . windows . forms . binding ( STR , this . binding _ configuration , STR , true ) ) ; this . by _ isp _ check _ box . location = new system . drawing . point ( NUM , NUM ) ; this . by _ isp _ check _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . by _ isp _ check _ box . name = STR ; this . by _ isp _ check _ box . size = new system . drawing . size ( NUM , NUM ) ; this . by _ isp _ check _ box . tab _ index = NUM ; this . by _ isp _ check _ box . text = STR ; this . by _ isp _ check _ box . use _ visual _ style _ back _ color = true ;
using shadowsocks _ util ; using timer = system . threading . timer ; namespace shadowsocks _ controller { using data _ unit = key _ value _ pair < string , string > ; using data _ list = list < key _ value _ pair < string , string > > ; internal class availability _ statistics { public static readonly string date _ time _ pattern = STR ; private const string statistics _ files _ name = STR ;
private timer timer ; private state state ; private list < server > servers ; private statistics _ strategy _ configuration config ; public static string availability _ statistics _ file ; static availability _ statistics ( ) { var temppath = utils . get _ temp _ path ( ) ; availability _ statistics _ file = path . combine ( temppath , statistics _ files _ name ) ; }
availability _ statistics _ file = path . combine ( temppath , statistics _ files _ name ) ; } public availability _ statistics ( configuration config , statistics _ strategy _ configuration statistics _ config ) { update _ configuration ( config , statistics _ config ) ; } public bool set ( statistics _ strategy _ configuration config ) { config = config ; try
{ update _ configuration ( config , statistics _ config ) ; } public bool set ( statistics _ strategy _ configuration config ) { config = config ; try { if ( config . statistics _ enabled ) {
{ if ( timer ? . change ( delay _ before _ start , interval ) = = null ) { state = new state ( ) ; timer = new timer ( evaluate , state , delay _ before _ start , interval ) ; } } else { timer ? . dispose ( ) ;
{ state = new state ( ) ; timer = new timer ( evaluate , state , delay _ before _ start , interval ) ; } } else { timer ? . dispose ( ) ; } return true ;
} } else { timer ? . dispose ( ) ; } return true ; } catch ( exception e ) {
{ logging . debug ( STR + server . friendly _ name ( ) ) ; if ( server . server = = STR ) return null ; var ip = dns . get _ host _ addresses ( server . server ) . first ( ip = > ip . address _ family = = address _ family . inter _ network ) ; var ping = new ping ( ) ; var ret = new list < data _ list > ( ) ; foreach ( var timestamp in enumerable . range ( 0 , repeat ) . select ( = > date _ time . now . to _ string ( date _ time _ pattern ) ) ) { try
{ try { var reply = ping . send ( ip , timeout ) ; ret . add ( new list < key _ value _ pair < string , string > > { new key _ value _ pair < string , string > ( STR , timestamp ) , new key _ value _ pair < string , string > ( STR , server . friendly _ name ( ) ) , new key _ value _ pair < string , string > ( STR , reply ? . status . to _ string ( ) ) , new key _ value _ pair < string , string > ( STR , reply ? . roundtrip _ time . to _ string ( ) )
ret . add ( new list < key _ value _ pair < string , string > > { new key _ value _ pair < string , string > ( STR , timestamp ) , new key _ value _ pair < string , string > ( STR , server . friendly _ name ( ) ) , new key _ value _ pair < string , string > ( STR , reply ? . status . to _ string ( ) ) , new key _ value _ pair < string , string > ( STR , reply ? . roundtrip _ time . to _ string ( ) ) } ) ; thread . sleep ( new random ( ) . next ( ) % timeout ) ; } catch ( exception e )
} internal void update _ configuration ( configuration config , statistics _ strategy _ configuration statistics _ config ) { set ( statistics _ config ) ; servers = config . configs ; } public class state { public data _ list data _ list = new data _ list ( ) ; public const string geolocation = STR ;
{ set ( statistics _ config ) ; servers = config . configs ; } public class state { public data _ list data _ list = new data _ list ( ) ; public const string geolocation = STR ; public const string isp = STR ; public const string unknown = STR ;
servers = config . configs ; } public class state { public data _ list data _ list = new data _ list ( ) ; public const string geolocation = STR ; public const string isp = STR ; public const string unknown = STR ; } }
{ public data _ list data _ list = new data _ list ( ) ; public const string geolocation = STR ; public const string isp = STR ; public const string unknown = STR ; } } }
try { ss _ url _ association = registry . current _ user . create _ sub _ key ( STR , registry _ key _ permission _ check . read _ write _ sub _ tree ) ; if ( ss _ url _ association = = null ) { logger . error ( STR ) ;
{ logger . error ( STR ) ; return false ; } if ( enabled ) { ss _ url _ association . set _ value ( STR , STR ) ; ss _ url _ association . set _ value ( STR , STR ) ; var shell _ open = ss _ url _ association . create _ sub _ key ( STR ) . create _ sub _ key ( STR ) . create _ sub _ key ( STR ) ; shell _ open . set _ value ( STR , $ STR ) ;
shell _ open . set _ value ( STR , $ STR ) ; logger . info ( STR ) ; } else { registry . current _ user . delete _ sub _ key _ tree ( STR ) ; logger . info ( STR ) ; } return true ;
} return true ; } catch ( exception e ) { logger . log _ useful _ exception ( e ) ; return false ; } finally {
} catch ( exception e ) { logger . log _ useful _ exception ( e ) ; } } } } public static bool check ( ) { registry _ key ss _ url _ association = null ; try
try { ss _ url _ association = registry . current _ user . open _ sub _ key ( STR , true ) ; if ( ss _ url _ association = = null ) { return false ; } var shell _ open = ss _ url _ association . open _ sub _ key ( STR ) . open _ sub _ key ( STR ) . open _ sub _ key ( STR ) ; return ( string ) shell _ open . get _ value ( STR ) = = $ STR ;
{ return false ; } var shell _ open = ss _ url _ association . open _ sub _ key ( STR ) . open _ sub _ key ( STR ) . open _ sub _ key ( STR ) ; return ( string ) shell _ open . get _ value ( STR ) = = $ STR ; } catch ( exception e ) { logger . log _ useful _ exception ( e ) ;
return false ; } var shell _ open = ss _ url _ association . open _ sub _ key ( STR ) . open _ sub _ key ( STR ) . open _ sub _ key ( STR ) ; return ( string ) shell _ open . get _ value ( STR ) = = $ STR ; } catch ( exception e ) { logger . log _ useful _ exception ( e ) ; return false ; }
return ( string ) shell _ open . get _ value ( STR ) = = $ STR ; } catch ( exception e ) { logger . log _ useful _ exception ( e ) ; return false ; } finally { if ( ss _ url _ association ! = null )
} catch ( exception e ) { logger . log _ useful _ exception ( e ) ; } } } } } }
assembly _ assembly _ product _ shadowsocks _ csharp assembly _ assembly _ copyright _ copyright _ clowwindy assembly _ assembly _ trademark assembly _ assembly _ culture assembly _ com _ visible _ false assembly _ guid _ bbd _ dcf assembly _ assembly _ version assembly _ assembly _ file _ version
assembly _ assembly _ trademark assembly _ assembly _ culture assembly _ com _ visible _ false assembly _ guid _ bbd _ dcf assembly _ assembly _ version assembly _ assembly _ file _ version
{ gc . collect ( gc . max _ generation ) ; gc . wait _ for _ pending _ finalizers ( ) ; if ( remove _ pages ) { set _ process _ working _ set _ size ( process . get _ current _ process ( ) . handle , ( u _ int _ ptr ) 0 xffffffff , ( u _ int _ ptr ) 0 xffffffff ) ; } } public static string un _ gzip ( byte [ ] buf )
} public static string un _ gzip ( byte [ ] buf ) { byte [ ] buffer = new byte [ NUM ] ; int n ; using ( memory _ stream sb = new memory _ stream ( ) ) { using ( g _ zip _ stream input = new g _ zip _ stream ( new memory _ stream ( buf ) , compression _ mode . decompress , false ) ) {
} private void connect _ callback ( i _ async _ result ar ) { if ( closed ) { return ; } try { remote . end _ connect ( ar ) ;
connection . begin _ send ( remote _ send _ buffer , 0 , bytes _ to _ send , 0 , new async _ callback ( pipe _ connection _ send _ callback ) , null ) ; } else { connection . shutdown ( socket _ shutdown . send ) ; connection _ shutdown = true ; check _ close ( ) ; } } catch ( exception e )
remote . begin _ send ( connetion _ send _ buffer , 0 , bytes _ to _ send , 0 , new async _ callback ( pipe _ remote _ send _ callback ) , null ) ; } else { remote . shutdown ( socket _ shutdown . send ) ; remote _ shutdown = true ; check _ close ( ) ; } } catch ( exception e )
} } private string get _ pac _ content ( ) { if ( file . exists ( pac _ file ) ) { return file . read _ all _ text ( pac _ file , encoding . ut ) ; } else {
{ application . set _ unhandled _ exception _ mode ( unhandled _ exception _ mode . catch _ exception ) ; application . thread _ exception + = application _ thread _ exception ; app _ domain . current _ domain . unhandled _ exception + = current _ domain _ unhandled _ exception ; application . application _ exit + = application _ application _ exit ; system _ events . power _ mode _ changed + = system _ events _ power _ mode _ changed ; application . enable _ visual _ styles ( ) ; application . set _ compatible _ text _ rendering _ default ( false ) ; application . application _ exit + = ( sender , args ) = > hot _ keys . destroy ( ) ; if ( ! mutex . wait _ one ( 0 , false ) )
STR , message _ box _ buttons . ok , message _ box _ icon . error ) ; application . exit ( ) ; } } private static void application _ thread _ exception ( object sender , thread _ exception _ event _ args e ) { string error _ msg = $ STR ; logging . error ( error _ msg ) ; message _ box . show ( $ STR unexpected error , shadowsocks will exit . please report to STR ,
} connection . begin _ send ( response , 0 , response . length , socket _ flags . none , handshake _ send _ callback , null ) ; } else close ( ) ; } catch ( exception e ) { logger . log _ useful _ exception ( e ) ;
close ( ) ; } } private void handshake _ send _ callback ( i _ async _ result ar ) { if ( closed ) return ; try { connection . end _ send ( ar ) ; connection . begin _ receive ( connetion _ recv _ buffer , 0 , NUM + addr _ atyp _ len + 1 , socket _ flags . none ,
close ( ) ; break ; } } else { logger . debug ( STR ) ; close ( ) ; }
close ( ) ; } } private void response _ callback ( i _ async _ result ar ) { try { connection . end _ send ( ar ) ; read _ address ( start _ connect ) ; }
} dest _ end _ point = socket _ util . get _ end _ point ( dst _ addr , dst _ port ) ; on _ success . invoke ( ) ; } else { logger . debug ( STR ) ; close ( ) ; } }
close ( ) ; } } catch ( exception e ) { logger . log _ useful _ exception ( e ) ; close ( ) ; } } private void handle _ udp _ associate ( )
close ( ) ; } } private void handle _ udp _ associate ( ) { ip _ end _ point end _ point = ( ip _ end _ point ) connection . local _ end _ point ; byte [ ] address = end _ point . address . get _ address _ bytes ( ) ; int port = end _ point . port ; byte [ ] response = new byte [ NUM + address . length + addr _ port _ len ] ; response [ 0 ] = NUM ;
send _ to _ server ( first _ packet _ length , session ) ; } catch ( exception e ) { logger . log _ useful _ exception ( e ) ; close ( ) ; } } private void pipe _ remote _ receive _ callback ( i _ async _ result ar ) {
close ( ) ; } } private void pipe _ remote _ receive _ callback ( i _ async _ result ar ) { if ( closed ) return ; try { var session = ( async _ session ) ar . async _ state ; int bytes _ read = session . remote . end _ receive ( ar ) ;
close ( ) ; return ; } } if ( bytes _ to _ send = = 0 ) { logger . debug ( STR ) ; session . remote . begin _ receive ( remote _ recv _ buffer , 0 , recv _ size , socket _ flags . none , pipe _ remote _ receive _ callback , session ) ; return ;
$ STR ) ; } } catch ( exception ex ) { logger . error ( STR + ex . message ) ; throw ; } return plugin . local _ end _ point ; }
throw ; } return plugin . local _ end _ point ; } public void save _ servers ( list < server > servers , int local _ port , bool portable _ mode ) { config . configs = servers ; config . local _ port = local _ port ; config . portable _ mode = portable _ mode ; configuration . save ( config ) ;
} } private void save ( ) { logger . debug ( $ STR ) ; if ( raw _ statistics . count = = 0 ) { return ; } try
if ( raw _ statistics . count = = 0 ) { return ; } try { string content ; content = json _ convert . serialize _ object ( raw _ statistics , formatting . indented ) ; content = json _ convert . serialize _ object ( raw _ statistics , formatting . none ) ; file . write _ all _ text ( availability _ statistics _ file , content ) ;
} } private void load _ raw _ statistics ( ) { try { var path = availability _ statistics _ file ; logger . debug ( $ STR ) ; if ( ! file . exists ( path ) ) {
if ( ! file . exists ( path ) ) { using ( file . create ( path ) ) { } } var content = file . read _ all _ text ( path ) ; raw _ statistics = json _ convert . deserialize _ object < statistics > ( content ) ? ? raw _ statistics ; } catch ( exception e )
fire _ completed ( e , userstate ) ; } } private void ping _ ping _ completed ( object sender , ping _ completed _ event _ args e ) { try { if ( e . reply . status = = ip _ status . success ) { logger . debug ( $ STR ) ;
fire _ completed ( ex , e . user _ state ) ; } } private void test _ next ( object userstate ) { if ( repeat > 0 ) { int delay = timeout _ milliseconds + new random ( ) . next ( ) % timeout _ milliseconds ; new task ( ( ) = > icmp _ test ( delay , userstate ) ) . start ( ) ; }
} public static void rand _ bytes ( byte [ ] buf , int length ) { rng . get _ bytes ( buf , length ) ; } public abstract void cipher _ encrypt ( byte [ ] plaintext , uint plen , byte [ ] ciphertext , ref uint clen ) ; public abstract void cipher _ decrypt ( byte [ ] ciphertext , uint clen , byte [ ] plaintext , ref uint plen ) ; public override void encrypt ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength ) { debug . assert ( enc _ circular _ buffer ! = null , STR ) ; enc _ circular _ buffer . put ( buf , 0 , length ) ; outlength = 0 ; logger . debug ( STR ) ;
throw new crypto _ error _ exception ( ) ; } logger . debug ( STR + chunk _ len ) ; buf _ size = dec _ circular _ buffer . size ; if ( buf _ size < chunk _ len _ bytes + tag _ len logger . debug ( STR ) ; return ; } increment _ nonce ( false ) ; dec _ circular _ buffer . skip ( chunk _ len _ bytes + tag _ len ) ;
using system _ io ; using system _ i _ compression ; using system _ text ; namespace shadowsocks _ controller { public static class file _ manager { private static logger logger = log _ manager . get _ current _ class _ logger ( ) ; public static bool byte _ array _ to _ file ( string file _ name , byte [ ] content ) {
using system ; using system _ collections _ generic ; using system _ net ; using system _ text ; namespace shadowsocks _ controller _ strategy { class high _ availability _ strategy : i _ strategy { private static logger logger = log _ manager . get _ current _ class _ logger ( ) ;
} } } public void update _ latency ( model . server server , time _ span latency ) { logger . debug ( $ STR ) ; server _ status status ; if ( server _ status . try _ get _ value ( server , out status ) ) { status . latency = latency ;
} tcp _ socket . begin _ accept ( new async _ callback ( accept _ callback ) , tcp _ socket ) ; udp _ state udp _ state = new udp _ state ( udp _ socket ) ; udp _ socket . begin _ receive _ from ( udp _ state . buffer , 0 , udp _ state . buffer . length , 0 , ref udp _ state . remote _ end _ point , new async _ callback ( recv _ from _ callback ) , udp _ state ) ; } catch ( socket _ exception ) { tcp _ socket . close ( ) ; throw ; }
web _ client http = create _ web _ client ( ) ; http . download _ string _ completed + = http _ download _ string _ completed ; http . download _ string _ async ( new uri ( update _ url ) ) ; } catch ( exception ex ) { logger . log _ useful _ exception ( ex ) ; } } private void http _ download _ string _ completed ( object sender , download _ string _ completed _ event _ args e )
} } private void http _ download _ string _ completed ( object sender , download _ string _ completed _ event _ args e ) { try { string response = e . result ; j _ array result = j _ array . parse ( response ) ; list < asset > asserts = new list < asset > ( ) ; if ( result ! = null )
if ( check _ update _ completed ! = null ) { check _ update _ completed ( this , new event _ args ( ) ) ; } } } catch ( exception ex ) { logger . log _ useful _ exception ( ex ) ; }
} } private void start _ download ( ) { try { latest _ version _ local _ name = utils . get _ temp _ path ( latest _ version _ name ) ; web _ client http = create _ web _ client ( ) ; http . download _ file _ completed + = http _ download _ file _ completed ; http . download _ file _ async ( new uri ( latest _ version _ url ) , latest _ version _ local _ name ) ;
if ( check _ update _ completed ! = null ) { check _ update _ completed ( this , new event _ args ( ) ) ; } } catch ( exception ex ) { logger . log _ useful _ exception ( ex ) ; } }
} } private web _ client create _ web _ client ( ) { web _ client http = new web _ client ( ) ; http . headers . add ( STR , user _ agent ) ; http . proxy = new web _ proxy ( config . local _ host , config . local _ port ) ; return http ; } private void sort _ by _ versions ( list < asset > asserts )
switch ( cipher ) { case cipher _ chach _ ietfpol : ret = sodium . crypto _ aead _ chacha _ poly _ ietf _ decrypt ( plaintext , ref dec _ plen , null , ciphertext , ( ulong ) clen , null , 0 , dec _ nonce , sodium _ dec _ subkey ) ; break ; case cipher _ xchach _ ietfpol :
remote ? . send _ to ( data _ out , outlen , socket _ flags . none , remote _ end _ point ) ; } public void receive ( ) { end _ point remote _ end _ point = new ip _ end _ point ( get _ ip _ address ( ) , 0 ) ; logger . debug ( $ STR + buffer . length ) ; remote ? . begin _ receive _ from ( buffer , 0 , buffer . length , 0 , ref remote _ end _ point , new async _ callback ( recv _ from _ callback ) , null ) ; } public void recv _ from _ callback ( i _ async _ result ar ) {
string privoxy _ log _ filename = utils . get _ temp _ path ( STR ) ; if ( file . exists ( privoxy _ log _ filename ) ) using ( new file _ stream ( privoxy _ log _ filename , file _ mode . truncate ) ) { } main _ controller = new shadowsocks _ controller ( ) ; menu _ controller = new menu _ view _ controller ( main _ controller ) ; hot _ keys . init ( main _ controller ) ; main _ controller . start ( ) ; application . run ( ) ; }
main _ controller = new shadowsocks _ controller ( ) ; menu _ controller = new menu _ view _ controller ( main _ controller ) ; hot _ keys . init ( main _ controller ) ; main _ controller . start ( ) ; application . run ( ) ; } } private static void touch _ and _ apply _ n _ log _ config ( ) { string n _ log _ config _ file _ name = STR ;
message _ box . show ( $ STR unexpected error , shadowsocks will exit . please report to STR , STR , message _ box _ buttons . ok , message _ box _ icon . error ) ; application . exit ( ) ; } } private static void application _ thread _ exception ( object sender , thread _ exception _ event _ args e ) { if ( interlocked . increment ( ref exited ) = = 1 ) {
} } ) ; } break ; case power _ modes . suspend : if ( main _ controller ! = null ) { main _ controller . stop ( ) ; logger . info ( STR ) ; }
handler handler = new handler ( ) ; handler . connection = conn ; handler . encryptor = encryptor _ factory . get _ encryptor ( config . method , config . password ) ; handler . config = config ; handler . start ( ) ; } catch ( exception ) { } }
{ } } } class handler { public i _ encryptor encryptor ; public config config ; public socket remote ; public socket connection ;
{ return strings . contains _ key ( key ) ? string . format ( strings [ key ] , args ) : string . format ( key , args ) ; } } }
} } }
} public void start ( configuration config ) { this . config = config ; this . share _ over _ lan = config . share _ over _ lan ; if ( check _ if _ port _ in _ use ( config . local _ port ) ) throw new exception ( n . get _ string ( STR , config . local _ port ) ) ; try { tcp _ socket = new socket ( address _ family . inter _ network , socket _ type . stream , protocol _ type . tcp ) ;
try { tcp _ socket = new socket ( address _ family . inter _ network , socket _ type . stream , protocol _ type . tcp ) ; udp _ socket = new socket ( address _ family . inter _ network , socket _ type . dgram , protocol _ type . udp ) ; tcp _ socket . set _ socket _ option ( socket _ option _ level . socket , socket _ option _ name . reuse _ address , true ) ; udp _ socket . set _ socket _ option ( socket _ option _ level . socket , socket _ option _ name . reuse _ address , true ) ; ip _ end _ point local _ end _ point = null ; local _ end _ point = share _ over _ lan ? new ip _ end _ point ( ip _ address . any , config . local _ port ) : new ip _ end _ point ( ip _ address . loopback , config . local _ port ) ;
dest _ host = host ; dest _ port = port ; byte [ ] request = null ; byte atyp = 0 ; ip _ address ip _ address ; bool parsed = ip _ address . try _ parse ( host , out ip _ address ) ; if ( parsed ) { ip _ end _ point ep = new ip _ end _ point ( ip _ address , port ) ; switch ( ep . address _ family )
request [ 0 ] = NUM ; request [ 1 ] = 1 ; request [ 2 ] = 0 ; request [ NUM ] = atyp ; request [ request . length - 2 ] = ( byte ) ( ( port > > NUM ) & 0 xff ) ; request [ request . length - 1 ] = ( byte ) ( port & 0 xff ) ; var st = new socks _ state ( ) ;
var st = new socks _ state ( ) ; st . callback = callback ; st . async _ state = state ; remote ? . begin _ send ( request , 0 , request . length , 0 , socks _ request _ send _ callback , st ) ; } public void end _ connect _ dest ( i _ async _ result async _ result ) { var state = ( ( fake _ async _ result ) async _ result ) . inner _ state ; if ( state . ex ! = null ) {
break ; case NUM : int len = connetion _ recv _ buffer [ 1 ] ; dst _ addr = system . text . encoding . ut . get _ string ( connetion _ recv _ buffer , 2 , len ) ; dst _ port = ( connetion _ recv _ buffer [ len + 2 ] < < NUM ) + connetion _ recv _ buffer [ len + NUM ] ; if ( controller . get _ current _ configuration ( ) . is _ verbose _ logging ) { logging . info ( $ STR ) ; } break ;
break ; case NUM : dst _ addr = new ip _ address ( connetion _ recv _ buffer . skip ( 1 ) . take ( NUM ) . to _ array ( ) ) . to _ string ( ) ; dst _ port = ( connetion _ recv _ buffer [ NUM ] < < NUM ) + connetion _ recv _ buffer [ NUM ] ; if ( controller . get _ current _ configuration ( ) . is _ verbose _ logging ) { logging . info ( $ STR ) ; } break ; }
break ; } int bytes _ to _ send ; lock ( encryption _ lock ) { if ( closed ) return ; encryptor . encrypt ( connetion _ recv _ buffer , bytes _ read , connetion _ send _ buffer , out bytes _ to _ send ) ; } tcprelay . update _ outbound _ counter ( server , bytes _ to _ send ) ; start _ sending _ time = date _ time . now ;
{ if ( name = = STR | | name = = STR ) { init ( resources . cn ) ; } else { init ( resources . zh _ tw ) ;
{ init ( resources . cn ) ; } else { init ( resources . zh _ tw ) ;
} } } public static string get _ string ( string key ) { if ( strings . contains _ key ( key ) ) { return strings [ key ] ; } else
{ byte [ ] str _ byte = encoding . ascii . get _ bytes ( str ) ; str = encoding . unicode . get _ string ( str _ byte ) ; user _ settings _ arr = str . split ( new string [ ] { STR } , string _ split _ options . remove _ empty _ entries ) ; if ( user _ settings _ arr . length ! = NUM ) { throw new proxy _ exception ( STR + bit _ converter . to _ string ( str _ byte ) ) ; } } user _ settings . flags = user _ settings _ arr [ 0 ] ;
{ var sb = new string _ builder ( $ STR ) ; for ( int i = 0 ; i < length - 1 ; i + + ) { sb . append ( $ STR ) ; } sb . append ( $ STR ) ; sb . append ( environment . new _ line ) ; logger . trace ( sb . to _ string ( ) ) ; }
} } public static void debug ( this logger logger , end _ point local , end _ point remote , int len , string header = null , string tailer = null ) { if ( logger . is _ debug _ enabled ) { if ( header = = null & & tailer = = null )
} public static void debug ( this logger logger , end _ point local , end _ point remote , int len , string header = null , string tailer = null ) { if ( logger . is _ debug _ enabled ) { if ( header = = null & & tailer = = null ) logger . debug ( $ STR ) ; else if ( header = = null & & tailer ! = null ) logger . debug ( $ STR ) ; else if ( header ! = null & & tailer = = null )
} public static void debug ( this logger logger , socket sock , int len , string header = null , string tailer = null ) { if ( logger . is _ debug _ enabled ) { logger . debug ( sock . local _ end _ point , sock . remote _ end _ point , len , header , tailer ) ; } } public static void log _ useful _ exception ( this logger logger , exception e ) {
} public static void log _ useful _ exception ( this logger logger , exception e ) { if ( e is socket _ exception ) { socket _ exception se = ( socket _ exception ) e ; if ( se . socket _ error _ code = = socket _ error . connection _ aborted ) { } else if ( se . socket _ error _ code = = socket _ error . connection _ reset )
return configuration ; } catch ( file _ not _ found _ exception ) { var configuration = new statistics _ strategy _ configuration ( ) ; save ( configuration ) ; return configuration ; } catch ( exception e ) {
{ var configuration = new statistics _ strategy _ configuration ( ) ; save ( configuration ) ; return configuration ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; return new statistics _ strategy _ configuration ( ) ; }
{ bool success = true ; if ( value is string ) success = serialize _ string ( ( string ) value , builder ) ; else if ( value is i _ dictionary < string , object > ) { i _ dictionary < string , object > dict = ( i _ dictionary < string , object > ) value ; success = serialize _ object ( json _ serializer _ strategy , dict . keys , dict . values , level , builder ) ; } else if ( value is i _ dictionary < string , string > )
} else if ( value is i _ dictionary < string , string > ) { i _ dictionary < string , string > dict = ( i _ dictionary < string , string > ) value ; success = serialize _ object ( json _ serializer _ strategy , dict . keys , dict . values , level , builder ) ; } else if ( value is i _ enumerable ) success = serialize _ array ( json _ serializer _ strategy , ( i _ enumerable ) value , level , builder ) ; else if ( is _ numeric ( value ) ) success = serialize _ number ( value , builder ) ;
} else if ( value is i _ enumerable ) success = serialize _ array ( json _ serializer _ strategy , ( i _ enumerable ) value , level , builder ) ; else if ( is _ numeric ( value ) ) success = serialize _ number ( value , builder ) ; else if ( value is boolean ) builder . append ( ( bool ) value ? STR : STR ) ; else if ( value = = null ) builder . append ( STR ) ; else
else if ( is _ numeric ( value ) ) success = serialize _ number ( value , builder ) ; else if ( value is boolean ) builder . append ( ( bool ) value ? STR : STR ) ; else if ( value = = null ) builder . append ( STR ) ; else { object serialized _ object ; success = json _ serializer _ strategy . serialize _ non _ primitive _ object ( value , out serialized _ object ) ;
} return success ; } protected static bool serialize _ object ( i _ json _ serializer _ strategy json _ serializer _ strategy , i _ enumerable keys , i _ enumerable values , int level , string _ builder builder ) { builder . append ( STR ) ; level + + ; i _ enumerator ke = keys . get _ enumerator ( ) ; i _ enumerator ve = values . get _ enumerator ( ) ; bool first = true ;
{ builder . append ( STR ) ; level + + ; i _ enumerator ke = keys . get _ enumerator ( ) ; i _ enumerator ve = values . get _ enumerator ( ) ; bool first = true ; while ( ke . move _ next ( ) & & ve . move _ next ( ) ) { object key = ke . current ; object value = ve . current ;
builder . append ( STR ) ; if ( ! serialize _ value ( json _ serializer _ strategy , value , level , builder ) ) return false ; first = false ; } builder . append ( STR ) ; feed _ indent ( level - 1 , builder ) ; builder . append ( STR ) ; return true ; }
return false ; first = false ; } builder . append ( STR ) ; feed _ indent ( level - 1 , builder ) ; builder . append ( STR ) ; return true ; } protected static bool serialize _ array ( i _ json _ serializer _ strategy json _ serializer _ strategy , i _ enumerable an _ array , int level , string _ builder builder ) {
return true ; } protected static bool serialize _ array ( i _ json _ serializer _ strategy json _ serializer _ strategy , i _ enumerable an _ array , int level , string _ builder builder ) { builder . append ( STR ) ; level + + ; bool first = true ; foreach ( object value in an _ array ) { if ( ! first )
bool first = true ; foreach ( object value in an _ array ) { if ( ! first ) builder . append ( STR ) ; feed _ indent ( level , builder ) ; if ( ! serialize _ value ( json _ serializer _ strategy , value , level , builder ) ) return false ; first = false ; }
return false ; first = false ; } builder . append ( STR ) ; feed _ indent ( level - 1 , builder ) ; builder . append ( STR ) ; return true ; } protected static bool serialize _ string ( string a _ string , string _ builder builder ) {
return true ; } protected static bool serialize _ string ( string a _ string , string _ builder builder ) { builder . append ( STR ) ; char [ ] char _ array = a _ string . to _ char _ array ( ) ; for ( int i = 0 ; i < char _ array . length ; i + + ) { char c = char _ array [ i ] ; if ( c = = '"' )
} public static void close ( ) { rng ? . dispose ( ) ; rng = null ; } public static void reload ( ) {
rng = null ; } public static void reload ( ) { close ( ) ; init ( ) ; } public static void get _ bytes ( byte [ ] buf ) { get _ bytes ( buf , buf . length ) ;
try { rng . get _ bytes ( buf , 0 , len ) ; } catch { byte [ ] tmp = new byte [ len ] ; rng . get _ bytes ( tmp ) ; buffer . block _ copy ( tmp , 0 , buf , 0 , len ) ; }
{ byte [ ] tmp = new byte [ len ] ; rng . get _ bytes ( tmp ) ; buffer . block _ copy ( tmp , 0 , buf , 0 , len ) ; } } } }
string abp _ content = utils . un _ gzip ( resources . abp _ js ) ; abp _ content = abp _ content . replace ( STR , simple _ json . simple _ json . serialize _ object ( lines ) ) ; file . write _ all _ text ( pac _ file , abp _ content , encoding . ut ) ; if ( update _ completed ! = null ) { update _ completed ( this , new event _ args ( ) ) ; } } catch ( exception ex ) {
file . write _ all _ text ( pac _ file , abp _ content , encoding . ut ) ; if ( update _ completed ! = null ) { update _ completed ( this , new event _ args ( ) ) ; } } catch ( exception ex ) { if ( error ! = null ) {
{ byte [ ] bytes = convert . from _ base _ string ( response ) ; string content = encoding . ascii . get _ string ( bytes ) ; string [ ] lines = content . split ( new char [ ] { '\r' , '\n' } , string _ split _ options . remove _ empty _ entries ) ; list < string > valid _ lines = new list < string > ( lines . length ) ; foreach ( string line in lines ) { if ( line . starts _ with ( STR ) | | line . starts _ with ( STR ) ) continue ; valid _ lines . add ( line ) ;
{ logging . log _ useful _ exception ( e ) ; message _ box . show ( n . get _ string ( STR ) ) ; } } public static void disable ( ) { try
} } public static void disable ( ) { try { registry _ key registry = registry . current _ user . open _ sub _ key ( STR , true ) ; registry . set _ value ( STR , 0 ) ;
{ logging . log _ useful _ exception ( e ) ; message _ box . show ( n . get _ string ( STR ) ) ; } } private static void copy _ proxy _ setting _ from _ lan ( ) { registry _ key registry =
} } private static void copy _ proxy _ setting _ from _ lan ( ) { registry _ key registry = registry . current _ user . open _ sub _ key ( STR , true ) ; var default _ value = registry . get _ value ( STR ) ; try {
socket listener ; public local ( config config ) { this . config = config ; } public void start ( ) { listener = new socket ( address _ family . inter _ network , socket _ type . stream , protocol _ type . tcp ) ;
} public void start ( ) { listener = new socket ( address _ family . inter _ network , socket _ type . stream , protocol _ type . tcp ) ; ip _ end _ point local _ end _ point = new ip _ end _ point ( 0 , config . local _ port ) ; listener . bind ( local _ end _ point ) ; listener . listen ( NUM ) ; console . write _ line ( STR ) ; listener . begin _ accept (
{ if ( enabled ) { if ( global ) { win _ i _ net . set _ ie _ proxy ( true , true , STR + config . local _ port . to _ string ( ) , STR ) ; } else { string pac _ url ;
{ if ( global ) { win _ i _ net . set _ ie _ proxy ( true , true , STR + config . local _ port . to _ string ( ) , STR ) ; } else { string pac _ url ; if ( config . use _ online _ pac & & ! config . pac _ url . is _ null _ or _ empty ( ) ) pac _ url = config . pac _ url ;
} else { win _ i _ net . set _ ie _ proxy ( false , false , STR , STR ) ;
} } catch ( proxy _ exception ex ) { logging . log _ useful _ exception ( ex ) ; } } } }
{ logging . log _ useful _ exception ( ex ) ; } } } }
} } } }
} private void log _ form _ form _ closing ( object sender , form _ closing _ event _ args e ) { timer . stop ( ) ; config . log _ viewer . top _ most = top _ most _ trigger ; config . log _ viewer . wrap _ text = wrap _ text _ trigger ; config . log _ viewer . toolbar _ shown = toolbar _ trigger ; config . log _ viewer . font _ name = log _ message _ text _ box . font . name ; config . log _ viewer . font _ size = log _ message _ text _ box . font . size ; config . log _ viewer . set _ background _ color ( log _ message _ text _ box . back _ color ) ;
} public static void legacy _ derive _ key ( byte [ ] password , byte [ ] key , int keylen ) { byte [ ] result = new byte [ password . length + m _ len ] ; int i = 0 ; byte [ ] md _ sum = null ; while ( i < keylen ) { if ( i = = 0 ) { md _ sum = mbed _ tls . m ( password ) ; } else {
{ byte [ ] result = new byte [ password . length + m _ len ] ; int i = 0 ; byte [ ] md _ sum = null ; while ( i < keylen ) { if ( i = = 0 ) { md _ sum = mbed _ tls . m ( password ) ; } else { array . copy ( md _ sum , 0 , result , 0 , m _ len ) ; array . copy ( password , 0 , result , m _ len , password . length ) ;
int i = 0 ; byte [ ] md _ sum = null ; while ( i < keylen ) { if ( i = = 0 ) { md _ sum = mbed _ tls . m ( password ) ; } else { array . copy ( md _ sum , 0 , result , 0 , m _ len ) ; array . copy ( password , 0 , result , m _ len , password . length ) ; md _ sum = mbed _ tls . m ( result ) ; }
if ( i = = 0 ) { md _ sum = mbed _ tls . m ( password ) ; } else { array . copy ( md _ sum , 0 , result , 0 , m _ len ) ; array . copy ( password , 0 , result , m _ len , password . length ) ; md _ sum = mbed _ tls . m ( result ) ; } array . copy ( md _ sum , 0 , key , i , math . min ( m _ len , keylen - i ) ) ; i + = m _ len ; }
md _ sum = mbed _ tls . m ( result ) ; } array . copy ( md _ sum , 0 , key , i , math . min ( m _ len , keylen - i ) ) ; i + = m _ len ; } } protected virtual void init _ cipher ( byte [ ] iv , bool is _ encrypt ) { if ( is _ encrypt ) { encrypt _ iv = new byte [ iv _ len ] ;
} } protected virtual void init _ cipher ( byte [ ] iv , bool is _ encrypt ) { if ( is _ encrypt ) { encrypt _ iv = new byte [ iv _ len ] ; array . copy ( iv , encrypt _ iv , iv _ len ) ; } else { decrypt _ iv = new byte [ iv _ len ] ; array . copy ( iv , decrypt _ iv , iv _ len ) ;
if ( session _ key = = null ) session _ key = new byte [ key _ len ] ; } public void derive _ key ( byte [ ] password , byte [ ] key , int keylen ) { stream _ encryptor . legacy _ derive _ key ( password , key , keylen ) ; } public void derive _ session _ key ( byte [ ] salt , byte [ ] master _ key , byte [ ] session _ key ) { int ret = mbed _ tls . hkdf ( salt , salt _ len , master _ key , key _ len , info _ bytes , info _ bytes . length , session _ key , key _ len ) ;
} public void derive _ session _ key ( byte [ ] salt , byte [ ] master _ key , byte [ ] session _ key ) { int ret = mbed _ tls . hkdf ( salt , salt _ len , master _ key , key _ len , info _ bytes , info _ bytes . length , session _ key , key _ len ) ; if ( ret ! = 0 ) throw new system . exception ( STR ) ; } protected void increment _ nonce ( bool is _ encrypt ) { lock ( nonce _ increment _ lock ) {
{ if ( string . is _ null _ or _ empty ( server ) ) { return n . get _ string ( STR ) ; } return string . is _ null _ or _ empty ( remarks ) ? server + STR + server _ port : server + STR + server _ port + STR + remarks + STR ;
{ return n . get _ string ( STR ) ; } return string . is _ null _ or _ empty ( remarks ) ? server + STR + server _ port : server + STR + server _ port + STR + remarks + STR ; } }
} return string . is _ null _ or _ empty ( remarks ) ? server + STR + server _ port : server + STR + server _ port + STR + remarks + STR ; } } }
string polipo _ config = resources . polipo _ config ; polipo _ config = polipo _ config . replace ( STR , server . local _ port . to _ string ( ) ) ; polipo _ config = polipo _ config . replace ( STR , configuration . share _ over _ lan ? STR : STR ) ; file _ manager . byte _ array _ to _ file ( temppath + STR , system . text . encoding . ut . get _ bytes ( polipo _ config ) ) ; process = new process ( ) ; process . start _ info . file _ name = temppath + STR ; process . start _ info . arguments = STR + temppath + STR ; process . start _ info . window _ style = process _ window _ style . hidden ; process . start _ info . use _ shell _ execute = true ;
process = new process ( ) ; process . start _ info . file _ name = temppath + STR ; process . start _ info . arguments = STR + temppath + STR ; process . start _ info . window _ style = process _ window _ style . hidden ; process . start _ info . use _ shell _ execute = true ; process . start _ info . create _ no _ window = true ; process . start ( ) ; } } public void stop ( )
public socket connection ; public shadowsocks _ controller controller ; public tcp _ relay tcprelay ; public date _ time last _ activity ; private const int max _ retry = NUM ; private int retry _ count = 0 ; private bool proxy _ connected ; private bool dest _ connected ; private byte command ; private byte [ ] first _ packet ;
public end _ point dest _ end _ point ; public server server ; public proxy _ timer ( int p ) : base ( p ) { } } private class server _ timer : timer { public async _ session session ; public server server ;
proxy _ timer . dest _ end _ point = socket _ util . get _ end _ point ( server . server , server . server _ port ) ; proxy _ timer . server = server ; proxy _ connected = false ; remote . begin _ connect _ proxy ( proxy _ ep , new async _ callback ( proxy _ connect _ callback ) , new async _ session < proxy _ timer > ( remote , proxy _ timer ) ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; }
} catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; } } private void proxy _ connect _ timer _ elapsed ( object sender , elapsed _ event _ args e ) { if ( proxy _ connected | | dest _ connected )
logging . info ( $ STR ) ; proxy . close ( ) ; retry _ connect ( ) ; } private void proxy _ connect _ callback ( i _ async _ result ar ) { server server = null ; if ( closed ) { return ;
retry _ connect ( ) ; } private void proxy _ connect _ callback ( i _ async _ result ar ) { server server = null ; if ( closed ) { return ; } try
var dest _ end _ point = timer . dest _ end _ point ; server = timer . server ; timer . elapsed - = proxy _ connect _ timer _ elapsed ; timer . enabled = false ; timer . dispose ( ) ; var remote = session . remote ; remote . end _ connect _ proxy ( ar ) ; proxy _ connected = true ; if ( config . is _ verbose _ logging ) {
} catch ( argument _ exception ) { } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; retry _ connect ( ) ; } }
retry _ connect ( ) ; } private void retry _ connect ( ) { if ( retry _ count < max _ retry ) { logging . debug ( $ STR ) ; start _ connect ( ) ; retry _ count + + ; }
server = timer . server ; timer . elapsed - = dest _ connect _ timer _ elapsed ; timer . enabled = false ; timer . dispose ( ) ; var remote = session . remote ; remote ? . end _ connect _ dest ( ar ) ; dest _ connected = true ; if ( config . is _ verbose _ logging ) { logging . info ( $ STR ) ;
{ if ( closed ) return ; try { start _ receiving _ time = date _ time . now ; session . remote . begin _ receive ( remote _ recv _ buffer , 0 , recv _ size , socket _ flags . none , new async _ callback ( pipe _ remote _ receive _ callback ) , session ) ; connection ? . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , socket _ flags . none , new async _ callback ( pipe _ connection _ receive _ callback ) , new async _ session < bool > ( session , true ) } catch ( exception e )
connection ? . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , socket _ flags . none , new async _ callback ( pipe _ connection _ receive _ callback ) , new async _ session < bool > ( session , true ) } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; } } private void pipe _ remote _ receive _ callback ( i _ async _ result ar )
} catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; } } private void pipe _ remote _ receive _ callback ( i _ async _ result ar ) { if ( closed ) return ;
{ int atyp = connetion _ recv _ buffer [ 0 ] ; string dst _ addr ; int dst _ port ; switch ( atyp ) { case 1 : dst _ addr = new ip _ address ( connetion _ recv _ buffer . skip ( 1 ) . take ( NUM ) . to _ array ( ) ) . to _ string ( ) ; dst _ port = ( connetion _ recv _ buffer [ NUM ] < < NUM ) + connetion _ recv _ buffer [ NUM ] ; logging . info ( $ STR ) ;
break ; } } int bytes _ to _ send ; lock ( encryption _ lock ) { if ( closed ) return ; encryptor . encrypt ( connetion _ recv _ buffer , bytes _ read , connetion _ send _ buffer , out bytes _ to _ send ) ; } tcprelay . update _ outbound _ counter ( server , bytes _ to _ send ) ;
} catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; } } } }
static dictionary < string , int [ ] > ciphers = new dictionary < string , int [ ] > { { STR , new int [ ] { NUM , NUM , cipher _ aes , polar _ ssl . aes _ ctx _ size } } , { STR , new int [ ] { NUM , NUM , cipher _ aes , polar _ ssl . aes _ ctx _ size } } , { STR , new int [ ] { NUM , NUM , cipher _ aes , polar _ ssl . aes _ ctx _ size } } , { STR , new int [ ] { NUM , 0 , cipher _ r , polar _ ssl . ar _ ctx _ size } } , { STR , new int [ ] { NUM , NUM , cipher _ r , polar _ ssl . ar _ ctx _ size } } , } ; private static readonly dictionary < string , byte [ ] > cached _ keys = new dictionary < string , byte [ ] > ( ) ; private int cipher ;
{ STR , new int [ ] { NUM , 0 , cipher _ r , polar _ ssl . ar _ ctx _ size } } , { STR , new int [ ] { NUM , NUM , cipher _ r , polar _ ssl . ar _ ctx _ size } } , } ; private static readonly dictionary < string , byte [ ] > cached _ keys = new dictionary < string , byte [ ] > ( ) ; private int cipher ; private int [ ] cipher _ info ; private byte [ ] key ; private int _ ptr encrypt _ ctx = int _ ptr . zero ; private int _ ptr decrypt _ ctx = int _ ptr . zero ; private byte [ ] encrypt _ iv ;
socket _ util . begin _ connect _ tcp ( remote _ ep , connect _ callback , null ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; this . close ( ) ; } }
} catch ( exception e ) { logging . log _ useful _ exception ( e ) ; this . close ( ) ; } } private void connect _ callback ( i _ async _ result ar ) { if ( closed )
} public void end _ connect _ dest ( i _ async _ result async _ result ) { remote = socket _ util . end _ connect _ tcp ( async _ result ) ; } public void begin _ send ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) { remote ? . begin _ send ( buffer , offset , size , socket _ flags , callback , state ) ; }
} public void begin _ send ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) { remote ? . begin _ send ( buffer , offset , size , socket _ flags , callback , state ) ; } public int end _ send ( i _ async _ result async _ result ) { return remote . end _ send ( async _ result ) ; }
var st = new socks _ state ( ) ; st . callback = callback ; st . async _ state = state ; proxy _ end _ point = remote _ ep ; socket _ util . begin _ connect _ tcp ( remote _ ep , connect _ callback , st ) ; } public void end _ connect _ proxy ( i _ async _ result async _ result ) { var state = ( ( fake _ async _ result ) async _ result ) . inner _ state ; if ( state . ex ! = null )
} public void end _ connect _ proxy ( i _ async _ result async _ result ) { var state = ( ( fake _ async _ result ) async _ result ) . inner _ state ; if ( state . ex ! = null ) { throw state . ex ; } } public void begin _ connect _ dest ( end _ point dest _ end _ point , async _ callback callback , object state )
{ public async _ callback callback { get ; } public socket _ async _ event _ args args { get ; } public tcp _ user _ token ( async _ callback callback , object state , socket _ async _ event _ args args ) { callback = callback ; async _ state = state ; args = args ;
{ callback = callback ; async _ state = state ; args = args ;
} public bool is _ completed { get ; } = true ; public wait _ handle async _ wait _ handle { get ; } = null ; public object async _ state { get ; } public bool completed _ synchronously { get ; } = true ; } private static void on _ tcp _ connect _ completed ( object sender , socket _ async _ event _ args args ) { tcp _ user _ token token = ( tcp _ user _ token ) args . user _ token ; token . callback ( token ) ;
{ throw new argument _ exception ( STR , nameof ( async _ result ) ) ; } var arg = tut . args ; if ( arg . socket _ error ! = socket _ error . success ) {
} var arg = tut . args ; if ( arg . socket _ error ! = socket _ error . success ) { if ( arg . connect _ by _ name _ error ! = null ) { throw arg . connect _ by _ name _ error ; } var ex = new socket _ exception ( ( int ) arg . socket _ error ) ;
{ if ( arg . connect _ by _ name _ error ! = null ) { throw arg . connect _ by _ name _ error ; } var ex = new socket _ exception ( ( int ) arg . socket _ error ) ; throw ex ; } var so = tut . args . connect _ socket ;
} var so = tut . args . connect _ socket ; so . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; return so ; } } }
{ continue ; } foreach ( j _ object asset in ( j _ array ) release [ STR ] ) { asset ass = asset . parse _ asset ( asset ) ; if ( ass ! = null )
{ ass . prerelease = is _ pre _ release ; if ( ass . is _ new _ version ( version , pre _ release , config . check _ pre _ release ) ) { asserts . add ( ass ) ; } } } } }
} } } } if ( asserts . count ! = 0 ) { sort _ by _ versions ( asserts ) ; asset asset = asserts [ asserts . count - 1 ] ; new _ version _ found = true ; latest _ version _ url = asset . browser _ download _ url ;
{ return false ; } if ( version = = null ) { return false ; } var cmp = compare _ version ( version , current _ version ) ; if ( cmp = = 0 ) {
} public static int compare _ version ( string l , string r ) { var ls = l . split ( '.' ) ; var rs = r . split ( '.' ) ; for ( int i = 0 ; i < math . max ( ls . length , rs . length ) ; i + + ) { int lp = ( i < ls . length ) ? int . parse ( ls [ i ] ) : 0 ; int rp = ( i < rs . length ) ? int . parse ( rs [ i ] ) : 0 ; if ( lp ! = rp )
} } private void pac _ server _ pac _ file _ changed ( object sender , event _ args e ) { update _ system _ proxy ( ) ; } private void start _ releasing _ memory ( ) { ram _ thread = new thread ( new thread _ start ( release _ memory ) ) ; ram _ thread . is _ background = true ;
break ; case power _ modes . suspend : controller ? . stop ( ) ; logging . info ( STR ) ; break ; } } private static void timer _ elapsed ( object sender , system . timers . elapsed _ event _ args e ) { try
{ if ( ! established ) { st . inner _ state . ex = new exception ( n . get _ string ( STR ) ) ; } } st . inner _ state . callback ? . invoke ( st ) ; } private void on _ exception ( exception ex , object state ) {
} st . inner _ state . callback ? . invoke ( st ) ; } private void on _ exception ( exception ex , object state ) { var st = ( fake _ async _ result ) state ; st . inner _ state . ex = ex ; } private static readonly regex http _ respond _ header _ regex = new regex ( STR ) ;
} private static readonly regex http _ respond _ header _ regex = new regex ( STR ) ; private int respond _ line _ count = 0 ; private bool established = false ; private bool on _ line _ read ( string line , object state ) { logging . debug ( line ) ; if ( respond _ line _ count = = 0 ) { var m = http _ respond _ header _ regex . match ( line ) ;
return true ; } return false ; } catch ( argument _ exception ) { return false ; } } public string touch _ pac _ file ( )
byte [ ] plain = new byte [ plain . length + NUM ] ; int out _ len = 0 ; int out _ len = 0 ; var random = new random ( ) ; random . next _ bytes ( plain ) ; encryptor . encrypt ( plain , plain . length , cipher , out out _ len , false ) ; decryptor . decrypt ( cipher , out _ len , plain , out out _ len ) ; assert . are _ equal ( plain . length , out _ len ) ; for ( int j = 0 ; j < plain . length ; j + + ) {
decryptor . decrypt ( cipher , out _ len , plain , out out _ len ) ; assert . are _ equal ( plain . length , out _ len ) ; for ( int j = 0 ; j < plain . length ; j + + ) { assert . are _ equal ( plain [ j ] , plain [ j ] ) ; } encryptor . encrypt ( plain , NUM , cipher , out out _ len , false ) ; decryptor . decrypt ( cipher , out _ len , plain , out out _ len ) ; assert . are _ equal ( NUM , out _ len ) ; for ( int j = 0 ; j < out _ len ; j + + )
decryptor . decrypt ( cipher , out _ len , plain , out out _ len ) ; assert . are _ equal ( NUM , out _ len ) ; for ( int j = 0 ; j < out _ len ; j + + ) { assert . are _ equal ( plain [ j ] , plain [ j ] ) ; } encryptor . encrypt ( plain , NUM , cipher , out out _ len , false ) ; decryptor . decrypt ( cipher , out _ len , plain , out out _ len ) ; assert . are _ equal ( NUM , out _ len ) ; for ( int j = 0 ; j < out _ len ; j + + )
decryptor . decrypt ( cipher , out _ len , plain , out out _ len ) ; assert . are _ equal ( NUM , out _ len ) ; for ( int j = 0 ; j < out _ len ; j + + ) { assert . are _ equal ( plain [ j ] , plain [ j ] ) ; } } private static bool encryption _ failed = false ; private static object locker = new object ( ) ; test _ method
public const int clen _ bytes = 2 ; public const int auth _ bytes = onetimeauth _ bytes + clen _ bytes ; protected static byte [ ] tempbuf = new byte [ max _ input _ size ] ; protected dictionary < string , int [ ] > ciphers ; private static readonly dictionary < string , byte [ ] > cached _ keys = new dictionary < string , byte [ ] > ( ) ; protected byte [ ] encrypt _ iv ; protected byte [ ] decrypt _ iv ; protected bool decrypt _ iv _ received ; protected bool encrypt _ iv _ sent ; protected int encrypt _ iv _ offset = 0 ;
protected static byte [ ] tempbuf = new byte [ max _ input _ size ] ; protected dictionary < string , int [ ] > ciphers ; private static readonly dictionary < string , byte [ ] > cached _ keys = new dictionary < string , byte [ ] > ( ) ; protected byte [ ] encrypt _ iv ; protected byte [ ] decrypt _ iv ; protected bool decrypt _ iv _ received ; protected bool encrypt _ iv _ sent ; protected int encrypt _ iv _ offset = 0 ; protected int decrypt _ iv _ offset = 0 ; protected string method ;
if ( key _ buffer = = null ) { key _ buffer = new byte [ max _ iv _ length + NUM ] ; buffer . block _ copy ( encrypt _ iv , 0 , key _ buffer , 0 , iv _ len ) ; } byte [ ] counter _ bytes = bit _ converter . get _ bytes ( ( uint ) ip _ address . host _ to _ network _ order ( ( int ) counter ) ) ; buffer . block _ copy ( counter _ bytes , 0 , key _ buffer , iv _ len , NUM ) ;
counter + + ; } protected byte [ ] gen _ hash ( byte [ ] buf , int offset , int len ) { byte [ ] hash = new byte [ NUM ] ; update _ key _ buffer ( ) ; sodium . ss _ sha _ hmac _ ex ( key _ buffer , ( uint ) key _ buffer . length , buf , offset , ( uint ) len , hash ) ; return hash ; }
{ if ( ! encrypt _ iv _ sent ) { encrypt _ iv _ sent = true ; rand _ bytes ( outbuf , iv _ len ) ; init _ cipher ( outbuf , true ) ; outlength = length + iv _ len ; if ( onetime _ auth & & iv _ len > 0 ) { if ( ! udp )
cipher _ update ( true , length , buf , tempbuf ) ; outlength = length + iv _ len ; buffer . block _ copy ( tempbuf , 0 , outbuf , iv _ len , length ) ; } } else { if ( onetime _ auth & & iv _ len > 0 ) { byte [ ] hash = gen _ hash ( buf , 0 , length ) ;
} outlength = length ; cipher _ update ( true , length , buf , outbuf ) ; } } public override void decrypt ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength ) { if ( ! decrypt _ iv _ received ) { decrypt _ iv _ received = true ;
array . copy ( data , NUM , data _ in , 0 , length - NUM ) ; byte [ ] data _ out = new byte [ length - NUM + NUM + iv _ encryptor . onetimeauth _ bytes ] ; int outlen ; encryptor . encrypt ( data _ in , length - NUM , data _ out , out outlen , true ) ; remote . send _ to ( data _ out , outlen , socket _ flags . none , remote _ end _ point ) ; } public void receive ( ) { end _ point remote _ end _ point = new ip _ end _ point ( ip _ address . any , 0 ) ; remote . begin _ receive _ from ( buffer , 0 , buffer . length , 0 , ref remote _ end _ point , new async _ callback ( recv _ from _ callback ) , null ) ;
int outlen ; encryptor . encrypt ( data _ in , length - NUM , data _ out , out outlen , true ) ; remote . send _ to ( data _ out , outlen , socket _ flags . none , remote _ end _ point ) ; } public void receive ( ) { end _ point remote _ end _ point = new ip _ end _ point ( ip _ address . any , 0 ) ; remote . begin _ receive _ from ( buffer , 0 , buffer . length , 0 , ref remote _ end _ point , new async _ callback ( recv _ from _ callback ) , null ) ; } public void recv _ from _ callback ( i _ async _ result ar )
} public void receive ( ) { end _ point remote _ end _ point = new ip _ end _ point ( ip _ address . any , 0 ) ; remote . begin _ receive _ from ( buffer , 0 , buffer . length , 0 , ref remote _ end _ point , new async _ callback ( recv _ from _ callback ) , null ) ; } public void recv _ from _ callback ( i _ async _ result ar ) { try {
this . notify _ icon = new system . windows . forms . notify _ icon ( this . components ) ; this . context _ menu _ strip = new system . windows . forms . context _ menu _ strip ( this . components ) ; this . config _ item = new system . windows . forms . tool _ strip _ menu _ item ( ) ; this . quit _ item = new system . windows . forms . tool _ strip _ menu _ item ( ) ; this . table _ layout _ panel . suspend _ layout ( ) ; this . panel . suspend _ layout ( ) ;

this . controls . add ( this . table _ layout _ panel ) ; this . controls . add ( this . panel ) ; this . name = STR ; this . start _ position = system . windows . forms . form _ start _ position . center _ screen ; this . text = STR ; this . form _ closed + = new system . windows . forms . form _ closed _ event _ handler ( this . form _ form _ closed ) ; this . table _ layout _ panel . resume _ layout ( false ) ; this . table _ layout _ panel . perform _ layout ( ) ; this . panel . resume _ layout ( false ) ;
this . context _ menu _ strip . resume _ layout ( false ) ; this . resume _ layout ( false ) ; this . perform _ layout ( ) ; } private system . windows . forms . table _ layout _ panel table _ layout _ panel ; private system . windows . forms . label label ; private system . windows . forms . label label ; private system . windows . forms . label label ; private system . windows . forms . label label ; private system . windows . forms . text _ box text _ box ;
{ switch _ system _ proxy _ text _ box . text = config . switch _ system _ proxy ; switch _ proxy _ mode _ text _ box . text = config . switch _ system _ proxy _ mode ; switch _ allow _ lan _ text _ box . text = config . switch _ allow _ lan ; show _ logs _ text _ box . text = config . show _ logs ; server _ move _ up _ text _ box . text = config . server _ move _ up ; server _ move _ down _ text _ box . text = config . server _ move _ down ; } private void save _ config ( ) {
{ message _ box . show ( n . get _ string ( STR ) ) ; } save _ config ( ) ; this . close ( ) ; } private void register _ all _ button _ click ( object sender , event _ args e ) { register _ all _ hotkeys ( ) ; }
{ bool is _ success = true ; foreach ( var tb in all _ text _ boxes ) { if ( tb . text . is _ null _ or _ empty ( ) ) { continue ; } if ( ! try _ reg _ hotkey ( tb ) )
foreach ( var tb in all _ text _ boxes ) { if ( tb . text . is _ null _ or _ empty ( ) ) { continue ; } if ( ! try _ reg _ hotkey ( tb ) ) { is _ success = false ; }
return is _ success ; } private bool try _ reg _ hotkey ( text _ box tb ) { var hotkey = hot _ keys . str _ hot _ key ( tb . text ) ; if ( hotkey = = null ) { message _ box . show ( string . format ( n . get _ string ( STR ) , tb . text ) ) ; tb . clear ( ) ; return false ;
privoxy _ config = privoxy _ config . replace ( STR , configuration . local _ port . to _ string ( ) ) ; privoxy _ config = privoxy _ config . replace ( STR , running _ port . to _ string ( ) ) ; privoxy _ config = configuration . is _ i _ pv _ enabled ? privoxy _ config . replace ( STR , configuration . share _ over _ lan ? STR : STR ) . replace ( STR , STR ) : privoxy _ config . replace ( STR , configuration . share _ over _ lan ? STR : STR ) . replace ( STR , STR ) ; file _ manager . byte _ array _ to _ file ( utils . get _ temp _ path ( unique _ config _ file ) , encoding . ut . get _ bytes ( privoxy _ config ) ) ; process = new process
file _ manager . byte _ array _ to _ file ( utils . get _ temp _ path ( unique _ config _ file ) , encoding . ut . get _ bytes ( privoxy _ config ) ) ; process = new process { start _ info = { file _ name = STR , arguments = unique _ config _ file , working _ directory = utils . get _ temp _ path ( ) , window _ style = process _ window _ style . hidden , use _ shell _ execute = true ,
{ int default _ port = NUM ; try { tcp _ listener l = new tcp _ listener ( is _ i _ pv ? ip _ address . i _ pv _ loopback : ip _ address . loopback , 0 ) ; l . start ( ) ; var port = ( ( ip _ end _ point ) l . local _ endpoint ) . port ; l . stop ( ) ; return port ; }
l . start ( ) ; var port = ( ( ip _ end _ point ) l . local _ endpoint ) . port ; l . stop ( ) ; return port ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; return default _ port ; }
} configuration config ; bool share _ over _ lan ; socket tcp _ socket ; socket udp _ socket ; list < i _ service > services ; public listener ( list < i _ service > services ) { this . services = services ; }
tcp _ socket . set _ socket _ option ( socket _ option _ level . socket , socket _ option _ name . reuse _ address , true ) ; udp _ socket . set _ socket _ option ( socket _ option _ level . socket , socket _ option _ name . reuse _ address , true ) ; ip _ end _ point local _ end _ point = null ; local _ end _ point = share _ over _ lan ? new ip _ end _ point ( config . is _ i _ pv _ enabled ? ip _ address . i _ pv _ any : ip _ address . any , config . local _ port ) : new ip _ end _ point ( config . is _ i _ pv _ enabled ? ip _ address . i _ pv _ loopback : ip _ address . loopback , config . local _ port ) ; tcp _ socket . bind ( local _ end _ point ) ; udp _ socket . bind ( local _ end _ point ) ; tcp _ socket . listen ( NUM ) ; logging . info ( $ STR ) ;
tcp _ socket . bind ( local _ end _ point ) ; udp _ socket . bind ( local _ end _ point ) ; tcp _ socket . listen ( NUM ) ; logging . info ( $ STR ) ; if ( config . is _ verbose _ logging ) { logging . info ( encryption . encryptor _ factory . dump _ registered _ encryptor ( ) ) ; } tcp _ socket . begin _ accept ( new async _ callback ( accept _ callback ) , tcp _ socket ) ; udp _ state udp _ state = new udp _ state ( udp _ socket ) ;
udp _ socket . begin _ receive _ from ( udp _ state . buffer , 0 , udp _ state . buffer . length , 0 , ref udp _ state . remote _ end _ point , new async _ callback ( recv _ from _ callback ) , udp _ state ) ; } catch ( socket _ exception ) { tcp _ socket . close ( ) ; throw ; } } public void stop ( ) {
logging . debug ( $ STR + buffer . length ) ; remote ? . begin _ receive _ from ( buffer , 0 , buffer . length , 0 , ref remote _ end _ point , new async _ callback ( recv _ from _ callback ) , null ) ; } public void recv _ from _ callback ( i _ async _ result ar ) { try { if ( remote = = null ) return ; end _ point remote _ end _ point = new ip _ end _ point ( get _ ip _ address ( ) , 0 ) ; int bytes _ read = remote . end _ receive _ from ( ar , ref remote _ end _ point ) ;
int bytes _ read = remote . end _ receive _ from ( ar , ref remote _ end _ point ) ; byte [ ] data _ out = new byte [ bytes _ read ] ; int outlen ; i _ encryptor encryptor = encryptor _ factory . get _ encryptor ( server . method , server . password ) ; encryptor . decrypt _ udp ( buffer , bytes _ read , data _ out , out outlen ) ; byte [ ] send _ buf = new byte [ outlen + NUM ] ; array . copy ( data _ out , 0 , send _ buf , NUM , outlen ) ; logging . debug ( local _ end _ point , remote _ end _ point , outlen , STR ) ; local ? . send _ to ( send _ buf , outlen + NUM , 0 , local _ end _ point ) ; receive ( ) ;
foreach ( i _ service service in services ) { if ( service . handle ( state . buffer , bytes _ read , socket , state ) ) { break ; } } } catch ( object _ disposed _ exception ) {
{ break ; } } } catch ( object _ disposed _ exception ) { } catch ( exception ex ) {
public server get _ current _ server ( ) { return config . get _ current _ server ( ) ; } public configuration get _ configuration ( ) { return configuration . load ( ) ; } public void save _ servers ( list < server > servers ) {
{ server server = get _ current _ server ( ) ; return get _ server _ url ( server ) ; } public static string get _ server _ url ( server server ) { string tag = string . empty ; string url = string . empty ; if ( string . is _ null _ or _ white _ space ( server . plugin ) ) {
} public void begin _ send ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) { remote ? . begin _ send ( buffer , offset , size , socket _ flags , callback , state ) ; } public int end _ send ( i _ async _ result async _ result ) { return remote . end _ send ( async _ result ) ; }
} public int end _ send ( i _ async _ result async _ result ) { return remote . end _ send ( async _ result ) ; } public void begin _ receive ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) { remote ? . begin _ receive ( buffer , offset , size , socket _ flags , callback , state ) ; }
} public int end _ receive ( i _ async _ result async _ result ) { return remote . end _ receive ( async _ result ) ; } public void shutdown ( socket _ shutdown how ) { remote ? . shutdown ( how ) ; } public void close ( )
} public int end _ send ( i _ async _ result async _ result ) { return remote . end _ send ( async _ result ) ; } public void begin _ receive ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) { remote ? . begin _ receive ( buffer , offset , size , socket _ flags , callback , state ) ; }
} public int end _ receive ( i _ async _ result async _ result ) { return remote . end _ receive ( async _ result ) ; } public void shutdown ( socket _ shutdown how ) { remote ? . shutdown ( how ) ; } public void close ( )
} public void receive ( ) { end _ point remote _ end _ point = new ip _ end _ point ( ip _ address . any , 0 ) ; logging . debug ( $ STR + buffer . length ) ; remote ? . begin _ receive _ from ( buffer , 0 , buffer . length , 0 , ref remote _ end _ point , new async _ callback ( recv _ from _ callback ) , null ) ; } public void recv _ from _ callback ( i _ async _ result ar ) { try
} public void recv _ from _ callback ( i _ async _ result ar ) { try { if ( remote = = null ) return ; end _ point remote _ end _ point = new ip _ end _ point ( ip _ address . any , 0 ) ; int bytes _ read = remote . end _ receive _ from ( ar , ref remote _ end _ point ) ; byte [ ] data _ out = new byte [ bytes _ read ] ; int outlen ;
receive ( ) ; } catch ( object _ disposed _ exception ) { } catch ( exception ) { } finally {
using newtonsoft _ json ; namespace shadowsocks _ util _ system _ proxy { public static class sysproxy { private const string user _ wininet _ config _ file = STR ; private static string query _ str ; private static sysproxy _ config user _ settings = null ; enum ret _ errors : int {
{ using ( var process = new process ( ) )
{ process . start _ info . file _ name = utils . get _ temp _ path ( STR ) ; process . start _ info . arguments = arguments ; process . start _ info . working _ directory = utils . get _ temp _ path ( ) ; process . start _ info . window _ style = process _ window _ style . hidden ; process . start _ info . use _ shell _ execute = false ; process . start _ info . redirect _ standard _ error = true ; process . start _ info . redirect _ standard _ output = true ; process . start _ info . standard _ output _ encoding = encoding . unicode ; process . start _ info . standard _ error _ encoding = encoding . unicode ;
{ if ( e . data = = null ) { output _ wait _ handle . set ( ) ; } else { output . append _ line ( e . data ) ; } } ;
} if ( arguments = = STR ) { if ( stdout . is _ null _ or _ white _ space ( ) | | stdout . is _ null _ or _ empty ( ) ) { throw new proxy _ exception ( STR ) ; } query _ str = stdout ; } } } }
} } } private static void save ( ) { try { using ( stream _ writer sw = new stream _ writer ( file . open ( utils . get _ temp _ path ( user _ wininet _ config _ file ) , file _ mode . create ) ) ) { string json _ string = json _ convert . serialize _ object ( user _ settings , formatting . indented ) ;
item . tag = strategy . id ; item . click + = a _ strategy _ item _ click ; items . add ( i , item ) ; i + + ; } int strategy _ count = i ; configuration configuration = controller . get _ configuration _ copy ( ) ; foreach ( var server in configuration . configs ) { menu _ item item = new menu _ item ( server . friendly _ name ( ) ) ;

} public string id { get { return STR ; } } public void reload _ servers ( ) { }
} public server get _ a _ server ( i _ strategy _ caller _ type type , ip _ end _ point local _ ip _ end _ point ) { var configs = controller . get _ current _ configuration ( ) . configs ; int index ; if ( type = = i _ strategy _ caller _ type . tcp ) { index = random . next ( ) ; } else
void update _ last _ read ( server server ) ; * tcp _ relay will call this when writing to a server * / void update _ last _ write ( server server ) ; * tcp _ relay will call this when fatal failure detected * / void set _ failure ( server server ) ; } }
this . remarks _ text _ box . name = STR ; this . remarks _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . remarks _ text _ box . tab _ index = NUM ; this . remarks _ text _ box . word _ wrap = false ; this . label . anchor = system . windows . forms . anchor _ styles . right ; this . label . auto _ size = true ; this . label . location = new system . drawing . point ( NUM , NUM ) ; this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ;
this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ; this . label . tab _ index = NUM ; this . label . text = STR ; this . label . anchor = system . windows . forms . anchor _ styles . right ; this . label . auto _ size = true ; this . label . location = new system . drawing . point ( NUM , NUM ) ; this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ;
this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ; this . label . tab _ index = 0 ; this . label . text = STR ; this . label . anchor = system . windows . forms . anchor _ styles . right ; this . label . auto _ size = true ; this . label . location = new system . drawing . point ( NUM , NUM ) ; this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ;
this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ; this . label . tab _ index = 1 ; this . label . text = STR ; this . proxy _ port _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . proxy _ port _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . proxy _ port _ text _ box . name = STR ; this . proxy _ port _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . proxy _ port _ text _ box . tab _ index = NUM ;
this . proxy _ port _ text _ box . name = STR ; this . proxy _ port _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . proxy _ port _ text _ box . tab _ index = NUM ; this . proxy _ port _ text _ box . word _ wrap = false ; this . label . anchor = system . windows . forms . anchor _ styles . right ; this . label . auto _ size = true ; this . label . location = new system . drawing . point ( NUM , NUM ) ; this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ;
this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ; this . label . tab _ index = NUM ; this . label . text = STR ; this . label . anchor = system . windows . forms . anchor _ styles . right ; this . label . auto _ size = true ; this . label . location = new system . drawing . point ( NUM , NUM ) ; this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ;
this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ; this . label . tab _ index = 2 ; this . label . text = STR ; this . ip _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . ip _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . ip _ text _ box . name = STR ; this . ip _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . ip _ text _ box . tab _ index = 0 ;
this . ip _ text _ box . name = STR ; this . ip _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . ip _ text _ box . tab _ index = 0 ; this . ip _ text _ box . word _ wrap = false ; this . server _ port _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . server _ port _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . server _ port _ text _ box . name = STR ; this . server _ port _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . server _ port _ text _ box . tab _ index = 1 ;
this . server _ port _ text _ box . name = STR ; this . server _ port _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . server _ port _ text _ box . tab _ index = 1 ; this . server _ port _ text _ box . word _ wrap = false ; this . password _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . password _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . password _ text _ box . name = STR ; this . password _ text _ box . password _ char = '*' ; this . password _ text _ box . size = new system . drawing . size ( NUM , NUM ) ;
this . password _ text _ box . name = STR ; this . password _ text _ box . password _ char = '*' ; this . password _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . password _ text _ box . tab _ index = 2 ; this . password _ text _ box . word _ wrap = false ; this . label . anchor = system . windows . forms . anchor _ styles . right ; this . label . auto _ size = true ; this . label . location = new system . drawing . point ( NUM , NUM ) ; this . label . name = STR ;
this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ; this . label . tab _ index = NUM ; this . label . text = STR ; this . encryption _ select . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( ( system . windows . forms . anchor _ styles . top | system . windows . forms . anchor _ styles . left ) | system . windows . forms . anchor _ styles . right ) ) ) ; this . encryption _ select . drop _ down _ style = system . windows . forms . combo _ box _ style . drop _ down _ list ; this . encryption _ select . formatting _ enabled = true ; this . encryption _ select . ime _ mode = system . windows . forms . ime _ mode . no _ control ; this . encryption _ select . item _ height = NUM ;
this . encryption _ select . name = STR ; this . encryption _ select . size = new system . drawing . size ( NUM , NUM ) ; this . encryption _ select . tab _ index = NUM ; this . notify _ icon . text = STR ; this . notify _ icon . double _ click + = new system . event _ handler ( this . notify _ icon _ double _ click ) ; this . panel . anchor = system . windows . forms . anchor _ styles . top ; this . panel . auto _ size = true ; this . panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . panel . location = new system . drawing . point ( NUM , NUM ) ;
this . panel . name = STR ; this . panel . size = new system . drawing . size ( 0 , 0 ) ; this . panel . tab _ index = 1 ; this . ok _ button . dialog _ result = system . windows . forms . dialog _ result . ok ; this . ok _ button . location = new system . drawing . point ( NUM , NUM ) ; this . ok _ button . name = STR ; this . ok _ button . size = new system . drawing . size ( NUM , NUM ) ; this . ok _ button . tab _ index = NUM ; this . ok _ button . text = STR ;
this . ok _ button . name = STR ; this . ok _ button . size = new system . drawing . size ( NUM , NUM ) ; this . ok _ button . tab _ index = NUM ; this . ok _ button . text = STR ; this . ok _ button . use _ visual _ style _ back _ color = true ; this . ok _ button . click + = new system . event _ handler ( this . ok _ button _ click ) ; this . my _ cancel _ button . dialog _ result = system . windows . forms . dialog _ result . cancel ; this . my _ cancel _ button . location = new system . drawing . point ( NUM , NUM ) ; this . my _ cancel _ button . name = STR ;
this . my _ cancel _ button . name = STR ; this . my _ cancel _ button . size = new system . drawing . size ( NUM , NUM ) ; this . my _ cancel _ button . tab _ index = NUM ; this . my _ cancel _ button . text = STR ; this . my _ cancel _ button . use _ visual _ style _ back _ color = true ; this . my _ cancel _ button . click + = new system . event _ handler ( this . cancel _ button _ click ) ; this . panel . auto _ size = true ; this . panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . panel . controls . add ( this . my _ cancel _ button ) ; this . panel . controls . add ( this . ok _ button ) ;
this . share _ over _ lan _ item , this . edit _ pac _ file _ item , this . menu _ item , this . qr _ code _ item , this . show _ log _ item , this . about _ item , this . menu _ item , this . quit _ item } ) ;
this . menu _ item , this . qr _ code _ item , this . show _ log _ item , this . about _ item , this . menu _ item , this . quit _ item } ) ; this . enable _ item . index = 0 ; this . enable _ item . text = STR ;
this . qr _ code _ item , this . show _ log _ item , this . about _ item , this . menu _ item , this . quit _ item } ) ; this . enable _ item . index = 0 ; this . enable _ item . text = STR ; this . enable _ item . click + = new system . event _ handler ( this . enable _ item _ click ) ; this . auto _ startup _ item . index = NUM ;
this . enable _ item . index = 0 ; this . enable _ item . text = STR ; this . enable _ item . click + = new system . event _ handler ( this . enable _ item _ click ) ; this . auto _ startup _ item . index = NUM ; this . auto _ startup _ item . text = STR ; this . auto _ startup _ item . click + = new system . event _ handler ( this . auto _ startup _ item _ click ) ; this . share _ over _ lan _ item . index = NUM ; this . share _ over _ lan _ item . text = STR ; this . share _ over _ lan _ item . click + = new system . event _ handler ( this . share _ over _ lan _ item _ click ) ; this . servers _ item . index = 1 ;
this . share _ over _ lan _ item . text = STR ; this . share _ over _ lan _ item . click + = new system . event _ handler ( this . share _ over _ lan _ item _ click ) ; this . servers _ item . index = 1 ; this . servers _ item . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . seperator _ item , this . config _ item } ) ; this . servers _ item . text = STR ; this . seperator _ item . index = 0 ; this . seperator _ item . text = STR ; this . config _ item . index = 1 ;
this . servers _ item . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . seperator _ item , this . config _ item } ) ; this . servers _ item . text = STR ; this . seperator _ item . index = 0 ; this . seperator _ item . text = STR ; this . config _ item . index = 1 ; this . config _ item . text = STR ; this . config _ item . click + = new system . event _ handler ( this . config _ click ) ; this . menu _ item . index = NUM ;
this . delete _ button . name = STR ; this . delete _ button . size = new system . drawing . size ( NUM , NUM ) ; this . delete _ button . tab _ index = NUM ; this . delete _ button . text = STR ; this . delete _ button . use _ visual _ style _ back _ color = true ; this . delete _ button . click + = new system . event _ handler ( this . delete _ button _ click ) ; this . add _ button . location = new system . drawing . point ( NUM , NUM ) ; this . add _ button . name = STR ; this . add _ button . size = new system . drawing . size ( NUM , NUM ) ;
this . add _ button . name = STR ; this . add _ button . size = new system . drawing . size ( NUM , NUM ) ; this . add _ button . tab _ index = NUM ; this . add _ button . text = STR ; this . add _ button . use _ visual _ style _ back _ color = true ; this . add _ button . click + = new system . event _ handler ( this . add _ button _ click ) ; this . server _ group _ box . controls . add ( this . table _ layout _ panel ) ; this . server _ group _ box . location = new system . drawing . point ( NUM , NUM ) ; this . server _ group _ box . name = STR ;
this . server _ group _ box . name = STR ; this . server _ group _ box . size = new system . drawing . size ( NUM , NUM ) ; this . server _ group _ box . tab _ index = NUM ; this . server _ group _ box . tab _ stop = false ; this . server _ group _ box . text = STR ; this . servers _ list _ box . formatting _ enabled = true ; this . servers _ list _ box . location = new system . drawing . point ( NUM , NUM ) ;
this . server _ group _ box . tab _ index = NUM ; this . server _ group _ box . tab _ stop = false ; this . server _ group _ box . text = STR ; this . servers _ list _ box . formatting _ enabled = true ; this . servers _ list _ box . location = new system . drawing . point ( NUM , NUM ) ; this . servers _ list _ box . name = STR ; this . servers _ list _ box . size = new system . drawing . size ( NUM , NUM ) ; this . servers _ list _ box . tab _ index = NUM ;
this . servers _ list _ box . name = STR ; this . servers _ list _ box . size = new system . drawing . size ( NUM , NUM ) ; this . servers _ list _ box . tab _ index = NUM ; this . servers _ list _ box . selected _ index _ changed + = new system . event _ handler ( this . servers _ list _ box _ selected _ index _ changed ) ; this . menu _ item . index = 2 ; this . menu _ item . text = STR ; this . accept _ button = this . ok _ button ; this . auto _ scale _ mode = system . windows . forms . auto _ scale _ mode . dpi ; this . auto _ size = true ;
this . accept _ button = this . ok _ button ; this . auto _ scale _ mode = system . windows . forms . auto _ scale _ mode . dpi ; this . auto _ size = true ; this . cancel _ button = this . my _ cancel _ button ; this . client _ size = new system . drawing . size ( NUM , NUM ) ; this . controls . add ( this . servers _ list _ box ) ; this . controls . add ( this . server _ group _ box ) ; this . controls . add ( this . panel ) ; this . controls . add ( this . panel ) ; this . controls . add ( this . panel ) ;
message _ box . show ( STR ) ; } } } }
} }
notify _ icon . balloon _ tip _ clicked - = notify _ icon _ balloon _ tip _ clicked ; string argument = STR + update _ checker . latest _ version _ local _ name + STR ; system . diagnostics . process . start ( STR , argument ) ;
using system _ collections ; using system _ collections _ generic ; using system _ net ; using system _ reflection ; using system _ text ; using system _ text _ regular _ expressions ; using system _ io ; using simple _ json ; using shadowsocks _ model ; using shadowsocks _ util ;
{ web _ client http = create _ web _ client ( ) ; http . download _ string _ completed + = http _ download _ string _ completed ; http . download _ string _ async ( new uri ( update _ url ) ) ;
} catch ( exception ex ) { logging . log _ useful _ exception ( ex ) ; }
{ logging . log _ useful _ exception ( ex ) ; }
}
} private void http _ download _ string _ completed ( object sender , download _ string _ completed _ event _ args e ) { try { string response = e . result ; json _ array result = ( json _ array ) simple _ json . simple _ json . deserialize _ object ( e . result ) ; list < asset > asserts = new list < asset > ( ) ; foreach ( json _ object release in result ) {
foreach ( json _ object release in result ) { if ( ( bool ) release [ STR ] ) { continue ; } foreach ( json _ object asset in ( json _ array ) release [ STR ] ) { asset ass = new asset ( ) ; ass . parse ( asset ) ;
{ asserts . add ( ass ) ; } } } if ( asserts . count ! = 0 ) { sort _ by _ versions ( asserts ) ; asset asset = asserts [ asserts . count - 1 ] ; new _ version _ found = true ;
} } } if ( asserts . count ! = 0 ) { sort _ by _ versions ( asserts ) ; asset asset = asserts [ asserts . count - 1 ] ; new _ version _ found = true ; latest _ version _ url = asset . browser _ download _ url ; latest _ version _ number = asset . version ;
{ sort _ by _ versions ( asserts ) ; asset asset = asserts [ asserts . count - 1 ] ; new _ version _ found = true ; latest _ version _ url = asset . browser _ download _ url ; latest _ version _ number = asset . version ; latest _ version _ name = asset . name ; start _ download ( ) ; } else if ( check _ update _ completed ! = null )
new _ version _ found = true ; latest _ version _ url = asset . browser _ download _ url ; latest _ version _ number = asset . version ; latest _ version _ name = asset . name ; start _ download ( ) ; } else if ( check _ update _ completed ! = null ) { check _ update _ completed ( this , new event _ args ( ) ) ; }
} if ( check _ update _ completed ! = null ) { check _ update _ completed ( this , new event _ args ( ) ) ; } } catch ( exception ex ) { logging . log _ useful _ exception ( ex ) ; }
} } } }
{ try { string pac = get _ pac _ content ( ) ; ip _ end _ point local _ end _ point = ( ip _ end _ point ) socket . local _ end _ point ; string proxy = get _ pac _ address ( first _ packet , length , local _ end _ point , use _ socks ) ; pac = pac . replace ( STR , proxy ) ; string text = string . format ( @ STR server : shadowsocks content - type : application / x - ns - proxy - autoconfig
pac = pac . replace ( STR , proxy ) ; string text = string . format ( @ STR server : shadowsocks content - type : application / x - ns - proxy - autoconfig content - length : { 0 } connection : close STR byte [ ] response = system . text . encoding . ut . get _ bytes ( text ) ; socket . begin _ send ( response , 0 , response . length , 0 , new async _ callback ( send _ callback ) , socket ) ; util . utils . release _ memory ( ) ;
{ return ( use _ socks ? STR : STR ) + local _ end _ point . address + STR + this . config . local _ port + STR ; } } }
} } }
polipo _ config = polipo _ config . replace ( STR , configuration . share _ over _ lan ? STR : STR ) ; file _ manager . byte _ array _ to _ file ( temppath + STR , system . text . encoding . ut . get _ bytes ( polipo _ config ) ) ; process = new process ( ) ; process . start _ info . file _ name = temppath + STR ; process . start _ info . arguments = STR + temppath + STR ; process . start _ info . window _ style = process _ window _ style . hidden ; process . start _ info . use _ shell _ execute = true ; process . start _ info . create _ no _ window = true ; process . start ( ) ; }
sysproxy . set _ ie _ proxy ( true , false , STR , pac _ url ) ; } } else { sysproxy . set _ ie _ proxy ( false , false , STR , STR ) ; } } catch ( proxy _ exception ex ) {
server = > new key _ value _ pair < string , string > ( server . get _ url ( config . generate _ legacy _ url ) , server . to _ string ( ) ) ) . to _ list ( ) ; list _ box . data _ source = server _ datas ; int select _ index = server _ datas . find _ index ( server _ data = > server _ data . key . starts _ with ( code ) ) ; if ( select _ index > = 0 ) list _ box . set _ selected ( select _ index , true ) ; } private void list _ box _ selected _ index _ changed ( object sender , event _ args e ) { var url = ( sender as list _ box ) ? . selected _ value . to _ string ( ) ;
) . to _ list ( ) ; list _ box . data _ source = server _ datas ; int select _ index = server _ datas . find _ index ( server _ data = > server _ data . key . starts _ with ( code ) ) ; if ( select _ index > = 0 ) list _ box . set _ selected ( select _ index , true ) ; } private void list _ box _ selected _ index _ changed ( object sender , event _ args e ) { var url = ( sender as list _ box ) ? . selected _ value . to _ string ( ) ; gen _ qr ( url ) ; text _ box _ url . text = url ;
if ( select _ index > = 0 ) list _ box . set _ selected ( select _ index , true ) ; } private void list _ box _ selected _ index _ changed ( object sender , event _ args e ) { var url = ( sender as list _ box ) ? . selected _ value . to _ string ( ) ; gen _ qr ( url ) ; text _ box _ url . text = url ; } private void text _ box _ url _ click ( object sender , event _ args e ) {
string plugin _ part = plugin ; if ( ! string . is _ null _ or _ white _ space ( plugin _ opts ) ) { plugin _ part + = STR + plugin _ opts ; } string plugin _ query = STR + http _ utility . url _ encode ( plugin _ part , encoding . ut ) ; url + = plugin _ query ; } } if ( ! remarks . is _ null _ or _ empty ( ) )
} public string formal _ host _ name { get { switch ( uri . check _ host _ name ( server ) ) { case uri _ host _ name _ type . i _ pv : return $ STR ; default :
func < string , object , bool > on _ line _ read , action < exception , object > on _ exception , action < byte [ ] , int , int , object > on _ finish , encoding encoding , string delimiter , int max _ line _ bytes , object state ) { if ( socket = = null )
object state ) { if ( socket = = null ) { throw new argument _ null _ exception ( nameof ( socket ) ) ; }
if ( socket = = null ) { throw new argument _ null _ exception ( nameof ( socket ) ) ; } if ( on _ line _ read = = null ) { throw new argument _ null _ exception ( nameof ( on _ line _ read ) ) ; } if ( encoding = = null ) {
{ throw new argument _ exception ( STR , nameof ( max _ line _ bytes ) ) ; } if ( length > 0 ) { if ( first _ packge = = null ) { throw new argument _ null _ exception ( nameof ( first _ packge ) ) ; } }
} if ( length > 0 ) { if ( first _ packge = = null ) { throw new argument _ null _ exception ( nameof ( first _ packge ) ) ; } } socket = socket ; on _ line _ read = on _ line _ read ;
{ throw new argument _ exception ( STR , nameof ( max _ line _ bytes ) ) ; } delimiter _ search = new byte _ search . search _ target ( delimiter _ bytes ) ; line _ buffer = new byte [ max _ line _ bytes ] ; if ( length > 0 ) { array . copy ( first _ packge , index , line _ buffer , 0 , length ) ;
} delimiter _ search = new byte _ search . search _ target ( delimiter _ bytes ) ; line _ buffer = new byte [ max _ line _ bytes ] ; if ( length > 0 ) { array . copy ( first _ packge , index , line _ buffer , 0 , length ) ;
if ( length > 0 ) { array . copy ( first _ packge , index , line _ buffer , 0 , length ) ;
buffer _ data _ length = length ; try { new _ package _ recv ( ) ; } catch ( exception ex ) { on _ exception ( ex ) ; on _ finish ( ) ; }
} } public line _ reader ( wrapped _ socket socket , func < string , object , bool > on _ line _ read , action < exception , object > on _ exception , action < byte [ ] , int , int , object > on _ finish , encoding encoding , string delimiter , int max _ line _ bytes , object state ) : this ( socket , null , 0 , 0 , on _ line _ read , on _ exception , on _ finish , encoding , delimiter , max _ line _ bytes , state )
{ } private void receive _ callback ( i _ async _ result ar ) { try { var bytes _ read = socket . end _ receive ( ar ) ; if ( bytes _ read = = 0 ) { on _ finish ( ) ;
} else { string pac _ url ; if ( config . use _ online _ pac & & ! config . pac _ url . is _ null _ or _ empty ( ) ) pac _ url = config . pac _ url ; else pac _ url = $ STR ; sysproxy . set _ ie _ proxy ( true , false , STR , pac _ url ) ; }
if ( ss _ url _ association = = null ) { logger . error ( STR ) ; return false ; } if ( enabled ) { ss _ url _ association . set _ value ( STR , STR ) ; ss _ url _ association . set _ value ( STR , STR ) ; var shell _ open = ss _ url _ association . create _ sub _ key ( STR ) . create _ sub _ key ( STR ) . create _ sub _ key ( STR ) ;
string config _ content = file . read _ all _ text ( config _ file ) ; configuration config = simple _ json . simple _ json . deserialize _ object < configuration > ( config _ content , new json _ serializer _ strategy ( ) ) ; config . is _ default = false ; return config ; } catch ( exception e ) { if ( ! ( e is file _ not _ found _ exception ) ) { console . write _ line ( e ) ;
config . is _ default = false ; return config ; } catch ( exception e ) { if ( ! ( e is file _ not _ found _ exception ) ) { console . write _ line ( e ) ; } return new configuration
using ( graphics g = graphics . from _ image ( draw _ area ) ) { g . clear ( color . white ) ; using ( brush b = new solid _ brush ( color . black ) ) { for ( int row = 0 ; row < m . height ; row + + ) { for ( int col = 0 ; col < m . height ; col + + ) { if ( m [ row , col ] ! = 0 )
{ for ( int col = 0 ; col < m . height ; col + + ) { if ( m [ row , col ] ! = 0 ) { g . fill _ rectangle ( b , block _ size * row , block _ size * col , block _ size , block _ size ) ; } } } }
{ if ( m [ row , col ] ! = 0 ) { g . fill _ rectangle ( b , block _ size * row , block _ size * col , block _ size , block _ size ) ; } } } } } picture _ box . image = draw _ area ;
{ g . fill _ rectangle ( b , block _ size * row , block _ size * col , block _ size , block _ size ) ; } } } } } picture _ box . image = draw _ area ; } private void qr _ code _ form _ load ( object sender , event _ args e )
} private menu _ item create _ menu _ group ( string text , menu _ item [ ] items ) { return new menu _ item ( n . get _ string ( text ) , items ) ;
} private void load _ menu ( ) { this . context _ menu = new system . windows . forms . context _ menu ( ) ; this . context _ menu . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . enable _ item = create _ menu _ item ( STR , new system . event _ handler ( this . enable _ item _ click ) ) , create _ menu _ group ( STR , new system . windows . forms . menu _ item [ ] { this . pac _ mode _ item = create _ menu _ item ( STR , new system . event _ handler ( this . pac _ mode _ item _ click ) ) , this . global _ mode _ item = create _ menu _ item ( STR , new system . event _ handler ( this . global _ mode _ item _ click ) ) } ) ,
this . config _ item = create _ menu _ item ( STR , new system . event _ handler ( this . config _ click ) ) } ) , new menu _ item ( STR ) , this . auto _ startup _ item = create _ menu _ item ( STR , new system . event _ handler ( this . auto _ startup _ item _ click ) ) , this . share _ over _ lan _ item = create _ menu _ item ( STR , new system . event _ handler ( this . share _ over _ lan _ item _ click ) ) , create _ menu _ item ( STR , new system . event _ handler ( this . edit _ pac _ file _ item _ click ) ) , new menu _ item ( STR ) , create _ menu _ item ( STR , new system . event _ handler ( this . qr _ code _ item _ click ) ) , create _ menu _ item ( STR , new system . event _ handler ( this . show _ log _ item _ click ) ) , create _ menu _ item ( STR , new system . event _ handler ( this . config _ click ) ) ,
this . auto _ startup _ item = create _ menu _ item ( STR , new system . event _ handler ( this . auto _ startup _ item _ click ) ) , this . share _ over _ lan _ item = create _ menu _ item ( STR , new system . event _ handler ( this . share _ over _ lan _ item _ click ) ) , create _ menu _ item ( STR , new system . event _ handler ( this . edit _ pac _ file _ item _ click ) ) , new menu _ item ( STR ) , create _ menu _ item ( STR , new system . event _ handler ( this . qr _ code _ item _ click ) ) , create _ menu _ item ( STR , new system . event _ handler ( this . show _ log _ item _ click ) ) , create _ menu _ item ( STR , new system . event _ handler ( this . config _ click ) ) , new menu _ item ( STR ) , create _ menu _ item ( STR , new system . event _ handler ( this . quit _ click ) ) } ) ;
create _ menu _ item ( STR , new system . event _ handler ( this . qr _ code _ item _ click ) ) , create _ menu _ item ( STR , new system . event _ handler ( this . show _ log _ item _ click ) ) , create _ menu _ item ( STR , new system . event _ handler ( this . config _ click ) ) , new menu _ item ( STR ) , create _ menu _ item ( STR , new system . event _ handler ( this . quit _ click ) ) } ) ; } private void controller _ config _ changed ( object sender , event _ args e ) { load _ current _ configuration ( ) ;
create _ menu _ item ( STR , new system . event _ handler ( this . quit _ click ) ) } ) ; } private void controller _ config _ changed ( object sender , event _ args e ) { load _ current _ configuration ( ) ; update _ tray _ icon ( ) ; } private void controller _ enable _ status _ changed ( object sender , event _ args e ) {
{ byte [ ] bytes = convert . from _ base _ string ( response ) ; string content = encoding . ascii . get _ string ( bytes ) ; return parse _ to _ valid _ list ( content ) ; } private static list < string > parse _ to _ valid _ list ( string content ) { list < string > valid _ lines = new list < string > ( ) ; using ( var sr = new string _ reader ( content ) ) {
} else { arguments = $ STR ; } } else { arguments = STR ; }
} } else { arguments = STR ; } using ( var process = new process ( ) ) { process . start _ info . file _ name = utils . get _ temp _ path ( STR ) ; process . start _ info . arguments = arguments ;
controller . enable _ status _ changed + = controller _ enable _ status _ changed ; controller . config _ changed + = controller _ config _ changed ; controller . pac _ file _ ready _ to _ open + = controller _ pac _ file _ ready _ to _ open ; controller . share _ over _ lan _ status _ changed + = controller _ share _ over _ lan _ status _ changed ; controller . enable _ global _ changed + = controller _ enable _ global _ changed ; controller . errored + = controller _ errored ; notify _ icon = new notify _ icon ( ) ; load _ tray _ icon ( ) ; notify _ icon . visible = true ; notify _ icon . text = n . get _ string ( STR ) ;
this . enable _ item . click + = new system . event _ handler ( this . enable _ item _ click ) ; this . mode _ item . index = 1 ; this . mode _ item . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . pac _ mode _ item , this . global _ mode _ item } ) ; this . mode _ item . text = n . get _ string ( STR ) ; this . pac _ mode _ item . index = 0 ; this . pac _ mode _ item . text = n . get _ string ( STR ) ; this . pac _ mode _ item . click + = new system . event _ handler ( this . pac _ mode _ item _ click ) ; this . global _ mode _ item . index = 1 ;
this . pac _ mode _ item . index = 0 ; this . pac _ mode _ item . text = n . get _ string ( STR ) ; this . pac _ mode _ item . click + = new system . event _ handler ( this . pac _ mode _ item _ click ) ; this . global _ mode _ item . index = 1 ; this . global _ mode _ item . text = n . get _ string ( STR ) ; this . global _ mode _ item . click + = new system . event _ handler ( this . global _ mode _ item _ click ) ; this . servers _ item . index = 2 ; this . servers _ item . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . seperator _ item , this . config _ item } ) ;
this . pac _ mode _ item . click + = new system . event _ handler ( this . pac _ mode _ item _ click ) ; this . global _ mode _ item . index = 1 ; this . global _ mode _ item . text = n . get _ string ( STR ) ; this . global _ mode _ item . click + = new system . event _ handler ( this . global _ mode _ item _ click ) ; this . servers _ item . index = 2 ; this . servers _ item . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . seperator _ item , this . config _ item } ) ; this . servers _ item . text = n . get _ string ( STR ) ; this . seperator _ item . index = 0 ;
this . global _ mode _ item . click + = new system . event _ handler ( this . global _ mode _ item _ click ) ; this . servers _ item . index = 2 ; this . servers _ item . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . seperator _ item , this . config _ item } ) ; this . servers _ item . text = n . get _ string ( STR ) ; this . seperator _ item . index = 0 ; this . seperator _ item . text = STR ; this . config _ item . index = 1 ; this . config _ item . text = n . get _ string ( STR ) ;
this . seperator _ item . index = 0 ; this . seperator _ item . text = STR ; this . config _ item . index = 1 ; this . config _ item . text = n . get _ string ( STR ) ; this . config _ item . click + = new system . event _ handler ( this . config _ click ) ; this . menu _ item . index = NUM ; this . menu _ item . text = STR ; this . auto _ startup _ item . index = NUM ; this . auto _ startup _ item . text = n . get _ string ( STR ) ; this . auto _ startup _ item . click + = new system . event _ handler ( this . auto _ startup _ item _ click ) ;
this . config _ item . click + = new system . event _ handler ( this . config _ click ) ; this . menu _ item . index = NUM ; this . menu _ item . text = STR ; this . auto _ startup _ item . index = NUM ; this . auto _ startup _ item . text = n . get _ string ( STR ) ; this . auto _ startup _ item . click + = new system . event _ handler ( this . auto _ startup _ item _ click ) ; this . share _ over _ lan _ item . index = NUM ; this . share _ over _ lan _ item . text = n . get _ string ( STR ) ; this . share _ over _ lan _ item . click + = new system . event _ handler ( this . share _ over _ lan _ item _ click ) ; this . edit _ pac _ file _ item . index = NUM ;
this . auto _ startup _ item . click + = new system . event _ handler ( this . auto _ startup _ item _ click ) ; this . share _ over _ lan _ item . index = NUM ; this . share _ over _ lan _ item . text = n . get _ string ( STR ) ; this . share _ over _ lan _ item . click + = new system . event _ handler ( this . share _ over _ lan _ item _ click ) ; this . edit _ pac _ file _ item . index = NUM ; this . edit _ pac _ file _ item . text = n . get _ string ( STR ) ; this . edit _ pac _ file _ item . click + = new system . event _ handler ( this . edit _ pac _ file _ item _ click ) ; this . menu _ item . index = NUM ; this . menu _ item . text = STR ; this . qr _ code _ item . index = NUM ;
this . share _ over _ lan _ item . click + = new system . event _ handler ( this . share _ over _ lan _ item _ click ) ; this . edit _ pac _ file _ item . index = NUM ; this . edit _ pac _ file _ item . text = n . get _ string ( STR ) ; this . edit _ pac _ file _ item . click + = new system . event _ handler ( this . edit _ pac _ file _ item _ click ) ; this . menu _ item . index = NUM ; this . menu _ item . text = STR ; this . qr _ code _ item . index = NUM ; this . qr _ code _ item . text = n . get _ string ( STR ) ; this . qr _ code _ item . click + = new system . event _ handler ( this . qr _ code _ item _ click ) ; this . show _ log _ item . index = NUM ;
this . edit _ pac _ file _ item . click + = new system . event _ handler ( this . edit _ pac _ file _ item _ click ) ; this . menu _ item . index = NUM ; this . menu _ item . text = STR ; this . qr _ code _ item . index = NUM ; this . qr _ code _ item . text = n . get _ string ( STR ) ; this . qr _ code _ item . click + = new system . event _ handler ( this . qr _ code _ item _ click ) ; this . show _ log _ item . index = NUM ; this . show _ log _ item . text = n . get _ string ( STR ) ; this . show _ log _ item . click + = new system . event _ handler ( this . show _ log _ item _ click ) ; this . about _ item . index = NUM ;
this . qr _ code _ item . click + = new system . event _ handler ( this . qr _ code _ item _ click ) ; this . show _ log _ item . index = NUM ; this . show _ log _ item . text = n . get _ string ( STR ) ; this . show _ log _ item . click + = new system . event _ handler ( this . show _ log _ item _ click ) ; this . about _ item . index = NUM ; this . about _ item . text = n . get _ string ( STR ) ; this . about _ item . click + = new system . event _ handler ( this . about _ item _ click ) ; this . menu _ item . index = NUM ; this . menu _ item . text = STR ; this . quit _ item . index = NUM ;
this . show _ log _ item . click + = new system . event _ handler ( this . show _ log _ item _ click ) ; this . about _ item . index = NUM ; this . about _ item . text = n . get _ string ( STR ) ; this . about _ item . click + = new system . event _ handler ( this . about _ item _ click ) ; this . menu _ item . index = NUM ; this . menu _ item . text = STR ; this . quit _ item . index = NUM ; this . quit _ item . text = n . get _ string ( STR ) ; this . quit _ item . click + = new system . event _ handler ( this . quit _ click ) ; }
this . about _ item . click + = new system . event _ handler ( this . about _ item _ click ) ; this . menu _ item . index = NUM ; this . menu _ item . text = STR ; this . quit _ item . index = NUM ; this . quit _ item . text = n . get _ string ( STR ) ; this . quit _ item . click + = new system . event _ handler ( this . quit _ click ) ; } private void controller _ config _ changed ( object sender , event _ args e ) { load _ current _ configuration ( ) ;
this . quit _ item . click + = new system . event _ handler ( this . quit _ click ) ; } private void controller _ config _ changed ( object sender , event _ args e ) { load _ current _ configuration ( ) ; } private void controller _ enable _ status _ changed ( object sender , event _ args e ) { enable _ item . checked = controller . get _ configuration ( ) . enabled ; load _ tray _ icon ( ) ;
this . proxy _ port _ text _ box = new system . windows . forms . text _ box ( ) ; this . proxy _ port _ label = new system . windows . forms . label ( ) ; this . password _ label = new system . windows . forms . label ( ) ; this . ip _ text _ box = new system . windows . forms . text _ box ( ) ; this . server _ port _ text _ box = new system . windows . forms . text _ box ( ) ; this . password _ text _ box = new system . windows . forms . text _ box ( ) ; this . encryption _ label = new system . windows . forms . label ( ) ; this . encryption _ select = new system . windows . forms . combo _ box ( ) ; this . panel = new system . windows . forms . panel ( ) ; this . ok _ button = new system . windows . forms . button ( ) ;
this . ip _ text _ box = new system . windows . forms . text _ box ( ) ; this . server _ port _ text _ box = new system . windows . forms . text _ box ( ) ; this . password _ text _ box = new system . windows . forms . text _ box ( ) ; this . encryption _ label = new system . windows . forms . label ( ) ; this . encryption _ select = new system . windows . forms . combo _ box ( ) ; this . panel = new system . windows . forms . panel ( ) ; this . ok _ button = new system . windows . forms . button ( ) ; this . my _ cancel _ button = new system . windows . forms . button ( ) ; this . panel = new system . windows . forms . panel ( ) ; this . panel = new system . windows . forms . panel ( ) ;
this . encryption _ select = new system . windows . forms . combo _ box ( ) ; this . panel = new system . windows . forms . panel ( ) ; this . ok _ button = new system . windows . forms . button ( ) ; this . my _ cancel _ button = new system . windows . forms . button ( ) ; this . panel = new system . windows . forms . panel ( ) ; this . panel = new system . windows . forms . panel ( ) ; this . delete _ button = new system . windows . forms . button ( ) ; this . add _ button = new system . windows . forms . button ( ) ; this . server _ group _ box = new system . windows . forms . group _ box ( ) ; this . servers _ list _ box = new system . windows . forms . list _ box ( ) ;
this . table _ layout _ panel . controls . add ( this . proxy _ port _ text _ box , 1 , NUM ) ; this . table _ layout _ panel . controls . add ( this . proxy _ port _ label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . password _ label , 0 , 2 ) ; this . table _ layout _ panel . controls . add ( this . ip _ text _ box , 1 , 0 ) ; this . table _ layout _ panel . controls . add ( this . server _ port _ text _ box , 1 , 1 ) ; this . table _ layout _ panel . controls . add ( this . password _ text _ box , 1 , 2 ) ; this . table _ layout _ panel . controls . add ( this . encryption _ label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . encryption _ select , 1 , NUM ) ; this . table _ layout _ panel . location = new system . drawing . point ( NUM , NUM ) ; this . table _ layout _ panel . margin = new system . windows . forms . padding ( NUM ) ;
this . table _ layout _ panel . controls . add ( this . ip _ text _ box , 1 , 0 ) ; this . table _ layout _ panel . controls . add ( this . server _ port _ text _ box , 1 , 1 ) ; this . table _ layout _ panel . controls . add ( this . password _ text _ box , 1 , 2 ) ; this . table _ layout _ panel . controls . add ( this . encryption _ label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . encryption _ select , 1 , NUM ) ; this . table _ layout _ panel . location = new system . drawing . point ( NUM , NUM ) ; this . table _ layout _ panel . margin = new system . windows . forms . padding ( NUM ) ; this . table _ layout _ panel . name = STR ; this . table _ layout _ panel . padding = new system . windows . forms . padding ( NUM ) ; this . table _ layout _ panel . row _ count = NUM ;
this . table _ layout _ panel . controls . add ( this . encryption _ select , 1 , NUM ) ; this . table _ layout _ panel . location = new system . drawing . point ( NUM , NUM ) ; this . table _ layout _ panel . margin = new system . windows . forms . padding ( NUM ) ; this . table _ layout _ panel . name = STR ; this . table _ layout _ panel . padding = new system . windows . forms . padding ( NUM ) ; this . table _ layout _ panel . row _ count = NUM ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ;
this . proxy _ port _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . proxy _ port _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . proxy _ port _ text _ box . name = STR ; this . proxy _ port _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . proxy _ port _ text _ box . tab _ index = NUM ; this . proxy _ port _ text _ box . word _ wrap = false ; this . proxy _ port _ label . anchor = system . windows . forms . anchor _ styles . right ; this . proxy _ port _ label . auto _ size = true ; this . proxy _ port _ label . location = new system . drawing . point ( NUM , NUM ) ; this . proxy _ port _ label . name = STR ;
this . ip _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . ip _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . ip _ text _ box . name = STR ; this . ip _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . ip _ text _ box . tab _ index = 0 ; this . ip _ text _ box . word _ wrap = false ; this . server _ port _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . server _ port _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . server _ port _ text _ box . name = STR ; this . server _ port _ text _ box . size = new system . drawing . size ( NUM , NUM ) ;
private system . windows . forms . text _ box ip _ text _ box ; private system . windows . forms . text _ box server _ port _ text _ box ; private system . windows . forms . text _ box password _ text _ box ; private system . windows . forms . text _ box proxy _ port _ text _ box ; private system . windows . forms . label encryption _ label ; private system . windows . forms . combo _ box encryption _ select ; private system . windows . forms . panel panel ; private system . windows . forms . button ok _ button ; private system . windows . forms . button my _ cancel _ button ; private system . windows . forms . panel panel ;
private system . windows . forms . combo _ box encryption _ select ; private system . windows . forms . panel panel ; private system . windows . forms . button ok _ button ; private system . windows . forms . button my _ cancel _ button ; private system . windows . forms . panel panel ; private system . windows . forms . panel panel ; private system . windows . forms . button delete _ button ; private system . windows . forms . button add _ button ; private system . windows . forms . group _ box server _ group _ box ; private system . windows . forms . list _ box servers _ list _ box ;
load _ configuration ( modified _ configuration ) ; servers _ list _ box . selected _ index = curr _ index + 1 ; last _ selected _ index = servers _ list _ box . selected _ index ; } private void delete _ button _ click ( object sender , event _ args e ) { last _ selected _ index = servers _ list _ box . selected _ index ; if ( last _ selected _ index > = 0 & & last _ selected _ index < modified _ configuration . configs . count ) { modified _ configuration . configs . remove _ at ( last _ selected _ index ) ;
last _ selected _ index = servers _ list _ box . selected _ index ; } private void delete _ button _ click ( object sender , event _ args e ) { last _ selected _ index = servers _ list _ box . selected _ index ; if ( last _ selected _ index > = 0 & & last _ selected _ index < modified _ configuration . configs . count ) { modified _ configuration . configs . remove _ at ( last _ selected _ index ) ; } if ( last _ selected _ index > = modified _ configuration . configs . count )
} catch ( io _ exception ) { } catch ( exception e ) { console . write _ line ( e . to _ string ( ) ) ; }
{ console . write _ line ( e . to _ string ( ) ) ; } } dll _ import _ kernel _ dll private static extern int _ ptr load _ library ( string path ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void aes _ init ( int _ ptr ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl
} dll _ import _ kernel _ dll private static extern int _ ptr load _ library ( string path ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void aes _ init ( int _ ptr ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void aes _ free ( int _ ptr ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int aes _ setkey _ enc ( int _ ptr ctx , byte [ ] key , int keysize ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl
get { object obj = resource _ manager . get _ object ( STR , resource _ culture ) ; return ( ( byte [ ] ) ( obj ) ) ; }
return ( ( byte [ ] ) ( obj ) ) ; } } internal static string polipo _ config { get { return resource _ manager . get _ string ( STR , resource _ culture ) ; } } internal static byte [ ] polipo _ exe { get {
} catch ( io _ exception ) { } catch ( exception e ) { console . write _ line ( e . to _ string ( ) ) ; }
{ console . write _ line ( e . to _ string ( ) ) ; } } dll _ import _ kernel _ dll private static extern int _ ptr load _ library ( string path ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void crypto _ stream _ salsa _ xor _ ic ( byte [ ] c , byte [ ] m , ulong mlen , byte [ ] n , ulong ic , byte [ ] k ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl
} dll _ import _ kernel _ dll private static extern int _ ptr load _ library ( string path ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void crypto _ stream _ salsa _ xor _ ic ( byte [ ] c , byte [ ] m , ulong mlen , byte [ ] n , ulong ic , byte [ ] k ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void crypto _ stream _ chacha _ xor _ ic ( byte [ ] c , byte [ ] m , ulong mlen , byte [ ] n , ulong ic , byte [ ] k ) ; } }
} private void log _ form _ form _ closing ( object sender , form _ closing _ event _ args e ) { timer . stop ( ) ; config . log _ viewer . top _ most = top _ most _ trigger ; config . log _ viewer . wrap _ text = wrap _ text _ trigger ; config . log _ viewer . toolbar _ shown = toolbar _ trigger ; config . log _ viewer . font _ name = log _ message _ text _ box . font . name ; config . log _ viewer . font _ size = log _ message _ text _ box . font . size ; config . log _ viewer . set _ background _ color ( log _ message _ text _ box . back _ color ) ;
} } else { if ( line . is _ null _ or _ empty ( ) ) { return true ;
return true ; } if ( ! is _ connect ) { if ( line . starts _ with ( STR ) ) {
} if ( ! is _ connect ) { if ( line . starts _ with ( STR ) ) { var location = line . substring ( NUM ) . trim ( ) ; var locs = location . split ( ':' ) ; target _ host = locs [ 0 ] ; if ( locs . length > 1 ) {
{ hotkey = keymap . first ( v = > v . value = = cb ) . key ; return true ; } else { hotkey = null ; return false ;
return true ; } else { hotkey = null ; return false ; } } public static string hot _ key _ str ( hot _ key key ) {
{ hotkey = null ; return false ; } } public static string hot _ key _ str ( hot _ key key ) { if ( key = = null ) throw new argument _ null _ exception ( nameof ( key ) ) ; return hot _ key _ str ( key . key , key . modifiers ) ; }
private void cancel _ button _ click ( object sender , event _ args e ) { this . close ( ) ; } private void ok _ button _ click ( object sender , event _ args e ) { modified _ hotkey _ config = get _ config _ from _ ui ( ) ; if ( ! register _ all _ hotkeys ( modified _ hotkey _ config ) ) { message _ box . show ( n . get _ string ( STR ) ) ;
{ message _ box . show ( n . get _ string ( STR ) ) ; } save _ config ( ) ; this . close ( ) ; } private void register _ all _ button _ click ( object sender , event _ args e ) { modified _ hotkey _ config = get _ config _ from _ ui ( ) ; register _ all _ hotkeys ( modified _ hotkey _ config ) ;
} private static void unreg _ prev _ hotkey ( hot _ keys . hot _ key _ call _ back _ handler cb ) { global _ hot _ key . hot _ key prev _ hot _ key ; if ( hot _ keys . is _ callback _ exists ( cb , out prev _ hot _ key ) ) { hot _ keys . unregister ( prev _ hot _ key ) ; } }
} }
this . switch _ system _ proxy _ text _ box . key _ down + = new system . windows . forms . key _ event _ handler ( this . hotkey _ down ) ; this . switch _ system _ proxy _ text _ box . key _ up + = new system . windows . forms . key _ event _ handler ( this . hotkey _ up ) ; this . switch _ proxy _ mode _ text _ box . dock = system . windows . forms . dock _ style . fill ; this . switch _ proxy _ mode _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . switch _ proxy _ mode _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . switch _ proxy _ mode _ text _ box . name = STR ; this . switch _ proxy _ mode _ text _ box . read _ only = true ; this . switch _ proxy _ mode _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . switch _ proxy _ mode _ text _ box . tab _ index = NUM ;
this . switch _ proxy _ mode _ text _ box . key _ down + = new system . windows . forms . key _ event _ handler ( this . hotkey _ down ) ; this . switch _ proxy _ mode _ text _ box . key _ up + = new system . windows . forms . key _ event _ handler ( this . hotkey _ up ) ; this . switch _ allow _ lan _ text _ box . dock = system . windows . forms . dock _ style . fill ; this . switch _ allow _ lan _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . switch _ allow _ lan _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . switch _ allow _ lan _ text _ box . name = STR ; this . switch _ allow _ lan _ text _ box . read _ only = true ; this . switch _ allow _ lan _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . switch _ allow _ lan _ text _ box . tab _ index = NUM ;
this . switch _ allow _ lan _ text _ box . key _ down + = new system . windows . forms . key _ event _ handler ( this . hotkey _ down ) ; this . switch _ allow _ lan _ text _ box . key _ up + = new system . windows . forms . key _ event _ handler ( this . hotkey _ up ) ; this . show _ logs _ text _ box . dock = system . windows . forms . dock _ style . fill ; this . show _ logs _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . show _ logs _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . show _ logs _ text _ box . name = STR ; this . show _ logs _ text _ box . read _ only = true ; this . show _ logs _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . show _ logs _ text _ box . tab _ index = NUM ;
this . show _ logs _ text _ box . key _ down + = new system . windows . forms . key _ event _ handler ( this . hotkey _ down ) ; this . show _ logs _ text _ box . key _ up + = new system . windows . forms . key _ event _ handler ( this . hotkey _ up ) ; this . server _ move _ up _ text _ box . dock = system . windows . forms . dock _ style . fill ; this . server _ move _ up _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . server _ move _ up _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . server _ move _ up _ text _ box . name = STR ; this . server _ move _ up _ text _ box . read _ only = true ; this . server _ move _ up _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . server _ move _ up _ text _ box . tab _ index = NUM ;
this . server _ move _ up _ text _ box . key _ down + = new system . windows . forms . key _ event _ handler ( this . hotkey _ down ) ; this . server _ move _ up _ text _ box . key _ up + = new system . windows . forms . key _ event _ handler ( this . hotkey _ up ) ; this . server _ move _ down _ text _ box . dock = system . windows . forms . dock _ style . fill ; this . server _ move _ down _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . server _ move _ down _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . server _ move _ down _ text _ box . name = STR ; this . server _ move _ down _ text _ box . read _ only = true ; this . server _ move _ down _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . server _ move _ down _ text _ box . tab _ index = NUM ;

{ controller = controller ; config = conf ; handlers = new hash _ set < tcp _ handler > ( ) ; last _ sweep _ time = date _ time . now ; } public bool handle ( byte [ ] first _ packet , int length , socket socket , object state ) { if ( socket . protocol _ type ! = protocol _ type . tcp ) {
public socket connection ; public shadowsocks _ controller controller ; public tcp _ relay relay ; public date _ time last _ activity ; private const int max _ retry = NUM ; private int retry _ count = 0 ; private bool proxy _ connected ; private bool dest _ connected ; private byte command ;
private byte command ; private byte [ ] first _ packet ; private int first _ packet _ length ; public const int recv _ size = NUM ; public const int recv _ reserve _ size = iv _ encryptor . onetimeauth _ bytes + iv _ encryptor . auth _ bytes ; public const int buffer _ size = recv _ size + recv _ reserve _ size + NUM ; private int total _ read = 0 ; private int total _ write = 0 ; private byte [ ] remote _ recv _ buffer = new byte [ buffer _ size ] ; private byte [ ] remote _ send _ buffer = new byte [ buffer _ size ] ;
connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , 0 , new async _ callback ( read _ all ) , null ) ; } else { int bytes _ read = connection . end _ receive ( ar ) ; if ( bytes _ read > 0 ) { logging . debug ( remote . local _ end _ point , remote . dest _ end _ point , recv _ size , STR ) ; connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , 0 , new async _ callback ( read _ all ) , null ) ; }
connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , 0 , new async _ callback ( read _ all ) , null ) ; } else { close ( ) ; } } } catch ( exception e ) {
start _ connect _ time = date _ time . now ; server _ timer connect _ timer = new server _ timer ( NUM ) ; connect _ timer . auto _ reset = false ; connect _ timer . elapsed + = dest _ connect _ timer _ elapsed ; connect _ timer . enabled = true ; connect _ timer . server = server ; dest _ connected = false ; remote . begin _ connect _ dest ( dest _ ep , new async _ callback ( connect _ callback ) , connect _ timer ) ; } catch ( argument _ exception )
connect _ timer . enabled = true ; connect _ timer . server = server ; dest _ connected = false ; remote . begin _ connect _ dest ( dest _ ep , new async _ callback ( connect _ callback ) , connect _ timer ) ; } catch ( argument _ exception ) { } catch ( exception e ) {
remote . begin _ connect _ dest ( dest _ ep , new async _ callback ( connect _ callback ) , connect _ timer ) ; } catch ( argument _ exception ) { } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; retry _ connect ( ) ; }
{ return ; } server server = ( ( server _ timer ) sender ) . server ; i _ strategy strategy = controller . get _ current _ strategy ( ) ; if ( strategy ! = null ) { strategy . set _ failure ( server ) ; } logging . info ( $ STR ) ;
timer . enabled = false ; timer . dispose ( ) ; remote . end _ connect _ dest ( ar ) ; dest _ connected = true ; logging . debug ( $ STR ) ; var latency = date _ time . now - start _ connect _ time ; i _ strategy strategy = controller . get _ current _ strategy ( ) ; strategy ? . update _ latency ( server , latency ) ; tcprelay . update _ latency ( server , latency ) ; start _ pipe ( ) ;
var latency = date _ time . now - start _ connect _ time ; i _ strategy strategy = controller . get _ current _ strategy ( ) ; strategy ? . update _ latency ( server , latency ) ; tcprelay . update _ latency ( server , latency ) ; start _ pipe ( ) ; } catch ( argument _ exception ) { } catch ( exception e )
{ this . key _ size = key _ size ; this . iv _ size = iv _ size ; this . type = type ; this . inner _ lib _ name = inner _ lib _ name ; } public encryptor _ info ( int key _ size , int iv _ size , int type ) { this . key _ size = key _ size ; this . iv _ size = iv _ size ;
} } public abstract class encryptor _ base : i _ encryptor { public const int max _ input _ size = NUM ; protected encryptor _ base ( string method , string password , bool onetimeauth , bool isudp ) { method = method ; password = password ;
{ if ( ! mutex . wait _ one ( 0 , false ) ) { process [ ] old _ processes = process . get _ processes _ by _ name ( STR ) ; if ( old _ processes . length > 0 ) { process old _ process = old _ processes [ 0 ] ; } message _ box . show ( STR ) ; return ;
}
} } }
series . is _ x _ value _ indexed = true ; series . legend = STR ; series . name = STR ; series . chart _ area = STR ; series . chart _ type = system . windows . forms . data _ visualization . charting . series _ chart _ type . line ; series . color = system . drawing . color . from _ argb ( NUM , NUM , NUM ) ;

public const int hash _ bytes = NUM ; public const int clen _ bytes = 2 ; public const int auth _ bytes = hash _ bytes + clen _ bytes ; protected static byte [ ] tempbuf = new byte [ max _ input _ size ] ; protected dictionary < string , int [ ] > ciphers ; private static readonly dictionary < string , byte [ ] > cached _ keys = new dictionary < string , byte [ ] > ( ) ; protected byte [ ] encrypt _ iv ; protected byte [ ] decrypt _ iv ; protected bool decrypt _ iv _ received ; protected bool encrypt _ iv _ sent ;
public iv _ encryptor ( string method , string password , bool onetimeauth ) : base ( method , password , onetimeauth ) { init _ key ( method , password ) ; } protected abstract dictionary < string , int [ ] > get _ ciphers ( ) ;
} protected abstract dictionary < string , int [ ] > get _ ciphers ( ) ; protected void init _ key ( string method , string password ) { method = method . to _ lower ( ) ; method = method ; string k = method + STR + password ; ciphers = get _ ciphers ( ) ; cipher _ info = ciphers [ method ] ; cipher = cipher _ info [ 2 ] ;
{ byte [ ] auth _ key = new byte [ onetimeauth _ keybytes ] ; byte [ ] auth _ bytes = new byte [ max _ iv _ length + max _ key _ length ] ; buffer . block _ copy ( encrypt _ iv , 0 , auth _ bytes , 0 , iv _ len ) ; buffer . block _ copy ( key , 0 , auth _ bytes , iv _ len , key _ len ) ; sodium . crypto _ generichash ( auth _ key , onetimeauth _ keybytes , auth _ bytes , ( ulong ) ( iv _ len + key _ len ) , null , 0 ) ; return sodium . crypto _ onetimeauth ( auth , msg , ( ulong ) msg _ len , auth _ key ) ; } protected void ss _ gen _ hash ( byte [ ] buf , ref int offset , ref int len , int buf _ size ) {
return sodium . crypto _ onetimeauth ( auth , msg , ( ulong ) msg _ len , auth _ key ) ; } protected void ss _ gen _ hash ( byte [ ] buf , ref int offset , ref int len , int buf _ size ) { int size = len + auth _ bytes ;
if ( buf _ size < ( size + offset ) ) throw new exception ( STR ) ; if ( key _ buffer = = null ) { key _ buffer = new byte [ max _ iv _ length + NUM ] ; buffer . block _ copy ( encrypt _ iv , 0 , key _ buffer , 0 , iv _ len ) ; } byte [ ] counter _ bytes = bit _ converter . get _ bytes ( ( uint ) ip _ address . host _ to _ network _ order ( ( int ) counter ) ) ; buffer . block _ copy ( counter _ bytes , 0 , key _ buffer , iv _ len , NUM ) ; byte [ ] hash = new byte [ hash _ bytes ] ;
} public override void encrypt ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength ) { if ( ! encrypt _ iv _ sent ) { encrypt _ iv _ sent = true ; rand _ bytes ( outbuf , iv _ len ) ; init _ cipher ( outbuf , true ) ; outlength = length + iv _ len ; lock ( tempbuf )
splash . target _ rect = new rectangle ( ( int ) min _ x , ( int ) min _ y , ( int ) max _ x - ( int ) min _ x , ( int ) max _ y - ( int ) min _ y ) ; splash . size = new size ( full _ image . width , full _ image . height ) ; splash . show ( ) ; return ; } } } message _ box . show ( n . get _ string ( STR ) ) ; } void splash _ form _ closed ( object sender , form _ closed _ event _ args e )
splash . show ( ) ; return ; } } } message _ box . show ( n . get _ string ( STR ) ) ; } void splash _ form _ closed ( object sender , form _ closed _ event _ args e ) { show _ config _ form ( ) ;
{ public class qr _ rect _ view : control { private pen pen ; private brush brush ; public qr _ rect _ view ( ) { pen = new pen ( color . red , NUM ) ; brush = new solid _ brush ( color . from _ argb ( NUM , color . red ) ) ; set _ style ( control _ styles . resize _ redraw , true ) ;
} private timer timer ; private int animation _ step ; private int flash _ step ; private static int animation _ steps = NUM ; private void qr _ code _ splash _ form _ load ( object sender , event _ args e ) { set _ style ( control _ styles . supports _ transparent _ back _ color , true ) ; this . back _ color = color . transparent ; animation _ step = 0 ; flash _ step = 0 ; x = 0 ;
timer = new timer ( ) ; timer . interval = ( int ) ( animation _ time * NUM / animation _ steps ) ; timer . tick + = timer _ tick ; timer . start ( ) ; bitmap = new bitmap ( width , height , pixel _ format . format _ bpp _ argb ) ; g = graphics . from _ image ( bitmap ) ; pen = new pen ( color . red , NUM ) ; brush = new solid _ brush ( color . from _ argb ( NUM , color . red ) ) ; } protected override create _ params create _ params
timer . tick + = timer _ tick ; timer . start ( ) ; bitmap = new bitmap ( width , height , pixel _ format . format _ bpp _ argb ) ; g = graphics . from _ image ( bitmap ) ; pen = new pen ( color . red , NUM ) ; brush = new solid _ brush ( color . from _ argb ( NUM , color . red ) ) ; } protected override create _ params create _ params { get
{ file . write _ all _ text ( pac _ file , resources . proxy _ pac _ txt ) ; } return pac _ file ; } internal string touch _ user _ rule _ file ( )
} return pac _ file ; } internal string touch _ user _ rule _ file ( ) { if ( ! file . exists ( user _ rule _ file ) )
} internal string touch _ user _ rule _ file ( ) { if ( ! file . exists ( user _ rule _ file ) ) {
{ file . write _ all _ text ( user _ rule _ file , resources . user _ rule ) ; } return user _ rule _ file ; } internal string get _ pac _ content ( ) { if ( file . exists ( pac _ file ) ) {
} return user _ rule _ file ; } internal string get _ pac _ content ( ) { if ( file . exists ( pac _ file ) ) { return file . read _ all _ text ( pac _ file , encoding . ut ) ; } else
} } private void watch _ pac _ file ( ) { pac _ file _ watcher ? . dispose ( ) ; pac _ file _ watcher = new file _ system _ watcher ( directory . get _ current _ directory ( ) ) ; pac _ file _ watcher . notify _ filter = notify _ filters . last _ write | notify _ filters . file _ name | notify _ filters . directory _ name ; pac _ file _ watcher . filter = pac _ file ; pac _ file _ watcher . changed + = pac _ file _ watcher _ changed ; pac _ file _ watcher . created + = pac _ file _ watcher _ changed ;
{ group = config . geosite _ group ; blacklist = config . geosite _ blacklist _ mode ; } if ( ! string . is _ null _ or _ white _ space ( config . geosite _ url ) ) { logger . info ( STR ) ; geosite _ url = config . geosite _ url ; } logger . info ( $ STR ) ;
} if ( ! string . is _ null _ or _ white _ space ( config . geosite _ url ) ) { logger . info ( STR ) ; geosite _ url = config . geosite _ url ; } logger . info ( $ STR ) ; web _ client http = new web _ client ( ) ; if ( config . enabled ) {
web _ client http = new web _ client ( ) ; if ( config . enabled ) { http . proxy = new web _ proxy ( config . is _ i _ pv _ enabled ? $ STR : ip _ address . loopback . to _ string ( ) , config . local _ port ) ; } http . download _ data _ completed + = ( o , e ) = >
update _ completed ? . invoke ( null , new geosite _ result _ event _ args ( pac _ file _ changed ) ) ; } catch ( exception ex ) { error ? . invoke ( null , new error _ event _ args ( ex ) ) ; } } ; http . download _ data _ async ( new uri ( geosite _ url ) ) ; } public static bool merge _ and _ write _ pac _ file ( string group , bool blacklist )
} public static bool merge _ and _ write _ pac _ file ( string group , bool blacklist ) { i _ list < domain _ object > domains = geosites [ group ] ; string abp _ content = merge _ pac _ file ( domains , blacklist ) ;
{ i _ list < domain _ object > domains = geosites [ group ] ; string abp _ content = merge _ pac _ file ( domains , blacklist ) ; if ( file . exists ( pac _ daemon . pac _ file ) ) {
if ( file . exists ( pac _ daemon . pac _ file ) ) { string original = file _ manager . non _ exclusive _ read _ all _ text ( pac _ daemon . pac _ file , encoding . ut ) ; if ( original = = abp _ content ) { return false ; } } file . write _ all _ text ( pac _ daemon . pac _ file , abp _ content , encoding . ut ) ; return true ;
} list < string > gfw _ lines = geosite _ to _ gfw _ list ( domains , blacklist ) ; abp _ content = $ @ STR var rules = { json _ convert . serialize _ object ( gfw _ lines , formatting . indented ) } ; { abp _ content } STR return abp _ content ; } private static readonly i _ enumerable < char > ignored _ line _ begins = new [ ] { '!' , '[' } ; private static list < string > pre _ process _ gfw _ list ( string content )
abp _ content = $ @ STR var rules = { json _ convert . serialize _ object ( gfw _ lines , formatting . indented ) } ; { abp _ content } STR return abp _ content ; } private static readonly i _ enumerable < char > ignored _ line _ begins = new [ ] { '!' , '[' } ; private static list < string > pre _ process _ gfw _ list ( string content ) { list < string > valid _ lines = new list < string > ( ) ;
{ list < string > valid _ lines = new list < string > ( ) ; using ( var sr = new string _ reader ( content ) ) { foreach ( var line in sr . non _ white _ space _ lines ( ) ) { if ( line . begin _ with _ any ( ignored _ line _ begins ) ) continue ; valid _ lines . add ( line ) ; }
{ return blacklist ? geosite _ to _ gfw _ list _ black ( domains ) : geosite _ to _ gfw _ list _ white ( domains ) ; } private static list < string > geosite _ to _ gfw _ list _ black ( i _ list < domain _ object > domains ) { list < string > ret = new list < string > ( domains . count + NUM ) ; foreach ( var d in domains ) { string domain = d . value ;
foreach ( var d in domains ) { string domain = d . value ; switch ( d . type ) { case domain _ object . types . type . plain : ret . add ( domain ) ; break ; case domain _ object . types . type . regex : ret . add ( $ STR ) ;
break ; case domain _ object . types . type . regex : ret . add ( $ STR ) ; break ; case domain _ object . types . type . domain : ret . add ( $ STR ) ; break ; case domain _ object . types . type . full : ret . add ( $ STR ) ; ret . add ( $ STR ) ;
{ this . config = config ; touch _ pac _ file ( ) ; touch _ user _ rule _ file ( ) ; this . watch _ pac _ file ( ) ; this . watch _ user _ rule _ file ( ) ; } public string touch _ pac _ file ( ) { if ( ! file . exists ( pac _ file ) )
} return pac _ file ; } internal string touch _ user _ rule _ file ( ) { if ( ! file . exists ( user _ rule _ file ) ) { file . write _ all _ text ( user _ rule _ file , resources . user _ rule ) ; } return user _ rule _ file ;
{ if ( name . is _ null _ or _ empty ( ) ) throw new argument _ exception ( nameof ( name ) ) ; try { registry _ key user _ key = registry _ key . open _ base _ key ( hive , environment . is _ bit _ operating _ system ? registry _ view . registry : registry _ view . registry ) . open _ sub _ key ( name , writable ) ; return user _ key ; } catch ( unauthorized _ access _ exception uae )
environment . is _ bit _ operating _ system ? registry _ view . registry : registry _ view . registry ) . open _ sub _ key ( name , writable ) ; return user _ key ; } catch ( unauthorized _ access _ exception uae ) { logging . log _ useful _ exception ( uae ) ; return null ; } catch ( security _ exception se )
} public void update _ outbound _ counter ( long n ) { interlocked . add ( ref outbound _ counter , n ) ; } protected void reload ( ) { config = configuration . load ( ) ; statistics _ configuration = statistics _ strategy _ configuration . load ( ) ; if ( polipo _ runner = = null )
} protected void reload ( ) { config = configuration . load ( ) ; statistics _ configuration = statistics _ strategy _ configuration . load ( ) ; if ( polipo _ runner = = null ) { polipo _ runner = new polipo _ runner ( ) ; } if ( pac _ server = = null )
polipo _ runner = new polipo _ runner ( ) ; polipo _ runner . start ( config . get _ current _ server ( ) ) ; local = new local ( config . get _ current _ server ( ) ) ; try { local . start ( ) ; pac _ server = new pac _ server ( ) ; pac _ server . pac _ file _ changed + = pac _ server _ pac _ file _ changed ; pac _ server . start ( ) ; }
try { local . start ( ) ; pac _ server = new pac _ server ( ) ; pac _ server . pac _ file _ changed + = pac _ server _ pac _ file _ changed ; pac _ server . start ( ) ; } catch ( exception e ) { console . write _ line ( e . message ) ;
{ configuration . save ( new _ config ) ; config = new _ config ; local . stop ( ) ; polipo _ runner . stop ( ) ; polipo _ runner . start ( config . get _ current _ server ( ) ) ; local = new local ( config . get _ current _ server ( ) ) ; local . start ( ) ; if ( config _ changed ! = null ) {
config = new _ config ; local . stop ( ) ; polipo _ runner . stop ( ) ; polipo _ runner . start ( config . get _ current _ server ( ) ) ; local = new local ( config . get _ current _ server ( ) ) ; local . start ( ) ; if ( config _ changed ! = null ) { config _ changed ( this , new event _ args ( ) ) ; }
local . start ( ) ; if ( config _ changed ! = null ) { config _ changed ( this , new event _ args ( ) ) ; } } public server get _ current _ server ( ) { return config . get _ current _ server ( ) ; }
{ return config ; } public void toggle _ enable ( bool enabled ) { config . enabled = enabled ; update _ system _ proxy ( ) ; save _ config ( config ) ; if ( enable _ status _ changed ! = null ) {
} private void form _ load ( object sender , event _ args e ) { if ( ! controller . get _ configuration ( ) . is _ default ) { this . opacity = 0 ; begin _ invoke ( new method _ invoker ( delegate { this . hide ( ) ; } ) ) ;
{ this . opacity = 0 ; begin _ invoke ( new method _ invoker ( delegate { this . hide ( ) ; } ) ) ; } } private void config _ click ( object sender , event _ args e ) {
{ server = text _ box . text , server _ port = int . parse ( text _ box . text ) , password = text _ box . text , local _ port = int . parse ( text _ box . text ) , method = combo _ box . text } ; configuration config = controller . get _ configuration ( ) ;
} ; configuration config = controller . get _ configuration ( ) ; config . configs . clear ( ) ; config . configs . add ( server ) ; config . index = 0 ; controller . save _ config ( config ) ; this . hide ( ) ; } catch ( format _ exception ) {
{ if ( ! int . try _ parse ( locs [ 1 ] , out target _ port ) ) { throw new exception ( STR + line ) ; } } else { target _ port = NUM ; }
} } } } else { if ( line . is _ null _ or _ empty ( ) ) { return true ; }
{ if ( ! int . try _ parse ( locs [ 1 ] , out target _ port ) ) { throw new exception ( STR + line ) ; } } else { target _ port = NUM ; }
} } } } request _ line _ count + + ; return false ; } private void on _ finish ( byte [ ] last _ bytes , int index , int length , object state ) { if ( closed )
byte [ ] response = { NUM , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 } ; connection . begin _ send ( response , 0 , response . length , socket _ flags . none , response _ callback , null ) ; break ; case cmd _ udp _ assoc : read _ address ( handle _ udp _ associate ) ; break ;
read _ address ( handle _ udp _ associate ) ; break ; case cmd _ bind : default : logging . debug ( STR + command ) ; close ( ) ; break ; } }
} } else { logging . debug ( STR ) ; close ( ) ; } } catch ( exception e )
using system _ diagnostics ; using system _ io ; using system _ i _ compression ; using system _ runtime _ interop _ services ;
using system _ runtime _ interop _ services ;

return null ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ;
return null ; } } public static bool is _ win _ vista _ or _ higher ( ) { return environment . os _ version . version . major > NUM ; } dll _ import _ kernel _ dll return _ marshal _ as _ unmanaged _ type _ bool private static extern bool set _ process _ working _ set _ size ( int _ ptr process , u _ int _ ptr minimum _ working _ set _ size , u _ int _ ptr maximum _ working _ set _ size ) ;
namespace shadowsocks _ util _ system _ proxy { internal static class remote _ access _ service { private enum ras _ field _ size _ constants { ras _ max _ entry _ name = NUM , ras _ max _ path = NUM } private const int error _ success = 0 ;
{ private enum ras _ field _ size _ constants { ras _ max _ entry _ name = NUM , ras _ max _ path = NUM } private const int error _ success = 0 ; private const int rasbase = NUM ; private const int error _ buffer _ too _ small = rasbase + NUM ; struct _ layout _ layout _ kind _ sequential _ char _ set _ char _ set _ auto
using system _ collections ; using system _ io ; using system _ net ; using system _ net _ sockets ; using system _ text ; using shadowsocks _ model ; using shadowsocks _ properties ;
using system _ io ; using system _ net ; using system _ net _ sockets ; using system _ text ; using shadowsocks _ model ; using shadowsocks _ properties ; using shadowsocks _ util ; namespace shadowsocks _ controller {
using system _ net ; using system _ net _ sockets ; using system _ text ; using shadowsocks _ model ; using shadowsocks _ properties ; using shadowsocks _ util ; namespace shadowsocks _ controller { class pac _ server : listener . service {
file _ system _ watcher pac _ file _ watcher ; file _ system _ watcher user _ rule _ file _ watcher ; private configuration config ; public event event _ handler pac _ file _ changed ; public event event _ handler user _ rule _ file _ changed ; public pac _ server ( ) { this . watch _ pac _ file ( ) ; this . watch _ user _ rule _ file ( ) ; }
{ string local = file . read _ all _ text ( pac _ server . user _ rule _ file , encoding . ut ) ; string [ ] rules = local . split ( new char [ ] { '\r' , '\n' } , string _ split _ options . remove _ empty _ entries ) ; foreach ( string rule in rules ) { if ( rule . starts _ with ( STR ) | | rule . starts _ with ( STR ) ) continue ; lines . add ( rule ) ; } }
string [ ] rules = local . split ( new char [ ] { '\r' , '\n' } , string _ split _ options . remove _ empty _ entries ) ; foreach ( string rule in rules ) { if ( rule . starts _ with ( STR ) | | rule . starts _ with ( STR ) ) continue ; lines . add ( rule ) ; } } string abp _ content ; if ( file . exists ( pac _ server . user _ abp _ file ) )
{ abp _ content = file . read _ all _ text ( pac _ server . user _ abp _ file , encoding . ut ) ; } else { abp _ content = utils . un _ gzip ( resources . abp _ js ) ; } abp _ content = abp _ content . replace ( STR , json _ convert . serialize _ object ( lines , formatting . indented ) ) ; if ( file . exists ( pac _ server . pac _ file ) ) {
} else { abp _ content = utils . un _ gzip ( resources . abp _ js ) ; } abp _ content = abp _ content . replace ( STR , json _ convert . serialize _ object ( lines , formatting . indented ) ) ; if ( file . exists ( pac _ server . pac _ file ) ) { string original = file . read _ all _ text ( pac _ server . pac _ file , encoding . ut ) ; if ( original = = abp _ content )
if ( original = = abp _ content ) { update _ completed ( this , new result _ event _ args ( false ) ) ; return ; } } file . write _ all _ text ( pac _ server . pac _ file , abp _ content , encoding . ut ) ; if ( update _ completed ! = null ) { update _ completed ( this , new result _ event _ args ( true ) ) ;
if ( update _ completed ! = null ) { update _ completed ( this , new result _ event _ args ( true ) ) ; } } catch ( exception ex ) { if ( error ! = null ) { error ( this , new error _ event _ args ( ex ) ) ;
{ var reply = await ping . send _ task _ async ( server . server , timeout ) ; ret . add ( new list < key _ value _ pair < string , string > > { new key _ value _ pair < string , string > ( STR , timestamp ) , new key _ value _ pair < string , string > ( STR , server . friendly _ name ( ) ) , new key _ value _ pair < string , string > ( STR , reply ? . status . to _ string ( ) ) , new key _ value _ pair < string , string > ( STR , reply ? . roundtrip _ time . to _ string ( ) ) } ) ; }
} return ret ; } private async void evaluate ( object obj ) { var geolocation _ and _ isp = get _ geolocation _ and _ isp ( ) ; foreach ( var data _ lists in await task _ ex . when _ all ( servers . select ( icmp _ test ) ) ) { if ( data _ lists = = null ) continue ; foreach ( var data _ list in data _ lists . where ( data _ list = > data _ list ! = null ) )
return output ; } dll _ import _ kernel _ dll private static extern int _ ptr load _ library ( string path ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern int md _ ret ( byte [ ] input , uint ilen , byte [ ] output ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern int cipher _ get _ size _ ex ( ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern int _ ptr cipher _ info _ from _ string ( string cipher _ name ) ;
dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern int cipher _ get _ size _ ex ( ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern int _ ptr cipher _ info _ from _ string ( string cipher _ name ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern void cipher _ init ( int _ ptr ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern int cipher _ setup ( int _ ptr ctx , int _ ptr cipher _ info ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern int cipher _ setkey ( int _ ptr ctx , byte [ ] key , int key _ bitlen , int operation ) ;
{ private configuration config ; public local ( configuration config ) { this . config = config ; } public bool good _ for _ me ( byte [ ] first _ packet , int length ) {
public local ( configuration config ) { this . config = config ; } public bool good _ for _ me ( byte [ ] first _ packet , int length ) { return true ; } public void handle ( byte [ ] first _ packet , int length , socket socket ) {
} } class handler { public i _ encryptor encryptor ; public server server ; public socket remote ; public socket connection ; private byte [ ] first _ packet ; private int first _ packet _ length ;
if ( bytes _ read > 1 ) { byte [ ] response = { NUM , 0 } ; if ( first _ packet [ 0 ] ! = NUM ) { response = new byte [ ] { 0 , NUM } ; console . write _ line ( STR ) ; } connection . begin _ send ( response , 0 , response . length , 0 , new async _ callback ( handshake _ send _ callback ) , null ) ; }
{ response = new byte [ ] { 0 , NUM } ; console . write _ line ( STR ) ; } connection . begin _ send ( response , 0 , response . length , 0 , new async _ callback ( handshake _ send _ callback ) , null ) ; } else { this . close ( ) ; }
} polipo _ runner . stop ( ) ; try { polipo _ runner . start ( config ) ; local local = new local ( config ) ; list < listener . service > services = new list < listener . service > ( ) ; services . add ( local ) ; listener = new listener ( services ) ; listener . start ( config ) ;
pac _ server . start ( config ) ; } catch ( exception e ) { if ( e is socket _ exception ) { socket _ exception se = ( socket _ exception ) e ; if ( se . socket _ error _ code = = socket _ error . access _ denied ) { e = new exception ( n . get _ string ( STR ) , e ) ;
this . value _ label . tab _ index = NUM ; this . value _ label . text = STR ;
{ new data _ unit ( state . geolocation , state . unknown ) , new data _ unit ( state . isp , state . unknown ) } ; } private static async task < data _ list > get _ info _ from _ api ( string api ) { string json _ string ; try {
} dynamic obj ; if ( ! simple _ json . simple _ json . try _ deserialize _ object ( json _ string , out obj ) ) return null ; string country = obj [ STR ] ; string city = obj [ STR ] ; string isp = obj [ STR ] ; if ( country = = null | | city = = null | | isp = = null ) return null ; return new data _ list { new data _ unit ( state . geolocation , $ STR ) , new data _ unit ( state . isp , isp )
string country = obj [ STR ] ; string city = obj [ STR ] ; string isp = obj [ STR ] ; if ( country = = null | | city = = null | | isp = = null ) return null ; return new data _ list { new data _ unit ( state . geolocation , $ STR ) , new data _ unit ( state . isp , isp ) } ; } private async task < list < data _ list > > icmp _ test ( server server )
} private async task < list < data _ list > > icmp _ test ( server server ) { logging . debug ( STR + server . friendly _ name ( ) ) ; if ( server . server = = STR ) return null ; var ip = dns . get _ host _ addresses ( server . server ) . first ( ip = > ip . address _ family = = address _ family . inter _ network ) ; var ping = new ping ( ) ; var ret = new list < data _ list > ( ) ; foreach ( var timestamp in enumerable . range ( 0 , repeat ) . select ( = > date _ time . now . to _ string ( date _ time _ pattern ) ) )
{ string server _ name = servers [ server _ selector . selected _ index ] ; data _ table . rows . clear ( ) ; list < availability _ statistics . raw _ statistics _ data > statistics ; if ( ! controller . availability _ statistics . filtered _ statistics . try _ get _ value ( server _ name , out statistics ) ) return ; i _ enumerable < i _ grouping < int , availability _ statistics . raw _ statistics _ data > > data _ groups ; if ( all _ mode . checked ) { data _ groups = statistics . group _ by ( data = > data . timestamp . day _ of _ year ) ;
{ data _ groups = statistics . group _ by ( data = > data . timestamp . day _ of _ year ) ; statistics _ chart . chart _ areas [ STR ] . axis _ x . label _ style . format = STR ; statistics _ chart . chart _ areas [ STR ] . axis . label _ style . format = STR ; } else { data _ groups = statistics . group _ by ( data = > data . timestamp . hour ) ; statistics _ chart . chart _ areas [ STR ] . axis _ x . label _ style . format = STR ;
} else { data _ groups = statistics . group _ by ( data = > data . timestamp . hour ) ; statistics _ chart . chart _ areas [ STR ] . axis _ x . label _ style . format = STR ; statistics _ chart . chart _ areas [ STR ] . axis . label _ style . format = STR ; } var final _ data = from data _ group in data _ groups orderby data _ group . key select new
} } }
( ( system . component _ model . i _ support _ initialize ) ( this . statistics _ chart ) ) . begin _ init ( ) ; this . chart _ mode _ selector . suspend _ layout ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . begin _ init ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . suspend _ layout ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . begin _ init ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . suspend _ layout ( ) ;
( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . begin _ init ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . suspend _ layout ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . begin _ init ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . suspend _ layout ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . data _ collection _ minutes _ num ) ) . begin _ init ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . choice _ kept _ minutes _ num ) ) . begin _ init ( ) ;
this . auto _ scale _ mode = system . windows . forms . auto _ scale _ mode . font ; this . auto _ size = true ; this . client _ size = new system . drawing . size ( NUM , NUM ) ; this . controls . add ( this . split _ container ) ; this . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . minimum _ size = new system . drawing . size ( NUM , NUM ) ; this . name = STR ; this . text = STR ; ( ( system . component _ model . i _ support _ initialize ) ( this . statistics _ chart ) ) . end _ init ( ) ; this . chart _ mode _ selector . resume _ layout ( false ) ;
this . split _ container . panel . resume _ layout ( false ) ; this . split _ container . panel . resume _ layout ( false ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . end _ init ( ) ; this . split _ container . resume _ layout ( false ) ; this . split _ container . panel . resume _ layout ( false ) ; this . split _ container . panel . perform _ layout ( ) ; this . split _ container . panel . resume _ layout ( false ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . end _ init ( ) ; this . split _ container . resume _ layout ( false ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . data _ collection _ minutes _ num ) ) . end _ init ( ) ;

} } else { registry . set _ value ( STR , 0 ) ; registry . set _ value ( STR , STR ) ; registry . set _ value ( STR , STR ) ; } system _ proxy . notify _ ie ( ) ; copy _ proxy _ setting _ from _ lan ( ) ;
{ string argument = STR + update _ checker . latest _ version _ local _ name + STR ; process . start ( STR , argument ) ; } } } private void notify _ icon _ balloon _ tip _ closed ( object sender , event _ args e ) { if ( update _ checker . new _ version _ found ) {
} } } private void notify _ icon _ balloon _ tip _ closed ( object sender , event _ args e ) { if ( update _ checker . new _ version _ found ) { update _ checker . new _ version _ found = false ; } }
namespace shadowsocks _ controller { class availability _ statistics { private const string statistics _ files _ name = STR ; private const string delimiter = STR ; private const int timeout = NUM ; private const int repeat = NUM ; private const int interval = NUM * NUM * NUM ; private timer timer ;
public static string availability _ statistics _ file ; static availability _ statistics ( ) { var temppath = path . get _ temp _ path ( ) ; availability _ statistics _ file = path . combine ( temppath , statistics _ files _ name ) ; } public bool set ( bool enabled ) { try {
availability _ statistics _ file = path . combine ( temppath , statistics _ files _ name ) ; } public bool set ( bool enabled ) { try { if ( enabled ) { if ( timer ? . change ( 0 , interval ) ! = null ) return true ; state = new state ( ) ;
} else { timer ? . dispose ( ) ; } return true ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ;
{ logging . debug ( STR + server . friendly _ name ( ) ) ; foreach ( var in enumerable . range ( 0 , repeat ) ) { var timestamp = date _ time . now . to _ string ( STR ) ; var reply = ping . send ( server . server , timeout ) ; state . data = new list < key _ value _ pair < string , string > > { new key _ value _ pair < string , string > ( STR , timestamp ) , new key _ value _ pair < string , string > ( STR , server . friendly _ name ( ) ) ,
var reply = ping . send ( server . server , timeout ) ; state . data = new list < key _ value _ pair < string , string > > { new key _ value _ pair < string , string > ( STR , timestamp ) , new key _ value _ pair < string , string > ( STR , server . friendly _ name ( ) ) , new key _ value _ pair < string , string > ( STR , reply ? . status . to _ string ( ) ) , new key _ value _ pair < string , string > ( STR , reply ? . roundtrip _ time . to _ string ( ) ) } ; append ( state . data ) ; }
append ( state . data ) ; } } } private static void append ( list < key _ value _ pair < string , string > > data ) { var data _ line = string . join ( delimiter , data . select ( kv = > kv . value ) . to _ array ( ) ) ; string [ ] lines ; if ( ! file . exists ( availability _ statistics _ file ) ) {
string [ ] lines ; if ( ! file . exists ( availability _ statistics _ file ) ) { var header _ line = string . join ( delimiter , data . select ( kv = > kv . key ) . to _ array ( ) ) ; lines = new [ ] { header _ line , data _ line } ; } else { lines = new [ ] { data _ line } ; }
} else { lines = new [ ] { data _ line } ; } file . append _ all _ lines ( availability _ statistics _ file , lines ) ; } internal void update _ configuration ( configuration config ) { set ( config . availability _ statistics ) ;
} file . append _ all _ lines ( availability _ statistics _ file , lines ) ; } internal void update _ configuration ( configuration config ) { set ( config . availability _ statistics ) ; servers = config . configs ; } private class state {
using system _ collections _ generic ; using system _ linq ; using system _ net ; using system _ net _ sockets ; using system _ timers ; using n _ log ; using shadowsocks _ controller _ strategy ; using shadowsocks _ encryption ; using shadowsocks _ encryption _ aead ; using shadowsocks _ encryption _ exception ;
{ public event event _ handler < sstcp _ connected _ event _ args > on _ connected ; public event event _ handler < ss _ transmit _ event _ args > on _ inbound ; public event event _ handler < ss _ transmit _ event _ args > on _ outbound ; public event event _ handler < ss _ relay _ event _ args > on _ failed ; private static readonly logger logger = log _ manager . get _ current _ class _ logger ( ) ; private readonly shadowsocks _ controller controller ; private date _ time last _ sweep _ time ; private readonly configuration config ; public i _ set < tcp _ handler > handlers { get ; set ; }
private date _ time last _ sweep _ time ; private readonly configuration config ; public i _ set < tcp _ handler > handlers { get ; set ; } public tcp _ relay ( shadowsocks _ controller controller , configuration conf ) { controller = controller ; config = conf ; handlers = new hash _ set < tcp _ handler > ( ) ; last _ sweep _ time = date _ time . now ; }
public i _ set < tcp _ handler > handlers { get ; set ; } public tcp _ relay ( shadowsocks _ controller controller , configuration conf ) { controller = controller ; config = conf ; handlers = new hash _ set < tcp _ handler > ( ) ; last _ sweep _ time = date _ time . now ; } public override bool handle ( byte [ ] first _ packet , int length , socket socket , object state ) {
{ public i _ proxy remote { get ; } public async _ session ( i _ proxy remote ) { remote = remote ; } } private class async _ session < t > : async _ session { public t state { get ; set ; }
{ public t state { get ; set ; } public async _ session ( i _ proxy remote , t state ) : base ( remote ) { state = state ; } public async _ session ( async _ session session , t state ) : base ( session . remote ) { state = state ; }
private readonly int server _ timeout ; private readonly int proxy _ timeout ; public const int recv _ size = NUM ; public const int chunk _ overhead _ size = NUM * 2 public const uint max _ chunk _ size = aead _ encryptor . chunk _ len _ mask + aead _ encryptor . chunk _ len _ bytes + NUM * 2 ; public const int buffer _ size = recv _ size + ( int ) max _ chunk _ size + NUM public date _ time last _ activity ; private readonly shadowsocks _ controller controller ; private readonly proxy _ config config ; private readonly socket connection ;
private i _ encryptor encryptor ; private server server ; private async _ session current _ remote _ session ; private bool proxy _ connected ; private bool dest _ connected ; private byte command ; private byte [ ] first _ packet ; private int first _ packet _ length ; private const int cmd _ connect = 0 ; private const int cmd _ bind = 0 ;
private readonly byte [ ] connetion _ recv _ buffer = new byte [ buffer _ size ] ; private readonly byte [ ] remote _ send _ buffer = new byte [ buffer _ size ] ; private readonly byte [ ] connetion _ send _ buffer = new byte [ buffer _ size ] ; private bool connection _ shutdown = false ; private bool remote _ shutdown = false ; private bool closed = false ; private readonly object encryption _ lock = new object ( ) ; private readonly object decryption _ lock = new object ( ) ; private readonly object close _ conn _ lock = new object ( ) ; private date _ time start _ connect _ time ;
private readonly byte [ ] remote _ send _ buffer = new byte [ buffer _ size ] ; private readonly byte [ ] connetion _ send _ buffer = new byte [ buffer _ size ] ; private bool connection _ shutdown = false ; private bool remote _ shutdown = false ; private bool closed = false ; private readonly object encryption _ lock = new object ( ) ; private readonly object decryption _ lock = new object ( ) ; private readonly object close _ conn _ lock = new object ( ) ; private date _ time start _ connect _ time ; private date _ time start _ receiving _ time ;
private readonly byte [ ] connetion _ send _ buffer = new byte [ buffer _ size ] ; private bool connection _ shutdown = false ; private bool remote _ shutdown = false ; private bool closed = false ; private readonly object encryption _ lock = new object ( ) ; private readonly object decryption _ lock = new object ( ) ; private readonly object close _ conn _ lock = new object ( ) ; private date _ time start _ connect _ time ; private date _ time start _ receiving _ time ; private date _ time start _ sending _ time ;
private bool connection _ shutdown = false ; private bool remote _ shutdown = false ; private bool closed = false ; private readonly object encryption _ lock = new object ( ) ; private readonly object decryption _ lock = new object ( ) ; private readonly object close _ conn _ lock = new object ( ) ; private date _ time start _ connect _ time ; private date _ time start _ receiving _ time ; private date _ time start _ sending _ time ; private end _ point dest _ end _ point = null ;
logger . trace ( $ STR ) ; encryptor . addr _ buf _ length = addr _ buf _ length ; } public void start ( byte [ ] first _ packet , int length ) { first _ packet = first _ packet ; first _ packet _ length = length ; handshake _ receive ( ) ; } private void check _ close ( )
closed = true ; } on _ closed ? . invoke ( this , new ss _ relay _ event _ args ( server ) ) ; try { connection . shutdown ( socket _ shutdown . both ) ; connection . close ( ) ; } catch ( exception e ) {
} } private void handshake _ send _ callback ( i _ async _ result ar ) { if ( closed ) { return ; } try
try { connection . end _ send ( ar ) ; connection . begin _ receive ( connetion _ recv _ buffer , 0 , NUM + addr _ atyp _ len + 1 , socket _ flags . none , address _ receive _ callback , null ) ; } catch ( exception e ) { error _ close ( e ) ; }
try { int bytes _ read = connection . end _ receive ( ar ) ; if ( bytes _ read > = NUM ) { command = connetion _ recv _ buffer [ 1 ] ; switch ( command ) { case cmd _ connect : byte [ ] response = { NUM , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 } ;
{ try { connection . end _ send ( ar ) ; read _ address ( start _ connect ) ; } catch ( exception e ) { error _ close ( e ) ;
} } private void read _ address ( action on _ success ) { int atyp = connetion _ recv _ buffer [ NUM ] ; switch ( atyp ) { case atyp _ i _ pv : read _ address ( NUM + addr _ port _ len - 1 , on _ success ) ; break ;
try { int bytes _ read = connection . end _ receive ( ar ) ; object [ ] states = ( object [ ] ) ar . async _ state ; int bytes _ remain = ( int ) states [ 0 ] ; action on _ success = ( action ) states [ 1 ] ; if ( bytes _ read > = bytes _ remain ) { first _ packet _ length = bytes _ read + 2 ; int atyp = connetion _ recv _ buffer [ 0 ] ;
int bytes _ remain = ( int ) states [ 0 ] ; action on _ success = ( action ) states [ 1 ] ; if ( bytes _ read > = bytes _ remain ) { first _ packet _ length = bytes _ read + 2 ; int atyp = connetion _ recv _ buffer [ 0 ] ; string dst _ addr = STR ; int dst _ port = - 1 ; switch ( atyp ) {
if ( bytes _ read > = bytes _ remain ) { first _ packet _ length = bytes _ read + 2 ; int atyp = connetion _ recv _ buffer [ 0 ] ; string dst _ addr = STR ; int dst _ port = - 1 ; switch ( atyp ) { case atyp _ i _ pv : dst _ addr = new ip _ address ( connetion _ recv _ buffer . skip ( 1 ) . take ( NUM ) . to _ array ( ) ) . to _ string ( ) ;
} } private class proxy _ timer : timer { public async _ session session ; public end _ point dest _ end _ point ; public server server ; public proxy _ timer ( int p ) : base ( p ) { }
} } private void proxy _ connect _ timer _ elapsed ( object sender , elapsed _ event _ args e ) { proxy _ timer timer = ( proxy _ timer ) sender ; timer . elapsed - = proxy _ connect _ timer _ elapsed ; timer . enabled = false ; timer . dispose ( ) ; if ( proxy _ connected | | dest _ connected | | closed ) {
timer . elapsed - = proxy _ connect _ timer _ elapsed ; timer . enabled = false ; timer . dispose ( ) ; if ( proxy _ connected | | dest _ connected | | closed ) { return ; } i _ proxy proxy = timer . session . remote ; logger . info ( $ STR ) ; proxy . close ( ) ;
logger . info ( $ STR ) ; proxy . close ( ) ; close ( ) ; } private void proxy _ connect _ callback ( i _ async _ result ar ) { if ( closed ) { return ; }
proxy _ timer timer = session . state ; end _ point dest _ end _ point = timer . dest _ end _ point ; server server = timer . server ; timer . elapsed - = proxy _ connect _ timer _ elapsed ; timer . enabled = false ; timer . dispose ( ) ; i _ proxy remote = session . remote ; remote . end _ connect _ proxy ( ar ) ; proxy _ connected = true ; if ( ! ( remote is direct _ connect ) )
timer . elapsed - = proxy _ connect _ timer _ elapsed ; timer . enabled = false ; timer . dispose ( ) ; i _ proxy remote = session . remote ; remote . end _ connect _ proxy ( ar ) ; proxy _ connected = true ; if ( ! ( remote is direct _ connect ) ) { logger . debug ( $ STR ) ; }
remote . end _ connect _ proxy ( ar ) ; proxy _ connected = true ; if ( ! ( remote is direct _ connect ) ) { logger . debug ( $ STR ) ; } start _ connect _ time = date _ time . now ; server _ timer connect _ timer = new server _ timer ( server _ timeout ) { auto _ reset = false } ; connect _ timer . elapsed + = dest _ connect _ timer _ elapsed ; connect _ timer . enabled = true ;
} } private void dest _ connect _ timer _ elapsed ( object sender , elapsed _ event _ args e ) { server _ timer timer = ( server _ timer ) sender ; timer . elapsed - = dest _ connect _ timer _ elapsed ; timer . enabled = false ; timer . dispose ( ) ; if ( dest _ connected | | closed ) {
timer . elapsed - = dest _ connect _ timer _ elapsed ; timer . enabled = false ; timer . dispose ( ) ; if ( dest _ connected | | closed ) { return ; } async _ session session = timer . session ; server server = timer . server ; on _ failed ? . invoke ( this , new ss _ relay _ event _ args ( server ) ) ;
server server = timer . server ; on _ failed ? . invoke ( this , new ss _ relay _ event _ args ( server ) ) ; logger . info ( $ STR ) ; session . remote . close ( ) ; close ( ) ; } private void connect _ callback ( i _ async _ result ar ) { if ( closed ) {
server _ timer timer = session . state ; server = timer . server ; timer . elapsed - = dest _ connect _ timer _ elapsed ; timer . enabled = false ; timer . dispose ( ) ; i _ proxy remote = session . remote ; remote . end _ connect _ dest ( ar ) ; dest _ connected = true ; logger . debug ( $ STR ) ; time _ span latency = date _ time . now - start _ connect _ time ;
remote . end _ connect _ dest ( ar ) ; dest _ connected = true ; logger . debug ( $ STR ) ; time _ span latency = date _ time . now - start _ connect _ time ; on _ connected ? . invoke ( this , new sstcp _ connected _ event _ args ( server , latency ) ) ; start _ pipe ( session ) ; } catch ( argument _ exception ) { }
on _ connected ? . invoke ( this , new sstcp _ connected _ event _ args ( server , latency ) ) ; start _ pipe ( session ) ; } catch ( argument _ exception ) { } catch ( exception e ) { if ( server ! = null ) {
} } private void try _ read _ available _ data ( ) { int available = math . min ( connection . available , recv _ size - first _ packet _ length ) ; if ( available > 0 ) { int size = connection . receive ( connetion _ recv _ buffer , first _ packet _ length , available , socket _ flags . none ) ; first _ packet _ length + = size ;
socket _ flags . none ) ; first _ packet _ length + = size ; } } private void start _ pipe ( async _ session session ) { if ( closed ) { return ; }
try { start _ receiving _ time = date _ time . now ; session . remote . begin _ receive ( remote _ recv _ buffer , 0 , recv _ size , socket _ flags . none , pipe _ remote _ receive _ callback , session ) ; try _ read _ available _ data ( ) ; logger . trace ( $ STR ) ; send _ to _ server ( first _ packet _ length , session ) ; } catch ( exception e )
} } private void pipe _ remote _ receive _ callback ( i _ async _ result ar ) { if ( closed ) { return ; } try {
int bytes _ read = session . remote . end _ receive ( ar ) ; total _ read + = bytes _ read ; on _ inbound ? . invoke ( this , new ss _ transmit _ event _ args ( server , bytes _ read ) ) ; if ( bytes _ read > 0 ) { last _ activity = date _ time . now ; int bytes _ to _ send = - 1 ; lock ( decryption _ lock ) { try
} } private void pipe _ connection _ receive _ callback ( i _ async _ result ar ) { if ( closed ) { return ; } try
try { int bytes _ read = connection . end _ receive ( ar ) ; async _ session session = ( async _ session ) ar . async _ state ; i _ proxy remote = session . remote ; if ( bytes _ read > 0 ) { send _ to _ server ( bytes _ read , session ) ; } else
if ( bytes _ read > 0 ) { send _ to _ server ( bytes _ read , session ) ; } else { remote . shutdown ( socket _ shutdown . send ) ; remote _ shutdown = true ; check _ close ( ) ; }
} } private void pipe _ connection _ send _ callback ( i _ async _ result ar ) { try { object [ ] container = ( object [ ] ) ar . async _ state ; async _ session session = ( async _ session ) container [ 0 ] ; int bytes _ should _ send = ( int ) container [ 1 ] ; int bytes _ sent = connection . end _ send ( ar ) ;
if ( bytes _ remaining > 0 ) { logger . info ( STR ) ; buffer . block _ copy ( remote _ send _ buffer , bytes _ sent , remote _ send _ buffer , 0 , bytes _ remaining ) ; connection . begin _ send ( remote _ send _ buffer , 0 , bytes _ remaining , socket _ flags . none , pipe _ connection _ send _ callback , new object [ ] { session , bytes _ remaining } ) ; return ; } session . remote . begin _ receive ( remote _ recv _ buffer , 0 , recv _ size , socket _ flags . none , pipe _ remote _ receive _ callback , session ) ;
private menu _ item edit _ pac _ file _ item ; private menu _ item qr _ code _ item ; private menu _ item show _ log _ item ; private menu _ item about _ item ; private menu _ item servers _ item ; private menu _ item seperator _ item ; private menu _ item quit _ item ; private menu _ item seperator _ item ;
private menu _ item quit _ item ; private menu _ item seperator _ item ;

this . context _ menu . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . enable _ item , this . mode _ item , this . servers _ item , this . seperator _ item , this . auto _ startup _ item , this . share _ over _ lan _ item , this . edit _ pac _ file _ item , this . seperator _ item , this . qr _ code _ item ,
this . auto _ startup _ item , this . share _ over _ lan _ item , this . edit _ pac _ file _ item , this . seperator _ item , this . qr _ code _ item , this . show _ log _ item , this . about _ item , this . seperator _ item , this . quit _ item } ) ;
this . qr _ code _ item , this . show _ log _ item , this . about _ item , this . seperator _ item , this . quit _ item } ) ;
this . quit _ item } ) ;
} private void controller _ config _ changed ( object sender , event _ args e ) { load _ current _ configuration ( ) ; update _ tray _ icon ( ) ; } private void controller _ enable _ status _ changed ( object sender , event _ args e ) { enable _ item . checked = controller . get _ configuration ( ) . enabled ; }
handler . send ( first _ packet , length ) ; handler . receive ( ) ; return true ; } public class udp _ handler { private socket local ; private socket remote ; private server server ; private byte [ ] buffer = new byte [ NUM ] ;
{ private socket local ; private socket remote ; private server server ; private byte [ ] buffer = new byte [ NUM ] ; private ip _ end _ point local _ end _ point ; private ip _ end _ point remote _ end _ point ; public udp _ handler ( socket local , server server , ip _ end _ point local _ end _ point ) { local = local ;
} private void ok _ button _ click ( object sender , event _ args e ) { if ( modified _ proxy _ config . use _ proxy = use _ proxy _ check _ box . checked ) { if ( ! int . try _ parse ( proxy _ port _ text _ box . text , out modified _ proxy _ config . proxy _ port ) ) {
{ if ( ! int . try _ parse ( proxy _ port _ text _ box . text , out modified _ proxy _ config . proxy _ port ) ) { message _ box . show ( n . get _ string ( STR ) ) ; return ; } if ( ! int . try _ parse ( proxy _ timeout _ text _ box . text , out modified _ proxy _ config . proxy _ timeout ) )
{ message _ box . show ( n . get _ string ( STR ) ) ; return ; } if ( ! int . try _ parse ( proxy _ timeout _ text _ box . text , out modified _ proxy _ config . proxy _ timeout ) ) { message _ box . show ( n . get _ string ( STR ) ) ; return ; } modified _ proxy _ config . proxy _ type = proxy _ type _ combo _ box . selected _ index ;
{ message _ box . show ( n . get _ string ( STR ) ) ; return ; } modified _ proxy _ config . proxy _ type = proxy _ type _ combo _ box . selected _ index ; try { configuration . check _ server ( modified _ proxy _ config . proxy _ server = proxy _ server _ text _ box . text ) ;
try { configuration . check _ server ( modified _ proxy _ config . proxy _ server = proxy _ server _ text _ box . text ) ; configuration . check _ port ( modified _ proxy _ config . proxy _ port ) ; configuration . check _ timeout ( modified _ proxy _ config . proxy _ timeout , proxy _ config . max _ proxy _ timeout _ sec ) ; } catch ( exception ex ) { message _ box . show ( ex . message ) ; return ;
} catch ( exception ex ) { message _ box . show ( ex . message ) ; return ; } } controller . save _ proxy ( modified _ proxy _ config ) ;
} controller . save _ proxy ( modified _ proxy _ config ) ; this . close ( ) ; } private void cancel _ button _ click ( object sender , event _ args e ) {
this . close ( ) ; } private void cancel _ button _ click ( object sender , event _ args e ) { this . close ( ) ; } private void proxy _ form _ form _ closed ( object sender , form _ closed _ event _ args e ) { controller . config _ changed - = controller _ config _ changed ; }
proxy _ type _ combo _ box . enabled = true ; } else { proxy _ server _ text _ box . enabled = proxy _ port _ text _ box . enabled = proxy _ timeout _ text _ box . enabled = proxy _ type _ combo _ box . enabled = false ; } }
} } } }
public void start ( configuration configuration ) { if ( process = = null ) { process [ ] existing _ privoxy = process . get _ processes _ by _ name ( STR ) ; foreach ( process p in existing _ privoxy . where ( is _ child _ process ) ) { kill _ process ( p ) ; }
if ( process = = null ) { process [ ] existing _ privoxy = process . get _ processes _ by _ name ( STR ) ; foreach ( process p in existing _ privoxy . where ( is _ child _ process ) ) { kill _ process ( p ) ; } string privoxy _ config = resources . privoxy _ conf ; running _ port = this . get _ free _ port ( ) ; privoxy _ config = privoxy _ config . replace ( STR , configuration . local _ port . to _ string ( ) ) ;
} catch ( exception e ) { logging . log _ useful _ exception ( e ) ; return default _ port ; } } struct _ layout _ layout _ kind _ sequential public struct rect
} struct _ layout _ layout _ kind _ sequential public struct rect { public int left ; public int top ; public int right ; public int bottom ; } dll _ import _ user _ dll
{ string rule ; while ( ( rule = sr . read _ line ( ) ) ! = null ) { if ( rule = = STR | | rule [ 0 ] = = '!' | | rule [ 0 ] = = '[' ) continue ; lines . add ( rule ) ; } } }
} } string abp _ content ; if ( file . exists ( pac _ server . user _ abp _ file ) ) { abp _ content = file . read _ all _ text ( pac _ server . user _ abp _ file , encoding . ut ) ; } else { abp _ content = utils . un _ gzip ( resources . abp _ js ) ;
{ string line ; while ( ( line = sr . read _ line ( ) ) ! = null ) { if ( line = = STR | | line [ 0 ] = = '!' | | line [ 0 ] = = '[' ) continue ; valid _ lines . add ( line ) ; } } return valid _ lines ;
} return valid _ lines ; } } }
using system _ drawing ; using system _ windows _ forms ; using newtonsoft _ json ; namespace shadowsocks _ model { serializable public class log _ viewer _ config {
public bool top _ most ; public bool wrap _ text ; public bool toolbar _ shown ; public log _ viewer _ config ( ) {
top _ most = false ; wrap _ text = false ; toolbar _ shown = false ; } public void save _ size ( )
} public void save _ size ( ) { properties . settings . default . save ( ) ; } json _ ignore public int width { get { return properties . settings . default . log _ viewer _ width ; } set { properties . settings . default . log _ viewer _ width = value ; }
{ get
{ } } json _ ignore public int best _ top
{ get { int height = height ;
{ int height = height ; height = ( height > = NUM ) ? height : NUM ; return screen . primary _ screen . working _ area . height - height ; }
} }
} }
} catch ( format _ exception ) { message _ box . show ( n . get _ string ( STR ) ) ; return ; } catch ( exception ex ) { message _ box . show ( ex . message ) ; return ;
namespace shadowsocks _ model { serializable public class proxy _ config { public const int proxy _ sock = 0 ; public const int proxy _ http = 1 ; public bool use _ proxy ; public int proxy _ type ; public string proxy _ server ;
this . table _ layout _ panel . controls . add ( this . use _ proxy _ check _ box , 0 , 0 ) ; this . table _ layout _ panel . controls . add ( this . table _ layout _ panel , 0 , 2 ) ; this . table _ layout _ panel . controls . add ( this . table _ layout _ panel , 0 , 1 ) ; this . table _ layout _ panel . location = new system . drawing . point ( NUM , NUM ) ; this . table _ layout _ panel . name = STR ; this . table _ layout _ panel . row _ count = NUM ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ;
this . table _ layout _ panel . location = new system . drawing . point ( NUM , NUM ) ; this . table _ layout _ panel . name = STR ; this . table _ layout _ panel . row _ count = NUM ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ;

} public int end _ send ( i _ async _ result async _ result ) { return remote . end _ send ( async _ result ) ; } public void begin _ receive ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) { remote . begin _ receive ( buffer , offset , size , socket _ flags , callback , state ) ; }
} public int end _ receive ( i _ async _ result async _ result ) { return remote . end _ receive ( async _ result ) ; } public void shutdown ( socket _ shutdown how ) { remote . shutdown ( how ) ; } public void close ( )
} public void close ( ) { remote . dispose ( ) ; } private void connect _ callback ( i _ async _ result ar ) { var state = ( socks _ state ) ar . async _ state ; try {
} private void connect _ callback ( i _ async _ result ar ) { var state = ( socks _ state ) ar . async _ state ; try { remote . end _ connect ( ar ) ; remote . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; byte [ ] handshake = { NUM , 1 , 0 } ; remote . begin _ send ( handshake , 0 , handshake . length , 0 , socks _ handshake _ send _ callback , state ) ;
{ config . proxy . use _ proxy = true ; config . proxy . proxy _ type = type ; config . proxy . proxy _ server = proxy ; config . proxy . proxy _ port = port ; save _ config ( config ) ; } public void toggle _ verbose _ logging ( bool enabled ) { config . is _ verbose _ logging = enabled ;
xml _ document doc = new xml _ document ( ) ; xml _ element log _ file _ name _ element ; xml _ element log _ level _ element ; public static n _ log _ config load _ xml ( ) { n _ log _ config config = new n _ log _ config ( ) ; config . doc . load ( nlog _ config _ file _ name ) ; config . log _ level _ element = ( xml _ element ) select _ single _ node ( config . doc , STR ) ; config . log _ file _ name _ element = ( xml _ element ) select _ single _ node ( config . doc , STR ) ;
public static n _ log _ config load _ xml ( ) { n _ log _ config config = new n _ log _ config ( ) ; config . doc . load ( nlog _ config _ file _ name ) ; config . log _ level _ element = ( xml _ element ) select _ single _ node ( config . doc , STR ) ; config . log _ file _ name _ element = ( xml _ element ) select _ single _ node ( config . doc , STR ) ; return config ; } public static void save _ xml ( n _ log _ config n _ log _ config ) {
} public void set _ log _ file _ name ( string file _ name ) { log _ file _ name _ element . set _ attribute ( logger _ file _ name _ attribute , file _ name ) ; } private static xml _ node select _ single _ node ( xml _ document doc , string xpath ) { xml _ namespace _ manager manager = new xml _ namespace _ manager ( doc . name _ table ) ; manager . add _ namespace ( STR , STR ) ; return doc . select _ single _ node ( xpath , manager ) ;
using system _ collections _ generic ; using system _ diagnostics ; using system _ drawing ; using system _ windows _ forms ; using z _ xing ; using z _ xing _ common ; using z _ xing _ qr _ code ; using shadowsocks _ controller ; using shadowsocks _ model ;
using system _ windows _ forms ; using z _ xing ; using z _ xing _ common ; using z _ xing _ qr _ code ; using shadowsocks _ controller ; using shadowsocks _ model ; using shadowsocks _ properties ; namespace shadowsocks _ view { public class menu _ view _ controller
this . notify _ icon = new system . windows . forms . notify _ icon ( this . components ) ; this . context _ menu _ strip = new system . windows . forms . context _ menu _ strip ( this . components ) ; this . config _ item = new system . windows . forms . tool _ strip _ menu _ item ( ) ; this . about _ tool _ strip _ menu _ item = new system . windows . forms . tool _ strip _ menu _ item ( ) ; this . tool _ strip _ separator = new system . windows . forms . tool _ strip _ separator ( ) ; this . quit _ item = new system . windows . forms . tool _ strip _ menu _ item ( ) ; this . panel = new system . windows . forms . panel ( ) ; this . button = new system . windows . forms . button ( ) ; this . button = new system . windows . forms . button ( ) ; this . panel = new system . windows . forms . panel ( ) ;
this . suspend _ layout ( ) ; this . table _ layout _ panel . auto _ size = true ; this . table _ layout _ panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . table _ layout _ panel . column _ count = 2 ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , 0 ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , 1 ) ; this . table _ layout _ panel . controls . add ( this . combo _ box , 1 , NUM ) ;
this . resume _ layout ( false ) ; this . perform _ layout ( ) ; } private system . windows . forms . table _ layout _ panel table _ layout _ panel ; private system . windows . forms . label label ; private system . windows . forms . label label ; private system . windows . forms . label label ; private system . windows . forms . label label ; private system . windows . forms . text _ box text _ box ; private system . windows . forms . text _ box text _ box ;
private system . windows . forms . notify _ icon notify _ icon ; private system . windows . forms . context _ menu _ strip context _ menu _ strip ; private system . windows . forms . tool _ strip _ menu _ item config _ item ; private system . windows . forms . tool _ strip _ menu _ item quit _ item ; private system . windows . forms . tool _ strip _ menu _ item about _ tool _ strip _ menu _ item ; private system . windows . forms . tool _ strip _ separator tool _ strip _ separator ; private system . windows . forms . label label ; private system . windows . forms . combo _ box combo _ box ; private system . windows . forms . panel panel ; private system . windows . forms . button button ;
{ m md = system . security . cryptography . m . create ( ) ; byte [ ] input _ bytes = system . text . encoding . ut . get _ bytes ( password ) ; byte [ ] hash = md . compute _ hash ( input _ bytes ) ; if ( method ! = null & & method . to _ lower _ invariant ( ) . equals ( STR ) ) { console . write _ line ( STR ) ; this . method = type _ r ; rc = new r ( ) ; encrypt _ table = rc . encrypt _ initalize ( hash ) ; decrypt _ table = rc . encrypt _ initalize ( hash ) ;
} } public void encrypt ( byte [ ] buf , int length ) { switch ( method ) { case type _ table : for ( int i = 0 ; i < length ; i + + ) buf [ i ] = encrypt _ table [ buf [ i ] ] ; break ;
{ case type _ table : for ( int i = 0 ; i < length ; i + + ) buf [ i ] = encrypt _ table [ buf [ i ] ] ; break ; case type _ r : rc . encrypt ( encrypt _ table , buf , length ) ; break ; } }
} } public void decrypt ( byte [ ] buf , int length ) { switch ( method ) { case type _ table : for ( int i = 0 ; i < length ; i + + ) buf [ i ] = decrypt _ table [ buf [ i ] ] ; break ;
{ case type _ table : for ( int i = 0 ; i < length ; i + + ) buf [ i ] = decrypt _ table [ buf [ i ] ] ; break ; case type _ r : rc . decrypt ( decrypt _ table , buf , length ) ; break ; } }
} } } }
using system _ net _ sockets ; using system _ timers ; using shadowsocks _ controller _ strategy ; using shadowsocks _ encryption ; using shadowsocks _ model ; namespace shadowsocks _ controller {
using shadowsocks _ encryption ; using shadowsocks _ model ; namespace shadowsocks _ controller { class tcp _ relay : listener . service { private shadowsocks _ controller controller ; private date _ time last _ sweep _ time ;
namespace shadowsocks _ controller { class tcp _ relay : listener . service { private shadowsocks _ controller controller ; private date _ time last _ sweep _ time ; public i _ set < tcp _ handler > handlers { get ; set ; }
{ get ; set ; } public tcp _ relay ( shadowsocks _ controller controller ) { controller = controller ; handlers = new hash _ set < tcp _ handler > ( ) ; last _ sweep _ time = date _ time . now ; } public bool handle ( byte [ ] first _ packet , int length , socket socket , object state )
} public bool handle ( byte [ ] first _ packet , int length , socket socket , object state ) { if ( socket . protocol _ type ! = protocol _ type . tcp ) { return false ; } if ( length < 2 | | first _ packet [ 0 ] ! = NUM ) { return false ;
handler . connection = socket ; handler . controller = controller ; handler . relay = this ; handler . start ( first _ packet , length ) ; i _ list < tcp _ handler > handlers _ to _ close = new list < tcp _ handler > ( ) ; lock ( handlers ) { handlers . add ( handler ) ; date _ time now = date _ time . now ;
date _ time now = date _ time . now ; if ( now - last _ sweep _ time > time _ span . from _ seconds ( 1 ) ) { last _ sweep _ time = now ; foreach ( tcp _ handler handler in handlers ) { if ( now - handler . last _ activity > time _ span . from _ seconds ( NUM ) ) { handlers _ to _ close . add ( handler ) ; }
{ if ( now - handler . last _ activity > time _ span . from _ seconds ( NUM ) ) { handlers _ to _ close . add ( handler ) ; } } } } foreach ( tcp _ handler handler in handlers _ to _ close ) {
{ logging . debug ( STR ) ; handler . close ( ) ; } return true ; } public void update _ inbound _ counter ( long n ) { controller . update _ inbound _ counter ( n ) ; }
{ public i _ encryptor encryptor ; public server server ; public socket remote ; public socket connection ; public shadowsocks _ controller controller ; public tcp _ relay relay ; public date _ time last _ activity ; private const int max _ retry = NUM ; private int retry _ count = 0 ;
this . server = server ; } public void start ( byte [ ] first _ packet , int length ) { first _ packet = first _ packet ; first _ packet _ length = length ; handshake _ receive ( ) ; last _ activity = date _ time . now ; } private void check _ close ( )
} private void check _ close ( ) { if ( connection _ shutdown & & remote _ shutdown ) { close ( ) ; } } public void close ( ) {
} } public void close ( ) { lock ( relay . handlers ) { relay . handlers . remove ( this ) ; } lock ( this )
relay . handlers . remove ( this ) ; } lock ( this ) { if ( closed ) { return ; } closed = true ; }
connection . begin _ send ( response , 0 , response . length , 0 , new async _ callback ( handshake _ send _ callback ) , null ) ; } else { close ( ) ; } } catch ( exception e ) { logging . log _ useful _ exception ( e ) ;
} } private void handshake _ send _ callback ( i _ async _ result ar ) { if ( closed ) { return ; } try {
connection . begin _ send ( response , 0 , response . length , 0 , new async _ callback ( response _ callback ) , null ) ; } else if ( command = = NUM ) { handle _ udp _ associate ( ) ; } } else { logging . debug ( STR ) ;
} } private void handle _ udp _ associate ( ) { ip _ end _ point end _ point = ( ip _ end _ point ) connection . local _ end _ point ; byte [ ] address = end _ point . address . get _ address _ bytes ( ) ; int port = end _ point . port ; byte [ ] response = new byte [ NUM + address . length + 2 ] ; response [ 0 ] = NUM ; if ( end _ point . address _ family = = address _ family . inter _ network )
} else { int bytes _ read = connection . end _ receive ( ar ) ; if ( bytes _ read > 0 ) { logging . debug ( remote , recv _ size , STR ) ; connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , 0 , new async _ callback ( read _ all ) , null ) ;
} else { close ( ) ; } } } catch ( exception e ) { logging . log _ useful _ exception ( e ) ;
} } private void response _ callback ( i _ async _ result ar ) { try { connection . end _ send ( ar ) ; start _ connect ( ) ; } catch ( exception e )
start _ connect ( ) ; retry _ count + + ; } else { close ( ) ; } } private void connect _ callback ( i _ async _ result ar ) {
} } private void connect _ callback ( i _ async _ result ar ) { server server = null ; if ( closed ) { return ; } try
int bytes _ to _ send ; lock ( decryption _ lock ) { if ( closed ) { return ; } encryptor . decrypt ( remote _ recv _ buffer , bytes _ read , remote _ send _ buffer , out bytes _ to _ send ) ; } logging . debug ( remote , bytes _ to _ send , STR , STR ) ;
connection . begin _ send ( remote _ send _ buffer , 0 , bytes _ to _ send , 0 , new async _ callback ( pipe _ connection _ send _ callback ) , null ) ; i _ strategy strategy = controller . get _ current _ strategy ( ) ; if ( strategy ! = null ) { strategy . update _ last _ read ( server ) ; } } else { connection . shutdown ( socket _ shutdown . send ) ;
} } else { connection . shutdown ( socket _ shutdown . send ) ; connection _ shutdown = true ; check _ close ( ) ; } } catch ( exception e )
} } private void pipe _ connection _ receive _ callback ( i _ async _ result ar ) { if ( closed ) { return ; } try {
remote . begin _ send ( connetion _ send _ buffer , 0 , bytes _ to _ send , 0 , new async _ callback ( pipe _ remote _ send _ callback ) , null ) ; i _ strategy strategy = controller . get _ current _ strategy ( ) ; if ( strategy ! = null ) { strategy . update _ last _ write ( server ) ; } } else { remote . shutdown ( socket _ shutdown . send ) ;
} } else { remote . shutdown ( socket _ shutdown . send ) ; remote _ shutdown = true ; check _ close ( ) ; } } catch ( exception e )
using system _ collections _ generic ; using system _ net ; using system _ net _ network _ information ; using system _ net _ sockets ; using shadowsocks _ model ; namespace shadowsocks _ controller { public class listener { public interface service
namespace shadowsocks _ controller { public class listener { public interface service { bool handle ( byte [ ] first _ packet , int length , socket socket , object state ) ; } public class udp _ state {
using system _ collections _ generic ; using system _ io ; using system _ net ; using system _ net _ sockets ; using system _ text ; using system _ threading ; using shadowsocks _ controller _ strategy ; using shadowsocks _ model ; using shadowsocks _ properties ;
using shadowsocks _ controller _ strategy ; using shadowsocks _ model ; using shadowsocks _ properties ; using shadowsocks _ util ; namespace shadowsocks _ controller { public class shadowsocks _ controller {
using shadowsocks _ util ; namespace shadowsocks _ controller { public class shadowsocks _ controller { private thread ram _ thread ; private listener listener ; private pac _ server pac _ server ; private configuration config ;
namespace shadowsocks _ controller { public class shadowsocks _ controller { private thread ram _ thread ; private listener listener ; private pac _ server pac _ server ; private configuration config ; private strategy _ manager strategy _ manager ; private polipo _ runner polipo _ runner ;
using shadowsocks _ encryption ; using shadowsocks _ model ; namespace shadowsocks _ controller { class udp _ relay : listener . service {
namespace shadowsocks _ controller { class udp _ relay : listener . service { private shadowsocks _ controller controller ; private lru _ cache < ip _ end _ point , udp _ handler > cache ; public long outbound = 0 ; public long inbound = 0 ; public udp _ relay ( shadowsocks _ controller controller ) {
using system _ diagnostics ; using system _ io ; using system _ i _ compression ; using system _ runtime _ interop _ services ; using system _ windows _ forms ; using shadowsocks _ controller ; namespace shadowsocks _ util { public class utils
using system _ windows _ forms ; using shadowsocks _ controller ; namespace shadowsocks _ util { public class utils { public static string get _ temp _ path ( ) { if ( file . exists ( application . startup _ path + STR ) ) {
using system _ drawing ; using system _ io ; using system _ windows _ forms ; using shadowsocks _ controller ; using shadowsocks _ properties ; using shadowsocks _ model ; using shadowsocks _ util ; namespace shadowsocks _ view
using system _ windows _ forms ; using shadowsocks _ controller ; using shadowsocks _ properties ; using shadowsocks _ model ; using shadowsocks _ util ; namespace shadowsocks _ view { public partial class log _ form : form { long last _ offset ;
using system _ net ; using system _ net _ sockets ; namespace shadowsocks _ controller { class port _ forwarder : listener . service { int target _ port ; public port _ forwarder ( int target _ port ) {
namespace shadowsocks _ controller { class port _ forwarder : listener . service { int target _ port ; public port _ forwarder ( int target _ port ) { this . target _ port = target _ port ; } public bool handle ( byte [ ] first _ packet , int length , socket socket , object state )
public void update _ inbound ( long delta ) { interlocked . add ( ref inbound , delta ) ;
} public void update _ outbound ( long delta ) { interlocked . add ( ref outbound , delta ) ;
} public void get _ delta ( out long inbound _ delta , out long outbound _ delta ) { var i = interlocked . read ( ref inbound ) ; var il = interlocked . exchange ( ref last _ inbound , i ) ; inbound _ delta = i - il ; var o = interlocked . read ( ref outbound ) ; var ol = interlocked . exchange ( ref last _ outbound , o ) ; outbound _ delta = o - ol ;
} } private readonly time _ span delay _ before _ start = time _ span . from _ seconds ( 1 ) ; private readonly time _ span retry _ interval = time _ span . from _ minutes ( 2 ) ; private timer recorder ; private time _ span recording _ interval = > time _ span . from _ minutes ( config . data _ collection _ minutes ) ; private timer speed _ monior ; private readonly time _ span monitor _ interval = time _ span . from _ seconds ( 1 ) ; private shadowsocks _ controller controller ; private statistics _ strategy _ configuration config = > controller . statistics _ configuration ;
void begin _ connect _ proxy ( end _ point remote _ ep , async _ callback callback , object state ) ; void end _ connect _ proxy ( i _ async _ result async _ result ) ; void begin _ connect _ dest ( end _ point dest _ end _ point , async _ callback callback , object state ) ; void end _ connect _ dest ( i _ async _ result async _ result ) ; void begin _ send ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) ; int end _ send ( i _ async _ result async _ result ) ; void begin _ receive ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) ; int end _ receive ( i _ async _ result async _ result ) ;
void end _ connect _ dest ( i _ async _ result async _ result ) ; void begin _ send ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) ; int end _ send ( i _ async _ result async _ result ) ; void begin _ receive ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) ; int end _ receive ( i _ async _ result async _ result ) ; void shutdown ( socket _ shutdown how ) ; void close ( ) ; }
byte [ ] request = null ; byte atyp = 0 ; int port ; var dep = dest _ end _ point as dns _ end _ point ; if ( dep ! = null ) { atyp = NUM ; var enc = encoding . ut ; var host _ byte _ count = enc . get _ byte _ count ( dep . host ) ; request = new byte [ NUM + 1
{ case address _ family . inter _ network : request = new byte [ NUM + NUM + 2 ] ; atyp = 1 ; break ; case address _ family . inter _ network : request = new byte [ NUM + NUM + 2 ] ; atyp = NUM ; break ; default :
array . copy ( addr , 0 , request , NUM , request . length - NUM - 2 ) ;
} request [ 0 ] = NUM ; request [ 1 ] = 1 ; request [ 2 ] = 0 ; request [ NUM ] = atyp ; request [ request . length - 2 ] = ( byte ) ( ( port > > NUM ) & 0 xff ) ; request [ request . length - 1 ] = ( byte ) ( port & 0 xff ) ; var st = new socks _ state ( ) ; st . callback = callback ; st . async _ state = state ;
public void begin _ connect _ proxy ( end _ point remote _ ep , async _ callback callback , object state ) { var r = new fake _ async _ result ( state ) ; callback ? . invoke ( r ) ; } public void end _ connect _ proxy ( i _ async _ result async _ result ) { } public void begin _ connect _ dest ( end _ point dest _ end _ point , async _ callback callback , object state ) {
{ end _ point real _ end _ point = dest _ end _ point = dest _ end _ point ; * on windows vista or later , dual - mode socket is supported , so that * we don ' t need to resolve a dns _ end _ point manually . * we could just create a dual - mode socket and pass the dns _ end _ point * directly to it ' s begin _ connect and the system will handle it correctlly * so that we won ' t worry about async resolving any more . * * see : https : *
{ ip _ host _ entry ip _ host _ info = dns . get _ host _ entry ( dep . host ) ; ip _ address ip _ address = ip _ host _ info . address _ list [ 0 ] ; real _ end _ point = new ip _ end _ point ( ip _ address , dep . port ) ; }
} if ( remote = = null ) { remote = new socket ( real _ end _ point . address _ family , socket _ type . stream , protocol _ type . tcp ) ; remote . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; } remote . begin _ connect ( real _ end _ point , callback , state ) ;
if ( remote = = null ) { remote = new socket ( real _ end _ point . address _ family , socket _ type . stream , protocol _ type . tcp ) ; remote . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; } remote . begin _ connect ( real _ end _ point , callback , state ) ; } public void end _ connect _ dest ( i _ async _ result async _ result ) { remote ? . end _ connect ( async _ result ) ;
remote . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; } remote . begin _ connect ( real _ end _ point , callback , state ) ; } public void end _ connect _ dest ( i _ async _ result async _ result ) { remote ? . end _ connect ( async _ result ) ; } public void begin _ send ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state )
} public void end _ connect _ dest ( i _ async _ result async _ result ) { remote ? . end _ connect ( async _ result ) ; } public void begin _ send ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) { remote ? . begin _ send ( buffer , offset , size , socket _ flags , callback , state ) ; }
{ this . controller = controller ; initialize _ component ( ) ; icon = icon . from _ handle ( resources . ssw . get _ hicon ( ) ) ; var n _ log _ config = n _ log _ config . load _ xml ( ) ; this . filename = n _ log _ config . get _ log _ file _ name ( ) ; log _ viewer _ config config = controller . get _ configuration _ copy ( ) . log _ viewer ; top _ most _ trigger = config . top _ most ; wrap _ text _ trigger = config . wrap _ text ;
initialize _ component ( ) ; icon = icon . from _ handle ( resources . ssw . get _ hicon ( ) ) ; var n _ log _ config = n _ log _ config . load _ xml ( ) ; this . filename = n _ log _ config . get _ log _ file _ name ( ) ; log _ viewer _ config config = controller . get _ configuration _ copy ( ) . log _ viewer ; top _ most _ trigger = config . top _ most ; wrap _ text _ trigger = config . wrap _ text ; toolbar _ trigger = config . toolbar _ shown ; log _ message _ text _ box . back _ color = config . background _ color ; log _ message _ text _ box . fore _ color = config . text _ color ;
{ public class stream _ sodium _ encryptor : stream _ encryptor , i _ disposable { const int cipher _ sals = 1 ; const int cipher _ chach = 2 ; const int cipher _ chach _ ietf = NUM ; const int sodium _ block _ size = NUM ; protected int encrypt _ bytes _ remaining ; protected int decrypt _ bytes _ remaining ;
{ const int cipher _ sals = 1 ; const int cipher _ chach = 2 ; const int cipher _ chach _ ietf = NUM ; const int sodium _ block _ size = NUM ; protected int encrypt _ bytes _ remaining ; protected int decrypt _ bytes _ remaining ; protected ulong encrypt _ ic ; protected ulong decrypt _ ic ; protected byte [ ] encrypt _ buf ;
{ int bytes _ remaining ; ulong ic ; byte [ ] sodium _ buf ; byte [ ] iv ; int ret = - 1 ; if ( is _ encrypt ) { bytes _ remaining = encrypt _ bytes _ remaining ;
{ bytes _ remaining = encrypt _ bytes _ remaining ; ic = encrypt _ ic ; sodium _ buf = encrypt _ buf ; iv = encrypt _ iv ; } else { bytes _ remaining = decrypt _ bytes _ remaining ; ic = decrypt _ ic ;
break ; case cipher _ chach : ret = sodium . crypto _ stream _ chacha _ xor _ ic ( sodium _ buf , sodium _ buf , ( ulong ) ( padding + length ) , iv , ic , key ) ; break ; case cipher _ chach _ ietf : ret = sodium . crypto _ stream _ chacha _ ietf _ xor _ ic ( sodium _ buf , sodium _ buf , ( ulong ) ( padding + length ) , iv , ( uint ) ic , key ) ; break ; } if ( ret ! = 0 ) throw new crypto _ error _ exception ( ) ; buffer . block _ copy ( sodium _ buf , padding , outbuf , 0 , length ) ;
break ; case cipher _ chach _ ietf : ret = sodium . crypto _ stream _ chacha _ ietf _ xor _ ic ( sodium _ buf , sodium _ buf , ( ulong ) ( padding + length ) , iv , ( uint ) ic , key ) ; break ; } if ( ret ! = 0 ) throw new crypto _ error _ exception ( ) ; buffer . block _ copy ( sodium _ buf , padding , outbuf , 0 , length ) ; padding + = length ; ic + = ( ulong ) padding / sodium _ block _ size ; bytes _ remaining = padding % sodium _ block _ size ;
break ; } if ( ret ! = 0 ) throw new crypto _ error _ exception ( ) ; buffer . block _ copy ( sodium _ buf , padding , outbuf , 0 , length ) ; padding + = length ; ic + = ( ulong ) padding / sodium _ block _ size ; bytes _ remaining = padding % sodium _ block _ size ; if ( is _ encrypt ) { encrypt _ bytes _ remaining = bytes _ remaining ;
{ encrypt _ bytes _ remaining = bytes _ remaining ; encrypt _ ic = ic ; } else { decrypt _ bytes _ remaining = bytes _ remaining ; decrypt _ ic = ic ; } }
{ public class encryptor _ info { public int key _ size ; public int iv _ size ; public int salt _ size ; public int tag _ size ; public int nonce _ size ; public int type ; public string inner _ lib _ name ;
{ public int key _ size ; public int iv _ size ; public int salt _ size ; public int tag _ size ; public int nonce _ size ; public int type ; public string inner _ lib _ name ; public encryptor _ info ( string inner _ lib _ name , int key _ size , int iv _ size , int type ) {
{ method = method ; password = password ; } protected string method ; protected string password ;
} protected string method ; protected string password ;
public abstract void encrypt ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength ) ; public abstract void decrypt ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength ) ; public abstract void encrypt _ udp ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength ) ; public abstract void decrypt _ udp ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength ) ; public abstract void dispose ( ) ; public int addr _ buf _ length { get ; set ; } = - 1 ; } }
{ private const string dllname = STR ; private static bool initialized = false ; private static readonly object init _ lock = new object ( ) ; static sodium ( ) { string dll _ path = utils . get _ temp _ path ( dllname ) ; try {
static sodium ( ) { string dll _ path = utils . get _ temp _ path ( dllname ) ; try { file _ manager . uncompress _ file ( dll _ path , resources . libsscrypto _ dll ) ; } catch ( io _ exception ) { }
try { file _ manager . uncompress _ file ( dll _ path , resources . libsscrypto _ dll ) ; } catch ( io _ exception ) { } catch ( system . exception e ) { logging . log _ useful _ exception ( e ) ;
{ logging . log _ useful _ exception ( e ) ; } load _ library ( dll _ path ) ; lock ( init _ lock ) { if ( ! initialized ) { if ( sodium _ init ( ) = = - 1 ) {
dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern int sodium _ increment ( byte [ ] n , int nlen ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern int crypto _ aead _ chacha _ poly _ ietf _ encrypt ( byte [ ] c , ref ulong clen _ p , byte [ ] m , ulong mlen , byte [ ] ad , ulong adlen , byte [ ] nsec , byte [ ] npub , byte [ ] k ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern int crypto _ aead _ chacha _ poly _ ietf _ decrypt ( byte [ ] m , ref ulong mlen _ p , byte [ ] nsec , byte [ ] c , ulong clen , byte [ ] ad , ulong adlen , byte [ ] npub , byte [ ] k ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl
dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern int crypto _ aead _ chacha _ poly _ ietf _ encrypt ( byte [ ] c , ref ulong clen _ p , byte [ ] m , ulong mlen , byte [ ] ad , ulong adlen , byte [ ] nsec , byte [ ] npub , byte [ ] k ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern int crypto _ aead _ chacha _ poly _ ietf _ decrypt ( byte [ ] m , ref ulong mlen _ p , byte [ ] nsec , byte [ ] c , ulong clen , byte [ ] ad , ulong adlen , byte [ ] npub , byte [ ] k ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern int crypto _ stream _ salsa _ xor _ ic ( byte [ ] c , byte [ ] m , ulong mlen , byte [ ] n , ulong ic , byte [ ] k ) ;
dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern int crypto _ aead _ chacha _ poly _ ietf _ decrypt ( byte [ ] m , ref ulong mlen _ p , byte [ ] nsec , byte [ ] c , ulong clen , byte [ ] ad , ulong adlen , byte [ ] npub , byte [ ] k ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern int crypto _ stream _ salsa _ xor _ ic ( byte [ ] c , byte [ ] m , ulong mlen , byte [ ] n , ulong ic , byte [ ] k ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern int crypto _ stream _ chacha _ xor _ ic ( byte [ ] c , byte [ ] m , ulong mlen , byte [ ] n , ulong ic , byte [ ] k ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl
} }
} public static void get _ bytes ( byte [ ] buf , int len ) { if ( rng = = null ) reload ( ) ; try { rng . get _ bytes ( buf , 0 , len ) ; } catch ( system . exception ) {
{ byte [ ] tmp = new byte [ len ] ; rng . get _ bytes ( tmp ) ; buffer . block _ copy ( tmp , 0 , buf , 0 , len ) ; } } } }
public long outbound = 0 ; public long inbound = 0 ; public udp _ relay ( shadowsocks _ controller controller ) { this . controller = controller ; } public override bool handle ( byte [ ] first _ packet , int length , socket socket , object state ) { if ( socket . protocol _ type ! = protocol _ type . udp )
} public override bool handle ( byte [ ] first _ packet , int length , socket socket , object state ) { if ( socket . protocol _ type ! = protocol _ type . udp ) { return false ; } if ( length < NUM ) { return false ;
array . copy ( data , NUM , data _ in , 0 , length - NUM ) ; byte [ ] data _ out = new byte [ length - NUM + NUM ] ; int outlen ; encryptor . encrypt _ udp ( data _ in , length - NUM , data _ out , out outlen ) ; logging . debug ( local _ end _ point , remote _ end _ point , outlen , STR ) ; remote ? . send _ to ( data _ out , outlen , socket _ flags . none , remote _ end _ point ) ; } public void receive ( ) { end _ point remote _ end _ point = new ip _ end _ point ( ip _ address . any , 0 ) ;
int outlen ; encryptor . encrypt _ udp ( data _ in , length - NUM , data _ out , out outlen ) ; logging . debug ( local _ end _ point , remote _ end _ point , outlen , STR ) ; remote ? . send _ to ( data _ out , outlen , socket _ flags . none , remote _ end _ point ) ; } public void receive ( ) { end _ point remote _ end _ point = new ip _ end _ point ( ip _ address . any , 0 ) ; logging . debug ( $ STR + buffer . length ) ; remote ? . begin _ receive _ from ( buffer , 0 , buffer . length , 0 , ref remote _ end _ point , new async _ callback ( recv _ from _ callback ) , null ) ;
logging . debug ( local _ end _ point , remote _ end _ point , outlen , STR ) ; remote ? . send _ to ( data _ out , outlen , socket _ flags . none , remote _ end _ point ) ; } public void receive ( ) { end _ point remote _ end _ point = new ip _ end _ point ( ip _ address . any , 0 ) ; logging . debug ( $ STR + buffer . length ) ; remote ? . begin _ receive _ from ( buffer , 0 , buffer . length , 0 , ref remote _ end _ point , new async _ callback ( recv _ from _ callback ) , null ) ; } public void recv _ from _ callback ( i _ async _ result ar )
public date _ time last _ activity ; private shadowsocks _ controller controller ; private configuration config ; private tcp _ relay tcprelay ; private socket connection ; private i _ encryptor encryptor ; private server server ; private async _ session current _ remote _ session ; private bool proxy _ connected ; private bool dest _ connected ;
private readonly object encryption _ lock = new object ( ) ; private readonly object decryption _ lock = new object ( ) ; private readonly object close _ conn _ lock = new object ( ) ; private date _ time start _ connect _ time ; private date _ time start _ receiving _ time ; private date _ time start _ sending _ time ; private end _ point dest _ end _ point = null ; public tcp _ handler ( shadowsocks _ controller controller , configuration config , tcp _ relay tcprelay , socket socket ) { controller = controller ;
this . server = server ; logging . debug ( $ STR ) ; encryptor . addr _ buf _ length = addr _ buf _ length ; } public void start ( byte [ ] first _ packet , int length ) { first _ packet = first _ packet ; first _ packet _ length = length ; handshake _ receive ( ) ; }
{ if ( closed ) return ; try { int bytes _ read = connection . end _ receive ( ar ) ; if ( bytes _ read > = NUM ) { command = connetion _ recv _ buffer [ 1 ] ; if ( command ! = cmd _ connect & & command ! = cmd _ udp _ assoc ) {
{ logging . debug ( STR + command ) ; close ( ) ; } else { if ( command = = cmd _ connect ) { byte [ ] response = { NUM , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 } ; connection . begin _ send ( response , 0 , response . length , socket _ flags . none ,
{ byte [ ] response = { NUM , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 } ; connection . begin _ send ( response , 0 , response . length , socket _ flags . none , response _ callback , null ) ; } else if ( command = = cmd _ udp _ assoc ) { read _ address ( handle _ udp _ associate ) ; } }
} else if ( command = = cmd _ udp _ assoc ) { read _ address ( handle _ udp _ associate ) ; } } } else { logging . debug (
{ read _ address ( handle _ udp _ associate ) ; } } } else { logging . debug ( STR ) ;
break ; case atyp _ domain : int len = connetion _ recv _ buffer [ NUM ] ; read _ address ( len + addr _ port _ len , on _ success ) ; break ; case atyp _ i _ pv : read _ address ( NUM + addr _ port _ len - 1 , on _ success ) ; break ; default : logging . debug ( STR + atyp ) ;
int len = connetion _ recv _ buffer [ NUM ] ; read _ address ( len + addr _ port _ len , on _ success ) ; break ; case atyp _ i _ pv : read _ address ( NUM + addr _ port _ len - 1 , on _ success ) ; break ; default : logging . debug ( STR + atyp ) ; close ( ) ; break ;
break ; case atyp _ i _ pv : read _ address ( NUM + addr _ port _ len - 1 , on _ success ) ; break ; default : logging . debug ( STR + atyp ) ; close ( ) ; break ; } }
break ; default : logging . debug ( STR + atyp ) ; close ( ) ; break ; } } private void read _ address ( int bytes _ remain , action on _ success ) { array . copy ( connetion _ recv _ buffer , NUM , connetion _ recv _ buffer , 0 , addr _ atyp _ len + 1 ) ;
connection . begin _ receive ( connetion _ recv _ buffer , 2 , recv _ size - 2 , socket _ flags . none , on _ address _ fully _ read , new object [ ] { bytes _ remain , on _ success } ) ; } private void on _ address _ fully _ read ( i _ async _ result ar ) { if ( closed ) return ; try { int bytes _ read = connection . end _ receive ( ar ) ;
break ; case atyp _ domain : int len = connetion _ recv _ buffer [ 1 ] ; dst _ addr = system . text . encoding . ut . get _ string ( connetion _ recv _ buffer , 2 , len ) ; dst _ port = ( connetion _ recv _ buffer [ len + 2 ] < < NUM ) + connetion _ recv _ buffer [ len + NUM ] ; addr _ buf _ length = addr _ atyp _ len + 1 + len + addr _ port _ len ; break ; case atyp _ i _ pv : dst _ addr = $ STR ; dst _ port = ( connetion _ recv _ buffer [ NUM ] < < NUM ) + connetion _ recv _ buffer [ NUM ] ;
int len = connetion _ recv _ buffer [ 1 ] ; dst _ addr = system . text . encoding . ut . get _ string ( connetion _ recv _ buffer , 2 , len ) ; dst _ port = ( connetion _ recv _ buffer [ len + 2 ] < < NUM ) + connetion _ recv _ buffer [ len + NUM ] ; addr _ buf _ length = addr _ atyp _ len + 1 + len + addr _ port _ len ; break ; case atyp _ i _ pv : dst _ addr = $ STR ; dst _ port = ( connetion _ recv _ buffer [ NUM ] < < NUM ) + connetion _ recv _ buffer [ NUM ] ; addr _ buf _ length = addr _ atyp _ len + NUM + addr _ port _ len ; break ;
break ; case atyp _ i _ pv : dst _ addr = $ STR ; dst _ port = ( connetion _ recv _ buffer [ NUM ] < < NUM ) + connetion _ recv _ buffer [ NUM ] ; addr _ buf _ length = addr _ atyp _ len + NUM + addr _ port _ len ; break ; } if ( config . is _ verbose _ logging ) { logging . info ( $ STR ) ;
break ; } if ( config . is _ verbose _ logging ) { logging . info ( $ STR ) ; } dest _ end _ point = socket _ util . get _ end _ point ( dst _ addr , dst _ port ) ; on _ success . invoke ( ) ; } else
response [ 0 ] = NUM ; switch ( end _ point . address _ family ) { case address _ family . inter _ network : response [ NUM ] = atyp _ i _ pv ; break ; case address _ family . inter _ network : response [ NUM ] = atyp _ i _ pv ; break ; }
break ; case address _ family . inter _ network : response [ NUM ] = atyp _ i _ pv ; break ; } address . copy _ to ( response , NUM ) ; response [ response . length - 1 ] = ( byte ) ( port & 0 xff ) ; response [ response . length - 2 ] = ( byte ) ( ( port > > NUM ) & 0 xff ) ; connection . begin _ send ( response , 0 , response . length , socket _ flags . none , read _ all , true ) ; }
break ; } address . copy _ to ( response , NUM ) ; response [ response . length - 1 ] = ( byte ) ( port & 0 xff ) ; response [ response . length - 2 ] = ( byte ) ( ( port > > NUM ) & 0 xff ) ; connection . begin _ send ( response , 0 , response . length , socket _ flags . none , read _ all , true ) ; } private void read _ all ( i _ async _ result ar ) { if ( closed ) return ;
} private void read _ all ( i _ async _ result ar ) { if ( closed ) return ; try { if ( ar . async _ state ! = null ) { connection . end _ send ( ar ) ; connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , socket _ flags . none ,
} else { int bytes _ read = connection . end _ receive ( ar ) ; if ( bytes _ read > 0 ) { connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , socket _ flags . none , read _ all , null ) ; }
} else close ( ) ; } } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; }
if ( config . proxy . use _ proxy ) { switch ( config . proxy . proxy _ type ) { case proxy _ config . proxy _ sock : remote = new socks _ proxy ( ) ; break ; case proxy _ config . proxy _ http : remote = new http _ proxy ( ) ; break ;
proxy _ timer . enabled = true ; proxy _ timer . session = session ; proxy _ timer . dest _ end _ point = socket _ util . get _ end _ point ( server . server , server . server _ port ) ; proxy _ timer . server = server ; proxy _ connected = false ; remote . begin _ connect _ proxy ( proxy _ ep , proxy _ connect _ callback , new async _ session < proxy _ timer > ( remote , proxy _ timer ) ) ; } catch ( exception e ) {
timer . enabled = false ; timer . dispose ( ) ; if ( proxy _ connected | | dest _ connected | | closed ) { return ; } var proxy = timer . session . remote ; logging . info ( $ STR ) ; proxy . close ( ) ; close ( ) ;
if ( closed ) { return ; } try { var session = ( async _ session < proxy _ timer > ) ar . async _ state ; proxy _ timer timer = session . state ; var dest _ end _ point = timer . dest _ end _ point ; var server = timer . server ;
timer . enabled = false ; timer . dispose ( ) ; var remote = session . remote ; remote . end _ connect _ proxy ( ar ) ; proxy _ connected = true ; if ( config . is _ verbose _ logging ) { if ( ! ( remote is direct _ connect ) ) { logging . info ( $ STR ) ;
connect _ timer . enabled = true ; connect _ timer . session = session ; connect _ timer . server = server ; dest _ connected = false ; remote . begin _ connect _ dest ( dest _ end _ point , connect _ callback , new async _ session < server _ timer > ( session , connect _ timer ) ) ; } catch ( argument _ exception ) {
} catch ( argument _ exception ) { } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; } }
lock ( decryption _ lock ) { try { encryptor . decrypt ( remote _ recv _ buffer , bytes _ read , remote _ send _ buffer , out bytes _ to _ send ) ; } catch ( crypto _ error _ exception ) { logging . error ( STR ) ; close ( ) ;
i _ strategy strategy = controller . get _ current _ strategy ( ) ; strategy ? . update _ last _ read ( server ) ; } else { connection . shutdown ( socket _ shutdown . send ) ; connection _ shutdown = true ; check _ close ( ) ; } }
} tcprelay . update _ outbound _ counter ( server , bytes _ to _ send ) ; start _ sending _ time = date _ time . now ; session . remote . begin _ send ( connetion _ send _ buffer , 0 , bytes _ to _ send , socket _ flags . none , pipe _ remote _ send _ callback , new object [ ] { session , bytes _ to _ send } ) ; i _ strategy strategy = controller . get _ current _ strategy ( ) ; strategy ? . update _ last _ write ( server ) ; } private void pipe _ remote _ send _ callback ( i _ async _ result ar )
i _ strategy strategy = controller . get _ current _ strategy ( ) ; strategy ? . update _ last _ write ( server ) ; } private void pipe _ remote _ send _ callback ( i _ async _ result ar ) { if ( closed ) return ; try { var container = ( object [ ] ) ar . async _ state ; var session = ( async _ session ) container [ 0 ] ;
private void pipe _ connection _ send _ callback ( i _ async _ result ar ) { try { var container = ( object [ ] ) ar . async _ state ; var session = ( async _ session ) container [ 0 ] ; var bytes _ should _ send = ( int ) container [ 1 ] ; var bytes _ sent = connection . end _ send ( ar ) ; var bytes _ remaining = bytes _ should _ send - bytes _ sent ; if ( bytes _ remaining > 0 )
} catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; } } } }
{ public class stream _ mbed _ tls _ encryptor : stream _ encryptor , i _ disposable { const int cipher _ r = 1 ; const int cipher _ aes = 2 ; const int cipher _ blowfish = NUM ; const int cipher _ camellia = NUM ; private int _ ptr encrypt _ ctx = int _ ptr . zero ; private int _ ptr decrypt _ ctx = int _ ptr . zero ;
{ const int cipher _ r = 1 ; const int cipher _ aes = 2 ; const int cipher _ blowfish = NUM ; const int cipher _ camellia = NUM ; private int _ ptr encrypt _ ctx = int _ ptr . zero ; private int _ ptr decrypt _ ctx = int _ ptr . zero ; public stream _ mbed _ tls _ encryptor ( string method , string password ) : base ( method , password ) {
{ } private static dictionary < string , encryptor _ info > ciphers = new dictionary < string , encryptor _ info > { { STR , new encryptor _ info ( STR , NUM , NUM , cipher _ aes ) } , { STR , new encryptor _ info ( STR , NUM , NUM , cipher _ aes ) } , { STR , new encryptor _ info ( STR , NUM , NUM , cipher _ aes ) } , { STR , new encryptor _ info ( STR , NUM , NUM , cipher _ aes ) } , { STR , new encryptor _ info ( STR , NUM , NUM , cipher _ aes ) } , { STR , new encryptor _ info ( STR , NUM , NUM , cipher _ aes ) } , { STR , new encryptor _ info ( STR , NUM , NUM , cipher _ blowfish ) } ,
int _ ptr ctx = marshal . alloc _ h _ global ( mbed _ tls . cipher _ get _ size _ ex ( ) ) ; if ( is _ encrypt ) { encrypt _ ctx = ctx ; } else { decrypt _ ctx = ctx ; } byte [ ] realkey ;
if ( mbed _ tls . cipher _ set _ iv ( ctx , iv , iv _ len ) ! = 0 ) throw new system . exception ( STR ) ; if ( mbed _ tls . cipher _ reset ( ctx ) ! = 0 ) throw new system . exception ( STR ) ; } protected override void cipher _ update ( bool is _ encrypt , int length , byte [ ] buf , byte [ ] outbuf ) { if ( disposed ) { throw new object _ disposed _ exception ( this . to _ string ( ) ) ;
if ( mbed _ tls . cipher _ reset ( ctx ) ! = 0 ) throw new system . exception ( STR ) ; } protected override void cipher _ update ( bool is _ encrypt , int length , byte [ ] buf , byte [ ] outbuf ) { if ( disposed ) { throw new object _ disposed _ exception ( this . to _ string ( ) ) ; } if ( mbed _ tls . cipher _ update ( is _ encrypt ? encrypt _ ctx : decrypt _ ctx ,
} protected override void cipher _ update ( bool is _ encrypt , int length , byte [ ] buf , byte [ ] outbuf ) { if ( disposed ) { throw new object _ disposed _ exception ( this . to _ string ( ) ) ; } if ( mbed _ tls . cipher _ update ( is _ encrypt ? encrypt _ ctx : decrypt _ ctx , buf , length , outbuf , ref length ) ! = 0 ) throw new crypto _ error _ exception ( ) ;
{ if ( disposed ) { throw new object _ disposed _ exception ( this . to _ string ( ) ) ; } if ( mbed _ tls . cipher _ update ( is _ encrypt ? encrypt _ ctx : decrypt _ ctx , buf , length , outbuf , ref length ) ! = 0 ) throw new crypto _ error _ exception ( ) ; } private bool disposed ;
buf , length , outbuf , ref length ) ! = 0 ) throw new crypto _ error _ exception ( ) ; } private bool disposed ; private readonly object lock = new object ( ) ; public override void dispose ( ) { dispose ( true ) ; gc . suppress _ finalize ( this ) ; }
} private bool disposed ; private readonly object lock = new object ( ) ; public override void dispose ( ) { dispose ( true ) ; gc . suppress _ finalize ( this ) ; } ~ stream _ mbed _ tls _ encryptor ( ) {
{ dispose ( false ) ; } protected virtual void dispose ( bool disposing ) { lock ( lock ) { if ( disposed ) return ; disposed = true ; }
static encryptor _ factory ( ) { foreach ( string method in stream _ mbed _ tls _ encryptor . supported _ ciphers ( ) ) { registered _ encryptors . add ( method , typeof ( stream _ mbed _ tls _ encryptor ) ) ; } foreach ( string method in stream _ sodium _ encryptor . supported _ ciphers ( ) ) {
{ registered _ encryptors . add ( method , typeof ( stream _ mbed _ tls _ encryptor ) ) ; } foreach ( string method in stream _ sodium _ encryptor . supported _ ciphers ( ) ) { registered _ encryptors . add ( method , typeof ( stream _ sodium _ encryptor ) ) ; } foreach ( string method in aead _ mbed _ tls _ encryptor . supported _ ciphers ( ) ) { registered _ encryptors . add ( method , typeof ( aead _ mbed _ tls _ encryptor ) ) ;
} foreach ( string method in stream _ sodium _ encryptor . supported _ ciphers ( ) ) { registered _ encryptors . add ( method , typeof ( stream _ sodium _ encryptor ) ) ; } foreach ( string method in aead _ mbed _ tls _ encryptor . supported _ ciphers ( ) ) { registered _ encryptors . add ( method , typeof ( aead _ mbed _ tls _ encryptor ) ) ; } foreach ( string method in aead _ sodium _ encryptor . supported _ ciphers ( ) )
{ registered _ encryptors . add ( method , typeof ( stream _ sodium _ encryptor ) ) ; } foreach ( string method in aead _ mbed _ tls _ encryptor . supported _ ciphers ( ) ) { registered _ encryptors . add ( method , typeof ( aead _ mbed _ tls _ encryptor ) ) ; } foreach ( string method in aead _ sodium _ encryptor . supported _ ciphers ( ) ) { registered _ encryptors . add ( method , typeof ( aead _ sodium _ encryptor ) ) ;
} } public static i _ encryptor get _ encryptor ( string method , string password ) { if ( method . is _ null _ or _ empty ( ) ) { method = STR ; } method = method . to _ lower _ invariant ( ) ; type t = registered _ encryptors [ method ] ;
{ if ( method . is _ null _ or _ empty ( ) ) { method = STR ; } method = method . to _ lower _ invariant ( ) ; type t = registered _ encryptors [ method ] ; constructor _ info c = t . get _ constructor ( constructor _ types ) ; if ( c = = null ) throw new system . exception ( STR ) ; i _ encryptor result = ( i _ encryptor ) c . invoke ( new object [ ] { method , password } ) ;
return result ; } } }
{ private const string dllname = STR ; public const int mbedtls _ encrypt = 1 ; public const int mbedtls _ decrypt = 0 ; static mbed _ tls ( ) { string dll _ path = utils . get _ temp _ path ( dllname ) ; try { file _ manager . uncompress _ file ( dll _ path , resources . libsscrypto _ dll ) ;
public const int mbedtls _ encrypt = 1 ; public const int mbedtls _ decrypt = 0 ; static mbed _ tls ( ) { string dll _ path = utils . get _ temp _ path ( dllname ) ; try { file _ manager . uncompress _ file ( dll _ path , resources . libsscrypto _ dll ) ; } catch ( io _ exception )
try { file _ manager . uncompress _ file ( dll _ path , resources . libsscrypto _ dll ) ; } catch ( io _ exception ) { } catch ( system . exception e ) { logging . log _ useful _ exception ( e ) ;
{ logging . log _ useful _ exception ( e ) ; } load _ library ( dll _ path ) ; } public static byte [ ] m ( byte [ ] input ) { byte [ ] output = new byte [ NUM ] ; md ( input , ( uint ) input . length , output ) ; return output ;
dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern int cipher _ auth _ decrypt ( int _ ptr ctx , byte [ ] iv , uint iv _ len , int _ ptr ad , uint ad _ len , byte [ ] input , uint ilen , byte [ ] output , ref uint olen , byte [ ] tag , uint tag _ len ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern int hkdf ( byte [ ] salt , int salt _ len , byte [ ] ikm , int ikm _ len ,
} }
} * once failed , try after NUM min * and ( last write - last read ) < NUM s * and ( now - last read ) < NUM s * and latency < NUM ms , try after NUM s * / public void choose _ new _ server ( ) { server _ status old _ server = current _ server ;

{ current _ server = max ; console . write _ line ( STR , current _ server . server . friendly _ name ( ) ) ; } } } public void update _ latency ( model . server server , time _ span latency ) {
} } } public void update _ latency ( model . server server , time _ span latency ) { logging . debug ( string . format ( STR , server . friendly _ name ( ) , latency ) ) ; server _ status status ; if ( server _ status . try _ get _ value ( server , out status ) ) {
} } public void update _ latency ( model . server server , time _ span latency ) { logging . debug ( string . format ( STR , server . friendly _ name ( ) , latency ) ) ; server _ status status ; if ( server _ status . try _ get _ value ( server , out status ) ) { status . latency = latency ; status . last _ time _ detect _ latency = date _ time . now ;
this . password _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . password _ text _ box . tab _ index = 2 ; this . password _ text _ box . word _ wrap = false ; this . password _ text _ box . use _ system _ password _ char = true ;
} ) ; thread . sleep ( timeout + new random ( ) . next ( ) % timeout ) ; } catch ( exception e ) { logging . error ( $ STR ) ; logging . log _ useful _ exception ( e ) ; } } return ret ;
foreach ( var data _ lists in await task _ ex . when _ all ( servers . select ( icmp _ test ) ) ) { if ( data _ lists = = null ) continue ; foreach ( var data _ list in data _ lists . where ( data _ list = > data _ list ! = null ) ) { append ( data _ list , enumerable . empty < data _ unit > ( ) ) ; } } } private static void append ( data _ list data _ list , i _ enumerable < data _ unit > extra )
} } } private static void append ( data _ list data _ list , i _ enumerable < data _ unit > extra ) { var data = data _ list . concat ( extra ) ; var data _ line = string . join ( delimiter , data . select ( kv = > kv . value ) . to _ array ( ) ) ; string [ ] lines ; if ( ! file . exists ( availability _ statistics _ file ) ) {
public const string unknown = STR ; } public class raw _ statistics _ data { public date _ time timestamp ; public string server _ name ; public string icmp _ status ; public int roundtrip _ time ;
} public class statistics _ data { public float package _ loss ; public int average _ response ; public int min _ response ; public int max _ response ; } public void update _ latency ( int latency ) {
array . copy ( iv , encrypt _ iv , iv _ len ) ; } else { decrypt _ iv = new byte [ iv _ len ] ; array . copy ( iv , decrypt _ iv , iv _ len ) ; } } else if ( cipher = = cipher _ bf )
array . copy ( iv , decrypt _ iv , iv _ len ) ; } } else if ( cipher = = cipher _ bf ) { polar _ ssl . blowfish _ init ( ctx ) ; polar _ ssl . blowfish _ setkey ( ctx , realkey , key _ len * NUM ) ; if ( is _ cipher ) { encrypt _ iv = new byte [ iv _ len ] ;
array . copy ( iv , encrypt _ iv , iv _ len ) ; } else { decrypt _ iv = new byte [ iv _ len ] ; array . copy ( iv , decrypt _ iv , iv _ len ) ; } } else if ( cipher = = cipher _ r )
array . copy ( iv , decrypt _ iv , iv _ len ) ; } } else if ( cipher = = cipher _ r ) { polar _ ssl . arc _ init ( ctx ) ; polar _ ssl . arc _ setup ( ctx , realkey , key _ len ) ; } } static byte [ ] tempbuf = new byte [ NUM ] ;
break ; case cipher _ bf : polar _ ssl . blowfish _ crypt _ cfb ( encrypt _ ctx , polar _ ssl . blowfish _ encrypt , length , ref encrypt _ iv _ offset , encrypt _ iv , buf , tempbuf ) ; break ; case cipher _ r : polar _ ssl . arc _ crypt ( encrypt _ ctx , length , buf , tempbuf ) ; break ; } outlength = length + iv _ len ; buffer . block _ copy ( tempbuf , 0 , outbuf , iv _ len , length ) ;
break ; case cipher _ r : polar _ ssl . arc _ crypt ( encrypt _ ctx , length , buf , tempbuf ) ; break ; } outlength = length + iv _ len ; buffer . block _ copy ( tempbuf , 0 , outbuf , iv _ len , length ) ; } } else
break ; case cipher _ bf : polar _ ssl . blowfish _ crypt _ cfb ( encrypt _ ctx , polar _ ssl . blowfish _ encrypt , length , ref encrypt _ iv _ offset , encrypt _ iv , buf , outbuf ) ; break ; case cipher _ r : polar _ ssl . arc _ crypt ( encrypt _ ctx , length , buf , outbuf ) ; break ; } } }
break ; case cipher _ r : polar _ ssl . arc _ crypt ( encrypt _ ctx , length , buf , outbuf ) ; break ; } } } public override void decrypt ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength ) { if ( decrypt _ ctx = = int _ ptr . zero )
break ; case cipher _ bf : polar _ ssl . blowfish _ crypt _ cfb ( decrypt _ ctx , polar _ ssl . blowfish _ decrypt , length - iv _ len , ref decrypt _ iv _ offset , decrypt _ iv , tempbuf , outbuf ) ; break ; case cipher _ r : polar _ ssl . arc _ crypt ( decrypt _ ctx , length - iv _ len , tempbuf , outbuf ) ; break ; } } }
break ; case cipher _ r : polar _ ssl . arc _ crypt ( decrypt _ ctx , length - iv _ len , tempbuf , outbuf ) ; break ; } } } else { outlength = length ;
break ; case cipher _ bf : polar _ ssl . blowfish _ crypt _ cfb ( decrypt _ ctx , polar _ ssl . blowfish _ decrypt , length , ref decrypt _ iv _ offset , decrypt _ iv , buf , outbuf ) ; break ; case cipher _ r : polar _ ssl . arc _ crypt ( decrypt _ ctx , length , buf , outbuf ) ; break ; } } }
break ; case cipher _ r : polar _ ssl . arc _ crypt ( decrypt _ ctx , length , buf , outbuf ) ; break ; } } } private bool disposed ; public override void dispose ( ) {
this . my _ cancel _ button . name = STR ; this . my _ cancel _ button . size = new system . drawing . size ( NUM , NUM ) ; this . my _ cancel _ button . tab _ index = NUM ; this . my _ cancel _ button . text = STR ; this . my _ cancel _ button . use _ visual _ style _ back _ color = true ; this . my _ cancel _ button . click + = new system . event _ handler ( this . cancel _ button _ click ) ; this . apply _ button . enabled = false ; this . apply _ button . dock = system . windows . forms . dock _ style . right ; this . apply _ button . location = new system . drawing . point ( NUM , NUM ) ; this . apply _ button . margin = new system . windows . forms . padding ( NUM , NUM , 0 , 0 ) ;
using system _ drawing ; using system _ windows _ forms ; using shadowsocks _ controller ; using shadowsocks _ model ; using shadowsocks _ properties ; namespace shadowsocks _ view
using system _ windows _ forms ; using shadowsocks _ controller ; using shadowsocks _ model ; using shadowsocks _ properties ; namespace shadowsocks _ view { public partial class config _ form : form
using shadowsocks _ controller ; using shadowsocks _ model ; using shadowsocks _ properties ; namespace shadowsocks _ view { public partial class config _ form : form { private shadowsocks _ controller controller ; private configuration modified _ configuration ;
namespace shadowsocks _ view { public partial class config _ form : form { private shadowsocks _ controller controller ; private configuration modified _ configuration ; private int last _ selected _ index = - 1 ; public config _ form ( shadowsocks _ controller controller ) { this . font = system _ fonts . message _ box _ font ;
byte [ ] data _ in = new byte [ length - NUM + iv _ encryptor . onetimeauth _ bytes ] ; array . copy ( data , NUM , data _ in , 0 , length - NUM ) ; byte [ ] data _ out = new byte [ length - NUM + NUM + iv _ encryptor . onetimeauth _ bytes ] ; int outlen ; encryptor . encrypt ( data _ in , length - NUM , data _ out , out outlen ) ; remote . send _ to ( data _ out , outlen , socket _ flags . none , remote _ end _ point ) ; } public void receive ( ) { end _ point remote _ end _ point = new ip _ end _ point ( ip _ address . any , 0 ) ;
remote . send _ to ( data _ out , outlen , socket _ flags . none , remote _ end _ point ) ; } public void receive ( ) { end _ point remote _ end _ point = new ip _ end _ point ( ip _ address . any , 0 ) ; remote . begin _ receive _ from ( buffer , 0 , buffer . length , 0 , ref remote _ end _ point , new async _ callback ( recv _ from _ callback ) , null ) ; } public void recv _ from _ callback ( i _ async _ result ar ) { try
{ if ( ! encrypt _ iv _ sent ) { int head _ len = get _ head _ len ( buf , length ) ; int data _ len = length - head _ len ; buf [ 0 ] | = onetimeauth _ flag ; byte [ ] hash = gen _ onetime _ auth _ hash ( buf , head _ len ) ; buffer . block _ copy ( buf , head _ len , buf , head _ len + onetimeauth _ bytes + auth _ bytes , data _ len ) ; buffer . block _ copy ( hash , 0 , buf , head _ len , onetimeauth _ bytes ) ; hash = gen _ hash ( buf , head _ len + onetimeauth _ bytes + auth _ bytes , data _ len ) ;
rand _ bytes ( outbuf , iv _ len ) ; init _ cipher ( outbuf , true ) ; outlength = length + iv _ len ; react _ buffer ( buf , ref length ) ; encrypt _ iv _ sent = true ;
lock ( tempbuf ) { cipher _ update ( true , length , buf , tempbuf ) ; outlength = length + iv _ len ; buffer . block _ copy ( tempbuf , 0 , outbuf , iv _ len , length ) ; } } else { react _ buffer ( buf , ref length ) ;
outlength = length ; cipher _ update ( true , length , buf , outbuf ) ; } } public override void decrypt ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength ) { if ( ! decrypt _ iv _ received ) { decrypt _ iv _ received = true ; init _ cipher ( buf , false ) ;
{ method = method ; password = password ; onetime _ auth = onetimeauth ; is _ udp = isudp ; } protected string method ; protected string password ; protected bool onetime _ auth ; protected bool is _ udp ;
public abstract void decrypt ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength ) ; public abstract void dispose ( ) ; } }
{ if ( string . is _ null _ or _ empty ( method ) ) { method = STR ; } method = method . to _ lower _ invariant ( ) ; type t = registered _ encryptors [ method ] ; constructor _ info c = t . get _ constructor ( constructor _ types ) ; i _ encryptor result = ( i _ encryptor ) c . invoke ( new object [ ] { method , password , onetimeauth , isudp } ) ; return result ;
return result ; } } }
decryptor . decrypt ( cipher , out _ len , plain , out out _ len ) ; assert . are _ equal ( plain . length , out _ len ) ; for ( int j = 0 ; j < plain . length ; j + + ) { assert . are _ equal ( plain [ j ] , plain [ j ] ) ; } encryptor . encrypt ( plain , NUM , cipher , out out _ len ) ; decryptor . decrypt ( cipher , out _ len , plain , out out _ len ) ; assert . are _ equal ( NUM , out _ len ) ; for ( int j = 0 ; j < out _ len ; j + + )
decryptor . decrypt ( cipher , out _ len , plain , out out _ len ) ; assert . are _ equal ( NUM , out _ len ) ; for ( int j = 0 ; j < out _ len ; j + + ) { assert . are _ equal ( plain [ j ] , plain [ j ] ) ; } encryptor . encrypt ( plain , NUM , cipher , out out _ len ) ; decryptor . decrypt ( cipher , out _ len , plain , out out _ len ) ; assert . are _ equal ( NUM , out _ len ) ; for ( int j = 0 ; j < out _ len ; j + + )
decryptor . decrypt ( cipher , out _ len , plain , out out _ len ) ; assert . are _ equal ( NUM , out _ len ) ; for ( int j = 0 ; j < out _ len ; j + + ) { assert . are _ equal ( plain [ j ] , plain [ j ] ) ; } } private static bool encryption _ failed = false ; private static object locker = new object ( ) ; test _ method
this . table _ layout _ panel = new system . windows . forms . table _ layout _ panel ( ) ; this . notify _ icon = new system . windows . forms . notify _ icon ( this . components ) ; this . context _ menu _ strip = new system . windows . forms . context _ menu _ strip ( this . components ) ; this . config = new system . windows . forms . tool _ strip _ menu _ item ( ) ; this . quit = new system . windows . forms . tool _ strip _ menu _ item ( ) ; this . table _ layout _ panel . suspend _ layout ( ) ; this . panel . suspend _ layout ( ) ; this . table _ layout _ panel . suspend _ layout ( ) ; this . context _ menu _ strip . suspend _ layout ( ) ;

private readonly concurrent _ dictionary < string , long > inbound _ counter = new concurrent _ dictionary < string , long > ( ) ; private readonly concurrent _ dictionary < string , long > last _ inbound _ counter = new concurrent _ dictionary < string , long > ( ) ; private readonly concurrent _ dictionary < string , list < int > > inbound _ speed _ records = new concurrent _ dictionary < string , list < int > > ( ) ; private readonly concurrent _ dictionary < string , long > outbound _ counter = new concurrent _ dictionary < string , long > ( ) ; private readonly concurrent _ dictionary < string , long > last _ outbound _ counter = new concurrent _ dictionary < string , long > ( ) ; private readonly concurrent _ dictionary < string , list < int > > outbound _ speed _ records = new concurrent _ dictionary < string , list < int > > ( ) ;
private readonly time _ span delay _ before _ start = time _ span . from _ seconds ( 1 ) ; private readonly time _ span retry _ interval = time _ span . from _ minutes ( 2 ) ; private timer recorder ; private time _ span recording _ interval = > time _ span . from _ minutes ( config . data _ collection _ minutes ) ; private timer speed _ monior ; private readonly time _ span monitor _ interval = time _ span . from _ seconds ( 1 ) ; private shadowsocks _ controller controller ; private statistics _ strategy _ configuration config = > controller . statistics _ configuration ;
private shadowsocks _ controller controller ; private statistics _ strategy _ configuration config = > controller . statistics _ configuration ; public static availability _ statistics instance { get ; } = new availability _ statistics ( ) ; public statistics raw _ statistics { get ; private set ; } public statistics filtered _ statistics { get ; private set ; } private availability _ statistics ( ) { raw _ statistics = new statistics ( ) ; }
public static availability _ statistics instance { get ; } = new availability _ statistics ( ) ; public statistics raw _ statistics { get ; private set ; } public statistics filtered _ statistics { get ; private set ; } private availability _ statistics ( ) { raw _ statistics = new statistics ( ) ; } internal void update _ configuration ( shadowsocks _ controller controller ) { controller = controller ;
} else { recorder ? . dispose ( ) ; speed _ monior ? . dispose ( ) ; } } catch ( exception e ) {
} } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; } } private void start _ timer _ without _ state ( ref timer timer , timer _ callback callback , time _ span interval ) { if ( timer ? . change ( delay _ before _ start , interval ) = = null )
} private void run ( object ) { update _ records ( ) ; save ( ) ; reset ( ) ; filter _ raw _ statistics ( ) ; } private async void update _ records ( ) {
return ; }
try { var content = json _ convert . serialize _ object ( raw _ statistics , formatting . none ) ; file . write _ all _ text ( availability _ statistics _ file , content ) ; } catch ( io _ exception e ) { logging . log _ useful _ exception ( e ) ; }
} catch ( io _ exception e ) { logging . log _ useful _ exception ( e ) ; } } private bool is _ valid _ record ( statistics _ record record ) { if ( config . by _ hour _ of _ day )
} } private bool is _ valid _ record ( statistics _ record record ) { if ( config . by _ hour _ of _ day ) { if ( ! record . timestamp . hour . equals ( date _ time . now . hour ) ) return false ; } return true ; }
speed _ monior . dispose ( ) ; } public void update _ latency ( server server , int latency ) { list < int > records ; latency _ records . try _ get _ value ( server . identifier ( ) , out records ) ; if ( records = = null ) { records = new list < int > ( ) ; }
{ interlocked . add ( ref inbound _ counter , n ) ; if ( config . availability _ statistics ) { new task ( ( ) = > availability _ statistics . update _ inbound _ counter ( server , n ) ) . start ( ) ; } } public void update _ outbound _ counter ( server server , long n ) { interlocked . add ( ref outbound _ counter , n ) ;
{ interlocked . add ( ref outbound _ counter , n ) ; if ( config . availability _ statistics ) { new task ( ( ) = > availability _ statistics . update _ outbound _ counter ( server , n ) ) . start ( ) ; } } protected void reload ( ) { config = configuration . load ( ) ;
public int? average _ latency ; public int? min _ latency ; public int? max _ latency ; private bool empty _ latency _ data = > ( average _ latency = = null ) & & ( min _ latency = = null ) & & ( max _ latency = = null ) ; public int? average _ inbound _ speed ; public int? min _ inbound _ speed ; public int? max _ inbound _ speed ; private bool empty _ inbound _ speed _ data = > ( average _ inbound _ speed = = null ) & & ( min _ inbound _ speed = = null ) & & ( max _ inbound _ speed = = null ) ; public int? average _ outbound _ speed ;
{ server _ identifier = identifier ; if ( inbound _ speed _ records ! = null & & inbound _ speed _ records . any ( ) ) { average _ inbound _ speed = ( int ) inbound _ speed _ records . average ( ) ; min _ inbound _ speed = inbound _ speed _ records . min ( ) ; max _ inbound _ speed = inbound _ speed _ records . max ( ) ; } if ( outbound _ speed _ records ! = null & & outbound _ speed _ records . any ( ) ) {
if ( inbound _ speed _ records ! = null & & inbound _ speed _ records . any ( ) ) { average _ inbound _ speed = ( int ) inbound _ speed _ records . average ( ) ; min _ inbound _ speed = inbound _ speed _ records . min ( ) ; max _ inbound _ speed = inbound _ speed _ records . max ( ) ; } if ( outbound _ speed _ records ! = null & & outbound _ speed _ records . any ( ) ) { average _ outbound _ speed = ( int ) outbound _ speed _ records . average ( ) ; min _ outbound _ speed = outbound _ speed _ records . min ( ) ;
} public void set _ response ( i _ collection < int? > response _ records ) { if ( response _ records = = null ) return ; var records = response _ records . where ( response = > response ! = null ) . select ( response = > response . value ) . to _ list ( ) ; if ( ! records . any ( ) ) return ; average _ response = ( int? ) records . average ( ) ; min _ response = records . min ( ) ; max _ response = records . max ( ) ; package _ loss = response _ records . count ( response = > response ! = null ) / ( float ) response _ records . count ;
{ if ( response _ records = = null ) return ; var records = response _ records . where ( response = > response ! = null ) . select ( response = > response . value ) . to _ list ( ) ; if ( ! records . any ( ) ) return ; average _ response = ( int? ) records . average ( ) ; min _ response = records . min ( ) ; max _ response = records . max ( ) ; package _ loss = response _ records . count ( response = > response ! = null ) / ( float ) response _ records . count ; } }
} } }
{ var config = controller . statistics _ configuration ; float? score = null ; var average _ record = new statistics _ record ( identifier , records . where ( record = > record . max _ inbound _ speed ! = null ) . select ( record = > record . max _ inbound _ speed . value ) . to _ list ( ) , records . where ( record = > record . max _ outbound _ speed ! = null ) . select ( record = > record . max _ outbound _ speed . value ) . to _ list ( ) , records . where ( record = > record . average _ latency ! = null ) . select ( record = > record . average _ latency . value ) . to _ list ( ) ) ; average _ record . set _ response ( records . select ( record = > record . average _ response ) . to _ list ( ) ) ; foreach ( var calculation in config . calculations ) {
return score ; } private void choose _ new _ server ( list < server > servers ) { if ( filtered _ statistics = = null | | servers . count = = 0 ) { return ; } try {
( ( system . component _ model . i _ support _ initialize ) ( this . statistics _ chart ) ) . begin _ init ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . binding _ configuration ) ) . begin _ init ( ) ; this . chart _ mode _ selector . suspend _ layout ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . begin _ init ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . suspend _ layout ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . begin _ init ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . panel . suspend _ layout ( ) ;
this . servers _ list _ box . location = new system . drawing . point ( NUM , NUM ) ; this . servers _ list _ box . name = STR ; this . servers _ list _ box . size = new system . drawing . size ( NUM , NUM ) ; this . servers _ list _ box . tab _ index = NUM ; this . servers _ list _ box . selected _ index _ changed + = new system . event _ handler ( this . servers _ list _ box _ selected _ index _ changed ) ;

{ if ( line [ 0 ] = = '#' ) continue ; var pos = line . index _ of ( '=' ) ; if ( pos < 1 ) continue ; strings [ line . substring ( 0 , pos ) ] = line . substring ( pos + 1 ) ; } } }
continue ; var pos = line . index _ of ( '=' ) ; if ( pos < 1 ) continue ; strings [ line . substring ( 0 , pos ) ] = line . substring ( pos + 1 ) ; } } } } public static string get _ string ( string key )
private encryptor encryptor ; socket listener ; public local ( config config ) { this . config = config ; this . encryptor = new encryptor ( config . password ) ; } public void start ( ) { listener = new socket ( address _ family . inter _ network ,
} public void start ( ) { listener = new socket ( address _ family . inter _ network , socket _ type . stream , protocol _ type . tcp ) ; ip _ end _ point local _ end _ point = new ip _ end _ point ( 0 , config . local _ port ) ; listener . bind ( local _ end _ point ) ; listener . listen ( NUM ) ; console . write _ line ( STR ) ; listener . begin _ accept (
listener . bind ( local _ end _ point ) ; listener . listen ( NUM ) ; console . write _ line ( STR ) ; listener . begin _ accept ( new async _ callback ( accept _ callback ) , listener ) ; } public void stop ( ) { listener . close ( ) ;
ip _ address ip _ address = ip _ host _ info . address _ list [ 0 ] ; ip _ end _ point remote _ ep = new ip _ end _ point ( ip _ address , config . server _ port ) ; remote = new socket ( address _ family . inter _ network , socket _ type . stream , protocol _ type . tcp ) ; remote . begin _ connect ( remote _ ep , new async _ callback ( connect _ callback ) , null ) ; } public void close ( ) { connection . close ( ) ;
remote = new socket ( address _ family . inter _ network , socket _ type . stream , protocol _ type . tcp ) ; remote . begin _ connect ( remote _ ep , new async _ callback ( connect _ callback ) , null ) ; } public void close ( ) { connection . close ( ) ; remote . close ( ) ; }
{ show _ balloon _ tip ( n . get _ string ( STR ) , e . get _ exception ( ) . message , tool _ tip _ icon . error , NUM ) ; logger . log _ useful _ exception ( e . get _ exception ( ) ) ; } void controller _ update _ pac _ from _ geosite _ completed ( object sender , geosite _ result _ event _ args e ) { string result = e . success ? n . get _ string ( STR ) : n . get _ string ( STR ) ; show _ balloon _ tip ( n . get _ string ( STR ) , result , tool _ tip _ icon . info , NUM ) ;
{ string result = e . success ? n . get _ string ( STR ) : n . get _ string ( STR ) ; show _ balloon _ tip ( n . get _ string ( STR ) , result , tool _ tip _ icon . info , NUM ) ; } void update _ checker _ check _ update _ completed ( object sender , event _ args e ) { if ( update _ checker . new _ version _ found ) {
} private void pac _ server _ pac _ update _ error ( object sender , error _ event _ args e ) { update _ pac _ from _ geosite _ error ? . invoke ( this , e ) ; } private static readonly i _ enumerable < char > ignored _ line _ begins = new [ ] { '!' , '[' } ; private void pac _ daemon _ user _ rule _ file _ changed ( object sender , event _ args e ) { geosite _ updater . merge _ and _ write _ pac _ file ( ) ; update _ system _ proxy ( ) ;
} private static readonly i _ enumerable < char > ignored _ line _ begins = new [ ] { '!' , '[' } ; private void pac _ daemon _ user _ rule _ file _ changed ( object sender , event _ args e ) { geosite _ updater . merge _ and _ write _ pac _ file ( ) ; update _ system _ proxy ( ) ; } public void copy _ pac _ url ( ) { clipboard . set _ data _ object ( pac _ server . pac _ url ) ;
} public static void disable ( ) { try { registry _ key registry = registry . current _ user . open _ sub _ key ( STR , true ) ; registry . set _ value ( STR , 0 ) ; registry . set _ value ( STR , STR ) ;
} private static string get _ timestamp ( date _ time value ) { return value . to _ string ( STR ) ; } } }
{ string original = file _ manager . non _ exclusive _ read _ all _ text ( pac _ daemon . pac _ file , encoding . ut ) ; if ( original = = abp _ content ) { return false ; } } file . write _ all _ text ( pac _ daemon . pac _ file , abp _ content , encoding . ut ) ; return true ; }
if ( original = = abp _ content ) { return false ; } } file . write _ all _ text ( pac _ daemon . pac _ file , abp _ content , encoding . ut ) ; return true ; } private static string merge _ pac _ file ( string gfw _ list _ result ) {
return true ; } private static string merge _ pac _ file ( string gfw _ list _ result ) { string abp _ content ; if ( file . exists ( pac _ daemon . user _ abp _ file ) ) { abp _ content = file _ manager . non _ exclusive _ read _ all _ text ( pac _ daemon . user _ abp _ file , encoding . ut ) ; } else
pac _ file _ ready _ to _ open ? . invoke ( this , new path _ event _ args ( ) { path = pac _ filename } ) ; } public void touch _ user _ rule _ file ( ) { string user _ rule _ filename = pac _ daemon . touch _ user _ rule _ file ( ) ; user _ rule _ file _ ready _ to _ open ? . invoke ( this , new path _ event _ args ( ) { path = user _ rule _ filename } ) ; } public string get _ server _ url _ for _ current _ server ( ) { server server = get _ current _ server ( ) ;
user _ rule _ file _ ready _ to _ open ? . invoke ( this , new path _ event _ args ( ) { path = user _ rule _ filename } ) ; } public string get _ server _ url _ for _ current _ server ( ) { server server = get _ current _ server ( ) ; return get _ server _ url ( server ) ; } public static string get _ server _ url ( server server ) { string tag = string . empty ;
if ( gfw _ list _ updater = = null ) { gfw _ list _ updater = new gfw _ list _ updater ( ) ; gfw _ list _ updater . update _ completed + = pac _ server _ pac _ update _ completed ; gfw _ list _ updater . error + = pac _ server _ pac _ update _ error ; } availability _ statistics . update _ configuration ( this ) ; if ( listener ! = null ) { listener . stop ( ) ;
private string pac _ secret { get ; set ; } = STR ; public string pac _ url { get ; private set ; } = STR ; private configuration config ; private pac _ daemon pac _ daemon ; public pac _ server ( pac _ daemon pac _ daemon )
private configuration config ; private pac _ daemon pac _ daemon ; public pac _ server ( pac _ daemon pac _ daemon ) { pac _ daemon = pac _ daemon ;
{ pac _ daemon = pac _ daemon ; } public void update _ pacurl ( configuration config ) { this . config = config ; if ( config . secure _ local _ pac ) {
} public void update _ pacurl ( configuration config ) { this . config = config ; if ( config . secure _ local _ pac ) { var rd = new byte [ NUM ] ; rng . get _ bytes ( rd ) ; pac _ secret = $ STR ; }
{ this . config = config ; if ( config . secure _ local _ pac ) { var rd = new byte [ NUM ] ; rng . get _ bytes ( rd ) ; pac _ secret = $ STR ; } else {
{ return false ; } string request _ line = lines [ 0 ] ; string [ ] request _ items = request _ line . split ( ' ' ) ; if ( request _ items . length = = NUM & & request _ items [ 0 ] = = STR ) { int index = request _ items [ 1 ] . index _ of ( '?' ) ; if ( index < 0 ) {
if ( kv . length = = 2 ) { if ( kv [ 0 ] = = STR ) { if ( kv [ 1 ] . trim ( ) = = ( ( ip _ end _ point ) socket . local _ end _ point ) . to _ string ( ) ) { host _ match = true ; } }
} } if ( host _ match & & path _ match ) { if ( ! secret _ match ) { socket . close ( ) ; } else {
public void send _ response ( socket socket , bool use _ socks ) { try { ip _ end _ point local _ end _ point = ( ip _ end _ point ) socket . local _ end _ point ; string proxy = get _ pac _ address ( local _ end _ point , use _ socks ) ; string pac _ content = pac _ daemon . get _ pac _ content ( ) . replace ( STR , proxy ) ; string response _ head = string . format ( @ STR server : shadowsocks content - type : application / x - ns - proxy - autoconfig
string response _ head = string . format ( @ STR server : shadowsocks content - type : application / x - ns - proxy - autoconfig content - length : { 0 } connection : close STR byte [ ] response = encoding . ut . get _ bytes ( response _ head + pac _ content ) ; socket . begin _ send ( response , 0 , response . length , 0 , new async _ callback ( send _ callback ) , socket ) ; utils . release _ memory ( true ) ; }
private time _ span recording _ interval = > time _ span . from _ minutes ( config . data _ collection _ minutes ) ; private timer per _ second _ timer ; private readonly time _ span monitor _ interval = time _ span . from _ seconds ( 1 ) ; private shadowsocks _ controller controller ; private statistics _ strategy _ configuration config = > controller . statistics _ configuration ; public static availability _ statistics instance { get ; } = new availability _ statistics ( ) ; public statistics raw _ statistics { get ; private set ; } public statistics filtered _ statistics { get ; private set ; } private availability _ statistics ( ) {
private readonly time _ span monitor _ interval = time _ span . from _ seconds ( 1 ) ; private shadowsocks _ controller controller ; private statistics _ strategy _ configuration config = > controller . statistics _ configuration ; public static availability _ statistics instance { get ; } = new availability _ statistics ( ) ; public statistics raw _ statistics { get ; private set ; } public statistics filtered _ statistics { get ; private set ; } private availability _ statistics ( ) { raw _ statistics = new statistics ( ) ; }
load _ raw _ statistics ( ) ; if ( per _ second _ timer = = null ) { per _ second _ timer = new timer ( operations _ per _ second , new counter ( ) , delay _ before _ start , time _ span . from _ seconds ( 1 ) ) ; } } else { per _ second _ timer ? . dispose ( ) ;
} else { per _ second _ timer ? . dispose ( ) ; } } catch ( exception e ) {
} } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; } } private void operations _ per _ second ( object state ) { lock ( state )
{ foreach ( var kv in in _ out _ bound _ records ) { var id = kv . key ; var record = kv . value ; long inbound _ delta , outbound _ delta ; record . get _ delta ( out inbound _ delta , out outbound _ delta ) ; var inbound _ speed = get _ speed _ in _ ki _ b _ per _ second ( inbound _ delta , monitor _ interval . total _ seconds ) ; var outbound _ speed = get _ speed _ in _ ki _ b _ per _ second ( outbound _ delta , monitor _ interval . total _ seconds ) ; var in _ r = inbound _ speed _ records . get _ or _ add ( id , ( k ) = > new list < int > ( ) ) ;
{ update _ records ( ) ; reset ( ) ; } private void update _ records ( ) { var records = new dictionary < string , statistics _ record > ( ) ; update _ records _ state state = new update _ records _ state ( ) ; int server _ count = controller . get _ current _ configuration ( ) . configs . count ; state . counter = server _ count ;
{ save ( ) ; filter _ raw _ statistics ( ) ; } } private void ping _ completed ( object sender , my _ ping . completed _ event _ args e ) { ping _ state ping _ state = ( ping _ state ) e . user _ state ; update _ records _ state state = ping _ state . state ; server server = e . server ;
foreach ( var server _ and _ records in raw _ statistics ) { var server = server _ and _ records . key ; var filtered _ records = server _ and _ records . value . find _ all ( is _ valid _ record ) ; filtered _ statistics [ server ] = filtered _ records ; } filtered _ statistics = filtered _ statistics ; } catch ( exception e ) {
} catch ( exception e ) { logging . log _ useful _ exception ( e ) ; } } private void load _ raw _ statistics ( ) { try {
} } private static int get _ speed _ in _ ki _ b _ per _ second ( long bytes , double seconds ) { var result = ( int ) ( bytes / seconds ) / NUM ; return result ; } public void dispose ( ) { per _ second _ timer . dispose ( ) ;
} public void update _ latency ( server server , int latency ) { latency _ records . get _ or _ add ( server . identifier ( ) , ( k ) = > { list < int > records = new list < int > ( ) ; records . add ( latency ) ; return records ; } ) ; }
public string pac _ url { get ; private set ; } = STR ; private configuration config ; private pac _ daemon pac _ daemon ; public pac _ server ( pac _ daemon pac _ daemon ) { pac _ daemon = pac _ daemon ; } public void update _ pacurl ( configuration config ) { config = config ;
} private static string get _ hash ( string content ) { var content _ bytes = encoding . ascii . get _ bytes ( content ) ; using ( var md = system . security . cryptography . m . create ( ) ) { var md _ bytes = md . compute _ hash ( content _ bytes ) ; return http _ server _ utility . url _ token _ encode ( md _ bytes ) ;

{ private static dictionary < string , string > strings = new dictionary < string , string > ( ) ; private static void init ( string res ) { using ( var sr = new string _ reader ( res ) ) { foreach ( var line in sr . non _ white _ space _ lines ( ) ) { if ( line [ 0 ] = = '#' ) continue ;
{ using ( var sr = new string _ reader ( res ) ) { foreach ( var line in sr . non _ white _ space _ lines ( ) ) { if ( line [ 0 ] = = '#' ) continue ; var pos = line . index _ of ( '=' ) ; if ( pos < 1 ) continue ;
{ init ( name . contains ( STR ) ? resources . zh _ tw : resources . cn ) ;
} } public static string get _ string ( string key ) { return strings . contains _ key ( key ) ? strings [ key ] : key ;
} } }
} else { logging . info ( STR ) ; n = file . read _ all _ text ( n _ file , encoding . ut ) ; } logging . info ( STR + locale ) ; init ( n , locale ) ; } public static string get _ string ( string key , params object [ ] args )
using system _ diagnostics ; using system _ drawing ; using system _ io ; using system _ linq ; using system _ text ; using system _ windows _ forms ; using z _ xing ; using z _ xing _ common ; using z _ xing _ qr _ code ;
using system _ windows _ forms ; using z _ xing ; using z _ xing _ common ; using z _ xing _ qr _ code ;
namespace shadowsocks _ view { public class menu _ view _ controller { private shadowsocks _ controller controller ; private update _ checker update _ checker ; private notify _ icon notify _ icon ; private icon icon , icon _ in , icon _ out , icon _ both , previous _ icon ; private bool is _ first _ run ; private bool is _ startup _ checking ;
list < listener . service > services = new list < listener . service > ( ) ; services . add ( tcp _ relay ) ; services . add ( udp _ relay ) ; services . add ( pac _ server ) ; services . add ( new port _ forwarder ( polipo _ runner . running _ port ) ) ; listener = new listener ( services ) ; listener . start ( config ) ; } catch ( exception e )
services . add ( pac _ server ) ; services . add ( new port _ forwarder ( polipo _ runner . running _ port ) ) ; listener = new listener ( services ) ; listener . start ( config ) ; } catch ( exception e ) { if ( e is socket _ exception ) { socket _ exception se = ( socket _ exception ) e ;
} configuration config ; bool share _ over _ lan ; socket tcp _ socket ; socket udp _ socket ; i _ list < service > services ; public listener ( i _ list < service > services ) { this . services = services ;
i _ list < service > services ; public listener ( i _ list < service > services ) { this . services = services ; } private bool check _ if _ port _ in _ use ( int port ) { ip _ global _ properties ip _ properties = ip _ global _ properties . get _ ip _ global _ properties ( ) ; ip _ end _ point [ ] ip _ end _ points = ip _ properties . get _ active _ tcp _ listeners ( ) ; foreach ( ip _ end _ point end _ point in ip _ end _ points )
ip _ end _ point local _ end _ point = null ; if ( share _ over _ lan ) { local _ end _ point = new ip _ end _ point ( ip _ address . any , config . local _ port ) ; } else { local _ end _ point = new ip _ end _ point ( ip _ address . loopback , config . local _ port ) ; } tcp _ socket . bind ( local _ end _ point ) ;
console . write _ line ( STR ) ; tcp _ socket . begin _ accept ( new async _ callback ( accept _ callback ) , tcp _ socket ) ; udp _ state udp _ state = new udp _ state ( ) ; udp _ socket . begin _ receive _ from ( udp _ state . buffer , 0 , udp _ state . buffer . length , 0 , ref udp _ state . remote _ end _ point , new async _ callback ( recv _ from _ callback ) , udp _ state ) ; } catch ( socket _ exception ) {
new async _ callback ( accept _ callback ) , tcp _ socket ) ; udp _ state udp _ state = new udp _ state ( ) ; udp _ socket . begin _ receive _ from ( udp _ state . buffer , 0 , udp _ state . buffer . length , 0 , ref udp _ state . remote _ end _ point , new async _ callback ( recv _ from _ callback ) , udp _ state ) ; } catch ( socket _ exception ) { tcp _ socket . close ( ) ; throw ;
} catch ( socket _ exception ) { tcp _ socket . close ( ) ; throw ; } } public void stop ( ) { if ( tcp _ socket ! = null )
throw ; } } public void stop ( ) { if ( tcp _ socket ! = null ) { tcp _ socket . close ( ) ; tcp _ socket = null ; }
{ tcp _ socket . close ( ) ; tcp _ socket = null ; } if ( udp _ socket ! = null ) { udp _ socket . close ( ) ; udp _ socket = null ; } }
} } public void accept _ callback ( i _ async _ result ar ) { socket listener = ( socket ) ar . async _ state ; try { socket conn = listener . end _ accept ( ar ) ; byte [ ] buf = new byte [ NUM ] ; object [ ] state = new object [ ] {
{ return ; } } if ( conn . protocol _ type = = protocol _ type . tcp ) { conn . close ( ) ; } } catch ( exception e )
} catch ( exception e ) { console . write _ line ( e ) ; conn . close ( ) ; } } } }
{ private configuration config ; public tcp _ relay ( configuration config ) { this . config = config ; } public bool handle ( byte [ ] first _ packet , int length , socket socket , object state ) { if ( socket . protocol _ type ! = protocol _ type . tcp ) {
{ this . config = config ; } public bool handle ( byte [ ] first _ packet , int length , socket socket , object state ) { if ( socket . protocol _ type ! = protocol _ type . tcp ) { return false ; } if ( length < 2 | | first _ packet [ 0 ] ! = NUM )
if ( length < 2 | | first _ packet [ 0 ] ! = NUM ) { return false ; } socket . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; handler handler = new handler ( ) ; handler . connection = socket ; server server = config . get _ current _ server ( ) ; handler . encryptor = encryptor _ factory . get _ encryptor ( server . method , server . password ) ; handler . server = server ;
{ if ( socket . protocol _ type ! = protocol _ type . tcp ) { return false ; } try { string request = encoding . ut . get _ string ( first _ packet , 0 , length ) ; string [ ] lines = request . split ( '\r' , '\n' ) ; bool host _ match = false , path _ match = false , use _ socks = false ;
{ if ( socket . protocol _ type ! = protocol _ type . tcp ) { return false ; } new handler ( ) . start ( first _ packet , length , socket , this . target _ port ) ; return true ; } class handler {
void end _ connect _ proxy ( i _ async _ result async _ result ) ; void begin _ connect _ dest ( end _ point remote _ ep , async _ callback callback , object state ) ; void end _ connect _ dest ( i _ async _ result async _ result ) ; void begin _ send ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) ; int end _ send ( i _ async _ result async _ result ) ; void begin _ receive ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) ; int end _ receive ( i _ async _ result async _ result ) ; void shutdown ( socket _ shutdown how ) ;
void end _ connect _ dest ( i _ async _ result async _ result ) ; void begin _ send ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) ; int end _ send ( i _ async _ result async _ result ) ; void begin _ receive ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) ; int end _ receive ( i _ async _ result async _ result ) ; void shutdown ( socket _ shutdown how ) ; void close ( ) ; }
object state ) ; int end _ send ( i _ async _ result async _ result ) ; void begin _ receive ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) ; int end _ receive ( i _ async _ result async _ result ) ; void shutdown ( socket _ shutdown how ) ; void close ( ) ; } }
object state ) ; int end _ receive ( i _ async _ result async _ result ) ; void shutdown ( socket _ shutdown how ) ; void close ( ) ; } }
{ proxy _ end _ point = remote _ ep ; var r = new fake _ async _ result ( state ) ; callback ? . invoke ( r ) ; } public void end _ connect _ proxy ( i _ async _ result async _ result ) { } public void begin _ connect _ dest ( end _ point remote _ ep , async _ callback callback , object state )
} public void end _ connect _ proxy ( i _ async _ result async _ result ) { } public void begin _ connect _ dest ( end _ point remote _ ep , async _ callback callback , object state ) { if ( remote = = null ) { remote = new socket ( remote _ ep . address _ family , socket _ type . stream , protocol _ type . tcp ) ; remote . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ;
{ if ( remote = = null ) { remote = new socket ( remote _ ep . address _ family , socket _ type . stream , protocol _ type . tcp ) ; remote . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; } dest _ end _ point = remote _ ep ; remote . begin _ connect ( remote _ ep , callback , state ) ; } public void end _ connect _ dest ( i _ async _ result async _ result )
} public void end _ connect _ dest ( i _ async _ result async _ result ) { remote . end _ connect ( async _ result ) ; } public void begin _ send ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) { remote . begin _ send ( buffer , offset , size , socket _ flags , callback , state ) ; }
object state ) { remote . begin _ send ( buffer , offset , size , socket _ flags , callback , state ) ; } public int end _ send ( i _ async _ result async _ result ) { return remote . end _ send ( async _ result ) ; } public void begin _ receive ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state )
} public int end _ send ( i _ async _ result async _ result ) { return remote . end _ send ( async _ result ) ; } public void begin _ receive ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) { remote . begin _ receive ( buffer , offset , size , socket _ flags , callback , state ) ; }
object state ) { remote . begin _ receive ( buffer , offset , size , socket _ flags , callback , state ) ; } public int end _ receive ( i _ async _ result async _ result ) { return remote . end _ receive ( async _ result ) ; } public void shutdown ( socket _ shutdown how ) {
} public int end _ receive ( i _ async _ result async _ result ) { return remote . end _ receive ( async _ result ) ; } public void shutdown ( socket _ shutdown how ) { remote ? . shutdown ( how ) ; } public void close ( )
{ kill _ process ( p ) ; } string polipo _ config = resources . privoxy _ conf ; running _ port = this . get _ free _ port ( ) ; polipo _ config = polipo _ config . replace ( STR , configuration . local _ port . to _ string ( ) ) ; polipo _ config = polipo _ config . replace ( STR , running _ port . to _ string ( ) ) ; polipo _ config = polipo _ config . replace ( STR , configuration . share _ over _ lan ? STR : STR ) ; file _ manager . byte _ array _ to _ file ( utils . get _ temp _ path ( unique _ config _ file ) , encoding . ut . get _ bytes ( polipo _ config ) ) ; process = new process ( ) ;
process = new process ( ) ; process . start _ info . file _ name = STR ; process . start _ info . arguments = unique _ config _ file ; process . start _ info . working _ directory = utils . get _ temp _ path ( ) ; process . start _ info . window _ style = process _ window _ style . hidden ; process . start _ info . use _ shell _ execute = true ; process . start _ info . create _ no _ window = true ; process . start ( ) ; * add this process to job obj associated with this ss process , so that * when ss exit unexpectedly , this process will be forced killed by system .
process . start _ info . working _ directory = utils . get _ temp _ path ( ) ; process . start _ info . window _ style = process _ window _ style . hidden ; process . start _ info . use _ shell _ execute = true ; process . start _ info . create _ no _ window = true ; process . start ( ) ; * add this process to job obj associated with this ss process , so that * when ss exit unexpectedly , this process will be forced killed by system . * / polipo _ job . add _ process ( process . handle ) ; }
try { directory . create _ directory ( path . combine ( application . startup _ path , STR ) ) ; } catch ( exception e ) { temp _ path = path . get _ temp _ path ( ) ; logging . log _ useful _ exception ( e ) ; } finally
log _ message _ text _ box . scroll _ to _ caret ( ) ; last _ offset = reader . base _ stream . position ; } } private void update _ content ( ) { try { using ( stream _ reader reader = new stream _ reader ( new file _ stream ( filename , file _ mode . open , file _ access . read , file _ share . read _ write ) ) )
} if ( changed ) { log _ message _ text _ box . append _ text ( append _ text . to _ string ( ) ) ; log _ message _ text _ box . scroll _ to _ caret ( ) ; } last _ offset = reader . base _ stream . position ; } } catch ( file _ not _ found _ exception )
public static string get _ temp _ path ( ) { if ( temp _ path = = null ) { bool is _ portable _ mode = configuration . load ( ) . portable _ mode ; try { if ( is _ portable _ mode ) { temp _ path = directory . create _ directory ( path . combine ( application . startup _ path , STR ) ) . full _ name ;
} else { temp _ path = directory . create _ directory ( path . combine ( path . get _ temp _ path ( ) , STR + application . executable _ path . get _ hash _ code ( ) ) ) . full _ name ; }

configuration . check _ server ( server ) ; configuration . check _ local _ port ( local _ port ) ; modified _ configuration . configs [ last _ selected _ index ] = server ; modified _ configuration . local _ port = local _ port ; modified _ configuration . portable _ mode = portable _ mode _ check _ box . checked ; return true ; } catch ( exception ex ) { message _ box . show ( ex . message ) ;
{ config . configs = servers ; config . local _ port = local _ port ; config . portable _ mode = portable _ mode ; configuration . save ( config ) ;
configuration . save ( config ) ; } public void save _ strategy _ configurations ( statistics _ strategy _ configuration configuration ) { statistics _ configuration = configuration ; statistics _ strategy _ configuration . save ( configuration ) ; } public bool add _ server _ by _ ssurl ( string ss _ url ) { try
private system . windows . forms . text _ box plugin _ arguments _ text _ box ; private system . windows . forms . label plugin _ arguments _ label ; private system . windows . forms . tool _ tip tool _ tip ; private system . windows . forms . check _ box portable _ mode _ check _ box ; } }
} }
} catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; } } private void pipe _ connection _ send _ callback ( i _ async _ result ar ) {
try { var session = ( async _ session ) ar . async _ state ; connection . end _ send ( ar ) ; session . remote . begin _ receive ( remote _ recv _ buffer , 0 , recv _ size , socket _ flags . none , new async _ callback ( pipe _ remote _ receive _ callback ) , session ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ;
session . remote . begin _ receive ( remote _ recv _ buffer , 0 , recv _ size , socket _ flags . none , new async _ callback ( pipe _ remote _ receive _ callback ) , session ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; } } } }
this . client _ size = new system . drawing . size ( NUM , NUM ) ; this . control _ box = false ; this . controls . add ( this . panel ) ;
screen . primary _ screen . bounds . height ) ) { using ( graphics g = graphics . from _ image ( full _ image ) ) { g . copy _ from _ screen ( screen . primary _ screen . bounds . x , screen . primary _ screen . bounds . y , 0 , 0 , full _ image . size , copy _ pixel _ operation . source _ copy ) ; }
{ g . copy _ from _ screen ( screen . primary _ screen . bounds . x , screen . primary _ screen . bounds . y , 0 , 0 , full _ image . size , copy _ pixel _ operation . source _ copy ) ; } for ( int i = 0 ; i < NUM ; i + + ) { int margin _ left = full _ image . width * i / NUM / NUM ;
copy _ pixel _ operation . source _ copy ) ; } for ( int i = 0 ; i < NUM ; i + + ) { int margin _ left = full _ image . width * i / NUM / NUM ; int margin _ top = full _ image . height * i / NUM / NUM ; rectangle crop _ rect = new rectangle ( margin _ left , margin _ top , full _ image . width - margin _ left * 2 , full _ image . height - margin _ top * 2 ) ; bitmap target = new bitmap ( crop _ rect . width , crop _ rect . height ) ; using ( graphics g = graphics . from _ image ( target ) )
{ int margin _ left = full _ image . width * i / NUM / NUM ; int margin _ top = full _ image . height * i / NUM / NUM ; rectangle crop _ rect = new rectangle ( margin _ left , margin _ top , full _ image . width - margin _ left * 2 , full _ image . height - margin _ top * 2 ) ; bitmap target = new bitmap ( crop _ rect . width , crop _ rect . height ) ; using ( graphics g = graphics . from _ image ( target ) ) { g . draw _ image ( full _ image , new rectangle ( 0 , 0 , target . width , target . height ) ,
{ g . draw _ image ( full _ image , new rectangle ( 0 , 0 , target . width , target . height ) , crop _ rect , graphics _ unit . pixel ) ; } var reader = new barcode _ reader
} var reader = new barcode _ reader { try _ harder = true ,
{ try _ harder = true , possible _ formats = new list < barcode _ format > { barcode _ format . qr _ code } } ; var result = reader . decode ( target ) ; if ( result ! = null ) {
splash . location = new point ( ( int ) min _ x , ( int ) min _ y ) ; splash . panel . size = new size ( ( int ) max _ x - ( int ) min _ x , ( int ) max _ y - ( int ) min _ y ) ; splash . size = splash . panel . size ; splash . show ( ) ; return ; } } } message _ box . show ( n . get _ string ( STR ) ) ;
splash . show ( ) ; return ; } } } message _ box . show ( n . get _ string ( STR ) ) ; } void splash _ form _ closed ( object sender , form _ closed _ event _ args e ) { show _ config _ form ( ) ;
} void splash _ form _ closed ( object sender , form _ closed _ event _ args e ) { show _ config _ form ( ) ; } void open _ url _ from _ qr _ code ( object sender , form _ closed _ event _ args e ) { process . start ( url _ to _ open ) ; } private void auto _ startup _ item _ click ( object sender , event _ args e ) {
private hotkey _ config modified _ config ; private readonly i _ enumerable < text _ box > all _ text _ boxes ; public hotkey _ settings _ form ( shadowsocks _ controller controller ) { initialize _ component ( ) ; update _ texts ( ) ;
public hotkey _ settings _ form ( shadowsocks _ controller controller ) { initialize _ component ( ) ; update _ texts ( ) ; icon = icon . from _ handle ( resources . ssw . get _ hicon ( ) ) ; controller = controller ; controller . config _ changed + = controller _ config _ changed ; load _ current _ configuration ( ) ; all _ text _ boxes = table _ layout _ panel . get _ child _ controls < text _ box > ( ) ; if ( ! all _ text _ boxes . any ( ) ) throw new exception ( STR ) ;
controller = controller ; controller . config _ changed + = controller _ config _ changed ; load _ current _ configuration ( ) ; all _ text _ boxes = table _ layout _ panel . get _ child _ controls < text _ box > ( ) ; if ( ! all _ text _ boxes . any ( ) ) throw new exception ( STR ) ; } private void controller _ config _ changed ( object sender , event _ args e ) { load _ current _ configuration ( ) ; }
if ( ! all _ text _ boxes . any ( ) ) throw new exception ( STR ) ; } private void controller _ config _ changed ( object sender , event _ args e ) { load _ current _ configuration ( ) ; } private void load _ current _ configuration ( ) { modified _ config = controller . get _ configuration _ copy ( ) . hotkey ; load _ configuration ( modified _ config ) ;
} private void hotkey _ down ( object sender , key _ event _ args e ) { string _ builder sb = new string _ builder ( ) ; if ( e . modifiers ! = 0 ) { if ( e . control ) { sb . append ( STR ) ; }
if ( e . modifiers ! = 0 ) { if ( e . control ) { sb . append ( STR ) ; } if ( e . alt ) { sb . append ( STR ) ; }
if ( content . length > = 1 & & content [ content . length - 1 ] = = '+' ) { tb . text = STR ; } } private void text _ box _ text _ changed ( object sender , event _ args e ) { var tb = ( text _ box ) sender ; if ( tb . text = = STR ) {
if ( tb . text = = STR ) { unreg _ hotkey ( tb ) ; } } private void unreg _ hotkey ( text _ box tb ) { hot _ keys . hot _ key _ call _ back _ handler call _ back ; label lb ; prepare _ for _ hotkey ( tb , out call _ back , out lb ) ;
} private void cancel _ button _ click ( object sender , event _ args e ) { close ( ) ; } private void ok _ button _ click ( object sender , event _ args e ) { foreach ( var tb in all _ text _ boxes ) { if ( tb . text . is _ null _ or _ empty ( ) )
} private void ok _ button _ click ( object sender , event _ args e ) { foreach ( var tb in all _ text _ boxes ) { if ( tb . text . is _ null _ or _ empty ( ) ) { continue ; } if ( ! try _ reg _ hotkey ( tb ) )
logging . info ( STR ) ; } logging . info ( STR ) ; break ; } } private static void timer _ elapsed ( object sender , system . timers . elapsed _ event _ args e ) { try {
logging . info ( STR ) ; } } catch ( exception ex ) { logging . log _ useful _ exception ( ex ) ; } finally { try
} } } }
} catch ( io _ exception ) { } catch ( exception e ) { console . write _ line ( e . to _ string ( ) ) ; } load _ library ( dll _ path ) ; }
logging . info ( $ STR ) ; proxy . close ( ) ; retry _ connect ( ) ; } private void proxy _ connect _ callback ( i _ async _ result ar ) { server server = null ; if ( closed ) { return ;
i _ strategy strategy = controller . get _ current _ strategy ( ) ; strategy ? . set _ failure ( server ) ; logging . info ( $ STR ) ; session . remote . close ( ) ; retry _ connect ( ) ; } private void retry _ connect ( ) { if ( retry _ count < max _ retry ) {
{ public bool is _ completed { get ; } = true ; public wait _ handle async _ wait _ handle { get ; } = null ; public object async _ state { get ; set ; } public bool completed _ synchronously { get ; } = true ; public tcp _ user _ token user _ token { get ; set ; } ~ auto _ release _ async _ result ( ) { user _ token . dispose ( ) ; }
public tcp _ user _ token ( async _ callback callback , object state , socket _ async _ event _ args args ) { callback = callback ; async _ state = state ; args = args ; } public void dispose ( ) { args ? . dispose ( ) ; callback = null ;
} private static void on _ tcp _ connect _ completed ( object sender , socket _ async _ event _ args args ) { args . completed - = on _ tcp _ connect _ completed ; tcp _ user _ token token = ( tcp _ user _ token ) args . user _ token ; auto _ release _ async _ result r = new auto _ release _ async _ result { async _ state = token . async _ state , user _ token = token } ;
} public static void begin _ connect _ tcp ( end _ point end _ point , async _ callback callback , object state ) { var arg = new socket _ async _ event _ args ( ) ; arg . remote _ end _ point = end _ point ; arg . completed + = on _ tcp _ connect _ completed ; arg . user _ token = new tcp _ user _ token ( callback , state , arg ) ; socket . connect _ async ( socket _ type . stream , protocol _ type . tcp , arg ) ; } public static socket end _ connect _ tcp ( i _ async _ result async _ result )
{ throw new argument _ exception ( STR , nameof ( async _ result ) ) ; } var tut = r . user _ token ; var arg = tut . args ; if ( arg . socket _ error ! = socket _ error . success ) { if ( arg . connect _ by _ name _ error ! = null ) { throw arg . connect _ by _ name _ error ;
this . panel = new system . windows . forms . panel ( ) ; this . ok _ button = new system . windows . forms . button ( ) ; this . my _ cancel _ button = new system . windows . forms . button ( ) ; this . panel = new system . windows . forms . panel ( ) ;
this . panel = new system . windows . forms . panel ( ) ; this . delete _ button = new system . windows . forms . button ( ) ; this . add _ button = new system . windows . forms . button ( ) ; this . server _ group _ box = new system . windows . forms . group _ box ( ) ; this . servers _ list _ box = new system . windows . forms . list _ box ( ) ; this . table _ layout _ panel . suspend _ layout ( ) ; this . panel . suspend _ layout ( ) ; this . panel . suspend _ layout ( ) ; this . server _ group _ box . suspend _ layout ( ) ;
this . table _ layout _ panel . suspend _ layout ( ) ; this . panel . suspend _ layout ( ) ; this . panel . suspend _ layout ( ) ; this . server _ group _ box . suspend _ layout ( ) ; this . suspend _ layout ( ) ; this . table _ layout _ panel . auto _ size = true ; this . table _ layout _ panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . table _ layout _ panel . column _ count = 2 ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ;
this . table _ layout _ panel . name = STR ; this . table _ layout _ panel . padding = new system . windows . forms . padding ( NUM ) ; this . table _ layout _ panel . row _ count = NUM ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ;
this . table _ layout _ panel . row _ count = NUM ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ; this . table _ layout _ panel . tab _ index = 0 ; this . remarks _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ;
private system . windows . forms . label label ; private system . windows . forms . combo _ box encryption _ select ; private system . windows . forms . panel panel ; private system . windows . forms . button ok _ button ; private system . windows . forms . button my _ cancel _ button ; private system . windows . forms . panel panel ;
private system . windows . forms . panel panel ; private system . windows . forms . button delete _ button ; private system . windows . forms . button add _ button ; private system . windows . forms . group _ box server _ group _ box ; private system . windows . forms . list _ box servers _ list _ box ; private system . windows . forms . text _ box remarks _ text _ box ; private system . windows . forms . label label ;
private system . windows . forms . text _ box remarks _ text _ box ; private system . windows . forms . label label ; } }
} }
this . controller = controller ; controller . config _ changed + = controller _ config _ changed ; load _ current _ configuration ( ) ;
controller . config _ changed + = controller _ config _ changed ; load _ current _ configuration ( ) ;
load _ current _ configuration ( ) ;
} private void controller _ config _ changed ( object sender , event _ args e ) { load _ current _ configuration ( ) ;
} void notify _ icon _ balloon _ tip _ clicked ( object sender , event _ args e ) { process . start ( update _ checker . latest _ version _ url ) ; } private void show _ window ( ) { this . opacity = 1 ; this . show ( ) ; ip _ text _ box . focus ( ) ;
} private void config _ form _ load ( object sender , event _ args e ) {
} private void servers _ list _ box _ selected _ index _ changed ( object sender , event _ args e ) { if ( old _ selected _ index = = servers _ list _ box . selected _ index ) { return ; } if ( ! save _ old _ selected _ server ( ) ) { servers _ list _ box . selected _ index = old _ selected _ index ;
} private void cancel _ button _ click ( object sender , event _ args e ) { this . close ( ) ;
} private void config _ form _ shown ( object sender , event _ args e ) { ip _ text _ box . focus ( ) ; } private void config _ form _ form _ closed ( object sender , form _ closed _ event _ args e ) { controller . config _ changed - = controller _ config _ changed ;
{ controller . config _ changed - = controller _ config _ changed ; }
} } }
} }
socket conn = listener . end _ accept ( ar ) ; conn . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; handler handler = new handler ( ) ; handler . connection = conn ; handler . encryptor = encryptor _ factory . get _ encryptor ( server . method , server . password ) ; handler . config = server ; handler . start ( ) ;
handler handler = new handler ( ) ; handler . connection = conn ; handler . encryptor = encryptor _ factory . get _ encryptor ( server . method , server . password ) ; handler . config = server ; handler . start ( ) ; } catch { } finally
socket conn = listener . end _ accept ( ar ) ; byte [ ] buf = new byte [ NUM ] ; object [ ] state = new object [ ] { conn , buf } ; conn . begin _ receive ( buf , 0 , NUM , 0 ,
byte [ ] buf = new byte [ NUM ] ; object [ ] state = new object [ ] { conn , buf } ; conn . begin _ receive ( buf , 0 , NUM , 0 , new async _ callback ( receive _ callback ) , state ) ; } catch ( object _ disposed _ exception ) {
this . delete _ button = new system . windows . forms . button ( ) ; this . add _ button = new system . windows . forms . button ( ) ; this . server _ group _ box = new system . windows . forms . group _ box ( ) ; this . servers _ list _ box = new system . windows . forms . list _ box ( ) ; this . table _ layout _ panel = new system . windows . forms . table _ layout _ panel ( ) ; this . table _ layout _ panel = new system . windows . forms . table _ layout _ panel ( ) ; this . table _ layout _ panel = new system . windows . forms . table _ layout _ panel ( ) ; this . table _ layout _ panel . suspend _ layout ( ) ;
this . server _ group _ box . suspend _ layout ( ) ; this . table _ layout _ panel . suspend _ layout ( ) ; this . table _ layout _ panel . suspend _ layout ( ) ; this . table _ layout _ panel . suspend _ layout ( ) ; this . suspend _ layout ( ) ; this . table _ layout _ panel . auto _ size = true ; this . table _ layout _ panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . table _ layout _ panel . column _ count = 2 ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ;
this . ok _ button . name = STR ; this . ok _ button . size = new system . drawing . size ( NUM , NUM ) ; this . ok _ button . tab _ index = NUM ; this . ok _ button . text = STR ; this . ok _ button . use _ visual _ style _ back _ color = true ; this . ok _ button . click + = new system . event _ handler ( this . ok _ button _ click ) ; this . my _ cancel _ button . dialog _ result = system . windows . forms . dialog _ result . cancel ; this . my _ cancel _ button . dock = system . windows . forms . dock _ style . right ; this . my _ cancel _ button . location = new system . drawing . point ( NUM , NUM ) ; this . my _ cancel _ button . margin = new system . windows . forms . padding ( NUM , NUM , 0 , 0 ) ;
this . my _ cancel _ button . name = STR ; this . my _ cancel _ button . size = new system . drawing . size ( NUM , NUM ) ; this . my _ cancel _ button . tab _ index = NUM ; this . my _ cancel _ button . text = STR ; this . my _ cancel _ button . use _ visual _ style _ back _ color = true ; this . my _ cancel _ button . click + = new system . event _ handler ( this . cancel _ button _ click ) ;
this . delete _ button . dock = system . windows . forms . dock _ style . right ; this . delete _ button . location = new system . drawing . point ( NUM , NUM ) ; this . delete _ button . margin = new system . windows . forms . padding ( NUM , NUM , 0 , NUM ) ; this . delete _ button . name = STR ; this . delete _ button . size = new system . drawing . size ( NUM , NUM ) ; this . delete _ button . tab _ index = NUM ; this . delete _ button . text = STR ; this . delete _ button . use _ visual _ style _ back _ color = true ; this . delete _ button . click + = new system . event _ handler ( this . delete _ button _ click ) ; this . add _ button . dock = system . windows . forms . dock _ style . left ;
this . delete _ button . name = STR ; this . delete _ button . size = new system . drawing . size ( NUM , NUM ) ; this . delete _ button . tab _ index = NUM ; this . delete _ button . text = STR ; this . delete _ button . use _ visual _ style _ back _ color = true ; this . delete _ button . click + = new system . event _ handler ( this . delete _ button _ click ) ; this . add _ button . dock = system . windows . forms . dock _ style . left ; this . add _ button . location = new system . drawing . point ( 0 , NUM ) ; this . add _ button . margin = new system . windows . forms . padding ( 0 , NUM , NUM , NUM ) ;
this . add _ button . name = STR ; this . add _ button . size = new system . drawing . size ( NUM , NUM ) ; this . add _ button . tab _ index = NUM ; this . add _ button . text = STR ; this . add _ button . use _ visual _ style _ back _ color = true ; this . add _ button . click + = new system . event _ handler ( this . add _ button _ click ) ; this . server _ group _ box . auto _ size = true ; this . server _ group _ box . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . server _ group _ box . controls . add ( this . table _ layout _ panel ) ; this . server _ group _ box . location = new system . drawing . point ( NUM , 0 ) ;
this . server _ group _ box . name = STR ; this . server _ group _ box . size = new system . drawing . size ( NUM , NUM ) ; this . server _ group _ box . tab _ index = NUM ; this . server _ group _ box . tab _ stop = false ; this . server _ group _ box . text = STR ; this . servers _ list _ box . formatting _ enabled = true ; this . servers _ list _ box . integral _ height = false ; this . servers _ list _ box . location = new system . drawing . point ( 0 , 0 ) ; this . servers _ list _ box . margin = new system . windows . forms . padding ( 0 ) ;
this . servers _ list _ box . name = STR ; this . servers _ list _ box . size = new system . drawing . size ( NUM , NUM ) ; this . servers _ list _ box . tab _ index = NUM ; this . servers _ list _ box . selected _ index _ changed + = new system . event _ handler ( this . servers _ list _ box _ selected _ index _ changed ) ; this . table _ layout _ panel . auto _ size = true ; this . table _ layout _ panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . table _ layout _ panel . column _ count = 2 ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . controls . add ( this . table _ layout _ panel , 1 , 2 ) ; this . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . cancel _ button = this . my _ cancel _ button ; this . client _ size = new system . drawing . size ( NUM , NUM ) ; this . controls . add ( this . table _ layout _ panel ) ;
this . controls . add ( this . panel ) ; this . form _ border _ style = system . windows . forms . form _ border _ style . fixed _ single ; this . maximize _ box = false ; this . minimize _ box = false ; this . name = STR ; this . padding = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . start _ position = system . windows . forms . form _ start _ position . center _ screen ; this . text = STR ; this . form _ closed + = new system . windows . forms . form _ closed _ event _ handler ( this . config _ form _ form _ closed ) ; this . load + = new system . event _ handler ( this . config _ form _ load ) ;
this . server _ group _ box . resume _ layout ( false ) ; this . server _ group _ box . perform _ layout ( ) ; this . table _ layout _ panel . resume _ layout ( false ) ; this . table _ layout _ panel . perform _ layout ( ) ; this . table _ layout _ panel . resume _ layout ( false ) ; this . table _ layout _ panel . resume _ layout ( false ) ; this . resume _ layout ( false ) ; this . perform _ layout ( ) ; } private system . windows . forms . table _ layout _ panel table _ layout _ panel ;
private system . windows . forms . button delete _ button ; private system . windows . forms . button add _ button ; private system . windows . forms . group _ box server _ group _ box ; private system . windows . forms . list _ box servers _ list _ box ; private system . windows . forms . text _ box remarks _ text _ box ; private system . windows . forms . label remarks _ label ; private system . windows . forms . table _ layout _ panel table _ layout _ panel ; private system . windows . forms . table _ layout _ panel table _ layout _ panel ; private system . windows . forms . table _ layout _ panel table _ layout _ panel ; }
using system _ net _ sockets ; using system _ text ; using system _ text _ regular _ expressions ; using shadowsocks _ forward _ proxy ; using shadowsocks _ util _ sockets ; namespace shadowsocks _ controller _ service { class http _ socks : listener . service {
using shadowsocks _ util _ sockets ; namespace shadowsocks _ controller _ service { class http _ socks : listener . service { private readonly byte _ search . search _ target connect _ search = new byte _ search . search _ target ( encoding . ut . get _ bytes ( STR ) ) ; private readonly int socks _ port ; public http _ socks ( int socks _ port ) {
registry . set _ value ( STR , pac _ url ) ; } } else { registry . set _ value ( STR , 0 ) ; if ( global ) { registry . set _ value ( STR , STR ) ; }
registry . set _ value ( STR , STR ) ; } ie _ auto _ detect _ proxy ( false ) ; system _ proxy . notify _ ie ( ) ; copy _ proxy _ setting _ from _ lan ( ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; message _ box . show ( n . get _ string ( STR ) ) ;
using system _ collections _ generic ; using system _ text ; namespace shadowsocks _ csharp _ controller { public class shadowsocks _ controller { private local local ; private pac _ server pac _ server ; private config config ; private polipo _ runner polipo _ runner ;
{ public class shadowsocks _ controller { private local local ; private pac _ server pac _ server ; private config config ; private polipo _ runner polipo _ runner ; private bool stopped = false ; public class path _ event _ args : event _ args {
using system ; using system _ collections _ generic ; using system _ diagnostics ; using system _ io ; using system _ i _ compression ; using system _ text ; namespace shadowsocks _ csharp _ controller { class polipo _ runner {
{ class polipo _ runner { private process process ;
public void start ( config config ) { if ( process = = null ) { process [ ] existing _ polipo = process . get _ processes _ by _ name ( STR ) ; foreach ( process p in existing _ polipo ) { p . kill ( ) ; p . wait _ for _ exit ( ) ; }
{ public class system _ proxy { dll _ import _ wininet _ dll public static extern bool internet _ set _ option ( int _ ptr h _ internet , int dw _ option , int _ ptr lp _ buffer , int dw _ buffer _ length ) ; public const int internet _ option _ settings _ changed = NUM ; public const int internet _ option _ refresh = NUM ; static bool settings _ return , refresh _ return ; public static void notify _ ie ( ) {
{ dll _ import _ wininet _ dll public static extern bool internet _ set _ option ( int _ ptr h _ internet , int dw _ option , int _ ptr lp _ buffer , int dw _ buffer _ length ) ; public const int internet _ option _ settings _ changed = NUM ; public const int internet _ option _ refresh = NUM ; static bool settings _ return , refresh _ return ; public static void notify _ ie ( ) { settings _ return = internet _ set _ option ( int _ ptr . zero , internet _ option _ settings _ changed , int _ ptr . zero , 0 ) ; refresh _ return = internet _ set _ option ( int _ ptr . zero , internet _ option _ refresh , int _ ptr . zero , 0 ) ;
} } else if ( e is object _ disposed _ exception ) { } else { info ( e ) ; } }
} } } public class stream _ writer _ with _ timestamp : stream _ writer { public stream _ writer _ with _ timestamp ( stream stream ) : base ( stream ) { } private string get _ timestamp ( ) {
{ bool handle ( byte [ ] first _ packet , int length , socket socket , object state ) ; void stop ( ) ; } public abstract class service : i _ service { public abstract bool handle ( byte [ ] first _ packet , int length , socket socket , object state ) ; public virtual void stop ( ) { } } public class udp _ state
{ if ( service . handle ( state . buffer , bytes _ read , udp _ socket , state ) ) { break ; } } } catch ( object _ disposed _ exception ) { }
{ register _ application _ restart ( null , ( int ) application _ restart _ flags . restart _ no _ crash | ( int ) application _ restart _ flags . restart _ no _ hang ) ; logging . debug ( STR ) ; } else if ( ! register ) { unregister _ application _ restart ( ) ; logging . debug ( STR ) ; } }
{ web _ client http = new web _ client ( ) ; http . proxy = new web _ proxy ( ip _ address . loopback . to _ string ( ) , config . local _ port ) ; http . download _ string _ completed + = http _ download _ string _ completed ; http . download _ string _ async ( new uri ( update _ url ) ) ; } public static int compare _ version ( string l , string r ) { var ls = l . split ( '.' ) ; var rs = r . split ( '.' ) ;
http . download _ string _ completed + = http _ download _ string _ completed ; http . download _ string _ async ( new uri ( update _ url ) ) ; } public static int compare _ version ( string l , string r ) { var ls = l . split ( '.' ) ; var rs = r . split ( '.' ) ; for ( int i = 0 ; i < math . max ( ls . length , rs . length ) ; i + + ) { int lp = ( i < ls . length ) ? int . parse ( ls [ i ] ) : 0 ;
this . table _ layout _ panel . controls . add ( this . toolbar _ flow _ layout _ panel , 0 , 0 ) ; this . table _ layout _ panel . controls . add ( this . split _ container , 0 , 1 ) ; this . table _ layout _ panel . dock = system . windows . forms . dock _ style . fill ; this . table _ layout _ panel . location = new system . drawing . point ( 0 , 0 ) ; this . table _ layout _ panel . name = STR ; this . table _ layout _ panel . row _ count = 2 ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . tab _ index = 2 ; this . toolbar _ flow _ layout _ panel . auto _ size = true ; this . toolbar _ flow _ layout _ panel . controls . add ( this . clean _ logs _ button ) ;
} dll _ import _ kernel _ dll return _ marshal _ as _ unmanaged _ type _ bool private static extern bool set _ process _ working _ set _ size ( int _ ptr process , u _ int _ ptr minimum _ working _ set _ size , u _ int _ ptr maximum _ working _ set _ size ) ; } }
if ( dpi < NUM ) { icon _ base _ bitmap = resources . ss ; } else if ( dpi < NUM ) { icon _ base _ bitmap = resources . ss ; } else {
} else if ( dpi < NUM ) { icon _ base _ bitmap = resources . ss ; } else { icon _ base _ bitmap = resources . ss ; } configuration config = controller . get _ configuration _ copy ( ) ;
} else { icon _ base _ bitmap = resources . ss ; } configuration config = controller . get _ configuration _ copy ( ) ; bool enabled = config . enabled ; bool global = config . global ; icon _ base _ bitmap = get _ tray _ icon _ by _ state ( icon _ base _ bitmap , enabled , global ) ; icon _ base = icon . from _ handle ( icon _ base _ bitmap . get _ hicon ( ) ) ;
} configuration config = controller . get _ configuration _ copy ( ) ; bool enabled = config . enabled ; bool global = config . global ; icon _ base _ bitmap = get _ tray _ icon _ by _ state ( icon _ base _ bitmap , enabled , global ) ; icon _ base = icon . from _ handle ( icon _ base _ bitmap . get _ hicon ( ) ) ; target _ icon = icon _ base ; icon _ in = icon . from _ handle ( add _ bitmap _ overlay ( icon _ base _ bitmap , resources . ss _ in ) . get _ hicon ( ) ) ; icon _ out = icon . from _ handle ( add _ bitmap _ overlay ( icon _ base _ bitmap , resources . ss _ out ) . get _ hicon ( ) ) ; icon _ both = icon . from _ handle ( add _ bitmap _ overlay ( icon _ base _ bitmap , resources . ss _ in , resources . ss _ out ) . get _ hicon ( ) ) ;

{ using ( graphics g = graphics . from _ image ( full _ image ) )
{ g . copy _ from _ screen ( screen . bounds . x , screen . bounds . y , 0 , 0 , full _ image . size , copy _ pixel _ operation . source _ copy ) ; }
} int max _ try = NUM ; for ( int i = 0 ; i < max _ try ; i + + ) { int margin _ left = full _ image . width * i / NUM / max _ try ;
{ int margin _ left = full _ image . width * i / NUM / max _ try ; int margin _ top = full _ image . height * i / NUM / max _ try ; rectangle crop _ rect = new rectangle ( margin _ left , margin _ top , full _ image . width - margin _ left * 2 , full _ image . height - margin _ top * 2 ) ; bitmap target = new bitmap ( crop _ rect . width , crop _ rect . height ) ; using ( graphics g = graphics . from _ image ( target ) ) {
{ g . draw _ image ( full _ image , new rectangle ( 0 , 0 , target . width , target . height ) , crop _ rect , graphics _ unit . pixel ) ; } var source = new bitmap _ luminance _ source ( target ) ; var bitmap = new binary _ bitmap ( new hybrid _ binarizer ( source ) ) ; qr _ code _ reader reader = new qr _ code _ reader ( ) ; var result = reader . decode ( bitmap ) ;
} var source = new bitmap _ luminance _ source ( target ) ; var bitmap = new binary _ bitmap ( new hybrid _ binarizer ( source ) ) ; qr _ code _ reader reader = new qr _ code _ reader ( ) ; var result = reader . decode ( bitmap ) ; if ( result ! = null ) { var success = controller . add _ server _ by _ ssurl ( result . text ) ; qr _ code _ splash _ form splash = new qr _ code _ splash _ form ( ) ;
{ var success = controller . add _ server _ by _ ssurl ( result . text ) ; qr _ code _ splash _ form splash = new qr _ code _ splash _ form ( ) ; if ( success ) { splash . form _ closed + = splash _ form _ closed ; } else if ( result . text . starts _ with ( STR ) | | result . text . starts _ with ( STR ) ) { url _ to _ open = result . text ;
break ; case STR : rc . encrypt ( encrypt _ table , buf , length ) ; return byte _ array _ with ( buf , length ) ; break ; default : return ssl _ encrypt ( buf , length ) ; } } public byte [ ] decrypt ( byte [ ] buf , int length )
break ; default : return ssl _ encrypt ( buf , length ) ; } } public byte [ ] decrypt ( byte [ ] buf , int length ) { switch ( method ) { case STR :
break ; case STR : rc . decrypt ( decrypt _ table , buf , length ) ; return byte _ array _ with ( buf , length ) ; break ; default : return ssl _ decrypt ( buf , length ) ; } } }
break ; default : return ssl _ decrypt ( buf , length ) ; } } } }
{ initialize _ component ( ) ; notify _ icon . context _ menu = context _ menu ; this . controller = controller ; controller . enable _ status _ changed + = controller _ enable _ status _ changed ; controller . config _ changed + = controller _ config _ changed ; update _ ui ( ) ; } private void controller _ config _ changed ( object sender , event _ args e )
initialize _ component ( ) ; notify _ icon . context _ menu = context _ menu ; this . controller = controller ; controller . enable _ status _ changed + = controller _ enable _ status _ changed ; controller . config _ changed + = controller _ config _ changed ; update _ ui ( ) ; } private void controller _ config _ changed ( object sender , event _ args e ) { update _ ui ( ) ;
} private void show _ window ( ) { this . opacity = 1 ; this . show ( ) ; } private void update _ ui ( ) { config config = controller . get _ config ( ) ; text _ box . text = config . server ;
{ config config = controller . get _ config ( ) ; text _ box . text = config . server ; text _ box . text = config . server _ port . to _ string ( ) ; text _ box . text = config . password ; text _ box . text = config . local _ port . to _ string ( ) ; combo _ box . text = config . method = = null ? STR : config . method ; enable _ item . checked = config . enabled ; } private void form _ load ( object sender , event _ args e )
} private void form _ load ( object sender , event _ args e ) { if ( ! controller . get _ config ( ) . is _ default ) { this . opacity = 0 ; begin _ invoke ( new method _ invoker ( delegate { this . hide ( ) ; } ) ) ;
{ this . opacity = 0 ; begin _ invoke ( new method _ invoker ( delegate { this . hide ( ) ; } ) ) ; }
{ this . hide ( ) ; } ) ) ; }
} private void config _ click ( object sender , event _ args e ) { show _ window ( ) ; } private void quit _ click ( object sender , event _ args e ) { this . close ( ) ; } private void ok _ button _ click ( object sender , event _ args e )
} private void form _ form _ closed ( object sender , form _ closed _ event _ args e ) { controller . stop ( ) ;
} private void about _ tool _ strip _ menu _ item _ click ( object sender , event _ args e ) { process . start ( STR ) ; } private void notify _ icon _ double _ click ( object sender , event _ args e ) { show _ window ( ) ; }
private void enable _ item _ click ( object sender , event _ args e ) { enable _ item . checked = ! enable _ item . checked ; controller . toggle _ enable ( enable _ item . checked ) ; } } }
} } }
{ config . proxy . use _ proxy = true ; config . proxy . proxy _ type = type ; config . proxy . proxy _ server = proxy ; config . proxy . proxy _ port = port ; config . proxy . proxy _ timeout = timeout ; save _ config ( config ) ; } public void toggle _ verbose _ logging ( bool enabled ) {
if ( use _ proxy _ check _ box . checked ) { int port ; int timeout ; if ( ! int . try _ parse ( proxy _ port _ text _ box . text , out port ) )
{ message _ box . show ( n . get _ string ( STR ) ) ; return ; } if ( ! int . try _ parse ( proxy _ timeout _ text _ box . text , out timeout ) )
return ; } if ( ! int . try _ parse ( proxy _ timeout _ text _ box . text , out timeout ) ) { message _ box . show ( n . get _ string ( STR ) ) ;
{ message _ box . show ( n . get _ string ( STR ) ) ; return ; } var type = proxy _ type _ combo _ box . selected _ index ; var proxy = proxy _ server _ text _ box . text ; try { configuration . check _ server ( proxy ) ;
return ; } var type = proxy _ type _ combo _ box . selected _ index ; var proxy = proxy _ server _ text _ box . text ; try { configuration . check _ server ( proxy ) ; configuration . check _ port ( port ) ; configuration . check _ timeout ( timeout , proxy _ config . max _ proxy _ timeout _ sec ) ; }
} else { controller . disable _ proxy ( ) ; }
this . close ( ) ; } private void cancel _ button _ click ( object sender , event _ args e ) { this . close ( ) ; } private void proxy _ form _ form _ closed ( object sender , form _ closed _ event _ args e ) { controller . config _ changed - = controller _ config _ changed ; }
if ( method = = STR ) { is _ connect = true ; if ( ! parse _ host ( m . groups [ 2 ] . value ) ) { throw new exception ( STR + line ) ; } } } }
{ throw new exception ( STR + line ) ; } } } } else {
if ( line . is _ null _ or _ empty ( ) ) { return true ; } if ( ! is _ connect ) { if ( line . starts _ with ( STR ) ) { if ( ! parse _ host ( line . substring ( NUM ) . trim ( ) ) ) {
if ( config . availability _ statistics ) { availability _ statistics . update _ latency ( args . server , ( int ) args . latency . total _ milliseconds ) ; } } public void update _ inbound _ counter ( object sender , ss _ transmit _ event _ args args ) { get _ current _ strategy ( ) ? . update _ last _ read ( args . server ) ; interlocked . add ( ref inbound _ counter , args . length ) ; if ( config . availability _ statistics )
if ( config . availability _ statistics ) { availability _ statistics . update _ inbound _ counter ( args . server , args . length ) ; } } public void update _ outbound _ counter ( object sender , ss _ transmit _ event _ args args ) { get _ current _ strategy ( ) ? . update _ last _ write ( args . server ) ; interlocked . add ( ref outbound _ counter , args . length ) ; if ( config . availability _ statistics )
if ( config . availability _ statistics ) { availability _ statistics . update _ outbound _ counter ( args . server , args . length ) ; } } protected void reload ( ) { encryption . rng . reload ( ) ; config = configuration . load ( ) ; n _ log _ config . load _ configuration ( ) ;
} } protected void reload ( ) { encryption . rng . reload ( ) ; config = configuration . load ( ) ; n _ log _ config . load _ configuration ( ) ; statistics _ configuration = statistics _ strategy _ configuration . load ( ) ; privoxy _ runner = privoxy _ runner ? ? new privoxy _ runner ( ) ; pac _ daemon = pac _ daemon ? ? new pac _ daemon ( ) ;
} public class ss _ relay _ event _ args : event _ args { public readonly server server ; public ss _ relay _ event _ args ( server server ) { this . server = server ; } } public class ss _ transmit _ event _ args : ss _ relay _ event _ args
{ public readonly server server ; public ss _ relay _ event _ args ( server server ) { this . server = server ; } } public class ss _ transmit _ event _ args : ss _ relay _ event _ args { public readonly long length ;
{ public readonly long length ; public ss _ transmit _ event _ args ( server server , long length ) : base ( server ) { this . length = length ; } } public class sstcp _ connected _ event _ args : ss _ relay _ event _ args
{ this . length = length ; } } public class sstcp _ connected _ event _ args : ss _ relay _ event _ args
{ public readonly time _ span latency ; public sstcp _ connected _ event _ args ( server server , time _ span latency ) : base ( server ) { this . latency = latency ;
} } internal class tcp _ handler { public event event _ handler < sstcp _ connected _ event _ args > on _ connected ; public event event _ handler < ss _ transmit _ event _ args > on _ inbound ; public event event _ handler < ss _ transmit _ event _ args > on _ outbound ; public event event _ handler < ss _ relay _ event _ args > on _ closed ; public event event _ handler < ss _ relay _ event _ args > on _ failed ;
class async _ session { public i _ proxy remote { get ; } public async _ session ( i _ proxy remote ) { remote = remote ; } } class async _ session < t > : async _ session {
start _ sending _ time = date _ time . now ; session . remote . begin _ send ( connetion _ send _ buffer , 0 , bytes _ to _ send , socket _ flags . none , pipe _ remote _ send _ callback , new object [ ] { session , bytes _ to _ send } ) ; } private void pipe _ remote _ send _ callback ( i _ async _ result ar ) { if ( closed ) return ; try
} private void pipe _ remote _ send _ callback ( i _ async _ result ar ) { if ( closed ) return ; try { var container = ( object [ ] ) ar . async _ state ; var session = ( async _ session ) container [ 0 ] ; var bytes _ should _ send = ( int ) container [ 1 ] ; int bytes _ sent = session . remote . end _ send ( ar ) ;
{ init _ key ( method , password ) ; if ( onetime _ auth ) { crc _ buf = new byte [ crc _ buf _ len ] ; } } protected abstract dictionary < string , int [ ] > get _ ciphers ( ) ; protected void init _ key ( string method , string password ) {
} dll _ import _ kernel _ dll private static extern int _ ptr load _ library ( string path ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void crypto _ stream _ salsa _ xor _ ic ( byte [ ] c , byte [ ] m , ulong mlen , byte [ ] n , ulong ic , byte [ ] k ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void crypto _ stream _ chacha _ xor _ ic ( byte [ ] c , byte [ ] m , ulong mlen , byte [ ] n , ulong ic , byte [ ] k ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int ss _ gen _ crc ( byte [ ] buf , ref int buf _ offset , ref int data _ len , byte [ ] crc _ buf , ref int crc _ idx , int buf _ size ) ;
{ method = method ; password = password ; onetime _ auth = onetimeauth ; } protected string method ; protected string password ; protected bool onetime _ auth ; protected byte [ ] get _ password _ hash ( ) {
this . table _ layout _ panel . tab _ index = 0 ; this . remarks _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . remarks _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . remarks _ text _ box . max _ length = NUM ; this . remarks _ text _ box . name = STR ; this . remarks _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . remarks _ text _ box . tab _ index = NUM ; this . remarks _ text _ box . word _ wrap = false ; this . remarks _ label . anchor = system . windows . forms . anchor _ styles . right ; this . remarks _ label . auto _ size = true ;
this . server _ group _ box . tab _ stop = false ; this . server _ group _ box . text = STR ; this . servers _ list _ box . formatting _ enabled = true ; this . servers _ list _ box . integral _ height = false ; this . servers _ list _ box . location = new system . drawing . point ( 0 , 0 ) ; this . servers _ list _ box . margin = new system . windows . forms . padding ( 0 ) ; this . servers _ list _ box . name = STR ; this . servers _ list _ box . size = new system . drawing . size ( NUM , NUM ) ; this . servers _ list _ box . tab _ index = NUM ;
this . servers _ list _ box . location = new system . drawing . point ( 0 , 0 ) ; this . servers _ list _ box . margin = new system . windows . forms . padding ( 0 ) ; this . servers _ list _ box . name = STR ; this . servers _ list _ box . size = new system . drawing . size ( NUM , NUM ) ; this . servers _ list _ box . tab _ index = NUM ; this . servers _ list _ box . selected _ index _ changed + = new system . event _ handler ( this . servers _ list _ box _ selected _ index _ changed ) ; this . table _ layout _ panel . auto _ size = true ; this . table _ layout _ panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . table _ layout _ panel . column _ count = 2 ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ;
{ if ( string . is _ null _ or _ empty ( method ) ) { method = STR ; } method = method . to _ lower _ invariant ( ) ; type t = registered _ encryptors [ method ] ; constructor _ info c = t . get _ constructor ( constructor _ types ) ; i _ encryptor result = ( i _ encryptor ) c . invoke ( new object [ ] { method , password , onetimeauth } ) ; return result ;
return result ; } } }
this . plugin _ options _ label . name = STR ; this . plugin _ options _ label . size = new system . drawing . size ( NUM , NUM ) ; this . plugin _ options _ label . tab _ index = NUM ; this . plugin _ options _ label . text = STR ; this . tool _ tip . set _ tool _ tip ( this . plugin _ options _ label , STR ) ; this . plugin _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . plugin _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . plugin _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . plugin _ text _ box . max _ length = NUM ; this . plugin _ text _ box . name = STR ;
this . plugin _ text _ box . max _ length = NUM ; this . plugin _ text _ box . name = STR ; this . plugin _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . plugin _ text _ box . tab _ index = NUM ; this . plugin _ text _ box . word _ wrap = false ; this . remarks _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . remarks _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . remarks _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . remarks _ text _ box . max _ length = NUM ; this . remarks _ text _ box . name = STR ;
this . remarks _ text _ box . max _ length = NUM ; this . remarks _ text _ box . name = STR ; this . remarks _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . remarks _ text _ box . tab _ index = NUM ; this . remarks _ text _ box . word _ wrap = false ; this . ip _ label . anchor = system . windows . forms . anchor _ styles . right ; this . ip _ label . auto _ size = true ; this . ip _ label . location = new system . drawing . point ( NUM , NUM ) ; this . ip _ label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ; this . ip _ label . name = STR ;
this . ip _ label . name = STR ; this . ip _ label . size = new system . drawing . size ( NUM , NUM ) ; this . ip _ label . tab _ index = 0 ; this . ip _ label . text = STR ; this . server _ port _ label . anchor = system . windows . forms . anchor _ styles . right ; this . server _ port _ label . auto _ size = true ; this . server _ port _ label . location = new system . drawing . point ( NUM , NUM ) ; this . server _ port _ label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ; this . server _ port _ label . name = STR ; this . server _ port _ label . size = new system . drawing . size ( NUM , NUM ) ;
this . server _ port _ label . name = STR ; this . server _ port _ label . size = new system . drawing . size ( NUM , NUM ) ; this . server _ port _ label . tab _ index = 1 ; this . server _ port _ label . text = STR ; this . password _ label . anchor = system . windows . forms . anchor _ styles . right ; this . password _ label . auto _ size = true ; this . password _ label . location = new system . drawing . point ( NUM , NUM ) ; this . password _ label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ; this . password _ label . name = STR ; this . password _ label . size = new system . drawing . size ( NUM , NUM ) ;
this . password _ label . name = STR ; this . password _ label . size = new system . drawing . size ( NUM , NUM ) ; this . password _ label . tab _ index = 2 ; this . password _ label . text = STR ; this . password _ label . text _ align = system . drawing . content _ alignment . middle _ center ; this . ip _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . ip _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . ip _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . ip _ text _ box . max _ length = NUM ; this . ip _ text _ box . name = STR ;
this . ip _ text _ box . max _ length = NUM ; this . ip _ text _ box . name = STR ; this . ip _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . ip _ text _ box . tab _ index = 0 ; this . ip _ text _ box . word _ wrap = false ; this . server _ port _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . server _ port _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . server _ port _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . server _ port _ text _ box . max _ length = NUM ; this . server _ port _ text _ box . name = STR ;
this . server _ port _ text _ box . max _ length = NUM ; this . server _ port _ text _ box . name = STR ; this . server _ port _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . server _ port _ text _ box . tab _ index = 1 ; this . server _ port _ text _ box . word _ wrap = false ; this . password _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . password _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . password _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . password _ text _ box . max _ length = NUM ; this . password _ text _ box . name = STR ;
this . password _ text _ box . max _ length = NUM ; this . password _ text _ box . name = STR ; this . password _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . password _ text _ box . tab _ index = 2 ; this . password _ text _ box . use _ system _ password _ char = true ; this . password _ text _ box . word _ wrap = false ; this . encryption _ label . anchor = system . windows . forms . anchor _ styles . right ; this . encryption _ label . auto _ size = true ; this . encryption _ label . location = new system . drawing . point ( NUM , NUM ) ; this . encryption _ label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ;
this . encryption _ label . name = STR ; this . encryption _ label . size = new system . drawing . size ( NUM , NUM ) ; this . encryption _ label . tab _ index = NUM ; this . encryption _ label . text = STR ; this . encryption _ select . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( ( system . windows . forms . anchor _ styles . top | system . windows . forms . anchor _ styles . left ) | system . windows . forms . anchor _ styles . right ) ) ) ; this . encryption _ select . drop _ down _ style = system . windows . forms . combo _ box _ style . drop _ down _ list ; this . encryption _ select . formatting _ enabled = true ; this . encryption _ select . ime _ mode = system . windows . forms . ime _ mode . no _ control ; this . encryption _ select . item _ height = NUM ;
this . encryption _ select . name = STR ; this . encryption _ select . size = new system . drawing . size ( NUM , NUM ) ; this . encryption _ select . tab _ index = NUM ; this . timeout _ label . anchor = system . windows . forms . anchor _ styles . right ; this . timeout _ label . auto _ size = true ; this . timeout _ label . location = new system . drawing . point ( NUM , NUM ) ; this . timeout _ label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ; this . timeout _ label . name = STR ; this . timeout _ label . right _ to _ left = system . windows . forms . right _ to _ left . no ; this . timeout _ label . size = new system . drawing . size ( NUM , NUM ) ;
this . timeout _ label . name = STR ; this . timeout _ label . right _ to _ left = system . windows . forms . right _ to _ left . no ; this . timeout _ label . size = new system . drawing . size ( NUM , NUM ) ; this . timeout _ label . tab _ index = NUM ; this . timeout _ label . text = STR ; this . timeout _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . timeout _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . timeout _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . timeout _ text _ box . max _ length = NUM ; this . timeout _ text _ box . name = STR ;
this . timeout _ text _ box . max _ length = NUM ; this . timeout _ text _ box . name = STR ; this . timeout _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . timeout _ text _ box . tab _ index = NUM ; this . plugin _ label . anchor = system . windows . forms . anchor _ styles . right ; this . plugin _ label . auto _ size = true ; this . plugin _ label . location = new system . drawing . point ( NUM , NUM ) ; this . plugin _ label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ; this . plugin _ label . name = STR ; this . plugin _ label . size = new system . drawing . size ( NUM , NUM ) ;
this . plugin _ label . name = STR ; this . plugin _ label . size = new system . drawing . size ( NUM , NUM ) ; this . plugin _ label . tab _ index = NUM ; this . plugin _ label . text = STR ; this . plugin _ options _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . plugin _ options _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . plugin _ options _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . plugin _ options _ text _ box . max _ length = NUM ; this . plugin _ options _ text _ box . name = STR ; this . plugin _ options _ text _ box . size = new system . drawing . size ( NUM , NUM ) ;
this . plugin _ options _ text _ box . max _ length = NUM ; this . plugin _ options _ text _ box . name = STR ; this . plugin _ options _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . plugin _ options _ text _ box . tab _ index = NUM ; this . plugin _ options _ text _ box . word _ wrap = false ; this . show _ passwd _ check _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( ( system . windows . forms . anchor _ styles . top | system . windows . forms . anchor _ styles . bottom ) | system . windows . forms . anchor _ styles . left ) ) ) ; this . show _ passwd _ check _ box . auto _ size = true ; this . show _ passwd _ check _ box . location = new system . drawing . point ( NUM , NUM ) ; this . show _ passwd _ check _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;
this . show _ passwd _ check _ box . name = STR ; this . show _ passwd _ check _ box . size = new system . drawing . size ( NUM , NUM ) ; this . show _ passwd _ check _ box . tab _ index = NUM ; this . show _ passwd _ check _ box . text = STR ; this . show _ passwd _ check _ box . text _ align = system . drawing . content _ alignment . middle _ center ; this . show _ passwd _ check _ box . use _ visual _ style _ back _ color = true ; this . show _ passwd _ check _ box . checked _ changed + = new system . event _ handler ( this . show _ passwd _ check _ box _ checked _ changed ) ; this . plugin _ arguments _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . plugin _ arguments _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . plugin _ arguments _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;
this . plugin _ arguments _ text _ box . max _ length = NUM ; this . plugin _ arguments _ text _ box . name = STR ; this . plugin _ arguments _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . plugin _ arguments _ text _ box . tab _ index = NUM ; this . plugin _ arguments _ text _ box . word _ wrap = false ; this . plugin _ arguments _ label . anchor = system . windows . forms . anchor _ styles . right ; this . plugin _ arguments _ label . auto _ size = true ; this . plugin _ arguments _ label . location = new system . drawing . point ( NUM , NUM ) ; this . plugin _ arguments _ label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ; this . plugin _ arguments _ label . name = STR ;
this . plugin _ arguments _ label . name = STR ; this . plugin _ arguments _ label . size = new system . drawing . size ( NUM , NUM ) ; this . plugin _ arguments _ label . tab _ index = NUM ; this . plugin _ arguments _ label . text = STR ; this . tool _ tip . set _ tool _ tip ( this . plugin _ arguments _ label , STR + STR ) ; this . remarks _ label . anchor = system . windows . forms . anchor _ styles . right ; this . remarks _ label . auto _ size = true ; this . remarks _ label . location = new system . drawing . point ( NUM , NUM ) ; this . remarks _ label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ;
this . remarks _ label . name = STR ; this . remarks _ label . size = new system . drawing . size ( NUM , NUM ) ; this . remarks _ label . tab _ index = NUM ; this . remarks _ label . text = STR ; this . need _ plugin _ arg _ check _ box . auto _ size = true ; this . need _ plugin _ arg _ check _ box . location = new system . drawing . point ( NUM , NUM ) ; this . need _ plugin _ arg _ check _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . need _ plugin _ arg _ check _ box . name = STR ; this . need _ plugin _ arg _ check _ box . size = new system . drawing . size ( NUM , NUM ) ; this . need _ plugin _ arg _ check _ box . tab _ index = NUM ;
this . need _ plugin _ arg _ check _ box . name = STR ; this . need _ plugin _ arg _ check _ box . size = new system . drawing . size ( NUM , NUM ) ; this . need _ plugin _ arg _ check _ box . tab _ index = NUM ; this . need _ plugin _ arg _ check _ box . text = STR ; this . need _ plugin _ arg _ check _ box . use _ visual _ style _ back _ color = true ; this . need _ plugin _ arg _ check _ box . checked _ changed + = new system . event _ handler ( this . use _ plugin _ arg _ check _ box _ checked _ changed ) ; this . panel . anchor = system . windows . forms . anchor _ styles . top ; this . panel . auto _ size = true ; this . panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . panel . location = new system . drawing . point ( NUM , NUM ) ;
this . panel . name = STR ; this . panel . size = new system . drawing . size ( 0 , 0 ) ; this . panel . tab _ index = 1 ; this . ok _ button . dialog _ result = system . windows . forms . dialog _ result . ok ; this . ok _ button . dock = system . windows . forms . dock _ style . right ; this . ok _ button . location = new system . drawing . point ( NUM , NUM ) ; this . ok _ button . margin = new system . windows . forms . padding ( NUM , NUM , NUM , 0 ) ; this . ok _ button . name = STR ; this . ok _ button . size = new system . drawing . size ( NUM , NUM ) ; this . ok _ button . tab _ index = NUM ;
this . table _ layout _ panel . row _ count = 2 ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ; this . table _ layout _ panel . tab _ index = NUM ; this . proxy _ port _ text _ box . anchor = system . windows . forms . anchor _ styles . left ; this . proxy _ port _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . proxy _ port _ text _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . proxy _ port _ text _ box . max _ length = NUM ; this . proxy _ port _ text _ box . name = STR ;
this . proxy _ port _ text _ box . max _ length = NUM ; this . proxy _ port _ text _ box . name = STR ; this . proxy _ port _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . proxy _ port _ text _ box . tab _ index = NUM ; this . proxy _ port _ text _ box . word _ wrap = false ; this . proxy _ port _ label . anchor = system . windows . forms . anchor _ styles . right ; this . proxy _ port _ label . auto _ size = true ; this . proxy _ port _ label . location = new system . drawing . point ( NUM , NUM ) ; this . proxy _ port _ label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ; this . proxy _ port _ label . name = STR ;
this . proxy _ port _ label . name = STR ; this . proxy _ port _ label . size = new system . drawing . size ( NUM , NUM ) ; this . proxy _ port _ label . tab _ index = NUM ; this . proxy _ port _ label . text = STR ; this . portable _ mode _ check _ box . anchor = system . windows . forms . anchor _ styles . left ; this . portable _ mode _ check _ box . auto _ size = true ; this . table _ layout _ panel . set _ column _ span ( this . portable _ mode _ check _ box , 2 ) ; this . portable _ mode _ check _ box . location = new system . drawing . point ( NUM , NUM ) ; this . portable _ mode _ check _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . portable _ mode _ check _ box . name = STR ;
this . portable _ mode _ check _ box . name = STR ; this . portable _ mode _ check _ box . size = new system . drawing . size ( NUM , NUM ) ; this . portable _ mode _ check _ box . tab _ index = NUM ; this . portable _ mode _ check _ box . text = STR ; this . tool _ tip . set _ tool _ tip ( this . portable _ mode _ check _ box , STR ) ; this . portable _ mode _ check _ box . use _ visual _ style _ back _ color = true ; this . table _ layout _ panel . auto _ size = true ; this . table _ layout _ panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . table _ layout _ panel . column _ count = NUM ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ;
using global _ hot _ key ; using system _ windows _ input ; using system _ threading ; using system _ collections _ generic ; using shadowsocks _ controller _ hotkeys ; using system _ diagnostics ; namespace shadowsocks _ test
using system _ diagnostics ; namespace shadowsocks _ test { test _ class public class unit _ test { test _ method public void test _ compare _ version ( )
{ test _ class public class unit _ test { test _ method public void test _ compare _ version ( ) { assert . is _ true ( update _ checker . asset . compare _ version ( STR , STR ) = = 0 ) ; assert . is _ true ( update _ checker . asset . compare _ version ( STR , STR ) < 0 ) ; assert . is _ true ( update _ checker . asset . compare _ version ( STR , STR ) > 0 ) ;
{ try { ip _ end _ point local _ end _ point = ( ip _ end _ point ) socket . local _ end _ point ; string proxy = get _ pac _ address ( local _ end _ point , use _ socks ) ; string pac _ content = get _ pac _ content ( ) . replace ( STR , proxy ) ; string response _ head = string . format ( @ STR server : shadowsocks content - type : application / x - ns - proxy - autoconfig
ip _ end _ point local _ end _ point = ( ip _ end _ point ) socket . local _ end _ point ; string proxy = get _ pac _ address ( local _ end _ point , use _ socks ) ; string pac _ content = get _ pac _ content ( ) . replace ( STR , proxy ) ; string response _ head = string . format ( @ STR server : shadowsocks content - type : application / x - ns - proxy - autoconfig content - length : { 0 } connection : close STR byte [ ] response = encoding . ut . get _ bytes ( response _ head + pac _ content ) ;
server : shadowsocks content - type : application / x - ns - proxy - autoconfig content - length : { 0 } connection : close STR byte [ ] response = encoding . ut . get _ bytes ( response _ head + pac _ content ) ; socket . begin _ send ( response , 0 , response . length , 0 , new async _ callback ( send _ callback ) , socket ) ; utils . release _ memory ( true ) ; } catch ( exception e )
socket . begin _ send ( response , 0 , response . length , 0 , new async _ callback ( send _ callback ) , socket ) ; utils . release _ memory ( true ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; socket . close ( ) ; } } private void send _ callback ( i _ async _ result ar )
} catch ( io _ exception e ) { console . write _ line ( e . to _ string ( ) ) ; } load _ library ( dll _ path ) ; logging . open _ log _ file ( ) ; application . enable _ visual _ styles ( ) ; application . set _ compatible _ text _ rendering _ default ( false ) ; shadowsocks _ controller controller = new shadowsocks _ controller ( ) ;
{ field _ offset public int dw _ value ; field _ offset public system . int _ ptr psz _ value ; field _ offset public system . runtime . interop _ services . com _ types . filetime ft _ value ; public void dispose ( ) { dispose ( true ) ;
{ public int size ; public system . int _ ptr connection ; public int option _ count ; public int option _ error ; public system . int _ ptr p _ options ; public void dispose ( ) { dispose ( true ) ; gc . suppress _ finalize ( this ) ;
return true ; } catch ( io _ exception e ) { console . write _ line ( e . to _ string ( ) ) ; return false ; } }
private static void write _ to _ log _ file ( object o ) { console . write _ line ( o ) ; } public static void error ( object o ) { write _ to _ log _ file ( STR + o ) ; }
console . write _ line ( o ) ; } public static void error ( object o ) { write _ to _ log _ file ( STR + o ) ; } public static void info ( object o ) { write _ to _ log _ file ( o ) ; }
private configuration modified _ configuration ; private int old _ selected _ index = - 1 ; public config _ form ( shadowsocks _ controller controller ) { initialize _ component ( ) ; this . icon = icon . from _ handle ( resources . ssw . get _ hicon ( ) ) ; this . controller = controller ; controller . config _ changed + = controller _ config _ changed ; load _ current _ configuration ( ) ;
public config _ form ( shadowsocks _ controller controller ) { initialize _ component ( ) ; this . icon = icon . from _ handle ( resources . ssw . get _ hicon ( ) ) ; this . controller = controller ; controller . config _ changed + = controller _ config _ changed ; load _ current _ configuration ( ) ; } private void controller _ config _ changed ( object sender , event _ args e ) {
private static readonly concurrent _ dictionary < string , byte [ ] > cached _ keys = new concurrent _ dictionary < string , byte [ ] > ( ) ; protected byte [ ] encrypt _ iv ; protected byte [ ] decrypt _ iv ; protected bool decrypt _ iv _ received ; protected bool encrypt _ iv _ sent ; protected string method ; protected int cipher ; protected string cipher _ mbed _ name ; protected encryptor _ info cipher _ info ; protected byte [ ] key ;
protected byte [ ] key ; protected int key _ len ; protected int iv _ len ; public iv _ encryptor ( string method , string password , bool onetimeauth , bool isudp ) : base ( method , password , onetimeauth , isudp ) { init _ key ( method , password ) ; } protected abstract dictionary < string , encryptor _ info > get _ ciphers ( ) ; private void init _ key ( string method , string password )
private void init _ key ( string method , string password ) { method = method . to _ lower ( ) ; method = method ; string k = method + STR + password ; ciphers = get _ ciphers ( ) ; cipher _ info = ciphers [ method ] ; cipher _ mbed _ name = cipher _ info . name ; cipher = cipher _ info . type ;
if ( cipher = = 0 ) { throw new exception ( STR ) ; } key _ len = cipher _ info . key _ size ; iv _ len = cipher _ info . iv _ size ; key = cached _ keys . get _ or _ add ( k , ( nk ) = > { byte [ ] passbuf = encoding . ut . get _ bytes ( password ) ; byte [ ] key = new byte [ NUM ] ;
key = cached _ keys . get _ or _ add ( k , ( nk ) = > { byte [ ] passbuf = encoding . ut . get _ bytes ( password ) ; byte [ ] key = new byte [ NUM ] ; bytes _ to _ key ( passbuf , key ) ; return key ; } ) ; } protected void bytes _ to _ key ( byte [ ] password , byte [ ] key ) {
} ; public static list < string > supported _ ciphers ( ) { return new list < string > ( ciphers . keys ) ; } protected override dictionary < string , encryptor _ info > get _ ciphers ( ) { return ciphers ; } protected override void init _ cipher ( byte [ ] iv , bool is _ cipher )
{ return ciphers ; } protected override void init _ cipher ( byte [ ] iv , bool is _ cipher ) { base . init _ cipher ( iv , is _ cipher ) ; int _ ptr ctx = marshal . alloc _ h _ global ( mbed _ tls . cipher _ get _ size _ ex ( ) ) ; if ( is _ cipher ) { encrypt _ ctx = ctx ;
} ; protected override dictionary < string , encryptor _ info > get _ ciphers ( ) { return ciphers ; } public static list < string > supported _ ciphers ( ) { return new list < string > ( ciphers . keys ) ; } protected override void cipher _ update ( bool is _ cipher , int length , byte [ ] buf , byte [ ] outbuf )
{ return ciphers ; } public static list < string > supported _ ciphers ( ) { return new list < string > ( ciphers . keys ) ; } protected override void cipher _ update ( bool is _ cipher , int length , byte [ ] buf , byte [ ] outbuf ) { int bytes _ remaining ;
} private system . windows . forms . table _ layout _ panel table _ layout _ panel ; private system . windows . forms . label label ; private system . windows . forms . label label ; private system . windows . forms . label label ; private system . windows . forms . label label ; private system . windows . forms . text _ box text _ box ; private system . windows . forms . text _ box text _ box ; private system . windows . forms . text _ box text _ box ; private system . windows . forms . text _ box text _ box ;
protected static byte [ ] tempbuf = new byte [ max _ input _ size ] ; protected dictionary < string , int [ ] > ciphers ; private static readonly dictionary < string , byte [ ] > cached _ keys = new dictionary < string , byte [ ] > ( ) ; protected byte [ ] encrypt _ iv ; protected byte [ ] decrypt _ iv ; protected bool decrypt _ iv _ received ; protected bool encrypt _ iv _ sent ; protected int encrypt _ iv _ offset = 0 ; protected int decrypt _ iv _ offset = 0 ; protected string method ;
public iv _ encryptor ( string method , string password , bool onetimeauth ) : base ( method , password , onetimeauth ) { init _ key ( method , password ) ; if ( onetime _ auth ) { hash _ buf = new byte [ hash _ buf _ len ] ; } } protected abstract dictionary < string , int [ ] > get _ ciphers ( ) ;
} } protected abstract dictionary < string , int [ ] > get _ ciphers ( ) ; protected void init _ key ( string method , string password ) { method = method . to _ lower ( ) ; method = method ; string k = method + STR + password ; ciphers = get _ ciphers ( ) ; cipher _ info = ciphers [ method ] ;
{ int head _ len = ss _ headlen ( buf , length ) ; int data _ len = length - head _ len ; buffer . block _ copy ( buf , head _ len , buf , head _ len + onetimeauth _ bytes , data _ len ) ; buf [ 0 ] | = onetimeauth _ flag ; byte [ ] auth = new byte [ onetimeauth _ bytes ] ; ss _ onetimeauth ( auth , buf , head _ len , encrypt _ iv , iv _ len , key , key _ len ) ; buffer . block _ copy ( auth , 0 , buf , head _ len , onetimeauth _ bytes ) ; int buf _ offset = head _ len + onetimeauth _ bytes ; ss _ gen _ hash ( buf , ref buf _ offset , ref data _ len , hash _ buf , ref hash _ idx , buf . length ) ;
int data _ len = length - head _ len ; buffer . block _ copy ( buf , head _ len , buf , head _ len + onetimeauth _ bytes , data _ len ) ; buf [ 0 ] | = onetimeauth _ flag ; byte [ ] auth = new byte [ onetimeauth _ bytes ] ; ss _ onetimeauth ( auth , buf , head _ len , encrypt _ iv , iv _ len , key , key _ len ) ; buffer . block _ copy ( auth , 0 , buf , head _ len , onetimeauth _ bytes ) ; int buf _ offset = head _ len + onetimeauth _ bytes ; ss _ gen _ hash ( buf , ref buf _ offset , ref data _ len , hash _ buf , ref hash _ idx , buf . length ) ;
buffer . block _ copy ( auth , 0 , buf , head _ len , onetimeauth _ bytes ) ; int buf _ offset = head _ len + onetimeauth _ bytes ; ss _ gen _ hash ( buf , ref buf _ offset , ref data _ len , hash _ buf , ref hash _ idx , buf . length ) ; length = head _ len + onetimeauth _ bytes + data _ len ; } } cipher _ update ( true , length , buf , tempbuf ) ;
length = head _ len + onetimeauth _ bytes + data _ len ; } } cipher _ update ( true , length , buf , tempbuf ) ; outlength = length + iv _ len ; buffer . block _ copy ( tempbuf , 0 , outbuf , iv _ len , length ) ; } } else {
{ int buf _ offset = 0 ; ss _ gen _ hash ( buf , ref buf _ offset , ref length , hash _ buf , ref hash _ idx , buf . length ) ; } } outlength = length ; cipher _ update ( true , length , buf , outbuf ) ;
} } outlength = length ; cipher _ update ( true , length , buf , outbuf ) ; } } public override void decrypt ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength ) { if ( ! decrypt _ iv _ received ) {
dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int crypto _ onetimeauth ( byte [ ] outbuf , byte [ ] inbuf , ulong inlen , byte [ ] k ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int crypto _ onetimeauth _ verify ( byte [ ] h , byte [ ] inbuf , ulong inlen , byte [ ] k ) ; } }
} }
private void auto _ startup _ click ( object sender , event _ args e ) { auto _ startup . checked = ! auto _ startup . checked ; if ( ! auto _ startup . set ( auto _ startup . checked ) ) { message _ box . show ( STR ) ; } } private void context _ menu _ popup ( object sender , event _ args e ) { auto _ startup . checked = auto _ startup . check ( ) ; } }
} } private void context _ menu _ popup ( object sender , event _ args e ) { auto _ startup . checked = auto _ startup . check ( ) ; } } }
} } }
using ( graphics g = graphics . from _ image ( draw _ area ) ) { g . clear ( color . white ) ; using ( brush b = new solid _ brush ( color . black ) ) { for ( int row = 0 ; row < m . width ; row + + ) { for ( int col = 0 ; col < m . height ; col + + ) { if ( m [ row , col ] ! = 0 )
string encoding = default _ byte _ mode _ encoding ; const string encoding = STR ; bool generate _ eci = ( hints ! = null & & hints . contains _ key ( encode _ hint _ type . character _ set ) ) ; mode mode = mode . byte ;
const string encoding = STR ; bool generate _ eci = ( hints ! = null & & hints . contains _ key ( encode _ hint _ type . character _ set ) ) ; mode mode = mode . byte ; bit _ array header _ bits = new bit _ array ( ) ; if ( mode = = mode . byte & & generate _ eci ) { character _ set _ eci eci = character _ set _ eci . get _ character _ set _ eci _ by _ name ( encoding ) ; if ( eci ! = null ) { var eci _ is _ explicit _ disabled = ( hints ! = null & & hints . contains _ key ( encode _ hint _ type . disable _ eci ) ? ( bool ) hints [ encode _ hint _ type . disable _ eci ] : false ) ;
bit _ array header _ bits = new bit _ array ( ) ; if ( mode = = mode . byte & & generate _ eci ) { character _ set _ eci eci = character _ set _ eci . get _ character _ set _ eci _ by _ name ( encoding ) ; if ( eci ! = null ) { var eci _ is _ explicit _ disabled = ( hints ! = null & & hints . contains _ key ( encode _ hint _ type . disable _ eci ) ? ( bool ) hints [ encode _ hint _ type . disable _ eci ] : false ) ; if ( ! eci _ is _ explicit _ disabled ) { append _ eci ( eci , header _ bits ) ;
if ( mode . equals ( mode . byte ) ) append _ bit _ bytes ( content , bits , encoding ) ; else throw new exception ( STR + mode ) ;
else throw new exception ( STR + mode ) ;
} internal static void append _ bit _ bytes ( string content , bit _ array bits , string encoding ) { byte [ ] bytes ; try { bytes = encoding . get _ encoding ( encoding ) . get _ bytes ( content ) ; } catch ( platform _ not _ supported _ exception ) {
public static version get _ version _ for _ number ( int version _ number ) { if ( version _ number < 1 | | version _ number > NUM ) { throw new argument _ exception ( ) ; } return versions [ version _ number - 1 ] ;
} public sealed class ec _ blocks { private readonly int ec _ codewords _ per _ block ; private readonly ecb [ ] ec _ blocks ; internal ec _ blocks ( int ec _ codewords _ per _ block , params ecb [ ] ec _ blocks ) { this . ec _ codewords _ per _ block = ec _ codewords _ per _ block ; this . ec _ blocks = ec _ blocks ; }
public int generator _ base { get { return generator _ base ; } } } }
} }
} public bit _ array ( ) { this . size = 0 ; this . bits = new int [ 1 ] ;
} private void ensure _ capacity ( int size ) { if ( size > bits . length < < NUM ) { int [ ] new _ bits = make _ array ( size ) ; system . array . copy ( bits , 0 , new _ bits , 0 , bits . length ) ; bits = new _ bits ; }
private static int [ ] make _ array ( int size ) { return new int [ ( size + NUM ) > > NUM ] ; }
} }
} else { log _ form = new log _ form ( controller , logging . log _ file _ path ) ; log _ form . show ( ) ; log _ form . activate ( ) ; log _ form . form _ closed + = log _ form _ form _ closed ;
} } void log _ form _ form _ closed ( object sender , form _ closed _ event _ args e ) { log _ form = null ; utils . release _ memory ( true ) ; } void config _ form _ form _ closed ( object sender , form _ closed _ event _ args e ) {
} void config _ form _ form _ closed ( object sender , form _ closed _ event _ args e ) { config _ form = null ; utils . release _ memory ( true ) ; if ( is _ first _ run ) { check _ update _ for _ first _ run ( ) ; show _ first _ time _ balloon ( ) ; is _ first _ run = false ;
bytes _ to _ key ( passbuf , key ) ; return key ; } ) ; } protected static void bytes _ to _ key ( byte [ ] password , byte [ ] key ) { byte [ ] result = new byte [ password . length + NUM ] ; int i = 0 ; byte [ ] md _ sum = null ; while ( i < key . length )
{ byte [ ] result = new byte [ password . length + NUM ] ; int i = 0 ; byte [ ] md _ sum = null ; while ( i < key . length ) { if ( i = = 0 ) { md _ sum = mbed _ tls . m ( password ) ; }
{ if ( file . exists ( nlog _ config _ file _ name ) ) return ; file . write _ all _ text ( nlog _ config _ file _ name , properties . resources . n _ log _ config ) ; } catch ( exception ex ) { n _ log . common . internal _ logger . error ( ex , STR , nlog _ config _ file _ name ) ; return ;
} catch ( exception ex ) { n _ log . common . internal _ logger . error ( ex , STR , nlog _ config _ file _ name ) ; return ; } load _ configuration ( ) ; } public static void load _ configuration ( ) {
} private sip _ plugin ( string plugin , string plugin _ opts , string plugin _ args , string server _ address , int server _ port ) { if ( plugin = = null ) throw new argument _ null _ exception ( nameof ( plugin ) ) ; if ( string . is _ null _ or _ white _ space ( server _ address ) ) { throw new argument _ exception ( STR , nameof ( server _ address ) ) ; } if ( server _ port < = 0 | | server _ port > NUM ) {
{ if ( plugin = = null ) throw new argument _ null _ exception ( nameof ( plugin ) ) ; if ( string . is _ null _ or _ white _ space ( server _ address ) ) { throw new argument _ exception ( STR , nameof ( server _ address ) ) ; } if ( server _ port < = 0 | | server _ port > NUM ) { throw new argument _ out _ of _ range _ exception ( STR ) ; }
this . table _ layout _ panel . tab _ index = 0 ; this . plugin _ options _ label . anchor = system . windows . forms . anchor _ styles . right ; this . plugin _ options _ label . auto _ size = true ; this . plugin _ options _ label . location = new system . drawing . point ( NUM , NUM ) ; this . plugin _ options _ label . name = STR ; this . plugin _ options _ label . size = new system . drawing . size ( NUM , NUM ) ; this . plugin _ options _ label . tab _ index = NUM ; this . plugin _ options _ label . text = STR ; this . plugin _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . plugin _ text _ box . location = new system . drawing . point ( NUM , NUM ) ;
private system . windows . forms . text _ box ip _ text _ box ; private system . windows . forms . text _ box server _ port _ text _ box ; private system . windows . forms . text _ box password _ text _ box ; private system . windows . forms . label encryption _ label ; private system . windows . forms . combo _ box encryption _ select ; private system . windows . forms . panel panel ; private system . windows . forms . button ok _ button ; private system . windows . forms . button my _ cancel _ button ; private system . windows . forms . button delete _ button ;
private system . windows . forms . label encryption _ label ; private system . windows . forms . combo _ box encryption _ select ; private system . windows . forms . panel panel ; private system . windows . forms . button ok _ button ; private system . windows . forms . button my _ cancel _ button ; private system . windows . forms . button delete _ button ; private system . windows . forms . button add _ button ; private system . windows . forms . group _ box server _ group _ box ; private system . windows . forms . list _ box servers _ list _ box ; private system . windows . forms . text _ box remarks _ text _ box ;
this . panel = new system . windows . forms . panel ( ) ; this . add _ button = new system . windows . forms . button ( ) ; this . delete _ button = new system . windows . forms . button ( ) ; this . group _ box = new system . windows . forms . group _ box ( ) ; this . servers _ list _ box = new system . windows . forms . list _ box ( ) ; this . table _ layout _ panel . suspend _ layout ( ) ; this . panel . suspend _ layout ( ) ; this . panel . suspend _ layout ( ) ; this . group _ box . suspend _ layout ( ) ; this . suspend _ layout ( ) ;
this . controls . add ( this . panel ) ; this . controls . add ( this . panel ) ; this . controls . add ( this . panel ) ; this . form _ border _ style = system . windows . forms . form _ border _ style . fixed _ single ; this . icon = ( ( system . drawing . icon ) ( resources . get _ object ( STR ) ) ) ; this . maximize _ box = false ; this . name = STR ; this . start _ position = system . windows . forms . form _ start _ position . center _ screen ; this . text = STR ; this . form _ closed + = new system . windows . forms . form _ closed _ event _ handler ( this . config _ form _ form _ closed ) ;
private system . windows . forms . panel panel ; private system . windows . forms . button delete _ button ; private system . windows . forms . button add _ button ; private system . windows . forms . group _ box group _ box ; private system . windows . forms . list _ box servers _ list _ box ; } }
assembly _ assembly _ product _ shadowsocks assembly _ assembly _ copyright _ copyright _ clowwindy assembly _ assembly _ trademark assembly _ assembly _ culture assembly _ com _ visible _ false assembly _ guid _ bbd _ dcf assembly _ assembly _ version

unknown _ fields = pb : : unknown _ field _ set . clone ( other . unknown _ fields ) ; } global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute public geosite clone ( ) { return new geosite ( this ) ; } public const int group _ name _ field _ number = 1 ; private string group _ name = STR ; global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute public string group _ name {
set { group _ name = pb : : proto _ preconditions . check _ not _ null ( value , STR ) ; } } public const int domains _ field _ number = 2 ; private static readonly pb : : field _ codec < global :: domain _ object > repeated _ domains _ codec = pb : : field _ codec . for _ message ( NUM , global :: domain _ object . parser ) ; private readonly pbc : : repeated _ field < global :: domain _ object > domains = new pbc : : repeated _ field < global :: domain _ object > ( ) ; global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute public pbc : : repeated _ field < global :: domain _ object > domains {
= pb : : field _ codec . for _ message ( NUM , global :: domain _ object . parser ) ; private readonly pbc : : repeated _ field < global :: domain _ object > domains = new pbc : : repeated _ field < global :: domain _ object > ( ) ; global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute public pbc : : repeated _ field < global :: domain _ object > domains { get { return domains ; } } global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute public override bool equals ( object other ) { return equals ( other as geosite ) ; }
} global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute public override bool equals ( object other ) { return equals ( other as geosite ) ; } global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute public bool equals ( geosite other ) { if ( reference _ equals ( other , null ) ) { return false ; }
return equals ( unknown _ fields , other . unknown _ fields ) ; } global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute public override int get _ hash _ code ( ) { int hash = 1 ; if ( group _ name . length ! = 0 ) hash ^ = group _ name . get _ hash _ code ( ) ; hash ^ = domains . get _ hash _ code ( ) ; if ( unknown _ fields ! = null ) { hash ^ = unknown _ fields . get _ hash _ code ( ) ; }
if ( unknown _ fields ! = null ) { hash ^ = unknown _ fields . get _ hash _ code ( ) ; } return hash ; } global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute public override string to _ string ( ) { return pb : : json _ formatter . to _ diagnostic _ string ( this ) ; } global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute
output . write _ raw _ tag ( NUM ) ; output . write _ string ( group _ name ) ; } domains . write _ to ( output , repeated _ domains _ codec ) ; if ( unknown _ fields ! = null ) { unknown _ fields . write _ to ( output ) ; } } global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute public int calculate _ size ( ) {
if ( unknown _ fields ! = null ) { unknown _ fields . write _ to ( output ) ; } } global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute public int calculate _ size ( ) { int size = 0 ; if ( group _ name . length ! = 0 ) { size + = 1 + pb : : coded _ output _ stream . compute _ string _ size ( group _ name ) ; }
if ( unknown _ fields ! = null ) { size + = unknown _ fields . calculate _ size ( ) ; } return size ; } global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute public void merge _ from ( geosite other ) { if ( other = = null ) { return ; }
break ; } case NUM : { domains . add _ entries _ from ( input , repeated _ domains _ codec ) ; break ; } } } } }
break ; } } } } } public sealed partial class geosite _ list : pb : : i _ message < geosite _ list > { private static readonly pb : : message _ parser < geosite _ list > parser = new pb : : message _ parser < geosite _ list > ( ( ) = > new geosite _ list ( ) ) ; private pb : : unknown _ field _ set unknown _ fields ; global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute
= pb : : field _ codec . for _ message ( NUM , global :: geosite . parser ) ; private readonly pbc : : repeated _ field < global :: geosite > entries = new pbc : : repeated _ field < global :: geosite > ( ) ; global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute public pbc : : repeated _ field < global :: geosite > entries { get { return entries ; } } global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute public override bool equals ( object other ) { return equals ( other as geosite _ list ) ; }
} global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute public override bool equals ( object other ) { return equals ( other as geosite _ list ) ; } global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute public bool equals ( geosite _ list other ) { if ( reference _ equals ( other , null ) ) { return false ; }
return equals ( unknown _ fields , other . unknown _ fields ) ; } global _ system _ diagnostics _ debugger _ non _ user _ code _ attribute public override int get _ hash _ code ( ) { int hash = 1 ; hash ^ = entries . get _ hash _ code ( ) ; if ( unknown _ fields ! = null ) { hash ^ = unknown _ fields . get _ hash _ code ( ) ; } return hash ;
static geosite _ updater ( ) { if ( ! file . exists ( database _ path ) ) { file . write _ all _ bytes ( database _ path , resources . dlc _ dat ) ; } load _ geosite _ list ( ) ; } static void load _ geosite _ list ( byte [ ] data = null ) {
{ geosites [ item . group _ name . to _ lower ( ) ] = item . domains ; } } public static void update _ pac _ from _ geosite ( configuration config ) { string gfw _ list _ url = geosite _ url ; if ( ! string . is _ null _ or _ white _ space ( config . gfw _ list _ url ) ) { logger . info ( STR ) ;
} } public static void update _ pac _ from _ geosite ( configuration config ) { string gfw _ list _ url = geosite _ url ; if ( ! string . is _ null _ or _ white _ space ( config . gfw _ list _ url ) ) { logger . info ( STR ) ; gfw _ list _ url = config . gfw _ list _ url ; }
line = line . replace ( STR , STR ) ; if ( line . starts _ with ( STR ) ) while ( line . starts _ with ( STR ) ) line = line . substring ( 2 ) ; else if ( line . starts _ with ( STR ) ) line = line . trim _ start ( '|' ) ; else if ( line . starts _ with ( STR ) ) line = line . trim _ start ( '.' ) ; if ( line . starts _ with ( STR ) ) continue ;
else if ( line . starts _ with ( STR ) ) line = line . trim _ start ( '|' ) ; else if ( line . starts _ with ( STR ) ) line = line . trim _ start ( '.' ) ; if ( line . starts _ with ( STR ) ) continue ; else if ( line . starts _ with ( STR ) ) continue ; else if ( line . starts _ with ( STR ) ) continue ;
else if ( line . starts _ with ( STR ) ) line = line . trim _ start ( '.' ) ; if ( line . starts _ with ( STR ) ) continue ; else if ( line . starts _ with ( STR ) ) continue ; else if ( line . starts _ with ( STR ) ) continue ; int pos = line . index _ of _ any ( new char [ ] { '/' } ) ; if ( pos > = 0 )
if ( line . starts _ with ( STR ) ) continue ; else if ( line . starts _ with ( STR ) ) continue ; else if ( line . starts _ with ( STR ) ) continue ; int pos = line . index _ of _ any ( new char [ ] { '/' } ) ; if ( pos > = 0 ) line = line . substring ( 0 , pos ) ; if ( line . length > 0 )
} public string [ ] get _ reduced _ domains ( ) { string [ ] domains = get _ domains ( ) ; list < string > new _ domains = new list < string > ( domains . length ) ; tld _ index tld _ index = get _ tld _ index ( ) ; foreach ( string domain in domains ) { string last _ root _ domain = null ; int pos ;
{ e = new exception ( n . get _ string ( STR , config . local _ port ) , e ) ; } else if ( se . socket _ error _ code = = socket _ error . access _ denied ) { e = new exception ( n . get _ string ( STR , config . local _ port ) , e ) ; } } logging . log _ useful _ exception ( e ) ; report _ error ( e ) ;
} }
initialize _ component ( ) ; servers _ list _ box . dock = dock _ style . fill ; table _ layout _ panel . dock = dock _ style . fill ; perform _ layout ( ) ; update _ texts ( ) ; setup _ value _ changed _ listeners ( ) ; icon = icon . from _ handle ( resources . ssw . get _ hicon ( ) ) ; this . controller = controller ; controller . config _ changed + = controller _ config _ changed ; load _ current _ configuration ( ) ;
update _ texts ( ) ; setup _ value _ changed _ listeners ( ) ; icon = icon . from _ handle ( resources . ssw . get _ hicon ( ) ) ; this . controller = controller ; controller . config _ changed + = controller _ config _ changed ; load _ current _ configuration ( ) ; } private void update _ texts ( ) { add _ button . text = n . get _ string ( STR ) ;
this . controller = controller ; controller . config _ changed + = controller _ config _ changed ; load _ current _ configuration ( ) ; } private void update _ texts ( ) { add _ button . text = n . get _ string ( STR ) ; delete _ button . text = n . get _ string ( STR ) ; duplicate _ button . text = n . get _ string ( STR ) ; ip _ label . text = n . get _ string ( STR ) ;
remarks _ label . text = n . get _ string ( STR ) ; timeout _ label . text = n . get _ string ( STR ) ; server _ group _ box . text = n . get _ string ( STR ) ; ok _ button . text = n . get _ string ( STR ) ; my _ cancel _ button . text = n . get _ string ( STR ) ; apply _ button . text = n . get _ string ( STR ) ; move _ up _ button . text = n . get _ string ( STR ) ; move _ down _ button . text = n . get _ string ( STR ) ; text = n . get _ string ( STR ) ; }
} private void setup _ value _ changed _ listeners ( ) { ip _ text _ box . text _ changed + = config _ value _ changed ; proxy _ port _ text _ box . text _ changed + = config _ value _ changed ; password _ text _ box . text _ changed + = config _ value _ changed ; encryption _ select . selected _ index _ changed + = config _ value _ changed ; plugin _ text _ box . text _ changed + = config _ value _ changed ; plugin _ arguments _ text _ box . text _ changed + = config _ value _ changed ; plugin _ options _ text _ box . text _ changed + = config _ value _ changed ;
{ try { if ( last _ selected _ index = = - 1 | | last _ selected _ index > = modified _ configuration . configs . count ) { return true ; } bool verify = get _ server _ details _ from _ ui ( out server server , is _ save , is _ copy ) ; if ( server ! = null ) {
return true ; }
load _ server _ name _ list _ to _ ui ( modified _ configuration ) ; update _ index _ to _ end ( ) ;
load _ selected _ server _ details ( ) ; update _ buttons ( ) ; } private void update _ buttons ( ) { delete _ button . enabled = ( servers _ list _ box . items . count > 0 ) ; move _ up _ button . enabled = ( servers _ list _ box . selected _ index > 0 ) ; move _ down _ button . enabled = ( servers _ list _ box . selected _ index < servers _ list _ box . items . count - 1 ) ; } private void move _ up _ button _ click ( object sender , event _ args e )
} private void move _ config _ item ( int step ) { int index = servers _ list _ box . selected _ index ; server server = modified _ configuration . configs [ index ] ; object item = servers _ list _ box . items [ index ] ; modified _ configuration . configs . remove ( server ) ; modified _ configuration . configs . insert ( index + step , server ) ; modified _ configuration . index + = step ; servers _ list _ box . begin _ update ( ) ;
} private void show _ passwd _ check _ box _ checked _ changed ( object sender , event _ args e ) { password _ text _ box . use _ system _ password _ char = ! show _ passwd _ check _ box . checked ; } private void use _ plugin _ arg _ check _ box _ checked _ changed ( object sender , event _ args e ) { show _ hide _ plugin _ arg _ input ( need _ plugin _ arg _ check _ box . checked ) ; } }
} private void use _ plugin _ arg _ check _ box _ checked _ changed ( object sender , event _ args e ) { show _ hide _ plugin _ arg _ input ( need _ plugin _ arg _ check _ box . checked ) ; } } }
} } }
namespace shadowsocks _ model { serializable public class configuration { public string version ; public list < server > configs ; public string strategy ; public int index ; public bool global ;
public server get _ current _ server ( ) { if ( index > = 0 & & index < configs . count ) return configs [ index ] ; else return get _ default _ server ( ) ; } public static void check _ server ( server server ) { check _ server ( server . server ) ;
check _ timeout ( server . timeout , server . max _ server _ timeout _ sec ) ; } public static bool checks _ server ( server server ) { try { check _ server ( server ) ; return true ; } catch ( exception )
{ if ( config ! = null & & config . configs ! = null ) { server = ( server ? ? get _ default _ server ( ) ) ; config . configs . insert ( index . get _ value _ or _ default ( config . configs . count ) , server ) ; } return server ; } public static server get _ default _ server ( )
} return server ; } public static server get _ default _ server ( ) { return new server ( ) ; } private static void assert ( bool condition ) { if ( ! condition )
private void pac _ file _ watcher _ changed ( object sender , file _ system _ event _ args e ) { if ( pac _ file _ changed ! = null ) { logging . info ( $ STR ) ; task . factory . start _ new ( ( ) = > { ( ( file _ system _ watcher ) sender ) . enable _ raising _ events = false ; system . threading . thread . sleep ( NUM ) ;
pac _ file _ changed ( this , new event _ args ( ) ) ; ( ( file _ system _ watcher ) sender ) . enable _ raising _ events = true ; } ) ; } } private void user _ rule _ file _ watcher _ changed ( object sender , file _ system _ event _ args e ) { if ( user _ rule _ file _ changed ! = null )
} } private void user _ rule _ file _ watcher _ changed ( object sender , file _ system _ event _ args e ) { if ( user _ rule _ file _ changed ! = null ) { logging . info ( $ STR ) ; task . factory . start _ new ( ( ) = > { ( ( file _ system _ watcher ) sender ) . enable _ raising _ events = false ;
user _ rule _ file _ changed ( this , new event _ args ( ) ) ; ( ( file _ system _ watcher ) sender ) . enable _ raising _ events = true ; } ) ; } } private string get _ pac _ address ( byte [ ] request _ buf , int length , ip _ end _ point local _ end _ point , bool use _ socks ) { return ( use _ socks ? STR : STR ) + local _ end _ point . address + STR + this . config . local _ port + STR ;
} } private string get _ pac _ address ( byte [ ] request _ buf , int length , ip _ end _ point local _ end _ point , bool use _ socks ) { return ( use _ socks ? STR : STR ) + local _ end _ point . address + STR + this . config . local _ port + STR ; } } }
using n _ log ; using shadowsocks _ controller ; using shadowsocks _ controller _ hotkeys ; using shadowsocks _ util ; using shadowsocks _ view ; using system ; using system _ collections _ generic ; using system _ diagnostics ; using system _ io ;
using shadowsocks _ controller ; using shadowsocks _ controller _ hotkeys ; using shadowsocks _ util ; using shadowsocks _ view ; using system ; using system _ collections _ generic ; using system _ diagnostics ; using system _ io ; using system _ i _ pipes ; using system _ linq ;
using system _ text ; using system _ threading ; using system _ threading _ tasks ; using system _ windows _ forms ; namespace shadowsocks { internal static class program { private static readonly logger logger = log _ manager . get _ current _ class _ logger ( ) ; public static shadowsocks _ controller main _ controller { get ; private set ; }
using system _ threading _ tasks ; using system _ windows _ forms ; namespace shadowsocks { internal static class program { private static readonly logger logger = log _ manager . get _ current _ class _ logger ( ) ; public static shadowsocks _ controller main _ controller { get ; private set ; } public static menu _ view _ controller menu _ controller { get ; private set ; } public static string [ ] args { get ; private set ; }
namespace shadowsocks { internal static class program { private static readonly logger logger = log _ manager . get _ current _ class _ logger ( ) ; public static shadowsocks _ controller main _ controller { get ; private set ; } public static menu _ view _ controller menu _ controller { get ; private set ; } public static string [ ] args { get ; private set ; } sta _ thread private static void main ( string [ ] args )
{ private static readonly logger logger = log _ manager . get _ current _ class _ logger ( ) ; public static shadowsocks _ controller main _ controller { get ; private set ; } public static menu _ view _ controller menu _ controller { get ; private set ; } public static string [ ] args { get ; private set ; } sta _ thread private static void main ( string [ ] args ) { directory . set _ current _ directory ( application . startup _ path ) ; model . n _ log _ config . touch _ and _ apply _ n _ log _ config ( ) ;
public static shadowsocks _ controller main _ controller { get ; private set ; } public static menu _ view _ controller menu _ controller { get ; private set ; } public static string [ ] args { get ; private set ; } sta _ thread private static void main ( string [ ] args ) { directory . set _ current _ directory ( application . startup _ path ) ; model . n _ log _ config . touch _ and _ apply _ n _ log _ config ( ) ; service _ point _ manager . security _ protocol | = security _ protocol _ type . tls | security _ protocol _ type . tls | security _ protocol _ type . tls ;
{ directory . set _ current _ directory ( application . startup _ path ) ; model . n _ log _ config . touch _ and _ apply _ n _ log _ config ( ) ; service _ point _ manager . security _ protocol | = security _ protocol _ type . tls | security _ protocol _ type . tls | security _ protocol _ type . tls ; args = args ; if ( ! utils . is _ win _ vista _ or _ higher ( ) ) { message _ box . show ( n . get _ string ( STR ) , STR , message _ box _ buttons . ok , message _ box _ icon . error ) ;
args = args ; if ( ! utils . is _ win _ vista _ or _ higher ( ) ) { message _ box . show ( n . get _ string ( STR ) , STR , message _ box _ buttons . ok , message _ box _ icon . error ) ; return ; } if ( ! utils . is _ supported _ runtime _ version ( ) ) { if ( dialog _ result . ok = = message _ box . show ( n . get _ string ( STR , STR ) ,
int urlidx = alist . index _ of ( STR ) + 1 ; if ( urlidx > 0 ) { if ( args . length < = urlidx ) { return ; } if ( ! pipe _ exist ) { added _ url = args [ urlidx ] ;
else if ( pipe _ exist ) { process [ ] old _ processes = process . get _ processes _ by _ name ( STR ) ; if ( old _ processes . length > 0 ) { process old _ process = old _ processes [ 0 ] ; } message _ box . show ( n . get _ string ( STR ) + environment . new _ line + n . get _ string ( STR ) ,
{ public rectangle target _ rect ; public qr _ code _ splash _ form ( ) { form _ border _ style = form _ border _ style . none ;
public event event _ handler config _ changed ; public event event _ handler enable _ status _ changed ; public event event _ handler < path _ event _ args > pac _ file _ ready _ to _ open ; public shadowsocks _ controller ( ) { config = configuration . load ( ) ; polipo _ runner = new polipo _ runner ( ) ; polipo _ runner . start ( config . get _ current _ server ( ) ) ; local = new local ( config . get _ current _ server ( ) ) ;
public event event _ handler < path _ event _ args > pac _ file _ ready _ to _ open ; public shadowsocks _ controller ( ) { config = configuration . load ( ) ; polipo _ runner = new polipo _ runner ( ) ; polipo _ runner . start ( config . get _ current _ server ( ) ) ; local = new local ( config . get _ current _ server ( ) ) ; try { local . start ( ) ;
enable _ item . checked = controller . get _ configuration ( ) . enabled ; } private void cinfig _ form _ load ( object sender , event _ args e ) { if ( ! controller . get _ configuration ( ) . is _ default ) { this . opacity = 0 ; begin _ invoke ( new method _ invoker ( delegate { this . hide ( ) ;
{ if ( ! controller . get _ configuration ( ) . is _ default ) { this . opacity = 0 ; begin _ invoke ( new method _ invoker ( delegate { this . hide ( ) ; } ) ) ; } }
{ controller . stop ( ) ; } private void about _ item _ click ( object sender , event _ args e ) { process . start ( STR ) ; } private void notify _ icon _ double _ click ( object sender , event _ args e ) { show _ window ( ) ;
this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ; this . ip _ text _ box = new system . windows . forms . text _ box ( ) ; this . server _ port _ text _ box = new system . windows . forms . text _ box ( ) ; this . password _ text _ box = new system . windows . forms . text _ box ( ) ; this . proxy _ port _ text _ box = new system . windows . forms . text _ box ( ) ; this . notify _ icon = new system . windows . forms . notify _ icon ( this . components ) ; this . panel = new system . windows . forms . panel ( ) ; this . ok _ button = new system . windows . forms . button ( ) ; this . my _ cancel _ button = new system . windows . forms . button ( ) ;
this . notify _ icon = new system . windows . forms . notify _ icon ( this . components ) ; this . panel = new system . windows . forms . panel ( ) ; this . ok _ button = new system . windows . forms . button ( ) ; this . my _ cancel _ button = new system . windows . forms . button ( ) ; this . panel = new system . windows . forms . panel ( ) ; this . context _ menu = new system . windows . forms . context _ menu ( ) ; this . enable _ item = new system . windows . forms . menu _ item ( ) ; this . config _ item = new system . windows . forms . menu _ item ( ) ; this . edit _ pac _ file _ item = new system . windows . forms . menu _ item ( ) ; this . about _ item = new system . windows . forms . menu _ item ( ) ;
this . panel = new system . windows . forms . panel ( ) ; this . context _ menu = new system . windows . forms . context _ menu ( ) ; this . enable _ item = new system . windows . forms . menu _ item ( ) ; this . config _ item = new system . windows . forms . menu _ item ( ) ; this . edit _ pac _ file _ item = new system . windows . forms . menu _ item ( ) ; this . about _ item = new system . windows . forms . menu _ item ( ) ; this . menu _ item = new system . windows . forms . menu _ item ( ) ; this . quit _ item = new system . windows . forms . menu _ item ( ) ; this . table _ layout _ panel = new system . windows . forms . table _ layout _ panel ( ) ; this . list _ view = new system . windows . forms . list _ view ( ) ;
this . table _ layout _ panel . suspend _ layout ( ) ; this . panel . suspend _ layout ( ) ; this . table _ layout _ panel . suspend _ layout ( ) ; this . table _ layout _ panel . suspend _ layout ( ) ; this . suspend _ layout ( ) ; this . table _ layout _ panel . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( ( system . windows . forms . anchor _ styles . top | system . windows . forms . anchor _ styles . left ) | system . windows . forms . anchor _ styles . right ) ) ) ; this . table _ layout _ panel . auto _ size = true ; this . table _ layout _ panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . table _ layout _ panel . column _ count = 2 ;
this . table _ layout _ panel . controls . add ( this . label , 0 , 2 ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . ip _ text _ box , 1 , 0 ) ; this . table _ layout _ panel . controls . add ( this . server _ port _ text _ box , 1 , 1 ) ; this . table _ layout _ panel . controls . add ( this . password _ text _ box , 1 , 2 ) ; this . table _ layout _ panel . controls . add ( this . proxy _ port _ text _ box , 1 , NUM ) ; this . table _ layout _ panel . location = new system . drawing . point ( NUM , NUM ) ; this . table _ layout _ panel . margin = new system . windows . forms . padding ( NUM ) ; this . table _ layout _ panel . name = STR ; this . table _ layout _ panel . padding = new system . windows . forms . padding ( NUM ) ;
this . table _ layout _ panel . margin = new system . windows . forms . padding ( NUM ) ; this . table _ layout _ panel . name = STR ; this . table _ layout _ panel . padding = new system . windows . forms . padding ( NUM ) ; this . table _ layout _ panel . row _ count = NUM ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ;
STR , STR , STR , STR , STR , STR , STR } ) ; this . encryption _ select . location = new system . drawing . point ( NUM , NUM ) ; this . encryption _ select . name = STR ; this . encryption _ select . size = new system . drawing . size ( NUM , NUM ) ;
this . panel . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( ( system . windows . forms . anchor _ styles . top | system . windows . forms . anchor _ styles . bottom ) | system . windows . forms . anchor _ styles . right ) ) ) ; this . panel . auto _ size = true ; this . panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . panel . controls . add ( this . my _ cancel _ button ) ; this . panel . controls . add ( this . ok _ button ) ; this . panel . location = new system . drawing . point ( NUM , NUM ) ; this . panel . name = STR ; this . panel . size = new system . drawing . size ( NUM , NUM ) ;
this . panel . auto _ size = true ; this . panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . panel . controls . add ( this . my _ cancel _ button ) ; this . panel . controls . add ( this . ok _ button ) ; this . panel . location = new system . drawing . point ( NUM , NUM ) ; this . panel . name = STR ; this . panel . size = new system . drawing . size ( NUM , NUM ) ; this . panel . tab _ index = 1 ; this . context _ menu . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . enable _ item ,
this . panel . name = STR ; this . panel . size = new system . drawing . size ( NUM , NUM ) ; this . panel . tab _ index = 1 ; this . context _ menu . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . enable _ item , this . config _ item , this . edit _ pac _ file _ item , this . about _ item , this . menu _ item , this . quit _ item } ) ;
this . menu _ item . index = NUM ; this . menu _ item . text = STR ; this . quit _ item . index = NUM ; this . quit _ item . text = STR ; this . quit _ item . click + = new system . event _ handler ( this . quit _ click ) ; this . table _ layout _ panel . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( ( ( system . windows . forms . anchor _ styles . top | system . windows . forms . anchor _ styles . bottom ) | system . windows . forms . anchor _ styles . left ) | system . windows . forms . anchor _ styles . right ) ) ) ; this . table _ layout _ panel . column _ count = 2 ; this . auto _ size = true ;
this . controls . add ( this . panel ) ; this . form _ border _ style = system . windows . forms . form _ border _ style . fixed _ single ; this . icon = ( ( system . drawing . icon ) ( resources . get _ object ( STR ) ) ) ; this . maximize _ box = false ; this . name = STR ; this . start _ position = system . windows . forms . form _ start _ position . center _ screen ; this . text = STR ; this . form _ closed + = new system . windows . forms . form _ closed _ event _ handler ( this . config _ form _ form _ closed ) ;
this . icon = ( ( system . drawing . icon ) ( resources . get _ object ( STR ) ) ) ; this . maximize _ box = false ; this . name = STR ; this . start _ position = system . windows . forms . form _ start _ position . center _ screen ; this . text = STR ; this . form _ closed + = new system . windows . forms . form _ closed _ event _ handler ( this . config _ form _ form _ closed ) ; this . load + = new system . event _ handler ( this . cinfig _ form _ load ) ; this . table _ layout _ panel . resume _ layout ( false ) ; this . table _ layout _ panel . perform _ layout ( ) ; this . panel . resume _ layout ( false ) ;
this . table _ layout _ panel . resume _ layout ( false ) ; this . table _ layout _ panel . perform _ layout ( ) ; this . panel . resume _ layout ( false ) ; this . table _ layout _ panel . resume _ layout ( false ) ; this . table _ layout _ panel . perform _ layout ( ) ; this . table _ layout _ panel . resume _ layout ( false ) ; this . table _ layout _ panel . perform _ layout ( ) ; this . resume _ layout ( false ) ; this . perform _ layout ( ) ; }
private system . windows . forms . notify _ icon notify _ icon ; private system . windows . forms . label label ; private system . windows . forms . combo _ box encryption _ select ; private system . windows . forms . panel panel ; private system . windows . forms . button ok _ button ; private system . windows . forms . button my _ cancel _ button ; private system . windows . forms . panel panel ; private system . windows . forms . context _ menu context _ menu ; private system . windows . forms . menu _ item enable _ item ; private system . windows . forms . menu _ item about _ item ;
private system . windows . forms . panel panel ; private system . windows . forms . button ok _ button ; private system . windows . forms . button my _ cancel _ button ; private system . windows . forms . panel panel ; private system . windows . forms . context _ menu context _ menu ; private system . windows . forms . menu _ item enable _ item ; private system . windows . forms . menu _ item about _ item ; private system . windows . forms . menu _ item menu _ item ; private system . windows . forms . menu _ item quit _ item ; private system . windows . forms . menu _ item config _ item ;
private system . windows . forms . panel panel ; private system . windows . forms . context _ menu context _ menu ; private system . windows . forms . menu _ item enable _ item ; private system . windows . forms . menu _ item about _ item ; private system . windows . forms . menu _ item menu _ item ; private system . windows . forms . menu _ item quit _ item ; private system . windows . forms . menu _ item config _ item ; private system . windows . forms . menu _ item edit _ pac _ file _ item ; private system . windows . forms . table _ layout _ panel table _ layout _ panel ; private system . windows . forms . list _ view list _ view ;
using system _ net ; using system _ io ; namespace shadowsocks _ controller { public class gfw _ list _ updater
namespace shadowsocks _ controller { public class gfw _ list _ updater { private const string gfwlist _ url = STR ; public i _ web _ proxy proxy = null ; public class gfw _ list _ download _ completed _ args : event _ args { public string content ; }
using system _ collections _ generic ; using system _ diagnostics ; using system _ io ; using system _ i _ compression ; using system _ net ; using system _ net _ sockets ; using system _ text ; namespace shadowsocks _ controller {
namespace shadowsocks _ controller { class pac _ server { private static int port = NUM ; private static string pac _ file = STR ; private static configuration config ; socket listener ; file _ system _ watcher watcher ; public event event _ handler pac _ file _ changed ;
flash _ step = 0 ; x = 0 ; y = 0 ; w = width ; h = height ; sw = stopwatch . start _ new ( ) ; timer = new timer ( ) ; timer . interval = ( int ) ( animation _ time * NUM / animation _ steps ) ; timer . tick + = timer _ tick ; timer . start ( ) ;
if ( flash _ step = = 0 ) { timer . interval = NUM ; g . clear ( color . transparent ) ; set _ bitmap ( bitmap ) ; } else if ( flash _ step = = 1 ) { timer . interval = NUM ; g . fill _ rectangle ( brush , x , y , w , h ) ;
registry . set _ value ( STR , pac _ url ) ; } } else { registry . set _ value ( STR , 0 ) ; registry . set _ value ( STR , STR ) ;
registry . set _ value ( STR , STR ) ; } ie _ auto _ detect _ proxy ( false ) ; system _ proxy . notify _ ie ( ) ; copy _ proxy _ setting _ from _ lan ( ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; message _ box . show ( n . get _ string ( STR ) ) ;
string before _ at = data . substring ( 0 , index _ last _ at ) ; string [ ] parts = before _ at . split ( new [ ] { ':' } ) ; method = parts [ 0 ] ; password = parts [ 1 ] ; } catch ( index _ out _ of _ range _ exception ) { throw new format _ exception ( ) ; } }
} catch ( index _ out _ of _ range _ exception ) { throw new format _ exception ( ) ; } } } }
return configs [ index ] ; else return get _ default _ server ( ) ; } public static void check _ server ( server server ) { check _ port ( server . server _ port ) ;
else return get _ default _ server ( ) ; } public static void check _ server ( server server ) { check _ port ( server . server _ port ) ; check _ password ( server . password ) ; check _ server ( server . server ) ;
return get _ default _ server ( ) ; } public static void check _ server ( server server ) { check _ port ( server . server _ port ) ; check _ password ( server . password ) ; check _ server ( server . server ) ; } public static configuration load ( )
} public static void check _ server ( server server ) { check _ port ( server . server _ port ) ; check _ password ( server . password ) ; check _ server ( server . server ) ; } public static configuration load ( ) { try
config . local _ port = NUM ; if ( config . index = = - 1 & & config . strategy = = null ) config . index = 0 ; return config ;
return config ; } catch ( exception e ) { if ( ! ( e is file _ not _ found _ exception ) ) logging . log _ useful _ exception ( e ) ; return new configuration {
logging . log _ useful _ exception ( e ) ; return new configuration { index = 0 , is _ default = true , local _ port = NUM , auto _ check _ update = true , configs = new list < server > ( ) {
return new configuration { index = 0 , is _ default = true , local _ port = NUM , auto _ check _ update = true , configs = new list < server > ( ) { get _ default _ server ( ) }
config . index = config . configs . count - 1 ; if ( config . index < - 1 ) config . index = - 1 ; if ( config . index = = - 1 & & config . strategy = = null ) config . index = 0 ;
if ( config . index < - 1 ) config . index = - 1 ; if ( config . index = = - 1 & & config . strategy = = null ) config . index = 0 ;
config . index = - 1 ; if ( config . index = = - 1 & & config . strategy = = null ) config . index = 0 ; config . is _ default = false ;
config . is _ default = false ; try { using ( stream _ writer sw = new stream _ writer ( file . open ( config _ file , file _ mode . create ) ) ) { string json _ string = json _ convert . serialize _ object ( config , formatting . indented ) ; sw . write ( json _ string ) ; sw . flush ( ) ; } }
throw new exception ( n . get _ string ( STR ) ) ; } public static void check _ port ( int port ) { if ( port < = 0 | | port > NUM ) throw new argument _ exception ( n . get _ string ( STR ) ) ; }
} public static void check _ port ( int port ) { if ( port < = 0 | | port > NUM ) throw new argument _ exception ( n . get _ string ( STR ) ) ; } public static void check _ local _ port ( int port ) {
throw new argument _ exception ( n . get _ string ( STR ) ) ; } public static void check _ local _ port ( int port ) { check _ port ( port ) ; if ( port = = NUM ) throw new argument _ exception ( n . get _ string ( STR ) ) ;
} public static void check _ local _ port ( int port ) { check _ port ( port ) ; if ( port = = NUM ) throw new argument _ exception ( n . get _ string ( STR ) ) ; } private static void check _ password ( string password )
throw new argument _ exception ( n . get _ string ( STR ) ) ; } private static void check _ password ( string password ) { if ( string . is _ null _ or _ empty ( password ) ) throw new argument _ exception ( n . get _ string ( STR ) ) ; }
} private static void check _ password ( string password ) { if ( string . is _ null _ or _ empty ( password ) ) throw new argument _ exception ( n . get _ string ( STR ) ) ; } private static void check _ server ( string server ) {
throw new argument _ exception ( n . get _ string ( STR ) ) ; } private static void check _ server ( string server ) { if ( string . is _ null _ or _ empty ( server ) ) throw new argument _ exception ( n . get _ string ( STR ) ) ; }
} private static void check _ server ( string server ) { if ( string . is _ null _ or _ empty ( server ) ) throw new argument _ exception ( n . get _ string ( STR ) ) ; } } }
throw new argument _ exception ( n . get _ string ( STR ) ) ; } } }
} } }
using system _ diagnostics ; using system _ io ; using system _ text ; using shadowsocks _ controller ; using shadowsocks _ properties ; namespace shadowsocks _ util _ system _ proxy { public static class sysproxy
using system _ text ; using shadowsocks _ controller ; using shadowsocks _ properties ; namespace shadowsocks _ util _ system _ proxy { public static class sysproxy { private static bool user _ settings _ recorded = false ; private static string [ ] user _ settings = new string [ NUM ] ;
using shadowsocks _ controller ; using shadowsocks _ properties ; namespace shadowsocks _ util _ system _ proxy { public static class sysproxy { private static bool user _ settings _ recorded = false ; private static string [ ] user _ settings = new string [ NUM ] ; enum ret _ errors : int {
} else { var flags = user _ settings [ 0 ] ; var proxy _ server = user _ settings [ 1 ] ? ? STR ; var bypass _ list = user _ settings [ 2 ] ? ? STR ; var pac _ url = user _ settings [ NUM ] ? ? STR ; arguments = $ STR ; user _ settings _ recorded = false ;
} exec _ sysproxy ( arguments , out str ) ; } private static void exec _ sysproxy ( string arguments , out string query _ str ) { using ( var process = new process ( ) ) { process . start _ info . file _ name = utils . get _ temp _ path ( STR ) ; process . start _ info . arguments = arguments ; process . start _ info . working _ directory = utils . get _ temp _ path ( ) ;
process . wait _ for _ exit ( ) ; var exit _ code = process . exit _ code ; if ( exit _ code ! = ( int ) ret _ errors . ret _ no _ error ) { throw new proxy _ exception ( stderr ) ; } if ( arguments = = STR & & stdout . is _ null _ or _ white _ space ( ) ) { throw new proxy _ exception ( STR ) ; }
} if ( arguments = = STR & & stdout . is _ null _ or _ white _ space ( ) ) { throw new proxy _ exception ( STR ) ; } query _ str = stdout ; } } private static void parse _ query _ str ( string str ) {
} } else { sysproxy . set _ ie _ proxy ( false , false , null , null ) ; } } catch ( proxy _ exception ex ) { logging . log _ useful _ exception ( ex ) ;
} } catch ( proxy _ exception ex ) { logging . log _ useful _ exception ( ex ) ; } } } }
{ use _ socks = true ; } * / } } else if ( kv . length = = 1 ) { if ( line . index _ of ( STR ) > = 0 ) { path _ match = true ;
} } else if ( kv . length = = 1 ) { if ( line . index _ of ( STR ) > = 0 ) { path _ match = true ; } } }
system _ proxy _ is _ dirty = true ; } else { if ( system _ proxy _ is _ dirty ) { system _ proxy . update ( config , false ) ; system _ proxy _ is _ dirty = false ; } }
system _ proxy _ is _ dirty = false ; } } } private void pac _ server _ pac _ file _ changed ( object sender , event _ args e ) { update _ system _ proxy ( ) ; } private void pac _ server _ pac _ update _ completed ( object sender , event _ args e ) {
{ bool global = config . global ; bool enabled = config . enabled ; if ( force _ disable ) { enabled = false ; } try { registry _ key registry =
{ if ( global ) { registry . set _ value ( STR , 1 ) ; registry . set _ value ( STR , STR + config . local _ port . to _ string ( ) ) ; registry . set _ value ( STR , STR ) ; } else { registry . set _ value ( STR , 0 ) ;
} else { registry . set _ value ( STR , 0 ) ; registry . set _ value ( STR , STR ) ; registry . set _ value ( STR , STR ) ; } system _ proxy . notify _ ie ( ) ;
} system _ proxy . notify _ ie ( ) ;
copy _ proxy _ setting _ from _ lan ( ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; message _ box . show ( n . get _ string ( STR ) ) ; } } private static void copy _ proxy _ setting _ from _ lan ( ) {
} if ( changed ) { log _ message _ text _ box . scroll _ to _ caret ( ) ; } last _ offset = reader . base _ stream . position ; } } private void log _ form _ load ( object sender , event _ args e ) {
} last _ offset = reader . base _ stream . position ; } } private void log _ form _ load ( object sender , event _ args e ) { init _ content ( ) ; timer = new timer ( ) ; timer . interval = NUM ; timer . tick + = timer _ tick ;
{ string argument = STR + filename ; system . diagnostics . process . start ( STR , argument ) ; } private void exit _ menu _ item _ click ( object sender , event _ args e ) {
{ this . close ( ) ; } private void log _ form _ shown ( object sender , event _ args e ) { log _ message _ text _ box . scroll _ to _ caret ( ) ; } private void wrap _ text _ check _ box _ checked _ changed ( object sender , event _ args e ) { log _ message _ text _ box . word _ wrap = wrap _ text _ check _ box . checked ;
} } }
this . context _ menu _ strip = new system . windows . forms . context _ menu _ strip ( this . components ) ; this . main _ menu = new system . windows . forms . main _ menu ( this . components ) ; this . file _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . open _ location _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . exit _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . panel = new system . windows . forms . panel ( ) ; this . change _ font _ button = new system . windows . forms . button ( ) ; this . clean _ logs _ button = new system . windows . forms . button ( ) ; this . wrap _ text _ check _ box = new system . windows . forms . check _ box ( ) ; this . table _ layout _ panel = new system . windows . forms . table _ layout _ panel ( ) ;
this . suspend _ layout ( ) ; this . context _ menu _ strip . name = STR ; this . context _ menu _ strip . size = new system . drawing . size ( NUM , NUM ) ; this . main _ menu . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . file _ menu _ item } ) ; this . file _ menu _ item . index = 0 ; this . file _ menu _ item . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . open _ location _ menu _ item ,
this . file _ menu _ item . index = 0 ; this . file _ menu _ item . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . open _ location _ menu _ item , this . exit _ menu _ item } ) ; this . file _ menu _ item . text = STR ; this . open _ location _ menu _ item . index = 0 ; this . open _ location _ menu _ item . text = STR ; this . open _ location _ menu _ item . click + = new system . event _ handler ( this . open _ location _ menu _ item _ click ) ; this . exit _ menu _ item . index = 1 ; this . exit _ menu _ item . text = STR ;
this . open _ location _ menu _ item . index = 0 ; this . open _ location _ menu _ item . text = STR ; this . open _ location _ menu _ item . click + = new system . event _ handler ( this . open _ location _ menu _ item _ click ) ; this . exit _ menu _ item . index = 1 ; this . exit _ menu _ item . text = STR ; this . exit _ menu _ item . click + = new system . event _ handler ( this . exit _ menu _ item _ click ) ; this . panel . controls . add ( this . top _ most _ check _ box ) ; this . panel . controls . add ( this . change _ font _ button ) ; this . panel . controls . add ( this . clean _ logs _ button ) ; this . panel . controls . add ( this . wrap _ text _ check _ box ) ; this . client _ size = new system . drawing . size ( NUM , NUM ) ; this . controls . add ( this . table _ layout _ panel ) ; this . menu = this . main _ menu ;
this . exit _ menu _ item . index = 1 ; this . exit _ menu _ item . text = STR ; this . exit _ menu _ item . click + = new system . event _ handler ( this . exit _ menu _ item _ click ) ; this . panel . controls . add ( this . top _ most _ check _ box ) ; this . panel . controls . add ( this . change _ font _ button ) ; this . panel . controls . add ( this . clean _ logs _ button ) ; this . panel . controls . add ( this . wrap _ text _ check _ box ) ; this . panel . dock = system . windows . forms . dock _ style . fill ; this . panel . location = new system . drawing . point ( NUM , NUM ) ; this . panel . name = STR ; this . client _ size = new system . drawing . size ( NUM , NUM ) ; this . controls . add ( this . table _ layout _ panel ) ; this . menu = this . main _ menu ; this . name = STR ; this . start _ position = system . windows . forms . form _ start _ position . center _ screen ; this . text = STR ;
this . menu = this . main _ menu ; this . name = STR ; this . start _ position = system . windows . forms . form _ start _ position . center _ screen ; this . text = STR ; this . form _ closing + = new system . windows . forms . form _ closing _ event _ handler ( this . log _ form _ form _ closing ) ; this . load + = new system . event _ handler ( this . log _ form _ load ) ; this . shown + = new system . event _ handler ( this . log _ form _ shown ) ; this . panel . resume _ layout ( false ) ; this . panel . perform _ layout ( ) ; this . table _ layout _ panel . resume _ layout ( false ) ;
} private system . windows . forms . text _ box log _ message _ text _ box ; private system . windows . forms . context _ menu _ strip context _ menu _ strip ; private system . windows . forms . main _ menu main _ menu ; private system . windows . forms . menu _ item file _ menu _ item ; private system . windows . forms . menu _ item open _ location _ menu _ item ; private system . windows . forms . menu _ item exit _ menu _ item ; private system . windows . forms . panel panel ; private system . windows . forms . check _ box wrap _ text _ check _ box ; private system . windows . forms . button clean _ logs _ button ;
private system . windows . forms . context _ menu _ strip context _ menu _ strip ; private system . windows . forms . main _ menu main _ menu ; private system . windows . forms . menu _ item file _ menu _ item ; private system . windows . forms . menu _ item open _ location _ menu _ item ; private system . windows . forms . menu _ item exit _ menu _ item ; private system . windows . forms . panel panel ; private system . windows . forms . check _ box wrap _ text _ check _ box ; private system . windows . forms . button clean _ logs _ button ; private system . windows . forms . button change _ font _ button ; private system . windows . forms . table _ layout _ panel table _ layout _ panel ;
} }
} } private static void check _ port ( int port ) { if ( port < = 0 | | port > NUM ) { throw new argument _ exception ( n . get _ string ( STR ) ) ; } } private static void check _ password ( string password )
} } private static void check _ password ( string password ) { if ( string . is _ null _ or _ empty ( password ) ) { throw new argument _ exception ( n . get _ string ( STR ) ) ; } } private static void check _ server ( string server )
} } private static void check _ server ( string server ) { if ( string . is _ null _ or _ empty ( server ) ) { throw new argument _ exception ( n . get _ string ( STR ) ) ; } } private static void check _ remark ( string remark )
} } private static void check _ remark ( string remark ) { } private class json _ serializer _ strategy : simple _ json . poco _ json _ serializer _ strategy { public override object deserialize _ object ( object value , type type ) { if ( type = = typeof ( int ) & & value . get _ type ( ) = = typeof ( string ) )
public event error _ event _ handler error ; public class result _ event _ args : event _ args { public bool success ; public result _ event _ args ( bool success ) { this . success = success ; } } private void http _ download _ string _ completed ( object sender , download _ string _ completed _ event _ args e )
} } catch ( exception ex ) { if ( error ! = null ) { error ( this , new error _ event _ args ( ex ) ) ; } } }
stream _ writer _ with _ timestamp sw = new stream _ writer _ with _ timestamp ( fs ) ; sw . auto _ flush = true ; console . set _ out ( sw ) ; console . set _ error ( sw ) ; return true ; } catch ( io _ exception e ) { console . write _ line ( e . to _ string ( ) ) ; return false ;
} private void receive _ callback ( i _ async _ result ar ) { try { var bytes _ read = socket . end _ receive ( ar ) ; if ( bytes _ read = = 0 ) { on _ finish ( ) ;
try { var bytes _ read = socket . end _ receive ( ar ) ; if ( bytes _ read = = 0 ) { on _ finish ( ) ; return ; } buffer _ data _ length + = bytes _ read ; new _ package _ recv ( ) ;
return ; } buffer _ data _ length + = bytes _ read ; new _ package _ recv ( ) ; } catch ( exception ex ) { on _ exception ( ex ) ; on _ finish ( ) ; }
return ; } } if ( buffer _ data _ length = = line _ buffer . length ) { on _ exception ( new index _ out _ of _ range _ exception ( STR ) ) ; on _ finish ( ) ; return ; } if ( buffer _ data _ index > 0 )
} private void on _ exception ( exception ex ) { on _ exception ? . invoke ( ex , state ) ; } private void on _ finish ( ) { on _ finish ? . invoke ( line _ buffer , buffer _ data _ index , buffer _ data _ length , state ) ; } private static int index _ of ( byte [ ] haystack , int index , int length , byte [ ] needle , int [ ] offset _ table , int [ ] char _ table )
} private static int index _ of ( byte [ ] haystack , int index , int length , byte [ ] needle , int [ ] offset _ table , int [ ] char _ table ) { var end = index + length ; for ( int i = needle . length - 1 + index , j ; i < end ; ) { for ( j = needle . length - 1 ; needle [ j ] = = haystack [ i ] ; - - i , - - j ) { if ( j = = 0 ) {
{ var end = index + length ; for ( int i = needle . length - 1 + index , j ; i < end ; ) { for ( j = needle . length - 1 ; needle [ j ] = = haystack [ i ] ; - - i , - - j ) { if ( j = = 0 ) { return i ; }
using system _ runtime _ interop _ services ; using system _ io ; using shadowsocks _ model ; using shadowsocks _ util ; namespace shadowsocks _ controller { public static class system _ proxy { dll _ import _ wininet _ dll
using system _ io ; using shadowsocks _ model ; using shadowsocks _ util ; namespace shadowsocks _ controller { public static class system _ proxy { dll _ import _ wininet _ dll public static extern bool internet _ set _ option ( int _ ptr h _ internet , int dw _ option , int _ ptr lp _ buffer , int dw _ buffer _ length ) ; public const int internet _ option _ settings _ changed = NUM ;
} } private static void copy _ proxy _ setting _ from _ lan ( ) { registry _ key registry = null ; try { registry = utils . open _ user _ reg _ key ( STR , true ) ; if ( registry = = null ) { logging . error ( STR ) ; return ;
var connections = registry . get _ value _ names ( ) ; foreach ( var each in connections ) { switch ( each . to _ upper _ invariant ( ) ) { case STR : case STR : case STR :
} } private static void ie _ auto _ detect _ proxy ( bool set ) { registry _ key registry = null ; try { registry = utils . open _ user _ reg _ key ( STR , true ) ; if ( registry = = null ) { logging . error ( STR ) ; return ;
}
} } }
{ bool pipe _ exist = false ; try { pipe . connect ( NUM ) ; pipe _ exist = true ; } catch ( timeout _ exception ) { pipe _ exist = false ;
{ process [ ] old _ processes = process . get _ processes _ by _ name ( STR ) ; if ( old _ processes . length > 0 ) { process old _ process = old _ processes [ 0 ] ; } message _ box . show ( n . get _ string ( STR ) + environment . new _ line + n . get _ string ( STR ) , n . get _ string ( STR ) ) ;
string privoxy _ log _ filename = utils . get _ temp _ path ( STR ) ; if ( file . exists ( privoxy _ log _ filename ) ) using ( new file _ stream ( privoxy _ log _ filename , file _ mode . truncate ) ) { } main _ controller = new shadowsocks _ controller ( ) ; menu _ controller = new menu _ view _ controller ( main _ controller ) ; hot _ keys . init ( main _ controller ) ; main _ controller . start ( ) ; application . run ( ) ; }
} private static int exited = 0 ; private static void current _ domain _ unhandled _ exception ( object sender , unhandled _ exception _ event _ args e ) { if ( interlocked . increment ( ref exited ) = = 1 ) { string err _ msg = e . exception _ object . to _ string ( ) ; logger . error ( err _ msg ) ; message _ box . show ( $ STR unexpected error , shadowsocks will exit . please report to STR ,
statistics _ chart . data _ source = data _ table ; load _ chart _ data ( ) ; statistics _ chart . data _ bind ( ) ; } private void cancel _ button _ click ( object sender , event _ args e ) { close ( ) ; } private void ok _ button _ click ( object sender , event _ args e ) {
foreach ( var data in final _ data ) { data _ table . rows . add ( data . timestamp , data . speed , data . package _ loss _ percentage , data . ping ) ; } statistics _ chart . data _ bind ( ) ; } private void server _ selector _ selection _ change _ committed ( object sender , event _ args e ) { load _ chart _ data ( ) ;
} statistics _ chart . data _ bind ( ) ; } private void server _ selector _ selection _ change _ committed ( object sender , event _ args e ) { load _ chart _ data ( ) ; }
{ load _ chart _ data ( ) ; } private void day _ mode _ checked _ changed ( object sender , event _ args e ) { load _ chart _ data ( ) ; }
} private void day _ mode _ checked _ changed ( object sender , event _ args e ) { load _ chart _ data ( ) ; } private void all _ mode _ checked _ changed ( object sender , event _ args e ) { load _ chart _ data ( ) ; } private void ping _ check _ box _ checked _ changed ( object sender , event _ args e )
this . chart _ mode _ selector . suspend _ layout ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . begin _ init ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . suspend _ layout ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . begin _ init ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . suspend _ layout ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . data _ collection _ minutes _ num ) ) . begin _ init ( ) ;
series . legend = STR ; series . name = STR ; series . tool _ tip = STR ; series . chart _ area = STR ; series . chart _ type = system . windows . forms . data _ visualization . charting . series _ chart _ type . bubble ; series . color = system . drawing . color . crimson ; series . custom _ properties = STR ;
series . chart _ area = STR ; series . chart _ type = system . windows . forms . data _ visualization . charting . series _ chart _ type . bubble ; series . color = system . drawing . color . crimson ; series . custom _ properties = STR ; series . legend = STR ; series . name = STR ; series . tool _ tip = STR ; series . y _ axis _ type = system . windows . forms . data _ visualization . charting . axis _ type . secondary ;
series . legend = STR ; series . name = STR ; series . tool _ tip = STR ; series . y _ axis _ type = system . windows . forms . data _ visualization . charting . axis _ type . secondary ; series . y _ values _ per _ point = 2 ; series . border _ width = NUM ; series . chart _ area = STR ; series . chart _ type = system . windows . forms . data _ visualization . charting . series _ chart _ type . line ; series . color = system . drawing . color . dodger _ blue ;
series . chart _ area = STR ; series . chart _ type = system . windows . forms . data _ visualization . charting . series _ chart _ type . line ; series . color = system . drawing . color . dodger _ blue ; series . legend = STR ; series . marker _ size = NUM ; series . marker _ style = system . windows . forms . data _ visualization . charting . marker _ style . circle ; series . name = STR ; series . tool _ tip = STR ; this . statistics _ chart . series . add ( series ) ;
series . legend = STR ; series . marker _ size = NUM ; series . marker _ style = system . windows . forms . data _ visualization . charting . marker _ style . circle ; series . name = STR ; series . tool _ tip = STR ; this . statistics _ chart . series . add ( series ) ; this . statistics _ chart . series . add ( series ) ; this . statistics _ chart . series . add ( series ) ; this . statistics _ chart . size = new system . drawing . size ( NUM , NUM ) ; this . statistics _ chart . tab _ index = 2 ;
this . statistics _ chart . series . add ( series ) ; this . statistics _ chart . series . add ( series ) ; this . statistics _ chart . series . add ( series ) ; this . statistics _ chart . size = new system . drawing . size ( NUM , NUM ) ; this . statistics _ chart . tab _ index = 2 ; this . ping _ check _ box . auto _ size = true ; this . ping _ check _ box . data _ bindings . add ( new system . windows . forms . binding ( STR , this . binding _ configuration , STR , true ) ) ; this . ping _ check _ box . location = new system . drawing . point ( NUM , NUM ) ; this . ping _ check _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ;
this . ping _ check _ box . auto _ size = true ; this . ping _ check _ box . data _ bindings . add ( new system . windows . forms . binding ( STR , this . binding _ configuration , STR , true ) ) ; this . ping _ check _ box . location = new system . drawing . point ( NUM , NUM ) ; this . ping _ check _ box . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . ping _ check _ box . name = STR ; this . ping _ check _ box . size = new system . drawing . size ( NUM , NUM ) ; this . ping _ check _ box . tab _ index = NUM ; this . ping _ check _ box . text = STR ; this . ping _ check _ box . use _ visual _ style _ back _ color = true ; this . ping _ check _ box . checked _ changed + = new system . event _ handler ( this . ping _ check _ box _ checked _ changed ) ;
this . chart _ mode _ selector . resume _ layout ( false ) ; this . chart _ mode _ selector . perform _ layout ( ) ; this . split _ container . panel . resume _ layout ( false ) ; this . split _ container . panel . resume _ layout ( false ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . end _ init ( ) ; this . split _ container . resume _ layout ( false ) ; this . split _ container . panel . resume _ layout ( false ) ; this . split _ container . panel . perform _ layout ( ) ; this . split _ container . panel . resume _ layout ( false ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . end _ init ( ) ;
public static readonly mode byte = new mode ( new int [ ] { NUM , NUM , NUM } , 0 , STR ) ; private readonly int [ ] character _ count _ bits _ for _ versions ; private readonly int bits ; private readonly string name ; private mode ( int [ ] character _ count _ bits _ for _ versions , int bits , system . string name )
private readonly int [ ] character _ count _ bits _ for _ versions ; private readonly int bits ; private readonly string name ; private mode ( int [ ] character _ count _ bits _ for _ versions , int bits , system . string name ) { this . character _ count _ bits _ for _ versions = character _ count _ bits _ for _ versions ; this . bits = bits ; this . name = name ; } public static mode for _ bits ( int bits )
case 0 : return byte ;
default : throw new argument _ exception ( ) ; } } public int get _ character _ count _ bits ( version version ) { if ( character _ count _ bits _ for _ versions = = null ) { throw new argument _ exception ( STR ) ; }
public static generic _ gf qr _ code _ field = new generic _ gf ( 0 d , NUM , 0 ) ; private int [ ] exp _ table ; private int [ ] log _ table ; private generic _ gf _ poly zero ; private generic _ gf _ poly one ; private readonly int size ; private readonly int primitive ;
private int [ ] exp _ table ; private int [ ] log _ table ; private generic _ gf _ poly zero ; private generic _ gf _ poly one ; private readonly int size ; private readonly int primitive ; private readonly int generator _ base ; public generic _ gf ( int primitive , int size , int gen _ base ) { this . primitive = primitive ;
{ private static logger logger = log _ manager . get _ current _ class _ logger ( ) ; public static event event _ handler < geosite _ result _ event _ args > update _ completed ;
public static event error _ event _ handler error ; private static readonly string database _ path = utils . get _ temp _ path ( STR ) ; private static readonly string geosite _ url = STR ; public static readonly dictionary < string , i _ list < domain _ object > > geosites = new dictionary < string , i _ list < domain _ object > > ( ) ; static geosite _ updater ( ) { if ( ! file . exists ( database _ path ) ) { file . write _ all _ bytes ( database _ path , resources . dlc _ dat ) ; }
} update _ system _ proxy ( ) ; } public server get _ current _ server ( ) { return config . get _ current _ server ( ) ; } public configuration get _ configuration ( ) { return configuration . load ( ) ;
if ( methodname . is _ null _ or _ empty ( ) ) throw new argument _ exception ( nameof ( methodname ) ) ; method _ info dyn _ method = typeof ( hotkey _ callbacks ) . get _ method ( methodname , binding _ flags . non _ public | binding _ flags . instance | binding _ flags . ignore _ case ) ; return dyn _ method = = null ? null : delegate . create _ delegate ( typeof ( hot _ keys . hot _ key _ call _ back _ handler ) , hotkey _ callbacks . instance , dyn _ method ) ; } } }
binding _ flags . non _ public | binding _ flags . instance | binding _ flags . ignore _ case ) ; return dyn _ method = = null ? null : delegate . create _ delegate ( typeof ( hot _ keys . hot _ key _ call _ back _ handler ) , hotkey _ callbacks . instance , dyn _ method ) ; } } }
} } }
using global _ hot _ key ; using system _ windows _ input ; using system _ threading ; using system _ collections _ generic ; using shadowsocks _ controller _ hotkeys ; namespace test { test _ class public class unit _ test {
{ public static class hot _ keys { private static hot _ key _ manager hot _ key _ manager ; public delegate void hot _ key _ call _ back _ handler ( ) ; private static dictionary < hot _ key , hot _ key _ call _ back _ handler > keymap = new dictionary < hot _ key , hot _ key _ call _ back _ handler > ( ) ; public static void init ( shadowsocks _ controller controller ) { hot _ key _ manager = new hot _ key _ manager ( ) ; hot _ key _ manager . key _ pressed + = hot _ key _ manager _ pressed ;
{ hot _ key _ manager = new hot _ key _ manager ( ) ; hot _ key _ manager . key _ pressed + = hot _ key _ manager _ pressed ; hotkey _ callbacks . init _ instance ( controller ) ; } public static void destroy ( ) { hot _ key _ manager . key _ pressed - = hot _ key _ manager _ pressed ; hot _ key _ manager . dispose ( ) ; }
int red = color . r * fly _ blue . r / NUM ; int green = color . g * fly _ blue . g / NUM ; int blue = color . b * fly _ blue . b / NUM ; int alpha = color . a * fly _ blue . a / NUM ; icon _ copy . set _ pixel ( x , y , color . from _ argb ( alpha , red , green , blue ) ) ; } else if ( global ) { color fly _ blue = color . from _ argb ( NUM , NUM , NUM ) ;
} else if ( global ) { color fly _ blue = color . from _ argb ( NUM , NUM , NUM ) ; int red = color . r * fly _ blue . r / NUM ; int green = color . g * fly _ blue . g / NUM ; int blue = color . b * fly _ blue . b / NUM ; icon _ copy . set _ pixel ( x , y , color . from _ argb ( color . a , red , green , blue ) ) ; } }
try { var strategy = get _ current _ strategy ( ) ; if ( strategy ! = null ) { strategy . reload _ servers ( ) ; } tcp _ relay tcp _ relay = new tcp _ relay ( this , config ) ; udp _ relay udp _ relay = new udp _ relay ( this ) ;
tcp _ relay tcp _ relay = new tcp _ relay ( this , config ) ; udp _ relay udp _ relay = new udp _ relay ( this ) ; list < listener . i _ service > services = new list < listener . i _ service > ( ) ; services . add ( tcp _ relay ) ; services . add ( udp _ relay ) ; services . add ( pac _ server ) ; listener = new listener ( services ) ; listener . start ( config ) ; }
listener = new listener ( services ) ; listener . start ( config ) ; } catch ( exception e ) { if ( e is socket _ exception ) { socket _ exception se = ( socket _ exception ) e ; if ( se . socket _ error _ code = = socket _ error . access _ denied ) {
dll _ import _ kernel _ dll private static extern bool set _ information _ job _ object ( int _ ptr h _ job , job _ object _ info _ type info _ type , int _ ptr lp _ job _ object _ info , u _ int cb _ job _ object _ info _ length ) ; dll _ import _ kernel _ dll _ set _ last _ error _ true private static extern bool assign _ process _ to _ job _ object ( int _ ptr job , int _ ptr process ) ; dll _ import _ kernel _ dll _ set _ last _ error _ true return _ marshal _ as _ unmanaged _ type _ bool private static extern bool close _ handle ( int _ ptr h _ object ) ; private int _ ptr handle ; private bool disposed ; public job ( )
dll _ import _ kernel _ dll _ set _ last _ error _ true private static extern bool assign _ process _ to _ job _ object ( int _ ptr job , int _ ptr process ) ; dll _ import _ kernel _ dll _ set _ last _ error _ true return _ marshal _ as _ unmanaged _ type _ bool private static extern bool close _ handle ( int _ ptr h _ object ) ; private int _ ptr handle ; private bool disposed ; public job ( ) { handle = create _ job _ object ( int _ ptr . zero , null ) ;
dll _ import _ kernel _ dll _ set _ last _ error _ true return _ marshal _ as _ unmanaged _ type _ bool private static extern bool close _ handle ( int _ ptr h _ object ) ; private int _ ptr handle ; private bool disposed ; public job ( ) { handle = create _ job _ object ( int _ ptr . zero , null ) ; var extended _ info _ ptr = int _ ptr . zero ; var info = new jobobject _ basic _ limit _ information
private int _ ptr handle ; private bool disposed ; public job ( ) { handle = create _ job _ object ( int _ ptr . zero , null ) ; var extended _ info _ ptr = int _ ptr . zero ; var info = new jobobject _ basic _ limit _ information { limit _ flags = 0 } ;
} public void dispose ( ) { dispose ( true ) ; gc . suppress _ finalize ( this ) ; } private void dispose ( bool disposing ) { if ( disposed ) return ;
servers _ list _ box . selected _ index = modified _ configuration . index ; load _ selected _ server ( ) ; enable _ item . checked = modified _ configuration . enabled ; } private void config _ form _ load ( object sender , event _ args e ) { if ( ! controller . get _ configuration ( ) . is _ default ) { this . opacity = 0 ; begin _ invoke ( new method _ invoker ( delegate
enable _ item . checked = modified _ configuration . enabled ; } private void config _ form _ load ( object sender , event _ args e ) { if ( ! controller . get _ configuration ( ) . is _ default ) { this . opacity = 0 ; begin _ invoke ( new method _ invoker ( delegate { this . hide ( ) ;

using system _ collections _ generic ; using system _ runtime _ interop _ services ; using system _ text ; namespace shadowsocks _ csharp _ encrypt { public class openssl _ encryptor : encryptor _ base , i _ disposable { static dictionary < string , int [ ] > ciphers = new dictionary < string , int [ ] > { { STR , new int [ ] { NUM , NUM } } ,
byte [ ] iv = new byte [ iv _ len ] ; open _ ssl . rand _ bytes ( iv , iv . length ) ; init _ cipher ( ref encrypt _ ctx , iv , true ) ; int out _ len = length + iv _ len ; byte [ ] cipher _ text = new byte [ out _ len ] ; open _ ssl . evp _ cipher _ update ( encrypt _ ctx , cipher _ text , out out _ len , buf , length ) ; byte [ ] result = new byte [ out _ len + iv _ len ] ; buffer . block _ copy ( iv , 0 , result , 0 , iv _ len ) ; buffer . block _ copy ( cipher _ text , 0 , result , iv _ len , out _ len ) ; return result ;
init _ cipher ( ref encrypt _ ctx , iv , true ) ; int out _ len = length + iv _ len ; byte [ ] cipher _ text = new byte [ out _ len ] ; open _ ssl . evp _ cipher _ update ( encrypt _ ctx , cipher _ text , out out _ len , buf , length ) ; byte [ ] result = new byte [ out _ len + iv _ len ] ; buffer . block _ copy ( iv , 0 , result , 0 , iv _ len ) ; buffer . block _ copy ( cipher _ text , 0 , result , iv _ len , out _ len ) ; return result ; } else
byte [ ] cipher _ text = new byte [ out _ len ] ; open _ ssl . evp _ cipher _ update ( encrypt _ ctx , cipher _ text , out out _ len , buf , length ) ; byte [ ] result = new byte [ out _ len + iv _ len ] ; buffer . block _ copy ( iv , 0 , result , 0 , iv _ len ) ; buffer . block _ copy ( cipher _ text , 0 , result , iv _ len , out _ len ) ; return result ; } else { int out _ len = length + iv _ len ;
byte [ ] result = new byte [ out _ len + iv _ len ] ; buffer . block _ copy ( iv , 0 , result , 0 , iv _ len ) ; buffer . block _ copy ( cipher _ text , 0 , result , iv _ len , out _ len ) ; return result ; } else { int out _ len = length + iv _ len ; byte [ ] cipher _ text = new byte [ out _ len ] ; open _ ssl . evp _ cipher _ update ( encrypt _ ctx , cipher _ text , out out _ len , buf , length ) ;
byte [ ] cipher _ text = new byte [ out _ len ] ; open _ ssl . evp _ cipher _ update ( encrypt _ ctx , cipher _ text , out out _ len , buf , length ) ; byte [ ] result = new byte [ out _ len ] ; buffer . block _ copy ( cipher _ text , 0 , result , 0 , out _ len ) ; return result ; } } public override byte [ ] decrypt ( byte [ ] buf , int length ) { if ( decrypt _ ctx = = int _ ptr . zero )
byte [ ] result = new byte [ out _ len ] ; buffer . block _ copy ( cipher _ text , 0 , result , 0 , out _ len ) ; return result ; } } public override byte [ ] decrypt ( byte [ ] buf , int length ) { if ( decrypt _ ctx = = int _ ptr . zero ) {
byte [ ] iv = new byte [ iv _ len ] ; buffer . block _ copy ( buf , 0 , iv , 0 , iv _ len ) ; init _ cipher ( ref decrypt _ ctx , iv , false ) ; int out _ len = length + iv _ len ; out _ len - = iv _ len ; byte [ ] cipher _ text = new byte [ out _ len ] ; byte [ ] subset = new byte [ length - iv _ len ] ; buffer . block _ copy ( buf , iv _ len , subset , 0 , length - iv _ len ) ; open _ ssl . evp _ cipher _ update ( decrypt _ ctx , cipher _ text , out out _ len , subset , length - iv _ len ) ; byte [ ] result = new byte [ out _ len ] ;
out _ len - = iv _ len ; byte [ ] cipher _ text = new byte [ out _ len ] ; byte [ ] subset = new byte [ length - iv _ len ] ; buffer . block _ copy ( buf , iv _ len , subset , 0 , length - iv _ len ) ; open _ ssl . evp _ cipher _ update ( decrypt _ ctx , cipher _ text , out out _ len , subset , length - iv _ len ) ; byte [ ] result = new byte [ out _ len ] ; buffer . block _ copy ( cipher _ text , 0 , result , 0 , out _ len ) ; return result ; } else
byte [ ] result = new byte [ out _ len ] ; buffer . block _ copy ( cipher _ text , 0 , result , 0 , out _ len ) ; return result ; } else { int out _ len = length + iv _ len ; byte [ ] cipher _ text = new byte [ out _ len ] ; open _ ssl . evp _ cipher _ update ( decrypt _ ctx , cipher _ text , out out _ len , buf , length ) ; byte [ ] result = new byte [ out _ len ] ;
byte [ ] cipher _ text = new byte [ out _ len ] ; open _ ssl . evp _ cipher _ update ( decrypt _ ctx , cipher _ text , out out _ len , buf , length ) ; byte [ ] result = new byte [ out _ len ] ; buffer . block _ copy ( cipher _ text , 0 , result , 0 , out _ len ) ; return result ; } } private static readonly dictionary < string , byte [ ] > cached _ keys = new dictionary < string , byte [ ] > ( ) ; private byte [ ] key ;
byte [ ] result = new byte [ out _ len ] ; buffer . block _ copy ( cipher _ text , 0 , result , 0 , out _ len ) ; return result ; } } private static readonly dictionary < string , byte [ ] > cached _ keys = new dictionary < string , byte [ ] > ( ) ; private byte [ ] key ; private int _ ptr encrypt _ ctx ;
private byte [ ] key ; private int _ ptr encrypt _ ctx ; private int _ ptr decrypt _ ctx ; private int _ ptr cipher ; private int key _ len ; private int iv _ len ; private void init _ key ( string method , string password ) { open _ ssl . open _ ssl _ add _ all _ ciphers ( ) ;
private int _ ptr encrypt _ ctx ; private int _ ptr decrypt _ ctx ; private int _ ptr cipher ; private int key _ len ; private int iv _ len ; private void init _ key ( string method , string password ) { open _ ssl . open _ ssl _ add _ all _ ciphers ( ) ; method = method . to _ lower ( ) ; string k = method + STR + password ;
} else { byte [ ] passbuf = encoding . ut . get _ bytes ( password ) ; key = new byte [ NUM ] ; byte [ ] iv = new byte [ NUM ] ; open _ ssl . evp _ bytes _ to _ key ( cipher , open _ ssl . evp _ md ( ) , int _ ptr . zero , passbuf , passbuf . length , 1 , key , iv ) ; cached _ keys [ k ] = key ;
{ byte [ ] passbuf = encoding . ut . get _ bytes ( password ) ; key = new byte [ NUM ] ; byte [ ] iv = new byte [ NUM ] ; open _ ssl . evp _ bytes _ to _ key ( cipher , open _ ssl . evp _ md ( ) , int _ ptr . zero , passbuf , passbuf . length , 1 , key , iv ) ; cached _ keys [ k ] = key ; }
} } private void init _ cipher ( ref int _ ptr ctx , byte [ ] iv , bool is _ cipher ) {
} private void init _ cipher ( ref int _ ptr ctx , byte [ ] iv , bool is _ cipher ) { ctx = open _ ssl . evp _ cipher _ ctx _ new ( ) ; int enc = is _ cipher ? 1 : 0 ; open _ ssl . evp _ cipher _ init _ ex ( ctx , cipher , int _ ptr . zero , key , iv , enc ) ;
int enc = is _ cipher ? 1 : 0 ; open _ ssl . evp _ cipher _ init _ ex ( ctx , cipher , int _ ptr . zero , key , iv , enc ) ; } private bool disposed ; public void dispose ( )
} private bool disposed ; public void dispose ( ) { dispose ( true ) ; gc . suppress _ finalize ( this ) ; } ~ openssl _ encryptor ( ) { dispose ( false ) ;
availability _ statistics . update _ configuration ( this ) ; listener ? . stop ( ) ; stop _ plugins ( ) ; privoxy _ runner . stop ( ) ; try {
stop _ plugins ( ) ; privoxy _ runner . stop ( ) ; try { var strategy = get _ current _ strategy ( ) ; strategy ? . reload _ servers ( ) ;
start _ plugin ( ) ; privoxy _ runner . start ( config ) ; tcp _ relay tcp _ relay = new tcp _ relay ( this , config ) ; udp _ relay udp _ relay = new udp _ relay ( this ) ; list < listener . i _ service > services = new list < listener . i _ service > { tcp _ relay , udp _ relay , pac _ server , new port _ forwarder ( privoxy _ runner . running _ port )
} catch ( exception e ) { logging . log _ useful _ exception ( e ) ; return false ; } } public static bool check ( ) { try
}

new menu _ item ( STR ) , create _ menu _ item ( STR , new event _ handler ( this . show _ log _ item _ click ) ) , create _ menu _ item ( STR , new event _ handler ( this . about _ item _ click ) ) , new menu _ item ( STR ) , create _ menu _ item ( STR , new event _ handler ( this . quit _ click ) ) } ) ; } private void controller _ config _ changed ( object sender , event _ args e ) { load _ current _ configuration ( ) ;
{ console . write _ line ( e . to _ string ( ) ) ; } process = null ; } } } }
return remarks . is _ null _ or _ empty ( ) ? server _ str : $ STR ; } public string format _ host _ name ( string host _ name ) { switch ( uri . check _ host _ name ( host _ name ) ) { case uri _ host _ name _ type . i _ pv : return $ STR ;
private static string get _ timestamp ( date _ time value ) { return value . to _ string ( STR ) ; } public static void update ( configuration config , bool force _ disable , pac _ server pac _ srv , bool no _ retry = false ) { bool global = config . global ; bool enabled = config . enabled ; if ( force _ disable )
{ bool global = config . global ; bool enabled = config . enabled ; if ( force _ disable ) { enabled = false ; } try {
bool global = config . global ; bool enabled = config . enabled ; if ( force _ disable ) { enabled = false ; } try { if ( enabled ) {
{ var ret = message _ box . show ( n . get _ string ( STR ) , n . get _ string ( STR ) , message _ box _ buttons . yes _ no , message _ box _ icon . warning ) ; if ( ret = = dialog _ result . yes ) { sysproxy . reset _ ie _ proxy ( ) ; update ( config , force _ disable , pac _ srv , true ) ; } } else {
} } } } }
{ settings _ return = internet _ set _ option ( int _ ptr . zero , internet _ option _ settings _ changed , int _ ptr . zero , 0 ) ; refresh _ return = internet _ set _ option ( int _ ptr . zero , internet _ option _ refresh , int _ ptr . zero , 0 ) ; } public static void enable ( ) { registry _ key registry = registry . current _ user . open _ sub _ key ( STR , true ) ;
settings _ return = internet _ set _ option ( int _ ptr . zero , internet _ option _ settings _ changed , int _ ptr . zero , 0 ) ; refresh _ return = internet _ set _ option ( int _ ptr . zero , internet _ option _ refresh , int _ ptr . zero , 0 ) ; } public static void enable ( ) { registry _ key registry = registry . current _ user . open _ sub _ key ( STR , true ) ; registry . set _ value ( STR , 1 ) ; registry . set _ value ( STR , STR ) ; system _ proxy . update _ ie ( ) ; }
{ registry _ key registry = registry . current _ user . open _ sub _ key ( STR , true ) ; registry . set _ value ( STR , 0 ) ; registry . set _ value ( STR , STR ) ; system _ proxy . update _ ie ( ) ; } } }
} } }
public class availability _ statistics { public static readonly string date _ time _ pattern = STR ; private const string statistics _ files _ name = STR ; private const string delimiter = STR ; private const int timeout = NUM ; private const int delay _ before _ start = NUM ; public statistics raw _ statistics { get ; private set ; } public statistics filtered _ statistics { get ; private set ; } private int repeat = > config . repeat _ times _ num ;
private const int retry _ interval = 2 * NUM * NUM ; private int interval = > ( int ) time _ span . from _ minutes ( config . data _ collection _ minutes ) . total _ milliseconds ; private timer timer ; private state state ; private list < server > servers ; private statistics _ strategy _ configuration config ; public static string availability _ statistics _ file ; static availability _ statistics ( ) { var temppath = utils . get _ temp _ path ( ) ;
ret . add ( new list < key _ value _ pair < string , string > > { new key _ value _ pair < string , string > ( STR , timestamp ) , new key _ value _ pair < string , string > ( STR , server . friendly _ name ( ) ) , new key _ value _ pair < string , string > ( STR , reply ? . status . to _ string ( ) ) , new key _ value _ pair < string , string > ( STR , reply ? . roundtrip _ time . to _ string ( ) ) } ) ; thread . sleep ( timeout + new random ( ) . next ( ) % timeout ) ; } catch ( exception e )
} catch ( exception e ) { console . write _ line ( $ STR ) ; logging . log _ useful _ exception ( e ) ; } } return ret ; } private void run ( object obj )
tcprelay . update _ outbound _ counter ( server , bytes _ to _ send ) ; start _ sending _ time = date _ time . now ; bytes _ to _ send = bytes _ to _ send ; remote . begin _ send ( connetion _ send _ buffer , 0 , bytes _ to _ send , 0 , new async _ callback ( pipe _ remote _ send _ callback ) , null ) ; i _ strategy strategy = controller . get _ current _ strategy ( ) ; strategy ? . update _ last _ write ( server ) ; } else { remote . shutdown ( socket _ shutdown . send ) ;
this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ; this . chart _ mode _ selector = new system . windows . forms . group _ box ( ) ; this . all _ mode = new system . windows . forms . radio _ button ( ) ; this . day _ mode = new system . windows . forms . radio _ button ( ) ; this . split _ container = new system . windows . forms . split _ container ( ) ; this . split _ container = new system . windows . forms . split _ container ( ) ; this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ;
this . chart _ mode _ selector = new system . windows . forms . group _ box ( ) ; this . all _ mode = new system . windows . forms . radio _ button ( ) ; this . day _ mode = new system . windows . forms . radio _ button ( ) ; this . split _ container = new system . windows . forms . split _ container ( ) ; this . split _ container = new system . windows . forms . split _ container ( ) ; this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ; this . data _ collection _ minutes _ num = new system . windows . forms . numeric _ up _ down ( ) ; this . statistics _ enabled _ check _ box = new system . windows . forms . check _ box ( ) ; this . choice _ kept _ minutes _ num = new system . windows . forms . numeric _ up _ down ( ) ;
private system . windows . forms . label label ; private system . windows . forms . label label ; private system . windows . forms . group _ box chart _ mode _ selector ; private system . windows . forms . radio _ button all _ mode ; private system . windows . forms . radio _ button day _ mode ; private system . windows . forms . split _ container split _ container ; private system . windows . forms . label label ; private system . windows . forms . split _ container split _ container ; private system . windows . forms . flow _ layout _ panel calculation _ container ;
private system . windows . forms . group _ box chart _ mode _ selector ; private system . windows . forms . radio _ button all _ mode ; private system . windows . forms . radio _ button day _ mode ; private system . windows . forms . split _ container split _ container ; private system . windows . forms . label label ; private system . windows . forms . split _ container split _ container ; private system . windows . forms . flow _ layout _ panel calculation _ container ; private system . windows . forms . split _ container split _ container ; private system . windows . forms . numeric _ up _ down repeat _ times _ num ; private system . windows . forms . label label ;
public static string availability _ statistics _ file ;
static availability _ statistics ( ) { availability _ statistics _ file = utils . get _ temp _ path ( statistics _ files _ name ) ; unknown _ date _ time = new date _ time ( NUM , 1 , 1 ) ; } private int repeat = > config . repeat _ times _ num ; private const int timeout _ milliseconds = NUM ; private list < int > latency _ records ; private long last _ inbound _ counter ; private list < int > inbound _ speed _ records ;
public static availability _ statistics instance { get ; } = new availability _ statistics ( ) ; public statistics raw _ statistics { get ; private set ; } public statistics filtered _ statistics { get ; private set ; } private availability _ statistics ( ) { raw _ statistics = new statistics ( ) ; } internal void update _ configuration ( shadowsocks _ controller controller ) { controller = controller ;
load _ raw _ statistics ( ) ; start _ timer _ without _ state ( ref speed _ monior , update _ speed , monitor _ interval ) ; start _ timer _ without _ state ( ref writer , save , writing _ interval ) ;
} else { recorder ? . dispose ( ) ; speed _ monior ? . dispose ( ) ; writer ? . dispose ( ) ; } } catch ( exception e ) {
} catch ( exception e ) { logging . log _ useful _ exception ( e ) ; } } private void start _ timer _ without _ state ( ref timer timer , timer _ callback callback , time _ span interval ) { if ( timer ? . change ( delay _ before _ start , interval ) = = null ) {
{ var bytes = controller . inbound _ counter - last _ inbound _ counter ; last _ inbound _ counter = controller . inbound _ counter ; var inbound _ speed = get _ speed _ in _ ki _ b _ per _ second ( bytes , monitor _ interval . total _ seconds ) ; inbound _ speed _ records . add ( inbound _ speed ) ; bytes = controller . outbound _ counter - last _ outbound _ counter ; last _ outbound _ counter = controller . outbound _ counter ; var outbound _ speed = get _ speed _ in _ ki _ b _ per _ second ( bytes , monitor _ interval . total _ seconds ) ; outbound _ speed _ records . add ( outbound _ speed ) ; logging . debug (
reset ( ) ; filter _ raw _ statistics ( ) ; } private async void update _ records ( ) { var current _ server _ record = new statistics _ record ( current _ server . identifier ( ) , inbound _ speed _ records , outbound _ speed _ records , latency _ records ) ; if ( ! config . ping ) { append _ record ( current _ server , current _ server _ record ) ; return ;
foreach ( var result in ( await icmp _ results ) . where ( result = > result ! = null ) ) { if ( result . server . equals ( current _ server ) ) { current _ server _ record . set _ response ( result . roundtrip _ time ) ;
{ current _ server _ record . set _ response ( result . roundtrip _ time ) ; append _ record ( current _ server , current _ server _ record ) ; } else { append _ record ( result . server , new statistics _ record ( result . server . identifier ( ) , result . roundtrip _ time ) ) ; } } }
} else { append _ record ( result . server , new statistics _ record ( result . server . identifier ( ) , result . roundtrip _ time ) ) ; } } } private void append _ record ( server server , statistics _ record record ) { list < statistics _ record > records ;
} private void save ( object ) { try { file . write _ all _ text ( availability _ statistics _ file , json _ convert . serialize _ object ( raw _ statistics , formatting . none ) ) ; } catch ( io _ exception e ) {
private bool is _ valid _ record ( statistics _ record record ) { if ( config . by _ hour _ of _ day ) { if ( record . timestamp = = unknown _ date _ time ) return false ; if ( ! record . timestamp . hour . equals ( date _ time . now . hour ) ) return false ; } return true ; }
if ( record . timestamp = = unknown _ date _ time ) return false ; if ( ! record . timestamp . hour . equals ( date _ time . now . hour ) ) return false ; } return true ; } private void filter _ raw _ statistics ( ) { if ( raw _ statistics = = null ) return ; if ( filtered _ statistics = = null ) {
{ choose _ new _ server ( controller . get _ current _ configuration ( ) . configs ) ; } return current _ server ; } public void reload _ servers ( ) {
} return current _ server ; } public void reload _ servers ( ) { choose _ new _ server ( controller . get _ current _ configuration ( ) . configs ) ; timer ? . change ( 0 , choice _ kept _ milliseconds ) ; } public void set _ failure ( server server ) {
} private void clean _ logs _ button _ click ( object sender , event _ args e ) { do _ clean _ logs ( ) ; } private void do _ change _ font ( ) { try {
{ try { font _ dialog fd = new font _ dialog ( ) ; fd . font = log _ message _ text _ box . font ; if ( fd . show _ dialog ( ) = = dialog _ result . ok ) { log _ message _ text _ box . font = new font ( fd . font . font _ family , fd . font . size , fd . font . style ) ; } }
} } }
this . file _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . open _ location _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . exit _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . view _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . clean _ logs _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . change _ font _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . wrap _ text _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . top _ most _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . menu _ item _ separater = new system . windows . forms . menu _ item ( ) ; this . show _ toolbar _ menu _ item = new system . windows . forms . menu _ item ( ) ;
this . change _ font _ button = new system . windows . forms . button ( ) ; this . clean _ logs _ button = new system . windows . forms . button ( ) ; this . wrap _ text _ check _ box = new system . windows . forms . check _ box ( ) ; this . table _ layout _ panel = new system . windows . forms . table _ layout _ panel ( ) ; this . toolbar _ flow _ layout _ panel = new system . windows . forms . flow _ layout _ panel ( ) ; this . table _ layout _ panel . suspend _ layout ( ) ; this . toolbar _ flow _ layout _ panel . suspend _ layout ( ) ;
this . table _ layout _ panel . suspend _ layout ( ) ; this . toolbar _ flow _ layout _ panel . suspend _ layout ( ) ;
this . change _ font _ button . auto _ size = true ; this . change _ font _ button . location = new system . drawing . point ( NUM , NUM ) ; this . change _ font _ button . name = STR ; this . change _ font _ button . size = new system . drawing . size ( NUM , NUM ) ; this . change _ font _ button . tab _ index = 2 ; this . change _ font _ button . text = STR ; this . change _ font _ button . use _ visual _ style _ back _ color = true ; this . change _ font _ button . click + = new system . event _ handler ( this . change _ font _ button _ click ) ; this . clean _ logs _ button . auto _ size = true ; this . clean _ logs _ button . location = new system . drawing . point ( NUM , NUM ) ;
this . change _ font _ button . name = STR ; this . change _ font _ button . size = new system . drawing . size ( NUM , NUM ) ; this . change _ font _ button . tab _ index = 2 ; this . change _ font _ button . text = STR ; this . change _ font _ button . use _ visual _ style _ back _ color = true ; this . change _ font _ button . click + = new system . event _ handler ( this . change _ font _ button _ click ) ; this . clean _ logs _ button . auto _ size = true ; this . clean _ logs _ button . location = new system . drawing . point ( NUM , NUM ) ; this . clean _ logs _ button . name = STR ; this . clean _ logs _ button . size = new system . drawing . size ( NUM , NUM ) ;
this . clean _ logs _ button . name = STR ; this . clean _ logs _ button . size = new system . drawing . size ( NUM , NUM ) ; this . clean _ logs _ button . tab _ index = 1 ; this . clean _ logs _ button . text = STR ; this . clean _ logs _ button . use _ visual _ style _ back _ color = true ; this . clean _ logs _ button . click + = new system . event _ handler ( this . clean _ logs _ button _ click ) ; this . wrap _ text _ check _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( ( system . windows . forms . anchor _ styles . top | system . windows . forms . anchor _ styles . bottom ) | system . windows . forms . anchor _ styles . left ) ) ) ; this . wrap _ text _ check _ box . auto _ size = true ; this . wrap _ text _ check _ box . location = new system . drawing . point ( NUM , NUM ) ;
this . table _ layout _ panel . controls . add ( this . log _ message _ text _ box , 0 , 1 ) ; this . table _ layout _ panel . controls . add ( this . toolbar _ flow _ layout _ panel , 0 , 0 ) ; this . table _ layout _ panel . dock = system . windows . forms . dock _ style . fill ; this . table _ layout _ panel . location = new system . drawing . point ( 0 , 0 ) ; this . table _ layout _ panel . name = STR ; this . table _ layout _ panel . row _ count = 2 ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ; this . table _ layout _ panel . tab _ index = 2 ;
this . table _ layout _ panel . tab _ index = 2 ; this . toolbar _ flow _ layout _ panel . auto _ size = true ; this . toolbar _ flow _ layout _ panel . controls . add ( this . clean _ logs _ button ) ; this . toolbar _ flow _ layout _ panel . controls . add ( this . change _ font _ button ) ; this . toolbar _ flow _ layout _ panel . controls . add ( this . wrap _ text _ check _ box ) ; this . toolbar _ flow _ layout _ panel . controls . add ( this . top _ most _ check _ box ) ; this . toolbar _ flow _ layout _ panel . dock = system . windows . forms . dock _ style . fill ; this . toolbar _ flow _ layout _ panel . location = new system . drawing . point ( NUM , NUM ) ; this . toolbar _ flow _ layout _ panel . name = STR ; this . toolbar _ flow _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ;

this . table _ layout _ panel . resume _ layout ( false ) ; this . table _ layout _ panel . perform _ layout ( ) ; this . toolbar _ flow _ layout _ panel . resume _ layout ( false ) ; this . toolbar _ flow _ layout _ panel . perform _ layout ( ) ; this . resume _ layout ( false ) ; } private system . windows . forms . text _ box log _ message _ text _ box ; private system . windows . forms . main _ menu main _ menu ; private system . windows . forms . menu _ item file _ menu _ item ;
private system . windows . forms . menu _ item file _ menu _ item ; private system . windows . forms . menu _ item open _ location _ menu _ item ; private system . windows . forms . menu _ item exit _ menu _ item ; private system . windows . forms . check _ box wrap _ text _ check _ box ; private system . windows . forms . button clean _ logs _ button ; private system . windows . forms . button change _ font _ button ; private system . windows . forms . table _ layout _ panel table _ layout _ panel ; private system . windows . forms . check _ box top _ most _ check _ box ; private system . windows . forms . menu _ item view _ menu _ item ;
private system . windows . forms . check _ box wrap _ text _ check _ box ; private system . windows . forms . button clean _ logs _ button ; private system . windows . forms . button change _ font _ button ; private system . windows . forms . table _ layout _ panel table _ layout _ panel ; private system . windows . forms . check _ box top _ most _ check _ box ; private system . windows . forms . menu _ item view _ menu _ item ; private system . windows . forms . menu _ item clean _ logs _ menu _ item ; private system . windows . forms . menu _ item change _ font _ menu _ item ; private system . windows . forms . menu _ item wrap _ text _ menu _ item ; private system . windows . forms . menu _ item top _ most _ menu _ item ;
public port _ forwarder ( int target _ port ) { target _ port = target _ port ; } public override bool handle ( byte [ ] first _ packet , int length , socket socket , object state ) { if ( socket . protocol _ type ! = protocol _ type . tcp ) { return false ; }
} public override bool handle ( byte [ ] first _ packet , int length , socket socket , object state ) { if ( socket . protocol _ type ! = protocol _ type . tcp ) { return false ; } new handler ( ) . start ( first _ packet , length , socket , target _ port ) ; return true ; }
return true ; } private class handler { private byte [ ] first _ packet ; private int first _ packet _ length ; private socket local ; private wrapped _ socket remote ; private bool closed = false ; private bool local _ shutdown = false ;
{ private byte [ ] first _ packet ; private int first _ packet _ length ; private socket local ; private wrapped _ socket remote ; private bool closed = false ; private bool local _ shutdown = false ; private bool remote _ shutdown = false ; private const int recv _ size = NUM ; private byte [ ] remote _ recv _ buffer = new byte [ recv _ size ] ;
private byte [ ] remote _ recv _ buffer = new byte [ recv _ size ] ; private byte [ ] connetion _ recv _ buffer = new byte [ recv _ size ] ; private readonly object lock = new object ( ) ; public void start ( byte [ ] first _ packet , int length , socket socket , int target _ port ) { first _ packet = first _ packet ; first _ packet _ length = length ; local = socket ; try {
try { end _ point remote _ ep = socket _ util . get _ end _ point ( STR , target _ port ) ; remote = new wrapped _ socket ( ) ; remote . begin _ connect ( remote _ ep , connect _ callback , null ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ;
} } private void connect _ callback ( i _ async _ result ar ) { if ( closed ) { return ; } try {
local . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , 0 , pipe _ connection _ receive _ callback , null ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; } } private void pipe _ remote _ receive _ callback ( i _ async _ result ar )
} } private void pipe _ remote _ receive _ callback ( i _ async _ result ar ) { if ( closed ) { return ; } try {
} } private void check _ close ( ) { if ( local _ shutdown & & remote _ shutdown ) { close ( ) ; } } public void close ( )
} } public void close ( ) { lock ( lock ) { if ( closed ) { return ; }
key = cached _ keys [ k ] ;
} protected void bytes _ to _ key ( byte [ ] password , byte [ ] key ) { byte [ ] result = new byte [ password . length + NUM ] ; int i = 0 ; byte [ ] md _ sum = null ; while ( i < key . length ) { if ( i = = 0 ) {
{ public class direct _ connect : i _ forward _ proxy { private class fake _ async _ result : i _ async _ result { public fake _ async _ result ( object state ) { async _ state = state ; } public bool is _ completed { get ; } = true ;
{ private class fake _ async _ result : i _ async _ result { public fake _ async _ result ( object state ) { async _ state = state ; } public bool is _ completed { get ; } = true ; public wait _ handle async _ wait _ handle { get ; } = null ; public object async _ state { get ; }
{ public class http _ proxy : i _ forward _ proxy { private class fake _ async _ result : i _ async _ result { public readonly http _ state inner _ state ; private readonly i _ async _ result r ; public fake _ async _ result ( i _ async _ result orig , http _ state state ) { r = orig ;
{ private class fake _ async _ result : i _ async _ result { public readonly http _ state inner _ state ; private readonly i _ async _ result r ; public fake _ async _ result ( i _ async _ result orig , http _ state state ) { r = orig ; inner _ state = state ; }
using shadowsocks _ util _ sockets ; namespace shadowsocks _ controller { class tcp _ relay : listener . service { private shadowsocks _ controller controller ; private date _ time last _ sweep _ time ; private configuration config ; public i _ set < tcp _ handler > handlers { get ; set ; } public tcp _ relay ( shadowsocks _ controller controller , configuration conf )
{ public interface i _ forward _ proxy { end _ point local _ end _ point { get ; } end _ point proxy _ end _ point { get ; } end _ point dest _ end _ point { get ; } void begin _ connect _ proxy ( end _ point remote _ ep , async _ callback callback , object state ) ; void end _ connect _ proxy ( i _ async _ result async _ result ) ; void begin _ connect _ dest ( end _ point dest _ end _ point , async _ callback callback , object state ) ; void end _ connect _ dest ( i _ async _ result async _ result ) ;
{ end _ point local _ end _ point { get ; } end _ point proxy _ end _ point { get ; } end _ point dest _ end _ point { get ; } void begin _ connect _ proxy ( end _ point remote _ ep , async _ callback callback , object state ) ; void end _ connect _ proxy ( i _ async _ result async _ result ) ; void begin _ connect _ dest ( end _ point dest _ end _ point , async _ callback callback , object state ) ; void end _ connect _ dest ( i _ async _ result async _ result ) ; void begin _ send ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) ;
{ public class socks _ proxy : i _ forward _ proxy { private class fake _ async _ result : i _ async _ result { public readonly socks _ state inner _ state ; private readonly i _ async _ result r ; public fake _ async _ result ( i _ async _ result orig , socks _ state state ) { r = orig ;
{ private class fake _ async _ result : i _ async _ result { public readonly socks _ state inner _ state ; private readonly i _ async _ result r ; public fake _ async _ result ( i _ async _ result orig , socks _ state state ) { r = orig ; inner _ state = state ; }
this . statistics _ chart = new system . windows . forms . data _ visualization . charting . chart ( ) ; this . by _ isp _ check _ box = new system . windows . forms . check _ box ( ) ; this . binding _ configuration = new system . windows . forms . binding _ source ( this . components ) ; this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ; this . group _ box = new system . windows . forms . group _ box ( ) ; this . radio _ button = new system . windows . forms . radio _ button ( ) ; this . radio _ button = new system . windows . forms . radio _ button ( ) ;
this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ; this . group _ box = new system . windows . forms . group _ box ( ) ; this . radio _ button = new system . windows . forms . radio _ button ( ) ; this . radio _ button = new system . windows . forms . radio _ button ( ) ; this . split _ container = new system . windows . forms . split _ container ( ) ; this . split _ container = new system . windows . forms . split _ container ( ) ; this . label = new system . windows . forms . label ( ) ; this . label = new system . windows . forms . label ( ) ;
this . label = new system . windows . forms . label ( ) ; this . split _ container = new system . windows . forms . split _ container ( ) ; this . label = new system . windows . forms . label ( ) ; this . calculation _ container = new system . windows . forms . flow _ layout _ panel ( ) ; this . ok _ button = new system . windows . forms . button ( ) ; this . cancel _ button = new system . windows . forms . button ( ) ;
( ( system . component _ model . i _ support _ initialize ) ( this . statistics _ chart ) ) . begin _ init ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . binding _ configuration ) ) . begin _ init ( ) ; this . group _ box . suspend _ layout ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . begin _ init ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . suspend _ layout ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . begin _ init ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . panel . suspend _ layout ( ) ;
( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . begin _ init ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . suspend _ layout ( ) ; this . suspend _ layout ( ) ; this . statistics _ chart . back _ color = system . drawing . color . transparent ; chart _ area . axis _ x . major _ grid . enabled = false ; chart _ area . axis _ y . major _ grid . enabled = false ;
this . suspend _ layout ( ) ; this . statistics _ chart . back _ color = system . drawing . color . transparent ; chart _ area . axis _ x . major _ grid . enabled = false ; chart _ area . axis _ y . major _ grid . enabled = false ; chart _ area . axis . major _ grid . enabled = false ; chart _ area . back _ color = system . drawing . color . transparent ; chart _ area . name = STR ; this . statistics _ chart . chart _ areas . add ( chart _ area ) ; this . statistics _ chart . dock = system . windows . forms . dock _ style . fill ; legend . back _ color = system . drawing . color . transparent ;
this . split _ container . panel . controls . add ( this . cancel _ button ) ; this . split _ container . panel . controls . add ( this . ok _ button ) ; this . split _ container . panel . controls . add ( this . group _ box ) ; this . split _ container . panel . controls . add ( this . statistics _ chart ) ; this . split _ container . size = new system . drawing . size ( NUM , NUM ) ; this . split _ container . splitter _ distance = NUM ; this . split _ container . splitter _ width = NUM ; this . split _ container . tab _ index = NUM ; this . split _ container . dock = system . windows . forms . dock _ style . fill ; this . split _ container . fixed _ panel = system . windows . forms . fixed _ panel . panel ;
this . split _ container . panel . controls . add ( this . label ) ; this . split _ container . panel . controls . add ( this . label ) ; this . split _ container . panel . controls . add ( this . label ) ; this . split _ container . panel . controls . add ( this . by _ isp _ check _ box ) ; this . split _ container . panel . controls . add ( this . label ) ; this . split _ container . panel . controls . add ( this . split _ container ) ; this . split _ container . size = new system . drawing . size ( NUM , NUM ) ; this . split _ container . splitter _ distance = NUM ; this . split _ container . splitter _ width = NUM ; this . split _ container . tab _ index = NUM ;
this . split _ container . panel . controls . add ( this . label ) ; this . split _ container . panel . controls . add ( this . split _ container ) ; this . split _ container . size = new system . drawing . size ( NUM , NUM ) ; this . split _ container . splitter _ distance = NUM ; this . split _ container . splitter _ width = NUM ; this . split _ container . tab _ index = NUM ; this . label . auto _ size = true ; this . label . location = new system . drawing . point ( NUM , NUM ) ; this . label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ; this . label . name = STR ;
NUM , 0 , 0 , 0 } ) ; this . data _ collection _ minutes _ num . location = new system . drawing . point ( NUM , NUM ) ; this . data _ collection _ minutes _ num . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . data _ collection _ minutes _ num . maximum = new decimal ( new int [ ] { NUM , 0 , 0 ,
NUM , 0 , 0 , 0 } ) ; this . label . auto _ size = true ; this . label . location = new system . drawing . point ( NUM , NUM ) ; this . label . name = STR ; this . label . size = new system . drawing . size ( NUM , NUM ) ; this . label . tab _ index = NUM ; this . label . text = STR ;
( ( system . component _ model . i _ support _ initialize ) ( this . statistics _ chart ) ) . end _ init ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . binding _ configuration ) ) . end _ init ( ) ; this . group _ box . resume _ layout ( false ) ; this . group _ box . perform _ layout ( ) ; this . split _ container . panel . resume _ layout ( false ) ; this . split _ container . panel . resume _ layout ( false ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . end _ init ( ) ; this . split _ container . resume _ layout ( false ) ; this . split _ container . panel . resume _ layout ( false ) ; this . split _ container . panel . perform _ layout ( ) ;
this . split _ container . panel . resume _ layout ( false ) ; this . split _ container . panel . perform _ layout ( ) ; this . split _ container . panel . resume _ layout ( false ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . end _ init ( ) ; this . split _ container . resume _ layout ( false ) ; this . resume _ layout ( false ) ;
this . resume _ layout ( false ) ; } private system . windows . forms . data _ visualization . charting . chart statistics _ chart ; private system . windows . forms . check _ box by _ isp _ check _ box ; private system . windows . forms . label label ; private system . windows . forms . label label ; private system . windows . forms . label label ; private system . windows . forms . group _ box group _ box ; private system . windows . forms . radio _ button radio _ button ; private system . windows . forms . radio _ button radio _ button ;
private system . windows . forms . label label ; private system . windows . forms . label label ; private system . windows . forms . label label ; private system . windows . forms . group _ box group _ box ; private system . windows . forms . radio _ button radio _ button ; private system . windows . forms . radio _ button radio _ button ; private system . windows . forms . split _ container split _ container ; private system . windows . forms . label label ; private system . windows . forms . split _ container split _ container ; private system . windows . forms . flow _ layout _ panel calculation _ container ;
private system . windows . forms . split _ container split _ container ; private system . windows . forms . numeric _ up _ down repeat _ times _ num ; private system . windows . forms . label label ; private system . windows . forms . check _ box by _ hour _ of _ day _ check _ box ;
private system . windows . forms . label label ; private system . windows . forms . check _ box by _ hour _ of _ day _ check _ box ; private system . windows . forms . numeric _ up _ down choice _ kept _ minutes _ num ; private system . windows . forms . check _ box statistics _ enabled _ check _ box ; private system . windows . forms . label label ; private system . windows . forms . label label ; private system . windows . forms . numeric _ up _ down data _ collection _ minutes _ num ; private system . windows . forms . binding _ source binding _ configuration ; private system . windows . forms . button cancel _ button ; private system . windows . forms . button ok _ button ;
} }
{ private readonly shadowsocks _ controller controller ; private server current _ server ; private readonly timer timer ; private dictionary < string , statistics _ data > statistics ; private const int cached _ interval = NUM * NUM * NUM ; private const int retry _ interval = 2 * NUM * NUM ; public class statistics _ data { public int success _ times ;
{ controller = controller ; var servers = controller . get _ current _ configuration ( ) . configs ; var random _ index = new random ( ) . next ( ) % servers . count ( ) ; current _ server = servers [ random _ index ] ; timer = new timer ( reload _ statistics _ and _ choose _ a _ server ) ; } private void reload _ statistics _ and _ choose _ a _ server ( object obj ) { logging . debug ( STR ) ;
{ var statistics _ strategy _ options _ form = new statistics _ strategy _ configuration _ form ( controller ) ;

current _ server = best _ result . server ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; } } public string id { get { return STR ; }
{ get { return STR ; } } public string name { get { return n . get _ string ( STR ) ; } } public server get _ a _ server ( i _ strategy _ caller _ type type , ip _ end _ point local _ ip _ end _ point ) { var old _ server = current _ server ;
{ get { return n . get _ string ( STR ) ; } } public server get _ a _ server ( i _ strategy _ caller _ type type , ip _ end _ point local _ ip _ end _ point ) { var old _ server = current _ server ; if ( old _ server = = null ) { choose _ new _ server ( controller . get _ current _ configuration ( ) . configs ) ; }
{ var old _ server = current _ server ; if ( old _ server = = null ) { choose _ new _ server ( controller . get _ current _ configuration ( ) . configs ) ; } if ( old _ server ! = current _ server ) { }
return current _ server ; } public void reload _ servers ( ) { choose _ new _ server ( controller . get _ current _ configuration ( ) . configs ) ; timer ? . change ( 0 , cached _ interval ) ; } public void set _ failure ( server server ) { logging . debug ( string . format ( STR , server . friendly _ name ( ) ) ) ;
{ choose _ new _ server ( controller . get _ current _ configuration ( ) . configs ) ; timer ? . change ( 0 , cached _ interval ) ; } public void set _ failure ( server server ) { logging . debug ( string . format ( STR , server . friendly _ name ( ) ) ) ; } public void update _ last _ read ( server server ) {
{ logging . debug ( string . format ( STR , server . friendly _ name ( ) ) ) ; } public void update _ last _ read ( server server ) { } public void update _ last _ write ( server server ) { } public void update _ latency ( server server , time _ span latency )
{ } public void update _ last _ write ( server server ) { } public void update _ latency ( server server , time _ span latency ) { } } }
{ } public void update _ latency ( server server , time _ span latency ) { } } }
{ } } }
load _ server _ name _ list _ to _ ui ( modified _ configuration ) ; servers _ list _ box . selected _ index = modified _ configuration . configs . count - 1 ; last _ selected _ index = servers _ list _ box . selected _ index ; } private void duplicate _ button _ click ( object sender , event _ args e ) { if ( last _ selected _ index = = - 1 | | last _ selected _ index > modified _ configuration . configs . count | | ! validate _ and _ save _ selected _ server _ details ( ) ) {
{ return ; } server curr _ server = modified _ configuration . configs [ last _ selected _ index ] ; var curr _ index = modified _ configuration . configs . index _ of ( curr _ server ) ; modified _ configuration . configs . insert ( curr _ index + 1 , curr _ server ) ; load _ server _ name _ list _ to _ ui ( modified _ configuration ) ; servers _ list _ box . selected _ index = curr _ index + 1 ; last _ selected _ index = servers _ list _ box . selected _ index ; }
} else if ( ! register ) { unregister _ application _ restart ( ) ; logging . debug ( STR ) ; } } } }
{ args = args ; if ( ! utils . is _ win _ vista _ or _ higher ( ) ) { message _ box . show ( n . get _ string ( STR ) , STR , message _ box _ buttons . ok , message _ box _ icon . error ) ; return ; } if ( ! utils . is _ supported _ runtime _ version ( ) ) {
} private byte [ ] merge _ sort ( byte [ ] array , ulong a , int j ) { if ( array . length = = 1 ) return array ; int middle = array . length / 2 ; byte [ ] left = new byte [ middle ] ; for ( int i = 0 ; i < middle ; i + + ) { left [ i ] = array [ i ] ;
{ if ( array . length = = 1 ) return array ; int middle = array . length / 2 ; byte [ ] left = new byte [ middle ] ; for ( int i = 0 ; i < middle ; i + + ) { left [ i ] = array [ i ] ; } byte [ ] right = new byte [ array . length - middle ] ;
socket _ type . stream , protocol _ type . tcp ) ; ip _ end _ point local _ end _ point = new ip _ end _ point ( 0 , port ) ; listener . bind ( local _ end _ point ) ; listener . listen ( NUM ) ; console . write _ line ( STR ) ; listener . begin _ accept ( new async _ callback ( accept _ callback ) , listener ) ; } public void stop ( )
application . enable _ visual _ styles ( ) ; application . set _ compatible _ text _ rendering _ default ( false ) ; application . run ( new form ( ) ) ; local . stop ( ) ; } } }
} else { remote . shutdown ( socket _ shutdown . send ) ; remote _ shutdown = true ; check _ close ( ) ; } } catch ( exception e ) {
private const string statistics _ files _ name = STR ; private const string delimiter = STR ; private const int timeout = NUM ; private readonly time _ span delay _ before _ start = time _ span . from _ seconds ( 1 ) ; public statistics raw _ statistics { get ; private set ; } public statistics filtered _ statistics { get ; private set ; } public static readonly date _ time unknown _ date _ time = new date _ time ( NUM , 1 , 1 ) ; private int repeat = > config . repeat _ times _ num ; private readonly time _ span retry _ interval = time _ span . from _ minutes ( 2 ) ; private time _ span interval = > time _ span . from _ minutes ( config . data _ collection _ minutes ) ;
public statistics raw _ statistics { get ; private set ; } public statistics filtered _ statistics { get ; private set ; } public static readonly date _ time unknown _ date _ time = new date _ time ( NUM , 1 , 1 ) ; private int repeat = > config . repeat _ times _ num ; private readonly time _ span retry _ interval = time _ span . from _ minutes ( 2 ) ; private time _ span interval = > time _ span . from _ minutes ( config . data _ collection _ minutes ) ; private timer timer ; private timer speed _ monior ; private state state ; private list < server > servers ;
private timer timer ; private timer speed _ monior ; private state state ; private list < server > servers ; private statistics _ strategy _ configuration config ; private const string empty = STR ; public static string availability _ statistics _ file ; private int inbound _ speed = 0 ; private int outbound _ speed = 0 ; private int? latency = 0 ;
} public bool set ( statistics _ strategy _ configuration config ) { config = config ; try { if ( config . statistics _ enabled ) { if ( timer ? . change ( delay _ before _ start , interval ) = = null ) {
append ( data _ list , geolocation _ and _ isp . result ) ; } } } private static void append ( data _ list data _ list , i _ enumerable < data _ unit > extra ) { var data = data _ list . concat ( extra ) ; var data _ line = string . join ( delimiter , data . select ( kv = > kv . value ) . to _ array ( ) ) ; string [ ] lines ; if ( ! file . exists ( availability _ statistics _ file ) )
try { process . kill ( ) ; process . wait _ for _ exit ( ) ; } catch ( invalid _ operation _ exception ) { } process = null ; }
{ ip _ global _ properties properties = ip _ global _ properties . get _ ip _ global _ properties ( ) ; ip _ end _ point [ ] tcp _ end _ points = properties . get _ active _ tcp _ listeners ( ) ; list < int > used _ ports = new list < int > ( ) ; foreach ( ip _ end _ point end _ point in ip _ global _ properties . get _ ip _ global _ properties ( ) . get _ active _ tcp _ listeners ( ) ) { used _ ports . add ( end _ point . port ) ; } for ( int port = default _ port ; port < NUM ; port + + ) {
} catch ( exception e ) { logging . log _ useful _ exception ( e ) ; return default _ port ; }
{ logging . log _ useful _ exception ( e ) ; return default _ port ; } throw new exception ( STR ) ; }
} throw new exception ( STR ) ; } } }
switch _ allow _ lan _ text _ box . text = config . switch _ allow _ lan ; show _ logs _ text _ box . text = config . show _ logs ; server _ move _ up _ text _ box . text = config . server _ move _ up ; server _ move _ down _ text _ box . text = config . server _ move _ down ; } private void update _ texts ( ) { switch _ system _ proxy _ label . text = n . get _ string ( STR ) ; switch _ proxy _ mode _ label . text = n . get _ string ( STR ) ;
switch _ allow _ lan _ label . text = n . get _ string ( STR ) ; show _ logs _ label . text = n . get _ string ( STR ) ; server _ move _ up _ label . text = n . get _ string ( STR ) ; server _ move _ down _ label . text = n . get _ string ( STR ) ; btn _ ok . text = n . get _ string ( STR ) ; btn _ cancel . text = n . get _ string ( STR ) ; btn _ register _ all . text = n . get _ string ( STR ) ; this . text = n . get _ string ( STR ) ; } private void hotkey _ down ( object sender , key _ event _ args e )
public string switch _ allow _ lan ; public string show _ logs ; public string server _ move _ up ; public string server _ move _ down ; public hotkey _ config ( ) { switch _ system _ proxy = STR ; switch _ system _ proxy _ mode = STR ;
switch _ allow _ lan = STR ; show _ logs = STR ; server _ move _ up = STR ; server _ move _ down = STR ; } } }
this . switch _ allow _ lan _ label = new system . windows . forms . label ( ) ; this . show _ logs _ label = new system . windows . forms . label ( ) ; this . server _ move _ up _ label = new system . windows . forms . label ( ) ; this . server _ move _ down _ label = new system . windows . forms . label ( ) ; this . switch _ system _ proxy _ text _ box = new system . windows . forms . text _ box ( ) ; this . switch _ proxy _ mode _ text _ box = new system . windows . forms . text _ box ( ) ; this . switch _ allow _ lan _ text _ box = new system . windows . forms . text _ box ( ) ; this . show _ logs _ text _ box = new system . windows . forms . text _ box ( ) ;
this . switch _ allow _ lan _ text _ box = new system . windows . forms . text _ box ( ) ; this . show _ logs _ text _ box = new system . windows . forms . text _ box ( ) ; this . server _ move _ up _ text _ box = new system . windows . forms . text _ box ( ) ; this . server _ move _ down _ text _ box = new system . windows . forms . text _ box ( ) ; flow _ layout _ panel = new system . windows . forms . flow _ layout _ panel ( ) ; flow _ layout _ panel . suspend _ layout ( ) ; this . table _ layout _ panel . suspend _ layout ( ) ; this . suspend _ layout ( ) ; this . table _ layout _ panel . set _ column _ span ( flow _ layout _ panel , 2 ) ; flow _ layout _ panel . controls . add ( this . btn _ ok ) ;
this . table _ layout _ panel . controls . add ( this . switch _ system _ proxy _ text _ box , 1 , 0 ) ; this . table _ layout _ panel . controls . add ( this . switch _ proxy _ mode _ text _ box , 1 , 1 ) ; this . table _ layout _ panel . controls . add ( this . switch _ allow _ lan _ text _ box , 1 , 2 ) ; this . table _ layout _ panel . controls . add ( this . show _ logs _ text _ box , 1 , NUM ) ; this . table _ layout _ panel . controls . add ( this . server _ move _ up _ text _ box , 1 , NUM ) ; this . table _ layout _ panel . controls . add ( this . server _ move _ down _ text _ box , 1 , NUM ) ; this . table _ layout _ panel . dock = system . windows . forms . dock _ style . fill ; this . table _ layout _ panel . location = new system . drawing . point ( 0 , 0 ) ; this . table _ layout _ panel . name = STR ;
this . table _ layout _ panel . dock = system . windows . forms . dock _ style . fill ; this . table _ layout _ panel . location = new system . drawing . point ( 0 , 0 ) ; this . table _ layout _ panel . name = STR ; this . table _ layout _ panel . tab _ index = 0 ; this . switch _ system _ proxy _ label . auto _ size = true ; this . switch _ system _ proxy _ label . dock = system . windows . forms . dock _ style . right ; this . switch _ system _ proxy _ label . location = new system . drawing . point ( NUM , 0 ) ; this . switch _ system _ proxy _ label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ; this . switch _ system _ proxy _ label . name = STR ; this . switch _ system _ proxy _ label . size = new system . drawing . size ( NUM , NUM ) ;
private system . windows . forms . label switch _ allow _ lan _ label ; private system . windows . forms . label show _ logs _ label ; private system . windows . forms . label server _ move _ up _ label ; private system . windows . forms . label server _ move _ down _ label ; private system . windows . forms . button btn _ ok ; private system . windows . forms . button btn _ cancel ; private system . windows . forms . text _ box show _ logs _ text _ box ; private system . windows . forms . text _ box switch _ allow _ lan _ text _ box ; private system . windows . forms . text _ box switch _ proxy _ mode _ text _ box ;
private system . windows . forms . text _ box switch _ system _ proxy _ text _ box ; private system . windows . forms . text _ box server _ move _ up _ text _ box ; private system . windows . forms . text _ box server _ move _ down _ text _ box ; private system . windows . forms . button btn _ register _ all ; private system . windows . forms . table _ layout _ panel table _ layout _ panel ; } }
string [ ] run _ list = run _ key . get _ value _ names ( ) ; foreach ( string item in run _ list ) { if ( item = = key ) return true ; else if ( item = = STR ) { string value = convert . to _ string ( run _ key . get _ value ( item ) ) ; if ( path . equals ( value , string _ comparison . invariant _ culture _ ignore _ case ) ) {
return true ; else if ( item = = STR ) { string value = convert . to _ string ( run _ key . get _ value ( item ) ) ; if ( path . equals ( value , string _ comparison . invariant _ culture _ ignore _ case ) ) { run _ key . delete _ value ( item ) ; run _ key . set _ value ( key , path ) ; return true ; }
{ string value = convert . to _ string ( run _ key . get _ value ( item ) ) ; if ( path . equals ( value , string _ comparison . invariant _ culture _ ignore _ case ) ) { run _ key . delete _ value ( item ) ; run _ key . set _ value ( key , path ) ; return true ; } } }
private int _ ptr handle = int _ ptr . zero ; public job ( ) { handle = create _ job _ object ( int _ ptr . zero , null ) ; var extended _ info _ ptr = int _ ptr . zero ; var info = new jobobject _ basic _ limit _ information { limit _ flags = 0 } ;
public job ( ) { handle = create _ job _ object ( int _ ptr . zero , null ) ; var extended _ info _ ptr = int _ ptr . zero ; var info = new jobobject _ basic _ limit _ information { limit _ flags = 0 } ; var extended _ info = new jobobject _ extended _ limit _ information {


this . table _ layout _ panel . resume _ layout ( false ) ; this . table _ layout _ panel . perform _ layout ( ) ; this . panel . resume _ layout ( false ) ; this . context _ menu _ strip . resume _ layout ( false ) ; this . resume _ layout ( false ) ; this . perform _ layout ( ) ; } private system . windows . forms . table _ layout _ panel table _ layout _ panel ; private system . windows . forms . label label ; private system . windows . forms . label label ;
} public void close ( ) { connection . close ( ) ; if ( remote ! = null ) { remote . close ( ) ; } } private void connect _ callback ( i _ async _ result ar )
} private void connect _ callback ( i _ async _ result ar ) { try { remote . end _ connect ( ar ) ; console . write _ line ( STR , remote . remote _ end _ point . to _ string ( ) ) ; handshake _ receive ( ) ; }
using system _ text ; using system _ io ; using system _ diagnostics ; using simple _ json ; namespace shadowsocks _ csharp { serializable public class config { public string server ;
public bool is _ default ; private static void assert ( bool condition ) { if ( ! condition ) { throw new exception ( STR ) ; } } public static config load ( ) {
try { using ( stream _ reader sr = new stream _ reader ( file . open _ read ( STR ) ) ) { config config = simple _ json . simple _ json . deserialize _ object < config > ( sr . read _ to _ end ( ) ) ; assert ( ! string . is _ null _ or _ empty ( config . server ) ) ; assert ( ! string . is _ null _ or _ empty ( config . password ) ) ; assert ( config . local _ port > 0 ) ; assert ( config . server _ port > 0 ) ; config . is _ default = false ;
{ config config = simple _ json . simple _ json . deserialize _ object < config > ( sr . read _ to _ end ( ) ) ; assert ( ! string . is _ null _ or _ empty ( config . server ) ) ; assert ( ! string . is _ null _ or _ empty ( config . password ) ) ; assert ( config . local _ port > 0 ) ; assert ( config . server _ port > 0 ) ; config . is _ default = false ; return config ; } }
assert ( ! string . is _ null _ or _ empty ( config . server ) ) ; assert ( ! string . is _ null _ or _ empty ( config . password ) ) ; assert ( config . local _ port > 0 ) ; assert ( config . server _ port > 0 ) ; config . is _ default = false ; return config ; } } catch ( exception e ) {
try { using ( stream _ writer sw = new stream _ writer ( file . open ( STR , file _ mode . create ) ) ) { string json _ string = simple _ json . simple _ json . serialize _ object ( new { server = config . server , server _ port = config . server _ port , local _ port = config . local _ port , password = config . password
{ string json _ string = simple _ json . simple _ json . serialize _ object ( new { server = config . server , server _ port = config . server _ port , local _ port = config . local _ port , password = config . password } ) ; sw . write ( json _ string ) ; sw . flush ( ) ;
} } catch ( io _ exception e ) { console . error . write _ line ( e ) ; } } } }
} ) , this . servers _ item = create _ menu _ group ( STR , new menu _ item [ ] { this . seperator _ item = new menu _ item ( STR ) , this . config _ item = create _ menu _ item ( STR , new event _ handler ( this . config _ click ) ) } ) , new menu _ item ( STR ) , this . auto _ startup _ item = create _ menu _ item ( STR , new event _ handler ( this . auto _ startup _ item _ click ) ) , this . share _ over _ lan _ item = create _ menu _ item ( STR , new event _ handler ( this . share _ over _ lan _ item _ click ) ) , create _ menu _ item ( STR , new event _ handler ( this . edit _ pac _ file _ item _ click ) ) , new menu _ item ( STR ) ,
this . seperator _ item = new menu _ item ( STR ) , this . config _ item = create _ menu _ item ( STR , new event _ handler ( this . config _ click ) ) } ) , new menu _ item ( STR ) , this . auto _ startup _ item = create _ menu _ item ( STR , new event _ handler ( this . auto _ startup _ item _ click ) ) , this . share _ over _ lan _ item = create _ menu _ item ( STR , new event _ handler ( this . share _ over _ lan _ item _ click ) ) , create _ menu _ item ( STR , new event _ handler ( this . edit _ pac _ file _ item _ click ) ) , new menu _ item ( STR ) , create _ menu _ item ( STR , new event _ handler ( this . qr _ code _ item _ click ) ) , create _ menu _ item ( STR , new event _ handler ( this . show _ log _ item _ click ) ) ,
} ) , new menu _ item ( STR ) , this . auto _ startup _ item = create _ menu _ item ( STR , new event _ handler ( this . auto _ startup _ item _ click ) ) , this . share _ over _ lan _ item = create _ menu _ item ( STR , new event _ handler ( this . share _ over _ lan _ item _ click ) ) , create _ menu _ item ( STR , new event _ handler ( this . edit _ pac _ file _ item _ click ) ) , new menu _ item ( STR ) , create _ menu _ item ( STR , new event _ handler ( this . qr _ code _ item _ click ) ) , create _ menu _ item ( STR , new event _ handler ( this . show _ log _ item _ click ) ) , create _ menu _ item ( STR , new event _ handler ( this . config _ click ) ) , new menu _ item ( STR ) ,
new menu _ item ( STR ) , create _ menu _ item ( STR , new event _ handler ( this . qr _ code _ item _ click ) ) , create _ menu _ item ( STR , new event _ handler ( this . show _ log _ item _ click ) ) , create _ menu _ item ( STR , new event _ handler ( this . config _ click ) ) , new menu _ item ( STR ) , create _ menu _ item ( STR , new event _ handler ( this . quit _ click ) ) } ) ; } private void controller _ config _ changed ( object sender , event _ args e ) {
new menu _ item ( STR ) , create _ menu _ item ( STR , new event _ handler ( this . quit _ click ) ) } ) ; } private void controller _ config _ changed ( object sender , event _ args e ) { load _ current _ configuration ( ) ; update _ tray _ icon ( ) ; } private void controller _ enable _ status _ changed ( object sender , event _ args e )
} ) ; } private void controller _ config _ changed ( object sender , event _ args e ) { load _ current _ configuration ( ) ; update _ tray _ icon ( ) ; } private void controller _ enable _ status _ changed ( object sender , event _ args e ) { enable _ item . checked = controller . get _ configuration ( ) . enabled ;
} load _ library ( dll _ path ) ; } public static byte [ ] m ( byte [ ] input ) { byte [ ] output = new byte [ NUM ] ; md ( input , ( uint ) input . length , output ) ;
public static byte [ ] m ( byte [ ] input ) { byte [ ] output = new byte [ NUM ] ; md ( input , ( uint ) input . length , output ) ; return output ; } dll _ import _ kernel _ dll private static extern int _ ptr load _ library ( string path ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern int _ ptr cipher _ info _ from _ string ( string cipher _ name ) ;
return output ; } dll _ import _ kernel _ dll private static extern int _ ptr load _ library ( string path ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern int _ ptr cipher _ info _ from _ string ( string cipher _ name ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern void cipher _ init ( int _ ptr ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public static extern int cipher _ setup ( int _ ptr ctx , int _ ptr cipher _ info ) ;
} }
private static readonly concurrent _ dictionary < string , byte [ ] > cached _ keys = new concurrent _ dictionary < string , byte [ ] > ( ) ; protected byte [ ] encrypt _ iv ; protected byte [ ] decrypt _ iv ; protected bool decrypt _ iv _ received ; protected bool encrypt _ iv _ sent ; protected string method ; protected int cipher ; protected string cipher _ mbed _ name ;
protected string method ; protected int cipher ; protected string cipher _ mbed _ name ; protected int [ ] cipher _ info ; protected byte [ ] key ; protected int key _ len ; protected int iv _ len ; protected uint counter = 0 ; protected byte [ ] key _ buffer = null ; public iv _ encryptor ( string method , string password , bool onetimeauth , bool isudp )
protected void init _ key ( string method , string password ) { method = method . to _ lower ( ) ; method = method ; string k = method + STR + password ; ciphers = get _ ciphers ( ) ; ciphers _ detail = ciphers [ method ] ; cipher _ mbed _ name = ciphers _ detail . keys . first _ or _ default ( ) ; cipher _ info = ciphers [ method ] [ cipher _ mbed _ name ] ;
cipher = cipher _ info [ 2 ] ; if ( cipher = = 0 ) { throw new exception ( STR ) ; } key _ len = cipher _ info [ 0 ] ; iv _ len = cipher _ info [ 1 ] ; key = cached _ keys . get _ or _ add ( k , ( nk ) = > { byte [ ] passbuf = encoding . ut . get _ bytes ( password ) ;
key = cached _ keys . get _ or _ add ( k , ( nk ) = > { byte [ ] passbuf = encoding . ut . get _ bytes ( password ) ; byte [ ] key = new byte [ NUM ] ; byte [ ] iv = new byte [ NUM ] ; bytes _ to _ key ( passbuf , key ) ; return key ; } ) ; } protected void bytes _ to _ key ( byte [ ] password , byte [ ] key )
} ; protected override dictionary < string , dictionary < string , int [ ] > > get _ ciphers ( ) { return ciphers ; } public static list < string > supported _ ciphers ( ) { return new list < string > ( ciphers . keys ) ; } protected override void cipher _ update ( bool is _ cipher , int length , byte [ ] buf , byte [ ] outbuf )
{ return ciphers ; } public static list < string > supported _ ciphers ( ) { return new list < string > ( ciphers . keys ) ; } protected override void cipher _ update ( bool is _ cipher , int length , byte [ ] buf , byte [ ] outbuf ) { int bytes _ remaining ;
{ run _ single _ mbed _ tls _ encryption _ thread ( ) ; list < thread > threads = new list < thread > ( ) ; for ( int i = 0 ; i < NUM ; i + + ) { thread t = new thread ( new thread _ start ( run _ single _ mbed _ tls _ encryption _ thread ) ) ; threads . add ( t ) ; t . start ( ) ; } foreach ( thread t in threads )
threads . add ( t ) ; t . start ( ) ; } foreach ( thread t in threads ) { t . join ( ) ; } assert . is _ false ( encryption _ failed ) ; } private void run _ single _ mbed _ tls _ encryption _ thread ( )
{ try { for ( int i = 0 ; i < NUM ; i + + ) { i _ encryptor encryptor ; i _ encryptor decryptor ; encryptor = new mbed _ tls _ encryptor ( STR , STR , false , false ) ; decryptor = new mbed _ tls _ encryptor ( STR , STR , false , false ) ; run _ encryption _ round ( encryptor , decryptor ) ;
run _ encryption _ round ( encryptor , decryptor ) ; } } catch { encryption _ failed = true ; throw ; } } test _ method
logging . dump ( STR , ciphertext , ( int ) enc _ clen ) ; clen = ( uint ) enc _ clen ; } public override void cipher _ decrypt ( byte [ ] ciphertext , uint clen , byte [ ] plaintext , ref uint plen ) { debug . assert ( sodium _ dec _ subkey ! = null ) ; int ret ; ulong dec _ plen = 0 ; logging . dump ( STR , dec _ nonce , nonce _ len ) ;
} public override void cipher _ decrypt ( byte [ ] ciphertext , uint clen , byte [ ] plaintext , ref uint plen ) { debug . assert ( sodium _ dec _ subkey ! = null ) ; int ret ; ulong dec _ plen = 0 ; logging . dump ( STR , dec _ nonce , nonce _ len ) ; logging . dump ( STR , sodium _ dec _ subkey , key _ len ) ; logging . dump ( STR , ciphertext , ( int ) clen ) ; switch ( cipher )
{ debug . assert ( sodium _ dec _ subkey ! = null ) ; int ret ; ulong dec _ plen = 0 ; logging . dump ( STR , dec _ nonce , nonce _ len ) ; logging . dump ( STR , sodium _ dec _ subkey , key _ len ) ; logging . dump ( STR , ciphertext , ( int ) clen ) ; switch ( cipher ) { case cipher _ chach _ ietfpol :
logging . dump ( STR , plaintext , ( int ) dec _ plen ) ; plen = ( uint ) dec _ plen ; } public override void dispose ( ) { } } }
} public override void dispose ( ) { } } }
{ if ( ! registered _ encryptors . contains _ key ( method ) ) registered _ encryptors . add ( method , typeof ( stream _ open _ ssl _ encryptor ) ) ; } foreach ( string method in stream _ sodium _ encryptor . supported _ ciphers ( ) ) { if ( ! registered _ encryptors . contains _ key ( method ) ) registered _ encryptors . add ( method , typeof ( stream _ sodium _ encryptor ) ) ; }
} foreach ( string method in stream _ sodium _ encryptor . supported _ ciphers ( ) ) { if ( ! registered _ encryptors . contains _ key ( method ) ) registered _ encryptors . add ( method , typeof ( stream _ sodium _ encryptor ) ) ; } foreach ( string method in stream _ mbed _ tls _ encryptor . supported _ ciphers ( ) ) { if ( ! registered _ encryptors . contains _ key ( method ) ) registered _ encryptors . add ( method , typeof ( stream _ mbed _ tls _ encryptor ) ) ;
} foreach ( string method in aead _ mbed _ tls _ encryptor _ supported _ ciphers ) { if ( ! registered _ encryptors . contains _ key ( method ) ) registered _ encryptors . add ( method , typeof ( aead _ mbed _ tls _ encryptor ) ) ; }
} } public static i _ encryptor get _ encryptor ( string method , string password ) { if ( method . is _ null _ or _ empty ( ) ) { method = STR ; } method = method . to _ lower _ invariant ( ) ; type t = registered _ encryptors [ method ] ;
debug . assert ( olen = = plen ) ; array . copy ( tagbuf , 0 , ciphertext , ( int ) plen , tag _ len ) ; clen = olen + ( uint ) tag _ len ; break ; default : throw new system . exception ( STR ) ; } } public override void cipher _ decrypt ( byte [ ] ciphertext , uint clen , byte [ ] plaintext , ref uint plen ) {
default : throw new system . exception ( STR ) ; } } public override void cipher _ decrypt ( byte [ ] ciphertext , uint clen , byte [ ] plaintext , ref uint plen ) { int ret ; uint olen = 0 ; byte [ ] tagbuf = new byte [ tag _ len ] ; array . copy ( ciphertext , ( int ) ( clen - tag _ len ) , tagbuf , 0 , tag _ len ) ;
{ int ret ; uint olen = 0 ; byte [ ] tagbuf = new byte [ tag _ len ] ; array . copy ( ciphertext , ( int ) ( clen - tag _ len ) , tagbuf , 0 , tag _ len ) ; switch ( cipher ) { case cipher _ aes : ret = mbed _ tls . cipher _ auth _ decrypt ( decrypt _ ctx , dec _ nonce , ( uint ) nonce _ len ,
debug . assert ( olen = = clen - tag _ len ) ; plen = olen ; break ; default : throw new system . exception ( STR ) ; } } private bool disposed ; private readonly object lock = new object ( ) ; public override void dispose ( )
default : throw new system . exception ( STR ) ; } } private bool disposed ; private readonly object lock = new object ( ) ; public override void dispose ( ) { dispose ( true ) ; gc . suppress _ finalize ( this ) ;
this . file _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . open _ location _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . exit _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . view _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . clean _ logs _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . change _ font _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . wrap _ text _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . top _ most _ menu _ item = new system . windows . forms . menu _ item ( ) ; this . menu _ item _ separater = new system . windows . forms . menu _ item ( ) ; this . show _ toolbar _ menu _ item = new system . windows . forms . menu _ item ( ) ;
this . change _ font _ button = new system . windows . forms . button ( ) ; this . clean _ logs _ button = new system . windows . forms . button ( ) ; this . wrap _ text _ check _ box = new system . windows . forms . check _ box ( ) ; this . table _ layout _ panel = new system . windows . forms . table _ layout _ panel ( ) ; this . toolbar _ flow _ layout _ panel = new system . windows . forms . flow _ layout _ panel ( ) ; this . table _ layout _ panel . suspend _ layout ( ) ; this . toolbar _ flow _ layout _ panel . suspend _ layout ( ) ;
this . table _ layout _ panel . suspend _ layout ( ) ; this . toolbar _ flow _ layout _ panel . suspend _ layout ( ) ;
this . change _ font _ button . auto _ size = true ; this . change _ font _ button . location = new system . drawing . point ( NUM , NUM ) ; this . change _ font _ button . name = STR ; this . change _ font _ button . size = new system . drawing . size ( NUM , NUM ) ; this . change _ font _ button . tab _ index = 2 ; this . change _ font _ button . text = STR ; this . change _ font _ button . use _ visual _ style _ back _ color = true ; this . change _ font _ button . click + = new system . event _ handler ( this . change _ font _ button _ click ) ; this . clean _ logs _ button . auto _ size = true ; this . clean _ logs _ button . location = new system . drawing . point ( NUM , NUM ) ;
this . change _ font _ button . name = STR ; this . change _ font _ button . size = new system . drawing . size ( NUM , NUM ) ; this . change _ font _ button . tab _ index = 2 ; this . change _ font _ button . text = STR ; this . change _ font _ button . use _ visual _ style _ back _ color = true ; this . change _ font _ button . click + = new system . event _ handler ( this . change _ font _ button _ click ) ; this . clean _ logs _ button . auto _ size = true ; this . clean _ logs _ button . location = new system . drawing . point ( NUM , NUM ) ; this . clean _ logs _ button . name = STR ; this . clean _ logs _ button . size = new system . drawing . size ( NUM , NUM ) ;
this . clean _ logs _ button . name = STR ; this . clean _ logs _ button . size = new system . drawing . size ( NUM , NUM ) ; this . clean _ logs _ button . tab _ index = 1 ; this . clean _ logs _ button . text = STR ; this . clean _ logs _ button . use _ visual _ style _ back _ color = true ; this . clean _ logs _ button . click + = new system . event _ handler ( this . clean _ logs _ button _ click ) ; this . wrap _ text _ check _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( ( system . windows . forms . anchor _ styles . top | system . windows . forms . anchor _ styles . bottom ) | system . windows . forms . anchor _ styles . left ) ) ) ; this . wrap _ text _ check _ box . auto _ size = true ; this . wrap _ text _ check _ box . location = new system . drawing . point ( NUM , NUM ) ;
this . table _ layout _ panel . controls . add ( this . log _ message _ text _ box , 0 , 1 ) ; this . table _ layout _ panel . controls . add ( this . toolbar _ flow _ layout _ panel , 0 , 0 ) ; this . table _ layout _ panel . dock = system . windows . forms . dock _ style . fill ; this . table _ layout _ panel . location = new system . drawing . point ( 0 , 0 ) ; this . table _ layout _ panel . name = STR ; this . table _ layout _ panel . row _ count = 2 ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ; this . table _ layout _ panel . tab _ index = 2 ;
this . table _ layout _ panel . tab _ index = 2 ; this . toolbar _ flow _ layout _ panel . auto _ size = true ; this . toolbar _ flow _ layout _ panel . controls . add ( this . clean _ logs _ button ) ; this . toolbar _ flow _ layout _ panel . controls . add ( this . change _ font _ button ) ; this . toolbar _ flow _ layout _ panel . controls . add ( this . wrap _ text _ check _ box ) ; this . toolbar _ flow _ layout _ panel . controls . add ( this . top _ most _ check _ box ) ; this . toolbar _ flow _ layout _ panel . dock = system . windows . forms . dock _ style . fill ; this . toolbar _ flow _ layout _ panel . location = new system . drawing . point ( NUM , NUM ) ; this . toolbar _ flow _ layout _ panel . name = STR ; this . toolbar _ flow _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ;

this . table _ layout _ panel . resume _ layout ( false ) ; this . table _ layout _ panel . perform _ layout ( ) ; this . toolbar _ flow _ layout _ panel . resume _ layout ( false ) ; this . toolbar _ flow _ layout _ panel . perform _ layout ( ) ; this . resume _ layout ( false ) ; } private system . windows . forms . text _ box log _ message _ text _ box ; private system . windows . forms . main _ menu main _ menu ; private system . windows . forms . menu _ item file _ menu _ item ;
private system . windows . forms . menu _ item file _ menu _ item ; private system . windows . forms . menu _ item open _ location _ menu _ item ; private system . windows . forms . menu _ item exit _ menu _ item ; private system . windows . forms . check _ box wrap _ text _ check _ box ; private system . windows . forms . button clean _ logs _ button ; private system . windows . forms . button change _ font _ button ; private system . windows . forms . table _ layout _ panel table _ layout _ panel ; private system . windows . forms . check _ box top _ most _ check _ box ; private system . windows . forms . menu _ item view _ menu _ item ;
private system . windows . forms . check _ box wrap _ text _ check _ box ; private system . windows . forms . button clean _ logs _ button ; private system . windows . forms . button change _ font _ button ; private system . windows . forms . table _ layout _ panel table _ layout _ panel ; private system . windows . forms . check _ box top _ most _ check _ box ; private system . windows . forms . menu _ item view _ menu _ item ; private system . windows . forms . menu _ item clean _ logs _ menu _ item ; private system . windows . forms . menu _ item change _ font _ menu _ item ; private system . windows . forms . menu _ item wrap _ text _ menu _ item ; private system . windows . forms . menu _ item top _ most _ menu _ item ;
} private void clean _ logs _ button _ click ( object sender , event _ args e ) { do _ clean _ logs ( ) ; } private void do _ change _ font ( ) { font _ dialog fd = new font _ dialog ( ) ; fd . font = log _ message _ text _ box . font ;
{ font _ dialog fd = new font _ dialog ( ) ; fd . font = log _ message _ text _ box . font ; if ( fd . show _ dialog ( ) = = dialog _ result . ok ) { log _ message _ text _ box . font = fd . font ; } } private void change _ font _ menu _ item _ click ( object sender , event _ args e ) {
} } }
{ byte [ ] response = { NUM , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 } ; connection . begin _ send ( response , 0 , response . length , socket _ flags . none , new async _ callback ( response _ callback ) , null ) ; } else if ( command = = NUM ) { read _ address ( handle _ udp _ associate ) ;
} } } else { logging . debug ( STR ) ; close ( ) ; } } catch ( exception e )
{ array . copy ( connetion _ recv _ buffer , NUM , connetion _ recv _ buffer , 0 , 2 ) ; connection . begin _ receive ( connetion _ recv _ buffer , 2 , recv _ size - 2 , socket _ flags . none , on _ address _ fully _ read , new object [ ] { bytes _ remain , on _ success } ) ; } private void on _ address _ fully _ read ( i _ async _ result ar ) { if ( closed ) return ; try { int bytes _ read = connection . end _ receive ( ar ) ;
} private void on _ address _ fully _ read ( i _ async _ result ar ) { if ( closed ) return ; try { int bytes _ read = connection . end _ receive ( ar ) ; var states = ( object [ ] ) ar . async _ state ; int bytes _ remain = ( int ) states [ 0 ] ; var on _ success = ( action ) states [ 1 ] ;
if ( bytes _ read > = bytes _ remain ) { first _ packet _ length = bytes _ read + 2 ; int atyp = connetion _ recv _ buffer [ 0 ] ; string dst _ addr = STR ; int dst _ port = - 1 ; switch ( atyp ) { case 1 : dst _ addr = new ip _ address ( connetion _ recv _ buffer . skip ( 1 ) . take ( NUM ) . to _ array ( ) ) . to _ string ( ) ;
} return null ; } public server ( ) { server = STR ;
} public server ( ) { server = STR ; server _ port = NUM ; method = STR ; password = STR ; remarks = STR ; auth = false ; }
if ( request _ line _ count = = 0 ) { var m = http _ request _ header _ regex . match ( line ) ; if ( m . success ) { var method = m . groups [ STR ] . value ; var path = m . groups [ STR ] . value ; if ( method = = STR ) {
if ( method = = STR ) { is _ connect = true ; if ( ! parse _ host ( path ) ) { throw new exception ( STR + line ) ; } } else {
{ throw new exception ( STR + line ) ; } } else { var target _ url = new uri ( path ) ; if ( ! parse _ host ( target _ url . authority ) ) { throw new exception ( STR + line ) ;
if ( line . is _ null _ or _ empty ( ) ) { return true ; } if ( ! is _ connect ) { if ( line . starts _ with ( STR ) ) { if ( ! parse _ host ( line . substring ( NUM ) . trim ( ) ) ) {
byte [ ] response = { NUM , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 } ; connection . begin _ send ( response , 0 , response . length , 0 , new async _ callback ( start _ connect ) , null ) ; } else { console . write _ line ( STR ) ; this . close ( ) ; } } catch ( exception e )
} else { console . write _ line ( STR ) ; this . close ( ) ; } } catch ( exception e ) { logging . log _ useful _ exception ( e ) ;
this . pac _ url _ text _ box . max _ length = NUM ; this . pac _ url _ text _ box . name = STR ; this . pac _ url _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . pac _ url _ text _ box . tab _ index = NUM ; this . pac _ url _ text _ box . word _ wrap = false ; this . pac _ url _ label . anchor = system . windows . forms . anchor _ styles . left ; this . pac _ url _ label . auto _ size = true ; this . pac _ url _ label . location = new system . drawing . point ( NUM , NUM ) ; this . pac _ url _ label . margin = new system . windows . forms . padding ( NUM ) ; this . pac _ url _ label . name = STR ;
this . pac _ url _ label . name = STR ; this . pac _ url _ label . size = new system . drawing . size ( NUM , NUM ) ; this . pac _ url _ label . tab _ index = NUM ; this . pac _ url _ label . text = STR ; this . pac _ url _ label . text _ align = system . drawing . content _ alignment . middle _ left ; this . ok _ button . location = new system . drawing . point ( NUM , NUM ) ; this . ok _ button . name = STR ; this . ok _ button . size = new system . drawing . size ( NUM , NUM ) ; this . ok _ button . tab _ index = NUM ; this . ok _ button . text = STR ;
this . form _ border _ style = system . windows . forms . form _ border _ style . fixed _ single ; this . maximize _ box = false ; this . minimize _ box = false ; this . name = STR ; this . padding = new system . windows . forms . padding ( NUM ) ; this . start _ position = system . windows . forms . form _ start _ position . center _ screen ; this . text = STR ; this . load + = new system . event _ handler ( this . pac _ url _ form _ load ) ; this . table _ layout _ panel . resume _ layout ( false ) ; this . table _ layout _ panel . perform _ layout ( ) ;
const string encoding = STR ; bool generate _ eci = ( hints ! = null & & hints . contains _ key ( encode _ hint _ type . character _ set ) ) ; mode mode = choose _ mode ( content , encoding ) ; bit _ array header _ bits = new bit _ array ( ) ;
bit _ array header _ bits = new bit _ array ( ) ;
append _ mode _ info ( mode , header _ bits ) ; bit _ array data _ bits = new bit _ array ( ) ; append _ bytes ( content , mode , data _ bits , encoding ) ; int provisional _ bits _ needed = header _ bits . size + mode . get _ character _ count _ bits ( version . get _ version _ for _ number ( 1 ) ) + data _ bits . size ; version provisional _ version = choose _ version ( provisional _ bits _ needed , ec _ level ) ; int bits _ needed = header _ bits . size + mode . get _ character _ count _ bits ( provisional _ version ) + data _ bits . size ;
} internal static void terminate _ bits ( int num _ data _ bytes , bit _ array bits ) { int capacity = num _ data _ bytes < < NUM ; if ( bits . size > capacity ) { throw new writer _ exception ( STR + bits . size + STR + capacity ) ; } for ( int i = 0 ; i < NUM & & bits . size < capacity ; + + i )
} if ( num _ rs _ blocks ! = num _ rs _ blocks _ in _ group + num _ rs _ blocks _ in _ group ) { throw new writer _ exception ( STR ) ; } if ( num _ total _ bytes ! = ( ( num _ data _ bytes _ in _ group + num _ ec _ bytes _ in _ group ) * num _ rs _ blocks _ in _ group ) + ( ( num _ data _ bytes _ in _ group + num _ ec _ bytes _ in _ group ) * num _ rs _ blocks _ in _ group ) )
} if ( num _ total _ bytes ! = ( ( num _ data _ bytes _ in _ group + num _ ec _ bytes _ in _ group ) * num _ rs _ blocks _ in _ group ) + ( ( num _ data _ bytes _ in _ group + num _ ec _ bytes _ in _ group ) * num _ rs _ blocks _ in _ group ) ) { throw new writer _ exception ( STR ) ; } if ( block _ id < num _ rs _ blocks _ in _ group )
} if ( block _ id < num _ rs _ blocks _ in _ group ) { num _ data _ bytes _ in _ block [ 0 ] = num _ data _ bytes _ in _ group ; num _ ec _ bytes _ in _ block [ 0 ] = num _ ec _ bytes _ in _ group ; } else { num _ data _ bytes _ in _ block [ 0 ] = num _ data _ bytes _ in _ group ; num _ ec _ bytes _ in _ block [ 0 ] = num _ ec _ bytes _ in _ group ;
} bits . append _ bits ( num _ letters , num _ bits ) ; } internal static void append _ bytes ( string content , mode mode , bit _ array bits , string encoding ) { if ( mode . equals ( mode . numeric ) ) append _ numeric _ bytes ( content , bits ) ;
} internal static void append _ bit _ bytes ( string content , bit _ array bits , string encoding ) { byte [ ] bytes ; try { bytes = encoding . get _ encoding ( encoding ) . get _ bytes ( content ) ; } catch ( platform _ not _ supported _ exception ) {
} foreach ( byte b in bytes ) { bits . append _ bits ( b , NUM ) ; } } internal static void append _ kanji _ bytes ( string content , bit _ array bits ) { byte [ ] bytes ; try
} matrix [ NUM , matrix . height - NUM ] = 1 ; } private static void embed _ horizontal _ separation _ pattern ( int x _ start , int y _ start , byte _ matrix matrix ) { for ( int x = 0 ; x < NUM ; + + x ) { if ( ! is _ empty ( matrix [ x _ start + x , y _ start ] ) ) { throw new writer _ exception ( ) ;
} matrix [ x _ start + x , y _ start ] = 0 ; } } private static void embed _ vertical _ separation _ pattern ( int x _ start , int y _ start , byte _ matrix matrix ) { for ( int y = 0 ; y < NUM ; + + y ) { if ( ! is _ empty ( matrix [ x _ start , y _ start + y ] ) ) {
} catch ( exception e ) { if ( e is socket _ exception ) { socket _ exception se = ( socket _ exception ) e ; if ( se . socket _ error _ code = = socket _ error . access _ denied ) { e = new exception ( n . get _ string ( STR ) , e ) ; }
{ private static int port = NUM ; public static string pac _ file = STR ; file _ system _ watcher watcher ; public event event _ handler pac _ file _ changed ; public pac _ server ( ) { this . watch _ pac _ file ( ) ;
file _ system _ watcher watcher ; public event event _ handler pac _ file _ changed ; public pac _ server ( ) { this . watch _ pac _ file ( ) ; } public bool handle ( byte [ ] first _ packet , int length , socket socket ) { try
{ try { string request = encoding . ut . get _ string ( first _ packet , 0 , length ) ; string [ ] lines = request . split ( '\r' , '\n' ) ; bool host _ match = false , path _ match = false ; foreach ( string line in lines )
{ string [ ] kv = line . split ( new char [ ] { ':' } , 2 ) ; if ( kv . length = = 2 ) { if ( kv [ 0 ] = = STR ) { if ( kv [ 1 ] . trim ( ) = = ( ( ip _ end _ point ) socket . local _ end _ point ) . to _ string ( ) ) { host _ match = true ; }
} if ( host _ match & & path _ match ) { send _ response ( first _ packet , length , socket ) ; return true ; } return false ;
{ send _ response ( first _ packet , length , socket ) ; return true ; } return false ;
} return false ; } catch ( argument _ exception )
} catch ( argument _ exception ) { return false ;
{ return false ;
} } public string touch _ pac _ file ( ) { if ( file . exists ( pac _ file ) ) { return pac _ file ; } else {
{ try { string pac = get _ pac _ content ( ) ; ip _ end _ point local _ end _ point = ( ip _ end _ point ) socket . local _ end _ point ; string proxy = get _ pac _ address ( first _ packet , length , local _ end _ point ) ;
try { string pac = get _ pac _ content ( ) ; ip _ end _ point local _ end _ point = ( ip _ end _ point ) socket . local _ end _ point ; string proxy = get _ pac _ address ( first _ packet , length , local _ end _ point ) ; pac = pac . replace ( STR , proxy ) ; string text = string . format ( @ STR
string pac = get _ pac _ content ( ) ; ip _ end _ point local _ end _ point = ( ip _ end _ point ) socket . local _ end _ point ; string proxy = get _ pac _ address ( first _ packet , length , local _ end _ point ) ; pac = pac . replace ( STR , proxy ) ; string text = string . format ( @ STR server : shadowsocks content - type : application / x - ns - proxy - autoconfig content - length : { 0 }
pac = pac . replace ( STR , proxy ) ; string text = string . format ( @ STR server : shadowsocks content - type : application / x - ns - proxy - autoconfig content - length : { 0 } connection : close STR byte [ ] response = system . text . encoding . ut . get _ bytes ( text ) ;
server : shadowsocks content - type : application / x - ns - proxy - autoconfig content - length : { 0 } connection : close STR byte [ ] response = system . text . encoding . ut . get _ bytes ( text ) ; socket . begin _ send ( response , 0 , response . length , 0 , new async _ callback ( send _ callback ) , socket ) ; util . utils . release _ memory ( ) ;
} catch ( exception e ) { console . write _ line ( e ) ; socket . close ( ) ; } } private void send _ callback ( i _ async _ result ar ) { socket conn = ( socket ) ar . async _ state ;
} } private void send _ callback ( i _ async _ result ar ) { socket conn = ( socket ) ar . async _ state ; try { conn . shutdown ( socket _ shutdown . send ) ; } catch
{ return STR + local _ end _ point . address + STR ; } } }
} } }
socket . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; handler handler = new handler ( ) ; handler . connection = socket ; server server = config . get _ current _ server ( ) ; handler . encryptor = encryptor _ factory . get _ encryptor ( server . method , server . password ) ; handler . server = server ; handler . start ( first _ packet , length ) ; return true ; } }
{ server = STR , server _ port = NUM , password = STR , method = STR } ; server _ canon _ url = STR ; server = new server
{ server = STR , server _ port = NUM , password = STR , method = STR } ; server _ canon _ url = STR ; server _ with _ remark = new server { server = server . server ,
remarks = STR } ; server _ with _ remark _ canon _ url = STR ; server _ with _ remark = new server { server = server . server , server _ port = server . server _ port , password = server . password , method = server . method , remarks = STR
{ server = server . server , server _ port = server . server _ port , password = server . password , method = server . method , remarks = STR } ; server _ with _ remark _ canon _ url = STR ; server _ with _ plugin = new server {
plugin = STR , plugin _ opts = STR } ; server _ with _ plugin _ canon _ url = STR ; server _ with _ plugin = new server { server = server . server , server _ port = server . server _ port , password = server . password ,
STR ; server _ with _ plugin = new server { server = server . server , server _ port = server . server _ port , password = server . password , method = server . method , plugin = STR , plugin _ opts = STR } ;
{ server = server . server , server _ port = server . server _ port , password = server . password , method = server . method , plugin = STR , plugin _ opts = STR } ; server _ with _ plugin _ canon _ url = STR ;
STR ; server _ with _ plugin _ and _ remark = new server { server = server . server , server _ port = server . server _ port , password = server . password , method = server . method , plugin = server _ with _ plugin . plugin , plugin _ opts = server _ with _ plugin . plugin _ opts , remarks = server _ with _ remark . remarks
STR ; server _ with _ plugin _ and _ remark = new server { server = server . server , server _ port = server . server _ port , password = server . password , method = server . method , plugin = server _ with _ plugin . plugin , plugin _ opts = server _ with _ plugin . plugin _ opts , remarks = server _ with _ remark . remarks
{ server = server . server , server _ port = server . server _ port , password = server . password , method = server . method , plugin = server _ with _ plugin . plugin , plugin _ opts = server _ with _ plugin . plugin _ opts , remarks = server _ with _ remark . remarks } ; server _ with _ plugin _ and _ remark _ canon _ url =
STR ; } test _ method public void test _ parse _ url _ server ( ) { run _ parse _ shadowsocks _ url _ test ( string . join ( STR , server _ canon _ url , STR ,
STR , STR , server _ with _ remark _ canon _ url , STR ) , new [ ] { server , server , server _ with _ remark , server _ with _ remark
run _ parse _ shadowsocks _ url _ test ( string . join ( STR , server _ canon _ url , STR , STR , server _ with _ remark _ canon _ url , STR ) , new [ ] {
{ var no _ plugin = sip _ plugin . create _ if _ configured ( new server { server = STR , server _ port = NUM , password = STR , method = STR } ) ; run _ plugin _ support _ test (
var no _ plugin = sip _ plugin . create _ if _ configured ( new server { server = STR , server _ port = NUM , password = STR , method = STR } ) ; run _ plugin _ support _ test ( no _ plugin , STR ,
public hotkey _ settings _ form ( shadowsocks _ controller controller ) { initialize _ component ( ) ; update _ texts ( ) ; icon = icon . from _ handle ( resources . ssw . get _ hicon ( ) ) ; controller = controller ; controller . config _ changed + = controller _ config _ changed ; load _ current _ configuration ( ) ;
} private void update _ texts ( ) { switch _ system _ proxy _ label . text = n . get _ string ( STR ) ; switch _ proxy _ mode _ label . text = n . get _ string ( STR ) ; switch _ allow _ lan _ label . text = n . get _ string ( STR ) ; show _ logs _ label . text = n . get _ string ( STR ) ; server _ move _ up _ label . text = n . get _ string ( STR ) ; server _ move _ down _ label . text = n . get _ string ( STR ) ; btn _ ok . text = n . get _ string ( STR ) ;
} private bool reg _ hotkey _ from _ string ( string hotkey _ str , string callback _ name , label indicator = null ) { var callback = hotkey _ callbacks . get _ callback ( callback _ name ) ; if ( callback = = null ) { throw new exception ( $ STR ) ; } var callback = callback as hot _ keys . hot _ key _ call _ back _ handler ; if ( hotkey _ str . is _ null _ or _ empty ( ) )
{ var callback = hotkey _ callbacks . get _ callback ( callback _ name ) ; if ( callback = = null ) { throw new exception ( $ STR ) ; } var callback = callback as hot _ keys . hot _ key _ call _ back _ handler ; if ( hotkey _ str . is _ null _ or _ empty ( ) ) { hot _ keys . unreg _ existing _ hotkey ( callback ) ;
return true ; } else { var hotkey = hot _ keys . str _ hot _ key ( hotkey _ str ) ; if ( hotkey = = null ) { message _ box . show ( string . format ( n . get _ string ( STR ) , hotkey _ str ) ) ; return false ; }
if ( indicator ! = null ) { indicator . back _ color = reg _ result ? color . green : color . yellow ; } return reg _ result ; } } }
} }
foreach ( var d in domains ) { string domain = d . value ; switch ( d . type ) { case domain _ object . types . type . plain : ret . add ( $ STR ) ; break ; case domain _ object . types . type . regex : ret . add ( $ STR ) ;
break ; case domain _ object . types . type . regex : ret . add ( $ STR ) ; break ; case domain _ object . types . type . domain : ret . add ( $ STR ) ; break ; case domain _ object . types . type . full : ret . add ( $ STR ) ; ret . add ( $ STR ) ;

this . table _ layout _ panel . location = new system . drawing . point ( NUM , NUM ) ; this . table _ layout _ panel . margin = new system . windows . forms . padding ( 0 ) ; this . table _ layout _ panel . name = STR ; this . table _ layout _ panel . padding = new system . windows . forms . padding ( NUM ) ; this . table _ layout _ panel . row _ count = NUM ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ;
this . table _ layout _ panel . tab _ index = 0 ; this . plugin _ options _ label . anchor = system . windows . forms . anchor _ styles . right ; this . plugin _ options _ label . auto _ size = true ; this . plugin _ options _ label . location = new system . drawing . point ( NUM , NUM ) ; this . plugin _ options _ label . name = STR ; this . plugin _ options _ label . size = new system . drawing . size ( NUM , NUM ) ; this . plugin _ options _ label . tab _ index = NUM ; this . plugin _ options _ label . text = STR ; this . plugin _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . plugin _ text _ box . location = new system . drawing . point ( NUM , NUM ) ;
return configuration ; } catch ( file _ not _ found _ exception e ) { var configuration = new statistics _ strategy _ configuration ( ) ; save ( configuration ) ; return configuration ; } catch ( exception e ) {
{ var configuration = new statistics _ strategy _ configuration ( ) ; save ( configuration ) ; return configuration ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; return new statistics _ strategy _ configuration ( ) ; }
this . chart _ mode _ selector = new system . windows . forms . group _ box ( ) ; this . all _ mode = new system . windows . forms . radio _ button ( ) ; this . day _ mode = new system . windows . forms . radio _ button ( ) ; this . split _ container = new system . windows . forms . split _ container ( ) ; this . split _ container = new system . windows . forms . split _ container ( ) ; this . collect _ data _ per _ label = new system . windows . forms . label ( ) ; this . minutes _ label = new system . windows . forms . label ( ) ; this . data _ collection _ minutes _ num = new system . windows . forms . numeric _ up _ down ( ) ; this . statistics _ enabled _ check _ box = new system . windows . forms . check _ box ( ) ; this . choice _ kept _ minutes _ num = new system . windows . forms . numeric _ up _ down ( ) ;
this . data _ collection _ minutes _ num = new system . windows . forms . numeric _ up _ down ( ) ; this . statistics _ enabled _ check _ box = new system . windows . forms . check _ box ( ) ; this . choice _ kept _ minutes _ num = new system . windows . forms . numeric _ up _ down ( ) ; this . by _ hour _ of _ day _ check _ box = new system . windows . forms . check _ box ( ) ; this . repeat _ times _ num = new system . windows . forms . numeric _ up _ down ( ) ; this . package _ per _ ping _ label = new system . windows . forms . label ( ) ; this . split _ container = new system . windows . forms . split _ container ( ) ; this . final _ score _ label = new system . windows . forms . label ( ) ; this . calculation _ container = new system . windows . forms . flow _ layout _ panel ( ) ; this . server _ selector = new system . windows . forms . combo _ box ( ) ;
this . split _ container = new system . windows . forms . split _ container ( ) ; this . final _ score _ label = new system . windows . forms . label ( ) ; this . calculation _ container = new system . windows . forms . flow _ layout _ panel ( ) ; this . server _ selector = new system . windows . forms . combo _ box ( ) ; this . cancel _ button = new system . windows . forms . button ( ) ; this . ok _ button = new system . windows . forms . button ( ) ; this . calculatin _ tip = new system . windows . forms . tool _ tip ( this . components ) ; this . binding _ configuration = new system . windows . forms . binding _ source ( this . components ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . statistics _ chart ) ) . begin _ init ( ) ;
this . calculation _ container = new system . windows . forms . flow _ layout _ panel ( ) ; this . server _ selector = new system . windows . forms . combo _ box ( ) ; this . cancel _ button = new system . windows . forms . button ( ) ; this . ok _ button = new system . windows . forms . button ( ) ; this . calculatin _ tip = new system . windows . forms . tool _ tip ( this . components ) ; this . binding _ configuration = new system . windows . forms . binding _ source ( this . components ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . statistics _ chart ) ) . begin _ init ( ) ; this . chart _ mode _ selector . suspend _ layout ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . begin _ init ( ) ;
this . chart _ mode _ selector . suspend _ layout ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . begin _ init ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . suspend _ layout ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . begin _ init ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . suspend _ layout ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . data _ collection _ minutes _ num ) ) . begin _ init ( ) ;
this . split _ container . panel . controls . add ( this . data _ collection _ minutes _ num ) ; this . split _ container . panel . controls . add ( this . statistics _ enabled _ check _ box ) ; this . split _ container . panel . controls . add ( this . choice _ kept _ minutes _ num ) ; this . split _ container . panel . controls . add ( this . by _ hour _ of _ day _ check _ box ) ; this . split _ container . panel . controls . add ( this . repeat _ times _ num ) ; this . split _ container . panel . controls . add ( this . package _ per _ ping _ label ) ; this . split _ container . panel . controls . add ( this . keep _ choice _ for _ label ) ; this . split _ container . panel . controls . add ( this . ping _ check _ box ) ; this . split _ container . panel . controls . add ( this . minutes _ label ) ; this . split _ container . panel . controls . add ( this . split _ container ) ;
this . split _ container . panel . controls . add ( this . ping _ check _ box ) ; this . split _ container . panel . controls . add ( this . minutes _ label ) ; this . split _ container . panel . controls . add ( this . split _ container ) ; this . split _ container . size = new system . drawing . size ( NUM , NUM ) ; this . split _ container . splitter _ distance = NUM ; this . split _ container . splitter _ width = NUM ; this . split _ container . tab _ index = NUM ; this . data _ collection _ minutes _ num . data _ bindings . add ( new system . windows . forms . binding ( STR , this . binding _ configuration , STR , true ) ) ; this . data _ collection _ minutes _ num . increment = new decimal ( new int [ ] { NUM ,
this . split _ container . panel . controls . add ( this . split _ container ) ; this . split _ container . size = new system . drawing . size ( NUM , NUM ) ; this . split _ container . splitter _ distance = NUM ; this . split _ container . splitter _ width = NUM ; this . split _ container . tab _ index = NUM ; this . data _ collection _ minutes _ num . data _ bindings . add ( new system . windows . forms . binding ( STR , this . binding _ configuration , STR , true ) ) ; this . data _ collection _ minutes _ num . increment = new decimal ( new int [ ] { NUM , 0 , 0 ,
this . split _ container . panel . controls . add ( this . calculation _ container ) ; this . split _ container . size = new system . drawing . size ( NUM , NUM ) ; this . split _ container . splitter _ distance = NUM ; this . split _ container . splitter _ width = 1 ; this . split _ container . tab _ index = NUM ; this . final _ score _ label . auto _ size = true ; this . final _ score _ label . location = new system . drawing . point ( NUM , NUM ) ; this . final _ score _ label . margin = new system . windows . forms . padding ( NUM , 0 , NUM , 0 ) ; this . final _ score _ label . name = STR ; this . final _ score _ label . size = new system . drawing . size ( NUM , NUM ) ;
this . calculation _ container . auto _ scroll = true ; this . calculation _ container . dock = system . windows . forms . dock _ style . fill ; this . calculation _ container . location = new system . drawing . point ( 0 , 0 ) ; this . calculation _ container . margin = new system . windows . forms . padding ( NUM , NUM , NUM , NUM ) ; this . calculation _ container . name = STR ; this . calculation _ container . size = new system . drawing . size ( NUM , NUM ) ; this . calculation _ container . tab _ index = 1 ; this . server _ selector . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . bottom | system . windows . forms . anchor _ styles . right ) ) ) ; this . server _ selector . formatting _ enabled = true ; this . server _ selector . location = new system . drawing . point ( NUM , NUM ) ;
this . chart _ mode _ selector . resume _ layout ( false ) ; this . chart _ mode _ selector . perform _ layout ( ) ; this . split _ container . panel . resume _ layout ( false ) ; this . split _ container . panel . resume _ layout ( false ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . end _ init ( ) ; this . split _ container . resume _ layout ( false ) ; this . split _ container . panel . resume _ layout ( false ) ; this . split _ container . panel . perform _ layout ( ) ; this . split _ container . panel . resume _ layout ( false ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . end _ init ( ) ;
private system . windows . forms . group _ box chart _ mode _ selector ; private system . windows . forms . radio _ button all _ mode ; private system . windows . forms . radio _ button day _ mode ; private system . windows . forms . split _ container split _ container ; private system . windows . forms . label final _ score _ label ; private system . windows . forms . split _ container split _ container ; private system . windows . forms . flow _ layout _ panel calculation _ container ; private system . windows . forms . split _ container split _ container ; private system . windows . forms . numeric _ up _ down repeat _ times _ num ; private system . windows . forms . label package _ per _ ping _ label ;
private system . windows . forms . split _ container split _ container ; private system . windows . forms . flow _ layout _ panel calculation _ container ; private system . windows . forms . split _ container split _ container ; private system . windows . forms . numeric _ up _ down repeat _ times _ num ; private system . windows . forms . label package _ per _ ping _ label ; private system . windows . forms . check _ box by _ hour _ of _ day _ check _ box ; private system . windows . forms . numeric _ up _ down choice _ kept _ minutes _ num ; private system . windows . forms . check _ box statistics _ enabled _ check _ box ; private system . windows . forms . label collect _ data _ per _ label ; private system . windows . forms . label minutes _ label ;
private system . windows . forms . check _ box by _ hour _ of _ day _ check _ box ; private system . windows . forms . numeric _ up _ down choice _ kept _ minutes _ num ; private system . windows . forms . check _ box statistics _ enabled _ check _ box ; private system . windows . forms . label collect _ data _ per _ label ; private system . windows . forms . label minutes _ label ; private system . windows . forms . numeric _ up _ down data _ collection _ minutes _ num ; private system . windows . forms . binding _ source binding _ configuration ; private new system . windows . forms . button cancel _ button ; private system . windows . forms . button ok _ button ; private system . windows . forms . combo _ box server _ selector ;
private system . windows . forms . numeric _ up _ down data _ collection _ minutes _ num ; private system . windows . forms . binding _ source binding _ configuration ; private new system . windows . forms . button cancel _ button ; private system . windows . forms . button ok _ button ; private system . windows . forms . combo _ box server _ selector ; private system . windows . forms . tool _ tip calculatin _ tip ; } }
this . hot _ key _ item = create _ menu _ item ( STR , new event _ handler ( this . hot _ key _ item _ click ) ) , create _ menu _ group ( STR , new menu _ item [ ] { create _ menu _ item ( STR , new event _ handler ( this . show _ log _ item _ click ) ) , this . verbose _ logging _ toggle _ item = create _ menu _ item ( STR , new event _ handler ( this . verbose _ logging _ toggle _ item _ click ) ) , create _ menu _ group ( STR , new menu _ item [ ] { create _ menu _ item ( STR , new event _ handler ( this . check _ updates _ item _ click ) ) , new menu _ item ( STR ) , this . auto _ check _ updates _ toggle _ item = create _ menu _ item ( STR , new event _ handler ( this . auto _ check _ updates _ toggle _ item _ click ) ) , this . check _ pre _ release _ toggle _ item = create _ menu _ item ( STR , new event _ handler ( this . check _ pre _ release _ toggle _ item _ click ) ) , } ) ,
} ) ,

using shadowsocks _ controller _ strategy ; using shadowsocks _ model ; using shadowsocks _ util ; namespace shadowsocks _ controller { public class shadowsocks _ controller
using shadowsocks _ util ; namespace shadowsocks _ controller { public class shadowsocks _ controller { private thread ram _ thread ; private thread traffic _ thread ;
namespace shadowsocks _ controller { public class shadowsocks _ controller { private thread ram _ thread ; private thread traffic _ thread ; private listener listener ; private pac _ server pac _ server ; private configuration config ; private strategy _ manager strategy _ manager ;
} public void toggle _ global ( bool global ) { config . global = global ; save _ config ( config ) ; enable _ global _ changed ? . invoke ( this , new event _ args ( ) ) ;
} public void toggle _ share _ over _ lan ( bool enabled ) { config . share _ over _ lan = enabled ; save _ config ( config ) ; share _ over _ lan _ status _ changed ? . invoke ( this , new event _ args ( ) ) ;
} public void save _ proxy ( proxy _ config proxy _ config ) { config . proxy = proxy _ config ; save _ config ( config ) ; } public void toggle _ verbose _ logging ( bool enabled ) { config . is _ verbose _ logging = enabled ; save _ config ( config ) ;
} public void touch _ user _ rule _ file ( ) { string user _ rule _ filename = pac _ server . touch _ user _ rule _ file ( ) ; user _ rule _ file _ ready _ to _ open ? . invoke ( this , new path _ event _ args ( ) { path = user _ rule _ filename } ) ; }
} public string get _ server _ url _ for _ current _ server ( ) { server server = get _ current _ server ( ) ; return get _ server _ url ( server ) ; } public static string get _ server _ url ( server server ) { string tag = string . empty ; string url = string . empty ;
} public void save _ pac _ url ( string pac _ url ) { config . pac _ url = pac _ url ; save _ config ( config ) ; config _ changed ? . invoke ( this , new event _ args ( ) ) ;
} public void use _ online _ pac ( bool use _ online _ pac ) { config . use _ online _ pac = use _ online _ pac ; save _ config ( config ) ; config _ changed ? . invoke ( this , new event _ args ( ) ) ;
} public void toggle _ secure _ local _ pac ( bool enabled ) { config . secure _ local _ pac = enabled ; save _ config ( config ) ; config _ changed ? . invoke ( this , new event _ args ( ) ) ;
} public void toggle _ checking _ update ( bool enabled ) { config . auto _ check _ update = enabled ; configuration . save ( config ) ; config _ changed ? . invoke ( this , new event _ args ( ) ) ;
} public void toggle _ checking _ pre _ release ( bool enabled ) { config . check _ pre _ release = enabled ; configuration . save ( config ) ; config _ changed ? . invoke ( this , new event _ args ( ) ) ;
} public void save _ log _ viewer _ config ( log _ viewer _ config new _ config ) { config . log _ viewer = new _ config ; new _ config . save _ size ( ) ; configuration . save ( config ) ; config _ changed ? . invoke ( this , new event _ args ( ) ) ;
} public void save _ hotkey _ config ( hotkey _ config new _ config ) { config . hotkey = new _ config ; save _ config ( config ) ; config _ changed ? . invoke ( this , new event _ args ( ) ) ;
} public void update _ latency ( server server , time _ span latency ) { if ( config . availability _ statistics ) { availability _ statistics . update _ latency ( server , ( int ) latency . total _ milliseconds ) ; } } public void update _ inbound _ counter ( server server , long n ) {
listener = new listener ( services ) ; listener . start ( config ) ; } catch ( exception e ) { if ( e is socket _ exception se ) { if ( se . socket _ error _ code = = socket _ error . address _ already _ in _ use ) {
if ( se . socket _ error _ code = = socket _ error . address _ already _ in _ use ) { e = new exception ( n . get _ string ( STR , config . local _ port ) , e ) ; } else if ( se . socket _ error _ code = = socket _ error . access _ denied ) { e = new exception ( n . get _ string ( STR , config . local _ port ) , e ) ; } } logging . log _ useful _ exception ( e ) ;
traffic _ thread . start ( ) ; } private void traffic _ statistics ( int queue _ max _ size ) { traffic _ per _ second previous , current ; while ( true ) { previous = traffic _ per _ second _ queue . last ( ) ; current = new traffic _ per _ second {
current . inbound _ increasement = current . inbound _ counter - previous . inbound _ counter ; current . outbound _ increasement = current . outbound _ counter - previous . outbound _ counter ; traffic _ per _ second _ queue . enqueue ( current ) ; if ( traffic _ per _ second _ queue . count > queue _ max _ size ) traffic _ per _ second _ queue . dequeue ( ) ; traffic _ changed ? . invoke ( this , new event _ args ( ) ) ; thread . sleep ( NUM ) ; } } }
} private void receive _ callback ( i _ async _ result ar ) { int length = ( int ) ar . async _ state ; try { var bytes _ read = socket . end _ receive ( ar ) ; if ( bytes _ read = = 0 ) { on _ finish ( length ) ;
return ; } length + = bytes _ read ; int i ; while ( ( i = index _ of ( line _ buffer , buffer _ index , length , delimiter _ bytes , delimiter _ search _ offset _ table , delimiter _ search _ char _ table ) ) ! = - 1 ) { var decode _ len = i - buffer _ index ; string line = encoding . get _ string ( line _ buffer , buffer _ index , decode _ len ) ; buffer _ index = i + delimiter _ bytes . length ;
} catch ( exception ex ) { on _ exception ( ex ) ; on _ finish ( length ) ; }
} private void on _ exception ( exception ex ) { on _ exception ? . invoke ( ex , state ) ; } private void on _ finish ( int length ) { on _ finish ? . invoke ( line _ buffer , buffer _ index , length , state ) ; } public static int index _ of ( byte [ ] haystack , int index , int length , byte [ ] needle , int [ ] offset _ table , int [ ] char _ table )
} public static int index _ of ( byte [ ] haystack , int index , int length , byte [ ] needle , int [ ] offset _ table , int [ ] char _ table ) { var end = index + length ; for ( int i = needle . length - 1 + index , j ; i < end ; ) { for ( j = needle . length - 1 ; needle [ j ] = = haystack [ i ] ; - - i , - - j ) { if ( j = = 0 ) {
{ var end = index + length ; for ( int i = needle . length - 1 + index , j ; i < end ; ) { for ( j = needle . length - 1 ; needle [ j ] = = haystack [ i ] ; - - i , - - j ) { if ( j = = 0 ) { return i ; }
{ logging . log _ useful _ exception ( ex ) ; } finally { try { udp _ socket . begin _ receive _ from ( state . buffer , 0 , state . buffer . length , 0 , ref state . remote _ end _ point , new async _ callback ( recv _ from _ callback ) , state ) ; } catch ( object _ disposed _ exception )
public udp _ handler ( socket local , server server , ip _ end _ point local _ end _ point ) { local = local ; server = server ; local _ end _ point = local _ end _ point ; ip _ address ip _ address ; bool parsed = ip _ address . try _ parse ( server . server , out ip _ address ) ; if ( ! parsed ) { ip _ host _ entry ip _ host _ info = dns . get _ host _ entry ( server . server ) ;
} public void send ( byte [ ] data , int length ) { i _ encryptor encryptor = encryptor _ factory . get _ encryptor ( server . method , server . password , server . auth , true ) ; byte [ ] data _ in = new byte [ length - NUM + iv _ encryptor . onetimeauth _ bytes ] ; array . copy ( data , NUM , data _ in , 0 , length - NUM ) ; byte [ ] data _ out = new byte [ length - NUM + NUM + iv _ encryptor . onetimeauth _ bytes ] ; int outlen ; encryptor . encrypt ( data _ in , length - NUM , data _ out , out outlen ) ; logging . debug ( local _ end _ point , remote _ end _ point , outlen , STR ) ;
} else if ( global ) { icon _ copy . set _ pixel ( x , y , color . from _ argb ( color . a , 0 , color . g , 0 ) ) ; } else { icon _ copy . set _ pixel ( x , y , color . from _ argb ( color . a , color . r , color . g , 0 ) ) ;
} else { icon _ copy . set _ pixel ( x , y , color . from _ argb ( color . a , color . r , color . g , 0 ) ) ;

var ret = new list < data _ list > ( ) ; try { var ip = dns . get _ host _ addresses ( server . server ) . first ( ip = > ( ip . address _ family = = address _ family . inter _ network | | ip . address _ family = = address _ family . inter _ network ) ) ; var ping = new ping ( ) ; foreach ( var timestamp in enumerable . range ( 0 , repeat ) . select ( = > date _ time . now . to _ string ( date _ time _ pattern ) ) ) { try { var reply = await ping . send _ task _ async ( ip , timeout ) ; ret . add ( new list < key _ value _ pair < string , string > >
{ new key _ value _ pair < string , string > ( STR , timestamp ) , new key _ value _ pair < string , string > ( STR , server . friendly _ name ( ) ) , new key _ value _ pair < string , string > ( STR , reply ? . status . to _ string ( ) ) , new key _ value _ pair < string , string > ( STR , reply ? . roundtrip _ time . to _ string ( ) ) } ) ; thread . sleep ( timeout + new random ( ) . next ( ) % timeout ) ; } catch ( exception e ) {
} return ret ; } private void run ( object obj ) { load _ raw _ statistics ( ) ; filter _ raw _ statistics ( ) ; evaluate ( ) ; } private async void evaluate ( )
} public void end _ connect _ dest ( i _ async _ result async _ result ) { remote . end _ connect ( async _ result ) ; remote . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; } public void begin _ send ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) {
} public void begin _ send ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) { remote ? . begin _ send ( buffer , offset , size , socket _ flags , callback , state ) ; } public int end _ send ( i _ async _ result async _ result ) { return remote . end _ send ( async _ result ) ; }
using system _ net ; using system _ net _ sockets ; using system _ text ; using system _ threading ; using shadowsocks _ controller ; using shadowsocks _ util _ sockets ; namespace shadowsocks _ proxy { public class socks _ proxy : i _ proxy {
namespace shadowsocks _ proxy { public class socks _ proxy : i _ proxy { private class fake _ async _ result : i _ async _ result { public readonly socks _ state inner _ state ; private readonly i _ async _ result r ; public fake _ async _ result ( i _ async _ result orig , socks _ state state ) {
} private void connect _ callback ( i _ async _ result ar ) { var state = ( socks _ state ) ar . async _ state ; try { remote . end _ connect ( ar ) ; remote . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; byte [ ] handshake = { NUM , 1 , 0 } ;
byte [ ] handshake = { NUM , 1 , 0 } ; remote . begin _ send ( handshake , 0 , handshake . length , 0 , socks _ handshake _ send _ callback , state ) ; } catch ( exception ex ) { state . ex = ex ; state . callback ? . invoke ( new fake _ async _ result ( ar , state ) ) ; } } private void socks _ handshake _ send _ callback ( i _ async _ result ar )
{ if ( config . enabled ) { system _ proxy . enable ( ) ; } else { system _ proxy . disable ( ) ;
{ system _ proxy . enable ( ) ; } else { system _ proxy . disable ( ) ; } } private void enable _ item _ click ( object sender , event _ args e ) {
get { object obj = resource _ manager . get _ object ( STR , resource _ culture ) ; return ( ( byte [ ] ) ( obj ) ) ; } } } }
} } } }
string proxy = STR ; pac = pac . replace ( STR , proxy ) ; if ( bytes _ read > 0 ) { string text = string . format ( @ STR server : shadowsocks content - type : application / x - ns - proxy - autoconfig content - length : { 0 } connection : close STR
this . panel = new system . windows . forms . panel ( ) ; this . button = new system . windows . forms . button ( ) ; this . button = new system . windows . forms . button ( ) ; this . panel = new system . windows . forms . panel ( ) ; this . context _ menu = new system . windows . forms . context _ menu ( ) ; this . enable _ item = new system . windows . forms . menu _ item ( ) ; this . about _ item = new system . windows . forms . menu _ item ( ) ; this . menu _ item = new system . windows . forms . menu _ item ( ) ; this . quit _ item = new system . windows . forms . menu _ item ( ) ; this . config _ item = new system . windows . forms . menu _ item ( ) ;
this . table _ layout _ panel . suspend _ layout ( ) ; this . panel . suspend _ layout ( ) ; this . suspend _ layout ( ) ; this . table _ layout _ panel . auto _ size = true ; this . table _ layout _ panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . table _ layout _ panel . column _ count = 2 ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , NUM ) ;
this . panel . suspend _ layout ( ) ; this . suspend _ layout ( ) ; this . table _ layout _ panel . auto _ size = true ; this . table _ layout _ panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . table _ layout _ panel . column _ count = 2 ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , 0 ) ; this . table _ layout _ panel . controls . add ( this . label , 0 , 1 ) ;
this . notify _ icon . icon = ( ( system . drawing . icon ) ( resources . get _ object ( STR ) ) ) ; this . notify _ icon . text = STR ; this . notify _ icon . visible = true ; this . notify _ icon . double _ click + = new system . event _ handler ( this . notify _ icon _ double _ click ) ;
this . panel . anchor = system . windows . forms . anchor _ styles . top ; this . panel . auto _ size = true ; this . panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . panel . location = new system . drawing . point ( NUM , NUM ) ; this . panel . name = STR ; this . panel . size = new system . drawing . size ( 0 , 0 ) ; this . panel . tab _ index = 1 ; this . button . dialog _ result = system . windows . forms . dialog _ result . ok ; this . button . location = new system . drawing . point ( NUM , NUM ) ; this . button . name = STR ;
private system . windows . forms . label label ; private system . windows . forms . combo _ box combo _ box ; private system . windows . forms . panel panel ; private system . windows . forms . button button ; private system . windows . forms . button button ; private system . windows . forms . panel panel ; private system . windows . forms . context _ menu context _ menu ; private system . windows . forms . menu _ item enable _ item ; private system . windows . forms . menu _ item about _ item ; private system . windows . forms . menu _ item menu _ item ;
} }
this . table _ layout _ panel . suspend _ layout ( ) ; this . panel . suspend _ layout ( ) ; this . suspend _ layout ( ) ; this . table _ layout _ panel . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( ( system . windows . forms . anchor _ styles . top | system . windows . forms . anchor _ styles . left ) | system . windows . forms . anchor _ styles . right ) ) ) ; this . table _ layout _ panel . auto _ size = true ; this . table _ layout _ panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . table _ layout _ panel . column _ count = 2 ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ;
this . table _ layout _ panel . name = STR ; this . table _ layout _ panel . padding = new system . windows . forms . padding ( NUM ) ; this . table _ layout _ panel . row _ count = NUM ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ; this . table _ layout _ panel . tab _ index = 0 ;

private void update _ online _ pacurl _ item _ click ( object sender , event _ args e ) { string orig _ pac _ url = controller . get _ configuration ( ) . pac _ url ; string pac _ url = microsoft . visual _ basic . interaction . input _ box ( n . get _ string ( STR ) , n . get _ string ( STR ) , orig _ pac _ url , - 1 , - 1 ) ; if ( ! string . is _ null _ or _ empty ( pac _ url ) & & pac _ url ! = orig _ pac _ url ) { controller . save _ pac _ url ( pac _ url ) ;
} } }
} catch ( exception ex ) { error ? . invoke ( this , new error _ event _ args ( ex ) ) ; } }
} } public void update _ pac _ from _ gfw _ list ( configuration config ) { web _ client http = new web _ client ( ) ; http . proxy = new web _ proxy ( ip _ address . loopback . to _ string ( ) , config . local _ port ) ; http . download _ string _ completed + = http _ download _ string _ completed ; http . download _ string _ async ( new uri ( gfwlist _ url ) ) ; } public static list < string > parse _ result ( string response )
using system _ collections _ generic ; using system _ globalization ; using system _ io ; namespace shadowsocks _ controller { using shadowsocks _ properties ; public class n { protected static dictionary < string , string > strings ; static n ( )
namespace shadowsocks _ controller { using shadowsocks _ properties ; public class n { protected static dictionary < string , string > strings ; static n ( ) { strings = new dictionary < string , string > ( ) ; if ( culture _ info . current _ culture . ietf _ language _ tag . starts _ with ( STR , string _ comparison . ordinal _ ignore _ case ) )
{ using ( var sr = new string _ reader ( resources . cn ) ) { string line ; while ( ( line = sr . read _ line ( ) ) ! = null ) { if ( line [ 0 ] = = '#' )
{ string line ; while ( ( line = sr . read _ line ( ) ) ! = null ) { if ( line [ 0 ] = = '#' ) continue ; var pos = line . index _ of ( '=' ) ; if ( pos < 1 ) continue ;
{ if ( line [ 0 ] = = '#' ) continue ; var pos = line . index _ of ( '=' ) ; if ( pos < 1 ) continue ; strings [ line . substring ( 0 , pos ) ] = line . substring ( pos + 1 ) ; } } }
} } } } public static string get _ string ( string key ) { if ( strings . contains _ key ( key ) ) { return strings [ key ] ; }
return true ; else if ( item . equals ( STR , string _ comparison . ordinal _ ignore _ case ) ) { string value = convert . to _ string ( run _ key . get _ value ( item ) ) ; if ( path . equals ( value , string _ comparison . ordinal _ ignore _ case ) ) { run _ key . delete _ value ( item ) ; run _ key . set _ value ( key , path ) ; return true ; }
{ string value = convert . to _ string ( run _ key . get _ value ( item ) ) ; if ( path . equals ( value , string _ comparison . ordinal _ ignore _ case ) ) { run _ key . delete _ value ( item ) ; run _ key . set _ value ( key , path ) ; return true ; } } }
{ run _ key . delete _ value ( item ) ; run _ key . set _ value ( key , path ) ; return true ; } } } return false ; } catch ( exception e )
try { int bytes _ read = conn . end _ receive ( ar ) ; string pac = get _ pac _ content ( ) ; ip _ end _ point local _ end _ point = ( ip _ end _ point ) conn . local _ end _ point ; string proxy = get _ pac _ address ( request _ buf , local _ end _ point ) ; pac = pac . replace ( STR , proxy ) ; if ( bytes _ read > 0 ) { string text = string . format ( @ STR
pac = pac . replace ( STR , proxy ) ; if ( bytes _ read > 0 ) { string text = string . format ( @ STR server : shadowsocks content - type : application / x - ns - proxy - autoconfig content - length : { 0 } connection : close STR byte [ ] response = system . text . encoding . ut . get _ bytes ( text ) ;
method = encryption _ select . text , remarks = remarks _ text _ box . text } ; int local _ port = int . parse ( proxy _ port _ text _ box . text ) ; configuration . check _ server ( server ) ; configuration . check _ port ( local _ port ) ; modified _ configuration . configs [ old _ selected _ index ] = server ; modified _ configuration . local _ port = local _ port ; return true ; }
private bool share _ over _ lan ; socket listener ; public local ( configuration config ) { this . config = config ; share _ over _ lan = config . share _ over _ lan ; } public void start ( ) { try
share _ over _ lan = config . share _ over _ lan ; } public void start ( ) { try { listener = new socket ( address _ family . inter _ network , socket _ type . stream , protocol _ type . tcp ) ; listener . set _ socket _ option ( socket _ option _ level . socket , socket _ option _ name . reuse _ address , true ) ; ip _ end _ point local _ end _ point = null ; if ( share _ over _ lan )
} else { local _ end _ point = new ip _ end _ point ( ip _ address . loopback , config . local _ port ) ; } listener . bind ( local _ end _ point ) ; listener . listen ( NUM ) ; console . write _ line ( STR ) ; listener . begin _ accept ( new async _ callback ( accept _ callback ) ,
} listener . bind ( local _ end _ point ) ; listener . listen ( NUM ) ; console . write _ line ( STR ) ; listener . begin _ accept ( new async _ callback ( accept _ callback ) , listener ) ; } catch ( socket _ exception ) {
if ( ! parsed ) { ip _ host _ entry ip _ host _ info = dns . get _ host _ entry ( server . server ) ; ip _ address = ip _ host _ info . address _ list [ 0 ] ; } ip _ end _ point remote _ ep = new ip _ end _ point ( ip _ address , server . server _ port ) ; remote = new socket ( ip _ address . address _ family , socket _ type . stream , protocol _ type . tcp ) ; remote . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; remote . begin _ connect ( remote _ ep ,
ip _ address = ip _ host _ info . address _ list [ 0 ] ; } ip _ end _ point remote _ ep = new ip _ end _ point ( ip _ address , server . server _ port ) ; remote = new socket ( ip _ address . address _ family , socket _ type . stream , protocol _ type . tcp ) ; remote . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; remote . begin _ connect ( remote _ ep , new async _ callback ( connect _ callback ) , null ) ; } catch ( exception e )
remote = new socket ( ip _ address . address _ family , socket _ type . stream , protocol _ type . tcp ) ; remote . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; remote . begin _ connect ( remote _ ep , new async _ callback ( connect _ callback ) , null ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; this . close ( ) ;
using system _ collections _ generic ; using system _ globalization ; using system _ io ; using system _ linq ; using system _ net ; using system _ net _ network _ information ; using system _ net _ sockets ; using system _ threading ; using system _ threading _ tasks ;
using system _ net _ network _ information ; using system _ net _ sockets ; using system _ threading ; using system _ threading _ tasks ; using shadowsocks _ model ; using shadowsocks _ util ; namespace shadowsocks _ controller {
using shadowsocks _ model ; using shadowsocks _ util ; namespace shadowsocks _ controller { using data _ unit = key _ value _ pair < string , string > ; using data _ list = list < key _ value _ pair < string , string > > ; using statistics = dictionary < string , list < availability _ statistics . raw _ statistics _ data > > ; public sealed class availability _ statistics {
{ public static availability _ statistics instance { get ; } = new availability _ statistics ( ) ; private availability _ statistics ( ) { } public const string date _ time _ pattern = STR ; private const string statistics _ files _ name = STR ; private const string delimiter = STR ; private const int timeout _ milliseconds = NUM ; private readonly time _ span delay _ before _ start = time _ span . from _ seconds ( 1 ) ; public statistics raw _ statistics { get ; private set ; } public statistics filtered _ statistics { get ; private set ; }
public statistics raw _ statistics { get ; private set ; } public statistics filtered _ statistics { get ; private set ; } public static readonly date _ time unknown _ date _ time = new date _ time ( NUM , 1 , 1 ) ; private int repeat = > config . repeat _ times _ num ; private readonly time _ span retry _ interval = time _ span . from _ minutes ( 2 ) ; private time _ span interval = > time _ span . from _ minutes ( config . data _ collection _ minutes ) ; private timer timer ; private timer speed _ monior ; private state state ; private list < server > servers ;
private long last _ inbound _ counter = 0 ; private long last _ outbound _ counter = 0 ; private readonly time _ span monitor _ interval = time _ span . from _ seconds ( 1 ) ; static availability _ statistics ( ) { availability _ statistics _ file = utils . get _ temp _ path ( statistics _ files _ name ) ; }
public bool set ( statistics _ strategy _ configuration config ) { config = config ; try { if ( config . statistics _ enabled ) { if ( timer ? . change ( delay _ before _ start , interval ) = = null ) { state = new state ( ) ;
} private string get _ recent _ inbound _ speed ( server server ) { return server ! = current _ server ? empty : inbound _ speed . to _ string ( ) ; } private string get _ recent _ latency ( server server ) { if ( server ! = current _ server ) return empty ;
} private string get _ recent _ latency ( server server ) { if ( server ! = current _ server ) return empty ; return latency = = null ? empty : latency . to _ string ( ) ; } private void reset _ speed ( ) { current _ server = controller . get _ current _ server ( ) ; latency = null ;
latency = null ; inbound _ speed = 0 ; outbound _ speed = 0 ; } private void run ( object obj ) { if ( speed _ monior ? . change ( delay _ before _ start , monitor _ interval ) = = null ) { speed _ monior = new timer ( update _ speed , null , delay _ before _ start , monitor _ interval ) ; }
reset _ speed ( ) ; set ( controller . statistics _ configuration ) ; servers = controller . get _ current _ configuration ( ) . configs ; } private void filter _ raw _ statistics ( ) { if ( raw _ statistics = = null ) return ; if ( filtered _ statistics = = null ) { filtered _ statistics = new statistics ( ) ;
{ if ( raw _ statistics = = null ) return ; if ( filtered _ statistics = = null ) { filtered _ statistics = new statistics ( ) ; } foreach ( i _ enumerable < raw _ statistics _ data > raw _ data in raw _ statistics . values ) { var filtered _ data = raw _ data ; if ( config . by _ hour _ of _ day )
} } public void update _ inbound _ counter ( server server , long n ) { interlocked . add ( ref inbound _ counter , n ) ; if ( config . availability _ statistics ) { availability _ statistics . update _ inbound _ counter ( server , n ) ; } }
} } public void update _ outbound _ counter ( server server , long n ) { interlocked . add ( ref outbound _ counter , n ) ; if ( config . availability _ statistics ) { availability _ statistics . update _ outbound _ counter ( server , n ) ; } }
} } protected void reload ( ) { config = configuration . load ( ) ; statistics _ configuration = statistics _ strategy _ configuration . load ( ) ; if ( polipo _ runner = = null ) { polipo _ runner = new polipo _ runner ( ) ; }
process = null ; } refresh _ tray _ area ( ) ; } private static void kill _ process ( process p ) { try { p . close _ main _ window ( ) ; p . wait _ for _ exit ( NUM ) ;
var last _ outbound = last _ outbound _ counter [ id ] ; var outbound = outbound _ counter [ id ] ; bytes = outbound - last _ outbound ; last _ outbound _ counter [ id ] = outbound ; var outbound _ speed = get _ speed _ in _ ki _ b _ per _ second ( bytes , monitor _ interval . total _ seconds ) ; outbound _ speed _ records . get _ or _ add ( id , ( k ) = > { list < int > records = new list < int > ( ) ; records . add ( outbound _ speed ) ; return records ;
logging . debug ( $ STR ) ; }
} private void reset ( ) { inbound _ speed _ records . clear ( ) ; outbound _ speed _ records . clear ( ) ; latency _ records . clear ( ) ; } private void run ( object ) { update _ records ( ) ;
reset ( ) ; } private void update _ records ( ) { var records = new dictionary < string , statistics _ record > ( ) ; update _ records _ state state = new update _ records _ state ( ) ; state . counter = controller . get _ current _ configuration ( ) . configs . count ; foreach ( var server in controller . get _ current _ configuration ( ) . configs ) {
{ var records = new dictionary < string , statistics _ record > ( ) ; update _ records _ state state = new update _ records _ state ( ) ; state . counter = controller . get _ current _ configuration ( ) . configs . count ; foreach ( var server in controller . get _ current _ configuration ( ) . configs ) { var id = server . identifier ( ) ; list < int > inbound _ speed _ records = null ; list < int > outbound _ speed _ records = null ; list < int > latency _ records = null ;
} } private void append _ record ( string server _ identifier , statistics _ record record ) { try { list < statistics _ record > records ; lock ( raw _ statistics ) { if ( ! raw _ statistics . try _ get _ value ( server _ identifier , out records ) )
} private void save ( ) { logging . debug ( $ STR ) ; if ( raw _ statistics . count = = 0 ) { return ; } try {
file . write _ all _ text ( availability _ statistics _ file , content ) ; } catch ( io _ exception e ) { logging . log _ useful _ exception ( e ) ; } } private bool is _ valid _ record ( statistics _ record record ) { if ( config . by _ hour _ of _ day )
} public void dispose ( ) { recorder . dispose ( ) ; speed _ monior . dispose ( ) ; } public void update _ latency ( server server , int latency ) { latency _ records . get _ or _ add ( server . identifier ( ) , ( k ) = > {
} public void update _ inbound _ counter ( server server , long n ) { inbound _ counter . add _ or _ update ( server . identifier ( ) , ( k ) = > { last _ inbound _ counter . get _ or _ add ( server . identifier ( ) , 0 ) ; return n ; } , ( k , v ) = > ( v + n ) ) ;
} public void update _ outbound _ counter ( server server , long n ) { outbound _ counter . add _ or _ update ( server . identifier ( ) , ( k ) = > { last _ outbound _ counter . get _ or _ add ( server . identifier ( ) , 0 ) ; return n ; } , ( k , v ) = > ( v + n ) ) ; } class update _ records _ state
} } }
string privoxy _ log _ filename = utils . get _ temp _ path ( STR ) ; if ( file . exists ( privoxy _ log _ filename ) ) using ( new file _ stream ( privoxy _ log _ filename , file _ mode . truncate ) ) { } main _ controller = new shadowsocks _ controller ( ) ; menu _ controller = new menu _ view _ controller ( main _ controller ) ; main _ controller . program _ updated + = ( o , e ) = > { logging . info ( $ STR ) ; } ;
main _ controller = new shadowsocks _ controller ( ) ; menu _ controller = new menu _ view _ controller ( main _ controller ) ; main _ controller . program _ updated + = ( o , e ) = > { logging . info ( $ STR ) ; } ; hot _ keys . init ( main _ controller ) ; main _ controller . start ( ) ; application . run ( ) ; }
system _ proxy _ is _ dirty = true ; } else { if ( system _ proxy _ is _ dirty ) { system _ proxy . update ( config , false , pac _ server ) ; system _ proxy _ is _ dirty = false ; } }
system _ proxy _ is _ dirty = false ; } } } private void pac _ server _ pac _ file _ changed ( object sender , event _ args e ) { update _ system _ proxy ( ) ; } private void pac _ server _ pac _ update _ completed ( object sender , gfw _ list _ updater . result _ event _ args e ) {
{ public const string pac _ file = STR ; public const string user _ rule _ file = STR ; public const string user _ abp _ file = STR ; public string pac _ secret { get ; private set ; } = STR ; file _ system _ watcher pac _ file _ watcher ; file _ system _ watcher user _ rule _ file _ watcher ; private configuration config ; public event event _ handler pac _ file _ changed ; public event event _ handler user _ rule _ file _ changed ;
object [ ] state = new object [ ] { conn , request _ buf } ; conn . begin _ receive ( request _ buf , 0 , request _ buf . length , 0 , new async _ callback ( receive _ callback ) , state ) ; } catch ( object _ disposed _ exception ) { }
} ; conn . begin _ receive ( request _ buf , 0 , request _ buf . length , 0 , new async _ callback ( receive _ callback ) , state ) ; } catch ( object _ disposed _ exception ) { } catch ( exception e ) { console . write _ line ( e ) ;
new async _ callback ( receive _ callback ) , state ) ; } catch ( object _ disposed _ exception ) { } catch ( exception e ) { console . write _ line ( e ) ; } finally
int n ; using ( g _ zip _ stream input = new g _ zip _ stream ( new memory _ stream ( pac _ gz ) , compression _ mode . decompress , false ) ) { while ( ( n = input . read ( buffer , 0 , buffer . length ) ) > 0 ) { sb . write ( buffer , 0 , n ) ; }
{ sb . write ( buffer , 0 , n ) ; } return system . text . encoding . ut . get _ string ( sb . to _ array ( ) ) ; } } } private void receive _ callback ( i _ async _ result ar ) { object [ ] state = ( object [ ] ) ar . async _ state ;
} return system . text . encoding . ut . get _ string ( sb . to _ array ( ) ) ; } } } private void receive _ callback ( i _ async _ result ar ) { object [ ] state = ( object [ ] ) ar . async _ state ; socket conn = ( socket ) state [ 0 ] ; byte [ ] request _ buf = ( byte [ ] ) state [ 1 ] ;
} } } private void receive _ callback ( i _ async _ result ar ) { object [ ] state = ( object [ ] ) ar . async _ state ; socket conn = ( socket ) state [ 0 ] ; byte [ ] request _ buf = ( byte [ ] ) state [ 1 ] ; try {
{ dest _ end _ point = dest _ end _ point ; string auth _ info = STR ; if ( auth ! = null ) { string auth _ key = convert . to _ base _ string ( encoding . ut . get _ bytes ( auth . user _ name + STR + auth . password ) ) ; auth _ info = string . format ( proxy _ auth _ template , auth _ key ) ; } string request = string . format ( http _ connect _ template , dest _ end _ point , auth _ info ) ;
var b = encoding . ut . get _ bytes ( request ) ; var st = new http _ state ( ) ; st . callback = callback ; st . async _ state = state ; remote . begin _ send ( b , 0 , b . length , 0 , http _ request _ send _ callback , st ) ; } public void end _ connect _ dest ( i _ async _ result async _ result ) { var state = ( ( fake _ async _ result ) async _ result ) . inner _ state ; if ( state . ex ! = null )
} catch ( argument _ exception ) { } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; } }
} } private void proxy _ type _ combo _ box _ selected _ index _ changed ( object sender , event _ args e ) { if ( proxy _ type _ combo _ box . selected _ index ! = proxy _ config . proxy _ http ) { use _ auth _ check _ box . checked = false ; auth _ user _ text _ box . clear ( ) ; auth _ pwd _ text _ box . clear ( ) ; }
modified _ configuration = new proxy _ config ( ) ; controller . save _ proxy _ config ( modified _ configuration ) ; } use _ proxy _ check _ box . checked = modified _ configuration . use _ proxy ; proxy _ server _ text _ box . text = modified _ configuration . proxy _ server ; proxy _ port _ text _ box . text = modified _ configuration . proxy _ port . to _ string ( ) ; } private void ok _ button _ click ( object sender , event _ args e ) { if ( use _ proxy _ check _ box . checked )
} private void use _ proxy _ check _ box _ checked _ changed ( object sender , event _ args e ) { update _ enabled ( ) ; } private void update _ enabled ( ) { if ( use _ proxy _ check _ box . checked ) { proxy _ server _ text _ box . enabled = true ;
byte [ ] input , int ioff , uint ilen , byte [ ] output ) ; } }
disposed = true ; } if ( disposing ) { } if ( encrypt _ ctx ! = int _ ptr . zero ) { mbed _ tls . cipher _ free ( encrypt _ ctx ) ; marshal . free _ h _ global ( encrypt _ ctx ) ; encrypt _ ctx = int _ ptr . zero ;
} } } }
if ( disposing ) { } close ( ) ; } private void close ( ) { if ( handle ! = int _ ptr . zero ) { close _ handle ( handle ) ; handle = int _ ptr . zero ;
} private void close ( ) { if ( handle ! = int _ ptr . zero ) { close _ handle ( handle ) ; handle = int _ ptr . zero ; } } ~ job ( )
{ if ( handle ! = int _ ptr . zero ) { close _ handle ( handle ) ; handle = int _ ptr . zero ; } } ~ job ( ) { dispose ( false ) ;
} public bool add _ process ( int _ ptr process _ handle ) { var succ = assign _ process _ to _ job _ object ( handle , process _ handle ) ; if ( ! succ ) { logging . error ( STR + marshal . get _ last _ win _ error ( ) ) ; } return succ ; }
{ average _ inbound _ speed = ( int ) inbound . average ( ) ; min _ inbound _ speed = inbound . min ( ) ; max _ inbound _ speed = inbound . max ( ) ; } var outbound = outbound _ speed _ records ? . where ( s = > s > 0 ) . to _ list ( ) ; if ( outbound ! = null & & outbound . any ( ) ) { average _ outbound _ speed = ( int ) outbound . average ( ) ;
} var outbound = outbound _ speed _ records ? . where ( s = > s > 0 ) . to _ list ( ) ; if ( outbound ! = null & & outbound . any ( ) ) { average _ outbound _ speed = ( int ) outbound . average ( ) ; min _ outbound _ speed = outbound . min ( ) ; max _ outbound _ speed = outbound . max ( ) ; } var latency = latency _ records ? . where ( s = > s > 0 ) . to _ list ( ) ;
{ average _ outbound _ speed = ( int ) outbound . average ( ) ; min _ outbound _ speed = outbound . min ( ) ; max _ outbound _ speed = outbound . max ( ) ; } var latency = latency _ records ? . where ( s = > s > 0 ) . to _ list ( ) ; if ( latency ! = null & & latency . any ( ) ) { average _ latency = ( int ) latency . average ( ) ;
} var latency = latency _ records ? . where ( s = > s > 0 ) . to _ list ( ) ; if ( latency ! = null & & latency . any ( ) ) { average _ latency = ( int ) latency . average ( ) ; min _ latency = latency . min ( ) ; max _ latency = latency . max ( ) ; } }
{ average _ latency = ( int ) latency . average ( ) ; min _ latency = latency . min ( ) ; max _ latency = latency . max ( ) ; } } public statistics _ record ( string identifier , i _ collection < int? > response _ records ) { server _ identifier = identifier ; set _ response ( response _ records ) ;
} } public statistics _ record ( string identifier , i _ collection < int? > response _ records ) { server _ identifier = identifier ; set _ response ( response _ records ) ; } public void set _ response ( i _ collection < int? > response _ records ) { if ( response _ records = = null ) return ;
} ; foreach ( var data in final _ data . where ( data = > data . speed ! = 0 | | data . package _ loss _ percentage ! = 0 | | data . ping ! = 0 ) ) { data _ table . rows . add ( data . timestamp , data . speed , data . package _ loss _ percentage , data . ping ) ; } statistics _ chart . data _ bind ( ) ; } private void server _ selector _ selection _ change _ committed ( object sender , event _ args e ) { load _ chart _ data ( ) ;
{ data _ table . rows . add ( data . timestamp , data . speed , data . package _ loss _ percentage , data . ping ) ; } statistics _ chart . data _ bind ( ) ; } private void server _ selector _ selection _ change _ committed ( object sender , event _ args e ) { load _ chart _ data ( ) ; } private void day _ mode _ checked _ changed ( object sender , event _ args e )
using system _ net _ network _ information ; using system _ threading ; using newtonsoft _ json ; using shadowsocks _ model ; namespace shadowsocks _ controller _ strategy { class statistics _ strategy : i _ strategy
using newtonsoft _ json ; using shadowsocks _ model ; namespace shadowsocks _ controller _ strategy { class statistics _ strategy : i _ strategy { private readonly shadowsocks _ controller controller ;
namespace shadowsocks _ controller _ strategy { class statistics _ strategy : i _ strategy { private readonly shadowsocks _ controller controller ; private server current _ server ; private readonly timer timer ; private dictionary < string , list < availability _ statistics . raw _ statistics _ data > > filtered _ statistics ;
class statistics _ strategy : i _ strategy { private readonly shadowsocks _ controller controller ; private server current _ server ; private readonly timer timer ; private dictionary < string , list < availability _ statistics . raw _ statistics _ data > > filtered _ statistics ; private int choice _ kept _ milliseconds = > ( int ) time _ span . from _ minutes ( controller . statistics _ configuration . choice _ kept _ minutes ) . total _ milliseconds ; public statistics _ strategy ( shadowsocks _ controller controller )
private int choice _ kept _ milliseconds = > ( int ) time _ span . from _ minutes ( controller . statistics _ configuration . choice _ kept _ minutes ) . total _ milliseconds ; public statistics _ strategy ( shadowsocks _ controller controller ) { controller = controller ; var servers = controller . get _ current _ configuration ( ) . configs ; var random _ index = new random ( ) . next ( ) % servers . count ( ) ; current _ server = servers [ random _ index ] ; timer = new timer ( reload _ statistics _ and _ choose _ a _ server ) ;
public statistics _ strategy ( shadowsocks _ controller controller ) { controller = controller ; var servers = controller . get _ current _ configuration ( ) . configs ; var random _ index = new random ( ) . next ( ) % servers . count ( ) ; current _ server = servers [ random _ index ] ; timer = new timer ( reload _ statistics _ and _ choose _ a _ server ) ; } private void reload _ statistics _ and _ choose _ a _ server ( object obj ) {
} private float get _ score ( string server _ name ) { var config = controller . statistics _ configuration ; list < availability _ statistics . raw _ statistics _ data > data _ list ; if ( filtered _ statistics = = null | | ! filtered _ statistics . try _ get _ value ( server _ name , out data _ list ) ) return 0 ;
{ var config = controller . statistics _ configuration ; list < availability _ statistics . raw _ statistics _ data > data _ list ; if ( filtered _ statistics = = null | | ! filtered _ statistics . try _ get _ value ( server _ name , out data _ list ) ) return 0 ;
var success _ times = ( float ) data _ list . count ( data = > data . icmp _ status . equals ( ip _ status . success . to _ string ( ) ) ) ; var timed _ out _ times = ( float ) data _ list . count ( data = > data . icmp _ status . equals ( ip _ status . timed _ out . to _ string ( ) ) ) ; var statistics _ data = new availability _ statistics . statistics _ data ( ) { package _ loss = timed _ out _ times / ( success _ times + timed _ out _ times ) * NUM , average _ response = convert . to _ int ( data _ list . average ( data = > data . roundtrip _ time ) ) , min _ response = data _ list . min ( data = > data . roundtrip _ time ) , max _ response = data _ list . max ( data = > data . roundtrip _ time ) } ; float factor ;
{ package _ loss = timed _ out _ times / ( success _ times + timed _ out _ times ) * NUM , average _ response = convert . to _ int ( data _ list . average ( data = > data . roundtrip _ time ) ) , min _ response = data _ list . min ( data = > data . roundtrip _ time ) , max _ response = data _ list . max ( data = > data . roundtrip _ time ) } ; float factor ; float score = 0 ; if ( ! config . calculations . try _ get _ value ( STR , out factor ) ) factor = 0 ; score + = statistics _ data . package _ loss * factor ;
private void choose _ new _ server ( list < server > servers ) { if ( filtered _ statistics = = null | | servers . count = = 0 ) { return ; } try { var best _ result = ( from server in servers let name = server . friendly _ name ( )
{ return ; } try { var best _ result = ( from server in servers let name = server . friendly _ name ( ) where filtered _ statistics . contains _ key ( name ) select new {
select new { server , score = get _ score ( name ) } ) . aggregate ( ( result , result ) = > result . score > result . score ? result : result ) ; if ( ! current _ server . equals ( best _ result . server ) ) { log _ when _ enabled ( $ STR ) ; }
} ) . aggregate ( ( result , result ) = > result . score > result . score ? result : result ) ; if ( ! current _ server . equals ( best _ result . server ) ) { log _ when _ enabled ( $ STR ) ; } current _ server = best _ result . server ; } catch ( exception e ) {
using system _ net _ http ; using system _ net _ network _ information ; using system _ net _ sockets ; using system _ threading ; using system _ threading _ tasks ; using shadowsocks _ model ; using shadowsocks _ util ; namespace shadowsocks _ controller
using shadowsocks _ model ; using shadowsocks _ util ; namespace shadowsocks _ controller { using data _ unit = key _ value _ pair < string , string > ; using data _ list = list < key _ value _ pair < string , string > > ; using raw _ statistics = dictionary < string , list < availability _ statistics . raw _ statistics _ data > > ; using statistics = dictionary < string , list < availability _ statistics . statistics _ data > > ; public class availability _ statistics
namespace shadowsocks _ controller { using data _ unit = key _ value _ pair < string , string > ; using data _ list = list < key _ value _ pair < string , string > > ; using raw _ statistics = dictionary < string , list < availability _ statistics . raw _ statistics _ data > > ; using statistics = dictionary < string , list < availability _ statistics . statistics _ data > > ; public class availability _ statistics { public static readonly string date _ time _ pattern = STR ;
{ public static readonly string date _ time _ pattern = STR ; private const string statistics _ files _ name = STR ; private const string delimiter = STR ; private const int timeout = NUM ; private const int delay _ before _ start = NUM ; public raw _ statistics raw _ statistics { get ; private set ; } public raw _ statistics filtered _ statistics { get ; private set ; } private int repeat = > config . repeat _ times _ num ; private const int retry _ interval = 2 * NUM * NUM ;
( ( system . component _ model . i _ support _ initialize ) ( this . statistics _ chart ) ) . begin _ init ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . binding _ configuration ) ) . begin _ init ( ) ; this . chart _ mode _ selector . suspend _ layout ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . begin _ init ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . suspend _ layout ( ) ; ( ( system . component _ model . i _ support _ initialize ) ( this . split _ container ) ) . begin _ init ( ) ; this . split _ container . panel . suspend _ layout ( ) ; this . split _ container . panel . suspend _ layout ( ) ;
{ registered _ encryptors . add ( method , typeof ( aead _ mbed _ tls _ encryptor ) ) ; } foreach ( string method in aead _ sodium _ encryptor _ supported _ ciphers ) { registered _ encryptors . add ( method , typeof ( aead _ sodium _ encryptor ) ) ; } } public static i _ encryptor get _ encryptor ( string method , string password ) {
{ registered _ encryptors . add ( method , typeof ( aead _ sodium _ encryptor ) ) ; } } public static i _ encryptor get _ encryptor ( string method , string password ) { if ( method . is _ null _ or _ empty ( ) ) { method = STR ; }
this . close ( ) ; } } private void connect _ callback ( i _ async _ result ar ) { server server = null ; if ( closed ) { return ; }
remote . end _ connect ( ar ) ; connected = true ; var latency = date _ time . now - start _ connect _ time ; controller . get _ current _ strategy ( ) . update _ latency ( server , latency ) ; start _ pipe ( ) ; } catch ( argument _ exception e ) { } catch ( exception e )
start _ pipe ( ) ; } catch ( argument _ exception e ) { } catch ( exception e ) { if ( server ! = null ) { controller . get _ current _ strategy ( ) . set _ failure ( server ) ;
} } private void start _ pipe ( ) { if ( closed ) { return ; } try {
{ if ( ! ( each . equals ( STR ) | | each . equals ( STR ) | | each . equals ( STR ) ) ) { registry . set _ value ( each , default _ value ) ; } } system _ proxy . notify _ ie ( ) ; } catch ( io _ exception e ) {
} system _ proxy . notify _ ie ( ) ; } catch ( io _ exception e ) { logging . log _ useful _ exception ( e ) ; } } private static string get _ timestamp ( date _ time value ) { return value . to _ string ( STR ) ;
} private static string get _ timestamp ( date _ time value ) { return value . to _ string ( STR ) ; } } }
{ g . copy _ from _ screen ( screen . primary _ screen . bounds . x , screen . primary _ screen . bounds . y , 0 , 0 , image . size , copy _ pixel _ operation . source _ copy ) ; } var reader = new barcode _ reader {
copy _ pixel _ operation . source _ copy ) ; } var reader = new barcode _ reader { try _ harder = true , possible _ formats = new list < barcode _ format > { barcode _ format . qr _ code }
{ try _ harder = true , possible _ formats = new list < barcode _ format > { barcode _ format . qr _ code } } ; var result = reader . decode ( image ) ; if ( result ! = null )
{ console . write _ line ( result . text ) ; } } } private void auto _ startup _ item _ click ( object sender , event _ args e ) { auto _ startup _ item . checked = ! auto _ startup _ item . checked ;
} } } private void auto _ startup _ item _ click ( object sender , event _ args e ) { auto _ startup _ item . checked = ! auto _ startup _ item . checked ; if ( ! auto _ startup . set ( auto _ startup _ item . checked ) ) { message _ box . show ( STR ) ;
} private void auto _ startup _ item _ click ( object sender , event _ args e ) { auto _ startup _ item . checked = ! auto _ startup _ item . checked ; if ( ! auto _ startup . set ( auto _ startup _ item . checked ) ) { message _ box . show ( STR ) ; } } } }
{ console . write _ line ( e ) ; return new config { server = STR , server _ port = NUM , local _ port = NUM , password = STR , is _ default = true
} ; } } public static void save ( config config ) { data _ contract _ json _ serializer ser = new data _ contract _ json _ serializer ( typeof ( config ) ) ; try { using ( file _ stream fs = file . open ( STR , file _ mode . create ) ) {
initialize _ component ( ) ; config _ to _ text _ box ( ) ; } private void show _ window ( ) { this . opacity = 1 ; this . show ( ) ; } private void config _ to _ text _ box ( ) {
{ try { config config = new config { server = text _ box . text , server _ port = int . parse ( text _ box . text ) , password = text _ box . text , local _ port = int . parse ( text _ box . text ) , is _ default = false
} private void cancel _ button _ click ( object sender , event _ args e ) { this . hide ( ) ; config _ to _ text _ box ( ) ; } private void form _ form _ closed ( object sender , form _ closed _ event _ args e ) { local . stop ( ) ; }
{ this . hide ( ) ; config _ to _ text _ box ( ) ; } private void form _ form _ closed ( object sender , form _ closed _ event _ args e ) { local . stop ( ) ; } private void about _ tool _ strip _ menu _ item _ click ( object sender , event _ args e ) {
this . button . dialog _ result = system . windows . forms . dialog _ result . ok ; this . button . location = new system . drawing . point ( NUM , NUM ) ; this . button . name = STR ; this . button . size = new system . drawing . size ( NUM , NUM ) ; this . button . tab _ index = 0 ; this . button . text = STR ; this . button . use _ visual _ style _ back _ color = true ; this . button . click + = new system . event _ handler ( this . ok _ button _ click ) ; this . notify _ icon . context _ menu _ strip = this . context _ menu _ strip ; this . notify _ icon . icon = ( ( system . drawing . icon ) ( resources . get _ object ( STR ) ) ) ;
this . notify _ icon . context _ menu _ strip = this . context _ menu _ strip ; this . notify _ icon . icon = ( ( system . drawing . icon ) ( resources . get _ object ( STR ) ) ) ; this . notify _ icon . text = STR ; this . notify _ icon . visible = true ; this . notify _ icon . double _ click + = new system . event _ handler ( this . notify _ icon _ double _ click ) ; this . context _ menu _ strip . items . add _ range ( new system . windows . forms . tool _ strip _ item [ ] { this . config _ item , this . about _ tool _ strip _ menu _ item , this . tool _ strip _ separator , this . quit _ item } ) ;
this . config _ item . name = STR ; this . config _ item . size = new system . drawing . size ( NUM , NUM ) ; this . config _ item . text = STR ; this . config _ item . click + = new system . event _ handler ( this . config _ click ) ; this . about _ tool _ strip _ menu _ item . name = STR ; this . about _ tool _ strip _ menu _ item . size = new system . drawing . size ( NUM , NUM ) ; this . about _ tool _ strip _ menu _ item . text = STR ; this . about _ tool _ strip _ menu _ item . click + = new system . event _ handler ( this . about _ tool _ strip _ menu _ item _ click ) ; this . quit _ item . name = STR ; this . quit _ item . size = new system . drawing . size ( NUM , NUM ) ;
} public static string get _ string ( string key , params object [ ] args ) { return string . format ( strings . try _ get _ value ( key . trim ( ) , out var value ) ? value : key , args ) ; } public static void translate _ form ( form c ) { if ( c = = null ) return ; c . text = get _ string ( c . text ) ; foreach ( var item in view _ utils . get _ child _ controls < control > ( c ) )
private byte [ ] remote _ send _ buffer = new byte [ buffer _ size ] ; private byte [ ] connetion _ recv _ buffer = new byte [ recv _ size ] ; private byte [ ] connetion _ send _ buffer = new byte [ buffer _ size ] ; private bool connection _ shutdown = false ; private bool remote _ shutdown = false ; private bool closed = false ; public void start ( ) { try
private byte [ ] connetion _ recv _ buffer = new byte [ recv _ size ] ; private byte [ ] connetion _ send _ buffer = new byte [ buffer _ size ] ; private bool connection _ shutdown = false ; private bool remote _ shutdown = false ; private bool closed = false ; public void start ( ) { try {
private byte [ ] connetion _ send _ buffer = new byte [ buffer _ size ] ; private bool connection _ shutdown = false ; private bool remote _ shutdown = false ; private bool closed = false ; public void start ( ) { try { ip _ address ip _ address ;
private bool connection _ shutdown = false ; private bool remote _ shutdown = false ; private bool closed = false ; public void start ( ) { try { ip _ address ip _ address ; bool parsed = ip _ address . try _ parse ( config . server , out ip _ address ) ;
private bool connection _ shutdown = false ; private bool remote _ shutdown = false ; private bool closed = false ; public void start ( ) { try { ip _ address ip _ address ; bool parsed = ip _ address . try _ parse ( config . server , out ip _ address ) ; if ( ! parsed )
this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ; this . table _ layout _ panel . tab _ index = NUM ; this . duplicate _ button . dock = system . windows . forms . dock _ style . left ; this . duplicate _ button . location = new system . drawing . point ( 0 , NUM ) ; this . duplicate _ button . margin = new system . windows . forms . padding ( 0 , NUM , NUM , NUM ) ; this . duplicate _ button . name = STR ; this . duplicate _ button . size = new system . drawing . size ( NUM , NUM ) ; this . duplicate _ button . tab _ index = NUM ;
this . table _ layout _ panel . tab _ index = NUM ; this . duplicate _ button . dock = system . windows . forms . dock _ style . left ; this . duplicate _ button . location = new system . drawing . point ( 0 , NUM ) ; this . duplicate _ button . margin = new system . windows . forms . padding ( 0 , NUM , NUM , NUM ) ; this . duplicate _ button . name = STR ; this . duplicate _ button . size = new system . drawing . size ( NUM , NUM ) ; this . duplicate _ button . tab _ index = NUM ; this . duplicate _ button . text = STR ; this . duplicate _ button . use _ visual _ style _ back _ color = true ; this . duplicate _ button . click + = new system . event _ handler ( this . duplicate _ button _ click ) ;
} public void update _ outbound _ counter ( long n ) { interlocked . add ( ref outbound _ counter , n ) ; } protected void reload ( ) { config = configuration . load ( ) ;
} protected void reload ( ) { config = configuration . load ( ) ; statistics _ configuration = statistics _ strategy _ configuration . load ( ) ; if ( polipo _ runner = = null ) { polipo _ runner = new polipo _ runner ( ) ;
statistics _ configuration = statistics _ strategy _ configuration . load ( ) ; if ( polipo _ runner = = null ) { polipo _ runner = new polipo _ runner ( ) ; } if ( pac _ server = = null ) { pac _ server = new pac _ server ( ) ; pac _ server . pac _ file _ changed + = pac _ server _ pac _ file _ changed ; pac _ server . user _ rule _ file _ changed + = pac _ server _ user _ rule _ file _ changed ;
public udp _ handler ( socket local , server server , ip _ end _ point local _ end _ point ) { local = local ; server = server ; local _ end _ point = local _ end _ point ; remote _ end _ point = socket _ util . get _ end _ point ( server . server , server . server _ port ) ; remote = socket _ util . create _ socket ( remote _ end _ point , protocol _ type . udp ) ;
} public void send ( byte [ ] data , int length ) { i _ encryptor encryptor = encryptor _ factory . get _ encryptor ( server . method , server . password , server . auth , true ) ; byte [ ] data _ in = new byte [ length - NUM + iv _ encryptor . onetimeauth _ bytes ] ; array . copy ( data , NUM , data _ in , 0 , length - NUM ) ; byte [ ] data _ out = new byte [ length - NUM + NUM + iv _ encryptor . onetimeauth _ bytes ] ; int outlen ; encryptor . encrypt ( data _ in , length - NUM , data _ out , out outlen ) ; logging . debug ( local _ end _ point , remote _ end _ point , outlen , STR ) ;
if ( remote = = null ) { remote = socket _ util . create _ socket ( dest _ end _ point ) ; remote . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; } remote . begin _ connect ( dest _ end _ point , callback , state ) ; } public void end _ connect _ dest ( i _ async _ result async _ result ) { remote ? . end _ connect ( async _ result ) ;
remote . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; } remote . begin _ connect ( dest _ end _ point , callback , state ) ; } public void end _ connect _ dest ( i _ async _ result async _ result ) { remote ? . end _ connect ( async _ result ) ; } public void begin _ send ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state )
} public void end _ connect _ dest ( i _ async _ result async _ result ) { remote ? . end _ connect ( async _ result ) ; } public void begin _ send ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) { remote ? . begin _ send ( buffer , offset , size , socket _ flags , callback , state ) ; }
if ( config . use _ proxy ) {
remote = new socks _ proxy ( ) ; proxy _ ep = socket _ util . get _ end _ point ( config . proxy _ server , config . proxy _ port ) ; } else { remote = new direct _ connect ( ) ; proxy _ ep = null ; } proxy _ timer proxy _ timer = new proxy _ timer ( NUM ) ; proxy _ timer . auto _ reset = false ;
} else { remote = new direct _ connect ( ) ; proxy _ ep = null ; } proxy _ timer proxy _ timer = new proxy _ timer ( NUM ) ; proxy _ timer . auto _ reset = false ; proxy _ timer . elapsed + = proxy _ connect _ timer _ elapsed ; proxy _ timer . enabled = true ;
notify _ icon . visible = true ; notify _ icon . context _ menu = context _ menu ; notify _ icon . double _ click + = notify _ icon _ double _ click ; this . update _ checker = new update _ checker ( ) ; update _ checker . new _ version _ found + = update _ checker _ new _ version _ found ; load _ current _ configuration ( ) ; update _ checker . check _ update ( ) ; if ( controller . get _ configuration ( ) . is _ default ) {
notify _ icon . context _ menu = context _ menu ; notify _ icon . double _ click + = notify _ icon _ double _ click ; this . update _ checker = new update _ checker ( ) ; update _ checker . new _ version _ found + = update _ checker _ new _ version _ found ; load _ current _ configuration ( ) ; update _ checker . check _ update ( ) ; if ( controller . get _ configuration ( ) . is _ default ) { is _ first _ run = true ; show _ config _ form ( ) ;
} void controller _ share _ over _ lan _ status _ changed ( object sender , event _ args e ) { share _ over _ lan _ item . checked = controller . get _ configuration ( ) . share _ over _ lan ; } void controller _ enable _ global _ changed ( object sender , event _ args e ) { global _ mode _ item . checked = controller . get _ configuration ( ) . global ; pac _ mode _ item . checked = ! global _ mode _ item . checked ; }
this . encryption _ label . anchor = system . windows . forms . anchor _ styles . right ; this . encryption _ label . auto _ size = true ; this . encryption _ label . location = new system . drawing . point ( NUM , NUM ) ; this . encryption _ label . name = STR ; this . encryption _ label . size = new system . drawing . size ( NUM , NUM ) ; this . encryption _ label . tab _ index = NUM ; this . encryption _ label . text = STR ; this . encryption _ select . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( ( system . windows . forms . anchor _ styles . top | system . windows . forms . anchor _ styles . left ) | system . windows . forms . anchor _ styles . right ) ) ) ; this . encryption _ select . drop _ down _ style = system . windows . forms . combo _ box _ style . drop _ down _ list ;
private bool is _ first _ run ; private bool is _ startup _ checking ; private string url _ to _ open ; private context _ menu context _ menu ; private menu _ item disable _ item ; private menu _ item auto _ startup _ item ; private menu _ item share _ over _ lan _ item ; private menu _ item seperator _ item ; private menu _ item config _ item ; private menu _ item servers _ item ;
notify _ icon . icon = new _ icon ; } } void controller _ errored ( object sender , system . io . error _ event _ args e ) { message _ box . show ( e . get _ exception ( ) . to _ string ( ) , n . get _ string ( STR , e . get _ exception ( ) . message ) ) ; } private void update _ tray _ icon _ and _ notify _ text ( ) {
configuration config = controller . get _ configuration _ copy ( ) ; bool enabled = config . enabled ; bool global = config . global ; color color _ mask = select _ color _ mask ( enabled , global ) ; size icon _ size = select _ icon _ size ( ) ; update _ icon _ set ( color _ mask , icon _ size , out icon , out icon _ in , out icon _ out , out icon _ both ) ; previous _ icon = icon ; notify _ icon . icon = previous _ icon ;
string server _ info = null ; if ( controller . get _ current _ strategy ( ) ! = null ) { server _ info = controller . get _ current _ strategy ( ) . name ; } else { server _ info = config . get _ current _ server ( ) . friendly _ name ( ) ; } string text = n . get _ string ( STR ) + STR + update _ checker . version + STR +
{ color _ mask = color _ mask _ eclipse ; } }
} } } else { if ( current _ windows _ theme _ mode = = utils . windows _ theme _ mode . light ) { color _ mask = color _ mask _ dark _ silver ; } else
} private menu _ item create _ menu _ item ( string text , event _ handler click ) { return new menu _ item ( n . get _ string ( text ) , click ) ; } private menu _ item create _ menu _ group ( string text , menu _ item [ ] items ) { return new menu _ item ( n . get _ string ( text ) , items ) ; } private void load _ menu ( )
try { registry _ key reg _ themes _ personalize = registry . current _ user . open _ sub _ key ( STR , false ) ; if ( reg _ themes _ personalize . get _ value ( STR ) ! = null ) { if ( ( int ) ( reg _ themes _ personalize . get _ value ( STR ) ) = = 0 ) theme _ mode = windows _ theme _ mode . dark ; else
if ( reg _ themes _ personalize . get _ value ( STR ) ! = null ) { if ( ( int ) ( reg _ themes _ personalize . get _ value ( STR ) ) = = 0 ) theme _ mode = windows _ theme _ mode . dark ; else theme _ mode = windows _ theme _ mode . light ; } else {
else theme _ mode = windows _ theme _ mode . light ; } else { throw new exception ( STR ) ; } } catch
} else { throw new exception ( STR ) ; } } catch { logging . info ( $ STR ) ;

initialize _ component ( ) ; this . servers _ list _ box . dock = dock _ style . fill ; this . table _ layout _ panel . dock = dock _ style . fill ; this . perform _ layout ( ) ; update _ texts ( ) ; this . icon = icon . from _ handle ( resources . ssw . get _ hicon ( ) ) ; this . controller = controller ; controller . config _ changed + = controller _ config _ changed ; load _ current _ configuration ( ) ;
this . perform _ layout ( ) ; update _ texts ( ) ; this . icon = icon . from _ handle ( resources . ssw . get _ hicon ( ) ) ; this . controller = controller ; controller . config _ changed + = controller _ config _ changed ; load _ current _ configuration ( ) ; } private void update _ texts ( ) { add _ button . text = n . get _ string ( STR ) ;
this . plugin _ arguments _ text _ box = new system . windows . forms . text _ box ( ) ; this . plugin _ arguments _ label = new system . windows . forms . label ( ) ; this . remarks _ label = new system . windows . forms . label ( ) ; this . panel = new system . windows . forms . panel ( ) ; this . ok _ button = new system . windows . forms . button ( ) ; this . my _ cancel _ button = new system . windows . forms . button ( ) ; this . delete _ button = new system . windows . forms . button ( ) ; this . add _ button = new system . windows . forms . button ( ) ; this . server _ group _ box = new system . windows . forms . group _ box ( ) ; this . servers _ list _ box = new system . windows . forms . list _ box ( ) ;
this . table _ layout _ panel . auto _ size = true ; this . table _ layout _ panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . table _ layout _ panel . column _ count = 2 ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . controls . add ( this . proxy _ port _ text _ box , 1 , 0 ) ; this . table _ layout _ panel . controls . add ( this . proxy _ port _ label , 0 , 0 ) ; this . table _ layout _ panel . controls . add ( this . temp _ folder _ label , 0 , 1 ) ; this . table _ layout _ panel . controls . add ( this . temp _ folder _ text _ box , 1 , 1 ) ; this . table _ layout _ panel . location = new system . drawing . point ( NUM , NUM ) ;
this . table _ layout _ panel . margin = new system . windows . forms . padding ( 0 ) ; this . table _ layout _ panel . name = STR ; this . table _ layout _ panel . padding = new system . windows . forms . padding ( NUM ) ; this . table _ layout _ panel . row _ count = 2 ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ; this . table _ layout _ panel . tab _ index = NUM ; this . proxy _ port _ text _ box . anchor = system . windows . forms . anchor _ styles . left ; this . proxy _ port _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . proxy _ port _ text _ box . max _ length = NUM ;
this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . size = new system . drawing . size ( NUM , NUM ) ; this . table _ layout _ panel . tab _ index = NUM ; this . proxy _ port _ text _ box . anchor = system . windows . forms . anchor _ styles . left ; this . proxy _ port _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . proxy _ port _ text _ box . max _ length = NUM ; this . proxy _ port _ text _ box . name = STR ; this . proxy _ port _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . proxy _ port _ text _ box . tab _ index = NUM ; this . proxy _ port _ text _ box . word _ wrap = false ;
string json _ string = json _ convert . serialize _ object ( user _ settings , formatting . indented ) ; sw . write ( json _ string ) ; sw . flush ( ) ; } } catch ( io _ exception e ) { logging . log _ useful _ exception ( e ) ; }
user _ settings = json _ convert . deserialize _ object < sysproxy _ config > ( config _ content ) ; } catch ( exception ) { } finally { if ( user _ settings = = null ) user _ settings = new sysproxy _ config ( ) ; } }
using system _ net ; using system _ net _ sockets ; using system _ timers ; using shadowsocks _ controller _ strategy ; using shadowsocks _ encryption ; using shadowsocks _ forward _ proxy ; using shadowsocks _ model ; using shadowsocks _ util _ sockets ; namespace shadowsocks _ controller _ service {
{ class tcp _ relay : listener . service { private shadowsocks _ controller controller ; private date _ time last _ sweep _ time ; private configuration config ; private readonly list < itcp _ handler _ factory > factories = new list < itcp _ handler _ factory > ( ) ; public i _ set < tcp _ handler > handlers { get ; } = new hash _ set < tcp _ handler > ( ) ; public tcp _ relay ( shadowsocks _ controller controller , configuration conf )
public tcp _ relay ( shadowsocks _ controller controller , configuration conf ) { controller = controller ; config = conf ; last _ sweep _ time = date _ time . now ; factories . add ( new socks _ handler _ factory ( ) ) ; factories . add ( new http _ handler _ handler _ factory ( ) ) ; } public override bool handle ( byte [ ] first _ packet , int length , socket socket , object state )
last _ sweep _ time = date _ time . now ; factories . add ( new socks _ handler _ factory ( ) ) ; factories . add ( new http _ handler _ handler _ factory ( ) ) ; } public override bool handle ( byte [ ] first _ packet , int length , socket socket , object state ) { tcp _ handler handler = null ; foreach ( var factory in factories ) { if ( factory . can _ handle ( first _ packet , length ) )
return false ; } socket . set _ socket _ option ( socket _ option _ level . tcp , socket _ option _ name . no _ delay , true ) ; i _ list < tcp _ handler > handlers _ to _ close = new list < tcp _ handler > ( ) ; lock ( handlers ) { handlers . add ( handler ) ; date _ time now = date _ time . now ; if ( now - last _ sweep _ time > time _ span . from _ seconds ( 1 ) )
i _ list < tcp _ handler > handlers _ to _ close = new list < tcp _ handler > ( ) ; lock ( handlers ) { handlers . add ( handler ) ; date _ time now = date _ time . now ; if ( now - last _ sweep _ time > time _ span . from _ seconds ( 1 ) ) { last _ sweep _ time = now ; foreach ( tcp _ handler handler in handlers ) if ( now - handler . last _ activity > time _ span . from _ seconds ( NUM ) )
{ bool can _ handle ( byte [ ] first _ packet , int length ) ; tcp _ handler new _ handler ( shadowsocks _ controller controller , configuration config , tcp _ relay tcprelay , socket socket ) ; } abstract class tcp _ handler { public abstract void start _ handshake ( byte [ ] first _ packet , int length ) ; protected abstract void on _ server _ connected ( async _ session session ) ; protected class async _ session
{ public i _ forward _ proxy remote { get ; } public async _ session ( i _ forward _ proxy remote ) { remote = remote ; } } protected class async _ session < t > : async _ session { public t state { get ; set ; }
{ public t state { get ; set ; } public async _ session ( i _ forward _ proxy remote , t state ) : base ( remote ) { state = state ; } public async _ session ( async _ session session , t state ) : base ( session . remote ) { state = state ; }
private async _ session current _ remote _ session ; private bool proxy _ connected ; private bool dest _ connected ; private int total _ read = 0 ; private int total _ write = 0 ; protected byte [ ] remote _ recv _ buffer { get ; } = new byte [ buffer _ size ] ; private readonly byte [ ] remote _ send _ buffer = new byte [ buffer _ size ] ; protected byte [ ] connetion _ recv _ buffer { get ; } = new byte [ buffer _ size ] ; private readonly byte [ ] connetion _ send _ buffer = new byte [ buffer _ size ] ; private i _ encryptor encryptor ;
private date _ time start _ connect _ time ; private date _ time start _ receiving _ time ; private date _ time start _ sending _ time ; private end _ point dest _ end _ point = null ; public tcp _ handler ( shadowsocks _ controller controller , configuration config , tcp _ relay tcprelay , socket socket , bool auto _ append _ header = true ) { controller = controller ; config = config ; tcprelay = tcprelay ; connection = socket ;
{ controller = controller ; config = config ; tcprelay = tcprelay ; connection = socket ; proxy _ timeout = config . proxy . proxy _ timeout * NUM ; server _ timeout = config . get _ current _ server ( ) . timeout * NUM ; last _ activity = date _ time . now ; server _ header _ sent = ! auto _ append _ header ; }
if ( server = = null | | server . server = = STR ) throw new argument _ exception ( STR ) ; lock ( encryption _ lock ) { lock ( decryption _ lock ) { encryptor = encryptor _ factory . get _ encryptor ( server . method , server . password , server . auth , false ) ; } } this . server = server ;
try { start _ receiving _ time = date _ time . now ; session . remote . begin _ receive ( remote _ recv _ buffer , 0 , recv _ size , socket _ flags . none , pipe _ remote _ receive _ callback , session ) ; connection . begin _ receive ( connetion _ recv _ buffer , 0 , recv _ size , socket _ flags . none , pipe _ connection _ receive _ callback , session ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ;
} catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; } } private void pipe _ remote _ receive _ callback ( i _ async _ result ar ) { if ( closed ) return ;
i _ strategy strategy = controller . get _ current _ strategy ( ) ; strategy ? . update _ last _ write ( server ) ; } protected async _ session end _ send _ to _ server ( i _ async _ result ar ) { var session = ( async _ session ) ar . async _ state ; session . remote . end _ send ( ar ) ; return session ; } private void pipe _ remote _ send _ callback ( i _ async _ result ar )
try { var session = ( async _ session ) ar . async _ state ; connection . end _ send ( ar ) ; session . remote . begin _ receive ( remote _ recv _ buffer , 0 , recv _ size , socket _ flags . none , pipe _ remote _ receive _ callback , session ) ;
} catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; } } } }
listener = new listener ( services ) ; listener . start ( config ) ; } catch ( exception e ) { if ( e is socket _ exception ) { socket _ exception se = ( socket _ exception ) e ; if ( se . socket _ error _ code = = socket _ error . access _ denied ) {
request [ 0 ] = NUM ; request [ 1 ] = 1 ; request [ 2 ] = 0 ; var st = new socks _ state ( ) ; st . callback = callback ; st . async _ state = state ; remote . begin _ send ( request , 0 , request . length , 0 , socks _ request _ send _ callback , st ) ;
var st = new socks _ state ( ) ; st . callback = callback ; st . async _ state = state ; remote . begin _ send ( request , 0 , request . length , 0 , socks _ request _ send _ callback , st ) ; } public void end _ connect _ dest ( i _ async _ result async _ result ) { var state = ( ( fake _ async _ result ) async _ result ) . inner _ state ; if ( state . ex ! = null ) {
int entry _ name _ size = 0 ; int lp _ size = 0 ; uint retval = error _ success ; ras _ entry _ name [ ] names = null ; entry _ name _ size = marshal . size _ of ( typeof ( ras _ entry _ name ) ) ; retval = ras _ enum _ entries ( null , null , null , ref lp _ size , out lp _ names ) ;
if ( retval = = error _ buffer _ too _ small ) { names = new ras _ entry _ name [ lp _ names ] ; for ( int i = 0 ; i < names . length ; i + + ) { names [ i ] . dw _ size = entry _ name _ size ; } retval = ras _ enum _ entries ( null , null , names , ref lp _ size , out lp _ names ) ; } if ( retval = = error _ success )
} if ( retval = = error _ success ) { if ( lp _ names = = 0 ) { return 1 ; } all _ conns = new string [ names . length ] ; for ( int i = 0 ; i < names . length ; i + + ) {
foreach ( var strategy in controller . get _ strategies ( ) ) { menu _ item item = new menu _ item ( strategy . name ) ; item . tag = strategy . id ; item . click + = a _ strategy _ item _ click ; items . add ( strategy _ count , item ) ; strategy _ count + + ; } items . add ( strategy _ count + + , new menu _ item ( STR ) ) ; int server _ count = 0 ;
} items . add ( strategy _ count + + , new menu _ item ( STR ) ) ; int server _ count = 0 ; configuration configuration = controller . get _ configuration _ copy ( ) ; foreach ( var server in configuration . configs ) { if ( configuration . checks _ server ( server ) ) { menu _ item item = new menu _ item ( server . friendly _ name ( ) ) ; item . tag = configuration . configs . find _ index ( s = > s = = server ) ;
configuration configuration = controller . get _ configuration _ copy ( ) ; foreach ( var server in configuration . configs ) { if ( configuration . checks _ server ( server ) ) { menu _ item item = new menu _ item ( server . friendly _ name ( ) ) ; item . tag = configuration . configs . find _ index ( s = > s = = server ) ; item . click + = a _ server _ item _ click ; items . add ( strategy _ count + server _ count , item ) ; server _ count + + ;
item . click + = a _ server _ item _ click ; items . add ( strategy _ count + server _ count , item ) ; server _ count + + ;

} ) , new menu _ item ( STR ) , this . auto _ startup _ item = create _ menu _ item ( STR , new event _ handler ( this . auto _ startup _ item _ click ) ) , this . share _ over _ lan _ item = create _ menu _ item ( STR , new event _ handler ( this . share _ over _ lan _ item _ click ) ) , create _ menu _ item ( STR , new event _ handler ( this . edit _ pac _ file _ item _ click ) ) , create _ menu _ item ( STR , new event _ handler ( this . update _ pac _ from _ gfw _ list _ item _ click ) ) , new menu _ item ( STR ) , create _ menu _ item ( STR , new event _ handler ( this . show _ log _ item _ click ) ) ,
create _ menu _ item ( STR , new event _ handler ( this . show _ log _ item _ click ) ) , create _ menu _ item ( STR , new event _ handler ( this . about _ item _ click ) ) , new menu _ item ( STR ) , create _ menu _ item ( STR , new event _ handler ( this . quit _ click ) ) } ) ; } private void controller _ config _ changed ( object sender , event _ args e ) { load _ current _ configuration ( ) ; update _ tray _ icon ( ) ;
configuration configuration = controller . get _ configuration ( ) ; for ( int i = 0 ; i < configuration . configs . count ; i + + ) { server server = configuration . configs [ i ] ; menu _ item item = new menu _ item ( server . friendly _ name ( ) ) ; item . tag = i ; item . click + = a _ server _ item _ click ; items . add ( i , item ) ; }
if ( configuration . index > = 0 & & configuration . index < configuration . configs . count ) { items [ configuration . index ] . checked = true ; } } private void show _ config _ form ( ) { if ( config _ form ! = null ) { config _ form . activate ( ) ;
} message _ box . show ( n . get _ string ( STR ) ) ; } } private void auto _ startup _ item _ click ( object sender , event _ args e ) { auto _ startup _ item . checked = ! auto _ startup _ item . checked ; if ( ! auto _ startup . set ( auto _ startup _ item . checked ) ) { message _ box . show ( STR ) ; } }
if ( file . exists ( pac _ server . user _ rule _ file ) ) { string local = file _ manager . non _ exclusive _ read _ all _ text ( pac _ server . user _ rule _ file , encoding . ut ) ; using ( var sr = new string _ reader ( local ) ) { foreach ( var rule in sr . non _ white _ space _ lines ( ) ) { if ( rule . begin _ with _ any ( ignored _ line _ begins ) ) continue ; lines . add ( rule ) ;
using ( var sr = new string _ reader ( local ) ) { foreach ( var rule in sr . non _ white _ space _ lines ( ) ) { if ( rule . begin _ with _ any ( ignored _ line _ begins ) ) continue ; lines . add ( rule ) ; } } }
} void controller _ share _ over _ lan _ status _ changed ( object sender , event _ args e ) { share _ over _ lan _ item . checked = controller . get _ configuration _ copy ( ) . share _ over _ lan ; } void controller _ verbose _ logging _ status _ changed ( object sender , event _ args e ) { verbose _ logging _ toggle _ item . checked = controller . get _ configuration _ copy ( ) . is _ verbose _ logging ; }
} private void global _ mode _ item _ click ( object sender , event _ args e ) { controller . toggle _ enable ( true ) ; controller . toggle _ global ( true ) ; configuration config = controller . get _ configuration _ copy ( ) ; update _ system _ proxy _ items _ enabled _ status ( config ) ; } private void pac _ mode _ item _ click ( object sender , event _ args e ) {
stream _ writer _ with _ timestamp sw = new stream _ writer _ with _ timestamp ( fs ) ; sw . auto _ flush = true ; console . set _ out ( sw ) ; console . set _ error ( sw ) ; return true ; } catch ( io _ exception e ) { console . write _ line ( e . to _ string ( ) ) ; return false ;
if ( polipo _ runner = = null ) { polipo _ runner = new polipo _ runner ( ) ; } polipo _ runner . start ( config ) ; local = new local ( config ) ; local . start ( ) ; } private void config _ click ( object sender , event _ args e ) {
{ menu _ item result = new menu _ item ( n . get _ string ( text ) , click ) ; return result ; } private menu _ item create _ seperator _ item ( ) { menu _ item result = new menu _ item ( STR ) ; return result ;
return result ; } private menu _ item create _ seperator _ item ( ) { menu _ item result = new menu _ item ( STR ) ; return result ; } private menu _ item create _ menu _ group ( string text , menu _ item [ ] items ) {
{ menu _ item result = new menu _ item ( STR ) ; return result ; } private menu _ item create _ menu _ group ( string text , menu _ item [ ] items ) { for ( int i = 0 ; i < items . length ; i + + ) { items [ i ] . index = i ;
return result ; } private menu _ item create _ menu _ group ( string text , menu _ item [ ] items ) { for ( int i = 0 ; i < items . length ; i + + ) { items [ i ] . index = i ; } menu _ item result = new menu _ item ( n . get _ string ( text ) , items ) ;
menu _ item result = new menu _ item ( n . get _ string ( text ) , items ) ; return result ; } private void load _ menu ( ) { this . context _ menu = new system . windows . forms . context _ menu ( ) ; this . context _ menu . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . enable _ item = create _ menu _ item ( STR , new system . event _ handler ( this . enable _ item _ click ) ) , create _ menu _ group ( STR , new system . windows . forms . menu _ item [ ] {
return result ; } private void load _ menu ( ) { this . context _ menu = new system . windows . forms . context _ menu ( ) ; this . context _ menu . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . enable _ item = create _ menu _ item ( STR , new system . event _ handler ( this . enable _ item _ click ) ) , create _ menu _ group ( STR , new system . windows . forms . menu _ item [ ] { this . pac _ mode _ item = create _ menu _ item ( STR , new system . event _ handler ( this . pac _ mode _ item _ click ) ) , this . global _ mode _ item = create _ menu _ item ( STR , new system . event _ handler ( this . global _ mode _ item _ click ) )
} ) ;
} private void controller _ config _ changed ( object sender , event _ args e ) { load _ current _ configuration ( ) ; update _ tray _ icon ( ) ; } private void controller _ enable _ status _ changed ( object sender , event _ args e ) { enable _ item . checked = controller . get _ configuration ( ) . enabled ; }
{ int atyp = connetion _ recv _ buffer [ 0 ] ; string dst _ addr ; int dst _ port ; switch ( atyp ) { case 1 : dst _ addr = new ip _ address ( connetion _ recv _ buffer . skip ( 1 ) . take ( NUM ) . to _ array ( ) ) . to _ string ( ) ; dst _ port = ( connetion _ recv _ buffer [ NUM ] < < NUM ) + connetion _ recv _ buffer [ NUM ] ; logging . info ( $ STR ) ;
} int bytes _ to _ send ; lock ( encryption _ lock ) { if ( closed ) return ; encryptor . encrypt ( connetion _ recv _ buffer , bytes _ read , connetion _ send _ buffer , out bytes _ to _ send ) ; } tcprelay . update _ outbound _ counter ( server , bytes _ to _ send ) ; start _ sending _ time = date _ time . now ; bytes _ to _ send = bytes _ to _ send ;
public string version ; public list < server > configs ; public string strategy ; public int index ; public bool global ; public bool enabled ; public bool share _ over _ lan ; public bool is _ default ; public int local _ port ;
public int local _ port ; public bool portable _ mode = true ; public bool show _ plugin _ output ; public string pac _ url ; public bool use _ online _ pac ; public bool secure _ local _ pac = true ; public bool availability _ statistics ;
public bool use _ online _ pac ; public bool secure _ local _ pac = true ; public bool availability _ statistics ; public bool auto _ check _ update ; public bool check _ pre _ release ; public bool is _ verbose _ logging ; public bool is _ i _ pv _ enabled = false ; public bool generate _ legacy _ url = false ; public string geosite _ url ; public string geosite _ group = STR ;
public log _ viewer _ config log _ viewer ; public proxy _ config proxy ; public hotkey _ config hotkey ; json _ ignore n _ log _ config n _ log _ config ; private static readonly string config _ file = STR ; private static readonly n _ log _ config . log _ level verbose _ log _ level = n _ log _ config . log _ level . trace ; private static readonly n _ log _ config . log _ level verbose _ log _ level = n _ log _ config . log _ level . debug ; json _ ignore
private static readonly n _ log _ config . log _ level verbose _ log _ level = n _ log _ config . log _ level . trace ; private static readonly n _ log _ config . log _ level verbose _ log _ level = n _ log _ config . log _ level . debug ; json _ ignore public bool updated = false ; json _ ignore public string local _ host = > get _ local _ host ( ) ; private string get _ local _ host ( ) { return is _ i _ pv _ enabled ? STR : STR ; }
private static readonly n _ log _ config . log _ level verbose _ log _ level = n _ log _ config . log _ level . debug ; json _ ignore public bool updated = false ; json _ ignore public string local _ host = > get _ local _ host ( ) ; private string get _ local _ host ( ) { return is _ i _ pv _ enabled ? STR : STR ; } public server get _ current _ server ( )
json _ ignore public bool updated = false ; json _ ignore public string local _ host = > get _ local _ host ( ) ; private string get _ local _ host ( ) { return is _ i _ pv _ enabled ? STR : STR ; } public server get _ current _ server ( ) {
using system _ text ; using system _ windows _ forms ; using shadowsocks _ controller ; using shadowsocks _ model ; using shadowsocks _ properties ; using static shadowsocks . controller . hotkey _ reg ; namespace shadowsocks _ view { public partial class hotkey _ settings _ form : form
using shadowsocks _ model ; using shadowsocks _ properties ; using static shadowsocks . controller . hotkey _ reg ; namespace shadowsocks _ view { public partial class hotkey _ settings _ form : form { private readonly shadowsocks _ controller controller ; private hotkey _ config modified _ hotkey _ config ; public hotkey _ settings _ form ( shadowsocks _ controller controller )
namespace shadowsocks _ view { public partial class hotkey _ settings _ form : form { private readonly shadowsocks _ controller controller ; private hotkey _ config modified _ hotkey _ config ; public hotkey _ settings _ form ( shadowsocks _ controller controller ) { initialize _ component ( ) ; update _ texts ( ) ;
} private void handle _ reg _ result ( string hotkey _ str , label label , reg _ result result ) { switch ( result ) { case reg _ result . parse _ error :
{ switch ( result ) { case reg _ result . parse _ error :
{ case reg _ result . parse _ error :
message _ box . show ( string . format ( n . get _ string ( STR ) , hotkey _ str ) ) ; break ; case reg _ result . unreg _ success : label . reset _ back _ color ( ) ; break ; case reg _ result . reg _ success : label . back _ color = color . green ; break ; case reg _ result . reg _ failure : label . back _ color = color . red ;
} } } }
{ is _ startup _ checking = true ; update _ checker . check _ update ( config , NUM ) ;

} else if ( ! is _ startup _ checking ) { show _ balloon _ tip ( n . get _ string ( STR ) , n . get _ string ( STR ) , tool _ tip _ icon . info , NUM ) ; } is _ startup _ checking = false ; } void notify _ icon _ balloon _ tip _ clicked ( object sender , event _ args e ) {
} is _ startup _ checking = false ; } void notify _ icon _ balloon _ tip _ clicked ( object sender , event _ args e ) { if ( update _ checker . new _ version _ found ) { update _ checker . new _ version _ found = false ; if ( system . io . file . exists ( update _ checker . latest _ version _ local _ name ) ) {

update _ move _ up _ and _ down _ button ( ) ; load _ selected _ server ( ) ; } private void config _ form _ load ( object sender , event _ args e ) { } private void servers _ list _ box _ selected _ index _ changed ( object sender , event _ args e ) { if ( last _ selected _ index = = servers _ list _ box . selected _ index ) {
{ last _ selected _ index = modified _ configuration . configs . count - 1 ; } servers _ list _ box . selected _ index = last _ selected _ index ; load _ configuration ( modified _ configuration ) ; servers _ list _ box . selected _ index = last _ selected _ index ; load _ selected _ server ( ) ; } private void ok _ button _ click ( object sender , event _ args e ) {
controller . save _ servers ( modified _ configuration . configs , modified _ configuration . local _ port ) ; controller . select _ server _ index ( modified _ configuration . configs . index _ of ( server ) ) ; this . close ( ) ; } private void cancel _ button _ click ( object sender , event _ args e ) { this . close ( ) ; } private void config _ form _ shown ( object sender , event _ args e ) {
this . close ( ) ; } private void cancel _ button _ click ( object sender , event _ args e ) { this . close ( ) ; } private void config _ form _ shown ( object sender , event _ args e ) { ip _ text _ box . focus ( ) ; }
protected int encrypt _ bytes _ remaining ; protected int decrypt _ bytes _ remaining ; protected ulong encrypt _ ic ; protected ulong decrypt _ ic ; protected byte [ ] encrypt _ buf ; protected byte [ ] decrypt _ buf ; public sodium _ encryptor ( string method , string password , bool onetimeauth , bool isudp ) : base ( method , password , onetimeauth , isudp ) { encrypt _ buf = new byte [ max _ input _ size + sodium _ block _ size ] ;
{ bytes _ remaining = encrypt _ bytes _ remaining ; ic = encrypt _ ic ; sodium _ buf = encrypt _ buf ; iv = encrypt _ iv ; } else { bytes _ remaining = decrypt _ bytes _ remaining ; ic = decrypt _ ic ;
} } public override void dispose ( ) { } } }
using system ; using system _ collections _ generic ; using system _ diagnostics ; using system _ io ; using system _ i _ compression ; using system _ text ; namespace shadowsocks _ controller { class polipo _ runner {
{ class polipo _ runner { private process process ; public void start ( server config ) { if ( process = = null ) { process [ ] existing _ polipo = process . get _ processes _ by _ name ( STR ) ; foreach ( process p in existing _ polipo )
using system ; using system _ collections _ generic ; using system _ diagnostics ; using system _ io ; using system _ i _ compression ; using system _ net ; using system _ net _ sockets ; using system _ text ; namespace shadowsocks _ controller {
{ class pac _ server { private static string pac _ file = STR ; socket listener ; file _ system _ watcher watcher ; public event event _ handler pac _ file _ changed ; public void start ( ) { listener = new socket ( address _ family . inter _ network ,
using system ; using system _ collections _ generic ; using system _ text ; namespace shadowsocks _ controller { public class shadowsocks _ controller { private local local ; private pac _ server pac _ server ; private configuration config ;
{ public class shadowsocks _ controller { private local local ; private pac _ server pac _ server ; private configuration config ; private polipo _ runner polipo _ runner ; private bool stopped = false ; public class path _ event _ args : event _ args {
using system ; using system _ collections _ generic ; using system _ io ; using system _ runtime _ interop _ services ; using system _ windows _ forms ; namespace shadowsocks { static class program { dll _ import _ kernel _ dll
{ static class program { dll _ import _ kernel _ dll private static extern int _ ptr load _ library ( string path ) ; sta _ thread static void main ( ) { string temp _ path = path . get _ temp _ path ( ) ; string dll _ path = temp _ path + STR ;
} } private void load _ current _ configuration ( ) { modified _ configuration = controller . get _ configuration ( ) ; load _ configuration ( modified _ configuration ) ; old _ selected _ index = modified _ configuration . index ; servers _ list _ box . selected _ index = modified _ configuration . index ; load _ selected _ server ( ) ; update _ servers _ menu ( ) ;
this . edit _ pac _ file _ item , this . about _ item , this . menu _ item , this . quit _ item } ) ; this . enable _ item . index = 0 ; this . enable _ item . text = STR ; this . enable _ item . click + = new system . event _ handler ( this . enable _ item _ click ) ; this . servers _ item . index = 1 ; this . servers _ item . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . seperator _ item ,
this . edit _ pac _ file _ item . index = NUM ; this . edit _ pac _ file _ item . text = STR ; this . edit _ pac _ file _ item . click + = new system . event _ handler ( this . edit _ pac _ file _ item _ click ) ; this . about _ item . index = NUM ; this . about _ item . text = STR ; this . about _ item . click + = new system . event _ handler ( this . about _ item _ click ) ; this . menu _ item . index = NUM ; this . menu _ item . text = STR ; this . quit _ item . index = NUM ; this . quit _ item . text = STR ;
this . edit _ pac _ file _ item . click + = new system . event _ handler ( this . edit _ pac _ file _ item _ click ) ; this . about _ item . index = NUM ; this . about _ item . text = STR ; this . about _ item . click + = new system . event _ handler ( this . about _ item _ click ) ; this . menu _ item . index = NUM ; this . menu _ item . text = STR ; this . quit _ item . index = NUM ; this . quit _ item . text = STR ; private system . windows . forms . menu _ item config _ item ; private system . windows . forms . menu _ item edit _ pac _ file _ item ;
listener = new listener ( services ) ; listener . start ( config ) ; } catch ( exception e ) { if ( e is socket _ exception ) { socket _ exception se = ( socket _ exception ) e ; if ( se . socket _ error _ code = = socket _ error . access _ denied ) {
{ private static int uid ; private static string unique _ config _ file ; private static job privoxy _ job ; private process process ; private int running _ port ; static privoxy _ runner ( ) { try {
{ try { uid = application . startup _ path . get _ hash _ code ( ) ; unique _ config _ file = $ STR ; privoxy _ job = new job ( ) ; file _ manager . uncompress _ file ( utils . get _ temp _ path ( STR ) , resources . privoxy _ exe ) ; file _ manager . uncompress _ file ( utils . get _ temp _ path ( STR ) , resources . mgwz _ dll ) ; } catch ( io _ exception e )
{ kill _ process ( p ) ; } string privoxy _ config = resources . privoxy _ conf ; running _ port = this . get _ free _ port ( ) ; privoxy _ config = privoxy _ config . replace ( STR , configuration . local _ port . to _ string ( ) ) ; privoxy _ config = privoxy _ config . replace ( STR , running _ port . to _ string ( ) ) ; privoxy _ config = privoxy _ config . replace ( STR , configuration . share _ over _ lan ? STR : STR ) ; file _ manager . byte _ array _ to _ file ( utils . get _ temp _ path ( unique _ config _ file ) , encoding . ut . get _ bytes ( privoxy _ config ) ) ; process = new process ( ) ;
running _ port = this . get _ free _ port ( ) ; privoxy _ config = privoxy _ config . replace ( STR , configuration . local _ port . to _ string ( ) ) ; privoxy _ config = privoxy _ config . replace ( STR , running _ port . to _ string ( ) ) ; privoxy _ config = privoxy _ config . replace ( STR , configuration . share _ over _ lan ? STR : STR ) ; file _ manager . byte _ array _ to _ file ( utils . get _ temp _ path ( unique _ config _ file ) , encoding . ut . get _ bytes ( privoxy _ config ) ) ; process = new process ( ) ; process . start _ info . file _ name = STR ; process . start _ info . arguments = unique _ config _ file ; process . start _ info . working _ directory = utils . get _ temp _ path ( ) ; process . start _ info . window _ style = process _ window _ style . hidden ;
process = new process ( ) ; process . start _ info . file _ name = STR ; process . start _ info . arguments = unique _ config _ file ; process . start _ info . working _ directory = utils . get _ temp _ path ( ) ; process . start _ info . window _ style = process _ window _ style . hidden ; process . start _ info . use _ shell _ execute = true ; process . start _ info . create _ no _ window = true ; process . start ( ) ; * add this process to job obj associated with this ss process , so that * when ss exit unexpectedly , this process will be forced killed by system .
{ throw new file _ not _ found _ exception ( n . get _ string ( STR ) , plugin _ process . start _ info . file _ name , ex ) ; } throw new application _ exception ( n . get _ string ( STR ) , ex ) ; } plugin _ job . add _ process ( plugin _ process . handle ) ; started = true ; } return true ; }
using shadowsocks _ controller ; using shadowsocks _ model ; namespace shadowsocks _ view { public partial class statistics _ strategy _ configuration _ form : form { private readonly shadowsocks _ controller controller ; private statistics _ strategy _ configuration configuration ;
namespace shadowsocks _ view { public partial class statistics _ strategy _ configuration _ form : form { private readonly shadowsocks _ controller controller ; private statistics _ strategy _ configuration configuration ; private data _ table data _ table = new data _ table ( ) ; private list < string > servers ; public statistics _ strategy _ configuration _ form ( shadowsocks _ controller controller ) {
list < asset > asserts = new list < asset > ( ) ; if ( result ! = null ) { foreach ( j _ object release in result ) { if ( ( bool ) release [ STR ] )
{ continue ; } foreach ( j _ object asset in ( j _ array ) release [ STR ] ) { asset ass = new asset ( ) ; ass . parse ( asset ) ; if ( ass . is _ new _ version ( version ) ) { asserts . add ( ass ) ;
} } } if ( asserts . count ! = 0 ) { sort _ by _ versions ( asserts ) ; asset asset = asserts [ asserts . count - 1 ] ; new _ version _ found = true ; latest _ version _ url = asset . browser _ download _ url ; latest _ version _ number = asset . version ;
using system _ text ; using system _ text _ regular _ expressions ; using shadowsocks _ controller ; namespace shadowsocks _ model { serializable
using shadowsocks _ controller ; namespace shadowsocks _ model { serializable public class server { public string server ; public int server _ port ; public string password ;
namespace shadowsocks _ model { serializable public class server { public string server ; public int server _ port ; public string password ; public string method ; public string remarks ;
using system _ collections _ generic ; using system _ io ; using shadowsocks _ controller ; using newtonsoft _ json ; namespace shadowsocks _ model { serializable
namespace shadowsocks _ model { serializable public class configuration { public list < server > configs ; public string strategy ; public int index ; public bool global ; public bool enabled ;
{ public static string [ ] encryption _ names = new string [ ] { STR , STR , STR , STR , STR , STR } ;
public byte [ ] encrypt _ table = new byte [ NUM ] ; public byte [ ] decrypt _ table = new byte [ NUM ] ; public string method = STR ; public string password ; public byte [ ] key ; private r rc = null ; private cipher cipher = null ; private int _ ptr encrypt _ ctx ; private int _ ptr decrypt _ ctx ; private static dictionary < string , byte [ ] > cached _ keys = new dictionary < string , byte [ ] > ( ) ;
private long compare ( byte x , byte y , ulong a , int i ) { return ( long ) ( a % ( ulong ) ( x + i ) ) - ( long ) ( a % ( ulong ) ( y + i ) ) ; } private byte [ ] merge _ sort ( byte [ ] array , ulong a , int j ) { if ( array . length = = 1 ) return array ; int middle = array . length / 2 ; byte [ ] left = new byte [ middle ] ;
rc = new r ( ) ; encrypt _ table = rc . encrypt _ initalize ( hash ) ; decrypt _ table = rc . encrypt _ initalize ( hash ) ; } else if ( method = = STR | | method = = STR | | method = = null ) { console . write _ line ( STR ) ; var a = bit _ converter . to _ u _ int ( hash , 0 ) ;
console . write _ line ( STR ) ; var a = bit _ converter . to _ u _ int ( hash , 0 ) ; for ( int i = 0 ; i < NUM ; i + + ) { encrypt _ table [ i ] = ( byte ) i ; } for ( int i = 1 ; i < NUM ; i + + ) { encrypt _ table = merge _ sort ( encrypt _ table , a , i ) ;
var a = bit _ converter . to _ u _ int ( hash , 0 ) ; for ( int i = 0 ; i < NUM ; i + + ) { encrypt _ table [ i ] = ( byte ) i ; } for ( int i = 1 ; i < NUM ; i + + ) { encrypt _ table = merge _ sort ( encrypt _ table , a , i ) ; } for ( int i = 0 ; i < NUM ; i + + )
{ switch ( method ) { case STR : for ( int i = 0 ; i < length ; i + + ) buf [ i ] = encrypt _ table [ buf [ i ] ] ; return buf ; break ; case STR : rc . encrypt ( encrypt _ table , buf , length ) ;
for ( int i = 0 ; i < length ; i + + ) buf [ i ] = encrypt _ table [ buf [ i ] ] ; return buf ; break ; case STR : rc . encrypt ( encrypt _ table , buf , length ) ; return buf ; break ; default : return ssl _ encrypt ( buf , length ) ;
rc . encrypt ( encrypt _ table , buf , length ) ; return buf ; break ; default : return ssl _ encrypt ( buf , length ) ; } } public byte [ ] decrypt ( byte [ ] buf , int length ) { switch ( method )
{ switch ( method ) { case STR : for ( int i = 0 ; i < length ; i + + ) buf [ i ] = decrypt _ table [ buf [ i ] ] ; return buf ; break ; case STR : rc . decrypt ( decrypt _ table , buf , length ) ;
for ( int i = 0 ; i < length ; i + + ) buf [ i ] = decrypt _ table [ buf [ i ] ] ; return buf ; break ; case STR : rc . decrypt ( decrypt _ table , buf , length ) ; return buf ; break ; default : return ssl _ decrypt ( buf , length ) ;
rc . decrypt ( decrypt _ table , buf , length ) ; return buf ; break ; default : return ssl _ decrypt ( buf , length ) ; } } } }
} } } }
{ message _ box . show ( ex . to _ string ( ) ) ; } } private void cancel _ button _ click ( object sender , event _ args e ) { this . hide ( ) ; config _ to _ text _ box ( ) ; } private void form _ form _ closed ( object sender , form _ closed _ event _ args e )
} } private void cancel _ button _ click ( object sender , event _ args e ) { this . hide ( ) ; config _ to _ text _ box ( ) ; } private void form _ form _ closed ( object sender , form _ closed _ event _ args e ) { if ( local ! = null ) local . stop ( ) ;
if ( remote ! = null ) { remote . shutdown ( socket _ shutdown . send ) ; } encryptor . dispose ( ) ; } private void connect _ callback ( i _ async _ result ar ) { try {
} private void connect _ callback ( i _ async _ result ar ) { try { remote . end _ connect ( ar ) ; console . write _ line ( STR , remote . remote _ end _ point . to _ string ( ) ) ; handshake _ receive ( ) ; }
{ if ( server = = null ) { throw new argument _ null _ exception ( nameof ( server ) ) ; } if ( string . is _ null _ or _ white _ space ( server . plugin ) ) { return null ; } return new sip _ plugin (
} private sip _ plugin ( string plugin , string plugin _ opts , string plugin _ args , string server _ address , int server _ port , bool show _ plugin _ output ) { if ( plugin = = null ) throw new argument _ null _ exception ( nameof ( plugin ) ) ; if ( string . is _ null _ or _ white _ space ( server _ address ) ) { throw new argument _ exception ( STR , nameof ( server _ address ) ) ; } if ( server _ port < = 0 | | server _ port > NUM ) {
{ if ( plugin = = null ) throw new argument _ null _ exception ( nameof ( plugin ) ) ; if ( string . is _ null _ or _ white _ space ( server _ address ) ) { throw new argument _ exception ( STR , nameof ( server _ address ) ) ; } if ( server _ port < = 0 | | server _ port > NUM ) { throw new argument _ out _ of _ range _ exception ( STR ) ; }
application . enable _ visual _ styles ( ) ; application . set _ compatible _ text _ rendering _ default ( false ) ; application . run ( new form ( ) ) ; } } }
} } }
this . context _ menu _ strip . name = STR ; this . context _ menu _ strip . render _ mode = system . windows . forms . tool _ strip _ render _ mode . system ; this . context _ menu _ strip . show _ image _ margin = false ; this . context _ menu _ strip . size = new system . drawing . size ( NUM , NUM ) ; this . config _ item . name = STR ; this . config _ item . size = new system . drawing . size ( NUM , NUM ) ; this . config _ item . text = STR ; this . config _ item . click + = new system . event _ handler ( this . config _ click ) ; this . quit _ item . name = STR ; this . quit _ item . size = new system . drawing . size ( NUM , NUM ) ;

var ret = new data _ list { new data _ unit ( state . geolocation , state . unknown ) , new data _ unit ( state . isp , state . unknown ) , } ; string json _ string ; try { json _ string = await new http _ client ( ) . get _ string _ async ( api ) ; }
{ await geolocation _ and _ isp ; append ( data _ list , geolocation _ and _ isp . result ) ; } } } private static void append ( data _ list data _ list , i _ enumerable < data _ unit > extra ) { var data = data _ list . concat ( extra ) ; var data _ line = string . join ( delimiter , data . select ( kv = > kv . value ) . to _ array ( ) ) ;
} polipo _ runner . stop ( ) ; try { var strategy = get _ current _ strategy ( ) ; if ( strategy ! = null ) { strategy . reload _ servers ( ) ; } polipo _ runner . start ( config ) ;
{ local local ; pac _ server pac _ server ; config config ; polipo _ runner polipo _ runner ; public config _ form ( ) { config = config . load ( ) ; initialize _ component ( ) ; notify _ icon . context _ menu = context _ menu ;
{ config = config . load ( ) ; initialize _ component ( ) ; notify _ icon . context _ menu = context _ menu ; enable _ item . checked = config . enabled ; config _ to _ text _ box ( ) ; } private void show _ window ( ) { this . opacity = 1 ;
} else { console . write _ line ( STR ) ; this . close ( ) ; } } catch ( exception e ) { logging . log _ useful _ exception ( e ) ;
{ list < internet _ per _ conn _ option > optionlist = new list < internet _ per _ conn _ option > ( ) ; if ( enable ) { if ( global ) { optionlist . add ( new internet _ per _ conn _ option { dw _ option = ( int ) internet _ per _ conn _ option _ enum . internet _ per _ conn _ flags _ ui , value = { dw _ value = ( int ) ( internet _ option _ per _ conn _ flags _ ui . proxy _ type _ proxy
} ) ; optionlist . add ( new internet _ per _ conn _ option { dw _ option = ( int ) internet _ per _ conn _ option _ enum . internet _ per _ conn _ proxy _ server , value = { psz _ value = marshal . string _ to _ h _ global _ auto ( proxy _ server ) } } ) ; optionlist . add ( new internet _ per _ conn _ option { dw _ option = ( int ) internet _ per _ conn _ option _ enum . internet _ per _ conn _ proxy _ bypass , value = { psz _ value = marshal . string _ to _ h _ global _ auto ( STR ) }
} ) ; optionlist . add ( new internet _ per _ conn _ option { dw _ option = ( int ) internet _ per _ conn _ option _ enum . internet _ per _ conn _ proxy _ bypass , value = { psz _ value = marshal . string _ to _ h _ global _ auto ( STR ) } } ) ; } else { optionlist . add ( new internet _ per _ conn _ option
} ) ; } else { optionlist . add ( new internet _ per _ conn _ option { dw _ option = ( int ) internet _ per _ conn _ option _ enum . internet _ per _ conn _ flags _ ui , value = { dw _ value = ( int ) internet _ option _ per _ conn _ flags _ ui . proxy _ type _ auto _ proxy _ url } } ) ; optionlist . add ( new internet _ per _ conn _ option
int _ ptr . zero , internet _ option . internet _ option _ proxy _ settings _ changed , int _ ptr . zero , 0 ) ; if ( ! b _ return ) { logging . error ( STR ) ; } b _ return = native _ methods . internet _ set _ option ( int _ ptr . zero ,
int _ ptr . zero , 0 ) ; if ( ! b _ return ) { logging . error ( STR ) ; } b _ return = native _ methods . internet _ set _ option ( int _ ptr . zero , internet _ option . internet _ option _ refresh , int _ ptr . zero , 0 ) ;
int _ ptr . zero , internet _ option . internet _ option _ refresh , int _ ptr . zero , 0 ) ; if ( ! b _ return ) { logging . error ( STR ) ; } } public static void set _ ie _ proxy ( bool enable , bool global , string proxy _ server , string pac _ url ) {
using system _ globalization ; using system _ io ; using system _ text ; using system _ windows _ forms ; namespace shadowsocks _ controller {
using system _ windows _ forms ; namespace shadowsocks _ controller { public static class n { private static readonly string n _ file = STR ; private static dictionary < string , string > strings = new dictionary < string , string > ( ) ; private static void init ( string res , string locale )
namespace shadowsocks _ controller { public static class n { private static readonly string n _ file = STR ; private static dictionary < string , string > strings = new dictionary < string , string > ( ) ; private static void init ( string res , string locale ) { using ( text _ field _ parser csv _ parser = new text _ field _ parser ( new string _ reader ( res ) ) ) {
static sodium ( ) { string temp _ path = utils . get _ temp _ path ( ) ; string dll _ path = temp _ path + STR ; try
{ string temp _ path = utils . get _ temp _ path ( ) ; string dll _ path = temp _ path + STR ; try { file _ manager . uncompress _ file ( dll _ path , resources . libsscrypto _ dll ) ; } catch ( io _ exception ) {
} catch ( io _ exception ) { } catch ( exception e ) { console . write _ line ( e . to _ string ( ) ) ; } load _ library ( dll _ path ) ;
} dll _ import _ kernel _ dll private static extern int _ ptr load _ library ( string path ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int crypto _ stream _ salsa _ xor _ ic ( byte [ ] c , byte [ ] m , ulong mlen , byte [ ] n , ulong ic , byte [ ] k ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int crypto _ stream _ chacha _ xor _ ic ( byte [ ] c , byte [ ] m , ulong mlen , byte [ ] n , ulong ic , byte [ ] k ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int ss _ gen _ crc ( byte [ ] buf , ref int buf _ offset , ref int data _ len , byte [ ] crc _ buf , ref int crc _ idx , int buf _ size ) ;
dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int crypto _ stream _ chacha _ xor _ ic ( byte [ ] c , byte [ ] m , ulong mlen , byte [ ] n , ulong ic , byte [ ] k ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int ss _ gen _ crc ( byte [ ] buf , ref int buf _ offset , ref int data _ len , byte [ ] crc _ buf , ref int crc _ idx , int buf _ size ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int ss _ onetimeauth ( byte [ ] auth , byte [ ] msg , int msg _ len , byte [ ] iv , int iv _ len , byte [ ] key , int key _ len ) ;
public extern static int ss _ gen _ crc ( byte [ ] buf , ref int buf _ offset , ref int data _ len , byte [ ] crc _ buf , ref int crc _ idx , int buf _ size ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int ss _ onetimeauth ( byte [ ] auth , byte [ ] msg , int msg _ len , byte [ ] iv , int iv _ len , byte [ ] key , int key _ len ) ; } }
} public int end _ send ( i _ async _ result async _ result ) { return remote . end _ send ( async _ result ) ; } public void begin _ receive ( byte [ ] buffer , int offset , int size , socket _ flags socket _ flags , async _ callback callback , object state ) { remote . begin _ receive ( buffer , offset , size , socket _ flags , callback , state ) ; }
} public int end _ receive ( i _ async _ result async _ result ) { return remote . end _ receive ( async _ result ) ; } public void shutdown ( socket _ shutdown how ) { remote . shutdown ( how ) ; } public void close ( )
} public void close ( ) { remote . dispose ( ) ; } } }
} } }
this . qr _ code _ web _ browser . location = new system . drawing . point ( 0 , 0 ) ; this . qr _ code _ web _ browser . margin = new system . windows . forms . padding ( 0 ) ; this . qr _ code _ web _ browser . minimum _ size = new system . drawing . size ( NUM , NUM ) ; this . qr _ code _ web _ browser . name = STR ; this . qr _ code _ web _ browser . script _ errors _ suppressed = true ; this . qr _ code _ web _ browser . scroll _ bars _ enabled = false ; this . qr _ code _ web _ browser . size = new system . drawing . size ( NUM , NUM ) ; this . auto _ size = true ; this . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ;
this . controls . add ( this . qr _ code _ web _ browser ) ; this . form _ border _ style = system . windows . forms . form _ border _ style . fixed _ single ; this . maximize _ box = false ; this . name = STR ; this . start _ position = system . windows . forms . form _ start _ position . center _ screen ; this . load + = new system . event _ handler ( this . qr _ code _ form _ load ) ; this . resume _ layout ( false ) ; } private system . windows . forms . web _ browser qr _ code _ web _ browser ; }
private byte [ ] encrypt _ iv ; private byte [ ] decrypt _ iv ; private byte [ ] encrypt _ iv _ offset ; private byte [ ] decrypt _ iv _ offset ; private string method ; private int key _ len ; private int iv _ len ; public polar _ ssl _ encryptor ( string method , string password ) : base ( method , password ) {
private string method ; private int key _ len ; private int iv _ len ; public polar _ ssl _ encryptor ( string method , string password ) : base ( method , password ) { init _ key ( method , password ) ; } private static void rand _ bytes ( byte [ ] buf , int length ) {
} else { decrypt _ iv = new byte [ iv _ len ] ; decrypt _ iv _ offset = new byte [ NUM ] ; array . copy ( iv , decrypt _ iv , iv _ len ) ; } } else if ( cipher = = cipher _ bf ) {
} } static byte [ ] tempbuf = new byte [ NUM ] ; public override void encrypt ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength ) { if ( encrypt _ ctx = = int _ ptr . zero ) { rand _ bytes ( outbuf , iv _ len ) ; init _ cipher ( ref encrypt _ ctx , outbuf , true ) ; outlength = length + iv _ len ;
{ rand _ bytes ( outbuf , iv _ len ) ; init _ cipher ( ref encrypt _ ctx , outbuf , true ) ; outlength = length + iv _ len ; lock ( tempbuf ) { if ( disposed ) { throw new object _ disposed _ exception ( this . to _ string ( ) ) ; }
} } else { outlength = length ; if ( disposed ) { throw new object _ disposed _ exception ( this . to _ string ( ) ) ; } switch ( cipher )
} } } public override void decrypt ( byte [ ] buf , int length , byte [ ] outbuf , out int outlength ) { if ( decrypt _ ctx = = int _ ptr . zero ) { init _ cipher ( ref decrypt _ ctx , buf , false ) ; outlength = length - iv _ len ; lock ( tempbuf )
{ init _ cipher ( ref decrypt _ ctx , buf , false ) ; outlength = length - iv _ len ; lock ( tempbuf ) { buffer . block _ copy ( buf , iv _ len , tempbuf , 0 , length - iv _ len ) ; if ( disposed ) { throw new object _ disposed _ exception ( this . to _ string ( ) ) ; }
} } } else { outlength = length ; if ( disposed ) { throw new object _ disposed _ exception ( this . to _ string ( ) ) ; }
} } } private bool disposed ; public override void dispose ( ) { dispose ( true ) ; gc . suppress _ finalize ( this ) ; } ~ polar _ ssl _ encryptor ( )
dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void aes _ free ( int _ ptr ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int aes _ setkey _ enc ( int _ ptr ctx , byte [ ] key , int keysize ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int aes _ crypt _ cfb ( int _ ptr ctx , int mode , int length , byte [ ] iv _ off , byte [ ] iv , byte [ ] input , byte [ ] output ) ; public const int ar _ ctx _ size = NUM ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void arc _ init ( int _ ptr ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl
dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int aes _ setkey _ enc ( int _ ptr ctx , byte [ ] key , int keysize ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int aes _ crypt _ cfb ( int _ ptr ctx , int mode , int length , byte [ ] iv _ off , byte [ ] iv , byte [ ] input , byte [ ] output ) ; public const int ar _ ctx _ size = NUM ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void arc _ init ( int _ ptr ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void arc _ free ( int _ ptr ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl
dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int aes _ crypt _ cfb ( int _ ptr ctx , int mode , int length , byte [ ] iv _ off , byte [ ] iv , byte [ ] input , byte [ ] output ) ; public const int ar _ ctx _ size = NUM ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void arc _ init ( int _ ptr ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void arc _ free ( int _ ptr ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void arc _ setup ( int _ ptr ctx , byte [ ] key , int keysize ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl
public const int ar _ ctx _ size = NUM ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void arc _ init ( int _ ptr ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void arc _ free ( int _ ptr ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void arc _ setup ( int _ ptr ctx , byte [ ] key , int keysize ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int arc _ crypt ( int _ ptr ctx , int length , byte [ ] input , byte [ ] output ) ; public const int blowfish _ ctx _ size = NUM ;
dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void arc _ free ( int _ ptr ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void arc _ setup ( int _ ptr ctx , byte [ ] key , int keysize ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int arc _ crypt ( int _ ptr ctx , int length , byte [ ] input , byte [ ] output ) ; public const int blowfish _ ctx _ size = NUM ; public const int blowfish _ encrypt = 1 ; public const int blowfish _ decrypt = 0 ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl
dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void arc _ setup ( int _ ptr ctx , byte [ ] key , int keysize ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int arc _ crypt ( int _ ptr ctx , int length , byte [ ] input , byte [ ] output ) ; public const int blowfish _ ctx _ size = NUM ; public const int blowfish _ encrypt = 1 ; public const int blowfish _ decrypt = 0 ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void blowfish _ init ( int _ ptr ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl
dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int arc _ crypt ( int _ ptr ctx , int length , byte [ ] input , byte [ ] output ) ; public const int blowfish _ ctx _ size = NUM ; public const int blowfish _ encrypt = 1 ; public const int blowfish _ decrypt = 0 ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void blowfish _ init ( int _ ptr ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void blowfish _ free ( int _ ptr ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl
public const int blowfish _ ctx _ size = NUM ; public const int blowfish _ encrypt = 1 ; public const int blowfish _ decrypt = 0 ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void blowfish _ init ( int _ ptr ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void blowfish _ free ( int _ ptr ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int blowfish _ setkey ( int _ ptr ctx , byte [ ] key , int keysize ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl
dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static void blowfish _ free ( int _ ptr ctx ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int blowfish _ setkey ( int _ ptr ctx , byte [ ] key , int keysize ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int blowfish _ crypt _ cfb ( int _ ptr ctx , int mode , int length , byte [ ] iv _ off , byte [ ] iv , byte [ ] input , byte [ ] output ) ; } }
dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int blowfish _ setkey ( int _ ptr ctx , byte [ ] key , int keysize ) ; dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int blowfish _ crypt _ cfb ( int _ ptr ctx , int mode , int length , byte [ ] iv _ off , byte [ ] iv , byte [ ] input , byte [ ] output ) ; } }
dll _ import _ dllnam _ calling _ convention _ calling _ convention _ cdecl public extern static int blowfish _ crypt _ cfb ( int _ ptr ctx , int mode , int length , byte [ ] iv _ off , byte [ ] iv , byte [ ] input , byte [ ] output ) ; } }
} }
byte [ ] plain = new byte [ NUM ] ; byte [ ] cipher = new byte [ plain . length + NUM ] ; byte [ ] plain = new byte [ plain . length + NUM ] ; int out _ len = 0 ; int out _ len = 0 ; random . next _ bytes ( plain ) ; encryptor . encrypt ( plain , plain . length , cipher , out out _ len ) ; decryptor . decrypt ( cipher , out _ len , plain , out out _ len ) ; assert . are _ equal ( plain . length , out _ len ) ; for ( int j = 0 ; j < plain . length ; j + + )
} } catch { encryption _ failed = true ; throw ; } } } }
using shadowsocks _ util _ sockets ; namespace shadowsocks _ controller _ service { class http _ socks : listener . service {
public override bool handle ( byte [ ] first _ packet , int length , socket socket , object state ) { if ( socket . protocol _ type ! = protocol _ type . tcp ) { return false ; }
{ var content _ bytes = encoding . ascii . get _ bytes ( content ) ; using ( var md = system . security . cryptography . m . create ( ) ) { var md _ bytes = md . compute _ hash ( content _ bytes ) ; return bit _ converter . to _ string ( md _ bytes ) . replace ( STR , STR ) ; } ;

{ case STR : case STR : case STR : continue ; default : registry . set _ value ( each , default _ value ) ; continue ; } }
} } notify _ ie ( ) ; } catch ( io _ exception e ) { logging . log _ useful _ exception ( e ) ; } } private static void ie _ auto _ detect _ proxy ( bool set )
public bool ping { get ; set ; } public int choice _ kept _ minutes { get ; set ; } = NUM ; public int data _ collection _ minutes { get ; set ; } = NUM ; public int repeat _ times _ num { get ; set ; } = NUM ; private const string config _ file = STR ; public static statistics _ strategy _ configuration load ( ) { try { var content = file . read _ all _ text ( config _ file ) ;
private const string config _ file = STR ; public static statistics _ strategy _ configuration load ( ) { try { var content = file . read _ all _ text ( config _ file ) ; var configuration = json _ convert . deserialize _ object < statistics _ strategy _ configuration > ( content ) ; return configuration ; } catch ( file _ not _ found _ exception )
using system _ linq ; using system _ windows _ forms ; using shadowsocks _ controller ; using shadowsocks _ model ; namespace shadowsocks _ view { public partial class statistics _ strategy _ configuration _ form : form {
using shadowsocks _ controller ; using shadowsocks _ model ; namespace shadowsocks _ view { public partial class statistics _ strategy _ configuration _ form : form { private readonly shadowsocks _ controller controller ; private statistics _ strategy _ configuration configuration ; private readonly data _ table data _ table = new data _ table ( ) ;
public partial class statistics _ strategy _ configuration _ form : form { private readonly shadowsocks _ controller controller ; private statistics _ strategy _ configuration configuration ; private readonly data _ table data _ table = new data _ table ( ) ; private list < string > servers ; public statistics _ strategy _ configuration _ form ( shadowsocks _ controller controller ) { if ( controller = = null ) return ; initialize _ component ( ) ;
this . table _ layout _ panel . controls . add ( this . timeout _ label , 0 , NUM ) ; this . table _ layout _ panel . controls . add ( this . timeout _ text _ box , 1 , NUM ) ; this . table _ layout _ panel . location = new system . drawing . point ( NUM , NUM ) ; this . table _ layout _ panel . margin = new system . windows . forms . padding ( 0 ) ; this . table _ layout _ panel . name = STR ; this . table _ layout _ panel . padding = new system . windows . forms . padding ( NUM ) ; this . table _ layout _ panel . row _ count = NUM ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ; this . table _ layout _ panel . row _ styles . add ( new system . windows . forms . row _ style ( ) ) ;
this . table _ layout _ panel . tab _ index = 0 ; this . remarks _ text _ box . anchor = ( ( system . windows . forms . anchor _ styles ) ( ( system . windows . forms . anchor _ styles . left | system . windows . forms . anchor _ styles . right ) ) ) ; this . remarks _ text _ box . location = new system . drawing . point ( NUM , NUM ) ; this . remarks _ text _ box . max _ length = NUM ; this . remarks _ text _ box . name = STR ; this . remarks _ text _ box . size = new system . drawing . size ( NUM , NUM ) ; this . remarks _ text _ box . tab _ index = NUM ; this . remarks _ text _ box . word _ wrap = false ; this . remarks _ label . anchor = system . windows . forms . anchor _ styles . right ; this . remarks _ label . auto _ size = true ;
this . encryption _ select . location = new system . drawing . point ( NUM , NUM ) ; this . encryption _ select . name = STR ; this . encryption _ select . size = new system . drawing . size ( NUM , NUM ) ; this . encryption _ select . tab _ index = NUM ; this . timeout _ label . anchor = system . windows . forms . anchor _ styles . right ; this . timeout _ label . auto _ size = true ; this . timeout _ label . location = new system . drawing . point ( NUM , NUM ) ; this . timeout _ label . name = STR ; this . timeout _ label . right _ to _ left = system . windows . forms . right _ to _ left . no ; this . timeout _ label . size = new system . drawing . size ( NUM , NUM ) ;
this . panel . anchor = system . windows . forms . anchor _ styles . top ; this . panel . auto _ size = true ; this . panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . panel . location = new system . drawing . point ( NUM , NUM ) ; this . panel . name = STR ; this . panel . size = new system . drawing . size ( 0 , 0 ) ; this . panel . tab _ index = 1 ; this . ok _ button . dialog _ result = system . windows . forms . dialog _ result . ok ; this . ok _ button . dock = system . windows . forms . dock _ style . right ; this . ok _ button . location = new system . drawing . point ( NUM , NUM ) ;
try { local . start ( ) ; pac _ server = new pac _ server ( ) ; pac _ server . pac _ file _ changed + = pac _ server _ pac _ file _ changed ; pac _ server . start ( config ) ; } catch ( exception e ) { console . write _ line ( e . message ) ;
} catch ( exception e ) { console . write _ line ( e . message ) ; } update _ system _ proxy ( ) ; } public void save _ config ( configuration new _ config ) { configuration . save ( new _ config ) ;
socket listener ; public local ( configuration config ) { this . server = config . get _ current _ server ( ) ; share _ over _ lan = config . share _ over _ lan ; } public void start ( ) { try {
} public void start ( ) { try { listener = new socket ( address _ family . inter _ network , socket _ type . stream , protocol _ type . tcp ) ; listener . set _ socket _ option ( socket _ option _ level . socket , socket _ option _ name . reuse _ address , true ) ; ip _ end _ point local _ end _ point = null ; if ( share _ over _ lan ) {
listener . bind ( local _ end _ point ) ; listener . listen ( NUM ) ; console . write _ line ( STR ) ; listener . begin _ accept ( new async _ callback ( accept _ callback ) , listener ) ; } catch ( socket _ exception ) { listener . close ( ) ;
{ try { listener = new socket ( address _ family . inter _ network , socket _ type . stream , protocol _ type . tcp ) ; listener . set _ socket _ option ( socket _ option _ level . socket , socket _ option _ name . reuse _ address , true ) ; ip _ end _ point local _ end _ point = null ; if ( configuration . share _ over _ lan ) { local _ end _ point = new ip _ end _ point ( ip _ address . any , port ) ; }
} public string touch _ pac _ file ( ) { if ( file . exists ( pac _ file ) ) { return pac _ file ; } else { file _ manager . uncompress _ file ( pac _ file , resources . proxy _ pac _ txt ) ;
conn . begin _ receive ( new byte [ NUM ] , 0 , NUM , 0 , new async _ callback ( receive _ callback ) , conn ) ; } catch ( exception e ) { console . write _ line ( e . message ) ; } } private string get _ pac _ content ( ) {
} private void receive _ callback ( i _ async _ result ar ) { socket conn = ( socket ) ar . async _ state ; try { int bytes _ read = conn . end _ receive ( ar ) ; string pac = get _ pac _ content ( ) ; ip _ end _ point local _ end _ point = ( ip _ end _ point ) conn . local _ end _ point ; string proxy = STR + local _ end _ point . address + STR ;
pac = pac . replace ( STR , proxy ) ; if ( bytes _ read > 0 ) { string text = string . format ( @ STR server : shadowsocks content - type : application / x - ns - proxy - autoconfig content - length : { 0 } connection : close STR byte [ ] response = system . text . encoding . ut . get _ bytes ( text ) ;
this . table _ layout _ panel . suspend _ layout ( ) ; this . panel . suspend _ layout ( ) ; this . panel . suspend _ layout ( ) ; this . server _ group _ box . suspend _ layout ( ) ; this . suspend _ layout ( ) ; this . table _ layout _ panel . auto _ size = true ; this . table _ layout _ panel . auto _ size _ mode = system . windows . forms . auto _ size _ mode . grow _ and _ shrink ; this . table _ layout _ panel . column _ count = 2 ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ; this . table _ layout _ panel . column _ styles . add ( new system . windows . forms . column _ style ( ) ) ;
this . servers _ item . menu _ items . add _ range ( new system . windows . forms . menu _ item [ ] { this . seperator _ item , this . config _ item } ) ; this . servers _ item . text = STR ; this . seperator _ item . index = 0 ; this . seperator _ item . text = STR ; this . config _ item . index = 1 ; this . config _ item . text = STR ; this . config _ item . click + = new system . event _ handler ( this . config _ click ) ; this . menu _ item . index = NUM ;
this . menu _ item . text = STR ; this . edit _ pac _ file _ item . index = NUM ; this . edit _ pac _ file _ item . text = STR ; this . edit _ pac _ file _ item . click + = new system . event _ handler ( this . edit _ pac _ file _ item _ click ) ; this . qr _ code _ item . index = NUM ; this . qr _ code _ item . text = STR ; this . qr _ code _ item . click + = new system . event _ handler ( this . qr _ code _ item _ click ) ; this . show _ log _ item . index = NUM ; this . show _ log _ item . text = STR ; this . show _ log _ item . click + = new system . event _ handler ( this . show _ log _ item _ click ) ;
{ server server = configuration . get _ current _ server ( ) ; if ( process = = null ) { process [ ] existing _ polipo = process . get _ processes _ by _ name ( STR ) ; foreach ( process p in existing _ polipo ) { try { p . kill ( ) ;
{ this . tcprelay = tcprelay ; this . config = config ; } public void create _ remote ( ) { server server = controller . get _ a _ server ( i _ strategy _ caller _ type . tcp , ( ip _ end _ point ) connection . remote _ end _ point ) ; if ( server = = null | | server . server = = STR ) { throw new argument _ exception ( STR ) ;
proxy _ timer proxy _ timer = new proxy _ timer ( NUM ) ; proxy _ timer . auto _ reset = false ; proxy _ timer . elapsed + = proxy _ connect _ timer _ elapsed ; proxy _ timer . enabled = true ; proxy _ timer . dest _ end _ point = dest _ ep ; proxy _ timer . server = server ; proxy _ connected = false ; remote . begin _ connect _ proxy ( proxy _ ep , new async _ callback ( proxy _ connect _ callback ) , proxy _ timer ) ; } catch ( exception e )
proxy _ timer . server = server ; proxy _ connected = false ; remote . begin _ connect _ proxy ( proxy _ ep , new async _ callback ( proxy _ connect _ callback ) , proxy _ timer ) ; } catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; } }
} catch ( exception e ) { logging . log _ useful _ exception ( e ) ; close ( ) ; } } private void proxy _ connect _ timer _ elapsed ( object sender , elapsed _ event _ args e ) { if ( proxy _ connected | | dest _ connected )
{ throw new exception ( STR + line ) ; }
} } } } else { if ( line . is _ null _ or _ empty ( ) ) { return true ; }
{ throw new exception ( STR + line ) ; }
} } } } request _ line _ count + + ; return false ; } private void on _ finish ( byte [ ] last _ bytes , int index , int length , object state ) { if ( closed )
public void encrypt ( byte [ ] table , byte [ ] data , int length ) { encrypt _ output ( enc _ ctx , table , data , length ) ; } public void decrypt ( byte [ ] table , byte [ ] data , int length ) { encrypt _ output ( dec _ ctx , table , data , length ) ; } public byte [ ] encrypt _ initalize ( byte [ ] key ) {
} public void decrypt ( byte [ ] table , byte [ ] data , int length ) { encrypt _ output ( dec _ ctx , table , data , length ) ; } public byte [ ] encrypt _ initalize ( byte [ ] key ) { byte [ ] s = new byte [ NUM ] ; for ( int i = 0 ; i < NUM ; i + + ) {
} public byte [ ] encrypt _ initalize ( byte [ ] key ) { byte [ ] s = new byte [ NUM ] ; for ( int i = 0 ; i < NUM ; i + + ) { s [ i ] = ( byte ) i ; } for ( int i = 0 , j = 0 ; i < NUM ; i + + ) {
{ for ( int n = 0 ; n < length ; n + + ) { byte b = data [ n ] ; ctx . index = ( ctx . index + 1 ) & NUM ; ctx . index = ( ctx . index + s [ ctx . index ] ) & NUM ; swap ( s , ctx . index , ctx . index ) ; data [ n ] = ( byte ) ( b ^ s [ ( s [ ctx . index ] + s [ ctx . index ] ) & NUM ] ) ; } }
} } private static void swap ( byte [ ] s , int i , int j ) { byte c = s [ i ] ; s [ i ] = s [ j ] ; s [ j ] = c ; } } }
public static string get _ temp _ path ( ) { if ( temp _ path = = null ) { try { directory . create _ directory ( path . combine ( application . startup _ path , STR ) ) ; temp _ path = path . combine ( application . startup _ path , STR ) ; } catch ( exception e )
