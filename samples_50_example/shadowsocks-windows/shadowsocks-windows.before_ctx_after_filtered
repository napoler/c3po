using System.IO.Compression;\nnamespace Shadowsocks.Controller\n{\n    public class FileManager\n    {\n        public static bool ByteArrayToFile(string fileName, byte[] content)\n        {\n            try\n            {
            _connection.BeginReceive(_connetionRecvBuffer, 2, RecvSize - 2, SocketFlags.None, OnAddressFullyRead,\n                new object[] { bytesRemain, onSuccess });\n        }\n        private void OnAddressFullyRead(IAsyncResult ar)\n        {\n            if (_closed)\n            {\n                return;\n            }\n            try\n            {\n                int bytesRead = _connection.EndReceive(ar);
        }\n        private void OnAddressFullyRead(IAsyncResult ar)\n        {\n            if (_closed)\n            {\n                return;\n            }\n            try\n            {\n                int bytesRead = _connection.EndReceive(ar);\n                object[] states = (object[])ar.AsyncState;\n                int bytesRemain = (int)states[0];
                            break;\n                        default:\n                            throw new NotSupportedException("Unknown forward proxy.");\n                    }\n                    proxyEP = SocketUtil.GetEndPoint(_config.proxyServer, _config.proxyPort);\n                }\n                else\n                {\n                    remote = new DirectConnect();\n                }
                remote.BeginConnectProxy(proxyEP, ProxyConnectCallback,\n                    new AsyncSession<ProxyTimer>(remote, proxyTimer));\n            }\n            catch (Exception e)\n            {\n                ErrorClose(e);\n            }\n        }\n        private void ProxyConnectTimer_Elapsed(object sender, ElapsedEventArgs e)\n        {
            Close();\n        }\n        private void ProxyConnectCallback(IAsyncResult ar)\n        {\n            if (_closed)\n            {\n                return;\n            }\n            try\n            {
            catch (ArgumentException)\n            {\n            }\n            catch (Exception e)\n            {\n                ErrorClose(e);\n            }\n        }\n        private void DestConnectTimer_Elapsed(object sender, ElapsedEventArgs e)\n        {
            }\n            AsyncSession session = timer.Session;\n            Server server = timer.Server;\n            OnFailed?.Invoke(this, new SSRelayEventArgs(_server));\n            Logger.Info($"{server.FriendlyName()} timed out");\n            session.Remote.Close();\n            Close();\n        }\n        private void ConnectCallback(IAsyncResult ar)\n        {
                Logger.Trace($"_firstPacketLength = {_firstPacketLength}");\n                SendToServer(_firstPacketLength, session);\n            }\n            catch (Exception e)\n            {\n                ErrorClose(e);\n            }\n        }\n        private void PipeRemoteReceiveCallback(IAsyncResult ar)\n        {
        }\n        private void RetryConnect()\n        {\n            if (_retryCount < _maxRetry)\n            {\n                Logging.Debug($"Connection failed, retry ({_retryCount})");\n                StartConnect();\n                _retryCount++;\n            }\n            else
using System.Text;\nusing System.Windows.Forms;\nusing Shadowsocks.Model;\nusing Shadowsocks.Properties;\nusing Shadowsocks.Util;\nusing Shadowsocks.Util.ProcessManagement;\nnamespace Shadowsocks.Controller\n{\n    class PrivoxyRunner\n    {
                throw new ArgumentException(I18N.GetString("Port out of range"));\n        }\n        public static void CheckLocalPort(int port)\n        {\n            CheckPort(port);\n            if (port == 8123)\n                throw new ArgumentException(I18N.GetString("Port can't be 8123"));\n        }\n        private static void CheckPassword(string password)\n        {
            if (port == 8123)\n                throw new ArgumentException(I18N.GetString("Port can't be 8123"));\n        }\n        private static void CheckPassword(string password)\n        {\n            if (password.IsNullOrEmpty())\n                throw new ArgumentException(I18N.GetString("Password can not be blank"));\n        }\n        private static void CheckServer(string server)\n        {
        {\n            return server.GetHashCode() ^ server_port;\n        }\n        public override bool Equals(object obj)\n        {\n            Server o2 = (Server)obj;\n            return server == o2.server && server_port == o2.server_port;\n        }\n        public string FriendlyName()\n        {
        {\n            Server o2 = (Server)obj;\n            return server == o2.server && server_port == o2.server_port;\n        }\n        public string FriendlyName()\n        {\n            if (server.IsNullOrEmpty())\n            {\n                return I18N.GetString("New server");\n            }

                if (controller.GetConfigurationCopy().pacUrl.IsNullOrEmpty())\n                {\n                    UpdateOnlinePACURLItem_Click(sender, e);\n                }
using Shadowsocks.Util;\nnamespace Shadowsocks.Controller\n{\n    public class Logging\n    {\n        public static string LogFile;\n        public static bool OpenLogFile()\n        {\n            try\n            {
                Logging.LogUsefulException(e);\n                Close();\n            }\n        }\n        private void PipeConnectionReceiveCallback(IAsyncResult ar)\n        {\n            if (_closed) return;\n            try\n            {\n                int bytesRead = _connection.EndReceive(ar);
                    new AsyncCallback(AcceptCallback),\n                    listener);\n                conn.BeginReceive(new byte[1024], 0, 1024, 0,\n                    new AsyncCallback(ReceiveCallback), conn);\n            }\n            catch (ObjectDisposedException)\n            {\n            }\n            catch (Exception e)\n            {
        private void UpdateServersMenu()\n        {\n            var items = ServersItem.MenuItems;\n            while (items[0] != SeperatorItem)\n            {\n                items.RemoveAt(0);\n            }\n            int i = 0;\n            foreach (var strategy in controller.GetStrategies())\n            {
                throw new ArgumentException("Too short!", nameof(delimiter));\n            }\n            if (maxLineBytes < _delimiterBytes.Length)\n            {\n                throw new ArgumentException("Too small!", nameof(maxLineBytes));\n            }\n            _delimiterSearch = new ByteSearch.SearchTarget(_delimiterBytes);\n            _lineBuffer = new byte[maxLineBytes];\n            if (length > 0)\n            {\n                // process first package
            TouchUserRuleFile();\n            this.WatchPacFile();\n            this.WatchUserRuleFile();\n        }\n        public string TouchPACFile()\n        {\n            if (!File.Exists(PAC_FILE))\n            {\n                File.WriteAllText(PAC_FILE, Resources.proxy_pac_txt);\n            }
            return USER_RULE_FILE;\n        }\n        internal string GetPACContent()\n        {\n            if (File.Exists(PAC_FILE))\n            {\n                return File.ReadAllText(PAC_FILE, Encoding.UTF8);\n            }\n            else\n            {
                    //state.data.Add(new KeyValuePair<string, string>("data", reply.Buffer.ToString())); // The data of reply\n            var dataLine = string.Join(Delimiter, data.Select(kv => kv.Value).ToArray());\n            string[] lines;\n            if (!File.Exists(AvailabilityStatisticsFile))\n            {\n                var headerLine = string.Join(Delimiter, data.Select(kv => kv.Key).ToArray());\n                lines = new[] { headerLine, dataLine };\n            }\n            else\n            {
        private readonly object _decryptionLock = new object();\n        private readonly object _closeConnLock = new object();\n        private DateTime _startConnectTime;\n        private DateTime _startReceivingTime;\n        private DateTime _startSendingTime;\n        private EndPoint _destEndPoint = null;\n            {\n                throw new ArgumentException("No server configured");\n            }\n            _encryptor = EncryptorFactory.GetEncryptor(server.method, server.password);
            _connection.BeginReceive(_connetionRecvBuffer, 2, RecvSize - 2, SocketFlags.None, OnAddressFullyRead,\n                new object[] { bytesRemain, onSuccess });\n        }\n        private void OnAddressFullyRead(IAsyncResult ar)\n        {\n            if (_closed)\n            {\n                return;\n            }\n            try\n            {\n                int bytesRead = _connection.EndReceive(ar);
        }\n        private void OnAddressFullyRead(IAsyncResult ar)\n        {\n            if (_closed)\n            {\n                return;\n            }\n            try\n            {\n                int bytesRead = _connection.EndReceive(ar);\n                object[] states = (object[])ar.AsyncState;\n                int bytesRemain = (int)states[0];
                remote.BeginConnectProxy(proxyEP, ProxyConnectCallback,\n                    new AsyncSession<ProxyTimer>(remote, proxyTimer));\n            }\n            catch (Exception e)\n            {\n                ErrorClose(e);\n            }\n        }\n        private void ProxyConnectTimer_Elapsed(object sender, ElapsedEventArgs e)\n        {
            Close();\n        }\n        private void ProxyConnectCallback(IAsyncResult ar)\n        {\n            if (_closed)\n            {\n                return;\n            }\n            try\n            {
            catch (ArgumentException)\n            {\n            }\n            catch (Exception e)\n            {\n                ErrorClose(e);\n            }\n        }\n        private void DestConnectTimer_Elapsed(object sender, ElapsedEventArgs e)\n        {
            }\n            AsyncSession session = timer.Session;\n            Server server = timer.Server;\n            OnFailed?.Invoke(this, new SSRelayEventArgs(_server));\n            Logger.Info($"{server.FriendlyName()} timed out");\n            session.Remote.Close();\n            Close();\n        }\n        private void ConnectCallback(IAsyncResult ar)\n        {
                Logger.Trace($"_firstPacketLength = {_firstPacketLength}");\n                SendToServer(_firstPacketLength, session);\n            }\n            catch (Exception e)\n            {\n                ErrorClose(e);\n            }\n        }\n        private void PipeRemoteReceiveCallback(IAsyncResult ar)\n        {
        {\n            this.tcprelay = tcprelay;\n        }\n        public void CreateRemote()\n        {\n            Server server = controller.GetAServer(IStrategyCallerType.TCP, (IPEndPoint)connection.RemoteEndPoint);\n            if (server == null || server.server == "")\n            {\n                throw new ArgumentException("No server configured");\n            }
            Server server = controller.GetAServer(IStrategyCallerType.TCP, (IPEndPoint)connection.RemoteEndPoint);\n            if (server == null || server.server == "")\n            {\n                throw new ArgumentException("No server configured");\n            }\n            encryptor = EncryptorFactory.GetEncryptor(server.method, server.password, server.auth, false);\n            this.server = server;\n        }\n        public void Start(byte[] firstPacket, int length)\n        {
        {\n            _firstPacket = firstPacket;\n            _firstPacketLength = length;\n            HandshakeReceive();\n            lastActivity = DateTime.Now;\n        }\n        private void CheckClose()\n        {\n            if (connectionShutdown && remoteShutdown)\n            {
                    {\n                        // reject socks 4\n                        response = new byte[] { 0, 91 };\n                        Logging.Error("socks 5 protocol error");\n                    }\n                    connection.BeginSend(response, 0, response.Length, 0, new AsyncCallback(HandshakeSendCallback), null);\n                }\n                else\n                {
                else\n                {\n                    int bytesRead = connection.EndReceive(ar);\n                    if (bytesRead > 0)\n                    {\n                        Logging.Debug(remote, RecvSize, "TCP Relay");\n                        connection.BeginReceive(connetionRecvBuffer, 0, RecvSize, 0, new AsyncCallback(ReadAll), null);\n                    }\n                    else\n                    {
        private void RetryConnect()\n        {\n            if (retryCount < maxRetry)\n            {\n                Logging.Debug($"Connection failed, retry ({retryCount})");\n                StartConnect();\n                retryCount++;\n            }\n            else\n            {
            {\n                return;\n            }\n            try\n            {\n                int bytesRead = remote.EndReceive(ar);\n                totalRead += bytesRead;\n                tcprelay.UpdateInboundCounter(bytesRead);\n                if (bytesRead > 0)\n                {
                        {\n                            return;\n                        }\n                        encryptor.Decrypt(remoteRecvBuffer, bytesRead, remoteSendBuffer, out bytesToSend);\n                    }\n                    Logging.Debug(remote, bytesToSend, "TCP Relay", "@PipeRemoteReceiveCallback() (download)");\n                    connection.BeginSend(remoteSendBuffer, 0, bytesToSend, 0, new AsyncCallback(PipeConnectionSendCallback), null);\n                    IStrategy strategy = controller.GetCurrentStrategy();\n                    if (strategy != null)\n                    {
                        {\n                            return;\n                        }\n                        encryptor.Encrypt(connetionRecvBuffer, bytesRead, connetionSendBuffer, out bytesToSend);\n                    }\n                    Logging.Debug(remote, bytesToSend, "TCP Relay", "@PipeConnectionReceiveCallback() (upload)");\n                    remote.BeginSend(connetionSendBuffer, 0, bytesToSend, 0, new AsyncCallback(PipeRemoteSendCallback), null);\n                    IStrategy strategy = controller.GetCurrentStrategy();\n                    if (strategy != null)\n                    {
        // instance-based lock without static\n            Server server = _controller.GetAServer(IStrategyCallerType.TCP, (IPEndPoint)_connection.RemoteEndPoint,\n                _destEndPoint);\n            if (server == null || server.server == "")\n                throw new ArgumentException("No server configured");
                    {\n                        Logging.Debug("Unsupported CMD=" + _command);\n                        Close();\n                    }\n                    else\n                    {\n                        if (_command == CMD_CONNECT)\n                        {\n                            byte[] response = { 5, 0, 0, 1, 0, 0, 0, 0, 0, 0 };\n                            _connection.BeginSend(response, 0, response.Length, SocketFlags.None,
                case AddressFamily.InterNetwork:\n                    response[3] = ATYP_IPv4;\n                    break;\n                case AddressFamily.InterNetworkV6:\n                    response[3] = ATYP_IPv6;\n                    break;\n            }\n            address.CopyTo(response, 4);\n            response[response.Length - 1] = (byte)(port & 0xFF);\n            response[response.Length - 2] = (byte)((port >> 8) & 0xFF);
            _connection.BeginSend(response, 0, response.Length, SocketFlags.None, ReadAll, true);\n        }\n        private void ReadAll(IAsyncResult ar)\n        {\n            if (_closed) return;\n            try\n            {\n                if (ar.AsyncState != null)\n                {\n                    _connection.EndSend(ar);
                {\n                    _connection.EndSend(ar);\n                    _connection.BeginReceive(_connetionRecvBuffer, 0, RecvSize, SocketFlags.None,\n                        ReadAll, null);\n                }\n                else\n                {\n                    int bytesRead = _connection.EndReceive(ar);\n                    if (bytesRead > 0)\n                    {
                    }\n                }\n                _startConnectTime = DateTime.Now;\n                ServerTimer connectTimer = new ServerTimer(_serverTimeout) { AutoReset = false };\n                connectTimer.Elapsed += DestConnectTimer_Elapsed;\n                connectTimer.Enabled = true;\n                connectTimer.Session = session;\n                connectTimer.Server = server;\n                _destConnected = false;\n                // Connect to the remote endpoint.
            this.EncryptionLabel.Anchor = System.Windows.Forms.AnchorStyles.Right;\n            this.EncryptionLabel.AutoSize = true;\n            this.EncryptionLabel.Location = new System.Drawing.Point(42, 113);\n            this.EncryptionLabel.Name = "EncryptionLabel";\n            this.EncryptionLabel.Size = new System.Drawing.Size(65, 12);\n            this.EncryptionLabel.TabIndex = 4;\n            this.EncryptionLabel.Text = "Encryption";\n            // \n            // EncryptionSelect\n            // 
            SetResponse(responseRecords);\n        }\n        public void SetResponse(ICollection<int?> responseRecords)\n        {\n            if (responseRecords == null) return;\n            var records = responseRecords.Where(response => response != null).Select(response => response.Value).ToList();\n            if (!records.Any()) return;\n            AverageResponse = (int?) records.Average();\n            MinResponse = records.Min();\n            MaxResponse = records.Max();
        private HotkeyConfig _modifiedConfig;\n        private readonly IEnumerable<TextBox> _allTextBoxes;\n        public HotkeySettingsForm(ShadowsocksController controller)\n        {\n            InitializeComponent();\n            UpdateTexts();\n            Icon = Icon.FromHandle(Resources.ssw128.GetHicon());\n            _controller = controller;\n            _controller.ConfigChanged += controller_ConfigChanged;\n            LoadCurrentConfiguration();\n            // get all textboxes belong to this form
            // I18N stuff\n            SwitchSystemProxyLabel.Text = I18N.GetString("Switch system proxy");\n            SwitchProxyModeLabel.Text = I18N.GetString("Switch system proxy mode");\n            SwitchAllowLanLabel.Text = I18N.GetString("Switch share over LAN");\n            ShowLogsLabel.Text = I18N.GetString("Show Logs");\n            ServerMoveUpLabel.Text = I18N.GetString("Switch to prev server");\n            ServerMoveDownLabel.Text = I18N.GetString("Switch to next server");\n            btnOK.Text = I18N.GetString("OK");\n            btnCancel.Text = I18N.GetString("Cancel");\n            btnRegisterAll.Text = I18N.GetString("Reg All");
            }\n        }\n        private void UnregHotkey(TextBox tb)\n        {\n            HotKeys.HotKeyCallBackHandler callBack;\n            Label lb;\n            PrepareForHotkey(tb, out callBack, out lb);\n            UnregPrevHotkey(callBack);\n        }\n        private void CancelButton_Click(object sender, EventArgs e)\n        {
                _listener.Close();\n                throw;\n            }\n        }\n        public void Stop()\n        {\n            _listener.Close();\n        }\n        public void AcceptCallback(IAsyncResult ar)\n        {
                return PAC_FILE;\n            }\n            else\n            {\n                FileManager.UncompressFile(PAC_FILE, Resources.proxy_pac_txt);\n                return PAC_FILE;\n            }\n        }\n        public void AcceptCallback(IAsyncResult ar)\n        {
                {\n                    if (OnetimeAuth)\n                    {\n                        lock (hash_buf)\n                        {\n                            int headLen = ss_headlen(buf, length);\n                            int data_len = length - headLen;\n                            Buffer.BlockCopy(buf, headLen, buf, headLen + ONETIMEAUTH_BYTES, data_len);\n                            buf[0] |= ONETIMEAUTH_FLAG;\n                            byte[] auth = new byte[ONETIMEAUTH_BYTES];
namespace Shadowsocks.View\n{\n    public partial class ConfigForm : Form\n    {\n        private ShadowsocksController controller;\n        // this is a copy of configuration that we are working on\n        private Configuration _modifiedConfiguration;\n        private int _lastSelectedIndex = -1;\n        public ConfigForm(ShadowsocksController controller)\n        {
    public partial class ConfigForm : Form\n    {\n        private ShadowsocksController controller;\n        // this is a copy of configuration that we are working on\n        private Configuration _modifiedConfiguration;\n        private int _lastSelectedIndex = -1;\n        public ConfigForm(ShadowsocksController controller)\n        {\n            Font = SystemFonts.MessageBoxFont;\n            InitializeComponent();\n            // a dirty hack
        private int _lastSelectedIndex = -1;\n        public ConfigForm(ShadowsocksController controller)\n        {\n            Font = SystemFonts.MessageBoxFont;\n            InitializeComponent();\n            // a dirty hack\n            ServersListBox.Dock = DockStyle.Fill;\n            tableLayoutPanel5.Dock = DockStyle.Fill;\n            PerformLayout();\n            UpdateTexts();\n            SetupValueChangedListeners();
            this.controller = controller;
            this.controller = controller;\n            toolTip1.SetToolTip(PortableModeCheckBox, I18N.GetString("Restart required"));\n            RemarksLabel.Text = I18N.GetString("Remarks");\n            TimeoutLabel.Text = I18N.GetString("Timeout(Sec)");\n            ServerGroupBox.Text = I18N.GetString("Server");\n            OKButton.Text = I18N.GetString("OK");\n            MyCancelButton.Text = I18N.GetString("Cancel");\n            ApplyButton.Text = I18N.GetString("Apply");\n            MoveUpButton.Text = I18N.GetString("Move &Up");\n            MoveDownButton.Text = I18N.GetString("Move D&own");
                    }\n                    else\n                    {\n                        string pacUrl;\n                        if (config.useOnlinePac && !string.IsNullOrEmpty(config.pacUrl))\n                            pacUrl = config.pacUrl;\n                        else\n                            pacUrl = "http://127.0.0.1:" + config.localPort.ToString() + "/pac?t=" + GetTimestamp(DateTime.Now);\n                        registry.SetValue("ProxyEnable", 0);\n                        var readProxyServer = registry.GetValue("ProxyServer");
                        registry.SetValue("ProxyEnable", 0);\n                        var readProxyServer = registry.GetValue("ProxyServer");\n                        registry.SetValue("ProxyServer", "");\n                        registry.SetValue("AutoConfigURL", pacUrl);\n                    }\n                }\n                else\n                {\n                    registry.SetValue("ProxyEnable", 0);
            try\n            {\n                string data = Encoding.UTF8.GetString(bytes);\n                int indexLastAt = data.LastIndexOf('@');\n                string afterAt = data.Substring(indexLastAt + 1);\n                int indexLastColon = afterAt.LastIndexOf(':');\n                server_port = int.Parse(afterAt.Substring(indexLastColon + 1));\n                server = afterAt.Substring(0, indexLastColon);\n                string beforeAt = data.Substring(0, indexLastAt);\n                string[] parts = beforeAt.Split(new[] { ':' });
                Console.WriteLine(e);\n            }\n            try\n            {\n                pacServer = new PACServer();\n                pacServer.PACFileChanged += pacServer_PACFileChanged;\n                pacServer.Start(_config);\n            }\n            catch (Exception e)\n            {
            Bitmap iconCopy = new Bitmap(originIcon);\n            for (int x = 0; x < iconCopy.Width; x++)\n            {\n                for (int y = 0; y < iconCopy.Height; y++)\n                {\n                    Color color = originIcon.GetPixel(x, y);\n                    if (color.A != 0)\n                    {\n                        if (!enabled)\n                        {
using System.Net.NetworkInformation;\nusing System.Net.Sockets;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Shadowsocks.Model;\nusing Shadowsocks.Util;\nnamespace Shadowsocks.Controller\n{\n    using DataUnit = KeyValuePair<string, string>;\n    using DataList = List<KeyValuePair<string, string>>;
        {\n            if (_controller.GetCurrentStrategy()?.ID == ID) //output when enabled\n            {\n                Console.WriteLine(log);\n            }\n        }\n        public string ID => "com.shadowsocks.strategy.scbs";\n        public string Name => I18N.GetString("Choose By Total Package Loss");\n        public Server GetAServer(IStrategyCallerType type, IPEndPoint localIPEndPoint)\n        {
        }\n        #region Windows Form Designer generated code\n        /// <summary>\n        /// Required method for Designer support - do not modify\n        /// the contents of this method with the code editor.\n        /// </summary>\n        private void InitializeComponent()\n        {\n            this.components = new System.ComponentModel.Container();\n            this.LogMessageTextBox = new System.Windows.Forms.TextBox();
            this.tableLayoutPanel1.ResumeLayout(false);\n            this.tableLayoutPanel1.PerformLayout();\n            this.ToolbarFlowLayoutPanel.ResumeLayout(false);\n            this.ToolbarFlowLayoutPanel.PerformLayout();\n            this.ResumeLayout(false);\n        }\n        #endregion\n        private System.Windows.Forms.TextBox LogMessageTextBox;
using System.Net;\nusing System.Net.Sockets;\nusing Shadowsocks.Util.Sockets;\nnamespace Shadowsocks.Controller\n{\n    class PortForwarder : Listener.Service\n    {\n        private readonly int _targetPort;\n        public PortForwarder(int targetPort)\n        {
        public PortForwarder(int targetPort)\n        {\n            _targetPort = targetPort;\n        }\n        public override bool Handle(byte[] firstPacket, int length, Socket socket, object state)\n        {\n            if (socket.ProtocolType != ProtocolType.Tcp)\n            {\n                return false;\n            }
                _local = socket;\n                try\n                {\n                    EndPoint remoteEP = SocketUtil.GetEndPoint("127.0.0.1", targetPort);\n                    // Connect to the remote endpoint.\n                    _remote = new WrappedSocket();\n                    _remote.BeginConnect(remoteEP, ConnectCallback, null);\n                }\n                catch (Exception e)\n                {\n                    Logging.LogUsefulException(e);
            private void StartPipe(IAsyncResult ar)\n            {\n                if (_closed)\n                {\n                    return;\n                }\n                try\n                {\n                    _remote.EndSend(ar);\n                    _remote.BeginReceive(remoteRecvBuffer, 0, RecvSize, 0,
                if (_closed)\n                {\n                    return;\n                }\n                try\n                {\n                    _remote.EndSend(ar);\n                    _remote.BeginReceive(remoteRecvBuffer, 0, RecvSize, 0,\n                        PipeRemoteReceiveCallback, null);\n                    _local.BeginReceive(connetionRecvBuffer, 0, RecvSize, 0,
                catch (Exception e)\n                {\n                    Logging.LogUsefulException(e);\n                    Close();\n                }\n            }\n            private void CheckClose()\n            {\n                if (_localShutdown && _remoteShutdown)\n                {
            catch (Exception e)\n            {\n                Logging.LogUsefulException(e);\n            }\n            LoadLibrary(dllPath);\n        }\n        public static byte[] MD5(byte[] input)\n        {\n            byte[] output = new byte[16];
        }\n        #region Windows Form Designer generated code\n        /// <summary>\n        /// Required method for Designer support - do not modify\n        /// the contents of this method with the code editor.\n        /// </summary>\n        private void InitializeComponent()\n        {\n            this.components = new System.ComponentModel.Container();\n            this.LogMessageTextBox = new System.Windows.Forms.TextBox();
            this.tableLayoutPanel1.ResumeLayout(false);\n            this.tableLayoutPanel1.PerformLayout();\n            this.ToolbarFlowLayoutPanel.ResumeLayout(false);\n            this.ToolbarFlowLayoutPanel.PerformLayout();\n            this.ResumeLayout(false);\n        }\n        #endregion\n        private System.Windows.Forms.TextBox LogMessageTextBox;
        public void SendResponse(byte[] firstPacket, int length, Socket socket)\n        {\n            try\n            {\n                string pac = GetPACContent();\n                IPEndPoint localEndPoint = (IPEndPoint)socket.LocalEndPoint;\n                string proxy = GetPACAddress(firstPacket, length, localEndPoint);\n                pac = pac.Replace("__PROXY__", proxy);
        }\n        private void Watcher_Changed(object sender, FileSystemEventArgs e)\n        {\n            if (PACFileChanged != null)\n            {\n                PACFileChanged(this, new EventArgs());\n            }\n        }\n        private string GetPACAddress(byte[] requestBuf, int length, IPEndPoint localEndPoint)\n        {
            if (_pacServer == null)\n            {\n                _pacServer = new PACServer();\n                    tcpRelay,\n                    udpRelay,\n                    _pacServer,\n                    new PortForwarder(privoxyRunner.RunningPort)\n                };\n                _listener = new Listener(services);\n                _listener.Start(_config);\n            }\n            catch (Exception e)\n            {\n                // translate Microsoft language into human language\n                // i.e. An attempt was made to access a socket in a way forbidden by its access permissions => Port already in use
        private bool remoteShutdown = false;\n        private bool closed = false;\n        private object encryptionLock = new object();\n        private object decryptionLock = new object();\n        public void Start()\n        {\n            try\n            {\n                // TODO async resolving\n                IPAddress ipAddress;
        private object decryptionLock = new object();\n        public void Start()\n        {\n            try\n            {\n                // TODO async resolving\n                IPAddress ipAddress;\n                bool parsed = IPAddress.TryParse(server.server, out ipAddress);\n                if (!parsed)\n                {
        }\n        public void SaveLogViewerConfig(LogViewerConfig newConfig)\n        {\n            _config.logViewer = newConfig;\n            Configuration.Save(_config);\n        }\n        public void UpdateLatency(Server server, TimeSpan latency)\n        {\n            if (_config.availabilityStatistics)\n            {
            if (_config.availabilityStatistics)\n            {\n                availabilityStatistics.UpdateLatency(server, (int)latency.TotalMilliseconds);\n            }\n        }\n        public void UpdateInboundCounter(Server server, long n)\n        {\n            Interlocked.Add(ref inboundCounter, n);\n            if (_config.availabilityStatistics)\n            {
            if (_config.availabilityStatistics)\n            {\n                availabilityStatistics.UpdateInboundCounter(server, n);\n            }\n        }\n        public void UpdateOutboundCounter(Server server, long n)\n        {\n            Interlocked.Add(ref outboundCounter, n);\n            if (_config.availabilityStatistics)\n            {
        }\n        [DllImport("Kernel32.dll")]\n        private static extern IntPtr LoadLibrary(string path);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public static extern int crypto_stream_salsa20_xor_ic(byte[] c, byte[] m, ulong mlen, byte[] n, ulong ic, byte[] k);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public static extern int crypto_stream_chacha20_xor_ic(byte[] c, byte[] m, ulong mlen, byte[] n, ulong ic, byte[] k);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]\n        public static extern int crypto_stream_chacha20_ietf_xor_ic(byte[] c, byte[] m, ulong mlen, byte[] n, uint ic, byte[] k);\n        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
            try\n            {\n                ServerTimer timer = (ServerTimer)ar.AsyncState;\n                server = timer.Server;\n                timer.Elapsed -= connectTimer_Elapsed;\n                timer.Enabled = false;\n                timer.Dispose();\n                // Complete the connection.\n                remote.EndConnect(ar);\n                connected = true;\n                //Console.WriteLine("Socket connected to {0}",\n                //    remote.RemoteEndPoint.ToString());\n                var latency = DateTime.Now - _startConnectTime;
            }\n            return _tempPath;\n        }\n        public enum WindowsThemeMode { Dark, Light }\n        // Support on Windows 10 1903+\n        public static WindowsThemeMode GetWindows10SystemThemeSetting()\n        {\n            WindowsThemeMode themeMode = WindowsThemeMode.Dark;\n            try\n            {
            entryNameSize = Marshal.SizeOf(typeof(RasEntryName));\n            // with lprasentryname set to NULL. The variable pointed to by lpcb should be set to zero.\n            // The function will return the required buffer size in lpcb and an error code of ERROR_BUFFER_TOO_SMALL.\n            retval = RasEnumEntries(null, null, null, ref lpSize, out lpNames);\n            if (retval == ERROR_BUFFER_TOO_SMALL)\n            {\n                names = new RasEntryName[lpNames];\n                for (int i = 0; i < names.Length; i++)\n                {\n                    names[i].dwSize = entryNameSize;\n                }
        private static object locker = new object();\n        private void RunSingleEncryptionThread()\n        {\n            try\n            {\n                    for (int i = 0; i < 1000; i++)\n                    {\n                        var random = new Random();\n                        IEncryptor encryptor;\n                        IEncryptor decryptor;
            public string Path;\n        }\n        public event EventHandler ConfigChanged;\n        public event EventHandler EnableStatusChanged;\n        public event EventHandler ShareOverLANStatusChanged;\n        // when user clicked Edit PAC, and PAC file has already created\n        public event EventHandler<PathEventArgs> PACFileReadyToOpen;\n        public ShadowsocksController()\n        {\n            _config = Configuration.Load();\n            polipoRunner = new PolipoRunner();
                {\n                    var m = HttpRequestHeaderRegex.Match(line);\n                    if (m.Success)\n                    {\n                        var method = m.Groups[1].Value;\n                        if (method == "CONNECT")\n                        {\n                            _isConnect = true;\n                            if (!ParseHost(m.Groups[2].Value))\n                            {
                    if (line.IsNullOrEmpty())\n                    {\n                        return true;\n                    }\n                    if (!_isConnect)\n                    {\n                        if (line.StartsWith("Host: "))\n                        {\n                            if (!ParseHost(line.Substring(6).Trim()))\n                            {
