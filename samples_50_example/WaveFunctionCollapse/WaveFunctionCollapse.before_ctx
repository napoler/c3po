else { if ( = = 0 ) { if ( ! periodic ) continue ; else = fmy - 1 ; } else = - 1 ; } if ( ! changes [ ] [ ] ) continue ;
else = fmy - 1 ; } else = - 1 ; } if ( ! changes [ ] [ ] ) continue ; <%> <+> bool [ ] = wave [ ] [ ] ; bool [ ] = wave [ ] [ ] ; </%> for ( int = 0 ; < t ; + + ) if ( <%> <-> wave [ ] [ ] </%> [ ] ) { <%> <+> bool [ ] prop = propagator [ d ] [ ] ; </%> b = false ;
for ( int y = ymin ; y < ymax ; y + + ) for ( int x = xmin ; x < xmax ; x + + ) if ( [ x + n * y ] ! = [ x - dx + n * ( y - dy ) ] ) return false ; return true ; } ; <%> <+> for ( int x = 0 ; x < 2 * n - 1 ; x + + ) { propagator [ x ] = new int [ 2 * n - 1 ] [ ] [ ] ; for ( int y = 0 ; y < 2 * n - 1 ; y + + ) { propagator [ x ] [ y ] = new int [ t ] [ ] ; </%> for ( int t = 0 ; t < t ; t + + )
<%> <+> { propagator [ x ] = new int [ 2 * n - 1 ] [ ] [ ] ; for ( int y = 0 ; y < 2 * n - 1 ; y + + ) { propagator [ x ] [ y ] = new int [ t ] [ ] ; </%> for ( int t = 0 ; t < t ; t + + ) <%> <-> { propagator [ t ] = new int [ 2 * n - 1 ] [ ] [ ] ; for ( int x = 0 ; x < 2 * n - 1 ; x + + ) { propagator [ t ] [ x ] = new int [ 2 * n - 1 ] [ ] ; for ( int y = 0 ; y < 2 * n - 1 ; y + + ) </%> { list < int > list = new list < int > ( ) ; for ( int = 0 ; < t ; + + ) if ( agrees ( patterns [ t ] , patterns [ ] , x - n + 1 , y - n + 1 ) ) list . add ( ) ;
propagator [ <%> <*> t -> x </%> ] [ <%> <*> x -> y </%> ] [ <%> <*> y -> t </%> ] = new int [ list . count ] ; for ( int c = 0 ; c < list . count ; c + + ) propagator [ <%> <*> t -> x </%> ] [ <%> <*> x -> y </%> ] [ <%> <*> y -> t </%> ] [ c ] = list [ c ] ; } } } } protected override bool on _ boundary ( int x , int y ) = > ! periodic & & ( x + n > fmx | | y + n > fmy ) ; override protected bool propagate ( ) { bool change = false , b ;
<%> <*> int , , sx , sy ; bool [ ] allowed ; -> int , ; </%> for ( int = 0 ; < fmx ; + + ) for ( int = 0 ; < fmy ; + + ) if ( changes [ ] [ ] ) { changes [ ] [ ] = false ; for ( int dx = - n + 1 ; dx < n ; dx + + ) for ( int dy = - n + 1 ; dy < n ; dy + + ) { = + dx ; <%> <+> if ( < 0 ) + = fmx ; else if ( > = fmx ) - = fmx ; </%> = + dy ;
for ( int dx = - n + 1 ; dx < n ; dx + + ) for ( int dy = - n + 1 ; dy < n ; dy + + ) { = + dx ; <%> <+> if ( < 0 ) + = fmx ; else if ( > = fmx ) - = fmx ; </%> = + dy ; <%> <*> sx = ; if ( sx < 0 ) sx + = fmx ; else if ( sx > = fmx ) sx - = fmx ; sy = ; if ( sy < 0 ) sy + = fmy ; else if ( sy > = fmy ) sy - = fmy ; if ( ! periodic & & ( sx + n > fmx | | sy + n > fmy ) ) continue ; allowed = wave [ sx ] [ sy ] ; -> if ( < 0 ) + = fmy ; </%> <%> <+> else if ( > = fmy ) - = fmy ; if ( ! periodic & & ( + n > fmx | | + n > fmy ) ) continue ; bool [ ] = wave [ ] [ ] ; bool [ ] = wave [ ] [ ] ; int [ ] [ ] p = propagator [ n - 1 - dx ] [ n - 1 - dy ] ; </%> for ( int = 0 ; < t ; + + ) {
= + dx ; <%> <+> if ( < 0 ) + = fmx ; else if ( > = fmx ) - = fmx ; </%> = + dy ; <%> <*> sx = ; if ( sx < 0 ) sx + = fmx ; else if ( sx > = fmx ) sx - = fmx ; sy = ; if ( sy < 0 ) sy + = fmy ; else if ( sy > = fmy ) sy - = fmy ; if ( ! periodic & & ( sx + n > fmx | | sy + n > fmy ) ) continue ; allowed = wave [ sx ] [ sy ] ; -> if ( < 0 ) + = fmy ; </%> <%> <+> else if ( > = fmy ) - = fmy ; if ( ! periodic & & ( + n > fmx | | + n > fmy ) ) continue ; bool [ ] = wave [ ] [ ] ; bool [ ] = wave [ ] [ ] ; int [ ] [ ] p = propagator [ n - 1 - dx ] [ n - 1 - dy ] ; </%> for ( int = 0 ; < t ; + + ) { if ( ! <%> <-> allowed </%> [ ] ) continue ; b = false ;
<%> <*> sx = ; if ( sx < 0 ) sx + = fmx ; else if ( sx > = fmx ) sx - = fmx ; sy = ; if ( sy < 0 ) sy + = fmy ; else if ( sy > = fmy ) sy - = fmy ; if ( ! periodic & & ( sx + n > fmx | | sy + n > fmy ) ) continue ; allowed = wave [ sx ] [ sy ] ; -> if ( < 0 ) + = fmy ; </%> <%> <+> else if ( > = fmy ) - = fmy ; if ( ! periodic & & ( + n > fmx | | + n > fmy ) ) continue ; bool [ ] = wave [ ] [ ] ; bool [ ] = wave [ ] [ ] ; int [ ] [ ] p = propagator [ n - 1 - dx ] [ n - 1 - dy ] ; </%> for ( int = 0 ; < t ; + + ) { if ( ! <%> <-> allowed </%> [ ] ) continue ; b = false ; int [ ] prop = <%> <*> propagator -> p </%> [ ] <%> <*> [ n - 1 - dx ] [ n - 1 - dy ] ; -> ; </%> for ( int = 0 ; < prop . length & & ! b ; + + ) b = <%> <-> wave [ ] [ ] </%> [ prop [ ] ] ; if ( ! b ) {
for ( int = 0 ; < t ; + + ) { if ( ! <%> <-> allowed </%> [ ] ) continue ; b = false ; int [ ] prop = <%> <*> propagator -> p </%> [ ] <%> <*> [ n - 1 - dx ] [ n - 1 - dy ] ; -> ; </%> for ( int = 0 ; < prop . length & & ! b ; + + ) b = <%> <-> wave [ ] [ ] </%> [ prop [ ] ] ; if ( ! b ) { changes [ <%> <-> sx </%> ] [ <%> <-> sy </%> ] = true ; change = true ;

<%> <*> stationary = temp _ stationary . to _ array ( ) ; -> weights = temp _ stationary . to _ array ( ) ; </%> <%> <+> propagator = new int [ NUM ] [ ] [ ] ; </%> var temp _ propagator = new bool [ NUM ] [ ] [ ] ;
<%> <*> stationary = temp _ stationary . to _ array ( ) ; -> weights = temp _ stationary . to _ array ( ) ; </%> <%> <+> propagator = new int [ NUM ] [ ] [ ] ; </%> var temp _ propagator = new bool [ NUM ] [ ] [ ] ; <%> <-> propagator = new int [ NUM ] [ ] [ ] ; </%> for ( int d = 0 ; d < NUM ; d + + ) { temp _ propagator [ d ] = new bool [ t ] [ ] ; propagator [ d ] = new int [ t ] [ ] ; for ( int t = 0 ; t < t ; t + + ) temp _ propagator [ d ] [ t ] = new bool [ t ] ; }

<%> <*> protected double [ ] stationary ; -> protected int [ ] [ ] [ ] propagator ; </%> <%> <+> int [ ] [ ] [ ] compatible ; </%> protected int [ ] observed ;
<%> <*> protected double [ ] stationary ; -> protected int [ ] [ ] [ ] propagator ; </%> <%> <+> int [ ] [ ] [ ] compatible ; </%> protected int [ ] observed ; <%> <*> protected bool [ ] changes ; protected int [ ] stack ; protected int stacksize ; -> tuple < int , int > [ ] stack ; </%> <%> <+> int stacksize ; </%> protected random random ; protected int fmx , fmy , t ; protected bool periodic ;
<%> <*> double [ ] -> double sum _ of _ weights , sum _ of _ weight _ </%> log <%> <+> _ weights , starting </%> _ <%> <*> prob -> entropy </%> ; <%> <*> double -> double [ ] sums _ of _ weights , sums _ of _ weight _ </%> log _ <%> <*> t -> weights , entropies </%> ; protected model ( int width , int height ) { fmx = width ; fmy = height ; <%> <+> } void init ( ) { </%> wave = new bool [ fmx * fmy ] [ ] ;
fmx = width ; fmy = height ; <%> <+> } void init ( ) { </%> wave = new bool [ fmx * fmy ] [ ] ; <%> <*> changes = new bool [ fmx * fmy ] ; stack = new int [ fmx * fmy ] ; -> compatible = new int [ wave . length ] [ ] [ ] ; </%> <%> <+> for ( int i = 0 ; i < wave . length ; i + + ) { wave [ i ] = new bool [ t ] ; compatible [ i ] = new int [ t ] [ ] ; for ( int t = 0 ; t < t ; t + + ) compatible [ i ] [ t ] = new int [ NUM ] ; } weight _ log _ weights = new double [ t ] ; sum _ of _ weights = 0 ; sum _ of _ weight _ log _ weights = 0 ; for ( int t = 0 ; t < t ; t + + ) { weight _ log _ weights [ t ] = weights [ t ] * math . log ( weights [ t ] ) ; sum _ of _ weights + = weights [ t ] ; sum _ of _ weight _ log _ weights + = weight _ log _ weights [ t ] ; } starting _ entropy = math . log ( sum _ of _ weights ) - sum _ of _ weight _ log _ weights / sum _ of _ weights ; sums _ of _ ones = new int [ fmx * fmy ] ; sums _ of _ weights = new double [ fmx * fmy ] ; sums _ of _ weight _ log _ weights = new double [ fmx * fmy ] ; entropies = new double [ fmx * fmy ] ; stack = new tuple < int , int > [ wave . length * t ] ; </%> stacksize = 0 ; }

if ( on _ boundary ( i <%> <+> % fmx , i / fmx </%> ) ) continue ; <%> <*> bool [ ] w -> int amount </%> = <%> <*> wave -> sums _ of _ ones </%> [ i ] ; <%> <*> int -> if ( </%> amount = <%> <+> = </%> 0 <%> <+> ) return false </%> ; double <%> <*> sum -> entropy </%> = <%> <*> 0 -> entropies [ i ] </%> ; <%> <*> for -> if </%> ( <%> <*> int t = 0 ; t -> amount > 1 & & entropy </%> < <%> <*> t ; t + + -> = min </%> ) <%> <-> if ( w [ t ] ) </%> {

<%> <+> } </%> } } if ( argmin = = - 1 ) { observed = new int [ fmx * fmy ] ; for ( int i = 0 ; i < wave . length ; i + + ) for ( int t = 0 ; t < t ; t + + ) if ( wave [ i ] [ t ] ) { observed [ i ] = t ; break ; } return true ; } double [ ] distribution = new double [ t ] ;
} if ( argmin = = - 1 ) { observed = new int [ fmx * fmy ] ; for ( int i = 0 ; i < wave . length ; i + + ) for ( int t = 0 ; t < t ; t + + ) if ( wave [ i ] [ t ] ) { observed [ i ] = t ; break ; } return true ; } double [ ] distribution = new double [ t ] ; for ( int t = 0 ; t < t ; t + + ) distribution [ t ] = wave [ argmin ] [ t ] ? <%> <*> stationary -> weights </%> [ t ] : 0 ; int r = distribution . random ( random . next _ double ( ) ) ;
<%> <+> int = p [ l ] ; int [ ] comp = compat [ ] ; comp [ d ] - - ; if ( comp [ d ] = = 0 ) ban ( , ) ; } } } </%> } public bool run ( int seed , int limit ) {
clear ( ) ; random = new random ( seed ) ; for ( int l = 0 ; l < limit | | limit = = 0 ; l + + ) { bool? result = observe ( ) ; if ( result ! = null ) return ( bool ) result ; propagate ( ) ; } return true ; }
for ( int l = 0 ; l < limit | | limit = = 0 ; l + + ) { bool? result = observe ( ) ; if ( result ! = null ) return ( bool ) result ; propagate ( ) ; } return true ; } protected void <%> <*> change -> ban </%> ( int i <%> <+> , int t </%> ) {
if ( result ! = null ) return ( bool ) result ; propagate ( ) ; } return true ; } protected void <%> <*> change -> ban </%> ( int i <%> <+> , int t </%> ) { <%> <*> if ( changes [ i ] ) return ; stack [ stacksize ] = i ; -> wave [ i ] [ t ] = false ; </%> <%> <+> int [ ] comp = compatible [ i ] [ t ] ; for ( int d = 0 ; d < NUM ; d + + ) comp [ d ] = 0 ; stack [ stacksize ] = new tuple < int , int > ( i , t ) ; </%> stacksize + + ;
<%> <*> if ( changes [ i ] ) return ; stack [ stacksize ] = i ; -> wave [ i ] [ t ] = false ; </%> <%> <+> int [ ] comp = compatible [ i ] [ t ] ; for ( int d = 0 ; d < NUM ; d + + ) comp [ d ] = 0 ; stack [ stacksize ] = new tuple < int , int > ( i , t ) ; </%> stacksize + + ; <%> <*> changes [ i ] = true ; -> double sum = sums _ of _ weights [ i ] ; </%> <%> <+> entropies [ i ] + = sums _ of _ weight _ log _ weights [ i ] / sum - math . log ( sum ) ; sums _ of _ ones [ i ] - = 1 ; sums _ of _ weights [ i ] - = weights [ t ] ; sums _ of _ weight _ log _ weights [ i ] - = weight _ log _ weights [ t ] ; sum = sums _ of _ weights [ i ] ; entropies [ i ] - = sums _ of _ weight _ log _ weights [ i ] / sum - math . log ( sum ) ; </%> } protected virtual void clear ( ) { for ( int i = 0 ; i < wave . length ; i + + ) {
<%> <+> entropies [ i ] + = sums _ of _ weight _ log _ weights [ i ] / sum - math . log ( sum ) ; sums _ of _ ones [ i ] - = 1 ; sums _ of _ weights [ i ] - = weights [ t ] ; sums _ of _ weight _ log _ weights [ i ] - = weight _ log _ weights [ t ] ; sum = sums _ of _ weights [ i ] ; entropies [ i ] - = sums _ of _ weight _ log _ weights [ i ] / sum - math . log ( sum ) ; </%> } protected virtual void clear ( ) { for ( int i = 0 ; i < wave . length ; i + + ) { <%> <*> for ( int t = 0 ; t < t ; t + + ) wave [ i ] [ t ] = true ; changes [ i ] = false ; -> for ( int t = 0 ; t < t ; t + + ) </%> <%> <+> { wave [ i ] [ t ] = true ; for ( int d = 0 ; d < NUM ; d + + ) compatible [ i ] [ t ] [ d ] = propagator [ opposite [ d ] ] [ t ] . length ; } sums _ of _ ones [ i ] = weights . length ; sums _ of _ weights [ i ] = sum _ of _ weights ; sums _ of _ weight _ log _ weights [ i ] = sum _ of _ weight _ log _ weights ; entropies [ i ] = starting _ entropy ; </%> } }
else { weights . add ( ind , 1 ) ; ordering . add ( ind ) ; } } } t = weights . count ; this . ground = ( ground + t ) % t ; patterns = new byte [ t ] [ ] ;
} } t = weights . count ; this . ground = ( ground + t ) % t ; patterns = new byte [ t ] [ ] ; <%> <*> stationary = new double [ t ] ; propagator = new int [ 2 * n - 1 ] [ ] [ ] [ ] ; -> base . weights = new double [ t ] ; </%> int counter = 0 ; foreach ( long w in ordering ) { patterns [ counter ] = pattern _ from _ index ( w ) ;
this . ground = ( ground + t ) % t ; patterns = new byte [ t ] [ ] ; <%> <*> stationary = new double [ t ] ; propagator = new int [ 2 * n - 1 ] [ ] [ ] [ ] ; -> base . weights = new double [ t ] ; </%> int counter = 0 ; foreach ( long w in ordering ) { patterns [ counter ] = pattern _ from _ index ( w ) ; <%> <*> stationary -> base . weights </%> [ counter ] = weights [ w ] ; counter + + ; }
<%> <*> stationary -> base . weights </%> [ counter ] = weights [ w ] ; counter + + ; } <%> <-> for ( int i = 0 ; i < wave . length ; i + + ) wave [ i ] = new bool [ t ] ; </%> bool agrees ( byte [ ] , byte [ ] , int dx , int dy ) { int xmin = dx < 0 ? 0 : dx , xmax = dx < 0 ? dx + n : n , ymin = dy < 0 ? 0 : dy , ymax = dy < 0 ? dy + n : n ; for ( int y = ymin ; y < ymax ; y + + ) for ( int x = xmin ; x < xmax ; x + + ) if ( [ x + n * y ] ! = [ x - dx + n * ( y - dy ) ] ) return false ; return true ; } ;
<%> <-> for ( int i = 0 ; i < wave . length ; i + + ) wave [ i ] = new bool [ t ] ; </%> bool agrees ( byte [ ] , byte [ ] , int dx , int dy ) { int xmin = dx < 0 ? 0 : dx , xmax = dx < 0 ? dx + n : n , ymin = dy < 0 ? 0 : dy , ymax = dy < 0 ? dy + n : n ; for ( int y = ymin ; y < ymax ; y + + ) for ( int x = xmin ; x < xmax ; x + + ) if ( [ x + n * y ] ! = [ x - dx + n * ( y - dy ) ] ) return false ; return true ; } ; <%> <*> for ( int x = 0 ; x < 2 * n - 1 ; x + + ) -> propagator = new int [ NUM ] [ ] [ ] ; </%> <%> <+> for ( int d = 0 ; d < NUM ; d + + ) </%> {
for ( int y = ymin ; y < ymax ; y + + ) for ( int x = xmin ; x < xmax ; x + + ) if ( [ x + n * y ] ! = [ x - dx + n * ( y - dy ) ] ) return false ; return true ; } ; <%> <*> for ( int x = 0 ; x < 2 * n - 1 ; x + + ) -> propagator = new int [ NUM ] [ ] [ ] ; </%> <%> <+> for ( int d = 0 ; d < NUM ; d + + ) </%> { <%> <*> propagator [ x ] = new int [ 2 * n - 1 ] [ ] [ ] ; for ( int y = 0 ; y < 2 * n - 1 ; y + + ) { propagator [ x ] [ y ] = new int [ t ] [ ] ; -> propagator [ d ] = new int [ t ] [ ] ; </%> for ( int t = 0 ; t < t ; t + + ) { list < int > list = new list < int > ( ) ;
<%> <*> propagator [ x ] = new int [ 2 * n - 1 ] [ ] [ ] ; for ( int y = 0 ; y < 2 * n - 1 ; y + + ) { propagator [ x ] [ y ] = new int [ t ] [ ] ; -> propagator [ d ] = new int [ t ] [ ] ; </%> for ( int t = 0 ; t < t ; t + + ) { list < int > list = new list < int > ( ) ; for ( int = 0 ; < t ; + + ) if ( agrees ( patterns [ t ] , patterns [ ] , <%> <*> x - n + 1 -> dx [ d ] </%> , <%> <*> y - n + 1 -> dy [ d ] </%> ) ) list . add ( ) ; propagator <%> <-> [ x ] </%> [ <%> <*> y -> d </%> ] [ t ] = new int [ list . count ] ; for ( int c = 0 ; c < list . count ; c + + ) propagator <%> <-> [ x ] </%> [ <%> <*> y -> d </%> ] [ t ] [ c ] = list [ c ] ; } } }

<%> <+> using system _ xml _ linq ; </%> using system _ component _ model ; <%> <+> using system _ collections _ generic ; </%> static class stuff { public static int random ( this double [ ] a , double r ) { double sum = a . sum ( ) ; if ( sum = = 0 ) {
static class stuff { public static int random ( this double [ ] a , double r ) { double sum = a . sum ( ) ; if ( sum = = 0 ) { for ( int j = 0 ; j < a . <%> <*> count ( ) -> length </%> ; j + + ) a [ j ] = 1 ; sum = a . sum ( ) ; }
{ double sum = a . sum ( ) ; if ( sum = = 0 ) { for ( int j = 0 ; j < a . <%> <*> count ( ) -> length </%> ; j + + ) a [ j ] = 1 ; sum = a . sum ( ) ; } for ( int j = 0 ; j < a . <%> <*> count ( ) -> length </%> ; j + + ) a [ j ] / = sum ; int i = 0 ; double x = 0 ;
i + + ; } return 0 ; } public static long power ( int a , int n ) { long product = 1 ; for ( int i = 0 ; i < n ; i + + ) product * = a ; return product ; }
return 0 ; } public static long power ( int a , int n ) { long product = 1 ; for ( int i = 0 ; i < n ; i + + ) product * = a ; return product ; } public static t get < t > ( this <%> <*> xml -> x </%> _ <%> <*> node node -> element xelem </%> , string attribute , t default _ t = default ( t ) ) {

{ int [ ] [ ] [ ] propagator ; list < color [ ] > tiles ; list < string > tilenames ; int tilesize ; bool black ; public simple _ tiled _ model ( string name , string subset _ name , int width , int height , bool periodic , bool black ) : base ( width , height ) { this . periodic = periodic ; this . black = black ;
bool black ; public simple _ tiled _ model ( string name , string subset _ name , int width , int height , bool periodic , bool black ) : base ( width , height ) { this . periodic = periodic ; this . black = black ; <%> <*> var xdoc = new xml _ document ( ) ; xdoc . load ( $ STR ) ; xml _ node xnode = xdoc . first _ child ; tilesize = xnode . get ( STR , NUM ) ; bool unique = xnode . get ( STR , false ) ; xnode = xnode . first _ child ; -> x _ element xroot = x _ document . load ( $ STR ) . root ; </%> <%> <+> tilesize = xroot . get ( STR , NUM ) ; bool unique = xroot . get ( STR , false ) ; </%> list < string > subset = null ; if ( subset _ name ! = default ( string ) ) {
<%> <*> foreach ( xml -> x </%> _ <%> <*> node -> element </%> xsubset <%> <*> in xnode -> = xroot </%> . <%> <*> next _ sibling -> element ( STR ) </%> . <%> <*> next _ sibling -> elements ( STR ) </%> . <%> <*> child -> first </%> _ <%> <*> nodes ) -> or _ default ( x = > x . get < string > ( STR ) = = subset _ name ) ; </%> if ( xsubset <%> <-> . node _ type ! </%> = <%> <*> xml _ node _ type . comment & & xsubset -> = null ) console </%> . <%> <*> get < string > -> write _ line </%> ( <%> <+> $ </%> STR ) <%> <*> = = subset _ name ) foreach ( xml _ node stile in -> ; else subset = </%> xsubset . <%> <*> child _ nodes -> elements ( STR </%> ) <%> <-> subset </%> . <%> <*> add -> select </%> ( <%> <*> stile -> x = > x </%> . get < string > ( STR ) ) <%> <*> ; -> . to _ list ( ) ; </%> } <%> <*> func < -> color [ ] tile ( </%> func < int , int , color > <%> <*> , color [ ] > tile = f = > -> f ) </%> { color [ ] result = new color [ tilesize * tilesize ] ; for ( int y = 0 ; y < tilesize ; y + + ) for ( int x = 0 ; x < tilesize ; x + + ) result [ x + y * tilesize ] = f ( x , y ) ; return result ; } ;
color [ ] result = new color [ tilesize * tilesize ] ; for ( int y = 0 ; y < tilesize ; y + + ) for ( int x = 0 ; x < tilesize ; x + + ) result [ x + y * tilesize ] = f ( x , y ) ; return result ; } ; <%> <-> func < </%> color [ ] <%> <*> , -> rotate ( </%> color [ ] <%> <-> > rotate = </%> array <%> <+> ) </%> = > tile ( ( x , y ) = > array [ tilesize - 1 - y + x * tilesize ] ) ; tiles = new list < color [ ] > ( ) ; tilenames = new list < string > ( ) ; var temp _ stationary = new list < double > ( ) ; list < int [ ] > action = new list < int [ ] > ( ) ; dictionary < string , int > first _ occurrence = new dictionary < string , int > ( ) ;
for ( int d = 0 ; d < NUM ; d + + ) for ( int = 0 ; < t ; + + ) { list < int > sp = sparse _ propagator [ d ] [ ] ; bool [ ] tp = temp _ propagator [ d ] [ ] ; for ( int = 0 ; < t ; + + ) if ( tp [ ] ) sp . add ( ) ; int st = sp . count ; propagator [ d ] [ ] = new int [ st ] ; for ( int st = 0 ; st < st ; st + + ) propagator [ d ] [ ] [ st ] = sp [ st ] ; } }
<%> <+> protected override void propagate ( ) { </%> <%> <*> protected override bool propagate -> while </%> ( <%> <+> stacksize > 0 </%> ) { <%> <+> int = stack [ stacksize - 1 ] ; changes [ ] = false ; stacksize - - ; bool [ ] = wave [ ] ; </%> <%> <*> bool change -> int </%> = <%> <*> false -> % fmx </%> , <%> <*> b -> = / fmx </%> ; <%> <-> for ( int = 0 ; < fmx ; + + ) for ( int = 0 ; < fmy ; + + ) </%> for ( int d = 0 ; d < NUM ; d + + ) { int = , = ; if ( d = = 0 ) {
{ if ( = = <%> <*> 0 -> fmx - 1 </%> ) { if ( ! periodic ) continue ; else = <%> <*> fmx - 1 -> 0 </%> ; } else = <%> <*> - -> + </%> 1 ; } else if ( d = = 1 ) {
{ if ( = = <%> <*> fmy - 1 -> 0 </%> ) { if ( ! periodic ) continue ; else = <%> <*> 0 -> fmy - 1 </%> ; } else = <%> <*> + -> - </%> 1 ; } else if ( d = = 2 ) {
bool [ ] = wave <%> <-> [ ] </%> [ ] ; <%> <*> bool -> int </%> [ ] <%> <-> = wave </%> [ ] <%> <+> prop = propagator </%> [ <%> <+> d </%> ] ; for ( int = 0 ; < t ; + + ) <%> <+> if ( [ ] ) </%> { <%> <*> if ( ! [ ] ) continue -> bool b = false </%> ; <%> <*> b -> int [ ] p </%> = <%> <*> false -> prop [ ] </%> ; <%> <*> int [ ] prop -> for ( int l = 0 ; l < p . length & & ! b ; l + + ) b </%> = <%> <*> propagator -> [ p </%> [ <%> <*> d -> l </%> ] <%> <-> [ </%> ] ; <%> <-> for ( int = 0 ; < prop . length & & ! b ; + + ) b = [ prop [ ] ] ; </%> if ( ! b ) {
<%> <*> b -> int [ ] p </%> = <%> <*> false -> prop [ ] </%> ; <%> <*> int [ ] prop -> for ( int l = 0 ; l < p . length & & ! b ; l + + ) b </%> = <%> <*> propagator -> [ p </%> [ <%> <*> d -> l </%> ] <%> <-> [ </%> ] ; <%> <-> for ( int = 0 ; < prop . length & & ! b ; + + ) b = [ prop [ ] ] ; </%> if ( ! b ) { <%> <*> changes [ ] [ ] = true ; change = true ; -> change ( ) ; </%> [ ] = false ; } } }
} protected override bool on _ boundary ( <%> <-> int x , </%> int <%> <*> y -> i </%> ) = > false ; public override bitmap graphics ( ) { bitmap result = new bitmap ( fmx * tilesize , fmy * tilesize ) ; int [ ] bitmap _ data = new int [ result . height * result . width ] ; if ( observed ! = null ) { for ( int x = 0 ; x < fmx ; x + + ) for ( int y = 0 ; y < fmy ; y + + ) {

<%> <*> func < -> byte [ ] pattern ( </%> func < int , int , byte > <%> <*> , byte [ ] > pattern = f = > -> f ) </%> { byte [ ] result = new byte [ n * n ] ; for ( int y = 0 ; y < n ; y + + ) for ( int x = 0 ; x < n ; x + + ) result [ x + y * n ] = f ( x , y ) ; return result ; } ;
<%> <*> func < -> long index ( </%> byte [ ] <%> <-> , long > index = </%> p <%> <*> = > -> ) </%> { long result = 0 , power = 1 ; for ( int i = 0 ; i < p . length ; i + + ) { result + = p [ p . length - 1 - i ] * power ; power * = c ; } return result ; } ;
for ( int t = 0 ; t < t ; t + + ) { list < int > list = new list < int > ( ) ; for ( int = 0 ; < t ; + + ) if ( agrees ( patterns [ t ] , patterns [ ] , x - n + 1 , y - n + 1 ) ) list . add ( ) ; propagator [ x ] [ y ] [ t ] = new int [ list . count ] ; for ( int c = 0 ; c < list . count ; c + + ) propagator [ x ] [ y ] [ t ] [ c ] = list [ c ] ; } } } }
protected override bool on _ boundary ( <%> <-> int x , </%> int <%> <*> y -> i </%> ) = > ! periodic & & ( <%> <*> x -> i % fmx </%> + n > fmx | | <%> <*> y -> i / fmx </%> + n > fmy ) ; override protected <%> <*> bool -> void </%> propagate ( ) { <%> <-> bool change = false , b ; int , ; </%> <%> <*> for ( int = 0 ; < fmx ; + + ) for -> while </%> ( <%> <*> int = -> stacksize > </%> 0 <%> <-> ; < fmy ; + + </%> ) <%> <-> if ( changes [ ] [ ] ) </%> { <%> <*> changes -> int = stack </%> [ <%> <*> ] [ -> stacksize - 1 </%> ] <%> <-> = false </%> ; <%> <+> stacksize - - ; changes [ ] = false ; bool [ ] = wave [ ] ; int = % fmx , = / fmx ; </%> for ( int dx = - n + 1 ; dx < n ; dx + + ) for ( int dy = - n + 1 ; dy < n ; dy + + ) {
<%> <-> bool change = false , b ; int , ; </%> <%> <*> for ( int = 0 ; < fmx ; + + ) for -> while </%> ( <%> <*> int = -> stacksize > </%> 0 <%> <-> ; < fmy ; + + </%> ) <%> <-> if ( changes [ ] [ ] ) </%> { <%> <*> changes -> int = stack </%> [ <%> <*> ] [ -> stacksize - 1 </%> ] <%> <-> = false </%> ; <%> <+> stacksize - - ; changes [ ] = false ; bool [ ] = wave [ ] ; int = % fmx , = / fmx ; </%> for ( int dx = - n + 1 ; dx < n ; dx + + ) for ( int dy = - n + 1 ; dy < n ; dy + + ) { <%> <+> int </%> = + dx ; if ( < 0 ) + = fmx ; else if ( > = fmx ) - = fmx ;
<%> <+> stacksize - - ; changes [ ] = false ; bool [ ] = wave [ ] ; int = % fmx , = / fmx ; </%> for ( int dx = - n + 1 ; dx < n ; dx + + ) for ( int dy = - n + 1 ; dy < n ; dy + + ) { <%> <+> int </%> = + dx ; if ( < 0 ) + = fmx ; else if ( > = fmx ) - = fmx ; <%> <+> int </%> = + dy ; if ( < 0 ) + = fmy ; else if ( > = fmy ) - = fmy ; if ( ! periodic & & ( + n > fmx | | + n > fmy ) ) continue ;
bool [ ] = wave <%> <-> [ ] </%> [ ] ; int [ ] [ ] <%> <*> p -> prop </%> = propagator [ n - 1 - dx ] [ n - 1 - dy ] ; for ( int = 0 ; < t ; + + ) <%> <+> if ( [ ] ) </%> { <%> <*> if ( ! [ ] ) continue -> bool b = false </%> ; <%> <*> b -> int [ ] p </%> = <%> <*> false -> prop [ ] </%> ; <%> <*> int [ ] prop -> for ( int l = 0 ; l < p . length & & ! b ; l + + ) b </%> = <%> <+> [ </%> p [ <%> <+> l ] </%> ] ; <%> <-> for ( int = 0 ; < prop . length & & ! b ; + + ) b = [ prop [ ] ] ; </%> if ( ! b ) {
<%> <*> int [ ] prop -> for ( int l = 0 ; l < p . length & & ! b ; l + + ) b </%> = <%> <+> [ </%> p [ <%> <+> l ] </%> ] ; <%> <-> for ( int = 0 ; < prop . length & & ! b ; + + ) b = [ prop [ ] ] ; </%> if ( ! b ) { <%> <*> changes [ ] [ ] = true ; change = true ; -> change ( ) ; </%> [ ] = false ; } } } }
bitmap result = new bitmap ( fmx , fmy ) ; int [ ] bitmap _ data = new int [ result . height * result . width ] ; if ( observed ! = null ) { for ( int y = 0 ; y < fmy ; y + + ) { int dy = y < fmy - n + 1 ? 0 : n - 1 ; for ( int x = 0 ; x < fmx ; x + + ) { int dx = x < fmx - n + 1 ? 0 : n - 1 ;
for ( int x = 0 ; x < fmx ; x + + ) { int dx = x < fmx - n + 1 ? 0 : n - 1 ; color c = colors [ patterns [ observed [ x - dx <%> <*> ] [ -> + ( </%> y - dy <%> <+> ) * fmx </%> ] ] [ dx + dy * n ] ] ; bitmap _ data [ x + y * fmx ] = unchecked ( ( int ) 0 xff | ( c . r < < NUM ) | ( c . g < < NUM ) | c . b ) ; } } } else {
<%> <-> for ( int y = 0 ; y < fmy ; y + + ) </%> for ( int <%> <*> x -> i </%> = 0 ; <%> <*> x -> i </%> < <%> <*> fmx -> wave . length </%> ; <%> <*> x -> i </%> + + ) { int contributors = 0 , r = 0 , g = 0 , b = 0 ; <%> <+> int x = i % fmx , y = i / fmx ; </%> for ( int dy = 0 ; dy < n ; dy + + ) for ( int dx = 0 ; dx < n ; dx + + ) { int sx = x - dx ; if ( sx < 0 ) sx + = fmx ; int sy = y - dy ; if ( sy < 0 ) sy + = fmy ;
<%> <*> if ( on _ boundary ( sx , sy ) ) continue ; for ( int t = 0 ; t < t ; t + + ) if ( wave [ sx ] [ sy ] [ t ] ) -> int s = sx + sy * fmx ; </%> <%> <+> if ( on _ boundary ( s ) ) continue ; for ( int t = 0 ; t < t ; t + + ) if ( wave [ s ] [ t ] ) </%> { contributors + + ; color color = colors [ patterns [ t ] [ dx + dy * n ] ] ; r + = color . r ; g + = color . g ; b + = color . b ; } }
result . unlock _ bits ( bits ) ; return result ; } protected override void clear ( ) { base . clear ( ) ; if ( ground ! = 0 ) { for ( int x = 0 ; x < fmx ; x + + ) {
{ base . clear ( ) ; if ( ground ! = 0 ) { for ( int x = 0 ; x < fmx ; x + + ) { for ( int t = 0 ; t < t ; t + + ) if ( t ! = ground ) wave [ x <%> <*> ] [ -> + ( </%> fmy - 1 <%> <+> ) * fmx </%> ] [ t ] = false ; <%> <*> changes [ -> change ( </%> x <%> <*> ] [ -> + ( </%> fmy - 1 <%> <*> ] = true -> ) * fmx ) </%> ; for ( int y = 0 ; y < fmy - 1 ; y + + ) {

using system _ xml <%> <+> _ linq </%> ; static class program { static void main ( ) { random random = new random ( ) ;
using system _ xml <%> <+> _ linq </%> ; static class program { static void main ( ) { random random = new random ( ) ; <%> <*> var xdoc = new xml _ document ( ) ; xdoc . load ( STR ) ; -> x _ document xdoc = x _ document . load ( STR ) ; </%> int counter = 1 ;
using system _ xml <%> <+> _ linq </%> ; static class program { static void main ( ) { random random = new random ( ) ; <%> <*> var xdoc = new xml _ document ( ) ; xdoc . load ( STR ) ; -> x _ document xdoc = x _ document . load ( STR ) ; </%> int counter = 1 ; foreach ( <%> <*> xml -> x </%> _ <%> <*> node xnode -> element xelem </%> in xdoc . <%> <*> first _ child . child _ nodes -> root . elements ( STR , STR </%> ) <%> <+> ) </%> {
{ static void main ( ) { random random = new random ( ) ; <%> <*> var xdoc = new xml _ document ( ) ; xdoc . load ( STR ) ; -> x _ document xdoc = x _ document . load ( STR ) ; </%> int counter = 1 ; foreach ( <%> <*> xml -> x </%> _ <%> <*> node xnode -> element xelem </%> in xdoc . <%> <*> first _ child . child _ nodes -> root . elements ( STR , STR </%> ) <%> <+> ) </%> { <%> <-> if ( xnode . name = = STR ) continue ; </%> model model ;
{ random random = new random ( ) ; <%> <*> var xdoc = new xml _ document ( ) ; xdoc . load ( STR ) ; -> x _ document xdoc = x _ document . load ( STR ) ; </%> int counter = 1 ; foreach ( <%> <*> xml -> x </%> _ <%> <*> node xnode -> element xelem </%> in xdoc . <%> <*> first _ child . child _ nodes -> root . elements ( STR , STR </%> ) <%> <+> ) </%> { <%> <-> if ( xnode . name = = STR ) continue ; </%> model model ; string name = <%> <*> xnode -> xelem </%> . get < string > ( STR ) ; console . write _ line ( $ STR ) ;
{ <%> <-> if ( xnode . name = = STR ) continue ; </%> model model ; string name = <%> <*> xnode -> xelem </%> . get < string > ( STR ) ; console . write _ line ( $ STR ) ; if ( <%> <*> xnode -> xelem </%> . name = = STR ) model = new overlapping _ model ( name , <%> <*> xnode -> xelem </%> . get ( STR , 2 ) , <%> <*> xnode -> xelem </%> . get ( STR , NUM ) , <%> <*> xnode -> xelem </%> . get ( STR , NUM ) , <%> <*> xnode -> xelem </%> . get ( STR , true ) , <%> <*> xnode -> xelem </%> . get ( STR , false ) , <%> <*> xnode -> xelem </%> . get ( STR , NUM ) , <%> <*> xnode -> xelem </%> . get ( STR , 0 ) ) ; else if ( <%> <*> xnode -> xelem </%> . name = = STR ) model = new simple _ tiled _ model ( name , <%> <*> xnode -> xelem </%> . get < string > ( STR ) , <%> <*> xnode -> xelem </%> . get ( STR , NUM ) , <%> <*> xnode -> xelem </%> . get ( STR , NUM ) , <%> <*> xnode -> xelem </%> . get ( STR , false ) , <%> <*> xnode -> xelem </%> . get ( STR , false ) ) ; else continue ;
<%> <*> xnode -> xelem </%> . get ( STR , true ) , <%> <*> xnode -> xelem </%> . get ( STR , false ) , <%> <*> xnode -> xelem </%> . get ( STR , NUM ) , <%> <*> xnode -> xelem </%> . get ( STR , 0 ) ) ; else if ( <%> <*> xnode -> xelem </%> . name = = STR ) model = new simple _ tiled _ model ( name , <%> <*> xnode -> xelem </%> . get < string > ( STR ) , <%> <*> xnode -> xelem </%> . get ( STR , NUM ) , <%> <*> xnode -> xelem </%> . get ( STR , NUM ) , <%> <*> xnode -> xelem </%> . get ( STR , false ) , <%> <*> xnode -> xelem </%> . get ( STR , false ) ) ; else continue ; for ( int i = 0 ; i < <%> <*> xnode -> xelem </%> . get ( STR , 2 ) ; i + + ) { for ( int k = 0 ; k < NUM ; k + + ) { console . write ( STR ) ; int seed = random . next ( ) ;

<%> <*> protected bool [ ] [ ] [ ] wave ; protected bool [ ] [ ] changes ; -> protected bool [ ] [ ] wave ; </%> protected double [ ] stationary ;
<%> <*> protected bool [ ] [ ] [ ] wave ; protected bool [ ] [ ] changes ; -> protected bool [ ] [ ] wave ; </%> protected double [ ] stationary ; <%> <*> protected int [ ] [ ] observed ; -> protected int [ ] observed ; </%> <%> <+> protected bool [ ] changes ; protected int [ ] stack ; protected int stacksize ; </%> protected random random ;
<%> <+> protected bool [ ] changes ; protected int [ ] stack ; protected int stacksize ; </%> protected random random ; protected int fmx , fmy , t <%> <-> , limit </%> ; protected bool periodic ; double [ ] log _ prob ; double log _ t ; protected model ( int width , int height ) { fmx = width ; fmy = height ;
protected bool periodic ; double [ ] log _ prob ; double log _ t ; protected model ( int width , int height ) { fmx = width ; fmy = height ; <%> <*> wave = new bool [ fmx ] [ ] [ ] ; changes = new bool [ fmx ] [ ] ; for ( int x = 0 ; x < fmx ; x + + ) { wave [ x ] = new bool [ fmy ] [ ] ; changes [ x ] = new bool [ fmy ] ; -> wave = new bool [ fmx * fmy ] [ ] ; </%> <%> <+> changes = new bool [ fmx * fmy ] ; stack = new int [ fmx * fmy ] ; stacksize = 0 ; </%> }
{ fmx = width ; fmy = height ; <%> <*> wave = new bool [ fmx ] [ ] [ ] ; changes = new bool [ fmx ] [ ] ; for ( int x = 0 ; x < fmx ; x + + ) { wave [ x ] = new bool [ fmy ] [ ] ; changes [ x ] = new bool [ fmy ] ; -> wave = new bool [ fmx * fmy ] [ ] ; </%> <%> <+> changes = new bool [ fmx * fmy ] ; stack = new int [ fmx * fmy ] ; stacksize = 0 ; </%> } <%> <*> } protected abstract bool propagate ( ) ; -> protected abstract void propagate ( ) ; </%> bool? observe ( ) { {
for ( int t = 0 ; t < t ; t + + ) if ( w [ t ] ) { amount + = 1 ; sum + = stationary [ t ] ; } if ( sum = = 0 ) return false ; if ( amount = = 1 ) entropy = 0 ; else if ( amount = = t ) entropy = log _ t ; else {
else { <%> <+> double </%> main _ sum = 0 ; <%> <+> double </%> log _ sum = math . log ( sum ) ; for ( int t = 0 ; t < t ; t + + ) if ( w [ t ] ) main _ sum + = stationary [ t ] * log _ prob [ t ] ; entropy = log _ sum - main _ sum / sum ; } if ( entropy > 0 & & entropy + noise < min ) { min = entropy + noise ;
<%> <+> double </%> log _ sum = math . log ( sum ) ; for ( int t = 0 ; t < t ; t + + ) if ( w [ t ] ) main _ sum + = stationary [ t ] * log _ prob [ t ] ; entropy = log _ sum - main _ sum / sum ; } if ( entropy > 0 & & entropy + noise < min ) { min = entropy + noise ; <%> <*> argminx = x ; argminy = y ; -> argmin = i ; </%> } }
entropy = log _ sum - main _ sum / sum ; } if ( entropy > 0 & & entropy + noise < min ) { min = entropy + noise ; <%> <*> argminx = x ; argminy = y ; -> argmin = i ; </%> } } if ( <%> <*> argminx -> argmin </%> = = - 1 <%> <*> & & argminy = = - 1 ) -> ) </%> {
<%> <*> argminx = x ; argminy = y ; -> argmin = i ; </%> } } if ( <%> <*> argminx -> argmin </%> = = - 1 <%> <*> & & argminy = = - 1 ) -> ) </%> { <%> <*> observed = new int [ fmx ] [ ] ; for ( int x = 0 ; x < fmx ; x + + ) { observed [ x ] = new int [ fmy ] ; for ( int y = 0 ; y < fmy ; y + + ) for ( int t = 0 ; t < t ; t + + ) if ( wave [ x ] [ y ] [ t ] ) { observed [ x ] [ y ] = t ; break ; } } -> observed = new int [ fmx * fmy ] ; </%> <%> <+> for ( int i = 0 ; i < wave . length ; i + + ) for ( int t = 0 ; t < t ; t + + ) if ( wave [ i ] [ t ] ) { observed [ i ] = t ; break ; } </%> return true ; } double [ ] distribution = new double [ t ] ;
} if ( <%> <*> argminx -> argmin </%> = = - 1 <%> <*> & & argminy = = - 1 ) -> ) </%> { <%> <*> observed = new int [ fmx ] [ ] ; for ( int x = 0 ; x < fmx ; x + + ) { observed [ x ] = new int [ fmy ] ; for ( int y = 0 ; y < fmy ; y + + ) for ( int t = 0 ; t < t ; t + + ) if ( wave [ x ] [ y ] [ t ] ) { observed [ x ] [ y ] = t ; break ; } } -> observed = new int [ fmx * fmy ] ; </%> <%> <+> for ( int i = 0 ; i < wave . length ; i + + ) for ( int t = 0 ; t < t ; t + + ) if ( wave [ i ] [ t ] ) { observed [ i ] = t ; break ; } </%> return true ; } double [ ] distribution = new double [ t ] ; for ( int t = 0 ; t < t ; t + + ) distribution [ t ] = wave <%> <-> [ argminx ] </%> [ <%> <*> argminy -> argmin </%> ] [ t ] ? stationary [ t ] : 0 ; int r = distribution . random ( random . next _ double ( ) ) ;
{ log _ t = math . log ( t ) ; log _ prob = new double [ t ] ; for ( int t = 0 ; t < t ; t + + ) log _ prob [ t ] = math . log ( stationary [ t ] ) ; clear ( ) ; random = new random ( seed ) ; for ( int l = 0 ; l < limit | | limit = = 0 ; l + + ) { bool? result = observe ( ) ; if ( result ! = null ) return ( bool ) result ;
} <%> <+> protected void change ( int i ) { if ( changes [ i ] ) return ; stack [ stacksize ] = i ; stacksize + + ; changes [ i ] = true ; } </%> protected virtual void clear ( ) {
<%> <+> { if ( changes [ i ] ) return ; stack [ stacksize ] = i ; stacksize + + ; changes [ i ] = true ; } </%> protected virtual void clear ( ) { <%> <-> for ( int x = 0 ; x < fmx ; x + + ) </%> for ( int <%> <*> y -> i </%> = 0 ; <%> <*> y -> i </%> < <%> <*> fmy -> wave . length </%> ; <%> <*> y -> i </%> + + ) {
<%> <+> changes [ i ] = true ; } </%> protected virtual void clear ( ) { <%> <-> for ( int x = 0 ; x < fmx ; x + + ) </%> for ( int <%> <*> y -> i </%> = 0 ; <%> <*> y -> i </%> < <%> <*> fmy -> wave . length </%> ; <%> <*> y -> i </%> + + ) { for ( int t = 0 ; t < t ; t + + ) wave <%> <-> [ x ] </%> [ <%> <*> y -> i </%> ] [ t ] = true ; changes <%> <-> [ x ] </%> [ <%> <*> y -> i </%> ] = false ; } }
ps [ 2 ] = rotate ( ps [ 0 ] ) ; ps [ NUM ] = reflect ( ps [ 2 ] ) ; ps [ NUM ] = rotate ( ps [ 2 ] ) ; ps [ NUM ] = reflect ( ps [ NUM ] ) ; ps [ NUM ] = rotate ( ps [ NUM ] ) ; ps [ NUM ] = reflect ( ps [ NUM ] ) ; for ( int k = 0 ; k < symmetry ; k + + ) { int ind = index ( ps [ k ] ) ; if ( weights . contains _ key ( ind ) ) weights [ ind ] + + ;
<%> <*> else weights . add ( ind , 1 ) ; -> else </%> <%> <+> { weights . add ( ind , 1 ) ; ordering . add ( ind ) ; } </%> } } t = weights . count ; this . ground = ( ground + t ) % t ; patterns = new byte [ t ] [ ] ; stationary = new double [ t ] ; propagator = new int [ t ] [ ] [ ] [ ] ; int counter = 0 ;
<%> <+> if ( ! allowed [ ] ) continue ; </%> b = false ; int [ ] prop = propagator [ ] [ n - 1 - dx ] [ n - 1 - dy ] ; for ( int = 0 ; < prop . length & & ! b ; + + ) b = wave [ ] [ ] [ prop [ ] ] ;

<%> <*> int -> long </%> w = stuff . power ( c , n * n ) ; func < func < int , int , byte > , byte [ ] > pattern = f = > { byte [ ] result = new byte [ n * n ] ; for ( int y = 0 ; y < n ; y + + ) for ( int x = 0 ; x < n ; x + + ) result [ x + y * n ] = f ( x , y ) ; return result ; } ; func < int , int , byte [ ] > pattern _ from _ sample = ( x , y ) = > pattern ( ( dx , dy ) = > sample [ ( x + dx ) % smx , ( y + dy ) % smy ] ) ; func < byte [ ] , byte [ ] > rotate = p = > pattern ( ( x , y ) = > p [ n - 1 - y + x * n ] ) ; func < byte [ ] , byte [ ] > reflect = p = > pattern ( ( x , y ) = > p [ n - 1 - x + y * n ] ) ;
func < byte [ ] , <%> <*> int -> long </%> > index = p = > { <%> <*> int -> long </%> result = 0 , power = 1 ; for ( int i = 0 ; i < p . length ; i + + ) { result + = p [ p . length - 1 - i ] * power ; power * = c ; } return result ; } ;
<%> <+> int [ ] bmp _ data = new int [ result . height * result . width ] ; </%> for ( int y = 0 ; y < fmy ; y + + ) for ( int x = 0 ; x < fmx ; x + + ) {
for ( int y = 0 ; y < fmy ; y + + ) for ( int x = 0 ; x < fmx ; x + + ) { <%> <*> list < byte > -> int </%> contributors <%> <+> _ nb </%> = <%> <*> new list < byte > ( ) ; -> 0 , r = 0 , g = 0 , b = 0 ; </%> for ( int dy = 0 ; dy < n ; dy + + ) for ( int dx = 0 ; dx < n ; dx + + ) { int sx = x - dx ; if ( sx < 0 ) sx + = fmx ; int sy = y - dy ; if ( sy < 0 ) sy + = fmy ; if ( on _ boundary ( sx , sy ) ) continue ;
<%> <+> bool [ ] w ; </%> for ( int x = 0 ; x < fmx ; x + + ) for ( int y = 0 ; y < fmy ; y + + ) { if ( on _ boundary ( x , y ) ) continue ; <%> <+> w = wave [ x ] [ y ] ; </%> amount = 0 ; sum = 0 ;

for ( int t = 0 ; t < t ; t + + ) if ( <%> <*> wave [ x ] [ y ] -> w </%> [ t ] ) main _ sum + = stationary [ t ] * log _ prob [ t ] ; entropy = log _ sum - main _ sum / sum ; } if ( entropy > 0 & & entropy + noise < min ) { min = entropy + noise ; argminx = x ; argminy = y ; } }

public overlapping _ model ( string name , int n , int width , int height , bool periodic _ input , bool periodic _ output , int symmetry , int ground ) <%> <+> : base ( width , height ) </%> { this . n = n ;
allowed [ ] = false ; } } } } return change ; } public override bitmap graphics ( ) { bitmap result = new bitmap ( fmx , fmy ) ;
} } return change ; } public override bitmap graphics ( ) { bitmap result = new bitmap ( fmx , fmy ) ; int [ ] <%> <*> bmp -> bitmap </%> _ data = new int [ result . height * result . width ] ; for ( int y = 0 ; y < fmy ; y + + ) for ( int x = 0 ; x < fmx ; x + + ) {
int contributors <%> <-> _ nb </%> = 0 , r = 0 , g = 0 , b = 0 ; for ( int dy = 0 ; dy < n ; dy + + ) for ( int dx = 0 ; dx < n ; dx + + ) { int sx = x - dx ; if ( sx < 0 ) sx + = fmx ; int sy = y - dy ; if ( sy < 0 ) sy + = fmy ; if ( on _ boundary ( sx , sy ) ) continue ; for ( int t = 0 ; t < t ; t + + ) if ( wave [ sx ] [ sy ] [ t ] ) {
if ( on _ boundary ( sx , sy ) ) continue ; for ( int t = 0 ; t < t ; t + + ) if ( wave [ sx ] [ sy ] [ t ] ) { contributors <%> <-> _ nb </%> + + ; color color = colors [ patterns [ t ] [ dx + dy * n ] ] ; r + = color . r ; g + = color . g ; b + = color . b ; } }
if ( <%> <*> foundation -> ground </%> ! = 0 ) { for ( int x = 0 ; x < fmx ; x + + ) {
if ( <%> <*> foundation -> ground </%> ! = 0 ) { for ( int x = 0 ; x < fmx ; x + + ) { for ( int t = 0 ; t < t ; t + + ) if ( t ! = <%> <*> foundation -> ground </%> ) wave [ x ] [ fmy - 1 ] [ t ] = false ; changes [ x ] [ fmy - 1 ] = true ; for ( int y = 0 ; y < fmy - 1 ; y + + ) {
{ for ( int x = 0 ; x < fmx ; x + + ) { for ( int t = 0 ; t < t ; t + + ) if ( t ! = <%> <*> foundation -> ground </%> ) wave [ x ] [ fmy - 1 ] [ t ] = false ; changes [ x ] [ fmy - 1 ] = true ; for ( int y = 0 ; y < fmy - 1 ; y + + ) { wave [ x ] [ y ] [ <%> <*> foundation -> ground </%> ] = false ; changes [ x ] [ y ] = true ; }
{ bitmap bitmap = new bitmap ( $ STR ) ; tiles . add ( tile ( ( x , y ) = > bitmap . get _ pixel ( x , y ) ) ) ; <%> <+> tilenames . add ( $ STR ) ; </%> } } else { bitmap bitmap = new bitmap ( $ STR ) ; tiles . add ( tile ( ( x , y ) = > bitmap . get _ pixel ( x , y ) ) ) ;

stack [ stacksize ] = <%> <-> new tuple < int , int > </%> ( i , t ) ; stacksize + + ;
stack [ stacksize ] = <%> <-> new tuple < int , int > </%> ( i , t ) ; stacksize + + ; <%> <-> double sum = sums _ of _ weights [ i ] ; entropies [ i ] + = sums _ of _ weight _ log _ weights [ i ] / sum - math . log ( sum ) ; </%> sums _ of _ ones [ i ] - = 1 ; sums _ of _ weights [ i ] - = weights [ t ] ; sums _ of _ weight _ log _ weights [ i ] - = weight _ log _ weights [ t ] ;

for ( int j = 0 ; j < a . length ; j + + ) a [ j ] / = sum ; int i = 0 ; double x = 0 ; while ( i < a . length ) { x + = a [ i ] ; if ( r < = x ) return i ; i + + ; <%> <+> } return 0 ; } public static long power ( int a , int n ) { long product = 1 ; for ( int i = 0 ; i < n ; i + + ) product * = a ; return product ; } public static t get < t > ( this x _ element xelem , string attribute , t default _ t = default ( t ) ) { x _ attribute a = xelem . attribute ( attribute ) ; return a = = null ? default _ t : ( t ) type _ descriptor . get _ converter ( typeof ( t ) ) . convert _ from _ invariant _ string ( a . value ) ; } public static i _ enumerable < x _ element > elements ( this x _ element x , params string [ ] names ) = > x . elements ( ) . where ( xelem = > names . any ( s = > s = = xelem . name ) ) ; </%> }

bool finished = model . run ( seed , xelem . get ( STR , 0 ) ) ; if ( finished ) { console . write _ line ( STR ) ; model . graphics ( ) . save ( $ STR ) ; if ( model is simple _ tiled _ model & & xelem . get ( STR , false ) ) system . io . file . write _ all _ text ( $ STR , ( model as simple _ tiled _ model ) . text _ output ( ) ) ; break ; <%> <+> } else console . write _ line ( STR ) ; } } counter + + ; } console . write _ line ( $ STR ) ; } </%> }

<%> <*> propagator = new bool [ NUM ] [ ] [ ] ; -> var temp _ propagator = new bool [ NUM ] [ ] [ ] ; </%> <%> <+> propagator = new int [ NUM ] [ ] [ ] ; </%> for ( int d = 0 ; d < NUM ; d + + ) {
<%> <+> propagator [ d ] = new int [ t ] [ ] ; for ( int t = 0 ; t < t ; t + + ) temp _ propagator [ d ] [ t ] = new bool [ t ] ; </%> } for ( int x = 0 ; x < fmx ; x + + ) for ( int y = 0 ; y < fmy ; y + + ) wave [ x ] [ y ] = new bool [ t ] ; foreach ( xml _ node xneighbor in xnode . next _ sibling . child _ nodes ) { string [ ] left = xneighbor . get < string > ( STR ) . split ( new char [ ] { ' ' } , string _ split _ options . remove _ empty _ entries ) ; string [ ] right = xneighbor . get < string > ( STR ) . split ( new char [ ] { ' ' } , string _ split _ options . remove _ empty _ entries ) ; if ( subset ! = null & & ( ! subset . contains ( left [ 0 ] ) | | ! subset . contains ( right [ 0 ] ) ) ) continue ; int l = action [ first _ occurrence [ left [ 0 ] ] ] [ left . length = = 1 ? 0 : int . parse ( left [ 1 ] ) ] , d = action [ l ] [ 1 ] ; int r = action [ first _ occurrence [ right [ 0 ] ] ] [ right . length = = 1 ? 0 : int . parse ( right [ 1 ] ) ] , u = action [ r ] [ 1 ] ;
<%> <+> temp _ </%> propagator [ 0 ] [ action [ r ] [ NUM ] ] [ action [ l ] [ NUM ] ] = true ; <%> <+> temp _ </%> propagator [ 0 ] [ action [ l ] [ NUM ] ] [ action [ r ] [ NUM ] ] = true ; <%> <+> temp _ </%> propagator [ 0 ] [ action [ l ] [ 2 ] ] [ action [ r ] [ 2 ] ] = true ; <%> <+> temp _ </%> propagator [ 1 ] [ u ] [ d ] = true ; <%> <+> temp _ </%> propagator [ 1 ] [ action [ d ] [ NUM ] ] [ action [ u ] [ NUM ] ] = true ; <%> <+> temp _ </%> propagator [ 1 ] [ action [ u ] [ NUM ] ] [ action [ d ] [ NUM ] ] = true ; <%> <+> temp _ </%> propagator [ 1 ] [ action [ d ] [ 2 ] ] [ action [ u ] [ 2 ] ] = true ; } for ( int = 0 ; < t ; + + ) for ( int = 0 ; < t ; + + ) {
if ( = = 0 ) { if ( ! periodic ) continue ; else = fmy - 1 ; } else = - 1 ; } if ( ! changes [ ] [ ] ) continue ; bool [ ] = wave [ ] [ ] ; bool [ ] = wave [ ] [ ] ;
} else = - 1 ; } if ( ! changes [ ] [ ] ) continue ; bool [ ] = wave [ ] [ ] ; bool [ ] = wave [ ] [ ] ; for ( int = 0 ; < t ; + + ) <%> <-> if ( [ ] ) </%> { <%> <*> bool [ ] prop = propagator -> if ( ! </%> [ <%> <-> d </%> ] <%> <*> [ ] -> ) continue </%> ; b = false ;
bool [ ] = wave [ ] [ ] ; bool [ ] = wave [ ] [ ] ; for ( int = 0 ; < t ; + + ) <%> <-> if ( [ ] ) </%> { <%> <*> bool [ ] prop = propagator -> if ( ! </%> [ <%> <-> d </%> ] <%> <*> [ ] -> ) continue </%> ; b = false ; <%> <*> for ( int = 0 ; < t & & ! b ; + + ) if ( [ ] ) b = prop [ ] ; -> int [ ] prop = propagator [ d ] [ ] ; </%> <%> <+> for ( int = 0 ; < prop . length & & ! b ; + + ) b = [ prop [ ] ] ; </%> if ( ! b ) {