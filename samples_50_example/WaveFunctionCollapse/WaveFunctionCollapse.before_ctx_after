else\n{\nif (y2 == 0)\n{\nif (!periodic) continue;\nelse y1 = FMY - 1;\n}\nelse y1 = y2 - 1;\n}\nif (!changes[x1][y1]) continue;
else y1 = FMY - 1;\n}\nelse y1 = y2 - 1;\n}\nif (!changes[x1][y1]) continue;\nbool[] w1 = wave[x1][y1];\nbool[] w2 = wave[x2][y2];\nfor (int t2 = 0; t2 < T; t2++) if (w2[t2])\n{\nbool[] prop = propagator[d][t2];\nb = false;
for (int y = ymin; y < ymax; y++) for (int x = xmin; x < xmax; x++) if (p1[x + N * y] != p2[x - dx + N * (y - dy)]) return false;\nreturn true;\n};\nfor (int x = 0; x < 2 * N - 1; x++)\n{\npropagator[x] = new int[2 * N - 1][][];\nfor (int y = 0; y < 2 * N - 1; y++)\n{\npropagator[x][y] = new int[T][];\nfor (int t = 0; t < T; t++)
{\npropagator[x] = new int[2 * N - 1][][];\nfor (int y = 0; y < 2 * N - 1; y++)\n{\npropagator[x][y] = new int[T][];\nfor (int t = 0; t < T; t++)\n{\nList<int> list = new List<int>();\nfor (int t2 = 0; t2 < T; t2++) if (agrees(patterns[t], patterns[t2], x - N + 1, y - N + 1)) list.Add(t2);
propagator[x][y][t] = new int[list.Count];\nfor (int c = 0; c < list.Count; c++) propagator[x][y][t][c] = list[c];\n}\n}\n}\n}\nprotected override bool OnBoundary(int x, int y) => !periodic && (x + N > FMX || y + N > FMY);\noverride protected bool Propagate()\n{\nbool change = false, b;
int x2, y2;\nfor (int x1 = 0; x1 < FMX; x1++) for (int y1 = 0; y1 < FMY; y1++) if (changes[x1][y1])\n{\nchanges[x1][y1] = false;\nfor (int dx = -N + 1; dx < N; dx++) for (int dy = -N + 1; dy < N; dy++)\n{\nx2 = x1 + dx;\nif (x2 < 0) x2 += FMX;\nelse if (x2 >= FMX) x2 -= FMX;\ny2 = y1 + dy;
for (int dx = -N + 1; dx < N; dx++) for (int dy = -N + 1; dy < N; dy++)\n{\nx2 = x1 + dx;\nif (x2 < 0) x2 += FMX;\nelse if (x2 >= FMX) x2 -= FMX;\ny2 = y1 + dy;\nif (y2 < 0) y2 += FMY;\nelse if (y2 >= FMY) y2 -= FMY;\nif (!periodic && (x2 + N > FMX || y2 + N > FMY)) continue;\nbool[] w1 = wave[x1][y1];\nbool[] w2 = wave[x2][y2];\nint[][] p = propagator[N - 1 - dx][N - 1 - dy];\nfor (int t2 = 0; t2 < T; t2++)\n{
x2 = x1 + dx;\nif (x2 < 0) x2 += FMX;\nelse if (x2 >= FMX) x2 -= FMX;\ny2 = y1 + dy;\nif (y2 < 0) y2 += FMY;\nelse if (y2 >= FMY) y2 -= FMY;\nif (!periodic && (x2 + N > FMX || y2 + N > FMY)) continue;\nbool[] w1 = wave[x1][y1];\nbool[] w2 = wave[x2][y2];\nint[][] p = propagator[N - 1 - dx][N - 1 - dy];\nfor (int t2 = 0; t2 < T; t2++)\n{\nif (!w2[t2]) continue;\nb = false;
bool[] w2 = wave[x2][y2];\nint[][] p = propagator[N - 1 - dx][N - 1 - dy];\nfor (int t2 = 0; t2 < T; t2++)\n{\nif (!w2[t2]) continue;\nb = false;\nint[] prop = p[t2];\nfor (int i1 = 0; i1 < prop.Length && !b; i1++) b = w1[prop[i1]];\nif (!b)\n{
for (int t2 = 0; t2 < T; t2++)\n{\nif (!w2[t2]) continue;\nb = false;\nint[] prop = p[t2];\nfor (int i1 = 0; i1 < prop.Length && !b; i1++) b = w1[prop[i1]];\nif (!b)\n{\nchanges[x2][y2] = true;\nchange = true;

weights = tempStationary.ToArray();\npropagator = new int[4][][];\nvar tempPropagator = new bool[4][][];
weights = tempStationary.ToArray();\npropagator = new int[4][][];\nvar tempPropagator = new bool[4][][];\nfor (int d = 0; d < 4; d++)\n{\ntempPropagator[d] = new bool[T][];\npropagator[d] = new int[T][];\nfor (int t = 0; t < T; t++) tempPropagator[d][t] = new bool[T];\n}

protected int[][][] propagator;\nint[][][] compatible;\nprotected int[] observed;
protected int[][][] propagator;\nint[][][] compatible;\nprotected int[] observed;\nTuple<int, int>[] stack;\nint stacksize;\nprotected Random random;\nprotected int FMX, FMY, T;\nprotected bool periodic;
double sumOfWeights, sumOfWeightLogWeights, startingEntropy;\ndouble[] sumsOfWeights, sumsOfWeightLogWeights, entropies;\nprotected Model(int width, int height) \n{\nFMX = width;\nFMY = height;\n}\nvoid Init()\n{\nwave = new bool[FMX * FMY][];
FMX = width;\nFMY = height;\n}\nvoid Init()\n{\nwave = new bool[FMX * FMY][];\nsumOfWeightLogWeights += weightLogWeights[t];\n}\nstartingEntropy = Math.Log(sumOfWeights) - sumOfWeightLogWeights / sumOfWeights;\nsumsOfOnes = new int[FMX * FMY];\nsumsOfWeights = new double[FMX * FMY];\nsumsOfWeightLogWeights = new double[FMX * FMY];\nentropies = new double[FMX * FMY];\nstack = new Tuple<int, int>[wave.Length * T];\nstacksize = 0;\n}

if (OnBoundary(i % FMX, i / FMX)) continue;\nint amount = sumsOfOnes[i];\nif (amount == 0) return false;\ndouble entropy = entropies[i];\nif (amount > 1 && entropy <= min)\n{

}\n}\n}\nif (argmin == -1)\n{\nobserved = new int[FMX * FMY];\nfor (int i = 0; i < wave.Length; i++) for (int t = 0; t < T; t++) if (wave[i][t]) { observed[i] = t; break; }\nreturn true;\n}\ndouble[] distribution = new double[T];
}\nif (argmin == -1)\n{\nobserved = new int[FMX * FMY];\nfor (int i = 0; i < wave.Length; i++) for (int t = 0; t < T; t++) if (wave[i][t]) { observed[i] = t; break; }\nreturn true;\n}\ndouble[] distribution = new double[T];\nfor (int t = 0; t < T; t++) distribution[t] = wave[argmin][t] ? weights[t] : 0;\nint r = distribution.Random(random.NextDouble());
int t2 = p[l];\nint[] comp = compat[t2];\ncomp[d]--;\nif (comp[d] == 0) Ban(i2, t2);\n}\n}\n}\n}\npublic bool Run(int seed, int limit)\n{
Clear();\nrandom = new Random(seed);\nfor (int l = 0; l < limit || limit == 0; l++)\n{\nbool? result = Observe();\nif (result != null) return (bool)result;\nPropagate();\n}\nreturn true;\n}
for (int l = 0; l < limit || limit == 0; l++)\n{\nbool? result = Observe();\nif (result != null) return (bool)result;\nPropagate();\n}\nreturn true;\n}\nprotected void Ban(int i, int t)\n{
if (result != null) return (bool)result;\nPropagate();\n}\nreturn true;\n}\nprotected void Ban(int i, int t)\n{\nwave[i][t] = false;\nint[] comp = compatible[i][t];\nfor (int d = 0; d < 4; d++) comp[d] = 0;\nstack[stacksize] = new Tuple<int, int>(i, t);\nstacksize++;
for (int d = 0; d < 4; d++) comp[d] = 0;\nstack[stacksize] = new Tuple<int, int>(i, t);\nstacksize++;\nsumsOfOnes[i] -= 1;\nsumsOfWeights[i] -= weights[t];\nsumsOfWeightLogWeights[i] -= weightLogWeights[t];\nsum = sumsOfWeights[i];\nentropies[i] -= sumsOfWeightLogWeights[i] / sum - Math.Log(sum);\n}\nprotected virtual void Clear()\n{\nfor (int i = 0; i < wave.Length; i++)\n{
entropies[i] -= sumsOfWeightLogWeights[i] / sum - Math.Log(sum);\n}\nprotected virtual void Clear()\n{\nfor (int i = 0; i < wave.Length; i++)\n{\n{\nwave[i][t] = true;\nfor (int d = 0; d < 4; d++) compatible[i][t][d] = propagator[opposite[d]][t].Length;\n}\nsumsOfOnes[i] = weights.Length;\nsumsOfWeights[i] = sumOfWeights;\nsumsOfWeightLogWeights[i] = sumOfWeightLogWeights;\nentropies[i] = startingEntropy;\n}\n}
else\n{\nweights.Add(ind, 1);\nordering.Add(ind);\n}\n}\n}\nT = weights.Count;\nthis.ground = (ground + T) % T;\npatterns = new byte[T][];
}\n}\nT = weights.Count;\nthis.ground = (ground + T) % T;\npatterns = new byte[T][];\nbase.weights = new double[T];\nint counter = 0;\nforeach (long w in ordering)\n{\npatterns[counter] = patternFromIndex(w);
this.ground = (ground + T) % T;\npatterns = new byte[T][];\nbase.weights = new double[T];\nint counter = 0;\nforeach (long w in ordering)\n{\npatterns[counter] = patternFromIndex(w);\nbase.weights[counter] = weights[w];\ncounter++;\n}
base.weights[counter] = weights[w];\ncounter++;\n}\nbool agrees(byte[] p1, byte[] p2, int dx, int dy)\n{\nint xmin = dx < 0 ? 0 : dx, xmax = dx < 0 ? dx + N : N, ymin = dy < 0 ? 0 : dy, ymax = dy < 0 ? dy + N : N;\nfor (int y = ymin; y < ymax; y++) for (int x = xmin; x < xmax; x++) if (p1[x + N * y] != p2[x - dx + N * (y - dy)]) return false;\nreturn true;\n};
bool agrees(byte[] p1, byte[] p2, int dx, int dy)\n{\nint xmin = dx < 0 ? 0 : dx, xmax = dx < 0 ? dx + N : N, ymin = dy < 0 ? 0 : dy, ymax = dy < 0 ? dy + N : N;\nfor (int y = ymin; y < ymax; y++) for (int x = xmin; x < xmax; x++) if (p1[x + N * y] != p2[x - dx + N * (y - dy)]) return false;\nreturn true;\n};\npropagator = new int[4][][];\nfor (int d = 0; d < 4; d++)\n{
for (int y = ymin; y < ymax; y++) for (int x = xmin; x < xmax; x++) if (p1[x + N * y] != p2[x - dx + N * (y - dy)]) return false;\nreturn true;\n};\npropagator = new int[4][][];\nfor (int d = 0; d < 4; d++)\n{\npropagator[d] = new int[T][];\nfor (int t = 0; t < T; t++)\n{\nList<int> list = new List<int>();
propagator[d] = new int[T][];\nfor (int t = 0; t < T; t++)\n{\nList<int> list = new List<int>();\nfor (int t2 = 0; t2 < T; t2++) if (agrees(patterns[t], patterns[t2], DX[d], DY[d])) list.Add(t2);\npropagator[d][t] = new int[list.Count];\nfor (int c = 0; c < list.Count; c++) propagator[d][t][c] = list[c];\n}\n}\n}

using System.Xml.Linq;\nusing System.ComponentModel;\nusing System.Collections.Generic;\nstatic class Stuff\n{\npublic static int Random(this double[] a, double r)\n{\ndouble sum = a.Sum();\nif (sum == 0)\n{
static class Stuff\n{\npublic static int Random(this double[] a, double r)\n{\ndouble sum = a.Sum();\nif (sum == 0)\n{\nfor (int j = 0; j < a.Length; j++) a[j] = 1;\nsum = a.Sum();\n}
{\ndouble sum = a.Sum();\nif (sum == 0)\n{\nfor (int j = 0; j < a.Length; j++) a[j] = 1;\nsum = a.Sum();\n}\nfor (int j = 0; j < a.Length; j++) a[j] /= sum;\nint i = 0;\ndouble x = 0;
i++;\n}\nreturn 0;\n}\npublic static long Power(int a, int n)\n{\nlong product = 1;\nfor (int i = 0; i < n; i++) product *= a;\nreturn product;\n}
return 0;\n}\npublic static long Power(int a, int n)\n{\nlong product = 1;\nfor (int i = 0; i < n; i++) product *= a;\nreturn product;\n}\npublic static T Get<T>(this XElement xelem, string attribute, T defaultT = default(T))\n{

{\nint[][][] propagator;\nList<Color[]> tiles;\nList<string> tilenames;\nint tilesize;\nbool black;\npublic SimpleTiledModel(string name, string subsetName, int width, int height, bool periodic, bool black) : base(width, height)\n{\nthis.periodic = periodic;\nthis.black = black;
bool black;\npublic SimpleTiledModel(string name, string subsetName, int width, int height, bool periodic, bool black) : base(width, height)\n{\nthis.periodic = periodic;\nthis.black = black;\nXElement xroot = XDocument.Load($"samples/{name}/data.xml").Root;\ntilesize = xroot.Get("size", 16);\nbool unique = xroot.Get("unique", false);\nList<string> subset = null;\nif (subsetName != default(string))\n{
XElement xsubset = xroot.Element("subsets").Elements("subset").FirstOrDefault(x => x.Get<string>("name") == subsetName);\nif (xsubset == null) Console.WriteLine($"ERROR: subset {subsetName} is not found");\nelse subset = xsubset.Elements("tile").Select(x => x.Get<string>("name")).ToList();\n}\nColor[] tile (Func<int, int, Color> f)\n{\nColor[] result = new Color[tilesize * tilesize];\nfor (int y = 0; y < tilesize; y++) for (int x = 0; x < tilesize; x++) result[x + y * tilesize] = f(x, y);\nreturn result;\n};
Color[] result = new Color[tilesize * tilesize];\nfor (int y = 0; y < tilesize; y++) for (int x = 0; x < tilesize; x++) result[x + y * tilesize] = f(x, y);\nreturn result;\n};\nColor[] rotate(Color[] array) => tile((x, y) => array[tilesize - 1 - y + x * tilesize]);\ntiles = new List<Color[]>();\ntilenames = new List<string>();\nvar tempStationary = new List<double>();\nList<int[]> action = new List<int[]>();\nDictionary<string, int> firstOccurrence = new Dictionary<string, int>();
for (int d = 0; d < 4; d++) for (int t1 = 0; t1 < T; t1++)\n{\nList<int> sp = sparsePropagator[d][t1];\nbool[] tp = tempPropagator[d][t1];\nfor (int t2 = 0; t2 < T; t2++) if (tp[t2]) sp.Add(t2);\nint ST = sp.Count;\npropagator[d][t1] = new int[ST];\nfor (int st = 0; st < ST; st++) propagator[d][t1][st] = sp[st];\n}\n}
int i1 = stack[stacksize - 1];\nchanges[i1] = false;\nstacksize--;\nbool[] w1 = wave[i1];\nint x1 = i1 % FMX, y1 = i1 / FMX;\nfor (int d = 0; d < 4; d++)\n{\nint x2 = x1, y2 = y1;\nif (d == 0)\n{
{\nif (x1 == FMX - 1)\n{\nif (!periodic) continue;\nelse x2 = 0;\n}\nelse x2 = x1 + 1;\n}\nelse if (d == 1)\n{
{\nif (y1 == 0)\n{\nif (!periodic) continue;\nelse y2 = FMY - 1;\n}\nelse y2 = y1 - 1;\n}\nelse if (d == 2)\n{
int i2 = x2 + y2 * FMX;\nbool[] w2 = wave[i2];\nint[][] prop = propagator[d];\nfor (int t2 = 0; t2 < T; t2++) if (w2[t2])\n{\nbool b = false;\nint[] p = prop[t2];\nfor (int l = 0; l < p.Length && !b; l++) b = w1[p[l]];\nif (!b)\n{
bool b = false;\nint[] p = prop[t2];\nfor (int l = 0; l < p.Length && !b; l++) b = w1[p[l]];\nif (!b)\n{\nChange(i2);\nw2[t2] = false;\n}\n}\n}
}\nprotected override bool OnBoundary(int i) => false;\npublic override Bitmap Graphics()\n{\nBitmap result = new Bitmap(FMX * tilesize, FMY * tilesize);\nint[] bitmapData = new int[result.Height * result.Width];\nif (observed != null)\n{\nfor (int x = 0; x < FMX; x++) for (int y = 0; y < FMY; y++)\n{

byte[] pattern (Func<int, int, byte> f)\n{\nbyte[] result = new byte[N * N];\nfor (int y = 0; y < N; y++) for (int x = 0; x < N; x++) result[x + y * N] = f(x, y);\nreturn result;\n};
long index(byte[] p)\n{\nlong result = 0, power = 1;\nfor (int i = 0; i < p.Length; i++)\n{\nresult += p[p.Length - 1 - i] * power;\npower *= C;\n}\nreturn result;\n};
for (int t = 0; t < T; t++)\n{\nList<int> list = new List<int>();\nfor (int t2 = 0; t2 < T; t2++) if (agrees(patterns[t], patterns[t2], x - N + 1, y - N + 1)) list.Add(t2);\npropagator[x][y][t] = new int[list.Count];\nfor (int c = 0; c < list.Count; c++) propagator[x][y][t][c] = list[c];\n}\n}\n}\n}
{\nwhile (stacksize > 0)\n{\nint i1 = stack[stacksize - 1];\nstacksize--;\nchanges[i1] = false;\nbool[] w1 = wave[i1];\nint x1 = i1 % FMX, y1 = i1 / FMX;\nfor (int dx = -N + 1; dx < N; dx++) for (int dy = -N + 1; dy < N; dy++)\n{
int i1 = stack[stacksize - 1];\nstacksize--;\nchanges[i1] = false;\nbool[] w1 = wave[i1];\nint x1 = i1 % FMX, y1 = i1 / FMX;\nfor (int dx = -N + 1; dx < N; dx++) for (int dy = -N + 1; dy < N; dy++)\n{\nint x2 = x1 + dx;\nif (x2 < 0) x2 += FMX;\nelse if (x2 >= FMX) x2 -= FMX;
int x1 = i1 % FMX, y1 = i1 / FMX;\nfor (int dx = -N + 1; dx < N; dx++) for (int dy = -N + 1; dy < N; dy++)\n{\nint x2 = x1 + dx;\nif (x2 < 0) x2 += FMX;\nelse if (x2 >= FMX) x2 -= FMX;\nint y2 = y1 + dy;\nif (y2 < 0) y2 += FMY;\nelse if (y2 >= FMY) y2 -= FMY;\nif (!periodic && (x2 + N > FMX || y2 + N > FMY)) continue;
int i2 = x2 + y2 * FMX;\nbool[] w2 = wave[i2];\nint[][] prop = propagator[N - 1 - dx][N - 1 - dy];\nfor (int t2 = 0; t2 < T; t2++) if (w2[t2])\n{\nbool b = false;\nint[] p = prop[t2];\nfor (int l = 0; l < p.Length && !b; l++) b = w1[p[l]];\nif (!b)\n{
int[] p = prop[t2];\nfor (int l = 0; l < p.Length && !b; l++) b = w1[p[l]];\nif (!b)\n{\nChange(i2);\nw2[t2] = false;\n}\n}\n}\n}
Bitmap result = new Bitmap(FMX, FMY);\nint[] bitmapData = new int[result.Height * result.Width];\nif (observed != null)\n{\nfor (int y = 0; y < FMY; y++)\n{\nint dy = y < FMY - N + 1 ? 0 : N - 1;\nfor (int x = 0; x < FMX; x++)\n{\nint dx = x < FMX - N + 1 ? 0 : N - 1;
for (int x = 0; x < FMX; x++)\n{\nint dx = x < FMX - N + 1 ? 0 : N - 1;\nColor c = colors[patterns[observed[x - dx + (y - dy) * FMX]][dx + dy * N]];\nbitmapData[x + y * FMX] = unchecked((int)0xff000000 | (c.R << 16) | (c.G << 8) | c.B);\n}\n}\n}\nelse\n{
for (int i = 0; i < wave.Length; i++)\n{\nint contributors = 0, r = 0, g = 0, b = 0;\nint x = i % FMX, y = i / FMX;\nfor (int dy = 0; dy < N; dy++) for (int dx = 0; dx < N; dx++)\n{\nint sx = x - dx;\nif (sx < 0) sx += FMX;\nint sy = y - dy;\nif (sy < 0) sy += FMY;
if (OnBoundary(s)) continue;\nfor (int t = 0; t < T; t++) if (wave[s][t])\n{\ncontributors++;\nColor color = colors[patterns[t][dx + dy * N]];\nr += color.R;\ng += color.G;\nb += color.B;\n}\n}
        result.UnlockBits(bits);\nreturn result;\n}\nprotected override void Clear()\n{\nbase.Clear();\nif (ground != 0)\n{\nfor (int x = 0; x < FMX; x++)\n{
{\nbase.Clear();\nif (ground != 0)\n{\nfor (int x = 0; x < FMX; x++)\n{\nfor (int t = 0; t < T; t++) if (t != ground) wave[x + (FMY - 1) * FMX][t] = false;\nChange(x + (FMY - 1) * FMX);\nfor (int y = 0; y < FMY - 1; y++)\n{

using System.Xml.Linq;\nstatic class Program\n{\nstatic void Main()\n{\nRandom random = new Random();
using System.Xml.Linq;\nstatic class Program\n{\nstatic void Main()\n{\nRandom random = new Random();\nXDocument xdoc = XDocument.Load("samples.xml");\nint counter = 1;
using System.Xml.Linq;\nstatic class Program\n{\nstatic void Main()\n{\nRandom random = new Random();\nXDocument xdoc = XDocument.Load("samples.xml");\nint counter = 1;\nforeach (XElement xelem in xdoc.Root.Elements("overlapping", "simpletiled"))\n{
{\nstatic void Main()\n{\nRandom random = new Random();\nXDocument xdoc = XDocument.Load("samples.xml");\nint counter = 1;\nforeach (XElement xelem in xdoc.Root.Elements("overlapping", "simpletiled"))\n{\nModel model;
{\nRandom random = new Random();\nXDocument xdoc = XDocument.Load("samples.xml");\nint counter = 1;\nforeach (XElement xelem in xdoc.Root.Elements("overlapping", "simpletiled"))\n{\nModel model;\nstring name = xelem.Get<string>("name");\nConsole.WriteLine($"< {name}");
{\nModel model;\nstring name = xelem.Get<string>("name");\nConsole.WriteLine($"< {name}");\nif (xelem.Name == "overlapping") model = new OverlappingModel(name, xelem.Get("N", 2), xelem.Get("width", 48), xelem.Get("height", 48), \nxelem.Get("periodicInput", true), xelem.Get("periodic", false), xelem.Get("symmetry", 8), xelem.Get("ground", 0));\nelse if (xelem.Name == "simpletiled") model = new SimpleTiledModel(name, xelem.Get<string>("subset"), \nxelem.Get("width", 10), xelem.Get("height", 10), xelem.Get("periodic", false), xelem.Get("black", false));\nelse continue;
xelem.Get("periodicInput", true), xelem.Get("periodic", false), xelem.Get("symmetry", 8), xelem.Get("ground", 0));\nelse if (xelem.Name == "simpletiled") model = new SimpleTiledModel(name, xelem.Get<string>("subset"), \nxelem.Get("width", 10), xelem.Get("height", 10), xelem.Get("periodic", false), xelem.Get("black", false));\nelse continue;\nfor (int i = 0; i < xelem.Get("screenshots", 2); i++)\n{\nfor (int k = 0; k < 10; k++)\n{\nConsole.Write("> ");\nint seed = random.Next();

protected bool[][] wave;\nprotected double[] stationary;
protected bool[][] wave;\nprotected double[] stationary;\nprotected int[] observed;\nprotected bool[] changes;\nprotected int[] stack;\nprotected int stacksize;\nprotected Random random;
protected int stacksize;\nprotected Random random;\nprotected int FMX, FMY, T;\nprotected bool periodic;\ndouble[] logProb;\ndouble logT;\nprotected Model(int width, int height)\n{\nFMX = width;\nFMY = height;
protected bool periodic;\ndouble[] logProb;\ndouble logT;\nprotected Model(int width, int height)\n{\nFMX = width;\nFMY = height;\nwave = new bool[FMX * FMY][];\nchanges = new bool[FMX * FMY];\nstack = new int[FMX * FMY];\nstacksize = 0;\n}
{\nFMX = width;\nFMY = height;\nwave = new bool[FMX * FMY][];\nchanges = new bool[FMX * FMY];\nstack = new int[FMX * FMY];\nstacksize = 0;\n}\nprotected abstract void Propagate();\nbool? Observe()\n{
for (int t = 0; t < T; t++) if (w[t])\n{\namount += 1;\nsum += stationary[t];\n}\nif (sum == 0) return false;
}\nif (sum == 0) return false;\ndouble mainSum = 0;\ndouble logSum = Math.Log(sum);\nfor (int t = 0; t < T; t++) if (w[t]) mainSum += stationary[t] * logProb[t];\nentropy = logSum - mainSum / sum;\n}\nif (entropy > 0 && entropy + noise < min)\n{\nmin = entropy + noise;
double logSum = Math.Log(sum);\nfor (int t = 0; t < T; t++) if (w[t]) mainSum += stationary[t] * logProb[t];\nentropy = logSum - mainSum / sum;\n}\nif (entropy > 0 && entropy + noise < min)\n{\nmin = entropy + noise;\nargmin = i;\n}\n}
entropy = logSum - mainSum / sum;\n}\nif (entropy > 0 && entropy + noise < min)\n{\nmin = entropy + noise;\nargmin = i;\n}\n}\nif (argmin == -1)\n{
argmin = i;\n}\n}\nif (argmin == -1)\n{\nobserved = new int[FMX * FMY];\nfor (int i = 0; i < wave.Length; i++) for (int t = 0; t < T; t++) if (wave[i][t]) { observed[i] = t; break; }\nreturn true;\n}\ndouble[] distribution = new double[T];
}\nif (argmin == -1)\n{\nobserved = new int[FMX * FMY];\nfor (int i = 0; i < wave.Length; i++) for (int t = 0; t < T; t++) if (wave[i][t]) { observed[i] = t; break; }\nreturn true;\n}\ndouble[] distribution = new double[T];\nfor (int t = 0; t < T; t++) distribution[t] = wave[argmin][t] ? stationary[t] : 0;\nint r = distribution.Random(random.NextDouble());
{\nlogT = Math.Log(T);\nlogProb = new double[T];\nfor (int t = 0; t < T; t++) logProb[t] = Math.Log(stationary[t]);\nClear();\nrandom = new Random(seed);\nfor (int l = 0; l < limit || limit == 0; l++)\n{\nbool? result = Observe();\nif (result != null) return (bool)result;
}\nprotected void Change(int i)\n{\nif (changes[i]) return;\nstack[stacksize] = i;\nstacksize++;\nchanges[i] = true;\n}\nprotected virtual void Clear()\n{
{\nif (changes[i]) return;\nstack[stacksize] = i;\nstacksize++;\nchanges[i] = true;\n}\nprotected virtual void Clear()\n{\nfor (int i = 0; i < wave.Length; i++)\n{
changes[i] = true;\n}\nprotected virtual void Clear()\n{\nfor (int i = 0; i < wave.Length; i++)\n{\nfor (int t = 0; t < T; t++) wave[i][t] = true;\nchanges[i] = false;\n}\n}
ps[2] = rotate(ps[0]);\nps[3] = reflect(ps[2]);\nps[4] = rotate(ps[2]);\nps[5] = reflect(ps[4]);\nps[6] = rotate(ps[4]);\nps[7] = reflect(ps[6]);\nfor (int k = 0; k < symmetry; k++)\n{\nint ind = index(ps[k]);\nif (weights.ContainsKey(ind)) weights[ind]++;
ordering.Add(ind);\n}\n}\n}\nT = weights.Count;\nthis.ground = (ground + T) % T;\npatterns = new byte[T][];\nstationary = new double[T];\npropagator = new int[T][][][];\nint counter = 0;
if (!allowed[t2]) continue;\nb = false;\nint[] prop = propagator[t2][N - 1 - dx][N - 1 - dy];\nfor (int i1 = 0; i1 < prop.Length && !b; i1++) b = wave[x1][y1][prop[i1]];

long W = Stuff.Power(C, N * N);\nFunc<Func<int, int, byte>, byte[]> pattern = f =>\n{\nbyte[] result = new byte[N * N];\nfor (int y = 0; y < N; y++) for (int x = 0; x < N; x++) result[x + y * N] = f(x, y);\nreturn result;\n};\nFunc<int, int, byte[]> patternFromSample = (x, y) => pattern((dx, dy) => sample[(x + dx) % SMX, (y + dy) % SMY]);\nFunc<byte[], byte[]> rotate = p => pattern((x, y) => p[N - 1 - y + x * N]);\nFunc<byte[], byte[]> reflect = p => pattern((x, y) => p[N - 1 - x + y * N]);
Func<byte[], long> index = p =>\n{\nlong result = 0, power = 1;\nfor (int i = 0; i < p.Length; i++)\n{\nresult += p[p.Length - 1 - i] * power;\npower *= C;\n}\nreturn result;\n};
int[] bmpData = new int[result.Height * result.Width];\nfor (int y = 0; y < FMY; y++) for (int x = 0; x < FMX; x++)\n{
for (int y = 0; y < FMY; y++) for (int x = 0; x < FMX; x++)\n{\nint contributorsNb = 0, r = 0, g = 0, b = 0;\nfor (int dy = 0; dy < N; dy++) for (int dx = 0; dx < N; dx++)\n{\nint sx = x - dx;\nif (sx < 0) sx += FMX;\nint sy = y - dy;\nif (sy < 0) sy += FMY;\nif (OnBoundary(sx, sy)) continue;
bool[] w;\nfor (int x = 0; x < FMX; x++) for (int y = 0; y < FMY; y++)\n{\nif (OnBoundary(x, y)) continue;\nw = wave[x][y];\namount = 0;\nsum = 0;

for (int t = 0; t < T; t++) if (w[t]) mainSum += stationary[t] * logProb[t];\nentropy = logSum - mainSum / sum;\n}\nif (entropy > 0 && entropy + noise < min)\n{\nmin = entropy + noise;\nargminx = x;\nargminy = y;\n}\n}

public OverlappingModel(string name, int N, int width, int height, bool periodicInput, bool periodicOutput, int symmetry, int ground) \n: base(width, height)\n{\nthis.N = N;
allowed[t2] = false;\n}\n}\n}\n}\nreturn change;\n}\npublic override Bitmap Graphics()\n{\nBitmap result = new Bitmap(FMX, FMY);
}\n}\nreturn change;\n}\npublic override Bitmap Graphics()\n{\nBitmap result = new Bitmap(FMX, FMY);\nint[] bitmapData = new int[result.Height * result.Width];\nfor (int y = 0; y < FMY; y++) for (int x = 0; x < FMX; x++)\n{
int contributors = 0, r = 0, g = 0, b = 0;\nfor (int dy = 0; dy < N; dy++) for (int dx = 0; dx < N; dx++)\n{\nint sx = x - dx;\nif (sx < 0) sx += FMX;\nint sy = y - dy;\nif (sy < 0) sy += FMY;\nif (OnBoundary(sx, sy)) continue;\nfor (int t = 0; t < T; t++) if (wave[sx][sy][t])\n{
if (OnBoundary(sx, sy)) continue;\nfor (int t = 0; t < T; t++) if (wave[sx][sy][t])\n{\ncontributors++;\nColor color = colors[patterns[t][dx + dy * N]];\nr += color.R;\ng += color.G;\nb += color.B;\n}\n}
if (ground != 0)\n{\nfor (int x = 0; x < FMX; x++)\n{
if (ground != 0)\n{\nfor (int x = 0; x < FMX; x++)\n{\nfor (int t = 0; t < T; t++) if (t != ground) wave[x][FMY - 1][t] = false;\nchanges[x][FMY - 1] = true;\nfor (int y = 0; y < FMY - 1; y++)\n{
{\nfor (int x = 0; x < FMX; x++)\n{\nfor (int t = 0; t < T; t++) if (t != ground) wave[x][FMY - 1][t] = false;\nchanges[x][FMY - 1] = true;\nfor (int y = 0; y < FMY - 1; y++)\n{\nwave[x][y][ground] = false;\nchanges[x][y] = true;\n}
{\nBitmap bitmap = new Bitmap($"samples/{name}/{tilename} {t}.png");\ntiles.Add(tile((x, y) => bitmap.GetPixel(x, y)));\ntilenames.Add($"{tilename} {t}");\n}\n}\nelse\n{\nBitmap bitmap = new Bitmap($"samples/{name}/{tilename}.png");\ntiles.Add(tile((x, y) => bitmap.GetPixel(x, y)));

stack[stacksize] = (i, t);\nstacksize++;
stack[stacksize] = (i, t);\nstacksize++;\nsumsOfOnes[i] -= 1;\nsumsOfWeights[i] -= weights[t];\nsumsOfWeightLogWeights[i] -= weightLogWeights[t];

        for (int i = 0; i < n; i++) product *= a;\n        return product;\n    }\n    public static T Get<T>(this XElement xelem, string attribute, T defaultT = default(T))\n    {\n        XAttribute a = xelem.Attribute(attribute);\n        return a == null ? defaultT : (T)TypeDescriptor.GetConverter(typeof(T)).ConvertFromInvariantString(a.Value);\n    }\n    public static IEnumerable<XElement> Elements(this XElement x, params string[] names) => x.Elements().Where(xelem => names.Any(s => s == xelem.Name));\n}

                        break;\n                    }\n                    else Console.WriteLine("CONTRADICTION");\n                }\n            }\n            counter++;\n        }\n        Console.WriteLine($"time = {sw.ElapsedMilliseconds}");\n    }\n}

var tempPropagator = new bool[4][][];\npropagator = new int[4][][];\nfor (int d = 0; d < 4; d++)\n{
for (int t = 0; t < T; t++) tempPropagator[d][t] = new bool[T];\n}\nfor (int x = 0; x < FMX; x++) for (int y = 0; y < FMY; y++) wave[x][y] = new bool[T];\nforeach (XmlNode xneighbor in xnode.NextSibling.ChildNodes)\n{\nstring[] left = xneighbor.Get<string>("left").Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);\nstring[] right = xneighbor.Get<string>("right").Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);\nif (subset != null && (!subset.Contains(left[0]) || !subset.Contains(right[0]))) continue;\nint L = action[firstOccurrence[left[0]]][left.Length == 1 ? 0 : int.Parse(left[1])], D = action[L][1];\nint R = action[firstOccurrence[right[0]]][right.Length == 1 ? 0 : int.Parse(right[1])], U = action[R][1];
tempPropagator[0][action[R][6]][action[L][6]] = true;\ntempPropagator[0][action[L][4]][action[R][4]] = true;\ntempPropagator[0][action[L][2]][action[R][2]] = true;\ntempPropagator[1][U][D] = true;\ntempPropagator[1][action[D][6]][action[U][6]] = true;\ntempPropagator[1][action[U][4]][action[D][4]] = true;\ntempPropagator[1][action[D][2]][action[U][2]] = true;\n}\nfor (int t2 = 0; t2 < T; t2++) for (int t1 = 0; t1 < T; t1++)\n{
if (y2 == 0)\n{\nif (!periodic) continue;\nelse y1 = FMY - 1;\n}\nelse y1 = y2 - 1;\n}\nif (!changes[x1][y1]) continue;\nbool[] w1 = wave[x1][y1];\nbool[] w2 = wave[x2][y2];
}\nelse y1 = y2 - 1;\n}\nif (!changes[x1][y1]) continue;\nbool[] w1 = wave[x1][y1];\nbool[] w2 = wave[x2][y2];\nfor (int t2 = 0; t2 < T; t2++)\n{\nif (!w2[t2]) continue;\nb = false;
bool[] w1 = wave[x1][y1];\nbool[] w2 = wave[x2][y2];\nfor (int t2 = 0; t2 < T; t2++)\n{\nif (!w2[t2]) continue;\nb = false;\nint[] prop = propagator[d][t2];\nfor (int i1 = 0; i1 < prop.Length && !b; i1++) b = w1[prop[i1]];\nif (!b)\n{