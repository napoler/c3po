public void configure ( i _ application _ builder app , i _ logger _ factory logger _ factory , i _ hosting _ environment env )
public void configure ( i _ application _ builder app , i _ logger _ factory logger _ factory , i _ hosting _ environment env )
public void configure ( i _ application _ builder app , i _ logger _ factory logger _ factory , i _ hosting _ environment env )
public void configure ( i _ application _ builder app , i _ logger _ factory logger _ factory , i _ hosting _ environment env )
public void configure ( i _ application _ builder app , i _ logger _ factory logger _ factory , i _ hosting _ environment env )
public void configure ( i _ application _ builder app , i _ logger _ factory logger _ factory , i _ hosting _ environment env )
public override async task < t > invoke < t > ( node _ invocation _ info invocation _ info ) { await ensure _ ready ( ) ; using ( var client = new http _ client ( ) ) {
var response = await client . post _ async ( STR + port _ number , payload ) ;
port _ number = 0 ;
private static readonly json _ serializer _ settings json _ serializer _ settings = new json _ serializer _ settings {
} finally { invocation _ semaphore . release ( ) ; current _ invocation _ result = null ;
protected override void on _ output _ data _ received ( string output _ data ) { if ( current _ invocation _ result ! = null ) { current _ invocation _ result . set _ result ( output _ data ) ; } else {
request . get _ encoded _ url ( ) , request . path + request . query _ string . value ) ;
public string _ as _ temp _ file ( string content ) { file _ name = path . get _ temp _ file _ name ( ) ; file . write _ all _ text ( file _ name , content ) ;
public i _ action _ result index ( int page _ index )
private readonly process node _ process ;
public void configure ( i _ application _ builder app , i _ logger _ factory logger _ factory , i _ hosting _ environment env )
public void configure ( i _ application _ builder app , i _ hosting _ environment env , i _ logger _ factory logger _ factory )
public void configure ( i _ application _ builder app , i _ hosting _ environment env , i _ logger _ factory logger _ factory )
public void configure ( i _ application _ builder app , i _ hosting _ environment env , i _ logger _ factory logger _ factory )
public void configure ( i _ application _ builder app , i _ hosting _ environment env , i _ logger _ factory logger _ factory )
public void configure ( i _ application _ builder app , i _ hosting _ environment env , i _ logger _ factory logger _ factory )
bool on _ drag _ enter ( i _ web _ browser browser _ control , i _ browser browser , i _ drag _ data drag _ data , drag _ operations _ mask mask ) ;
if ( handle ! = int _ ptr . zero )
def _ wnd _ proc ( ref m ) ;
managed _ cef _ browser _ adapter . send _ focus _ event ( true ) ;
managed _ cef _ browser _ adapter . send _ focus _ event ( false ) ;
managed _ cef _ browser _ adapter . load _ html ( html , url ) ;
managed _ cef _ browser _ adapter . go _ back ( ) ;
managed _ cef _ browser _ adapter . go _ forward ( ) ;
managed _ cef _ browser _ adapter . reload ( ) ;
browser _ core . address = browser _ core . address ; if ( is _ offscreen _ browser _ created ) { cef _ browser _ wrapper . load _ url ( address ) ;
if ( source ! = null )
create _ offscreen _ browser ( ) ;
using system ;
on _ preview _ key ( e ) ;
on _ preview _ key ( e ) ;
render _ handler ? . on _ paint ( type , dirty _ rect , buffer , width , height ) ;
browser . get _ host ( ) . send _ mouse _ move _ event ( ( int ) point . x , ( int ) point . y , true , modifiers ) ;
result = subprocess . run ( ) ;
this . browser _ panel . location = new system . drawing . point ( 0 , 0 ) ;
using cef _ sharp _ wpf _ example _ views _ main ; using system _ windows ;
if ( e . old _ items ! = null )
int result ; using ( var subprocess = create ( args ) )
owner . show ( ) ; } } ) ;
owner . close ( ) ; } } } ) ;
resize _ browser ( ) ;
return bitmap = = null ? null : new bitmap ( bitmap ) ;
void i _ render _ handler . on _ paint ( bool is _ popup , rect dirty _ rect , int _ ptr buffer , int width , int height , image image )
create _ or _ update _ bitmap ( is _ popup , dirty _ rect , buffer , width , height , image , ref popup _ size , ref popup _ memory _ mapped _ file , ref popup _ memory _ mapped _ view _ accessor ) ;
private void create _ or _ update _ bitmap ( bool is _ popup , rect dirty _ rect , int _ ptr buffer , int width , int height , image image , ref size current _ size , ref memory _ mapped _ file mapped _ file , ref memory _ mapped _ view _ accessor view _ accessor )
void i _ render _ handler . on _ paint ( bool is _ popup , rect dirty _ rect , int _ ptr buffer , int width , int height , image image )
create _ or _ update _ bitmap ( is _ popup , dirty _ rect , buffer , width , height , image , ref popup _ size , ref popup _ memory _ mapped _ file , ref popup _ memory _ mapped _ view _ accessor ) ;
private void create _ or _ update _ bitmap ( bool is _ popup , rect dirty _ rect , int _ ptr buffer , int width , int height , image image , ref size current _ size , ref memory _ mapped _ file mapped _ file , ref memory _ mapped _ view _ accessor view _ accessor )
void i _ render _ handler . on _ paint ( bool is _ popup , rect dirty _ rect , int _ ptr buffer , int width , int height , image image )
create _ or _ update _ bitmap ( is _ popup , dirty _ rect , buffer , width , height , image , ref popup _ size , ref popup _ memory _ mapped _ file , ref popup _ memory _ mapped _ view _ accessor ) ;
private void create _ or _ update _ bitmap ( bool is _ popup , rect dirty _ rect , int _ ptr buffer , int width , int height , image image , ref size current _ size , ref memory _ mapped _ file mapped _ file , ref memory _ mapped _ view _ accessor view _ accessor )
bool on _ before _ browse ( i _ web _ browser browser _ control , i _ browser browser , i _ frame frame , i _ request request , bool is _ redirect ) ;
managed _ cef _ browser _ adapter . create _ browser ( browser _ settings ? ? new browser _ settings ( ) , handle , address ) ;
browser _ core . address = address ;
managed _ cef _ browser _ adapter . create _ offscreen _ browser ( int _ ptr . zero , browser _ settings , address ) ;
get { return new [ ] { 1 , 2 , NUM , NUM , NUM , NUM , NUM , NUM } ; }
if ( settings . windowless _ rendering _ enabled ) {
owner . close ( ) ;
if ( ! cef . initialize ( settings , shutdown _ on _ process _ exit : true , perform _ dependency _ check : true ) )
return dictionary [ property _ name ] ;
is _ loading = isloading ;
can _ go _ back = can _ go _ back ; can _ go _ forward = can _ go _ forward ; can _ reload = can _ reload ;
title = title ;
tooltip _ text = tooltip _ text ;
browser . get _ host ( ) . was _ hidden ( false ) ;
browser . get _ host ( ) . was _ hidden ( true ) ;
interop _ bitmap = null ;
browser . get _ host ( ) . notify _ screen _ info _ changed ( ) ;
return new cef _ render _ process ( args ) ;
get { return new [ ] { 1 , 2 , NUM , NUM , NUM , NUM , NUM , NUM } ; }
address = browser _ core . address ;
return cef _ browser . get _ zoom _ level _ async ( ) ;
cef _ browser . stop _ finding ( clear _ selection ) ;
cef _ browser . print ( ) ;
cef _ browser . show _ dev _ tools ( ) ;
cef _ browser . close _ dev _ tools ( ) ;
cef _ browser . add _ word _ to _ dictionary ( word ) ;
return managed _ cef _ browser _ adapter . get _ focused _ frame ( ) ;
return managed _ cef _ browser _ adapter . get _ browser ( ) ;
modifiers : modifiers ) ;
return wcf _ enabled ? new cef _ render _ process ( args ) : new cef _ sub _ process ( args ) ;
internal sealed class javascript _ callback _ surrogate : i _ data _ contract _ surrogate
cef . do _ message _ loop _ work ( ) ;
return javascript _ object _ repository . try _ call _ method ( object _ id , name , parameters , out result ) ;
return javascript _ object _ repository . try _ get _ property ( object _ id , name , out result ) ;
public override system . io . stream decrypt ( system . io . stream input )
public override system . io . stream decrypt ( system . io . stream input )
new _ opts [ STR ] = STR ;
var missing = new list < key _ value _ pair < remote _ volume _ entry , i _ file _ entry > > ( ) ;
public void post ( string key , request _ info info )
public stream open _ write ( string file )
create _ managed _ connection ( true ) . put ( get _ full _ path ( remotename ) , stream ) ;
create _ managed _ connection ( true ) . get ( get _ full _ path ( remotename ) , stream ) ;
return run _ from _ most _ recent _ spawn ( method , cmdargs , defaultstrategy ) ;
known _ storage _ classes = ns ;
program . use _ database _ encryption = ! library . utility . utility . parse _ bool _ option ( commandline _ options , STR ) ;
var sshfolder = client . list _ directory ( STR ) . first ( x = > x . name = = STR ) ;
var existing _ authorized _ keys = client . list _ directory ( ssh _ folder ) . any ( x = > x . name = = authorized _ keys _ file ) ;
i _ node parent = nodes . first ( x = > x . type = = node _ type . root ) ;
var cur = notifications . first _ or _ default ( x = > x . id = = id ) ;
throw new folder _ missing _ exception ( ex ) ;
using ( var backend = new fh _ backend ( m _ backendurl , m _ options , m _ stat , restoredb ) )
using ( var tr = new temporary _ transaction _ wrapper ( m _ connection , transaction ) ) {
using ( var backend = new fh _ backend ( m _ backendurl , m _ options , m _ stat , db ) )
using ( var backend = new fh _ backend ( m _ backendurl , m _ options , m _ stat , database ) )
using ( var backend = new fh _ backend ( m _ backendurl , m _ options , m _ stat , db ) )
if ( t = = null | | t . backup = = null ) return null ;
using ( file _ stream fs = file . open _ read ( filename ) )
using ( file _ stream fs = file . create ( filename ) )
if ( options = = null )
temp _ file ret _ target = null , dl _ target = null , decrypt _ target = null ;
using ( temp _ folder ttf = new temp _ folder ( ) )
using ( new timer ( STR + folders [ i ] ) )
( log . current _ log as stream _ log ) . dispose ( ) ; log . current _ log = null ;
public static void print _ argument ( list < string > lines , i _ command _ line _ argument arg )
mx . value . configure ( m _ options . raw _ options ) ;
forest _ hash . forest _ hash . restore ( m _ backend , m _ options , rs , target [ 0 ] ) ;
using ( var handler = new forest _ hash . operation . restore _ control _ files _ handler ( m _ backend , m _ options , rs , target ) )
using ( var handler = new forest _ hash . operation . delete _ handler ( m _ backend , m _ options , rs ) )
using ( var handler = new forest _ hash . operation . repair _ handler ( m _ backend , m _ options , rs ) )
using ( var handler = new forest _ hash . operation . list _ files _ handler ( m _ backend , m _ options , rs ) )
using ( var handler = new forest _ hash . operation . find _ last _ file _ version _ handler ( m _ backend , m _ options , rs ) )
var writer _ guids = new [ ] { hyper _ v _ writer _ guid } ;
operation _ progress ( this , duplicati _ operation . backup , - 1 , - 1 , strings . interface . status _ loading _ filelist , STR ) ;
n = n . union ( db . delete _ all _ but _ n ( m _ options . delete _ all _ but _ n , m _ options . allow _ full _ removal , m _ stat , m _ options , tr ) ) ;
using ( file _ stream fs = file . create ( filename ) )
var pwd = m _ active _ nonces [ nonce ] . item ; m _ active _ nonces . remove ( nonce ) ;
else if ( result is i _ enumerable )
cert _ hash = core . utility . byte _ array _ as _ hex _ string ( cert . get _ cert _ hash ( ) ) ;
get { return m _ current ; }
list < backup _ entry > entries = parse _ file _ list ( backend , options ) ;
foreach ( var mx in m _ options . loaded _ modules )
public class hyper _ v _ options : interface . i _ generic _ source _ module
if ( rd . read ( ) )
m _ username = null ;  m _ password = null ;
return null ;
( rd ) = > new backup {
files . add ( new temp _ file ( filename , localfilename , sha . compute _ hash ( fs ) , fs . length ) ) ;
remote _ path = STR ;
void enumerate _ files _ and _ folders ( string startpath , duplicati . library . utility . filename _ filter filter , duplicati . library . utility . utility . enumeration _ callback _ delegate callback ) ;
m _ statusmessage = string . format ( strings . backend _ wrapper . status _ message _ uploading , remotename , utility . utility . format _ size _ string ( new system . io . file _ info ( filename ) . length ) ) ;
if ( utility . utility . is _ client _ linux )
m _ path = utility . utility . append _ dir _ separator ( path ) ;
public void enumerate _ files _ and _ folders ( string rootpath , duplicati . library . utility . filename _ filter filter , duplicati . library . utility . utility . enumeration _ callback _ delegate callback )
callback ( rootpath , r . key , duplicati . library . utility . utility . enumerated _ file _ status . file ) ;
if ( r . value . usn > = last _ usn & & r . key . starts _ with ( source _ folder , utility . utility . client _ filename _ string _ comparision ) )
if ( r . key . starts _ with ( m _ path , utility . utility . client _ filename _ string _ comparision ) )
success = utility . utility . compare _ streams ( m _ original _ signature _ stream , m _ signature _ stream , true ) ;
utility . utility . copy _ stream ( m _ signature _ stream , , true ) ;
sourcefolder [ i ] = utility . utility . append _ dir _ separator ( sourcefolder [ i ] ) ;
if ( utility . utility . is _ client _ linux & & options . usn _ strategy ! = options . optimization _ strategy . auto )
usn _ helpers = new dictionary < string , duplicati . library . snapshots . usn _ helper > ( utility . utility . client _ filename _ string _ comparer ) ;
int ix = m _ unproccesed . files . binary _ search ( folder , utility . utility . client _ filename _ string _ comparer ) ;
fs = new utility . temp _ file _ stream ( ) ; utility . utility . copy _ stream ( ts , fs , false ) ;
if ( ! utility . utility . compare _ streams ( signature , new _ sig , true ) )
return m _ filter . should _ include ( utility . utility . directory _ separator _ string , utility . utility . directory _ separator _ string + utility . utility . append _ dir _ separator ( element ) ) ;
destination [ i ] = utility . utility . append _ dir _ separator ( destination [ i ] ) ;
string contentprefix = utility . utility . append _ dir _ separator ( content _ root ) ;
string deltaprefix = utility . utility . append _ dir _ separator ( delta _ root ) ;
utility . utility . copy _ stream ( , st ) ;
public void callback ( string rootpath , string path , utility . utility . enumerated _ file _ status status ) { if ( status = = utility . utility . enumerated _ file _ status . folder )
else if ( status = = utility . utility . enumerated _ file _ status . file )
else if ( status = = utility . utility . enumerated _ file _ status . error )
if ( ! library . utility . utility . is _ client _ linux )
dictionary < string , int > duplicates = new dictionary < string , int > ( library . utility . utility . client _ filename _ string _ comparer ) ;
targets [ index ] = string . is _ null _ or _ empty ( m _ default _ target ) ? STR : library . utility . utility . append _ dir _ separator ( m _ default _ target ) + suffix ;
public void callback ( string rootpath , string path , utility . utility . enumerated _ file _ status status ) { if ( status = = duplicati . library . utility . utility . enumerated _ file _ status . file )
else if ( status = = duplicati . library . utility . utility . enumerated _ file _ status . folder )
public void enumerate _ files _ and _ folders ( string startpath , duplicati . library . utility . filename _ filter filter , duplicati . library . utility . utility . enumeration _ callback _ delegate callback )
parent _ folders . add ( duplicati . library . utility . utility . append _ dir _ separator ( folder ) ) ;
m _ folder = utility . utility . append _ dir _ separator ( basefolder ) ;
return utility . utility . enumerate _ files ( system . io . path . combine ( m _ folder , prefix ) ) . to _ array ( ) ;
return utility . utility . enumerate _ folders ( system . io . path . combine ( m _ folder , prefix ) ) . to _ array ( ) ;
return utility . utility . enumerate _ file _ system _ entries ( system . io . path . combine ( m _ folder , prefix ) ) . to _ array ( ) ;
sources [ i ] = utility . utility . append _ dir _ separator ( sources [ i ] ) ;
if ( sources [ i ] . equals ( sources [ j ] , utility . utility . is _ fs _ case _ sensitive ? string _ comparison . current _ culture : string _ comparison . current _ culture _ ignore _ case ) )
else if ( sources [ i ] . starts _ with ( sources [ j ] , utility . utility . is _ fs _ case _ sensitive ? string _ comparison . current _ culture : string _ comparison . current _ culture _ ignore _ case ) )
manifest . content _ hashes . add ( utility . utility . calculate _ hash ( contentfile ) ) ;
manifest . signature _ hashes . add ( utility . utility . calculate _ hash ( signaturefile ) ) ;
string prefix = utility . utility . append _ dir _ separator ( r _ sync . r _ sync _ dir . control _ root ) ;
system . threading . thread . current _ thread . priority = utility . utility . parse _ priority ( m _ options . thread _ priority ) ;
string root = duplicati . library . utility . utility . append _ dir _ separator ( application . startup _ path ) ;
foreach ( string s in duplicati . library . utility . utility . enumerate _ files ( application . startup _ path ) )
if ( ! library . utility . utility . is _ client _ linux )
if ( ! library . utility . utility . is _ client _ linux & & string . is _ null _ or _ empty ( environment . get _ environment _ variable ( db _ key _ env _ name ) ) )
entry . folder _ size = library . utility . utility . format _ size _ string ( m _ sizes [ path ] ) ;
total _ size . text = string . format ( strings . select _ files . final _ size _ calculated , library . utility . utility . format _ size _ string ( s ) ) ;
total _ size . text = string . format ( strings . select _ files . partial _ size _ calculated , library . utility . utility . format _ size _ string ( s ) ) ;
my _ music _ size . text = library . utility . utility . format _ size _ string ( find _ actual _ size ( m _ my _ music ) ) ;
my _ pictures _ size . text = library . utility . utility . format _ size _ string ( find _ actual _ size ( m _ my _ pictures ) ) ;
desktop _ size . text = library . utility . utility . format _ size _ string ( find _ actual _ size ( m _ desktop ) ) ;
appdata _ size . text = library . utility . utility . format _ size _ string ( find _ actual _ size ( m _ app _ data ) ) ;
my _ documents _ size . text = library . utility . utility . format _ size _ string ( find _ actual _ size ( m _ my _ documents ) ) ;
m _ sourcefolders [ i ] = utility . utility . append _ dir _ separator ( folders [ i ] ) ;
if ( s . equals ( startpath , utility . utility . client _ filename _ string _ comparision ) )
return new key _ value _ pair < string , string > ( x , n ) ;
return STR + this . host + STR + this . port + STR + this . folder ;
return STR + this . host + STR + this . folder ;
return STR + this . destination _ folder ;
result . add _ verbose _ message ( STR , sources [ i ] , sources [ j ] ) ;
private const string oauth _ login _ url _ template = STR ; public static string oauth _ login _ url ( string modulename ) { return string . format ( oauth _ login _ url _ template , modulename ) ; }
return this +
? environment . new _ line + exception
throw new exception ( string . format ( STR , error _ builder ) ) ;
console . error . write _ line ( error _ builder ) ;
internal bool do _ compact ( local _ delete _ database db , bool has _ verified _ backend , system . data . i _ db _ transaction transaction )
if ( ( old _ id < 0 | | m _ options . disable _ filetime _ check | | local _ database . normalize _ date _ time ( last _ modified ) > = old _ scanned ) & & ( m _ options . skip _ files _ larger _ than = = long . max _ value | | filestatsize < m _ options . skip _ files _ larger _ than ) )
assert . are _ equal ( NUM , filesets , STR ) ;
assert . are _ equal ( filenames . count + 1 , filecount , STR ) ;
assert . are _ equal ( NUM , res . rewritten _ file _ lists , STR ) ; assert . are _ equal ( NUM , res . removed _ file _ count , STR ) ;
assert . are _ equal ( 2 , res . rewritten _ file _ lists , STR ) ; assert . are _ equal ( NUM , res . removed _ file _ count , STR ) ;
assert . are _ equal ( 1 , res . rewritten _ file _ lists , STR ) ; assert . are _ equal ( 2 , res . removed _ file _ count , STR ) ;
assert . are _ equal ( NUM , filesets , STR ) ; assert . are _ equal ( filenames . count - NUM + 1 , filecount , STR ) ;
assert . are _ equal ( NUM , filesets , STR ) ; assert . are _ equal ( filenames . count + 1 , filecount , STR ) ;
m _ old _ folders . remove ( s ) ;
target = new upload _ request ( new block _ volume _ writer ( options ) , null ) ;
system . net . http _ web _ request req = create _ request ( remotename , STR ) ; req . method = STR ; using ( req . get _ response ( ) ) { }
private i _ write _ channel < data _ block > m _ blockoutput ;
private async task add _ folder _ to _ output ( string filename , date _ time last _ modified , i _ metahash meta )
cmd . execute _ non _ query ( string . format ( STR + query , m _ tablename ) , args ) ;
void runner _ duplicati _ progress ( duplicati _ operation operation , runner _ state state , string message , string submessage , int progress , int subprogress )
public void set _ current _ icon ( runner _ result icon , string message ) { if ( icon = = runner _ result . error )
void runner _ result _ event ( runner _ result result , string parsed _ message , string message )
foreach ( var s in system _ io . io _ os . enumerate _ file _ system _ entries ( entrypath ) )
if ( system . io . directory . exists ( s ) )
if ( ! system . io . directory . exists ( s ) )
void connection _ status _ updated ( i _ serializable _ status status )
logging . log . write _ message ( strings . run _ script . invalid _ exit _ code _ error ( scriptpath , p . exit _ code ) , duplicati . library . logging . log _ message _ type . warning ) ;
logging . log . write _ message ( strings . run _ script . std _ error _ report ( scriptpath , stderr ) , duplicati . library . logging . log _ message _ type . warning ) ;
return strings . utility . format _ string _ gb ( ( double ) size / ( NUM * NUM * NUM ) ) ;
return strings . utility . format _ string _ mb ( ( double ) size / ( NUM * NUM ) ) ;
return strings . utility . format _ string _ kb ( ( double ) size / NUM ) ;
throw new exception ( strings . google _ docs . folder _ has _ multiple _ owners _ error ( cur . title , pids ) ) ;
return strings . controller . unsupported _ boolean _ value ( optionname , value ) ;
return strings . controller . unsupported _ integer _ value ( optionname , value ) ;
return strings . controller . unsupported _ path _ value ( optionname , p ) ;
return strings . controller . unsupported _ size _ value ( optionname , value ) ;
var bit = data % m _ bits ;
var bit = data % m _ bits ;
task = new key _ value _ pair < int , task > ( 1 , upload _ file _ async ( ( ( fileset _ upload _ request ) req ) . fileset ) ) ;
task = new key _ value _ pair < int , task > ( 1 , upload _ file _ async ( ( ( index _ volume _ upload _ request ) req ) . index _ volume ) ) ;
m _ task . signaturekey = null ;
private i _ task _ reader m _ taskreader ;
private async task do _ with _ retry ( file _ entry _ item item , func < task > method )
private async task do _ put ( file _ entry _ item item )
vss _ backup _ components . disable _ writer _ classes ( excluded _ writers ) ;
return res ;
if ( m . key ) { if ( m . value . supported _ commands ! = null )
using ( var fs = snapshot . open _ read ( path ) )
m _ block _ hash _ lookup . add ( key , size , new key _ value _ pair < long , long > ( r , size ) ) ;
m _ block _ hash _ lookup . add ( key , size , new key _ value _ pair < long , long > ( r , size ) ) ;
entry . add _ fileset _ id ( blockset _ id , metadata _ id , fileidobj ) ;
return handler . run ( ) ;
public i _ list _ results list ( string filter = null )
public i _ list _ results list ( i _ enumerable < string > filter )
private void add _ tree _ item ( string value , string imagekey )
schedule s = m _ wrapper . data _ connection . get _ object _ by _ id < schedule > ( m _ wrapper . schedule _ id ) ;
m _ client = new amazon _ client ( aws _ id , aws _ key , cfg ) ;
application _ settings [ allow _ saved _ credentials ] = gui _ options [ allow _ saved _ credentials ] ;
deletedfolders . sort ( ) ; deletedfolders . reverse ( ) ;
addedfolders . sort ( ) ;
count + + ;
count + + ;
extras . add _ range ( filters ) ; m _ wrapper . encoded _ filters = library . core . filename _ filter . encode _ as _ filter ( extras ) ;
items . enqueue ( t ) ;
directory . delete ( restorefolder , true ) ;
directory . delete ( restorefolder , true ) ;
backend . delete ( be ) ;
backend . delete ( be . signature _ file [ i ] ) ;
backend . delete ( be . content _ volumes [ i ] ) ;
m _ stderr . write _ line ( entry ) ;
m _ stdout . write _ line ( entry ) ;
add _ message ( message ) ;
m _ database . add _ blockset ( filehash , size , m _ blockbuffer . length , hashlist , blocklisthashes , out blocksetid , m _ transaction ) ;
system . net . http _ web _ request req = create _ request ( remotename ) ; req . method = system . net . web _ request _ methods . http . put ; req . content _ type = STR ; try {
private readonly i _ metahash empty _ metadata ;
i _ metahash metahash ;
private bool add _ folder _ to _ output ( string filename , date _ time scantime , i _ metahash meta )
private bool add _ symlink _ to _ output ( string filename , date _ time scantime , i _ metahash meta )
private void add _ file _ to _ output ( string filename , long size , date _ time scantime , i _ metahash metadata , hashlist _ collector hashlist , string filehash , i _ list < string > blocklisthashes )
public operation _ mode operation _ mode { get { return m _ operation _ mode ; } }
} data _ connection . purge _ log _ data ( library . utility . timeparser . parse _ time _ interval ( pts , date _ time . now , true ) ) ;
backend . get ( entry , null , tf , null ) ;
public void get ( string remotename , stream output )
throw new interface . folder _ missing _ exception ( wex ) ;
throw new interface . folder _ missing _ exception ( tex ) ;
cmd . command _ text = c ;
throw new user _ information _ exception ( STR , STR ) ;
throw new user _ information _ exception ( STR , STR ) ;
m _ stat . log _ warning ( string . format ( strings . r _ sync _ dir . snapshot _ failed _ error , ex . to _ string ( ) ) , ex ) ;
return metadata ;
return new dictionary < string , string > ( ) ;
return false ;
return false ;
return true ;
return false ;
return false ;
return false ;
return false ;
return false ;
return false ;
return true ;
s + = url _ encode ( username ? ? STR ) ;
s + = url _ encode ( password ? ? STR ) ;
public const file _ attributes attribute _ error = ( file _ attributes ) ( 1 < < NUM ) ;
public delegate bool enumeration _ filter _ delegate ( string rootpath , string path , file _ attributes attributes ) ;
public static void copy _ stream ( stream source , stream target )
public delegate file _ attributes extract _ file _ attributes ( string path ) ;
return enumerate _ file _ system _ entries ( rootpath , callback , directory . get _ directories , directory . get _ files ) ;
file _ attributes attr = attribute _ reader = = null ? file _ attributes . directory : attribute _ reader ( rootpath ) ;
file _ attributes attr = attribute _ reader = = null ? file _ attributes . normal : attribute _ reader ( s ) ;
return enumerate _ folders ( folder , filter ) . sum ( ( path ) = > new file _ info ( path ) . length ) ;
public static int force _ stream _ read ( stream stream , byte [ ] buf , int count )
return parse _ bool ( value , ( ) = > default ) ;
var regex = new regex ( STR ) ;
return get _ unique _ items ( collection , equality _ comparer < t > . default , out duplicate _ items ) ;
using ( var sw = new string _ writer ( sb ) )
this . auth . password _ credentials = new password _ based _ request
this . auth . api _ credentials = new api _ key _ based _ request
options [ STR ] = STR ;
options [ STR ] = STR ;
return post _ and _ get _ json _ data < folder _ metadata > ( url , pa ) ;
json _ property _ tag
tk . show _ url _ in _ window ( connection . status _ window _ url ) ; duplicati . server . program . is _ first _ run = false ; duplicati . server . program . server _ port _ changed = false ;
directory . delete ( normalize _ path ( path ) ) ;
directory . create _ directory ( normalize _ path ( path ) ) ;
return directory . exists ( normalize _ path ( path ) ) ;
return unix _ support . file . get _ symlink _ target ( normalize _ path ( path ) ) ;
return path . get _ directory _ name ( normalize _ path ( path ) ) ;
directory . set _ last _ write _ time _ utc ( normalize _ path ( path ) , time ) ;
directory . set _ creation _ time _ utc ( normalize _ path ( path ) , time ) ;
return directory . get _ last _ write _ time _ utc ( normalize _ path ( path ) ) ;
return directory . get _ creation _ time _ utc ( normalize _ path ( path ) ) ;
directory . delete ( normalize _ path ( path ) , recursive ) ;
var f = normalize _ path ( file ) ;
var s = string . format ( STR , string . join ( STR , doubles ) ) ;
} data _ connection . purge _ log _ data ( library . utility . timeparser . parse _ time _ interval ( pts , date _ time . now , true ) ) ;
m _ selectfilelastmodified _ command . set _ parameter _ value ( 0 , path ) ; m _ selectfilelastmodified _ command . set _ parameter _ value ( 1 , filesetid ) ;
tr . commit ( ) ;
if ( keyfile . text . trim ( ) . length = = 0 )
public task task
sp . file . save _ binary _ direct ( ctx , fileurl , stream , true ) ;
string path = file ;
foreach ( string f in z . list _ files ( prefix ) )
foreach ( string f in arch . list _ files ( sigentry . value ) )
foreach ( string f in arch . list _ files ( control _ prefix ) )
foreach ( string f in signature . list _ files ( prefix ) )
args . add ( time ) ;
path _ size _ calculator c = new path _ size _ calculator ( filter ) ; enumerate _ file _ system _ entries ( folder , new enumeration _ callback _ delegate ( c . callback ) ) ;
next _ progress _ event = date _ time . now + progress _ timespan ;
} catch {
this . regexp = new system . text . regular _ expressions . regex ( library . utility . utility . convert _ globbing _ to _ reg _ exp ( filter ) , regexp _ options ) ;
parents = new google _ drive _ parent _ reference [ ] { new google _ drive _ parent _ reference { id = current _ folder _ id } }
parents = new google _ drive _ parent _ reference [ ] { new google _ drive _ parent _ reference { id = parent } }
return environment . expand _ environment _ variables ( str ) ;
console . write _ line ( STR , h , environment . new _ line , ex ) ;
console . write _ line ( STR , blh , environment . new _ line , ex ) ;
system . diagnostics . trace . write _ line ( STR + ex ) ; console . write _ line ( STR + ex ) ;
system . diagnostics . trace . write _ line ( STR + ex ) ; console . write _ line ( STR + ex ) ;
console . write _ line ( STR , i , e , remotefilename ) ;
console . write _ line ( string . format ( STR , e ) ) ;
sw . write _ line ( c ) ;
sw . write _ line ( STR , e ) ;
log . known _ file _ count = remotelist . count ;
log . unknown _ file _ count = unknownlist . count ;
var url = utility . uri . uri _ builder ( web _ api . google _ cloud _ storage . url . api , path , query _ params ) ;
m _ hash . transform _ block ( m _ hashbuffer , 0 , m _ hashbuffer . length , m _ hashbuffer , 0 ) ;
m _ hash . transform _ block ( buffer , offset , bytes _ to _ use , buffer , offset ) ;
m _ block _ hash _ lookup . add ( str , size , new key _ value _ pair < long , long > ( id , size ) ) ;
m _ block _ hash _ lookup . add ( key , size , new key _ value _ pair < long , long > ( convert . to _ int ( r ) , size ) ) ;
m _ block _ hash _ lookup . add ( key , size , new key _ value _ pair < long , long > ( convert . to _ int ( r ) , size ) ) ;
m _ lookup = null ;
backend = new backend _ wrapper ( bs , backend , m _ options ) ;
backend = encrypted _ backend _ wrapper . wrap _ with _ encryption ( backend , m _ options ) ;
backend = new backend _ wrapper ( rs , backend , m _ options ) ;
backend = encrypted _ backend _ wrapper . wrap _ with _ encryption ( backend , best _ fit . encryption _ mode , m _ options ) ;
backend = new backend _ wrapper ( rs , backend , m _ options ) ;
backend = encrypted _ backend _ wrapper . wrap _ with _ encryption ( backend , best _ fit . encryption _ mode , m _ options ) ;
public static i _ localization _ service get ( culture _ info ci )
if ( m _ filters . any ( x = > x . matches ( path ) ) )
foreach ( var path in filterhandler . enumerate _ files _ and _ folders ( m _ snapshot ) )
else return m _ filters . aggregate ( library . utility . joined _ filter _ expression . join ) ;
var httpex = wex . response as http _ web _ response ;
if ( package _ result ! = null & & package _ result . package ! = null ) { var pkginfo = package _ info _ service . get _ package _ information ( package _ result . package ) ;
this . log ( ) . error ( chocolatey _ loggers . important , STR . format _ with ( command _ name . to _ string ( ) , package _ result . name ) ) ;
this . log ( ) . info ( chocolatey _ loggers . important , STR . format _ with ( command _ name . to _ string ( ) , package _ result . name ) ) ;
this . log ( ) . debug ( ( ) = > STR . format _ with ( uninstall _ args ) ) ;
public operating _ system os _ version
private static readonly i _ log logger = log _ manager . get _ logger ( typeof ( bootstrap ) ) ;
nuget _ service . install _ noop ( configuration , ( pkg ) = > powershell _ service . install _ noop ( pkg ) ) ;
public bool copy _ file _ unsafe ( string source _ file _ name , string destination _ file _ name , bool overwrite _ the _ existing _ file )
if ( ! string . is _ null _ or _ white _ space ( configuration . source ) )
using synchronization ;
this . log ( ) . trace ( STR . format _ with ( xml _ file _ path ) ) ;
this . log ( ) . trace ( STR . format _ with ( temp _ update _ file ) ) ;
this . log ( ) . trace ( STR . format _ with ( temp _ update _ file ) ) ;
this . log ( ) . trace ( STR . format _ with ( xml _ file _ path , temp _ update _ file ) ) ;
this . log ( ) . trace ( STR . format _ with ( destination _ file _ path , backup _ file _ path ) ) ;
this . log ( ) . trace ( STR . format _ with ( backup _ file _ path ) ) ;
this . log ( ) . trace ( STR . format _ with ( destination _ file _ path , backup _ file _ path ) ) ;
this . log ( ) . trace ( STR . format _ with ( source _ file _ path , destination _ file _ path ) ) ;
this . log ( ) . trace ( STR . format _ with ( source _ file _ path ) ) ;
nuget _ service . uninstall _ noop ( config , ( pkg ) = > powershell _ service . uninstall _ noop ( pkg ) ) ;
configuration . push _ command . timeout _ in _ seconds = timeout ; } } )
var original _ config = config ;
var original _ config = config ;
using system ;
using system _ collections _ concurrent ; using configuration ; using results ; public interface i _ nuget _ service : i _ source _ runner
& & p . declaring _ type ! = typeof ( db _ context )
detect _ navigation _ change ( entry , navigation ) ;
private expression try _ optimize (
var persistent _ database = new in _ memory _ database ( new logger _ factory ( ) ) ;
var persistent _ database = new in _ memory _ database ( new logger _ factory ( ) ) ;
var persistent _ database = new in _ memory _ database ( new logger _ factory ( ) ) ;
using system ;
expression . constant ( query _ sql _ generator _ factory ) ,
theory
theory
conditional _ fact
conditional _ fact
old _ base _ type . builder ? . relational ( configuration _ source . convention ) . has _ discriminator ( property _ info : null ) ;
select [ ] . [ customer _ id ]
return convert . change _ type ( interlocked . increment ( ref current ) , property . property _ type . unwrap _ nullable _ type ( ) ) ;
values . add ( new guid ( ( byte [ ] ) generated _ value ) ) ;
return convert . change _ type ( new _ value . current , property . property _ type . unwrap _ nullable _ type ( ) ) ;
return convert . change _ type ( new _ value . current , property . property _ type . unwrap _ nullable _ type ( ) ) ;
values . add ( guid . parse ( ( string ) generated _ value ) ) ;
return guid . new _ guid ( ) . to _ byte _ array ( ) ;
return 1 ;
return guid . new _ guid ( ) ;
return guid . new _ guid ( ) . to _ string ( ) ;
values . add ( ( guid ) generated _ value ) ;
values . add ( ( guid ) generated _ value ) ;
var dependent _ type = model . add _ entity _ type ( typeof ( dependent _ entity ) ) ;
var dependent _ type _ with _ composite _ key = model . add _ entity _ type ( typeof ( dependent _ entity _ with _ composite _ key ) ) ;
public static model model ( )
entity _ type ( model ) ;
var customer _ type = model . add _ entity _ type ( typeof ( customer ) ) ;
var order _ type = model . add _ entity _ type ( typeof ( order ) ) ;
var entity = model . add _ entity _ type ( STR ) ;
var entity = model . add _ entity _ type ( STR ) ;
var entity _ type = model . add _ entity _ type ( typeof ( some _ entity ) . full _ name ) ;
var entity _ type = model . add _ entity _ type ( typeof ( some _ dependent _ entity ) . full _ name ) ;
var entity _ type = model . add _ entity _ type ( typeof ( full _ notification _ entity ) ) ;
var entity _ type = model . add _ entity _ type ( typeof ( changed _ only _ entity ) ) ;
var entity _ type = model . add _ entity _ type ( typeof ( some _ more _ dependent _ entity ) . full _ name ) ;
var entity _ type = model . add _ entity _ type ( typeof ( some _ entity ) ) ;
var entity _ type = model . add _ entity _ type ( typeof ( some _ dependent _ entity ) ) ;
var entity _ type = model . add _ entity _ type ( typeof ( full _ notification _ entity ) ) ;
var entity _ type = model . add _ entity _ type ( typeof ( changed _ only _ entity ) ) ;
var entity _ type = model . add _ entity _ type ( typeof ( some _ more _ dependent _ entity ) ) ;
var entity _ type = model . add _ entity _ type ( typeof ( some _ entity ) ) ;
var entity _ type = model . add _ entity _ type ( typeof ( some _ dependent _ entity ) ) ;
var entity _ type = model . add _ entity _ type ( typeof ( full _ notification _ entity ) ) ;
var entity _ type = model . add _ entity _ type ( typeof ( some _ more _ dependent _ entity ) ) ;
var entity _ type = model . add _ entity _ type ( typeof ( kool _ entity ) ) ;
var entity _ type = model . add _ entity _ type ( typeof ( kool _ entity ) ) ;
var entity _ type = model . add _ entity _ type ( typeof ( some _ dependent _ entity ) ) ;
var entity _ type = model . add _ entity _ type ( typeof ( some _ more _ dependent _ entity ) ) ;
sb . append ( use _ identity _ facet _ config ) ;
public virtual i _ db _ context _ transaction begin _ transaction ( isolation _ level isolation _ level )
new [ ]
: identity _ map _ factory _ factory _ base , i _ in _ memory _ table _ factory
console . write _ line ( STR , option _ help . long _ name ) ;
private readonly i _ principal _ key _ value _ factory < t _ key > key _ value _ factory ;
not _ null i _ principal _ key _ value _ factory < t _ key > key _ value _ factory ,
namespace microsoft _ data _ relational _ tests _ model
b . property ( STR ) ; b . property ( STR ) ;
b . property ( STR ) ;
b . property ( STR ) . has _ field ( STR ) ; b . property ( STR ) . has _ field ( STR ) ;
b . property ( STR ) ;
b . property ( STR ) ; b . property ( STR ) ;
b . property ( STR ) ;
b . property ( STR ) ;
not _ null string invariant _ name , not _ null string name )
public new virtual t _ property current _ value
parameters . add ( ( sqlite _ parameter ) value ) ;
var ptr = marshal . alloc _ h _ global ( bytes . length + 1 ) ;
= > entity . make _ member _ access ( navigation . get _ member _ info ( for _ materialization : true , for _ set : true ) ) . assign ( related _ entity ) ;
var target _ entry = state _ manager . get _ or _ create _ entry ( related _ entity , target _ entity _ type ) ;
var target _ entry = state _ manager . get _ or _ create _ entry ( navigation _ value , target _ entity _ type ) ;
var target _ entry = state _ manager . get _ or _ create _ entry ( related _ entity , target _ type ) ;
var target _ entry = state _ manager . get _ or _ create _ entry ( navigation _ value , target _ type ) ;
public virtual foreign _ key remove _ foreign _ key ( [ not _ null ] foreign _ key foreign _ key )
order _ type . get _ or _ add _ foreign _ key ( customer _ fk , customer _ pk ) ;
order _ type . get _ or _ add _ foreign _ key ( customer _ fk , customer _ pk ) ;
order _ type . get _ or _ add _ foreign _ key ( customer _ fk , customer _ key ) ;
var customer _ foreign _ key = order _ type . get _ or _ add _ foreign _ key ( foreign _ key _ property , customer _ key ) ;
var customer _ foreign _ key = order _ type . get _ or _ add _ foreign _ key ( foreign _ key _ property , customer _ key ) ;
var customer _ foreign _ key = order _ type . get _ or _ add _ foreign _ key ( foreign _ key _ property , customer _ key ) ;
var customer _ foreign _ key = order _ type . get _ or _ add _ foreign _ key ( foreign _ key _ property , customer _ key ) ; customer _ type . add _ navigation ( STR , customer _ foreign _ key , points _ to _ principal : false ) ;
category _ type . add _ navigation ( STR , category _ fk , points _ to _ principal : false ) ;
product _ type . add _ navigation ( STR , category _ fk , points _ to _ principal : true ) ;
product _ type . add _ navigation ( STR , featured _ product _ fk , points _ to _ principal : false ) ;
category _ type . add _ navigation ( STR , featured _ product _ fk , points _ to _ principal : true ) ;
var fk = dependent _ type . get _ or _ add _ foreign _ key ( fk _ property , principal _ type . get _ primary _ key ( ) ) ;
var fk = dependent _ type . get _ or _ add _ foreign _ key ( fk _ property , principal _ type . get _ primary _ key ( ) ) ;
var fk = dependent _ type . get _ or _ add _ foreign _ key ( fk _ property , principal _ type . get _ primary _ key ( ) ) ;
var fk = dependent _ type . get _ or _ add _ foreign _ key ( fk _ property , principal _ type . get _ primary _ key ( ) ) ; dependent _ type . add _ navigation ( STR , fk , points _ to _ principal : true ) ;
var fk = dependent _ type . get _ or _ add _ foreign _ key ( fk _ property , principal _ type . get _ primary _ key ( ) ) ; principal _ type . add _ navigation ( STR , fk , points _ to _ principal : false ) ;
var fk = dependent _ type . get _ or _ add _ foreign _ key ( fk _ property , principal _ type . get _ primary _ key ( ) ) ;
( ) = > new foreign _ key ( new [ ] { dependent _ property , dependent _ property } , principal _ type . get _ primary _ key ( ) ) ) . message ) ;
var foreign _ key = new foreign _ key ( new [ ] { dependent _ prop } , entity _ type . get _ primary _ key ( ) ) ;
var foreign _ key = new foreign _ key ( new [ ] { dependent _ prop } , entity _ type . get _ primary _ key ( ) ) ;
var foreign _ key = new foreign _ key ( new [ ] { dependent _ prop , dependent _ prop } , entity _ type . get _ primary _ key ( ) ) ;
return property . entity _ type . foreign _ keys . select _ many ( k = > k . properties ) . contains ( property ) ;
return property . entity _ type . get _ primary _ key ( ) . properties . contains ( property ) ;
return property . entity _ type . keys . select _ many ( e = > e . properties ) . contains ( property ) ;
assert . throws < argument _ null _ exception > ( ( ) = > new navigation ( STR , null , points _ to _ principal : true ) ) . param _ name ) ;
assert . throws < argument _ exception > ( ( ) = > new navigation ( STR , new mock < foreign _ key > ( ) . object , points _ to _ principal : true ) ) . message ) ;
var navigation = new navigation ( STR , foreign _ key , points _ to _ principal : true ) ;
var navigation = new navigation ( STR , foreign _ key , points _ to _ principal : false ) ;
var fk = entity _ type . get _ or _ add _ foreign _ key ( fk _ property , entity _ type . get _ primary _ key ( ) ) ;
entity _ type . add _ navigation ( STR , fk , points _ to _ principal : false ) ; entity _ type . add _ navigation ( STR , fk , points _ to _ principal : true ) ;
entity _ type . get _ or _ add _ foreign _ key ( fk _ property , new key ( new [ ] { id _ property } ) ) ;
entity _ type . get _ or _ add _ foreign _ key ( new [ ] { fk } , entity _ type . get _ primary _ key ( ) ) ;
entity _ type . get _ or _ add _ foreign _ key ( new [ ] { fk _ a , fk _ b } , entity _ type . get _ primary _ key ( ) ) ;
product _ type . add _ navigation ( STR , product _ id _ fk , points _ to _ principal : false ) ; order _ detail _ type . add _ navigation ( STR , product _ id _ fk , points _ to _ principal : true ) ;
customer _ type . add _ navigation ( STR , customer _ id _ fk , points _ to _ principal : false ) ; order _ type . add _ navigation ( STR , customer _ id _ fk , points _ to _ principal : true ) ;
entity _ type . get _ or _ add _ foreign _ key ( new [ ] { fk } , entity _ type . get _ primary _ key ( ) ) ;
var customer _ fk = customer _ type . get _ or _ add _ foreign _ key ( customer _ fk _ property , house _ type . get _ primary _ key ( ) ) ;
order _ type . get _ or _ add _ foreign _ key ( order _ fk , customer _ type . get _ primary _ key ( ) ) ;
order _ detail _ type . add _ navigation ( STR , product _ id _ fk , points _ to _ principal : true ) ; product _ type . add _ navigation ( STR , product _ id _ fk , points _ to _ principal : false ) ;
order _ type . add _ navigation ( STR , customer _ id _ fk , points _ to _ principal : true ) ; customer _ type . add _ navigation ( STR , customer _ id _ fk , points _ to _ principal : false ) ;
entity _ type . get _ or _ add _ foreign _ key ( new [ ] { fk } , entity _ type . get _ primary _ key ( ) ) ;
return new model _ builder ( create _ convention _ set ( ) , model ) ;
var dispatch _ args = create _ args (
property . builder . value _ generated ( value _ generated . never , configuration _ source . convention ) ;
i ,
new column _ expression ( foreign _ key _ property , target _ table _ expression ) , new column _ expression ( primary _ key _ property , inner _ join _ expression ) ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
await context . save _ changes _ async ( ) ; validator ( validation _ context ) ;
var model _ builder = new basic _ model _ builder ( new model ( ) ) ;
sql ) ;
sql ) ;
sql ) ;
sql ) ;
file . delete ( file _ name ) ;
if ( parameters [ index ] = = value )
if ( value is t _ enum enum _ value )
protected abstract i _ service _ collection configure _ design _ time _ services ( i _ service _ collection services ) ;
public virtual i _ service _ collection configure _ design _ time _ services ( [ not _ null ] i _ service _ collection services )
private i _ service _ collection configure _ provider _ services ( string provider , i _ service _ collection services , bool throw _ on _ error = false )
where [ g ] . [ discriminator ] in ( n ' officer ' , n ' gear ' ) and ( ( [ g . tag ] . [ note ] < > n ' foo ' ) or [ g . tag ] . [ note ] is null ) STR
= > new relational _ database _ dependencies ( batch _ preparer , batch _ executor , connection ) ;
= > new relational _ database _ dependencies ( batch _ preparer , batch _ executor , connection ) ;
= > new relational _ database _ dependencies ( batch _ preparer , batch _ executor , connection ) ;
= > new relational _ connection _ dependencies ( context _ options , logger , diagnostic _ source ) ;
= > new relational _ connection _ dependencies ( context _ options , logger , diagnostic _ source ) ;
= > new relational _ connection _ dependencies ( context _ options , logger , diagnostic _ source ) ;
} else { new _ right = right _ join ? . inner _ key _ selector ;
entity _ type ,
query _ context . start _ tracking ( entity , entity _ tracking _ infos [ i ] ) ;
query _ context . start _ tracking ( entity , entity _ tracking _ infos [ i ] ) ;
sql _ command _ builder . build ( STR ) . execute _ non _ query ( this ) ;
using microsoft _ extensions _ dependency _ injection _ extensions ;
using microsoft _ extensions _ caching _ memory ; using microsoft _ extensions _ dependency _ injection _ extensions ; using microsoft _ extensions _ logging ;
using microsoft _ extensions _ dependency _ injection _ extensions ;
using microsoft _ extensions _ dependency _ injection _ extensions ;
i _ read _ only _ dictionary < string , object > > ;
var expected _ count = 1 ;
var expected _ count = 1 ;
var expected _ count = 1 ;
var expected _ count = 1 ;
var expected _ count = 1 ;
var expected _ count = 1 ;
connection . open ( ) ;
connection . close ( ) ;
await connection . open _ async ( cancellation _ token ) ;
connection . close ( ) ;
var value _ generation _ strategy _ convention = new sql _ server _ value _ generation _ strategy _ convention ( dependencies ) ;
read _ only _ files . add ( file _ name ) ;
script _ path = path . combine ( app _ base , script _ path ) ;
script _ path = path . combine ( app _ base , script _ path ) ;
= > selector ( query _ context , shaper . shape ( query _ context , value _ buffer ) ) ;
if ( ordering _ expression is member _ expression member _ expression
if ( ordering _ expression is method _ call _ expression method _ call _ expression
var property = entity _ type . add _ property ( customer . id _ property ) ;
public virtual task detect _ changes _ async ( cancellation _ token cancellation _ token = default ( cancellation _ token ) )
} public virtual task detect _ changes _ async (
change _ detector . detect _ changes ( state _ manager ) ;
change _ detector . detect _ changes ( state _ manager ) ;
check _ disposed ( ) ;
check _ disposed ( ) ;
check _ disposed ( ) ;
check _ disposed ( ) ;
check _ disposed ( ) ;
columns ,
precision : precision , scale : scale ) )
query = extract _ parameters ( query , query _ context , logger ) ;
query = extract _ parameters ( query , query _ context _ factory . create ( ) , logger , parameterize : false ) ;
query = extract _ parameters ( query , query _ context , logger ) ;
assert . equal ( 1 , entity . get _ primary _ key ( ) . properties . count ) ;
assert . equal ( 1 , entity . get _ primary _ key ( ) . properties . count ) ;
assert . equal ( 1 , entity . get _ primary _ key ( ) . properties . count ) ;
using ( var connection = new sql _ server _ connection ( create _ configuration ( ) ) )
using ( var connection = new sql _ server _ connection ( create _ configuration ( ) ) )
assert . throws < invalid _ operation _ exception > ( ( ) = > new fake _ connection ( create _ configuration ( null ) ) ) . message ) ;
new fake _ database _ model _ factory ( ) , new fake _ scaffolding _ model _ factory ( new test _ operation _ reporter ( ) ) ,
var code _ gen _ model = new model ( ) ;
var level = result . single ( e = > e . name = = STR ) ;
var level = level . one _ to _ many _ optional . single ( e = > e . name = = STR ) ;
var level = result . single ( e = > e . name = = STR ) ;
var level = level . one _ to _ many _ optional . single ( e = > e . name = = STR ) ;
conditional _ fact
conditional _ fact
if ( underlying _ type = = typeof ( string ) )
if ( underlying _ type = = typeof ( int ) )
if ( underlying _ type = = typeof ( int ) )
if ( underlying _ type = = typeof ( double ) )
if ( underlying _ type = = typeof ( decimal ) )
if ( underlying _ type = = typeof ( date _ time ) )
if ( underlying _ type = = typeof ( date _ time _ offset ) )
if ( underlying _ type = = typeof ( single ) )
if ( underlying _ type = = typeof ( boolean ) )
if ( underlying _ type = = typeof ( byte ) )
if ( underlying _ type = = typeof ( u _ int ) )
if ( underlying _ type = = typeof ( u _ int ) )
if ( underlying _ type = = typeof ( int ) )
if ( underlying _ type = = typeof ( u _ int ) )
if ( underlying _ type = = typeof ( char ) )
if ( underlying _ type = = typeof ( s _ byte ) )
| | property . property _ type = = typeof ( uint ) | | property . property _ type = = typeof ( ulong ) | | property . property _ type = = typeof ( ushort ) | | property . property _ type = = typeof ( sbyte ) ) )
fact
fact
fact
fact
return date _ time . parse ( date , new culture _ info ( STR ) ) ;
interception _ result result ) ;
public interception _ result < db _ data _ reader > reader _ executing ( db _ command command , command _ event _ data event _ data , interception _ result < db _ data _ reader > result )
public interception _ result < object > scalar _ executing ( db _ command command , command _ event _ data event _ data , interception _ result < object > result )
public interception _ result < int > non _ query _ executing ( db _ command command , command _ event _ data event _ data , interception _ result < int > result )
public async task < interception _ result < int > > non _ query _ executing _ async ( db _ command command , command _ event _ data event _ data , interception _ result < int > result ,
interception _ result result )
interception _ result < db _ transaction > result )
public virtual task < interception _ result < db _ transaction > > transaction _ starting _ async ( db _ connection connection , transaction _ starting _ event _ data event _ data , interception _ result < db _ transaction > result ,
interception _ result result )
interception _ result result )
interception _ result result )
interception _ result < db _ transaction > result )
public override interception _ result transaction _ committing ( db _ transaction transaction , transaction _ event _ data event _ data , interception _ result result )
interception _ result < db _ transaction > result )
public override interception _ result < db _ data _ reader > reader _ executing ( db _ command command , command _ event _ data event _ data , interception _ result < db _ data _ reader > result )
public override interception _ result < object > scalar _ executing ( db _ command command , command _ event _ data event _ data , interception _ result < object > result )
public override interception _ result < int > non _ query _ executing ( db _ command command , command _ event _ data event _ data , interception _ result < int > result )
public override interception _ result < db _ data _ reader > reader _ executing ( db _ command command , command _ event _ data event _ data , interception _ result < db _ data _ reader > result )
public override task < interception _ result < db _ data _ reader > > reader _ executing _ async ( db _ command command , command _ event _ data event _ data , interception _ result < db _ data _ reader > result ,
public override interception _ result < object > scalar _ executing ( db _ command command , command _ event _ data event _ data , interception _ result < object > result )
public override task < interception _ result < object > > scalar _ executing _ async ( db _ command command , command _ event _ data event _ data , interception _ result < object > result ,
public override interception _ result < int > non _ query _ executing ( db _ command command , command _ event _ data event _ data , interception _ result < int > result )
public override task < interception _ result < int > > non _ query _ executing _ async ( db _ command command , command _ event _ data event _ data , interception _ result < int > result ,
public override interception _ result < db _ data _ reader > reader _ executing ( db _ command command , command _ event _ data event _ data , interception _ result < db _ data _ reader > result )
public override interception _ result < object > scalar _ executing ( db _ command command , command _ event _ data event _ data , interception _ result < object > result )
public override interception _ result < int > non _ query _ executing ( db _ command command , command _ event _ data event _ data , interception _ result < int > result )
public override interception _ result < db _ data _ reader > reader _ executing ( db _ command command , command _ event _ data event _ data , interception _ result < db _ data _ reader > result )
public override task < interception _ result < db _ data _ reader > > reader _ executing _ async ( db _ command command , command _ event _ data event _ data , interception _ result < db _ data _ reader > result ,
public override interception _ result < object > scalar _ executing ( db _ command command , command _ event _ data event _ data , interception _ result < object > result )
public override task < interception _ result < object > > scalar _ executing _ async ( db _ command command , command _ event _ data event _ data , interception _ result < object > result ,
public override interception _ result < int > non _ query _ executing ( db _ command command , command _ event _ data event _ data , interception _ result < int > result )
public override task < interception _ result < int > > non _ query _ executing _ async ( db _ command command , command _ event _ data event _ data , interception _ result < int > result ,
public virtual interception _ result < db _ data _ reader > reader _ executing ( db _ command command , command _ event _ data event _ data , interception _ result < db _ data _ reader > result )
public virtual interception _ result < object > scalar _ executing ( db _ command command , command _ event _ data event _ data , interception _ result < object > result )
public virtual interception _ result < int > non _ query _ executing ( db _ command command , command _ event _ data event _ data , interception _ result < int > result )
public virtual task < interception _ result < db _ data _ reader > > reader _ executing _ async ( db _ command command , command _ event _ data event _ data , interception _ result < db _ data _ reader > result ,
public virtual task < interception _ result < object > > scalar _ executing _ async ( db _ command command , command _ event _ data event _ data , interception _ result < object > result ,
public virtual task < interception _ result < int > > non _ query _ executing _ async ( db _ command command , command _ event _ data event _ data , interception _ result < int > result ,
interception _ result result )
interception _ result result ) ;
interception _ result result ) ;
interception _ result result ) ;
interception _ result result )
interception _ result result )
interception _ result result )
interception _ result result )
interception _ result < db _ transaction > result )
public override interception _ result connection _ opening ( db _ connection connection , connection _ event _ data event _ data , interception _ result result )
public virtual interception _ result connection _ opening ( db _ connection connection , connection _ event _ data event _ data , interception _ result result )
public virtual task < interception _ result > connection _ opening _ async ( db _ connection connection , connection _ event _ data event _ data , interception _ result result ,
public virtual interception _ result connection _ closing ( db _ connection connection , connection _ event _ data event _ data , interception _ result result )
public virtual task < interception _ result > connection _ closing _ async ( db _ connection connection , connection _ event _ data event _ data , interception _ result result )
interception _ result < db _ transaction > result ) ;
result = db _ command . execute _ non _ query ( ) ;
result = db _ command . execute _ scalar ( ) ;
result = await db _ command . execute _ non _ query _ async ( cancellation _ token ) ;
result = await db _ command . execute _ scalar _ async ( cancellation _ token ) ;
where [ g ] . [ discriminator ] in ( n ' gear ' , n ' officer ' ) and ( ( [ g ] . [ has _ soul _ patch ] = cast ( 1 as bit ) ) and ( (
where [ g ] . [ discriminator ] in ( n ' gear ' , n ' officer ' ) and ( ( [ g ] . [ has _ soul _ patch ] = cast ( 1 as bit ) ) and ( (
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ fact
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
new logging _ options ( ) , new diagnostic _ listener ( STR ) ) , new diagnostics _ logger < logger _ category . database . connection > (
args [ 0 ] = test _ logger ;
protected internal virtual void generate _ sequence _ presence _ check ( schema _ qualified _ name sequence _ name , bool negative )
namespace system _ text
using microsoft _ data _ entity _ metadata ;
public virtual database build ( [ not _ null ] i _ model model )
private static void build _ table ( database database , i _ entity _ type entity _ type )
private static void build _ column ( table table , i _ property property )
private static void build _ primary _ key ( database database , i _ key primary _ key )
private static void build _ foreign _ key ( database database , i _ foreign _ key foreign _ key )
using microsoft _ data _ entity _ metadata ;
using microsoft _ data _ entity _ metadata ;
private static i _ model create _ model ( )
= > new bad _ data _ relational _ data _ reader ( values ) ;
statement _ executor . execute _ non _ query ( connection , connection . db _ transaction , create _ schema _ commands ( model ) ) ;
return ( int ) statement _ executor . execute _ scalar ( connection , connection . db _ transaction , create _ has _ tables _ command ( ) ) ! = 0 ;
conditional _ fact
conditional _ fact
conditional _ fact
conditional _ fact
conditional _ fact
conditional _ fact
using ( context . database . begin _ transaction ( ) )
public virtual internal _ entity _ entry propagate _ value ( internal _ entity _ entry entry , i _ property property )
private static internal _ entity _ entry try _ propagate _ value ( internal _ entity _ entry entry , i _ property property )
internal _ entity _ entry propagate _ value ( [ not _ null ] internal _ entity _ entry entry , [ not _ null ] i _ property property ) ;
public virtual internal _ entity _ entry propagate ( internal _ entity _ entry entry )
= > time _ span . parse ( get _ string ( ordinal ) ) ;
assert . equal ( NUM , result . count ) ;
typeof ( startup _ invoker _ test ) . get _ type _ info ( ) . assembly ,
typeof ( startup _ invoker _ test ) . get _ type _ info ( ) . assembly ,
typeof ( startup _ invoker _ test ) . get _ type _ info ( ) . assembly ,
typeof ( startup _ invoker _ test ) . get _ type _ info ( ) . assembly ,
typeof ( startup _ invoker _ test ) . get _ type _ info ( ) . assembly ,
assert . equal ( STR , generate _ data _ type ( column ) ) ;
assert _ results (
assert _ results (
assert _ results (
assert _ results (
assert _ results (
assert _ results (
assert _ results (
assert _ results (
on _ type _ member _ ignored ( name ) ;
return convention _ dispatcher . on _ entity _ type _ added ( entity _ type . builder ) ? . metadata ;
convention _ dispatcher . on _ entity _ type _ ignored ( builder , name , type ) ;
configuration _ source configuration _ source = configuration _ source . explicit ) = > navigation ( property _ identity . create ( name ) , configuration _ source , points _ to _ principal : true ) ;
configuration _ source configuration _ source = configuration _ source . explicit ) = > navigation ( property _ identity . create ( name ) , configuration _ source , points _ to _ principal : false ) ;
model . convention _ dispatcher . on _ index _ removed ( builder , index ) ;
builder = model _ builder . metadata . convention _ dispatcher . on _ principal _ end _ set ( builder ) ;
builder = model _ builder . metadata . convention _ dispatcher . on _ principal _ end _ set ( builder ) ;
builder = model _ builder . metadata . convention _ dispatcher . on _ principal _ end _ set ( builder ) ;
property . builder ? . attach ( this ) ;
list < internal _ index _ builder > detached _ indexes = null ;
detached _ indexes = new list < internal _ index _ builder > ( ) ;
private static internal _ index _ builder detach _ index ( index index _ to _ detach )
return index _ builder ;
internal class tracking _ grouping < t _ key , t _ out , t _ in > : i _ grouping < t _ key , t _ out >
query _ context . query _ buffer . start _ tracking ( entity , entity _ tracking _ infos [ i ] ) ;
builder . has _ key ( property _ names ) . has _ name ( index . name ) ;
conditional _ fact
) as [ t ] on [ ] . [ customer _ id ] = [ t ] . [ customer _ id ] where [ t ] . [ order _ id ] > NUM group by [ t ] . [ customer _ id ] STR
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
= > visit ( apply _ optimizations ( projection , search _ condition : false ) ) ;
when [ w ] . [ is _ automatic ] = cast ( 0 as bit ) then cast ( 1 as bit ) else cast ( 0 as bit )
) , cast ( 0 as bit ) ) = cast ( 1 as bit ) then cast ( 1 as bit ) else cast ( 0 as bit ) end = cast ( 1 as bit ) then cast ( 1 as bit ) else cast ( 0 as bit ) end = cast ( 1 as bit ) then cast ( 1 as bit ) else cast ( 0 as bit )
private string debugger _ display = > get _ primary _ key _ value ( ) + STR + entity _ state ;
assert . same ( fk , order _ type . remove _ foreign _ key ( fk ) ) ; assert . null ( order _ type . remove _ foreign _ key ( fk ) ) ;
assert . throws < invalid _ operation _ exception > ( ( ) = > order _ type . remove _ foreign _ key ( fk ) ) . message ) ;
var is _ principal _ key _ referenced = principal _ pk ! = null & & principal _ pk . find _ referencing _ foreign _ keys ( ) . count ( ) > principal _ pk _ reference _ threshold ;
var is _ dependent _ primary _ key _ referenced = dependent _ pk ! = null & & dependent _ pk . find _ referencing _ foreign _ keys ( ) . any ( ) ;
return new completed _ async _ enumerator ( enumerable . get _ enumerator ( ) ) ;
public virtual book _ detail book _ detail { get ; set ; }
public virtual useless _ book _ details useless _ book _ details { get ; set ; }
= replace _ clause _ references ( join _ clause . outer _ key _ selector , join _ clause ) ;
= replace _ clause _ references ( join _ clause . inner _ sequence , join _ clause ) ;
= replace _ clause _ references ( group _ join _ clause . join _ clause . outer _ key _ selector , group _ join _ clause ) ;
= replace _ clause _ references ( group _ join _ clause . join _ clause . inner _ sequence , group _ join _ clause . join _ clause ) ;
if ( is _ empty )
debug . assert ( ! is _ empty ) ; var index = property . get _ original _ value _ index ( ) ;
if ( is _ empty )
if ( is _ empty )
entry . ensure _ original _ values ( ) ;
return new relational _ query _ model _ visitor ( this ) ;
public class db _ set < t _ entity > : i _ ordered _ queryable < t _ entity > , i _ async _ enumerable _ accessor < t _ entity >
conditional _ theory
conditional _ theory
conditional _ fact
conditional _ fact
conditional _ fact
conditional _ fact
conditional _ fact
conditional _ fact
conditional _ fact
conditional _ fact
conditional _ fact
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ fact
conditional _ fact
conditional _ fact
conditional _ fact
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ fact
conditional _ fact
conditional _ fact
conditional _ fact
public int get _ value _ buffer _ index ( [ not _ null ] i _ property _ base property ) = > property . get _ index ( ) ;
where [ g ] . [ discriminator ] in ( n ' gear ' , n ' officer ' ) and ( ( [ g ] . [ rank ] | 1 ) > 0 ) STR
where [ g ] . [ discriminator ] in ( n ' gear ' , n ' officer ' ) and ( ( [ g ] . [ rank ] & 1 ) = 1 ) STR
where [ g ] . [ discriminator ] in ( n ' gear ' , n ' officer ' ) and ( ( 1 & [ g ] . [ rank ] ) = [ g ] . [ rank ] ) STR
where [ g ] . [ discriminator ] in ( n ' gear ' , n ' officer ' )
where [ g ] . [ discriminator ] in ( n ' gear ' , n ' officer ' ) and ( [ g ] . [ has _ soul _ patch ] = cast ( 1 as bit ) )
where [ g ] . [ discriminator ] in ( n ' gear ' , n ' officer ' ) and ( ( [ g ] . [ full _ name ] < > n ' dom ' ) and (
create _ schema _ commands ( ) ) ; public override async task create _ tables _ async ( cancellation _ token cancellation _ token = default ( cancellation _ token ) )
create _ schema _ commands ( ) ,
if ( ! remove ( property , configuration _ source , can _ override _ same _ source : false ) )
b . key ( customer . id _ property . name ) ;
if ( ( left _ expressions ! = null ) & & ( right _ constant _ expression ! = null ) & & ( right _ constant _ expression . value = = null ) )
if ( ( right _ expressions ! = null ) & & ( left _ constant _ expression ! = null ) & & ( left _ constant _ expression . value = = null ) )
if ( ( query _ source _ reference _ expression = = null ) | | in _ projection | | ! query _ model _ visitor . query _ compilation _ context . query _ source _ requires _ materialization ( query _ source _ reference _ expression . referenced _ query _ source ) )
private readonly dictionary < type , object > entity _ sorters ; private readonly dictionary < type , object > entity _ asserters ;
var expected = expected _ query ( expected _ data ) . to _ array ( ) ;
var expected = expected _ query ( expected _ data ) . to _ array ( ) ;
private readonly dictionary < type , object > entity _ sorters ; private readonly dictionary < type , object > entity _ asserters ;
entity _ sorters = entity _ sorters ? ? new dictionary < type , object > ( ) ; entity _ asserters = entity _ asserters ? ? new dictionary < type , object > ( ) ;
assert . equal ( expected _ message ( default _ options ) , actual _ message ( create _ options _ builder ) ) ;
benchmark
benchmark
: base ( STR , 0 , 0 , 0 , 0 )
: base ( STR , 0 , 0 , 0 , 0 )
benchmark
benchmark
public virtual t _ entity find ( [ can _ be _ null ] params object [ ] key _ values ) = > throw new not _ implemented _ exception ( ) ;
public virtual task < t _ entity > find _ async ( [ can _ be _ null ] params object [ ] key _ values ) = > throw new not _ implemented _ exception ( ) ;
public virtual task < t _ entity > find _ async ( [ can _ be _ null ] object [ ] key _ values , cancellation _ token cancellation _ token )
public virtual value _ converter converter = > parameters . converter ;
public static t _ related load < t _ related > ( can _ be _ null this i _ lazy _ loader loader ,
public virtual t _ entity find ( object [ ] key _ values )
public virtual task < t _ entity > find _ async ( object [ ] key _ values , cancellation _ token cancellation _ token = default )
public virtual converter _ mapping _ hints with ( [ can _ be _ null ] converter _ mapping _ hints hints )
? ( action < i _ service _ provider , db _ context _ options _ builder > ) null
? ( object ) null
new t _ entity find ( [ can _ be _ null ] object [ ] key _ values ) ;
task < object > find _ async ( [ can _ be _ null ] object [ ] key _ values , cancellation _ token cancellation _ token = default ) ;
public virtual object find ( [ not _ null ] type entity _ type , [ can _ be _ null ] params object [ ] key _ values )
public virtual task < object > find _ async ( [ not _ null ] type entity _ type , [ can _ be _ null ] params object [ ] key _ values )
public virtual task < object > find _ async ( [ not _ null ] type entity _ type , [ can _ be _ null ] object [ ] key _ values , cancellation _ token cancellation _ token )
public virtual t _ entity find < t _ entity > ( [ can _ be _ null ] params object [ ] key _ values )
public virtual task < t _ entity > find _ async < t _ entity > ( [ can _ be _ null ] params object [ ] key _ values )
public virtual task < t _ entity > find _ async < t _ entity > ( [ can _ be _ null ] object [ ] key _ values , cancellation _ token cancellation _ token )
public override t _ entity find ( params object [ ] key _ values )
public override task < t _ entity > find _ async ( params object [ ] key _ values )
public override task < t _ entity > find _ async ( object [ ] key _ values , cancellation _ token cancellation _ token )
func < type , type , i _ enumerable < value _ converter _ info > > after _ preferred )
var field _ info = get _ field _ info ( field _ name , declaring _ type , name , should _ throw : true ) ;
break ;
& & ! can _ merge _ with ( existing _ navigation , inverse _ property _ info , target _ entity _ type _ builder ) )
| | ! can _ merge _ with ( existing _ inverse , navigation _ property , entity _ type _ builder ) )
dependent _ properties . format ( ) ,
dependent _ properties . format ( ) ,
key . properties . format ( ) ,
key . properties . format ( ) ,
throw new invalid _ operation _ exception ( core _ strings . keyless _ type _ with _ key ( properties . format ( ) , this . display _ name ( ) ) ) ;
throw new invalid _ operation _ exception ( core _ strings . duplicate _ property _ in _ list ( properties . format ( ) , property . name ) ) ;
throw new invalid _ operation _ exception ( core _ strings . key _ properties _ wrong _ entity ( properties . format ( ) , this . display _ name ( ) ) ) ;
throw new invalid _ operation _ exception ( core _ strings . duplicate _ property _ in _ list ( properties . format ( ) , property . name ) ) ;
throw new invalid _ operation _ exception ( core _ strings . foreign _ key _ properties _ wrong _ entity ( properties . format ( ) , this . display _ name ( ) ) ) ;
properties . format ( ) ,
throw new invalid _ operation _ exception ( core _ strings . duplicate _ property _ in _ list ( properties . format ( ) , property . name ) ) ;
throw new invalid _ operation _ exception ( core _ strings . index _ properties _ wrong _ entity ( properties . format ( ) , this . display _ name ( ) ) ) ;
throw new invalid _ operation _ exception ( core _ strings . duplicate _ index ( properties . format ( ) , this . display _ name ( ) , duplicate _ index . declaring _ entity _ type . display _ name ( ) ) ) ;
core _ strings . property _ in _ use _ key ( property . name , this . display _ name ( ) , containing _ key . properties . format ( ) ) ) ;
index . properties . format ( ) ,
index . properties . format ( ) ,
foreign _ key . properties . format ( ) ,
foreign _ key . properties . format ( ) ,
foreign _ key . properties . format ( ) ,
foreign _ key . properties . format ( ) ,
foreign _ key . properties . format ( ) ,
= > ( property _ access _ mode ? ) check . not _ null ( type _ base , nameof ( type _ base ) ) [ core _ annotation _ names . property _ access _ mode ]
p . first _ property _ collection . format ( ) ,
key . properties . format ( ) ,
foreign _ key . properties . format ( ) ) ) ;
referencing _ foreign _ key . properties . format ( ) ,
using ( var executor = new app _ domain _ operation _ executor ( assembly . get _ executing _ assembly ( ) . location , path . combine ( target _ dir , STR ) , target _ dir , null , null , null ) )
return STR ;
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ fact
conditional _ fact
conditional _ fact
conditional _ fact
conditional _ theory
conditional _ theory
conditional _ fact
conditional _ fact
conditional _ theory
conditional _ fact
conditional _ fact
conditional _ fact
conditional _ fact
conditional _ fact
conditional _ fact
conditional _ fact
private readonly func < query _ context , value _ buffer , t > shaper ;
func < query _ context , value _ buffer , t > shaper ,
private readonly func < query _ context , value _ buffer , t > shaper ;
func < query _ context , value _ buffer , t > shaper ,
predicate = expression . greater _ than ( column _ expression , offset ) ;
final _ identifier = proposed _ identifier + suffix ;
return new default _ expression _ or _ value
return new default _ expression _ or _ value
return new default _ expression _ or _ value
return new default _ expression _ or _ value
return new default _ expression _ or _ value
return new compiled _ assembly _ result
return new compiled _ assembly _ result
return field _ info . get _ value ( object ) ;
public new virtual string column
public new virtual string column _ type
return new template _ result
return new template _ result
return new template _ result
private readonly list < i _ member _ translator > sqlite _ translators = new list < i _ member _ translator >
private readonly list < i _ method _ call _ translator > sqlite _ translators = new list < i _ method _ call _ translator >
private static event _ id make _ update _ id ( id id ) = > new event _ id ( ( int ) id , update _ prefix + id ) ;
private static event _ id make _ query _ id ( id id ) = > new event _ id ( ( int ) id , query _ prefix + id ) ;
private static event _ id make _ validation _ id ( id id ) = > new event _ id ( ( int ) id , validation _ prefix + id ) ;
private static event _ id make _ scaffolding _ id ( id id ) = > new event _ id ( ( int ) id , scaffolding _ prefix + id ) ;
private static event _ id make _ connection _ id ( id id ) = > new event _ id ( ( int ) id , connection _ prefix + id ) ;
private static event _ id make _ command _ id ( id id ) = > new event _ id ( ( int ) id , sql _ prefix + id ) ;
private static event _ id make _ transaction _ id ( id id ) = > new event _ id ( ( int ) id , transaction _ prefix + id ) ;
private static event _ id make _ migrations _ id ( id id ) = > new event _ id ( ( int ) id , migrations _ prefix + id ) ;
private static event _ id make _ query _ id ( id id ) = > new event _ id ( ( int ) id , query _ prefix + id ) ;
private static event _ id make _ validation _ id ( id id ) = > new event _ id ( ( int ) id , validation _ prefix + id ) ;
private static event _ id make _ validation _ id ( id id ) = > new event _ id ( ( int ) id , validation _ prefix + id ) ;
private static event _ id make _ scaffolding _ id ( id id ) = > new event _ id ( ( int ) id , scaffolding _ prefix + id ) ;
private static event _ id make _ transaction _ id ( id id ) = > new event _ id ( ( int ) id , transaction _ prefix + id ) ;
private static event _ id make _ update _ id ( id id ) = > new event _ id ( ( int ) id , update _ prefix + id ) ;
fk . table . name , fk . name ,
left join STR customers STR as STR c STR on STR o STR . STR customer _ id STR = STR c STR . STR customer _ id STR
left join STR customers STR as STR c STR on STR o STR . STR customer _ id STR = STR c STR . STR customer _ id STR
left join STR customers STR as STR c STR on STR o STR . STR customer _ id STR = STR c STR . STR customer _ id STR
left join [ customers ] as [ c ] on [ o ] . [ customer _ id ] = [ c ] . [ customer _ id ]
left join [ customers ] as [ c ] on [ o ] . [ customer _ id ] = [ c ] . [ customer _ id ]
conditional _ fact
conditional _ fact
) as [ ] on [ o ] . [ customer _ id ] = [ ] . [ customer _ id ]
var target _ table _ alias = target _ table _ name . first ( ) . to _ string ( ) . to _ lower ( ) ;
key _ properties [ i ] = entity _ type . get _ or _ add _ property ( STR + ( starting _ property _ index + i ) , typeof ( int? ) ) ;
base _ entity _ type . relational ( ) . discriminator _ property = base _ entity _ type . get _ or _ add _ property ( STR , typeof ( string ) ) ;
fact
fact
fact
fact
fact
fact
fact
fact
fact
fact
fact
& & is _ compatible _ sequence _ hi _ lo ( property ) )
& & is _ compatible _ identity _ column ( property ) )
& & is _ compatible _ sequence _ hi _ lo ( property ) )
& & is _ compatible _ identity _ column ( property ) )
b . service _ collection . add _ singleton < fake _ service > ( ) ; b . service _ collection . add _ instance ( service _ instance ) ;
b . service _ collection . add _ singleton < fake _ service > ( ) ; b . service _ collection . add _ instance ( service _ instance ) ;
b . service _ collection . add _ singleton < fake _ service > ( ) ; b . service _ collection . add _ instance ( new fake _ service ( ) ) ;
b . service _ collection . add _ singleton < fake _ service > ( ) ; b . service _ collection . add _ instance ( new fake _ service ( ) ) ;
b . service _ collection . add _ singleton < fake _ service > ( ) ; b . service _ collection . add _ instance ( service _ instance ) ;
b . service _ collection . add _ singleton < fake _ service > ( ) ; b . service _ collection . add _ instance ( service _ instance ) ;
b . service _ collection . add _ singleton < fake _ service > ( ) ; b . service _ collection . add _ instance ( service _ instance ) ;
b . service _ collection . add _ scoped < fake _ service > ( ) ; b . service _ collection . add _ instance ( service _ instance ) ;
b . service _ collection . add _ singleton < fake _ service > ( ) ; b . service _ collection . add _ instance ( service _ instance ) ;
b . service _ collection . add _ singleton < fake _ service > ( ) ; b . service _ collection . add _ instance ( service _ instance ) ;
builder . service _ collection . add _ instance ( model _ source ) ;
builder . service _ collection . add _ instance ( initializer ) ;
builder . service _ collection . add _ instance ( factory ) ;
builder . service _ collection . add _ instance ( generators ) ;
builder . service _ collection . add _ instance ( finder ) ;
builder . service _ collection . add _ instance ( source ) ;
builder . service _ collection . add _ instance ( source ) ;
builder . service _ collection . add _ instance ( source ) ;
builder . service _ collection . add _ instance ( source ) ;
builder . service _ collection . add _ instance ( source ) ;
builder . service _ collection . add _ instance ( factory ) ;
fact
i _ logger _ factory logger _ factory ; i _ memory _ cache memory _ cache ;
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
isolation _ level isolation _ level , cancellation _ token cancellation _ token = default ) = > throw new not _ implemented _ exception ( ) ;
new [ ] { polygon , polygon } ) { srid = NUM } ;
new [ ] { polygon , polygon } ) { srid = NUM } ;
public task < bool > close _ async ( ) = > task . from _ result ( true ) ;
public i _ db _ context _ transaction begin _ transaction ( isolation _ level isolation _ level ) = > throw new not _ implemented _ exception ( ) ;
isolation _ level isolation _ level , cancellation _ token cancellation _ token = default ) = > throw new not _ implemented _ exception ( ) ;
public static session _ response map _ session _ response ( this session session ) = > new session _ response
model _ builder . entity < full _ notification _ entity > (
model _ builder . entity < changed _ only _ entity > (
model _ builder . entity < owner _ class > (
public async task < attendee _ response > get ( string username )
public async task < list < session _ response > > get _ sessions ( string username )
public async task < attendee _ response > post ( attendee input )
new search _ term { query = search _ term } ) ;
public async task < list < session _ response > > get ( )
public async task < session _ response > get ( int id )
public async task < list < speaker _ response > > get _ speakers ( )
public async task < speaker _ response > get _ speaker ( int id )
public class database _ error _ page : base _ view
public database _ error _ page _ model model { get ; set ; }
var query _ model _ visitor = create _ querying _ expression _ tree _ visitor ( query _ source _ mock . object ) ; assert . is _ type < redis _ querying _ expression _ tree _ visitor > ( query _ model _ visitor ) ;
options . use _ azure _ table _ storage ( connection _ string , false ) ;
options . use _ azure _ table _ storage ( STR , true ) ;
assert . throws < argument _ exception > ( ( ) = > options . use _ azure _ table _ storage ( name , key ) ) . message
assert . throws < argument _ exception > ( ( ) = > options . use _ azure _ table _ storage ( STR ) ) . message
public batch _ executor _ for _ test ( ) : base ( new logger _ factory ( ) )
return command _ builder . build _ relational _ command ( ) . create _ command ( connection ) ;
if ( ! batch . add _ command ( modification _ command ) )
batch = modification _ command _ batch _ factory . create ( ) ; batch . add _ command ( modification _ command ) ;
name , schema ) ;
where ( [ e ] . [ nullable _ string _ a ] not in ( ' foo ' ) and [ e ] . [ nullable _ string _ a ] is not null ) STR
where ( [ e ] . [ nullable _ string _ a ] in ( ' foo ' ) or [ e ] . [ nullable _ string _ a ] is null ) STR
where ( [ e ] . [ nullable _ string _ a ] in ( ' foo ' ) or [ e ] . [ nullable _ string _ a ] is null ) STR
foreach ( var entity _ type in entity _ types )
= > new sql _ server _ string _ type _ mapping ( parameters . with _ store _ type _ and _ size ( store _ type , size ) ) ;
public virtual string sql { get ; } public virtual bool suppress _ transaction { get ; set ; }
connection _ mock . protected ( ) . verify ( STR , times . once ( ) , true ) ;
connection _ mock . protected ( ) . verify ( STR , times . never ( ) , true ) ;
connection _ mock . protected ( ) . verify ( STR , times . never ( ) , true ) ;
predicate ) ;
predicate ) ; }
predicate ) ;
predicate ) ;
predicate ) ;
count ) ;
count ) ;
predicate ) ;
public class change _ tracker : i _ resettable _ service
public class inheritance _ relationships _ query _ sqlite _ fixture : inheritance _ relationships _ query _ relational _ fixture
public abstract class inheritance _ relational _ fixture : inheritance _ fixture _ base
public class funky _ data _ query _ sql _ server _ fixture : funky _ data _ query _ fixture _ base
public class complex _ navigations _ owned _ query _ sql _ server _ fixture : complex _ navigations _ owned _ query _ relational _ fixture _ base
public class complex _ navigations _ owned _ query _ sqlite _ fixture : complex _ navigations _ owned _ query _ relational _ fixture _ base
public class inheritance _ sqlite _ fixture : inheritance _ relational _ fixture
public class gears _ of _ war _ query _ sqlite _ fixture : gears _ of _ war _ query _ relational _ fixture
public class inheritance _ sql _ server _ fixture : inheritance _ relational _ fixture
public abstract class complex _ navigations _ owned _ query _ fixture _ base : complex _ navigations _ query _ fixture _ base
public class inheritance _ relationships _ query _ sql _ server _ fixture : inheritance _ relationships _ query _ relational _ fixture
public abstract class inheritance _ relationships _ query _ relational _ fixture : inheritance _ relationships _ query _ fixture _ base
public class gears _ of _ war _ query _ sql _ server _ fixture : gears _ of _ war _ query _ relational _ fixture
public class funky _ data _ query _ sqlite _ fixture : funky _ data _ query _ fixture _ base
public abstract class complex _ navigations _ owned _ query _ relational _ fixture _ base : complex _ navigations _ owned _ query _ fixture _ base
public interface i _ identity _ generator
return model ;
return model ;
public class database : i _ accessor < i _ service _ provider >
public class sql _ server _ value _ generation _ strategy _ convention : i _ model _ convention
namespace microsoft _ data _ entity _ metadata _ conventions _ tests
default _ hints . with ( mapping _ hints ) )
default _ hints . with ( mapping _ hints ) )
default _ hints . with ( mapping _ hints ) )
default _ hints . with ( mapping _ hints ) )
default _ hints . with ( mapping _ hints ) )
mapping _ hints )
default _ hints . with ( mapping _ hints ) )
default _ hints . with ( mapping _ hints ) )
default _ hints . with ( mapping _ hints ) )
select [ o ] . [ order _ id ] , [ o ] . [ customer _ id ] , [ o ] . [ order _ date ]
public relational _ decimal _ type _ mapping ( byte precision , byte scale ) : base ( STR + precision + STR + scale + STR , db _ type . decimal )
return row _ version _ mapping ;
public virtual annotations annotations
state _ manager . save _ changes _ async ( ) . wait ( ) ;
logger . log _ error ( STR , name . name ) ; add . show _ help ( ) ;
execute (
return expression . lambda ( materializer , materialization _ context _ parameter ) ;
logger . missing _ schema _ warning ( schema _ selection . text ) ;
logger . missing _ table _ warning ( table _ selection . text ) ;
logger . missing _ primary _ key _ warning ( table . display _ name ) ;
model ,
not _ null i _ requires _ materialization _ expression _ visitor _ factory requires _ materialization _ expression _ visitor _ factory ) = > new query _ compilation _ context _ dependencies ( model , logger , entity _ query _ model _ visitor _ factory , requires _ materialization _ expression _ visitor _ factory , current _ context ) ;
schema _ filters , table _ filters , use _ data _ annotations , overwrite _ files ) . result ;
sql _ select ,
sql _ select ,
conditional _ fact
conditional _ fact
conditional _ fact
pending _ collection _ joins . add ( inner _ select _ expression ) ;
return visit ( expression ) ;
entity _ key _ factory _ source , entity _ materializer _ source ,
= > database _ facade . create _ execution _ strategy ( ) . execute ( database _ facade , database = > database . get _ relational _ service < i _ relational _ connection > ( ) . open ( ) ) ;
= > database _ facade . create _ execution _ strategy ( ) . execute _ async ( database _ facade , ( database , ct ) = > database . get _ relational _ service < i _ relational _ connection > ( ) . open _ async ( cancellation _ token ) , cancellation _ token ) ;
return strategy . execute _ async ( operation , ( operation _ scoped , ct ) = > operation _ scoped ( ) , default ( cancellation _ token ) ) ;
not _ null func < t _ state , cancellation _ token , task < bool > > verify _ succeeded ,
= > dependencies . execution _ strategy _ factory . create ( ) . execute ( connection , connection = > ( int ) create _ has _ tables _ command ( ) . execute _ scalar ( connection ) ! = 0 ) ;
context ,
context ,
public virtual foreign _ key add _ foreign _ key ( [ not _ null ] foreign _ key foreign _ key )
assert . throws < argument _ null _ exception > ( ( ) = > new entity _ entry ( null ) ) . param _ name ) ;
namespace microsoft _ data _ entity _ metadata _ tests
namespace microsoft _ data _ entity _ metadata _ tests
internal _ entry [ value . key ] = value . value ;
extension = extension . with _ store _ name ( database _ name ) ;
public class sql _ server _ value _ generation _ strategy _ convention : i _ model _ convention
conditional _ fact
conditional _ fact
conditional _ theory
conditional _ theory
| | ! configuration _ source . value . overrides ( ignored _ configuration _ source ) ;
foreach ( var detached _ relationship _ tuple in relationships )
conditional _ fact
conditional _ fact
) as [ ] order by [ t ] . [ order _ id ] STR
from [ carts ] as [ c ] left join [ configuration ] as [ ] on [ c ] . [ configuration _ id ] = [ ] . [ id ] STR
return column _ expression ;
) as [ ] on [ t ] . [ customer _ id ] = [ ] . [ customer _ id ] group by [ ] . [ customer _ id ] STR
foreach ( var property in entity _ type . get _ properties ( ) ) {
public virtual bool is _ unique ( bool is _ unique , configuration _ source configuration _ source )
unknown _ literal ( value ) ;
new [ ]
new [ ]
benchmark
benchmark
return constructor _ expression ;
protected model create _ model ( )
var model = new model ( ) ;
conditional _ fact
conditional _ fact
public abstract task execute _ async (
commandbatch . execute (
( property , sql _ select )
( property , sql _ select )
( property , sql _ select )
public readonly struct interception _ result
where [ e ] . [ customer _ id ] like n 'A' + n '%' and ( left ( [ e ] . [ customer _ id ] , len ( n 'A' ) ) = n 'A' )
when [ c ] . [ customer _ id ] like n 'S' + n '%' and ( left ( [ c ] . [ customer _ id ] , len ( n 'S' ) ) = n 'S' )
public class ats _ batched _ data _ store _ tests : i _ class _ fixture < mock < ats _ connection > >
public class ats _ data _ store _ tests : i _ class _ fixture < mock < ats _ connection > >
target _ entry . set _ original _ value ( target _ property , target _ property . clr _ type . get _ default _ value ( ) ) ;
return ( bits [ property _ index / bits _ per _ int ] & ( 1 < < ( property _ index % bits _ per _ int ) ) ) ! = 0 ;
if ( ( existing _ navigation ! = null ) & & ! can _ merge _ with ( existing _ navigation , inverse _ property _ info . name , target _ entity _ type _ builder ) )
if ( ( constant _ expression = = null ) | | ( constant _ expression . value is i _ enumerable & & ( constant _ expression . type ! = typeof ( string ) ) & & ( constant _ expression . type ! = typeof ( byte [ ] ) ) ) )
namespace microsoft _ entity _ framework _ core _ infrastructure _ tests
derived _ dependent _ entity _ builder . relationship (
check . not _ null ( query , nameof ( query ) ) ,
throw new invalid _ operation _ exception ( core _ strings . navigation _ collection _ wrong _ clr _ type ( navigation _ property . name , source _ clr _ type . name , navigation _ property . property _ type . full _ name , target _ clr _ type . full _ name ) ) ;
navigation _ property . name , source _ clr _ type . name , navigation _ property . property _ type . full _ name , target _ clr _ type . full _ name ) ) ;
using ( var transaction = await context . database . begin _ transaction _ async ( ) )
using ( var transaction = context . database . begin _ transaction ( ) )
using ( var transaction = await context . database . begin _ transaction _ async ( ) )
using ( context . database . begin _ transaction ( ) )
context . database . use _ transaction ( transaction ) ) ;
assert _ query < order _ detail , order > (
assert _ query < customer , order > (
conditional _ fact
expression left , expression right , expression left _ is _ null , expression right _ is _ null ) = > new not _ nullable _ expression ( expression . or _ else (
expression left , expression right , expression left _ is _ null , expression right _ is _ null ) = > new not _ nullable _ expression ( expression . and _ also (
expression left , expression right , expression left _ is _ null , expression right _ is _ null ) = > new not _ nullable _ expression ( expression . and _ also (
private i _ read _ only _ list < column _ modification > column _ modifications ;
return create _ sql _ generator ( database ) . generate ( migration _ operation ) ;
return create _ sql _ generator ( database ) . generate ( migration _ operation ) ;
command _ builder ,
command _ builder ,
command _ builder ,
command _ builder ,
using microsoft _ entity _ framework _ core _ diagnostics ;
opened _ count + + ;
public virtual async task group _ by _ with _ aggregate _ function _ by _ navigation _ property ( )
using ( var context = new early _ learning _ center ( in _ memory _ test _ helpers . instance . create _ service _ provider ( ) ) ) { var entity = new category { id = 1 , name = STR } ;
using ( var context = new early _ learning _ center ( service _ provider ) )
using ( var context = new early _ learning _ center ( service _ provider ) )
assert . true ( context . database . is _ sqlite ( ) ) ;
assert . false ( context . database . is _ sqlite ( ) ) ;
( await assert . throws _ async < invalid _ operation _ exception > ( async ( ) = >
( await assert . throws _ async < invalid _ operation _ exception > ( async ( ) = >
( await assert . throws _ async < invalid _ operation _ exception > ( async ( ) = >
( await assert . throws _ async < invalid _ operation _ exception > ( async ( ) = >
( await assert . throws _ async < invalid _ operation _ exception > ( async ( ) = >
( await assert . throws _ async < invalid _ operation _ exception > ( async ( ) = >
( await assert . throws _ async < invalid _ operation _ exception > ( async ( ) = >
( await assert . throws _ async < invalid _ operation _ exception > ( async ( ) = >
( await assert . throws _ async < invalid _ operation _ exception > ( async ( ) = >
var sql _ server _ modification _ command _ batch _ factory = scoped _ provider . get _ service < sql _ server _ modification _ command _ batch _ factory > ( ) ;
dependent _ entity _ type : dependent _ entity _ type ) )
var command
await commands . execute _ non _ query _ async ( connection ) ;
var command
await relational _ commands . execute _ non _ query _ async ( connection , cancellation _ token ) ;
scenario = run _ result . test _ name ,
protected virtual state _ manager _ dependencies state _ manager _ dependencies { get ; }
key _ properties _ map . add ( source _ property ) ;
generate _ annotations ( foreign _ key . annotations . to _ array ( ) , string _ builder ) ;
conditional _ fact
cvs = > cvs ) ;
var results = context . customer _ queries . to _ array ( ) ;
ovs = > from ov in ovs
login = login
login = login ,
. append _ line ( STR ) . append _ line ( STR )
. append _ line ( STR ) . append _ line ( STR )
fact
@ STR v _ count integer ; begin select count ( * ) into v _ count from all _ tab _ identity _ cols t where t . table _ name = n ' people ' and t . column _ name = ' lucky _ number ' ; if v _ count > 0 then execute immediate ' alter table STR people STR modify STR lucky _ number STR drop identity ' ; end if ; end ; go alter table STR people STR modify STR lucky _ number STR int not null default NUM STR sql ) ; } fact
@ STR v _ count integer ; begin select count ( * ) into v _ count from all _ tab _ identity _ cols t where t . table _ name = n ' people ' and t . column _ name = ' lucky _ number ' ; if v _ count > 0 then execute immediate ' alter table STR people STR modify STR lucky _ number STR drop identity ' ; end if ; end ; go alter table STR people STR modify STR lucky _ number STR number ( NUM ) not null STR sql ) ; } fact
fact
query _ model
return true ;
return true ;
assert . equal ( ( byte? ) 1 , create _ and _ use _ factory ( entity _ type . find _ property ( STR ) ) ) ;
var countries = new [ ] { STR , STR , STR , STR , STR , STR } ;
{ if ( result ! = null )
element _ asserter : ( e , a ) = > assert _ collection ( e , a ) ,
= > assert _ all ( is _ async , query , query , predicate , predicate ) ;
= > assert _ count ( is _ async , query , query ) ;
= > assert _ count ( is _ async , query , query , predicate , predicate ) ;
= > assert _ long _ count ( is _ async , query , query ) ;
element _ asserter : ( e , a ) = > assert _ collection ( e , a ) ) ;
element _ asserter : ( e , a ) = > assert _ equal ( e . p , a . p ) ) ;
element _ asserter : ( e , a ) = > assert _ collection ( e , a ) ) ;
using ( var context = new blogging _ context ( test _ database ) ) { var creator = get _ database _ creator ( context ) ;
using ( var context = new blogging _ context ( test _ database ) )
using ( var context = new blogging _ context ( test _ database ) )
var database _ creator = get _ database _ creator ( test _ database ) ;
var creator = get _ database _ creator ( test _ database ) ;
var creator = get _ database _ creator ( test _ database ) ;
var creator = get _ database _ creator ( connection _ string _ builder . to _ string ( ) ) ;
var creator = get _ database _ creator ( test _ database ) ;
var creator = get _ database _ creator ( test _ database ) ;
var creator = get _ database _ creator ( test _ database ) ;
public class in _ memory _ cross _ store _ fixture : cross _ store _ fixture
public class sql _ server _ cross _ store _ fixture : cross _ store _ fixture
public abstract class cross _ store _ fixture
public abstract class end _ to _ end _ test < t _ test _ store , t _ fixture > : i _ disposable
public virtual async task next _ async ( state _ entry state _ entry , i _ property property , cancellation _ token cancellation _ token = default ( cancellation _ token ) )
. property ( c = > c . name ) . column _ name ( STR ) ;
. property < string > ( STR ) ;
. property < string > ( STR ) ;
. property ( s = > s . sh ) ;
. property ( c = > c . name ) . annotation ( STR , STR ) ;
. property < string > ( STR ) . annotation ( STR , STR ) ;
. property < string > ( STR ) . annotation ( STR , STR ) ;
. property ( c = > c . name ) . use _ store _ sequence ( ) ;
model _ builder . entity < customer > ( ) . property < int > ( STR ) . column _ type ( STR ) ;
. property ( e = > e . name ) ;
. property ( s = > s . name ) ;
stmts . enqueue ( tuple . create ( stmt , rc ! = sqlite _ done ) ) ;
if ( try _ create _ from _ current _ values ( entry , out key ) )
var context _ services = create _ context _ services ( build _ model ( ) ) ;
where [ p ] . [ discontinued ] = [ p ] . [ discontinued ] STR
public virtual entity _ state state
change _ detector . detect _ changes ( entry ) ;
change _ detector . detect _ changes ( entry ) ;
change _ detector . detect _ changes ( entry ) ;
change _ detector . detect _ changes ( entry ) ;
change _ detector . detect _ changes ( entry ) ;
change _ detector . detect _ changes ( entry ) ;
change _ detector . detect _ changes ( entry ) ;
change _ detector . detect _ changes ( entry ) ;
change _ detector . detect _ changes ( state _ manager ) ;
change _ detector . detect _ changes ( state _ manager ) ;
change _ detector . detect _ changes ( state _ manager ) ;
change _ detector . detect _ changes ( state _ manager ) ;
change _ detector . detect _ changes ( state _ manager ) ;
change _ detector . detect _ changes ( state _ manager ) ;
change _ detector . detect _ changes ( state _ manager ) ;
change _ detector . detect _ changes ( state _ manager ) ;
element _ asserter : ( e , a ) = > assert _ collection ( e , a ) ,
assert _ equal ( e . a , a . a ) ; assert _ equal ( e . b , a . b ) ;
assert _ equal ( e . a , a . a ) ; assert _ equal ( e . b , a . b ) ;
assert _ collection ( e . orders , a . orders ) ;
assert _ collection ( e . orders , a . orders ) ;
assert _ collection ( e . orders , a . orders ) ;
element _ asserter : ( e , a ) = > assert _ collection ( e , a , ordered : true ) ) ;
element _ asserter : ( e , a ) = > assert _ collection ( e , a ) ) ;
assert _ collection ( e . order _ ids , a . order _ ids ) ; assert _ equal ( e . customer , a . customer ) ;
element _ asserter : ( e , a ) = > assert _ collection ( e , a , ordered : true ) ) ;
element _ asserter : ( e , a ) = > assert _ collection ( e , a , ordered : true ) ) ;
element _ asserter : ( e , a ) = > assert _ collection ( e , a , ordered : true ) ) ) )
assert _ equal ( e . tag , a . tag ) ; assert _ equal ( e . tag , a . tag ) ;
assert _ equal ( e . a , a . a ) ;
element _ asserter : ( e , a ) = > assert _ collection ( e , a , ordered : true ) ) ;
element _ asserter : ( e , a ) = > assert _ collection ( e , a , ordered : true ) ) ;
element _ asserter : ( e , a ) = > assert _ collection ( e , a ) ) ;
element _ asserter : ( e , a ) = > assert _ collection ( e , a ) ) ;
element _ asserter : ( e , a ) = > assert _ collection ( e , a ) ) ;
element _ asserter : ( e , a ) = > assert _ collection ( e , a ) ) ;
element _ asserter : ( e , a ) = > assert _ collection ( e , a ) ) ;
element _ asserter : ( e , a ) = > assert _ collection ( e , a ) ) ;
element _ asserter : ( e , a ) = > assert _ collection ( e , a ) ) ;
element _ asserter : ( e , a ) = > assert _ collection ( e , a , ordered : true ) ) ;
element _ asserter : ( e , a ) = > assert _ collection ( e , a ) ) ;
element _ asserter : ( e , a ) = > assert _ collection ( e , a ) ) ;
element _ asserter : ( e , a ) = > assert _ collection ( e , a ) ) ;
element _ asserter : ( e , a ) = > assert _ collection ( e , a ) ) ;
assert _ collection ( e . first , a . first ) ; assert _ collection ( e . second , a . second ) ;
assert _ collection ( e . first , a . first ) ; assert _ collection ( e . second , a . second ) ;
assert _ collection ( e . outer _ collection , a . outer _ collection , ordered : true ) ;
assert _ collection ( e . outer _ collection , a . outer _ collection , ordered : true ) ;
assert _ collection ( e . outer _ collection , a . outer _ collection , ordered : true ) ;
assert _ collection ( e . collection , a . collection ) ; assert _ collection ( e . collection , a . collection ) ;
element _ asserter : ( e , a ) = > assert _ collection ( e , a , ordered : true ) ) ;
element _ asserter : ( e , a ) = > assert _ collection ( e , a , ordered : true ) ) ;
element _ asserter : ( e , a ) = > assert _ collection ( e , a , ordered : true ) ) ;
assert _ collection ( e . weapon _ names , a . weapon _ names ) ;
element _ asserter : ( e , a ) = > assert _ collection ( e , a ) ) ;
assert _ collection ( e . report _ names , a . report _ names ) ;
assert _ collection ( e . weapons , a . weapons ) ;
assert _ collection ( e . weapons , a . weapons ) ;
element _ asserter : ( e , a ) = > assert _ collection ( e , a ) ) ;
element _ asserter : ( e , a ) = > assert _ collection ( e , a ) ) ;
element _ asserter : ( e , a ) = > assert _ collection ( e , a ) ) ;
element _ asserter : ( e , a ) = > assert _ collection ( e , a , ordered : true ) ) ;
assert _ collection ( e . weapons , a . weapons ) ;
assert _ equal ( e . , a . ) ; assert _ equal ( e . , a . ) ;
assert _ equal ( e . , a . ) ; assert _ equal ( e . , a . ) ;
element _ asserter : ( e , a ) = > assert _ collection ( e , a ) ) ;
element _ asserter : ( e , a ) = > assert _ equal ( e , a ) ,
assert _ equal ( e . , a . ) ; assert _ equal ( e . , a . ) ;
assert _ equal ( e . , a . ) ; assert _ equal ( e . , a . ) ;
assert _ equal ( e . , a . ) ; assert _ equal ( e . , a . ) ;
assert _ equal ( e . , a . ) ; assert _ equal ( e . , a . ) ;
assert _ equal ( e . entity , a . entity ) ; assert _ collection ( e . collection , a . collection ) ;
assert _ equal ( e . , a . ) ; assert _ equal ( e . , a . ) ;
assert _ equal ( e . , a . ) ; assert _ equal ( e . , a . ) ;
element _ asserter : ( e , a ) = > assert _ collection ( e , a ) ) ;
element _ asserter : ( e , a ) = > assert _ collection ( e , a ) ) ;
element _ asserter : ( e , a ) = > assert _ collection ( e , a ) ) ;
assert _ collection ( e . one _ to _ many _ optional , a . one _ to _ many _ optional ) ;
assert _ collection ( e . collection , a . collection ) ;
assert _ collection ( e . one _ to _ many _ optional , a . one _ to _ many _ optional ) ;
assert _ collection ( e . one _ to _ many _ optional , a . one _ to _ many _ optional ) ;
assert _ collection ( e . one _ to _ many _ optional , a . one _ to _ many _ optional ) ;
assert _ collection ( e . one _ to _ many _ optional , a . one _ to _ many _ optional ) ;
assert _ collection ( e . one _ to _ many _ optional , a . one _ to _ many _ optional ) ;
navigation ,
sql . append ( STR ) ;
read _ only _ files . add ( file _ name ) ;
script _ path = path . combine ( app _ base , script _ path ) ;
script _ path = path . combine ( app _ base , script _ path ) ;
protected virtual i _ logger logger { get ; } protected override void show _ warning ( string message ) = > logger . log _ warning ( message ) ;
builder . append ( STR ) . append ( name ) ;
builder . append ( STR ) . append ( value ) ;
. append ( level _ name ) ;
. append ( level _ name ) ;
. append ( level _ name ) ;
builder . append ( STR ) . append ( name ) ;
. append ( level _ name ) ;
. append ( level _ name ) ;
. append ( level _ name ) ;
var resolvable _ relationships = new list < tuple < internal _ relationship _ builder , bool , resolution , bool > > ( ) ;
: t = > candidate _ naming _ service . generate _ candidate _ identifier ( t ) ,
: t = > candidate _ naming _ service . generate _ candidate _ identifier ( t ) ,
return left . assign ( right ) ;
if ( ! ( column . table . primary _ key ? . columns . contains ( column ) ? ? false ) )
prepare _ select _ expression _ for _ aggregate ( handler _ context ) ;
private i _ update _ entry get _ main _ entry ( i _ update _ entry entry )
return entry ; }       public virtual i _ read _ only _ list < i _ update _ entry > get _ all _ entries ( [ not _ null ] i _ update _ entry entry ) { var entries = new list < i _ update _ entry > ( ) ;
compiled _ query = compiler ( ) ; memory _ cache . set ( cache _ key , compiled _ query ) ;
break ;
public static void set _ sql _ server _ include _ properties ( [ not _ null ] this i _ mutable _ index index , [ not _ null ] i _ read _ only _ list < string > properties )
not _ null this i _ convention _ index index , [ not _ null ] i _ read _ only _ list < string > properties , bool from _ data _ annotation = false )
var attributes = get _ attributes < required _ attribute > ( inverse . declaring _ entity _ type , inverse ) ;
var inverse _ target _ entity _ type = find _ actual _ entity _ type ( referencing _ tuple . item ) ;
& & find _ actual _ entity _ type ( referencing _ tuple . item ) = = entity _ type )
& & find _ actual _ entity _ type ( referencing _ tuple . item ) = = entity _ type )
var other _ entity _ type = find _ actual _ entity _ type ( referencing _ navigations _ with _ attribute [ 0 ] . item ) ;
same _ configuration _ source ? ? = false ;
= > foreign _ keys ? ? enumerable . empty < foreign _ key > ( ) ;
= > keys ? ? enumerable . empty < key > ( ) ;
= > indexes ? ? enumerable . empty < index > ( ) ;
metadata . remove _ key ( key ) ;
metadata . remove _ foreign _ key ( foreign _ key ) ;
var attributes = get _ attributes < t _ attribute > ( navigation . declaring _ entity _ type , navigation ) ;
entity _ type _ builder ? ? = relationship . metadata . declaring _ entity _ type . builder ;
if ( key _ values = = null )
add _ provider _ services ( services ) ;
public new virtual relational _ query _ compilation _ context query _ compilation _ context
= > property ( property _ type , property _ name , type _ configuration _ source : configuration _ source , configuration _ source : configuration _ source ) ;
configuration _ source ? type _ configuration _ source , configuration _ source ? configuration _ source )
property _ type , property _ name , member _ info : null , type _ configuration _ source : type _ configuration _ source , configuration _ source : configuration _ source ) ;
property _ type : null , property _ name : property _ name , member _ info : null , type _ configuration _ source : null , configuration _ source : configuration _ source ) ;
configuration _ source ? type _ configuration _ source , configuration _ source ? configuration _ source )
existing _ property , property _ name , property _ type , member _ info , type _ configuration _ source , configuration _ source ) ;
i _ convention _ entity _ type _ builder i _ convention _ entity _ type _ builder . remove _ unused _ shadow _ properties (
= > value _ buffer ;
private static readonly dictionary < string , string > type _ mapping = new dictionary < string , string >
check . not _ empty ( value , nameof ( value ) ) ;
return identity _ map . try _ get _ value ( entity , out entry ) & & reference _ equals ( entry . entity , entity ) ? entry : null ;
parameter . value = value ? ? db _ null . value ;
conditional _ theory
var entry = entry ( entity ) ;
case parameter _ expression parameter :
detached _ properties = detach _ properties ( metadata . find _ derived _ properties ( property _ name ) ) ;
= > discover _ properties ( relationship _ builder ) ;
= > discover _ properties ( relationship _ builder ) ;
fact
fact
fact
fact
fact
fact
fact
fact
fact
fact
fact
fact
fact
var lambda _ body = remap _ lambda _ body ( shaped _ query _ expression , lambda _ expression ) ;
return client _ eval ? base . visit _ extension ( include _ expression ) : null ;
where [ o ] . [ discriminator ] in ( n ' owned _ person ' , n ' branch ' , n ' leaf _ b ' , n ' leaf _ a ' ) STR
if ( navigations . count > 1 )
var enumerable = value as i _ enumerable ; if ( enumerable ! = null & & ! ( value is string ) )
append _ action ( string _ builder , item + STR ) ;
conditional _ theory
conditional _ theory
conditional _ theory
var model _ differ = create _ model _ differ ( target _ model _ builder . model ) ;
model _ differ = create _ model _ differ ( source _ model _ builder . model ) ;
return expression . block ( new [ ] { instance _ variable } , block _ expressions ) ;
new [ ]
namespace microsoft _ data _ entity _ value _ generation
order by [ g ] . [ full _ name ]
var property = metadata . find _ properties _ in _ hierarchy ( member _ name ) . single _ or _ default ( ) ;
var navigation = metadata . find _ navigations _ in _ hierarchy ( member _ name ) . single _ or _ default ( ) ;
return foreign _ key ( principal _ type , get _ or _ create _ properties ( property _ names , configuration _ source ) , configuration _ source ) ;
( ) = > new foreign _ key ( new [ ] { dependent _ property , dependent _ property } , principal _ type . get _ primary _ key ( ) , dependent _ type , principal _ type ) ) . message ) ;
dependent _ properties , principal _ properties ,
= > property ( clr _ property . name , clr _ property . property _ type , clr _ property : clr _ property , configuration _ source : configuration _ source ) ;
store _ generated _ always = NUM < < NUM
batch . add _ command ( new modification _ command ( STR , null , new parameter _ name _ generator ( ) ) , null ) ) . param _ name ) ;
typeof ( alter _ sequence _ operation )
target . declaring _ entity _ type . root _ type ( ) ) ;
var entity _ type = builder . model . find _ entity _ type ( typeof ( an _ entity ) ) ;
store _ type = value . store _ type ;
where getutcdate ( ) < > my _ datetime STR
where newid ( ) < > ' 00000000 - 0000 - 0000 - 0000 - 000000000000 ' STR
op = binary _ expression . type = = typeof ( string )
assert . equal ( STR , ex . param _ name ) ;
assert . equal ( STR , ex . param _ name ) ;
assert . equal ( typeof ( int ) , db _ func _ builder . metadata . return _ type ) ;
assert . equal ( typeof ( string ) , db _ func _ builder . metadata . return _ type ) ;
protected virtual entity _ type related _ entity _ type { get ; }
command _ builder . add _ parameter (
command _ builder . add _ parameter (
command _ builder . add _ parameter (
j _ object _ parameter ) ;
protected override void on _ model _ creating ( model _ builder model _ builder )
sequence . type ,
var create _ sequence _ operation = new create _ sequence _ operation ( STR ) ;
private readonly migrator migrator ;
get { return migrator ; }
return data _ store _ creator . ensure _ created ( model ) ;
return data _ store _ creator . ensure _ created _ async ( model , cancellation _ token ) ;
return data _ store _ creator . ensure _ deleted _ async ( model , cancellation _ token ) ;
logger . query _ iteration _ failed ( context _ type , exception ) ;
relational _ query _ context . connection . semaphore . release ( ) ; } relational _ query _ context . dispose ( ) ;
break ;
| | ( foreign _ key . declaring _ entity _ type . find _ foreign _ key ( foreign _ key _ properties , foreign _ key . principal _ key , foreign _ key . principal _ entity _ type ) ! = null ) )
command _ text = command _ text + @ STR
assert . equal ( typeof ( in _ memory _ data _ store ) . name , new in _ memory _ data _ store _ source ( ) . name ) ;
assert . equal ( typeof ( sql _ server _ data _ store ) . name , new sql _ server _ data _ store _ source ( ) . name ) ;
conditional _ fact
conditional _ fact
return new state _ entry _ subscriber ( mock . of < state _ entry _ notifier > ( ) ) ;
private internal _ relationship _ builder split _ navigations _ to _ separate _ relationships ( internal _ relationship _ builder relationship _ builder )
public virtual i _ read _ only _ list < property > get _ actual _ properties ( [ can _ be _ null ] i _ read _ only _ list < property > properties , configuration _ source ? configuration _ source )
fact
fact
fact
fact
fact
fact
fact
fact
fact
fact
fact
fact
fact
fact
fact
var foreign _ key _ name = foreign _ key . relational ( ) . name ;
using microsoft _ entity _ framework _ core _ in _ memory _ diagnostics _ internal ;
var other _ navigation = navigations . values . first _ or _ default ( n = > n . foreign _ key = = navigation . foreign _ key & & n . points _ to _ principal = = navigation . points _ to _ principal ) ;
conditional _ fact
node , ( ps , qs ) = >
using system ;
assert . throws < argument _ null _ exception > ( STR , ( ) = > new sq _ lite _ command ( STR , null ) ) ;
using ( model . convention _ dispatcher . start _ batch ( ) )
if ( metadata . get _ properties _ configuration _ source ( ) = = configuration _ source )
if ( metadata . get _ principal _ key _ configuration _ source ( ) = = configuration _ source )
metadata . update _ configuration _ source ( configuration _ source ) ;
is _ unique ( should _ be _ unique . value , configuration _ source ) ;
metadata . has _ principal _ to _ dependent ( ( string ) null , configuration _ source ) ;
metadata . has _ dependent _ to _ principal ( navigation _ property , configuration _ source ) ;
metadata . has _ dependent _ to _ principal ( navigation _ to _ principal _ name , configuration _ source ) ;
metadata . has _ principal _ to _ dependent ( navigation _ property , configuration _ source ) ;
metadata . has _ principal _ to _ dependent ( navigation _ to _ dependent _ name , configuration _ source ) ;
configuration _ source configuration _ source )
configuration _ source configuration _ source )
metadata . update _ properties _ configuration _ source ( configuration _ source ) ;
metadata . update _ principal _ end _ configuration _ source ( configuration _ source ) ;
principal _ end _ configuration _ source : configuration _ source ,
configuration _ source configuration _ source )
metadata . update _ principal _ key _ configuration _ source ( configuration _ source ) ;
metadata . update _ principal _ end _ configuration _ source ( configuration _ source ) ;
assert . same ( dependent _ type , new _ relationship _ builder . metadata . declaring _ entity _ type ) ;
assert . same ( dependent _ type , new _ relationship _ builder . metadata . declaring _ entity _ type ) ;
return model . convention _ dispatcher . on _ property _ added ( property . builder ) ? . metadata ;
sql _ generator ) ) ;
conditional _ fact
internal static string call _ requires _ open _ connection ( object method _ name )
internal static string call _ requires _ set _ command _ text ( object method _ name )
internal static string data _ reader _ closed ( object operation )
internal static string invalid _ cache _ mode ( object mode )
internal static string invalid _ command _ behavior ( object behavior )
internal static string invalid _ command _ type ( object command _ type )
internal static string invalid _ isolation _ level ( object isolation _ level )
internal static string invalid _ isolation _ level _ for _ unshared _ cache ( object isolation _ level )
internal static string invalid _ parameter _ direction ( object direction )
internal static string keyword _ not _ supported ( object keyword )
internal static string missing _ parameters ( object parameters )
internal static string parameter _ not _ found ( object parameter _ name )
internal static string requires _ set ( object property _ name )
internal static string unknown _ data _ type ( object type _ name )
internal static string sqlite _ native _ error ( object error _ code , object message )
internal static string ambiguous _ parameter _ name ( object parameter _ name )
internal static string invalid _ enum _ value ( object enum _ type , object value )
conditional _ fact
if ( max _ batch _ size < = modification _ commands . count )
remove _ entity _ type ( entity _ type _ with _ defining _ navigation , configuration _ source ) ;
remove _ entity _ type ( entity _ type _ with _ defining _ navigation , configuration _ source ) ;
namespace microsoft _ entity _ framework _ core _ design _ tests _ migrations _ design
namespace microsoft _ entity _ framework _ core _ design _ tests _ design
public void write _ error ( string message )
namespace microsoft _ entity _ framework _ core _ design _ tests _ design
namespace microsoft _ entity _ framework _ core _ design _ tests _ migrations _ design
namespace microsoft _ entity _ framework _ core _ design _ tests _ design _ internal
await context . save _ changes _ async ( ) ; validator ( validation _ context ) ;
var up _ operations = model _ differ . get _ differences ( model _ snapshot , model ) ;
if ( equals ( member , is _ closed ) )
if ( equals ( method , item ) )
if ( equals ( method , get _ point _ n ) )
public geometry geometry { get ; set ; } public point point { get ; set ; }
public polygon polygon { get ; set ; }
typeof ( t _ geometry ) . get _ runtime _ method ( STR , new [ ] { typeof ( t _ geometry ) } ) ,
public multi _ line _ string multi _ line _ string { get ; set ; }
public override geometry _ factory geometry _ factory
public line _ string line _ string { get ; set ; }
if ( equals ( method , get _ interior _ ring _ n ) )
if ( equals ( member , is _ closed ) )
where 0 = 1
conditional _ theory
conditional _ theory
conditional _ theory
entity _ type . add _ check _ constraint ( name , sql ) ;
using system ;
public class add _ primary _ key _ operation : migration _ operation
public class drop _ sequence _ operation : migration _ operation
public class drop _ primary _ key _ operation : migration _ operation
public class create _ table _ operation : migration _ operation
public class create _ sequence _ operation : migration _ operation
public class drop _ table _ operation : migration _ operation
. get _ server ( connection . connection _ string ) ;
get _ underlying _ server ( ) . flush _ database ( connection . database ) ;
await get _ underlying _ server ( ) . flush _ database _ async ( connection . database ) . with _ current _ culture ( ) ;
relational _ data _ store _ creator . create _ tables ( model ) ;
return relational _ data _ store _ creator . create _ tables _ async ( model , cancellation _ token ) ;
= ' ' ( db _ type = string ) = ' ' ( db _ type = string ) = ' ' ( size = NUM ) = ' ' ( size = NUM )
log _ error ( STR , connection . name ) ;
log _ error ( STR , provider . name ) ;
log _ error ( STR , name . name ) ;
log _ error ( STR , from . name ) ;
public abstract class relational _ type _ mapper : i _ relational _ type _ mapper
var literal = get _ mapping ( typeof ( date _ time ) ) . generate _ sql _ literal ( value ) ;
var literal = get _ mapping ( typeof ( date _ time _ offset ) ) . generate _ sql _ literal ( value ) ;
var literal = get _ mapping ( typeof ( guid ) ) . generate _ sql _ literal ( value ) ;
private readonly dictionary < string , relational _ type _ mapping > store _ type _ mappings ;
= new dictionary < string , relational _ type _ mapping > ( string _ comparer . ordinal _ ignore _ case )
private readonly dictionary < string , relational _ type _ mapping > store _ type _ mappings ;
= new dictionary < string , relational _ type _ mapping > ( string _ comparer . ordinal _ ignore _ case ) ;
private readonly i _ read _ only _ dictionary < string , relational _ type _ mapping > simple _ name _ mappings = new dictionary < string , relational _ type _ mapping >
private readonly dictionary < string , relational _ type _ mapping > store _ type _ mappings ;
= new dictionary < string , relational _ type _ mapping > ( string _ comparer . ordinal _ ignore _ case )
private readonly i _ read _ only _ dictionary < string , relational _ type _ mapping > simple _ name _ mappings = new dictionary < string , relational _ type _ mapping >
var literal = get _ mapping ( typeof ( byte [ ] ) ) . generate _ sql _ literal ( value ) ;
var literal = get _ mapping ( typeof ( date _ time ) ) . generate _ sql _ literal ( value ) ;
var literal = get _ mapping ( typeof ( date _ time _ offset ) ) . generate _ sql _ literal ( value ) ;
= new dictionary < string , relational _ type _ mapping > ( string _ comparer . ordinal _ ignore _ case )
new point _ entity
new polygon _ entity
new a _ few _ bytes
new a _ few _ bytes
query . load ( ) ;
public virtual internal _ relationship _ builder on _ foreign _ key _ uniqueness _ changed ( [ not _ null ] internal _ relationship _ builder relationship _ builder )
= > context . get _ service < i _ convention _ set _ builder > ( ) ;
var model _ builder = new model _ builder ( create _ convention _ set ( ) ) ;
var model _ builder = new model _ builder ( create _ convention _ set ( ) ) ;
var model _ builder = new model _ builder ( create _ convention _ set ( ) ) ;
var model _ builder = new model _ builder ( create _ convention _ set ( ) ) ;
var model _ builder = new model _ builder ( create _ convention _ set ( ) ) ;
var model _ builder = new model _ builder ( create _ convention _ set ( ) ) ;
return task . from _ result ( move _ next ( ) ) ;
metadata . add _ annotation ( name , value , configuration _ source ) ;
set _ reference _ or _ add _ to _ collection ( new _ target _ entry , inverse , entry ) ;
set _ navigation ( new _ target _ entry , inverse , entry ) ;
set _ reference _ or _ add _ to _ collection ( new _ principal _ entry , principal _ to _ dependent , entry ) ;
set _ reference _ or _ add _ to _ collection ( entry , principal _ to _ dependent , dependent _ entry ) ;
set _ navigation ( dependent _ entry , dependent _ to _ principal , entry ) ;
set _ navigation ( entry , principal _ to _ dependent , dependent _ entry ) ; set _ navigation ( dependent _ entry , dependent _ to _ principal , entry ) ;
& & ( ( method _ call _ expression . arguments [ 0 ] as constant _ expression ) ? . value as array ) ? . length = = 0 )
conditional _ fact
conditional _ fact
namespace microsoft _ data _ entity _ query _ expression _ translators
namespace microsoft _ data _ entity _ query _ expression _ translators
namespace microsoft _ data _ entity _ query _ expression _ translators
namespace microsoft _ data _ entity _ query _ expression _ translators
namespace microsoft _ data _ entity _ value _ generation
namespace microsoft _ data _ entity _ query _ expression _ translators
namespace microsoft _ data _ entity _ query _ expression _ translators
public entity _ builder < t _ entity > annotation ( [ not _ null ] string annotation , [ not _ null ] string value )
public property _ builder annotation ( [ not _ null ] string annotation , [ not _ null ] string value )
dependent _ properties = dependent _ properties ;
key _ properties = value ;
where [ g ] . [ discriminator ] in ( n ' officer ' , n ' gear ' ) and ( [ g . tag ] . [ id ] is not null and [ g . tag ] . [ id ] in ( STR test _ sql _ logger _ factory . sql _ statements [ 1 ] ) ;
where [ g ] . [ discriminator ] in ( n ' officer ' , n ' gear ' ) and ( [ g . city _ of _ birth ] . [ location ] is not null and [ g . tag ] . [ id ] in ( STR test _ sql _ logger _ factory . sql _ statements [ 1 ] ) ;
where [ g ] . [ discriminator ] in ( n ' officer ' , n ' gear ' ) and ( [ g . tag ] . [ id ] is not null and [ g . tag ] . [ id ] in ( STR test _ sql _ logger _ factory . sql _ statements [ 1 ] ) ;
& & t . get _ custom _ attribute < db _ context _ attribute > ( ) ? . context _ type = = context _ type
& & t . get _ custom _ attribute < db _ context _ attribute > ( ) ? . context _ type = = context _ type
= > is _ unicode ? $ STR : $ STR ;
int? size = null ) : base ( store _ type , db _ type , size )
if ( base . open ( ) )
if ( await base . open _ async ( cancellation _ token ) )
= > context . remove ( entity ) ;
= > context . update ( entity ) ;
= > context . attach _ range ( entities ) ;
= > context . remove _ range ( entities ) ;
= > context . update _ range ( entities ) ;
assert . false ( string _ property . is _ nullable ) ;
assert . false ( string _ property . is _ nullable ) ; assert . false ( int _ property . is _ nullable ) ;
assert . false ( string _ property . is _ nullable ) ;
assert . equal ( value _ generated . never , property . value _ generated ) ;
assert . equal ( value _ generated . never , property . value _ generated ) ;
assert . false ( property . is _ concurrency _ token ) ;
assert . false ( property . is _ concurrency _ token ) ;
assert . false ( property . is _ store _ generated _ always ) ;
assert . false ( property . is _ read _ only _ before _ save ) ;
assert . false ( property . is _ read _ only _ after _ save ) ;
assert . false ( key _ properties [ 0 ] . requires _ value _ generator ) ;
var messages = generator _ results . parser _ errors . select ( e = > e . message ) ;
= > property ( property _ name , property _ type : null , member _ info : null , configuration _ source , type _ configuration _ source : null ) ;
conditional _ fact
conditional _ fact
= > database _ creator . can _ connect ( ) ;
= > database _ creator . can _ connect _ async ( cancellation _ token ) ;
var context _ services = create _ context _ services ( ) ;
var context _ services = create _ context _ services ( ) ;
var context _ services = create _ context _ services ( ) ;
var context _ services = create _ context _ services ( ) ;
var context _ services = create _ context _ services ( ) ;
var context _ services = create _ context _ services ( ) ;
var context _ services = create _ context _ services ( ) ;
var context _ services = create _ context _ services ( ) ;
var context _ services = create _ context _ services ( build _ model _ with _ changed ( ) ) ;
var context _ services = create _ context _ services ( build _ model _ with _ changed ( ) ) ;
var context _ services = create _ context _ services ( build _ model _ with _ changed ( ) ) ;
var context _ services = create _ context _ services ( build _ model _ with _ changed ( ) ) ;
var context _ services = create _ context _ services ( build _ notifying _ model ( ) ) ;
var context _ services = create _ context _ services ( build _ notifying _ model ( ) ) ;
var context _ services = create _ context _ services ( build _ notifying _ model ( ) ) ;
var context _ services = create _ context _ services ( build _ notifying _ model ( ) ) ;
var context _ services = create _ context _ services ( build _ notifying _ model ( ) ) ;
var context _ services = create _ context _ services ( build _ notifying _ model ( ) ) ;
var context _ services = create _ context _ services ( build _ notifying _ model ( ) ) ;
var context _ services = create _ context _ services ( build _ notifying _ model ( ) ) ;
context . database . ensure _ created ( ) ;
var tracked = find _ tracked ( key _ values , out i _ read _ only _ list < i _ property > key _ properties ) ;
var tracked = find _ tracked ( key _ values , out i _ read _ only _ list < i _ property > key _ properties ) ;
return method _ call _ expression ;
var indexes = new property _ indexes ( index + + , - 1 , - 1 , relationship _ index + + , - 1 ) ;
public abstract partial class internal _ entity _ entry : i _ update _ entry
return null ;
member _ info _ test ( property , null , field , field , field ) ;
member _ info _ test ( property , null , field , field , field ) ;
member _ info _ test ( property , null , field , field , field ) ;
member _ info _ test ( property , null , field , field , field ) ;
member _ info _ test ( property , null , field , field , field ) ;
member _ info _ test ( property , null , field , field , field ) ;
member _ info _ test ( property , null , field , field , field ) ;
member _ info _ test ( property , null , field , field , field ) ;
member _ info _ test ( navigation , null , field , field , field ) ;
member _ info _ test ( navigation , null , field , field , field ) ;
member _ info _ test ( navigation , null , field , field , field ) ;
member _ info _ test ( navigation , null , field , field , field ) ;
member _ info _ test ( navigation , null , field , field , field ) ;
member _ info _ test ( navigation , null , field , field , field ) ;
member _ info _ test ( navigation , null , field , field , field ) ;
member _ info _ test ( navigation , null , field , field , field ) ;
member _ info _ test ( navigation , null , field , field , field ) ;
member _ info _ test ( navigation , null , field , field , field ) ;
member _ info _ test ( navigation , null , field , field , field ) ;
member _ info _ test ( navigation , null , field , field , field ) ;
member _ info _ test ( navigation , null , field , field , field ) ;
member _ info _ test ( navigation , null , field , field , field ) ;
member _ info _ test ( navigation , null , field , field , field ) ;
member _ info _ test ( navigation , null , field , field , field ) ;
throw new invalid _ operation _ exception ( relational _ strings . stored _ procedure _ include _ not _ supported ) ;
if ( expression is query _ shaper _ expression query _ shaper _ expression )
private readonly i _ model model ;
not _ null i _ model model )
var context _ type = context . get _ type ( ) ; var assembly _ name = relational _ options _ extension . extract ( options ) ? . migrations _ assembly ;
private readonly db _ context context ;
not _ null db _ context context ,
not _ null i _ db _ context _ options options ,
options = options ;
not _ null db _ context context ,
private readonly i _ history _ repository history _ repository ; private readonly relational _ data _ store _ creator data _ store _ creator ; private readonly migration _ sql _ generator sql _ generator ;
private readonly relational _ connection connection ; private readonly model _ differ model _ differ ; private readonly i _ model model ;
not _ null i _ history _ repository history _ repository , not _ null data _ store _ creator data _ store _ creator , not _ null migration _ sql _ generator sql _ generator ,
data _ store _ creator = ( relational _ data _ store _ creator ) data _ store _ creator ;
connection = ( relational _ connection ) connection ;
model _ differ . has _ differences ( migration _ assembly . model _ snapshot ? . model , model ) ;
executor . execute _ non _ query ( connection , transaction . db _ transaction , sql _ batches ) ;
private readonly i _ model model ;
not _ null db _ context context , not _ null i _ model model ,
not _ null model _ differ model _ differ ,
context _ type = context . get _ type ( ) ; model = model ;
history _ repository = history _ repository ; logger = new lazy _ ref < i _ logger > ( logger _ factory . create < migration _ scaffolder > ) ;
not _ null i _ model model , not _ null data _ store data _ store )
not _ null db _ context context )
private readonly db _ context context ;
not _ null db _ context context ,
context ,
context ,
not _ null db _ context context ,
check . not _ null ( migrator , nameof ( migrator ) ) ;
return context _ options ;
not _ null i _ db _ context _ options options ,
var store _ config = relational _ options _ extension . extract ( options ) ;
i _ db _ context _ options options ,
not _ null i _ db _ context _ options options ,
. execute _ async < t _ result > ( expression , data _ store , query _ context , cancellation _ token ) ;
private readonly db _ context context ;
not _ null db _ context context ,
var entry = new entity _ entry ( context , state _ manager . get _ or _ create _ entry ( entity ) ) ;
private readonly db _ context context ;
not _ null db _ context context )
return state _ manager . entries . select ( e = > new entity _ entry ( context , e ) ) ;
. select ( e = > new entity _ entry < t _ entity > ( context , e ) ) ;
public virtual db _ context context = > context ;
public static i _ db _ context _ options create _ options ( )
return options ;
using microsoft _ data _ entity _ storage ; namespace microsoft _ data _ entity _ internal
private static sql _ logger logger ;
not _ null i _ read _ only _ list < property > foreign _ key _ properties ,
new [ ] { fk _ property , fk _ property } ,
var model = new model ( ) ;
var model = new model ( ) ;
var model = new model ( ) ;
var model = new model ( ) ;
var model = new model ( ) ;
var model = new model ( ) ;
var model = new model ( ) ;
var model = new model ( ) ;
var current _ configuration _ source = entity _ type . get _ configuration _ source ( ) ;
& & ! query _ model . result _ operators . any ( ) | | ! query _ model . body _ clauses . any ( ) & & ! sub _ query _ model . result _ operators . any ( ro = > ro is group _ result _ operator ) )
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
return open _ reader = new sq _ lite _ data _ reader ( this ) ;
private static bool is _ composite _ key ( [ not _ null ] type type )
fact
STR ,
invoke ( type , STR , services ) ;
return expression . block ( variables , expressions ) ;
inner _ shaper = new entity _ shaper _ nullable _ marking _ expression _ visitor ( ) . visit ( inner _ shaper ) ;
shaper _ expression ,
var old _ behavior = ! precision _ and _ scale _ overriden ;
var pickle _ clone = model _ builder . model . clone ( ) . get _ entity _ type ( pickle . name ) ;
public class relationship _ discovery _ convention : i _ entity _ type _ convention , i _ base _ type _ convention , i _ navigation _ removed _ convention , i _ entity _ type _ member _ ignored _ convention
sql _ builder . append ( value ) ;
sql _ builder . append ( root _ reference _ expression ) ;
sql _ builder . append ( key _ access _ expression ) ;
sql _ builder . append ( entity _ projection _ expression ) ;
execution _ strategy _ mock , ( ) = >
execution _ strategy _ mock , ( ) = >
execution _ strategy _ mock , ( ) = >
execution _ strategy _ mock , ( ) = >
execution _ strategy _ mock , ct = >
execution _ strategy _ mock , ct = >
execution _ strategy _ mock , ct = >
execution _ strategy _ mock , ct = >
query _ source ) ;
query _ source ) ;
visit ( alias _ expression . expression ) ; if ( alias _ expression . alias ! = null ) { relational _ command _ builder . append ( STR ) ;
func < expression , list < expression > , expression > in _ expression _ factory )
select top ( p ) [ c ] . [ customer _ id ] , [ c ] . [ company _ name ] , coalesce ( [ c ] . [ region ] , n ' zz ' ) as [ c ]
new exists _ expression ( inner _ select _ expression ) ) ;
new exists _ expression ( outer _ select _ expression ) ) ;
= > string . equals ( alias , other . alias ) & & equals ( expression , other . expression ) ;
context . add _ range ( entity ) ; context . add _ range ( entity ) ;
context . attach _ range ( entity ) ; context . attach _ range ( entity ) ;
context . update _ range ( entity ) ; context . update _ range ( entity ) ;
context . remove _ range ( entity ) ; context . remove _ range ( entity ) ;
return table . execute ( operation , null , request _ context . operation _ context ) ;
return task . run ( ( ) = > table . execute _ async ( operation , null , request _ context . operation _ context , cancellation _ token )
var results = setup _ results ( new [ ] { test _ table _ result . ok ( ) , test _ table _ result . ok ( ) } ) ;
var results = setup _ results ( new [ ] { test _ table _ result . ok ( ) , test _ table _ result . ok ( ) } ) ;
reporter = new operation _ reporter ( report _ handler ) ;
result _ handler = result _ handler ;
namespace microsoft _ entity _ framework _ core _ scaffolding _ configuration _ internal
namespace microsoft _ entity _ framework _ core _ scaffolding _ configuration _ internal
namespace microsoft _ entity _ framework _ core _ scaffolding _ configuration _ internal
using ( var context = create _ context ( ) )
using ( var context = create _ context ( ) )
using ( var context = create _ context ( ) )
using ( var context = create _ context ( ) )
public override internal _ property _ builder apply ( internal _ property _ builder property _ builder , key _ attribute attribute )
public override internal _ property _ builder apply ( internal _ property _ builder property _ builder , concurrency _ check _ attribute attribute )
public abstract internal _ entity _ type _ builder apply ( [ not _ null ] internal _ entity _ type _ builder entity _ type _ builder , [ not _ null ] t _ attribute attribute ) ;
public override internal _ property _ builder apply ( internal _ property _ builder property _ builder , required _ attribute attribute )
public override internal _ property _ builder apply ( internal _ property _ builder property _ builder , database _ generated _ attribute attribute )
public abstract internal _ property _ builder apply ( [ not _ null ] internal _ property _ builder property _ builder , [ not _ null ] t _ attribute attribute ) ;
conditional _ fact
conditional _ fact
conditional _ fact
conditional _ fact
conditional _ fact
conditional _ fact
conditional _ fact
conditional _ fact
conditional _ fact
conditional _ fact
conditional _ fact
conditional _ fact
conditional _ fact
conditional _ fact
conditional _ fact
conditional _ fact
conditional _ fact
conditional _ fact
conditional _ fact
conditional _ fact
conditional _ fact
conditional _ fact
conditional _ fact
conditional _ fact
conditional _ fact
conditional _ fact
conditional _ fact
conditional _ fact
conditional _ fact
where t _ entity _ builder : entity _ builder _ base < t _ entity _ builder >
where t _ entity _ builder : entity _ builder _ base < t _ entity _ builder >
where t _ entity _ builder : entity _ builder _ base < t _ entity _ builder >
where t _ entity _ builder : entity _ builder _ base < t _ entity _ builder >
where t _ entity _ builder : entity _ builder _ base < t _ entity _ builder >
where t _ entity _ builder : entity _ builder _ base < t _ entity _ builder >
public static entity _ builder _ base < t _ metadata _ builder > to _ table < t _ metadata _ builder > ( not _ null this entity _ builder _ base < t _ metadata _ builder > builder ,
where t _ metadata _ builder : metadata _ builder < entity _ type , t _ metadata _ builder >
public static entity _ builder _ base < t _ metadata _ builder > to _ table < t _ metadata _ builder > ( not _ null this entity _ builder _ base < t _ metadata _ builder > builder ,
where t _ metadata _ builder : metadata _ builder < entity _ type , t _ metadata _ builder >
where t _ metadata _ builder : metadata _ builder < entity _ type , t _ metadata _ builder >
where t _ metadata _ builder : metadata _ builder < entity _ type , t _ metadata _ builder >
where t _ metadata _ builder : metadata _ builder < entity _ type , t _ metadata _ builder >
public static entity _ builder _ base < t _ metadata _ builder > table _ name < t _ metadata _ builder > ( not _ null this entity _ builder _ base < t _ metadata _ builder > builder ,
where t _ metadata _ builder : metadata _ builder < entity _ type , t _ metadata _ builder >
where t _ metadata _ builder : metadata _ builder < entity _ type , t _ metadata _ builder >
public static entity _ builder < t _ entity > timestamp < t _ entity > ( [ not _ null ] this entity _ builder < t _ entity > builder , [ not _ null ] string name , bool shadow _ property = false )
strings . format _ no _ value _ generator ( STR , STR , STR ) ,
? ? find _ mapping _ with _ conversion ( new concrete _ type _ mapping _ info ( property ) , property ) ;
? ? find _ mapping _ with _ conversion ( new concrete _ relational _ type _ mapping _ info ( property ) , property ) ;
navigation . name , navigation . declaring _ entity _ type . name , property . property _ type . name , navigation . get _ target _ type ( ) . name ) ) ;
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
public class model _ builder : i _ model _ builder < model _ builder >
private internal _ entity _ builder entity _ type _ added ( internal _ entity _ builder builder )
public virtual internal _ entity _ builder apply ( internal _ entity _ builder entity _ builder )
return new context ( service _ provider , options ) ;
fact
fact
public abstract class internal _ metadata _ builder
var field _ info = try _ match _ field _ name ( property _ base , type ) ;
customer . name + = STR ;
context . customers . remove ( customer ) ;
customer . name + = STR ;
context . customers . remove ( customer ) ;
if ( model _ clr _ type . is _ enum )
typeof ( one _ to _ one _ principal _ entity ) . name + STR + one _ to _ one _ principal _ entity . navigation _ property . name , typeof ( one _ to _ one _ dependent _ entity ) . name + STR + one _ to _ one _ dependent _ entity . navigation _ property . name ) ,
. ignore ( o = > o . details ) ;
values . remove ( key ) ; return tuple . item ;
return default _ configuration _ source ;
protected void assert _ equal ( i _ enumerable < string > expected _ names , i _ enumerable < string > actual _ names )
model _ builder . entity ( typeof ( customer ) , configuration _ source . explicit ) . key ( new [ ] { customer . id _ property , customer . unique _ property } , configuration _ source . explicit ) ;
return tuple . item ;
return default ( t _ value ) ;
private cosmos _ result _ set _ iterator create _ query (
query = cosmos _ client . create _ query ( container _ id , cosmos _ sql _ query ) ;
query = cosmos _ client . create _ query ( container _ id , cosmos _ sql _ query ) ;
return new service _ collection ( ) . add _ entity _ framework ( s = > s . add _ in _ memory _ store ( ) ) . build _ service _ provider ( ) ;
var sets = new context _ entity _ sets ( ) ;
var sets = new context _ entity _ sets ( ) ;
var sets = new context _ entity _ sets ( ) ;
var sets = new context _ entity _ sets ( ) ;
visit _ default _ value ( property _ builder , column ) ;
where STR discontinued STR < > STR
if ( entry . entity _ state ! = entity _ state . added & & entry . entity _ state ! = entity _ state . modified & & entry . entity _ state ! = entity _ state . deleted )
var test _ type _ alias = db _ model . sql _ server ( ) . type _ aliases . single _ or _ default ( kvp = > kvp . key . contains ( STR ) ) ;
var test _ type _ alias = db _ model . sql _ server ( ) . type _ aliases . single _ or _ default ( kvp = > kvp . key . contains ( STR ) ) ;
var matching _ candidate = navigation _ tree _ node _ candidates . single _ or _ default ( m = > m . path . count = = 0 ) ;
var matching _ candidate = navigation _ tree _ node _ candidates . single _ or _ default ( m = > m . path . count = = 0 ) ;
return member _ expression . update ( new _ expression ) ;
public class relational _ index _ annotations : i _ relational _ index _ annotations
public class relational _ entity _ type _ annotations : i _ relational _ entity _ type _ annotations
public class relational _ model _ annotations : i _ relational _ model _ annotations
public class relational _ foreign _ key _ annotations : i _ relational _ foreign _ key _ annotations
public class relational _ property _ annotations : i _ relational _ property _ annotations
throw new argument _ out _ of _ range _ exception ( nameof ( value ) , entity . internal . strings . hi _ lo _ bad _ pool _ size ) ;
public class relational _ key _ annotations : i _ relational _ key _ annotations
expression selector = expression . make _ member _ access (
is _ required _ configuration _ source = configuration _ source . max ( is _ required _ configuration _ source ) ;
on _ model _ creating ( context , model _ builder ) ;
conditional _ theory
conditional _ theory
conditional _ fact
using system ;
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ fact
conditional _ fact
conditional _ fact
assert . true ( table _ selection _ set . allows ( STR ) ) ;
assert . true ( table _ selection _ set . allows ( STR ) ) ;
assert . false ( table _ selection _ set . allows ( STR ) ) ;
assert . true ( table _ selection _ set . allows ( STR , STR ) ) ;
assert . true ( table _ selection _ set . allows ( STR , STR ) ) ;
assert . false ( table _ selection _ set . allows ( STR , STR ) ) ;
assert . true ( table _ selection _ set . allows ( STR , STR ) ) ;
assert . true ( table _ selection _ set . allows ( STR , STR ) ) ;
= > table _ namer . get _ name ( check . not _ null ( table , nameof ( table ) ) ) ;
private static readonly string [ ] valid _ keywords = new [ ]
private static readonly i _ dictionary < string , keywords > keywords = new dictionary < string , keywords > ( NUM , string _ comparer . ordinal _ ignore _ case )
assert . true ( await context . database . ensure _ deleted _ async ( ) ) ;
assert . true ( context . database . ensure _ deleted ( ) ) ;
values [ index ] = entry [ property ] ;
assert _ sql ( @ STR
assert _ sql ( @ STR
protected override i _ test _ store _ factory test _ store _ factory = > sql _ server _ test _ store _ factory . instance ;
protected override i _ test _ store _ factory test _ store _ factory = > sql _ server _ test _ store _ factory . instance ;
protected override i _ test _ store _ factory test _ store _ factory = > sql _ server _ test _ store _ factory . instance ;
protected override i _ test _ store _ factory test _ store _ factory = > sqlite _ test _ store _ factory . instance ;
protected override i _ test _ store _ factory test _ store _ factory = > in _ memory _ test _ store _ factory . instance ;
protected override i _ test _ store _ factory test _ store _ factory = > sql _ server _ test _ store _ factory . instance ;
protected override i _ test _ store _ factory test _ store _ factory = > sqlite _ test _ store _ factory . instance ;
protected override i _ test _ store _ factory test _ store _ factory = > in _ memory _ test _ store _ factory . instance ;
protected override i _ test _ store _ factory test _ store _ factory = > sql _ server _ test _ store _ factory . instance ;
protected override i _ test _ store _ factory test _ store _ factory = > in _ memory _ test _ store _ factory . instance ;
protected override i _ test _ store _ factory test _ store _ factory = > in _ memory _ test _ store _ factory . instance ;
protected override i _ test _ store _ factory test _ store _ factory = > sql _ server _ test _ store _ factory . instance ;
protected override i _ test _ store _ factory test _ store _ factory = > in _ memory _ test _ store _ factory . instance ;
public class sql _ server _ test _ store _ factory : i _ test _ store _ factory
protected override i _ test _ store _ factory test _ store _ factory = > sql _ server _ test _ store _ factory . instance ;
protected override i _ test _ store _ factory test _ store _ factory = > in _ memory _ test _ store _ factory . instance ;
public test _ store create _ test _ store ( i _ test _ store _ factory test _ store _ factory )
protected override i _ test _ store _ factory test _ store _ factory = > sql _ server _ test _ store _ factory . instance ;
protected override i _ test _ store _ factory test _ store _ factory = > sql _ server _ test _ store _ factory . instance ;
protected override i _ test _ store _ factory test _ store _ factory = > sqlite _ northwind _ test _ store _ factory . instance ;
protected override i _ test _ store _ factory test _ store _ factory = > sqlite _ test _ store _ factory . instance ;
protected override i _ test _ store _ factory test _ store _ factory = > sql _ server _ test _ store _ factory . instance ;
public interface i _ test _ store _ factory
protected override i _ test _ store _ factory test _ store _ factory = > sql _ server _ northwind _ test _ store _ factory . instance ;
protected override i _ test _ store _ factory test _ store _ factory = > sqlite _ test _ store _ factory . instance ;
protected override i _ test _ store _ factory test _ store _ factory = > sql _ server _ test _ store _ factory . instance ;
protected override i _ test _ store _ factory test _ store _ factory = > private _ cache _ sqlite _ test _ store _ factory . instance ;
protected override i _ test _ store _ factory test _ store _ factory = > sql _ server _ test _ store _ factory . instance ;
protected override i _ test _ store _ factory test _ store _ factory = > sql _ server _ test _ store _ factory . instance ;
protected override i _ test _ store _ factory test _ store _ factory = > sqlite _ test _ store _ factory . instance ;
protected override i _ test _ store _ factory test _ store _ factory = > sqlite _ test _ store _ factory . instance ;
protected override i _ test _ store _ factory test _ store _ factory = > in _ memory _ test _ store _ factory . instance ;
protected override i _ test _ store _ factory test _ store _ factory = > sql _ server _ test _ store _ factory . instance ;
protected override i _ test _ store _ factory test _ store _ factory = > sqlite _ test _ store _ factory . instance ;
protected override i _ test _ store _ factory test _ store _ factory = > sqlite _ test _ store _ factory . instance ;
protected override i _ test _ store _ factory test _ store _ factory = > in _ memory _ test _ store _ factory . instance ;
protected override i _ test _ store _ factory test _ store _ factory = > sqlite _ test _ store _ factory . instance ;
protected override i _ test _ store _ factory test _ store _ factory = > sql _ server _ adventure _ works _ test _ store _ factory . instance ;
protected override i _ test _ store _ factory test _ store _ factory = > sql _ server _ test _ store _ factory . instance ;
public class sqlite _ test _ store _ factory : i _ test _ store _ factory
protected override i _ test _ store _ factory test _ store _ factory = > in _ memory _ test _ store _ factory . instance ;
protected abstract i _ test _ store _ factory test _ store _ factory { get ; }
protected override i _ test _ store _ factory test _ store _ factory = > sqlite _ test _ store _ factory . instance ;
protected override i _ test _ store _ factory test _ store _ factory = > in _ memory _ test _ store _ factory . instance ;
public class in _ memory _ test _ store _ factory : i _ test _ store _ factory
protected override i _ test _ store _ factory test _ store _ factory = > sqlite _ test _ store _ factory . instance ;
started _ transaction = connection . begin _ transaction ( ) ; } else { connection . open ( ) ;
started _ transaction = await connection . begin _ transaction _ async ( cancellation _ token ) ; } else { await connection . open _ async ( cancellation _ token ) ;
return null ;
public override async task < bool > open _ async ( cancellation _ token cancellation _ token , bool errors _ expected = false )
if ( await base . open _ async ( cancellation _ token , errors _ expected ) )
public class byte _ array _ type _ mapping : relational _ type _ mapping
public class string _ type _ mapping : relational _ type _ mapping
public virtual task < bool > open _ async ( cancellation _ token cancellation _ token , bool errors _ expected = false )
return real _ connection . open _ async ( cancellation _ token , errors _ expected ) ;
conditional _ theory
conditional _ theory
using concurrency _ model ; using microsoft _ data _ entity _ relational _ functional _ tests ;
namespace concurrency _ model
namespace concurrency _ model
return model ;
public new virtual sqlite _ command create _ command ( ) = > new sqlite _ command { connection = this , transaction = transaction } ;
public new virtual sqlite _ transaction begin _ transaction ( ) = > begin _ transaction ( isolation _ level . unspecified ) ;
public new virtual sqlite _ parameter _ collection parameters = > parameters . value ;
public new virtual sqlite _ parameter create _ parameter ( ) = > new sqlite _ parameter ( ) ;
public new virtual sqlite _ data _ reader execute _ reader ( ) = > execute _ reader ( command _ behavior . default ) ; public new virtual sqlite _ data _ reader execute _ reader ( command _ behavior behavior )
throw new invalid _ operation _ exception ( sql _ server _ strings . transient _ exception _ detected , ex ) ;
throw new invalid _ operation _ exception ( sql _ server _ strings . transient _ exception _ detected , ex ) ;
public bool has _ tables _ base ( ) = > has _ tables ( ) ;
= > has _ tables _ async ( cancellation _ token ) ;
columns = { children _ table . columns [ 1 ] } ,
columns = { children _ table . columns [ 0 ] } ,
columns = { children _ table . columns [ 1 ] , children _ table . columns [ 2 ] } ,
columns = { table . columns [ 1 ] } ,
columns = { children _ table . columns [ 1 ] } ,
columns = { table . columns [ 1 ] } ,
columns = { children _ table . columns [ 1 ] , children _ table . columns [ 2 ] } ,
column . display _ name , column . data _ type ) ) ;
build _ action . invoke ( owns _ one _ builder ( new type _ identity ( owned _ type _ name ) , navigation _ name ) ) ; return this ;
build _ action . invoke ( owns _ many _ builder ( new type _ identity ( owned _ type _ name ) , navigation _ name ) ) ; return this ;
. has _ foreign _ key ( STR microsoft . entity _ framework _ core . migrations . model _ snapshot _ sql _ server _ test + entity _ with _ two _ properties STR , STR entity _ with _ string _ key _ id STR ) ;
build _ action . invoke ( owns _ one _ builder < t _ related _ entity > ( new property _ identity ( navigation _ name ) ) ) ; return this ;
build _ action . invoke ( owns _ many _ builder < t _ related _ entity > ( new property _ identity ( navigation _ name ) ) ) ; return this ;
var existing _ inverse _ type = existing _ inverse ? . declaring _ entity _ type ;
& & is _ ambiguous _ inverse ( navigation , entity _ type , entity _ type . model , inverse _ navigation . value ) )
entity _ type = entity _ type ;
entity _ type = entity _ type ;
where [ a ] . [ discriminator ] in ( n ' eagle ' , n ' kiwi ' )
where [ a ] . [ discriminator ] in ( n ' eagle ' , n ' kiwi ' )
where [ a ] . [ discriminator ] in ( n ' eagle ' , n ' kiwi ' ) and ( ( [ a ] . [ name ] = n ' great spotted kiwi ' ) and [ a ] . [ name ] is not null )
where [ a ] . [ discriminator ] in ( n ' eagle ' , n ' kiwi ' )
where [ c . animals ] . [ discriminator ] in ( n ' eagle ' , n ' kiwi ' )
conditional _ fact
var customer = customers . first ( c = > c . customer _ id = = order . customer _ id ) ;
var order = orders . first ( o = > o . order _ id = = order _ detail . order _ id ) ;
var product = products . first ( p = > p . product _ id = = order _ detail . product _ id ) ;
var manager = employees . first _ or _ default ( e = > employee . reports _ to = = e . employee _ id ) ;
assert . true ( await connection . open _ async ( cancellation _ token : cancellation _ token ) ) ;
assert . false ( await connection . open _ async ( cancellation _ token : cancellation _ token ) ) ; assert . false ( await connection . open _ async ( cancellation _ token : cancellation _ token ) ) ;
assert . true ( await connection . open _ async ( cancellation _ token : cancellation _ token ) ) ;
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
var redis _ value _ generator _ factory = new redis _ value _ generator _ factory ( ) ;
var redis _ value _ generator _ factory = new redis _ value _ generator _ factory ( ) ;
assert . is _ type < key _ builder > ( returned _ builder ) ;
assert . is _ type < property _ builder > ( returned _ builder ) ;
assert . is _ type < index _ builder > ( returned _ builder ) ;
return service _ collection ;
throw new invalid _ operation _ exception ( STR + reference ) ;
private static readonly string project _ command
connection . close ( ) ;
connection . open ( ) ;
connection . close ( ) ;
var query _ source = create _ with _ entity _ queryable < poco _ test _ type > ( ) ;
service _ collection . add _ singleton ( service _ type , implementation ) ;
service _ collection . add _ singleton ( service _ type , implementation _ type ) ; var constructors = implementation _ type . get _ constructors ( ) ;
value _ reader _ factory . create _ value _ reader ( query _ context . get _ data _ reader ( reader _ index ) ) ,
value _ reader _ factory . create _ value _ reader ( query _ context . get _ data _ reader ( reader _ index ) ) ,
console . write _ line ( STR ) ;
console . write _ line ( STR ) ;
order by [ ] . [ customer _ id ]
order by [ ] . [ customer _ id ] , [ ] . [ order _ id ] STR
results ? ? = new list < object [ ] >
column _ names ? ? = new [ ] { STR } ;
assert . equal ( delete _ behavior . restrict , foreign _ key . delete _ behavior ) ;
new bool is _ unique { get ; set ; }
new bool is _ required { get ; set ; }
new delete _ behavior delete _ behavior { get ; set ; }
assert . true ( relationship _ builder . metadata . is _ required ) ;
var existing _ child = parent . children . single _ or _ default ( c = > c . navigation = = navigation ) ;
& & ( left _ binding . navigation _ tree _ node . is _ collection | | right _ binding . navigation _ tree _ node . is _ collection ) )
method _ call _ expression ) ) ;
| | relationship _ candidate . navigation _ properties . count > 1 & & relationship _ candidate . inverse _ properties . count > 0 | | relationship _ candidate . inverse _ properties . count > 1 )
seed _ data ( context ) ;
return base . get _ next _ delay ( last _ exception ) ;
save _ changes ( ) ;
save _ changes ( ) ;
conditional _ fact
conditional _ fact
if ( foreign _ key . declaring _ entity _ type . find _ primary _ key ( ) ! = null )
t _ result execute _ async < t _ result > ( [ not _ null ] expression query ) ;
public virtual t _ result execute _ async < t _ result > ( expression query )
func < query _ context , t _ result > get _ or _ add _ async _ query < t _ result > (
not _ null func < func < query _ context , t _ result > > compiler ) ;
validate ( model _ builder ) ;
validate ( model _ builder ) ;
validate ( model _ builder ) ;
validate ( model _ builder ) ;
validate ( model _ builder ) ;
validate ( model _ builder ) ;
validate ( model _ builder ) ;
validate ( model _ builder ) ;
validate ( model _ builder ) ;
validate ( model _ builder ) ;
validate ( model _ builder ) ;
validate ( model _ builder ) ;
using system ;
var relationship _ builder = dependent _ type _ with _ composite _ key . relationship (
principal _ type _ with _ composite _ key , STR , null , configuration _ source . convention ) ;
principal _ type , STR , null , configuration _ source . convention ) ;
strings . format _ bad _ backing _ field _ type ( STR , typeof ( string ) . name , typeof ( the _ dark _ side ) . full _ name , STR , typeof ( int ) . name ) ,
var options _ extension = new test _ relational _ options _ extension ( ) ;
assert . throws < argument _ null _ exception > ( ( ) = > { new test _ relational _ options _ extension ( ) . connection = null ; } ) ;
var options _ extension = new test _ relational _ options _ extension ( ) ;
var options _ extension = new test _ relational _ options _ extension ( ) ;
var options _ extension = new test _ relational _ options _ extension ( ) ;
foreach ( var include _ specification in include _ specifications )
include _ specification ,
conditional _ theory
using ( var context = create _ context ( ) )
var validator = create _ model _ validator ( ) ;
db _ function
db _ function
var db _ context _ generator _ model = new db _ context _ generator _ model
directory . create _ directory ( output _ directory _ name ) ;
+ STR + error _ message _ annotation ) ;
c _ sharp _ code _ generator _ helper . instance . single _ line _ comment ( STR , sb ) ;
public override void generate _ entity _ property ( i _ property property , indented _ string _ builder sb )
c _ sharp _ code _ generator _ helper . instance . add _ property ( access _ modifier . public , virtual _ modifier . none , property . property _ type , property . name , sb ) ;
c _ sharp _ code _ generator _ helper . instance . single _ line _ comment ( STR , sb ) ;
c _ sharp _ code _ generator _ helper . instance . single _ line _ comment ( STR + other _ entity _ type . name + STR , sb ) ;
public virtual void single _ line _ comment ( string comment , indented _ string _ builder sb )
public virtual void add _ using _ statement ( string namespace , indented _ string _ builder sb )
public virtual void begin _ namespace ( string class _ namespace , indented _ string _ builder sb )
c _ sharp _ code _ generator _ helper . instance . begin _ namespace ( class _ namespace , sb ) ; c _ sharp _ code _ generator _ helper . instance . begin _ class ( access _ modifier . public , class _ name , is _ partial : true , sb : sb ) ;
c _ sharp _ code _ generator _ helper . instance . add _ using _ statement ( namespace , sb ) ;
generate _ entity _ property ( property , sb ) ;
public abstract void generate _ entity _ property ( i _ property property , indented _ string _ builder sb ) ;
c _ sharp _ code _ generator _ helper . instance . add _ using _ statement ( namespace , sb ) ;
c _ sharp _ code _ generator _ helper . instance . begin _ method ( access _ modifier . protected , virtual _ modifier . override , STR , STR , sb , on _ configuring _ method _ parameters ) ;
c _ sharp _ code _ generator _ helper . instance . begin _ method ( access _ modifier . protected , virtual _ modifier . override , STR , STR , sb , on _ model _ creating _ method _ parameters ) ;
generate _ navigations _ configuration ( entity _ type , navigations _ string _ builder ) ;
generate _ entity _ key _ configuration ( key , sb ) ; } generate _ entity _ facets _ configuration ( entity _ type , sb ) ;
public virtual void generate _ entity _ key _ configuration ( i _ key key , indented _ string _ builder sb ) { sb . append ( STR ) ;
on _ entity _ type _ added ,
on _ entity _ type _ added ,
if ( ignored _ configuration _ source . overrides ( configuration _ source ) )
case sqlite _ integer :
case sqlite _ float :
case sqlite _ text :
case sqlite _ blob :
case sqlite _ null :
case sqlite _ integer :
case sqlite _ float :
case sqlite _ text :
case sqlite _ blob :
case sqlite _ null :
if ( type = = sqlite _ null
case sqlite _ integer :
case sqlite _ float :
case sqlite _ text :
case sqlite _ blob :
case sqlite _ null :
return property . sql _ server ( ) . identity _ strategy = = sql _ server _ identity _ strategy . sequence _ hi _ lo
return new [ ]
linq _ operator _ provider . intercept _ exceptions < t > ( null , null , null , null ) ;
async _ linq _ operator _ provider . intercept _ exceptions < t > ( null , null , null , null ) ;
conditional _ theory
return mapping ;
conditional _ fact
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ fact
conditional _ fact
conditional _ fact
conditional _ fact
throw new argument _ out _ of _ range _ exception ( ) ;
await context . save _ changes _ async ( ) ; validator ( validation _ context ) ;
new post
processed = true
var query = context . gears . include ( STR ) . to _ list ( ) ; } } ) . message ) ;
& & ! entity _ type . is _ query _ type ,
if ( entity _ type . is _ query _ type )
using ( var context = create _ context ( ) )
using ( var context = create _ context ( ) )
using ( var context = create _ context ( ) )
? ? mapping . size ;
property _ metadata _ changed ( ) ;
var login = new login { customer = customer , customer _ id = customer . customer _ id , username = customer . name + customer . customer _ id , } ;
var photo = new product _ photo { photo _ id = ( photos _ per _ product * product . product _ id ) + k , photo = new byte [ ] { 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 } , } ;
var line = new order _ line { order _ id = order . order _ id , product _ id = ( product _ per _ customer _ count * customer . customer _ id ) + m , concurrency _ token = i . to _ string ( ) , } ;
var order = new order { order _ id = ( ( 2 * orders _ per _ customer ) * customer . customer _ id ) + l + orders _ per _ customer , customer _ id = customer . customer _ id , concurrency _ token = i . to _ string ( ) , } ;
public override task group _ by _ distinct ( )
var product _ model = new product _ model { catalog _ description = STR + product _ iterator , instructions = STR , modified _ date = date _ time . now , name = STR , row _ guid = run _ guid } ;
var product _ category = new product _ category { name = STR , row _ guid = run _ guid , modified _ date = date _ time . now } ;
var product _ sub _ category = new product _ sub _ category { name = STR , row _ guid = run _ guid , modified _ date = date _ time . now , category = product _ category } ;
get { return value ; } set { this . value = value ; }
get { return first _ level _ property ; } set { second _ level _ property = value ; }
var query = context . customers . first _ or _ default ( c = > c . customer _ id = = STR ) ;
var query = context . customers . single _ or _ default ( c = > c . customer _ id = = STR ) ;
public class in _ memory _ fixture : fixture _ base
public abstract class property _ entry _ test _ base < t _ fixture > : i _ class _ fixture < t _ fixture > where t _ fixture : fixture _ base , new ( )
public class sql _ server _ fixture : relational _ fixture
public class sqlite _ fixture : relational _ fixture
public abstract class relational _ fixture : fixture _ base
= shaper _ command _ context . get _ relational _ command ( relational _ query _ context . parameter _ values ) ; await relational _ query _ context
lock ( relational _ query _ context )
using ( var context = create _ context ( use _ relational _ nulls ) ) {
public new virtual one _ to _ many _ builder < t _ related _ entity > foreign _ key ( [ not _ null ] params string [ ] foreign _ key _ property _ names )
public new virtual many _ to _ one _ builder < t _ related _ entity > foreign _ key ( [ not _ null ] params string [ ] foreign _ key _ property _ names )
private entity _ type entity _ type _ added ( entity _ type entity _ type )
return ( t ) ( unwrapped _ type ! = value . get _ type ( )
var removed _ foreign _ key = metadata . remove _ foreign _ key ( foreign _ key ) ;
return replace _ foreign _ key (
conditional _ theory
var query _ model _ visitor = create _ query _ model _ visitor ( ) ;
var query _ model _ visitor = create _ query _ model _ visitor ( ) ;
var model _ builder = new model _ builder ( new convention _ set ( ) ) ; build _ model ( model _ builder ) ; return model _ builder . model ;
private i _ model target _ model ; private list < migration _ operation > up _ operations ; private list < migration _ operation > down _ operations ;
private i _ model model ; private string migration _ id _ column _ name ; private string product _ version _ column _ name ;
connection = relational _ options . connection ;
. navigation ( navigation _ to _ dependent _ name , builder . metadata , points _ to _ principal : builder . metadata . declaring _ entity _ type ! = metadata , configuration _ source : configuration _ source ) ;
typeof ( int ) ,
return run _ server ( server _ path ) ;
private lazy _ ref < i _ model > model ; private lazy _ ref < state _ manager > state _ manager ; private context _ entity _ sets sets ;
using ( await test _ database . northwind ( ) )
using ( await test _ database . northwind ( ) )
namespace microsoft _ data _ entity _ query _ expression _ translators
namespace microsoft _ data _ entity _ query _ expression _ translators
namespace microsoft _ data _ entity _ query _ expression _ translators
namespace microsoft _ data _ entity _ query _ expression _ translators
namespace microsoft _ data _ entity _ query _ expression _ translators
return new i _ xunit _ test _ case [ ] { new skipped _ test _ case ( diagnostic _ message _ sink , discovery _ options . method _ display _ or _ default ( ) , test _ method ) } ;
start _ value = target . start _ value ,
is _ cyclic = target . is _ cyclic
public virtual list < migration _ operation > operations { get ; } = new list < migration _ operation > ( ) ;
public one _ to _ one _ builder one _ to _ one < t _ related _ entity > (
public one _ to _ one _ builder foreign _ key < t _ dependent _ entity > (
t = > ! string . is _ null _ or _ empty ( schema ) & & t . schema = = schema | | t . name = = table ) )
message ) ;
message ) ;
? state
force _ state _ when _ unknown _ key : force ) ;
? state
force _ state _ when _ unknown _ key : force ,
t = > ! string . is _ null _ or _ empty ( schema ) & & t . schema = = schema | | t . name = = table ) )
using ( var context = create _ context ( ) )
var model = ( model ) model ;
| | state _ data . is _ property _ flagged ( navigation . get _ index ( ) , property _ flag . is _ loaded ) ;
discriminator . has _ value ( entity _ type , entity _ type . short _ name ( ) ) ;
: right ;
assert . not _ null ( model . find _ sequence ( STR ) ) ; var sequence = model . find _ sequence ( STR ) ;
protected virtual internal _ entity _ type _ builder entity _ type _ builder { get ; }
entity _ type _ builder . to _ table ( null ) ;
= > property ( property _ type : null , property _ name : property _ name , member _ info : null , configuration _ source : configuration _ source , type _ configuration _ source : null ) ;
= > property ( member _ info . get _ member _ type ( ) , member _ info . get _ simple _ member _ name ( ) , member _ info , configuration _ source , configuration _ source ) ;
type property _ type , string property _ name , bool set _ type _ configuration _ source , bool from _ data _ annotation )
property _ type , property _ name , from _ data _ annotation ? configuration _ source . data _ annotation : configuration _ source . convention , set _ type _ configuration _ source
var id _ property = entity _ type _ builder . property ( typeof ( string ) , id _ property _ name , configuration _ source . convention ) ;
var j _ object _ property = entity _ type _ builder . property ( typeof ( j _ object ) , j _ object _ property _ name , configuration _ source . convention ) ;
. first _ or _ default ( i = > index . declaring _ entity _ type . find _ property ( i ) = = null ) ;
entry , concurrency _ property , generator . generate _ next , false , true , false , false ,
entry , concurrency _ property , generator . generate _ next , false , true , false ,
var property _ builder = entity _ type _ builder . property ( typeof ( guid ) , STR , configuration _ source . explicit ) ;
var property _ builder = entity _ type _ builder . property ( typeof ( guid ) , STR , configuration _ source . explicit ) ;
var property _ builder = entity _ type _ builder . property ( typeof ( int ) , STR , configuration _ source . explicit ) ;
var property _ builder = entity _ type _ builder . property ( typeof ( int ) , STR , configuration _ source . explicit ) ;
var property _ builder = entity _ type _ builder . property ( typeof ( string ) , STR , configuration _ source . explicit ) ;
var property _ builder = entity _ type _ builder . property ( typeof ( string ) , STR , configuration _ source . explicit ) ;
entity _ type _ builder . property ( typeof ( string ) , STR , configuration _ source . convention ) ;
entity _ type _ builder . property ( typeof ( string ) , STR , configuration _ source . explicit ) ;
entity _ type _ builder . property ( typeof ( string ) , STR , configuration _ source . convention ) ;
var property _ builder = entity _ type _ builder . property ( typeof ( string ) , STR , configuration _ source . explicit ) ;
var property _ builder = entity _ type _ builder . property ( typeof ( string ) , STR , configuration _ source . explicit ) ;
var property _ builder = entity _ type _ builder . property ( typeof ( string ) , STR , configuration _ source . explicit ) ;
var property _ builder = entity _ type _ builder . property ( typeof ( string ) , STR , configuration _ source . explicit ) ;
var shadow _ key _ property = principal _ entity _ builder . property ( typeof ( int ) , STR , configuration _ source . convention ) ;
dependent _ entity _ builder . property ( typeof ( int ) , order . id _ property . name , configuration _ source . convention ) ;
new [ ] { entity _ builder . property ( typeof ( int ) , STR , configuration _ source . convention ) . metadata . name , property . name } ,
( entity _ builder , property ) = > entity _ builder . property ( typeof ( guid ) , STR , configuration _ source . explicit ) ) ;
var shadow _ property = dependent _ entity _ builder . property ( typeof ( guid ) , STR , configuration _ source . convention ) ;
entity _ builder . property ( typeof ( int ) , order . id _ property . name , configuration _ source . convention ) ;
derived _ entity _ builder . property ( typeof ( string ) , special _ order . specialty _ property . name , configuration _ source . convention ) ;
( entity _ builder , property ) = > entity _ builder . property ( property . clr _ type , ( ( i _ property ) property ) . name , configuration _ source . explicit ) ) ;
var shadow _ property = entity _ builder . property ( typeof ( guid ) , STR , configuration _ source . convention ) ;
( entity _ builder , property ) = > entity _ builder . property ( typeof ( guid ) , STR , configuration _ source . explicit ) ) ;
var shadow _ property = entity _ builder . property ( typeof ( guid ) , STR , configuration _ source . convention ) ;
typeof ( int ) , order . id _ property . name , configuration _ source . data _ annotation , type _ configuration _ source : configuration _ source . data _ annotation ) ) ;
entity _ builder . property ( typeof ( int ) , order . id _ property . name , configuration _ source . convention , type _ configuration _ source : null ) ) ;
typeof ( string ) , order . id _ property . name , configuration _ source . convention , type _ configuration _ source : configuration _ source . convention ) ) ;
var derived _ property = derived _ entity _ builder . property ( typeof ( int ) , STR , configuration _ source . data _ annotation ) ;
var derived _ property = derived _ entity _ builder . property ( typeof ( byte ) , STR , configuration _ source . convention ) ;
var property _ builder = entity _ builder . property ( typeof ( int ) , STR , configuration _ source . convention ) ;
var property _ builder = derived _ entity _ builder . property ( typeof ( int ) , nameof ( special _ order . specialty ) , configuration _ source . data _ annotation ) ;
assert . null ( derived _ entity _ builder . property ( typeof ( string ) , nameof ( special _ order . specialty ) , configuration _ source . data _ annotation ) ) ;
property _ builder = derived _ entity _ builder . property ( typeof ( string ) , nameof ( special _ order . specialty ) , configuration _ source . explicit ) ;
assert . not _ null ( entity _ builder . property ( typeof ( int ) , order . id _ property . name , configuration _ source . data _ annotation ) ) ;
assert . not _ null ( entity _ builder . property ( typeof ( int ) , order . id _ property . name , configuration _ source . explicit ) ) ;
if ( property . is _ fixed _ length ( ) )
var db _ function = model . find _ db _ function ( method ) ;
new [ ] { entity _ builder . property ( typeof ( int ) , STR , configuration _ source . convention ) . metadata } ,
new [ ] { entity _ builder . property ( typeof ( int ) , STR , configuration _ source . convention ) . metadata } ,
index _ builder . has _ filter ( null ) ;
dependent _ entity _ builder . property ( typeof ( int ) , STR , configuration _ source . convention ) ;
principal _ entity _ builder . property ( typeof ( int ) , STR , configuration _ source . convention ) ;
dependent _ entity _ builder . property ( typeof ( string ) , STR , configuration _ source . convention ) ; principal _ entity _ builder . property ( typeof ( string ) , STR , configuration _ source . convention ) ;
var property _ builder = entity _ builder . property ( typeof ( string ) , STR , configuration _ source . explicit ) ;
var property _ builder = entity _ builder . property ( typeof ( string ) , STR , configuration _ source . explicit ) ;
var property _ builder = entity _ builder . property ( typeof ( int ) , STR , configuration _ source . data _ annotation ) ;
var property _ builder = entity _ builder . property ( typeof ( int ) , STR , configuration _ source . convention ) ;
assert . true ( property . is _ fixed _ length ( ) ) ;
assert . false ( property . is _ fixed _ length ( ) ) ;
var sequence = model _ builder . model . find _ sequence ( STR ) ;
var db _ func = model _ builder . model . find _ db _ function ( test _ method ) as db _ function ;
public virtual task delete _ async ( cancellation _ token cancellation _ token = default ( cancellation _ token ) )
var source = create _ source ( STR , configured : true , available : false , store : mock . of < data _ store > ( ) ) ;
where [ g ] . [ discriminator ] in ( n ' gear ' , n ' officer ' ) and ( [ g ] . [ has _ soul _ patch ] < > cast ( 1 as bit ) )
linq _ operator _ provider , result _ operator _ handler ,
private readonly i _ async _ grouping < t _ key , t _ out > grouping ;
i _ async _ grouping < t _ key , t _ out > grouping ,
private static i _ enumerable < t _ entity > entity _ query < t _ entity > ( query _ context query _ context ,
private static i _ enumerable < value _ buffer > projection _ query ( query _ context query _ context ,
private static i _ enumerable < i _ grouping < t _ key , t _ out > > track _ grouped _ entities < t _ key , t _ out , t _ in > ( i _ enumerable < i _ grouping < t _ key , t _ out > > groupings ,
private class tracking _ grouping < t _ key , t _ out , t _ in > : i _ grouping < t _ key , t _ out >
private readonly i _ grouping < t _ key , t _ out > grouping ;
i _ grouping < t _ key , t _ out > grouping ,
optional _ default _ value ) ;
query _ sources _ requiring _ materialization . add ( sub _ query _ source ) ;
convention _ set _ builder = new composite _ convention _ set _ builder ( ( i _ read _ only _ list < i _ convention _ set _ builder > ) convention _ set _ builders ) ;
context = create _ context ( ) ;
context = create _ context ( ) ;
namespace microsoft _ entity _ framework _ core _ benchmarks _ models _ adventure _ works
namespace microsoft _ entity _ framework _ core _ benchmarks _ models _ adventure _ works
from [ weapons ] as [ t . gear . weapons ]
from [ weapons ] as [ t . gear . weapons ]
from [ weapons ] as [ g . weapons ]
from [ weapons ] as [ g . weapons ]
from [ weapons ] as [ g . weapons ]
from [ weapons ] as [ o . weapons ]
from [ weapons ] as [ g . weapons ]
from [ weapons ] as [ . weapons ]
from [ weapons ] as [ g . weapons ]
from [ weapons ] as [ . weapons ]
from [ weapons ] as [ g . weapons ]
from [ weapons ] as [ . weapons ]
from [ weapons ] as [ g . weapons ]
from [ weapons ] as [ . weapons ]
from [ weapons ] as [ g . weapons ]
from [ weapons ] as [ . weapons ]
protected t _ annotations lazy _ annotations ;
protected t _ annotations lazy _ annotations ; protected t _ entities lazy _ entities ;
protected t _ properties lazy _ properties ; protected t _ annotations lazy _ annotations ;
northwind _ data . seed ( context ) ;
: i _ primary _ key _ convention , i _ foreign _ key _ convention , i _ foreign _ key _ removed _ convention , i _ model _ convention
return property ;
private entity _ queryable < t _ entity > entity _ queryable ;
visit _ navigation _ properties ( model _ builder ) ;
visit _ column ( builder , column ) ;
entity _ configuration . navigation _ property _ initializer _ configurations . add ( configuration _ factory . create _ navigation _ property _ initializer _ configuration ( navigation _ property _ name , other _ entity _ type . name ) ) ;
write _ literal ( STR ) ;   write ( ex . get _ type ( ) . name ) ;
throw new argument _ exception ( strings . index _ properties _ wrong _ entity ( property . format ( properties ) , name ) ) ; } indexes . value . add ( properties , index ) ;
sequence _ name = > new sql _ server _ sequence _ value _ generator _ state ( sequence ) ) ;
test _ event _ logging (
candidate _ property = member _ info ;
new relational _ convention _ set _ builder _ dependencies ( sql _ server _ type _ mapper , null , null , null ) , new sql _ server _ sql _ generation _ helper ( new relational _ sql _ generation _ helper _ dependencies ( ) ) )
test _ event _ logging ( typeof ( core _ event _ id ) , typeof ( core _ logger _ extensions ) , fake _ factories ) ;
new relational _ convention _ set _ builder _ dependencies ( relational _ type _ mapper , null , null , null ) )
var sorted _ command _ sets = topological _ sort ( commands ) ;
( ) = > relational _ strings . using _ connection ( connection . database , connection . data _ source ) ) ;
( ) = > relational _ strings . using _ connection ( connection . database , connection . data _ source ) ) ;
( ) = > relational _ strings . generating _ down ( migration . get _ id ( ) ) ) ;
( ) = > relational _ strings . generating _ up ( migration . get _ id ( ) ) ) ;
e = > string . equals ( e , migration . key , string _ comparison . ordinal _ ignore _ case ) ) )
builder . append _ line ( command . command _ text ) ; } builder . append ( sql . batch _ separator ) ;
public class null _ semantics _ query _ sqlite _ fixture : null _ semantics _ query _ relational _ fixture
public class null _ semantics _ query _ sql _ server _ fixture : null _ semantics _ query _ relational _ fixture
public class updates _ in _ memory _ fixture : updates _ fixture _ base
public class updates _ sql _ server _ fixture : updates _ fixture _ base
public class updates _ sqlite _ fixture : updates _ fixture _ base
using ( var context = new early _ learning _ center ( ) )
conditional _ fact
public virtual list < fluent _ api _ configuration > get _ fluent _ api _ configurations ( bool use _ fluent _ api _ only )
inner _ item _ parameter ) )
return annotations . get _ annotation ( relational _ annotation _ names . default _ value ) ;
& & ( ( method _ call _ expression . arguments [ 0 ] as constant _ expression ) ? . value as array ) ? . length = = 0 )
return member _ assignment . expression ;
foreach ( var kvp in projection _ mapping ) { projection _ mapping [ kvp . key ] = kvp . value ;
new db _ context _ options ( ) . use _ model ( model ) . use _ in _ memory _ store ( ) ) ) . scoped _ service _ provider ;
logger . log ( log _ level . information , ( int ) event _ id , state , null , ( s , ) = > formatter ( s ) ) ;
conditional _ theory
conditional _ theory
var columns = db _ model . tables . single ( ) . columns ;
columns = { table . columns . element _ at ( 0 ) } ,
columns = { table . columns . element _ at ( 1 ) } ,
columns = { table . columns . element _ at ( 1 ) } ,
indexes ,
var columns = db _ model . tables . single ( ) . columns ;
return new one _ to _ one _ builder ( builder . referenced _ key ( key _ expression . get _ property _ access _ list ( ) ) ) ;
assert . null ( model . remove _ entity _ type ( typeof ( customer ) ) ) ;
assert . null ( model . remove _ entity _ type ( typeof ( customer ) . full _ name ) ) ;
assert . null ( model . remove _ entity _ type ( typeof ( customer ) . full _ name ) ) ;
assert . null ( model . remove _ entity _ type ( typeof ( customer ) ) ) ;
var navigations = foreign _ key . get _ navigations ( ) . to _ list ( ) ;
assert . null ( entity _ type . remove _ key ( new [ ] { id _ property } ) ) ;
assert . same ( key , entity _ type . remove _ key ( new [ ] { id _ property } ) ) ;
principal _ entity _ type _ builder ? ? = ( old _ relationship _ inverted
dependent _ entity _ type _ builder ? ? = ( old _ relationship _ inverted
dependent _ properties ? ? = ( ( metadata . get _ properties _ configuration _ source ( ) ? . overrides ( configuration _ source ) ? ? false )
principal _ properties ? ? = ( ( metadata . get _ principal _ key _ configuration _ source ( ) ? . overrides ( configuration _ source ) ? ? false )
is _ unique ? ? = ( ( metadata . get _ is _ unique _ configuration _ source ( ) ? . overrides ( configuration _ source ) ? ? false )
is _ required ? ? = ( ( metadata . get _ is _ required _ configuration _ source ( ) ? . overrides ( configuration _ source ) ? ? false )
is _ ownership ? ? = ( ( metadata . get _ is _ ownership _ configuration _ source ( ) ? . overrides ( configuration _ source ) ? ? false )
delete _ behavior ? ? = ( ( metadata . get _ delete _ behavior _ configuration _ source ( ) ? . overrides ( configuration _ source ) ? ? false )
principal _ end _ configuration _ source ? ? = ( principal _ entity _ type _ builder . metadata ! = dependent _ entity _ type _ builder . metadata
suppliers ? ? = new observable _ collection < i _ supplier > ( ) ;
reviews ? ? = new observable _ collection < i _ product _ review > ( ) ; photos ? ? = new observable _ collection < i _ product _ photo > ( ) ; barcodes ? ? = new observable _ collection < i _ barcode > ( ) ;
suppliers ? ? = new observable _ collection < i _ supplier > ( ) ;
reviews ? ? = new observable _ collection < i _ product _ review > ( ) ; photos ? ? = new observable _ collection < i _ product _ photo > ( ) ; barcodes ? ? = new observable _ collection < i _ barcode > ( ) ;
fact
fact
if ( builder . initial _ catalog ! = null )
string migration _ namespace , string migration _ name , i _ read _ only _ list < migration _ operation > up _ operations , i _ read _ only _ list < migration _ operation > down _ operations ) ;
. where ( mi = > mi . get _ parameters ( ) . length = = 2 & & mi . get _ parameters ( ) [ 1 ] . parameter _ type = = typeof ( cancellation _ token ) )
= > new test _ sql _ server _ retrying _ execution _ strategy ( ) . execute (
list _ logger _ factory ,
list _ logger _ factory ,
list _ logger _ factory ,
list _ logger _ factory ,
. add _ singleton < i _ logger _ factory > ( test _ sql _ logger _ factory )
. add _ singleton < i _ logger _ factory > ( test _ sql _ logger _ factory )
. add _ singleton < i _ logger _ factory > ( test _ sql _ logger _ factory )
. add _ singleton < i _ logger _ factory > ( test _ sql _ logger _ factory )
. add _ singleton < i _ logger _ factory > ( test _ sql _ logger _ factory )
. add _ singleton < i _ logger _ factory > ( test _ sql _ logger _ factory )
. add _ singleton < i _ logger _ factory > ( test _ sql _ logger _ factory )
. add _ singleton < i _ logger _ factory > ( test _ sql _ logger _ factory )
. add _ singleton < i _ logger _ factory > ( test _ sql _ logger _ factory )
. add _ singleton < i _ logger _ factory > ( test _ sql _ logger _ factory )
. add _ singleton < i _ logger _ factory > ( test _ sql _ logger _ factory )
cancellation _ token _ source . cancel ( ) ; cancellation _ token _ source = null ;
. add _ singleton < i _ logger _ factory > ( test _ sql _ logger _ factory )
. add _ singleton < i _ logger _ factory > ( test _ sql _ logger _ factory )
. add _ singleton < i _ logger _ factory > ( test _ sql _ logger _ factory )
. add _ singleton < i _ logger _ factory > ( test _ sql _ logger _ factory )
. add _ singleton < i _ logger _ factory > ( test _ sql _ logger _ factory )
. add _ singleton < i _ logger _ factory > ( test _ sql _ logger _ factory )
. add _ singleton < i _ logger _ factory > ( test _ sql _ logger _ factory )
. add _ singleton < i _ logger _ factory > ( test _ sql _ logger _ factory )
. add _ singleton < i _ logger _ factory > ( test _ sql _ logger _ factory )
. add _ singleton < i _ logger _ factory > ( test _ sql _ logger _ factory )
. add _ singleton < i _ logger _ factory > ( test _ sql _ logger _ factory )
. add _ singleton < i _ logger _ factory > ( test _ sql _ logger _ factory ) . build _ service _ provider ( ) ;
select distinct [ o ] . [ customer _ id ] , [ o ] . [ order _ id ]
conditional _ fact
conditional _ theory
if ( ! property _ base . is _ shadow _ property )
return bind _ operand ( expression ) ;
protected virtual test _ model _ builder create _ model _ builder ( ) = > create _ test _ model _ builder ( test _ helpers . instance . create _ convention _ builder ( ) ) ;
var builder = create _ model _ builder ( ) ;
var id _ property = ( i _ property ) entity . find _ property ( customer . id _ property ) ;
var model _ builder = create _ model _ builder ( ) ;
return new model _ builder ( convention _ set ) ;
namespace microsoft _ entity _ framework _ core _ tests _ metadata
namespace microsoft _ entity _ framework _ core _ tests _ metadata _ conventions
using microsoft _ entity _ framework _ core _ tests _ metadata _ conventions ;
namespace microsoft _ entity _ framework _ core _ sql _ server _ tests _ metadata _ conventions
? nvarcharmax
if ( entity _ type ! = null )
if ( primary _ key )
= > has _ value ( entity _ type _ builder , value ) ;
var base _ entity _ type _ builder = entity _ type _ builder ;
generate ( new create _ database _ operation ( STR ) , generate _ idempotent _ sql : true ) . sql ) ;
generate ( new drop _ database _ operation ( STR ) , generate _ idempotent _ sql : true ) . sql ) ;
generate ( new create _ sequence _ operation ( new sequence ( STR ) ) , generate _ idempotent _ sql : true ) . sql ) ;
generate ( new drop _ sequence _ operation ( STR ) , generate _ idempotent _ sql : true ) . sql ) ;
generate (
generate ( new drop _ table _ operation ( STR ) , generate _ idempotent _ sql : true ) . sql ) ;
generate ( new rename _ table _ operation ( STR , STR ) , generate _ idempotent _ sql : true ) . sql ) ;
generate ( new move _ table _ operation ( STR , STR ) , generate _ idempotent _ sql : true ) . sql ) ;
generate ( new add _ column _ operation ( STR , column ) , generate _ idempotent _ sql : true ) . sql ) ;
generate ( new drop _ column _ operation ( STR , STR ) , generate _ idempotent _ sql : true ) . sql ) ;
generate (
generate (
generate (
generate (
generate ( new drop _ primary _ key _ operation ( STR , STR ) , generate _ idempotent _ sql : true ) . sql ) ;
generate (
generate ( new drop _ foreign _ key _ operation ( STR , STR ) , generate _ idempotent _ sql : true ) . sql ) ;
generate (
generate ( new drop _ index _ operation ( STR , STR ) , generate _ idempotent _ sql : true ) . sql ) ;
generate (
using system ;
generate ( new create _ database _ operation ( STR ) , generate _ idempotent _ sql : false ) . sql ) ;
generate ( new drop _ database _ operation ( STR ) , generate _ idempotent _ sql : false ) . sql ) ;
generate (
generate ( new drop _ sequence _ operation ( STR ) , generate _ idempotent _ sql : false ) . sql ) ;
generate (
generate ( new drop _ table _ operation ( STR ) , generate _ idempotent _ sql : false ) . sql ) ;
generate (
generate (
generate (
generate (
generate (
generate (
generate (
generate (
generate (
generate (
generate (
generate (
generate ( new drop _ foreign _ key _ operation ( STR , STR ) , generate _ idempotent _ sql : false ) . sql ) ;
generate (
generate ( new drop _ index _ operation ( STR , STR ) , generate _ idempotent _ sql : false ) . sql ) ;
generate (
return ( sql _ server _ value _ generation _ strategy ) annotation ;
return tuple ;
: invert ( configuration _ source ) ;
public virtual exception exception { get ; set ; }
( c , ex ) = > assert . is _ type < db _ update _ exception > ( ex ) ,
query _ optimizer . optimize ( query _ compilation _ context , query _ model ) ;
query _ optimizer . optimize ( query _ compilation _ context , query _ model ) ;
correlate _ subquery _ method = correlate _ subquery _ method . make _ generic _ method ( collection _ query _ model . select _ clause . selector . type , navigation . get _ collection _ accessor ( ) . collection _ type ) ;
connection _ uri = test _ environment . default _ connection ;
var model = model _ builder . finalize _ model ( ) ;
assert . equal ( navigation _ to _ dependent . name , new _ fk . get _ navigation _ to _ dependent ( ) . name ) ; assert . equal ( navigation _ to _ principal . name , new _ fk . get _ navigation _ to _ principal ( ) . name ) ;
namespace microsoft _ entity _ framework _ core _ design _ tests _ migrations _ design
namespace microsoft _ entity _ framework _ core _ design _ tests _ migrations _ design
namespace microsoft _ entity _ framework _ core _ design _ tests _ design
namespace microsoft _ entity _ framework _ core _ design _ tests _ design
namespace microsoft _ entity _ framework _ core _ design _ tests _ design
fact
theory
return new composite _ entity _ key _ factory ( k ) ;
i _ read _ only _ list < i _ property > properties , value _ buffer value _ buffer ) = > create ( value _ buffer [ properties [ 0 ] . index ] ) ;
= vr = > key _ factory . create ( key _ properties , vr ) ;
type . get _ primary _ key ( ) ) . create ( type . get _ primary _ key ( ) . properties , entry ) ) ;
assert . null ( model _ builder . model . find _ entity _ type ( typeof ( c ) ) ) ;
using microsoft _ entity _ framework _ core _ test _ utilities ; using microsoft _ entity _ framework _ core _ test _ utilities _ fake _ provider ;
using microsoft _ entity _ framework _ core _ test _ models _ complex _ navigations _ model ; using microsoft _ entity _ framework _ core _ test _ utilities ; using microsoft _ entity _ framework _ core _ test _ utilities _ xunit ;
builder . append ( entity _ type . annotations _ to _ debug _ string ( indent : indent + STR ) ) ;
. name ( STR ) ;
. name ( STR ) ;
. name ( STR ) ;
. table ( STR ) ;
. table ( STR , STR ) ;
model _ builder . sequence ( ) ;
model _ builder . sequence ( STR ) ;
conditional _ fact
conditional _ fact
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
private readonly i _ logger logger ;
i _ relational _ connection connection , string sql , cancellation _ token cancellation _ token = new cancellation _ token ( ) ) = > task . from _ result < object > ( interlocked . add ( ref current , block _ size ) ) ;
var sorted _ entities = create _ command _ batch _ preparer ( )
var sorted _ entities = create _ command _ batch _ preparer ( )
create _ command _ batch _ preparer ( state _ manager : state _ manager , sensitive _ logging : true ) . batch _ commands ( new [ ] { first _ entry , second _ entry } ) . to _ array ( ) ) . message ) ;
conditional _ theory
using system ;
integer = sqlite _ integer , real = sqlite _ float , text = sqlite _ text , blob = sqlite _ blob
native _ methods . sqlite _ bind _ blob ( stmt , index , value , value . length , sqlite _ transient ) ;
native _ methods . sqlite _ bind _ text ( stmt , index , value , sqlite _ transient ) ;
= expression . lambda ( new sub _ query _ expression ( collection _ query _ model ) ) ;
public abstract class relational _ test _ store : test _ store
public class table _ splitting _ sqlite _ test : table _ splitting _ test _ base
assert . equal ( customers , inner _ context . set < transaction _ customer > ( ) . order _ by ( c = > c . id ) . to _ list ( ) ) ;
using ( var inner _ context = create _ context ( ) )
assert . equal ( customers , await inner _ context . set < transaction _ customer > ( ) . order _ by ( c = > c . id ) . to _ list _ async ( ) ) ;
using ( var inner _ context = create _ context ( ) )
public abstract class end _ to _ end _ test : i _ disposable
context . simple _ entities . add ( new simple _ entity { string _ property = STR } ) ;
public class shared _ in _ memory _ end _ to _ end _ test : end _ to _ end _ test
public class shared _ sql _ server _ end _ to _ end _ test : end _ to _ end _ test
public class table _ splitting _ sql _ server _ test : table _ splitting _ test _ base
public class sqlite _ test _ store : relational _ test _ store
public abstract class table _ splitting _ test _ base
using ( create _ test _ store ( on _ model _ creating ) )
using ( create _ test _ store ( on _ model _ creating ) )
public class sql _ server _ test _ store : relational _ test _ store
return current _ expression ;
return new [ ] { operation } ;
protected value _ generator _ factory _ selector (
return null ;
public virtual i _ state _ manager state _ manager = > dependencies . state _ manager ;
return 1 ;
return 1 ;
using ( await sql _ server _ northwind _ context . get _ shared _ store _ async ( ) )
internal _ property _ builder builder , type property _ type , bool? shadow _ property , configuration _ source ? configuration _ source )
i _ mutable _ entity _ type i _ mutable _ foreign _ key . principal _ entity _ type
public virtual i _ model finalize _ model ( ) = > builder . metadata . finalize _ model ( ) ;
not _ null i _ query _ compilation _ context _ factory query _ compilation _ context _ factory , not _ null i _ update _ adapter _ factory update _ adapter _ factory )
public class query _ context : i _ parameter _ values
return try _ expand _ navigation ( inner _ expression , member _ identity . create ( member _ expression . member ) ) ? ? member _ expression . update ( inner _ expression ) ;
: . one _ to _ one _ optional _ f . one _ to _ one _ optional _ f . one _ to _ one _ optional _ f . name ) = = STR ) ) ;
return sort ( diff ( source , target , diff _ context ) , diff _ context ) ;
conditional _ theory
var property _ builder = entity _ type _ builder . property ( STR , typeof ( guid ) , configuration _ source . explicit ) ;
var property _ builder = entity _ type _ builder . property ( STR , typeof ( guid ) , configuration _ source . explicit ) ;
var property _ builder = entity _ type _ builder . property ( STR , typeof ( int ) , configuration _ source . explicit ) ;
var property _ builder = entity _ type _ builder . property ( STR , typeof ( int ) , configuration _ source . explicit ) ;
var property _ builder = entity _ type _ builder . property ( STR , typeof ( int ) , configuration _ source . explicit ) ;
var property _ builder = entity _ type _ builder . property ( STR , typeof ( int ) , configuration _ source . explicit ) ;
var property _ builder = entity _ type _ builder . property ( STR , typeof ( string ) , configuration _ source . explicit ) ;
var property _ builder = entity _ type _ builder . property ( STR , typeof ( string ) , configuration _ source . explicit ) ;
var property _ builder = entity _ type _ builder . property ( STR , typeof ( string ) , configuration _ source . convention ) ;
var property _ builder = entity _ type _ builder . property ( STR , typeof ( string ) , configuration _ source . explicit ) ;
var property _ builder = entity _ type _ builder . property ( STR , typeof ( string ) , configuration _ source . explicit ) ;
var property _ builder = entity _ type _ builder . property ( STR , typeof ( string ) , configuration _ source . explicit ) ;
var property _ builder = entity _ type _ builder . property ( STR , typeof ( string ) , configuration _ source . explicit ) ;
var property _ builder = entity _ type _ builder . property ( STR , typeof ( string ) , configuration _ source . explicit ) ;
new [ ] { entity _ builder . property ( STR , typeof ( int ) , configuration _ source . convention ) . metadata . name , property . name } ,
( entity _ builder , property ) = > entity _ builder . property ( STR , typeof ( guid ) , configuration _ source . explicit ) ) ;
var shadow _ property = dependent _ entity _ builder . property ( STR , typeof ( guid ) , configuration _ source . convention ) ;
( entity _ builder , property ) = > entity _ builder . property ( STR , typeof ( guid ) , configuration _ source . explicit ) ) ;
var shadow _ property = entity _ builder . property ( STR , typeof ( guid ) , configuration _ source . convention ) ;
assert . same ( property _ builder , entity _ builder . property ( order . id _ property . name , typeof ( order ) , configuration _ source . explicit ) ) ;
var property _ builder = entity _ builder . property ( order . id _ property . name , typeof ( order ) , configuration _ source . data _ annotation ) ;
var property _ builder = entity _ builder . property ( order . id _ property . name , typeof ( int ) , configuration _ source . convention ) ;
derived _ entity _ builder . property ( order . id _ property . name , typeof ( int ) , configuration _ source . data _ annotation ) ) . message ) ;
assert . null ( entity _ builder . property ( order . id _ property . name , typeof ( order ) , configuration _ source . data _ annotation ) ) ;
entity _ builder . property ( order . id _ property . name , typeof ( order ) , configuration _ source . explicit ) ) . message ) ;
assert . not _ null ( entity _ builder . property ( order . id _ property . name , typeof ( order ) , configuration _ source . convention ) ) ;
assert . not _ null ( entity _ builder . property ( order . id _ property . name , typeof ( order ) , configuration _ source . data _ annotation ) ) ;
assert . not _ null ( entity _ builder . property ( order . id _ property . name , typeof ( order ) , configuration _ source . explicit ) ) ;
entity _ builder . property ( order . id _ property . name , typeof ( order ) , configuration _ source . explicit ) ) . message ) ;
return execute _ command . create ( ref args ) . execute ( args ) ;
b . index ( STR ) ;
. foreign _ key < customer > ( c = > c . customer _ id ) ;
. foreign _ key < customer > ( c = > c . customer _ id ) ;
. foreign _ key < customer > ( c = > c . customer _ id ) ;
. foreign _ key < customer > ( c = > c . customer _ id ) ;
. foreign _ key < customer > ( c = > c . customer _ id ) ;
. foreign _ key < customer > ( c = > c . customer _ id ) ;
. foreign _ key < customer > ( c = > c . id ) ;
. foreign _ key < customer > ( c = > c . id ) ;
. foreign _ key < customer > ( c = > c . id ) ;
model _ builder . entity ( STR , b = > b . foreign _ key ( STR , STR ) ) ;
b . foreign _ key < fake _ entity > ( c = > c . related _ id ) ;
. foreign _ key < related _ fake _ entity > ( c = > c . related _ id ) ;
statement _ executor . execute _ non _ query ( master _ connection , create _ create _ operations ( ) ) ; clear _ pool ( ) ;
new expression _ string _ builder ( ) . build ( query ) ,
query _ compilation _ context ) ;
using xunit ;
public virtual void navigation _ collection _ changed ( internal _ entity _ entry entry , i _ navigation navigation , i _ set < object > added , i _ set < object > removed )
not _ null i _ relational _ value _ buffer _ factory _ factory value _ buffer _ factory _ factory ,
| | ( declaring _ type = = typeof ( entity _ framework _ queryable _ extensions )
operation ,
operation ,
operation ,
can _ be _ null ref t _ related ? navigation _ field ,
can _ be _ null ref t _ value ? target ,
can _ be _ null ref t _ value ? target ,
can _ be _ null ref t _ value ? target ,
can _ be _ null ref t _ value ? target ,
private t _ entity ? find _ tracked ( object [ ] key _ values , out i _ read _ only _ list < i _ property > key _ properties )
protected class relational _ type _ mapping _ info : type _ mapping _ info
= > has _ base _ type ( typeof ( t _ base _ type ) ) ;
query _ context . query _ buffer . start _ tracking ( entity ) ;
query _ context . query _ buffer . start _ tracking ( entity ) ;
results _ grouping append _ bulk _ insert _ operation (
not _ null string name , configuration _ source configuration _ source , bool? owned = false ) = > entity ( new type _ identity ( name ) , configuration _ source , owned ) ;
var entity _ type _ builder = entity _ type _ builder . model _ builder . entity (
var entity _ type _ builder = entity _ type _ builder . model _ builder . entity (
using microsoft _ entity _ framework _ core _ query _ navigation _ expansion _ internal ;
using microsoft _ entity _ framework _ core _ query _ navigation _ expansion _ internal ; namespace microsoft _ entity _ framework _ core _ query _ internal
namespace microsoft _ entity _ framework _ core _ query _ internal
select top ( p ) [ c ] . [ customer _ id ] , [ c ] . [ company _ name ] , coalesce ( [ c ] . [ region ] , n ' zz ' ) as [ region ]
( string container _ id , j _ token document , string partition _ key ) parameters )
( string container _ id , string item _ id , j _ object document , string partition _ key ) parameters )
( string container _ id , string item _ id , j _ object document , string partition _ key ) parameters ,
( string container _ id , string document _ id , string partition _ key ) parameters )
fact
fact
fact
fact
fact
expression . new _ array _ init (
var target _ type = n . get _ target _ type ( ) ;
i _ async _ enumerable < t > source , type context _ type , i _ logger logger )
private static value _ buffer create _ value _ buffer (
= > value _ buffer . with _ offset ( value _ buffer _ offset ) ;
private static t _ entity create _ entity < t _ entity > (
query _ source ) ;
i _ enumerable < t > source , type context _ type , i _ logger logger )
query _ source ) ;
command _ string _ builder . append _ line ( STR ) ;
command _ string _ builder . append _ line ( sql _ generation _ helper . statement _ terminator ) ;
. append _ line ( sql _ generation _ helper . statement _ terminator ) ;
assert . throws < invalid _ operation _ exception > ( ( ) = > a . has _ base _ type ( a ) ) . message ) ;
assert . throws < invalid _ operation _ exception > ( ( ) = > a . has _ base _ type ( b ) ) . message ) ;
assert . throws < invalid _ operation _ exception > ( ( ) = > a . has _ base _ type ( d ) ) . message ) ;
assert . throws < invalid _ operation _ exception > ( ( ) = > b . has _ base _ type ( a ) ) . message ) ;
assert . throws < invalid _ operation _ exception > ( ( ) = > b . has _ base _ type ( a ) ) . message ) ;
assert . throws < invalid _ operation _ exception > ( ( ) = > a . has _ base _ type ( b ) ) . message ) ;
assert . throws < invalid _ operation _ exception > ( ( ) = > b . has _ base _ type ( a ) ) . message ) ;
assert . throws < invalid _ operation _ exception > ( ( ) = > b . has _ base _ type ( a ) ) . message ) ;
assert . throws < invalid _ operation _ exception > ( ( ) = > b . has _ base _ type ( a ) ) . message ) ;
assert . throws < invalid _ operation _ exception > ( ( ) = > a . has _ base _ type ( b ) ) . message ) ;
cb . owns _ one ( c = > c . sub _ child , scb = > scb . has _ foreign _ key ( STR ) ) ;
cb . owns _ one ( c = > c . sub _ child , scb = > scb . has _ foreign _ key ( STR ) ) ;
model _ builder . entity < non _ signed _ integer _ key _ entity > ( e = > e . has _ data ( entity ) ) ;
model _ builder . entity < a > ( e = > e . has _ data ( new a ( ) ) ) ;
conditional _ fact
private i _ enumerable < i _ value _ reader > execute _ value _ reader (
shaped _ query _ compiling _ expression _ visitor _ dependencies dependencies , query _ compilation _ context query _ compilation _ context )
namespace microsoft _ data _ sq _ lite _ interop
public class built _ in _ data _ types _ in _ memory _ fixture : built _ in _ data _ types _ fixture _ base
public class built _ in _ data _ types _ sqlite _ fixture : built _ in _ data _ types _ fixture _ base
public class built _ in _ data _ types _ sql _ server _ fixture : built _ in _ data _ types _ fixture _ base
t _ result execute _ async < t _ result > ( [ not _ null ] expression query , cancellation _ token cancellation _ token ) ;
private static t _ result execute _ async < t _ source , t _ result > (
private static t _ result execute _ async < t _ source , t _ result > (
private static t _ result execute _ async < t _ source , t _ result > (
{ typeof ( i _ member _ translator _ plugin ) , new service _ characteristics ( service _ lifetime . singleton , multiple _ registrations : true ) } ,
member _ info . declaring _ type , property _ type , element _ type ) ;
assert . false ( new in _ memory _ data _ store _ source ( configuration _ mock . object ) . is _ configured ) ;
assert . true ( new in _ memory _ data _ store _ source ( mock . of < db _ context _ configuration > ( ) ) . is _ available ) ;
if ( ! sources [ 0 ] . is _ available )
assert . false ( new sql _ server _ data _ store _ source ( configuration _ mock . object ) . is _ configured ) ;
assert . true ( new sql _ server _ data _ store _ source ( configuration _ mock . object ) . is _ available ) ;
assert . false ( new sql _ server _ data _ store _ source ( configuration _ mock . object ) . is _ available ) ;
private readonly i _ in _ memory _ store database ;
public virtual i _ in _ memory _ store store = > database ;
append _ line ( ) ;
append _ line ( ) ;
append _ line ( ) ;
append _ line ( ) ;
append _ line ( ) ;
append _ line ( ) ;
append _ line ( ) ; transforming _ visitor . string _ builder . append ( STR ) ;
append _ line ( ) ;
append _ line ( ) ;
append _ line ( STR + node . result ) ;
append _ line ( STR ) ;
append _ line ( STR + node . target . type . short _ display _ name ( ) + STR + node . target + STR ) ;
append _ line ( core _ strings . invalid _ member _ init _ binding ) ;
append _ line ( STR ) ;
append _ line ( STR ) ;
entity _ type . set _ primary _ key ( matching _ properties ) ;
entity _ type . add _ key ( matching _ properties ) ;
return process _ set _ operation ( source , generic _ method , inner _ source ) ;
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
conditional _ theory
where [ g ] . [ discriminator ] in ( n ' gear ' , n ' officer ' ) STR
where [ g ] . [ discriminator ] in ( n ' gear ' , n ' officer ' )
conditional _ theory
conditional _ fact
conditional _ theory
conditional _ theory
sqlite _ bind _ blob ( stmt , index , blob ) ;
= > sqlite _ bind _ double ( stmt , index , value ) ;
= > sqlite _ bind _ int ( stmt , index , value ) ;
= > sqlite _ bind _ null ( stmt , index ) ;
private readonly list < sqlite _ stmt > prepared _ statements = new list < sqlite _ stmt > ( ) ;
var expected _ params = sqlite _ bind _ parameter _ count ( stmt ) ;
var name = sqlite _ bind _ parameter _ name ( stmt , i ) ;
sqlite _ reset ( stmt ) ;
changes + = sqlite _ changes ( connection . handle ) ;
case sqlite _ integer :
case sqlite _ float :
case sqlite _ text :
case sqlite _ blob :
case sqlite _ null :
case sqlite _ integer :
case sqlite _ text :
case sqlite _ blob :
case sqlite _ null :
var rc = sqlite _ table _ column _ metadata (
sqlite _ reset ( stmt _ queue . dequeue ( ) . stmt ) ;
: record . is _ db _ null ( ordinal ) ;
= > sqlite _ result _ blob ( ctx , value ) ;
= > sqlite _ result _ double ( ctx , value ) ;
= > sqlite _ result _ int ( ctx , value ) ;
= > sqlite _ result _ null ( ctx ) ;
= > sqlite _ result _ text ( ctx , value ) ;
= > sqlite _ close ( db ) ;
= > sqlite _ libversion ( ) ;
flags | = sqlite _ open _ readonly ;
flags | = sqlite _ open _ readwrite ;
flags | = sqlite _ open _ readwrite | sqlite _ open _ create | sqlite _ open _ memory ; if ( ( flags & sqlite _ open _ uri ) = = 0 ) { flags | = sqlite _ open _ uri ;
flags | = sqlite _ open _ sharedcache ;
flags | = sqlite _ open _ privatecache ;
& & ( flags & sqlite _ open _ uri ) = = 0
var rc = sqlite _ open ( filename , out db , flags , vfs : null ) ;
rc = sqlite _ create _ collation ( db , item . key , item . value . state , item . value . collation ) ;
rc = sqlite _ create _ function ( db , item . key . name , item . key . arity , item . value . state , item . value . func ) ;
rc = sqlite _ enable _ load _ extension ( db , 1 ) ;
rc = sqlite _ enable _ load _ extension ( db , extensions _ enabled ? 1 : 0 ) ;
rc = sqlite _ enable _ load _ extension ( db , 1 ) ;
rc = sqlite _ enable _ load _ extension ( db , 0 ) ;
using ( var backup = sqlite _ backup _ init ( destination . db , destination _ name , db , source _ name ) )
rc = sqlite _ errcode ( destination . db ) ;
rc = sqlite _ backup _ step ( backup , - 1 ) ;
sqlite _ result _ error ( ctx , ex . message ) ;
sqlite _ result _ error _ code ( ctx , sql _ ex . sqlite _ error _ code ) ;
var flags = is _ deterministic ? sqlite _ deterministic : 0 ;
var rc = sqlite _ create _ function (
sqlite _ result _ error ( ctx , context . exception . message ) ;
sqlite _ result _ error _ code ( ctx , sql _ ex . sqlite _ error _ code ) ;
var flags = is _ deterministic ? sqlite _ deterministic : 0 ;
var rc = sqlite _ create _ function (
assert . equal ( sqlite _ readonly , ex . sqlite _ error _ code ) ;
assert . equal ( sqlite _ cantopen , ex . sqlite _ error _ code ) ;
assert . equal ( sqlite _ busy , ex . sqlite _ error _ code ) ;
assert . equal ( sqlite _ cantopen , ex . sqlite _ error _ code ) ;
resources . sqlite _ native _ error ( sqlite _ error , resources . udf _ called _ with _ null ( STR , 0 ) ) ,
assert . equal ( sqlite _ error , ex . sqlite _ error _ code ) ;
= > get _ sqlite _ type ( ordinal ) = = sqlite _ null ;
if ( sqlite _ type = = sqlite _ text )
case sqlite _ float : case sqlite _ integer :
case sqlite _ float : case sqlite _ integer :
case sqlite _ integer :
case sqlite _ float :
case sqlite _ text :
case sqlite _ blob :
case sqlite _ null :
var rc = sqlite _ blob _ open (
length = sqlite _ blob _ bytes ( blob ) ;
sqlite _ rollback _ hook ( connection . handle , null , null ) ;
sqlite _ rollback _ hook ( connection . handle , null , null ) ;
if ( rc = = sqlite _ ok | | rc = = sqlite _ row | | rc = = sqlite _ done )
| | rc ! = sqlite _ errcode ( db ) )
message = sqlite _ errstr ( rc ) + STR + resources . default _ native _ error ;
message = sqlite _ errmsg ( db ) ; extended _ error _ code = sqlite _ extended _ errcode ( db ) ;
integer = sqlite _ integer ,
real = sqlite _ float ,
text = sqlite _ text ,
blob = sqlite _ blob
= > sqlite _ value _ double ( values [ ordinal ] ) ;
= > sqlite _ value _ int ( values [ ordinal ] ) ;
= > sqlite _ value _ text ( values [ ordinal ] ) ;
= > sqlite _ value _ blob ( values [ ordinal ] ) ;
= > sqlite _ value _ type ( values [ ordinal ] ) ;
first _ properties . format _ columns ( ) ) ) ;
first _ properties . format _ columns ( ) ) ) ;
first _ properties . format _ columns ( ) ) ) ;
first _ properties . format _ columns ( ) ) ) ;
var sequence = model . relational ( ) . find _ sequence ( STR ) ;
return get _ annotations ( entity _ type . root _ type ( ) ) . discriminator _ property ;
func < i _ queryable < t _ item > , i _ queryable < bool > > query , bool assert _ order = false )
private async task assert _ query < t _ item > (
test _ helpers . assert _ results (
private async task assert _ query < t _ item > (
test _ helpers . assert _ results (
private async task assert _ query < t _ item > (
test _ helpers . assert _ results (
private async task assert _ query < t _ item , t _ item > (
test _ helpers . assert _ results (
test _ helpers . assert _ results (
private async task assert _ query < t _ item , t _ item > (
test _ helpers . assert _ results (
private async task assert _ query < t _ item , t _ item , t _ item > (
test _ helpers . assert _ results (
constraint STR my _ pk STR primary key ( STR foo STR , STR bar STR )
STR , generate ( new add _ primary _ key _ operation ( STR , STR , new [ ] { STR , STR } , is _ clustered : false ) ) . sql ) ;
if ( target _ type . get _ type _ info ( ) . is _ interface
conditional _ theory
conditional _ theory
conditional _ theory
where [ g ] . [ discriminator ] in ( n ' gear ' , n ' officer ' )
assert _ sent _ messages _ consistent ( login , message ) ; assert _ sent _ messages _ consistent ( login ) ;
assert _ sent _ messages _ consistent ( login , message ) ; assert _ sent _ messages _ consistent ( login ) ;
assert _ sent _ messages _ consistent ( login , message ) ; assert _ sent _ messages _ consistent ( login ) ;
assert _ sent _ messages _ consistent ( login , message ) ; assert _ sent _ messages _ consistent ( login ) ;
using microsoft _ data _ entity _ relational _ migrations _ utilities ;
using microsoft _ data _ entity _ relational _ migrations _ infrastructure ;
return operation _ processor . process ( operations , new model ( ) , model ) ;
return operation _ processor . process ( operations , model , new model ( ) ) ;
using microsoft _ data _ entity _ relational _ migrations _ infrastructure ;
using microsoft _ data _ entity _ relational _ migrations _ infrastructure ;
not _ null reverse _ engineering _ generator generator , not _ null i _ entity _ type entity _ type , not _ null string namespace _ name )
not _ null reverse _ engineering _ generator generator , not _ null i _ entity _ type entity _ type , not _ null string namespace _ name )
public task < object > execute _ scalar _ async ( i _ relational _ connection connection , bool manage _ connection = true , cancellation _ token cancellation _ token = default ( cancellation _ token ) )
public task < relational _ data _ reader > execute _ reader _ async ( i _ relational _ connection connection , bool manage _ connection = true , i _ read _ only _ dictionary < string , object > parameters = null , cancellation _ token cancellation _ token = default ( cancellation _ token ) )
public task < object > execute _ scalar _ async ( i _ relational _ connection connection , bool manage _ connection = true , cancellation _ token cancellation _ token = default ( cancellation _ token ) )
public task < relational _ data _ reader > execute _ reader _ async ( i _ relational _ connection connection , bool manage _ connection = true , i _ read _ only _ dictionary < string , object > parameters = null , cancellation _ token cancellation _ token = default ( cancellation _ token ) )
= > ( int ) await create _ has _ tables _ command ( ) . execute _ scalar _ async ( connection , cancellation _ token : cancellation _ token ) ! = 0 ;
public task < relational _ data _ reader > execute _ reader _ async ( i _ relational _ connection connection , bool manage _ connection = true , i _ read _ only _ dictionary < string , object > parameters = null , cancellation _ token cancellation _ token = default ( cancellation _ token ) )
public task < object > execute _ scalar _ async ( i _ relational _ connection connection , bool manage _ connection = true , cancellation _ token cancellation _ token = default ( cancellation _ token ) )
verify _ produced _ expression < int , bool > ( value = > value . any _ async ( e = > true , default ) ) ;
verify _ produced _ expression < int , int > ( value = > value . single _ async ( e = > true , default ) ) ;
demote _ query _ source ( query _ source ) ; } } ) ;
= typeof ( random ) . get _ runtime _ method ( nameof ( random . next ) , new [ ] { typeof ( int ) } ) ;
= typeof ( random ) . get _ runtime _ method ( nameof ( random . next ) , new [ ] { typeof ( int ) , typeof ( int ) } ) ;
query _ context . start _ tracking ( entity , entity _ tracking _ infos [ i ] ) ;
} else { query _ context . start _ tracking ( entity _ or _ collection , entity _ tracking _ infos [ i ] ) ;
return create _ key ( entity _ type , entity _ type . get _ key ( ) . properties , this ) ;
return create _ key ( foreign _ key . referenced _ entity _ type , foreign _ key . properties , this ) ;
protected internal virtual void on _ model _ creating ( [ not _ null ] model _ builder builder )
has _ null _ value = true ; continue ;
has _ null _ value = true ; continue ;
has _ null _ value = true ; continue ;
has _ null _ value = true ; continue ;
assert . equal ( 1 , store _ command . parameter _ values . count ) ;
conditional _ fact
fact
fact
fact
fact
fact
fact
fact
fact
fact
fact
fact
fact
fact
fact
fact
fact
fact
fact
fact
fact
fact
fact
fact
fact
fact
theory
theory
theory
theory
theory
theory
theory
theory
theory
theory
theory
theory
theory
theory
theory
theory
theory
theory
theory
theory
theory
theory
theory
theory
theory
fact
fact
fact
fact
fact
public override model _ builder _ factory model _ builder _ factory = > model _ builder _ factory ;
public override model _ source model _ source = > model _ source ;
public override model _ builder _ factory model _ builder _ factory = > model _ builder _ factory ;
public override model _ source model _ source = > model _ source ;
benchmark
typeof ( non _ primitive _ as _ property _ entity ) . display _ name ( full _ name : false ) , STR , typeof ( navigation _ as _ property ) . display _ name ( full _ name : false ) ) ,
core _ strings . property _ not _ mapped ( typeof ( primitive _ property _ entity ) . display _ name ( full _ name : false ) , STR , typeof ( int ) . display _ name ( ) ) ,
core _ strings . property _ not _ added ( typeof ( non _ primitive _ value _ type _ property _ entity ) . display _ name ( full _ name : false ) , STR , typeof ( cancellation _ token ) . name ) ,
entity _ type . display _ name ( ) , actual _ property . name , property _ type . display _ name ( full _ name : false ) ) ) ;
entity _ type . display _ name ( ) , actual _ property . name , property _ type . display _ name ( full _ name : false ) ) ) ;
entity _ type . display _ name ( ) , actual _ property . name , property _ type . display _ name ( full _ name : false ) ) ) ;
assert . equal ( core _ strings . property _ not _ mapped ( typeof ( non _ primitive _ as _ property _ entity ) . display _ name ( full _ name : false ) , STR , typeof ( long ) . display _ name ( full _ name : false ) ) ,
assert . equal ( core _ strings . property _ not _ mapped ( typeof ( non _ primitive _ as _ property _ entity ) . display _ name ( full _ name : false ) , STR , typeof ( long ) . display _ name ( full _ name : false ) ) ,
if ( ! inverse _ navigations . try _ get _ value ( inverse _ navigation , out list < tuple < property _ info , type > > referencing _ navigations _ with _ attribute ) )
. referenced _ key < order > ( e = > e . order _ id ) . foreign _ key < order _ details > ( e = > e . order _ id ) ;
var dependent _ type = model . get _ entity _ type ( typeof ( order ) ) ; var principal _ type = model . get _ entity _ type ( typeof ( order _ details ) ) ;
return create _ get _ store _ value _ expression ( j _ object _ expression , store _ name , property . clr _ type , property . get _ type _ mapping ( ) ) ; } private expression create _ get _ store _ value _ expression (
return navigation _ binding _ expression . root _ parameter . build _ property _ access ( navigation _ binding _ expression . navigation _ tree _ node . to _ mapping ) ;
public override int get _ hash _ code ( ) = > hash _ code . combine ( alias , expression ) ;
. add ( type _ mapper . get _ mapping _ for _ value ( null ) . create _ parameter ( command , name , null ) ) ;
var nullable _ string _ values = new [ ] { STR , STR , null } ;
file . append _ all _ text ( log _ file _ path , message + environment . new _ line ) ;
var nullable _ string _ values = new [ ] { STR , STR , null } ;
var collection _ navigation = navigations . single _ or _ default ( n = > n . is _ collection ( ) ) ;
var query _ executor = new query _ model _ visitor ( ) . create _ query _ executor < t _ result > ( query _ model ) ;
public static object handle _ exception ( i _ app _ host app _ host , object request , exception ex )
startup _ instance = create _ startup _ instance ( startup _ type ) ;
/ raw
foreach ( var request _ filter in request _ filters )
foreach ( var response _ filter in response _ filters )
public class return _ void _ dto _ request : i _ return _ void
var path _ controller = path _ parts [ 0 ] . to _ lower ( ) ;
var path _ action = path _ parts [ 1 ] . to _ lower ( ) ;
var enum _ value = convert . change _ type ( value , type ) . to _ string ( ) ;
var path _ controller = path _ parts [ 0 ] . to _ lower ( ) ;
t _ delegate d = target _ method . create _ delegate ( typeof ( t _ delegate ) , this _ parameter ) as t _ delegate ;
if ( page _ result . return _ value ! = null )
public routeless _ reqstar any ( routeless _ reqstar request )
if ( mi . get _ parameters ( ) . length ! = 1 )
api _ member _ description _ range _ description _ parameter _ type _ path _ data _ type _ double _ is _ required _ true
data _ member
data _ member
data _ member
protected sealed override void initialize ( ) { }
protected sealed override void initialize ( )
protected sealed override void initialize ( )
new [ ] { typeof ( string ) } , null ) ;
var value = type . enum _ values ? [ i ] ;
provider = name ; auth _ realm = realm ;
using system ;
provider = name ;
auth _ realm = realm ;
tag _ builder tag _ builder = new tag _ builder ( STR ) ;
namespace service _ stack _ html
stack < string > name _ parts = new stack < string > ( ) ;
method _ call _ expression method _ expression = ( method _ call _ expression ) part ;
return filter < from > ( request , typed _ query . create _ query ( get _ db < from > ( request ) , model , dynamic _ params , this ) , model ) ;
return execute ( request ) ;
var verified = rsa . verify _ data ( data _ to _ verify , signature , hash _ algorithm ) ;
var verified = rsa . verify _ data ( data _ to _ verify , signature , hash _ algorithm ) ;
var verified = rsa . verify _ data ( data _ to _ verify , signature , hash _ algorithm ) ;
var verified = rsa . verify _ data ( data _ to _ verify , signature , hash _ algorithm ) ;
template _ args = person ;
while ( is _ listening )
while ( is _ listening ) { if ( listener = = null ) return ;
listener . begin _ get _ context ( listener _ callback , listener ) ;
if ( listener = = null ) return ;
namespace service _ stack _ text _ tests
namespace service _ stack _ text _ tests
namespace service _ stack _ text _ tests
public static i _ application _ builder use _ service _ stack ( this i _ application _ builder app , app _ host _ base app _ host )
if ( ! using _ integrated _ pipeline )
get { return files ; }
get { return dirs ; }
public type type { get ; set ; }
namespace service _ stack
using service _ stack _ auth ; using service _ stack _ fluent _ validation ;
namespace service _ stack
public class requires _ custom _ auth _ service : service
public class custom _ authenticate _ attribute : authenticate _ attribute
public class base _ service < t > : service
namespace service _ stack
namespace service _ stack
public class exception _ with _ response _ status _ service : service
public class exception _ no _ response _ status _ service : service
public class exception _ no _ response _ dto _ service : service
public class uncatched _ exception _ service : service
public class exception _ with _ response _ status _ service : service
public class exception _ no _ response _ status _ service : service
public class exception _ no _ response _ dto _ service : service
namespace service _ stack
namespace service _ stack
namespace service _ stack
namespace service _ stack
class uncached _ proto _ buf _ email _ service : service
class cached _ proto _ buf _ email _ service : service
namespace service _ stack
public class check _ box _ service : service
namespace service _ stack
namespace service _ stack
public class mini _ profiler _ service : service
namespace service _ stack
public class multiple _ test _ request _ service : service
public class swagger _ feature _ service : service
namespace service _ stack
public class custom _ form _ data _ service : service
namespace service _ stack
namespace service _ stack
? ? default _ http _ handler ;
assert . that ( result . normalize _ new _ lines ( ) , is . equal _ to ( STR ) ) ;
assert . that ( result . normalize _ new _ lines ( ) , is . equal _ to ( STR ) ) ;
assert . that ( result . normalize _ new _ lines ( ) , is . equal _ to ( STR ) ) ;
public static template _ scope _ context add _ item _ to _ scope ( this template _ scope _ context scope , string item _ binding , object item , int index )
namespace service _ stack
register _ services ( service _ controller , get _ hiro _ type _ factory ( ) ) ;
register _ services ( service _ controller , get _ hiro _ type _ factory ( ) ) ;
private static readonly string web _ host _ physical _ path = null ; private static readonly string default _ root _ file _ name = null ;
if ( ! is _ null _ or _ empty ( default _ operation _ namespace ) ) return null ;
if ( is _ null _ or _ empty ( attr . namespace ) ) continue ;
return is _ null _ or _ empty ( path ) | | path [ path . length - 1 ] = = '/'
if ( is _ null _ or _ empty ( last _ path _ info ) ) return null ;
if ( is _ null _ or _ empty ( path _ info ) )
if ( ! is _ null _ or _ empty ( request . path _ info ) ) return request . path _ info . trim _ end ( '/' ) ;
if ( ! is _ null _ or _ empty ( path _ info ) ) return path _ info ;
if ( ! is _ null _ or _ empty ( path _ info ) ) return path _ info ;
if ( ! is _ null _ or _ empty ( specified _ content _ type ) ) return specified _ content _ type ;
var has _ default _ content _ type = ! is _ null _ or _ empty ( default _ content _ type ) ;
if ( is _ null _ or _ empty ( from _ path _ info ) )
if ( is _ null _ or _ empty ( absolute _ uri ) )
var user _ auth _ id = session ? . user _ auth _ id ;
var feature = app _ host ? . get _ plugin < server _ events _ feature > ( ) ;
var register _ method _ info = method _ info . make _ generic _ method ( service _ type ) ;
var register _ method _ info = method _ info . make _ generic _ method ( service _ type ) ;
if ( ! is _ null _ or _ empty ( specified _ content _ type ) )
else if ( is _ null _ or _ empty ( config . default _ content _ type ) )
return has _ container ? . container ;
var response = request _ context ? . response ;
public static js _ token to _ token ( this object value , js _ token binding )
assembly entry _ assembly ;
var supports _ client _ validation = validator as i _ client _ validatable ;
auto _ query _ viewer _ default _ search _ field _ title _ default _ search _ text _ service _ stack _ default _ search _ type _ contains _ description _ find _ service _ stack _ questions _ on _ stack _ overflow _ icon _ url _ material _ icons _ cast _ title _ explore _ stack _ overflow _ questions
return first _ async _ error = async _ responses [ i ] ;
public static i _ list < array _ result > get ( this i _ hello _ array _ operations operations , string names = default ( string ) )
public static i _ list < array _ result > create ( this i _ hello _ array _ operations operations , string names = default ( string ) , hello _ array body = default ( hello _ array ) )
public static i _ list < array _ result > post ( this i _ hello _ array _ operations operations , string names = default ( string ) , hello _ array body = default ( hello _ array ) )
public static i _ list < array _ result > delete ( this i _ hello _ array _ operations operations , string names = default ( string ) )
public static i _ list < list _ result > get ( this i _ hello _ list _ operations operations , string names = default ( string ) )
public static i _ list < list _ result > create ( this i _ hello _ list _ operations operations , string names = default ( string ) , hello _ list body = default ( hello _ list ) )
public static i _ list < list _ result > post ( this i _ hello _ list _ operations operations , string names = default ( string ) , hello _ list body = default ( hello _ list ) )
public static i _ list < list _ result > delete ( this i _ hello _ list _ operations operations , string names = default ( string ) )
var value = type . enum _ values ? [ i ] ;
var value = type . enum _ values ? [ i ] ;
app _ host . dispose ( ) ;  }
return request _ obj . serialize _ and _ format ( ) ;
container . auto _ wire ( attr _ instance ) ;
container . auto _ wire ( attr _ instance ) ;
var dto _ a _ validator = ( dto _ a _ request _ validator ) app _ host . try _ resolve < i _ validator < dto _ a > > ( ) ;
return provider _ o _ auth _ access
var page = get _ page ( path _ info ) ;
preserve
preserve
preserve
preserve
preserve
preserve _ all _ members _ true
preserve
preserve
preserve
preserve
preserve
preserve _ all _ members _ true
preserve
preserve
preserve
preserve
preserve
preserve _ all _ members _ true
include _ file = { { ' file . txt ' | include _ file } }
api _ member _ data _ type _ double _ description _ range _ description _ is _ required _ true _ parameter _ type _ path
api _ member _ data _ type _ double _ description _ range _ description _ is _ required _ true _ parameter _ type _ path
api _ member _ data _ type _ double _ description _ range _ description _ is _ required _ true _ parameter _ type _ path
public interface i _ message
def ( STR , - 1 , ( i , a ) = > { var c = ( cell ) a [ 0 ] ; foreach ( var x in c ) { print ( i , str ( x , false ) ) ; } return a [ a . length - 1 ] ;
stream _ serializer = serialize _ to _ stream ,
factory _ fn , request _ context , cache _ client , cache _ key , null ) ;
factory _ fn , request _ context ,
stream _ serializer = serialize _ to _ stream ,
serialize _ to _ stream , csv _ serializer . deserialize _ from _ stream ) ;
stream _ serializer = serialize _ to _ stream ,
using system ;
test
args . append ( type _ value ( ctor _ arg . type , ctor _ arg . value ) ) ;
using system ;
public static object to _ optimized _ result ( this i _ request request , object dto )
req . set _ item ( keywords . invoke _ verb , http _ methods . post ) ; req . request _ attributes & = ~ request _ attributes . reply ; req . request _ attributes | = request _ attributes . one _ way ; try {
digest _ hash = new digest _ auth _ functions ( ) . create _ ha ( new _ user . user _ name , digest _ auth _ provider . realm , password ) ;
if ( value . length > one _ gb )
if ( handler _ path = = null ) return ; if ( location _ path = = null )
using ( use _ scope . output _ stream )
caches = name _ list ;
return new string ( value _ bytes ) ;
return stream _ serializer . deserialize _ from _ stream < t > ( stream ) ;
return stream _ serializer . deserialize _ from _ stream ( type , stream ) ;
if ( is _ null _ or _ empty ( to . error _ code ) )
if ( is _ null _ or _ empty ( to . message ) )
req . try _ resolve < i _ server _ events > ( ) . pulse ( req . query _ string [ STR ] ) ;
? ? STR + anon _ user _ id ;
namespace service _ stack
public int? x _ forwarded _ port
var request _ obj = reflection _ utils . populate _ object ( dto _ type . create _ instance ( ) ) ;
var var _ value = evaluate _ any _ bindings ( evaluate ( arg , scope _ context , var ) , scope _ context ) ;
var var _ value = evaluate _ any _ bindings ( evaluate ( arg , scope _ context , var ) , scope _ context ) ;
internal static byte [ ] encode _ packet ( bool from _ server , bool is _ response , uint id , byte [ ] [ ] words )
private static byte [ ] encode _ words ( byte [ ] [ ] words )
var html = render _ in _ template _ if _ any ( markdown _ page , scope _ args , html _ page ) ;
return ( w , x ) = > write _ string ( w , ( string ) x ) ;
log . error ( STR + ex . message , ex ) ;
public static i _ service _ routes add < t > ( this i _ service _ routes service _ routes , string rest _ path , apply _ to verbs , params expression < func < t , object > > [ ] property _ expressions )
i _ async _ result result = this . listener . begin _ get _ context ( web _ request _ callback , this . listener ) ;
sb _ roles . append ( STR + role ) ;
return new attribute _ filtered _ response {
path _ info = raw _ url ;
auth _ key = auth _ key ,
response _ handler = ( action < exception , string > ) mi . create _ delegate ( typeof ( action < exception , string > ) ) ;
if ( app _ host ! = null )
return result ? . item ;
attribute _ usage _ attribute _ targets _ class _ attribute _ targets _ method _ inherited _ true _ allow _ multiple _ true
public service _ metadata metadata { get ; set ; } public service _ controller service _ controller { get ; set ; }
assert . that ( app _ host . rest _ paths . count , is . equal _ to ( 0 ) ) ;
return host _ context . metadata . get _ operation _ type ( operation _ name ) ;
get { return assert _ app _ host ( ) . service _ controller ; }
if ( ! template _ config . dont _ evaluate _ blocks _ named . contains ( block _ name ) )
var value _ string = get _ string ( value _ bytes ) ;
var value _ string = get _ string ( value _ bytes ) ;
page . write _ to ( writer ) ;
page . init ( view _ engine : this , http _ req : http _ req , http _ res : http _ res ) ;
return endpoint _ attributes . external ;
return broadcast _ address ;
var response = client . send < attribute _ filtered _ response > ( new attribute _ filtered { request _ filter _ executed = false } ) ;
return meta ? . base _ uri ;
container . register ( new memory _ cache _ client ( ) ) ;
output _ stream . write ( b _ output , 0 , b _ output . length ) ;
service _ client . send ( registration ) ;
service _ client . send ( new _ user _ registration ) ;
service _ client . send ( new content _ manager _ only ( ) ) ;
var response = new _ user _ client . send ( new content _ manager _ only ( ) ) ;
service _ client . send ( new content _ permission _ only ( ) ) ;
var response = new _ user _ client . send ( new content _ permission _ only ( ) ) ;
return to _ compressed _ bytes ( result , serialize _ ctx ) ;
public override object create _ request ( i _ http _ request request , string operation _ name )
public mvc _ html _ string eval _ expr ( )
var directory _ nodes = get _ directories ( )
var file _ nodes = get _ files ( )
using service _ stack ;
namespace service _ stack
namespace service _ stack
namespace service _ stack
namespace service _ stack
namespace service _ stack
namespace service _ stack
namespace service _ stack
return key _ value _ data _ contract _ deserializer . instance . parse ( http _ req . form _ data , operation _ type ) ;
public profiler profiler { get ; private set ; }
internal profiler profiler { get ; private set ; }
storage = new http _ runtime _ cache _ storage ( time _ span . from _ days ( 1 ) ) ;
container . register < i _ cache _ client > ( default _ cache ) ;
container . register ( default _ cache ) ;
{ STR , photo _ url } ,
service _ model _ finder = service _ model _ finder . instance ,
all _ types . add _ range ( metadata . response _ types ) ;
foreach ( var pair in key _ value _ pairs )
return res . write _ error ( new argument _ exception ( STR + pos ) ) ;
return wsdl . execute ( http _ req , http _ res ) ;
return wsdl . execute ( http _ req , http _ res ) ;
start ( base _ url ) ;
task get _ async ( i _ return _ void request _ dto ) ;
task delete _ async ( i _ return _ void request _ dto ) ;
task post _ async ( i _ return _ void request _ dto ) ;
task put _ async ( i _ return _ void request _ dto ) ;
task custom _ method _ async ( string http _ verb , i _ return _ void request _ dto ) ;
public virtual task custom _ method _ async ( string http _ verb , i _ return _ void request _ dto )
operation _ type , request . query _ string , ex ) ;
operation _ type , deserializer , form _ data , ex ) ;
namespace service _ stack
init _ collections : ! type . is _ interface ( ) & & init _ collections ,
init _ collections : ! type . is _ interface ( ) & & init _ collections ,
private web _ request send _ request ( string request _ uri , object request )
var client = send _ request ( request _ uri , request ) ;
using ( var xw = new xml _ text _ writer ( ms , encoding ) )
using ( var xw = new xml _ text _ writer ( deflate _ stream , encoding ) )
using ( var xw = new xml _ text _ writer ( stream , encoding ) )
var result = load _ individually ( conn , id _ parameter ) ;
return db _ cmd . select < movie > ( ) ;
public object assign _ to ( template _ scope _ context scope , object value , string arg _ name )
template _ filters . add ( filter ) ;
code _ pages . add ( code _ page ) ;
action ( 1 ) ;      break ;
return this . memory . try _ get _ value ( key , out entry ) ;
this . memory [ key ] = entry ;
string serialized _ dto = serialize _ to _ string ( request , response _ dto ) ;
filter . invoke ( container ) . invoke ( request , response , dto ) ;
if ( config . add _ implicit _ version = = null & & ! config . initialize _ collections )
if ( config . add _ implicit _ version = = null & & ! config . initialize _ collections )
return operation ? . request _ type ;
return operation ? . service _ type ;
return operation ? . service _ type ;
return operation ? . response _ type ;
private readonly http _ listener _ response response ;
private readonly bool [ ] components _ with _ separators ;
throw new not _ supported _ exception ( STR ) ;
public static container container
return basic _ msg . to _ message < t > ( ) ;
var basic _ msg = get _ message ( queue _ name , no _ ack : false ) ; return basic _ msg . to _ message < t > ( ) ;
return msg _ result . to _ message < t > ( ) ;
serialize _ request _ to _ stream ( request _ context , request , stream ) ;
return stream _ deserializer ( type , from _ stream ) ;
var message _ bytes = this . read _ write _ client . r _ pop ( queue _ name ) ; return message _ bytes . to _ message < t > ( ) ;
return json _ object . parse ( json ) ;
return json . from _ json < t > ( ) ;
return o . to _ json ( ) ;
return zip _ stream . read _ fully ( ) ;
return zip _ stream . read _ fully ( ) ;
namespace service _ stack
namespace service _ stack
namespace service _ stack _ support _ web _ host
namespace service _ stack
namespace service _ stack
namespace service _ stack _ support _ web _ host
namespace service _ stack
digest _ hash = new digest _ auth _ functions ( ) . create _ ha ( new _ user . user _ name , digest _ auth _ provider . realm , password ) ;
return cached _ session ;
var cache = db . single _ by _ id < cache _ entry > ( key ) ;
return get _ value ( expr , scope _ context ) ;
failure . custom _ state = custom _ state _ provider ( context ) ;
return evaluate _ flag _ enum _ values ( typed _ value , enum _ type ) ;
return evaluate _ flag _ enum _ values ( typed _ value , enum _ type ) ;
return evaluate _ flag _ enum _ values ( typed _ value , enum _ type ) ;
private static expression remove _ unary ( expression to _ unwrap ) {
namespace service _ stack _ fluent _ validation { using system ;    using system _ collections _ generic ; using results ; using system _ linq ;
layout : alt - layout . html
public class register _ service : service
static read _ only _ memory < char > parse _ template _ body ( this read _ only _ memory < char > literal , read _ only _ memory < char > block _ name , out read _ only _ memory < char > body )
body = literal . slice ( 0 , pos ) . trim _ first _ new _ line ( ) ;
body = literal . slice ( 0 , pos ) . trim _ first _ new _ line ( ) ;
var len = math . min ( param _ values . length , args . length ) ;
return clr _ types _ to _ swagger _ scalar _ types . contains _ key ( type ) | | type . is _ enum ;
return clr _ types _ to _ swagger _ scalar _ types . contains _ key ( lookup _ type ) ? clr _ types _ to _ swagger _ scalar _ types [ lookup _ type ]
using service _ stack _ web _ host _ endpoints _ formats ; namespace service _ stack _ web _ host _ endpoints _ support _ markdown
namespace service _ stack _ web _ host _ endpoints _ support _ markdown
namespace service _ stack _ web _ host _ endpoints _ utils
to . add ( item ) ;
new [ ] { app _ settings . get _ string ( STR ) ? ? STR } ) ) ;
catch ( exception ex )
using system ;
var response = client . send ( request ) ;
response = new _ client . send ( request ) ;
var response = jwt _ client . send ( request ) ;
response = new _ client . send ( request ) ;
var response = client . send ( request ) ;
response = new _ client . send ( request ) ;
var response = client . send ( request ) ;
response = new _ client . send ( request ) ;
if ( commands _ string . is _ null _ or _ empty ( ) )
string content _ type , int status _ code ) { response . status _ code = status _ code ;
. first ( ctor = > ! ctor . is _ static ) ;
mq _ client . notify ( queue _ names < t > . out , message ) ;
publish ( message . to _ in _ queue _ name ( ) , message ) ;
var value = evaluate ( expr , scope _ context , var ) ;
var var _ value = evaluate ( arg , scope _ context , var ) ;
. start ( listening _ on ) ;
public string raw _ url = > request . get _ display _ url ( ) ; public string absolute _ uri = > request . get _ display _ url ( ) ;
headers = headers ,
headers = headers ,
template _ cache [ name ] = instance ;   }
var request _ obj = reflection _ utils . populate _ object ( dto _ type . create _ instance ( ) ) ;
var encrypted _ bytes = encrypt ( bytes , public _ key _ xml , rsa _ key _ length ) ;
var redis _ repo = new redis _ auth _ repository ( new basic _ redis _ client _ manager ( new [ ] { app _ settings . get _ string ( STR ) ? ? STR } ) ) ;
while ( i < literal . length & & literal . get _ char ( i ) . is _ white _ space ( ) )
public abstract class view _ page < t > : razor _ page < t > , i _ disposable
public i _ raw _ string validation _ summary ( script _ scope _ context scope , object except _ fields ) = >
public i _ raw _ string validation _ summary ( script _ scope _ context scope , object except _ fields , object html _ attrs )
log _ request ( req , request _ dto , response ) ;
this . http _ methods = ( verbs ? ? empty ) . split ( new [ ] { ',' , ' ' } , string _ split _ options . remove _ empty _ entries ) ;
namespace service _ stack _ web _ host _ integration _ tests _ tests
var q = auto _ query . create _ query ( dto , request ) ;
await item _ scope . write _ page _ async ( ) ;
public static category category ( int id , string category _ name , string description , byte [ ] picture )
public static supplier supplier (
public static product product (
throw new not _ implemented _ exception ( ) ;
namespace service _ stack _ web _ handlers
namespace service _ stack _ web _ asp _ net
using service _ stack _ web _ asp _ net ; using service _ stack _ web _ http _ listener ; namespace service _ stack _ web _ handlers
namespace service _ stack _ web _ http _ listener
namespace service _ stack _ web _ handlers
using service _ stack _ web _ asp _ net ; namespace service _ stack _ web _ handlers
using service _ stack _ web _ handlers ; namespace service _ stack _ web
return read _ data ( ) ;
public razor _ format razor _ format { get ; set ; }
var verified = rsa . verify _ data ( data _ to _ verify , signature , hash _ algorithm ) ;
namespace service _ stack _ web _ host _ http _ listener
return type _ serializer . deserialize _ from _ reader < t > ( reader ) ;
api _ member _ name _ sentence _ data _ type _ string _ description _ the _ sentence _ to _ echo _ is _ required _ true _ parameter _ type _ form _ allow _ multiple _ false
mq _ server . register _ handler < hello _ intro > ( execute _ message ) ;
var response = execute _ message ( m , req ) ;
await write _ page _ fragment _ async ( page _ scope , fragment , output _ stream , token ) ;
using service _ stack ;
public override void serialize _ to _ stream ( i _ request _ context request _ context , object request , system . io . stream stream )
public override object create _ request ( i _ http _ request request , string operation _ name )
api _ service _ description
api
api
api _ test
api
api
api
public string _ segment parse _ next _ token ( string _ segment literal , out object value , out js _ binding binding )
string display _ name = get _ display _ name ( context ) ;
if ( this . credentials ! = null ) client . credentials = this . credentials ; if ( this . auth _ info ! = null )
else if ( this . always _ send _ basic _ auth _ header ) client . add _ basic _ auth ( this . user _ name , this . password ) ;
var request _ state = ( async _ state < t > ) async _ result . async _ state ;
var web _ response = client . get _ response ( ) ;
var web _ response = client . get _ response ( ) ;
var web _ response = client . get _ response ( ) ;
var web _ response = web _ request . get _ response ( ) ;
throw new not _ implemented _ exception ( STR ) ;
using ( service as i _ disposable ) { } }
result [ property _ name . to _ camel _ case ( ) ] = new property _ route _ member ( property _ info ) ;
result [ field _ name . to _ camel _ case ( ) ] = new field _ route _ member ( field _ info ) ;
return ! type . is _ generic _ type _ definition & &
if ( type . is _ generic _ type )
var base _ type = validator . base _ type ;
while ( ! base _ type . is _ generic _ type )
base _ type = base _ type . base _ type ;
type cur = to _ check . is _ generic _ type ? to _ check . get _ generic _ type _ definition ( ) : to _ check ;
to _ check = to _ check . base _ type ;
if ( type . base _ type ! = null )
if ( ! ref _ types . contains ( type . base _ type ) )
ref _ types . add ( type . base _ type ) ; add _ referenced _ types ( type . base _ type , ref _ types ) ;
if ( service _ type . is _ abstract | | service _ type . contains _ generic _ parameters )
if ( service _ type . is _ abstract | | service _ type . contains _ generic _ parameters )
if ( service _ type . is _ abstract | | service _ type . contains _ generic _ parameters )
if ( service _ type . is _ abstract | | service _ type . contains _ generic _ parameters )
if ( ! pi . property _ type . is _ generic _ type ) continue ;
if ( ! ignore _ type _ fn ( type . base _ type ) | |
register _ type _ fn ( type . base _ type ) ;
if ( ! iface . is _ generic _ type & & ! iface . is _ system _ type ( ) & & ! iface . is _ service _ stack _ type ( ) )
if ( ! type . is _ generic _ type )
if ( type . is _ generic _ type )
generic _ args = type . is _ generic _ type ? get _ generic _ args ( type ) : null ,
is _ enum = type . is _ enum ? true : ( bool? ) null ,
meta _ type . inherits = to _ type _ name ( type . base _ type ) ;
if ( pi . property _ type . is _ generic _ type )
if ( type . is _ generic _ type )
is _ value _ type = pi . property _ type . is _ value _ type ? true : ( bool? ) null ,
is _ enum = pi . property _ type . is _ enum ? true : ( bool? ) null ,
is _ value _ type = pi . parameter _ type . is _ value _ type ? true : ( bool? ) null ,
is _ enum = pi . parameter _ type . is _ enum ? true : ( bool? ) null ,
var base _ type = type . base _ type ;
else if ( pi . property _ type . is _ array )
type . is _ class & & type ! = typeof ( string ) & & ! type . is _ generic _ type & &
public static readonly assembly ms _ cor _ lib _ assembly = typeof ( string ) . assembly ;
public static readonly assembly system _ web _ assembly = typeof ( http _ context ) . assembly ;
if ( ! type . is _ generic _ type ) return null ;
return type . is _ generic _ type & & type . get _ generic _ type _ definition ( ) = = typeof ( key _ value _ pair < , > ) ;
if ( ( ! is _ key _ value _ pair _ type ( schema _ type ) & & schema _ type . is _ value _ type ) | | schema _ type . is _ nullable _ type ( ) )
if ( ! schema _ type . is _ generic _ type )
var base _ type = schema _ type . base _ type ;
base _ type = base _ type . base _ type ;
public class dto _ get _ test _ service : service
. append ( value _ string ) ;
xw . formatting = formatting . indented ; } serializer . write _ object ( xw , from ) ; xw . flush ( ) ;
var response = ( get _ all _ users _ response ) get _ all _ handler . execute ( new get _ all _ users ( ) ) ;
public type register _ service ( type service _ type )
var response = new search _ reqstars _ response {
return split _ case ( text ) ;
return humanize ( text ) ;
return title _ case ( text ) ;
return pascal _ case ( text ) ;
return camel _ case ( text ) ;
credentials = new network _ credential ( api _ key , STR ) ,
request _ filter : req = > req . add _ api _ key _ auth ( api _ key ) ) ,
request _ filter : req = > req . add _ api _ key _ auth ( api _ key ) ) ,
request _ filter : req = > req . add _ api _ key _ auth ( api _ key ) ) ,
request _ filter : req = > req . add _ api _ key _ auth ( api _ key ) ) ,
request _ filter : req = > req . add _ api _ key _ auth ( api _ key ) ) ,
request _ filter : req = > req . add _ api _ key _ auth ( api _ key ) ) ,
request _ filter : req = > req . add _ api _ key _ auth ( api _ key ) ) ,
request _ filter : req = > req . add _ api _ key _ auth ( api _ key ) ) ,
request _ filter : req = > req . add _ api _ key _ auth ( api _ key ) ) ,
request _ filter : req = > req . add _ api _ key _ auth ( api _ key ) ) ,
request _ filter : req = > req . add _ bearer _ token ( api _ key ) ) ,
request _ filter : req = > req . add _ bearer _ token ( api _ key ) ) ,
request _ filter : req = > req . add _ api _ key _ auth ( api _ key ) ) ,
request _ filter : req = > req . add _ bearer _ token ( api _ key ) ) ,
request _ filter : req = > req . add _ bearer _ token ( api _ key ) ) ,
request _ filter : req = > req . add _ bearer _ token ( api _ key ) ) ,
request _ filter : req = > req . add _ bearer _ token ( api _ key ) ) ,
request _ filter : req = > req . add _ bearer _ token ( api _ key ) ) ,
request _ filter : req = > req . add _ bearer _ token ( api _ key ) ) ,
request _ filter : req = > req . add _ bearer _ token ( api _ key ) ) ,
return service ;
if ( repo . parent ! = null ) return repo . parent . full _ name ;
app _ host . register _ service ( typeof ( swagger _ resources _ service ) , new [ ] { STR } ) ; app _ host . register _ service ( typeof ( swagger _ api _ service ) , new [ ] { STR } ) ;
return get _ handler _ for _ path _ info ( http _ req , path _ translated ) ? ? not _ found _ http _ handler ;
. split ( new [ ] { '/' } , string _ split _ options . remove _ empty _ entries ) ;
operation _ id = name + path _ postfix + num + verb _ postfix ;
if ( apply _ response _ filters ( http _ req , http _ res , response ) )
var feature = content _ type . to _ feature ( ) ;
throw new not _ supported _ exception ( $ STR ) ;
return STR . fmt ( generic _ arg ( generic _ args [ 0 ] ) ) ;
return STR . fmt ( generic _ arg ( generic _ args [ 0 ] ) ) ;
return STR . fmt ( generic _ arg ( generic _ args [ 0 ] ) , generic _ arg ( generic _ args [ 1 ] ) ) ;
args . append ( generic _ arg ( arg ) ) ;
public static object create _ error _ response ( object request , exception ex , response _ status response _ status )
var csv _ rows = res . read _ lines ( ) . to _ list ( ) ;
var csv _ rows = res . read _ lines ( ) . to _ list ( ) ;
var csv _ rows = res . read _ lines ( ) . to _ list ( ) ;
var csv _ rows = res . read _ lines ( ) . to _ list ( ) ;
var csv _ rows = res . read _ lines ( ) . to _ list ( ) ;
public static i _ comparer < object > get _ comparer ( object x , interpreter i )
return http _ utility . parse _ query _ string ( query ) ;
headers = message . to _ headers ( ) . to _ name _ value _ collection ( ) ;
static _ file _ handler . set _ default _ file ( file . virtual _ path , file . read _ all _ bytes ( ) , file . last _ modified ) ;
var service _ factory = generate _ auto _ wire _ fn < t > ( ) ;
var service _ factory = generate _ auto _ wire _ fn < t > ( ) ;
result = app _ settings . get _ or _ create ( key , ( ) = > key + + + i ) ;
private object authenticate ( authenticate request , string provider , i _ auth _ session session , i _ auth _ provider o _ auth _ config )
public override object authenticate ( i _ service _ base auth _ service , i _ auth _ session session , authenticate request )
public override object authenticate ( i _ service _ base auth _ service , i _ auth _ session session , authenticate request )
public override object authenticate ( i _ service _ base auth _ service , i _ auth _ session session , authenticate request )
return type . is _ generic _ type & & type . get _ generic _ type _ definition ( ) = = typeof ( nullable < > ) ;
if ( model _ type . is _ value _ type | | model _ type . is _ nullable _ type ( ) )
if ( ! model _ type . is _ generic _ type )
var base _ type = model _ type . base _ type ;
base _ type = base _ type . base _ type ;
namespace service _ stack _ virtual _ path
return create _ urn < t > ( id ) ;
http _ web _ request _ filter ( client ) ;
where t : i _ auth _ session
throw new argument _ null _ exception ( typeof ( t ) . name ) ;
byte [ ] compressed _ bytes = serialized _ dto . compress ( request _ context . compression _ type ) ;
def ( STR , 1 , a = > ( a [ 0 ] is string s ) ? s . to _ upper ( ) : a [ 0 ] ! = null ? throw new lisp _ eval _ exception ( STR , a [ 0 ] ) : STR ) ;
http _ cookie . domain = cookie . domain ;
var html = transform ( markdown ) ;
public interface i _ user _ auth _ repository : i _ auth _ repository
return remote _ ip ? ? ( remote _ ip = x _ forwarded _ for ? ? ( x _ real _ ip ? ? request . user _ host _ address ) ) ;
return remote _ ip ? ? ( remote _ ip = x _ forwarded _ for ? ? ( x _ real _ ip ? ? request . user _ host _ address ) ) ;
var host _ directory _ path = assembly _ directory _ path + append _ partial _ path _ modifier ;
api _ member _ description _ the _ sentence _ to _ echo _ parameter _ type _ form _ data _ type _ string _ is _ required _ true _ name _ sentence
return execute ( request ) ;
last _ modified = template _ file . last _ modified , service = template _ service ,
return ctx ;
var http _ req = new asp _ net _ request ( context , path _ translated ) ;
return assert _ app _ host ( ) . service _ controller . execute ( request , http _ req ) ;
mock _ app _ host . container . register < i _ auth _ repository > ( user _ auth _ repository ) ;
where t _ attribute : attribute
where t _ attribute : attribute
where t _ attribute : attribute
where t _ attribute : attribute
where t _ attribute : attribute
where t _ attribute : attribute
where t _ attribute : attribute
where t _ attribute : attribute
port _ typeof _ http _ get _ endpoint _ attributes _ external _ endpoint _ attributes _ http _ get
: i _ service , i _ requires _ request _ context
public class cors _ feature _ service : i _ service
public class global _ cors _ feature _ service : i _ service
public class verb _ match _ service : i _ service
public class verb _ match _ service : i _ service
: i _ service , i _ requires _ request _ context
public class test _ service : i _ service
public class get _ customer _ service : i _ service
public class hello _ service : i _ service
public class hello _ service : i _ service
public class hello _ service : i _ service
public class basic _ service : i _ service
public class hello _ image _ service : i _ service
public class hello _ image _ service : i _ service
public class reset _ movie _ database _ service : i _ service
public class raw _ request _ service : i _ service
public class ioc _ scope _ service : i _ service , i _ disposable
public class failing _ service : i _ service
public class store _ customers _ service : i _ service
: i _ service
: i _ service
: i _ service
public class rest _ test _ service : i _ service
public class generic _ service < t > : i _ service
return new generic _ response { data = request . get _ type ( ) . full _ name } ;
public string error _ response _ except ( template _ scope _ context scope , object fields ) = >
public string error _ response _ except ( template _ scope _ context scope , response _ status error _ status , object fields )
foreach ( var field _ name in field _ names ) {
var response = web _ req . get _ response ( ) . get _ response _ stream ( ) . read _ to _ end ( ) ;
var error _ response = error _ web _ response . get _ response _ stream ( ) . read _ to _ end ( ) ;
return ms . read _ to _ end ( ) ;
var expected _ contents = uploaded _ file . open _ read ( ) . read _ to _ end ( ) ;
var value = get _ value _ from _ hash ( hash _ id , test _ key ) ;
var value = get _ value _ from _ hash ( hash _ id , test _ key ) ;
var value = get _ value _ from _ hash ( hash _ id , test _ key ) ;
set _ entry ( test _ key , STR ) ;
set _ entry ( test _ key , STR ) ;
set _ entry ( test _ key , test _ value ) ;
set _ entry ( test _ key , STR ) ;
set _ entry ( test _ key , test _ value ) ;
set _ entry ( test _ key , test _ value , expire _ in ) ;
set _ entry ( test _ key , test _ value ) ;
set _ entry ( test _ key , test _ value ) ;
var value = get _ item _ from _ list ( list _ id , 0 ) ;
var value = get _ item _ from _ list ( list _ id , 0 ) ;
var rest _ path = new rest _ path ( typeof ( simple _ type ) , STR ) ;
var rest _ path = new rest _ path ( typeof ( simple _ type ) , STR ) ;
var base _ class = host . default _ base _ class . split _ on _ first ( '<' ) [ 0 ] ;
namespace service _ stack _ service _ host
sb . append ( STR ) . append ( class _ name ) . append ( STR ) ;
service _ model _ finder = service _ model _ finder . instance ,
public override int get _ hash _ code ( ) = > binding . get _ hash _ code ( ) ;
void remove _ client _ session ( guid user _ id , i _ collection < guid > client _ session _ ids ) ;
user _ client _ session get _ user _ client _ session ( guid user _ id , guid client _ session _ id ) ;
db . insert ( seed _ data ) ;
using system ;
public static i _ collection throw _ if _ null _ or _ empty ( this i _ collection collection )
public static i _ collection < t > throw _ if _ null _ or _ empty < t > ( this i _ collection < t > collection )
public static i _ collection < t > throw _ if _ null _ or _ empty < t > ( this i _ collection < t > collection , string var _ name )
public string binding { get ; set ; }
var literal = fragment . argument . advance _ past _ whitespace ( ) ;
var literal = fragment . argument . advance _ past _ whitespace ( ) ;
using ( app _ config _ scope . change ( app _ config _ path ) )
data _ contract
data _ contract
data _ contract
data _ contract
data _ contract
data _ contract
data _ contract
data _ contract
data _ contract
data _ contract
client . content _ type = content _ type ;
client . content _ type = content _ type ;
data _ contract
data _ contract
data _ contract
get { return response ? ? ( response = request _ context ! = null ? request _ context . get < i _ http _ response > ( ) : try _ resolve < i _ http _ response > ( ) ) ; }
razor _ format . add _ template ( STR , website _ template ) ; razor _ format . add _ page ( new view _ page _ ref ( razor _ format , STR , page _ name , page _ template ) { template = STR ,
handle _ unknown _ value public stop _ execution end ( ) = > stop _ execution . value ;
handle _ unknown _ value public stop _ execution end ( object ignore ) = > stop _ execution . value ;
task < http _ web _ response > get _ async ( i _ return _ void request _ dto ) ;
task < http _ web _ response > post _ async ( i _ return _ void request _ dto ) ;
task < http _ web _ response > put _ async ( i _ return _ void request _ dto ) ;
} . init ( ) ;
namespace service _ stack _ text _ tests
public razor _ page razor _ page { get ; set ; }
throw _ response _ type _ exception ( request , sub _ ex , request _ uri ) ;
throw _ response _ type _ exception ( request , ex , request _ uri ) ;
public object execute _ message ( i _ message mq _ message )
public object execute _ message ( i _ message dto , i _ request req )
object execute _ message ( i _ message mq _ message ) ;
object execute _ message ( i _ message dto , i _ request request _ context ) ;
write _ file ( path , rom _ chars ) ;
write _ file ( path , rom _ bytes ) ;
append _ file ( path , rom _ chars ) ;
append _ file ( path , rom _ bytes ) ;
property _ names _ map . add ( property _ name , property _ name ) ;
property _ names _ map . add ( property _ name , property _ name ) ;
await write _ page _ async _ internal ( page , new script _ scope _ context ( scope , ms , scope . scoped _ params ) , token ) ;
public abstract class http _ listener _ base : i _ disposable
return render _ dynamic _ page ( get _ view _ page ( page _ name ) , model , render _ html , true ) ;
channels = channels . to _ array ( ) ,
default _ file _ path = default _ file _ path ; default _ file _ contents = default _ file _ contents ; default _ file _ modified = default _ file _ modified ;
var property _ parse _ string _ fn = get _ parse _ fn ( property _ type ) ;
response . status _ code = ( int ) status _ code ;
keep _ alive _ retry _ after _ ms = NUM ;
private static i _ http _ handler default _ http _ handler ; private static redirect _ http _ handler non _ root _ mode _ default _ http _ handler ; private static i _ http _ handler forbidden _ http _ handler ; private static i _ http _ handler not _ found _ http _ handler ;
public object continue _ executing _ filters _ on _ error ( template _ scope _ context scope , object ignore _ target ) = > continue _ executing _ filters _ on _ error ( scope ) ;
public object skip _ executing _ filters _ on _ error ( template _ scope _ context scope , object ignore _ target ) = > skip _ executing _ filters _ on _ error ( scope ) ;
service _ model _ finder = service _ model _ finder . instance ,
mi . create _ delegate ( typeof ( func < object , type , object > ) ) ;
this . auth _ http _ gateway = new auth _ http _ gateway ( ) ;
. register _ query _ filter < query _ rockstars _ filter , rockstar > ( ( q , dto , req ) = >
. register _ query _ filter < query _ custom _ rockstars _ filter , rockstar > ( ( q , dto , req ) = >
. register _ query _ filter < i _ filter _ rockstars , rockstar > ( ( q , dto , req ) = >
namespace service _ stack
namespace service _ stack
namespace service _ stack
namespace service _ stack
public static object to _ optimized _ result _ using _ cache < t > ( this i _ request _ context request _ context , i _ cache _ client cache _ client , string cache _ key , func < t > factory _ fn )
public static object to _ optimized _ result _ using _ cache < t > ( this i _ request _ context request _ context , string cache _ key , func < t > factory _ fn )
start ( base _ url ) ;
method . statements . add ( create _ to _ source _ assignment _ method ( attr , to , to _ source _ type _ property , from , get _ types _ translate _ attribute _ fn ) ) ;
args . append ( type _ value ( ctor _ arg . type , ctor _ arg . value ) ) ;
api _ member _ description _ range _ description _ parameter _ type _ path _ data _ type _ double _ is _ required _ true
client . increment _ item _ in _ sorted _ set ( set _ id , value , increment _ by _ score ) ;
double increment _ item _ in _ sorted _ set ( string set _ id , string value , double increment _ by ) ;
public int h _ set ( string hash _ id , byte [ ] key , byte [ ] value )
public class orm _ lite _ cache _ client : i _ cache _ client , i _ requires _ schema
value = invoke _ filter ( has _ filter _ as _ binding , filter , new object [ 0 ] , var . binding _ string ) ;
if ( api _ key _ filter _ fn ! = null ) api _ key _ filter _ fn ( api _ key ) ;
return null ;
api _ member _ parameter _ type _ path _ description _ range _ description _ data _ type _ double _ is _ required _ true
: web _ host _ url . combine _ with ( path _ info ) ,
? path _ info
: web _ host _ url . combine _ with ( path _ info ) ,
? path _ info
var is _ reply = path _ action = = STR ; var is _ one _ way = path _ action = = STR ;
return ! ( type . is _ user _ type ( ) | | type . is _ user _ enum ( ) | | type . is _ interface )
! type . is _ interface & &
if ( typeof ( t ) . is _ class | | typeof ( t ) . is _ interface )
& & ! service _ type . is _ abstract & & ! service _ type . is _ generic _ type _ definition & & ! service _ type . contains _ generic _ parameters ;
var rest _ path = get _ rest _ path ( http _ req ) ;
if ( ! auth _ http _ gateway . verify _ facebook _ access _ token ( app _ id , request . access _ token ) )
namespace service _ stack
namespace service _ stack
using service _ stack ;
namespace service _ stack
namespace service _ stack
var referrer _ url = request ? . continue
var precedences = new list < int > { prec } ;
public i _ service _ resolver service _ resolver { get ; private set ; }
if ( claim . type = = permission _ claim _ type )
var dynamic _ page = new markdown _ page ( dynamic _ page _ content , STR , dynamic _ page _ content ) ;
using system _ collections _ generic ; using n _ unit _ framework ;
while ( ( base _ type = base _ type . base _ type ( ) ) ! = null ) ;
if ( typeof ( t ) . is _ class ( ) )
var compiled _ regex = new regex ( regex , regex _ options . compiled ) ;
html . get _ session ( ) . get _ profile _ url ( ) ;
using system ;
using system ;
log _ manager . throw _ exceptions = nlog _ element . get _ optional _ boolean _ attribute ( STR , log _ manager . throw _ exceptions ) ; internal _ logger . log _ to _ console = nlog _ element . get _ optional _ boolean _ attribute ( STR , internal _ logger . log _ to _ console ) ;
internal _ logger . log _ to _ console _ error = nlog _ element . get _ optional _ boolean _ attribute ( STR , internal _ logger . log _ to _ console _ error ) ;
exceptions . add ( ex ) ;
for ( int i = 0 ; i < encoded _ value . length ; + + i )
throw new n _ log _ runtime _ exception ( STR , ex ) ;
data _ targets . add ( append _ message ) ;
data _ targets . add ( append _ type ) ;
data _ targets . add ( append _ short _ type ) ;
data _ targets . add ( append _ to _ string ) ;
data _ targets . add ( append _ method ) ;
data _ targets . add ( append _ stack _ trace ) ;
log _ event . add _ cached _ layout _ value ( this , value ) ;
string prop _ name _ element = append _ xml _ property _ value ( prop _ name , string . empty , sb , org _ length , true ) ;
string prop _ name _ element = append _ xml _ property _ value ( prop _ name , string . empty , sb , org _ length , true , ignore _ properties _ element _ name ) ;
string prop _ name _ element = append _ xml _ property _ value ( prop _ name , string . empty , sb , org _ length , true , ignore _ properties _ element _ name ) ;
namespace n _ log _ targets
return text . replace ( environment . new _ line , STR ) ;
using config ; using layouts ;
date _ time archive _ date = get _ archive _ date ( file _ name , log _ event ) ;
enable _ levels = child _ property . value ;
min _ level = child _ property . value ;
max _ level = child _ property . value ;
builder . append ( context . request . query _ string [ query _ string ] ) ;
builder . append ( context . request . form [ form ] ) ;
if ( keep _ connection )
if ( keep _ connection )
item = item ;
this . all _ layouts = object _ graph _ scanner . find _ reachable _ objects < layout > ( this ) ;
assert . null ( empty _ cache . get _ file _ characteristics ( STR ) ) ;
assert . null ( cache . get _ file _ characteristics ( STR ) ) ;
return new file _ characteristics ( this . open _ time , this . current _ file _ length ) ;
if ( ! contains _ column ( s ) )
return save ( file _ name ) ;
if ( file _ name = = null )
return capture _ parameters _ and _ save _ config ( file _ name ) ;
if ( file _ name ! = null ) sfd . file _ name = file _ name ;
name = path . get _ file _ name _ without _ extension ( sfd . file _ name ) ; tab _ page . text = name ;
sorted _ list < log _ event , log _ event > new _ filtered _ events = new sorted _ list < log _ event , log _ event > ( new item _ comparer ( order _ by , sort _ ascending ) ) ;
if ( dirty )
STR + name + STR ,
loggers = logger _ cache . loggers ; }
test _ writer ( expected , writer ) ;
private static void test _ writer ( string expected , string _ writer writer )
file _ length + = bytes . length ; last _ write _ time = date _ time . now ; file . write ( bytes , 0 , bytes . length ) ;
creation _ time _ utc = date _ time . utc _ now ; file . set _ creation _ time _ utc ( file _ name , creation _ time _ utc ) ;
return creation _ time _ utc ;
previous _ task . start ( task _ scheduler ) ;
this . do _ invoke ( parameters , log _ event ) ;
internal _ logger . info ( STR , assembly _ name ) ;
archive _ mutex = create _ archive _ mutex ( ) ;
if ( this . clean _ names _ of _ anonymous _ delegates & & ( method _ name . starts _ with ( STR ) & & method _ name . contains ( STR ) & & method _ name . contains ( STR ) ) )
case type _ code . string : return true ; case type _ code . empty : return true ; default : return false ;
return hashtable ;
this . dictionary [ key ] = value ;
return file _ name ;
file _ name = value ;
return directory _ name ;
return nlog _ dir ;
return variable ;
builder . append ( apply _ padding ( environment . get _ environment _ variable ( variable ) ) ) ;
return format ;
foreach ( var path in private _ bin _ paths )
assert . is _ instance _ of _ type ( typeof ( condition _ message _ expression ) , result ) ;
assert . is _ instance _ of _ type ( typeof ( condition _ level _ expression ) , result ) ;
assert . is _ instance _ of _ type ( typeof ( condition _ logger _ name _ expression ) , result ) ;
assert . is _ instance _ of _ type ( typeof ( invalid _ operation _ exception ) , last _ exception ) ;
assert . is _ instance _ of _ type ( typeof ( invalid _ operation _ exception ) , last _ exception ) ;
assert . is _ instance _ of _ type ( typeof ( not _ supported _ exception ) , last _ exception ) ;
assert . is _ instance _ of _ type ( typeof ( invalid _ operation _ exception ) , last _ exception ) ;
assert . is _ instance _ of _ type ( typeof ( invalid _ operation _ exception ) , last _ exception ) ;
assert . is _ instance _ of _ type ( typeof ( invalid _ operation _ exception ) , last _ exception ) ;
assert . is _ instance _ of _ type ( typeof ( invalid _ operation _ exception ) , last _ exception ) ;
assert . is _ instance _ of _ type ( typeof ( my _ smtp _ client ) , client ) ;
assert . is _ instance _ of _ type ( typeof ( timeout _ exception ) , exceptions [ 0 ] ) ;
assert . is _ instance _ of _ type ( typeof ( invalid _ operation _ exception ) , last _ exception ) ;
assert . is _ instance _ of _ type ( typeof ( n _ log _ runtime _ exception ) , last _ exception ) ;
builder . append _ invariant ( async _ helpers . get _ managed _ thread _ id ( ) ) ;
return quit _ thread ;
app _ info = STR ;
instance . create _ tab ( this ) ;
return null ;
builder . append ( context . request . query _ string [ query _ string ] ) ;
builder . append ( context . request . form [ form ] ) ;
builder . append ( cookie . value ) ;
builder . append ( context . request . server _ variables [ server _ variable ] ) ;
builder . append ( context . request [ item ] ) ;
builder . append ( log _ event . logger _ name ) ;
builder . append ( log _ event . logger _ name . substring ( last _ dot + 1 ) ) ;
builder . append ( msg ) ;
builder . append ( path . combine ( base _ dir , file ) ) ;
builder . append ( path . combine ( base _ dir , dir ) ) ;
builder . append ( base _ dir ) ;
builder . append ( path . combine ( base _ dir , file ) ) ;
builder . append ( path . combine ( base _ dir , dir ) ) ;
builder . append ( base _ dir ) ;
builder . append ( environment _ helper . get _ safe _ environment _ variable ( variable ) ) ;
return false ;
get { return default _ filter ; } set { default _ filter = value ; }
builder . append ( path . combine ( base _ dir , file ) ) ;
builder . append ( path . combine ( base _ dir , dir ) ) ;
builder . append ( base _ dir ) ;
int sbstart = builder . length ;
builder . append ( path . combine ( base _ dir , file ) ) ;
builder . append ( path . combine ( base _ dir , dir ) ) ;
builder . append ( base _ dir ) ;
builder . append ( thread _ id _ helper . instance . current _ process _ name ) ;
builder . append ( thread _ id _ helper . instance . current _ process _ base _ name ) ;
namespace n _ log
namespace n _ log
namespace n _ log
namespace n _ log
namespace n _ log
namespace n _ log
namespace n _ log
get { return counter _ type ; } set { counter _ type = value ; }
bool wrote _ full _ batch _ size = false ;
private static readonly char [ ] directory _ separator _ chars = new [ ] { path . directory _ separator _ char , path . alt _ directory _ separator _ char } ;
private static readonly hash _ set < char > invalid _ file _ name _ chars = new hash _ set < char > ( path . get _ invalid _ file _ name _ chars ( ) ) ;
float single _ value = ( float ) value ;
return cached _ prev _ raw _ file _ name ;
file . dispose ( ) ; file = create _ file _ stream ( false ) ; current _ file _ length = file . length ;
file _ share & = ~ file _ share . delete ;
internal _ logger . debug ( STR , name , previous _ task . status ) ;
file . dispose ( ) ; file = create _ file _ stream ( false ) ;
string directory _ path = path . get _ directory _ name ( archive _ file _ pattern _ to _ watch ) ;
return appender ;
string file _ name = bucket . key ;
write _ events _ in _ buffer ( STR ) ;
fact
internal class socket _ proxy : i _ socket
exceptions . add ( ex ) ;
suppress _ message _ microsoft _ naming _ c _ compound _ words _ should _ be _ cased _ correctly _ message _ id _ time _ stamp _ justification _ backwards _ compatibility
suppress _ message _ microsoft _ performance _ c _ properties _ should _ not _ return _ arrays _ justification _ for _ backwards _ compatibility
if ( is _ positional )
internal _ logger . error ( config _ exception , STR ) ;
internal _ logger . error ( config _ exception , STR ) ;
values = STR
log _ manager . throw _ exceptions = false ; assert _ layout _ renderer _ output ( STR , STR ) ;
throw ;
return previous _ log _ event _ timestamp ; } if ( previous _ log _ overlapped _ period ( log _ event , previous _ log _ event _ timestamp , last _ write _ time _ source ) )
return previous _ log _ event _ timestamp ;
if ( is _ travis ( ) )
if ( is _ travis ( ) )
return this . windows _ create _ file ( this . file _ name , allow _ concurrent _ write ) ;
var buckets = log _ events . bucket _ sort ( c = > this . build _ connection _ string ( c . log _ event ) ) ;
filter _ result result = filter _ result . neutral ;
builder . query = query _ parameters ;
using internal ; using time ;
builder . append ( level ) ;
builder . append ( ex ) ; } var msg = builder . to _ string ( ) ;
append _ inner _ exception ( current _ exception , builder ) ;
using common ; using internal ;
using common ; using config ; using internal ; using internal _ file _ appenders ; using layouts ;
hive = registry _ hive . local _ machine ;
hive = registry _ hive . current _ user ;
namespace n _ log
namespace n _ log
namespace n _ log
namespace n _ log
namespace n _ log
namespace n _ log
namespace n _ log
else if ( is _ archiving _ enabled )
directory _ info directory _ info = new directory _ info ( dir _ name ) ; if ( ! directory _ info . exists ) { directory . create _ directory ( dir _ name ) ; return ; }
this . request _ queue = new async _ request _ queue ( NUM , async _ target _ wrapper _ overflow _ action . discard ) ;
this . request _ queue = new async _ request _ queue ( NUM , async _ target _ wrapper _ overflow _ action . discard ) ;
public class async _ request _ queue
using n _ log _ web ;
namespace n _ log
return filter _ result . neutral ;
<DEL>
return key _ collection ? ? ( key _ collection = new dictionary _ collection ( this , true ) ) ;
return value _ collection ? ? ( value _ collection = new dictionary _ collection ( this , false ) ) ;
return new dictionary _ enumerator ( this ) ;
return new dictionary _ enumerator ( this ) ;
throw new invalid _ operation _ exception ( ) ;
if ( previous _ log _ overlapped _ period ( log _ event , previous _ log _ event _ timestamp . value , last _ write _ time _ source ) )
return last _ write _ time _ source ;
private readonly condition _ tokenizer tokenizer ; private readonly configuration _ item _ factory configuration _ item _ factory ;
using config ;
combined _ properties = capture _ context _ gdc ( log _ event , combined _ properties ) ;
instance . create _ tab ( this ) ;
continue ;
continue ;
continue ;
return new condition _ literal _ expression ( int . parse ( number _ string , culture _ info . invariant _ culture ) ) ;
async _ target _ wrapper atw = new async _ target _ wrapper ( ) ;
foreach ( string config _ file in get _ candidate _ file _ names ( ) )
dump ( this . config ) ;
dump ( this . config ) ;
return create ( log _ level . off , string . empty , null , string . empty ) ;
log _ event . add _ cached _ layout _ value ( this , value ) ;
public class null _ appender : appender
namespace n _ log _ layout _ appenders
public class console _ appender : appender
public class asp _ net _ trace _ appender : appender
public class memory _ appender : appender
public class trace _ appender : appender
return ;
internal _ logger . trace ( STR , rule . exists ) ;
var test _ cases = new list < tuple < string , string , string > >
return file _ name ;
return hashtable ;
file _ name = value ;
return directory _ name ;
return nlog _ dir ;
return format ;
return variable ;
builder . append ( apply _ padding ( environment . get _ environment _ variable ( variable ) ) ) ;
this . dictionary [ key ] = value ;
throw new n _ log _ configuration _ exception ( STR , STR ) ;
if ( reference _ equals ( options , instance . serialize _ options ) & & value is exception )
file _ length + = bytes . length ; last _ write _ time = date _ time . now ; file . write ( bytes , 0 , bytes . length ) ;
return STR + o + STR ;
assembly _ location = app _ domain _ base _ directory ; extension _ dlls = get _ n _ log _ extension _ files ( app _ domain _ base _ directory ) ;
throw new n _ log _ runtime _ exception ( STR , ex ) ;
public bool add _ to _ archive ( string archive _ file _ name , string file _ name , bool create _ directory _ if _ not _ exists )
return result _ events ;
visited _ objects . add ( o ) ;
return new context _ reverter ( this . new _ identity . impersonate ( ) ) ;
theory
theory
get
assert _ layout _ renderer _ output ( STR + file _ name + STR , content ) ;
assert _ layout _ renderer _ output ( STR , string . empty ) ;
get
var last = intermediate . first _ or _ default ( ) ;
flush _ timer . change ( flush _ timeout , - 1 ) ;
left _ expression = left _ expression ; right _ expression = right _ expression ; relational _ operator = relational _ operator ;
return STR + left _ expression + STR + get _ operator _ string ( ) + STR + right _ expression + STR ;
using common ; using internal ;
parent _ factory = parent _ factory ;
register _ type ( t , prefix ) ;
register _ definition ( item _ name _ prefix + attr . name , type ) ;
if ( ! try _ get _ definition ( item _ name , out type ) )
if ( try _ create _ instance ( name , out result ) )
using config ;
string _ comparison comparison _ type = ignore _ case
if ( layout . render ( log _ event ) . index _ of ( substring , comparison _ type ) > = 0 )
return action ;
init _ attributes ( ) ; return log _ factory ;
attributes _ loaded = true ; log _ factory = value ;
init _ attributes ( ) ; return default _ log _ level ;
attributes _ loaded = true ; default _ log _ level = value ;
init _ attributes ( ) ; return force _ log _ level ;
attributes _ loaded = true ; force _ log _ level = value ;
init _ attributes ( ) ; return disable _ flush ;
attributes _ loaded = true ; disable _ flush = value ;
attributes _ loaded = true ; auto _ logger _ name = value ;
process _ log _ event _ info ( default _ log _ level , null , message , null , null , trace _ event _ type . resume , null ) ;
process _ log _ event _ info ( default _ log _ level , null , message , null , null , trace _ event _ type . resume , null ) ;
process _ log _ event _ info ( log _ level . error , null , message , null , null , trace _ event _ type . error , null ) ;
process _ log _ event _ info ( log _ level . error , null , message + STR + detail _ message , null , null , trace _ event _ type . error , null ) ;
if ( ! disable _ flush ) { if ( log _ factory ! = null ) { log _ factory . flush ( ) ;
process _ log _ event _ info ( translate _ log _ level ( event _ type ) , source , sb . to _ string ( ) , data , id , event _ type , null ) ;
process _ log _ event _ info ( translate _ log _ level ( event _ type ) , source , format , args , id , event _ type , null ) ;
process _ log _ event _ info ( translate _ log _ level ( event _ type ) , source , message , null , id , event _ type , null ) ;
process _ log _ event _ info ( log _ level . debug , source , message , null , id , trace _ event _ type . transfer , related _ activity _ id ) ;
logger _ name = ( logger _ name ? ? name ) ? ? string . empty ;
if ( auto _ logger _ name )
if ( method . declaring _ type = = get _ type ( ) )
if ( log _ factory ! = null ) { logger = log _ factory . get _ logger ( logger _ name ) ;
log _ level = force _ log _ level ? ? log _ level ;
if ( ! attributes _ loaded ) { attributes _ loaded = true ; foreach ( dictionary _ entry de in attributes )
default _ log _ level = log _ level . from _ string ( value ) ;
force _ log _ level = log _ level . from _ string ( value ) ;
auto _ logger _ name = xml _ convert . to _ boolean ( value ) ;
disable _ flush = boolean . parse ( value ) ;
using common ; using internal _ network _ senders ; using layouts ;
name = name ;
lock ( open _ network _ senders ) { remaining _ count = open _ network _ senders . count ;
foreach ( var open _ sender in open _ network _ senders )
lock ( open _ network _ senders ) { foreach ( var open _ sender in open _ network _ senders )
release _ cached _ connection ( sender _ node ) ;
lock ( open _ network _ senders )
switch ( on _ connection _ overflow )
while ( open _ network _ senders . count > = max _ connections )
monitor . wait ( open _ network _ senders ) ;
lock ( open _ network _ senders ) { try _ remove ( open _ network _ senders , linked _ list _ node ) ; if ( on _ connection _ overflow = = network _ target _ connections _ overflow _ action . block )
monitor . pulse _ all ( open _ network _ senders ) ;
if ( new _ line ) { text = rendered + line _ ending . new _ line _ characters ;
lock ( current _ sender _ cache )
if ( current _ sender _ cache . count > = connection _ cache _ size )
foreach ( var pair in current _ sender _ cache )
release _ cached _ connection ( least _ recently _ used ) ; } } var sender = sender _ factory . create ( address , max _ queue _ size ) ;
lock ( open _ network _ senders ) { sender _ node = open _ network _ senders . add _ last ( sender ) ; } current _ sender _ cache . add ( address , sender _ node ) ;
lock ( current _ sender _ cache )
lock ( open _ network _ senders ) { if ( try _ remove ( open _ network _ senders , sender _ node ) )
if ( chunksize > max _ message _ size ) { if ( on _ overflow = = network _ target _ overflow _ action . discard )
if ( on _ overflow = = network _ target _ overflow _ action . error ) { continuation ( new overflow _ exception ( STR + max _ message _ size + STR + buffer . length + STR ) ) ;
chunksize = max _ message _ size ;
creation _ time _ utc = file . get _ creation _ time _ utc ( file _ name ) ; if ( creation _ time _ utc < date _ time . utc _ now - time _ span . from _ seconds ( 2 ) & & file _ position = = 0 )
creation _ time _ utc = file . get _ creation _ time _ utc ( file _ name ) ;
if ( file _ stream = = null | | file _ characteristics _ helper = = null )
return file _ characteristics _ helper . get _ file _ characteristics ( file _ name , file _ stream ) ;
interlocked . increment ( ref write _ count ) ; if ( throw _ exceptions )
assert . true ( flush _ count < = write _ count ) ; write _ count + + ;
flush _ count + + ;
internal _ logger . debug ( STR , name ) ;
internal _ logger . debug ( STR , name , request _ queue . count + 1 ) ;
internal _ logger . debug ( STR , name ) ;
internal _ logger . debug ( STR , name ) ;
lock ( sync _ root )
internal _ logger . warn ( completed _ task . exception , STR , name ) ;
internal _ logger . info ( STR , name ) ;
internal _ logger . warn ( completed _ task . exception , STR , name ) ;
internal _ logger . warn ( STR , name ) ;
lock ( sync _ root )
internal _ logger . debug ( STR , name , previous _ task . status ) ;
internal _ logger . debug ( ex , STR , name ) ;
internal _ logger . error ( ex , STR , name ) ;
lock ( sync _ root )
using layout _ renderers ; using layouts ; using targets ;
name = name ;
if ( is _ enabled ( level ) ) { write _ to _ targets ( level , STR , new object [ ] { value } ) ;
if ( is _ enabled ( level ) ) { write _ to _ targets ( level , format _ provider , STR , new [ ] { value } ) ;
if ( is _ enabled ( level ) ) { write _ to _ targets ( level , message , new [ ] { arg , arg } ) ;
if ( is _ enabled ( level ) ) { write _ to _ targets ( level , message , new [ ] { arg , arg , arg } ) ;
if ( is _ enabled ( level ) ) { write _ to _ targets ( level , format _ provider , message , new object [ ] { argument } ) ;
if ( is _ enabled ( level ) ) { write _ to _ targets ( level , message , new object [ ] { argument } ) ;
if ( is _ enabled ( level ) ) { write _ to _ targets ( level , format _ provider , message , new object [ ] { argument } ) ;
if ( is _ enabled ( level ) ) { write _ to _ targets ( level , message , new object [ ] { argument } ) ;
if ( is _ enabled ( level ) ) { write _ to _ targets ( level , format _ provider , message , new object [ ] { argument } ) ;
if ( is _ enabled ( level ) ) { write _ to _ targets ( level , message , new object [ ] { argument } ) ;
if ( is _ enabled ( level ) ) { write _ to _ targets ( level , format _ provider , message , new object [ ] { argument } ) ;
if ( is _ enabled ( level ) ) { write _ to _ targets ( level , message , new object [ ] { argument } ) ;
if ( is _ enabled ( level ) ) { write _ to _ targets ( level , format _ provider , message , new object [ ] { argument } ) ;
if ( is _ enabled ( level ) ) { write _ to _ targets ( level , message , new object [ ] { argument } ) ;
if ( is _ enabled ( level ) ) { write _ to _ targets ( level , format _ provider , message , new object [ ] { argument } ) ;
if ( is _ enabled ( level ) ) { write _ to _ targets ( level , message , new object [ ] { argument } ) ;
if ( is _ enabled ( level ) ) { write _ to _ targets ( level , format _ provider , message , new object [ ] { argument } ) ;
if ( is _ enabled ( level ) ) { write _ to _ targets ( level , message , new object [ ] { argument } ) ;
if ( is _ enabled ( level ) ) { write _ to _ targets ( level , format _ provider , message , new object [ ] { argument } ) ;
if ( is _ enabled ( level ) ) { write _ to _ targets ( level , message , new object [ ] { argument } ) ;
if ( is _ enabled ( level ) ) { write _ to _ targets ( level , format _ provider , message , new object [ ] { argument } ) ;
if ( is _ enabled ( level ) ) { write _ to _ targets ( level , message , new object [ ] { argument } ) ;
if ( is _ enabled ( level ) ) { write _ to _ targets ( level , format _ provider , message , new object [ ] { argument } ) ;
if ( is _ enabled ( level ) ) { write _ to _ targets ( level , message , new object [ ] { argument } ) ;
if ( is _ enabled ( level ) ) { write _ to _ targets ( level , format _ provider , message , new object [ ] { argument } ) ;
if ( is _ enabled ( level ) ) { write _ to _ targets ( level , message , new object [ ] { argument } ) ;
if ( is _ enabled ( level ) ) { write _ to _ targets ( level , format _ provider , message , new object [ ] { argument } ) ;
if ( is _ enabled ( level ) ) { write _ to _ targets ( level , message , new object [ ] { argument } ) ;
if ( is _ enabled ( level ) ) { write _ to _ targets ( level , format _ provider , message , new object [ ] { argument } ) ;
if ( is _ enabled ( level ) ) { write _ to _ targets ( level , message , new object [ ] { argument } ) ;
if ( is _ trace _ enabled ) { write _ to _ targets ( log _ level . trace , STR , new object [ ] { value } ) ;
if ( is _ trace _ enabled ) { write _ to _ targets ( log _ level . trace , format _ provider , STR , new [ ] { value } ) ;
if ( is _ trace _ enabled ) { write _ to _ targets ( log _ level . trace , message , new [ ] { arg , arg } ) ;
if ( is _ trace _ enabled ) { write _ to _ targets ( log _ level . trace , message , new [ ] { arg , arg , arg } ) ;
if ( is _ trace _ enabled ) { write _ to _ targets ( log _ level . trace , format _ provider , message , new object [ ] { argument } ) ;
if ( is _ trace _ enabled ) { write _ to _ targets ( log _ level . trace , message , new object [ ] { argument } ) ;
if ( is _ trace _ enabled ) { write _ to _ targets ( log _ level . trace , message , new object [ ] { argument } ) ;
if ( is _ trace _ enabled ) { write _ to _ targets ( log _ level . trace , message , new object [ ] { argument } ) ;
if ( is _ trace _ enabled ) { write _ to _ targets ( log _ level . trace , message , new object [ ] { argument } ) ;
if ( is _ trace _ enabled ) { write _ to _ targets ( log _ level . trace , message , new object [ ] { argument } ) ;
if ( is _ trace _ enabled ) { write _ to _ targets ( log _ level . trace , message , new object [ ] { argument } ) ;
if ( is _ trace _ enabled ) { write _ to _ targets ( log _ level . trace , message , new object [ ] { argument } ) ;
if ( is _ trace _ enabled ) { write _ to _ targets ( log _ level . trace , message , new object [ ] { argument } ) ;
if ( is _ trace _ enabled ) { write _ to _ targets ( log _ level . trace , message , new object [ ] { argument } ) ;
if ( is _ trace _ enabled ) { write _ to _ targets ( log _ level . trace , message , new object [ ] { argument } ) ;
if ( is _ trace _ enabled ) { write _ to _ targets ( log _ level . trace , format _ provider , message , new object [ ] { argument } ) ;
if ( is _ trace _ enabled ) { write _ to _ targets ( log _ level . trace , message , new object [ ] { argument } ) ;
if ( is _ trace _ enabled ) { write _ to _ targets ( log _ level . trace , format _ provider , message , new object [ ] { argument } ) ;
if ( is _ trace _ enabled ) { write _ to _ targets ( log _ level . trace , message , new object [ ] { argument } ) ;
if ( is _ trace _ enabled ) { write _ to _ targets ( log _ level . trace , format _ provider , message , new object [ ] { argument } ) ;
if ( is _ trace _ enabled ) { write _ to _ targets ( log _ level . trace , message , new object [ ] { argument } ) ;
if ( is _ debug _ enabled ) { write _ to _ targets ( log _ level . debug , STR , new object [ ] { value } ) ;
if ( is _ debug _ enabled ) { write _ to _ targets ( log _ level . debug , format _ provider , STR , new [ ] { value } ) ;
if ( is _ debug _ enabled ) { write _ to _ targets ( log _ level . debug , message , new [ ] { arg , arg } ) ;
if ( is _ debug _ enabled ) { write _ to _ targets ( log _ level . debug , message , new [ ] { arg , arg , arg } ) ;
if ( is _ debug _ enabled ) { write _ to _ targets ( log _ level . debug , format _ provider , message , new object [ ] { argument } ) ;
if ( is _ debug _ enabled ) { write _ to _ targets ( log _ level . debug , message , new object [ ] { argument } ) ;
if ( is _ debug _ enabled ) { write _ to _ targets ( log _ level . debug , message , new object [ ] { argument } ) ;
if ( is _ debug _ enabled ) { write _ to _ targets ( log _ level . debug , message , new object [ ] { argument } ) ;
if ( is _ debug _ enabled ) { write _ to _ targets ( log _ level . debug , message , new object [ ] { argument } ) ;
if ( is _ debug _ enabled ) { write _ to _ targets ( log _ level . debug , message , new object [ ] { argument } ) ;
if ( is _ debug _ enabled ) { write _ to _ targets ( log _ level . debug , message , new object [ ] { argument } ) ;
if ( is _ debug _ enabled ) { write _ to _ targets ( log _ level . debug , message , new object [ ] { argument } ) ;
if ( is _ debug _ enabled ) { write _ to _ targets ( log _ level . debug , message , new object [ ] { argument } ) ;
if ( is _ debug _ enabled ) { write _ to _ targets ( log _ level . debug , message , new object [ ] { argument } ) ;
if ( is _ debug _ enabled ) { write _ to _ targets ( log _ level . debug , message , new object [ ] { argument } ) ;
if ( is _ debug _ enabled ) { write _ to _ targets ( log _ level . debug , format _ provider , message , new object [ ] { argument } ) ;
if ( is _ debug _ enabled ) { write _ to _ targets ( log _ level . debug , message , new object [ ] { argument } ) ;
if ( is _ debug _ enabled ) { write _ to _ targets ( log _ level . debug , format _ provider , message , new object [ ] { argument } ) ;
if ( is _ debug _ enabled ) { write _ to _ targets ( log _ level . debug , message , new object [ ] { argument } ) ;
if ( is _ debug _ enabled ) { write _ to _ targets ( log _ level . debug , format _ provider , message , new object [ ] { argument } ) ;
if ( is _ debug _ enabled ) { write _ to _ targets ( log _ level . debug , message , new object [ ] { argument } ) ;
if ( is _ info _ enabled ) { write _ to _ targets ( log _ level . info , STR , new object [ ] { value } ) ;
if ( is _ info _ enabled ) { write _ to _ targets ( log _ level . info , format _ provider , STR , new [ ] { value } ) ;
if ( is _ info _ enabled ) { write _ to _ targets ( log _ level . info , message , new [ ] { arg , arg } ) ;
if ( is _ info _ enabled ) { write _ to _ targets ( log _ level . info , message , new [ ] { arg , arg , arg } ) ;
if ( is _ info _ enabled ) { write _ to _ targets ( log _ level . info , format _ provider , message , new object [ ] { argument } ) ;
if ( is _ info _ enabled ) { write _ to _ targets ( log _ level . info , message , new object [ ] { argument } ) ;
if ( is _ info _ enabled ) { write _ to _ targets ( log _ level . info , message , new object [ ] { argument } ) ;
if ( is _ info _ enabled ) { write _ to _ targets ( log _ level . info , message , new object [ ] { argument } ) ;
if ( is _ info _ enabled ) { write _ to _ targets ( log _ level . info , message , new object [ ] { argument } ) ;
if ( is _ info _ enabled ) { write _ to _ targets ( log _ level . info , message , new object [ ] { argument } ) ;
if ( is _ info _ enabled ) { write _ to _ targets ( log _ level . info , message , new object [ ] { argument } ) ;
if ( is _ info _ enabled ) { write _ to _ targets ( log _ level . info , message , new object [ ] { argument } ) ;
if ( is _ info _ enabled ) { write _ to _ targets ( log _ level . info , message , new object [ ] { argument } ) ;
if ( is _ info _ enabled ) { write _ to _ targets ( log _ level . info , message , new object [ ] { argument } ) ;
if ( is _ info _ enabled ) { write _ to _ targets ( log _ level . info , message , new object [ ] { argument } ) ;
if ( is _ info _ enabled ) { write _ to _ targets ( log _ level . info , format _ provider , message , new object [ ] { argument } ) ;
if ( is _ info _ enabled ) { write _ to _ targets ( log _ level . info , message , new object [ ] { argument } ) ;
if ( is _ info _ enabled ) { write _ to _ targets ( log _ level . info , format _ provider , message , new object [ ] { argument } ) ;
if ( is _ info _ enabled ) { write _ to _ targets ( log _ level . info , message , new object [ ] { argument } ) ;
if ( is _ info _ enabled ) { write _ to _ targets ( log _ level . info , format _ provider , message , new object [ ] { argument } ) ;
if ( is _ info _ enabled ) { write _ to _ targets ( log _ level . info , message , new object [ ] { argument } ) ;
if ( is _ warn _ enabled ) { write _ to _ targets ( log _ level . warn , STR , new object [ ] { value } ) ;
if ( is _ warn _ enabled ) { write _ to _ targets ( log _ level . warn , format _ provider , STR , new [ ] { value } ) ;
if ( is _ warn _ enabled ) { write _ to _ targets ( log _ level . warn , message , new [ ] { arg , arg } ) ;
if ( is _ warn _ enabled ) { write _ to _ targets ( log _ level . warn , message , new [ ] { arg , arg , arg } ) ;
if ( is _ warn _ enabled ) { write _ to _ targets ( log _ level . warn , format _ provider , message , new object [ ] { argument } ) ;
if ( is _ warn _ enabled ) { write _ to _ targets ( log _ level . warn , message , new object [ ] { argument } ) ;
if ( is _ warn _ enabled ) { write _ to _ targets ( log _ level . warn , message , new object [ ] { argument } ) ;
if ( is _ warn _ enabled ) { write _ to _ targets ( log _ level . warn , message , new object [ ] { argument } ) ;
if ( is _ warn _ enabled ) { write _ to _ targets ( log _ level . warn , message , new object [ ] { argument } ) ;
if ( is _ warn _ enabled ) { write _ to _ targets ( log _ level . warn , message , new object [ ] { argument } ) ;
if ( is _ warn _ enabled ) { write _ to _ targets ( log _ level . warn , message , new object [ ] { argument } ) ;
if ( is _ warn _ enabled ) { write _ to _ targets ( log _ level . warn , message , new object [ ] { argument } ) ;
if ( is _ warn _ enabled ) { write _ to _ targets ( log _ level . warn , message , new object [ ] { argument } ) ;
if ( is _ warn _ enabled ) { write _ to _ targets ( log _ level . warn , message , new object [ ] { argument } ) ;
if ( is _ warn _ enabled ) { write _ to _ targets ( log _ level . warn , message , new object [ ] { argument } ) ;
if ( is _ warn _ enabled ) { write _ to _ targets ( log _ level . warn , format _ provider , message , new object [ ] { argument } ) ;
if ( is _ warn _ enabled ) { write _ to _ targets ( log _ level . warn , message , new object [ ] { argument } ) ;
if ( is _ warn _ enabled ) { write _ to _ targets ( log _ level . warn , format _ provider , message , new object [ ] { argument } ) ;
if ( is _ warn _ enabled ) { write _ to _ targets ( log _ level . warn , message , new object [ ] { argument } ) ;
if ( is _ warn _ enabled ) { write _ to _ targets ( log _ level . warn , format _ provider , message , new object [ ] { argument } ) ;
if ( is _ warn _ enabled ) { write _ to _ targets ( log _ level . warn , message , new object [ ] { argument } ) ;
if ( is _ error _ enabled ) { write _ to _ targets ( log _ level . error , STR , new object [ ] { value } ) ;
if ( is _ error _ enabled ) { write _ to _ targets ( log _ level . error , format _ provider , STR , new [ ] { value } ) ;
if ( is _ error _ enabled ) { write _ to _ targets ( log _ level . error , message , new [ ] { arg , arg } ) ;
if ( is _ error _ enabled ) { write _ to _ targets ( log _ level . error , message , new [ ] { arg , arg , arg } ) ;
if ( is _ error _ enabled ) { write _ to _ targets ( log _ level . error , format _ provider , message , new object [ ] { argument } ) ;
if ( is _ error _ enabled ) { write _ to _ targets ( log _ level . error , message , new object [ ] { argument } ) ;
if ( is _ error _ enabled ) { write _ to _ targets ( log _ level . error , message , new object [ ] { argument } ) ;
if ( is _ error _ enabled ) { write _ to _ targets ( log _ level . error , message , new object [ ] { argument } ) ;
if ( is _ error _ enabled ) { write _ to _ targets ( log _ level . error , message , new object [ ] { argument } ) ;
if ( is _ error _ enabled ) { write _ to _ targets ( log _ level . error , message , new object [ ] { argument } ) ;
if ( is _ error _ enabled ) { write _ to _ targets ( log _ level . error , message , new object [ ] { argument } ) ;
if ( is _ error _ enabled ) { write _ to _ targets ( log _ level . error , message , new object [ ] { argument } ) ;
if ( is _ error _ enabled ) { write _ to _ targets ( log _ level . error , message , new object [ ] { argument } ) ;
if ( is _ error _ enabled ) { write _ to _ targets ( log _ level . error , message , new object [ ] { argument } ) ;
if ( is _ error _ enabled ) { write _ to _ targets ( log _ level . error , message , new object [ ] { argument } ) ;
if ( is _ error _ enabled ) { write _ to _ targets ( log _ level . error , format _ provider , message , new object [ ] { argument } ) ;
if ( is _ error _ enabled ) { write _ to _ targets ( log _ level . error , message , new object [ ] { argument } ) ;
if ( is _ error _ enabled ) { write _ to _ targets ( log _ level . error , format _ provider , message , new object [ ] { argument } ) ;
if ( is _ error _ enabled ) { write _ to _ targets ( log _ level . error , message , new object [ ] { argument } ) ;
if ( is _ error _ enabled ) { write _ to _ targets ( log _ level . error , format _ provider , message , new object [ ] { argument } ) ;
if ( is _ error _ enabled ) { write _ to _ targets ( log _ level . error , message , new object [ ] { argument } ) ;
if ( is _ fatal _ enabled ) { write _ to _ targets ( log _ level . fatal , STR , new object [ ] { value } ) ;
if ( is _ fatal _ enabled ) { write _ to _ targets ( log _ level . fatal , format _ provider , STR , new [ ] { value } ) ;
if ( is _ fatal _ enabled ) { write _ to _ targets ( log _ level . fatal , message , new [ ] { arg , arg } ) ;
if ( is _ fatal _ enabled ) { write _ to _ targets ( log _ level . fatal , message , new [ ] { arg , arg , arg } ) ;
if ( is _ fatal _ enabled ) { write _ to _ targets ( log _ level . fatal , format _ provider , message , new object [ ] { argument } ) ;
if ( is _ fatal _ enabled ) { write _ to _ targets ( log _ level . fatal , message , new object [ ] { argument } ) ;
if ( is _ fatal _ enabled ) { write _ to _ targets ( log _ level . fatal , message , new object [ ] { argument } ) ;
if ( is _ fatal _ enabled ) { write _ to _ targets ( log _ level . fatal , message , new object [ ] { argument } ) ;
if ( is _ fatal _ enabled ) { write _ to _ targets ( log _ level . fatal , message , new object [ ] { argument } ) ;
if ( is _ fatal _ enabled ) { write _ to _ targets ( log _ level . fatal , message , new object [ ] { argument } ) ;
if ( is _ fatal _ enabled ) { write _ to _ targets ( log _ level . fatal , message , new object [ ] { argument } ) ;
if ( is _ fatal _ enabled ) { write _ to _ targets ( log _ level . fatal , message , new object [ ] { argument } ) ;
if ( is _ fatal _ enabled ) { write _ to _ targets ( log _ level . fatal , message , new object [ ] { argument } ) ;
if ( is _ fatal _ enabled ) { write _ to _ targets ( log _ level . fatal , message , new object [ ] { argument } ) ;
if ( is _ fatal _ enabled ) { write _ to _ targets ( log _ level . fatal , message , new object [ ] { argument } ) ;
if ( is _ fatal _ enabled ) { write _ to _ targets ( log _ level . fatal , format _ provider , message , new object [ ] { argument } ) ;
if ( is _ fatal _ enabled ) { write _ to _ targets ( log _ level . fatal , message , new object [ ] { argument } ) ;
if ( is _ fatal _ enabled ) { write _ to _ targets ( log _ level . fatal , format _ provider , message , new object [ ] { argument } ) ;
if ( is _ fatal _ enabled ) { write _ to _ targets ( log _ level . fatal , message , new object [ ] { argument } ) ;
if ( is _ fatal _ enabled ) { write _ to _ targets ( log _ level . fatal , format _ provider , message , new object [ ] { argument } ) ;
if ( is _ fatal _ enabled ) { write _ to _ targets ( log _ level . fatal , message , new object [ ] { argument } ) ;
name = name ;
assert . true ( flush _ count < = write _ count ) ; write _ count + + ;
if ( throw _ exceptions )
name = name ;
assert . true ( flush _ count < = write _ count ) ; write _ count + + ; if ( fail _ counter > 0 )
fail _ counter - - ;
flush _ count + + ;
using config ;
fs _ normalize = true ;
if ( fs _ normalize )
name = name ;
optimize _ buffer _ reuse = get _ type ( ) = = typeof ( fallback _ group _ target ) ;
lock ( lock _ object )
if ( current _ target ! = 0 )
if ( return _ to _ first _ on _ success )
internal _ logger . debug ( STR , targets [ target _ to _ invoke ] ) ; current _ target = 0 ;
lock ( lock _ object )
current _ target = ( target _ to _ invoke + 1 ) % targets . count ;
target _ to _ invoke = current _ target ; if ( try _ counter > = targets . count )
lock ( lock _ object )
target _ to _ invoke = current _ target ;
include _ n _ log _ data = true ; ndc _ item _ separator = STR ;
ndlc _ item _ separator = STR ;
app _ info = string . format (
parameters = new list < n _ log _ viewer _ parameter _ info > ( ) ;
machine _ name = environment . machine _ name ;
machine _ name = string . empty ; } xml _ writer _ settings = new xml _ writer _ settings { indent = indent _ xml ,
if ( include _ source _ info )
if ( include _ call _ site )
append ( sb , log _ event ) ;
using ( xml _ writer xtw = xml _ writer . create ( sb , xml _ writer _ settings ) )
if ( include _ ndc ) { ndc _ content = string . join ( ndc _ item _ separator , nested _ diagnostics _ context . get _ all _ messages ( ) ) ;
if ( include _ ndlc )
ndc _ content + = ndc _ item _ separator ; } ndc _ content + = string . join ( ndlc _ item _ separator , nested _ diagnostics _ logical _ context . get _ all _ messages ( ) ) ;
if ( include _ source _ info )
if ( include _ n _ log _ data )
if ( include _ all _ properties )
if ( parameters . count > 0 ) { foreach ( n _ log _ viewer _ parameter _ info parameter in parameters )
xtw . write _ attribute _ safe _ string ( STR , app _ info ) ;
xtw . write _ attribute _ safe _ string ( STR , machine _ name ) ;
using internal ;
optimize _ buffer _ reuse = true ;
native _ methods . output _ debug _ string ( render _ log _ event ( layout , log _ event ) ) ;
file = create _ file _ stream ( false ) ;
if ( file = = null )
if ( file = = null )
if ( file = = null )
file = null ;
return creation _ time _ utc ;
return last _ write _ time _ utc ;
detect _ console _ available = false ; optimize _ buffer _ reuse = true ;
name = name ;
if ( header ! = null ) { write _ to _ output ( render _ log _ event ( header , log _ event _ info . create _ null _ event ( ) ) ) ;
if ( footer ! = null ) { write _ to _ output ( render _ log _ event ( footer , log _ event _ info . create _ null _ event ( ) ) ) ;
write _ to _ output ( render _ log _ event ( layout , log _ event ) ) ;
using config ;
string _ comparison comparison = ignore _ case
string result = layout . render ( log _ event ) ; if ( result . index _ of ( substring , comparison ) < 0 )
return action ;
message = STR ;
throw new invalid _ operation _ exception ( message ) ;
init _ count + + ;
close _ count + + ;
using internal ;
normalize = true ; difference = false ; precision = NUM ; align _ decimal _ point = true ;
get { return ! raw ; } set { raw = ! value ; }
frequency = performance _ frequency ; first _ qpc _ value = qpc _ value ; last _ qpc _ value = qpc _ value ;
if ( difference )
qpc _ value - = last _ qpc _ value ;
else if ( normalize )
qpc _ value - = first _ qpc _ value ;
last _ qpc _ value = v ;
if ( seconds )
double val = math . round ( qpc _ value / frequency , precision ) ;
if ( align _ decimal _ point )
string _ value + = STR + new string ( '0' , precision ) ;
string _ value + = new string ( '0' , precision - ( string _ value . length - 1 - p ) ) ;
log _ event _ info lei = log _ event _ info . create ( log _ level . info , name , null , message , par ) ;
log ( typeof ( my _ logger ) , lei ) ;
using config ;
if ( universal _ time )
name = name ;
assert . true ( flush _ count < = write _ count ) ; write _ count + + ;
if ( throw _ exceptions )
flush _ count + + ;
written _ events = new list < log _ event _ info > ( ) ;
name = name ;
assert . true ( flush _ count < = write _ count ) ;
write _ count + + ; written _ events . add ( log _ event ) ; } if ( fail _ counter > 0 ) { fail _ counter - - ;
flush _ count + + ;
succeeded = succeeded ;
succeeded = succeeded ; exception = exception ;
left = left ; right = right ;
return STR + left + STR + right + STR ;
name = name ;
wrapped _ target = wrapped _ target ; condition = condition ; optimize _ buffer _ reuse = get _ type ( ) = = typeof ( filtering _ target _ wrapper ) ;
using config ; using filters ; using targets ;
target = target ; filter _ chain = filter _ chain ;
log _ factory = log _ factory ;
initialize ( reader , file _ name , ignore _ errors ) ;
log _ factory = log _ factory ; initialize ( reader , file _ name , ignore _ errors ) ;
initialize ( reader , file _ name , false ) ;
initialize ( reader , file _ name , ignore _ errors ) ;
return new xml _ logging _ configuration ( original _ file _ name ) ;
original _ file _ name = file _ name ; parse _ top _ level ( content , file _ name , auto _ reload _ default : false ) ;
parse _ top _ level ( content , null , auto _ reload _ default : false ) ;
check _ parsing _ errors ( content ) ; check _ unused _ targets ( ) ;
if ( initialize _ succeeded = = null )
if ( ! file _ must _ auto _ reload _ lookup . contains _ key ( get _ file _ lookup _ key ( file _ name ) ) ) parse _ top _ level ( new n _ log _ xml _ element ( file _ name ) , file _ name , auto _ reload _ default ) ;
parse _ configuration _ element ( content , file _ path , auto _ reload _ default ) ;
parse _ n _ log _ element ( content , file _ path , auto _ reload _ default ) ;
parse _ n _ log _ element ( nlog _ element , file _ path , auto _ reload _ default ) ;
default _ culture _ info = culture _ info . invariant _ culture ;
exception _ logging _ old _ style = nlog _ element . get _ optional _ boolean _ attribute ( STR , false ) ;
parse _ extensions _ element ( extensions _ child , path . get _ directory _ name ( file _ path ) ) ;
parse _ include _ element ( child , path . get _ directory _ name ( file _ path ) , auto _ reload _ default : auto _ reload ) ;
parse _ targets _ element ( child ) ;
parse _ variable _ element ( child ) ;
parse _ time _ element ( child ) ;
parse _ rules _ element ( rule _ child , logging _ rules ) ;
parse _ logger _ element ( logger _ element , rules _ collection ) ;
parse _ filters ( rule , child ) ;
parse _ logger _ element ( child , rule . child _ rules ) ;
filter filter = configuration _ item _ factory . filters . create _ instance ( name ) ; configure _ object _ from _ attributes ( filter , filter _ element , false ) ;
string value = expand _ simple _ variables ( variable _ element . get _ required _ attribute ( STR ) ) ; variables [ name ] = value ;
target new _ target = configuration _ item _ factory . targets . create _ instance ( type _ attribute _ val ) ; parse _ target _ element ( new _ target , target _ element , type _ name _ to _ default _ target _ parameters ) ;
new _ target = wrap _ with _ default _ wrapper ( new _ target , default _ wrapper _ element ) ;
parse _ target _ element ( target , defaults , null ) ;
configure _ object _ from _ attributes ( target , target _ element , true ) ;
set _ property _ from _ element ( target , child _ element ) ;
parse _ target _ element ( new _ target , child _ element , type _ name _ to _ default _ target _ parameters ) ;
parse _ target _ element ( new _ target , child _ element , type _ name _ to _ default _ target _ parameters ) ;
configure _ from _ file ( file , auto _ reload _ default ) ;
time _ source new _ time _ source = configuration _ item _ factory . time _ sources . create _ instance ( type ) ; configure _ object _ from _ attributes ( new _ time _ source , time _ element , true ) ;
if ( add _ array _ item _ from _ element ( o , element ) )
if ( set _ layout _ from _ element ( o , element ) )
if ( set _ item _ from _ element ( o , element ) )
var value = expand _ simple _ variables ( element . value ) ;
property _ helper . set _ property _ from _ string ( o , element . local _ name , value , configuration _ item _ factory ) ;
configure _ object _ from _ attributes ( item , element , true ) ; configure _ object _ from _ element ( item , element ) ;
set _ property _ from _ element ( target _ object , child ) ;
parse _ target _ element ( wrapper _ target _ instance , default _ parameters ) ;
return configuration _ item _ factory . layouts . create _ instance ( expand _ simple _ variables ( layout _ type _ name ) ) ;
using config ;
if ( log _ event . properties . try _ get _ value ( parameter , out value ) )
return get _ targets _ for _ level ( level ) ! = null ;
if ( is _ enabled ( log _ event . level ) ) { write _ to _ targets ( log _ event ) ;
if ( is _ enabled ( log _ event . level ) ) { write _ to _ targets ( wrapper _ type , log _ event ) ;
if ( is _ enabled ( level ) ) { write _ to _ targets ( level , null , value ) ;
if ( is _ enabled ( level ) ) { write _ to _ targets ( level , format _ provider , value ) ;
if ( is _ enabled ( level ) )
write _ to _ targets ( level , null , message _ func ( ) ) ;
log ( level , message , exception ) ;
if ( is _ enabled ( level ) ) { write _ to _ targets ( level , format _ provider , message , args ) ;
if ( is _ enabled ( level ) ) { write _ to _ targets ( level , null , message ) ;
if ( is _ enabled ( level ) ) { write _ to _ targets ( level , message , args ) ;
if ( is _ enabled ( level ) ) { write _ to _ targets ( level , message , exception ) ;
if ( is _ enabled ( level ) ) { write _ to _ targets ( level , exception , message , args ) ;
if ( is _ enabled ( level ) ) { write _ to _ targets ( level , exception , format _ provider , message , args ) ;
if ( is _ enabled ( level ) ) { write _ to _ targets ( level , format _ provider , message , new object [ ] { argument } ) ;
if ( is _ enabled ( level ) ) { write _ to _ targets ( level , message , new object [ ] { argument } ) ;
if ( is _ enabled ( level ) ) { write _ to _ targets ( level , format _ provider , message , new object [ ] { argument , argument } ) ;
if ( is _ enabled ( level ) ) { write _ to _ targets ( level , message , new object [ ] { argument , argument } ) ;
if ( is _ enabled ( level ) ) { write _ to _ targets ( level , format _ provider , message , new object [ ] { argument , argument , argument } ) ;
name = name ; factory = factory ; set _ configuration ( logger _ configuration ) ;
logger _ impl . write ( logger _ type , get _ targets _ for _ level ( level ) , log _ event , factory ) ;
write _ to _ targets ( level , factory . default _ culture _ info , message , args ) ;
using config ;
name = name ; layout = layout ; encode = encode ;
using config ;
string _ comparison comparison _ type = ignore _ case
if ( layout . render ( log _ event ) . equals ( compare _ to , comparison _ type ) )
return action ;
using filters ; using targets ;
filters = new list < filter > ( ) ; child _ rules = new list < logging _ rule > ( ) ; targets = new list < target > ( ) ;
logger _ name _ pattern = logger _ name _ pattern ; targets . add ( target ) ;
logger _ name _ pattern = logger _ name _ pattern ; targets . add ( target ) ;
logger _ name _ pattern = logger _ name _ pattern ; targets . add ( target ) ;
return logger _ name _ pattern ;
logger _ name _ pattern = value ; int first _ pos = logger _ name _ pattern . index _ of ( '*' ) ; int last _ pos = logger _ name _ pattern . last _ index _ of ( '*' ) ;
logger _ name _ match _ mode = match _ mode . equals ; logger _ name _ match _ argument = value ;
logger _ name _ match _ mode = match _ mode . starts _ with ; logger _ name _ match _ argument = before ;
logger _ name _ match _ mode = match _ mode . ends _ with ; logger _ name _ match _ argument = after ;
logger _ name _ match _ mode = match _ mode . none ; logger _ name _ match _ argument = string . empty ;
enable _ logging _ for _ level ( log _ level . from _ ordinal ( i ) ) ;
sb . append _ format ( culture _ info . invariant _ culture , STR , logger _ name _ match _ argument , logger _ name _ match _ mode ) ;
foreach ( target app in targets )
switch ( logger _ name _ match _ mode )
return logger _ name . equals ( logger _ name _ match _ argument , string _ comparison . ordinal ) ;
return logger _ name . starts _ with ( logger _ name _ match _ argument , string _ comparison . ordinal ) ;
return logger _ name . ends _ with ( logger _ name _ match _ argument , string _ comparison . ordinal ) ;
return logger _ name . index _ of ( logger _ name _ match _ argument , string _ comparison . ordinal ) > = 0 ;
text = text ; position = 0 ;
get { return text ; }
if ( position < text . length )
return text [ position ] ;
if ( position < text . length )
return text [ position + + ] ;
write ( ( i _ list < async _ log _ event _ info > ) new [ ] { log _ event } ) ;
var buckets = log _ events . bucket _ sort ( c = > get _ smtp _ settings _ key ( c . log _ event ) ) ;
process _ single _ mail _ message ( event _ infos ) ;
if ( header ! = null ) { body _ buffer . append ( header . render ( first _ event ) ) ; if ( add _ new _ lines )
body _ buffer . append ( layout . render ( event _ info . log _ event ) ) ; if ( add _ new _ lines )
if ( footer ! = null ) { body _ buffer . append ( footer . render ( last _ event ) ) ; if ( add _ new _ lines )
if ( smtp _ server = = null & & string . is _ null _ or _ empty ( pickup _ directory _ location ) )
if ( delivery _ method = = smtp _ delivery _ method . network & & smtp _ server = = null )
if ( delivery _ method = = smtp _ delivery _ method . specified _ pickup _ directory & & string . is _ null _ or _ empty ( pickup _ directory _ location ) )
if ( smtp _ server ! = null & & delivery _ method = = smtp _ delivery _ method . network ) { var rendered _ smtp _ server = smtp _ server . render ( last _ event ) ;
client . port = smtp _ port ; client . enable _ ssl = enable _ ssl ; if ( smtp _ authentication = = smtp _ authentication _ mode . ntlm )
if ( ! string . is _ null _ or _ empty ( pickup _ directory _ location ) & & delivery _ method = = smtp _ delivery _ method . specified _ pickup _ directory )
client . delivery _ method = delivery _ method ; client . timeout = timeout ;
if ( ! use _ system _ net _ mail _ settings & & string . is _ null _ or _ empty ( pickup _ directory _ location ) & & delivery _ method = = smtp _ delivery _ method . specified _ pickup _ directory )
if ( from = = null )
var rendered _ from = from = = null ? null : from . render ( last _ event ) ;
if ( condition = = null )
name = name ;
name = name ;
flush _ count + + ;
log _ output = log _ output ; parameters = new dictionary < string , string > ( ) ; log _ level = log _ level . info ; throw _ exceptions = false ;
log ( log _ level . trace , message , arguments ) ;
log ( log _ level . debug , message , arguments ) ;
log ( log _ level . info , message , arguments ) ;
log ( log _ level . warn , message , arguments ) ;
log ( log _ level . error , message , arguments ) ;
if ( log _ output ! = null )
log _ output . close ( ) ; log _ output = null ;
foreach ( var kvp in parameters )
if ( log _ level > = log _ level )
using common ; using internal ;
get { return name _ to _ method _ info ; }
register _ type ( t , prefix ) ;
register _ definition ( item _ name _ prefix + attr . name , mi ) ;
if ( try _ create _ instance ( name , out result ) )
buffer = new log _ event _ info _ buffer ( buffer _ size , false , 0 ) ;
flush _ timer = new timer ( flush _ callback , null , timeout . infinite , timeout . infinite ) ;
var current _ timer = flush _ timer ;
flush _ timer = null ;
lock ( lock _ object )
if ( flush _ timeout > 0 )
if ( sliding _ timeout | | count = = 1 )
flush _ timer . change ( flush _ timeout , - 1 ) ;
lock ( lock _ object ) { if ( flush _ timer = = null )
internal _ logger . error ( exception , STR , name ) ;
if ( wrapped _ target = = null ) { internal _ logger . error ( STR , name ) ;
lock ( lock _ object ) { async _ log _ event _ info [ ] log _ events = buffer . get _ events _ and _ clear ( ) ;
internal _ logger . trace ( STR , name , log _ events . length , reason ) ; wrapped _ target . write _ async _ log _ events ( log _ events ) ;
name = name ;
domain = STR ; log _ on _ type = security _ log _ on _ type . interactive ; log _ on _ provider = log _ on _ provider _ type . default ; impersonation _ level = security _ impersonation _ level . impersonation ; wrapped _ target = wrapped _ target ;
if ( ! revert _ to _ self ) { new _ identity = create _ windows _ identity ( out duplicate _ token _ handle ) ; } using ( do _ impersonate ( ) )
using ( do _ impersonate ( ) )
using ( do _ impersonate ( ) ) { wrapped _ target . write _ async _ log _ event ( log _ event ) ;
using ( do _ impersonate ( ) ) { wrapped _ target . write _ async _ log _ events ( log _ events ) ;
using ( do _ impersonate ( ) ) { wrapped _ target . flush ( async _ continuation ) ;
if ( revert _ to _ self )
user _ name , domain , password , ( int ) log _ on _ type , ( int ) log _ on _ provider ,
if ( ! native _ methods . duplicate _ token ( logon _ handle , ( int ) impersonation _ level , out handle ) )
wic = windows _ impersonation _ context ;
layout . initialize ( logging _ configuration ) ;
using common ; using internal ; using config ;
using layouts ;
using config ;
trim _ white _ space = true ;
if ( trim _ white _ space )
separator = STR ; bottom _ frames = - 1 ; top _ frames = - 1 ;
if ( top _ frames ! = - 1 )
end _ pos = math . min ( top _ frames , messages . length ) ;
else if ( bottom _ frames ! = - 1 )
start _ pos = messages . length - math . min ( bottom _ frames , messages . length ) ;
current _ separator = separator ;
assert . true ( flush _ count < = write _ count ) ; write _ count + + ; if ( fail _ counter > 0 ) { fail _ counter - - ;
flush _ count + + ;
events = new list < log _ event _ info > ( ) ;
name = name ;
assert _ expected _ user ( ) ;
assert _ expected _ user ( ) ;
assert _ expected _ user ( ) ; events . add ( log _ event ) ;
assert _ expected _ user ( ) ;
assert _ expected _ user ( ) ;
if ( expected _ user ! = null )
using config ; using internal ;
separator = STR ; top _ frames = NUM ; format = stack _ trace _ format . flat ;
int starting _ frame = log _ event . user _ stack _ frame _ number + top _ frames - 1 ;
switch ( format )
using config ; using layouts ;
parameter _ type = typeof ( string ) ;
parameter _ type = typeof ( string ) ; layout = layout ;
parameter _ type = typeof ( string ) ; name = parameter _ name ; layout = layout ;
parameter _ type = type ; name = name ; layout = layout ;
current _ process _ id = native _ methods . get _ current _ process _ id ( ) ;
current _ process _ name = sb . to _ string ( ) ; current _ process _ base _ name = path . get _ file _ name _ without _ extension ( current _ process _ name ) ;
get { return current _ process _ id ; }
get { return current _ process _ name ; }
get { return current _ process _ base _ name ; }
using config ;
background _ color = console _ output _ color . no _ change ; foreground _ color = console _ output _ color . no _ change ;
text = text ; foreground _ color = foreground _ color ; background _ color = background _ color ;
if ( compiled _ regex = = null )
compiled _ regex = new regex ( regexpression , regex _ options ) ;
return compiled _ regex ;
if ( ignore _ case )
result . append ( ( char ) ( ( int ) foreground _ color + 'A' ) ) ; result . append ( ( char ) ( ( int ) background _ color + 'A' ) ) ;
var regex = compiled _ regex ;
return regex . replace ( message , match _ evaluator ) ;
return system . text . regular _ expressions . regex . replace ( message , expression , match _ evaluator , regex _ options ) ;
using config ;
format = STR ; culture = culture _ info . invariant _ culture ;
private key _ value _ pair < date _ time , string > cached _ utc _ time = new key _ value _ pair < date _ time , string > ( ) ;
private key _ value _ pair < date _ time , string > cached _ local _ time = new key _ value _ pair < date _ time , string > ( ) ;
if ( universal _ time )
text = text ;
builder . append ( text ) ;
using common ; using config ; using internal ; using layouts ;
encoding = encoding . default ;
last _ file _ name = string . empty ;
string file _ name = file _ name . render ( log _ event ) ; if ( file _ name ! = last _ file _ name )
current _ file _ contents = read _ file _ contents ( file _ name ) ; last _ file _ name = file _ name ;
builder . append ( current _ file _ contents ) ;
return file . read _ all _ text ( file _ name , encoding ) ;
using ( var reader = new stream _ reader ( file _ name , encoding ) )
internal class json _ converter _ legacy : i _ json _ converter , i _ json _ serializer
connection _ strings _ settings = configuration _ manager . connection _ strings ;  command _ type = command _ type . text ; optimize _ buffer _ reuse = get _ type ( ) = = typeof ( database _ target ) ;
name = name ;
run _ install _ commands ( installation _ context , install _ ddl _ commands ) ;
run _ install _ commands ( installation _ context , uninstall _ ddl _ commands ) ;
if ( provider _ factory ! = null ) { connection = provider _ factory . create _ connection ( ) ;
connection = ( i _ db _ connection ) activator . create _ instance ( connection _ type ) ;
if ( ! string . is _ null _ or _ empty ( connection _ string _ name ) )
var cs = connection _ strings _ settings [ connection _ string _ name ] ;
throw new n _ log _ configuration _ exception ( STR + connection _ string _ name + STR ) ; } connection _ string = simple _ layout . escape ( cs . connection _ string ) ;
provider _ factory = db _ provider _ factories . get _ factory ( cs . provider _ name ) ;
if ( invariantname = = db _ provider ) { provider _ factory = db _ provider _ factories . get _ factory ( db _ provider ) ;
set _ connection _ type ( ) ;
connection _ type = assembly . get _ type ( STR , true , true ) ;
connection _ type = system _ data _ assembly . get _ type ( STR , true ) ;
connection _ type = type . get _ type ( db _ provider , true ) ;
close _ connection ( ) ;
write _ event _ to _ database ( log _ event ) ;
close _ connection ( ) ;
if ( ! keep _ connection )
close _ connection ( ) ;
var buckets = log _ events . bucket _ sort ( c = > build _ connection _ string ( c . log _ event ) ) ;
write _ event _ to _ database ( ev . log _ event ) ;
if ( ! keep _ connection )
close _ connection ( ) ;
foreach ( database _ parameter _ info par in parameters )
if ( connection _ string ! = null ) { return render _ log _ event ( connection _ string , log _ event ) ;
sb . append ( render _ log _ event ( db _ host , log _ event ) ) ;
if ( db _ user _ name = = null )
sb . append ( render _ log _ event ( db _ user _ name , log _ event ) ) ;
sb . append ( render _ log _ event ( db _ password , log _ event ) ) ;
if ( db _ database ! = null )
sb . append ( render _ log _ event ( db _ database , log _ event ) ) ;
if ( active _ connection ! = null ) { if ( active _ connection _ string ! = connection _ string )
close _ connection ( ) ; } } if ( active _ connection ! = null )
active _ connection = open _ connection ( connection _ string ) ; active _ connection _ string = connection _ string ;
if ( active _ connection ! = null ) { active _ connection . close ( ) ; active _ connection . dispose ( ) ; active _ connection = null ; active _ connection _ string = null ;
cs = render _ log _ event ( command _ info . connection _ string , log _ event ) ; } else if ( install _ connection _ string ! = null )
cs = render _ log _ event ( install _ connection _ string , log _ event ) ;
cs = build _ connection _ string ( log _ event ) ;
if ( connection _ type = = null ) { set _ connection _ type ( ) ; } ensure _ connection _ open ( cs ) ; using ( var command = active _ connection . create _ command ( ) )
command . command _ text = render _ log _ event ( command _ info . text , log _ event ) ;
mutex = create _ sharable _ mutex ( STR ) ; file _ stream = create _ file _ stream ( true ) ; file _ characteristics _ helper = file _ characteristics _ helper . create _ helper ( parameters . force _ managed ) ;
if ( mutex = = null | | file _ stream = = null )
if ( mutex ! = null )
mutex = null ; } } if ( file _ stream ! = null )
file _ stream = null ;
get { return name ; }
get { return new _ line _ characters ; }
name = name ; new _ line _ characters = new _ line _ characters ;
using common ; using internal ;
dispose ( true ) ;
close ( ) ;
last _ write _ time _ utc = date _ time ;
return try _ create _ file _ stream ( allow _ file _ shared _ writing ) ;
var directory _ name = path . get _ directory _ name ( file _ name ) ;
return try _ create _ file _ stream ( allow _ file _ shared _ writing ) ;
int actual _ delay = random . next ( current _ delay ) ; internal _ logger . warn ( STR , i , file _ name , actual _ delay ) ;
return windows _ create _ file ( file _ name , allow _ file _ shared _ writing ) ;
file _ name ,
file _ info file _ info = new file _ info ( file _ name ) ;
file . create ( file _ name ) . dispose ( ) ; creation _ time _ utc = date _ time . utc _ now ;
file . set _ creation _ time _ utc ( file _ name , creation _ time _ utc ) ;
using common ; using config ; using internal ;
var lra = get _ type ( ) . get _ custom _ attribute < layout _ renderer _ attribute > ( ) ;
return get _ type ( ) . name ;
dispose ( true ) ;
int initial _ length = max _ rendered _ length ;
render _ append _ builder ( log _ event , builder ) ; if ( builder . length > max _ rendered _ length ) { max _ rendered _ length = builder . length ;
initialize ( configuration ) ;
close ( ) ;
if ( logging _ configuration = = null ) logging _ configuration = configuration ; if ( ! is _ initialized ) { is _ initialized = true ; initialize _ layout _ renderer ( ) ;
if ( is _ initialized ) { logging _ configuration = null ; is _ initialized = false ; close _ layout _ renderer ( ) ;
if ( ! is _ initialized ) { is _ initialized = true ; initialize _ layout _ renderer ( ) ;
append ( builder , log _ event ) ;
close ( ) ;
if ( culture = = null & & logging _ configuration ! = null ) { culture = logging _ configuration . default _ culture _ info ;
using config ; using internal ; using layouts ;
configuration _ item _ factory = configuration _ item _ factory ; tokenizer = new condition _ tokenizer ( string _ reader ) ;
tokenizer . get _ next _ token ( ) ; } tokenizer . expect ( condition _ token _ type . right _ paren ) ;
if ( tokenizer . token _ type = = condition _ token _ type . left _ paren ) { tokenizer . get _ next _ token ( ) ; condition _ method _ expression predicate _ expression = parse _ predicate ( keyword ) ;
return parse _ boolean _ expression ( ) ;
using conditions ; using config ;
exists = when _ exists _ expression ; filter = filter _ to _ apply ;
using common ; using config ; using internal ;
counter _ type = performance _ counter _ type . number _ of _ items ; increment _ value = new simple _ layout ( STR ) ; instance _ name = string . empty ; counter _ help = string . empty ;
name = name ;
counter _ creation _ data _ collection ccds = get _ counter _ creation _ data _ collection ( counters _ by _ category [ category _ name ] , out category _ type ) ;
if ( ! performance _ counter _ category . exists ( category _ name ) )
return performance _ counter _ category . counter _ exists ( counter _ name , category _ name ) ;
if ( perf _ counter ! = null ) { perf _ counter . close ( ) ; perf _ counter = null ; } initialized = false ;
if ( ! initialized ) { initialized = true ; if ( auto _ create )
install ( context ) ;
perf _ counter = new performance _ counter ( category _ name , counter _ name , instance _ name , false ) ;
internal _ logger . error ( exception , STR , category _ name , counter _ name , instance _ name ) ;
return perf _ counter ! = null ;
machine _ name = environment . machine _ name ;
machine _ name = string . empty ;
builder . append ( machine _ name ) ;
using common ; using config ; using internal ;
parameters = new list < method _ call _ parameter > ( ) ;
do _ invoke ( parameters , log _ event ) ;
var parameter _ value = render _ log _ event ( param . layout , log _ event ) ;
using ( var target _ builder = optimize _ buffer _ reuse ? reusable _ layout _ builder . allocate ( ) : reusable _ layout _ builder . none )
using config ; using internal ;
message _ queue _ proxy = new message _ queue _ proxy ( ) ; label = STR ; encoding = encoding . ut ; check _ if _ queue _ exists = true ;
name = name ;
if ( queue = = null )
if ( create _ queue _ if _ not _ exists )
var msg = prepare _ message ( log _ event ) ; message _ queue _ proxy . send ( queue , msg ) ;
if ( string . is _ null _ or _ empty ( host ) & & string . is _ null _ or _ empty ( pickup _ directory _ location ) )
if ( smtp _ server = = null & & string . is _ null _ or _ empty ( pickup _ directory _ location ) )
if ( delivery _ method = = smtp _ delivery _ method . network & & smtp _ server = = null )
if ( delivery _ method = = smtp _ delivery _ method . specified _ pickup _ directory & & string . is _ null _ or _ empty ( pickup _ directory _ location ) )
if ( ! string . is _ null _ or _ empty ( pickup _ directory _ location ) & & delivery _ method = = smtp _ delivery _ method . specified _ pickup _ directory )
client . delivery _ method = delivery _ method ;
name = name ;
return console _ target _ helper . get _ console _ output _ encoding ( encoding , is _ initialized , pause _ logging ) ;
if ( console _ target _ helper . set _ console _ output _ encoding ( value , is _ initialized , pause _ logging ) )
pause _ logging = false ;
if ( encoding ! = null & & ! pause _ logging ) console . output _ encoding = encoding ;
write _ to _ output ( lei , render _ log _ event ( header , lei ) ) ;
write _ to _ output ( lei , render _ log _ event ( footer , lei ) ) ;
write _ to _ output ( log _ event , render _ log _ event ( layout , log _ event ) ) ;
var console _ stream = error _ stream ? console . error : console . out ; if ( word _ highlighting _ rules . count = = 0 )
foreach ( console _ word _ highlighting _ rule hl in word _ highlighting _ rules )
foreach ( console _ row _ highlighting _ rule rule in row _ highlighting _ rules )
if ( use _ default _ row _ highlighting _ rules )
foreground _ color = foreground _ color ; background _ color = background _ color ;
get { return background _ color ; }
get { return foreground _ color ; }
stack = stack ; previous _ count = previous _ count ;
while ( stack . count > previous _ count )
var target _ attribute = get _ type ( ) . get _ custom _ attribute < time _ source _ attribute > ( ) ;
return get _ type ( ) . name ;
using common ;
async _ continuation = async _ continuation ;
var cont = interlocked . exchange ( ref async _ continuation , null ) ;
name = name ;
repeat _ count = repeat _ count ; optimize _ buffer _ reuse = get _ type ( ) = = typeof ( repeating _ target _ wrapper ) ;
optimize _ buffer _ reuse = true ;
name = name ;
if ( header ! = null )
debugger . log ( log _ level . off . ordinal , string . empty , render _ log _ event ( header , log _ event _ info . create _ null _ event ( ) ) + STR ) ;
debugger . log ( log _ level . off . ordinal , string . empty , render _ log _ event ( footer , log _ event _ info . create _ null _ event ( ) ) + STR ) ;
if ( optimize _ buffer _ reuse )
log _ message = render _ log _ event ( layout , log _ event ) + STR ;
separator = STR ; bottom _ frames = - 1 ; top _ frames = - 1 ;
if ( top _ frames ! = - 1 )
end _ pos = math . min ( top _ frames , messages . length ) ;
else if ( bottom _ frames ! = - 1 )
start _ pos = messages . length - math . min ( bottom _ frames , messages . length ) ;
current _ separator = separator ;
last _ message = string . empty ; counter = 0 ; optimize _ buffer _ reuse = true ;
name = name ;
counter + + ; last _ message = render _ log _ event ( layout , log _ event ) ;
events = new list < log _ event _ info > ( ) ;
name = name ;
events . add ( log _ event ) ; if ( throw _ exceptions )
name = name ;
assert . true ( flush _ count < = write _ count ) ; write _ count + + ;
if ( throw _ exceptions )
name = name ;
assert . true ( flush _ count < = write _ count ) ; write _ count + + ; if ( fail _ counter > 0 )
fail _ counter - - ;
flush _ count + + ;
if ( variable ! = null )
var environment _ variable = environment _ helper . get _ safe _ environment _ variable ( variable ) ;
if ( ! thread _ agnostic ) { render ( log _ event ) ;
if ( ! is _ initialized ) { initialize ( logging _ configuration ) ; } return get _ formatted _ message ( log _ event ) ;
if ( ! thread _ agnostic )
if ( ! is _ initialized ) { initialize ( logging _ configuration ) ; } if ( ! thread _ agnostic )
cache _ layout _ result = cache _ layout _ result & & ! thread _ agnostic ;
if ( ! thread _ agnostic )
int initial _ length = max _ rendered _ length ;
if ( sb . length > max _ rendered _ length ) { max _ rendered _ length = sb . length ; } if ( cache _ layout _ result & & ! thread _ agnostic )
initialize ( configuration ) ;
close ( ) ;
thread _ agnostic = object _ graph _ scanner _ list . all ( item = > item . get _ type ( ) . is _ defined ( typeof ( thread _ agnostic _ attribute ) , true ) ) ;
if ( is _ initialized ) { logging _ configuration = null ; is _ initialized = false ; close _ layout ( ) ;
current _ file _ length = file _ info . length ;
current _ file _ length = 0 ;
file = create _ file _ stream ( false ) ;
if ( file ! = null )
file = null ;
if ( file = = null )
return creation _ time _ utc ;
return last _ write _ time _ utc ;
return current _ file _ length ;
if ( file = = null )
current _ file _ length + = count ; file . write ( bytes , offset , count ) ;
using config ;
action = filter _ result . neutral ;
return check ( log _ event ) ;
using config ; using internal ;
if ( class _ name )
if ( method _ name )
if ( file _ name )
if ( clean _ names _ of _ async _ continuations & & method . name = = STR & & type . declaring _ type ! = null & & type . name . starts _ with ( STR ) )
if ( clean _ names _ of _ anonymous _ delegates & & class _ name ! = null )
if ( class _ name )
if ( clean _ names _ of _ async _ continuations & & method . name = = STR & & type ? . declaring _ type ! = null & & type . name . starts _ with ( STR ) )
if ( clean _ names _ of _ anonymous _ delegates & & ( method _ name . starts _ with ( STR ) & & method _ name . contains ( STR ) & & method _ name . contains ( STR ) ) )
using common ;
request _ limit = request _ limit ; on _ overflow = overflow _ action ;
if ( log _ event _ info _ queue . count > = request _ limit )
switch ( on _ overflow )
while ( log _ event _ info _ queue . count > = request _ limit )
if ( on _ overflow = = async _ target _ wrapper _ overflow _ action . block )
result . add ( log _ event _ info _ queue . dequeue ( ) ) ; if ( on _ overflow = = async _ target _ wrapper _ overflow _ action . block )
if ( is _ authenticated )
separator = separator ;
if ( auth _ type )
separator = separator ;
if ( name )
name = name ; ordinal = ordinal ;
get { return name ; }
return name ;
return ordinal ;
return ordinal = = other . ordinal ;
return other ! = null & & ordinal = = other . ordinal ;
return ordinal - level . ordinal ;
name = name ;
if ( throw _ on _ initialize )
assert . equal ( 0 , in _ blocking _ operation ) ; initialize _ count + + ;
assert . equal ( 0 , in _ blocking _ operation ) ; close _ count + + ;
assert . equal ( 0 , in _ blocking _ operation ) ; flush _ count + + ;
assert . equal ( 0 , in _ blocking _ operation ) ; write _ count + + ;
assert . equal ( 0 , in _ blocking _ operation ) ; write _ count + + ;
assert . equal ( 0 , in _ blocking _ operation ) ; write _ count + + ;
lock ( sync _ root ) { in _ blocking _ operation + + ;
in _ blocking _ operation - - ;
using config ; using layouts ;
string msg = render _ inner ( log _ event ) ; builder . append ( transform ( msg ) ) ;
previous _ culture _ info = thread . current _ thread . current _ culture ;
thread . current _ thread . current _ culture = previous _ culture _ info ;
return ( t ) get _ logger ( name , typeof ( t ) ) ;
return get _ logger ( frame . get _ method ( ) . declaring _ type . full _ name ) ;
using common ; using internal ;
targets = new list < target > ( targets ) ;
name = name ;
last _ log _ event = log _ event ;
events = new list < log _ event _ info > ( ) ;
name = name ;
if ( throw _ exceptions - - > 0 )
using config ; using internal ;
space _ as _ plus = true ;
log = new string _ writer ( ) ;
log = sender . log ; log . write _ line ( STR , address _ family , socket _ type , protocol _ type ) ;
return ( address _ family ) NUM ;
return STR + uri + STR ;
properties = new properties _ dictionary ( message _ template _ parameters ) ;
level = level ; logger _ name = logger _ name ; message = message ; parameters = parameters ; format _ provider = format _ provider ; exception = exception ;
calc _ formatted _ message ( ) ;
get { return stack _ trace ! = null ; }
get { return ( stack _ trace ! = null ) ? stack _ trace . get _ frame ( user _ stack _ frame _ number ) : null ; }
return logger _ name . substring ( last _ dot + 1 ) ; } return logger _ name ;
get { return message ; }
message = value ;
get { return parameters ; }
parameters = value ;
get { return format _ provider ; }
if ( format _ provider ! = value ) { format _ provider = value ;
get { return message _ formatter ; }
message _ formatter = value ? ? string _ format _ message _ formatter ;
if ( formatted _ message = = null ) { calc _ formatted _ message ( ) ; } return formatted _ message ;
if ( properties ! = null ) { return properties . count > 0 ;
internal properties _ dictionary properties _ dictionary { get { return properties ; } set { properties = value ; } }
if ( properties = = null ) { interlocked . compare _ exchange ( ref properties , new properties _ dictionary ( ) , null ) ;
calc _ formatted _ message ( ) ;
return properties ;
var log _ message _ formatter = message _ formatter ? . target as i _ log _ message _ formatter ;
if ( properties ! = null & & properties . message _ properties . count > 0 ) { return new message _ template _ parameters ( properties . message _ properties ) ;
return new message _ template _ parameters ( message , parameters ) ;
return STR + logger _ name + STR + level + STR + formatted _ message + STR + sequence _ id ;
stack _ trace = stack _ trace ; user _ stack _ frame _ number = user _ stack _ frame ;
if ( layout _ cache = = null )
lock ( layout _ cache ) { if ( layout _ cache . count = = 0 )
formatted _ message = message _ formatter ( this ) ;
formatted _ message = message ;
formatted _ message = null ;
calc _ formatted _ message ( ) ;
if ( properties ! = null & & has _ message _ template _ parameters ) { properties . message _ properties = null ;
grow _ as _ needed = grow _ as _ needed ; buffer = new async _ log _ event _ info [ size ] ; grow _ limit = grow _ limit ; get _ pointer = 0 ; put _ pointer = 0 ;
if ( count > = buffer . length )
if ( grow _ as _ needed & & buffer . length < grow _ limit )
int cnt = count ;
count = 0 ; get _ pointer = 0 ; put _ pointer = 0 ;
using conditions ; using config ;
return action ;
using config ;
xml _ encode = true ;
return xml _ encode ? do _ xml _ escape ( text ) : text ;
if ( value _ indexes ! = null )
foreach ( int index in value _ indexes )
if ( value _ indexes ! = null )
value _ indexes = new list < int > ( ) ;
using config ;
json _ encode = true ; escape _ unicode = true ;
if ( json _ encode )
var result = targets . default _ json _ serializer . escape _ string ( target . to _ string ( ) , escape _ unicode ) ;
using config ; using internal ;
exception _ separator = environment _ helper . new _ line ;
if ( raw )
if ( with _ exception & & log _ event . exception ! = null )
builder . append ( exception _ separator ) ;
cached = true ; clear _ cache = clear _ cache _ option . on _ init | clear _ cache _ option . on _ close ;
cached _ value = null ;
cached _ value = null ;
if ( cached )
if ( cached _ value = = null | | rendered _ cache _ key ! = new _ cache _ key )
cached _ value = base . render _ inner ( log _ event ) ; rendered _ cache _ key = new _ cache _ key ;
return cached _ value ;
assert . equal ( STR , get _ connection _ string ( dt ) ) ;
assert . equal ( STR , get _ connection _ string ( dt ) ) ;
assert . equal ( STR , get _ connection _ string ( dt ) ) ;
assert . equal ( STR , get _ connection _ string ( dt ) ) ;
assert . equal ( STR , get _ connection _ string ( dt ) ) ;
( ( mock _ db _ connection ) connection ) . add _ to _ log ( STR , param _ count ) ;
( ( mock _ db _ connection ) connection ) . add _ to _ log ( STR , command _ text ) ; if ( connection . connection _ string = = STR )
get { return parameter _ name ; }
parameter _ name = value ;
get { return parameter _ value ; }
parameter _ value = value ;
current _ process _ id = process . get _ current _ process ( ) . id ;
get { return current _ process _ id ; }
get _ process _ name ( ) ; return current _ process _ name ;
get _ process _ name ( ) ; return current _ process _ base _ name ;
if ( current _ process _ name = = null )
current _ process _ name = process . get _ current _ process ( ) . main _ module . file _ name ;
current _ process _ name = unknown _ process _ name ;
current _ process _ base _ name = path . get _ file _ name _ without _ extension ( current _ process _ name ) ;
if ( throw _ exceptions )
using config ; using internal ;
if ( full _ name )
using internal ;
string _ reader = string _ reader ; token _ type = condition _ token _ type . beginning _ of _ input ; get _ next _ token ( ) ;
string s = token _ value ;
if ( token _ type ! = token _ type ) { throw new condition _ parse _ exception ( STR + token _ type + STR + token _ type + STR + token _ value + STR ) ; } get _ next _ token ( ) ;
if ( token _ type ! = condition _ token _ type . keyword )
string s = token _ value ; get _ next _ token ( ) ;
if ( token _ type ! = condition _ token _ type . keyword )
if ( token _ type ! = condition _ token _ type . end _ of _ input )
return token _ type = = condition _ token _ type . number ;
return token _ type = = token _ type ;
if ( token _ type = = condition _ token _ type . end _ of _ input )
skip _ whitespace ( ) ; token _ position = token _ position ; int i = peek _ char ( ) ;
token _ type = condition _ token _ type . end _ of _ input ;
parse _ number ( ch ) ;
parse _ single _ quoted _ string ( ch ) ;
parse _ keyword ( ch ) ;
token _ value = ch . to _ string ( ) ;
token _ type = tt ; token _ value = new string ( ch , 1 ) ; read _ char ( ) ;
read _ char ( ) ; int next _ char = peek _ char ( ) ;
token _ type = condition _ token _ type . not _ equal ; token _ value = STR ; read _ char ( ) ;
token _ type = condition _ token _ type . less _ than _ or _ equal _ to ; token _ value = STR ; read _ char ( ) ; return true ; } token _ type = condition _ token _ type . less _ than ; token _ value = STR ;
read _ char ( ) ; int next _ char = peek _ char ( ) ;
token _ type = condition _ token _ type . greater _ than _ or _ equal _ to ; token _ value = STR ; read _ char ( ) ; return true ; } token _ type = condition _ token _ type . greater _ than ; token _ value = STR ;
read _ char ( ) ; int next _ char = peek _ char ( ) ;
token _ type = condition _ token _ type . not _ equal ; token _ value = STR ; read _ char ( ) ; return true ; } token _ type = condition _ token _ type . not ; token _ value = STR ;
read _ char ( ) ; int next _ char = peek _ char ( ) ;
token _ type = condition _ token _ type . and ; token _ value = STR ; read _ char ( ) ;
read _ char ( ) ; int next _ char = peek _ char ( ) ;
token _ type = condition _ token _ type . or ; token _ value = STR ; read _ char ( ) ;
read _ char ( ) ; int next _ char = peek _ char ( ) ;
token _ type = condition _ token _ type . equal _ to ; token _ value = STR ; read _ char ( ) ; return true ; } token _ type = condition _ token _ type . equal _ to ; token _ value = STR ;
token _ type = condition _ token _ type . string ;
read _ char ( ) ; while ( ( i = peek _ char ( ) ) ! = - 1 )
sb . append ( ( char ) read _ char ( ) ) ;
if ( peek _ char ( ) = = ( int ) '\'' )
read _ char ( ) ;
token _ value = sb . to _ string ( ) ;
token _ type = condition _ token _ type . keyword ;
read _ char ( ) ; while ( ( i = peek _ char ( ) ) ! = - 1 )
sb . append ( ( char ) read _ char ( ) ) ;
token _ value = sb . to _ string ( ) ;
token _ type = condition _ token _ type . number ;
read _ char ( ) ; while ( ( i = peek _ char ( ) ) ! = - 1 )
sb . append ( ( char ) read _ char ( ) ) ;
token _ value = sb . to _ string ( ) ;
while ( ( ch = peek _ char ( ) ) ! = - 1 )
read _ char ( ) ;
character = character ; token _ type = token _ type ;
get { return x ; } set { x = value ; }
return action ;
string _ comparison comparison _ type = ignore _ case
if ( ! layout . render ( log _ event ) . equals ( compare _ to , comparison _ type ) )
return action ;
name = name ;
message _ limit = message _ limit ; interval = interval ; wrapped _ target = wrapped _ target ; optimize _ buffer _ reuse = get _ type ( ) = = typeof ( limiting _ target _ wrapper ) ;
if ( message _ limit < = 0 )
if ( interval < = time _ span . zero )
if ( throw _ exceptions )
assert . true ( flush _ count < = write _ count ) ; write _ count + + ;
flush _ count + + ;
open _ async ( null ) ;
invoke _ async ( on _ begin _ open , null , on _ end _ open , on _ open _ completed , user _ state ) ;
close _ async ( null ) ;
on _ end _ process _ log _ messages , on _ process _ log _ messages _ completed ,
return begin _ process _ log _ messages ( events , callback , async _ state ) ;
end _ process _ log _ messages ( result ) ;
if ( process _ log _ messages _ completed ! = null )
process _ log _ messages _ completed ( this , new async _ completed _ event _ args ( e . error , e . cancelled , e . user _ state ) ) ;
if ( open _ completed ! = null )
open _ completed ( this , new async _ completed _ event _ args ( e . error , e . cancelled , e . user _ state ) ) ;
if ( close _ completed ! = null )
close _ completed ( this , new async _ completed _ event _ args ( e . error , e . cancelled , e . user _ state ) ) ;
name = name ;
if ( file _ appender _ cache ! = null ) { file _ appender _ cache . check _ close _ appenders - = auto _ closing _ timer _ callback ;
cleanup _ initialized _ files ( time _ source . current . time . add _ days ( - initialized _ files _ cleanup _ period ) ) ;
foreach ( var file in initialized _ files )
if ( discard _ all )
else if ( ! keep _ file _ open )
else if ( network _ writes )
else if ( concurrent _ writes )
if ( ! force _ mutex _ concurrent _ writes & & platform _ detector . is _ desktop _ win & & ! platform _ detector . is _ mono )
return archive _ above _ size ! = archive _ above _ size _ disabled | | archive _ every ! = file _ archive _ period . none ;
appender _ factory = get _ file _ appender _ factory ( ) ;
open _ file _ cache _ timeout * NUM , open _ file _ cache _ timeout * NUM ) ;
auto _ closing _ timer = null ;
file _ archive _ helper = null ;
var log _ file _ name = get _ full _ file _ name ( log _ event ) ;
byte [ ] bytes = get _ bytes _ to _ write ( log _ event ) ;
if ( full _ file _ name = = null )
byte [ ] bytes = get _ bytes _ to _ write ( ev . log _ event ) ;
flush _ current _ file _ writes ( file _ name , first _ log _ event , ms , out last _ exception ) ;
write _ to _ file ( file _ name , bytes _ to _ write , initialized _ new _ file ) ;
builder . copy _ to _ stream ( work _ stream , encoding , transform _ buffer ) ;
var cleanup _ archive _ files = file _ archive _ style . check _ archive _ cleanup ( archive _ file _ pattern , existing _ archive _ files , max _ archive _ files ) ;
if ( full _ archive _ file _ name = = null )
archive _ file = get _ archive _ file _ name ( file _ name , ev , upcoming _ write _ size ) ;
var validated _ archive _ file = get _ archive _ file _ name ( file _ name , ev , upcoming _ write _ size ) ;
do _ auto _ archive ( archive _ file , ev , initialized _ new _ file ) ;
if ( archive _ above _ size = = archive _ above _ size _ disabled )
var should _ archive = length . value + upcoming _ write _ size > archive _ above _ size ;
if ( archive _ every = = file _ archive _ period . none )
date _ time file _ create _ time = truncate _ archive _ time ( creation _ time _ source . value , archive _ every ) ; date _ time log _ event _ time = truncate _ archive _ time ( log _ event . time _ stamp , archive _ every ) ;
lock ( sync _ root ) { if ( ! is _ initialized )
date _ time expire _ time = open _ file _ cache _ timeout > 0 ? date _ time . utc _ now . add _ seconds ( - open _ file _ cache _ timeout ) : date _ time . min _ value ;
if ( replace _ file _ contents _ on _ each _ write )
write _ header ( appender ) ;
if ( auto _ flush )
initialized _ files [ file _ name ] = now ; initialized _ files _ counter + + ;
if ( initialized _ files _ counter > = initialized _ files _ counter _ max ) { initialized _ files _ counter = 0 ; cleanup _ initialized _ files ( ) ;
if ( ( is _ archiving ) | | ( ! write _ footer _ on _ archiving _ only ) )
array _ segment < byte > footer _ bytes = get _ layout _ bytes ( footer ) ;
write _ to _ file ( file _ name , footer _ bytes , false ) ;
do _ auto _ archive ( file _ name , log _ event , true ) ;
if ( delete _ old _ file _ on _ startup )
if ( file _ archive _ mode _ factory . should _ delete _ old _ archives ( max _ archive _ files ) )
if ( file _ archive _ style . attempt _ cleanup _ on _ initialize _ file ( archive _ file _ pattern , max _ archive _ files ) )
var cleanup _ archive _ files = file _ archive _ style . check _ archive _ cleanup ( archive _ file _ pattern , existing _ archive _ files , max _ archive _ files ) ;
array _ segment < byte > header _ bytes = get _ layout _ bytes ( header ) ;
array _ segment < byte > footer _ bytes = get _ layout _ bytes ( footer ) ;
if ( ! create _ dirs | | ! first _ attempt )
name = name ;
optimize _ buffer _ reuse = get _ type ( ) = = typeof ( randomize _ group _ target ) ;
lock ( random )
using common ; using config ; using internal ;
return base . to _ string ( ) + STR + wrapped _ target + STR ;
name = name ;
optimize _ buffer _ reuse = get _ type ( ) = = typeof ( round _ robin _ group _ target ) ;
lock ( lock _ object )
selected _ target = current _ target ; current _ target = ( current _ target + 1 ) % targets . count ;
using config ; using layouts ;
name = parameter _ name ; layout = parameter _ layout ;
using common ; using config ; using internal ; using layouts ; using log _ receiver _ service ;
parameters = new list < method _ call _ parameter > ( ) ;
name = name ;
write ( ( i _ list < async _ log _ event _ info > ) new [ ] { log _ event } ) ;
if ( in _ call )
precalculate _ volatile _ layouts ( log _ events [ i ] . log _ event ) ; buffer . append ( log _ events [ i ] ) ;
var network _ log _ events = translate _ log _ events ( log _ events _ array ) ; send ( network _ log _ events , log _ events _ array , null ) ;
send _ buffered _ events ( async _ continuation ) ;
if ( client _ id ! = null ) { client _ id = client _ id . render ( log _ events [ 0 ] . log _ event ) ;
merge _ event _ properties ( ev ) ;
network _ log _ events . events [ i ] = translate _ event ( ev . log _ event , network _ log _ events , string _ table ) ;
if ( ! on _ send ( events , async _ continuations ) )
internal _ logger . error ( e . error , STR , name ) ;
send _ buffered _ events ( null ) ;
in _ call = true ;
if ( string . is _ null _ or _ empty ( endpoint _ configuration _ name ) )
if ( use _ binary _ encoding )
client = new wcf _ log _ receiver _ client ( use _ one _ way _ contract , binding , new endpoint _ address ( endpoint _ address ) ) ;
client = new wcf _ log _ receiver _ client ( use _ one _ way _ contract , endpoint _ configuration _ name , new endpoint _ address ( endpoint _ address ) ) ;
return create _ wcf _ log _ receiver _ client ( ) ;
lock ( sync _ root )
var network _ log _ events = translate _ log _ events ( buffered _ events ) ; send ( network _ log _ events , buffered _ events , flush _ continuation ) ;
in _ call = false ;
internal _ logger . error ( exception , STR , name ) ;
internal _ logger . error ( exception , STR , name ) ;
var config = new logging _ configuration ( ) ;
var config = new logging _ configuration ( ) ;
var config = new logging _ configuration ( ) ;
register _ items _ from _ assembly ( asm ) ;
get { return targets ; }
get { return filters ; }
return layout _ renderers ;
get { return layout _ renderers ; }
get { return layouts ; }
get { return ambient _ properties ; }
public i _ json _ serializer json _ serializer { get { return json _ serializer as i _ json _ serializer ; }
get { return time _ sources ; }
get { return condition _ methods ; }
register _ items _ from _ assembly ( assembly , string . empty ) ;
foreach ( i _ factory f in all _ factories )
foreach ( i _ factory f in all _ factories )
get { return x ; } set { x = value ; }
return STR + x ;
if ( padding ! = 0 )
if ( padding > 0 )
s = s . pad _ left ( padding , pad _ character ) ;
s = s . pad _ right ( - padding , pad _ character ) ;
int absolute _ padding = padding ;
if ( fixed _ length & & s . length > absolute _ padding )
if ( alignment _ on _ truncation = = padding _ horizontal _ alignment . right )
assert . equal ( get _ type ( ) . full _ name , logger . name ) ;
name = name ;
max _ size = size ;
logs = new queue < string > ( max _ size ) ;
logs = null ;
if ( logs = = null )
if ( log _ event . has _ properties & & log _ event . properties . try _ get _ value ( item , out value ) )
var format _ provider = get _ format _ provider ( log _ event , culture ) ; builder . append _ formatted _ value ( value , format , format _ provider ) ;
socket = new socket ( address _ family , socket _ type , protocol _ type ) ;
return socket ;
( ( i _ disposable ) socket ) . dispose ( ) ;
name = name ;
type target _ type = type . get _ type ( class _ name ) ;
method = target _ type . get _ method ( method _ name ) ; if ( method = = null )
needed _ parameters = method . get _ parameters ( ) . length ;
method = null ;
method = null ;
if ( method ! = null )
else if ( lhf = = null )
lhf = new layout _ with _ header _ and _ footer ( )
get { return is _ trace _ enabled ; }
get { return is _ debug _ enabled ; }
get { return is _ info _ enabled ; }
get { return is _ warn _ enabled ; }
get { return is _ error _ enabled ; }
get { return is _ fatal _ enabled ; }
if ( is _ trace _ enabled ) { write _ to _ targets ( log _ level . trace , null , value ) ;
if ( is _ trace _ enabled ) { write _ to _ targets ( log _ level . trace , format _ provider , value ) ;
if ( is _ trace _ enabled )
write _ to _ targets ( log _ level . trace , null , message _ func ( ) ) ;
trace ( message , exception ) ;
if ( is _ trace _ enabled ) { write _ to _ targets ( log _ level . trace , format _ provider , message , args ) ;
if ( is _ trace _ enabled ) { write _ to _ targets ( log _ level . trace , null , message ) ;
if ( is _ trace _ enabled ) { write _ to _ targets ( log _ level . trace , message , args ) ;
if ( is _ trace _ enabled ) { write _ to _ targets ( log _ level . trace , message , exception ) ;
if ( is _ trace _ enabled ) { write _ to _ targets ( log _ level . trace , exception , message , null ) ;
if ( is _ trace _ enabled ) { write _ to _ targets ( log _ level . trace , exception , message , args ) ;
if ( is _ trace _ enabled ) { write _ to _ targets ( log _ level . trace , exception , format _ provider , message , args ) ;
if ( is _ trace _ enabled ) { write _ to _ targets ( log _ level . trace , format _ provider , message , new object [ ] { argument } ) ;
if ( is _ trace _ enabled )
trace ( message , exception _ candidate ) ;
write _ to _ targets ( log _ level . trace , message , new object [ ] { argument } ) ;
if ( is _ trace _ enabled ) { write _ to _ targets ( log _ level . trace , format _ provider , message , new object [ ] { argument , argument } ) ;
if ( is _ trace _ enabled ) { write _ to _ targets ( log _ level . trace , message , new object [ ] { argument , argument } ) ;
if ( is _ trace _ enabled ) { write _ to _ targets ( log _ level . trace , format _ provider , message , new object [ ] { argument , argument , argument } ) ;
if ( is _ trace _ enabled ) { write _ to _ targets ( log _ level . trace , message , new object [ ] { argument , argument , argument } ) ;
if ( is _ debug _ enabled ) { write _ to _ targets ( log _ level . debug , null , value ) ;
if ( is _ debug _ enabled ) { write _ to _ targets ( log _ level . debug , format _ provider , value ) ;
if ( is _ debug _ enabled )
write _ to _ targets ( log _ level . debug , null , message _ func ( ) ) ;
debug ( message , exception ) ;
if ( is _ debug _ enabled ) { write _ to _ targets ( log _ level . debug , format _ provider , message , args ) ;
if ( is _ debug _ enabled ) { write _ to _ targets ( log _ level . debug , null , message ) ;
if ( is _ debug _ enabled ) { write _ to _ targets ( log _ level . debug , message , args ) ;
if ( is _ debug _ enabled ) { write _ to _ targets ( log _ level . debug , message , exception ) ;
if ( is _ debug _ enabled ) { write _ to _ targets ( log _ level . debug , exception , message , null ) ;
if ( is _ debug _ enabled ) { write _ to _ targets ( log _ level . debug , exception , message , args ) ;
if ( is _ debug _ enabled ) { write _ to _ targets ( log _ level . debug , exception , format _ provider , message , args ) ;
if ( is _ debug _ enabled ) { write _ to _ targets ( log _ level . debug , format _ provider , message , new object [ ] { argument } ) ;
if ( is _ debug _ enabled )
debug ( message , exception _ candidate ) ;
write _ to _ targets ( log _ level . debug , message , new object [ ] { argument } ) ;
if ( is _ debug _ enabled ) { write _ to _ targets ( log _ level . debug , format _ provider , message , new object [ ] { argument , argument } ) ;
if ( is _ debug _ enabled ) { write _ to _ targets ( log _ level . debug , message , new object [ ] { argument , argument } ) ;
if ( is _ debug _ enabled ) { write _ to _ targets ( log _ level . debug , format _ provider , message , new object [ ] { argument , argument , argument } ) ;
if ( is _ debug _ enabled ) { write _ to _ targets ( log _ level . debug , message , new object [ ] { argument , argument , argument } ) ;
if ( is _ info _ enabled ) { write _ to _ targets ( log _ level . info , null , value ) ;
if ( is _ info _ enabled ) { write _ to _ targets ( log _ level . info , format _ provider , value ) ;
if ( is _ info _ enabled )
write _ to _ targets ( log _ level . info , null , message _ func ( ) ) ;
info ( message , exception ) ;
if ( is _ info _ enabled ) { write _ to _ targets ( log _ level . info , format _ provider , message , args ) ;
if ( is _ info _ enabled ) { write _ to _ targets ( log _ level . info , null , message ) ;
if ( is _ info _ enabled ) { write _ to _ targets ( log _ level . info , message , args ) ;
if ( is _ info _ enabled ) { write _ to _ targets ( log _ level . info , message , exception ) ;
if ( is _ info _ enabled ) { write _ to _ targets ( log _ level . info , exception , message , null ) ;
if ( is _ info _ enabled ) { write _ to _ targets ( log _ level . info , exception , message , args ) ;
if ( is _ info _ enabled ) { write _ to _ targets ( log _ level . info , exception , format _ provider , message , args ) ;
if ( is _ info _ enabled ) { write _ to _ targets ( log _ level . info , format _ provider , message , new object [ ] { argument } ) ;
if ( is _ info _ enabled )
info ( message , exception _ candidate ) ;
write _ to _ targets ( log _ level . info , message , new object [ ] { argument } ) ;
if ( is _ info _ enabled ) { write _ to _ targets ( log _ level . info , format _ provider , message , new object [ ] { argument , argument } ) ;
if ( is _ info _ enabled ) { write _ to _ targets ( log _ level . info , message , new object [ ] { argument , argument } ) ;
if ( is _ info _ enabled ) { write _ to _ targets ( log _ level . info , format _ provider , message , new object [ ] { argument , argument , argument } ) ;
if ( is _ info _ enabled ) { write _ to _ targets ( log _ level . info , message , new object [ ] { argument , argument , argument } ) ;
if ( is _ warn _ enabled ) { write _ to _ targets ( log _ level . warn , null , value ) ;
if ( is _ warn _ enabled ) { write _ to _ targets ( log _ level . warn , format _ provider , value ) ;
if ( is _ warn _ enabled )
write _ to _ targets ( log _ level . warn , null , message _ func ( ) ) ;
warn ( message , exception ) ;
if ( is _ warn _ enabled ) { write _ to _ targets ( log _ level . warn , format _ provider , message , args ) ;
if ( is _ warn _ enabled ) { write _ to _ targets ( log _ level . warn , null , message ) ;
if ( is _ warn _ enabled ) { write _ to _ targets ( log _ level . warn , message , args ) ;
if ( is _ warn _ enabled ) { write _ to _ targets ( log _ level . warn , message , exception ) ;
if ( is _ warn _ enabled ) { write _ to _ targets ( log _ level . warn , exception , message , null ) ;
if ( is _ warn _ enabled ) { write _ to _ targets ( log _ level . warn , exception , message , args ) ;
if ( is _ warn _ enabled ) { write _ to _ targets ( log _ level . warn , exception , format _ provider , message , args ) ;
if ( is _ warn _ enabled ) { write _ to _ targets ( log _ level . warn , format _ provider , message , new object [ ] { argument } ) ;
if ( is _ warn _ enabled )
warn ( message , exception _ candidate ) ;
write _ to _ targets ( log _ level . warn , message , new object [ ] { argument } ) ;
if ( is _ warn _ enabled ) { write _ to _ targets ( log _ level . warn , format _ provider , message , new object [ ] { argument , argument } ) ;
if ( is _ warn _ enabled ) { write _ to _ targets ( log _ level . warn , message , new object [ ] { argument , argument } ) ;
if ( is _ warn _ enabled ) { write _ to _ targets ( log _ level . warn , format _ provider , message , new object [ ] { argument , argument , argument } ) ;
if ( is _ warn _ enabled ) { write _ to _ targets ( log _ level . warn , message , new object [ ] { argument , argument , argument } ) ;
if ( is _ error _ enabled ) { write _ to _ targets ( log _ level . error , null , value ) ;
if ( is _ error _ enabled ) { write _ to _ targets ( log _ level . error , format _ provider , value ) ;
if ( is _ error _ enabled )
write _ to _ targets ( log _ level . error , null , message _ func ( ) ) ;
error ( message , exception ) ;
if ( is _ error _ enabled ) { write _ to _ targets ( log _ level . error , format _ provider , message , args ) ;
if ( is _ error _ enabled ) { write _ to _ targets ( log _ level . error , null , message ) ;
if ( is _ error _ enabled ) { write _ to _ targets ( log _ level . error , message , args ) ;
if ( is _ error _ enabled ) { write _ to _ targets ( log _ level . error , message , exception ) ;
if ( is _ error _ enabled ) { write _ to _ targets ( log _ level . error , exception , message , null ) ;
if ( is _ error _ enabled ) { write _ to _ targets ( log _ level . error , exception , message , args ) ;
if ( is _ error _ enabled ) { write _ to _ targets ( log _ level . error , exception , format _ provider , message , args ) ;
if ( is _ error _ enabled ) { write _ to _ targets ( log _ level . error , format _ provider , message , new object [ ] { argument } ) ;
if ( is _ error _ enabled )
error ( message , exception _ candidate ) ;
write _ to _ targets ( log _ level . error , message , new object [ ] { argument } ) ;
if ( is _ error _ enabled ) { write _ to _ targets ( log _ level . error , format _ provider , message , new object [ ] { argument , argument } ) ;
if ( is _ error _ enabled ) { write _ to _ targets ( log _ level . error , message , new object [ ] { argument , argument } ) ;
if ( is _ error _ enabled ) { write _ to _ targets ( log _ level . error , format _ provider , message , new object [ ] { argument , argument , argument } ) ;
if ( is _ error _ enabled ) { write _ to _ targets ( log _ level . error , message , new object [ ] { argument , argument , argument } ) ;
if ( is _ fatal _ enabled ) { write _ to _ targets ( log _ level . fatal , null , value ) ;
if ( is _ fatal _ enabled ) { write _ to _ targets ( log _ level . fatal , format _ provider , value ) ;
if ( is _ fatal _ enabled )
write _ to _ targets ( log _ level . fatal , null , message _ func ( ) ) ;
fatal ( message , exception ) ;
if ( is _ fatal _ enabled ) { write _ to _ targets ( log _ level . fatal , format _ provider , message , args ) ;
if ( is _ fatal _ enabled ) { write _ to _ targets ( log _ level . fatal , null , message ) ;
if ( is _ fatal _ enabled ) { write _ to _ targets ( log _ level . fatal , message , args ) ;
if ( is _ fatal _ enabled ) { write _ to _ targets ( log _ level . fatal , message , exception ) ;
if ( is _ fatal _ enabled ) { write _ to _ targets ( log _ level . fatal , exception , message , null ) ;
if ( is _ fatal _ enabled ) { write _ to _ targets ( log _ level . fatal , exception , message , args ) ;
if ( is _ fatal _ enabled ) { write _ to _ targets ( log _ level . fatal , exception , format _ provider , message , args ) ;
if ( is _ fatal _ enabled ) { write _ to _ targets ( log _ level . fatal , format _ provider , message , new object [ ] { argument } ) ;
if ( is _ fatal _ enabled )
fatal ( message , exception _ candidate ) ;
write _ to _ targets ( log _ level . fatal , message , new object [ ] { argument } ) ;
if ( is _ fatal _ enabled ) { write _ to _ targets ( log _ level . fatal , format _ provider , message , new object [ ] { argument , argument } ) ;
if ( is _ fatal _ enabled ) { write _ to _ targets ( log _ level . fatal , message , new object [ ] { argument , argument } ) ;
if ( is _ fatal _ enabled ) { write _ to _ targets ( log _ level . fatal , format _ provider , message , new object [ ] { argument , argument , argument } ) ;
if ( is _ fatal _ enabled ) { write _ to _ targets ( log _ level . fatal , message , new object [ ] { argument , argument , argument } ) ;
return to _ event _ info ( string . empty ) ;
implementation = implementation ;
get { return implementation ; }
return get _ enumerator ( ) ;
wrapped = wrapped ;
get { return entry ; }
using config ; using layouts ;
parameters = new list < database _ parameter _ info > ( ) ; command _ type = command _ type . text ;
using common ;
address _ family = address _ family ;
close _ socket ( continuation ) ;
var sock = socket ; socket = null ;
args . completed + = socket _ operation _ completed ; args . remote _ end _ point = endpoint ; if ( ! socket . send _ to _ async ( args ) )
socket _ operation _ completed ( socket , args ) ;
name = name ;
get { return max _ message _ length ; }
max _ message _ length = value ;
get { return max _ kilobytes ; }
max _ kilobytes = value ;
event _ log . delete _ event _ source ( fixed _ source , machine _ name ) ;
return event _ log . source _ exists ( fixed _ source , machine _ name ) ;
string message = render _ log _ event ( layout , log _ event ) ;
if ( message . length > max _ message _ length )
message = message . substring ( 0 , max _ message _ length ) ;
for ( int offset = 0 ; offset < message . length ; offset + = max _ message _ length )
string chunk = message . substring ( offset , math . min ( max _ message _ length , ( message . length - offset ) ) ) ;
if ( entry _ type ! = null )
var value = render _ log _ event ( entry _ type , log _ event ) ;
event _ log _ instance . log = = log & & event _ log _ instance . machine _ name = = machine _ name ;
event _ log _ instance = new event _ log ( log , machine _ name , rendered _ source ) ; } if ( max _ kilobytes . has _ value )
return source ! = null ? render _ log _ event ( source , log _ event ) : null ;
machine _ name = machine _ name
machine _ name = machine _ name
process _ log _ messages ( log _ events ) ;
if ( log _ factory ! = null )
using config ; using internal ;
property = process _ info _ property . id ;
property _ info = typeof ( process ) . get _ property ( property . to _ string ( ) ) ; if ( property _ info = = null )
throw new argument _ exception ( STR + property _ info + STR ) ;
late _ bound _ property _ get = reflection _ helpers . create _ late _ bound _ method ( property _ info . get _ get _ method ( ) ) ; process = process . get _ current _ process ( ) ;
if ( process ! = null )
process . close ( ) ; process = null ;
if ( late _ bound _ property _ get ! = null )
var value = late _ bound _ property _ get ( process , null ) ; builder . append _ formatted _ value ( value , format , format _ provider ) ;
using config ;
culture = culture _ info . invariant _ culture ; uppercase = true ;
if ( uppercase )
culture _ info culture = culture ;
using common ; using internal ; using layouts ; using targets ;
logging _ rules = new list < logging _ rule > ( ) ;
initialize _ all ( ) ;
config _ items = object _ graph _ scanner . find _ reachable _ objects < object > ( roots . to _ array ( ) ) ;
internal _ logger . info ( STR , config _ items . count ) ; foreach ( object o in config _ items )
validate _ config ( ) ;
initialize _ all ( ) ;
logs = new list < string > ( ) ; optimize _ buffer _ reuse = true ;
name = name ;
logs . add ( render _ log _ event ( layout , log _ event ) ) ;
if ( ignore _ case )
if ( whole _ words )
regex = new regex ( regex _ string , regex _ options ) ;
text = text ; replace _ group _ name = replace _ group _ name ; replace _ with = replace _ with ;
optimize _ buffer _ reuse = true ;
name = name ;
if ( format _ message )
render _ log _ event ( layout , log _ event ) ;
using common ;
var web _ request = web _ request . create ( new uri ( address ) ) ;
sent _ messages = new list < message > ( ) ;
queue _ exists _ called = true ; return queue _ exists ;
queue _ created = true ;
increment = 1 ; value = 1 ;
if ( sequence ! = null )
v = get _ next _ sequence _ value ( sequence . render ( log _ event ) , value , increment ) ;
v = value ; value + = increment ;
if ( user _ name )
if ( domain )
get { return lock _ object ; }
if ( is _ initialized )
lock ( sync _ root ) { return is _ initialized ;
lock ( sync _ root )
bool was _ initialized = is _ initialized ; initialize ( configuration ) ;
close ( ) ;
dispose ( true ) ;
lock ( sync _ root ) { if ( ! is _ initialized )
flush _ async ( async _ continuation ) ;
if ( all _ layouts _ are _ thread _ agnostic )
lock ( sync _ root ) { if ( ! is _ initialized )
if ( all _ layouts ! = null ) { if ( optimize _ buffer _ reuse ) { using ( var target _ builder = reusable _ layout _ builder . allocate ( ) )
foreach ( layout layout in all _ layouts )
foreach ( layout layout in all _ layouts )
var target _ attribute = get _ type ( ) . get _ custom _ attribute < target _ attribute > ( ) ;
return target _ attribute . name + STR + ( name ? ? STR ) + STR ; } return get _ type ( ) . name ;
if ( ! is _ initialized ) { lock ( sync _ root )
if ( initialize _ exception ! = null ) { lock ( sync _ root ) { log _ event . continuation ( create _ init _ exception ( ) ) ;
write _ async _ thread _ safe ( wrapped _ log _ event ) ;
if ( ! is _ initialized ) { lock ( sync _ root )
if ( initialize _ exception ! = null ) { lock ( sync _ root )
log _ events [ i ] . continuation ( create _ init _ exception ( ) ) ;
if ( optimize _ buffer _ reuse )
write _ async _ thread _ safe ( wrapped _ events ) ;
lock ( sync _ root ) { logging _ configuration = configuration ; if ( ! is _ initialized )
initialize _ target ( ) ; initialize _ exception = null ;
initialize _ exception = exception ;
is _ initialized = true ;
lock ( sync _ root ) { logging _ configuration = null ; if ( is _ initialized ) { is _ initialized = false ;
if ( initialize _ exception = = null )
close _ target ( ) ;
lock ( sync _ root ) { if ( ! is _ initialized )
write ( log _ event ) ;
write ( log _ events [ i ] ) ;
lock ( sync _ root ) { if ( ! is _ initialized )
async _ log _ event _ info [ ] log _ events _ array = optimize _ buffer _ reuse ? null : log _ events as async _ log _ event _ info [ ] ; if ( ! optimize _ buffer _ reuse & & log _ events _ array ! = null )
write ( log _ events _ array ) ;
write ( log _ events ) ;
if ( process _ exit _ event = = null & & current _ app _ domain ! = null ) current _ app _ domain . process _ exit + = on _ process _ exit ;
process _ exit _ event + = value ;
process _ exit _ event - = value ;
if ( process _ exit _ event = = null & & current _ app _ domain ! = null ) current _ app _ domain . process _ exit - = on _ process _ exit ;
if ( domain _ unload _ event = = null & & current _ app _ domain ! = null ) current _ app _ domain . domain _ unload + = on _ domain _ unload ;
domain _ unload _ event + = value ;
domain _ unload _ event - = value ;
if ( domain _ unload _ event = = null & & current _ app _ domain ! = null ) current _ app _ domain . domain _ unload - = on _ domain _ unload ;
optimize _ buffer _ reuse = true ;
name = name ;
string log _ message = render _ log _ event ( layout , log _ event ) ; if ( raw _ write | | log _ event . level < = log _ level . debug )
protocol = web _ service _ protocol . soap ;
encoding = new ut _ encoding ( write _ bom ) ; include _ bom = write _ bom ; optimize _ buffer _ reuse = true ; headers = new list < method _ call _ parameter > ( ) ;
name = name ;
found _ enable _ group _ layout = false ; only _ enable _ group _ layout = true ;
if ( headers ! = null & & headers . count > 0 )
var header _ buckets = log _ events . bucket _ sort ( convet _ to _ header _ array _ delegate , array _ deep _ equality _ comparer < string > . default ) ;
if ( pre _ authenticate )
write _ stream _ and _ fix _ preamble ( post _ payload , stream , include _ bom , encoding ) ;
internal _ logger . error ( ex , STR , name ) ;
if ( protocol ! = web _ service _ protocol . http _ get ) { return url ;
using ( var target _ builder = optimize _ buffer _ reuse ? reusable _ layout _ builder . allocate ( ) : reusable _ layout _ builder . none )
var builder = new uri _ builder ( url ) ;
if ( throw _ exceptions )
buffered _ write _ count + + ; buffered _ total _ events + = log _ events . count ;
if ( fail _ counter > 0 ) { fail _ counter - - ;
flush _ count + + ;
configuration _ item _ factory = configuration _ item _ factory ; text = txt ;
configuration _ item _ factory = configuration _ item _ factory ; set _ renderers ( renderers , text ) ;
return layout _ text ;
set _ renderers ( renderers , txt ) ;
return STR + text + STR ;
fixed _ text = null ; } layout _ text = text ; if ( logging _ configuration ! = null )
return fixed _ text ;
left _ expression = left ; right _ expression = right ;
return STR + left _ expression + STR + right _ expression + STR ;
events = new list < log _ event _ info > ( ) ;
name = name ;
using config ; using layouts ;
get { return inner ; } set { inner = value ; }
using layout _ renderers ;
renderer = new log _ j _ xml _ event _ layout _ renderer ( ) ;
name = name ;
using common ;
address = url ; last _ send _ time = interlocked . increment ( ref current _ send _ time ) ;
do _ initialize ( ) ;
do _ close ( continuation ) ;
do _ flush ( continuation ) ;
last _ send _ time = interlocked . increment ( ref current _ send _ time ) ; do _ send ( bytes , offset , length , async _ continuation ) ;
dispose ( true ) ;
if ( ! with _ header ) { header = null ; } switch ( delimiter )
actual _ column _ delimiter = culture _ info . current _ culture . text _ info . list _ separator ;
actual _ column _ delimiter = STR ;
actual _ column _ delimiter = STR ;
actual _ column _ delimiter = STR ;
sb . append ( actual _ column _ delimiter ) ;
switch ( quoting )
if ( column _ value . index _ of _ any ( quotable _ characters ) > = 0 )
sb . append ( quote _ char ) ;
sb . append ( column _ value . replace ( quote _ char , double _ quote _ char ) ) ;
sb . append ( quote _ char ) ;
parent = parent ;
using config ; using layout _ renderers ; using layouts ;
parameters = new list < n _ log _ viewer _ parameter _ info > ( ) ; renderer . parameters = parameters ;
name = name ;
return layout ;
using common ; using conditions ; using config ; using internal ;
rules = new list < filtering _ rule > ( ) ;
rules = new list < filtering _ rule > ( ) ; wrapped _ target = wrapped _ target ;
name = name ;
result _ filter = default _ filter ;
watcher = new multi _ file _ watcher ( ) ; watcher . file _ changed + = config _ file _ changed ;
configuration = config ;
if ( config _ loaded ) return config ; lock ( sync _ root ) { if ( config _ loaded ) return config ;
if ( config = = null )
config = xml _ logging _ configuration . app _ config ;
if ( config = = null )
if ( config ! = null )
config _ loaded = true ; } } return config ;
lock ( sync _ root ) { logging _ configuration old _ config = config ;
flush ( ) ;
config = value ; if ( config = = null ) config _ loaded = false ;
config . initialize _ all ( ) ; reconfig _ existing _ loggers ( ) ;
config _ loaded = true ; } } on _ configuration _ changed ( new logging _ configuration _ changed _ event _ args ( value , old _ config ) ) ;
return global _ threshold ;
lock ( sync _ root ) { global _ threshold = value ; reconfig _ existing _ loggers ( ) ;
var configuration = configuration ;
return get _ logger ( frame . get _ method ( ) . declaring _ type . full _ name ) ;
return ( t ) get _ logger ( frame . get _ method ( ) . declaring _ type . full _ name , typeof ( t ) ) ;
return get _ logger ( frame . get _ method ( ) . declaring _ type . full _ name , logger _ type ) ;
return ( t ) get _ logger ( new logger _ cache _ key ( name , typeof ( t ) ) ) ;
return get _ logger ( new logger _ cache _ key ( name , logger _ type ) ) ;
lock ( sync _ root ) { if ( config ! = null ) { config . initialize _ all ( ) ;
logger . set _ configuration ( get _ configuration _ for _ logger ( logger . name , config ) ) ;
flush ( default _ flush _ timeout ) ;
async _ helpers . run _ synchronously ( cb = > flush ( cb , timeout ) ) ;
flush ( time _ span . from _ milliseconds ( timeout _ milliseconds ) ) ;
flush ( async _ continuation , time _ span . max _ value ) ;
flush ( async _ continuation , time _ span . from _ milliseconds ( timeout _ milliseconds ) ) ;
lock ( sync _ root ) { logs _ enabled - - ; if ( logs _ enabled = = - 1 ) { reconfig _ existing _ loggers ( ) ;
lock ( sync _ root ) { logs _ enabled + + ; if ( logs _ enabled = = 0 ) { reconfig _ existing _ loggers ( ) ;
return logs _ enabled > = 0 ;
if ( reload _ timer = = null & & is _ disposing )
lock ( sync _ root )
if ( is _ disposing )
var current _ timer = reload _ timer ;
reload _ timer = null ;
watcher . stop _ watching ( ) ; if ( configuration ! = configuration _ to _ reload )
if ( is _ disposing )
is _ disposing = true ;
configuration _ reloaded = null ; if ( watcher ! = null )
watcher . file _ changed - = config _ file _ changed ; }  if ( monitor . try _ enter ( sync _ root , NUM ) )
var current _ timer = reload _ timer ;
reload _ timer = null ;
if ( watcher ! = null )
watcher . dispose ( ) ; }  var old _ config = config ; if ( config _ loaded & & old _ config ! = null )
config = new xml _ logging _ configuration ( config _ file , this ) ;
internal _ logger . info ( STR , reconfig _ after _ file _ changed _ timeout ) ;
lock ( sync _ root ) { if ( is _ disposing )
if ( reload _ timer = = null ) { var configuration = configuration ;
reconfig _ after _ file _ changed _ timeout ,
name = name ; concrete _ type = concrete _ type ;
return ( concrete _ type = = key . concrete _ type ) & & string . equals ( key . name , name , string _ comparison . ordinal ) ;
factory = factory ;
using layouts ;
layout = layout ;
return format ;
format = value ;
return inner _ format ;
inner _ format = value ;
foreach ( exception _ rendering _ format rendering _ format in formats )
separator = separator ;
while ( current _ exception ! = null & & current _ level < max _ inner _ exception _ level )
sb . append ( inner _ exception _ separator ) ;
foreach ( exception _ rendering _ format rendering _ format in inner _ formats ? ? formats )
separator = separator ;
increment _ usage _ count ( type . base _ type ) ;
increment _ usage _ count ( iface ) ;
increment _ usage _ count ( method . return _ type ) ;
increment _ usage _ count ( p . parameter _ type ) ;
increment _ usage _ count ( type . get _ generic _ type _ definition ( ) ) ;
increment _ usage _ count ( parm ) ;
args . remote _ end _ point = parse _ endpoint _ address ( new uri ( address ) , address _ family ) ; args . completed + = socket _ operation _ completed ;
if ( async _ operation _ in _ progress ) { close _ continuation = continuation ;
close _ socket ( continuation ) ;
if ( ! async _ operation _ in _ progress & & pending _ requests . count = = 0 )
flush _ continuation = continuation ;
var sock = socket ; socket = null ;
async _ operation _ in _ progress = false ;
pending _ error = new io _ exception ( STR + e . socket _ error ) ;
async _ continuation ( pending _ error ) ; } } process _ next _ queued _ item ( ) ;
if ( async _ operation _ in _ progress )
if ( pending _ error ! = null ) { while ( pending _ requests . count ! = 0 ) { args = pending _ requests . dequeue ( ) ;
async _ continuation ( pending _ error ) ; } } if ( pending _ requests . count = = 0 ) { var fc = flush _ continuation ;
flush _ continuation = null ; fc ( pending _ error ) ; } var cc = close _ continuation ;
close _ continuation = null ; close _ socket ( cc ) ;
parse ( reader ) ;
parse ( reader ) ;
foreach ( var ch in children )
string value = get _ optional _ attribute ( attribute _ name , null ) ;
throw new n _ log _ configuration _ exception ( STR + attribute _ name + STR + local _ name + STR ) ;
throw new invalid _ operation _ exception ( STR + string . join ( STR , allowed _ names ) + STR + local _ name + STR ) ;
foreach ( var child _ element in children )
value + = reader . value ;
if ( machine _ name ! = null )
perf _ counter = new performance _ counter ( category , counter , instance , machine _ name ) ;
perf _ counter = new performance _ counter ( category , counter , instance , true ) ;
perf _ counter . close ( ) ; perf _ counter = null ;
name = name ;
stop _ lazy _ writer _ thread ( ) ; if ( monitor . try _ enter ( write _ lock _ object , NUM ) )
monitor . exit ( write _ lock _ object ) ;
lock ( timer _ lock _ object ) { if ( lazy _ writer _ timer ! = null ) { if ( time _ to _ sleep _ between _ batches < = 0 )
internal _ logger . trace ( STR , name ) ; lazy _ writer _ timer . change ( 1 , timeout . infinite ) ;
lazy _ writer _ timer . change ( time _ to _ sleep _ between _ batches , timeout . infinite ) ;
lock _ taken = monitor . try _ enter ( write _ lock _ object ) ;
lock ( timer _ lock _ object )
if ( lazy _ writer _ timer ! = null )
monitor . exit ( write _ lock _ object ) ;
lock ( timer _ lock _ object ) { var current _ timer = lazy _ writer _ timer ;
lazy _ writer _ timer = null ;
write ( log _ event ) ;
if ( lazy _ writer _ timer = = null )
lock ( write _ lock _ object ) { int count = write _ events _ in _ queue ( batch _ size , STR ) ; if ( count = = batch _ size )
if ( wrote _ full _ batch _ size & & time _ to _ sleep _ between _ batches < = 0 ) start _ instant _ writer _ timer ( ) ;
internal _ logger . error ( exception , STR , name ) ;
if ( time _ to _ sleep _ between _ batches < = 0 )
if ( ! wrote _ full _ batch _ size & & request _ queue . request _ count > 0 ) start _ lazy _ writer _ timer ( ) ;
start _ lazy _ writer _ timer ( ) ;
lock ( write _ lock _ object )
if ( time _ to _ sleep _ between _ batches < = 0 & & request _ queue . request _ count > 0 ) start _ lazy _ writer _ timer ( ) ;
internal _ logger . error ( exception , STR , name ) ;
if ( wrapped _ target = = null ) { internal _ logger . error ( STR , name ) ;
internal _ logger . trace ( STR , name , log _ events . length , reason ) ; wrapped _ target . write _ async _ log _ events ( log _ events ) ;
internal _ logger . trace ( STR , name , log _ events . count , reason ) ; wrapped _ target . write _ async _ log _ events ( log _ events ) ;
assert _ layout _ renderer _ output ( $ STR , path . combine ( sys _ dir , STR ) ) ;
assert _ layout _ renderer _ output ( $ STR , path . combine ( sys _ dir , STR ) ) ;
assert _ layout _ renderer _ output ( $ STR , path . combine ( sys _ dir , STR , STR ) ) ;
property = garbage _ collector _ property . total _ memory ;
switch ( property )
using config ;
if ( short _ name )
using config ;
if ( universal _ time )
happy _ path _ test ( false , line _ ending _ mode . crlf , STR , STR , STR ) ;
happy _ path _ test ( true , line _ ending _ mode . crlf , STR , STR , STR ) ;
happy _ path _ test ( true , line _ ending _ mode . lf , STR , STR , STR ) ;
memory _ stream = new memory _ stream ( ) ;
log . write _ line ( STR , id , address ) ;
log . write _ line ( STR , id ) ;
using config ;
culture = culture _ info . invariant _ culture ; lowercase = true ;
if ( lowercase )
culture _ info culture = culture ;
name = name ;
wrapped _ target = wrapped _ target ; retry _ count = retry _ count ; retry _ delay _ milliseconds = retry _ delay _ milliseconds ; optimize _ buffer _ reuse = get _ type ( ) = = typeof ( retrying _ target _ wrapper ) ;
lock ( retry _ sync _ object )
if ( ! is _ initialized )
write _ async _ thread _ safe ( log _ events [ i ] ) ;
lock ( retry _ sync _ object )
internal _ logger . warn ( STR , wrapped _ target , ex , retry _ number , retry _ count ) ;
if ( retry _ number > = retry _ count )
for ( int i = 0 ; i < retry _ delay _ milliseconds ; )
int retry _ delay = math . min ( NUM , retry _ delay _ milliseconds - i ) ;
literal _ value = literal _ value ;
if ( literal _ value = = null )
return convert . to _ string ( literal _ value , culture _ info . invariant _ culture ) ;
return literal _ value ;
format = STR ;
if ( generated _ from _ log _ event )
builder . append ( guid . new _ guid ( ) . to _ string ( format ) ) ;
thread _ agnostic = false ;
thread _ agnostic = false ;
if ( include _ mdc )
if ( include _ mdlc )
if ( include _ all _ properties & & log _ event . has _ properties )
if ( ! suppress _ spaces )
if ( ! suppress _ spaces )
public debug _ target get _ debug _ target ( string target _ name )
protected debug _ target get _ debug _ target ( string target _ name , logging _ configuration configuration ) { var debug _ target = ( debug _ target ) configuration . find _ target _ by _ name ( target _ name ) ;
lock ( writer ) { writer . write ( value ) ;
lock ( writer ) { writer . write _ line ( value ) ;
lock ( writer ) { return writer . to _ string ( ) ;
old _ console _ output _ writer = console . out ; old _ console _ error _ writer = console . error ;
global _ threshold = log _ manager . global _ threshold ; throw _ exceptions = log _ manager . throw _ exceptions ; throw _ config _ exceptions = log _ manager . throw _ config _ exceptions ;
using common ;
async _ continuation = async _ continuation ; timeout _ timer = new timer ( timer _ elapsed , null , timeout , time _ span . from _ milliseconds ( - 1 ) ) ;
stop _ timer ( ) ; var cont = interlocked . exchange ( ref async _ continuation , null ) ;
stop _ timer ( ) ;
var current _ timer = timeout _ timer ;
timeout _ timer = null ;
function ( new timeout _ exception ( STR ) ) ;
expression = expression ;
return STR + expression + STR ;
using common ;
accepts _ log _ event = true ;
int actual _ parameter _ count = method _ parameters . count ; if ( accepts _ log _ event )
late _ bound _ method = internal . reflection _ helpers . create _ late _ bound _ method ( method _ info ) ;
late _ bound _ method _ default _ parameters = new object [ formal _ parameters . length - method _ parameters . count ] ;
late _ bound _ method _ default _ parameters = null ;
sb . append ( condition _ method _ name ) ;
if ( accepts _ log _ event )
if ( late _ bound _ method _ default _ parameters ! = null )
return late _ bound _ method ( null , call _ parameters ) ;
using config ; using layouts ;
layout = STR ;
parse _ compound _ target ( compound , child _ element , type _ name _ to _ default _ target _ parameters , null ) )
parse _ target _ wrapper ( wrapper , child _ element , type _ name _ to _ default _ target _ parameters ) )
logger . error ( ex , STR ) ;
logger . log ( log _ level . error , ex , STR ) ;
logger . trace ( ex , STR ) ;
logger . debug ( ex , STR ) ;
logger . info ( ex , STR ) ;
logger . warn ( ex , STR ) ;
logger . error ( ex , STR ) ;
logger . fatal ( ex , STR ) ;
hash _ set < string > class _ names = new hash _ set < string > ( ) ;
throw new not _ supported _ exception ( STR ) ;
throw new not _ supported _ exception ( STR ) ;
this . close ( ) ;
return STR + this . layout + STR ;
internal string add _ cached _ layout _ value ( layout layout , string value )
builder . append ( context . request . query _ string [ query _ string ] ) ;
builder . append ( context . request . form [ form ] ) ;
message _ queue _ proxy . create ( queue ) ; } else { return ;
nlog _ event . message _ ordinal = get _ string _ ordinal ( context , string _ table , event _ info . formatted _ message ) ;
nlog _ event . logger _ ordinal = get _ string _ ordinal ( context , string _ table , event _ info . logger _ name ) ;
int string _ index = get _ string _ ordinal ( context , string _ table , value ) ;
if ( is _ target _ element ( name ) )
if ( is _ target _ element ( name ) )
http _ web _ request request = ( http _ web _ request ) web _ request . create ( this . url ) ;
builder . append ( get _ item ( request . get _ query _ string ( ) , this . query _ string ) ) ;
builder . append ( get _ item ( request . get _ form ( ) , this . form ) ) ;
builder . append ( get _ item ( request . get _ server _ variables ( ) , this . server _ variable ) ) ;
new _ value = null ; return false ;
return sb . to _ string ( ) ; }
internal _ logging _ config _ test ( log _ level . trace , true , true , log _ level . warn , true , true , STR , true ) ;
{ internal _ logging _ config _ test ( log _ level . error , false , false , log _ level . info , false , false , STR , false ) ;
return ( t argument , async _ continuation cont ) = >
var changed = configuration _ changed ;
layout . initialize ( logging _ configuration ) ;
builder . append ( cached _ time . value ) ; return ;
this . status _ strip . location = new system . drawing . point ( 0 , 0 ) ;
assert . equal ( 0 , log _ level . fatal . compare _ to ( level _ max ) ) ; assert . equal ( 1 , log _ level . off . compare _ to ( level _ max ) ) ;
assert . equal ( STR , msg . body ) ;
assert . equal ( STR , t . name ) ;
assert . equal ( STR , t . name ) ;
assert . equal ( STR , t . name ) ;
assert . equal ( STR , t . name ) ;
mq . send ( message ) ;
write _ to _ targets ( log _ level . trace , format _ provider , value ) ;
write _ to _ targets ( log _ level . debug , format _ provider , value ) ;
write _ to _ targets ( log _ level . info , format _ provider , value ) ;
write _ to _ targets ( log _ level . warn , format _ provider , value ) ;
write _ to _ targets ( log _ level . error , format _ provider , value ) ;
write _ to _ targets ( log _ level . fatal , format _ provider , value ) ;
return declaring _ type ! = null & & logger _ type . is _ assignable _ from ( declaring _ type ) ;
this . on _ change ( source , e ) ;
name = name ;
if ( condition = = null | | condition . evaluate ( log _ event . log _ event ) . equals ( true ) )
dir = path . get _ directory _ name ( dir ) ;
<DEL>
<DEL>
<DEL>
<DEL>
<DEL>
<DEL>
<DEL>
<DEL>
<DEL>
<DEL>
get { return stack _ trace ! = null ; }
public i _ dictionary context
async _ log _ event _ info [ ] log _ events _ array = optimize _ buffer _ reuse ? null : log _ events as async _ log _ event _ info [ ] ; if ( ! optimize _ buffer _ reuse & & log _ events _ array ! = null ) {
sb . append ( ex . stack _ trace ) ;
int expected _ growing _ number = NUM ;
get { return counter _ type ; } set { counter _ type = value ; }
this . skip _ whitespace ( ) ;
using internal ; using time ;
builder . append ( level ) ;
builder . append ( ex ) ; } var msg = builder . to _ string ( ) ;
filter _ info . refresh ( log _ event . level , log _ event . time _ stamp , filter _ info . filter _ count + 1 ) ; return action ;
return ( log _ event _ time - last _ filter _ time ) . total _ seconds > timeout _ seconds & & has _ expired ( log _ event _ time , timeout _ seconds * 2 ) ;
private date _ time last _ log _ time { get ; set ; } private date _ time last _ filter _ time { get ; set ; }
internal class object _ graph _ scanner
new _ renderer . inner = new simple _ layout ( new [ ] { lr } , string . empty ) ;
return - 1 ;
return - 1 ;
default _ value
default _ value _ true
default _ value _ true
default _ value _ true
default _ value _ false
default _ value
default _ value _ auto
public layout layout
default _ value _ true
default _ value
default _ value
default _ value _ false
default _ value _ false
default _ value _ false
default _ value _ true
default _ value _ true
default _ value
public encoding encoding { get { return encoding ; } set { encoding = value ; }
default _ value _ true
default _ value _ false
default _ value
public layout archive _ file _ name { get { return auto _ archive _ file _ name ; } set { auto _ archive _ file _ name = value ; }
default _ value
default _ value
public encoding encoding
get { return encoding ; } set { encoding = value ; }
default _ value _ true
default _ value _ true
default _ value _ false
default _ value _ false
default _ value _ false
default _ value _ empty
default _ value _ false
default _ value _ flat
default _ value
default _ value
default _ value _ false
default _ value _ false
default _ value _ false
private layout label = STR ;
public layout queue { get { return queue ; } set { queue = value ; }
public layout label { get { return label ; } set { label = value ; }
default _ value _ false
public encoding encoding { get { return encoding ; } set { encoding = value ; }
default _ value _ false
default _ value _ false
default _ value _ true
layout = layout ;
public layout layout
default _ value
default _ value
public layout layout
default _ value _ false
default _ value _ true
default _ value _ true
default _ value _ true
default _ value _ false
default _ value _ true
default _ value
public layout event _ id { get { return event _ id ; } set { event _ id = value ; }
public layout category { get { return category ; } set { category = value ; }
public layout layout
assert _ layout _ renderer _ output ( STR , base _ dir ) ;
assert _ layout _ renderer _ output ( STR , path . combine ( base _ dir , STR ) ) ;
assert _ layout _ renderer _ output ( STR , path . combine ( base _ dir , STR ) ) ;
default _ value
default _ value
default _ value _ discard
default _ value
default _ value _ false
default _ value
default _ value
layout l = STR ;
get { return caption ; } set { caption = value ; }
layout l = STR ;
public layout layout
default _ value
default _ value
default _ value
default _ value _ no _ change
default _ value _ no _ change
private layout db _ host _ layout = STR ;
default _ value _ sqlserver
public layout connection _ string { get { return connection _ string ; } set { connection _ string = value ; }
default _ value _ true
default _ value _ false
set { db _ host _ layout = value ; }
set { db _ user _ name _ layout = value ; }
set { db _ password _ layout = value ; }
set { db _ database _ layout = value ; }
default _ value _ false
default _ value _ false
default _ value _ false
default _ value _ no _ change
default _ value _ no _ change
assert _ layout _ renderer _ output ( STR , system . environment . get _ environment _ variable ( STR ) ) ;
assert _ layout _ renderer _ output ( STR , system . environment . get _ environment _ variable ( STR ) ) ;
default _ value _ false
private layout subject = STR ;
public layout from { get { return from ; } set { from = value ; }
public layout to { get { return to ; } set { to = value ; }
public layout cc { get { return cc ; } set { cc = value ; }
public layout bcc { get { return bcc ; } set { bcc = value ; }
default _ value _ message _ from _ n _ log _ on _ machinename public layout subject { get { return subject ; } set { subject = value ; }
default _ value _ false
default _ value _ none
default _ value
default _ value _ false
public layout layout
default _ value _ true
default _ value
default _ value _ true
default _ value _ false
address _ layout = value ;
default _ value _ true
default _ value _ false
default _ value _ false
get { return exists ; } set { exists = value ; }
public condition _ expression filter
default _ value
default _ value
default _ value
default _ value _ false
return s ;
default _ value _ longdate _ level _ uppercase _ true _ logger _ message public virtual layout layout
default _ value _ empty
break ; }
throw new template _ parser _ exception ( STR , position , template ) ;
this . logs . add ( msg ) ;
if ( this . sender ! = null ) { this . sender . close ( ) ;
foreach ( log _ event ev in filtered _ events )
this . parse _ top _ level ( content , file _ name ) ;
throw new n _ log _ runtime _ exception ( required _ property _ is _ empty _ format , STR ) ;
throw new n _ log _ runtime _ exception ( required _ property _ is _ empty _ format , STR ) ;
current _ timer . wait _ for _ dispose ( time _ span . zero ) ;
public class trace _ appender : appender
public class memory _ appender : appender
public class console _ appender : appender
public class asp _ net _ trace _ appender : appender
namespace n _ log _ layout _ appenders
public class null _ appender : appender
return new property _ value ( owner , fast _ lookup [ index ] ) ;
return new property _ value ( owner , properties [ index ] ) ;
system . threading . monitor . pulse _ all ( this . open _ network _ senders ) ;
this . targets [ name ] = target ;
this . targets . remove ( name ) ;
if ( ! this . targets . try _ get _ value ( name , out value ) )
return cache . try _ get _ value ( property _ name , out result ) ;
ret _ val [ attributes [ 0 ] . element _ name ] = prop _ info ;
return filter _ result . neutral ;
data _ targets . add ( this . append _ message ) ;
data _ targets . add ( this . append _ stack _ trace ) ;
data _ targets . add ( this . append _ method ) ;
return filter _ result . neutral ;
return filter _ result . neutral ;
var fi = new file _ info ( file _ path ) ;
var fi = new file _ info ( file _ name ) ;
writer . write _ attribute _ string ( prefix , local _ name , ns , remove _ invalid _ xml _ chars ( value ) ) ;
writer . write _ attribute _ string ( local _ name , remove _ invalid _ xml _ chars ( value ) ) ;
writer . write _ element _ string ( prefix , local _ name , ns , remove _ invalid _ xml _ chars ( value ) ) ;
return cached _ date _ formatted . formatted _ date ;
builder . append ( value . to _ string ( ) ) ;